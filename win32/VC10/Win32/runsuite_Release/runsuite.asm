; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\runsuite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_snprintf
PUBLIC	_main
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@ ; `string'
PUBLIC	??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@ ; `string'
PUBLIC	??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_09DGPCOFBK@TestSuite@			; `string'
PUBLIC	??_C@_02FHFEMMFE@ts@				; `string'
PUBLIC	??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@ ; `string'
PUBLIC	??_C@_05HHOAKHHD@xlink@				; `string'
PUBLIC	??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@	; `string'
PUBLIC	??_C@_03MCCMDFBL@?4?1?$CK@			; `string'
PUBLIC	??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@ ; `string'
PUBLIC	??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@	; `string'
PUBLIC	??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@ ; `string'
PUBLIC	??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@ ; `string'
PUBLIC	??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@	; `string'
PUBLIC	??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@	; `string'
PUBLIC	??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@		; `string'
PUBLIC	??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@		; `string'
PUBLIC	??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@ ; `string'
PUBLIC	??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@ ; `string'
PUBLIC	??_C@_03DIJGCOJI@dtd@				; `string'
PUBLIC	??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@ ; `string'
PUBLIC	??_C@_04CEJDCDCH@test@				; `string'
PUBLIC	??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@ ; `string'
PUBLIC	??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@ ; `string'
PUBLIC	??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@ ; `string'
PUBLIC	??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@ ; `string'
PUBLIC	??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@ ; `string'
PUBLIC	??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@ ; `string'
PUBLIC	??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@	; `string'
PUBLIC	??_C@_09IBKNLDJC@Suite?5?$CFs?6@		; `string'
PUBLIC	??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@	; `string'
PUBLIC	??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@ ; `string'
PUBLIC	??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@ ; `string'
PUBLIC	??_C@_09HJKPOGMK@testSuite@			; `string'
PUBLIC	??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@	; `string'
PUBLIC	??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@	; `string'
PUBLIC	??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@	; `string'
PUBLIC	??_C@_0M@DACABIB@Section?5?$CFs?6@		; `string'
PUBLIC	??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@ ; `string'
PUBLIC	??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@ ; `string'
PUBLIC	??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@ ; `string'
PUBLIC	??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@ ; `string'
PUBLIC	??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@ ; `string'
PUBLIC	??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@ ; `string'
PUBLIC	??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@ ; `string'
PUBLIC	??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@ ; `string'
PUBLIC	??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@ ; `string'
PUBLIC	??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@ ; `string'
PUBLIC	??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@ ; `string'
PUBLIC	??_C@_05HDPIMK@valid@				; `string'
PUBLIC	??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@ ; `string'
PUBLIC	??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@ ; `string'
PUBLIC	??_C@_07MALOAKCI@invalid@			; `string'
PUBLIC	??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@ ; `string'
PUBLIC	??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@ ; `string'
PUBLIC	??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@ ; `string'
PUBLIC	??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@ ; `string'
PUBLIC	??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@ ; `string'
PUBLIC	??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@ ; `string'
PUBLIC	??_C@_0N@MBLKFBIB@nimplemented@			; `string'
PUBLIC	??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@ ; `string'
PUBLIC	??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@ ; `string'
PUBLIC	??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@ ; `string'
PUBLIC	??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@ ; `string'
PUBLIC	??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@ ; `string'
PUBLIC	??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@ ; `string'
PUBLIC	??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@ ; `string'
PUBLIC	??_C@_07DGFKPAKL@testSet@			; `string'
PUBLIC	??_C@_0M@EECBLNBL@contributor@			; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@ ; `string'
PUBLIC	??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@	; `string'
PUBLIC	??_C@_09EANEKJKI@testGroup@			; `string'
PUBLIC	??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@ ; `string'
PUBLIC	??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@ ; `string'
PUBLIC	??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@ ; `string'
PUBLIC	??_C@_0BP@FKMNNKLE@Execution?5start?5time?5?$CFs?5?$CI?$CFs?$CJ?6?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0N@NKKOPKIL@runsuite?4log@		; `string'
PUBLIC	??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@ ; `string'
PUBLIC	??_C@_02EJEOCNCO@?9v@				; `string'
PUBLIC	??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@ ; `string'
PUBLIC	??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@ ; `string'
PUBLIC	??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@	; `string'
PUBLIC	??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@ ; `string'
PUBLIC	??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@ ; `string'
PUBLIC	??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0M@OKJBACOM@xstc?1Tests?1@		; `string'
PUBLIC	??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@ ; `string'
PUBLIC	??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@ ; `string'
PUBLIC	??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@ ; `string'
PUBLIC	??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__FormatNowLocalA@8:PROC
EXTRN	__imp__FormatNowUTCA@8:PROC
EXTRN	__imp__ShowProgramInfoA@0:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	_xmlBufferEmpty:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlNodeDump:PROC
EXTRN	_xmlSetGenericErrorFunc:PROC
EXTRN	_xmlResetLastError:PROC
EXTRN	_xmlMemSetup:PROC
EXTRN	_xmlMemUsed:PROC
EXTRN	_xmlMemoryDump:PROC
EXTRN	_xmlMemMalloc:PROC
EXTRN	_xmlMemRealloc:PROC
EXTRN	_xmlMemFree:PROC
EXTRN	_xmlMemoryStrdup:PROC
EXTRN	___xmlGetWarningsDefaultValue:PROC
EXTRN	_xmlNoNetExternalEntityLoader:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_xmlCleanupParser:PROC
EXTRN	_xmlPedanticParserDefault:PROC
EXTRN	_xmlSetExternalEntityLoader:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	_xmlReadMemory:PROC
EXTRN	_xmlNewStringInputStream:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlRelaxNGInitTypes:PROC
EXTRN	_xmlRelaxNGNewMemParserCtxt:PROC
EXTRN	_xmlRelaxNGFreeParserCtxt:PROC
EXTRN	_xmlRelaxNGSetParserErrors:PROC
EXTRN	_xmlRelaxNGParse:PROC
EXTRN	_xmlRelaxNGFree:PROC
EXTRN	_xmlRelaxNGSetValidErrors:PROC
EXTRN	_xmlRelaxNGNewValidCtxt:PROC
EXTRN	_xmlRelaxNGFreeValidCtxt:PROC
EXTRN	_xmlRelaxNGValidateDoc:PROC
EXTRN	_xmlSchemaNewParserCtxt:PROC
EXTRN	_xmlSchemaFreeParserCtxt:PROC
EXTRN	_xmlSchemaSetParserErrors:PROC
EXTRN	_xmlSchemaParse:PROC
EXTRN	_xmlSchemaFree:PROC
EXTRN	_xmlSchemaSetValidErrors:PROC
EXTRN	_xmlSchemaNewValidCtxt:PROC
EXTRN	_xmlSchemaFreeValidCtxt:PROC
EXTRN	_xmlSchemaValidateDoc:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPathContextSetCache:PROC
EXTRN	_xmlXPathCompile:PROC
EXTRN	_xmlXPathCompiledEval:PROC
EXTRN	_xmlXPathFreeCompExpr:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlSchemaInitTypes:PROC
EXTRN	__imp__xmlFree:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_logfile DD	01H DUP (?)
_verbose DD	01H DUP (?)
_nb_tests DD	01H DUP (?)
_nb_errors DD	01H DUP (?)
_nb_internals DD 01H DUP (?)
_nb_schematas DD 01H DUP (?)
_nb_unimplemented DD 01H DUP (?)
_nb_leaks DD	01H DUP (?)
_extraMemoryFromResolver DD 01H DUP (?)
_testEntitiesName DD 014H DUP (?)
_testEntitiesValue DD 014H DUP (?)
_nb_entities DD	01H DUP (?)
_testErrors DB	08001H DUP (?)
	ALIGN	4

_testErrorsSize DD 01H DUP (?)
_ctxtXPath DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@
CONST	SEGMENT
??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@ DB 'T'
	DB	'otal %d tests, %d errors, %d leaks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@
CONST	SEGMENT
??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@ DB 'Total %d test'
	DB	's, no errors', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@
CONST	SEGMENT
??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@ DB 'xstc/Tests/Met'
	DB	'adata/MSXMLSchema1-0-20020116.testSet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@
CONST	SEGMENT
??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@ DB 'xstc/Tests/Met'
	DB	'adata/SunXMLSchema1-0-20020116.testSet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKJBACOM@xstc?1Tests?1@
CONST	SEGMENT
??_C@_0M@OKJBACOM@xstc?1Tests?1@ DB 'xstc/Tests/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
CONST	SEGMENT
??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@ DB 'R'
	DB	'an %d tests (%d schemata), %d errors (%d internals), %d leaks'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
CONST	SEGMENT
??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@ DB 'R'
	DB	'an %d tests (%d schemata), no errors', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@
CONST	SEGMENT
??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@ DB 'xstc/Tests/Met'
	DB	'adata/NISTXMLSchemaDatatypes.testSet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@
CONST	SEGMENT
??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@ DB 'xstc/Tests/Metadata/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
CONST	SEGMENT
??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@ DB 'R'
	DB	'an %d tests, %d errors, %d leaks', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
CONST	SEGMENT
??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@ DB 'Ran %d tests, n'
	DB	'o errors', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02EJEOCNCO@?9v@
CONST	SEGMENT
??_C@_02EJEOCNCO@?9v@ DB '-v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@
CONST	SEGMENT
??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@ DB 'Could not '
	DB	'open the log file, running in verbose mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKKOPKIL@runsuite?4log@
CONST	SEGMENT
??_C@_0N@NKKOPKIL@runsuite?4log@ DB 'runsuite.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FKMNNKLE@Execution?5start?5time?5?$CFs?5?$CI?$CFs?$CJ?6?6@
CONST	SEGMENT
??_C@_0BP@FKMNNKLE@Execution?5start?5time?5?$CFs?5?$CI?$CFs?$CJ?6?6@ DB 'E'
	DB	'xecution start time %s (%s)', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@
CONST	SEGMENT
??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@ DB '%Y/'
	DB	'%m/%d %H:%M:%S UTC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@
CONST	SEGMENT
??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@ DB '%'
	DB	'Y/%m/%d %H:%M:%S %Z', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@
CONST	SEGMENT
??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@ DB 'following-sib'
	DB	'ling::ts:testGroup[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EANEKJKI@testGroup@
CONST	SEGMENT
??_C@_09EANEKJKI@testGroup@ DB 'testGroup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@
CONST	SEGMENT
??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@ DB './ts:testGroup[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@
CONST	SEGMENT
??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@ DB '##'
	DB	' %s test suite for Schemas version %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EECBLNBL@contributor@
CONST	SEGMENT
??_C@_0M@EECBLNBL@contributor@ DB 'contributor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DGFKPAKL@testSet@
CONST	SEGMENT
??_C@_07DGFKPAKL@testSet@ DB 'testSet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@
CONST	SEGMENT
??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@ DB 'Proces'
	DB	'sing test line %ld %s leaked %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@
CONST	SEGMENT
??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@ DB 'testGroup '
	DB	'line %ld misses unexpected validity value%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@
CONST	SEGMENT
??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@ DB 'invalid s'
	DB	'chemas %s hit an unimplemented block', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@
CONST	SEGMENT
??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@ DB 'Failed to de'
	DB	'tect error in schemas %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@
CONST	SEGMENT
??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@ DB 'following-sib'
	DB	'ling::ts:instanceTest[1]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@
CONST	SEGMENT
??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@ DB './ts:instanceTest[1'
	DB	']', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@
CONST	SEGMENT
??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@ DB 'valid sch'
	DB	'emas %s hit an unimplemented block', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MBLKFBIB@nimplemented@
CONST	SEGMENT
??_C@_0N@MBLKFBIB@nimplemented@ DB 'nimplemented', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@
CONST	SEGMENT
??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@ DB 'valid sch'
	DB	'emas %s failed to parse', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@
CONST	SEGMENT
??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@ DB 'testGroup '
	DB	'line %ld misses expected validity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@
CONST	SEGMENT
??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@ DB 'string(ts:s'
	DB	'chemaTest/ts:expected/@validity)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@
CONST	SEGMENT
??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@ DB 'string(ts:s'
	DB	'chemaTest/ts:schemaDocument/@xlink:href)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@
CONST	SEGMENT
??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@ DB 'instanceDo'
	DB	'cument line %ld has unexpected validity value%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@
CONST	SEGMENT
??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@ DB 'Failed to det'
	DB	'ect invalid instance %s against %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MALOAKCI@invalid@
CONST	SEGMENT
??_C@_07MALOAKCI@invalid@ DB 'invalid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@
CONST	SEGMENT
??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@ DB 'valid ins'
	DB	'tance %s got internal error validating %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@
CONST	SEGMENT
??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@ DB 'valid ins'
	DB	'tance %s failed to validate against %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDPIMK@valid@
CONST	SEGMENT
??_C@_05HDPIMK@valid@ DB 'valid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@
CONST	SEGMENT
??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@ DB 'instance %s f'
	DB	'ails to parse', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@
CONST	SEGMENT
??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@ DB 'instanceDoc'
	DB	'ument line %ld misses expected validity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@
CONST	SEGMENT
??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@ DB 'string(t'
	DB	's:expected/@validity)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@
CONST	SEGMENT
??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@ DB 'schemas f'
	DB	'or testGroup line %ld is missing: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
CONST	SEGMENT
??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@ DB 'Failed to bu'
	DB	'ild path to schemas testGroup line %ld : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
CONST	SEGMENT
??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@ DB 'testGroup'
	DB	' line %ld misses href for schemaDocument', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@
CONST	SEGMENT
??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@ DB 'string(ts'
	DB	':instanceDocument/@xlink:href)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@
CONST	SEGMENT
??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@ DB '## Re'
	DB	'lax NG test suite for libxml2', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
CONST	SEGMENT
??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@ DB 'test/relaxng/testsu'
	DB	'ite.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@
CONST	SEGMENT
??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@ DB '## Re'
	DB	'lax NG test suite from James Clark', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@
CONST	SEGMENT
??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@ DB 'test/relaxng/'
	DB	'OASIS/spectest.xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DACABIB@Section?5?$CFs?6@
CONST	SEGMENT
??_C@_0M@DACABIB@Section?5?$CFs?6@ DB 'Section %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@
CONST	SEGMENT
??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@ DB 'string(section)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
CONST	SEGMENT
??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@ DB 'followin'
	DB	'g-sibling::testSuite[1]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
CONST	SEGMENT
??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@ DB './testSuite[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@ DB 'Unexpected format %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJKPOGMK@testSuite@
CONST	SEGMENT
??_C@_09HJKPOGMK@testSuite@ DB 'testSuite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@
CONST	SEGMENT
??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@ DB '## XML'
	DB	' Schemas datatypes test suite from James Clark', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@ DB 'Failed to parse %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
CONST	SEGMENT
??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@ DB 'test/xsdtest/xsd'
	DB	'testsuite.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@
CONST	SEGMENT
??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@ DB 'following'
	DB	'-sibling::testCase[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@
CONST	SEGMENT
??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@ DB './testCase[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBKNLDJC@Suite?5?$CFs?6@
CONST	SEGMENT
??_C@_09IBKNLDJC@Suite?5?$CFs?6@ DB 'Suite %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
CONST	SEGMENT
??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@ DB 'string(documentation)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@
CONST	SEGMENT
??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@ DB 'Failed to dete'
	DB	'ct invalid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@
CONST	SEGMENT
??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@ DB 'Failed to'
	DB	' find test in <invalid> line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
CONST	SEGMENT
??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@ DB 'following-'
	DB	'sibling::invalid[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
CONST	SEGMENT
??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@ DB 'Validation'
	DB	' of instance line %ld leaked %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
CONST	SEGMENT
??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@ DB 'Internal error'
	DB	' validating instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@
CONST	SEGMENT
??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@ DB 'Failed to val'
	DB	'idate valid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
CONST	SEGMENT
??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@ DB 'Failed to pa'
	DB	'rse valid instance line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CEJDCDCH@test@
CONST	SEGMENT
??_C@_04CEJDCDCH@test@ DB 'test', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@
CONST	SEGMENT
??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@ DB 'Faile'
	DB	'd to find test in <valid> line %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DIJGCOJI@dtd@
CONST	SEGMENT
??_C@_03DIJGCOJI@dtd@ DB 'dtd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
CONST	SEGMENT
??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@ DB 'following-si'
	DB	'bling::valid[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@
CONST	SEGMENT
??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@ DB 'Failed to'
	DB	' parse RNGtest line %ld', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@
CONST	SEGMENT
??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@ DB './correct[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@
CONST	SEGMENT
??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@ DB 'following-sibl'
	DB	'ing::dir[1]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
CONST	SEGMENT
??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@ DB './dir[1]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
CONST	SEGMENT
??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@ DB './resource[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@
CONST	SEGMENT
??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@ DB 'following'
	DB	'-sibling::resource[1]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
CONST	SEGMENT
??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@ DB 'string(@name)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
CONST	SEGMENT
??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@ DB 'Validation of'
	DB	' tests starting line %ld leaked %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@
CONST	SEGMENT
??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@ DB 'Failed to de'
	DB	'tect incorect RNG line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
CONST	SEGMENT
??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@ DB 'out of memory !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
CONST	SEGMENT
??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@ DB 'Failed to f'
	DB	'ind test in correct line %ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCCMDFBL@?4?1?$CK@
CONST	SEGMENT
??_C@_03MCCMDFBL@?4?1?$CK@ DB './*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@
CONST	SEGMENT
??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@ DB './incorrect[1]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@ DB 'Failed to compile %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHOAKHHD@xlink@
CONST	SEGMENT
??_C@_05HHOAKHHD@xlink@ DB 'xlink', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@
CONST	SEGMENT
??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@ DB 'http://www.w3.'
	DB	'org/1999/xlink', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FHFEMMFE@ts@
CONST	SEGMENT
??_C@_02FHFEMMFE@ts@ DB 'ts', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGPCOFBK@TestSuite@
CONST	SEGMENT
??_C@_09DGPCOFBK@TestSuite@ DB 'TestSuite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@
CONST	SEGMENT
??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@ DB 0aH, '------------', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@
CONST	SEGMENT
??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@ DB 'Too many entities '
	DB	'defined', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@
CONST	SEGMENT
??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@ DB 'Exitting test'
	DB	's on fatal error', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _main
_TEXT	SEGMENT
_old_tests$3$ = -12					; size = 4
_old_errors$2$ = -12					; size = 4
_old_errors$1$ = -12					; size = 4
_old_tests$1$ = -8					; size = 4
_old_errors$3$ = -8					; size = 4
_old_leaks$3$ = -4					; size = 4
_old_leaks$1$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 1080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 1081 : 	int ret = 0;
; 1082 : 	int old_errors , old_tests , old_leaks;
; 1083 : 
; 1084 : 	char *	lpszProgramName = ShowProgramInfo( );

	call	DWORD PTR __imp__ShowProgramInfoA@0

; 1085 : 
; 1086 : 	char *  lpFormattedStartTimeLocal = FormatNowLocal( STRFTIME_DEFAULT_LOCAL_FORMAT ,

	push	0
	push	OFFSET ??_C@_0BF@CDOBHHMA@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5?$CFZ@
	call	DWORD PTR __imp__FormatNowLocalA@8
	mov	esi, eax

; 1087 : 		                                                NULL );
; 1088 : 
; 1089 : 	if ( lpFormattedStartTimeLocal == NULL )

	test	esi, esi
	jne	SHORT $LN2@main
$LN59@main:

; 1242 : }	// int main

	call	DWORD PTR __imp__GetLastError@0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@main:

; 1090 : 		return GetLastError( );
; 1091 : 
; 1092 : 	LPTSTR  lpFormattedStartTimeUTC = FormatNowUTC( STRFTIME_DEFAULT_UTC_FORMAT ,

	push	0
	push	OFFSET ??_C@_0BG@CBLCLCJH@?$CFY?1?$CFm?1?$CFd?5?$CFH?3?$CFM?3?$CFS?5UTC@
	call	DWORD PTR __imp__FormatNowUTCA@8

; 1093 : 		                                             NULL );
; 1094 : 
; 1095 : 	if ( lpFormattedStartTimeUTC == NULL )

	test	eax, eax
	je	SHORT $LN59@main

; 1096 : 		return GetLastError( );
; 1097 : 
; 1098 : 	_tprintf( "Execution start time %s (%s)\n\n" ,

	push	ebx
	push	edi
	push	eax
	push	esi
	push	OFFSET ??_C@_0BP@FKMNNKLE@Execution?5start?5time?5?$CFs?5?$CI?$CFs?$CJ?6?6@
	call	_printf

; 1099 : 		      lpFormattedStartTimeLocal ,
; 1100 : 		      lpFormattedStartTimeUTC );
; 1101 : 
; 1102 : 	logfile = fopen( LOGFILE ,

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0N@NKKOPKIL@runsuite?4log@
	call	DWORD PTR __imp__fopen

; 1103 : 		             "w" );
; 1104 : 	
; 1105 : 	if ( logfile == NULL )

	mov	edi, DWORD PTR __imp____acrt_iob_func
	add	esp, 20					; 00000014H
	mov	DWORD PTR _logfile, eax
	test	eax, eax
	jne	SHORT $LN4@main

; 1106 : 	{
; 1107 : 		fprintf( stderr ,

	push	OFFSET ??_C@_0DG@NLJMPNNG@Could?5not?5open?5the?5log?5file?0?5ru@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 1108 : 			     "Could not open the log file, running in verbose mode\n" );
; 1109 : 		verbose = 1;

	mov	DWORD PTR _verbose, 1
$LN4@main:

; 240  :     xmlGetWarningsDefaultValue = 0;

	call	___xmlGetWarningsDefaultValue

; 241  :     xmlPedanticParserDefault(0);

	push	0
	mov	DWORD PTR [eax], 0
	call	_xmlPedanticParserDefault

; 242  : 
; 243  :     xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);

	push	OFFSET _xmlMemoryStrdup
	push	OFFSET _xmlMemRealloc
	push	OFFSET _xmlMemMalloc
	push	OFFSET _xmlMemFree
	call	_xmlMemSetup

; 244  :     xmlInitParser();

	call	_xmlInitParser

; 245  :     xmlSetExternalEntityLoader(testExternalEntityLoader);

	push	OFFSET _testExternalEntityLoader
	call	_xmlSetExternalEntityLoader

; 246  :     ctxtXPath = xmlXPathNewContext(NULL);

	push	0
	call	_xmlXPathNewContext
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ctxtXPath, eax

; 247  :     /*
; 248  :     * Deactivate the cache if created; otherwise we have to create/free it
; 249  :     * for every test, since it will confuse the memory leak detection.
; 250  :     * Note that normally this need not be done, since the cache is not
; 251  :     * created until set explicitely with xmlXPathContextSetCache();
; 252  :     * but for test purposes it is sometimes usefull to activate the
; 253  :     * cache by default for the whole library.
; 254  :     */
; 255  :     if (ctxtXPath->cache != NULL)

	cmp	DWORD PTR [eax+200], 0
	je	SHORT $LN23@main

; 256  : 	xmlXPathContextSetCache(ctxtXPath, 0, -1, 0);

	push	0
	push	-1
	push	0
	push	eax
	call	_xmlXPathContextSetCache
	mov	eax, DWORD PTR _ctxtXPath
	add	esp, 16					; 00000010H
$LN23@main:

; 257  :     /* used as default nanemspace in xstc tests */
; 258  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "ts", BAD_CAST "TestSuite");

	push	OFFSET ??_C@_09DGPCOFBK@TestSuite@
	push	OFFSET ??_C@_02FHFEMMFE@ts@
	push	eax
	call	_xmlXPathRegisterNs

; 259  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "xlink",

	push	OFFSET ??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@
	push	OFFSET ??_C@_05HHOAKHHD@xlink@
	push	DWORD PTR _ctxtXPath
	call	_xmlXPathRegisterNs

; 260  :                        BAD_CAST "http://www.w3.org/1999/xlink");
; 261  :     xmlSetGenericErrorFunc(NULL, testErrorHandler);

	push	OFFSET _testErrorHandler
	push	0
	call	_xmlSetGenericErrorFunc
	add	esp, 32					; 00000020H

; 262  : #ifdef LIBXML_SCHEMAS_ENABLED
; 263  :     xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes

; 264  :     xmlRelaxNGInitTypes();

	call	_xmlRelaxNGInitTypes

; 1110 : 	}	// if ( logfile == NULL )
; 1111 : 
; 1112 : 	initializeLibxml2( );
; 1113 : 
; 1114 : 	if ( ( argc >= 2 ) && ( !strcmp( argv [ 1 ] , "-v" ) ) )

	cmp	DWORD PTR _argc$[ebp], 2
	jl	SHORT $LN5@main
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, OFFSET ??_C@_02EJEOCNCO@?9v@
	mov	eax, DWORD PTR [eax+4]
$LL53@main:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN54@main
	test	dl, dl
	je	SHORT $LN55@main
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN54@main
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL53@main
$LN55@main:
	xor	ecx, ecx
	jmp	SHORT $LN56@main
$LN54@main:
	sbb	ecx, ecx
	or	ecx, 1
$LN56@main:
	mov	eax, DWORD PTR _verbose
	test	ecx, ecx
	mov	edx, 1
	cmove	eax, edx
	mov	DWORD PTR _verbose, eax
$LN5@main:

; 1115 : 		verbose = 1;
; 1116 : 
; 1117 : 	old_errors = nb_errors;

	mov	eax, DWORD PTR _nb_errors

; 1118 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 668  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2

; 1115 : 		verbose = 1;
; 1116 : 
; 1117 : 	old_errors = nb_errors;

	mov	DWORD PTR _old_errors$1$[ebp], eax

; 1119 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks

; 668  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	0
	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@

; 1118 : 	old_tests = nb_tests;

	mov	DWORD PTR _old_tests$1$[ebp], esi

; 1119 : 	old_leaks = nb_leaks;

	mov	DWORD PTR _old_leaks$1$[ebp], eax

; 668  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	call	_xmlReadFile
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 669  :     if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN28@main

; 670  :         fprintf(stderr, "Failed to parse %s\n", filename);

	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 671  : 	return(-1);

	jmp	$LN33@main
$LN28@main:

; 672  :     }
; 673  :     printf("## XML Schemas datatypes test suite from James Clark\n");

	push	OFFSET ??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@
	call	_printf

; 674  : 
; 675  :     cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 8

; 676  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN30@main
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@main

; 677  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 678  : 	ret = -1;
; 679  : 	goto done;
; 680  :     }
; 681  : 
; 682  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 683  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN30@main
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@main
	npad	3
$LL26@main:

; 684  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 685  : 	ret = -1;
; 686  : 	goto done;
; 687  :     }
; 688  :     while (cur != NULL) {
; 689  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite

; 690  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL26@main

; 676  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	jmp	SHORT $done$61
$LN30@main:

; 691  :     }
; 692  : 
; 693  : done:
; 694  :     if (doc != NULL)
; 695  : 	xmlFreeDoc(doc);

	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$done$61:
	push	ebx
	call	_xmlFreeDoc
	mov	esi, DWORD PTR _old_tests$1$[ebp]
	add	esp, 4
$LN33@main:

; 1120 : 	xsdTest( );
; 1121 : 
; 1122 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	mov	edx, DWORD PTR _old_errors$1$[ebp]
	mov	eax, DWORD PTR _nb_leaks
	mov	ebx, DWORD PTR _old_leaks$1$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@main
	cmp	eax, ebx
	jne	SHORT $LN6@main

; 1123 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN7@main
$LN6@main:

; 1124 : 			    nb_tests - old_tests );
; 1125 : 	else
; 1126 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	sub	eax, ebx
	sub	ecx, edx
	push	eax
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN7@main:

; 1127 : 			    nb_tests - old_tests ,
; 1128 : 			    nb_errors - old_errors ,
; 1129 : 			    nb_leaks - old_leaks );
; 1130 : 
; 1131 : 	old_errors = nb_errors;

	mov	eax, DWORD PTR _nb_errors

; 1132 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 1133 : 	old_leaks = nb_leaks;

	mov	ebx, DWORD PTR _nb_leaks
	mov	DWORD PTR _old_errors$2$[ebp], eax

; 1134 : 	rngTest1( );

	call	_rngTest1

; 1135 : 
; 1136 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	mov	edx, DWORD PTR _old_errors$2$[ebp]
	mov	eax, DWORD PTR _nb_leaks
	cmp	ecx, edx
	jne	SHORT $LN8@main
	cmp	eax, ebx
	jne	SHORT $LN8@main

; 1137 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN9@main
$LN8@main:

; 1138 : 			    nb_tests - old_tests );
; 1139 : 	else
; 1140 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	sub	eax, ebx
	sub	ecx, edx
	push	eax
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN9@main:

; 1141 : 			    nb_tests - old_tests ,
; 1142 : 			    nb_errors - old_errors ,
; 1143 : 			    nb_leaks - old_leaks );
; 1144 : 
; 1145 : 	old_errors = nb_errors;

	mov	eax, DWORD PTR _nb_errors

; 1146 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 769  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2

; 1141 : 			    nb_tests - old_tests ,
; 1142 : 			    nb_errors - old_errors ,
; 1143 : 			    nb_leaks - old_leaks );
; 1144 : 
; 1145 : 	old_errors = nb_errors;

	mov	DWORD PTR _old_errors$3$[ebp], eax

; 1147 : 	old_leaks = nb_leaks;

	mov	eax, DWORD PTR _nb_leaks

; 769  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	0
	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@

; 1146 : 	old_tests = nb_tests;

	mov	DWORD PTR _old_tests$3$[ebp], esi

; 1147 : 	old_leaks = nb_leaks;

	mov	DWORD PTR _old_leaks$3$[ebp], eax

; 769  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	call	_xmlReadFile
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 770  :     if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN38@main

; 771  :         fprintf(stderr, "Failed to parse %s\n", filename);

	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 772  : 	return(-1);

	jmp	$LN43@main
$LN38@main:

; 773  :     }
; 774  :     printf("## Relax NG test suite for libxml2\n");

	push	OFFSET ??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@
	call	_printf

; 775  : 
; 776  :     cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 8

; 777  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN40@main
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@main

; 778  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 779  : 	ret = -1;
; 780  : 	goto done;
; 781  :     }
; 782  : 
; 783  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 784  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN40@main
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@main
$LL36@main:

; 785  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 786  : 	ret = -1;
; 787  : 	goto done;
; 788  :     }
; 789  :     while (cur != NULL) {
; 790  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite

; 791  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL36@main

; 676  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	jmp	SHORT $done$62
$LN40@main:

; 796  : 	xmlFreeDoc(doc);

	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	edi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$done$62:
	push	ebx
	call	_xmlFreeDoc
	mov	esi, DWORD PTR _old_tests$3$[ebp]
	add	esp, 4
$LN43@main:

; 1148 : 	rngTest2( );
; 1149 : 
; 1150 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	mov	edx, DWORD PTR _old_errors$3$[ebp]
	mov	eax, DWORD PTR _nb_leaks
	mov	edi, DWORD PTR _old_leaks$3$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN10@main
	cmp	eax, edi
	jne	SHORT $LN10@main

; 1151 : 		printf( "Ran %d tests, no errors\n" ,

	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0BJ@OIFNJJDH@Ran?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8
	jmp	SHORT $LN11@main
$LN10@main:

; 1152 : 			    nb_tests - old_tests );
; 1153 : 	else
; 1154 : 		printf( "Ran %d tests, %d errors, %d leaks\n" ,

	sub	eax, edi
	sub	ecx, edx
	push	eax
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CD@FKBFBNPO@Ran?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5lea@
	call	_printf
	add	esp, 16					; 00000010H
$LN11@main:

; 1155 : 			    nb_tests - old_tests ,
; 1156 : 			    nb_errors - old_errors ,
; 1157 : 			    nb_leaks - old_leaks );
; 1158 : 
; 1159 : 	old_errors = nb_errors;

	mov	ebx, DWORD PTR _nb_errors

; 1160 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 1161 : 	old_leaks = nb_leaks;

	mov	edi, DWORD PTR _nb_leaks

; 1162 : 	nb_internals = 0;
; 1163 : 	nb_schematas = 0;
; 1164 : 	xstcMetadata( "xstc/Tests/Metadata/NISTXMLSchemaDatatypes.testSet" ,

	push	OFFSET ??_C@_0BF@JAEPBNCO@xstc?1Tests?1Metadata?1@
	push	OFFSET ??_C@_0DD@EEANKDMB@xstc?1Tests?1Metadata?1NISTXMLSche@
	mov	DWORD PTR _nb_internals, 0
	mov	DWORD PTR _nb_schematas, 0
	call	_xstcMetadata

; 1165 : 		          "xstc/Tests/Metadata/" );
; 1166 : 
; 1167 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	add	esp, 8
	mov	eax, DWORD PTR _nb_leaks
	cmp	ecx, ebx
	jne	SHORT $LN12@main
	cmp	eax, edi
	jne	SHORT $LN12@main

; 1168 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	push	DWORD PTR _nb_schematas
	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@main
$LN12@main:

; 1169 : 			    nb_tests - old_tests ,
; 1170 : 			    nb_schematas );
; 1171 : 	else
; 1172 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	sub	eax, edi
	sub	ecx, ebx
	push	eax
	push	DWORD PTR _nb_internals
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	push	DWORD PTR _nb_schematas
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN13@main:

; 1173 : 			    nb_tests - old_tests ,
; 1174 : 			    nb_schematas ,
; 1175 : 			    nb_errors - old_errors ,
; 1176 : 			    nb_internals ,
; 1177 : 			    nb_leaks - old_leaks );
; 1178 : 
; 1179 : 	old_errors = nb_errors;

	mov	ebx, DWORD PTR _nb_errors

; 1180 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 1181 : 	old_leaks = nb_leaks;

	mov	edi, DWORD PTR _nb_leaks

; 1182 : 	nb_internals = 0;
; 1183 : 	nb_schematas = 0;
; 1184 : 	xstcMetadata( "xstc/Tests/Metadata/SunXMLSchema1-0-20020116.testSet" ,

	push	OFFSET ??_C@_0M@OKJBACOM@xstc?1Tests?1@
	push	OFFSET ??_C@_0DF@OEALCOMO@xstc?1Tests?1Metadata?1SunXMLSchem@
	mov	DWORD PTR _nb_internals, 0
	mov	DWORD PTR _nb_schematas, 0
	call	_xstcMetadata

; 1185 : 		          "xstc/Tests/" );
; 1186 : 	
; 1187 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	add	esp, 8
	mov	eax, DWORD PTR _nb_leaks
	cmp	ecx, ebx
	jne	SHORT $LN14@main
	cmp	eax, edi
	jne	SHORT $LN14@main

; 1188 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	push	DWORD PTR _nb_schematas
	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@main
$LN14@main:

; 1189 : 			    nb_tests - old_tests ,
; 1190 : 			    nb_schematas );
; 1191 : 	else
; 1192 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	sub	eax, edi
	sub	ecx, ebx
	push	eax
	push	DWORD PTR _nb_internals
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	push	DWORD PTR _nb_schematas
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN15@main:

; 1193 : 			    nb_tests - old_tests ,
; 1194 : 			    nb_schematas ,
; 1195 : 			    nb_errors - old_errors ,
; 1196 : 			    nb_internals ,
; 1197 : 			    nb_leaks - old_leaks );
; 1198 : 
; 1199 : 	old_errors = nb_errors;

	mov	ebx, DWORD PTR _nb_errors

; 1200 : 	old_tests = nb_tests;

	mov	esi, DWORD PTR _nb_tests

; 1201 : 	old_leaks = nb_leaks;

	mov	edi, DWORD PTR _nb_leaks

; 1202 : 	nb_internals = 0;
; 1203 : 	nb_schematas = 0;
; 1204 : 	xstcMetadata( "xstc/Tests/Metadata/MSXMLSchema1-0-20020116.testSet" ,

	push	OFFSET ??_C@_0M@OKJBACOM@xstc?1Tests?1@
	push	OFFSET ??_C@_0DE@CCIMICPD@xstc?1Tests?1Metadata?1MSXMLSchema@
	mov	DWORD PTR _nb_internals, 0
	mov	DWORD PTR _nb_schematas, 0
	call	_xstcMetadata

; 1205 : 		          "xstc/Tests/" );
; 1206 : 
; 1207 : 	if ( ( nb_errors == old_errors ) && ( nb_leaks == old_leaks ) )

	mov	ecx, DWORD PTR _nb_errors
	add	esp, 8
	mov	eax, DWORD PTR _nb_leaks
	cmp	ecx, ebx
	jne	SHORT $LN16@main
	cmp	eax, edi
	jne	SHORT $LN16@main

; 1208 : 		printf( "Ran %d tests (%d schemata), no errors\n" ,

	push	DWORD PTR _nb_schematas
	mov	eax, DWORD PTR _nb_tests
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0CH@EHPPMFBH@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5no?5@
	call	_printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN17@main
$LN16@main:

; 1209 : 			    nb_tests - old_tests ,
; 1210 : 			    nb_schematas );
; 1211 : 	else
; 1212 : 		printf( "Ran %d tests (%d schemata), %d errors (%d internals), %d leaks\n" ,

	sub	eax, edi
	sub	ecx, ebx
	push	eax
	push	DWORD PTR _nb_internals
	mov	eax, DWORD PTR _nb_tests
	push	ecx
	push	DWORD PTR _nb_schematas
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0EA@PNDHDNOB@Ran?5?$CFd?5tests?5?$CI?$CFd?5schemata?$CJ?0?5?$CFd?5@
	call	_printf
	add	esp, 24					; 00000018H
$LN17@main:

; 1213 : 			    nb_tests - old_tests ,
; 1214 : 			    nb_schematas ,
; 1215 : 			    nb_errors - old_errors ,
; 1216 : 			    nb_internals ,
; 1217 : 			    nb_leaks - old_leaks );
; 1218 : 
; 1219 : 	if ( ( nb_errors == 0 ) && ( nb_leaks == 0 ) )

	mov	ecx, DWORD PTR _nb_errors
	mov	eax, DWORD PTR _nb_leaks
	pop	edi
	pop	ebx
	test	ecx, ecx
	jne	SHORT $LN18@main
	test	eax, eax
	jne	SHORT $LN18@main

; 1220 : 	{
; 1221 : 		ret = 0;
; 1222 : 		printf( "Total %d tests, no errors\n" ,

	push	DWORD PTR _nb_tests
	xor	esi, esi
	push	OFFSET ??_C@_0BL@HGPINOJF@Total?5?$CFd?5tests?0?5no?5errors?6@
	call	_printf
	add	esp, 8

; 1223 : 			    nb_tests );
; 1224 : 	}

	jmp	SHORT $LN19@main
$LN18@main:

; 1225 : 	else
; 1226 : 	{
; 1227 : 		ret = 1;
; 1228 : 		printf( "Total %d tests, %d errors, %d leaks\n" ,

	push	eax
	push	ecx
	push	DWORD PTR _nb_tests
	mov	esi, 1
	push	OFFSET ??_C@_0CF@BABBENFF@Total?5?$CFd?5tests?0?5?$CFd?5errors?0?5?$CFd?5l@
	call	_printf
	add	esp, 16					; 00000010H
$LN19@main:

; 1229 : 			    nb_tests ,
; 1230 : 			    nb_errors ,
; 1231 : 			    nb_leaks );
; 1232 : 	}	// if ( ( nb_errors == 0 ) && ( nb_leaks == 0 ) )
; 1233 : 
; 1234 : 	xmlXPathFreeContext( ctxtXPath );

	push	DWORD PTR _ctxtXPath
	call	_xmlXPathFreeContext
	add	esp, 4

; 1235 : 	xmlCleanupParser( );

	call	_xmlCleanupParser

; 1236 : 	xmlMemoryDump( );

	call	_xmlMemoryDump

; 1237 : 
; 1238 : 	if ( logfile != NULL )

	mov	ecx, DWORD PTR _logfile
	test	ecx, ecx
	je	SHORT $LN20@main

; 1239 : 		fclose( logfile );

	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN20@main:

; 1240 : 
; 1241 : 	return( ret );

	mov	eax, esi
	pop	esi

; 1242 : }	// int main

	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcMetadata
_TEXT	SEGMENT
_ret$1$ = -12						; size = 4
_name$1$ = -8						; size = 4
_contributor$1$ = -4					; size = 4
_metadata$ = 8						; size = 4
_base$ = 12						; size = 4
_xstcMetadata PROC					; COMDAT

; 1027 : xstcMetadata(const char *metadata, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi

; 1028 :     xmlDocPtr doc;
; 1029 :     xmlNodePtr cur;
; 1030 :     xmlChar *contributor;
; 1031 :     xmlChar *name;
; 1032 :     int ret = 0;
; 1033 : 
; 1034 :     doc = xmlReadFile(metadata, NULL, XML_PARSE_NOENT);

	mov	edi, DWORD PTR _metadata$[ebp]
	push	2
	push	0
	push	edi
	mov	DWORD PTR _ret$1$[ebp], 0
	call	_xmlReadFile
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 1035 :     if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xstcMetada

; 1036 :         fprintf(stderr, "Failed to parse %s\n", metadata);

	push	edi
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1037 : 	return(-1);

	or	eax, -1
	pop	edi

; 1071 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xstcMetada:
	push	esi

; 1038 :     }
; 1039 : 
; 1040 :     cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 4

; 1041 :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSet"))) {

	test	esi, esi
	je	$LN6@xstcMetada
	push	OFFSET ??_C@_07DGFKPAKL@testSet@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xstcMetada

; 1044 :     }
; 1045 :     contributor = xmlGetProp(cur, BAD_CAST "contributor");

	push	OFFSET ??_C@_0M@EECBLNBL@contributor@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _contributor$1$[ebp], eax

; 1046 :     if (contributor == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xstcMetada

; 1047 :         contributor = xmlStrdup(BAD_CAST "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _contributor$1$[ebp], eax
$LN7@xstcMetada:

; 1048 :     }
; 1049 :     name = xmlGetProp(cur, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _name$1$[ebp], eax

; 1050 :     if (name == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xstcMetada

; 1051 :         name = xmlStrdup(BAD_CAST "Unknown");

	push	OFFSET ??_C@_07NBCGADJA@Unknown@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _name$1$[ebp], eax
$LN8@xstcMetada:

; 1052 :     }
; 1053 :     printf("## %s test suite for Schemas version %s\n", contributor, name);

	push	eax
	push	DWORD PTR _contributor$1$[ebp]
	push	OFFSET ??_C@_0CJ@PEBJNNOD@?$CD?$CD?5?$CFs?5test?5suite?5for?5Schemas?5ve@
	call	_printf

; 1054 :     xmlFree(contributor);

	mov	eax, DWORD PTR __imp__xmlFree
	push	DWORD PTR _contributor$1$[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax

; 1055 :     xmlFree(name);

	mov	eax, DWORD PTR __imp__xmlFree
	push	DWORD PTR _name$1$[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax

; 1056 : 
; 1057 :     cur = getNext(cur, "./ts:testGroup[1]");

	push	OFFSET ??_C@_0BC@LOBCMKNF@?4?1ts?3testGroup?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 1058 :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testGroup"))) {

	test	esi, esi
	je	SHORT $LN10@xstcMetada
	push	OFFSET ??_C@_09EANEKJKI@testGroup@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xstcMetada
	mov	edi, DWORD PTR _base$[ebp]
	npad	1
$LL2@xstcMetada:

; 1061 : 	goto done;
; 1062 :     }
; 1063 :     while (cur != NULL) {
; 1064 :         xstcTestGroup(cur, base);

	push	edi
	push	esi
	call	_xstcTestGroup

; 1065 : 	cur = getNext(cur, "following-sibling::ts:testGroup[1]");

	push	OFFSET ??_C@_0CD@EPMPPHIO@following?9sibling?3?3ts?3testGroup@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 16					; 00000010H
	test	esi, esi
	jne	SHORT $LL2@xstcMetada

; 1066 :     }
; 1067 : 
; 1068 : done:
; 1069 :     xmlFreeDoc(doc);

	push	ebx
	call	_xmlFreeDoc

; 1070 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 1071 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xstcMetada:

; 1059 :         fprintf(stderr, "Unexpected format %s\n", metadata);

	push	edi
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1060 : 	ret = -1;

	mov	DWORD PTR _ret$1$[ebp], -1
$done$18:

; 1066 :     }
; 1067 : 
; 1068 : done:
; 1069 :     xmlFreeDoc(doc);

	push	ebx
	call	_xmlFreeDoc

; 1070 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 1071 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xstcMetada:

; 1042 :         fprintf(stderr, "Unexpected format %s\n", metadata);

	push	edi
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1043 : 	return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1071 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xstcMetadata ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcTestGroup
_TEXT	SEGMENT
_buf$1 = -68						; size = 48
_mem$1$ = -20						; size = 4
_href$1$ = -16						; size = 4
_ret$1$ = -12						; size = 4
_validity$1$ = -8					; size = 4
_schemas$1$ = -4					; size = 4
_cur$ = 8						; size = 4
_base$ = 12						; size = 4
_xstcTestGroup PROC					; COMDAT

; 905  : xstcTestGroup(xmlNodePtr cur, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 906  :     xmlChar *href = NULL;
; 907  :     xmlChar *path = NULL;

	xor	edi, edi

; 908  :     xmlChar *validity = NULL;
; 909  :     xmlSchemaPtr schemas = NULL;
; 910  :     xmlSchemaParserCtxtPtr ctxt;
; 911  :     xmlNodePtr instance;
; 912  :     int ret = 0, mem;

	xor	ebx, ebx
	mov	DWORD PTR _validity$1$[ebp], edi
	xor	esi, esi
	mov	DWORD PTR _ret$1$[ebp], ebx

; 913  : 
; 914  :     xmlResetLastError();

	call	_xmlResetLastError

; 915  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, ebx
	mov	BYTE PTR _testErrors, bl

; 916  :     mem = xmlMemUsed();

	call	_xmlMemUsed

; 917  :     href = getString(cur,

	push	OFFSET ??_C@_0DE@ONCAFCLF@string?$CIts?3schemaTest?1ts?3schemaD@
	push	DWORD PTR _cur$[ebp]
	mov	DWORD PTR _mem$1$[ebp], eax
	call	_getString
	add	esp, 8
	mov	DWORD PTR _href$1$[ebp], eax

; 918  :                      "string(ts:schemaTest/ts:schemaDocument/@xlink:href)");
; 919  :     if ((href == NULL) || (href[0] == 0)) {

	test	eax, eax
	je	$LN5@xstcTestGr
	cmp	BYTE PTR [eax], bl
	je	$LN5@xstcTestGr

; 923  : 	goto done;
; 924  :     }
; 925  :     path = xmlBuildURI(href, BAD_CAST base);

	push	DWORD PTR _base$[ebp]
	push	eax
	call	_xmlBuildURI
	mov	edi, eax
	add	esp, 8

; 926  :     if (path == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xstcTestGr

; 927  : 	test_log("Failed to build path to schemas testGroup line %ld : %s\n",

	push	DWORD PTR _href$1$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
	call	_test_log
	add	esp, 12					; 0000000cH

; 928  : 		xmlGetLineNo(cur), href);
; 929  : 	ret = -1;

	or	ebx, -1

; 930  : 	goto done;

	jmp	$done$43
$LN6@xstcTestGr:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 79   :     if (stat(filename, &buf) == -1)

	cmp	eax, -1
	je	$LN35@xstcTestGr

; 80   :         return(0);
; 81   : 
; 82   : #if defined(_WIN32) && !defined(__CYGWIN__)
; 83   :     if (!(buf.st_mode & _S_IFREG))

	test	DWORD PTR _buf$1[ebp+6], 32768		; 00008000H
	je	$LN35@xstcTestGr

; 937  :     }
; 938  :     validity = getString(cur,

	mov	ecx, DWORD PTR _cur$[ebp]
	push	OFFSET ??_C@_0CM@KEHKFIFH@string?$CIts?3schemaTest?1ts?3expecte@
	push	ecx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _validity$1$[ebp], eax

; 939  :                          "string(ts:schemaTest/ts:expected/@validity)");
; 940  :     if (validity == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xstcTestGr

; 941  :         test_log("testGroup line %ld misses expected validity\n",

	push	DWORD PTR _cur$[ebp]
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CN@KBELDKMH@testGroup?5line?5?$CFld?5misses?5expec@
	call	_test_log
	add	esp, 12					; 0000000cH

; 942  : 	        xmlGetLineNo(cur));
; 943  : 	ret = -1;

	or	ebx, -1

; 944  : 	goto done;

	jmp	$done$43
$LN8@xstcTestGr:

; 945  :     }
; 946  :     nb_tests++;

	inc	DWORD PTR _nb_tests

; 947  :     if (xmlStrEqual(validity, BAD_CAST "valid")) {

	push	OFFSET ??_C@_05HDPIMK@valid@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xstcTestGr

; 948  :         nb_schematas++;

	inc	DWORD PTR _nb_schematas

; 949  : 	ctxt = xmlSchemaNewParserCtxt((const char *) path);

	push	edi
	call	_xmlSchemaNewParserCtxt
	mov	esi, eax

; 950  : 	xmlSchemaSetParserErrors(ctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlSchemaSetParserErrors

; 951  : 	     (xmlSchemaValidityErrorFunc) testErrorHandler,
; 952  : 	     (xmlSchemaValidityWarningFunc) testErrorHandler,
; 953  : 	     ctxt);
; 954  : 	schemas = xmlSchemaParse(ctxt);

	push	esi
	call	_xmlSchemaParse

; 955  : 	xmlSchemaFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR _schemas$1$[ebp], eax
	call	_xmlSchemaFreeParserCtxt
	add	esp, 28					; 0000001cH

; 956  : 	if (schemas == NULL) {

	cmp	DWORD PTR _schemas$1$[ebp], ebx
	jne	SHORT $LN36@xstcTestGr

; 957  : 	    test_log("valid schemas %s failed to parse\n",

	push	edi
	push	OFFSET ??_C@_0CC@MDMCGIDK@valid?5schemas?5?$CFs?5failed?5to?5pars@
	call	_test_log

; 958  : 			path);
; 959  : 	    ret = 1;
; 960  : 	    nb_errors++;
; 961  : 	}
; 962  : 	if ((ret == 0) && (strstr(testErrors, "nimplemented") != NULL)) {

	jmp	SHORT $LN41@xstcTestGr
$LN36@xstcTestGr:
	push	OFFSET ??_C@_0N@MBLKFBIB@nimplemented@
	push	OFFSET _testErrors
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xstcTestGr

; 963  : 	    test_log("valid schemas %s hit an unimplemented block\n",

	push	edi
	push	OFFSET ??_C@_0CN@ELPOJJMN@valid?5schemas?5?$CFs?5hit?5an?5unimple@
	call	_test_log

; 964  : 			path);
; 965  : 	    ret = 1;
; 966  : 	    nb_unimplemented++;

	inc	DWORD PTR _nb_unimplemented
$LN41@xstcTestGr:

; 967  : 	    nb_errors++;
; 968  : 	}
; 969  : 	instance = getNext(cur, "./ts:instanceTest[1]");

	mov	ebx, 1
	add	esp, 8
	inc	DWORD PTR _nb_errors
	mov	DWORD PTR _ret$1$[ebp], ebx
$LN12@xstcTestGr:
	push	OFFSET ??_C@_0BF@KAPKJJJH@?4?1ts?3instanceTest?$FL1?$FN@
	push	DWORD PTR _cur$[ebp]
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 970  : 	while (instance != NULL) {

	test	esi, esi
	je	SHORT $LN40@xstcTestGr
	mov	ebx, DWORD PTR _schemas$1$[ebp]
$LL2@xstcTestGr:

; 971  : 	    if (schemas != NULL) {

	test	ebx, ebx
	je	SHORT $LN13@xstcTestGr

; 972  : 		xstcTestInstance(instance, schemas, path, base);

	push	DWORD PTR _base$[ebp]
	push	edi
	push	ebx
	push	esi
	call	_xstcTestInstance
	add	esp, 16					; 00000010H

; 973  : 	    } else {

	jmp	SHORT $LN14@xstcTestGr
$LN13@xstcTestGr:

; 974  : 		/*
; 975  : 		* We'll automatically mark the instances as failed
; 976  : 		* if the schema was broken.
; 977  : 		*/
; 978  : 		nb_errors++;

	inc	DWORD PTR _nb_errors
$LN14@xstcTestGr:

; 979  : 	    }
; 980  : 	    instance = getNext(instance,

	push	OFFSET ??_C@_0CG@FCJJLOOA@following?9sibling?3?3ts?3instanceT@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@xstcTestGr

; 981  : 		"following-sibling::ts:instanceTest[1]");
; 982  : 	}
; 983  :     } else if (xmlStrEqual(validity, BAD_CAST "invalid")) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN40@xstcTestGr:

; 1010 :     }
; 1011 : 
; 1012 : done:
; 1013 :     if (href != NULL) xmlFree(href);

	mov	esi, DWORD PTR _schemas$1$[ebp]
$done$43:
	mov	eax, DWORD PTR _href$1$[ebp]
	test	eax, eax
	je	SHORT $LN19@xstcTestGr
	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN19@xstcTestGr:

; 1014 :     if (path != NULL) xmlFree(path);

	test	edi, edi
	je	SHORT $LN20@xstcTestGr
	mov	eax, DWORD PTR __imp__xmlFree
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN20@xstcTestGr:

; 1015 :     if (validity != NULL) xmlFree(validity);

	mov	eax, DWORD PTR _validity$1$[ebp]
	test	eax, eax
	je	SHORT $LN21@xstcTestGr
	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN21@xstcTestGr:

; 1016 :     if (schemas != NULL) xmlSchemaFree(schemas);

	test	esi, esi
	je	SHORT $LN22@xstcTestGr
	push	esi
	call	_xmlSchemaFree
	add	esp, 4
$LN22@xstcTestGr:

; 1017 :     xmlResetLastError();

	call	_xmlResetLastError

; 1018 :     if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	mov	esi, DWORD PTR _mem$1$[ebp]
	cmp	esi, eax
	je	SHORT $LN38@xstcTestGr
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN38@xstcTestGr

; 1019 : 	test_log("Processing test line %ld %s leaked %d\n",

	call	_xmlMemUsed
	sub	eax, esi
	push	eax
	push	edi
	push	DWORD PTR _cur$[ebp]
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CH@MEDDADMO@Processing?5test?5line?5?$CFld?5?$CFs?5lea@
	call	_test_log
	add	esp, 16					; 00000010H

; 1020 : 		xmlGetLineNo(cur), path, xmlMemUsed() - mem);
; 1021 : 	nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN38@xstcTestGr:

; 1022 :     }
; 1023 :     return(ret);
; 1024 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xstcTestGr:

; 981  : 		"following-sibling::ts:instanceTest[1]");
; 982  : 	}
; 983  :     } else if (xmlStrEqual(validity, BAD_CAST "invalid")) {

	push	OFFSET ??_C@_07MALOAKCI@invalid@
	push	DWORD PTR _validity$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN15@xstcTestGr

; 984  :         nb_schematas++;

	inc	DWORD PTR _nb_schematas

; 985  : 	ctxt = xmlSchemaNewParserCtxt((const char *) path);

	push	edi
	call	_xmlSchemaNewParserCtxt
	mov	esi, eax

; 986  : 	xmlSchemaSetParserErrors(ctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlSchemaSetParserErrors

; 987  : 	     (xmlSchemaValidityErrorFunc) testErrorHandler,
; 988  : 	     (xmlSchemaValidityWarningFunc) testErrorHandler,
; 989  : 	     ctxt);
; 990  : 	schemas = xmlSchemaParse(ctxt);

	push	esi
	call	_xmlSchemaParse

; 991  : 	xmlSchemaFreeParserCtxt(ctxt);

	push	esi
	mov	DWORD PTR _schemas$1$[ebp], eax
	call	_xmlSchemaFreeParserCtxt

; 992  : 	if (schemas != NULL) {

	mov	esi, DWORD PTR _schemas$1$[ebp]
	add	esp, 28					; 0000001cH
	test	esi, esi
	je	SHORT $LN37@xstcTestGr

; 993  : 	    test_log("Failed to detect error in schemas %s\n",

	push	edi
	push	OFFSET ??_C@_0CG@PIGAEOBP@Failed?5to?5detect?5error?5in?5schem@
	call	_test_log
	add	esp, 8

; 994  : 			path);
; 995  : 	    nb_errors++;
; 996  : 	    ret = 1;

	mov	ebx, 1
	inc	DWORD PTR _nb_errors

; 997  : 	}
; 998  : 	if ((ret == 0) && (strstr(testErrors, "nimplemented") != NULL)) {

	jmp	$done$43
$LN37@xstcTestGr:
	push	OFFSET ??_C@_0N@MBLKFBIB@nimplemented@
	push	OFFSET _testErrors
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	$done$43

; 999  : 	    nb_unimplemented++;

	inc	DWORD PTR _nb_unimplemented

; 1000 : 	    test_log("invalid schemas %s hit an unimplemented block\n",

	push	edi
	push	OFFSET ??_C@_0CP@HIGMEMKG@invalid?5schemas?5?$CFs?5hit?5an?5unimp@
	call	_test_log
	add	esp, 8

; 1001 : 			path);
; 1002 : 	    ret = 1;

	mov	ebx, 1

; 1003 : 	    nb_errors++;

	inc	DWORD PTR _nb_errors

; 1004 : 	}
; 1005 :     } else {

	jmp	$done$43
$LN15@xstcTestGr:

; 1006 :         test_log("testGroup line %ld misses unexpected validity value%s\n",

	push	DWORD PTR _validity$1$[ebp]
	push	DWORD PTR _cur$[ebp]
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DH@MPCAIJDE@testGroup?5line?5?$CFld?5misses?5unexp@
	call	_test_log
	add	esp, 12					; 0000000cH

; 1007 : 	        xmlGetLineNo(cur), validity);
; 1008 : 	ret = -1;

	or	ebx, -1

; 1009 : 	goto done;

	jmp	$done$43
$LN35@xstcTestGr:

; 931  :     }
; 932  :     if (checkTestFile((const char *) path) <= 0) {
; 933  : 	test_log("schemas for testGroup line %ld is missing: %s\n",

	push	edi
	push	DWORD PTR _cur$[ebp]
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 934  : 		xmlGetLineNo(cur), path);
; 935  : 	ret = -1;

	or	ebx, -1

; 936  : 	goto done;

	jmp	$done$43
$LN5@xstcTestGr:

; 920  :         test_log("testGroup line %ld misses href for schemaDocument\n",

	push	DWORD PTR _cur$[ebp]
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 921  : 		    xmlGetLineNo(cur));
; 922  : 	ret = -1;

	or	ebx, -1

; 970  : 	while (instance != NULL) {

	jmp	$done$43
_xstcTestGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xstcTestInstance
_TEXT	SEGMENT
_buf$1 = -68						; size = 48
_mem$1$ = -20						; size = 4
_href$1$ = -16						; size = 4
_doc$1$ = -12						; size = 4
_ctxt$1$ = -8						; size = 4
_validity$1$ = -4					; size = 4
_cur$ = 8						; size = 4
_schemas$ = 12						; size = 4
_spath$ = 16						; size = 4
_base$ = 20						; size = 4
_xstcTestInstance PROC					; COMDAT

; 808  :                  const xmlChar *spath, const char *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 809  :     xmlChar *href = NULL;
; 810  :     xmlChar *path = NULL;
; 811  :     xmlChar *validity = NULL;
; 812  :     xmlSchemaValidCtxtPtr ctxt = NULL;

	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _validity$1$[ebp], edi
	mov	DWORD PTR _ctxt$1$[ebp], eax

; 813  :     xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$1$[ebp], eax

; 814  :     int ret = 0, mem;
; 815  : 
; 816  :     xmlResetLastError();

	call	_xmlResetLastError

; 817  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, edi
	mov	BYTE PTR _testErrors, 0

; 818  :     mem = xmlMemUsed();

	call	_xmlMemUsed

; 819  :     href = getString(cur,

	mov	ebx, DWORD PTR _cur$[ebp]
	push	OFFSET ??_C@_0CI@CMJHJDGI@string?$CIts?3instanceDocument?1?$EAxli@
	push	ebx
	mov	DWORD PTR _mem$1$[ebp], eax
	call	_getString
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR _href$1$[ebp], esi

; 820  :                      "string(ts:instanceDocument/@xlink:href)");
; 821  :     if ((href == NULL) || (href[0] == 0)) {

	test	esi, esi
	je	$LN3@xstcTestIn
	cmp	BYTE PTR [esi], 0
	je	$LN3@xstcTestIn

; 823  : 		    xmlGetLineNo(cur));
; 824  : 	ret = -1;
; 825  : 	goto done;
; 826  :     }
; 827  :     path = xmlBuildURI(href, BAD_CAST base);

	push	DWORD PTR _base$[ebp]
	push	esi
	call	_xmlBuildURI
	mov	edi, eax
	add	esp, 8

; 828  :     if (path == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xstcTestIn

; 829  : 	fprintf(stderr,

	push	esi
	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DJ@ODKNMILE@Failed?5to?5build?5path?5to?5schemas@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 830  : 	        "Failed to build path to schemas testGroup line %ld : %s\n",
; 831  : 		xmlGetLineNo(cur), href);
; 832  : 	ret = -1;
; 833  : 	goto done;

	jmp	$LN31@xstcTestIn
$LN4@xstcTestIn:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 79   :     if (stat(filename, &buf) == -1)

	cmp	eax, -1
	je	$LN29@xstcTestIn

; 80   :         return(0);
; 81   : 
; 82   : #if defined(_WIN32) && !defined(__CYGWIN__)
; 83   :     if (!(buf.st_mode & _S_IFREG))

	test	DWORD PTR _buf$1[ebp+6], 32768		; 00008000H
	je	$LN29@xstcTestIn

; 840  :     }
; 841  :     validity = getString(cur,

	push	OFFSET ??_C@_0BO@LLDGLFOO@string?$CIts?3expected?1?$EAvalidity?$CJ@
	push	ebx
	call	_getString
	add	esp, 8
	mov	DWORD PTR _validity$1$[ebp], eax

; 842  :                          "string(ts:expected/@validity)");
; 843  :     if (validity == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xstcTestIn

; 844  :         fprintf(stderr, "instanceDocument line %ld misses expected validity\n",

	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DE@ELAIJGEI@instanceDocument?5line?5?$CFld?5misse@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 845  : 	        xmlGetLineNo(cur));
; 846  : 	ret = -1;
; 847  : 	goto done;

	jmp	$LN32@xstcTestIn
$LN6@xstcTestIn:

; 848  :     }
; 849  :     nb_tests++;

	inc	DWORD PTR _nb_tests

; 850  :     doc = xmlReadFile((const char *) path, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	push	edi
	call	_xmlReadFile
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$1$[ebp], esi

; 851  :     if (doc == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xstcTestIn

; 852  :         fprintf(stderr, "instance %s fails to parse\n", path);

	push	edi
	push	OFFSET ??_C@_0BM@MMDCFNIM@instance?5?$CFs?5fails?5to?5parse?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 853  : 	ret = -1;

	or	esi, -1

; 854  : 	nb_errors++;

	inc	DWORD PTR _nb_errors

; 855  : 	goto done;

	jmp	$done$36
$LN7@xstcTestIn:

; 856  :     }
; 857  : 
; 858  :     ctxt = xmlSchemaNewValidCtxt(schemas);

	push	DWORD PTR _schemas$[ebp]
	call	_xmlSchemaNewValidCtxt

; 859  :     xmlSchemaSetValidErrors(ctxt,

	push	eax
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	eax
	mov	DWORD PTR _ctxt$1$[ebp], eax
	call	_xmlSchemaSetValidErrors

; 860  :          (xmlSchemaValidityErrorFunc) testErrorHandler,
; 861  :          (xmlSchemaValidityWarningFunc) testErrorHandler,
; 862  : 	 ctxt);
; 863  :     ret = xmlSchemaValidateDoc(ctxt, doc);

	mov	eax, DWORD PTR _ctxt$1$[ebp]
	push	esi
	push	eax
	call	_xmlSchemaValidateDoc

; 864  : 
; 865  :     if (xmlStrEqual(validity, BAD_CAST "valid")) {

	push	OFFSET ??_C@_05HDPIMK@valid@
	push	DWORD PTR _validity$1$[ebp]
	mov	esi, eax
	call	_xmlStrEqual
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN8@xstcTestIn

; 866  : 	if (ret > 0) {

	test	esi, esi
	jle	SHORT $LN33@xstcTestIn

; 867  : 	    test_log("valid instance %s failed to validate against %s\n",

	push	DWORD PTR _spath$[ebp]
	push	edi
	push	OFFSET ??_C@_0DB@MEJOFODP@valid?5instance?5?$CFs?5failed?5to?5val@
	call	_test_log
	add	esp, 12					; 0000000cH

; 868  : 			path, spath);
; 869  : 	    nb_errors++;

	inc	DWORD PTR _nb_errors
	jmp	$done$36
$LN33@xstcTestIn:

; 870  : 	} else if (ret < 0) {

	jns	$done$36

; 871  : 	    test_log("valid instance %s got internal error validating %s\n",

	push	DWORD PTR _spath$[ebp]
	push	edi
	push	OFFSET ??_C@_0DE@PEFCJFEE@valid?5instance?5?$CFs?5got?5internal?5@
	call	_test_log

; 872  : 			path, spath);
; 873  : 	    nb_internals++;

	inc	DWORD PTR _nb_internals
	add	esp, 12					; 0000000cH

; 874  : 	    nb_errors++;

	inc	DWORD PTR _nb_errors

; 875  : 	}

	jmp	SHORT $done$36
$LN8@xstcTestIn:

; 876  :     } else if (xmlStrEqual(validity, BAD_CAST "invalid")) {

	push	OFFSET ??_C@_07MALOAKCI@invalid@
	push	DWORD PTR _validity$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xstcTestIn

; 877  : 	if (ret == 0) {

	test	esi, esi
	jne	SHORT $done$36

; 878  : 	    test_log("Failed to detect invalid instance %s against %s\n",

	push	DWORD PTR _spath$[ebp]
	push	edi
	push	OFFSET ??_C@_0DB@NHKLIBPD@Failed?5to?5detect?5invalid?5instan@
	call	_test_log
	add	esp, 12					; 0000000cH

; 879  : 			path, spath);
; 880  : 	    nb_errors++;

	inc	DWORD PTR _nb_errors

; 881  : 	}
; 882  :     } else {

	jmp	SHORT $done$36
$LN13@xstcTestIn:

; 883  :         test_log("instanceDocument line %ld has unexpected validity value%s\n",

	push	DWORD PTR _validity$1$[ebp]
	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DL@GJKHAOCE@instanceDocument?5line?5?$CFld?5has?5u@

; 884  : 	        xmlGetLineNo(cur), validity);
; 885  : 	ret = -1;
; 886  : 	goto done;

	jmp	SHORT $LN34@xstcTestIn
$LN29@xstcTestIn:

; 834  :     }
; 835  :     if (checkTestFile((const char *) path) <= 0) {
; 836  : 	test_log("schemas for testGroup line %ld is missing: %s\n",

	push	edi
	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@OLLDHGKK@schemas?5for?5testGroup?5line?5?$CFld?5@

; 837  : 		xmlGetLineNo(cur), path);
; 838  : 	ret = -1;
; 839  : 	goto done;

	jmp	SHORT $LN34@xstcTestIn
$LN3@xstcTestIn:

; 822  : 	test_log("testGroup line %ld misses href for schemaDocument\n",

	push	ebx
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0DD@HGOIGGEJ@testGroup?5line?5?$CFld?5misses?5href?5@
$LN34@xstcTestIn:

; 887  :     }
; 888  : 
; 889  : done:
; 890  :     if (href != NULL) xmlFree(href);

	call	_test_log
$LN32@xstcTestIn:
	add	esp, 12					; 0000000cH
$LN31@xstcTestIn:
	or	esi, -1
$done$36:
	mov	eax, DWORD PTR _href$1$[ebp]
	test	eax, eax
	je	SHORT $LN16@xstcTestIn
	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN16@xstcTestIn:

; 891  :     if (path != NULL) xmlFree(path);

	test	edi, edi
	je	SHORT $LN17@xstcTestIn
	mov	eax, DWORD PTR __imp__xmlFree
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN17@xstcTestIn:

; 892  :     if (validity != NULL) xmlFree(validity);

	mov	eax, DWORD PTR _validity$1$[ebp]
	test	eax, eax
	je	SHORT $LN18@xstcTestIn
	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN18@xstcTestIn:

; 893  :     if (ctxt != NULL) xmlSchemaFreeValidCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$1$[ebp]
	test	eax, eax
	je	SHORT $LN19@xstcTestIn
	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN19@xstcTestIn:

; 894  :     if (doc != NULL) xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$1$[ebp]
	test	eax, eax
	je	SHORT $LN20@xstcTestIn
	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN20@xstcTestIn:

; 895  :     xmlResetLastError();

	call	_xmlResetLastError

; 896  :     if (mem != xmlMemUsed()) {

	call	_xmlMemUsed
	mov	edi, DWORD PTR _mem$1$[ebp]
	cmp	edi, eax
	je	SHORT $LN30@xstcTestIn

; 897  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, edi
	push	eax
	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 898  : 		xmlGetLineNo(cur), xmlMemUsed() - mem);
; 899  : 	nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN30@xstcTestIn:

; 900  :     }
; 901  :     return(ret);
; 902  : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xstcTestInstance ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTest2
_TEXT	SEGMENT
_rngTest2 PROC						; COMDAT

; 763  : rngTest2(void) {

	push	ebx
	push	edi

; 764  :     xmlDocPtr doc;
; 765  :     xmlNodePtr cur;
; 766  :     const char *filename = "test/relaxng/testsuite.xml";
; 767  :     int ret = 0;
; 768  : 
; 769  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	xor	edi, edi
	push	edi
	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
	call	_xmlReadFile
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 770  :     if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@rngTest2

; 771  :         fprintf(stderr, "Failed to parse %s\n", filename);

	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 772  : 	return(-1);

	or	eax, -1
	pop	edi

; 798  : }

	pop	ebx
	ret	0
$LN4@rngTest2:
	push	esi

; 773  :     }
; 774  :     printf("## Relax NG test suite for libxml2\n");

	push	OFFSET ??_C@_0CE@PPJGKGKI@?$CD?$CD?5Relax?5NG?5test?5suite?5for?5libx@
	call	_printf

; 775  : 
; 776  :     cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 8

; 777  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN6@rngTest2
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@rngTest2

; 778  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 779  : 	ret = -1;
; 780  : 	goto done;
; 781  :     }
; 782  : 
; 783  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 784  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN6@rngTest2
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@rngTest2
$LL2@rngTest2:

; 785  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 786  : 	ret = -1;
; 787  : 	goto done;
; 788  :     }
; 789  :     while (cur != NULL) {
; 790  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite

; 791  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL2@rngTest2

; 792  :     }
; 793  : 
; 794  : done:
; 795  :     if (doc != NULL)
; 796  : 	xmlFreeDoc(doc);

	push	ebx
	call	_xmlFreeDoc
	add	esp, 4

; 797  :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 798  : }

	pop	ebx
	ret	0
$LN6@rngTest2:

; 792  :     }
; 793  : 
; 794  : done:
; 795  :     if (doc != NULL)
; 796  : 	xmlFreeDoc(doc);

	push	OFFSET ??_C@_0BL@INNHDNAD@test?1relaxng?1testsuite?4xml@
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	or	edi, -1
$done$16:
	push	ebx
	call	_xmlFreeDoc
	add	esp, 4

; 797  :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 798  : }

	pop	ebx
	ret	0
_rngTest2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTest1
_TEXT	SEGMENT
_doc$1$ = -12						; size = 4
_ret$1$ = -8						; size = 4
_cur$2$ = -4						; size = 4
_rngTest1 PROC						; COMDAT

; 725  : rngTest1(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 726  :     xmlDocPtr doc;
; 727  :     xmlNodePtr cur;
; 728  :     const char *filename = "test/relaxng/OASIS/spectest.xml";
; 729  :     int ret = 0;
; 730  : 
; 731  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	push	0
	push	OFFSET ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@
	mov	DWORD PTR _ret$1$[ebp], 0
	call	_xmlReadFile
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$1$[ebp], esi

; 732  :     if (doc == NULL) {

	test	esi, esi
	jne	SHORT $LN4@rngTest1

; 733  :         fprintf(stderr, "Failed to parse %s\n", filename);

	push	OFFSET ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 734  : 	return(-1);

	or	eax, -1
	pop	esi

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@rngTest1:
	push	ebx

; 735  :     }
; 736  :     printf("## Relax NG test suite from James Clark\n");

	push	OFFSET ??_C@_0CJ@HIMBOBNB@?$CD?$CD?5Relax?5NG?5test?5suite?5from?5Jam@
	call	_printf

; 737  : 
; 738  :     cur = xmlDocGetRootElement(doc);

	push	esi
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 8

; 739  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	$LN6@rngTest1
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@rngTest1

; 740  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 741  : 	ret = -1;
; 742  : 	goto done;
; 743  :     }
; 744  : 
; 745  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _cur$2$[ebp], ebx

; 746  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	ebx, ebx
	je	$LN6@rngTest1
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@rngTest1
	push	edi
	npad	8
$LL2@rngTest1:

; 701  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	je	SHORT $LN17@rngTest1

; 702  : 	xmlChar *doc = getString(cur, "string(documentation)");

	push	OFFSET ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
	push	ebx
	call	_getString
	mov	esi, eax
	add	esp, 8

; 703  : 
; 704  : 	if (doc != NULL) {

	test	esi, esi
	je	SHORT $LN15@rngTest1

; 705  : 	    printf("Suite %s\n", doc);

	push	esi
	push	OFFSET ??_C@_09IBKNLDJC@Suite?5?$CFs?6@

; 706  : 	    xmlFree(doc);
; 707  : 	} else {

	jmp	SHORT $LN40@rngTest1
$LN15@rngTest1:

; 708  : 	    doc = getString(cur, "string(section)");

	push	OFFSET ??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@
	push	ebx
	call	_getString
	mov	esi, eax
	add	esp, 8

; 709  : 	    if (doc != NULL) {

	test	esi, esi
	je	SHORT $LN17@rngTest1

; 710  : 		printf("Section %s\n", doc);

	push	esi
	push	OFFSET ??_C@_0M@DACABIB@Section?5?$CFs?6@
$LN40@rngTest1:

; 711  : 		xmlFree(doc);
; 712  : 	    }
; 713  : 	}
; 714  :     }
; 715  :     cur = getNext(cur, "./testSuite[1]");

	call	_printf
	mov	eax, DWORD PTR __imp__xmlFree
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
$LN17@rngTest1:
	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	ebx
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 716  :     while (cur != NULL) {

	test	esi, esi
	je	$LN35@rngTest1
	npad	7
$LL12@rngTest1:

; 717  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite
	add	esp, 4

; 270  :     xmlNodePtr ret = NULL;

	xor	edi, edi

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	esi, esi
	je	$LN39@rngTest1
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	$LN39@rngTest1

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
	call	_xmlXPathCompile
	mov	ebx, eax
	add	esp, 4

; 279  :     if (comp == NULL) {

	test	ebx, ebx
	je	SHORT $LN34@rngTest1

; 281  : 	return(NULL);
; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	ebx
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN39@rngTest1

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN24@rngTest1
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN24@rngTest1
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN24@rngTest1
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN24@rngTest1

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	edi, DWORD PTR [eax]
$LN24@rngTest1:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	esi, edi

; 716  :     while (cur != NULL) {

	test	edi, edi
	jne	SHORT $LL12@rngTest1
	jmp	SHORT $LN39@rngTest1
$LN34@rngTest1:

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN39@rngTest1:

; 747  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 748  : 	ret = -1;
; 749  : 	goto done;
; 750  :     }
; 751  :     while (cur != NULL) {
; 752  :         rngTestSuite(cur);
; 753  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	mov	ebx, DWORD PTR _cur$2$[ebp]
$LN35@rngTest1:
	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	ebx
	call	_getNext
	mov	ebx, eax
	mov	DWORD PTR _cur$2$[ebp], eax
	add	esp, 8
	test	ebx, ebx
	jne	$LL2@rngTest1

; 754  :     }
; 755  : 
; 756  : done:
; 757  :     if (doc != NULL)
; 758  : 	xmlFreeDoc(doc);

	pop	edi
	push	DWORD PTR _doc$1$[ebp]
	call	_xmlFreeDoc

; 759  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	ebx
	pop	esi

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@rngTest1:

; 754  :     }
; 755  : 
; 756  : done:
; 757  :     if (doc != NULL)
; 758  : 	xmlFreeDoc(doc);

	push	OFFSET ??_C@_0CA@KKAOGFMP@test?1relaxng?1OASIS?1spectest?4xml@
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	mov	DWORD PTR _ret$1$[ebp], -1
	add	esp, 12					; 0000000cH
$done$42:
	push	DWORD PTR _doc$1$[ebp]
	call	_xmlFreeDoc

; 759  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	ebx
	pop	esi

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_rngTest1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _rngTestSuite
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_rngTestSuite PROC					; COMDAT

; 700  : rngTestSuite(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp

; 701  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	push	edi
	je	SHORT $LN7@rngTestSui

; 702  : 	xmlChar *doc = getString(cur, "string(documentation)");

	push	OFFSET ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
	push	esi
	call	_getString
	mov	edi, eax
	add	esp, 8

; 703  : 
; 704  : 	if (doc != NULL) {

	test	edi, edi
	je	SHORT $LN5@rngTestSui

; 705  : 	    printf("Suite %s\n", doc);

	push	edi
	push	OFFSET ??_C@_09IBKNLDJC@Suite?5?$CFs?6@

; 706  : 	    xmlFree(doc);
; 707  : 	} else {

	jmp	SHORT $LN28@rngTestSui
$LN5@rngTestSui:

; 708  : 	    doc = getString(cur, "string(section)");

	push	OFFSET ??_C@_0BA@IFALBHJB@string?$CIsection?$CJ@
	push	esi
	call	_getString
	mov	edi, eax
	add	esp, 8

; 709  : 	    if (doc != NULL) {

	test	edi, edi
	je	SHORT $LN7@rngTestSui

; 710  : 		printf("Section %s\n", doc);

	push	edi
	push	OFFSET ??_C@_0M@DACABIB@Section?5?$CFs?6@
$LN28@rngTestSui:

; 711  : 		xmlFree(doc);
; 712  : 	    }
; 713  : 	}
; 714  :     }
; 715  :     cur = getNext(cur, "./testSuite[1]");

	call	_printf
	mov	eax, DWORD PTR __imp__xmlFree
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
$LN7@rngTestSui:
	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 716  :     while (cur != NULL) {

	test	esi, esi
	je	$LN25@rngTestSui
	push	ebx
$LL2@rngTestSui:

; 717  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite
	add	esp, 4

; 270  :     xmlNodePtr ret = NULL;

	xor	edi, edi

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	esi, esi
	je	$LN22@rngTestSui
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	$LN22@rngTestSui

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
	call	_xmlXPathCompile
	mov	ebx, eax
	add	esp, 4

; 279  :     if (comp == NULL) {

	test	ebx, ebx
	je	SHORT $LN20@rngTestSui

; 281  : 	return(NULL);
; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	ebx
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN22@rngTestSui

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN14@rngTestSui
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN14@rngTestSui
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN14@rngTestSui
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN14@rngTestSui

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	edi, DWORD PTR [eax]
$LN14@rngTestSui:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	esi, edi

; 716  :     while (cur != NULL) {

	test	edi, edi
	jne	SHORT $LL2@rngTestSui

; 718  : 	cur = getNext(cur, "following-sibling::testSuite[1]");
; 719  :     }
; 720  : 
; 721  :     return(0);
; 722  : }

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN20@rngTestSui:

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN22@rngTestSui:
	pop	ebx
$LN25@rngTestSui:
	pop	edi

; 718  : 	cur = getNext(cur, "following-sibling::testSuite[1]");
; 719  :     }
; 720  : 
; 721  :     return(0);
; 722  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_rngTestSuite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTest
_TEXT	SEGMENT
_xsdTest PROC						; COMDAT

; 662  : xsdTest(void) {

	push	ebx
	push	edi

; 663  :     xmlDocPtr doc;
; 664  :     xmlNodePtr cur;
; 665  :     const char *filename = "test/xsdtest/xsdtestsuite.xml";
; 666  :     int ret = 0;
; 667  : 
; 668  :     doc = xmlReadFile(filename, NULL, XML_PARSE_NOENT);

	push	2
	xor	edi, edi
	push	edi
	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
	call	_xmlReadFile
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 669  :     if (doc == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xsdTest

; 670  :         fprintf(stderr, "Failed to parse %s\n", filename);

	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
	push	OFFSET ??_C@_0BE@MIGLFCAE@Failed?5to?5parse?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 671  : 	return(-1);

	or	eax, -1
	pop	edi

; 697  : }

	pop	ebx
	ret	0
$LN4@xsdTest:
	push	esi

; 672  :     }
; 673  :     printf("## XML Schemas datatypes test suite from James Clark\n");

	push	OFFSET ??_C@_0DG@ICOCCJHI@?$CD?$CD?5XML?5Schemas?5datatypes?5test?5s@
	call	_printf

; 674  : 
; 675  :     cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 8

; 676  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN6@xsdTest
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xsdTest

; 677  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 678  : 	ret = -1;
; 679  : 	goto done;
; 680  :     }
; 681  : 
; 682  :     cur = getNext(cur, "./testSuite[1]");

	push	OFFSET ??_C@_0P@MCCEHCEB@?4?1testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 683  :     if ((cur == NULL) || (!xmlStrEqual(cur->name, BAD_CAST "testSuite"))) {

	test	esi, esi
	je	SHORT $LN6@xsdTest
	push	OFFSET ??_C@_09HJKPOGMK@testSuite@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xsdTest
$LL2@xsdTest:

; 684  :         fprintf(stderr, "Unexpected format %s\n", filename);
; 685  : 	ret = -1;
; 686  : 	goto done;
; 687  :     }
; 688  :     while (cur != NULL) {
; 689  :         xsdTestSuite(cur);

	push	esi
	call	_xsdTestSuite

; 690  : 	cur = getNext(cur, "following-sibling::testSuite[1]");

	push	OFFSET ??_C@_0CA@JBBMIANC@following?9sibling?3?3testSuite?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL2@xsdTest

; 691  :     }
; 692  : 
; 693  : done:
; 694  :     if (doc != NULL)
; 695  : 	xmlFreeDoc(doc);

	push	ebx
	call	_xmlFreeDoc
	add	esp, 4

; 696  :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 697  : }

	pop	ebx
	ret	0
$LN6@xsdTest:

; 691  :     }
; 692  : 
; 693  : done:
; 694  :     if (doc != NULL)
; 695  : 	xmlFreeDoc(doc);

	push	OFFSET ??_C@_0BO@MGGLCEJL@test?1xsdtest?1xsdtestsuite?4xml@
	push	OFFSET ??_C@_0BG@PMFPBAMH@Unexpected?5format?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	or	edi, -1
$done$16:
	push	ebx
	call	_xmlFreeDoc
	add	esp, 4

; 696  :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 697  : }

	pop	ebx
	ret	0
_xsdTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTestSuite
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xsdTestSuite PROC					; COMDAT

; 643  : xsdTestSuite(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp

; 644  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	push	esi
	push	edi
	mov	edi, DWORD PTR _cur$[ebp]
	je	SHORT $LN5@xsdTestSui

; 645  : 	xmlChar *doc = getString(cur, "string(documentation)");

	push	OFFSET ??_C@_0BG@IHDGFAMN@string?$CIdocumentation?$CJ@
	push	edi
	call	_getString
	mov	esi, eax
	add	esp, 8

; 646  : 
; 647  : 	if (doc != NULL) {

	test	esi, esi
	je	SHORT $LN5@xsdTestSui

; 648  : 	    printf("Suite %s\n", doc);

	push	esi
	push	OFFSET ??_C@_09IBKNLDJC@Suite?5?$CFs?6@
	call	_printf

; 649  : 	    xmlFree(doc);

	mov	eax, DWORD PTR __imp__xmlFree
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
$LN5@xsdTestSui:

; 650  : 	}
; 651  :     }
; 652  :     cur = getNext(cur, "./testCase[1]");

	push	OFFSET ??_C@_0O@GKEMDIAD@?4?1testCase?$FL1?$FN@
	push	edi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 653  :     while (cur != NULL) {

	test	esi, esi
	je	$LN23@xsdTestSui
	push	ebx
$LL2@xsdTestSui:

; 654  :         xsdTestCase(cur);

	push	esi
	call	_xsdTestCase
	add	esp, 4

; 270  :     xmlNodePtr ret = NULL;

	xor	edi, edi

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	esi, esi
	je	$LN20@xsdTestSui
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	$LN20@xsdTestSui

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], esi
	call	_xmlXPathCompile
	mov	ebx, eax
	add	esp, 4

; 279  :     if (comp == NULL) {

	test	ebx, ebx
	je	SHORT $LN18@xsdTestSui

; 281  : 	return(NULL);
; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	ebx
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN20@xsdTestSui

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN12@xsdTestSui
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@xsdTestSui
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN12@xsdTestSui
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN12@xsdTestSui

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	edi, DWORD PTR [eax]
$LN12@xsdTestSui:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	esi, edi

; 653  :     while (cur != NULL) {

	test	edi, edi
	jne	SHORT $LL2@xsdTestSui

; 655  : 	cur = getNext(cur, "following-sibling::testCase[1]");
; 656  :     }
; 657  : 
; 658  :     return(0);
; 659  : }

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN18@xsdTestSui:

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_0BP@OBCNJLPB@following?9sibling?3?3testCase?$FL1?$FN@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN20@xsdTestSui:
	pop	ebx
$LN23@xsdTestSui:
	pop	edi

; 655  : 	cur = getNext(cur, "following-sibling::testCase[1]");
; 656  :     }
; 657  : 
; 658  :     return(0);
; 659  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xsdTestSuite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdTestCase
_TEXT	SEGMENT
_mem$2$ = -28						; size = 4
_mem$1$ = -28						; size = 4
_rng$1$ = -24						; size = 4
_buf$1$ = -24						; size = 4
_doc$2$ = -24						; size = 4
_buf$1$ = -20						; size = 4
_test$2$ = -20						; size = 4
_doc$1$ = -20						; size = 4
_test$1$ = -16						; size = 4
_cur$1$ = -16						; size = 4
_memt$1$ = -12						; size = 4
_memt$2$ = -12						; size = 4
_rng$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_tst$ = 8						; size = 4
_xsdTestCase PROC					; COMDAT

; 450  : xsdTestCase(xmlNodePtr tst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 133  :     for (i = 0;i < nb_entities;i++) {

	xor	esi, esi

; 451  :     xmlNodePtr test, tmp, cur;
; 452  :     xmlBufferPtr buf;
; 453  :     xmlDocPtr doc = NULL;
; 454  :     xmlRelaxNGParserCtxtPtr pctxt;
; 455  :     xmlRelaxNGValidCtxtPtr ctxt;
; 456  :     xmlRelaxNGPtr rng = NULL;
; 457  :     int ret = 0, mem, memt;

	mov	DWORD PTR _ret$1$[ebp], 0
	push	edi

; 133  :     for (i = 0;i < nb_entities;i++) {

	cmp	DWORD PTR _nb_entities, esi
	jle	SHORT $LN37@xsdTestCas
	npad	6
$LL38@xsdTestCas:

; 134  :         if (testEntitiesName[i] != NULL)

	mov	eax, DWORD PTR _testEntitiesName[esi*4]
	test	eax, eax
	je	SHORT $LN39@xsdTestCas

; 135  : 	    xmlFree(testEntitiesName[i]);

	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN39@xsdTestCas:

; 136  :         if (testEntitiesValue[i] != NULL)

	mov	eax, DWORD PTR _testEntitiesValue[esi*4]
	test	eax, eax
	je	SHORT $LN36@xsdTestCas

; 137  : 	    xmlFree(testEntitiesValue[i]);

	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN36@xsdTestCas:

; 133  :     for (i = 0;i < nb_entities;i++) {

	inc	esi
	cmp	esi, DWORD PTR _nb_entities
	jl	SHORT $LL38@xsdTestCas
$LN37@xsdTestCas:

; 462  : 
; 463  :     tmp = getNext(tst, "./dir[1]");

	mov	esi, DWORD PTR _tst$[ebp]
	push	OFFSET ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
	push	esi

; 139  :     nb_entities = 0;

	mov	DWORD PTR _nb_entities, 0

; 458  :     xmlChar *dtd;
; 459  : 
; 460  :     resetEntities();
; 461  :     testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	BYTE PTR _testErrors, 0

; 462  : 
; 463  :     tmp = getNext(tst, "./dir[1]");

	call	_getNext
	add	esp, 8

; 464  :     if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN6@xsdTestCas

; 465  :         installDirs(tmp, NULL);

	push	0
	push	eax
	call	_installDirs
	add	esp, 8
$LN6@xsdTestCas:

; 466  :     }
; 467  :     tmp = getNext(tst, "./resource[1]");

	push	OFFSET ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
	push	esi
	call	_getNext
	add	esp, 8

; 468  :     if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN7@xsdTestCas

; 469  :         installResources(tmp, NULL);

	push	0
	push	eax
	call	_installResources
	add	esp, 8
$LN7@xsdTestCas:

; 470  :     }
; 471  : 
; 472  :     cur = getNext(tst, "./correct[1]");

	push	OFFSET ??_C@_0N@GHEABEGP@?4?1correct?$FL1?$FN@
	push	esi
	call	_getNext
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _cur$1$[ebp], ebx

; 473  :     if (cur == NULL) {

	test	ebx, ebx
	jne	$LN8@xsdTestCas

; 337  :     cur = getNext(cur, "./incorrect[1]");

	push	OFFSET ??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@
	push	esi
	xor	edi, edi
	call	_getNext
	mov	ebx, eax
	add	esp, 8

; 338  :     if (cur == NULL) {

	test	ebx, ebx
	jne	SHORT $LN43@xsdTestCas

; 640  : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xsdTestCas:

; 342  :     test = getNext(cur, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	ebx
	call	_getNext
	add	esp, 8
	mov	DWORD PTR _test$1$[ebp], eax

; 343  :     if (test == NULL) {

	test	eax, eax
	jne	SHORT $LN44@xsdTestCas

; 344  :         test_log("Failed to find test in correct line %ld\n",

	push	ebx
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 345  : 	        xmlGetLineNo(cur));
; 346  :         return(1);

	mov	edi, 1

; 474  :         return(xsdIncorectTestCase(tst));

	mov	eax, edi
	pop	edi

; 640  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xsdTestCas:

; 349  :     memt = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memt$1$[ebp], eax

; 350  :     extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, edi

; 351  :     /*
; 352  :      * dump the schemas to a buffer, then reparse it and compile the schemas
; 353  :      */
; 354  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	esi, eax
	mov	DWORD PTR _buf$1$[ebp], esi

; 355  :     if (buf == NULL) {

	test	esi, esi
	je	$LN70@xsdTestCas

; 356  :         fprintf(stderr, "out of memory !\n");
; 357  : 	fatalError();
; 358  :     }
; 359  :     xmlNodeDump(buf, test->doc, test, 0, 0);

	mov	eax, DWORD PTR _test$1$[ebp]
	push	0
	push	0
	push	eax
	push	DWORD PTR [eax+32]
	push	esi
	call	_xmlNodeDump

; 360  :     pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	_xmlRelaxNGNewMemParserCtxt
	mov	esi, eax

; 361  :     xmlRelaxNGSetParserErrors(pctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlRelaxNGSetParserErrors

; 362  :          (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 363  :          (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 364  : 	 pctxt);
; 365  :     rng = xmlRelaxNGParse(pctxt);

	push	esi
	call	_xmlRelaxNGParse

; 366  :     xmlRelaxNGFreeParserCtxt(pctxt);

	push	esi
	mov	DWORD PTR _rng$1$[ebp], eax
	call	_xmlRelaxNGFreeParserCtxt

; 367  :     if (rng != NULL) {

	mov	esi, DWORD PTR _rng$1$[ebp]
	add	esp, 52					; 00000034H
	test	esi, esi
	je	SHORT $done$72

; 368  : 	test_log("Failed to detect incorect RNG line %ld\n",

	push	DWORD PTR _test$1$[ebp]
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@
	call	_test_log
	add	esp, 12					; 0000000cH

; 369  : 		    xmlGetLineNo(test));
; 370  :         ret = 1;

	mov	edi, 1
$done$72:

; 371  : 	goto done;
; 372  :     }
; 373  : 
; 374  : done:
; 375  :     if (buf != NULL)
; 376  : 	xmlBufferFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufferFree
	add	esp, 4

; 377  :     if (rng != NULL)

	test	esi, esi
	je	SHORT $LN48@xsdTestCas

; 378  :         xmlRelaxNGFree(rng);

	push	esi
	call	_xmlRelaxNGFree
	add	esp, 4
$LN48@xsdTestCas:

; 379  :     xmlResetLastError();

	call	_xmlResetLastError

; 380  :     if ((memt < xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	mov	esi, DWORD PTR _memt$1$[ebp]
	cmp	esi, eax
	jge	SHORT $LN49@xsdTestCas
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN49@xsdTestCas

; 381  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, esi
	push	eax
	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 382  : 		xmlGetLineNo(cur), xmlMemUsed() - memt);
; 383  : 	nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN49@xsdTestCas:

; 474  :         return(xsdIncorectTestCase(tst));

	mov	eax, edi
	pop	edi

; 640  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xsdTestCas:

; 475  :     }
; 476  : 
; 477  :     test = getNext(cur, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	ebx
	call	_getNext
	mov	edi, eax
	add	esp, 8

; 478  :     if (test == NULL) {

	test	edi, edi
	jne	SHORT $LN9@xsdTestCas

; 479  :         fprintf(stderr, "Failed to find test in correct line %ld\n",

	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 480  : 	        xmlGetLineNo(cur));
; 481  :         return(1);

	lea	eax, DWORD PTR [edi+1]
	pop	edi

; 640  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xsdTestCas:

; 482  :     }
; 483  : 
; 484  :     memt = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memt$2$[ebp], eax

; 485  :     extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 486  :     /*
; 487  :      * dump the schemas to a buffer, then reparse it and compile the schemas
; 488  :      */
; 489  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	ebx, eax
	mov	DWORD PTR _buf$1$[ebp], ebx

; 490  :     if (buf == NULL) {

	test	ebx, ebx
	je	$LN70@xsdTestCas

; 491  :         fprintf(stderr, "out of memory !\n");
; 492  : 	fatalError();
; 493  :     }
; 494  :     xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	push	edi
	push	DWORD PTR [edi+32]
	push	ebx
	call	_xmlNodeDump

; 495  :     pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);

	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	_xmlRelaxNGNewMemParserCtxt
	mov	esi, eax

; 496  :     xmlRelaxNGSetParserErrors(pctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlRelaxNGSetParserErrors

; 497  :          (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 498  :          (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 499  : 	 pctxt);
; 500  :     rng = xmlRelaxNGParse(pctxt);

	push	esi
	call	_xmlRelaxNGParse

; 501  :     xmlRelaxNGFreeParserCtxt(pctxt);

	push	esi
	mov	DWORD PTR _rng$1$[ebp], eax
	call	_xmlRelaxNGFreeParserCtxt

; 502  :     if (extraMemoryFromResolver)

	mov	eax, DWORD PTR _memt$2$[ebp]
	xor	ecx, ecx
	add	esp, 52					; 00000034H
	cmp	DWORD PTR _extraMemoryFromResolver, ecx
	cmovne	eax, ecx
	mov	DWORD PTR _memt$2$[ebp], eax

; 503  :         memt = 0;
; 504  : 
; 505  :     if (rng == NULL) {

	cmp	DWORD PTR _rng$1$[ebp], ecx
	jne	SHORT $LN12@xsdTestCas

; 506  :         test_log("Failed to parse RNGtest line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CC@NJOGDFNA@Failed?5to?5parse?5RNGtest?5line?5?$CFl@
	call	_test_log
	add	esp, 12					; 0000000cH

; 507  : 	        xmlGetLineNo(test));
; 508  : 	nb_errors++;
; 509  :         ret = 1;

	mov	esi, 1
	inc	DWORD PTR _nb_errors

; 510  : 	goto done;

	jmp	$done$73
$LN12@xsdTestCas:

; 511  :     }
; 512  :     /*
; 513  :      * now scan all the siblings of correct to process the <valid> tests
; 514  :      */
; 515  :     tmp = getNext(cur, "following-sibling::valid[1]");

	push	OFFSET ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
	push	DWORD PTR _cur$1$[ebp]
	call	_getNext
	mov	edi, eax
	add	esp, 8

; 516  :     while (tmp != NULL) {

	test	edi, edi
	je	$LN3@xsdTestCas
	npad	6
$LL2@xsdTestCas:

; 517  : 	dtd = xmlGetProp(tmp, BAD_CAST "dtd");

	push	OFFSET ??_C@_03DIJGCOJI@dtd@
	push	edi
	call	_xmlGetProp

; 518  : 	test = getNext(tmp, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	edi
	mov	ebx, eax
	call	_getNext
	add	esp, 16					; 00000010H
	mov	DWORD PTR _test$2$[ebp], eax

; 519  : 	if (test == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xsdTestCas

; 520  : 	    fprintf(stderr, "Failed to find test in <valid> line %ld\n",

	push	edi
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CJ@OBKFIGCD@Failed?5to?5find?5test?5in?5?$DMvalid?$DO?5@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 521  : 		    xmlGetLineNo(tmp));
; 522  : 
; 523  : 	} else {

	jmp	$LN21@xsdTestCas
$LN13@xsdTestCas:

; 524  : 	    xmlBufferEmpty(buf);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	esi
	call	_xmlBufferEmpty
	add	esp, 4

; 525  : 	    if (dtd != NULL)

	test	ebx, ebx
	je	SHORT $LN15@xsdTestCas

; 526  : 		xmlBufferAdd(buf, dtd, -1);

	push	-1
	push	ebx
	push	esi
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN15@xsdTestCas:

; 527  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	mov	eax, DWORD PTR _test$2$[ebp]
	push	0
	push	0
	push	eax
	push	DWORD PTR [eax+32]
	push	esi
	call	_xmlNodeDump

; 528  : 
; 529  : 	    /*
; 530  : 	     * We are ready to run the test
; 531  : 	     */
; 532  : 	    mem = xmlMemUsed();

	call	_xmlMemUsed

; 533  : 	    extraMemoryFromResolver = 0;
; 534  :             doc = xmlReadMemory((const char *)buf->content, buf->use,

	push	0
	push	0
	push	OFFSET ??_C@_04CEJDCDCH@test@
	push	DWORD PTR [esi+4]
	mov	DWORD PTR _mem$1$[ebp], eax
	push	DWORD PTR [esi]
	mov	DWORD PTR _extraMemoryFromResolver, 0
	call	_xmlReadMemory
	add	esp, 40					; 00000028H
	mov	DWORD PTR _doc$1$[ebp], eax

; 535  : 	                        "test", NULL, 0);
; 536  : 	    if (doc == NULL) {

	test	eax, eax
	jne	SHORT $LN16@xsdTestCas

; 537  : 		test_log("Failed to parse valid instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 538  : 			xmlGetLineNo(tmp));
; 539  : 		nb_errors++;

	inc	DWORD PTR _nb_errors

; 540  : 	    } else {

	jmp	SHORT $LN17@xsdTestCas
$LN16@xsdTestCas:

; 541  : 		nb_tests++;
; 542  : 	        ctxt = xmlRelaxNGNewValidCtxt(rng);

	push	DWORD PTR _rng$1$[ebp]
	inc	DWORD PTR _nb_tests
	call	_xmlRelaxNGNewValidCtxt
	mov	esi, eax

; 543  : 		xmlRelaxNGSetValidErrors(ctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlRelaxNGSetValidErrors

; 544  : 		     (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 545  : 		     (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 546  : 		     ctxt);
; 547  : 		ret = xmlRelaxNGValidateDoc(ctxt, doc);

	push	DWORD PTR _doc$1$[ebp]
	push	esi
	call	_xmlRelaxNGValidateDoc

; 548  : 		xmlRelaxNGFreeValidCtxt(ctxt);

	push	esi
	mov	DWORD PTR _ret$1$[ebp], eax
	call	_xmlRelaxNGFreeValidCtxt

; 549  : 		if (ret > 0) {

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	jle	SHORT $LN66@xsdTestCas

; 550  : 		    test_log("Failed to validate valid instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CM@HILILNIM@Failed?5to?5validate?5valid?5instan@

; 551  : 				xmlGetLineNo(tmp));
; 552  : 		    nb_errors++;

	jmp	SHORT $LN67@xsdTestCas
$LN66@xsdTestCas:

; 553  : 		} else if (ret < 0) {

	jns	SHORT $LN20@xsdTestCas

; 554  : 		    test_log("Internal error validating instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
$LN67@xsdTestCas:

; 555  : 			    xmlGetLineNo(tmp));
; 556  : 		    nb_errors++;
; 557  : 		}
; 558  : 		xmlFreeDoc(doc);

	call	_test_log
	add	esp, 12					; 0000000cH
	inc	DWORD PTR _nb_errors
$LN20@xsdTestCas:
	push	DWORD PTR _doc$1$[ebp]
	call	_xmlFreeDoc
	add	esp, 4
$LN17@xsdTestCas:

; 559  : 	    }
; 560  : 	    xmlResetLastError();

	call	_xmlResetLastError

; 561  : 	    if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	mov	esi, DWORD PTR _mem$1$[ebp]
	cmp	esi, eax
	je	SHORT $LN21@xsdTestCas
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN21@xsdTestCas

; 562  : 	        test_log("Validation of instance line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, esi
	push	eax
	push	edi
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
	call	_test_log
	add	esp, 12					; 0000000cH

; 563  : 		        xmlGetLineNo(tmp), xmlMemUsed() - mem);
; 564  : 		xmlMemoryDump();

	call	_xmlMemoryDump

; 565  : 	        nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN21@xsdTestCas:

; 566  : 	    }
; 567  : 	}
; 568  : 	if (dtd != NULL)

	test	ebx, ebx
	je	SHORT $LN22@xsdTestCas

; 569  : 	    xmlFree(dtd);

	mov	eax, DWORD PTR __imp__xmlFree
	push	ebx
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN22@xsdTestCas:

; 570  : 	tmp = getNext(tmp, "following-sibling::valid[1]");

	push	OFFSET ??_C@_0BM@BOGBCHLM@following?9sibling?3?3valid?$FL1?$FN@
	push	edi
	call	_getNext
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	$LL2@xsdTestCas
	mov	ebx, DWORD PTR _buf$1$[ebp]
$LN3@xsdTestCas:

; 571  :     }
; 572  :     /*
; 573  :      * now scan all the siblings of correct to process the <invalid> tests
; 574  :      */
; 575  :     tmp = getNext(cur, "following-sibling::invalid[1]");

	push	OFFSET ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
	push	DWORD PTR _cur$1$[ebp]
	call	_getNext
	mov	edi, eax
	add	esp, 8

; 576  :     while (tmp != NULL) {

	test	edi, edi
	je	$LN64@xsdTestCas
	npad	2
$LL4@xsdTestCas:

; 577  : 	test = getNext(tmp, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	edi
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 578  : 	if (test == NULL) {

	test	esi, esi
	jne	SHORT $LN23@xsdTestCas

; 579  : 	    fprintf(stderr, "Failed to find test in <invalid> line %ld\n",

	push	edi
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@OLCIMLMA@Failed?5to?5find?5test?5in?5?$DMinvalid@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 580  : 		    xmlGetLineNo(tmp));
; 581  : 
; 582  : 	} else {

	jmp	$LN30@xsdTestCas
$LN23@xsdTestCas:

; 583  : 	    xmlBufferEmpty(buf);

	push	ebx
	call	_xmlBufferEmpty

; 584  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	push	esi
	push	DWORD PTR [esi+32]
	push	ebx
	call	_xmlNodeDump

; 585  : 
; 586  : 	    /*
; 587  : 	     * We are ready to run the test
; 588  : 	     */
; 589  : 	    mem = xmlMemUsed();

	call	_xmlMemUsed

; 590  : 	    extraMemoryFromResolver = 0;
; 591  :             doc = xmlReadMemory((const char *)buf->content, buf->use,

	push	0
	push	0
	push	OFFSET ??_C@_04CEJDCDCH@test@
	push	DWORD PTR [ebx+4]
	mov	esi, eax
	mov	DWORD PTR _extraMemoryFromResolver, 0
	push	DWORD PTR [ebx]
	mov	DWORD PTR _mem$2$[ebp], esi
	call	_xmlReadMemory
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _doc$2$[ebp], eax

; 592  : 	                        "test", NULL, 0);
; 593  : 	    if (doc == NULL) {

	test	eax, eax
	jne	SHORT $LN25@xsdTestCas

; 594  : 		test_log("Failed to parse valid instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CJ@HBAOOEGJ@Failed?5to?5parse?5valid?5instance?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 595  : 			xmlGetLineNo(tmp));
; 596  : 		nb_errors++;

	inc	DWORD PTR _nb_errors

; 597  : 	    } else {

	jmp	SHORT $LN26@xsdTestCas
$LN25@xsdTestCas:

; 598  : 		nb_tests++;
; 599  : 	        ctxt = xmlRelaxNGNewValidCtxt(rng);

	push	DWORD PTR _rng$1$[ebp]
	inc	DWORD PTR _nb_tests
	call	_xmlRelaxNGNewValidCtxt
	mov	esi, eax

; 600  : 		xmlRelaxNGSetValidErrors(ctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlRelaxNGSetValidErrors

; 601  : 		     (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 602  : 		     (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 603  : 		     ctxt);
; 604  : 		ret = xmlRelaxNGValidateDoc(ctxt, doc);

	push	DWORD PTR _doc$2$[ebp]
	push	esi
	call	_xmlRelaxNGValidateDoc

; 605  : 		xmlRelaxNGFreeValidCtxt(ctxt);

	push	esi
	mov	DWORD PTR _ret$1$[ebp], eax
	call	_xmlRelaxNGFreeValidCtxt

; 606  : 		if (ret == 0) {

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN68@xsdTestCas

; 607  : 		    test_log("Failed to detect invalid instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CM@HLHCNDD@Failed?5to?5detect?5invalid?5instan@

; 608  : 				xmlGetLineNo(tmp));
; 609  : 		    nb_errors++;

	jmp	SHORT $LN69@xsdTestCas
$LN68@xsdTestCas:

; 610  : 		} else if (ret < 0) {

	jns	SHORT $LN29@xsdTestCas

; 611  : 		    test_log("Internal error validating instance line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CN@MNFDEAFF@Internal?5error?5validating?5insta@
$LN69@xsdTestCas:

; 612  : 			    xmlGetLineNo(tmp));
; 613  : 		    nb_errors++;
; 614  : 		}
; 615  : 		xmlFreeDoc(doc);

	call	_test_log
	add	esp, 12					; 0000000cH
	inc	DWORD PTR _nb_errors
$LN29@xsdTestCas:
	push	DWORD PTR _doc$2$[ebp]
	call	_xmlFreeDoc
	mov	esi, DWORD PTR _mem$2$[ebp]
	add	esp, 4
$LN26@xsdTestCas:

; 616  : 	    }
; 617  : 	    xmlResetLastError();

	call	_xmlResetLastError

; 618  : 	    if ((mem != xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	cmp	esi, eax
	je	SHORT $LN30@xsdTestCas
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN30@xsdTestCas

; 619  : 	        test_log("Validation of instance line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, esi
	push	eax
	push	edi
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CL@CHMJIAMO@Validation?5of?5instance?5line?5?$CFld@
	call	_test_log
	add	esp, 12					; 0000000cH

; 620  : 		        xmlGetLineNo(tmp), xmlMemUsed() - mem);
; 621  : 		xmlMemoryDump();

	call	_xmlMemoryDump

; 622  : 	        nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN30@xsdTestCas:

; 623  : 	    }
; 624  : 	}
; 625  : 	tmp = getNext(tmp, "following-sibling::invalid[1]");

	push	OFFSET ??_C@_0BO@EOANKJHM@following?9sibling?3?3invalid?$FL1?$FN@
	push	edi
	call	_getNext
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	$LL4@xsdTestCas
$LN64@xsdTestCas:

; 626  :     }
; 627  : 
; 628  : done:
; 629  :     if (buf != NULL)
; 630  : 	xmlBufferFree(buf);

	mov	esi, DWORD PTR _ret$1$[ebp]
$done$73:
	push	ebx
	call	_xmlBufferFree

; 631  :     if (rng != NULL)

	mov	eax, DWORD PTR _rng$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@xsdTestCas

; 632  :         xmlRelaxNGFree(rng);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4
$LN32@xsdTestCas:

; 633  :     xmlResetLastError();

	call	_xmlResetLastError

; 634  :     if ((memt != xmlMemUsed()) && (memt != 0)) {

	call	_xmlMemUsed
	mov	ebx, DWORD PTR _memt$2$[ebp]
	cmp	ebx, eax
	je	SHORT $LN33@xsdTestCas
	test	ebx, ebx
	je	SHORT $LN33@xsdTestCas

; 635  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, ebx
	push	eax
	push	DWORD PTR _cur$1$[ebp]
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 636  : 		xmlGetLineNo(cur), xmlMemUsed() - memt);
; 637  : 	nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN33@xsdTestCas:

; 638  :     }
; 639  :     return(ret);

	pop	edi
	mov	eax, esi

; 640  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xsdTestCas:
	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8
	call	_fatalError
$LN65@xsdTestCas:
	int	3
_xsdTestCase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _installDirs
_TEXT	SEGMENT
_buf$1 = -500						; size = 500
_tst$ = 8						; size = 4
_base$ = 12						; size = 4
_installDirs PROC					; COMDAT

; 424  : installDirs(xmlNodePtr tst, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	push	ebx

; 425  :     xmlNodePtr test;
; 426  :     xmlChar *name, *res;
; 427  : 
; 428  :     name = getString(tst, "string(@name)");

	mov	ebx, DWORD PTR _tst$[ebp]
	push	esi
	push	OFFSET ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
	push	ebx
	call	_getString
	mov	esi, eax
	add	esp, 8

; 429  :     if (name == NULL)

	test	esi, esi
	je	$LN1@installDir

; 96   :     if (dir == NULL) return(xmlStrdup(path));

	mov	eax, DWORD PTR _base$[ebp]
	test	eax, eax
	jne	SHORT $LN9@installDir
	mov	eax, esi
	jmp	SHORT $LN8@installDir
$LN9@installDir:

; 97   :     if (path == NULL) return(NULL);
; 98   : 
; 99   :     snprintf(buf, 500, "%s/%s", (const char *) dir, (const char *) path);

	push	esi
	push	eax
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 100  :     return(xmlStrdup((const xmlChar *) buf));

	lea	eax, DWORD PTR _buf$1[ebp]
$LN8@installDir:
	push	edi

; 430  :         return;
; 431  :     res = composeDir(base, name);
; 432  :     xmlFree(name);

	push	eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edi, eax
	push	esi
	mov	ecx, DWORD PTR [ecx]
	call	ecx
	add	esp, 8

; 433  :     if (res == NULL) {

	test	edi, edi
	je	SHORT $LN16@installDir

; 434  : 	return;
; 435  :     }
; 436  :     /* Now process resources and subdir recursively */
; 437  :     test = getNext(tst, "./resource[1]");

	push	OFFSET ??_C@_0O@LNKGJPHN@?4?1resource?$FL1?$FN@
	push	ebx
	call	_getNext
	add	esp, 8

; 438  :     if (test != NULL) {

	test	eax, eax
	je	SHORT $LN6@installDir

; 439  :         installResources(test, res);

	push	edi
	push	eax
	call	_installResources
	add	esp, 8
$LN6@installDir:

; 440  :     }
; 441  :     test = getNext(tst, "./dir[1]");

	push	OFFSET ??_C@_08JGDDGDEM@?4?1dir?$FL1?$FN@
	push	ebx
	call	_getNext
	mov	esi, eax
	add	esp, 8

; 442  :     while (test != NULL) {

	test	esi, esi
	je	SHORT $LN3@installDir
	npad	3
$LL2@installDir:

; 443  :         installDirs(test, res);

	push	edi
	push	esi
	call	_installDirs

; 444  : 	test = getNext(test, "following-sibling::dir[1]");

	push	OFFSET ??_C@_0BK@JBEJBKGG@following?9sibling?3?3dir?$FL1?$FN@
	push	esi
	call	_getNext
	mov	esi, eax
	add	esp, 16					; 00000010H
	test	esi, esi
	jne	SHORT $LL2@installDir
$LN3@installDir:

; 445  :     }
; 446  :     xmlFree(res);

	mov	eax, DWORD PTR __imp__xmlFree
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN16@installDir:
	pop	edi
$LN1@installDir:
	pop	esi

; 447  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_installDirs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _installResources
_TEXT	SEGMENT
_buf$1 = -508						; size = 500
_buf$1$ = -8						; size = 4
tv512 = -4						; size = 4
_comp$1$ = -4						; size = 4
_comp$1$ = -4						; size = 4
_tst$ = 8						; size = 4
_base$ = 12						; size = 4
_installResources PROC					; COMDAT

; 389  : installResources(xmlNodePtr tst, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 508				; 000001fcH

; 390  :     xmlNodePtr test;
; 391  :     xmlBufferPtr buf;
; 392  :     xmlChar *name, *content, *res;
; 393  : 
; 394  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buf$1$[ebp], eax

; 395  :     if (buf == NULL) {

	test	eax, eax
	je	$LN53@installRes

; 398  :     }
; 399  :     xmlNodeDump(buf, tst->doc, tst, 0, 0);

	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _tst$[ebp]
	push	0
	push	0
	push	edi
	push	DWORD PTR [edi+32]
	push	eax
	call	_xmlNodeDump
	add	esp, 20					; 00000014H
$LN50@installRes:

; 270  :     xmlNodePtr ret = NULL;

	mov	esi, DWORD PTR __imp____acrt_iob_func
	xor	ebx, ebx

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	edi, edi
	je	$LN9@installRes
	mov	ecx, DWORD PTR [edi+32]
	test	ecx, ecx
	je	$LN9@installRes

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	call	_xmlXPathCompile
	add	esp, 4
	mov	DWORD PTR _comp$1$[ebp], eax

; 279  :     if (comp == NULL) {

	test	eax, eax
	jne	SHORT $LN15@installRes

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	esi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 281  : 	return(NULL);

	jmp	$LN9@installRes
$LN15@installRes:

; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	eax
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	DWORD PTR _comp$1$[ebp]
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	$LN48@installRes

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN17@installRes
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN17@installRes
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN17@installRes
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN17@installRes

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	ebx, DWORD PTR [eax]
$LN17@installRes:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 402  : 	test = getNext(tst, "./*");
; 403  : 	if (test != NULL) {

	test	ebx, ebx
	je	$LN48@installRes

; 404  : 	    xmlBufferEmpty(buf);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	esi
	call	_xmlBufferEmpty

; 405  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	push	ebx
	push	DWORD PTR [ebx+32]
	push	esi
	call	_xmlNodeDump

; 302  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	mov	ecx, DWORD PTR [edi+32]

; 405  : 	    xmlNodeDump(buf, test->doc, test, 0, 0);

	add	esp, 24					; 00000018H

; 298  :     xmlChar *ret = NULL;

	xor	esi, esi

; 299  :     xmlXPathObjectPtr res;
; 300  :     xmlXPathCompExprPtr comp;
; 301  : 
; 302  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	ecx, ecx
	je	SHORT $LN21@installRes

; 303  :         return(NULL);
; 304  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 305  :     ctxtXPath->node = cur;
; 306  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	call	_xmlXPathCompile
	add	esp, 4
	mov	DWORD PTR _comp$1$[ebp], eax

; 307  :     if (comp == NULL) {

	test	eax, eax
	jne	SHORT $LN22@installRes

; 308  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_0O@ONOBOMHP@string?$CI?$EAname?$CJ@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN21@installRes:

; 406  : 	    name = getString(tst, "string(@name)");
; 407  : 	    content = xmlStrdup(buf->content);

	xor	esi, esi
$LN19@installRes:
	mov	eax, DWORD PTR _buf$1$[ebp]
	push	DWORD PTR [eax]
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax

; 408  : 	    if ((name != NULL) && (content != NULL)) {

	test	esi, esi
	je	$LN8@installRes
	test	ebx, ebx
	je	$LN6@installRes

; 96   :     if (dir == NULL) return(xmlStrdup(path));

	mov	eax, DWORD PTR _base$[ebp]
	test	eax, eax
	jne	SHORT $LN27@installRes
	mov	eax, esi
	jmp	SHORT $LN26@installRes
$LN22@installRes:

; 311  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	eax
	call	_xmlXPathCompiledEval

; 312  :     xmlXPathFreeCompExpr(comp);

	push	DWORD PTR _comp$1$[ebp]
	mov	ebx, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 313  :     if (res == NULL)

	test	ebx, ebx
	je	SHORT $LN21@installRes

; 314  :         return(NULL);
; 315  :     if (res->type == XPATH_STRING) {

	cmp	DWORD PTR [ebx], 4
	jne	SHORT $LN24@installRes

; 316  :         ret = res->stringval;

	mov	esi, DWORD PTR [ebx+24]

; 317  : 	res->stringval = NULL;

	mov	DWORD PTR [ebx+24], 0
$LN24@installRes:

; 318  :     }
; 319  :     xmlXPathFreeObject(res);

	push	ebx
	call	_xmlXPathFreeObject
	add	esp, 4

; 320  :     return(ret);

	jmp	SHORT $LN19@installRes
$LN27@installRes:

; 99   :     snprintf(buf, 500, "%s/%s", (const char *) dir, (const char *) path);

	push	esi
	push	eax
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 100  :     return(xmlStrdup((const xmlChar *) buf));

	lea	eax, DWORD PTR _buf$1[ebp]
$LN26@installRes:

; 409  : 	        res = composeDir(base, name);
; 410  : 		xmlFree(name);

	push	eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR __imp__xmlFree
	push	esi
	mov	DWORD PTR tv512[ebp], eax
	mov	ecx, DWORD PTR [ecx]
	call	ecx

; 142  :     if (nb_entities >= MAX_ENTITIES) {

	mov	ecx, DWORD PTR _nb_entities

; 409  : 	        res = composeDir(base, name);
; 410  : 		xmlFree(name);

	add	esp, 8

; 142  :     if (nb_entities >= MAX_ENTITIES) {

	mov	esi, DWORD PTR __imp____acrt_iob_func
	cmp	ecx, 20					; 00000014H
	jl	SHORT $LN31@installRes

; 143  : 	fprintf(stderr, "Too many entities defined\n");

	push	OFFSET ??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@
	push	2
	call	esi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 144  : 	return(-1);

	jmp	SHORT $LN9@installRes
$LN31@installRes:

; 145  :     }
; 146  :     testEntitiesName[nb_entities] = name;

	mov	eax, DWORD PTR tv512[ebp]
	mov	DWORD PTR _testEntitiesName[ecx*4], eax

; 147  :     testEntitiesValue[nb_entities] = content;

	mov	DWORD PTR _testEntitiesValue[ecx*4], ebx

; 148  :     nb_entities++;

	inc	ecx
	mov	DWORD PTR _nb_entities, ecx

; 411  : 	        addEntity((char *) res, (char *) content);
; 412  : 	    } else {

	jmp	SHORT $LN9@installRes
$LN6@installRes:

; 413  : 	        if (name != NULL) xmlFree(name);

	push	esi

; 414  : 	        if (content != NULL) xmlFree(content);

	jmp	SHORT $LN51@installRes
$LN8@installRes:
	test	ebx, ebx
	je	SHORT $LN48@installRes
	push	ebx
$LN51@installRes:

; 270  :     xmlNodePtr ret = NULL;

	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN48@installRes:
	mov	esi, DWORD PTR __imp____acrt_iob_func
$LN9@installRes:
	xor	ebx, ebx

; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	test	edi, edi
	je	$LN45@installRes
	mov	ecx, DWORD PTR [edi+32]
	test	ecx, ecx
	je	SHORT $LN45@installRes

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	OFFSET ??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	call	_xmlXPathCompile
	mov	edi, eax
	add	esp, 4

; 279  :     if (comp == NULL) {

	test	edi, edi
	je	SHORT $LN44@installRes

; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	edi
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	edi
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN45@installRes

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN38@installRes
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN38@installRes
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN38@installRes
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN38@installRes

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	ebx, DWORD PTR [eax]
$LN38@installRes:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	edi, ebx

; 400  : 
; 401  :     while (tst != NULL) {

	test	ebx, ebx
	je	SHORT $LN45@installRes
	jmp	$LN50@installRes
$LN44@installRes:

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	OFFSET ??_C@_0BP@DGMHDMIP@following?9sibling?3?3resource?$FL1?$FN@
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	esi
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN45@installRes:

; 415  : 	    }
; 416  : 	}
; 417  : 	tst = getNext(tst, "following-sibling::resource[1]");
; 418  :     }
; 419  :     if (buf != NULL)
; 420  : 	xmlBufferFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufferFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 421  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@installRes:

; 396  :         fprintf(stderr, "out of memory !\n");

	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 397  : 	fatalError();

	call	_fatalError
$LN49@installRes:
	int	3
_installResources ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _xsdIncorectTestCase
_TEXT	SEGMENT
_memt$1$ = -8						; size = 4
_buf$1$ = -4						; size = 4
_rng$1$ = 8						; size = 4
_cur$ = 8						; size = 4
_xsdIncorectTestCase PROC				; COMDAT

; 330  : xsdIncorectTestCase(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi

; 331  :     xmlNodePtr test;
; 332  :     xmlBufferPtr buf;
; 333  :     xmlRelaxNGParserCtxtPtr pctxt;
; 334  :     xmlRelaxNGPtr rng = NULL;
; 335  :     int ret = 0, memt;
; 336  : 
; 337  :     cur = getNext(cur, "./incorrect[1]");

	push	OFFSET ??_C@_0P@CKJJNHKD@?4?1incorrect?$FL1?$FN@
	push	DWORD PTR _cur$[ebp]
	call	_getNext
	mov	edi, eax
	add	esp, 8

; 338  :     if (cur == NULL) {

	test	edi, edi
	jne	SHORT $LN2@xsdIncorec
	pop	edi

; 386  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xsdIncorec:
	push	ebx

; 339  :         return(0);
; 340  :     }
; 341  : 
; 342  :     test = getNext(cur, "./*");

	push	OFFSET ??_C@_03MCCMDFBL@?4?1?$CK@
	push	edi
	call	_getNext
	mov	ebx, eax
	add	esp, 8

; 343  :     if (test == NULL) {

	test	ebx, ebx
	jne	SHORT $LN3@xsdIncorec

; 344  :         test_log("Failed to find test in correct line %ld\n",

	push	edi
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CJ@BODPNGCB@Failed?5to?5find?5test?5in?5correct?5@
	call	_test_log
	add	esp, 12					; 0000000cH

; 345  : 	        xmlGetLineNo(cur));
; 346  :         return(1);

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx
	pop	edi

; 386  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xsdIncorec:
	push	esi

; 347  :     }
; 348  : 
; 349  :     memt = xmlMemUsed();

	call	_xmlMemUsed
	mov	DWORD PTR _memt$1$[ebp], eax

; 350  :     extraMemoryFromResolver = 0;

	mov	DWORD PTR _extraMemoryFromResolver, 0

; 351  :     /*
; 352  :      * dump the schemas to a buffer, then reparse it and compile the schemas
; 353  :      */
; 354  :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	esi, eax
	mov	DWORD PTR _buf$1$[ebp], esi

; 355  :     if (buf == NULL) {

	test	esi, esi
	je	$LN14@xsdIncorec

; 358  :     }
; 359  :     xmlNodeDump(buf, test->doc, test, 0, 0);

	push	0
	push	0
	push	ebx
	push	DWORD PTR [ebx+32]
	push	esi
	call	_xmlNodeDump

; 360  :     pctxt = xmlRelaxNGNewMemParserCtxt((const char *)buf->content, buf->use);

	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	_xmlRelaxNGNewMemParserCtxt
	mov	esi, eax

; 361  :     xmlRelaxNGSetParserErrors(pctxt,

	push	esi
	push	OFFSET _testErrorHandler
	push	OFFSET _testErrorHandler
	push	esi
	call	_xmlRelaxNGSetParserErrors

; 362  :          (xmlRelaxNGValidityErrorFunc) testErrorHandler,
; 363  :          (xmlRelaxNGValidityWarningFunc) testErrorHandler,
; 364  : 	 pctxt);
; 365  :     rng = xmlRelaxNGParse(pctxt);

	push	esi
	call	_xmlRelaxNGParse

; 366  :     xmlRelaxNGFreeParserCtxt(pctxt);

	push	esi
	mov	DWORD PTR _rng$1$[ebp], eax
	call	_xmlRelaxNGFreeParserCtxt

; 367  :     if (rng != NULL) {

	mov	esi, DWORD PTR _rng$1$[ebp]
	add	esp, 52					; 00000034H
	test	esi, esi
	je	SHORT $LN10@xsdIncorec

; 368  : 	test_log("Failed to detect incorect RNG line %ld\n",

	push	ebx
	call	_xmlGetLineNo
	push	eax
	push	OFFSET ??_C@_0CI@DKMJCAPB@Failed?5to?5detect?5incorect?5RNG?5l@
	call	_test_log
	add	esp, 12					; 0000000cH

; 369  : 		    xmlGetLineNo(test));
; 370  :         ret = 1;

	mov	ebx, 1
	jmp	SHORT $done$15
$LN10@xsdIncorec:

; 367  :     if (rng != NULL) {

	xor	ebx, ebx
$done$15:

; 371  : 	goto done;
; 372  :     }
; 373  : 
; 374  : done:
; 375  :     if (buf != NULL)
; 376  : 	xmlBufferFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufferFree
	add	esp, 4

; 377  :     if (rng != NULL)

	test	esi, esi
	je	SHORT $LN7@xsdIncorec

; 378  :         xmlRelaxNGFree(rng);

	push	esi
	call	_xmlRelaxNGFree
	add	esp, 4
$LN7@xsdIncorec:

; 379  :     xmlResetLastError();

	call	_xmlResetLastError

; 380  :     if ((memt < xmlMemUsed()) && (extraMemoryFromResolver == 0)) {

	call	_xmlMemUsed
	mov	esi, DWORD PTR _memt$1$[ebp]
	cmp	esi, eax
	jge	SHORT $LN8@xsdIncorec
	cmp	DWORD PTR _extraMemoryFromResolver, 0
	jne	SHORT $LN8@xsdIncorec

; 381  : 	test_log("Validation of tests starting line %ld leaked %d\n",

	call	_xmlMemUsed
	sub	eax, esi
	push	eax
	push	edi
	call	_xmlGetLineNo
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@KOEBBOFA@Validation?5of?5tests?5starting?5li@
	call	_test_log
	add	esp, 12					; 0000000cH

; 382  : 		xmlGetLineNo(cur), xmlMemUsed() - memt);
; 383  : 	nb_leaks++;

	inc	DWORD PTR _nb_leaks
$LN8@xsdIncorec:

; 384  :     }
; 385  :     return(ret);

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	edi

; 386  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xsdIncorec:

; 356  :         fprintf(stderr, "out of memory !\n");

	push	OFFSET ??_C@_0BB@NKPLANIP@out?5of?5memory?5?$CB?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 357  : 	fatalError();

	call	_fatalError
$LN12@xsdIncorec:
	int	3
_xsdIncorectTestCase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _getString
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xpath$ = 12						; size = 4
_getString PROC						; COMDAT

; 297  : getString(xmlNodePtr cur, const char *xpath) {

	push	ebp
	mov	ebp, esp

; 298  :     xmlChar *ret = NULL;
; 299  :     xmlXPathObjectPtr res;
; 300  :     xmlXPathCompExprPtr comp;
; 301  : 
; 302  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN3@getString
	mov	edx, DWORD PTR [ecx+32]
	test	edx, edx
	je	SHORT $LN3@getString
	mov	esi, DWORD PTR _xpath$[ebp]
	test	esi, esi
	je	SHORT $LN3@getString

; 303  :         return(NULL);
; 304  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 305  :     ctxtXPath->node = cur;
; 306  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	call	_xmlXPathCompile
	mov	ebx, eax
	add	esp, 4

; 307  :     if (comp == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@getString

; 308  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	esi
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN3@getString:

; 321  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN4@getString:

; 309  : 	return(NULL);
; 310  :     }
; 311  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	ebx
	call	_xmlXPathCompiledEval

; 312  :     xmlXPathFreeCompExpr(comp);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 313  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN3@getString

; 314  :         return(NULL);
; 315  :     if (res->type == XPATH_STRING) {

	cmp	DWORD PTR [esi], 4
	jne	SHORT $LN6@getString

; 316  :         ret = res->stringval;

	mov	edi, DWORD PTR [esi+24]

; 317  : 	res->stringval = NULL;

	mov	DWORD PTR [esi+24], 0
$LN6@getString:

; 318  :     }
; 319  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 320  :     return(ret);

	mov	eax, edi
	pop	edi

; 321  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_getString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _getNext
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xpath$ = 12						; size = 4
_getNext PROC						; COMDAT

; 269  : getNext(xmlNodePtr cur, const char *xpath) {

	push	ebp
	mov	ebp, esp

; 270  :     xmlNodePtr ret = NULL;
; 271  :     xmlXPathObjectPtr res;
; 272  :     xmlXPathCompExprPtr comp;
; 273  : 
; 274  :     if ((cur == NULL)  || (cur->doc == NULL) || (xpath == NULL))

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN3@getNext
	mov	edx, DWORD PTR [ecx+32]
	test	edx, edx
	je	SHORT $LN3@getNext
	mov	esi, DWORD PTR _xpath$[ebp]
	test	esi, esi
	je	SHORT $LN3@getNext

; 275  :         return(NULL);
; 276  :     ctxtXPath->doc = cur->doc;

	mov	eax, DWORD PTR _ctxtXPath

; 277  :     ctxtXPath->node = cur;
; 278  :     comp = xmlXPathCompile(BAD_CAST xpath);

	push	esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	call	_xmlXPathCompile
	mov	ebx, eax
	add	esp, 4

; 279  :     if (comp == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@getNext

; 280  :         fprintf(stderr, "Failed to compile %s\n", xpath);

	push	esi
	push	OFFSET ??_C@_0BG@NHDHPLMD@Failed?5to?5compile?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN3@getNext:

; 294  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN4@getNext:

; 281  : 	return(NULL);
; 282  :     }
; 283  :     res = xmlXPathCompiledEval(comp, ctxtXPath);

	push	DWORD PTR _ctxtXPath
	push	ebx
	call	_xmlXPathCompiledEval

; 284  :     xmlXPathFreeCompExpr(comp);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeCompExpr
	add	esp, 12					; 0000000cH

; 285  :     if (res == NULL)

	test	esi, esi
	je	SHORT $LN3@getNext

; 286  :         return(NULL);
; 287  :     if ((res->type == XPATH_NODESET) &&
; 288  :         (res->nodesetval != NULL) &&
; 289  : 	(res->nodesetval->nodeNr > 0) &&

	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN6@getNext
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@getNext
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN6@getNext
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN6@getNext

; 290  : 	(res->nodesetval->nodeTab != NULL))
; 291  : 	ret = res->nodesetval->nodeTab[0];

	mov	edi, DWORD PTR [eax]
$LN6@getNext:

; 292  :     xmlXPathFreeObject(res);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 293  :     return(ret);

	mov	eax, edi
	pop	edi

; 294  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_getNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _initializeLibxml2
_TEXT	SEGMENT
_initializeLibxml2 PROC					; COMDAT

; 240  :     xmlGetWarningsDefaultValue = 0;

	call	___xmlGetWarningsDefaultValue

; 241  :     xmlPedanticParserDefault(0);

	push	0
	mov	DWORD PTR [eax], 0
	call	_xmlPedanticParserDefault

; 242  : 
; 243  :     xmlMemSetup(xmlMemFree, xmlMemMalloc, xmlMemRealloc, xmlMemoryStrdup);

	push	OFFSET _xmlMemoryStrdup
	push	OFFSET _xmlMemRealloc
	push	OFFSET _xmlMemMalloc
	push	OFFSET _xmlMemFree
	call	_xmlMemSetup

; 244  :     xmlInitParser();

	call	_xmlInitParser

; 245  :     xmlSetExternalEntityLoader(testExternalEntityLoader);

	push	OFFSET _testExternalEntityLoader
	call	_xmlSetExternalEntityLoader

; 246  :     ctxtXPath = xmlXPathNewContext(NULL);

	push	0
	call	_xmlXPathNewContext
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ctxtXPath, eax

; 247  :     /*
; 248  :     * Deactivate the cache if created; otherwise we have to create/free it
; 249  :     * for every test, since it will confuse the memory leak detection.
; 250  :     * Note that normally this need not be done, since the cache is not
; 251  :     * created until set explicitely with xmlXPathContextSetCache();
; 252  :     * but for test purposes it is sometimes usefull to activate the
; 253  :     * cache by default for the whole library.
; 254  :     */
; 255  :     if (ctxtXPath->cache != NULL)

	cmp	DWORD PTR [eax+200], 0
	je	SHORT $LN2@initialize

; 256  : 	xmlXPathContextSetCache(ctxtXPath, 0, -1, 0);

	push	0
	push	-1
	push	0
	push	eax
	call	_xmlXPathContextSetCache
	mov	eax, DWORD PTR _ctxtXPath
	add	esp, 16					; 00000010H
$LN2@initialize:

; 257  :     /* used as default nanemspace in xstc tests */
; 258  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "ts", BAD_CAST "TestSuite");

	push	OFFSET ??_C@_09DGPCOFBK@TestSuite@
	push	OFFSET ??_C@_02FHFEMMFE@ts@
	push	eax
	call	_xmlXPathRegisterNs

; 259  :     xmlXPathRegisterNs(ctxtXPath, BAD_CAST "xlink",

	push	OFFSET ??_C@_0BN@GKPMOOH@http?3?1?1www?4w3?4org?11999?1xlink@
	push	OFFSET ??_C@_05HHOAKHHD@xlink@
	push	DWORD PTR _ctxtXPath
	call	_xmlXPathRegisterNs

; 260  :                        BAD_CAST "http://www.w3.org/1999/xlink");
; 261  :     xmlSetGenericErrorFunc(NULL, testErrorHandler);

	push	OFFSET _testErrorHandler
	push	0
	call	_xmlSetGenericErrorFunc
	add	esp, 32					; 00000020H

; 262  : #ifdef LIBXML_SCHEMAS_ENABLED
; 263  :     xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes

; 264  :     xmlRelaxNGInitTypes();

	jmp	_xmlRelaxNGInitTypes
_initializeLibxml2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _testErrorHandler
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_testErrorHandler PROC					; COMDAT

; 215  : testErrorHandler(void *ctx  ATTRIBUTE_UNUSED, const char *msg, ...) {

	push	ebp
	mov	ebp, esp

; 216  :     va_list args;
; 217  :     int res;
; 218  : 
; 219  :     if (testErrorsSize >= 32768)

	mov	eax, DWORD PTR _testErrorsSize
	cmp	eax, 32768				; 00008000H
	jge	SHORT $LN1@testErrorH
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	lea	edx, DWORD PTR _msg$[ebp+4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 222  :     res = vsnprintf(&testErrors[testErrorsSize],

	mov	ecx, 32768				; 00008000H
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	push	edx
	push	0
	push	DWORD PTR _msg$[ebp]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 222  :     res = vsnprintf(&testErrors[testErrorsSize],

	sub	ecx, eax
	lea	eax, DWORD PTR _testErrors[eax]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	push	ecx
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 226  :     if (testErrorsSize + res >= 32768) {

	add	eax, DWORD PTR _testErrorsSize
	cmp	eax, 32768				; 00008000H
	jl	SHORT $LN4@testErrorH

; 227  :         /* buffer is full */
; 228  : 	testErrorsSize = 32768;
; 229  : 	testErrors[testErrorsSize] = 0;

	mov	BYTE PTR _testErrors+32768, 0
	mov	eax, 32768				; 00008000H
$LN4@testErrorH:

; 230  :     } else {
; 231  :         testErrorsSize += res;
; 232  :     }
; 233  :     testErrors[testErrorsSize] = 0;

	mov	DWORD PTR _testErrorsSize, eax
	mov	BYTE PTR _testErrors[eax], 0
$LN1@testErrorH:

; 234  : }

	pop	ebp
	ret	0
_testErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _test_log
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_test_log PROC						; COMDAT

; 197  : static void test_log(const char *msg, ...) {

	push	ebp
	mov	ebp, esp

; 198  :     va_list args;
; 199  :     if (logfile != NULL) {

	mov	eax, DWORD PTR _logfile
	test	eax, eax
	je	SHORT $LN2@test_log

; 200  :         fprintf(logfile, "\n------------\n");

	push	OFFSET ??_C@_0P@BFDMMPAI@?6?9?9?9?9?9?9?9?9?9?9?9?9?6@
	push	eax
	call	_fprintf
	add	esp, 8
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR _msg$[ebp]
	push	DWORD PTR _logfile
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 204  : 	fprintf(logfile, "%s", testErrors);

	push	OFFSET _testErrors
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR _logfile
	call	_fprintf
	add	esp, 36					; 00000024H

; 205  : 	testErrorsSize = 0; testErrors[0] = 0;

	mov	DWORD PTR _testErrorsSize, 0
	mov	BYTE PTR _testErrors, 0
$LN2@test_log:

; 206  :     }
; 207  :     if (verbose) {

	cmp	DWORD PTR _verbose, 0
	je	SHORT $LN3@test_log

; 208  : 	va_start(args, msg);
; 209  : 	vfprintf(stderr, msg, args);

	push	esi
	mov	esi, DWORD PTR _msg$[ebp]
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	eax
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	pop	esi
$LN3@test_log:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 212  : }

	pop	ebp
	ret	0
_test_log ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _testExternalEntityLoader
_TEXT	SEGMENT
_buf$1 = -48						; size = 48
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_testExternalEntityLoader PROC				; COMDAT

; 159  : 			 xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx

; 160  :     xmlParserInputPtr ret;
; 161  :     int i;
; 162  : 
; 163  :     for (i = 0;i < nb_entities;i++) {

	mov	ebx, DWORD PTR _nb_entities
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _URL$[ebp]
	test	ebx, ebx
	jle	SHORT $LN3@testExtern
	npad	8
$LL4@testExtern:

; 164  :         if (!strcmp(testEntitiesName[i], URL)) {

	mov	ecx, DWORD PTR _testEntitiesName[esi*4]
	mov	eax, edi
	npad	7
$LL22@testExtern:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN23@testExtern
	test	dl, dl
	je	SHORT $LN24@testExtern
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN23@testExtern
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL22@testExtern
$LN24@testExtern:
	xor	eax, eax
	jmp	SHORT $LN25@testExtern
$LN23@testExtern:
	sbb	eax, eax
	or	eax, 1
$LN25@testExtern:
	test	eax, eax
	je	SHORT $LN17@testExtern

; 160  :     xmlParserInputPtr ret;
; 161  :     int i;
; 162  : 
; 163  :     for (i = 0;i < nb_entities;i++) {

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@testExtern
$LN3@testExtern:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 79   :     if (stat(filename, &buf) == -1)

	cmp	eax, -1
	je	SHORT $LN7@testExtern

; 80   :         return(0);
; 81   : 
; 82   : #if defined(_WIN32) && !defined(__CYGWIN__)
; 83   :     if (!(buf.st_mode & _S_IFREG))

	test	DWORD PTR _buf$1[ebp+6], 32768		; 00008000H
	je	SHORT $LN7@testExtern

; 169  : 		                xmlStrdup((xmlChar *)testEntitiesName[i]);
; 170  : 	    }
; 171  : 	    return(ret);
; 172  : 	}
; 173  :     }
; 174  :     if (checkTestFile(URL)) {
; 175  : 	ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);

	push	DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _ID$[ebp]
	push	edi
	call	_xmlNoNetExternalEntityLoader
	add	esp, 12					; 0000000cH
	mov	edi, eax
	pop	edi

; 180  :     }
; 181  : #if 0
; 182  :     if (ret == NULL) {
; 183  :         fprintf(stderr, "Failed to find resource %s\n", URL);
; 184  :     }
; 185  : #endif
; 186  : 
; 187  :     return(ret);
; 188  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@testExtern:

; 165  : 	    ret = xmlNewStringInputStream(ctxt,

	push	DWORD PTR _testEntitiesValue[esi*4]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlNewStringInputStream
	mov	edi, eax
	add	esp, 8

; 166  : 	                (const xmlChar *) testEntitiesValue[i]);
; 167  : 	    if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN8@testExtern

; 168  : 	        ret->filename = (const char *)

	push	DWORD PTR _testEntitiesName[esi*4]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+4], eax

; 180  :     }
; 181  : #if 0
; 182  :     if (ret == NULL) {
; 183  :         fprintf(stderr, "Failed to find resource %s\n", URL);
; 184  :     }
; 185  : #endif
; 186  : 
; 187  :     return(ret);
; 188  : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@testExtern:

; 176  :     } else {
; 177  : 	int memused = xmlMemUsed();

	call	_xmlMemUsed

; 178  : 	ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);

	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	push	DWORD PTR _ID$[ebp]
	push	edi
	call	_xmlNoNetExternalEntityLoader
	add	esp, 12					; 0000000cH
	mov	edi, eax

; 179  : 	extraMemoryFromResolver += xmlMemUsed() - memused;

	call	_xmlMemUsed
	sub	eax, esi
	add	DWORD PTR _extraMemoryFromResolver, eax
$LN8@testExtern:

; 180  :     }
; 181  : #if 0
; 182  :     if (ret == NULL) {
; 183  :         fprintf(stderr, "Failed to find resource %s\n", URL);
; 184  :     }
; 185  : #endif
; 186  : 
; 187  :     return(ret);
; 188  : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_testExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _addEntity
_TEXT	SEGMENT
_name$ = 8						; size = 4
_content$ = 12						; size = 4
_addEntity PROC						; COMDAT

; 141  : static int addEntity(char *name, char *content) {

	push	ebp
	mov	ebp, esp

; 142  :     if (nb_entities >= MAX_ENTITIES) {

	mov	ecx, DWORD PTR _nb_entities
	cmp	ecx, 20					; 00000014H
	jl	SHORT $LN2@addEntity

; 143  : 	fprintf(stderr, "Too many entities defined\n");

	push	OFFSET ??_C@_0BL@OMNEBIPD@Too?5many?5entities?5defined?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 144  : 	return(-1);

	or	eax, -1

; 150  : }

	pop	ebp
	ret	0
$LN2@addEntity:

; 145  :     }
; 146  :     testEntitiesName[nb_entities] = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _testEntitiesName[ecx*4], eax

; 147  :     testEntitiesValue[nb_entities] = content;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR _testEntitiesValue[ecx*4], eax

; 148  :     nb_entities++;

	inc	ecx
	mov	DWORD PTR _nb_entities, ecx

; 149  :     return(0);

	xor	eax, eax

; 150  : }

	pop	ebp
	ret	0
_addEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _resetEntities
_TEXT	SEGMENT
_resetEntities PROC					; COMDAT

; 130  : static void resetEntities(void) {

	push	esi

; 131  :     int i;
; 132  : 
; 133  :     for (i = 0;i < nb_entities;i++) {

	xor	esi, esi
	cmp	DWORD PTR _nb_entities, esi
	jle	SHORT $LN12@resetEntit
	npad	5
$LL4@resetEntit:

; 134  :         if (testEntitiesName[i] != NULL)

	mov	eax, DWORD PTR _testEntitiesName[esi*4]
	test	eax, eax
	je	SHORT $LN5@resetEntit

; 135  : 	    xmlFree(testEntitiesName[i]);

	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN5@resetEntit:

; 136  :         if (testEntitiesValue[i] != NULL)

	mov	eax, DWORD PTR _testEntitiesValue[esi*4]
	test	eax, eax
	je	SHORT $LN2@resetEntit

; 137  : 	    xmlFree(testEntitiesValue[i]);

	push	eax
	mov	eax, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN2@resetEntit:

; 131  :     int i;
; 132  : 
; 133  :     for (i = 0;i < nb_entities;i++) {

	inc	esi
	cmp	esi, DWORD PTR _nb_entities
	jl	SHORT $LL4@resetEntit

; 138  :     }
; 139  :     nb_entities = 0;

	mov	DWORD PTR _nb_entities, 0
	pop	esi

; 140  : }

	ret	0
$LN12@resetEntit:

; 138  :     }
; 139  :     nb_entities = 0;

	mov	DWORD PTR _nb_entities, esi
	pop	esi

; 140  : }

	ret	0
_resetEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _fatalError
_TEXT	SEGMENT
_fatalError PROC					; COMDAT

; 119  :     fprintf(stderr, "Exitting tests on fatal error\n");

	push	OFFSET ??_C@_0BP@MFIPDKLN@Exitting?5tests?5on?5fatal?5error?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 120  :     exit(1);

	push	1
	call	DWORD PTR __imp__exit
$LN3@fatalError:
	int	3
_fatalError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _composeDir
_TEXT	SEGMENT
_buf$ = -500						; size = 500
_dir$ = 8						; size = 4
_path$ = 12						; size = 4
_composeDir PROC					; COMDAT

; 93   : static xmlChar *composeDir(const xmlChar *dir, const xmlChar *path) {

	push	ebp
	mov	ebp, esp

; 94   :     char buf[500];
; 95   : 
; 96   :     if (dir == NULL) return(xmlStrdup(path));

	mov	eax, DWORD PTR _dir$[ebp]
	sub	esp, 500				; 000001f4H
	test	eax, eax
	jne	SHORT $LN2@composeDir
	push	DWORD PTR _path$[ebp]
	call	_xmlStrdup
	add	esp, 4

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@composeDir:

; 97   :     if (path == NULL) return(NULL);

	mov	ecx, DWORD PTR _path$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@composeDir
	xor	eax, eax

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@composeDir:

; 98   : 
; 99   :     snprintf(buf, 500, "%s/%s", (const char *) dir, (const char *) path);

	push	ecx
	push	eax
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	eax, DWORD PTR _buf$[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf

; 100  :     return(xmlStrdup((const xmlChar *) buf));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 24					; 00000018H

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_composeDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c
;	COMDAT _checkTestFile
_TEXT	SEGMENT
_buf$ = -48						; size = 48
_filename$ = 8						; size = 4
_checkTestFile PROC					; COMDAT

; 76   : static int checkTestFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\runsuite.c

; 79   :     if (stat(filename, &buf) == -1)

	cmp	eax, -1
	je	SHORT $LN7@checkTestF

; 80   :         return(0);
; 81   : 
; 82   : #if defined(_WIN32) && !defined(__CYGWIN__)
; 83   :     if (!(buf.st_mode & _S_IFREG))

	test	DWORD PTR _buf$[ebp+6], 32768		; 00008000H
	je	SHORT $LN7@checkTestF

; 85   : #else
; 86   :     if (!S_ISREG(buf.st_mode))
; 87   :         return(0);
; 88   : #endif
; 89   : 
; 90   :     return(1);

	mov	eax, 1

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@checkTestF:

; 84   :         return(0);

	xor	eax, eax

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_checkTestFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
;	COMDAT _stat
_TEXT	SEGMENT
__FileName$ = 8						; size = 4
__Stat$ = 12						; size = 4
_stat	PROC						; COMDAT

; 240  :         {

	push	ebp
	mov	ebp, esp

; 243  :         }

	pop	ebp

; 241  :             _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	jmp	DWORD PTR __imp___stat64i32
_stat	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp

; 1440 :         int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;
; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp

; 1440 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	push	esi

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	esi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	eax
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

	pop	esi

; 961  :     }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vfprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vfprintf PROC						; COMDAT

; 656  :     {

	push	ebp
	mov	ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 657  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 658  :     }

	pop	ebp
	ret	0
_vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
