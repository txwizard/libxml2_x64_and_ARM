; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlschemastypes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__74485836_xmlschemastypes@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_snprintf
PUBLIC	_sscanf
PUBLIC	_xmlSchemaInitTypes
PUBLIC	_xmlSchemaCleanupTypes
PUBLIC	_xmlSchemaGetPredefinedType
PUBLIC	_xmlSchemaValidatePredefinedType
PUBLIC	_xmlSchemaValPredefTypeNode
PUBLIC	_xmlSchemaValidateFacet
PUBLIC	_xmlSchemaValidateFacetWhtsp
PUBLIC	_xmlSchemaFreeValue
PUBLIC	_xmlSchemaCompareValues
PUBLIC	_xmlSchemaGetBuiltInListSimpleTypeItemType
PUBLIC	_xmlSchemaValidateListSimpleTypeFacet
PUBLIC	_xmlSchemaGetBuiltInType
PUBLIC	_xmlSchemaIsBuiltInTypeFacet
PUBLIC	_xmlSchemaCollapseString
PUBLIC	_xmlSchemaWhiteSpaceReplace
PUBLIC	_xmlSchemaGetFacetValueAsULong
PUBLIC	_xmlSchemaValidateLengthFacet
PUBLIC	_xmlSchemaValidateLengthFacetWhtsp
PUBLIC	_xmlSchemaValPredefTypeNodeNoNorm
PUBLIC	_xmlSchemaGetCanonValue
PUBLIC	_xmlSchemaGetCanonValueWhtsp
PUBLIC	_xmlSchemaValueAppend
PUBLIC	_xmlSchemaValueGetNext
PUBLIC	_xmlSchemaValueGetAsString
PUBLIC	_xmlSchemaValueGetAsBoolean
PUBLIC	_xmlSchemaNewStringValue
PUBLIC	_xmlSchemaNewNOTATIONValue
PUBLIC	_xmlSchemaNewQNameValue
PUBLIC	_xmlSchemaCompareValuesWhtsp
PUBLIC	_xmlSchemaCopyValue
PUBLIC	_xmlSchemaGetValType
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@ ; `string'
PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_0BO@IIFFCFND@allocating?5particle?5component@ ; `string'
PUBLIC	??_C@_07OGOHJKKN@anyType@			; `string'
PUBLIC	??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ ; `string'
PUBLIC	??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@ ; `string'
PUBLIC	??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@ ; `string'
PUBLIC	??_C@_0O@DMECCPMH@anySimpleType@		; `string'
PUBLIC	??_C@_06ICGJLFIM@string@			; `string'
PUBLIC	??_C@_07EEKBCPDP@decimal@			; `string'
PUBLIC	??_C@_04JNIHBGGH@date@				; `string'
PUBLIC	??_C@_08JHBOOHBO@dateTime@			; `string'
PUBLIC	??_C@_04CLCEDBPF@time@				; `string'
PUBLIC	??_C@_05DGCLHBFG@gYear@				; `string'
PUBLIC	??_C@_0L@FEFFJNNL@gYearMonth@			; `string'
PUBLIC	??_C@_06KBADAKNH@gMonth@			; `string'
PUBLIC	??_C@_09EILODGOG@gMonthDay@			; `string'
PUBLIC	??_C@_04LBFBAPHN@gDay@				; `string'
PUBLIC	??_C@_08LGBPINEC@duration@			; `string'
PUBLIC	??_C@_05KNFBNCOH@float@				; `string'
PUBLIC	??_C@_06BNJCAIGJ@double@			; `string'
PUBLIC	??_C@_07GOBOHMJA@boolean@			; `string'
PUBLIC	??_C@_06DLDOHKEG@anyURI@			; `string'
PUBLIC	??_C@_09EHHLIAMK@hexBinary@			; `string'
PUBLIC	??_C@_0N@NBAOPEBP@base64Binary@			; `string'
PUBLIC	??_C@_08NCDGCBCC@NOTATION@			; `string'
PUBLIC	??_C@_05LFDDDENB@QName@				; `string'
PUBLIC	??_C@_07LKHFMGFB@integer@			; `string'
PUBLIC	??_C@_0BD@FMNGDL@nonPositiveInteger@		; `string'
PUBLIC	??_C@_0BA@HJODLFEP@negativeInteger@		; `string'
PUBLIC	??_C@_04GOKPGOLB@long@				; `string'
PUBLIC	??_C@_03JBIPMCLC@int@				; `string'
PUBLIC	??_C@_05BFKKPKCG@short@				; `string'
PUBLIC	??_C@_04IHGKJMLH@byte@				; `string'
PUBLIC	??_C@_0BD@IEOLADAC@nonNegativeInteger@		; `string'
PUBLIC	??_C@_0N@PNDKOLAJ@unsignedLong@			; `string'
PUBLIC	??_C@_0M@NPFOHDP@unsignedInt@			; `string'
PUBLIC	??_C@_0O@NAIDFEBN@unsignedShort@		; `string'
PUBLIC	??_C@_0N@BEPPBJAP@unsignedByte@			; `string'
PUBLIC	??_C@_0BA@PNFEGAHG@positiveInteger@		; `string'
PUBLIC	??_C@_0BB@HPFKIGKN@normalizedString@		; `string'
PUBLIC	??_C@_05JMKJMOPH@token@				; `string'
PUBLIC	??_C@_08JGCCIMAA@language@			; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_07JKBEJDBF@NMTOKEN@			; `string'
PUBLIC	??_C@_06MDLHOHLI@NCName@			; `string'
PUBLIC	??_C@_02OLOABKKD@ID@				; `string'
PUBLIC	??_C@_05HKGPJLPA@IDREF@				; `string'
PUBLIC	??_C@_06GKLBAPIO@ENTITY@			; `string'
PUBLIC	??_C@_08ICGBNEMG@ENTITIES@			; `string'
PUBLIC	??_C@_06CMFBJDBA@IDREFS@			; `string'
PUBLIC	??_C@_08PMNBPOOP@NMTOKENS@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf@			; `string'
PUBLIC	??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@	; `string'
PUBLIC	??_C@_0BH@PBMCLKED@allocating?5base64?5data@	; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_03MDAFIFFL@0?40@				; `string'
PUBLIC	??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_06DFHLHGNP@?$CFlu?$CFlu@			; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_07KPEGABEP@?9?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_04IEOFADKM@?9?$CFlu@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ ; `string'
PUBLIC	??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ ; `string'
PUBLIC	??_C@_05IHGIIBEO@?$CF04ld@			; `string'
PUBLIC	??_C@_06PLGGIKKN@?9?9?$CF02u@			; `string'
PUBLIC	??_C@_07GBFLPNDN@?9?9?9?$CF02u@			; `string'
PUBLIC	??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@		; `string'
PUBLIC	??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@		; `string'
PUBLIC	??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@		; `string'
PUBLIC	??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@ ; `string'
PUBLIC	??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@ ; `string'
PUBLIC	??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@	; `string'
PUBLIC	??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@	; `string'
PUBLIC	??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ ; `string'
PUBLIC	??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ ; `string'
PUBLIC	??_C@_07EBIAOBPB@?$CF01?414e@			; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4028000000000000
PUBLIC	__real@4038000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40ac200000000000
PUBLIC	__real@40e89c0000000000
PUBLIC	__real@40f5180000000000
PUBLIC	__real@c0e89c0000000000
PUBLIC	__xmm@3ff0000000000000404e000000000000
PUBLIC	__xmm@40ac20000000000040f5180000000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlUTF8Strlen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	_xmlRegexpExec:PROC
EXTRN	_xmlValidateNCName:PROC
EXTRN	_xmlValidateQName:PROC
EXTRN	_xmlValidateName:PROC
EXTRN	_xmlValidateNMToken:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlAddID:PROC
EXTRN	_xmlAddRef:PROC
EXTRN	_xmlValidateNotationUse:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlCheckLanguageID:PROC
EXTRN	_xmlXPathIsNaN:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlSchemaFreeType:PROC
EXTRN	_xmlSchemaFreeWildcard:PROC
EXTRN	_xmlSchemaNewFacet:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__dtoui3:PROC
EXTRN	_floor:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlSchemaTypesInitialized DD 01H DUP (?)
_xmlSchemaTypesBank DD 01H DUP (?)
_xmlSchemaTypeStringDef DD 01H DUP (?)
_xmlSchemaTypeAnyTypeDef DD 01H DUP (?)
_xmlSchemaTypeAnySimpleTypeDef DD 01H DUP (?)
_xmlSchemaTypeDecimalDef DD 01H DUP (?)
_xmlSchemaTypeDatetimeDef DD 01H DUP (?)
_xmlSchemaTypeDateDef DD 01H DUP (?)
_xmlSchemaTypeTimeDef DD 01H DUP (?)
_xmlSchemaTypeGYearDef DD 01H DUP (?)
_xmlSchemaTypeGYearMonthDef DD 01H DUP (?)
_xmlSchemaTypeGDayDef DD 01H DUP (?)
_xmlSchemaTypeGMonthDayDef DD 01H DUP (?)
_xmlSchemaTypeGMonthDef DD 01H DUP (?)
_xmlSchemaTypeDurationDef DD 01H DUP (?)
_xmlSchemaTypeFloatDef DD 01H DUP (?)
_xmlSchemaTypeBooleanDef DD 01H DUP (?)
_xmlSchemaTypeDoubleDef DD 01H DUP (?)
_xmlSchemaTypeHexBinaryDef DD 01H DUP (?)
_xmlSchemaTypeBase64BinaryDef DD 01H DUP (?)
_xmlSchemaTypeAnyURIDef DD 01H DUP (?)
_xmlSchemaTypePositiveIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNonPositiveIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNegativeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNonNegativeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeLongDef DD 01H DUP (?)
_xmlSchemaTypeIntDef DD 01H DUP (?)
_xmlSchemaTypeShortDef DD 01H DUP (?)
_xmlSchemaTypeByteDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedLongDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedIntDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedShortDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedByteDef DD 01H DUP (?)
_xmlSchemaTypeNormStringDef DD 01H DUP (?)
_xmlSchemaTypeTokenDef DD 01H DUP (?)
_xmlSchemaTypeLanguageDef DD 01H DUP (?)
_xmlSchemaTypeNameDef DD 01H DUP (?)
_xmlSchemaTypeQNameDef DD 01H DUP (?)
_xmlSchemaTypeNCNameDef DD 01H DUP (?)
_xmlSchemaTypeIdDef DD 01H DUP (?)
_xmlSchemaTypeIdrefDef DD 01H DUP (?)
_xmlSchemaTypeIdrefsDef DD 01H DUP (?)
_xmlSchemaTypeEntityDef DD 01H DUP (?)
_xmlSchemaTypeEntitiesDef DD 01H DUP (?)
_xmlSchemaTypeNotationDef DD 01H DUP (?)
_xmlSchemaTypeNmtokenDef DD 01H DUP (?)
_xmlSchemaTypeNmtokensDef DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@40ac20000000000040f5180000000000
CONST	SEGMENT
__xmm@40ac20000000000040f5180000000000 DB 00H, 00H, 00H, 00H, 00H, 018H, 0f5H
	DB	'@', 00H, 00H, 00H, 00H, 00H, ' ', 0acH, '@'
CONST	ENDS
;	COMDAT __xmm@3ff0000000000000404e000000000000
CONST	SEGMENT
__xmm@3ff0000000000000404e000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 'N'
	DB	'@', 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '?'
CONST	ENDS
;	COMDAT __real@c0e89c0000000000
CONST	SEGMENT
__real@c0e89c0000000000 DQ 0c0e89c0000000000r	; -50400
CONST	ENDS
;	COMDAT __real@40f5180000000000
CONST	SEGMENT
__real@40f5180000000000 DQ 040f5180000000000r	; 86400
CONST	ENDS
;	COMDAT __real@40e89c0000000000
CONST	SEGMENT
__real@40e89c0000000000 DQ 040e89c0000000000r	; 50400
CONST	ENDS
;	COMDAT __real@40ac200000000000
CONST	SEGMENT
__real@40ac200000000000 DQ 040ac200000000000r	; 3600
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4038000000000000
CONST	SEGMENT
__real@4038000000000000 DQ 04038000000000000r	; 24
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBIAOBPB@?$CF01?414e@
CONST	SEGMENT
??_C@_07EBIAOBPB@?$CF01?414e@ DB '%01.14e', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
CONST	SEGMENT
??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ DB '%'
	DB	'04ld:%02u:%02uT%02u:%02u:%02.14g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
CONST	SEGMENT
??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ DB '%'
	DB	'04ld:%02u:%02uT%02u:%02u:%02.14gZ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@
CONST	SEGMENT
??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@ DB '%04ld:%02u:%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@
CONST	SEGMENT
??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@ DB '%04ld:%02u:%02uZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@
CONST	SEGMENT
??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@ DB '%02u:%02u:%02.14g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@
CONST	SEGMENT
??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@ DB '%02u:%02u:%02.14gZ'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@
CONST	SEGMENT
??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@ DB '%04ld-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@
CONST	SEGMENT
??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@ DB '-%04ld-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@
CONST	SEGMENT
??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@ DB '--%02u-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GBFLPNDN@?9?9?9?$CF02u@
CONST	SEGMENT
??_C@_07GBFLPNDN@?9?9?9?$CF02u@ DB '---%02u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PLGGIKKN@?9?9?$CF02u@
CONST	SEGMENT
??_C@_06PLGGIKKN@?9?9?$CF02u@ DB '--%02u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHGIIBEO@?$CF04ld@
CONST	SEGMENT
??_C@_05IHGIIBEO@?$CF04ld@ DB '%04ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
CONST	SEGMENT
??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ DB '-'
	DB	'P%luY%luM%luDT%luH%luM%.14gS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
CONST	SEGMENT
??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ DB 'P'
	DB	'%luY%luM%luDT%luH%luM%.14gS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEOFADKM@?9?$CFlu@
CONST	SEGMENT
??_C@_04IEOFADKM@?9?$CFlu@ DB '-%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KPEGABEP@?9?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_07KPEGABEP@?9?$CFlu?$CFlu@ DB '-%lu%lu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@ DB '-%lu%lu%lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_06DFHLHGNP@?$CFlu?$CFlu@ DB '%lu%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@ DB '%lu%lu%lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDAFIFFL@0?40@
CONST	SEGMENT
??_C@_03MDAFIFFL@0?40@ DB '0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PBMCLKED@allocating?5base64?5data@
CONST	SEGMENT
??_C@_0BH@PBMCLKED@allocating?5base64?5data@ DB 'allocating base64 data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@
CONST	SEGMENT
??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@ DB 'allocating hexbin data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlschemastypes.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf@ DB '%lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
CONST	SEGMENT
_daysInMonth DD	01fH
	DD	01cH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
_daysInMonthLeap DD 01fH
	DD	01dH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
_dayInYearByMonth DD 00H
	DD	01fH
	DD	03bH
	DD	05aH
	DD	078H
	DD	097H
	DD	0b5H
	DD	0d4H
	DD	0f3H
	DD	0111H
	DD	0130H
	DD	014eH
_dayInLeapYearByMonth DD 00H
	DD	01fH
	DD	03cH
	DD	05bH
	DD	079H
	DD	098H
	DD	0b6H
	DD	0d5H
	DD	0f4H
	DD	0112H
	DD	0131H
	DD	014fH
?dayRange@?1??xmlSchemaCompareDurations@@9@9 DD 00H	; `xmlSchemaCompareDurations'::`2'::dayRange
	DD	01cH
	DD	03bH
	DD	059H
	DD	078H
	DD	096H
	DD	0b5H
	DD	0d4H
	DD	0f2H
	DD	0111H
	DD	012fH
	DD	014eH
	DD	00H
	DD	01fH
	DD	03eH
	DD	05cH
	DD	07bH
	DD	099H
	DD	0b8H
	DD	0d7H
	DD	0f5H
	DD	0114H
	DD	0132H
	DD	0151H
CONST	ENDS
;	COMDAT ??_C@_08PMNBPOOP@NMTOKENS@
CONST	SEGMENT
??_C@_08PMNBPOOP@NMTOKENS@ DB 'NMTOKENS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMFBJDBA@IDREFS@
CONST	SEGMENT
??_C@_06CMFBJDBA@IDREFS@ DB 'IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICGBNEMG@ENTITIES@
CONST	SEGMENT
??_C@_08ICGBNEMG@ENTITIES@ DB 'ENTITIES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKLBAPIO@ENTITY@
CONST	SEGMENT
??_C@_06GKLBAPIO@ENTITY@ DB 'ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKGPJLPA@IDREF@
CONST	SEGMENT
??_C@_05HKGPJLPA@IDREF@ DB 'IDREF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID@
CONST	SEGMENT
??_C@_02OLOABKKD@ID@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDLHOHLI@NCName@
CONST	SEGMENT
??_C@_06MDLHOHLI@NCName@ DB 'NCName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKBEJDBF@NMTOKEN@
CONST	SEGMENT
??_C@_07JKBEJDBF@NMTOKEN@ DB 'NMTOKEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGCCIMAA@language@
CONST	SEGMENT
??_C@_08JGCCIMAA@language@ DB 'language', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMKJMOPH@token@
CONST	SEGMENT
??_C@_05JMKJMOPH@token@ DB 'token', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HPFKIGKN@normalizedString@
CONST	SEGMENT
??_C@_0BB@HPFKIGKN@normalizedString@ DB 'normalizedString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNFEGAHG@positiveInteger@
CONST	SEGMENT
??_C@_0BA@PNFEGAHG@positiveInteger@ DB 'positiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEPPBJAP@unsignedByte@
CONST	SEGMENT
??_C@_0N@BEPPBJAP@unsignedByte@ DB 'unsignedByte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAIDFEBN@unsignedShort@
CONST	SEGMENT
??_C@_0O@NAIDFEBN@unsignedShort@ DB 'unsignedShort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NPFOHDP@unsignedInt@
CONST	SEGMENT
??_C@_0M@NPFOHDP@unsignedInt@ DB 'unsignedInt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNDKOLAJ@unsignedLong@
CONST	SEGMENT
??_C@_0N@PNDKOLAJ@unsignedLong@ DB 'unsignedLong', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IEOLADAC@nonNegativeInteger@
CONST	SEGMENT
??_C@_0BD@IEOLADAC@nonNegativeInteger@ DB 'nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHGKJMLH@byte@
CONST	SEGMENT
??_C@_04IHGKJMLH@byte@ DB 'byte', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFKKPKCG@short@
CONST	SEGMENT
??_C@_05BFKKPKCG@short@ DB 'short', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int@
CONST	SEGMENT
??_C@_03JBIPMCLC@int@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOKPGOLB@long@
CONST	SEGMENT
??_C@_04GOKPGOLB@long@ DB 'long', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJODLFEP@negativeInteger@
CONST	SEGMENT
??_C@_0BA@HJODLFEP@negativeInteger@ DB 'negativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMNGDL@nonPositiveInteger@
CONST	SEGMENT
??_C@_0BD@FMNGDL@nonPositiveInteger@ DB 'nonPositiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKHFMGFB@integer@
CONST	SEGMENT
??_C@_07LKHFMGFB@integer@ DB 'integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LFDDDENB@QName@
CONST	SEGMENT
??_C@_05LFDDDENB@QName@ DB 'QName', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCDGCBCC@NOTATION@
CONST	SEGMENT
??_C@_08NCDGCBCC@NOTATION@ DB 'NOTATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NBAOPEBP@base64Binary@
CONST	SEGMENT
??_C@_0N@NBAOPEBP@base64Binary@ DB 'base64Binary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHHLIAMK@hexBinary@
CONST	SEGMENT
??_C@_09EHHLIAMK@hexBinary@ DB 'hexBinary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLDOHKEG@anyURI@
CONST	SEGMENT
??_C@_06DLDOHKEG@anyURI@ DB 'anyURI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOBOHMJA@boolean@
CONST	SEGMENT
??_C@_07GOBOHMJA@boolean@ DB 'boolean', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNFBNCOH@float@
CONST	SEGMENT
??_C@_05KNFBNCOH@float@ DB 'float', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGBPINEC@duration@
CONST	SEGMENT
??_C@_08LGBPINEC@duration@ DB 'duration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBFBAPHN@gDay@
CONST	SEGMENT
??_C@_04LBFBAPHN@gDay@ DB 'gDay', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EILODGOG@gMonthDay@
CONST	SEGMENT
??_C@_09EILODGOG@gMonthDay@ DB 'gMonthDay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBADAKNH@gMonth@
CONST	SEGMENT
??_C@_06KBADAKNH@gMonth@ DB 'gMonth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEFFJNNL@gYearMonth@
CONST	SEGMENT
??_C@_0L@FEFFJNNL@gYearMonth@ DB 'gYearMonth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGCLHBFG@gYear@
CONST	SEGMENT
??_C@_05DGCLHBFG@gYear@ DB 'gYear', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time@
CONST	SEGMENT
??_C@_04CLCEDBPF@time@ DB 'time', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHBOOHBO@dateTime@
CONST	SEGMENT
??_C@_08JHBOOHBO@dateTime@ DB 'dateTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNIHBGGH@date@
CONST	SEGMENT
??_C@_04JNIHBGGH@date@ DB 'date', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEKBCPDP@decimal@
CONST	SEGMENT
??_C@_07EEKBCPDP@decimal@ DB 'decimal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string@
CONST	SEGMENT
??_C@_06ICGJLFIM@string@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMECCPMH@anySimpleType@
CONST	SEGMENT
??_C@_0O@DMECCPMH@anySimpleType@ DB 'anySimpleType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@
CONST	SEGMENT
??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@ DB 'could not cr'
	DB	'eate an attribute wildcard on anyType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@
CONST	SEGMENT
??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@ DB 'allocating wildca'
	DB	'rd component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
CONST	SEGMENT
??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ DB 'allocating mod'
	DB	'el group component', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OGOHJKKN@anyType@
CONST	SEGMENT
??_C@_07OGOHJKKN@anyType@ DB 'anyType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
CONST	SEGMENT
??_C@_0BO@IIFFCFND@allocating?5particle?5component@ DB 'allocating partic'
	DB	'le component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
CONST	SEGMENT
??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@ DB 'could not ini'
	DB	'tialize basic types', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacetInternal
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_fws$ = 12						; size = 4
_valType$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateFacetInternal PROC			; COMDAT

; 5318 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _facet$[ebp]
	test	edi, edi
	je	$LN65@xmlSchemaV

; 5319 :     int ret;
; 5320 :     int stringType;
; 5321 : 
; 5322 :     if (facet == NULL)
; 5323 : 	return(-1);
; 5324 : 
; 5325 :     switch (facet->type) {

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi-1000]
	cmp	eax, 11					; 0000000bH
	ja	$LN74@xmlSchemaV
	mov	ecx, DWORD PTR _valType$[ebp]
	jmp	DWORD PTR $LN90@xmlSchemaV[eax*4]
$LN7@xmlSchemaV:

; 5326 : 	case XML_SCHEMA_FACET_PATTERN:
; 5327 : 	    /*
; 5328 : 	    * NOTE that for patterns, the @value needs to be the normalized
; 5329 : 	    * value, *not* the lexical initial value or the canonical value.
; 5330 : 	    */
; 5331 : 	    if (value == NULL)

	mov	edx, DWORD PTR _value$[ebp]
	test	edx, edx
	je	$LN65@xmlSchemaV

; 5332 : 		return(-1);
; 5333 : 	    /*
; 5334 : 	    * If string-derived type, regexp must be tested on the value space of
; 5335 : 	    * the datatype.
; 5336 : 	    * See https://www.w3.org/TR/xmlschema-2/#rf-pattern
; 5337 : 	    */
; 5338 : 	    stringType = val && ((val->type >= XML_SCHEMAS_STRING && val->type <= XML_SCHEMAS_NORMSTRING)

	mov	ecx, DWORD PTR _val$[ebp]
	test	ecx, ecx
	je	SHORT $LN81@xmlSchemaV
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 1
	jl	SHORT $LN76@xmlSchemaV
	cmp	eax, 2
	jle	SHORT $LN86@xmlSchemaV
$LN76@xmlSchemaV:
	add	eax, -16				; fffffff0H
	cmp	eax, 6
	ja	SHORT $LN81@xmlSchemaV
$LN86@xmlSchemaV:

; 5339 : 			      || (val->type >= XML_SCHEMAS_TOKEN && val->type <= XML_SCHEMAS_NCNAME));
; 5340 : 	    ret = xmlRegexpExec(facet->regexp,

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	jne	SHORT $LN82@xmlSchemaV
$LN81@xmlSchemaV:
	mov	eax, edx
$LN82@xmlSchemaV:
	push	eax
	push	DWORD PTR [edi+36]
	call	_xmlRegexpExec
	add	esp, 8

; 5341 : 	                        (stringType && val->value.str) ? val->value.str : value);
; 5342 : 	    if (ret == 1)

	cmp	eax, 1
	je	$LN2@xmlSchemaV

; 5343 : 		return(0);
; 5344 : 	    if (ret == 0)

	pop	edi
	test	eax, eax
	mov	ecx, 1839				; 0000072fH

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	esi
	cmove	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlSchemaV:

; 5345 : 		return(XML_SCHEMAV_CVC_PATTERN_VALID);
; 5346 : 	    return(ret);
; 5347 : 	case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 5348 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	push	DWORD PTR [edi+32]
	push	DWORD PTR _val$[ebp]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 5349 : 	    if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	$LN65@xmlSchemaV

; 5350 : 		return(-1);
; 5351 : 	    if (ret == -1)

	cmp	eax, -1
	je	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1836				; 0000072cH
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlSchemaV:

; 5352 : 		return(0);
; 5353 : 	    return(XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID);
; 5354 : 	case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 5355 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	push	DWORD PTR [edi+32]
	push	DWORD PTR _val$[ebp]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 5356 : 	    if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	$LN65@xmlSchemaV

; 5357 : 		return(-1);
; 5358 : 	    if ((ret == -1) || (ret == 0))

	cmp	eax, -1
	je	$LN2@xmlSchemaV
	test	eax, eax
	je	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1834				; 0000072aH
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlSchemaV:

; 5359 : 		return(0);
; 5360 : 	    return(XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID);
; 5361 : 	case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 5362 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	push	DWORD PTR [edi+32]
	push	DWORD PTR _val$[ebp]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 5363 : 	    if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	$LN65@xmlSchemaV

; 5364 : 		return(-1);
; 5365 : 	    if (ret == 1)

	cmp	eax, 1
	je	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1835				; 0000072bH
	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlSchemaV:

; 5366 : 		return(0);
; 5367 : 	    return(XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID);
; 5368 : 	case XML_SCHEMA_FACET_MININCLUSIVE:
; 5369 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	push	DWORD PTR [edi+32]
	push	DWORD PTR _val$[ebp]
	call	_xmlSchemaCompareValues
	add	esp, 8

; 5370 : 	    if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	$LN65@xmlSchemaV

; 5371 : 		return(-1);
; 5372 : 	    if ((ret == 1) || (ret == 0))

	cmp	eax, 1
	je	$LN2@xmlSchemaV
	test	eax, eax
	je	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1833				; 00000729H
	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlSchemaV:

; 5373 : 		return(0);
; 5374 : 	    return(XML_SCHEMAV_CVC_MININCLUSIVE_VALID);
; 5375 : 	case XML_SCHEMA_FACET_WHITESPACE:
; 5376 : 	    /* TODO whitespaces */
; 5377 : 	    /*
; 5378 : 	    * NOTE: Whitespace should be handled to normalize
; 5379 : 	    * the value to be validated against a the facets;
; 5380 : 	    * not to normalize the value in-between.
; 5381 : 	    */
; 5382 : 	    return(0);
; 5383 : 	case  XML_SCHEMA_FACET_ENUMERATION:
; 5384 : 	    if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	mov	ecx, DWORD PTR _ws$[ebp]
	test	ecx, ecx
	jne	SHORT $LN27@xmlSchemaV

; 5385 : 		/*
; 5386 : 		* This is to ensure API compatibility with the old
; 5387 : 		* xmlSchemaValidateFacet().
; 5388 : 		* TODO: Get rid of this case.
; 5389 : 		*/
; 5390 : 		if ((facet->value != NULL) &&

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN31@xmlSchemaV
	push	DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN27@xmlSchemaV:

; 5391 : 		    (xmlStrEqual(facet->value, value)))
; 5392 : 		    return(0);
; 5393 : 	    } else {
; 5394 : 		ret = xmlSchemaCompareValuesWhtspExt(facet->val->type,

	mov	eax, DWORD PTR [edi+32]

; 5006 :     return(xmlSchemaCompareValuesInternal(xtype, x, xvalue, xws, ytype, y,

	push	ecx
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _valType$[ebp]
	push	DWORD PTR _fws$[ebp]
	push	DWORD PTR [edi+8]
	push	eax
	push	DWORD PTR [eax]
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H

; 5395 : 		    facet->val, facet->value, fws, valType, val,
; 5396 : 		    value, ws);
; 5397 : 		if (ret == -2)

	cmp	eax, -2					; fffffffeH
	je	$LN65@xmlSchemaV

; 5398 : 		    return(-1);
; 5399 : 		if (ret == 0)

	test	eax, eax
	je	$LN2@xmlSchemaV
$LN31@xmlSchemaV:
	pop	edi

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	esi
	mov	eax, 1840				; 00000730H
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlSchemaV:

; 5400 : 		    return(0);
; 5401 : 	    }
; 5402 : 	    return(XML_SCHEMAV_CVC_ENUMERATION_VALID);
; 5403 : 	case XML_SCHEMA_FACET_LENGTH:
; 5404 : 	    /*
; 5405 : 	    * SPEC (1.3) "if {primitive type definition} is QName or NOTATION,
; 5406 : 	    * then any {value} is facet-valid."
; 5407 : 	    */
; 5408 : 	    if ((valType == XML_SCHEMAS_QNAME) ||

	cmp	ecx, 21					; 00000015H
	je	$LN2@xmlSchemaV
	cmp	ecx, 28					; 0000001cH
	je	$LN2@xmlSchemaV
$LN33@xmlSchemaV:

; 5409 : 		(valType == XML_SCHEMAS_NOTATION))
; 5410 : 		return (0);
; 5411 :             /* Falls through. */
; 5412 : 	case XML_SCHEMA_FACET_MAXLENGTH:
; 5413 : 	case XML_SCHEMA_FACET_MINLENGTH: {
; 5414 : 	    unsigned int len = 0;

	xor	ebx, ebx

; 5415 : 
; 5416 : 	    if ((valType == XML_SCHEMAS_QNAME) ||

	cmp	ecx, 21					; 00000015H
	je	$LN2@xmlSchemaV
	cmp	ecx, 28					; 0000001cH
	je	$LN2@xmlSchemaV

; 5417 : 		(valType == XML_SCHEMAS_NOTATION))
; 5418 : 		return (0);
; 5419 : 	    /*
; 5420 : 	    * TODO: length, maxLength and minLength must be of type
; 5421 : 	    * nonNegativeInteger only. Check if decimal is used somehow.
; 5422 : 	    */
; 5423 : 	    if ((facet->val == NULL) ||
; 5424 : 		((facet->val->type != XML_SCHEMAS_DECIMAL) &&
; 5425 : 		 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	$LN65@xmlSchemaV
	mov	edx, DWORD PTR [eax]
	cmp	edx, 3
	je	SHORT $LN40@xmlSchemaV
	cmp	edx, 33					; 00000021H
	jne	$LN65@xmlSchemaV
$LN40@xmlSchemaV:
	test	BYTE PTR [eax+24], 254			; 000000feH
	jne	$LN65@xmlSchemaV

; 5426 : 		(facet->val->value.decimal.frac != 0)) {
; 5427 : 		return(-1);
; 5428 : 	    }
; 5429 : 	    if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN87@xmlSchemaV
	mov	edx, DWORD PTR [eax]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN85@xmlSchemaV

; 5430 : 		len = val->value.hex.total;

	mov	ebx, DWORD PTR [eax+12]
	jmp	$LN4@xmlSchemaV
$LN85@xmlSchemaV:

; 5431 : 	    else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))

	cmp	edx, 44					; 0000002cH
	jne	SHORT $LN87@xmlSchemaV

; 5432 : 		len = val->value.base64.total;

	mov	ebx, DWORD PTR [eax+12]
	jmp	$LN4@xmlSchemaV
$LN87@xmlSchemaV:

; 5433 : 	    else {
; 5434 : 		switch (valType) {

	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 28					; 0000001cH
	ja	SHORT $LN55@xmlSchemaV
	movzx	eax, BYTE PTR $LN88@xmlSchemaV[eax]
	jmp	DWORD PTR $LN91@xmlSchemaV[eax*4]
$LN45@xmlSchemaV:

; 5435 : 		    case XML_SCHEMAS_STRING:
; 5436 : 		    case XML_SCHEMAS_NORMSTRING:
; 5437 : 			if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	mov	edx, DWORD PTR _ws$[ebp]
	test	edx, edx
	jne	SHORT $LN46@xmlSchemaV

; 5438 : 			    /*
; 5439 : 			    * This is to ensure API compatibility with the old
; 5440 : 			    * xmlSchemaValidateFacet(). Anyway, this was and
; 5441 : 			    * is not the correct handling.
; 5442 : 			    * TODO: Get rid of this case somehow.
; 5443 : 			    */
; 5444 : 			    if (valType == XML_SCHEMAS_STRING)

	push	DWORD PTR _value$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN48@xmlSchemaV
$LN51@xmlSchemaV:

; 5471 : 		}
; 5472 : 	    }
; 5473 : 	    if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	call	_xmlUTF8Strlen
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN4@xmlSchemaV
$LN46@xmlSchemaV:

; 5445 : 				len = xmlUTF8Strlen(value);
; 5446 : 			    else
; 5447 : 				len = xmlSchemaNormLen(value);
; 5448 : 			} else if (value != NULL) {

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaV

; 5449 : 			    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	push	eax
	cmp	edx, 3
	jne	SHORT $LN51@xmlSchemaV

; 5450 : 				len = xmlSchemaNormLen(value);

	call	_xmlSchemaNormLen
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN4@xmlSchemaV
$LN53@xmlSchemaV:

; 5451 : 			    else
; 5452 : 				/*
; 5453 : 				* Should be OK for "preserve" as well.
; 5454 : 				*/
; 5455 : 				len = xmlUTF8Strlen(value);
; 5456 : 			}
; 5457 : 			break;
; 5458 : 		    case XML_SCHEMAS_IDREF:
; 5459 : 		    case XML_SCHEMAS_TOKEN:
; 5460 : 		    case XML_SCHEMAS_LANGUAGE:
; 5461 : 		    case XML_SCHEMAS_NMTOKEN:
; 5462 : 		    case XML_SCHEMAS_NAME:
; 5463 : 		    case XML_SCHEMAS_NCNAME:
; 5464 : 		    case XML_SCHEMAS_ID:
; 5465 : 		    case XML_SCHEMAS_ANYURI:
; 5466 : 			if (value != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaV

; 5467 : 			    len = xmlSchemaNormLen(value);

	push	eax
$LN48@xmlSchemaV:

; 5471 : 		}
; 5472 : 	    }
; 5473 : 	    if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	call	_xmlSchemaNormLen
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN4@xmlSchemaV
$LN55@xmlSchemaV:

; 5468 : 			break;
; 5469 : 		    default:
; 5470 : 		        TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5470					; 0000155eH
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN4@xmlSchemaV:

; 5471 : 		}
; 5472 : 	    }
; 5473 : 	    if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+32]
	cmp	ecx, 1009				; 000003f1H
	jne	SHORT $LN56@xmlSchemaV

; 5474 : 		if (len != facet->val->value.decimal.lo)

	cmp	ebx, DWORD PTR [eax+8]
	je	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1830				; 00000726H
	pop	ebx
	pop	ebp
	ret	0
$LN56@xmlSchemaV:

; 5475 : 		    return(XML_SCHEMAV_CVC_LENGTH_VALID);
; 5476 : 	    } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	mov	eax, DWORD PTR [eax+8]
	cmp	ecx, 1011				; 000003f3H
	jne	SHORT $LN59@xmlSchemaV

; 5477 : 		if (len < facet->val->value.decimal.lo)

	cmp	ebx, eax
	jae	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1831				; 00000727H
	pop	ebx
	pop	ebp
	ret	0
$LN59@xmlSchemaV:

; 5478 : 		    return(XML_SCHEMAV_CVC_MINLENGTH_VALID);
; 5479 : 	    } else {
; 5480 : 		if (len > facet->val->value.decimal.lo)

	cmp	ebx, eax
	jbe	$LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1832				; 00000728H
	pop	ebx
	pop	ebp
	ret	0
$LN63@xmlSchemaV:

; 5481 : 		    return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);
; 5482 : 	    }
; 5483 : 	    break;
; 5484 : 	}
; 5485 : 	case XML_SCHEMA_FACET_TOTALDIGITS:
; 5486 : 	case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 5487 : 
; 5488 : 	    if ((facet->val == NULL) ||
; 5489 : 		((facet->val->type != XML_SCHEMAS_PINTEGER) &&
; 5490 : 		 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	ecx, DWORD PTR [edi+32]
	test	ecx, ecx
	je	$LN65@xmlSchemaV
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN66@xmlSchemaV
	cmp	eax, 33					; 00000021H
	jne	$LN65@xmlSchemaV
$LN66@xmlSchemaV:
	test	BYTE PTR [ecx+24], 254			; 000000feH
	jne	$LN65@xmlSchemaV

; 5491 : 		(facet->val->value.decimal.frac != 0)) {
; 5492 : 		return(-1);
; 5493 : 	    }
; 5494 : 	    if ((val == NULL) ||

	mov	edx, DWORD PTR _val$[ebp]
	test	edx, edx
	je	$LN65@xmlSchemaV
	mov	eax, DWORD PTR [edx]
	cmp	eax, 3
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 30					; 0000001eH
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 31					; 0000001fH
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 32					; 00000020H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 33					; 00000021H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 34					; 00000022H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 35					; 00000023H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 36					; 00000024H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 37					; 00000025H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 38					; 00000026H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 39					; 00000027H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 40					; 00000028H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 41					; 00000029H
	je	SHORT $LN67@xmlSchemaV
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN65@xmlSchemaV
$LN67@xmlSchemaV:

; 5495 : 		((val->type != XML_SCHEMAS_DECIMAL) &&
; 5496 : 		 (val->type != XML_SCHEMAS_INTEGER) &&
; 5497 : 		 (val->type != XML_SCHEMAS_NPINTEGER) &&
; 5498 : 		 (val->type != XML_SCHEMAS_NINTEGER) &&
; 5499 : 		 (val->type != XML_SCHEMAS_NNINTEGER) &&
; 5500 : 		 (val->type != XML_SCHEMAS_PINTEGER) &&
; 5501 : 		 (val->type != XML_SCHEMAS_INT) &&
; 5502 : 		 (val->type != XML_SCHEMAS_UINT) &&
; 5503 : 		 (val->type != XML_SCHEMAS_LONG) &&
; 5504 : 		 (val->type != XML_SCHEMAS_ULONG) &&
; 5505 : 		 (val->type != XML_SCHEMAS_SHORT) &&
; 5506 : 		 (val->type != XML_SCHEMAS_USHORT) &&
; 5507 : 		 (val->type != XML_SCHEMAS_BYTE) &&
; 5508 : 		 (val->type != XML_SCHEMAS_UBYTE))) {
; 5509 : 		return(-1);
; 5510 : 	    }
; 5511 : 	    if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {

	cmp	esi, 1004				; 000003ecH
	jne	SHORT $LN69@xmlSchemaV

; 5512 : 	        if (val->value.decimal.total > facet->val->value.decimal.lo)

	movzx	eax, BYTE PTR [edx+25]
	cmp	eax, DWORD PTR [ecx+8]
	jbe	SHORT $LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1837				; 0000072dH
	pop	ebx
	pop	ebp
	ret	0
$LN69@xmlSchemaV:

; 5513 : 	            return(XML_SCHEMAV_CVC_TOTALDIGITS_VALID);
; 5514 : 
; 5515 : 	    } else if (facet->type == XML_SCHEMA_FACET_FRACTIONDIGITS) {

	cmp	esi, 1005				; 000003edH
	jne	SHORT $LN2@xmlSchemaV

; 5516 : 	        if (val->value.decimal.frac > facet->val->value.decimal.lo)

	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	cmp	eax, DWORD PTR [ecx+8]
	jbe	SHORT $LN2@xmlSchemaV

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	mov	eax, 1838				; 0000072eH
	pop	ebx
	pop	ebp
	ret	0
$LN74@xmlSchemaV:

; 5517 : 		    return(XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID);
; 5518 : 	    }
; 5519 : 	    break;
; 5520 : 	default:
; 5521 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5521					; 00001591H
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN2@xmlSchemaV:

; 5522 :     }
; 5523 :     return(0);
; 5524 : 
; 5525 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN65@xmlSchemaV:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LN90@xmlSchemaV:
	DD	$LN21@xmlSchemaV
	DD	$LN18@xmlSchemaV
	DD	$LN14@xmlSchemaV
	DD	$LN11@xmlSchemaV
	DD	$LN63@xmlSchemaV
	DD	$LN63@xmlSchemaV
	DD	$LN7@xmlSchemaV
	DD	$LN26@xmlSchemaV
	DD	$LN2@xmlSchemaV
	DD	$LN32@xmlSchemaV
	DD	$LN33@xmlSchemaV
	DD	$LN33@xmlSchemaV
$LN91@xmlSchemaV:
	DD	$LN45@xmlSchemaV
	DD	$LN53@xmlSchemaV
	DD	$LN55@xmlSchemaV
$LN88@xmlSchemaV:
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_xmlSchemaValidateFacetInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacetInternal
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_valType$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateLengthFacetInternal PROC		; COMDAT

; 5149 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _length$[ebp]
	xor	edi, edi
	test	eax, eax
	je	$LN5@xmlSchemaV

; 5150 :     unsigned int len = 0;
; 5151 : 
; 5152 :     if ((length == NULL) || (facet == NULL))

	mov	ebx, DWORD PTR _facet$[ebp]
	test	ebx, ebx
	je	$LN5@xmlSchemaV

; 5154 :     *length = 0;

	mov	DWORD PTR [eax], edi

; 5155 :     if ((facet->type != XML_SCHEMA_FACET_LENGTH) &&
; 5156 : 	(facet->type != XML_SCHEMA_FACET_MAXLENGTH) &&

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1009				; 000003f1H
	je	SHORT $LN6@xmlSchemaV
	cmp	eax, 1010				; 000003f2H
	je	SHORT $LN6@xmlSchemaV
	cmp	eax, 1011				; 000003f3H
	jne	$LN5@xmlSchemaV
$LN6@xmlSchemaV:

; 5157 : 	(facet->type != XML_SCHEMA_FACET_MINLENGTH))
; 5158 : 	return (-1);
; 5159 : 
; 5160 :     /*
; 5161 :     * TODO: length, maxLength and minLength must be of type
; 5162 :     * nonNegativeInteger only. Check if decimal is used somehow.
; 5163 :     */
; 5164 :     if ((facet->val == NULL) ||
; 5165 : 	((facet->val->type != XML_SCHEMAS_DECIMAL) &&
; 5166 : 	 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	$LN5@xmlSchemaV
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 3
	je	SHORT $LN9@xmlSchemaV
	cmp	ecx, 33					; 00000021H
	jne	$LN5@xmlSchemaV
$LN9@xmlSchemaV:
	test	BYTE PTR [eax+24], 254			; 000000feH
	jne	$LN5@xmlSchemaV

; 5167 : 	(facet->val->value.decimal.frac != 0)) {
; 5168 : 	return(-1);
; 5169 :     }
; 5170 :     if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN35@xmlSchemaV
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN34@xmlSchemaV

; 5171 : 	len = val->value.hex.total;

	mov	edi, DWORD PTR [eax+12]
	jmp	$LN2@xmlSchemaV
$LN34@xmlSchemaV:

; 5172 :     else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))

	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN35@xmlSchemaV

; 5173 : 	len = val->value.base64.total;

	mov	edi, DWORD PTR [eax+12]
	jmp	$LN2@xmlSchemaV
$LN35@xmlSchemaV:

; 5174 :     else {
; 5175 : 	switch (valType) {

	mov	ecx, DWORD PTR _valType$[ebp]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 28					; 0000001cH
	ja	SHORT $LN25@xmlSchemaV
	movzx	eax, BYTE PTR $LN36@xmlSchemaV[eax]
	jmp	DWORD PTR $LN38@xmlSchemaV[eax*4]
$LN14@xmlSchemaV:

; 5176 : 	    case XML_SCHEMAS_STRING:
; 5177 : 	    case XML_SCHEMAS_NORMSTRING:
; 5178 : 		if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	mov	edx, DWORD PTR _ws$[ebp]
	test	edx, edx
	jne	SHORT $LN15@xmlSchemaV

; 5179 : 		    /*
; 5180 : 		    * This is to ensure API compatibility with the old
; 5181 : 		    * xmlSchemaValidateLengthFacet(). Anyway, this was and
; 5182 : 		    * is not the correct handling.
; 5183 : 		    * TODO: Get rid of this case somehow.
; 5184 : 		    */
; 5185 : 		    if (valType == XML_SCHEMAS_STRING)

	push	DWORD PTR _value$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN17@xmlSchemaV
$LN20@xmlSchemaV:

; 5222 : 	}
; 5223 :     }
; 5224 :     *length = (unsigned long) len;

	call	_xmlUTF8Strlen
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN2@xmlSchemaV
$LN15@xmlSchemaV:

; 5186 : 			len = xmlUTF8Strlen(value);
; 5187 : 		    else
; 5188 : 			len = xmlSchemaNormLen(value);
; 5189 : 		} else if (value != NULL) {

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaV

; 5190 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	push	eax
	cmp	edx, 3
	jne	SHORT $LN20@xmlSchemaV

; 5191 : 			len = xmlSchemaNormLen(value);

	call	_xmlSchemaNormLen
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN2@xmlSchemaV
$LN22@xmlSchemaV:

; 5192 : 		    else
; 5193 : 		    /*
; 5194 : 		    * Should be OK for "preserve" as well.
; 5195 : 		    */
; 5196 : 		    len = xmlUTF8Strlen(value);
; 5197 : 		}
; 5198 : 		break;
; 5199 : 	    case XML_SCHEMAS_IDREF:
; 5200 : 	    case XML_SCHEMAS_TOKEN:
; 5201 : 	    case XML_SCHEMAS_LANGUAGE:
; 5202 : 	    case XML_SCHEMAS_NMTOKEN:
; 5203 : 	    case XML_SCHEMAS_NAME:
; 5204 : 	    case XML_SCHEMAS_NCNAME:
; 5205 : 	    case XML_SCHEMAS_ID:
; 5206 : 		/*
; 5207 : 		* FIXME: What exactly to do with anyURI?
; 5208 : 		*/
; 5209 : 	    case XML_SCHEMAS_ANYURI:
; 5210 : 		if (value != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaV

; 5211 : 		    len = xmlSchemaNormLen(value);

	push	eax
$LN17@xmlSchemaV:

; 5222 : 	}
; 5223 :     }
; 5224 :     *length = (unsigned long) len;

	call	_xmlSchemaNormLen
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN2@xmlSchemaV
$LN24@xmlSchemaV:
	pop	edi

; 5237 :     }
; 5238 : 
; 5239 :     return (0);
; 5240 : }

	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN25@xmlSchemaV:
	push	esi

; 5212 : 		break;
; 5213 : 	    case XML_SCHEMAS_QNAME:
; 5214 : 	    case XML_SCHEMAS_NOTATION:
; 5215 : 		/*
; 5216 : 		* For QName and NOTATION, those facets are
; 5217 : 		* deprecated and should be ignored.
; 5218 : 		*/
; 5219 : 		return (0);
; 5220 : 	    default:
; 5221 : 		TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5221					; 00001465H
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN2@xmlSchemaV:

; 5222 : 	}
; 5223 :     }
; 5224 :     *length = (unsigned long) len;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], edi

; 5225 :     /*
; 5226 :     * TODO: Return the whole expected value, i.e. "lo", "mi" and "hi".
; 5227 :     */
; 5228 :     if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+32]
	cmp	ecx, 1009				; 000003f1H
	jne	SHORT $LN26@xmlSchemaV

; 5229 : 	if (len != facet->val->value.decimal.lo)

	cmp	edi, DWORD PTR [eax+8]
	je	SHORT $LN24@xmlSchemaV

; 5230 : 	    return(XML_SCHEMAV_CVC_LENGTH_VALID);

	pop	edi
	mov	eax, 1830				; 00000726H

; 5237 :     }
; 5238 : 
; 5239 :     return (0);
; 5240 : }

	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlSchemaV:

; 5231 :     } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	mov	eax, DWORD PTR [eax+8]
	cmp	ecx, 1011				; 000003f3H
	jne	SHORT $LN29@xmlSchemaV

; 5232 : 	if (len < facet->val->value.decimal.lo)

	cmp	edi, eax
	jae	SHORT $LN24@xmlSchemaV

; 5233 : 	    return(XML_SCHEMAV_CVC_MINLENGTH_VALID);

	pop	edi
	mov	eax, 1831				; 00000727H

; 5237 :     }
; 5238 : 
; 5239 :     return (0);
; 5240 : }

	pop	ebx
	pop	ebp
	ret	0
$LN29@xmlSchemaV:

; 5234 :     } else {
; 5235 : 	if (len > facet->val->value.decimal.lo)

	cmp	edi, eax
	jbe	SHORT $LN24@xmlSchemaV

; 5236 : 	    return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);

	pop	edi
	mov	eax, 1832				; 00000728H

; 5237 :     }
; 5238 : 
; 5239 :     return (0);
; 5240 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlSchemaV:
	pop	edi

; 5153 :         return (-1);

	or	eax, -1

; 5237 :     }
; 5238 : 
; 5239 :     return (0);
; 5240 : }

	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN38@xmlSchemaV:
	DD	$LN14@xmlSchemaV
	DD	$LN22@xmlSchemaV
	DD	$LN24@xmlSchemaV
	DD	$LN25@xmlSchemaV
$LN36@xmlSchemaV:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	3
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
_xmlSchemaValidateLengthFacetInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNormLen
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaNormLen PROC					; COMDAT

; 5019 : xmlSchemaNormLen(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _value$[ebp]
	xor	edi, edi
	test	edx, edx
	je	$LN36@xmlSchemaN
	npad	4
$LL2@xmlSchemaN:

; 5020 :     const xmlChar *utf;
; 5021 :     int ret = 0;
; 5022 : 
; 5023 :     if (value == NULL)
; 5024 : 	return(-1);
; 5025 :     utf = value;
; 5026 :     while (IS_BLANK_CH(*utf)) utf++;

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlSchemaN
	cmp	al, 9
	jb	SHORT $LN10@xmlSchemaN
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN9@xmlSchemaN
$LN10@xmlSchemaN:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN31@xmlSchemaN
$LN9@xmlSchemaN:
	inc	edx
	jmp	SHORT $LL2@xmlSchemaN
$LN31@xmlSchemaN:

; 5027 :     while (*utf != 0) {

	test	al, al
	je	$LN51@xmlSchemaN
$LN53@xmlSchemaN:

; 5028 : 	if (utf[0] & 0x80) {

	jns	SHORT $LN11@xmlSchemaN

; 5029 : 	    if ((utf[1] & 0xc0) != 0x80)

	mov	cl, BYTE PTR [edx+1]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	$LN36@xmlSchemaN

; 5030 : 		return(-1);
; 5031 : 	    if ((utf[0] & 0xe0) == 0xe0) {

	mov	cl, al
	and	cl, 224					; 000000e0H
	cmp	cl, 224					; 000000e0H
	jne	SHORT $LN14@xmlSchemaN

; 5032 : 		if ((utf[2] & 0xc0) != 0x80)

	mov	cl, BYTE PTR [edx+2]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN36@xmlSchemaN

; 5033 : 		    return(-1);
; 5034 : 		if ((utf[0] & 0xf0) == 0xf0) {

	mov	cl, al
	and	cl, 240					; 000000f0H
	cmp	cl, 240					; 000000f0H
	jne	SHORT $LN17@xmlSchemaN

; 5035 : 		    if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	and	al, 248					; 000000f8H
	cmp	al, cl
	jne	SHORT $LN36@xmlSchemaN
	mov	al, BYTE PTR [edx+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN36@xmlSchemaN

; 5037 : 		    utf += 4;

	mov	eax, 4

; 5040 : 		}
; 5041 : 	    } else {

	add	edx, eax

; 5042 : 		utf += 2;
; 5043 : 	    }

	mov	al, BYTE PTR [edx]
	jmp	SHORT $LN27@xmlSchemaN
$LN17@xmlSchemaN:

; 5038 : 		} else {
; 5039 : 		    utf += 3;

	mov	eax, 3

; 5040 : 		}
; 5041 : 	    } else {

	add	edx, eax

; 5042 : 		utf += 2;
; 5043 : 	    }

	mov	al, BYTE PTR [edx]
	jmp	SHORT $LN27@xmlSchemaN
$LN14@xmlSchemaN:
	mov	al, BYTE PTR [edx+2]
	add	edx, 2
	jmp	SHORT $LN27@xmlSchemaN
$LN11@xmlSchemaN:

; 5044 : 	} else if (IS_BLANK_CH(*utf)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaN
	cmp	al, 9
	jb	SHORT $LN24@xmlSchemaN
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LL39@xmlSchemaN
$LN24@xmlSchemaN:
	cmp	al, 13					; 0000000dH
	je	SHORT $LL39@xmlSchemaN

; 5047 : 		break;
; 5048 : 	} else {
; 5049 : 	    utf++;

	mov	al, BYTE PTR [edx+1]
	inc	edx
	jmp	SHORT $LN27@xmlSchemaN
$LL39@xmlSchemaN:

; 5045 : 	    while (IS_BLANK_CH(*utf)) utf++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaN
	cmp	al, 9
	jb	SHORT $LN26@xmlSchemaN
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN25@xmlSchemaN
$LN26@xmlSchemaN:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaN
$LN25@xmlSchemaN:
	mov	al, BYTE PTR [edx+1]
	inc	edx
	jmp	SHORT $LL39@xmlSchemaN
$LN7@xmlSchemaN:

; 5046 : 	    if (*utf == 0)

	test	al, al
	je	SHORT $LN51@xmlSchemaN
$LN27@xmlSchemaN:

; 5050 : 	}
; 5051 : 	ret++;

	inc	edi
	test	al, al
	jne	$LN53@xmlSchemaN
$LN51@xmlSchemaN:

; 5052 :     }
; 5053 :     return(ret);

	mov	eax, edi
	pop	edi

; 5054 : }

	pop	esi
	pop	ebp
	ret	0
$LN36@xmlSchemaN:
	pop	edi

; 5036 : 			return(-1);

	or	eax, -1

; 5054 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaNormLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesWhtspExt
_TEXT	SEGMENT
_xtype$ = 8						; size = 4
_x$ = 12						; size = 4
_xvalue$ = 16						; size = 4
_xws$ = 20						; size = 4
_ytype$ = 24						; size = 4
_y$ = 28						; size = 4
_yvalue$ = 32						; size = 4
_yws$ = 36						; size = 4
_xmlSchemaCompareValuesWhtspExt PROC			; COMDAT

; 5005 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5007 : 	yvalue, yws));
; 5008 : }

	pop	ebp

; 5006 :     return(xmlSchemaCompareValuesInternal(xtype, x, xvalue, xws, ytype, y,

	jmp	_xmlSchemaCompareValuesInternal
_xmlSchemaCompareValuesWhtspExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesInternal
_TEXT	SEGMENT
_d1$1$ = -16						; size = 8
_d2$1$ = -8						; size = 8
_minday$1$ = 8						; size = 4
_xtype$ = 8						; size = 4
_x$ = 12						; size = 4
_xvalue$ = 16						; size = 4
_xws$ = 20						; size = 4
_ytype$ = 24						; size = 4
_y$ = 28						; size = 4
_yvalue$ = 32						; size = 4
_yws$ = 36						; size = 4
_xmlSchemaCompareValuesInternal PROC			; COMDAT

; 4699 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _xtype$[ebp]
	cmp	ecx, 46					; 0000002eH
	ja	$LN2@xmlSchemaC

; 4700 :     switch (xtype) {

	movzx	eax, BYTE PTR $LN358@xmlSchemaC[ecx]
	jmp	DWORD PTR $LN386@xmlSchemaC[eax*4]
$LN5@xmlSchemaC:

; 4701 : 	case XML_SCHEMAS_UNKNOWN:
; 4702 : 	case XML_SCHEMAS_ANYTYPE:
; 4703 : 	    return(-2);
; 4704 :         case XML_SCHEMAS_INTEGER:
; 4705 :         case XML_SCHEMAS_NPINTEGER:
; 4706 :         case XML_SCHEMAS_NINTEGER:
; 4707 :         case XML_SCHEMAS_NNINTEGER:
; 4708 :         case XML_SCHEMAS_PINTEGER:
; 4709 :         case XML_SCHEMAS_INT:
; 4710 :         case XML_SCHEMAS_UINT:
; 4711 :         case XML_SCHEMAS_LONG:
; 4712 :         case XML_SCHEMAS_ULONG:
; 4713 :         case XML_SCHEMAS_SHORT:
; 4714 :         case XML_SCHEMAS_USHORT:
; 4715 :         case XML_SCHEMAS_BYTE:
; 4716 :         case XML_SCHEMAS_UBYTE:
; 4717 : 	case XML_SCHEMAS_DECIMAL:
; 4718 : 	    if ((x == NULL) || (y == NULL))

	mov	edx, DWORD PTR _x$[ebp]
	test	edx, edx
	je	$LN2@xmlSchemaC
	mov	esi, DWORD PTR _y$[ebp]
	test	esi, esi
	je	$LN2@xmlSchemaC

; 4719 : 		return(-2);
; 4720 : 	    if (ytype == xtype)

	mov	eax, DWORD PTR _ytype$[ebp]
	cmp	eax, ecx
	je	SHORT $LN10@xmlSchemaC

; 4721 : 		return(xmlSchemaCompareDecimals(x, y));
; 4722 : 	    if ((ytype == XML_SCHEMAS_DECIMAL) ||
; 4723 : 		(ytype == XML_SCHEMAS_INTEGER) ||
; 4724 : 		(ytype == XML_SCHEMAS_NPINTEGER) ||
; 4725 : 		(ytype == XML_SCHEMAS_NINTEGER) ||
; 4726 : 		(ytype == XML_SCHEMAS_NNINTEGER) ||
; 4727 : 		(ytype == XML_SCHEMAS_PINTEGER) ||
; 4728 : 		(ytype == XML_SCHEMAS_INT) ||
; 4729 : 		(ytype == XML_SCHEMAS_UINT) ||
; 4730 : 		(ytype == XML_SCHEMAS_LONG) ||
; 4731 : 		(ytype == XML_SCHEMAS_ULONG) ||
; 4732 : 		(ytype == XML_SCHEMAS_SHORT) ||
; 4733 : 		(ytype == XML_SCHEMAS_USHORT) ||
; 4734 : 		(ytype == XML_SCHEMAS_BYTE) ||

	cmp	eax, 3
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 30					; 0000001eH
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 31					; 0000001fH
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 33					; 00000021H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 34					; 00000022H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 35					; 00000023H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 36					; 00000024H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 37					; 00000025H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 38					; 00000026H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 39					; 00000027H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 40					; 00000028H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 41					; 00000029H
	je	SHORT $LN10@xmlSchemaC
	cmp	eax, 42					; 0000002aH
	jne	$LN2@xmlSchemaC
$LN10@xmlSchemaC:

; 4924 : }

	push	esi
	push	edx
	call	_xmlSchemaCompareDecimals
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlSchemaC:

; 4735 : 		(ytype == XML_SCHEMAS_UBYTE))
; 4736 : 		return(xmlSchemaCompareDecimals(x, y));
; 4737 : 	    return(-2);
; 4738 :         case XML_SCHEMAS_DURATION:
; 4739 : 	    if ((x == NULL) || (y == NULL))

	mov	esi, DWORD PTR _x$[ebp]
	test	esi, esi
	je	$LN2@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	test	edx, edx
	je	$LN2@xmlSchemaC

; 4740 : 		return(-2);
; 4741 : 	    if (ytype == XML_SCHEMAS_DURATION)

	cmp	DWORD PTR _ytype$[ebp], 12		; 0000000cH
	jne	$LN2@xmlSchemaC

; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;

	movsd	xmm2, QWORD PTR [esi+16]
	mov	ebx, 1
	subsd	xmm2, QWORD PTR [edx+16]
	mov	ecx, DWORD PTR [esi+8]

; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;

	mov	esi, DWORD PTR [esi+12]
	sub	esi, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [edx+8]
	movaps	xmm0, xmm2
	divsd	xmm0, QWORD PTR __real@40f5180000000000
	cvttsd2si eax, xmm0
	add	esi, eax
	movd	xmm0, eax

; 3590 :     carry = (long)(sec / SECS_PER_DAY);
; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@40f5180000000000
	subsd	xmm2, xmm0

; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {

	test	ecx, ecx
	jne	SHORT $LN366@xmlSchemaC

; 3598 :         if (day == 0)

	test	esi, esi
	jne	SHORT $LN93@xmlSchemaC
	xorps	xmm0, xmm0

; 3599 :             if (sec == 0.0)

	ucomisd	xmm2, xmm0
	lahf
	xor	ebx, ebx
	test	ah, 68					; 00000044H
	jnp	$LN111@xmlSchemaC

; 3600 :                 return 0;
; 3601 :             else if (sec < 0.0)

	comisd	xmm0, xmm2
	pop	edi

; 4924 : }

	pop	esi

; 3601 :             else if (sec < 0.0)

	setbe	bl
	lea	ebx, DWORD PTR [ebx*2-1]

; 4742 :                 return(xmlSchemaCompareDurations(x, y));

	mov	eax, ebx

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@xmlSchemaC:

; 3605 :         else if (day < 0)

	xor	ebx, ebx
	test	esi, esi
	pop	edi
	setns	bl

; 4924 : }

	pop	esi

; 3605 :         else if (day < 0)

	lea	ebx, DWORD PTR [ebx*2-1]

; 4742 :                 return(xmlSchemaCompareDurations(x, y));

	mov	eax, ebx

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN366@xmlSchemaC:

; 3611 :     if (mon > 0) {

	jle	SHORT $LN101@xmlSchemaC

; 3612 :         if ((day >= 0) && (sec >= 0.0))

	test	esi, esi
	js	SHORT $LN103@xmlSchemaC
	comisd	xmm2, QWORD PTR __real@0000000000000000
	jae	$LN111@xmlSchemaC
$LN103@xmlSchemaC:

; 3613 :             return 1;
; 3614 :         else {
; 3615 :             xmon = mon;
; 3616 :             xday = -day;

	neg	esi

; 3617 :         }
; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {

	jmp	SHORT $LN106@xmlSchemaC
$LN101@xmlSchemaC:
	test	esi, esi
	jg	SHORT $LN105@xmlSchemaC
	xorps	xmm0, xmm0
	comisd	xmm0, xmm2
	jb	SHORT $LN105@xmlSchemaC
	pop	edi

; 3619 :         return -1;

	or	ebx, -1

; 4924 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@xmlSchemaC:

; 3621 : 	invert = -1;

	or	ebx, -1

; 3622 :         xmon = -mon;

	neg	ecx
$LN106@xmlSchemaC:

; 3623 :         xday = day;
; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;

	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 3627 :     if (myear == 0) {

	jne	SHORT $LN107@xmlSchemaC

; 3628 : 	minday = 0;

	xor	eax, eax

; 3629 : 	maxday = 0;

	xor	edx, edx

; 3630 :     } else {

	jmp	SHORT $LN367@xmlSchemaC
$LN107@xmlSchemaC:

; 3631 : 	maxday = 366 * ((myear + 3) / 4) +

	lea	eax, DWORD PTR [edi+3]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	edx, eax, 366
	lea	eax, DWORD PTR [edi-1]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN365@xmlSchemaC
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN365@xmlSchemaC:
	imul	eax, eax, 365
	add	edx, eax

; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;

	lea	eax, DWORD PTR [edx-1]
$LN367@xmlSchemaC:

; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;

	mov	DWORD PTR _minday$1$[ebp], eax
	lea	eax, DWORD PTR [edi*4]
	sub	eax, edi

; 3637 :     minday += dayRange[0][xmon];

	mov	edi, DWORD PTR _minday$1$[ebp]
	neg	eax
	lea	eax, DWORD PTR [ecx+eax*4]
	add	edi, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax*4]

; 3638 :     maxday += dayRange[1][xmon];

	add	edx, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax*4+48]

; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))

	cmp	edx, edi
	jne	SHORT $LN109@xmlSchemaC
	cmp	edx, esi
	jne	SHORT $LN368@xmlSchemaC
	pop	edi

; 3641 : 	return(0); /* can this really happen ? */

	xor	ebx, ebx

; 4924 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN109@xmlSchemaC:

; 3642 :     if (maxday < xday)

	cmp	edx, esi
$LN368@xmlSchemaC:
	jge	SHORT $LN110@xmlSchemaC
	pop	edi

; 3643 :         return(-invert);

	neg	ebx

; 4924 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN110@xmlSchemaC:

; 3644 :     if (minday > xday)

	cmp	edi, esi
	mov	ecx, 2
	cmovg	ecx, ebx
	mov	ebx, ecx
$LN111@xmlSchemaC:
	pop	edi

; 4924 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSchemaC:

; 4743 :             return(-2);
; 4744 :         case XML_SCHEMAS_TIME:
; 4745 :         case XML_SCHEMAS_GDAY:
; 4746 :         case XML_SCHEMAS_GMONTH:
; 4747 :         case XML_SCHEMAS_GMONTHDAY:
; 4748 :         case XML_SCHEMAS_GYEAR:
; 4749 :         case XML_SCHEMAS_GYEARMONTH:
; 4750 :         case XML_SCHEMAS_DATE:
; 4751 :         case XML_SCHEMAS_DATETIME:
; 4752 : 	    if ((x == NULL) || (y == NULL))

	mov	ecx, DWORD PTR _x$[ebp]
	test	ecx, ecx
	je	$LN2@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	test	edx, edx
	je	$LN2@xmlSchemaC

; 4753 : 		return(-2);
; 4754 :             if ((ytype == XML_SCHEMAS_DATETIME)  ||
; 4755 :                 (ytype == XML_SCHEMAS_TIME)      ||
; 4756 :                 (ytype == XML_SCHEMAS_GDAY)      ||
; 4757 :                 (ytype == XML_SCHEMAS_GMONTH)    ||
; 4758 :                 (ytype == XML_SCHEMAS_GMONTHDAY) ||
; 4759 :                 (ytype == XML_SCHEMAS_GYEAR)     ||
; 4760 :                 (ytype == XML_SCHEMAS_DATE)      ||

	mov	eax, DWORD PTR _ytype$[ebp]
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 4
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 5
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 6
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 7
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 8
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN19@xmlSchemaC
	cmp	eax, 9
	jne	$LN2@xmlSchemaC
$LN19@xmlSchemaC:

; 4761 :                 (ytype == XML_SCHEMAS_GYEARMONTH))
; 4762 :                 return (xmlSchemaCompareDates(x, y));

	push	edx
	push	ecx
	call	_xmlSchemaCompareDates
	add	esp, 8
	pop	edi

; 4924 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemaC:

; 4763 :             return (-2);
; 4764 : 	/*
; 4765 : 	* Note that we will support comparison of string types against
; 4766 : 	* anySimpleType as well.
; 4767 : 	*/
; 4768 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 4769 : 	case XML_SCHEMAS_STRING:
; 4770 :         case XML_SCHEMAS_NORMSTRING:
; 4771 :         case XML_SCHEMAS_TOKEN:
; 4772 :         case XML_SCHEMAS_LANGUAGE:
; 4773 :         case XML_SCHEMAS_NMTOKEN:
; 4774 :         case XML_SCHEMAS_NAME:
; 4775 :         case XML_SCHEMAS_NCNAME:
; 4776 :         case XML_SCHEMAS_ID:
; 4777 :         case XML_SCHEMAS_IDREF:
; 4778 :         case XML_SCHEMAS_ENTITY:
; 4779 :         case XML_SCHEMAS_ANYURI:
; 4780 : 	{
; 4781 : 	    const xmlChar *xv, *yv;
; 4782 : 
; 4783 : 	    if (x == NULL)

	mov	ecx, DWORD PTR _x$[ebp]
	test	ecx, ecx
	jne	SHORT $LN21@xmlSchemaC

; 4784 : 		xv = xvalue;

	mov	ecx, DWORD PTR _xvalue$[ebp]
	jmp	SHORT $LN22@xmlSchemaC
$LN21@xmlSchemaC:

; 4785 : 	    else
; 4786 : 		xv = x->value.str;

	mov	ecx, DWORD PTR [ecx+8]
$LN22@xmlSchemaC:

; 4787 : 	    if (y == NULL)

	mov	edx, DWORD PTR _y$[ebp]
	test	edx, edx
	jne	SHORT $LN23@xmlSchemaC

; 4788 : 		yv = yvalue;

	mov	edx, DWORD PTR _yvalue$[ebp]
	jmp	SHORT $LN24@xmlSchemaC
$LN23@xmlSchemaC:

; 4789 : 	    else
; 4790 : 		yv = y->value.str;

	mov	edx, DWORD PTR [edx+8]
$LN24@xmlSchemaC:

; 4791 : 	    /*
; 4792 : 	    * TODO: Compare those against QName.
; 4793 : 	    */
; 4794 : 	    if (ytype == XML_SCHEMAS_QNAME) {

	mov	eax, DWORD PTR _ytype$[ebp]
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN25@xmlSchemaC

; 4795 : 		TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	4795					; 000012bbH

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	jmp	$LN369@xmlSchemaC
$LN25@xmlSchemaC:

; 4796 : 		if (y == NULL)
; 4797 : 		    return(-2);
; 4798 : 		return (-2);
; 4799 : 	    }
; 4800 :             if ((ytype == XML_SCHEMAS_ANYSIMPLETYPE) ||
; 4801 : 		(ytype == XML_SCHEMAS_STRING) ||
; 4802 : 		(ytype == XML_SCHEMAS_NORMSTRING) ||
; 4803 :                 (ytype == XML_SCHEMAS_TOKEN) ||
; 4804 :                 (ytype == XML_SCHEMAS_LANGUAGE) ||
; 4805 :                 (ytype == XML_SCHEMAS_NMTOKEN) ||
; 4806 :                 (ytype == XML_SCHEMAS_NAME) ||
; 4807 :                 (ytype == XML_SCHEMAS_NCNAME) ||
; 4808 :                 (ytype == XML_SCHEMAS_ID) ||
; 4809 :                 (ytype == XML_SCHEMAS_IDREF) ||
; 4810 :                 (ytype == XML_SCHEMAS_ENTITY) ||

	cmp	eax, 46					; 0000002eH
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 1
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 2
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 16					; 00000010H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 17					; 00000011H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 18					; 00000012H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 20					; 00000014H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 22					; 00000016H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 23					; 00000017H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 24					; 00000018H
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 26					; 0000001aH
	je	SHORT $LN28@xmlSchemaC
	cmp	eax, 29					; 0000001dH
	jne	$LN2@xmlSchemaC
$LN28@xmlSchemaC:

; 4811 :                 (ytype == XML_SCHEMAS_ANYURI)) {
; 4812 : 
; 4813 : 		if (xws == XML_SCHEMA_WHITESPACE_PRESERVE) {

	mov	eax, DWORD PTR _xws$[ebp]
	cmp	eax, 1
	jne	$LN29@xmlSchemaC

; 4814 : 
; 4815 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) {

	mov	eax, DWORD PTR _yws$[ebp]
	cmp	eax, 1
	jne	SHORT $LN31@xmlSchemaC

; 4816 : 			/* TODO: What about x < y or x > y. */
; 4817 : 			if (xmlStrEqual(xv, yv))

	push	edx
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN53@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlSchemaC:

; 4818 : 			    return (0);
; 4819 : 			else
; 4820 : 			    return (2);
; 4821 : 		    } else if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	eax, 2
	jne	SHORT $LN35@xmlSchemaC

; 4275 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN134@xmlSchemaC
	npad	4
$LL114@xmlSchemaC:
	mov	al, BYTE PTR [edx]
	test	al, al
	je	SHORT $LN115@xmlSchemaC

; 4276 : 	if (IS_WSP_REPLACE_CH(*y)) {

	cmp	al, 9
	je	SHORT $LN118@xmlSchemaC
	cmp	al, 10					; 0000000aH
	je	SHORT $LN118@xmlSchemaC
	cmp	al, 13					; 0000000dH
	je	SHORT $LN118@xmlSchemaC

; 4278 : 		if ((*x - 0x20) < 0) {
; 4279 : 		    if (invert)
; 4280 : 			return(1);
; 4281 : 		    else
; 4282 : 			return(-1);
; 4283 : 		} else {
; 4284 : 		    if (invert)
; 4285 : 			return(-1);
; 4286 : 		    else
; 4287 : 			return(1);
; 4288 : 		}
; 4289 : 	    }
; 4290 : 	} else {
; 4291 : 	    tmp = *x - *y;

	movzx	esi, BYTE PTR [ecx]
	movzx	eax, al
	sub	esi, eax

; 4292 : 	    if (tmp < 0) {

	js	$LN85@xmlSchemaC

; 4293 : 		if (invert)
; 4294 : 		    return(1);
; 4295 : 		else
; 4296 : 		    return(-1);
; 4297 : 	    }
; 4298 : 	    if (tmp > 0) {

	test	esi, esi
	jg	$LN349@xmlSchemaC
	jmp	SHORT $LN125@xmlSchemaC
$LN118@xmlSchemaC:

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	jne	$LN371@xmlSchemaC
$LN125@xmlSchemaC:

; 4299 : 		if (invert)
; 4300 : 		    return(-1);
; 4301 : 		else
; 4302 : 		    return(1);
; 4303 : 	    }
; 4304 : 	}
; 4305 : 	x++;

	inc	ecx

; 4306 : 	y++;

	inc	edx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL114@xmlSchemaC

; 4924 : }

	movzx	eax, BYTE PTR [edx]
	pop	edi
	neg	eax
	pop	esi
	sbb	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@xmlSchemaC:

; 4308 :     if (*x != 0) {

	cmp	BYTE PTR [ecx], 0
	jne	$LN349@xmlSchemaC
$LN134@xmlSchemaC:

; 4924 : }

	movzx	eax, BYTE PTR [edx]
	pop	edi
	neg	eax
	pop	esi
	sbb	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlSchemaC:

; 4822 : 			return (xmlSchemaComparePreserveReplaceStrings(xv, yv, 0));
; 4823 : 		    else if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	eax, 3
	jne	$LN2@xmlSchemaC
	npad	7
$LL140@xmlSchemaC:

; 4346 :     while IS_WSP_BLANK_CH(*y)

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN148@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN149@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN148@xmlSchemaC
$LN149@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN292@xmlSchemaC
$LN148@xmlSchemaC:

; 4347 : 	y++;

	inc	edx
	jmp	SHORT $LL140@xmlSchemaC
$LN292@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN171@xmlSchemaC
	npad	6
$LL142@xmlSchemaC:
	mov	al, BYTE PTR [edx]
	test	al, al
	je	SHORT $LN143@xmlSchemaC

; 4350 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN152@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN153@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN152@xmlSchemaC
$LN153@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN152@xmlSchemaC

; 4373 : 		y++;
; 4374 : 	} else {
; 4375 : 	    tmp = *x++ - *y++;

	movzx	esi, BYTE PTR [ecx]
	inc	edx
	movzx	eax, al
	sub	esi, eax

; 4376 : 	    if (tmp < 0) {

	js	SHORT $LN85@xmlSchemaC

; 4377 : 		if (invert)
; 4378 : 		    return(1);
; 4379 : 		else
; 4380 : 		    return(-1);
; 4381 : 	    }
; 4382 : 	    if (tmp > 0) {

	test	esi, esi
	jg	$LN349@xmlSchemaC
	jmp	SHORT $LN363@xmlSchemaC
$LN152@xmlSchemaC:

; 4351 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	jne	$LN371@xmlSchemaC
$LN161@xmlSchemaC:

; 4352 : 		/*
; 4353 : 		* The yv character would have been replaced to 0x20.
; 4354 : 		*/
; 4355 : 		if ((*x - 0x20) < 0) {
; 4356 : 		    if (invert)
; 4357 : 			return(1);
; 4358 : 		    else
; 4359 : 			return(-1);
; 4360 : 		} else {
; 4361 : 		    if (invert)
; 4362 : 			return(-1);
; 4363 : 		    else
; 4364 : 			return(1);
; 4365 : 		}
; 4366 : 	    }
; 4367 : 	    x++;
; 4368 : 	    y++;
; 4369 : 	    /*
; 4370 : 	    * Skip contiguous blank chars of the collapsed string.
; 4371 : 	    */
; 4372 : 	    while IS_WSP_BLANK_CH(*y)

	mov	al, BYTE PTR [edx+1]
	inc	edx
	cmp	al, 32					; 00000020H
	je	SHORT $LN161@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN162@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN161@xmlSchemaC
$LN162@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN161@xmlSchemaC
$LN363@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	inc	ecx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL142@xmlSchemaC
$LN143@xmlSchemaC:

; 4383 : 		if (invert)
; 4384 : 		    return(-1);
; 4385 : 		else
; 4386 : 		    return(1);
; 4387 : 	    }
; 4388 : 	}
; 4389 :     }
; 4390 :     if (*x != 0) {

	cmp	BYTE PTR [ecx], 0
	jne	$LN349@xmlSchemaC
$LN171@xmlSchemaC:

; 4391 : 	 if (invert)
; 4392 : 	     return(-1);
; 4393 : 	 else
; 4394 : 	     return(1);
; 4395 :     }
; 4396 :     if (*y != 0) {

	mov	al, BYTE PTR [edx]
	test	al, al
	je	$LN177@xmlSchemaC
$LL146@xmlSchemaC:

; 4397 : 	/*
; 4398 : 	* Skip trailing blank chars of the collapsed string.
; 4399 : 	*/
; 4400 : 	while IS_WSP_BLANK_CH(*y)

	cmp	al, 32					; 00000020H
	je	SHORT $LN173@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN174@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN173@xmlSchemaC
$LN174@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN147@xmlSchemaC
$LN173@xmlSchemaC:

; 4401 : 	    y++;

	mov	al, BYTE PTR [edx+1]
	inc	edx
	jmp	SHORT $LL146@xmlSchemaC
$LN147@xmlSchemaC:

; 4402 : 	if (*y != 0) {

	test	al, al
	je	$LN177@xmlSchemaC
$LN85@xmlSchemaC:
	pop	edi

; 4924 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlSchemaC:

; 4824 : 			return (xmlSchemaComparePreserveCollapseStrings(xv, yv, 0));
; 4825 : 
; 4826 : 		} else if (xws == XML_SCHEMA_WHITESPACE_REPLACE) {

	cmp	eax, 2
	jne	$LN38@xmlSchemaC

; 4827 : 
; 4828 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)

	mov	eax, DWORD PTR _yws$[ebp]
	cmp	eax, 1
	jne	SHORT $LN40@xmlSchemaC

; 4275 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN200@xmlSchemaC
$LL180@xmlSchemaC:
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN181@xmlSchemaC

; 4276 : 	if (IS_WSP_REPLACE_CH(*y)) {

	cmp	al, 9
	je	SHORT $LN184@xmlSchemaC
	cmp	al, 10					; 0000000aH
	je	SHORT $LN184@xmlSchemaC
	cmp	al, 13					; 0000000dH
	je	SHORT $LN184@xmlSchemaC

; 4278 : 		if ((*x - 0x20) < 0) {
; 4279 : 		    if (invert)
; 4280 : 			return(1);
; 4281 : 		    else
; 4282 : 			return(-1);
; 4283 : 		} else {
; 4284 : 		    if (invert)
; 4285 : 			return(-1);
; 4286 : 		    else
; 4287 : 			return(1);
; 4288 : 		}
; 4289 : 	    }
; 4290 : 	} else {
; 4291 : 	    tmp = *x - *y;

	movzx	esi, BYTE PTR [edx]
	movzx	eax, al
	sub	esi, eax

; 4292 : 	    if (tmp < 0) {

	js	$LN349@xmlSchemaC

; 4293 : 		if (invert)
; 4294 : 		    return(1);
; 4295 : 		else
; 4296 : 		    return(-1);
; 4297 : 	    }
; 4298 : 	    if (tmp > 0) {

	test	esi, esi
	jg	SHORT $LN85@xmlSchemaC
	jmp	SHORT $LN191@xmlSchemaC
$LN184@xmlSchemaC:

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	jne	SHORT $LN375@xmlSchemaC
$LN191@xmlSchemaC:

; 4299 : 		if (invert)
; 4300 : 		    return(-1);
; 4301 : 		else
; 4302 : 		    return(1);
; 4303 : 	    }
; 4304 : 	}
; 4305 : 	x++;

	inc	edx

; 4306 : 	y++;

	inc	ecx
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LL180@xmlSchemaC

; 4309 : 	if (invert)
; 4310 : 	    return(-1);
; 4311 : 	else
; 4312 : 	    return(1);
; 4313 :     }
; 4314 :     if (*y != 0) {

	xor	eax, eax
	cmp	BYTE PTR [ecx], al
	pop	edi

; 4924 : }

	pop	esi

; 4314 :     if (*y != 0) {

	setne	al

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN375@xmlSchemaC:
	sbb	eax, eax
	pop	edi
	and	eax, 2
	pop	esi
	dec	eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN181@xmlSchemaC:

; 4308 :     if (*x != 0) {

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN85@xmlSchemaC
$LN200@xmlSchemaC:

; 4309 : 	if (invert)
; 4310 : 	    return(-1);
; 4311 : 	else
; 4312 : 	    return(1);
; 4313 :     }
; 4314 :     if (*y != 0) {

	xor	eax, eax
	cmp	BYTE PTR [ecx], al
	pop	edi

; 4924 : }

	pop	esi

; 4314 :     if (*y != 0) {

	setne	al

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlSchemaC:

; 4829 : 			return (xmlSchemaComparePreserveReplaceStrings(yv, xv, 1));
; 4830 : 		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	eax, 2
	jne	$LN41@xmlSchemaC

; 4526 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [ecx], 0
	je	$LN134@xmlSchemaC
$LL206@xmlSchemaC:
	mov	al, BYTE PTR [edx]
	test	al, al
	je	$LN207@xmlSchemaC

; 4527 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN210@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN211@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN210@xmlSchemaC
$LN211@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN210@xmlSchemaC

; 4530 : 		    return(-1);
; 4531 : 		else
; 4532 : 		    return(1);
; 4533 : 	    }
; 4534 : 	} else {
; 4535 : 	    if IS_WSP_BLANK_CH(*x) {

	mov	bl, BYTE PTR [ecx]
	cmp	bl, 32					; 00000020H
	je	SHORT $LN217@xmlSchemaC
	cmp	bl, 9
	jb	SHORT $LN218@xmlSchemaC
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LN217@xmlSchemaC
$LN218@xmlSchemaC:
	cmp	bl, 13					; 0000000dH
	je	SHORT $LN217@xmlSchemaC

; 4537 : 		    return(-1);
; 4538 : 		else
; 4539 : 		    return(1);
; 4540 : 	    }
; 4541 : 	    tmp = *x - *y;

	movzx	eax, al
	movzx	esi, bl
	sub	esi, eax

; 4542 : 	    if (tmp < 0)

	js	$LN85@xmlSchemaC

; 4543 : 		return(-1);
; 4544 : 	    if (tmp > 0)

	test	esi, esi
	jg	SHORT $LN349@xmlSchemaC
	jmp	SHORT $LN215@xmlSchemaC
$LN210@xmlSchemaC:

; 4528 : 	    if (! IS_WSP_BLANK_CH(*x)) {

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN215@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN213@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN215@xmlSchemaC
$LN213@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN315@xmlSchemaC
$LN215@xmlSchemaC:

; 4545 : 		return(1);
; 4546 : 	}
; 4547 : 	x++;

	inc	ecx

; 4548 : 	y++;

	inc	edx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL206@xmlSchemaC

; 4924 : }

	movzx	eax, BYTE PTR [edx]
	pop	edi
	neg	eax
	pop	esi
	sbb	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN217@xmlSchemaC:

; 4536 : 		if ((0x20 - *y) < 0)

	movzx	eax, al
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	mov	eax, 0
	pop	edi
	setns	al

; 4924 : }

	pop	esi
	pop	ebx

; 4536 : 		if ((0x20 - *y) < 0)

	lea	eax, DWORD PTR [eax*2-1]

; 4924 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN315@xmlSchemaC:

; 4529 : 		if ((*x - 0x20) < 0)

	cmp	al, 32					; 00000020H
$LN371@xmlSchemaC:

; 4924 : }

	sbb	eax, eax
	pop	edi
	and	eax, -2					; fffffffeH
	pop	esi
	inc	eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN207@xmlSchemaC:

; 4550 :     if (*x != 0)

	cmp	BYTE PTR [ecx], 0
	je	$LN134@xmlSchemaC
$LN349@xmlSchemaC:
	pop	edi

; 4924 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlSchemaC:

; 4831 : 			return (xmlSchemaCompareReplacedStrings(xv, yv));
; 4832 : 		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	eax, 3
	jne	$LN2@xmlSchemaC

; 4833 : 			return (xmlSchemaCompareReplaceCollapseStrings(xv, yv, 0));

	push	0
	push	edx
	push	ecx
	call	_xmlSchemaCompareReplaceCollapseStrings
	add	esp, 12					; 0000000cH
	pop	edi

; 4924 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlSchemaC:

; 4834 : 
; 4835 : 		} else if (xws == XML_SCHEMA_WHITESPACE_COLLAPSE) {

	cmp	eax, 3
	jne	$LN2@xmlSchemaC

; 4836 : 
; 4837 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)

	mov	eax, DWORD PTR _yws$[ebp]
	cmp	eax, 1
	jne	$LN45@xmlSchemaC
$LL227@xmlSchemaC:

; 4346 :     while IS_WSP_BLANK_CH(*y)

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN235@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN236@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN235@xmlSchemaC
$LN236@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN298@xmlSchemaC
$LN235@xmlSchemaC:

; 4347 : 	y++;

	inc	ecx
	jmp	SHORT $LL227@xmlSchemaC
$LN298@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN258@xmlSchemaC
	npad	3
$LL229@xmlSchemaC:
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN230@xmlSchemaC

; 4350 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN239@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN240@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN239@xmlSchemaC
$LN240@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN239@xmlSchemaC

; 4373 : 		y++;
; 4374 : 	} else {
; 4375 : 	    tmp = *x++ - *y++;

	movzx	esi, BYTE PTR [edx]
	inc	ecx
	movzx	eax, al
	sub	esi, eax

; 4376 : 	    if (tmp < 0) {

	js	SHORT $LN349@xmlSchemaC

; 4377 : 		if (invert)
; 4378 : 		    return(1);
; 4379 : 		else
; 4380 : 		    return(-1);
; 4381 : 	    }
; 4382 : 	    if (tmp > 0) {

	test	esi, esi
	jg	$LN85@xmlSchemaC
	jmp	SHORT $LN364@xmlSchemaC
$LN239@xmlSchemaC:

; 4351 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	jne	$LN375@xmlSchemaC
$LN248@xmlSchemaC:

; 4352 : 		/*
; 4353 : 		* The yv character would have been replaced to 0x20.
; 4354 : 		*/
; 4355 : 		if ((*x - 0x20) < 0) {
; 4356 : 		    if (invert)
; 4357 : 			return(1);
; 4358 : 		    else
; 4359 : 			return(-1);
; 4360 : 		} else {
; 4361 : 		    if (invert)
; 4362 : 			return(-1);
; 4363 : 		    else
; 4364 : 			return(1);
; 4365 : 		}
; 4366 : 	    }
; 4367 : 	    x++;
; 4368 : 	    y++;
; 4369 : 	    /*
; 4370 : 	    * Skip contiguous blank chars of the collapsed string.
; 4371 : 	    */
; 4372 : 	    while IS_WSP_BLANK_CH(*y)

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 32					; 00000020H
	je	SHORT $LN248@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN249@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN248@xmlSchemaC
$LN249@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN248@xmlSchemaC
$LN364@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	inc	edx
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LL229@xmlSchemaC
$LN230@xmlSchemaC:

; 4383 : 		if (invert)
; 4384 : 		    return(-1);
; 4385 : 		else
; 4386 : 		    return(1);
; 4387 : 	    }
; 4388 : 	}
; 4389 :     }
; 4390 :     if (*x != 0) {

	cmp	BYTE PTR [edx], 0
	jne	$LN85@xmlSchemaC
$LN258@xmlSchemaC:

; 4391 : 	 if (invert)
; 4392 : 	     return(-1);
; 4393 : 	 else
; 4394 : 	     return(1);
; 4395 :     }
; 4396 :     if (*y != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	$LN177@xmlSchemaC
$LL233@xmlSchemaC:

; 4397 : 	/*
; 4398 : 	* Skip trailing blank chars of the collapsed string.
; 4399 : 	*/
; 4400 : 	while IS_WSP_BLANK_CH(*y)

	cmp	al, 32					; 00000020H
	je	SHORT $LN260@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN261@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN260@xmlSchemaC
$LN261@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN234@xmlSchemaC
$LN260@xmlSchemaC:

; 4401 : 	    y++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL233@xmlSchemaC
$LN234@xmlSchemaC:

; 4402 : 	if (*y != 0) {

	test	al, al
	je	$LN177@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi

; 4404 : 		return(1);

	mov	eax, 1

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlSchemaC:

; 4838 : 			return (xmlSchemaComparePreserveCollapseStrings(yv, xv, 1));
; 4839 : 		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	eax, 2
	jne	SHORT $LN46@xmlSchemaC

; 4840 : 			return (xmlSchemaCompareReplaceCollapseStrings(yv, xv, 1));

	push	1
	push	ecx
	push	edx
	call	_xmlSchemaCompareReplaceCollapseStrings
	add	esp, 12					; 0000000cH
	pop	edi

; 4924 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlSchemaC:

; 4841 : 		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	eax, 3
	jne	$LN2@xmlSchemaC

; 4842 : 			return (xmlSchemaCompareNormStrings(xv, yv));

	push	edx
	push	ecx
	call	_xmlSchemaCompareNormStrings
	add	esp, 8
	pop	edi

; 4924 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlSchemaC:

; 4843 : 		} else
; 4844 : 		    return (-2);
; 4845 : 
; 4846 : 	    }
; 4847 :             return (-2);
; 4848 : 	}
; 4849 :         case XML_SCHEMAS_QNAME:
; 4850 : 	case XML_SCHEMAS_NOTATION:
; 4851 : 	    if ((x == NULL) || (y == NULL))

	mov	esi, DWORD PTR _x$[ebp]
	test	esi, esi
	je	$LN2@xmlSchemaC
	mov	edi, DWORD PTR _y$[ebp]
	test	edi, edi
	je	$LN2@xmlSchemaC

; 4852 : 		return(-2);
; 4853 :             if ((ytype == XML_SCHEMAS_QNAME) ||

	mov	eax, DWORD PTR _ytype$[ebp]
	cmp	eax, 21					; 00000015H
	je	SHORT $LN52@xmlSchemaC
	cmp	eax, 28					; 0000001cH
	jne	$LN2@xmlSchemaC
$LN52@xmlSchemaC:

; 4854 : 		(ytype == XML_SCHEMAS_NOTATION)) {
; 4855 : 		if ((xmlStrEqual(x->value.qname.name, y->value.qname.name)) &&

	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaC
	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN177@xmlSchemaC
$LN53@xmlSchemaC:
	pop	edi

; 4924 : }

	pop	esi
	mov	eax, 2
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlSchemaC:

; 4856 : 		    (xmlStrEqual(x->value.qname.uri, y->value.qname.uri)))
; 4857 : 		    return(0);
; 4858 : 		return(2);
; 4859 : 	    }
; 4860 : 	    return (-2);
; 4861 :         case XML_SCHEMAS_FLOAT:
; 4862 :         case XML_SCHEMAS_DOUBLE:
; 4863 : 	    if ((x == NULL) || (y == NULL))

	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN2@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	je	$LN2@xmlSchemaC

; 4864 : 		return(-2);
; 4865 :             if ((ytype == XML_SCHEMAS_FLOAT) ||

	mov	edx, DWORD PTR _ytype$[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN58@xmlSchemaC
	cmp	edx, 14					; 0000000eH
	jne	$LN2@xmlSchemaC
$LN58@xmlSchemaC:

; 4623 :     if (x->type == XML_SCHEMAS_DOUBLE)

	mov	edx, DWORD PTR [eax]
	cmp	edx, 14					; 0000000eH
	jne	SHORT $LN269@xmlSchemaC

; 4624 : 	d1 = x->value.d;

	movsd	xmm1, QWORD PTR [eax+8]
	jmp	SHORT $LN379@xmlSchemaC
$LN269@xmlSchemaC:

; 4625 :     else if (x->type == XML_SCHEMAS_FLOAT)

	cmp	edx, 13					; 0000000dH
	jne	$LN2@xmlSchemaC
	movss	xmm1, DWORD PTR [eax+8]

; 4626 : 	d1 = x->value.f;

	cvtps2pd xmm1, xmm1
$LN379@xmlSchemaC:

; 4627 :     else
; 4628 : 	return(-2);
; 4629 : 
; 4630 :     if (y->type == XML_SCHEMAS_DOUBLE)

	mov	eax, DWORD PTR [ecx]
	movsd	QWORD PTR _d1$1$[ebp], xmm1
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN273@xmlSchemaC

; 4631 : 	d2 = y->value.d;

	movsd	xmm0, QWORD PTR [ecx+8]
	jmp	SHORT $LN380@xmlSchemaC
$LN273@xmlSchemaC:

; 4632 :     else if (y->type == XML_SCHEMAS_FLOAT)

	cmp	eax, 13					; 0000000dH
	jne	$LN2@xmlSchemaC
	movss	xmm0, DWORD PTR [ecx+8]

; 4633 : 	d2 = y->value.f;

	cvtps2pd xmm0, xmm0
$LN380@xmlSchemaC:

; 4634 :     else
; 4635 : 	return(-2);
; 4636 : 
; 4637 :     /*
; 4638 :      * Check for special cases.
; 4639 :      */
; 4640 :     if (xmlXPathIsNaN(d1)) {

	sub	esp, 8
	movsd	QWORD PTR _d2$1$[ebp], xmm0
	movsd	QWORD PTR [esp], xmm1
	call	_xmlXPathIsNaN
	movsd	xmm0, QWORD PTR _d2$1$[ebp]
	mov	esi, eax
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	mov	ecx, eax
	test	esi, esi
	je	SHORT $LN277@xmlSchemaC

; 4641 : 	if (xmlXPathIsNaN(d2))

	xor	eax, eax
	test	ecx, ecx
	pop	edi

; 4924 : }

	pop	esi

; 4641 : 	if (xmlXPathIsNaN(d2))

	sete	al

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN277@xmlSchemaC:

; 4645 :     if (xmlXPathIsNaN(d2))

	test	ecx, ecx
	jne	$LN85@xmlSchemaC

; 4646 : 	return(-1);
; 4647 :     if (d1 == xmlXPathPINF) {

	movsd	xmm2, QWORD PTR _xmlXPathPINF
	movsd	xmm1, QWORD PTR _d1$1$[ebp]
	movsd	xmm0, QWORD PTR _d2$1$[ebp]
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN280@xmlSchemaC

; 4648 : 	if (d2 == xmlXPathPINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	$LN349@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN280@xmlSchemaC:

; 4652 :     if (d2 == xmlXPathPINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN282@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi

; 4653 :         return(-1);

	mov	eax, -1

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN282@xmlSchemaC:

; 4654 :     if (d1 == xmlXPathNINF) {

	movsd	xmm2, QWORD PTR _xmlXPathNINF
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN283@xmlSchemaC

; 4655 : 	if (d2 == xmlXPathNINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	$LN85@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN283@xmlSchemaC:

; 4659 :     if (d2 == xmlXPathNINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN349@xmlSchemaC

; 4660 :         return(1);
; 4661 : 
; 4662 :     /*
; 4663 :      * basic tests, the last one we should have equality, but
; 4664 :      * portability is more important than speed and handling
; 4665 :      * NaN or Inf in a portable way is always a challenge, so ...
; 4666 :      */
; 4667 :     if (d1 < d2)

	comisd	xmm0, xmm1
	ja	$LN85@xmlSchemaC

; 4668 : 	return(-1);
; 4669 :     if (d1 > d2)

	comisd	xmm1, xmm0
	ja	$LN349@xmlSchemaC

; 4670 : 	return(1);
; 4671 :     if (d1 == d2)

	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	$LN53@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi

; 4672 : 	return(0);

	xor	eax, eax

; 4924 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlSchemaC:

; 4866 :                 (ytype == XML_SCHEMAS_DOUBLE))
; 4867 :                 return (xmlSchemaCompareFloats(x, y));
; 4868 :             return (-2);
; 4869 :         case XML_SCHEMAS_BOOLEAN:
; 4870 : 	    if ((x == NULL) || (y == NULL))

	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN2@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	je	$LN2@xmlSchemaC

; 4871 : 		return(-2);
; 4872 :             if (ytype == XML_SCHEMAS_BOOLEAN) {

	cmp	DWORD PTR _ytype$[ebp], 15		; 0000000fH
	jne	$LN2@xmlSchemaC

; 4873 : 		if (x->value.b == y->value.b)

	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN177@xmlSchemaC

; 4874 : 		    return(0);
; 4875 : 		if (x->value.b == 0)

	test	eax, eax
	jne	$LN349@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlSchemaC:

; 4876 : 		    return(-1);
; 4877 : 		return(1);
; 4878 : 	    }
; 4879 : 	    return (-2);
; 4880 :         case XML_SCHEMAS_HEXBINARY:
; 4881 : 	    if ((x == NULL) || (y == NULL))

	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN2@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaC

; 4882 : 		return(-2);
; 4883 :             if (ytype == XML_SCHEMAS_HEXBINARY) {

	cmp	DWORD PTR _ytype$[ebp], 43		; 0000002bH

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	jmp	SHORT $LN384@xmlSchemaC
$LN75@xmlSchemaC:

; 4884 : 	        if (x->value.hex.total == y->value.hex.total) {
; 4885 : 		    int ret = xmlStrcmp(x->value.hex.str, y->value.hex.str);
; 4886 : 		    if (ret > 0)
; 4887 : 			return(1);
; 4888 : 		    else if (ret == 0)
; 4889 : 			return(0);
; 4890 : 		}
; 4891 : 		else if (x->value.hex.total > y->value.hex.total)
; 4892 : 		    return(1);
; 4893 : 
; 4894 : 		return(-1);
; 4895 :             }
; 4896 :             return (-2);
; 4897 :         case XML_SCHEMAS_BASE64BINARY:
; 4898 : 	    if ((x == NULL) || (y == NULL))

	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlSchemaC

; 4899 : 		return(-2);
; 4900 :             if (ytype == XML_SCHEMAS_BASE64BINARY) {

	cmp	DWORD PTR _ytype$[ebp], 44		; 0000002cH
$LN384@xmlSchemaC:

; 4901 :                 if (x->value.base64.total == y->value.base64.total) {
; 4902 :                     int ret = xmlStrcmp(x->value.base64.str,
; 4903 : 		                        y->value.base64.str);
; 4904 :                     if (ret > 0)
; 4905 :                         return(1);
; 4906 :                     else if (ret == 0)
; 4907 :                         return(0);

	jne	SHORT $LN2@xmlSchemaC
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN79@xmlSchemaC
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [eax+8]
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jg	$LN349@xmlSchemaC
	jne	$LN85@xmlSchemaC
$LN177@xmlSchemaC:
	pop	edi

; 4924 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@xmlSchemaC:

; 4908 : 		    else
; 4909 : 		        return(-1);
; 4910 :                 }
; 4911 :                 else if (x->value.base64.total > y->value.base64.total)
; 4912 :                     return(1);

	jbe	$LN85@xmlSchemaC

; 4924 : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@xmlSchemaC:

; 4913 :                 else
; 4914 :                     return(-1);
; 4915 :             }
; 4916 :             return (-2);
; 4917 :         case XML_SCHEMAS_IDREFS:
; 4918 :         case XML_SCHEMAS_ENTITIES:
; 4919 :         case XML_SCHEMAS_NMTOKENS:
; 4920 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	4920					; 00001338H
$LN369@xmlSchemaC:

; 4921 : 	    break;
; 4922 :     }
; 4923 :     return -2;

	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN2@xmlSchemaC:

; 4924 : }

	pop	edi
	pop	esi
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN386@xmlSchemaC:
	DD	$LN2@xmlSchemaC
	DD	$LN20@xmlSchemaC
	DD	$LN5@xmlSchemaC
	DD	$LN15@xmlSchemaC
	DD	$LN11@xmlSchemaC
	DD	$LN54@xmlSchemaC
	DD	$LN59@xmlSchemaC
	DD	$LN87@xmlSchemaC
	DD	$LN48@xmlSchemaC
	DD	$LN65@xmlSchemaC
	DD	$LN75@xmlSchemaC
$LN358@xmlSchemaC:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	4
	DB	5
	DB	5
	DB	6
	DB	1
	DB	1
	DB	1
	DB	7
	DB	1
	DB	8
	DB	1
	DB	1
	DB	1
	DB	7
	DB	1
	DB	7
	DB	8
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	9
	DB	10					; 0000000aH
	DB	0
	DB	1
_xmlSchemaCompareValuesInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareFloats
_TEXT	SEGMENT
_d1$1$ = -16						; size = 8
_d2$1$ = -8						; size = 8
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareFloats PROC				; COMDAT

; 4614 : xmlSchemaCompareFloats(xmlSchemaValPtr x, xmlSchemaValPtr y) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN3@xmlSchemaC

; 4615 :     double d1, d2;
; 4616 : 
; 4617 :     if ((x == NULL) || (y == NULL))

	mov	ecx, DWORD PTR _y$[ebp]
	test	ecx, ecx
	je	$LN3@xmlSchemaC

; 4619 : 
; 4620 :     /*
; 4621 :      * Cast everything to doubles.
; 4622 :      */
; 4623 :     if (x->type == XML_SCHEMAS_DOUBLE)

	mov	edx, DWORD PTR [eax]
	cmp	edx, 14					; 0000000eH
	jne	SHORT $LN4@xmlSchemaC

; 4624 : 	d1 = x->value.d;

	movsd	xmm1, QWORD PTR [eax+8]
	jmp	SHORT $LN28@xmlSchemaC
$LN4@xmlSchemaC:

; 4625 :     else if (x->type == XML_SCHEMAS_FLOAT)

	cmp	edx, 13					; 0000000dH
	jne	$LN3@xmlSchemaC

; 4626 : 	d1 = x->value.f;

	movss	xmm1, DWORD PTR [eax+8]
	cvtps2pd xmm1, xmm1
$LN28@xmlSchemaC:

; 4627 :     else
; 4628 : 	return(-2);
; 4629 : 
; 4630 :     if (y->type == XML_SCHEMAS_DOUBLE)

	mov	eax, DWORD PTR [ecx]
	movsd	QWORD PTR _d1$1$[ebp], xmm1
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN8@xmlSchemaC

; 4631 : 	d2 = y->value.d;

	movsd	xmm0, QWORD PTR [ecx+8]
	jmp	SHORT $LN29@xmlSchemaC
$LN8@xmlSchemaC:

; 4632 :     else if (y->type == XML_SCHEMAS_FLOAT)

	cmp	eax, 13					; 0000000dH
	jne	$LN3@xmlSchemaC

; 4633 : 	d2 = y->value.f;

	movss	xmm0, DWORD PTR [ecx+8]
	cvtps2pd xmm0, xmm0
$LN29@xmlSchemaC:

; 4634 :     else
; 4635 : 	return(-2);
; 4636 : 
; 4637 :     /*
; 4638 :      * Check for special cases.
; 4639 :      */
; 4640 :     if (xmlXPathIsNaN(d1)) {

	push	esi
	sub	esp, 8
	movsd	QWORD PTR _d2$1$[ebp], xmm0
	movsd	QWORD PTR [esp], xmm1
	call	_xmlXPathIsNaN
	movsd	xmm0, QWORD PTR _d2$1$[ebp]
	mov	esi, eax
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	esi, esi
	pop	esi
	je	SHORT $LN12@xmlSchemaC

; 4641 : 	if (xmlXPathIsNaN(d2))

	test	eax, eax
	jne	$LN27@xmlSchemaC
$LN25@xmlSchemaC:

; 4670 : 	return(1);

	mov	eax, 1

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemaC:

; 4642 : 	    return(0);
; 4643 : 	return(1);
; 4644 :     }
; 4645 :     if (xmlXPathIsNaN(d2))

	test	eax, eax
	jne	SHORT $LN26@xmlSchemaC

; 4646 : 	return(-1);
; 4647 :     if (d1 == xmlXPathPINF) {

	movsd	xmm2, QWORD PTR _xmlXPathPINF
	movsd	xmm1, QWORD PTR _d1$1$[ebp]
	movsd	xmm0, QWORD PTR _d2$1$[ebp]
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@xmlSchemaC

; 4648 : 	if (d2 == xmlXPathPINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@xmlSchemaC

; 4672 : 	return(0);

	xor	eax, eax

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSchemaC:

; 4649 : 	    return(0);
; 4650 :         return(1);
; 4651 :     }
; 4652 :     if (d2 == xmlXPathPINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@xmlSchemaC

; 4653 :         return(-1);
; 4654 :     if (d1 == xmlXPathNINF) {

	movsd	xmm2, QWORD PTR _xmlXPathNINF
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@xmlSchemaC

; 4655 : 	if (d2 == xmlXPathNINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@xmlSchemaC
$LN26@xmlSchemaC:

; 4668 : 	return(-1);

	or	eax, -1

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaC:

; 4656 : 	    return(0);
; 4657 :         return(-1);
; 4658 :     }
; 4659 :     if (d2 == xmlXPathNINF)

	ucomisd	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@xmlSchemaC

; 4660 :         return(1);
; 4661 : 
; 4662 :     /*
; 4663 :      * basic tests, the last one we should have equality, but
; 4664 :      * portability is more important than speed and handling
; 4665 :      * NaN or Inf in a portable way is always a challenge, so ...
; 4666 :      */
; 4667 :     if (d1 < d2)

	comisd	xmm0, xmm1
	ja	SHORT $LN26@xmlSchemaC

; 4669 :     if (d1 > d2)

	comisd	xmm1, xmm0
	ja	SHORT $LN25@xmlSchemaC

; 4671 :     if (d1 == d2)

	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@xmlSchemaC
$LN27@xmlSchemaC:

; 4672 : 	return(0);

	xor	eax, eax

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlSchemaC:

; 4673 :     return(2);

	mov	eax, 2

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 4618 : 	return(-2);

	mov	eax, -2					; fffffffeH

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareFloats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareNormStrings
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareNormStrings PROC			; COMDAT

; 4569 : 			    const xmlChar *y) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _x$[ebp]
$LL2@xmlSchemaC:

; 4570 :     int tmp;
; 4571 : 
; 4572 :     while (IS_BLANK_CH(*x)) x++;

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN17@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlSchemaC
$LN17@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN104@xmlSchemaC
$LN16@xmlSchemaC:
	inc	edx
	jmp	SHORT $LL2@xmlSchemaC
$LN104@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	push	ebx
	push	esi
	npad	6
$LL4@xmlSchemaC:

; 4573 :     while (IS_BLANK_CH(*y)) y++;

	mov	bl, BYTE PTR [ecx]
	cmp	bl, 32					; 00000020H
	je	SHORT $LN18@xmlSchemaC
	cmp	bl, 9
	jb	SHORT $LN19@xmlSchemaC
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LN18@xmlSchemaC
$LN19@xmlSchemaC:
	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN44@xmlSchemaC
$LN18@xmlSchemaC:
	inc	ecx
	jmp	SHORT $LL4@xmlSchemaC
$LN44@xmlSchemaC:

; 4574 :     while ((*x != 0) && (*y != 0)) {

	test	al, al
	je	SHORT $LN35@xmlSchemaC
	npad	3
$LL6@xmlSchemaC:
	mov	bl, BYTE PTR [ecx]
	mov	al, BYTE PTR [edx]
	test	bl, bl
	je	$LN7@xmlSchemaC

; 4575 : 	if (IS_BLANK_CH(*x)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN22@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN23@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN22@xmlSchemaC
$LN23@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN22@xmlSchemaC

; 4582 : 	} else {
; 4583 : 	    tmp = *x++ - *y++;

	movzx	esi, al
	inc	ecx
	movzx	eax, bl
	inc	edx
	sub	esi, eax

; 4584 : 	    if (tmp < 0)

	js	$LN81@xmlSchemaC

; 4585 : 		return(-1);
; 4586 : 	    if (tmp > 0)

	test	esi, esi
	jg	$LN80@xmlSchemaC
$LN115@xmlSchemaC:

; 4574 :     while ((*x != 0) && (*y != 0)) {

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LL6@xmlSchemaC
$LN35@xmlSchemaC:

; 4594 :     }
; 4595 :     if (*y != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	$LN39@xmlSchemaC
$LL14@xmlSchemaC:

; 4596 : 	while (IS_BLANK_CH(*y)) y++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN37@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN38@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN37@xmlSchemaC
$LN38@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	$LN15@xmlSchemaC
$LN37@xmlSchemaC:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL14@xmlSchemaC
$LN22@xmlSchemaC:

; 4576 : 	    if (!IS_BLANK_CH(*y)) {

	cmp	bl, 32					; 00000020H
	je	SHORT $LL8@xmlSchemaC
	cmp	bl, 9
	jb	SHORT $LN25@xmlSchemaC
	cmp	bl, 10					; 0000000aH
	jbe	SHORT $LL8@xmlSchemaC
$LN25@xmlSchemaC:
	cmp	bl, 13					; 0000000dH
	jne	SHORT $LN52@xmlSchemaC
$LL8@xmlSchemaC:

; 4578 : 		return(tmp);
; 4579 : 	    }
; 4580 : 	    while (IS_BLANK_CH(*x)) x++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN26@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN27@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN26@xmlSchemaC
$LN27@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LL10@xmlSchemaC
$LN26@xmlSchemaC:
	mov	al, BYTE PTR [edx+1]
	inc	edx
	jmp	SHORT $LL8@xmlSchemaC
$LL10@xmlSchemaC:

; 4581 : 	    while (IS_BLANK_CH(*y)) y++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN28@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN29@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN28@xmlSchemaC
$LN29@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN115@xmlSchemaC
$LN28@xmlSchemaC:
	inc	ecx
	jmp	SHORT $LL10@xmlSchemaC
$LN52@xmlSchemaC:

; 4577 : 		tmp = *x - *y;

	movzx	ecx, bl
	movzx	eax, al
	pop	esi
	sub	eax, ecx

; 4601 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemaC:

; 4587 : 		return(1);
; 4588 : 	}
; 4589 :     }
; 4590 :     if (*x != 0) {

	test	al, al
	je	SHORT $LN35@xmlSchemaC
	npad	4
$LL12@xmlSchemaC:

; 4591 : 	while (IS_BLANK_CH(*x)) x++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN33@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN34@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN33@xmlSchemaC
$LN34@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN13@xmlSchemaC
$LN33@xmlSchemaC:
	mov	al, BYTE PTR [edx+1]
	inc	edx
	jmp	SHORT $LL12@xmlSchemaC
$LN13@xmlSchemaC:

; 4592 : 	if (*x != 0)

	test	al, al
	je	$LN35@xmlSchemaC
$LN80@xmlSchemaC:
	pop	esi

; 4593 : 	    return(1);

	mov	eax, 1

; 4601 : }

	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlSchemaC:

; 4597 : 	if (*y != 0)

	test	al, al
	je	SHORT $LN39@xmlSchemaC
$LN81@xmlSchemaC:
	pop	esi

; 4598 : 	    return(-1);

	or	eax, -1

; 4601 : }

	pop	ebx
	pop	ebp
	ret	0
$LN39@xmlSchemaC:
	pop	esi

; 4599 :     }
; 4600 :     return(0);

	xor	eax, eax

; 4601 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchemaCompareNormStrings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareReplacedStrings
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareReplacedStrings PROC			; COMDAT

; 4523 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN19@xmlSchemaC
	npad	6
$LL2@xmlSchemaC:

; 4524 :     int tmp;
; 4525 : 
; 4526 :     while ((*x != 0) && (*y != 0)) {

	mov	cl, BYTE PTR [edx]
	test	cl, cl
	je	SHORT $LN3@xmlSchemaC

; 4527 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN6@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN7@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN6@xmlSchemaC

; 4530 : 		    return(-1);
; 4531 : 		else
; 4532 : 		    return(1);
; 4533 : 	    }
; 4534 : 	} else {
; 4535 : 	    if IS_WSP_BLANK_CH(*x) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN14@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlSchemaC
$LN14@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN13@xmlSchemaC

; 4537 : 		    return(-1);
; 4538 : 		else
; 4539 : 		    return(1);
; 4540 : 	    }
; 4541 : 	    tmp = *x - *y;

	movzx	ecx, cl
	movzx	eax, al
	sub	eax, ecx

; 4542 : 	    if (tmp < 0)

	js	SHORT $LN31@xmlSchemaC

; 4543 : 		return(-1);
; 4544 : 	    if (tmp > 0)

	test	eax, eax
	jg	SHORT $LN30@xmlSchemaC
	jmp	SHORT $LN11@xmlSchemaC
$LN6@xmlSchemaC:

; 4528 : 	    if (! IS_WSP_BLANK_CH(*x)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN9@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlSchemaC
$LN9@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN26@xmlSchemaC
$LN11@xmlSchemaC:

; 4524 :     int tmp;
; 4525 : 
; 4526 :     while ((*x != 0) && (*y != 0)) {

	mov	al, BYTE PTR [esi+1]

; 4545 : 		return(1);
; 4546 : 	}
; 4547 : 	x++;

	inc	esi

; 4548 : 	y++;

	inc	edx
	test	al, al
	jne	SHORT $LL2@xmlSchemaC
$LN19@xmlSchemaC:

; 4552 :     if (*y != 0)

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN20@xmlSchemaC
$LN31@xmlSchemaC:

; 4553 :         return(-1);

	or	eax, -1
	pop	esi

; 4555 : }

	pop	ebp
	ret	0
$LN13@xmlSchemaC:

; 4536 : 		if ((0x20 - *y) < 0)

	movzx	eax, cl
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	jns	SHORT $LN30@xmlSchemaC

; 4553 :         return(-1);

	or	eax, -1
	pop	esi

; 4555 : }

	pop	ebp
	ret	0
$LN26@xmlSchemaC:

; 4529 : 		if ((*x - 0x20) < 0)

	cmp	al, 32					; 00000020H
	jae	SHORT $LN30@xmlSchemaC

; 4553 :         return(-1);

	or	eax, -1
	pop	esi

; 4555 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 4549 :     }
; 4550 :     if (*x != 0)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN19@xmlSchemaC
$LN30@xmlSchemaC:

; 4551 :         return(1);

	mov	eax, 1
	pop	esi

; 4555 : }

	pop	ebp
	ret	0
$LN20@xmlSchemaC:

; 4554 :     return(0);

	xor	eax, eax
	pop	esi

; 4555 : }

	pop	ebp
	ret	0
_xmlSchemaCompareReplacedStrings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareReplaceCollapseStrings
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaCompareReplaceCollapseStrings PROC		; COMDAT

; 4429 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _y$[ebp]
$LL2@xmlSchemaC:

; 4430 :     int tmp;
; 4431 : 
; 4432 :     /*
; 4433 :     * Skip leading blank chars of the collapsed string.
; 4434 :     */
; 4435 :     while IS_WSP_BLANK_CH(*y)

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN11@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN49@xmlSchemaC
$LN10@xmlSchemaC:

; 4436 : 	y++;

	inc	eax
	jmp	SHORT $LL2@xmlSchemaC
$LN49@xmlSchemaC:
	push	esi

; 4437 : 
; 4438 :     while ((*x != 0) && (*y != 0)) {

	mov	esi, DWORD PTR _x$[ebp]
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN39@xmlSchemaC
$LL4@xmlSchemaC:
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN70@xmlSchemaC

; 4439 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN14@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN15@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN14@xmlSchemaC

; 4462 : 		y++;
; 4463 : 	} else {
; 4464 : 	    if IS_WSP_BLANK_CH(*x) {

	mov	dl, BYTE PTR [esi]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN27@xmlSchemaC
	cmp	dl, 9
	jb	SHORT $LN28@xmlSchemaC
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN27@xmlSchemaC
$LN28@xmlSchemaC:
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN27@xmlSchemaC

; 4469 : 		    if (invert)
; 4470 : 			return(1);
; 4471 : 		    else
; 4472 : 			return(-1);
; 4473 : 		} else {
; 4474 : 		    if (invert)
; 4475 : 			return(-1);
; 4476 : 		    else
; 4477 : 			return(1);
; 4478 : 		}
; 4479 : 	    }
; 4480 : 	    tmp = *x++ - *y++;

	movzx	edx, dl
	inc	eax
	movzx	ecx, cl
	sub	edx, ecx

; 4481 : 	    if (tmp < 0)

	js	SHORT $LN44@xmlSchemaC

; 4482 : 		return(-1);
; 4483 : 	    if (tmp > 0)

	test	edx, edx
	jg	$LN67@xmlSchemaC
	jmp	SHORT $LN74@xmlSchemaC
$LN14@xmlSchemaC:

; 4440 : 	    if (! IS_WSP_BLANK_CH(*x)) {

	mov	cl, BYTE PTR [esi]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN23@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN17@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlSchemaC
$LN17@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN56@xmlSchemaC
$LN23@xmlSchemaC:

; 4445 : 		    if (invert)
; 4446 : 			return(1);
; 4447 : 		    else
; 4448 : 			return(-1);
; 4449 : 		} else {
; 4450 : 		    if (invert)
; 4451 : 			return(-1);
; 4452 : 		    else
; 4453 : 			return(1);
; 4454 : 		}
; 4455 : 	    }
; 4456 : 	    x++;
; 4457 : 	    y++;
; 4458 : 	    /*
; 4459 : 	    * Skip contiguous blank chars of the collapsed string.
; 4460 : 	    */
; 4461 : 	    while IS_WSP_BLANK_CH(*y)

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 32					; 00000020H
	je	SHORT $LN23@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN25@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlSchemaC
$LN25@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN23@xmlSchemaC
$LN74@xmlSchemaC:

; 4437 : 
; 4438 :     while ((*x != 0) && (*y != 0)) {

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL4@xmlSchemaC
$LN70@xmlSchemaC:

; 4484 : 		return(1);
; 4485 : 	}
; 4486 :     }
; 4487 :     if (*x != 0) {

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN77@xmlSchemaC
$LN39@xmlSchemaC:

; 4488 : 	 if (invert)
; 4489 : 	     return(-1);
; 4490 : 	 else
; 4491 : 	     return(1);
; 4492 :     }
; 4493 :     if (*y != 0) {

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN45@xmlSchemaC
$LL8@xmlSchemaC:

; 4494 : 	/*
; 4495 : 	* Skip trailing blank chars of the collapsed string.
; 4496 : 	*/
; 4497 : 	while IS_WSP_BLANK_CH(*y)

	cmp	cl, 32					; 00000020H
	je	SHORT $LN41@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN42@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN41@xmlSchemaC
$LN42@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlSchemaC
$LN41@xmlSchemaC:

; 4498 : 	    y++;

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	jmp	SHORT $LL8@xmlSchemaC
$LN27@xmlSchemaC:

; 4465 : 		/*
; 4466 : 		* The xv character would have been replaced to 0x20.
; 4467 : 		*/
; 4468 : 		if ((0x20 - *y) < 0) {

	movzx	eax, cl
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	js	SHORT $LN76@xmlSchemaC
$LN77@xmlSchemaC:

; 4502 : 	    else
; 4503 : 		return(-1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN67@xmlSchemaC
$LN44@xmlSchemaC:
	or	eax, -1
	pop	esi

; 4507 : }

	pop	ebp
	ret	0
$LN56@xmlSchemaC:

; 4441 : 		/*
; 4442 : 		* The yv character would have been replaced to 0x20.
; 4443 : 		*/
; 4444 : 		if ((*x - 0x20) < 0) {

	cmp	cl, 32					; 00000020H
	jb	SHORT $LN76@xmlSchemaC

; 4502 : 	    else
; 4503 : 		return(-1);

	jmp	SHORT $LN77@xmlSchemaC
$LN9@xmlSchemaC:

; 4499 : 	if (*y != 0) {

	test	cl, cl
	je	SHORT $LN45@xmlSchemaC
$LN76@xmlSchemaC:

; 4500 : 	    if (invert)
; 4501 : 		return(1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN44@xmlSchemaC
$LN67@xmlSchemaC:
	mov	eax, 1
	pop	esi

; 4507 : }

	pop	ebp
	ret	0
$LN45@xmlSchemaC:

; 4504 : 	}
; 4505 :     }
; 4506 :     return(0);

	xor	eax, eax
	pop	esi

; 4507 : }

	pop	ebp
	ret	0
_xmlSchemaCompareReplaceCollapseStrings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaComparePreserveCollapseStrings
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaComparePreserveCollapseStrings PROC		; COMDAT

; 4340 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _y$[ebp]
$LL2@xmlSchemaC:

; 4341 :     int tmp;
; 4342 : 
; 4343 :     /*
; 4344 :     * Skip leading blank chars of the collapsed string.
; 4345 :     */
; 4346 :     while IS_WSP_BLANK_CH(*y)

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN11@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN43@xmlSchemaC
$LN10@xmlSchemaC:

; 4347 : 	y++;

	inc	eax
	jmp	SHORT $LL2@xmlSchemaC
$LN43@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	mov	edx, DWORD PTR _x$[ebp]
	push	esi
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN33@xmlSchemaC
$LL4@xmlSchemaC:
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN5@xmlSchemaC

; 4350 : 	if IS_WSP_BLANK_CH(*y) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN14@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN15@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN14@xmlSchemaC

; 4373 : 		y++;
; 4374 : 	} else {
; 4375 : 	    tmp = *x++ - *y++;

	movzx	esi, BYTE PTR [edx]
	inc	eax
	movzx	ecx, cl
	sub	esi, ecx

; 4376 : 	    if (tmp < 0) {

	js	SHORT $LN47@xmlSchemaC

; 4377 : 		if (invert)
; 4378 : 		    return(1);
; 4379 : 		else
; 4380 : 		    return(-1);
; 4381 : 	    }
; 4382 : 	    if (tmp > 0) {

	test	esi, esi
	jg	SHORT $LN70@xmlSchemaC
	jmp	SHORT $LN67@xmlSchemaC
$LN14@xmlSchemaC:

; 4351 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	jne	SHORT $LN68@xmlSchemaC
$LN23@xmlSchemaC:

; 4356 : 		    if (invert)
; 4357 : 			return(1);
; 4358 : 		    else
; 4359 : 			return(-1);
; 4360 : 		} else {
; 4361 : 		    if (invert)
; 4362 : 			return(-1);
; 4363 : 		    else
; 4364 : 			return(1);
; 4365 : 		}
; 4366 : 	    }
; 4367 : 	    x++;
; 4368 : 	    y++;
; 4369 : 	    /*
; 4370 : 	    * Skip contiguous blank chars of the collapsed string.
; 4371 : 	    */
; 4372 : 	    while IS_WSP_BLANK_CH(*y)

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 32					; 00000020H
	je	SHORT $LN23@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN24@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlSchemaC
$LN24@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN23@xmlSchemaC
$LN67@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	inc	edx
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LL4@xmlSchemaC
$LN5@xmlSchemaC:

; 4383 : 		if (invert)
; 4384 : 		    return(-1);
; 4385 : 		else
; 4386 : 		    return(1);
; 4387 : 	    }
; 4388 : 	}
; 4389 :     }
; 4390 :     if (*x != 0) {

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN70@xmlSchemaC
$LN33@xmlSchemaC:

; 4391 : 	 if (invert)
; 4392 : 	     return(-1);
; 4393 : 	 else
; 4394 : 	     return(1);
; 4395 :     }
; 4396 :     if (*y != 0) {

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN39@xmlSchemaC
	npad	3
$LL8@xmlSchemaC:

; 4397 : 	/*
; 4398 : 	* Skip trailing blank chars of the collapsed string.
; 4399 : 	*/
; 4400 : 	while IS_WSP_BLANK_CH(*y)

	cmp	cl, 32					; 00000020H
	je	SHORT $LN35@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN36@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN35@xmlSchemaC
$LN36@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlSchemaC
$LN35@xmlSchemaC:

; 4401 : 	    y++;

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	jmp	SHORT $LL8@xmlSchemaC
$LN68@xmlSchemaC:

; 4352 : 		/*
; 4353 : 		* The yv character would have been replaced to 0x20.
; 4354 : 		*/
; 4355 : 		if ((*x - 0x20) < 0) {

	jb	SHORT $LN47@xmlSchemaC
$LN70@xmlSchemaC:

; 4405 : 	    else
; 4406 : 		return(-1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN60@xmlSchemaC
$LN38@xmlSchemaC:
	or	eax, -1
	pop	esi

; 4410 : }

	pop	ebp
	ret	0
$LN9@xmlSchemaC:

; 4402 : 	if (*y != 0) {

	test	cl, cl
	je	SHORT $LN39@xmlSchemaC
$LN47@xmlSchemaC:

; 4403 : 	    if (invert)
; 4404 : 		return(1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN38@xmlSchemaC
$LN60@xmlSchemaC:
	mov	eax, 1
	pop	esi

; 4410 : }

	pop	ebp
	ret	0
$LN39@xmlSchemaC:

; 4407 : 	}
; 4408 :     }
; 4409 :     return(0);

	xor	eax, eax
	pop	esi

; 4410 : }

	pop	ebp
	ret	0
_xmlSchemaComparePreserveCollapseStrings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaComparePreserveReplaceStrings
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaComparePreserveReplaceStrings PROC		; COMDAT

; 4272 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	SHORT $LN22@xmlSchemaC
	npad	6
$LL2@xmlSchemaC:

; 4273 :     int tmp;
; 4274 : 
; 4275 :     while ((*x != 0) && (*y != 0)) {

	mov	al, BYTE PTR [edx]
	test	al, al
	je	SHORT $LN3@xmlSchemaC

; 4276 : 	if (IS_WSP_REPLACE_CH(*y)) {

	cmp	al, 9
	je	SHORT $LN6@xmlSchemaC
	cmp	al, 10					; 0000000aH
	je	SHORT $LN6@xmlSchemaC
	cmp	al, 13					; 0000000dH
	je	SHORT $LN6@xmlSchemaC

; 4279 : 		    if (invert)
; 4280 : 			return(1);
; 4281 : 		    else
; 4282 : 			return(-1);
; 4283 : 		} else {
; 4284 : 		    if (invert)
; 4285 : 			return(-1);
; 4286 : 		    else
; 4287 : 			return(1);
; 4288 : 		}
; 4289 : 	    }
; 4290 : 	} else {
; 4291 : 	    tmp = *x - *y;

	movzx	eax, al
	movzx	ecx, cl
	sub	ecx, eax

; 4292 : 	    if (tmp < 0) {

	js	SHORT $LN28@xmlSchemaC

; 4293 : 		if (invert)
; 4294 : 		    return(1);
; 4295 : 		else
; 4296 : 		    return(-1);
; 4297 : 	    }
; 4298 : 	    if (tmp > 0) {

	test	ecx, ecx
	jg	SHORT $LN38@xmlSchemaC
	jmp	SHORT $LN13@xmlSchemaC
$LN6@xmlSchemaC:

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	cmp	cl, 32					; 00000020H
	jne	SHORT $LN30@xmlSchemaC
$LN13@xmlSchemaC:

; 4273 :     int tmp;
; 4274 : 
; 4275 :     while ((*x != 0) && (*y != 0)) {

	mov	cl, BYTE PTR [esi+1]

; 4299 : 		if (invert)
; 4300 : 		    return(-1);
; 4301 : 		else
; 4302 : 		    return(1);
; 4303 : 	    }
; 4304 : 	}
; 4305 : 	x++;

	inc	esi

; 4306 : 	y++;

	inc	edx
	test	cl, cl
	jne	SHORT $LL2@xmlSchemaC

; 4273 :     int tmp;
; 4274 : 
; 4275 :     while ((*x != 0) && (*y != 0)) {

	jmp	SHORT $LN22@xmlSchemaC
$LN30@xmlSchemaC:

; 4278 : 		if ((*x - 0x20) < 0) {

	jb	SHORT $LN28@xmlSchemaC
$LN38@xmlSchemaC:

; 4317 : 	else
; 4318 : 	    return(-1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN34@xmlSchemaC
$LN24@xmlSchemaC:
	or	eax, -1
	pop	esi

; 4321 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 4307 :     }
; 4308 :     if (*x != 0) {

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN38@xmlSchemaC
$LN22@xmlSchemaC:

; 4309 : 	if (invert)
; 4310 : 	    return(-1);
; 4311 : 	else
; 4312 : 	    return(1);
; 4313 :     }
; 4314 :     if (*y != 0) {

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN25@xmlSchemaC
$LN28@xmlSchemaC:

; 4315 : 	if (invert)
; 4316 : 	    return(1);

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN24@xmlSchemaC
$LN34@xmlSchemaC:
	mov	eax, 1
	pop	esi

; 4321 : }

	pop	ebp
	ret	0
$LN25@xmlSchemaC:

; 4319 :     }
; 4320 :     return(0);

	xor	eax, eax
	pop	esi

; 4321 : }

	pop	ebp
	ret	0
_xmlSchemaComparePreserveReplaceStrings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDates
_TEXT	SEGMENT
_q1d$2$ = -24						; size = 4
_q1$3$ = -24						; size = 4
_p1$1$ = -24						; size = 4
_ret$1$ = -20						; size = 4
_p1d$1$ = -20						; size = 4
_p2$1$ = -16						; size = 4
_ret$1$ = -12						; size = 4
tv845 = -12						; size = 4
tv823 = -12						; size = 4
tv787 = -8						; size = 4
tv750 = -8						; size = 4
_q1$2$ = -8						; size = 4
_q2$1$ = -4						; size = 4
_p1$3$ = -4						; size = 4
tv871 = 8						; size = 4
_q1$1$ = 8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDates PROC				; COMDAT

; 4009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _x$[ebp]
	test	edi, edi
	je	$LN7@xmlSchemaC

; 4010 :     unsigned char xmask, ymask, xor_mask, and_mask;
; 4011 :     xmlSchemaValPtr p1, p2, q1, q2;
; 4012 :     long p1d, p2d, q1d, q2d;
; 4013 : 
; 4014 :     if ((x == NULL) || (y == NULL))

	mov	ebx, DWORD PTR _y$[ebp]
	test	ebx, ebx
	je	$LN7@xmlSchemaC

; 4016 : 
; 4017 :     if (x->value.date.tz_flag) {

	mov	eax, DWORD PTR [ebx+24]
	and	eax, 1
	test	BYTE PTR [edi+24], 1
	push	esi
	je	$LN8@xmlSchemaC

; 4018 : 
; 4019 :         if (!y->value.date.tz_flag) {

	test	eax, eax
	jne	$LN27@xmlSchemaC

; 4020 :             p1 = xmlSchemaDateNormalize(x, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	edi
	call	_xmlSchemaDateNormalize
	mov	esi, eax

; 4021 :             p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	push	esi
	mov	DWORD PTR _p1$1$[ebp], esi
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR [esi+12]

; 4022 :             /* normalize y + 14:00 */
; 4023 :             q1 = xmlSchemaDateNormalize(y, (14 * SECS_PER_HOUR));

	add	esp, 8
	movsd	xmm0, QWORD PTR __real@40e89c0000000000
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	movsd	QWORD PTR [esp], xmm0
	push	ebx
	mov	DWORD PTR _p1d$1$[ebp], eax
	call	_xmlSchemaDateNormalize

; 4024 : 
; 4025 :             q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	push	eax
	mov	DWORD PTR _q1$1$[ebp], eax
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv750[ebp], ecx
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR tv750[ebp]
	add	esp, 16					; 00000010H
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	lea	edx, DWORD PTR [ecx+eax]

; 4026 :             if (p1d < q1d) {

	cmp	DWORD PTR _p1d$1$[ebp], edx
	jl	$LN103@xmlSchemaC

; 4027 : 		xmlSchemaFreeValue(p1);
; 4028 : 		xmlSchemaFreeValue(q1);
; 4029 :                 return -1;
; 4030 : 	    } else if (p1d == q1d) {

	jne	$LN13@xmlSchemaC

; 4031 :                 double sec;
; 4032 : 
; 4033 :                 sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	edx, DWORD PTR [esi+12]
	mov	eax, edx
	shr	eax, 9
	and	eax, 31					; 0000001fH
	shr	edx, 14					; 0000000eH
	mov	ecx, eax
	and	edx, 63					; 0000003fH
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, edx
	mov	edx, DWORD PTR _q1$1$[ebp]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	shl	ecx, 2
	mov	edx, DWORD PTR [edx+24]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	movd	xmm1, ecx
	shr	ecx, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	ecx, DWORD PTR tv750[ebp]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	mov	ecx, DWORD PTR tv750[ebp]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	addsd	xmm1, QWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+eax*4]
	add	eax, ecx
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR _q1$1$[ebp]
	shl	ecx, 2
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	addsd	xmm0, QWORD PTR [eax+16]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0

; 4034 :                 if (sec < 0.0) {

	comisd	xmm0, xmm1
	ja	$LN103@xmlSchemaC

; 4038 : 		} else {
; 4039 : 		    int ret = 0;
; 4040 :                     /* normalize y - 14:00 */
; 4041 :                     q2 = xmlSchemaDateNormalize(y, -(14 * SECS_PER_HOUR));

	movsd	xmm0, QWORD PTR __real@c0e89c0000000000
	sub	esp, 8
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
	movsd	QWORD PTR [esp], xmm0
	push	ebx
	call	_xmlSchemaDateNormalize

; 4042 :                     q2d = _xmlSchemaDateCastYMToDays(q2) + q2->value.date.day;

	push	eax
	mov	DWORD PTR _q2$1$[ebp], eax
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv787[ebp], ecx
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR tv787[ebp]
	add	esp, 16					; 00000010H
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	lea	edx, DWORD PTR [ecx+eax]

; 4043 :                     if (p1d > q2d)

	cmp	DWORD PTR _p1d$1$[ebp], edx
	jle	SHORT $LN17@xmlSchemaC

; 4044 :                         ret = 1;

	mov	eax, 1
	jmp	$LN105@xmlSchemaC
$LN17@xmlSchemaC:

; 4045 :                     else if (p1d == q2d) {

	jne	$LN20@xmlSchemaC

; 4046 :                         sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2);

	mov	edx, DWORD PTR [esi+12]
	mov	eax, edx
	shr	eax, 9
	and	eax, 31					; 0000001fH
	shr	edx, 14					; 0000000eH
	mov	ecx, eax
	and	edx, 63					; 0000003fH
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR tv787[ebp]
	add	esi, edx
	shr	ecx, 9
	mov	edx, DWORD PTR _q2$1$[ebp]
	and	ecx, 31					; 0000001fH
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	mov	edx, DWORD PTR [edx+24]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR tv787[ebp]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	add	ecx, eax
	imul	eax, esi, 15
	mov	esi, DWORD PTR _p1$1$[ebp]
	shl	eax, 2
	movd	xmm1, eax
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	imul	eax, ecx, 15
	addsd	xmm1, QWORD PTR [esi+16]
	shl	eax, 2
	movd	xmm0, eax
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _q2$1$[ebp]
	addsd	xmm0, QWORD PTR [eax+16]

; 4047 :                         if (sec > 0.0)

	xor	eax, eax
	subsd	xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@0000000000000000
	setbe	al
	inc	eax
$LN105@xmlSchemaC:

; 4048 :                             ret = 1;
; 4049 :                         else
; 4050 :                             ret = 2; /* indeterminate */
; 4051 :                     }
; 4052 : 		    xmlSchemaFreeValue(p1);

	mov	DWORD PTR _ret$1$[ebp], eax
$LN20@xmlSchemaC:
	push	esi
	call	_xmlSchemaFreeValue

; 4053 : 		    xmlSchemaFreeValue(q1);

	push	DWORD PTR _q1$1$[ebp]
	call	_xmlSchemaFreeValue

; 4054 : 		    xmlSchemaFreeValue(q2);

	push	DWORD PTR _q2$1$[ebp]
	call	_xmlSchemaFreeValue

; 4055 : 		    if (ret != 0)

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@xmlSchemaC

; 4252 : }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaC:

; 4056 : 		        return(ret);
; 4057 :                 }
; 4058 :             } else {
; 4059 : 		xmlSchemaFreeValue(p1);

	push	esi
	call	_xmlSchemaFreeValue

; 4060 : 		xmlSchemaFreeValue(q1);

	push	DWORD PTR _q1$1$[ebp]
$LN107@xmlSchemaC:

; 4107 :         }
; 4108 :     }
; 4109 : 
; 4110 :     /*
; 4111 :      * if the same type then calculate the difference
; 4112 :      */
; 4113 :     if (x->type == y->type) {

	call	_xmlSchemaFreeValue
	add	esp, 8
$LN27@xmlSchemaC:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ebx]
	cmp	eax, edx
	jne	$LN36@xmlSchemaC

; 4114 :         int ret = 0;
; 4115 :         q1 = xmlSchemaDateNormalize(y, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	ebx
	call	_xmlSchemaDateNormalize
	mov	ebx, eax

; 4116 :         q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	push	ebx
	mov	DWORD PTR _q1$3$[ebp], ebx
	call	__xmlSchemaDateCastYMToDays
	mov	esi, DWORD PTR [ebx+12]

; 4117 : 
; 4118 :         p1 = xmlSchemaDateNormalize(x, 0);

	add	esp, 8
	shr	esi, 4
	xorps	xmm0, xmm0
	and	esi, 31					; 0000001fH
	add	esi, eax
	movsd	QWORD PTR [esp], xmm0
	push	edi
	call	_xmlSchemaDateNormalize
	mov	edi, eax

; 4119 :         p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	push	edi
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR tv871[ebp], eax
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR tv871[ebp]
	add	esp, 16					; 00000010H
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx

; 4120 : 
; 4121 :         if (p1d < q1d) {

	cmp	eax, esi
	jl	$LN108@xmlSchemaC

; 4122 :             ret = -1;
; 4123 : 	} else if (p1d > q1d) {

	jle	$LN39@xmlSchemaC

; 4124 :             ret = 1;

	mov	ebx, 1

; 4125 : 	} else {

	jmp	$LN43@xmlSchemaC
$LN103@xmlSchemaC:

; 4035 : 		    xmlSchemaFreeValue(p1);

	push	esi
	call	_xmlSchemaFreeValue

; 4036 : 		    xmlSchemaFreeValue(q1);

	push	DWORD PTR _q1$1$[ebp]
	call	_xmlSchemaFreeValue
	add	esp, 8
$LN100@xmlSchemaC:

; 4037 :                     return -1;

	pop	esi
	pop	edi
	or	eax, -1

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaC:

; 4061 : 	    }
; 4062 :         }
; 4063 :     } else if (y->value.date.tz_flag) {

	test	eax, eax
	je	$LN27@xmlSchemaC

; 4064 :         q1 = xmlSchemaDateNormalize(y, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	ebx
	call	_xmlSchemaDateNormalize
	mov	esi, eax

; 4065 :         q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	push	esi
	mov	DWORD PTR _q1$2$[ebp], esi
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR [esi+12]

; 4066 : 
; 4067 :         /* normalize x - 14:00 */
; 4068 :         p1 = xmlSchemaDateNormalize(x, -(14 * SECS_PER_HOUR));

	add	esp, 8
	movsd	xmm0, QWORD PTR __real@c0e89c0000000000
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	movsd	QWORD PTR [esp], xmm0
	push	edi
	mov	DWORD PTR _q1d$2$[ebp], eax
	call	_xmlSchemaDateNormalize

; 4069 :         p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	push	eax
	mov	DWORD PTR _p1$3$[ebp], eax
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv823[ebp], ecx
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR tv823[ebp]
	add	esp, 16					; 00000010H
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	lea	edx, DWORD PTR [ecx+eax]

; 4070 : 
; 4071 :         if (p1d < q1d) {

	cmp	edx, DWORD PTR _q1d$2$[ebp]
	jl	$LN102@xmlSchemaC

; 4072 : 	    xmlSchemaFreeValue(p1);
; 4073 : 	    xmlSchemaFreeValue(q1);
; 4074 :             return -1;
; 4075 : 	} else if (p1d == q1d) {

	jne	$LN26@xmlSchemaC

; 4076 :             double sec;
; 4077 : 
; 4078 :             sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	ecx, DWORD PTR tv823[ebp]
	mov	edx, DWORD PTR _p1$3$[ebp]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	mov	esi, DWORD PTR [esi+12]
	mov	eax, ecx
	mov	edx, DWORD PTR [edx+24]
	shl	eax, 4
	sub	eax, ecx
	shl	edx, 19					; 00000013H
	mov	ecx, DWORD PTR tv823[ebp]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	sar	edx, 20					; 00000014H
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _q1$2$[ebp]
	add	eax, ecx
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	edx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _p1$3$[ebp]
	shl	ecx, 2
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	movd	xmm1, ecx
	shr	ecx, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	ecx, esi
	shr	esi, 14					; 0000000eH
	shr	ecx, 9
	and	esi, 63					; 0000003fH
	and	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR [eax+16]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	lea	eax, DWORD PTR [edx+eax*4]
	add	eax, esi
	mov	esi, DWORD PTR _q1$2$[ebp]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	shl	ecx, 2
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	addsd	xmm0, QWORD PTR [esi+16]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0

; 4079 :             if (sec < 0.0) {

	comisd	xmm0, xmm1
	ja	$LN102@xmlSchemaC

; 4082 :                 return -1;
; 4083 : 	    } else {
; 4084 : 	        int ret = 0;
; 4085 :                 /* normalize x + 14:00 */
; 4086 :                 p2 = xmlSchemaDateNormalize(x, (14 * SECS_PER_HOUR));

	movsd	xmm0, QWORD PTR __real@40e89c0000000000
	sub	esp, 8
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], eax
	movsd	QWORD PTR [esp], xmm0
	push	edi
	call	_xmlSchemaDateNormalize

; 4087 :                 p2d = _xmlSchemaDateCastYMToDays(p2) + p2->value.date.day;

	push	eax
	mov	DWORD PTR _p2$1$[ebp], eax
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv845[ebp], ecx
	call	__xmlSchemaDateCastYMToDays
	mov	ecx, DWORD PTR tv845[ebp]
	add	esp, 16					; 00000010H
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	lea	edx, DWORD PTR [ecx+eax]

; 4088 : 
; 4089 :                 if (p2d > q1d) {

	cmp	edx, DWORD PTR _q1d$2$[ebp]
	jle	SHORT $LN30@xmlSchemaC

; 4090 :                     ret = 1;

	mov	eax, 1
	jmp	$LN106@xmlSchemaC
$LN30@xmlSchemaC:

; 4091 : 		} else if (p2d == q1d) {

	jne	$LN33@xmlSchemaC

; 4092 :                     sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1);

	mov	ecx, DWORD PTR tv845[ebp]
	mov	edx, DWORD PTR _p2$1$[ebp]
	mov	edi, DWORD PTR [esi+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR [edx+24]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	mov	ecx, edi
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	shr	edi, 14					; 0000000eH
	and	edi, 63					; 0000003fH
	lea	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR tv845[ebp]
	mov	edx, DWORD PTR _q1$2$[ebp]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	add	esi, eax
	mov	eax, ecx
	mov	edx, DWORD PTR [edx+24]
	shl	eax, 4
	sub	eax, ecx
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	lea	ecx, DWORD PTR [edx+eax*4]
	imul	eax, esi, 15
	mov	esi, DWORD PTR _q1$2$[ebp]
	add	ecx, edi
	mov	edi, DWORD PTR _x$[ebp]
	shl	eax, 2
	movd	xmm1, eax
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _p2$1$[ebp]
	addsd	xmm1, QWORD PTR [eax+16]
	imul	eax, ecx, 15
	shl	eax, 2
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 4093 :                     if (sec > 0.0)

	xor	eax, eax
	addsd	xmm0, QWORD PTR [esi+16]
	subsd	xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@0000000000000000
	setbe	al
	inc	eax
$LN106@xmlSchemaC:

; 4094 :                         ret = 1;
; 4095 :                     else
; 4096 :                         ret = 2; /* indeterminate */
; 4097 :                 }
; 4098 : 		xmlSchemaFreeValue(p1);

	mov	DWORD PTR _ret$1$[ebp], eax
$LN33@xmlSchemaC:
	push	DWORD PTR _p1$3$[ebp]
	call	_xmlSchemaFreeValue

; 4099 : 		xmlSchemaFreeValue(q1);

	push	esi
	call	_xmlSchemaFreeValue

; 4100 : 		xmlSchemaFreeValue(p2);

	push	DWORD PTR _p2$1$[ebp]
	call	_xmlSchemaFreeValue

; 4101 : 		if (ret != 0)

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN27@xmlSchemaC

; 4252 : }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlSchemaC:

; 4102 : 		    return(ret);
; 4103 :             }
; 4104 : 	} else {
; 4105 : 	    xmlSchemaFreeValue(p1);

	push	DWORD PTR _p1$3$[ebp]
	call	_xmlSchemaFreeValue

; 4106 : 	    xmlSchemaFreeValue(q1);

	push	esi
	jmp	$LN107@xmlSchemaC
$LN102@xmlSchemaC:

; 4080 : 		xmlSchemaFreeValue(p1);

	push	DWORD PTR _p1$3$[ebp]
	call	_xmlSchemaFreeValue

; 4081 : 		xmlSchemaFreeValue(q1);

	push	esi
	call	_xmlSchemaFreeValue
	add	esp, 8
	or	eax, -1
	pop	esi
	pop	edi

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlSchemaC:

; 4126 :             double sec;
; 4127 : 
; 4128 :             sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	ecx, DWORD PTR tv871[ebp]
	mov	edx, DWORD PTR [edi+24]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	shl	edx, 19					; 00000013H
	mov	eax, ecx
	sar	edx, 20					; 00000014H
	shl	eax, 4
	sub	eax, ecx
	mov	esi, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR tv871[ebp]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ebx+24]
	add	eax, ecx
	shl	edx, 19					; 00000013H
	mov	ecx, eax
	sar	edx, 20					; 00000014H
	shl	ecx, 4
	sub	ecx, eax
	shl	ecx, 2
	movd	xmm1, ecx
	shr	ecx, 31					; 0000001fH
	cvtdq2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	ecx, esi
	shr	esi, 14					; 0000000eH
	shr	ecx, 9
	and	esi, 63					; 0000003fH
	and	ecx, 31					; 0000001fH
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	addsd	xmm1, QWORD PTR [edi+16]
	lea	eax, DWORD PTR [edx+eax*4]
	add	eax, esi
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	shl	ecx, 2
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	addsd	xmm0, QWORD PTR [ebx+16]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0

; 4129 :             if (sec < 0.0)

	comisd	xmm0, xmm1
	jbe	SHORT $LN41@xmlSchemaC
$LN108@xmlSchemaC:

; 4132 :                 ret = 1;
; 4133 : 
; 4134 :         }
; 4135 : 	xmlSchemaFreeValue(p1);

	or	ebx, -1
	jmp	SHORT $LN43@xmlSchemaC
$LN41@xmlSchemaC:

; 4130 :                 ret = -1;
; 4131 :             else if (sec > 0.0)

	comisd	xmm1, xmm0
	mov	eax, 1
	mov	ebx, 0
	cmova	ebx, eax
$LN43@xmlSchemaC:

; 4132 :                 ret = 1;
; 4133 : 
; 4134 :         }
; 4135 : 	xmlSchemaFreeValue(p1);

	push	edi
	call	_xmlSchemaFreeValue

; 4136 : 	xmlSchemaFreeValue(q1);

	push	DWORD PTR _q1$3$[ebp]
	call	_xmlSchemaFreeValue
	add	esp, 8

; 4137 :         return(ret);

	mov	eax, ebx
	pop	esi
	pop	edi

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlSchemaC:

; 4138 :     }
; 4139 : 
; 4140 :     switch (x->type) {

	add	eax, -4					; fffffffcH
	cmp	eax, 7
	ja	SHORT $LN52@xmlSchemaC
	jmp	DWORD PTR $LN111@xmlSchemaC[eax*4]
$LN44@xmlSchemaC:

; 4141 :         case XML_SCHEMAS_DATETIME:
; 4142 :             xmask = 0xf;

	mov	cl, 15					; 0000000fH

; 4143 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN45@xmlSchemaC:

; 4144 :         case XML_SCHEMAS_DATE:
; 4145 :             xmask = 0x7;

	mov	cl, 7

; 4146 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN46@xmlSchemaC:

; 4147 :         case XML_SCHEMAS_GYEAR:
; 4148 :             xmask = 0x1;

	mov	cl, 1

; 4149 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN47@xmlSchemaC:

; 4150 :         case XML_SCHEMAS_GMONTH:
; 4151 :             xmask = 0x2;

	mov	cl, 2

; 4152 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN48@xmlSchemaC:

; 4167 :             break;
; 4168 :     }
; 4169 : 
; 4170 :     switch (y->type) {

	mov	cl, 3
	jmp	SHORT $LN2@xmlSchemaC
$LN50@xmlSchemaC:

; 4153 :         case XML_SCHEMAS_GDAY:
; 4154 :             xmask = 0x3;
; 4155 :             break;
; 4156 :         case XML_SCHEMAS_GYEARMONTH:
; 4157 :             xmask = 0x3;
; 4158 :             break;
; 4159 :         case XML_SCHEMAS_GMONTHDAY:
; 4160 :             xmask = 0x6;

	mov	cl, 6

; 4161 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN51@xmlSchemaC:

; 4162 :         case XML_SCHEMAS_TIME:
; 4163 :             xmask = 0x8;

	mov	cl, 8

; 4164 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN52@xmlSchemaC:

; 4165 :         default:
; 4166 :             xmask = 0;

	xor	cl, cl
$LN2@xmlSchemaC:

; 4167 :             break;
; 4168 :     }
; 4169 : 
; 4170 :     switch (y->type) {

	lea	eax, DWORD PTR [edx-4]
	cmp	eax, 7
	ja	SHORT $LN61@xmlSchemaC
	jmp	DWORD PTR $LN112@xmlSchemaC[eax*4]
$LN53@xmlSchemaC:

; 4171 :         case XML_SCHEMAS_DATETIME:
; 4172 :             ymask = 0xf;

	mov	al, 15					; 0000000fH

; 4173 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN54@xmlSchemaC:

; 4174 :         case XML_SCHEMAS_DATE:
; 4175 :             ymask = 0x7;

	mov	al, 7

; 4176 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN55@xmlSchemaC:

; 4177 :         case XML_SCHEMAS_GYEAR:
; 4178 :             ymask = 0x1;

	mov	al, 1

; 4179 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN56@xmlSchemaC:

; 4180 :         case XML_SCHEMAS_GMONTH:
; 4181 :             ymask = 0x2;

	mov	al, 2

; 4182 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN57@xmlSchemaC:

; 4197 :             break;
; 4198 :     }
; 4199 : 
; 4200 :     xor_mask = xmask ^ ymask;           /* mark type differences */

	mov	al, 3
	jmp	SHORT $LN4@xmlSchemaC
$LN59@xmlSchemaC:

; 4183 :         case XML_SCHEMAS_GDAY:
; 4184 :             ymask = 0x3;
; 4185 :             break;
; 4186 :         case XML_SCHEMAS_GYEARMONTH:
; 4187 :             ymask = 0x3;
; 4188 :             break;
; 4189 :         case XML_SCHEMAS_GMONTHDAY:
; 4190 :             ymask = 0x6;

	mov	al, 6

; 4191 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN60@xmlSchemaC:

; 4192 :         case XML_SCHEMAS_TIME:
; 4193 :             ymask = 0x8;

	mov	al, 8

; 4194 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN61@xmlSchemaC:

; 4195 :         default:
; 4196 :             ymask = 0;

	xor	al, al
$LN4@xmlSchemaC:

; 4197 :             break;
; 4198 :     }
; 4199 : 
; 4200 :     xor_mask = xmask ^ ymask;           /* mark type differences */

	mov	dl, al

; 4201 :     and_mask = xmask & ymask;           /* mark field specification */

	and	al, cl
	xor	dl, cl

; 4202 : 
; 4203 :     /* year */
; 4204 :     if (xor_mask & 1)

	test	dl, 1
	jne	$LN101@xmlSchemaC

; 4205 :         return 2; /* indeterminate */
; 4206 :     else if (and_mask & 1) {

	test	al, 1
	je	SHORT $LN67@xmlSchemaC

; 4207 :         if (x->value.date.year < y->value.date.year)

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, DWORD PTR [ebx+8]
	jl	$LN100@xmlSchemaC

; 4208 :             return -1;
; 4209 :         else if (x->value.date.year > y->value.date.year)

	jg	$LN99@xmlSchemaC
$LN67@xmlSchemaC:

; 4210 :             return 1;
; 4211 :     }
; 4212 : 
; 4213 :     /* month */
; 4214 :     if (xor_mask & 2)

	test	dl, 2
	jne	$LN101@xmlSchemaC

; 4215 :         return 2; /* indeterminate */
; 4216 :     else if (and_mask & 2) {

	test	al, 2
	je	SHORT $LN97@xmlSchemaC

; 4217 :         if (x->value.date.mon < y->value.date.mon)

	mov	ecx, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [ebx+12]
	and	ecx, 15					; 0000000fH
	and	esi, 15					; 0000000fH
	cmp	ecx, esi
	jb	$LN100@xmlSchemaC

; 4218 :             return -1;
; 4219 :         else if (x->value.date.mon > y->value.date.mon)

	ja	$LN99@xmlSchemaC
$LN97@xmlSchemaC:

; 4220 :             return 1;
; 4221 :     }
; 4222 : 
; 4223 :     /* day */
; 4224 :     if (xor_mask & 4)

	test	dl, 4
	jne	$LN101@xmlSchemaC

; 4225 :         return 2; /* indeterminate */
; 4226 :     else if (and_mask & 4) {

	test	al, 4
	je	SHORT $LN98@xmlSchemaC

; 4227 :         if (x->value.date.day < y->value.date.day)

	mov	ecx, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [ebx+12]
	shr	ecx, 4
	shr	esi, 4
	and	ecx, 31					; 0000001fH
	and	esi, 31					; 0000001fH
	cmp	ecx, esi
	jb	$LN100@xmlSchemaC

; 4228 :             return -1;
; 4229 :         else if (x->value.date.day > y->value.date.day)

	ja	SHORT $LN99@xmlSchemaC
$LN98@xmlSchemaC:

; 4230 :             return 1;
; 4231 :     }
; 4232 : 
; 4233 :     /* time */
; 4234 :     if (xor_mask & 8)

	test	dl, 8
	jne	SHORT $LN101@xmlSchemaC

; 4236 :     else if (and_mask & 8) {

	test	al, 8
	je	SHORT $LN93@xmlSchemaC

; 4237 :         if (x->value.date.hour < y->value.date.hour)

	mov	eax, DWORD PTR [edi+12]
	mov	edx, eax
	mov	ecx, DWORD PTR [ebx+12]
	mov	esi, ecx
	shr	edx, 9
	shr	esi, 9
	and	edx, 31					; 0000001fH
	and	esi, 31					; 0000001fH
	cmp	edx, esi
	jb	$LN100@xmlSchemaC

; 4238 :             return -1;
; 4239 :         else if (x->value.date.hour > y->value.date.hour)

	ja	SHORT $LN99@xmlSchemaC

; 4240 :             return 1;
; 4241 :         else if (x->value.date.min < y->value.date.min)

	shr	eax, 14					; 0000000eH
	shr	ecx, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	and	ecx, 63					; 0000003fH
	cmp	eax, ecx
	jb	$LN100@xmlSchemaC

; 4242 :             return -1;
; 4243 :         else if (x->value.date.min > y->value.date.min)

	ja	SHORT $LN99@xmlSchemaC

; 4244 :             return 1;
; 4245 :         else if (x->value.date.sec < y->value.date.sec)

	movsd	xmm1, QWORD PTR [edi+16]
	movsd	xmm0, QWORD PTR [ebx+16]
	comisd	xmm0, xmm1
	ja	$LN100@xmlSchemaC

; 4246 :             return -1;
; 4247 :         else if (x->value.date.sec > y->value.date.sec)

	comisd	xmm1, xmm0
	jbe	SHORT $LN93@xmlSchemaC
$LN99@xmlSchemaC:
	pop	esi
	pop	edi

; 4248 :             return 1;

	mov	eax, 1

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@xmlSchemaC:
	pop	esi
	pop	edi

; 4249 :     }
; 4250 : 
; 4251 :     return 0;

	xor	eax, eax

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@xmlSchemaC:
	pop	esi
	pop	edi

; 4235 :         return 2; /* indeterminate */

	mov	eax, 2

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaC:
	pop	edi

; 4015 :         return -2;

	mov	eax, -2					; fffffffeH

; 4252 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@xmlSchemaC:
	DD	$LN51@xmlSchemaC
	DD	$LN48@xmlSchemaC
	DD	$LN47@xmlSchemaC
	DD	$LN50@xmlSchemaC
	DD	$LN46@xmlSchemaC
	DD	$LN48@xmlSchemaC
	DD	$LN45@xmlSchemaC
	DD	$LN44@xmlSchemaC
$LN112@xmlSchemaC:
	DD	$LN60@xmlSchemaC
	DD	$LN57@xmlSchemaC
	DD	$LN56@xmlSchemaC
	DD	$LN59@xmlSchemaC
	DD	$LN55@xmlSchemaC
	DD	$LN57@xmlSchemaC
	DD	$LN54@xmlSchemaC
	DD	$LN53@xmlSchemaC
_xmlSchemaCompareDates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaDateCastYMToDays
_TEXT	SEGMENT
tv263 = 8						; size = 4
tv262 = 8						; size = 4
_dt$ = 8						; size = 4
__xmlSchemaDateCastYMToDays PROC			; COMDAT

; 3962 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dt$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [eax+8]
	and	ecx, 15					; 0000000fH
	mov	eax, ebx
	cmovbe	ecx, edx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN12@xmlSchemaD

; 3963 :     long ret;
; 3964 :     int mon;
; 3965 : 
; 3966 :     mon = dt->value.date.mon;
; 3967 :     if (mon <= 0) mon = 1; /* normalization */
; 3968 : 
; 3969 :     if (dt->value.date.year <= 0)

	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN12@xmlSchemaD:
	test	ebx, ebx
	jg	SHORT $LN3@xmlSchemaD

; 3970 :         ret = (dt->value.date.year * 365) +

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaD
	mov	eax, ebx
	mov	esi, 100				; 00000064H
	cdq
	idiv	esi
	test	edx, edx
	jne	SHORT $LN7@xmlSchemaD
$LN6@xmlSchemaD:
	mov	eax, ebx
	mov	esi, 400				; 00000190H
	cdq
	idiv	esi
	test	edx, edx
	je	SHORT $LN7@xmlSchemaD
	mov	eax, DWORD PTR _dayInYearByMonth[ecx*4-4]
	jmp	SHORT $LN13@xmlSchemaD
$LN7@xmlSchemaD:
	mov	eax, DWORD PTR _dayInLeapYearByMonth[ecx*4-4]
$LN13@xmlSchemaD:
	mov	DWORD PTR tv263[ebp], eax
	lea	edi, DWORD PTR [ebx+1]
	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	mov	eax, 1374389535				; 51eb851fH
	sar	edx, 7
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	imul	edi
	mov	eax, edi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cdq
	sub	esi, ecx
	and	edx, 3
	pop	edi
	lea	ecx, DWORD PTR [edx+eax]
	imul	eax, ebx, 365
	sar	ecx, 2
	add	ecx, DWORD PTR tv263[ebp]
	add	ecx, esi

; 3976 :               (((dt->value.date.year-1)/4)-((dt->value.date.year-1)/100)+
; 3977 :                ((dt->value.date.year-1)/400)) +
; 3978 :               DAY_IN_YEAR(0, mon, dt->value.date.year);
; 3979 : 
; 3980 :     return ret;
; 3981 : }

	pop	esi
	add	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemaD:

; 3971 :               (((dt->value.date.year+1)/4)-((dt->value.date.year+1)/100)+
; 3972 :                ((dt->value.date.year+1)/400)) +
; 3973 :               DAY_IN_YEAR(0, mon, dt->value.date.year);
; 3974 :     else
; 3975 :         ret = ((dt->value.date.year-1) * 365) +

	test	eax, eax
	jne	SHORT $LN9@xmlSchemaD
	mov	eax, ebx
	mov	esi, 100				; 00000064H
	cdq
	idiv	esi
	test	edx, edx
	jne	SHORT $LN10@xmlSchemaD
$LN9@xmlSchemaD:
	mov	eax, ebx
	mov	esi, 400				; 00000190H
	cdq
	idiv	esi
	test	edx, edx
	je	SHORT $LN10@xmlSchemaD
	mov	eax, DWORD PTR _dayInYearByMonth[ecx*4-4]
	jmp	SHORT $LN15@xmlSchemaD
$LN10@xmlSchemaD:
	mov	eax, DWORD PTR _dayInLeapYearByMonth[ecx*4-4]
$LN15@xmlSchemaD:
	mov	DWORD PTR tv262[ebp], eax
	lea	edi, DWORD PTR [ebx-1]
	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	mov	eax, 1374389535				; 51eb851fH
	sar	edx, 7
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	imul	edi
	mov	eax, edi
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cdq
	sub	esi, ecx
	and	edx, 3
	add	eax, edx
	imul	ecx, ebx, 365
	sar	eax, 2
	add	eax, DWORD PTR tv262[ebp]
	pop	edi
	add	eax, esi
	add	ecx, -365				; fffffe93H

; 3976 :               (((dt->value.date.year-1)/4)-((dt->value.date.year-1)/100)+
; 3977 :                ((dt->value.date.year-1)/400)) +
; 3978 :               DAY_IN_YEAR(0, mon, dt->value.date.year);
; 3979 : 
; 3980 :     return ret;
; 3981 : }

	pop	esi
	add	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
__xmlSchemaDateCastYMToDays ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaDateNormalize
_TEXT	SEGMENT
_dt$ = 8						; size = 4
_offset$ = 12						; size = 8
_xmlSchemaDateNormalize PROC				; COMDAT

; 3922 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _dt$[ebp]
	test	esi, esi
	je	SHORT $LN13@xmlSchemaD

; 3923 :     xmlSchemaValPtr dur, ret;
; 3924 : 
; 3925 :     if (dt == NULL)
; 3926 :         return NULL;
; 3927 : 
; 3928 :     if (((dt->type != XML_SCHEMAS_TIME) &&
; 3929 :          (dt->type != XML_SCHEMAS_DATETIME) &&
; 3930 : 	 (dt->type != XML_SCHEMAS_DATE)) || (dt->value.date.tzo == 0))

	mov	eax, DWORD PTR [esi]
	cmp	eax, 4
	je	SHORT $LN5@xmlSchemaD
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN5@xmlSchemaD
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN4@xmlSchemaD
$LN5@xmlSchemaD:
	test	DWORD PTR [esi+24], 8190		; 00001ffeH
	jne	SHORT $LN3@xmlSchemaD
$LN4@xmlSchemaD:

; 3931 :         return xmlSchemaDupVal(dt);

	push	esi
	call	_xmlSchemaDupVal
	add	esp, 4
	pop	edi

; 3947 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaD:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	edi, edi
	je	SHORT $LN13@xmlSchemaD
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [edi], xmm0

; 3938 : 
; 3939 :     ret = _xmlSchemaDateAdd(dt, dur);

	push	edi

; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [edi+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [edi], 12			; 0000000cH

; 3932 : 
; 3933 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
; 3934 :     if (dur == NULL)
; 3935 :         return NULL;
; 3936 : 
; 3937 :     dur->value.date.sec -= offset;

	movsd	xmm0, QWORD PTR [edi+16]
	subsd	xmm0, QWORD PTR _offset$[ebp]

; 3938 : 
; 3939 :     ret = _xmlSchemaDateAdd(dt, dur);

	push	esi
	movsd	QWORD PTR [edi+16], xmm0
	call	__xmlSchemaDateAdd
	mov	esi, eax
	add	esp, 8

; 3940 :     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN13@xmlSchemaD

; 3942 : 
; 3943 :     xmlSchemaFreeValue(dur);

	push	edi
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3944 : 
; 3945 :     /* ret->value.date.tzo = 0; */
; 3946 :     return ret;

	mov	eax, esi
	pop	edi

; 3947 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlSchemaD:
	pop	edi

; 3941 :         return NULL;

	xor	eax, eax

; 3947 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaDateNormalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaDateAdd
_TEXT	SEGMENT
tv2321 = -40						; size = 8
tv2259 = -40						; size = 8
tv2246 = -40						; size = 8
tv2198 = -40						; size = 8
tv2185 = -40						; size = 8
tv2166 = -40						; size = 8
tv2152 = -40						; size = 8
tv2123 = -40						; size = 8
tv1897 = -40						; size = 8
tv1877 = -40						; size = 8
tv1794 = -40						; size = 8
tv1735 = -40						; size = 8
tv2005 = -36						; size = 4
_temp$1$ = -36						; size = 4
tv2238 = -32						; size = 8
tv2225 = -32						; size = 8
tv2218 = -32						; size = 8
tv1954 = -28						; size = 4
tv2231 = -24						; size = 8
tv1953 = -20						; size = 4
tv2030 = -16						; size = 4
tv2028 = -16						; size = 4
tv2008 = -16						; size = 4
_type$1$ = -16						; size = 4
tv2090 = -12						; size = 8
tv2068 = -12						; size = 8
$T1 = -8						; size = 4
tv2013 = -8						; size = 4
_tmon$3$ = -8						; size = 4
_tmp$1$ = -4						; size = 4
_value$1$ = 8						; size = 4
_dt$ = 8						; size = 4
_dur$ = 12						; size = 4
__xmlSchemaDateAdd PROC					; COMDAT

; 3769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dt$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSchemaD

; 3770 :     xmlSchemaValPtr ret, tmp;
; 3771 :     long carry, tempdays, temp;
; 3772 :     xmlSchemaValDatePtr r, d;
; 3773 :     xmlSchemaValDurationPtr u;
; 3774 : 
; 3775 :     if ((dt == NULL) || (dur == NULL))

	mov	esi, DWORD PTR _dur$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemaD

; 3776 :         return NULL;
; 3777 : 
; 3778 :     ret = xmlSchemaNewValue(dt->type);

	mov	eax, DWORD PTR [edi]

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 3776 :         return NULL;
; 3777 : 
; 3778 :     ret = xmlSchemaNewValue(dt->type);

	mov	DWORD PTR _type$1$[ebp], eax

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _value$1$[ebp], ebx

; 231  :     if (value == NULL) {

	test	ebx, ebx
	je	SHORT $LN5@xmlSchemaD

; 235  :     value->type = type;

	mov	eax, DWORD PTR _type$1$[ebp]
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [ebx], xmm0

; 3779 :     if (ret == NULL)
; 3780 :         return NULL;
; 3781 : 
; 3782 :     /* make a copy so we don't alter the original value */
; 3783 :     tmp = xmlSchemaDupVal(dt);

	push	edi

; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [ebx+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [ebx], eax

; 3779 :     if (ret == NULL)
; 3780 :         return NULL;
; 3781 : 
; 3782 :     /* make a copy so we don't alter the original value */
; 3783 :     tmp = xmlSchemaDupVal(dt);

	call	_xmlSchemaDupVal
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _tmp$1$[ebp], edx

; 3784 :     if (tmp == NULL) {

	test	edx, edx
	jne	SHORT $LN7@xmlSchemaD

; 3785 :         xmlSchemaFreeValue(ret);

	push	ebx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN5@xmlSchemaD:

; 3908 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaD:

; 3786 :         return NULL;
; 3787 :     }
; 3788 : 
; 3789 :     r = &(ret->value.date);
; 3790 :     d = &(tmp->value.date);
; 3791 :     u = &(dur->value.dur);
; 3792 : 
; 3793 :     /* normalization */
; 3794 :     if (d->mon == 0)

	mov	eax, DWORD PTR [edx+12]
	test	al, 15					; 0000000fH
	jne	SHORT $LN8@xmlSchemaD

; 3795 :         d->mon = 1;

	and	eax, -15				; fffffff1H
	or	eax, 1
	mov	DWORD PTR [edx+12], eax
$LN8@xmlSchemaD:

; 3796 : 
; 3797 :     /* normalize for time zone offset */
; 3798 :     u->sec -= (d->tzo * 60);

	mov	ecx, DWORD PTR [edx+24]
	movsd	xmm1, QWORD PTR [esi+16]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	shl	eax, 2
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	subsd	xmm1, xmm0
	movsd	QWORD PTR [esi+16], xmm1

; 3799 :     d->tzo = 0;

	and	DWORD PTR [edx+24], -8191		; ffffe001H

; 3800 : 
; 3801 :     /* normalization */
; 3802 :     if (d->day == 0)

	mov	ecx, DWORD PTR [edx+12]
	test	ecx, 496				; 000001f0H
	jne	SHORT $LN9@xmlSchemaD

; 3803 :         d->day = 1;

	and	ecx, -481				; fffffe1fH
	or	ecx, 16					; 00000010H
	mov	DWORD PTR [edx+12], ecx
$LN9@xmlSchemaD:

; 3804 : 
; 3805 :     /* month */
; 3806 :     carry  = d->mon + u->mon;

	mov	esi, DWORD PTR [esi+8]
	and	ecx, 15					; 0000000fH
	dec	esi

; 3807 :     r->mon = (unsigned int) MODULO_RANGE(carry, 1, 13);

	sub	esp, 8
	add	esi, ecx
	mov	eax, esp
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv1735[ebp], xmm0
	mov	ebx, DWORD PTR tv1735[ebp]
	mov	edi, DWORD PTR tv1735[ebp+4]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor
	movd	xmm0, esi
	add	esp, 8
	fstp	QWORD PTR tv2259[ebp]
	movsd	xmm1, QWORD PTR tv2259[ebp]
	mulsd	xmm1, QWORD PTR __real@4028000000000000
	cvtdq2pd xmm0, xmm0
	subsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	call	__dtoui3
	mov	ecx, eax

; 3808 :     carry  = (long) FQUOTIENT_RANGE(carry, 1, 13);

	sub	esp, 8
	mov	eax, DWORD PTR _value$1$[ebp]
	xor	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	xor	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, esp
	mov	DWORD PTR tv2030[ebp], ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor

; 3809 : 
; 3810 :     /* year (may be modified later) */
; 3811 :     r->year = d->year + carry;

	mov	edi, DWORD PTR _tmp$1$[ebp]
	add	esp, 8
	mov	ebx, DWORD PTR _value$1$[ebp]
	fstp	QWORD PTR tv2246[ebp]
	cvttsd2si esi, QWORD PTR tv2246[ebp]
	add	esi, DWORD PTR [edi+8]
	mov	DWORD PTR $T1[ebp], esi
	mov	DWORD PTR [ebx+8], esi

; 3812 :     if (r->year == 0) {

	jne	SHORT $LN12@xmlSchemaD

; 3813 :         if (d->year > 0)

	cmp	DWORD PTR [edi+8], 0
	jle	SHORT $LN11@xmlSchemaD

; 3814 :             r->year--;

	dec	esi
	jmp	SHORT $LN74@xmlSchemaD
$LN11@xmlSchemaD:

; 3815 :         else
; 3816 :             r->year++;

	inc	esi
$LN74@xmlSchemaD:

; 3817 :     }
; 3818 : 
; 3819 :     /* time zone */
; 3820 :     r->tzo     = d->tzo;

	mov	DWORD PTR [ebx+8], esi
	mov	DWORD PTR $T1[ebp], esi
$LN12@xmlSchemaD:
	mov	eax, DWORD PTR [edi+24]

; 3821 :     r->tz_flag = d->tz_flag;
; 3822 : 
; 3823 :     /* seconds */
; 3824 :     r->sec = d->sec + u->sec;
; 3825 :     carry  = (long) FQUOTIENT((long)r->sec, 60);

	sub	esp, 8
	xor	eax, DWORD PTR [ebx+24]
	and	eax, 8190				; 00001ffeH
	xor	DWORD PTR [ebx+24], eax
	mov	ecx, DWORD PTR [edi+24]
	xor	ecx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR _dur$[ebp]
	and	ecx, 1
	xor	DWORD PTR [ebx+24], ecx
	movsd	xmm0, QWORD PTR [edi+16]
	addsd	xmm0, QWORD PTR [eax+16]
	cvttsd2si eax, xmm0
	movsd	QWORD PTR tv1877[ebp], xmm0
	movsd	QWORD PTR [ebx+16], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv2238[ebp], xmm0
	fld	QWORD PTR tv2238[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 3826 :     if (r->sec != 0.0) {

	movsd	xmm0, QWORD PTR tv1877[ebp]
	add	esp, 8
	xorps	xmm1, xmm1
	ucomisd	xmm0, xmm1
	fstp	QWORD PTR tv2231[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@xmlSchemaD

; 3827 :         r->sec = MODULO(r->sec, 60.0);

	divsd	xmm0, QWORD PTR __real@404e000000000000
	sub	esp, 8
	movsd	QWORD PTR tv2225[ebp], xmm0
	fld	QWORD PTR tv2225[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	movsd	xmm1, QWORD PTR tv1877[ebp]
	add	esp, 8
	fstp	QWORD PTR tv2218[ebp]
	movsd	xmm0, QWORD PTR tv2218[ebp]
	mulsd	xmm0, QWORD PTR __real@404e000000000000
	mov	DWORD PTR $T1[ebp], esi
	subsd	xmm1, xmm0
	movsd	QWORD PTR [ebx+16], xmm1
$LN13@xmlSchemaD:

; 3828 :     }
; 3829 : 
; 3830 :     /* minute */
; 3831 :     carry += d->min;

	cvttsd2si eax, QWORD PTR tv2231[ebp]
	mov	esi, DWORD PTR [edi+12]

; 3832 :     r->min = (unsigned int) MODULO(carry, 60);

	sub	esp, 8
	shr	esi, 14					; 0000000eH
	and	esi, 63					; 0000003fH
	add	esi, eax
	mov	eax, esp
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv1794[ebp], xmm0
	mov	ebx, DWORD PTR tv1794[ebp]
	mov	edi, DWORD PTR tv1794[ebp+4]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor
	movd	xmm0, esi
	add	esp, 8
	fstp	QWORD PTR tv2198[ebp]
	movsd	xmm1, QWORD PTR tv2198[ebp]
	mulsd	xmm1, QWORD PTR __real@404e000000000000
	cvtdq2pd xmm0, xmm0
	subsd	xmm0, xmm1
	call	__dtoui3
	mov	ecx, DWORD PTR _value$1$[ebp]

; 3833 :     carry  = (long) FQUOTIENT(carry, 60);

	sub	esp, 8
	shl	eax, 14					; 0000000eH
	xor	eax, DWORD PTR tv2030[ebp]
	and	eax, 1032192				; 000fc000H
	xor	eax, DWORD PTR tv2030[ebp]
	mov	DWORD PTR tv2008[ebp], eax
	mov	DWORD PTR [ecx+12], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor
	mov	eax, DWORD PTR _tmp$1$[ebp]
	fstp	QWORD PTR tv2185[ebp]
	cvttsd2si esi, QWORD PTR tv2185[ebp]
	mov	eax, DWORD PTR [eax+12]
	shr	eax, 9

; 3834 : 
; 3835 :     /* hours */
; 3836 :     carry  += d->hour;

	and	eax, 31					; 0000001fH
	add	esi, eax

; 3837 :     r->hour = (unsigned int) MODULO(carry, 24);

	mov	eax, esp
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4038000000000000
	movsd	QWORD PTR tv2321[ebp], xmm0
	mov	ebx, DWORD PTR tv2321[ebp]
	mov	edi, DWORD PTR tv2321[ebp+4]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor
	movd	xmm0, esi
	add	esp, 8
	fstp	QWORD PTR tv2166[ebp]
	movsd	xmm1, QWORD PTR tv2166[ebp]
	mulsd	xmm1, QWORD PTR __real@4038000000000000
	cvtdq2pd xmm0, xmm0
	subsd	xmm0, xmm1
	call	__dtoui3
	mov	esi, eax

; 3838 :     carry   = (long)FQUOTIENT(carry, 24);

	sub	esp, 8
	mov	eax, DWORD PTR _value$1$[ebp]
	shl	esi, 9
	xor	esi, DWORD PTR tv2008[ebp]
	and	esi, 15872				; 00003e00H
	xor	esi, DWORD PTR tv2008[ebp]
	mov	DWORD PTR [eax+12], esi
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
	call	_floor

; 3839 : 
; 3840 :     /*
; 3841 :      * days
; 3842 :      * Note we use tempdays because the temporary values may need more
; 3843 :      * than 5 bits
; 3844 :      */
; 3845 :     if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&

	mov	ebx, DWORD PTR $T1[ebp]
	add	esp, 8
	mov	DWORD PTR tv1954[ebp], 400		; 00000190H
	mov	edi, 100				; 00000064H
	mov	DWORD PTR tv1953[ebp], edi
	fstp	QWORD PTR tv2152[ebp]
	test	ebx, ebx
	je	$LN14@xmlSchemaD
	mov	eax, esi
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	jb	$LN14@xmlSchemaD
	cmp	eax, 12					; 0000000cH
	ja	$LN14@xmlSchemaD
	mov	ecx, ebx
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN71@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	add	ecx, 1
$LN71@xmlSchemaD:
	jne	SHORT $LN65@xmlSchemaD
	mov	eax, ebx
	cdq
	idiv	edi
	test	edx, edx
	jne	SHORT $LN67@xmlSchemaD
$LN65@xmlSchemaD:
	mov	eax, ebx
	mov	edi, 400				; 00000190H
	cdq
	idiv	edi
	test	edx, edx
	je	SHORT $LN67@xmlSchemaD
	mov	edi, esi
	and	edi, 15					; 0000000fH
	shl	edi, 2
	mov	edx, DWORD PTR _daysInMonth[edi-4]
	jmp	SHORT $LN39@xmlSchemaD
$LN67@xmlSchemaD:
	mov	edi, esi
	and	edi, 15					; 0000000fH
	shl	edi, 2
	mov	edx, DWORD PTR _daysInMonthLeap[edi-4]
$LN39@xmlSchemaD:
	mov	eax, DWORD PTR _tmp$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	eax, edx
	jbe	SHORT $LN14@xmlSchemaD

; 3846 :                   (d->day > MAX_DAYINMONTH(r->year, r->mon)))
; 3847 :         tempdays = MAX_DAYINMONTH(r->year, r->mon);

	test	ecx, ecx
	jne	SHORT $LN40@xmlSchemaD
	mov	eax, ebx
	mov	ecx, 100				; 00000064H
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN41@xmlSchemaD
$LN40@xmlSchemaD:
	mov	eax, ebx
	mov	ecx, 400				; 00000190H
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN41@xmlSchemaD
	mov	edi, DWORD PTR _daysInMonth[edi-4]
	jmp	SHORT $LN16@xmlSchemaD
$LN41@xmlSchemaD:
	mov	edi, DWORD PTR _daysInMonthLeap[edi-4]
	jmp	SHORT $LN16@xmlSchemaD
$LN14@xmlSchemaD:

; 3848 :     else if (d->day < 1)

	mov	eax, DWORD PTR _tmp$1$[ebp]
	mov	edi, DWORD PTR [eax+12]
	shr	edi, 4
	and	edi, 31					; 0000001fH
	cmp	edi, 1
	jae	SHORT $LN16@xmlSchemaD

; 3849 :         tempdays = 1;

	mov	edi, 1
$LN16@xmlSchemaD:

; 3850 :     else
; 3851 :         tempdays = d->day;
; 3852 : 
; 3853 :     tempdays += u->day + carry;

	cvttsd2si ecx, QWORD PTR tv2152[ebp]
	mov	eax, DWORD PTR _dur$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, ecx
	mov	ecx, DWORD PTR _value$1$[ebp]
	add	edi, eax
$LL2@xmlSchemaD:

; 3854 : 
; 3855 :     while (1) {
; 3856 :         if (tempdays < 1) {

	mov	DWORD PTR tv2028[ebp], esi
	cmp	edi, 1
	jge	$LN18@xmlSchemaD

; 3857 :             long tmon = (long) MODULO_RANGE((int)r->mon-1, 1, 13);

	and	esi, 15					; 0000000fH
	sub	esp, 8
	sub	esi, 2
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv2123[ebp], xmm0
	fld	QWORD PTR tv2123[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	movd	xmm2, esi
	add	esp, 8
	fstp	QWORD PTR tv1897[ebp]
	movsd	xmm0, QWORD PTR tv1897[ebp]

; 3858 :             long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);
; 3859 :             if (tyr == 0)
; 3860 :                 tyr--;
; 3861 : 	    /*
; 3862 : 	     * Coverity detected an overrun in daysInMonth
; 3863 : 	     * of size 12 at position 12 with index variable "((r)->mon - 1)"
; 3864 : 	     */
; 3865 : 	    if (tmon < 1)

	or	esi, -1
	mulsd	xmm0, QWORD PTR __real@4028000000000000
	cvttsd2si eax, QWORD PTR tv1897[ebp]
	cvtdq2pd xmm2, xmm2
	add	eax, ebx
	cmovne	esi, eax
	mov	eax, 1
	subsd	xmm2, xmm0
	addsd	xmm2, QWORD PTR __real@3ff0000000000000
	cvttsd2si ecx, xmm2
	cmp	ecx, 1
	cmovl	ecx, eax

; 3866 : 	        tmon = 1;
; 3867 : 	    if (tmon > 12)

	mov	eax, 12					; 0000000cH
	cmp	ecx, 12					; 0000000cH
	cmovg	ecx, eax

; 3868 : 	        tmon = 12;
; 3869 :             tempdays += MAX_DAYINMONTH(tyr, tmon);

	mov	eax, esi
	mov	DWORD PTR _tmon$3$[ebp], ecx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN72@xmlSchemaD
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN72@xmlSchemaD:
	jne	SHORT $LN43@xmlSchemaD
	mov	eax, 1374389535				; 51eb851fH
	mov	ecx, esi
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, eax, 100
	sub	ecx, eax
	jne	SHORT $LN44@xmlSchemaD
	mov	ecx, DWORD PTR _tmon$3$[ebp]
$LN43@xmlSchemaD:
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 7
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, eax, 400
	sub	esi, eax
	je	SHORT $LN44@xmlSchemaD
	mov	eax, DWORD PTR _daysInMonth[ecx*4-4]
	add	edi, eax

; 3870 :             carry = -1;

	or	ecx, -1
	jmp	$LN24@xmlSchemaD
$LN44@xmlSchemaD:

; 3868 : 	        tmon = 12;
; 3869 :             tempdays += MAX_DAYINMONTH(tyr, tmon);

	mov	eax, DWORD PTR _tmon$3$[ebp]
	mov	eax, DWORD PTR _daysInMonthLeap[eax*4-4]
	add	edi, eax

; 3870 :             carry = -1;

	or	ecx, -1
	jmp	$LN24@xmlSchemaD
$LN18@xmlSchemaD:

; 3871 :         } else if (VALID_YEAR(r->year) && VALID_MONTH(r->mon) &&

	test	ebx, ebx
	je	$LN23@xmlSchemaD
	mov	eax, esi
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv2013[ebp], eax
	dec	eax
	cmp	eax, 11					; 0000000bH
	ja	$LN23@xmlSchemaD
	mov	eax, ebx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN73@xmlSchemaD
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN73@xmlSchemaD:
	mov	DWORD PTR tv2005[ebp], eax
	jne	SHORT $LN68@xmlSchemaD
	mov	eax, ebx
	cdq
	idiv	DWORD PTR tv1953[ebp]
	test	edx, edx
	jne	SHORT $LN70@xmlSchemaD
$LN68@xmlSchemaD:
	mov	eax, ebx
	cdq
	idiv	DWORD PTR tv1954[ebp]
	test	edx, edx
	je	SHORT $LN70@xmlSchemaD
	mov	eax, DWORD PTR tv2013[ebp]
	mov	eax, DWORD PTR _daysInMonth[eax*4-4]
	jmp	SHORT $LN48@xmlSchemaD
$LN70@xmlSchemaD:
	mov	eax, DWORD PTR tv2013[ebp]
	mov	eax, DWORD PTR _daysInMonthLeap[eax*4-4]
$LN48@xmlSchemaD:
	cmp	edi, eax
	jle	$LN23@xmlSchemaD

; 3872 :                    tempdays > (long) MAX_DAYINMONTH(r->year, r->mon)) {
; 3873 :             tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);

	cmp	DWORD PTR tv2005[ebp], 0
	jne	SHORT $LN49@xmlSchemaD
	mov	eax, ebx
	mov	ecx, 100				; 00000064H
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN50@xmlSchemaD
$LN49@xmlSchemaD:
	mov	eax, ebx
	mov	ecx, 400				; 00000190H
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN50@xmlSchemaD
	mov	eax, DWORD PTR tv2013[ebp]
	mov	eax, DWORD PTR _daysInMonth[eax*4-4]
	jmp	SHORT $LN51@xmlSchemaD
$LN50@xmlSchemaD:
	mov	eax, DWORD PTR tv2013[ebp]
	mov	eax, DWORD PTR _daysInMonthLeap[eax*4-4]
$LN51@xmlSchemaD:
	sub	edi, eax

; 3874 :             carry = 1;

	mov	ecx, 1
$LN24@xmlSchemaD:

; 3875 :         } else
; 3876 :             break;
; 3877 : 
; 3878 :         temp = r->mon + carry;

	mov	eax, DWORD PTR tv2028[ebp]

; 3879 :         r->mon = (unsigned int) MODULO_RANGE(temp, 1, 13);

	sub	esp, 8
	and	eax, 15					; 0000000fH
	add	eax, ecx
	mov	DWORD PTR _temp$1$[ebp], eax
	lea	esi, DWORD PTR [eax-1]
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv2068[ebp], xmm0
	fld	QWORD PTR tv2068[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	movd	xmm0, esi
	add	esp, 8
	fstp	QWORD PTR tv2090[ebp]
	movsd	xmm1, QWORD PTR tv2090[ebp]
	mulsd	xmm1, QWORD PTR __real@4028000000000000
	cvtdq2pd xmm0, xmm0
	subsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	call	__dtoui3

; 3880 :         r->year = r->year + (unsigned int) FQUOTIENT_RANGE(temp, 1, 13);

	movsd	xmm0, QWORD PTR tv2090[ebp]
	mov	esi, eax
	xor	esi, DWORD PTR tv2028[ebp]
	mov	eax, DWORD PTR _value$1$[ebp]
	and	esi, 15					; 0000000fH
	xor	esi, DWORD PTR tv2028[ebp]
	mov	DWORD PTR [eax+12], esi
	call	__dtoui3
	mov	ecx, DWORD PTR _value$1$[ebp]
	add	ebx, eax
	mov	DWORD PTR [ecx+8], ebx

; 3881 :         if (r->year == 0) {

	jne	$LL2@xmlSchemaD

; 3882 :             if (temp < 1)

	cmp	DWORD PTR _temp$1$[ebp], 1
	jge	SHORT $LN26@xmlSchemaD

; 3883 :                 r->year--;

	mov	DWORD PTR [ecx+8], -1
	or	ebx, -1
	jmp	$LL2@xmlSchemaD
$LN26@xmlSchemaD:

; 3884 :             else
; 3885 :                 r->year++;

	mov	DWORD PTR [ecx+8], 1
	mov	ebx, 1

; 3886 : 	}
; 3887 :     }

	jmp	$LL2@xmlSchemaD
$LN23@xmlSchemaD:

; 3888 : 
; 3889 :     r->day = tempdays;

	shl	edi, 4
	xor	edi, esi
	and	edi, 496				; 000001f0H
	xor	edi, esi
	mov	DWORD PTR [ecx+12], edi

; 3890 : 
; 3891 :     /*
; 3892 :      * adjust the date/time type to the date values
; 3893 :      */
; 3894 :     if (ret->type != XML_SCHEMAS_DATETIME) {

	mov	edx, DWORD PTR [ecx]
	cmp	edx, 11					; 0000000bH
	je	SHORT $LN35@xmlSchemaD

; 3895 :         if ((r->hour) || (r->min) || (r->sec))

	test	edi, 1048064				; 000ffe00H
	jne	SHORT $LN31@xmlSchemaD
	movsd	xmm0, QWORD PTR [ecx+16]
	xorps	xmm1, xmm1
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@xmlSchemaD

; 3897 :         else if (ret->type != XML_SCHEMAS_DATE) {

	cmp	edx, 10					; 0000000aH
	je	SHORT $LN35@xmlSchemaD

; 3898 :             if ((r->mon != 1) && (r->day != 1))

	mov	eax, edi
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	je	SHORT $LN33@xmlSchemaD
	and	edi, 496				; 000001f0H
	cmp	edi, 16					; 00000010H
	je	SHORT $LN33@xmlSchemaD

; 3901 :                 ret->type = XML_SCHEMAS_GYEARMONTH;
; 3902 :         }
; 3903 :     }
; 3904 : 
; 3905 :     xmlSchemaFreeValue(tmp);

	push	DWORD PTR _tmp$1$[ebp]
	mov	DWORD PTR [ecx], 10			; 0000000aH
	call	_xmlSchemaFreeValue

; 3906 : 
; 3907 :     return ret;

	mov	eax, DWORD PTR _value$1$[ebp]
	add	esp, 4

; 3908 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlSchemaD:

; 3899 :                 ret->type = XML_SCHEMAS_DATE;
; 3900 :             else if ((ret->type != XML_SCHEMAS_GYEARMONTH) && (r->mon != 1))

	cmp	edx, 9
	je	SHORT $LN35@xmlSchemaD
	cmp	eax, 1
	je	SHORT $LN35@xmlSchemaD

; 3901 :                 ret->type = XML_SCHEMAS_GYEARMONTH;
; 3902 :         }
; 3903 :     }
; 3904 : 
; 3905 :     xmlSchemaFreeValue(tmp);

	push	DWORD PTR _tmp$1$[ebp]
	mov	DWORD PTR [ecx], 9
	call	_xmlSchemaFreeValue

; 3906 : 
; 3907 :     return ret;

	mov	eax, DWORD PTR _value$1$[ebp]
	add	esp, 4

; 3908 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlSchemaD:

; 3896 :             ret->type = XML_SCHEMAS_DATETIME;

	mov	DWORD PTR [ecx], 11			; 0000000bH
$LN35@xmlSchemaD:

; 3901 :                 ret->type = XML_SCHEMAS_GYEARMONTH;
; 3902 :         }
; 3903 :     }
; 3904 : 
; 3905 :     xmlSchemaFreeValue(tmp);

	push	DWORD PTR _tmp$1$[ebp]
	call	_xmlSchemaFreeValue

; 3906 : 
; 3907 :     return ret;

	mov	eax, DWORD PTR _value$1$[ebp]
	add	esp, 4

; 3908 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaDateAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaDupVal
_TEXT	SEGMENT
_v$ = 8							; size = 4
_xmlSchemaDupVal PROC					; COMDAT

; 3670 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _v$[ebp]

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 3671 :     xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);

	mov	edi, DWORD PTR [esi]

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlSchemaD
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], edi

; 3674 : 
; 3675 :     memcpy(ret, v, sizeof(xmlSchemaVal));

	movups	xmm0, XMMWORD PTR [esi]
	pop	edi
	movups	XMMWORD PTR [eax], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]

; 3676 :     ret->next = NULL;
; 3677 :     return ret;
; 3678 : }

	pop	esi
	movups	XMMWORD PTR [eax+16], xmm0
	mov	DWORD PTR [eax+4], 0
	pop	ebp
	ret	0
$LN7@xmlSchemaD:
	pop	edi

; 3672 :     if (ret == NULL)
; 3673 :         return NULL;

	xor	eax, eax

; 3676 :     ret->next = NULL;
; 3677 :     return ret;
; 3678 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaDupVal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDurations
_TEXT	SEGMENT
_minday$1$ = 8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDurations PROC				; COMDAT

; 3573 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _x$[ebp]
	mov	ebx, 1
	test	ecx, ecx
	je	$LN3@xmlSchemaC

; 3574 :     long carry, mon, day;
; 3575 :     double sec;
; 3576 :     int invert = 1;
; 3577 :     long xmon, xday, myear, minday, maxday;
; 3578 :     static const long dayRange [2][12] = {
; 3579 :         { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
; 3580 :         { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
; 3581 : 
; 3582 :     if ((x == NULL) || (y == NULL))

	mov	edx, DWORD PTR _y$[ebp]
	test	edx, edx
	je	$LN3@xmlSchemaC

; 3584 : 
; 3585 :     /* months */
; 3586 :     mon = x->value.dur.mon - y->value.dur.mon;
; 3587 : 
; 3588 :     /* seconds */
; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;

	movsd	xmm2, QWORD PTR [ecx+16]
	subsd	xmm2, QWORD PTR [edx+16]
	push	esi
	mov	esi, DWORD PTR [ecx+8]

; 3590 :     carry = (long)(sec / SECS_PER_DAY);
; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;
; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, DWORD PTR [edx+12]
	movaps	xmm0, xmm2
	sub	esi, DWORD PTR [edx+8]
	divsd	xmm0, QWORD PTR __real@40f5180000000000
	cvttsd2si eax, xmm0
	add	ecx, eax
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@40f5180000000000
	subsd	xmm2, xmm0

; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {

	test	esi, esi
	jne	SHORT $LN30@xmlSchemaC

; 3598 :         if (day == 0)

	test	ecx, ecx
	jne	SHORT $LN31@xmlSchemaC

; 3599 :             if (sec == 0.0)

	xorps	xmm0, xmm0
	ucomisd	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN27@xmlSchemaC

; 3600 :                 return 0;
; 3601 :             else if (sec < 0.0)

	comisd	xmm0, xmm2
	jbe	$LN25@xmlSchemaC

; 3619 :         return -1;

	pop	esi
	or	eax, -1
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN31@xmlSchemaC:

; 3602 :                 return -1;
; 3603 :             else
; 3604 :                 return 1;
; 3605 :         else if (day < 0)

	jns	$LN25@xmlSchemaC

; 3619 :         return -1;

	pop	esi
	or	eax, -1
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN30@xmlSchemaC:

; 3606 :             return -1;
; 3607 :         else
; 3608 :             return 1;
; 3609 :     }
; 3610 : 
; 3611 :     if (mon > 0) {

	jle	SHORT $LN13@xmlSchemaC

; 3612 :         if ((day >= 0) && (sec >= 0.0))

	test	ecx, ecx
	js	SHORT $LN15@xmlSchemaC
	comisd	xmm2, QWORD PTR __real@0000000000000000
	jae	$LN25@xmlSchemaC
$LN15@xmlSchemaC:

; 3613 :             return 1;
; 3614 :         else {
; 3615 :             xmon = mon;
; 3616 :             xday = -day;

	neg	ecx

; 3617 :         }

	jmp	SHORT $LN18@xmlSchemaC
$LN13@xmlSchemaC:

; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {

	test	ecx, ecx
	jg	SHORT $LN17@xmlSchemaC
	xorps	xmm0, xmm0
	comisd	xmm0, xmm2
	jb	SHORT $LN17@xmlSchemaC

; 3619 :         return -1;

	pop	esi
	or	eax, -1
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN17@xmlSchemaC:

; 3620 :     } else {
; 3621 : 	invert = -1;

	or	ebx, -1

; 3622 :         xmon = -mon;

	neg	esi
$LN18@xmlSchemaC:

; 3623 :         xday = day;
; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;

	mov	eax, 715827883				; 2aaaaaabH
	imul	esi
	push	edi
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 3627 :     if (myear == 0) {

	jne	SHORT $LN19@xmlSchemaC

; 3628 : 	minday = 0;

	xor	eax, eax

; 3629 : 	maxday = 0;

	xor	edx, edx

; 3630 :     } else {

	jmp	SHORT $LN32@xmlSchemaC
$LN19@xmlSchemaC:

; 3631 : 	maxday = 366 * ((myear + 3) / 4) +

	lea	eax, DWORD PTR [edi+3]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	edx, eax, 366
	lea	eax, DWORD PTR [edi-1]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN29@xmlSchemaC
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN29@xmlSchemaC:
	imul	eax, eax, 365
	add	edx, eax

; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;

	lea	eax, DWORD PTR [edx-1]
$LN32@xmlSchemaC:

; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;

	mov	DWORD PTR _minday$1$[ebp], eax
	lea	eax, DWORD PTR [edi*4]
	sub	eax, edi
	neg	eax

; 3637 :     minday += dayRange[0][xmon];
; 3638 :     maxday += dayRange[1][xmon];
; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))

	pop	edi
	lea	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _minday$1$[ebp]
	add	esi, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax*4]
	add	edx, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax*4+48]
	cmp	edx, esi
	jne	SHORT $LN21@xmlSchemaC
	cmp	edx, ecx
	jne	SHORT $LN33@xmlSchemaC
$LN27@xmlSchemaC:
	pop	esi

; 3641 : 	return(0); /* can this really happen ? */

	xor	eax, eax
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN21@xmlSchemaC:

; 3642 :     if (maxday < xday)

	cmp	edx, ecx
$LN33@xmlSchemaC:
	jge	SHORT $LN22@xmlSchemaC

; 3643 :         return(-invert);

	neg	ebx
$LN25@xmlSchemaC:
	pop	esi
	mov	eax, ebx
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN22@xmlSchemaC:

; 3644 :     if (minday > xday)

	cmp	esi, ecx
	mov	eax, 2
	pop	esi
	cmovg	eax, ebx
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 3583 :         return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }

	pop	ebp
	ret	0
_xmlSchemaCompareDurations ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDecimals
_TEXT	SEGMENT
_swp$1$ = -24						; size = 4
_integx$1$ = -24					; size = 4
tv494 = -20						; size = 4
_dlen$1$ = -20						; size = 4
_order$1$ = -16						; size = 4
$T1 = -12						; size = 4
_hi$1$ = -12						; size = 4
_lo$1$ = -8						; size = 4
_mi$1$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDecimals PROC				; COMDAT

; 3425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _x$[ebp]
	mov	ecx, 1
	mov	DWORD PTR _order$1$[ebp], ecx
	mov	edx, DWORD PTR [edi+24]
	test	dl, cl
	je	$LN54@xmlSchemaC

; 3426 :     xmlSchemaValPtr swp;
; 3427 :     int order = 1, integx, integy, dlen;
; 3428 :     unsigned long hi, mi, lo;
; 3429 : 
; 3430 :     /*
; 3431 :      * First test: If x is -ve and not zero
; 3432 :      */
; 3433 :     if ((x->value.decimal.sign) &&

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN8@xmlSchemaC
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN8@xmlSchemaC
	cmp	DWORD PTR [edi+16], 0
	je	$LN54@xmlSchemaC
$LN8@xmlSchemaC:

; 3434 : 	((x->value.decimal.lo != 0) ||
; 3435 : 	 (x->value.decimal.mi != 0) ||
; 3436 : 	 (x->value.decimal.hi != 0))) {
; 3437 : 	/*
; 3438 : 	 * Then if y is -ve and not zero reverse the compare
; 3439 : 	 */
; 3440 : 	if ((y->value.decimal.sign) &&

	mov	ebx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR $T1[ebp], eax
	test	al, 1
	je	SHORT $LN9@xmlSchemaC
	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN11@xmlSchemaC
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN11@xmlSchemaC
	cmp	DWORD PTR [ebx+16], 0
	je	SHORT $LN9@xmlSchemaC
$LN11@xmlSchemaC:

; 3441 : 	    ((y->value.decimal.lo != 0) ||
; 3442 : 	     (y->value.decimal.mi != 0) ||
; 3443 : 	     (y->value.decimal.hi != 0)))
; 3444 : 	    order = -1;

	or	ecx, -1
	mov	DWORD PTR _order$1$[ebp], ecx
$LN12@xmlSchemaC:

; 3458 :     }
; 3459 :     /*
; 3460 :      * If it's not simply determined by a difference in sign,
; 3461 :      * then we need to compare the actual values of the two nums.
; 3462 :      * To do this, we start by looking at the integral parts.
; 3463 :      * If the number of integral digits differ, then we have our
; 3464 :      * answer.
; 3465 :      */
; 3466 :     integx = x->value.decimal.total - x->value.decimal.frac;

	mov	eax, edx
	shr	eax, 8
	movzx	edx, al
	mov	eax, DWORD PTR [edi+24]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	push	esi
	mov	esi, edx
	sub	esi, eax

; 3467 :     integy = y->value.decimal.total - y->value.decimal.frac;

	mov	eax, DWORD PTR $T1[ebp]
	shr	eax, 8
	mov	DWORD PTR _integx$1$[ebp], esi
	movzx	esi, al
	mov	eax, DWORD PTR $T1[ebp]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	mov	DWORD PTR tv494[ebp], esi
	sub	esi, eax

; 3468 :     /*
; 3469 :     * NOTE: We changed the "total" for values like "0.1"
; 3470 :     *   (or "-0.1" or ".1") to be 1, which was 2 previously.
; 3471 :     *   Therefore the special case, when such values are
; 3472 :     *   compared with 0, needs to be handled separately;
; 3473 :     *   otherwise a zero would be recognized incorrectly as
; 3474 :     *   greater than those values. This has the nice side effect
; 3475 :     *   that we gain an overall optimized comparison with zeroes.
; 3476 :     * Note that a "0" has a "total" of 1 already.
; 3477 :     */
; 3478 :     if (integx == 1) {

	mov	eax, DWORD PTR _integx$1$[ebp]
	cmp	eax, 1
	jne	SHORT $LN55@xmlSchemaC

; 3479 : 	if (x->value.decimal.lo == 0) {

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN55@xmlSchemaC

; 3480 : 	    if (integy != 1)

	cmp	esi, eax
	jne	SHORT $LN59@xmlSchemaC

; 3481 : 		return -order;
; 3482 : 	    else if (y->value.decimal.lo != 0)

	cmp	DWORD PTR [ebx+8], 0
	je	$LN57@xmlSchemaC

; 3502 : 	return -order;

	pop	esi
	neg	ecx
	pop	edi
	mov	eax, ecx

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSchemaC:
	pop	edi

; 3445 : 	/*
; 3446 : 	 * Otherwise (y >= 0) we have the answer
; 3447 : 	 */
; 3448 : 	else
; 3449 : 	    return (-1);

	or	eax, -1

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlSchemaC:

; 3450 :     /*
; 3451 :      * If x is not -ve and y is -ve we have the answer
; 3452 :      */
; 3453 :     } else if ((y->value.decimal.sign) &&

	mov	ebx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR $T1[ebp], eax
	test	al, 1
	je	SHORT $LN12@xmlSchemaC
	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN13@xmlSchemaC
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN13@xmlSchemaC
	cmp	DWORD PTR [ebx+16], 0
	mov	DWORD PTR $T1[ebp], eax
	je	SHORT $LN12@xmlSchemaC
$LN13@xmlSchemaC:
	pop	edi

; 3454 : 	       ((y->value.decimal.lo != 0) ||
; 3455 : 		(y->value.decimal.mi != 0) ||
; 3456 : 		(y->value.decimal.hi != 0))) {
; 3457 :         return (1);

	mov	eax, ecx

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@xmlSchemaC:

; 3483 : 		return -order;
; 3484 : 	    else
; 3485 : 		return(0);
; 3486 : 	}
; 3487 :     }
; 3488 :     if (integy == 1) {

	cmp	esi, 1
	jne	SHORT $LN56@xmlSchemaC

; 3489 : 	if (y->value.decimal.lo == 0) {

	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN56@xmlSchemaC

; 3490 : 	    if (integx != 1)

	cmp	eax, esi
	jne	SHORT $LN58@xmlSchemaC

; 3491 : 		return order;
; 3492 : 	    else if (x->value.decimal.lo != 0)

	cmp	DWORD PTR [edi+8], 0
	je	$LN57@xmlSchemaC

; 3502 : 	return -order;

	pop	esi
	pop	edi
	mov	eax, ecx

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlSchemaC:

; 3493 : 		return order;
; 3494 : 	    else
; 3495 : 		return(0);
; 3496 : 	}
; 3497 :     }
; 3498 : 
; 3499 :     if (integx > integy)

	cmp	eax, esi
	jg	SHORT $LN58@xmlSchemaC

; 3500 : 	return order;
; 3501 :     else if (integy > integx)

	jge	SHORT $LN28@xmlSchemaC
$LN59@xmlSchemaC:

; 3502 : 	return -order;

	neg	ecx
$LN58@xmlSchemaC:
	pop	esi
	pop	edi
	mov	eax, ecx

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlSchemaC:

; 3503 : 
; 3504 :     /*
; 3505 :      * If the number of integral digits is the same for both numbers,
; 3506 :      * then things get a little more complicated.  We need to "normalize"
; 3507 :      * the numbers in order to properly compare them.  To do this, we
; 3508 :      * look at the total length of each number (length => number of
; 3509 :      * significant digits), and divide the "shorter" by 10 (decreasing
; 3510 :      * the length) until they are of equal length.
; 3511 :      */
; 3512 :     dlen = x->value.decimal.total - y->value.decimal.total;

	sub	edx, DWORD PTR tv494[ebp]
	mov	DWORD PTR _dlen$1$[ebp], edx

; 3513 :     if (dlen < 0) {	/* y has more digits than x */

	jns	SHORT $LN29@xmlSchemaC

; 3514 : 	swp = x;
; 3515 : 	hi = y->value.decimal.hi;

	mov	esi, DWORD PTR [ebx+16]

; 3516 : 	mi = y->value.decimal.mi;
; 3517 : 	lo = y->value.decimal.lo;
; 3518 : 	dlen = -dlen;

	neg	edx
	mov	eax, DWORD PTR [ebx+8]

; 3519 : 	order = -order;

	neg	ecx
	mov	DWORD PTR _swp$1$[ebp], edi
	mov	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR _dlen$1$[ebp], edx
	mov	DWORD PTR _order$1$[ebp], ecx

; 3520 :     } else {		/* x has more digits than y */

	jmp	SHORT $LN63@xmlSchemaC
$LN29@xmlSchemaC:

; 3521 : 	swp = y;
; 3522 : 	hi = x->value.decimal.hi;
; 3523 : 	mi = x->value.decimal.mi;
; 3524 : 	lo = x->value.decimal.lo;

	mov	eax, DWORD PTR _x$[ebp]
	mov	esi, DWORD PTR [edi+16]
	mov	edi, DWORD PTR [edi+12]
	mov	DWORD PTR _swp$1$[ebp], ebx
	mov	eax, DWORD PTR [eax+8]
$LN63@xmlSchemaC:

; 3525 :     }
; 3526 :     while (dlen > 8) {	/* in effect, right shift by 10**8 */

	mov	DWORD PTR _lo$1$[ebp], eax
	mov	DWORD PTR _mi$1$[ebp], edi
	mov	DWORD PTR _hi$1$[ebp], esi
	cmp	edx, 8
	jle	SHORT $LN44@xmlSchemaC
	lea	ecx, DWORD PTR [edx-9]
	shr	ecx, 3
	inc	ecx
	mov	eax, ecx
	neg	eax
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _dlen$1$[ebp], edx
	npad	4
$LL2@xmlSchemaC:

; 3527 : 	lo = mi;

	mov	DWORD PTR _lo$1$[ebp], edi

; 3528 : 	mi = hi;

	mov	edi, esi

; 3529 : 	hi = 0;

	xor	esi, esi
	sub	ecx, 1
	jne	SHORT $LL2@xmlSchemaC
	mov	DWORD PTR _hi$1$[ebp], esi
	mov	DWORD PTR _mi$1$[ebp], edi
$LN44@xmlSchemaC:

; 3530 : 	dlen -= 8;
; 3531 :     }
; 3532 :     while (dlen > 0) {

	test	edx, edx
	jle	SHORT $LN61@xmlSchemaC
	mov	ebx, DWORD PTR _dlen$1$[ebp]
	jmp	SHORT $LN4@xmlSchemaC
	npad	5
$LL60@xmlSchemaC:
	mov	esi, DWORD PTR _hi$1$[ebp]
$LN4@xmlSchemaC:

; 3533 : 	unsigned long rem1, rem2;
; 3534 : 	rem1 = (hi % 10) * 100000000L;

	mov	eax, -858993459				; cccccccdH

; 3535 : 	hi = hi / 10;
; 3536 : 	rem2 = (mi % 10) * 100000000L;
; 3537 : 	mi = (mi + rem1) / 10;
; 3538 : 	lo = (lo + rem2) / 10;
; 3539 : 	dlen--;

	dec	ebx
	mul	esi
	shr	edx, 3
	mov	DWORD PTR _hi$1$[ebp], edx
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	esi, eax
	mov	eax, -858993459				; cccccccdH
	mul	DWORD PTR _mi$1$[ebp]
	imul	edi, esi, 100000000
	shr	edx, 3
	lea	ecx, DWORD PTR [edx+edx*4]
	mov	edx, DWORD PTR _mi$1$[ebp]
	add	ecx, ecx
	mov	eax, edx
	sub	eax, ecx
	imul	esi, eax, 100000000
	mov	eax, -858993459				; cccccccdH
	lea	ecx, DWORD PTR [edi+edx]
	mul	ecx
	mov	ecx, DWORD PTR _lo$1$[ebp]
	mov	eax, -858993459				; cccccccdH
	mov	edi, edx
	shr	edi, 3
	mov	DWORD PTR _mi$1$[ebp], edi
	lea	ecx, DWORD PTR [esi+ecx]
	mul	ecx
	mov	ecx, edx
	shr	ecx, 3
	mov	DWORD PTR _lo$1$[ebp], ecx
	test	ebx, ebx
	jg	SHORT $LL60@xmlSchemaC

; 3530 : 	dlen -= 8;
; 3531 :     }
; 3532 :     while (dlen > 0) {

	mov	ebx, DWORD PTR _y$[ebp]
	jmp	SHORT $LN5@xmlSchemaC
$LN61@xmlSchemaC:
	mov	ecx, DWORD PTR _lo$1$[ebp]
$LN5@xmlSchemaC:

; 3540 :     }
; 3541 :     if (hi > swp->value.decimal.hi) {

	mov	edx, DWORD PTR _swp$1$[ebp]
	mov	esi, DWORD PTR [edx+16]
	cmp	DWORD PTR _hi$1$[ebp], esi
	ja	SHORT $LN40@xmlSchemaC

; 3542 : 	return order;
; 3543 :     } else if (hi == swp->value.decimal.hi) {

	jne	SHORT $LN41@xmlSchemaC

; 3544 : 	if (mi > swp->value.decimal.mi) {

	cmp	edi, DWORD PTR [edx+12]
	ja	SHORT $LN40@xmlSchemaC

; 3545 : 	    return order;
; 3546 : 	} else if (mi == swp->value.decimal.mi) {

	jne	SHORT $LN41@xmlSchemaC

; 3547 : 	    if (lo > swp->value.decimal.lo) {

	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN40@xmlSchemaC

; 3548 : 		return order;
; 3549 : 	    } else if (lo == swp->value.decimal.lo) {

	jne	SHORT $LN41@xmlSchemaC

; 3550 : 		if (x->value.decimal.total == y->value.decimal.total) {

	mov	eax, DWORD PTR _x$[ebp]
	mov	al, BYTE PTR [eax+25]
	cmp	al, BYTE PTR [ebx+25]
	jne	SHORT $LN40@xmlSchemaC
$LN57@xmlSchemaC:
	pop	esi
	pop	edi

; 3551 : 		    return 0;

	xor	eax, eax

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlSchemaC:

; 3554 : 		}
; 3555 : 	    }
; 3556 : 	}
; 3557 :     }
; 3558 :     return -order;

	mov	eax, DWORD PTR _order$1$[ebp]
	pop	esi
	pop	edi
	neg	eax

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlSchemaC:

; 3552 : 		} else {
; 3553 : 		    return order;

	mov	eax, DWORD PTR _order$1$[ebp]
	pop	esi
	pop	edi

; 3559 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareDecimals ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValAtomicType
_TEXT	SEGMENT
_cval$1 = -56						; size = 25
_ret$3$ = -28						; size = 4
_hi$2 = -28						; size = 4
_lo$3 = -28						; size = 4
_mi$4 = -24						; size = 4
_mi$5 = -24						; size = 4
_lo$6 = -24						; size = 4
_ret$4$ = -20						; size = 4
_lo$7 = -20						; size = 4
_mi$8 = -20						; size = 4
_ret$5$ = -16						; size = 4
_hi$9 = -16						; size = 4
_sign$1$ = -12						; size = 4
_pad$1$ = -12						; size = 4
_neg$1$ = -12						; size = 4
_neg$1$ = -12						; size = 4
_v$14$ = -12						; size = 4
$T10 = -12						; size = 1
_hi$11 = -12						; size = 4
_prefix$12 = -12					; size = 4
_uri$1$ = -8						; size = 4
_digits_before$1$ = -8					; size = 4
_v$21$ = -8						; size = 4
_v$18$ = -8						; size = 4
_cur$13 = -8						; size = 4
_cur$14 = -8						; size = 4
_cptr$15 = -8						; size = 4
_norm$1$ = -4						; size = 4
_total$1$ = 8						; size = 4
_uri$1$ = 8						; size = 4
_strip$1$ = 8						; size = 4
_strip$1$ = 8						; size = 4
_strip$1$ = 8						; size = 4
_integ$1$ = 8						; size = 4
$T16 = 8						; size = 1
$T17 = 8						; size = 1
_cur$18 = 8						; size = 4
_prefix$19 = 8						; size = 4
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_flags$ = 24						; size = 4
_ws$ = 28						; size = 4
_normOnTheFly$ = 32					; size = 4
_applyNorm$ = 36					; size = 4
_createStringValue$ = 40				; size = 4
_xmlSchemaValAtomicType PROC				; COMDAT

; 2147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	ebx, ebx
	mov	DWORD PTR _norm$1$[ebp], 0
	cmp	DWORD PTR _xmlSchemaTypesInitialized, ebx
	jne	SHORT $LN74@xmlSchemaV

; 2148 :     xmlSchemaValPtr v;
; 2149 :     xmlChar *norm = NULL;
; 2150 :     int ret = 0;
; 2151 : 
; 2152 :     if (xmlSchemaTypesInitialized == 0)
; 2153 :         xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN74@xmlSchemaV:

; 2154 :     if (type == NULL)

	mov	ecx, DWORD PTR _type$[ebp]
	test	ecx, ecx
	jne	SHORT $LN75@xmlSchemaV

; 2155 :         return (-1);

	or	eax, -1
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@xmlSchemaV:

; 2156 : 
; 2157 :     /*
; 2158 :      * validating a non existant text node is similar to validating
; 2159 :      * an empty one.
; 2160 :      */
; 2161 :     if (value == NULL)
; 2162 :         value = BAD_CAST "";
; 2163 : 
; 2164 :     if (val != NULL)

	mov	eax, DWORD PTR _value$[ebp]
	test	eax, eax
	mov	edx, DWORD PTR _val$[ebp]
	push	edi
	mov	edi, OFFSET ??_C@_00CNPNBAHC@@
	cmovne	edi, eax
	test	edx, edx
	je	SHORT $LN77@xmlSchemaV

; 2165 :         *val = NULL;

	mov	DWORD PTR [edx], ebx
$LN77@xmlSchemaV:
	push	esi

; 2166 :     if ((flags == 0) && (value != NULL)) {

	mov	esi, edi
	cmp	DWORD PTR _flags$[ebp], ebx
	jne	SHORT $LN82@xmlSchemaV
	test	edi, edi
	je	SHORT $LN82@xmlSchemaV

; 2167 : 
; 2168 :         if ((type->builtInType != XML_SCHEMAS_STRING) &&
; 2169 : 	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&

	mov	eax, DWORD PTR [ecx+88]
	cmp	eax, 1
	je	SHORT $LN82@xmlSchemaV
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN82@xmlSchemaV
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN82@xmlSchemaV

; 2170 : 	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
; 2171 : 	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)

	push	edi
	cmp	eax, 2
	jne	SHORT $LN80@xmlSchemaV

; 2172 : 		norm = xmlSchemaWhiteSpaceReplace(value);

	call	_xmlSchemaWhiteSpaceReplace
	jmp	SHORT $LN656@xmlSchemaV
$LN80@xmlSchemaV:

; 2173 :             else
; 2174 : 		norm = xmlSchemaCollapseString(value);

	call	_xmlSchemaCollapseString
$LN656@xmlSchemaV:
	mov	edx, DWORD PTR _val$[ebp]

; 2175 :             if (norm != NULL)

	add	esp, 4
	test	eax, eax
	mov	DWORD PTR _norm$1$[ebp], eax
	cmovne	esi, eax
$LN82@xmlSchemaV:

; 2176 :                 value = norm;
; 2177 :         }
; 2178 :     }
; 2179 : 
; 2180 :     switch (type->builtInType) {

	mov	edi, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [edi+88]
	cmp	ecx, 46					; 0000002eH
	ja	$done$680
	movzx	eax, BYTE PTR $LN633@xmlSchemaV[ecx]
	jmp	DWORD PTR $LN679@xmlSchemaV[eax*4]
$LN84@xmlSchemaV:

; 2181 :         case XML_SCHEMAS_UNKNOWN:
; 2182 :             goto error;
; 2183 : 	case XML_SCHEMAS_ANYTYPE:
; 2184 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 2185 : 	    if ((createStringValue) && (val != NULL)) {

	cmp	DWORD PTR _createStringValue$[ebp], ebx
	je	$return0$681
	test	edx, edx
	je	$return0$681

; 2186 : 		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2187 : 		if (v != NULL) {

	test	edi, edi
	je	$error$682

; 2188 : 		    v->value.str = xmlStrdup(value);

	push	esi
	call	_xmlStrdup

; 2189 : 		    *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [ecx], edi

; 2190 : 		} else {

	jmp	$return0$681
$LN88@xmlSchemaV:

; 2191 : 		    goto error;
; 2192 : 		}
; 2193 : 	    }
; 2194 : 	    goto return0;
; 2195 :         case XML_SCHEMAS_STRING:
; 2196 : 	    if (! normOnTheFly) {

	mov	edi, DWORD PTR _ws$[ebp]
	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	jne	SHORT $LN7@xmlSchemaV

; 2197 : 		const xmlChar *cur = value;

	mov	ecx, esi

; 2198 : 
; 2199 : 		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {

	cmp	edi, 2
	jne	SHORT $LN90@xmlSchemaV

; 2200 : 		    while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN7@xmlSchemaV
$LL4@xmlSchemaV:

; 2201 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	cmp	al, 13					; 0000000dH
	je	$return1$683
	cmp	al, 10					; 0000000aH
	je	$return1$683
	cmp	al, 9
	je	$return1$683

; 2202 : 			    goto return1;
; 2203 : 			} else {
; 2204 : 			    cur++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL4@xmlSchemaV

; 3053 :                     else if (decc < 64)

	jmp	SHORT $LN7@xmlSchemaV
$LN90@xmlSchemaV:

; 2205 : 			}
; 2206 : 		    }
; 2207 : 		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {

	cmp	edi, 3
	jne	SHORT $LN7@xmlSchemaV

; 2208 : 		    while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN7@xmlSchemaV
$LL6@xmlSchemaV:

; 2209 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	cmp	al, 13					; 0000000dH
	je	$return1$683
	cmp	al, 10					; 0000000aH
	je	$return1$683
	cmp	al, 9
	je	$return1$683

; 2210 : 			    goto return1;
; 2211 : 			} else if IS_WSP_SPACE_CH(*cur) {

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 32					; 00000020H
	jne	SHORT $LN99@xmlSchemaV

; 2212 : 			    cur++;
; 2213 : 			    if IS_WSP_SPACE_CH(*cur)

	cmp	dl, al
	je	$return1$683
$LN99@xmlSchemaV:

; 2208 : 		    while (*cur != 0) {

	mov	al, dl
	test	dl, dl
	jne	SHORT $LL6@xmlSchemaV
$LN7@xmlSchemaV:

; 2214 : 				goto return1;
; 2215 : 			} else {
; 2216 : 			    cur++;
; 2217 : 			}
; 2218 : 		    }
; 2219 : 		}
; 2220 : 	    }
; 2221 : 	    if (createStringValue && (val != NULL)) {

	cmp	DWORD PTR _createStringValue$[ebp], ebx
	je	$return0$681
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2222 : 		if (applyNorm) {

	cmp	DWORD PTR _applyNorm$[ebp], 0
	je	SHORT $LN107@xmlSchemaV

; 2223 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	edi, 3
	jne	SHORT $LN104@xmlSchemaV

; 2224 : 			norm = xmlSchemaCollapseString(value);

	push	esi
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$1$[ebp], eax

; 2227 : 		    if (norm != NULL)

	test	eax, eax
	cmovne	esi, eax

; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);

	push	1

; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {

	jmp	$LN673@xmlSchemaV
$LN104@xmlSchemaV:

; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	edi, 2
	jne	SHORT $LN650@xmlSchemaV

; 2226 : 			norm = xmlSchemaWhiteSpaceReplace(value);

	push	esi
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	DWORD PTR _norm$1$[ebp], eax

; 2227 : 		    if (norm != NULL)

	test	eax, eax
	cmovne	esi, eax

; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);

	push	1

; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {

	jmp	$LN673@xmlSchemaV
$LN650@xmlSchemaV:

; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	mov	eax, DWORD PTR _norm$1$[ebp]

; 2227 : 		    if (norm != NULL)

	test	eax, eax
	cmovne	esi, eax
$LN107@xmlSchemaV:

; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);

	push	1

; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {

	jmp	$LN673@xmlSchemaV
$LN110@xmlSchemaV:

; 2235 : 		    goto error;
; 2236 : 		}
; 2237 : 	    }
; 2238 :             goto return0;
; 2239 :         case XML_SCHEMAS_NORMSTRING:{
; 2240 : 		if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	SHORT $LN111@xmlSchemaV

; 2241 : 		    if (applyNorm) {

	cmp	DWORD PTR _applyNorm$[ebp], ebx
	je	SHORT $LN9@xmlSchemaV

; 2242 : 			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	push	esi
	jne	SHORT $LN114@xmlSchemaV

; 2243 : 			    norm = xmlSchemaCollapseString(value);

	call	_xmlSchemaCollapseString
	jmp	SHORT $LN657@xmlSchemaV
$LN114@xmlSchemaV:

; 2244 : 			else
; 2245 : 			    norm = xmlSchemaWhiteSpaceReplace(value);

	call	_xmlSchemaWhiteSpaceReplace
$LN657@xmlSchemaV:

; 2246 : 			if (norm != NULL)

	add	esp, 4
	mov	DWORD PTR _norm$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN9@xmlSchemaV

; 2247 : 			    value = norm;

	mov	esi, eax

; 2248 : 		    }
; 2249 : 		} else {

	jmp	SHORT $LN9@xmlSchemaV
$LN111@xmlSchemaV:

; 2250 : 		    const xmlChar *cur = value;
; 2251 : 		    while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	mov	ecx, esi
	test	al, al
	je	SHORT $LN9@xmlSchemaV
	npad	7
$LL8@xmlSchemaV:

; 2252 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	cmp	al, 13					; 0000000dH
	je	$return1$683
	cmp	al, 10					; 0000000aH
	je	$return1$683
	cmp	al, 9
	je	$return1$683

; 2253 : 			    goto return1;
; 2254 : 			} else {
; 2255 : 			    cur++;

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL8@xmlSchemaV
$LN9@xmlSchemaV:

; 2256 : 			}
; 2257 : 		    }
; 2258 : 		}
; 2259 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2260 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);

	push	2

; 2261 :                     if (v != NULL) {
; 2262 :                         v->value.str = xmlStrdup(value);
; 2263 :                         *val = v;
; 2264 :                     } else {

	jmp	$LN673@xmlSchemaV
$LN123@xmlSchemaV:

; 2265 :                         goto error;
; 2266 :                     }
; 2267 :                 }
; 2268 :                 goto return0;
; 2269 :             }
; 2270 :         case XML_SCHEMAS_DECIMAL:{
; 2271 :                 const xmlChar *cur = value;
; 2272 :                 unsigned int len, neg, integ, hasLeadingZeroes;
; 2273 : 		xmlChar cval[25];
; 2274 : 		xmlChar *cptr = cval;

	lea	edi, DWORD PTR _cval$1[ebp]

; 2275 : 
; 2276 :                 if ((cur == NULL) || (*cur == 0))

	test	esi, esi
	je	$return1$683
	mov	al, BYTE PTR [esi]
	test	al, al
	je	$return1$683

; 2277 :                     goto return1;
; 2278 : 
; 2279 : 		/*
; 2280 : 		* xs:decimal has a whitespace-facet value of 'collapse'.
; 2281 : 		*/
; 2282 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	SHORT $LN636@xmlSchemaV
	npad	4
$LL10@xmlSchemaV:

; 2283 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN127@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN128@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN127@xmlSchemaV
$LN128@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN636@xmlSchemaV
$LN127@xmlSchemaV:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL10@xmlSchemaV
$LN636@xmlSchemaV:

; 2284 : 
; 2285 : 		/*
; 2286 : 		* First we handle an optional sign.
; 2287 : 		*/
; 2288 : 		neg = 0;

	mov	DWORD PTR _neg$1$[ebp], ebx

; 2289 :                 if (*cur == '-') {

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN129@xmlSchemaV

; 2290 : 		    neg = 1;

	mov	DWORD PTR _neg$1$[ebp], 1

; 2291 :                     cur++;

	jmp	SHORT $LN658@xmlSchemaV
$LN129@xmlSchemaV:

; 2292 : 		} else if (*cur == '+')

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN131@xmlSchemaV
$LN658@xmlSchemaV:

; 2293 :                     cur++;
; 2294 : 		/*
; 2295 : 		* Disallow: "", "-", "- "
; 2296 : 		*/
; 2297 : 		if (*cur == 0)

	mov	al, BYTE PTR [esi+1]
	inc	esi
$LN131@xmlSchemaV:
	test	al, al
	je	$return1$683

; 2298 : 		    goto return1;
; 2299 : 		/*
; 2300 : 		 * Next we "pre-parse" the number, in preparation for calling
; 2301 : 		 * the common routine xmlSchemaParseUInt.  We get rid of any
; 2302 : 		 * leading zeroes (because we have reserved only 25 chars),
; 2303 : 		 * and note the position of a decimal point.
; 2304 : 		 */
; 2305 : 		len = 0;
; 2306 : 		integ = ~0u;

	or	ecx, -1
	xor	ebx, ebx

; 2307 : 		hasLeadingZeroes = 0;

	xor	edx, edx
	mov	DWORD PTR _integ$1$[ebp], ecx

; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {

	cmp	al, 48					; 00000030H
	jne	SHORT $LN13@xmlSchemaV

; 2313 : 		    hasLeadingZeroes = 1;

	lea	edx, DWORD PTR [ebx+1]
$LL12@xmlSchemaV:

; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {

	mov	al, BYTE PTR [esi+1]

; 2312 : 		    cur++;

	inc	esi
	cmp	al, 48					; 00000030H
	je	SHORT $LL12@xmlSchemaV
$LN13@xmlSchemaV:

; 2314 : 		}
; 2315 : 		if (*cur != 0) {

	test	al, al
	je	SHORT $LN15@xmlSchemaV
$LL16@xmlSchemaV:

; 2316 : 		    do {
; 2317 : 			if ((*cur >= '0') && (*cur <= '9')) {

	mov	cl, BYTE PTR [esi]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN134@xmlSchemaV

; 2318 : 			    *cptr++ = *cur++;

	mov	BYTE PTR [edi], cl

; 2319 : 			    len++;

	inc	ebx
	inc	edi
	inc	esi

; 2334 : 				goto return1;
; 2335 : 			    break;
; 2336 : 			} else
; 2337 : 			    break;
; 2338 : 		    } while (len < 24);

	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL16@xmlSchemaV
	jmp	SHORT $LN15@xmlSchemaV
$LN134@xmlSchemaV:

; 2320 : 			} else if (*cur == '.') {

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN15@xmlSchemaV

; 2321 : 			    cur++;
; 2322 : 			    integ = len;

	mov	ecx, ebx
	inc	esi
	mov	DWORD PTR _integ$1$[ebp], ecx
$LL19@xmlSchemaV:

; 2323 : 			    do {
; 2324 : 				if ((*cur >= '0') && (*cur <= '9')) {

	mov	cl, BYTE PTR [esi]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN18@xmlSchemaV

; 2325 : 				    *cptr++ = *cur++;

	mov	BYTE PTR [edi], cl

; 2326 : 				    len++;

	inc	ebx
	inc	edi
	inc	esi

; 2327 : 				} else
; 2328 : 				    break;
; 2329 : 			    } while (len < 24);

	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL19@xmlSchemaV
$LN18@xmlSchemaV:

; 2330 : 			    /*
; 2331 : 			    * Disallow "." but allow "00."
; 2332 : 			    */
; 2333 : 			    if ((len == 0) && (!hasLeadingZeroes))

	test	ebx, ebx
	jne	SHORT $LN15@xmlSchemaV
	test	edx, edx
	je	$return1$683
$LN15@xmlSchemaV:

; 2339 : 		}
; 2340 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN637@xmlSchemaV
$LL20@xmlSchemaV:

; 2341 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN142@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN143@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN142@xmlSchemaV
$LN143@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN637@xmlSchemaV
$LN142@xmlSchemaV:
	inc	esi
	jmp	SHORT $LL20@xmlSchemaV
$LN637@xmlSchemaV:

; 2342 : 		if (*cur != 0)

	cmp	BYTE PTR [esi], 0
	jne	$return1$683

; 2343 : 		    goto return1; /* error if any extraneous chars */
; 2344 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$return0$681

; 2345 :                     v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);

	push	3
	call	_xmlSchemaNewValue
	mov	esi, eax
	add	esp, 4

; 2346 :                     if (v != NULL) {

	test	esi, esi
	je	$return0$681

; 2347 : 			/*
; 2348 : 			* Now evaluate the significant digits of the number
; 2349 : 			*/
; 2350 : 			if (len != 0) {

	mov	ecx, DWORD PTR _integ$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN149@xmlSchemaV

; 2351 : 
; 2352 : 			    if (integ != ~0u) {

	cmp	ecx, -1
	je	SHORT $LN638@xmlSchemaV

; 2353 : 				/*
; 2354 : 				* Get rid of trailing zeroes in the
; 2355 : 				* fractional part.
; 2356 : 				*/
; 2357 : 				while ((len != integ) && (*(cptr-1) == '0')) {

	cmp	ebx, ecx
	je	SHORT $LN638@xmlSchemaV
$LL22@xmlSchemaV:
	cmp	BYTE PTR [edi-1], 48			; 00000030H
	jne	SHORT $LN638@xmlSchemaV

; 2358 : 				    cptr--;
; 2359 : 				    len--;

	dec	ebx
	dec	edi
	cmp	ebx, ecx
	jne	SHORT $LL22@xmlSchemaV
$LN638@xmlSchemaV:

; 2360 : 				}
; 2361 : 			    }
; 2362 : 			    /*
; 2363 : 			    * Terminate the (preparsed) string.
; 2364 : 			    */
; 2365 : 			    if (len != 0) {

	test	ebx, ebx
	je	SHORT $LN149@xmlSchemaV

; 2366 : 				*cptr = 0;
; 2367 : 				cptr = cval;

	lea	eax, DWORD PTR _cval$1[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR _cptr$15[ebp], eax

; 2368 : 
; 2369 : 				xmlSchemaParseUInt((const xmlChar **)&cptr,

	lea	eax, DWORD PTR [esi+16]
	push	eax
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	eax, DWORD PTR [esi+8]
	push	eax
	lea	eax, DWORD PTR _cptr$15[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	mov	ecx, DWORD PTR _integ$1$[ebp]
	add	esp, 16					; 00000010H
$LN149@xmlSchemaV:

; 2370 : 				    &v->value.decimal.lo,
; 2371 : 				    &v->value.decimal.mi,
; 2372 : 				    &v->value.decimal.hi);
; 2373 : 			    }
; 2374 : 			}
; 2375 : 			/*
; 2376 : 			* Set the total digits to 1 if a zero value.
; 2377 : 			*/
; 2378 :                         v->value.decimal.sign = neg;

	mov	eax, DWORD PTR [esi+24]
	and	eax, -2					; fffffffeH
	or	eax, DWORD PTR _neg$1$[ebp]
	mov	DWORD PTR [esi+24], eax

; 2379 : 			if (len == 0) {

	test	ebx, ebx
	jne	SHORT $LN150@xmlSchemaV

; 2388 : 			}
; 2389 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	BYTE PTR [esi+25], 1
	mov	DWORD PTR [eax], esi

; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;

	jmp	$return0$681
$LN150@xmlSchemaV:

; 2380 : 			    /* Speedup for zero values. */
; 2381 : 			    v->value.decimal.total = 1;
; 2382 : 			} else {
; 2383 : 			    v->value.decimal.total = len;

	mov	BYTE PTR [esi+25], bl
	mov	eax, DWORD PTR [esi+24]
	and	eax, -255				; ffffff01H

; 2384 : 			    if (integ == ~0u)

	cmp	ecx, -1
	jne	SHORT $LN152@xmlSchemaV

; 2385 : 				v->value.decimal.frac = 0;

	mov	DWORD PTR [esi+24], eax

; 2388 : 			}
; 2389 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], esi

; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;

	jmp	$return0$681
$LN152@xmlSchemaV:

; 2386 : 			    else
; 2387 : 				v->value.decimal.frac = len - integ;

	sub	ebx, ecx
	add	ebx, ebx
	and	ebx, 254				; 000000feH
	or	ebx, eax

; 2388 : 			}
; 2389 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [eax], esi

; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;

	jmp	$return0$681
$LN154@xmlSchemaV:

; 2393 :             }
; 2394 :         case XML_SCHEMAS_TIME:
; 2395 :         case XML_SCHEMAS_GDAY:
; 2396 :         case XML_SCHEMAS_GMONTH:
; 2397 :         case XML_SCHEMAS_GMONTHDAY:
; 2398 :         case XML_SCHEMAS_GYEAR:
; 2399 :         case XML_SCHEMAS_GYEARMONTH:
; 2400 :         case XML_SCHEMAS_DATE:
; 2401 :         case XML_SCHEMAS_DATETIME:
; 2402 :             ret = xmlSchemaValidateDates(type->builtInType, value, val,

	push	DWORD PTR _normOnTheFly$[ebp]
	push	edx
	push	esi
	push	ecx
	call	_xmlSchemaValidateDates
$LN676@xmlSchemaV:

; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)

	add	esp, 16					; 00000010H
	mov	ebx, eax
$done$680:
	mov	eax, DWORD PTR _norm$1$[ebp]
	test	eax, eax
	je	SHORT $LN497@xmlSchemaV

; 3335 :         xmlFree(norm);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN497@xmlSchemaV:

; 3336 :     return (ret);

	pop	esi
	pop	edi
	mov	eax, ebx
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN155@xmlSchemaV:

; 2403 : 		normOnTheFly);
; 2404 :             break;
; 2405 :         case XML_SCHEMAS_DURATION:
; 2406 :             ret = xmlSchemaValidateDuration(type, value, val,

	push	DWORD PTR _normOnTheFly$[ebp]
	push	edx
	push	esi
	push	edi
	call	_xmlSchemaValidateDuration

; 2407 : 		normOnTheFly);
; 2408 :             break;

	jmp	SHORT $LN676@xmlSchemaV
$LN156@xmlSchemaV:

; 2409 :         case XML_SCHEMAS_FLOAT:
; 2410 :         case XML_SCHEMAS_DOUBLE: {
; 2411 :                 const xmlChar *cur = value;
; 2412 :                 int neg = 0;
; 2413 :                 int digits_before = 0;
; 2414 :                 int digits_after = 0;

	xor	edi, edi
	mov	DWORD PTR _neg$1$[ebp], ebx
	mov	ecx, esi
	mov	DWORD PTR _digits_before$1$[ebp], ebx

; 2415 : 
; 2416 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	SHORT $LN639@xmlSchemaV
$LL24@xmlSchemaV:

; 2417 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN158@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN159@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN158@xmlSchemaV
$LN159@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN639@xmlSchemaV
$LN158@xmlSchemaV:
	inc	ecx
	jmp	SHORT $LL24@xmlSchemaV
$LN639@xmlSchemaV:

; 2418 : 
; 2419 :                 if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {

	mov	al, BYTE PTR [ecx]
	cmp	al, 78					; 0000004eH
	jne	SHORT $LN160@xmlSchemaV
	cmp	BYTE PTR [ecx+1], 97			; 00000061H
	jne	SHORT $LN160@xmlSchemaV
	cmp	BYTE PTR [ecx+2], al
	jne	SHORT $LN160@xmlSchemaV

; 2420 :                     cur += 3;
; 2421 :                     if (*cur != 0)

	cmp	BYTE PTR [ecx+3], bl
	jne	$return1$683

; 2422 :                         goto return1;
; 2423 :                     if (val != NULL) {

	test	edx, edx
	je	$return0$681

; 2424 :                         if (type == xmlSchemaTypeFloatDef) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN163@xmlSchemaV

; 2425 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	add	esp, 4

; 2426 :                             if (v != NULL) {

	test	eax, eax
	je	SHORT $LN165@xmlSchemaV

; 2427 :                                 v->value.f = (float) xmlXPathNAN;

	movsd	xmm0, QWORD PTR _xmlXPathNAN
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 2428 :                             } else {
; 2429 :                                 xmlSchemaFreeValue(v);
; 2430 :                                 goto error;
; 2431 :                             }
; 2432 :                         } else {

	jmp	$LN168@xmlSchemaV
$LN165@xmlSchemaV:

; 3349 :   error:
; 3350 :     if (norm != NULL)

	push	0
	call	_xmlSchemaFreeValue
	jmp	$LN665@xmlSchemaV
$LN163@xmlSchemaV:

; 2433 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	add	esp, 4

; 2434 :                             if (v != NULL) {

	test	eax, eax
	je	SHORT $LN165@xmlSchemaV

; 2435 :                                 v->value.d = xmlXPathNAN;

	movsd	xmm0, QWORD PTR _xmlXPathNAN
	movsd	QWORD PTR [eax+8], xmm0

; 2436 :                             } else {
; 2437 :                                 xmlSchemaFreeValue(v);
; 2438 :                                 goto error;
; 2439 :                             }
; 2440 :                         }
; 2441 :                         *val = v;

	jmp	$LN168@xmlSchemaV
$LN160@xmlSchemaV:

; 2442 :                     }
; 2443 :                     goto return0;
; 2444 :                 }
; 2445 :                 if (*cur == '-') {

	mov	bl, al
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN169@xmlSchemaV

; 2446 :                     neg = 1;
; 2447 :                     cur++;

	mov	bl, BYTE PTR [ecx+1]
	mov	DWORD PTR _neg$1$[ebp], 1
$LN169@xmlSchemaV:

; 2448 :                 }
; 2449 :                 if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {

	lea	edx, DWORD PTR [ecx+1]
	cmovne	edx, ecx
	cmp	bl, 73					; 00000049H
	jne	$LN170@xmlSchemaV
	cmp	BYTE PTR [edx+1], 78			; 0000004eH
	jne	$LN170@xmlSchemaV
	cmp	BYTE PTR [edx+2], 70			; 00000046H
	jne	$LN170@xmlSchemaV

; 2450 :                     cur += 3;
; 2451 :                     if (*cur != 0)

	cmp	BYTE PTR [edx+3], 0
	jne	$return1$683

; 2452 :                         goto return1;
; 2453 :                     if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2454 :                         if (type == xmlSchemaTypeFloatDef) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN173@xmlSchemaV

; 2455 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	add	esp, 4

; 2456 :                             if (v != NULL) {

	test	eax, eax
	je	$LN165@xmlSchemaV

; 2457 :                                 if (neg)

	cmp	DWORD PTR _neg$1$[ebp], edi
	je	SHORT $LN177@xmlSchemaV

; 2458 :                                     v->value.f = (float) xmlXPathNINF;
; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;
; 2461 :                             } else {
; 2462 :                                 xmlSchemaFreeValue(v);
; 2463 :                                 goto error;
; 2464 :                             }
; 2465 :                         } else {

	movsd	xmm0, QWORD PTR _xmlXPathNINF
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;

	mov	DWORD PTR [ebx], eax
	jmp	$return0$681
$LN177@xmlSchemaV:
	movsd	xmm0, QWORD PTR _xmlXPathPINF

; 2458 :                                     v->value.f = (float) xmlXPathNINF;
; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;
; 2461 :                             } else {
; 2462 :                                 xmlSchemaFreeValue(v);
; 2463 :                                 goto error;
; 2464 :                             }
; 2465 :                         } else {

	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;

	mov	DWORD PTR [ebx], eax
	jmp	$return0$681
$LN173@xmlSchemaV:

; 2466 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	add	esp, 4

; 2467 :                             if (v != NULL) {

	test	eax, eax
	je	$LN165@xmlSchemaV

; 2468 :                                 if (neg)

	cmp	DWORD PTR _neg$1$[ebp], edi
	je	SHORT $LN181@xmlSchemaV

; 2469 :                                     v->value.d = xmlXPathNINF;

	movsd	xmm0, QWORD PTR _xmlXPathNINF

; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;

	movsd	QWORD PTR [eax+8], xmm0
	mov	DWORD PTR [ebx], eax
	jmp	$return0$681
$LN181@xmlSchemaV:

; 2470 :                                 else
; 2471 :                                     v->value.d = xmlXPathPINF;

	movsd	xmm0, QWORD PTR _xmlXPathPINF

; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;

	movsd	QWORD PTR [eax+8], xmm0
	mov	DWORD PTR [ebx], eax
	jmp	$return0$681
$LN170@xmlSchemaV:

; 2478 :                     }
; 2479 :                     goto return0;
; 2480 :                 }
; 2481 :                 if ((neg == 0) && (*cur == '+'))

	mov	cl, bl
	mov	eax, edx
	cmp	DWORD PTR _neg$1$[ebp], edi
	jne	SHORT $LN183@xmlSchemaV
	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN183@xmlSchemaV

; 2482 :                     cur++;

	mov	cl, BYTE PTR [edx+1]
	lea	eax, DWORD PTR [edx+1]
$LN183@xmlSchemaV:

; 2483 :                 if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))

	test	cl, cl
	je	$return1$683
	cmp	cl, 43					; 0000002bH
	je	$return1$683
	cmp	cl, 45					; 0000002dH
	je	$return1$683

; 2484 :                     goto return1;
; 2485 :                 while ((*cur >= '0') && (*cur <= '9')) {

	cmp	cl, 48					; 00000030H
	jb	SHORT $LN27@xmlSchemaV
	mov	dl, cl
	xor	edi, edi
$LL26@xmlSchemaV:
	mov	cl, dl
	cmp	dl, 57					; 00000039H
	ja	SHORT $LN640@xmlSchemaV
	mov	cl, BYTE PTR [eax+1]

; 2486 :                     cur++;

	inc	eax

; 2487 :                     digits_before++;

	inc	edi
	mov	dl, cl
	cmp	cl, 48					; 00000030H
	jae	SHORT $LL26@xmlSchemaV
$LN640@xmlSchemaV:
	mov	DWORD PTR _digits_before$1$[ebp], edi
	xor	edi, edi
$LN27@xmlSchemaV:

; 2488 :                 }
; 2489 :                 if (*cur == '.') {

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN641@xmlSchemaV

; 2490 :                     cur++;
; 2491 :                     while ((*cur >= '0') && (*cur <= '9')) {

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN641@xmlSchemaV
	npad	6
$LL28@xmlSchemaV:
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN641@xmlSchemaV
	mov	cl, BYTE PTR [eax+1]

; 2492 :                         cur++;

	inc	eax

; 2493 :                         digits_after++;

	inc	edi
	cmp	cl, 48					; 00000030H
	jae	SHORT $LL28@xmlSchemaV
$LN641@xmlSchemaV:

; 2494 :                     }
; 2495 :                 }
; 2496 :                 if ((digits_before == 0) && (digits_after == 0))

	cmp	DWORD PTR _digits_before$1$[ebp], 0
	jne	SHORT $LN187@xmlSchemaV
	test	edi, edi
	je	$return1$683
$LN187@xmlSchemaV:

; 2497 :                     goto return1;
; 2498 :                 if ((*cur == 'e') || (*cur == 'E')) {

	mov	cl, BYTE PTR [eax]
	cmp	cl, 101					; 00000065H
	je	SHORT $LN189@xmlSchemaV
	cmp	cl, 69					; 00000045H
	jne	SHORT $LN642@xmlSchemaV
$LN189@xmlSchemaV:

; 2499 :                     cur++;
; 2500 :                     if ((*cur == '-') || (*cur == '+'))

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 45					; 0000002dH
	je	SHORT $LN191@xmlSchemaV
	cmp	cl, 43					; 0000002bH
	jne	SHORT $LN515@xmlSchemaV
$LN191@xmlSchemaV:

; 2501 :                         cur++;

	mov	cl, BYTE PTR [eax+1]
	inc	eax
$LN515@xmlSchemaV:

; 2502 :                     while ((*cur >= '0') && (*cur <= '9'))

	cmp	cl, 48					; 00000030H
	jb	SHORT $LN642@xmlSchemaV
$LL30@xmlSchemaV:
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN642@xmlSchemaV
	mov	cl, BYTE PTR [eax+1]

; 2503 :                         cur++;

	inc	eax
	cmp	cl, 48					; 00000030H
	jae	SHORT $LL30@xmlSchemaV
$LN642@xmlSchemaV:

; 2504 :                 }
; 2505 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN643@xmlSchemaV
$LL32@xmlSchemaV:

; 2506 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN193@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN194@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN193@xmlSchemaV
$LN194@xmlSchemaV:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN643@xmlSchemaV
$LN193@xmlSchemaV:
	inc	eax
	jmp	SHORT $LL32@xmlSchemaV
$LN643@xmlSchemaV:

; 2507 : 
; 2508 :                 if (*cur != 0)

	cmp	BYTE PTR [eax], 0
	jne	SHORT $return1$683

; 2509 :                     goto return1;
; 2510 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2511 :                     if (type == xmlSchemaTypeFloatDef) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN197@xmlSchemaV

; 2512 :                         v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2513 :                         if (v != NULL) {

	test	edi, edi
	je	$error$682

; 2514 : 			    /*
; 2515 : 			    * TODO: sscanf seems not to give the correct
; 2516 : 			    * value for extremely high/low values.
; 2517 : 			    * E.g. "1E-149" results in zero.
; 2518 : 			    */
; 2519 :                             if (sscanf((const char *) value, "%f",
; 2520 :                                  &(v->value.f)) == 1) {

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf@
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	$LN674@xmlSchemaV
$LN201@xmlSchemaV:

; 3341 :   return1:
; 3342 :     if (norm != NULL)

	push	edi
	call	_xmlSchemaFreeValue
$LN675@xmlSchemaV:
	add	esp, 4
$return1$683:
	mov	eax, DWORD PTR _norm$1$[ebp]
	test	eax, eax
	je	SHORT $LN499@xmlSchemaV

; 3343 :         xmlFree(norm);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN499@xmlSchemaV:

; 3344 :     return (1);

	pop	esi
	pop	edi
	mov	eax, 1
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN197@xmlSchemaV:

; 2521 :                                 *val = v;
; 2522 :                             } else {
; 2523 :                                 xmlSchemaFreeValue(v);
; 2524 :                                 goto return1;
; 2525 :                             }
; 2526 :                         } else {
; 2527 :                             goto error;
; 2528 :                         }
; 2529 :                     } else {
; 2530 :                         v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2531 :                         if (v != NULL) {

	test	edi, edi
	je	$error$682

; 2532 : 			    /*
; 2533 : 			    * TODO: sscanf seems not to give the correct
; 2534 : 			    * value for extremely high/low values.
; 2535 : 			    */
; 2536 :                             if (sscanf((const char *) value, "%lf",
; 2537 :                                  &(v->value.d)) == 1) {

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf@
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN201@xmlSchemaV

; 3345 :   return0:
; 3346 :     if (norm != NULL)

	mov	DWORD PTR [ebx], edi
	jmp	$return0$681
$LN207@xmlSchemaV:

; 2538 :                                 *val = v;
; 2539 :                             } else {
; 2540 :                                 xmlSchemaFreeValue(v);
; 2541 :                                 goto return1;
; 2542 :                             }
; 2543 :                         } else {
; 2544 :                             goto error;
; 2545 :                         }
; 2546 :                     }
; 2547 :                 }
; 2548 :                 goto return0;
; 2549 :             }
; 2550 :         case XML_SCHEMAS_BOOLEAN:{
; 2551 :                 const xmlChar *cur = value;
; 2552 : 
; 2553 : 		if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	$LN208@xmlSchemaV
$LL34@xmlSchemaV:

; 2554 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN210@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN211@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN210@xmlSchemaV
$LN211@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN35@xmlSchemaV
$LN210@xmlSchemaV:
	inc	esi
	jmp	SHORT $LL34@xmlSchemaV
$LN35@xmlSchemaV:

; 2555 : 		    if (*cur == '0') {

	cmp	al, 48					; 00000030H
	je	SHORT $LN661@xmlSchemaV

; 2556 : 			ret = 0;
; 2557 : 			cur++;
; 2558 : 		    } else if (*cur == '1') {

	cmp	al, 49					; 00000031H
	jne	SHORT $LN214@xmlSchemaV

; 2559 : 			ret = 1;

	mov	edi, 1

; 2560 : 			cur++;

	jmp	SHORT $LN223@xmlSchemaV
$LN214@xmlSchemaV:

; 2561 : 		    } else if (*cur == 't') {

	cmp	al, 116					; 00000074H
	jne	SHORT $LN216@xmlSchemaV

; 2562 : 			cur++;
; 2563 : 			if ((*cur++ == 'r') && (*cur++ == 'u') &&

	mov	al, BYTE PTR [esi+1]
	cmp	al, 114					; 00000072H
	jne	$return1$683
	mov	al, BYTE PTR [esi+2]
	add	esi, 3
	cmp	al, 117					; 00000075H
	jne	$return1$683
	cmp	BYTE PTR [esi], 101			; 00000065H
	jne	$return1$683

; 2564 : 			    (*cur++ == 'e')) {
; 2565 : 			    ret = 1;

	mov	edi, 1

; 2566 : 			} else
; 2567 : 			    goto return1;
; 2568 : 		    } else if (*cur == 'f') {

	jmp	SHORT $LN223@xmlSchemaV
$LN216@xmlSchemaV:
	cmp	al, 102					; 00000066H
	jne	$return1$683

; 2569 : 			cur++;
; 2570 : 			if ((*cur++ == 'a') && (*cur++ == 'l') &&
; 2571 : 			    (*cur++ == 's') && (*cur++ == 'e')) {

	mov	al, BYTE PTR [esi+1]
	cmp	al, 97					; 00000061H
	jne	$return1$683
	mov	al, BYTE PTR [esi+2]
	cmp	al, 108					; 0000006cH
	jne	$return1$683
	mov	al, BYTE PTR [esi+3]
	add	esi, 4
	cmp	al, 115					; 00000073H
	jne	$return1$683
	cmp	BYTE PTR [esi], 101			; 00000065H
	jne	$return1$683
$LN661@xmlSchemaV:

; 2572 : 			    ret = 0;
; 2573 : 			} else
; 2574 : 			    goto return1;
; 2575 : 		    } else
; 2576 : 			goto return1;
; 2577 : 		    if (*cur != 0) {

	xor	edi, edi
$LN223@xmlSchemaV:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN235@xmlSchemaV
	npad	4
$LL36@xmlSchemaV:

; 2578 : 			while IS_WSP_BLANK_CH(*cur) cur++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN225@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN226@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN225@xmlSchemaV
$LN226@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN37@xmlSchemaV
$LN225@xmlSchemaV:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL36@xmlSchemaV
$LN37@xmlSchemaV:

; 2579 : 			if (*cur != 0)

	test	al, al
	jne	$return1$683

; 2580 : 			    goto return1;
; 2581 : 		    }
; 2582 : 		} else {

	jmp	$LN235@xmlSchemaV
$LN208@xmlSchemaV:

; 2583 : 		    if ((cur[0] == '0') && (cur[1] == 0))

	mov	al, BYTE PTR [esi]
	cmp	al, 48					; 00000030H
	jne	SHORT $LN586@xmlSchemaV
	cmp	BYTE PTR [esi+1], bl

; 2584 : 			ret = 0;

	jmp	SHORT $LN662@xmlSchemaV
$LN586@xmlSchemaV:

; 2585 : 		    else if ((cur[0] == '1') && (cur[1] == 0))

	cmp	al, 49					; 00000031H
	jne	SHORT $LN587@xmlSchemaV
	cmp	BYTE PTR [esi+1], bl
	jne	$return1$683

; 2586 : 			ret = 1;

	mov	edi, 1
	jmp	SHORT $LN235@xmlSchemaV
$LN587@xmlSchemaV:

; 2587 : 		    else if ((cur[0] == 't') && (cur[1] == 'r')
; 2588 : 			&& (cur[2] == 'u') && (cur[3] == 'e')
; 2589 : 			&& (cur[4] == 0))

	cmp	al, 116					; 00000074H
	jne	SHORT $LN232@xmlSchemaV
	cmp	BYTE PTR [esi+1], 114			; 00000072H
	jne	$return1$683
	cmp	BYTE PTR [esi+2], 117			; 00000075H
	jne	$return1$683
	cmp	BYTE PTR [esi+3], 101			; 00000065H
	jne	$return1$683
	cmp	BYTE PTR [esi+4], bl
	jne	$return1$683

; 2590 : 			ret = 1;

	mov	edi, 1
	jmp	SHORT $LN235@xmlSchemaV
$LN232@xmlSchemaV:

; 2591 : 		    else if ((cur[0] == 'f') && (cur[1] == 'a')
; 2592 : 			&& (cur[2] == 'l') && (cur[3] == 's')
; 2593 : 			&& (cur[4] == 'e') && (cur[5] == 0))

	cmp	al, 102					; 00000066H
	jne	$return1$683
	cmp	BYTE PTR [esi+1], 97			; 00000061H
	jne	$return1$683
	cmp	BYTE PTR [esi+2], 108			; 0000006cH
	jne	$return1$683
	cmp	BYTE PTR [esi+3], 115			; 00000073H
	jne	$return1$683
	cmp	BYTE PTR [esi+4], 101			; 00000065H
	jne	$return1$683
	cmp	BYTE PTR [esi+5], bl
$LN662@xmlSchemaV:

; 2594 : 			ret = 0;
; 2595 : 		    else
; 2596 : 			goto return1;
; 2597 : 		}
; 2598 :                 if (val != NULL) {

	jne	$return1$683
	xor	edi, edi
$LN235@xmlSchemaV:
	test	edx, edx
	je	$return0$681

; 2599 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);

	push	15					; 0000000fH
	call	_xmlSchemaNewValue
	add	esp, 4

; 2600 :                     if (v != NULL) {

	test	eax, eax
	je	$error$682

; 2601 :                         v->value.b = ret;

	mov	DWORD PTR [eax+8], edi

; 2602 :                         *val = v;
; 2603 :                     } else {

	jmp	$LN168@xmlSchemaV
$LN239@xmlSchemaV:

; 2604 :                         goto error;
; 2605 :                     }
; 2606 :                 }
; 2607 :                 goto return0;
; 2608 :             }
; 2609 :         case XML_SCHEMAS_TOKEN:{
; 2610 :                 const xmlChar *cur = value;

	mov	edx, esi

; 2611 : 
; 2612 : 		if (! normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	jne	SHORT $LN39@xmlSchemaV

; 2613 : 		    while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN39@xmlSchemaV
	npad	2
$LL38@xmlSchemaV:

; 2614 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	cmp	al, 13					; 0000000dH
	je	$return1$683
	cmp	al, 10					; 0000000aH
	je	$return1$683
	cmp	al, 9
	je	$return1$683

; 2615 : 			    goto return1;
; 2616 : 			} else if (*cur == ' ') {

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	cmp	al, 32					; 00000020H
	jne	SHORT $LN244@xmlSchemaV

; 2617 : 			    cur++;
; 2618 : 			    if (*cur == 0)

	test	cl, cl
	je	$return1$683

; 2619 : 				goto return1;
; 2620 : 			    if (*cur == ' ')

	cmp	cl, al
	je	$return1$683
$LN244@xmlSchemaV:

; 2613 : 		    while (*cur != 0) {

	mov	al, cl
	test	cl, cl
	jne	SHORT $LL38@xmlSchemaV
$LN39@xmlSchemaV:

; 2621 : 				goto return1;
; 2622 : 			} else {
; 2623 : 			    cur++;
; 2624 : 			}
; 2625 : 		    }
; 2626 : 		}
; 2627 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2628 :                     v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);

	push	16					; 00000010H

; 2629 :                     if (v != NULL) {
; 2630 :                         v->value.str = xmlStrdup(value);
; 2631 :                         *val = v;
; 2632 :                     } else {

	jmp	$LN673@xmlSchemaV
$LN251@xmlSchemaV:

; 2633 :                         goto error;
; 2634 :                     }
; 2635 :                 }
; 2636 :                 goto return0;
; 2637 :             }
; 2638 :         case XML_SCHEMAS_LANGUAGE:
; 2639 : 	    if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	SHORT $LN253@xmlSchemaV

; 2640 : 		norm = xmlSchemaCollapseString(value);

	push	esi
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$1$[ebp], eax

; 2641 : 		if (norm != NULL)

	test	eax, eax
	cmovne	esi, eax
$LN253@xmlSchemaV:

; 2642 : 		    value = norm;
; 2643 : 	    }
; 2644 :             if (xmlCheckLanguageID(value) == 1) {

	push	esi
	call	_xmlCheckLanguageID
	add	esp, 4
	cmp	eax, 1
	jne	$return1$683

; 2645 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2646 :                     v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);

	push	17					; 00000011H

; 2647 :                     if (v != NULL) {
; 2648 :                         v->value.str = xmlStrdup(value);
; 2649 :                         *val = v;
; 2650 :                     } else {

	jmp	$LN673@xmlSchemaV
$LN258@xmlSchemaV:

; 2651 :                         goto error;
; 2652 :                     }
; 2653 :                 }
; 2654 :                 goto return0;
; 2655 :             }
; 2656 :             goto return1;
; 2657 :         case XML_SCHEMAS_NMTOKEN:
; 2658 :             if (xmlValidateNMToken(value, 1) == 0) {

	push	1
	push	esi
	call	_xmlValidateNMToken
	add	esp, 8
	test	eax, eax
	jne	$return1$683

; 2659 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2660 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);

	push	18					; 00000012H

; 2661 :                     if (v != NULL) {
; 2662 :                         v->value.str = xmlStrdup(value);
; 2663 :                         *val = v;
; 2664 :                     } else {

	jmp	$LN673@xmlSchemaV
$LN263@xmlSchemaV:

; 2665 :                         goto error;
; 2666 :                     }
; 2667 :                 }
; 2668 :                 goto return0;
; 2669 :             }
; 2670 :             goto return1;
; 2671 :         case XML_SCHEMAS_NMTOKENS:
; 2672 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,

	push	DWORD PTR _node$[ebp]
	push	edx
	push	esi
	push	DWORD PTR _xmlSchemaTypeNmtokenDef
	call	_xmlSchemaValAtomicListNode

; 2673 :                                              value, val, node);
; 2674 :             if (ret > 0)

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	test	eax, eax
	setle	bl

; 2675 :                 ret = 0;
; 2676 :             else
; 2677 :                 ret = 1;
; 2678 :             goto done;

	jmp	$done$680
$LN266@xmlSchemaV:

; 2679 :         case XML_SCHEMAS_NAME:
; 2680 :             ret = xmlValidateName(value, 1);

	push	1
	push	esi
	call	_xmlValidateName
	mov	ebx, eax
	add	esp, 8

; 2681 :             if ((ret == 0) && (val != NULL) && (value != NULL)) {

	test	ebx, ebx
	jne	$done$680
	cmp	DWORD PTR _val$[ebp], eax
	je	$done$680
	test	esi, esi
	je	$done$680

; 2682 : 		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);

	push	20					; 00000014H
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2683 : 		if (v != NULL) {

	test	edi, edi
	je	$error$682
$LL40@xmlSchemaV:

; 2684 : 		     const xmlChar *start = value, *end;
; 2685 : 		     while (IS_BLANK_CH(*start)) start++;

	mov	cl, BYTE PTR [esi]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN270@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN271@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN270@xmlSchemaV
$LN271@xmlSchemaV:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN41@xmlSchemaV
$LN270@xmlSchemaV:
	inc	esi
	jmp	SHORT $LL40@xmlSchemaV
$LN41@xmlSchemaV:

; 2686 : 		     end = start;

	mov	eax, esi

; 2687 : 		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;

	test	cl, cl
	je	SHORT $LN644@xmlSchemaV
	npad	1
$LL42@xmlSchemaV:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN644@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN272@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN644@xmlSchemaV
$LN272@xmlSchemaV:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN644@xmlSchemaV
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL42@xmlSchemaV
$LN644@xmlSchemaV:

; 2688 : 		     v->value.str = xmlStrndup(start, end - start);

	sub	eax, esi
	push	eax
	push	esi
	call	_xmlStrndup
	mov	DWORD PTR [edi+8], eax
	add	esp, 8

; 2689 : 		    *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], edi

; 2690 : 		} else {

	jmp	$done$680
$LN273@xmlSchemaV:

; 2691 : 		    goto error;
; 2692 : 		}
; 2693 :             }
; 2694 :             goto done;
; 2695 :         case XML_SCHEMAS_QNAME:{
; 2696 :                 const xmlChar *uri = NULL;
; 2697 :                 xmlChar *local = NULL;
; 2698 : 
; 2699 :                 ret = xmlValidateQName(value, 1);

	push	1
	push	esi
	mov	DWORD PTR _uri$1$[ebp], ebx
	xor	edi, edi
	call	_xmlValidateQName
	mov	ebx, eax
	add	esp, 8

; 2700 : 		if (ret != 0)

	test	ebx, ebx
	jne	$done$680

; 2701 : 		    goto done;
; 2702 :                 if (node != NULL) {

	cmp	DWORD PTR _node$[ebp], edi
	je	SHORT $LN279@xmlSchemaV

; 2703 :                     xmlChar *prefix;
; 2704 : 		    xmlNsPtr ns;
; 2705 : 
; 2706 :                     local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$19[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName2

; 2707 : 		    ns = xmlSearchNs(node->doc, node, prefix);

	push	DWORD PTR _prefix$19[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlSearchNs
	add	esp, 20					; 00000014H

; 2708 : 		    if ((ns == NULL) && (prefix != NULL)) {

	test	eax, eax
	jne	SHORT $LN622@xmlSchemaV
	mov	eax, DWORD PTR _prefix$19[ebp]
	test	eax, eax
	je	SHORT $LN279@xmlSchemaV

; 2709 : 			xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2710 : 			if (local != NULL)

	test	edi, edi
	je	$return1$683

; 2711 : 			    xmlFree(local);

	push	edi
	call	DWORD PTR _xmlFree

; 2712 : 			goto return1;

	jmp	$LN675@xmlSchemaV
$LN622@xmlSchemaV:

; 2713 : 		    }
; 2714 : 		    if (ns != NULL)
; 2715 : 			uri = ns->href;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _uri$1$[ebp], eax

; 2716 :                     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$19[ebp]
	test	eax, eax
	je	SHORT $LN279@xmlSchemaV

; 2717 :                         xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN279@xmlSchemaV:

; 2718 :                 }
; 2719 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN280@xmlSchemaV

; 2720 :                     v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);

	push	21					; 00000015H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$14$[ebp], eax

; 2721 :                     if (v == NULL) {

	test	eax, eax
	jne	SHORT $LN282@xmlSchemaV

; 2722 : 			if (local != NULL)

	test	edi, edi
	je	SHORT $error$682

; 2723 : 			    xmlFree(local);

	push	edi
$LN677@xmlSchemaV:

; 3349 :   error:
; 3350 :     if (norm != NULL)

	call	DWORD PTR _xmlFree
$LN665@xmlSchemaV:
	add	esp, 4
$error$682:
	mov	eax, DWORD PTR _norm$1$[ebp]
	test	eax, eax
	je	SHORT $LN501@xmlSchemaV

; 3351 :         xmlFree(norm);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN501@xmlSchemaV:

; 3352 :     return (-1);

	pop	esi
	pop	edi
	or	eax, -1
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN282@xmlSchemaV:

; 2724 : 			goto error;
; 2725 : 		    }
; 2726 : 		    if (local != NULL)

	test	edi, edi
	jne	SHORT $LN285@xmlSchemaV

; 2727 : 			v->value.qname.name = local;
; 2728 : 		    else
; 2729 : 			v->value.qname.name = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR _v$14$[ebp]
$LN285@xmlSchemaV:

; 2730 : 		    if (uri != NULL)

	mov	DWORD PTR [eax+8], edi
	mov	ecx, DWORD PTR _uri$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN286@xmlSchemaV

; 2731 : 			v->value.qname.uri = xmlStrdup(uri);

	push	ecx
	call	_xmlStrdup
	mov	ecx, DWORD PTR _v$14$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
$LN286@xmlSchemaV:

; 2732 : 		    *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], eax

; 2733 :                 } else

	jmp	$done$680
$LN280@xmlSchemaV:

; 2734 : 		    if (local != NULL)

	test	edi, edi
	je	$done$680

; 2735 : 			xmlFree(local);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2736 :                 goto done;

	jmp	$done$680
$LN288@xmlSchemaV:

; 2737 :             }
; 2738 :         case XML_SCHEMAS_NCNAME:
; 2739 :             ret = xmlValidateNCName(value, 1);

	push	1
	push	esi
	call	_xmlValidateNCName
	mov	ebx, eax
	add	esp, 8

; 2740 :             if ((ret == 0) && (val != NULL)) {

	test	ebx, ebx
	jne	$done$680
	cmp	DWORD PTR _val$[ebp], eax
	je	$done$680

; 2741 :                 v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);

	push	22					; 00000016H
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2742 :                 if (v != NULL) {

	test	edi, edi
	je	$error$682

; 2743 :                     v->value.str = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	DWORD PTR [edi+8], eax
	add	esp, 4

; 2744 :                     *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], edi

; 2745 :                 } else {

	jmp	$done$680
$LN292@xmlSchemaV:

; 2746 :                     goto error;
; 2747 :                 }
; 2748 :             }
; 2749 :             goto done;
; 2750 :         case XML_SCHEMAS_ID:
; 2751 :             ret = xmlValidateNCName(value, 1);

	push	1
	push	esi
	call	_xmlValidateNCName
	mov	ebx, eax
	add	esp, 8

; 2752 :             if ((ret == 0) && (val != NULL)) {

	test	ebx, ebx
	jne	$done$680
	cmp	DWORD PTR _val$[ebp], eax
	je	SHORT $LN623@xmlSchemaV

; 2753 :                 v = xmlSchemaNewValue(XML_SCHEMAS_ID);

	push	23					; 00000017H
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2754 :                 if (v != NULL) {

	test	edi, edi
	je	$error$682

; 2755 :                     v->value.str = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	DWORD PTR [edi+8], eax
	add	esp, 4

; 2756 :                     *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], edi
$LN623@xmlSchemaV:

; 2757 :                 } else {
; 2758 :                     goto error;
; 2759 :                 }
; 2760 :             }
; 2761 :             if ((ret == 0) && (node != NULL) &&

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$done$680
	cmp	DWORD PTR [edi+4], 2
	jne	$done$680

; 2762 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2763 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2764 : 
; 2765 :                 /*
; 2766 :                  * NOTE: the IDness might have already be declared in the DTD
; 2767 :                  */
; 2768 :                 if (attr->atype != XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [edi+40], 2
	je	$done$680

; 2769 :                     xmlIDPtr res;
; 2770 :                     xmlChar *strip;
; 2771 : 
; 2772 :                     strip = xmlSchemaStrip(value);

	push	esi
	call	_xmlSchemaStrip
	mov	ecx, DWORD PTR [edi+32]
	add	esp, 4
	mov	DWORD PTR _strip$1$[ebp], eax

; 2773 :                     if (strip != NULL) {

	push	edi
	test	eax, eax
	je	SHORT $LN298@xmlSchemaV

; 2774 :                         res = xmlAddID(NULL, node->doc, strip, attr);

	push	eax
	push	ecx
	push	0
	call	_xmlAddID

; 2775 :                         xmlFree(strip);

	push	DWORD PTR _strip$1$[ebp]
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2776 :                     } else

	jmp	SHORT $LN299@xmlSchemaV
$LN298@xmlSchemaV:

; 2777 :                         res = xmlAddID(NULL, node->doc, value, attr);

	push	esi
	push	ecx
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
	mov	esi, eax
$LN299@xmlSchemaV:

; 2778 :                     if (res == NULL) {

	test	esi, esi
	jne	SHORT $LN300@xmlSchemaV

; 2779 :                         ret = 2;

	lea	ebx, DWORD PTR [esi+2]

; 2780 :                     } else {

	jmp	$done$680
$LN300@xmlSchemaV:

; 2781 :                         attr->atype = XML_ATTRIBUTE_ID;

	mov	DWORD PTR [edi+40], 2

; 2782 :                     }
; 2783 :                 }
; 2784 :             }
; 2785 :             goto done;

	jmp	$done$680
$LN302@xmlSchemaV:

; 2786 :         case XML_SCHEMAS_IDREF:
; 2787 :             ret = xmlValidateNCName(value, 1);

	push	1
	push	esi
	call	_xmlValidateNCName
	mov	ebx, eax
	add	esp, 8

; 2788 :             if ((ret == 0) && (val != NULL)) {

	test	ebx, ebx
	jne	$done$680
	cmp	DWORD PTR _val$[ebp], eax
	je	SHORT $LN624@xmlSchemaV

; 2789 : 		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);

	push	24					; 00000018H
	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4

; 2790 : 		if (v == NULL)

	test	edi, edi
	je	$error$682

; 2791 : 		    goto error;
; 2792 : 		v->value.str = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	DWORD PTR [edi+8], eax
	add	esp, 4

; 2793 : 		*val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], edi
$LN624@xmlSchemaV:

; 2794 :             }
; 2795 :             if ((ret == 0) && (node != NULL) &&

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$done$680
	cmp	DWORD PTR [edi+4], 2
	jne	$done$680

; 2796 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2797 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2798 :                 xmlChar *strip;
; 2799 : 
; 2800 :                 strip = xmlSchemaStrip(value);

	push	esi
	call	_xmlSchemaStrip
	mov	ecx, DWORD PTR [edi+32]
	add	esp, 4
	mov	DWORD PTR _strip$1$[ebp], eax

; 2801 :                 if (strip != NULL) {

	push	edi
	test	eax, eax
	je	SHORT $LN306@xmlSchemaV

; 2802 :                     xmlAddRef(NULL, node->doc, strip, attr);

	push	eax
	push	ecx
	push	0
	call	_xmlAddRef

; 2803 :                     xmlFree(strip);

	push	DWORD PTR _strip$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;

	mov	DWORD PTR [edi+40], 3

; 2807 :             }
; 2808 :             goto done;

	jmp	$done$680
$LN306@xmlSchemaV:

; 2804 :                 } else
; 2805 :                     xmlAddRef(NULL, node->doc, value, attr);

	push	esi
	push	ecx
	push	0
	call	_xmlAddRef
	add	esp, 16					; 00000010H

; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;

	mov	DWORD PTR [edi+40], 3

; 2807 :             }
; 2808 :             goto done;

	jmp	$done$680
$LN308@xmlSchemaV:

; 2809 :         case XML_SCHEMAS_IDREFS:
; 2810 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,

	mov	edi, DWORD PTR _node$[ebp]
	push	edi
	push	edx
	push	esi
	push	DWORD PTR _xmlSchemaTypeIdrefDef
	call	_xmlSchemaValAtomicListNode
	add	esp, 16					; 00000010H

; 2811 :                                              value, val, node);
; 2812 :             if (ret < 0)

	test	eax, eax
	jns	SHORT $LN309@xmlSchemaV

; 2813 :                 ret = 2;

	mov	ebx, 2
	jmp	$done$680
$LN309@xmlSchemaV:

; 2814 :             else
; 2815 :                 ret = 0;

	xor	ebx, ebx

; 2816 :             if ((ret == 0) && (node != NULL) &&

	test	edi, edi
	je	$done$680
	cmp	DWORD PTR [edi+4], 2
	jne	$done$680

; 2817 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2818 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2819 : 
; 2820 :                 attr->atype = XML_ATTRIBUTE_IDREFS;

	mov	DWORD PTR [edi+40], 4

; 2821 :             }
; 2822 :             goto done;

	jmp	$done$680
$LN312@xmlSchemaV:

; 2823 :         case XML_SCHEMAS_ENTITY:{
; 2824 :                 xmlChar *strip;
; 2825 : 
; 2826 :                 ret = xmlValidateNCName(value, 1);

	push	1
	push	esi
	call	_xmlValidateNCName

; 2827 :                 if ((node == NULL) || (node->doc == NULL))

	mov	edi, DWORD PTR _node$[ebp]
	add	esp, 8
	mov	ebx, eax
	test	edi, edi
	je	$LN588@xmlSchemaV
	cmp	DWORD PTR [edi+32], 0
	je	$LN588@xmlSchemaV

; 2828 :                     ret = 3;
; 2829 :                 if (ret == 0) {

	test	ebx, ebx
	jne	$done$680

; 2830 :                     xmlEntityPtr ent;
; 2831 : 
; 2832 :                     strip = xmlSchemaStrip(value);

	push	esi
	call	_xmlSchemaStrip
	mov	ecx, DWORD PTR [edi+32]
	add	esp, 4
	mov	DWORD PTR _strip$1$[ebp], eax

; 2833 :                     if (strip != NULL) {

	test	eax, eax
	je	SHORT $LN316@xmlSchemaV

; 2834 :                         ent = xmlGetDocEntity(node->doc, strip);

	push	eax
	push	ecx
	call	_xmlGetDocEntity

; 2835 :                         xmlFree(strip);

	push	DWORD PTR _strip$1$[ebp]
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 2836 :                     } else {

	jmp	SHORT $LN317@xmlSchemaV
$LN316@xmlSchemaV:

; 2837 :                         ent = xmlGetDocEntity(node->doc, value);

	push	esi
	push	ecx
	call	_xmlGetDocEntity
	add	esp, 8
	mov	esi, eax
$LN317@xmlSchemaV:

; 2838 :                     }
; 2839 :                     if ((ent == NULL) ||

	test	esi, esi
	je	SHORT $LN319@xmlSchemaV
	cmp	DWORD PTR [esi+48], 3
	jne	SHORT $LN319@xmlSchemaV

; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN627@xmlSchemaV

; 2845 :                     TODO;

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	2845					; 00000b1dH
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	mov	eax, DWORD PTR [eax]
	push	esi
	call	eax
	add	esp, 16					; 00000010H
$LN627@xmlSchemaV:

; 2846 :                 }
; 2847 :                 if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR [edi+4], 2
	jne	$done$680

; 2848 :                     (node->type == XML_ATTRIBUTE_NODE)) {
; 2849 :                     xmlAttrPtr attr = (xmlAttrPtr) node;
; 2850 : 
; 2851 :                     attr->atype = XML_ATTRIBUTE_ENTITY;

	mov	DWORD PTR [edi+40], 5

; 2852 :                 }
; 2853 :                 goto done;

	jmp	$done$680
$LN319@xmlSchemaV:

; 2840 :                         (ent->etype !=
; 2841 :                          XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
; 2842 :                         ret = 4;

	mov	ebx, 4

; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {

	jmp	$done$680
$LN588@xmlSchemaV:

; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)

	mov	ebx, 3
	jmp	$done$680
$LN322@xmlSchemaV:

; 2854 :             }
; 2855 :         case XML_SCHEMAS_ENTITIES:
; 2856 :             if ((node == NULL) || (node->doc == NULL))

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $return3$684
	cmp	DWORD PTR [edi+32], ebx
	je	SHORT $return3$684

; 2857 :                 goto return3;
; 2858 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,

	push	edi
	push	edx
	push	esi
	push	DWORD PTR _xmlSchemaTypeEntityDef
	call	_xmlSchemaValAtomicListNode
	add	esp, 16					; 00000010H

; 2859 :                                              value, val, node);
; 2860 :             if (ret <= 0)

	test	eax, eax
	jg	SHORT $LN325@xmlSchemaV
$LN340@xmlSchemaV:

; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)

	mov	ebx, 1
	jmp	$done$680
$LN325@xmlSchemaV:

; 2861 :                 ret = 1;
; 2862 :             else
; 2863 :                 ret = 0;

	xor	ebx, ebx

; 2864 :             if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR [edi+4], 2
	jne	$done$680

; 2865 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2866 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2867 : 
; 2868 :                 attr->atype = XML_ATTRIBUTE_ENTITIES;

	mov	DWORD PTR [edi+40], 6

; 2869 :             }
; 2870 :             goto done;

	jmp	$done$680
$return3$684:

; 3337 :   return3:
; 3338 :     if (norm != NULL)

	mov	eax, DWORD PTR _norm$1$[ebp]
	test	eax, eax
	je	SHORT $LN498@xmlSchemaV

; 3339 :         xmlFree(norm);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN498@xmlSchemaV:

; 3340 :     return (3);

	pop	esi
	pop	edi
	mov	eax, 3
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN328@xmlSchemaV:

; 2871 :         case XML_SCHEMAS_NOTATION:{
; 2872 :                 xmlChar *uri = NULL;

	xor	eax, eax

; 2873 :                 xmlChar *local = NULL;

	xor	edi, edi

; 2874 : 
; 2875 :                 ret = xmlValidateQName(value, 1);

	push	1
	push	esi
	mov	DWORD PTR _uri$1$[ebp], eax
	call	_xmlValidateQName
	mov	ebx, eax
	add	esp, 8

; 2876 :                 if ((ret == 0) && (node != NULL)) {

	test	ebx, ebx
	jne	SHORT $LN336@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], edi
	je	$LN588@xmlSchemaV

; 2877 :                     xmlChar *prefix;
; 2878 : 
; 2879 :                     local = xmlSplitQName2(value, &prefix);

	lea	eax, DWORD PTR _prefix$12[ebp]
	push	eax
	push	esi
	call	_xmlSplitQName2
	mov	edi, eax
	add	esp, 8

; 2880 :                     if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$12[ebp]
	test	eax, eax
	je	SHORT $LN649@xmlSchemaV

; 2881 :                         xmlNsPtr ns;
; 2882 : 
; 2883 :                         ns = xmlSearchNs(node->doc, node, prefix);

	push	eax
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlSearchNs

; 2884 :                         if (ns == NULL)

	mov	ecx, DWORD PTR _val$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN331@xmlSchemaV

; 2885 :                             ret = 1;

	lea	ebx, DWORD PTR [eax+1]
	jmp	SHORT $LN634@xmlSchemaV
$LN331@xmlSchemaV:

; 2886 :                         else if (val != NULL)

	test	ecx, ecx
	je	SHORT $LN634@xmlSchemaV

; 2887 :                             uri = xmlStrdup(ns->href);

	push	DWORD PTR [eax+8]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], eax
$LN649@xmlSchemaV:

; 2888 :                     }
; 2889 :                     if ((local != NULL) && ((val == NULL) || (ret != 0)))

	mov	ecx, DWORD PTR _val$[ebp]
$LN634@xmlSchemaV:
	test	edi, edi
	je	SHORT $LN334@xmlSchemaV
	test	ecx, ecx
	je	SHORT $LN335@xmlSchemaV
	test	ebx, ebx
	je	SHORT $LN334@xmlSchemaV
$LN335@xmlSchemaV:

; 2890 :                         xmlFree(local);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN334@xmlSchemaV:

; 2891 :                     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$12[ebp]
	test	eax, eax
	je	SHORT $LN336@xmlSchemaV

; 2892 :                         xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN336@xmlSchemaV:

; 2893 :                 }
; 2894 :                 if ((node == NULL) || (node->doc == NULL))

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	$LN588@xmlSchemaV
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	$LN588@xmlSchemaV

; 2895 :                     ret = 3;
; 2896 :                 if (ret == 0) {

	test	ebx, ebx
	jne	$done$680

; 2897 :                     ret = xmlValidateNotationUse(NULL, node->doc, value);

	push	esi
	push	eax
	push	ebx
	call	_xmlValidateNotationUse
	add	esp, 12					; 0000000cH

; 2898 :                     if (ret == 1)

	cmp	eax, 1
	jne	$LN340@xmlSchemaV

; 2899 :                         ret = 0;
; 2900 :                     else
; 2901 :                         ret = 1;
; 2902 :                 }
; 2903 :                 if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _val$[ebp], ebx
	je	$done$680

; 2904 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);

	push	28					; 0000001cH
	call	_xmlSchemaNewValue
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _v$18$[ebp], ecx

; 2905 :                     if (v != NULL) {

	test	ecx, ecx
	je	SHORT $LN343@xmlSchemaV

; 2906 :                         if (local != NULL)

	test	edi, edi
	jne	SHORT $LN346@xmlSchemaV

; 2907 :                             v->value.qname.name = local;
; 2908 :                         else
; 2909 :                             v->value.qname.name = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	ecx, DWORD PTR _v$18$[ebp]
	add	esp, 4
	mov	edi, eax
$LN346@xmlSchemaV:

; 2910 :                         if (uri != NULL)

	mov	DWORD PTR [ecx+8], edi
	mov	eax, DWORD PTR _uri$1$[ebp]
	test	eax, eax
	je	SHORT $LN347@xmlSchemaV

; 2911 :                             v->value.qname.uri = uri;

	mov	DWORD PTR [ecx+12], eax
$LN347@xmlSchemaV:

; 2912 : 
; 2913 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 2914 :                     } else {

	jmp	$done$680
$LN343@xmlSchemaV:

; 2915 :                         if (local != NULL)

	test	edi, edi
	je	SHORT $LN348@xmlSchemaV

; 2916 :                             xmlFree(local);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN348@xmlSchemaV:

; 2917 :                         if (uri != NULL)

	mov	eax, DWORD PTR _uri$1$[ebp]
	test	eax, eax
	je	$error$682

; 2918 :                             xmlFree(uri);

	push	eax

; 2919 :                         goto error;

	jmp	$LN677@xmlSchemaV
$LN350@xmlSchemaV:

; 2920 :                     }
; 2921 :                 }
; 2922 :                 goto done;
; 2923 :             }
; 2924 :         case XML_SCHEMAS_ANYURI:{
; 2925 :                 if (*value != 0) {

	cmp	BYTE PTR [esi], bl
	je	$LN351@xmlSchemaV

; 2926 : 		    xmlURIPtr uri;
; 2927 : 		    xmlChar *tmpval, *cur;
; 2928 : 		    if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], ebx
	je	SHORT $LN353@xmlSchemaV

; 2929 : 			norm = xmlSchemaCollapseString(value);

	push	esi
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$1$[ebp], eax

; 2930 : 			if (norm != NULL)

	test	eax, eax
	cmovne	esi, eax
$LN353@xmlSchemaV:

; 2931 : 			    value = norm;
; 2932 : 		    }
; 2933 : 		    tmpval = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	ebx, eax
	add	esp, 4

; 2934 : 		    for (cur = tmpval; *cur; ++cur) {

	mov	edx, ebx
	mov	cl, BYTE PTR [ebx]
	test	cl, cl
	je	SHORT $LN45@xmlSchemaV
	npad	1
$LL46@xmlSchemaV:

; 2935 : 			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
; 2936 : 			    *cur == '<' || *cur == '>' || *cur == '"' ||
; 2937 : 			    *cur == '{' || *cur == '}' || *cur == '|' ||
; 2938 : 			    *cur == '\\' || *cur == '^' || *cur == '`' ||

	lea	eax, DWORD PTR [ecx-32]
	cmp	al, 94					; 0000005eH
	ja	SHORT $LN355@xmlSchemaV
	cmp	cl, 32					; 00000020H
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 60					; 0000003cH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 62					; 0000003eH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 34					; 00000022H
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 123					; 0000007bH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 125					; 0000007dH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 124					; 0000007cH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 94					; 0000005eH
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 96					; 00000060H
	je	SHORT $LN355@xmlSchemaV
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN44@xmlSchemaV
$LN355@xmlSchemaV:

; 2939 : 			    *cur == '\'')
; 2940 : 			    *cur = '_';

	mov	BYTE PTR [edx], 95			; 0000005fH
$LN44@xmlSchemaV:

; 2934 : 		    for (cur = tmpval; *cur; ++cur) {

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	test	cl, cl
	jne	SHORT $LL46@xmlSchemaV
$LN45@xmlSchemaV:

; 2941 : 		    }
; 2942 :                     uri = xmlParseURI((const char *) tmpval);

	push	ebx
	call	_xmlParseURI

; 2943 : 		    xmlFree(tmpval);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 8

; 2944 :                     if (uri == NULL)

	test	edi, edi
	je	$return1$683

; 2945 :                         goto return1;
; 2946 :                     xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN351@xmlSchemaV:

; 2947 :                 }
; 2948 : 
; 2949 :                 if (val != NULL) {

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$return0$681

; 2950 :                     v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);

	push	29					; 0000001dH
$LN673@xmlSchemaV:

; 3345 :   return0:
; 3346 :     if (norm != NULL)

	call	_xmlSchemaNewValue
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	$error$682
	push	esi
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+8], eax
$LN674@xmlSchemaV:
	mov	DWORD PTR [ebx], edi
	jmp	$return0$681
$LN359@xmlSchemaV:

; 2951 :                     if (v == NULL)
; 2952 :                         goto error;
; 2953 :                     v->value.str = xmlStrdup(value);
; 2954 :                     *val = v;
; 2955 :                 }
; 2956 :                 goto return0;
; 2957 :             }
; 2958 :         case XML_SCHEMAS_HEXBINARY:{
; 2959 :                 const xmlChar *cur = value, *start;
; 2960 :                 xmlChar *base;
; 2961 :                 int total, i = 0;

	xor	ebx, ebx

; 2962 : 
; 2963 :                 if (cur == NULL)

	test	esi, esi
	je	$return1$683

; 2964 :                     goto return1;
; 2965 : 
; 2966 : 		if (normOnTheFly)

	mov	edx, DWORD PTR _normOnTheFly$[ebp]
	test	edx, edx
	je	SHORT $LN645@xmlSchemaV
	npad	1
$LL47@xmlSchemaV:

; 2967 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN362@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN363@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN362@xmlSchemaV
$LN363@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN645@xmlSchemaV
$LN362@xmlSchemaV:
	inc	esi
	jmp	SHORT $LL47@xmlSchemaV
$LN645@xmlSchemaV:

; 2968 : 
; 2969 : 		start = cur;

	mov	edi, esi
$LL49@xmlSchemaV:

; 2970 :                 while (((*cur >= '0') && (*cur <= '9')) ||
; 2971 :                        ((*cur >= 'A') && (*cur <= 'F')) ||

	mov	cl, BYTE PTR [esi]
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN365@xmlSchemaV
	cmp	cl, 57					; 00000039H
	jbe	SHORT $LN364@xmlSchemaV
$LN365@xmlSchemaV:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN366@xmlSchemaV
	cmp	cl, 70					; 00000046H
	jbe	SHORT $LN364@xmlSchemaV
$LN366@xmlSchemaV:
	lea	eax, DWORD PTR [ecx-97]
	cmp	al, 5
	ja	SHORT $LN50@xmlSchemaV
$LN364@xmlSchemaV:

; 2972 :                        ((*cur >= 'a') && (*cur <= 'f'))) {
; 2973 :                     i++;

	inc	ebx

; 2974 :                     cur++;

	inc	esi

; 2975 :                 }

	jmp	SHORT $LL49@xmlSchemaV
$LN50@xmlSchemaV:

; 2976 : 		if (normOnTheFly)

	test	edx, edx
	je	SHORT $LN646@xmlSchemaV
	npad	4
$LL51@xmlSchemaV:

; 2977 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	cmp	cl, 32					; 00000020H
	je	SHORT $LN368@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN369@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN368@xmlSchemaV
$LN369@xmlSchemaV:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN646@xmlSchemaV
$LN368@xmlSchemaV:
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL51@xmlSchemaV
$LN646@xmlSchemaV:

; 2978 : 
; 2979 :                 if (*cur != 0)

	test	cl, cl
	jne	$return1$683

; 2980 :                     goto return1;
; 2981 :                 if ((i % 2) != 0)

	test	bl, 1
	jne	$return1$683

; 2982 :                     goto return1;
; 2983 : 
; 2984 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$return0$681

; 2985 : 
; 2986 :                     v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);

	push	43					; 0000002bH
	call	_xmlSchemaNewValue
	mov	esi, eax
	add	esp, 4

; 2987 :                     if (v == NULL)

	test	esi, esi
	je	$error$682

; 2988 :                         goto error;
; 2989 : 		    /*
; 2990 : 		    * Copy only the normalized piece.
; 2991 : 		    * CRITICAL TODO: Check this.
; 2992 : 		    */
; 2993 :                     cur = xmlStrndup(start, i);

	push	ebx
	push	edi
	call	_xmlStrndup
	mov	edi, eax
	add	esp, 8

; 2994 :                     if (cur == NULL) {

	test	edi, edi
	jne	SHORT $LN374@xmlSchemaV

; 2995 : 		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");

	push	OFFSET ??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaTypeErrMemory

; 2996 :                         xmlFree(v);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 2997 :                         goto return1;

	jmp	$return1$683
$LN374@xmlSchemaV:

; 2998 :                     }
; 2999 : 
; 3000 :                     total = i / 2;      /* number of octets */

	mov	eax, ebx

; 3001 : 
; 3002 :                     base = (xmlChar *) cur;

	mov	ecx, edi
	cdq
	sub	eax, edx
	mov	edx, eax
	sar	edx, 1

; 3003 :                     while (i-- > 0) {

	test	ebx, ebx
	jle	SHORT $LN549@xmlSchemaV
$LL554@xmlSchemaV:

; 3004 :                         if (*base >= 'a')

	mov	al, BYTE PTR [ecx]
	dec	ebx
	cmp	al, 97					; 00000061H
	jb	SHORT $LN630@xmlSchemaV

; 3005 :                             *base = *base - ('a' - 'A');

	sub	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al
$LN630@xmlSchemaV:

; 3006 :                         base++;

	inc	ecx
	test	ebx, ebx
	jg	SHORT $LL554@xmlSchemaV
$LN549@xmlSchemaV:

; 3007 :                     }
; 3008 : 
; 3009 :                     v->value.hex.str = (xmlChar *) cur;
; 3010 :                     v->value.hex.total = total;
; 3011 :                     *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edx
	mov	DWORD PTR [eax], esi

; 3012 :                 }
; 3013 :                 goto return0;

	jmp	$return0$681
$LN376@xmlSchemaV:

; 3014 :             }
; 3015 :         case XML_SCHEMAS_BASE64BINARY:{
; 3016 :                 /* ISSUE:
; 3017 :                  *
; 3018 :                  * Ignore all stray characters? (yes, currently)
; 3019 :                  * Worry about long lines? (no, currently)
; 3020 :                  *
; 3021 :                  * rfc2045.txt:
; 3022 :                  *
; 3023 :                  * "The encoded output stream must be represented in lines of
; 3024 :                  * no more than 76 characters each.  All line breaks or other
; 3025 :                  * characters not found in Table 1 must be ignored by decoding
; 3026 :                  * software.  In base64 data, characters other than those in
; 3027 :                  * Table 1, line breaks, and other white space probably
; 3028 :                  * indicate a transmission error, about which a warning
; 3029 :                  * message or even a message rejection might be appropriate
; 3030 :                  * under some circumstances." */
; 3031 :                 const xmlChar *cur = value;
; 3032 :                 xmlChar *base;
; 3033 :                 int total, i = 0, pad = 0;

	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _pad$1$[ebp], eax
	mov	edi, esi

; 3034 : 
; 3035 :                 if (cur == NULL)

	test	esi, esi
	je	$return1$683

; 3036 :                     goto return1;
; 3037 : 
; 3038 :                 for (; *cur; ++cur) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN631@xmlSchemaV

; 3005 :                             *base = *base - ('a' - 'A');

	mov	BYTE PTR $T17[ebp], al
	npad	2
$LL57@xmlSchemaV:

; 3039 :                     int decc;
; 3040 : 
; 3041 :                     decc = _xmlSchemaBase64Decode(*cur);

	push	DWORD PTR $T17[ebp]
	call	__xmlSchemaBase64Decode
	add	esp, 4

; 3042 :                     if (decc < 0) ;

	test	eax, eax
	js	SHORT $LN55@xmlSchemaV

; 3043 :                     else if (decc < 64)

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN631@xmlSchemaV

; 3044 :                         i++;

	inc	ebx
$LN55@xmlSchemaV:

; 3036 :                     goto return1;
; 3037 : 
; 3038 :                 for (; *cur; ++cur) {

	mov	al, BYTE PTR [edi+1]
	inc	edi
	mov	BYTE PTR $T17[ebp], al
	test	al, al
	jne	SHORT $LL57@xmlSchemaV

; 3045 :                     else
; 3046 :                         break;
; 3047 :                 }
; 3048 :                 for (; *cur; ++cur) {

	jmp	SHORT $LN59@xmlSchemaV
$LN631@xmlSchemaV:
	mov	al, BYTE PTR [edi]
	test	al, al
	je	SHORT $LN59@xmlSchemaV

; 3005 :                             *base = *base - ('a' - 'A');

	mov	BYTE PTR $T16[ebp], al
	npad	5
$LL60@xmlSchemaV:

; 3049 :                     int decc;
; 3050 : 
; 3051 :                     decc = _xmlSchemaBase64Decode(*cur);

	push	DWORD PTR $T16[ebp]
	call	__xmlSchemaBase64Decode
	add	esp, 4

; 3052 :                     if (decc < 0) ;

	test	eax, eax
	js	SHORT $LN384@xmlSchemaV

; 3053 :                     else if (decc < 64)

	cmp	eax, 64					; 00000040H
	jl	$return1$683
$LN384@xmlSchemaV:

; 3054 :                         goto return1;
; 3055 :                     if (decc == 64)

	cmp	eax, 64					; 00000040H
	jne	SHORT $LN58@xmlSchemaV

; 3056 :                         pad++;

	inc	DWORD PTR _pad$1$[ebp]
$LN58@xmlSchemaV:

; 3045 :                     else
; 3046 :                         break;
; 3047 :                 }
; 3048 :                 for (; *cur; ++cur) {

	mov	al, BYTE PTR [edi+1]
	inc	edi
	mov	BYTE PTR $T16[ebp], al
	test	al, al
	jne	SHORT $LL60@xmlSchemaV
$LN59@xmlSchemaV:

; 3057 :                 }
; 3058 : 
; 3059 :                 /* rfc2045.txt: "Special processing is performed if fewer than
; 3060 :                  * 24 bits are available at the end of the data being encoded.
; 3061 :                  * A full encoding quantum is always completed at the end of a
; 3062 :                  * body.  When fewer than 24 input bits are available in an
; 3063 :                  * input group, zero bits are added (on the right) to form an
; 3064 :                  * integral number of 6-bit groups.  Padding at the end of the
; 3065 :                  * data is performed using the "=" character.  Since all
; 3066 :                  * base64 input is an integral number of octets, only the
; 3067 :                  * following cases can arise: (1) the final quantum of
; 3068 :                  * encoding input is an integral multiple of 24 bits; here,
; 3069 :                  * the final unit of encoded output will be an integral
; 3070 :                  * multiple ofindent: Standard input:701: Warning:old style
; 3071 : 		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
; 3072 : 		 * with no "=" padding, (2) the final
; 3073 :                  * quantum of encoding input is exactly 8 bits; here, the
; 3074 :                  * final unit of encoded output will be two characters
; 3075 :                  * followed by two "=" padding characters, or (3) the final
; 3076 :                  * quantum of encoding input is exactly 16 bits; here, the
; 3077 :                  * final unit of encoded output will be three characters
; 3078 :                  * followed by one "=" padding character." */
; 3079 : 
; 3080 :                 total = 3 * (i / 4);

	mov	eax, ebx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _total$1$[ebp], eax

; 3081 :                 if (pad == 0) {

	mov	eax, DWORD PTR _pad$1$[ebp]
	test	eax, eax
	jne	SHORT $LN386@xmlSchemaV

; 3082 :                     if (i % 4 != 0)

	mov	eax, ebx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN653@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN653@xmlSchemaV:
	jne	$return1$683

; 3083 :                         goto return1;
; 3084 :                 } else if (pad == 1) {

	jmp	$LN395@xmlSchemaV
$LN386@xmlSchemaV:
	cmp	eax, 1
	jne	SHORT $LN389@xmlSchemaV

; 3085 :                     int decc;
; 3086 : 
; 3087 :                     if (i % 4 != 3)

	mov	eax, ebx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN654@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN654@xmlSchemaV:
	cmp	eax, 3
	jne	$return1$683
$LN663@xmlSchemaV:

; 3088 :                         goto return1;
; 3089 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3090 :                          (decc < 0) || (decc > 63);

	movzx	eax, BYTE PTR [edi]
	push	eax
	call	__xmlSchemaBase64Decode
	add	esp, 4
	test	eax, eax
	js	SHORT $LN392@xmlSchemaV
	cmp	eax, 63					; 0000003fH
	jle	SHORT $LN62@xmlSchemaV
$LN392@xmlSchemaV:

; 3091 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3092 :                         --cur;

	dec	edi
	jmp	SHORT $LN663@xmlSchemaV
$LN62@xmlSchemaV:

; 3093 :                     /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
; 3094 :                     /* 00111100 -> 0x3c */
; 3095 :                     if (decc & ~0x3c)

	test	eax, -61				; ffffffc3H
	jne	$return1$683

; 3096 :                         goto return1;
; 3097 :                     total += 2;

	add	DWORD PTR _total$1$[ebp], 2
	jmp	SHORT $LN395@xmlSchemaV
$LN389@xmlSchemaV:

; 3098 :                 } else if (pad == 2) {

	cmp	eax, 2
	jne	$return1$683

; 3099 :                     int decc;
; 3100 : 
; 3101 :                     if (i % 4 != 2)

	mov	eax, ebx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN655@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN655@xmlSchemaV:
	cmp	eax, 2
	jne	$return1$683
$LN664@xmlSchemaV:

; 3102 :                         goto return1;
; 3103 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3104 :                          (decc < 0) || (decc > 63);

	movzx	eax, BYTE PTR [edi]
	push	eax
	call	__xmlSchemaBase64Decode
	add	esp, 4
	test	eax, eax
	js	SHORT $LN397@xmlSchemaV
	cmp	eax, 63					; 0000003fH
	jle	SHORT $LN65@xmlSchemaV
$LN397@xmlSchemaV:

; 3105 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3106 :                         --cur;

	dec	edi
	jmp	SHORT $LN664@xmlSchemaV
$LN65@xmlSchemaV:

; 3107 :                     /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
; 3108 :                     /* 00110000 -> 0x30 */
; 3109 :                     if (decc & ~0x30)

	test	eax, -49				; ffffffcfH
	jne	$return1$683

; 3110 :                         goto return1;
; 3111 :                     total += 1;

	inc	DWORD PTR _total$1$[ebp]
$LN395@xmlSchemaV:

; 3112 :                 } else
; 3113 :                     goto return1;
; 3114 : 
; 3115 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$return0$681

; 3116 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);

	push	44					; 0000002cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$21$[ebp], eax

; 3117 :                     if (v == NULL)

	test	eax, eax
	je	$error$682

; 3118 :                         goto error;
; 3119 :                     base =

	mov	ecx, DWORD PTR _pad$1$[ebp]
	inc	ecx
	add	ecx, ebx
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 3120 :                         (xmlChar *) xmlMallocAtomic((i + pad + 1) *
; 3121 :                                                     sizeof(xmlChar));
; 3122 :                     if (base == NULL) {

	test	edi, edi
	jne	SHORT $LN401@xmlSchemaV

; 3123 : 		        xmlSchemaTypeErrMemory(node, "allocating base64 data");

	push	OFFSET ??_C@_0BH@PBMCLKED@allocating?5base64?5data@
	push	DWORD PTR _node$[ebp]
	call	_xmlSchemaTypeErrMemory

; 3124 :                         xmlFree(v);

	mov	ebx, DWORD PTR _v$21$[ebp]
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 3125 :                         goto return1;

	jmp	$return1$683
$LN401@xmlSchemaV:

; 3126 :                     }
; 3127 :                     v->value.base64.str = base;

	mov	ebx, DWORD PTR _v$21$[ebp]
	mov	DWORD PTR [ebx+8], edi

; 3128 :                     for (cur = value; *cur; ++cur)

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN68@xmlSchemaV

; 3005 :                             *base = *base - ('a' - 'A');

	mov	BYTE PTR $T10[ebp], al
	npad	4
$LL69@xmlSchemaV:

; 3129 :                         if (_xmlSchemaBase64Decode(*cur) >= 0) {

	push	DWORD PTR $T10[ebp]
	call	__xmlSchemaBase64Decode
	add	esp, 4
	test	eax, eax
	js	SHORT $LN67@xmlSchemaV

; 3130 :                             *base = *cur;

	mov	al, BYTE PTR [esi]
	mov	BYTE PTR [edi], al

; 3131 :                             ++base;

	inc	edi
$LN67@xmlSchemaV:

; 3128 :                     for (cur = value; *cur; ++cur)

	mov	al, BYTE PTR [esi+1]
	inc	esi
	mov	BYTE PTR $T10[ebp], al
	test	al, al
	jne	SHORT $LL69@xmlSchemaV
$LN68@xmlSchemaV:

; 3132 :                         }
; 3133 :                     *base = 0;
; 3134 :                     v->value.base64.total = total;

	mov	eax, DWORD PTR _total$1$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [ebx+12], eax

; 3135 :                     *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ebx

; 3136 :                 }
; 3137 :                 goto return0;

	jmp	$return0$681
$LN403@xmlSchemaV:

; 3138 :             }
; 3139 :         case XML_SCHEMAS_INTEGER:
; 3140 :         case XML_SCHEMAS_PINTEGER:
; 3141 :         case XML_SCHEMAS_NPINTEGER:
; 3142 :         case XML_SCHEMAS_NINTEGER:
; 3143 :         case XML_SCHEMAS_NNINTEGER:{
; 3144 :                 const xmlChar *cur = value;

	mov	DWORD PTR _cur$14[ebp], esi

; 3145 :                 unsigned long lo, mi, hi;
; 3146 :                 int sign = 0;

	mov	DWORD PTR _sign$1$[ebp], ebx
	test	esi, esi

; 3147 : 
; 3148 :                 if (cur == NULL)

	je	$return1$683

; 3149 :                     goto return1;
; 3150 : 		if (normOnTheFly)

	mov	edi, DWORD PTR _normOnTheFly$[ebp]
	mov	ecx, esi
	test	edi, edi
	je	SHORT $LN647@xmlSchemaV
$LN666@xmlSchemaV:

; 3151 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	mov	ecx, esi
	cmp	al, 32					; 00000020H
	je	SHORT $LN406@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN407@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN406@xmlSchemaV
$LN407@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN647@xmlSchemaV
$LN406@xmlSchemaV:
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR _cur$14[ebp], esi
	jmp	SHORT $LN666@xmlSchemaV
$LN647@xmlSchemaV:

; 3152 :                 if (*cur == '-') {

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN408@xmlSchemaV

; 3153 :                     sign = 1;

	mov	DWORD PTR _sign$1$[ebp], 1

; 3154 :                     cur++;

	jmp	SHORT $LN667@xmlSchemaV
$LN408@xmlSchemaV:

; 3155 :                 } else if (*cur == '+')

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN410@xmlSchemaV
$LN667@xmlSchemaV:

; 3156 :                     cur++;
; 3157 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _cur$14[ebp], eax
$LN410@xmlSchemaV:
	lea	eax, DWORD PTR _hi$9[ebp]
	push	eax
	lea	eax, DWORD PTR _mi$8[ebp]
	push	eax
	lea	eax, DWORD PTR _lo$6[ebp]
	push	eax
	lea	eax, DWORD PTR _cur$14[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$3$[ebp], eax

; 3158 :                 if (ret < 0)

	test	eax, eax
	js	$return1$683

; 3159 :                     goto return1;
; 3160 : 		if (normOnTheFly)

	mov	ecx, DWORD PTR _cur$14[ebp]
	test	edi, edi
	je	SHORT $LN73@xmlSchemaV
$LL72@xmlSchemaV:

; 3161 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN413@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN414@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN413@xmlSchemaV
$LN414@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN73@xmlSchemaV
$LN413@xmlSchemaV:
	inc	ecx
	jmp	SHORT $LL72@xmlSchemaV
$LN73@xmlSchemaV:

; 3162 :                 if (*cur != 0)

	cmp	BYTE PTR [ecx], bl
	jne	$return1$683

; 3163 :                     goto return1;
; 3164 :                 if (type->builtInType == XML_SCHEMAS_NPINTEGER) {

	mov	ecx, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _hi$9[ebp]
	mov	edi, DWORD PTR _mi$8[ebp]
	mov	ebx, DWORD PTR _lo$6[ebp]
	mov	eax, DWORD PTR [ecx+88]
	cmp	eax, 31					; 0000001fH
	jne	SHORT $LN416@xmlSchemaV

; 3165 :                     if ((sign == 0) &&

	cmp	DWORD PTR _sign$1$[ebp], 0
	jne	SHORT $LN429@xmlSchemaV
	test	esi, esi
	jne	$return1$683
	test	edi, edi
	jne	$return1$683
	test	ebx, ebx
	je	SHORT $LN429@xmlSchemaV

; 3166 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3167 :                         goto return1;

	jmp	$return1$683
$LN416@xmlSchemaV:

; 3168 :                 } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {

	cmp	eax, 34					; 00000022H
	jne	SHORT $LN420@xmlSchemaV

; 3169 :                     if (sign == 1)

	cmp	DWORD PTR _sign$1$[ebp], 1

; 3170 :                         goto return1;
; 3171 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3172 :                         goto return1;
; 3173 :                 } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {

	jmp	SHORT $LN668@xmlSchemaV
$LN420@xmlSchemaV:
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN424@xmlSchemaV

; 3174 :                     if (sign == 0)

	cmp	DWORD PTR _sign$1$[ebp], 0
$LN668@xmlSchemaV:

; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;
; 3182 :                 }
; 3183 :                 if (val != NULL) {

	je	$return1$683
	test	esi, esi
	jne	SHORT $LN429@xmlSchemaV
	test	edi, edi
	jne	SHORT $LN429@xmlSchemaV
	test	ebx, ebx
	je	$return1$683
	jmp	SHORT $LN429@xmlSchemaV
$LN424@xmlSchemaV:

; 3175 :                         goto return1;
; 3176 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3177 :                         goto return1;
; 3178 :                 } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {

	cmp	eax, 33					; 00000021H
	jne	SHORT $LN429@xmlSchemaV

; 3179 :                     if ((sign == 1) &&

	cmp	DWORD PTR _sign$1$[ebp], 1
	jne	SHORT $LN429@xmlSchemaV
	test	esi, esi
	jne	$return1$683
	test	edi, edi
	jne	$return1$683
	test	ebx, ebx
	jne	$return1$683
$LN429@xmlSchemaV:

; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;
; 3182 :                 }
; 3183 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$return0$681

; 3184 :                     v = xmlSchemaNewValue(type->builtInType);

	push	eax
	call	_xmlSchemaNewValue
	mov	ecx, eax
	add	esp, 4

; 3185 :                     if (v != NULL) {

	test	ecx, ecx
	je	$return0$681

; 3186 : 			if (ret == 0)

	mov	edx, DWORD PTR _ret$3$[ebp]
	mov	eax, 1
	test	edx, edx

; 3187 : 			    ret++;
; 3188 :                         v->value.decimal.lo = lo;

	mov	DWORD PTR [ecx+8], ebx

; 3189 :                         v->value.decimal.mi = mi;

	mov	DWORD PTR [ecx+12], edi
	cmove	edx, eax

; 3190 :                         v->value.decimal.hi = hi;

	mov	DWORD PTR [ecx+16], esi

; 3191 :                         v->value.decimal.sign = sign;

	mov	eax, DWORD PTR [ecx+24]
	and	eax, -2					; fffffffeH

; 3192 :                         v->value.decimal.frac = 0;

	or	eax, DWORD PTR _sign$1$[ebp]
	and	eax, -255				; ffffff01H
	mov	DWORD PTR [ecx+24], eax

; 3193 :                         v->value.decimal.total = ret;
; 3194 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	BYTE PTR [ecx+25], dl
	mov	DWORD PTR [eax], ecx

; 3195 :                     }
; 3196 :                 }
; 3197 :                 goto return0;

	jmp	$return0$681
$LN434@xmlSchemaV:

; 3198 :             }
; 3199 :         case XML_SCHEMAS_LONG:
; 3200 :         case XML_SCHEMAS_BYTE:
; 3201 :         case XML_SCHEMAS_SHORT:
; 3202 :         case XML_SCHEMAS_INT:{
; 3203 :                 const xmlChar *cur = value;
; 3204 :                 unsigned long lo, mi, hi;
; 3205 :                 int sign = 0;

	xor	edi, edi
	mov	DWORD PTR _cur$13[ebp], esi
	test	esi, esi

; 3206 : 
; 3207 :                 if (cur == NULL)

	je	$return1$683

; 3208 :                     goto return1;
; 3209 :                 if (*cur == '-') {

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN436@xmlSchemaV

; 3210 :                     sign = 1;

	mov	edi, 1

; 3211 :                     cur++;

	jmp	SHORT $LN669@xmlSchemaV
$LN436@xmlSchemaV:

; 3212 :                 } else if (*cur == '+')

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN438@xmlSchemaV
$LN669@xmlSchemaV:

; 3213 :                     cur++;
; 3214 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _cur$13[ebp], eax
$LN438@xmlSchemaV:
	lea	eax, DWORD PTR _hi$11[ebp]
	push	eax
	lea	eax, DWORD PTR _mi$5[ebp]
	push	eax
	lea	eax, DWORD PTR _lo$3[ebp]
	push	eax
	lea	eax, DWORD PTR _cur$13[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$4$[ebp], eax

; 3215 :                 if (ret < 0)

	test	eax, eax
	js	$return1$683

; 3216 :                     goto return1;
; 3217 :                 if (*cur != 0)

	mov	ecx, DWORD PTR _cur$13[ebp]
	cmp	BYTE PTR [ecx], bl
	jne	$return1$683

; 3218 :                     goto return1;
; 3219 :                 if (type->builtInType == XML_SCHEMAS_LONG) {

	mov	ecx, DWORD PTR _type$[ebp]
	mov	esi, DWORD PTR _lo$3[ebp]
	mov	ebx, DWORD PTR _mi$5[ebp]
	mov	ecx, DWORD PTR [ecx+88]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $LN441@xmlSchemaV

; 3220 :                     if (hi >= 922) {

	cmp	DWORD PTR _hi$11[ebp], 922		; 0000039aH
	jb	$LN466@xmlSchemaV

; 3221 :                         if (hi > 922)

	ja	$return1$683

; 3222 :                             goto return1;
; 3223 :                         if (mi >= 33720368) {

	cmp	ebx, 33720368				; 02028830H
	jb	$LN466@xmlSchemaV

; 3224 :                             if (mi > 33720368)

	ja	$return1$683

; 3225 :                                 goto return1;
; 3226 :                             if ((sign == 0) && (lo > 54775807))

	test	edi, edi
	jne	SHORT $LN447@xmlSchemaV
	cmp	esi, 54775807				; 0343cfffH

; 3227 :                                 goto return1;
; 3228 :                             if ((sign == 1) && (lo > 54775808))

	jmp	$LN670@xmlSchemaV
$LN447@xmlSchemaV:
	cmp	edi, 1
	jne	$LN466@xmlSchemaV
	cmp	esi, 54775808				; 0343d000H

; 3229 :                                 goto return1;
; 3230 :                         }
; 3231 :                     }

	jmp	$LN670@xmlSchemaV
$LN441@xmlSchemaV:

; 3232 :                 } else if (type->builtInType == XML_SCHEMAS_INT) {

	cmp	ecx, 35					; 00000023H
	jne	SHORT $LN449@xmlSchemaV

; 3233 :                     if (hi != 0)

	cmp	DWORD PTR _hi$11[ebp], 0
	jne	$return1$683

; 3234 :                         goto return1;
; 3235 :                     if (mi >= 21) {

	cmp	ebx, 21					; 00000015H
	jb	SHORT $LN466@xmlSchemaV

; 3236 :                         if (mi > 21)

	ja	$return1$683

; 3237 :                             goto return1;
; 3238 :                         if ((sign == 0) && (lo > 47483647))

	test	edi, edi
	jne	SHORT $LN454@xmlSchemaV
	cmp	esi, 47483647				; 02d48affH

; 3239 :                             goto return1;
; 3240 :                         if ((sign == 1) && (lo > 47483648))

	jmp	SHORT $LN670@xmlSchemaV
$LN454@xmlSchemaV:
	cmp	edi, 1
	jne	SHORT $LN466@xmlSchemaV
	cmp	esi, 47483648				; 02d48b00H

; 3241 :                             goto return1;
; 3242 :                     }

	jmp	SHORT $LN670@xmlSchemaV
$LN449@xmlSchemaV:

; 3243 :                 } else if (type->builtInType == XML_SCHEMAS_SHORT) {

	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN456@xmlSchemaV

; 3244 :                     if ((mi != 0) || (hi != 0))

	test	ebx, ebx
	jne	$return1$683
	cmp	DWORD PTR _hi$11[ebp], ebx
	jne	$return1$683

; 3245 :                         goto return1;
; 3246 :                     if ((sign == 1) && (lo > 32768))

	cmp	edi, 1
	jne	SHORT $LN460@xmlSchemaV
	cmp	esi, 32768				; 00008000H

; 3247 :                         goto return1;
; 3248 :                     if ((sign == 0) && (lo > 32767))

	jmp	SHORT $LN670@xmlSchemaV
$LN460@xmlSchemaV:
	test	edi, edi
	jne	SHORT $LN466@xmlSchemaV
	cmp	esi, 32767				; 00007fffH

; 3249 :                         goto return1;
; 3250 :                 } else if (type->builtInType == XML_SCHEMAS_BYTE) {

	jmp	SHORT $LN670@xmlSchemaV
$LN456@xmlSchemaV:
	cmp	ecx, 41					; 00000029H
	jne	SHORT $LN466@xmlSchemaV

; 3251 :                     if ((mi != 0) || (hi != 0))

	test	ebx, ebx
	jne	$return1$683
	cmp	DWORD PTR _hi$11[ebp], ebx
	jne	$return1$683

; 3252 :                         goto return1;
; 3253 :                     if ((sign == 1) && (lo > 128))

	cmp	edi, 1
	jne	SHORT $LN465@xmlSchemaV
	cmp	esi, 128				; 00000080H

; 3254 :                         goto return1;
; 3255 :                     if ((sign == 0) && (lo > 127))

	jmp	SHORT $LN670@xmlSchemaV
$LN465@xmlSchemaV:
	test	edi, edi
	jne	SHORT $LN466@xmlSchemaV
	cmp	esi, 127				; 0000007fH
$LN670@xmlSchemaV:

; 3256 :                         goto return1;
; 3257 :                 }
; 3258 :                 if (val != NULL) {

	ja	$return1$683
$LN466@xmlSchemaV:
	cmp	DWORD PTR _val$[ebp], 0
	je	$return0$681

; 3259 :                     v = xmlSchemaNewValue(type->builtInType);

	push	ecx
	call	_xmlSchemaNewValue
	add	esp, 4

; 3260 :                     if (v != NULL) {

	test	eax, eax
	je	$return0$681

; 3261 :                         v->value.decimal.lo = lo;
; 3262 :                         v->value.decimal.mi = mi;
; 3263 :                         v->value.decimal.hi = hi;

	mov	ecx, DWORD PTR _hi$11[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3264 :                         v->value.decimal.sign = sign;

	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR [eax+8], esi

; 3265 :                         v->value.decimal.frac = 0;

	or	ecx, edi
	mov	DWORD PTR [eax+12], ebx
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR [eax+24], ecx

; 3266 :                         v->value.decimal.total = ret;

	mov	ecx, DWORD PTR _ret$4$[ebp]

; 3267 :                         *val = v;
; 3268 :                     }
; 3269 :                 }
; 3270 :                 goto return0;

	jmp	$LN671@xmlSchemaV
$LN469@xmlSchemaV:

; 3271 :             }
; 3272 :         case XML_SCHEMAS_UINT:
; 3273 :         case XML_SCHEMAS_ULONG:
; 3274 :         case XML_SCHEMAS_USHORT:
; 3275 :         case XML_SCHEMAS_UBYTE:{
; 3276 :                 const xmlChar *cur = value;

	mov	DWORD PTR _cur$18[ebp], esi
	test	esi, esi

; 3277 :                 unsigned long lo, mi, hi;
; 3278 : 
; 3279 :                 if (cur == NULL)

	je	$return1$683

; 3280 :                     goto return1;
; 3281 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	eax, DWORD PTR _hi$2[ebp]
	push	eax
	lea	eax, DWORD PTR _mi$4[ebp]
	push	eax
	lea	eax, DWORD PTR _lo$7[ebp]
	push	eax
	lea	eax, DWORD PTR _cur$18[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$5$[ebp], eax

; 3282 :                 if (ret < 0)

	test	eax, eax
	js	$return1$683

; 3283 :                     goto return1;
; 3284 :                 if (*cur != 0)

	mov	ecx, DWORD PTR _cur$18[ebp]
	cmp	BYTE PTR [ecx], bl
	jne	$return1$683

; 3285 :                     goto return1;
; 3286 :                 if (type->builtInType == XML_SCHEMAS_ULONG) {

	mov	ecx, DWORD PTR [edi+88]
	mov	edi, DWORD PTR _hi$2[ebp]
	mov	esi, DWORD PTR _mi$4[ebp]
	mov	ebx, DWORD PTR _lo$7[ebp]
	cmp	ecx, 38					; 00000026H
	jne	SHORT $LN473@xmlSchemaV

; 3287 :                     if (hi >= 1844) {

	cmp	edi, 1844				; 00000734H
	jb	SHORT $LN494@xmlSchemaV

; 3288 :                         if (hi > 1844)

	ja	$return1$683

; 3289 :                             goto return1;
; 3290 :                         if (mi >= 67440737) {

	cmp	esi, 67440737				; 04051061H
	jb	SHORT $LN494@xmlSchemaV

; 3291 :                             if (mi > 67440737)

	ja	$return1$683

; 3292 :                                 goto return1;
; 3293 :                             if (lo > 9551615)

	cmp	ebx, 9551615				; 0091beffH

; 3294 :                                 goto return1;
; 3295 :                         }
; 3296 :                     }

	jmp	SHORT $LN672@xmlSchemaV
$LN473@xmlSchemaV:

; 3297 :                 } else if (type->builtInType == XML_SCHEMAS_UINT) {

	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN480@xmlSchemaV

; 3298 :                     if (hi != 0)

	test	edi, edi
	jne	$return1$683

; 3299 :                         goto return1;
; 3300 :                     if (mi >= 42) {

	cmp	esi, 42					; 0000002aH
	jb	SHORT $LN494@xmlSchemaV

; 3301 :                         if (mi > 42)

	ja	$return1$683

; 3302 :                             goto return1;
; 3303 :                         if (lo > 94967295)

	cmp	ebx, 94967295				; 05a915ffH

; 3304 :                             goto return1;
; 3305 :                     }

	jmp	SHORT $LN672@xmlSchemaV
$LN480@xmlSchemaV:

; 3306 :                 } else if (type->builtInType == XML_SCHEMAS_USHORT) {

	cmp	ecx, 40					; 00000028H
	jne	SHORT $LN486@xmlSchemaV

; 3307 :                     if ((mi != 0) || (hi != 0))

	test	esi, esi
	jne	$return1$683
	test	edi, edi
	jne	$return1$683

; 3308 :                         goto return1;
; 3309 :                     if (lo > 65535)

	cmp	ebx, 65535				; 0000ffffH

; 3310 :                         goto return1;
; 3311 :                 } else if (type->builtInType == XML_SCHEMAS_UBYTE) {

	jmp	SHORT $LN672@xmlSchemaV
$LN486@xmlSchemaV:
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN494@xmlSchemaV

; 3312 :                     if ((mi != 0) || (hi != 0))

	test	esi, esi
	jne	$return1$683
	test	edi, edi
	jne	$return1$683

; 3313 :                         goto return1;
; 3314 :                     if (lo > 255)

	cmp	ebx, 255				; 000000ffH
$LN672@xmlSchemaV:

; 3315 :                         goto return1;
; 3316 :                 }
; 3317 :                 if (val != NULL) {

	ja	$return1$683
$LN494@xmlSchemaV:
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $return0$681

; 3318 :                     v = xmlSchemaNewValue(type->builtInType);

	push	ecx
	call	_xmlSchemaNewValue
	add	esp, 4

; 3319 :                     if (v != NULL) {

	test	eax, eax
	je	SHORT $return0$681

; 3320 :                         v->value.decimal.lo = lo;
; 3321 :                         v->value.decimal.mi = mi;
; 3322 :                         v->value.decimal.hi = hi;
; 3323 :                         v->value.decimal.sign = 0;
; 3324 :                         v->value.decimal.frac = 0;

	and	DWORD PTR [eax+24], -256		; ffffff00H

; 3325 :                         v->value.decimal.total = ret;

	mov	ecx, DWORD PTR _ret$5$[ebp]
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], edi
$LN671@xmlSchemaV:

; 3345 :   return0:
; 3346 :     if (norm != NULL)

	mov	BYTE PTR [eax+25], cl
$LN168@xmlSchemaV:
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], eax
$return0$681:
	mov	eax, DWORD PTR _norm$1$[ebp]
	test	eax, eax
	je	SHORT $LN500@xmlSchemaV

; 3347 :         xmlFree(norm);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN500@xmlSchemaV:

; 3348 :     return (0);

	pop	esi
	pop	edi
	xor	eax, eax
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN679@xmlSchemaV:
	DD	$error$682
	DD	$LN88@xmlSchemaV
	DD	$LN110@xmlSchemaV
	DD	$LN123@xmlSchemaV
	DD	$LN154@xmlSchemaV
	DD	$LN155@xmlSchemaV
	DD	$LN156@xmlSchemaV
	DD	$LN207@xmlSchemaV
	DD	$LN239@xmlSchemaV
	DD	$LN251@xmlSchemaV
	DD	$LN258@xmlSchemaV
	DD	$LN263@xmlSchemaV
	DD	$LN266@xmlSchemaV
	DD	$LN273@xmlSchemaV
	DD	$LN288@xmlSchemaV
	DD	$LN292@xmlSchemaV
	DD	$LN302@xmlSchemaV
	DD	$LN308@xmlSchemaV
	DD	$LN312@xmlSchemaV
	DD	$LN322@xmlSchemaV
	DD	$LN328@xmlSchemaV
	DD	$LN350@xmlSchemaV
	DD	$LN403@xmlSchemaV
	DD	$LN434@xmlSchemaV
	DD	$LN469@xmlSchemaV
	DD	$LN359@xmlSchemaV
	DD	$LN376@xmlSchemaV
	DD	$LN84@xmlSchemaV
$LN633@xmlSchemaV:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	5
	DB	6
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
_xmlSchemaValAtomicType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaParseUInt
_TEXT	SEGMENT
_hi$1$ = -12						; size = 4
_mi$1$ = -8						; size = 4
_lo$1$ = -4						; size = 4
_str$ = 8						; size = 4
_llo$ = 12						; size = 4
_lmi$ = 16						; size = 4
_lhi$ = 20						; size = 4
_xmlSchemaParseUInt PROC				; COMDAT

; 2088 :                    unsigned long *lmi, unsigned long *lhi) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR _lo$1$[ebp], 0
	mov	DWORD PTR _mi$1$[ebp], 0
	mov	DWORD PTR _hi$1$[ebp], 0
	mov	edx, DWORD PTR [edi]
	mov	cl, BYTE PTR [edx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	$LN13@xmlSchemaP

; 2089 :     unsigned long lo = 0, mi = 0, hi = 0;
; 2090 :     const xmlChar *tmp, *cur = *str;
; 2091 :     int ret = 0, i = 0;
; 2092 : 
; 2093 :     if (!((*cur >= '0') && (*cur <= '9')))
; 2094 :         return(-2);
; 2095 : 
; 2096 :     while (*cur == '0') {        /* ignore leading zeroes */

	cmp	cl, 48					; 00000030H
	jne	SHORT $LN3@xmlSchemaP
$LL2@xmlSchemaP:
	mov	cl, BYTE PTR [edx+1]

; 2097 :         cur++;

	inc	edx
	cmp	cl, 48					; 00000030H
	je	SHORT $LL2@xmlSchemaP
$LN3@xmlSchemaP:

; 2098 :     }
; 2099 :     tmp = cur;

	mov	eax, edx

; 2100 :     while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {

	test	cl, cl
	je	$LN11@xmlSchemaP
$LL4@xmlSchemaP:
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN5@xmlSchemaP
	mov	cl, BYTE PTR [eax+1]

; 2101 :         i++;tmp++;ret++;

	inc	eax
	inc	esi
	inc	ebx
	test	cl, cl
	jne	SHORT $LL4@xmlSchemaP
$LN5@xmlSchemaP:

; 2102 :     }
; 2103 :     if (i > 24) {

	cmp	esi, 24					; 00000018H
	jle	SHORT $LN18@xmlSchemaP

; 2104 :         *str = tmp;

	mov	DWORD PTR [edi], eax

; 2105 :         return(-1);

	or	eax, -1
	pop	edi

; 2122 :     *lmi = mi;
; 2123 :     *lhi = hi;
; 2124 :     return(ret);
; 2125 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaP:

; 2106 :     }
; 2107 :     while (i > 16) {

	cmp	esi, 16					; 00000010H
	jle	SHORT $LN19@xmlSchemaP
	lea	edi, DWORD PTR [esi-16]
	xor	eax, eax
	mov	esi, 16					; 00000010H
$LL6@xmlSchemaP:

; 2108 :         hi = hi * 10 + (*cur++ - '0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR [edx]
	inc	edx
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	sub	edi, 1
	jne	SHORT $LL6@xmlSchemaP
	mov	DWORD PTR _hi$1$[ebp], eax
$LN19@xmlSchemaP:

; 2109 :         i--;
; 2110 :     }
; 2111 :     while (i > 8) {

	cmp	esi, 8
	jle	SHORT $LN20@xmlSchemaP
	lea	edi, DWORD PTR [esi-8]
	xor	eax, eax
	mov	esi, 8
	npad	4
$LL8@xmlSchemaP:

; 2112 :         mi = mi * 10 + (*cur++ - '0');

	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR [edx]
	inc	edx
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	sub	edi, 1
	jne	SHORT $LL8@xmlSchemaP
	mov	DWORD PTR _mi$1$[ebp], eax
$LN20@xmlSchemaP:

; 2113 :         i--;
; 2114 :     }
; 2115 :     while (i > 0) {

	test	esi, esi
	jle	SHORT $LN11@xmlSchemaP
	xor	ecx, ecx
	npad	5
$LL10@xmlSchemaP:

; 2116 :         lo = lo * 10 + (*cur++ - '0');

	movzx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+ecx*4]

; 2117 :         i--;

	dec	esi
	lea	ecx, DWORD PTR [ecx-24]
	inc	edx
	lea	ecx, DWORD PTR [eax+ecx*2]
	test	esi, esi
	jg	SHORT $LL10@xmlSchemaP
	mov	DWORD PTR _lo$1$[ebp], ecx
$LN11@xmlSchemaP:

; 2118 :     }
; 2119 : 
; 2120 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]

; 2121 :     *llo = lo;

	mov	ecx, DWORD PTR _llo$[ebp]
	pop	edi

; 2122 :     *lmi = mi;
; 2123 :     *lhi = hi;
; 2124 :     return(ret);
; 2125 : }

	pop	esi
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _lo$1$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _lmi$[ebp]
	mov	eax, DWORD PTR _mi$1$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _lhi$[ebp]
	mov	eax, DWORD PTR _hi$1$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaP:
	pop	edi
	pop	esi
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseUInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValAtomicListNode
_TEXT	SEGMENT
_tmp$1$ = -8						; size = 4
_nb_values$1$ = -4					; size = 4
_type$ = 8						; size = 4
_val$1$ = 12						; size = 4
_value$ = 12						; size = 4
_ret$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValAtomicListNode PROC			; COMDAT

; 2019 : 	                   xmlSchemaValPtr *ret, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _value$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _tmp$1$[ebp], ebx
	test	eax, eax
	je	$LN32@xmlSchemaV

; 2020 :     xmlChar *val, *cur, *endval;
; 2021 :     int nb_values = 0;
; 2022 :     int tmp = 0;
; 2023 : 
; 2024 :     if (value == NULL) {
; 2025 : 	return(-1);
; 2026 :     }
; 2027 :     val = xmlStrdup(value);

	push	eax
	call	_xmlStrdup
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _val$1$[ebp], edx

; 2028 :     if (val == NULL) {

	test	edx, edx
	je	$LN32@xmlSchemaV

; 2029 : 	return(-1);
; 2030 :     }
; 2031 :     if (ret != NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaV

; 2032 :         *ret = NULL;

	mov	DWORD PTR [eax], ebx
$LN20@xmlSchemaV:

; 2033 :     }
; 2034 :     cur = val;

	mov	esi, edx
$LL2@xmlSchemaV:

; 2035 :     /*
; 2036 :      * Split the list
; 2037 :      */
; 2038 :     while (IS_BLANK_CH(*cur)) *cur++ = 0;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN21@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN22@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN21@xmlSchemaV
$LN22@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN38@xmlSchemaV
$LN21@xmlSchemaV:
	mov	BYTE PTR [esi], bl
	inc	esi
	jmp	SHORT $LL2@xmlSchemaV
$LN38@xmlSchemaV:

; 2039 :     while (*cur != 0) {

	test	al, al
	je	$LN67@xmlSchemaV
$LL4@xmlSchemaV:

; 2040 : 	if (IS_BLANK_CH(*cur)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN26@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN25@xmlSchemaV
$LN26@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN25@xmlSchemaV

; 2044 : 	} else {
; 2045 : 	    nb_values++;
; 2046 : 	    cur++;
; 2047 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	inc	ebx
	test	al, al
	je	SHORT $LN84@xmlSchemaV
	mov	cl, al
	npad	3
$LL8@xmlSchemaV:
	mov	al, cl
	cmp	cl, 32					; 00000020H
	je	SHORT $LN80@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN29@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN80@xmlSchemaV
$LN29@xmlSchemaV:
	mov	al, cl
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN80@xmlSchemaV
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	test	cl, cl
	jne	SHORT $LL8@xmlSchemaV

; 2059 : 	if (tmp != 0)

	xor	al, al
	jmp	SHORT $LN80@xmlSchemaV
$LN25@xmlSchemaV:

; 2041 : 	    *cur = 0;
; 2042 : 	    cur++;
; 2043 : 	    while (IS_BLANK_CH(*cur)) *cur++ = 0;

	mov	BYTE PTR [esi], 0
	inc	esi
	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN28@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN25@xmlSchemaV
$LN28@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN25@xmlSchemaV
$LN80@xmlSchemaV:

; 2039 :     while (*cur != 0) {

	test	al, al
	jne	SHORT $LL4@xmlSchemaV
$LN84@xmlSchemaV:
	mov	DWORD PTR _nb_values$1$[ebp], ebx

; 2048 : 	}
; 2049 :     }
; 2050 :     if (nb_values == 0) {

	test	ebx, ebx
	je	$LN67@xmlSchemaV

; 2053 :     }
; 2054 :     endval = cur;
; 2055 :     cur = val;
; 2056 :     while ((*cur == 0) && (cur != endval)) cur++;

	cmp	BYTE PTR [edx], 0
	push	edi
	mov	edi, edx
	jne	SHORT $LN42@xmlSchemaV
$LL10@xmlSchemaV:
	cmp	edi, esi
	je	SHORT $LN46@xmlSchemaV
	inc	edi
	cmp	BYTE PTR [edi], 0
	je	SHORT $LL10@xmlSchemaV
$LN42@xmlSchemaV:

; 2057 :     while (cur != endval) {

	cmp	edi, esi
	je	SHORT $LN46@xmlSchemaV
	mov	ebx, DWORD PTR _node$[ebp]
$LL12@xmlSchemaV:

; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,

	push	0
	push	1
	push	1
	push	0
	push	0
	push	ebx
	push	0
	push	edi
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 2058 : 	tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);

	mov	DWORD PTR _tmp$1$[ebp], eax

; 2059 : 	if (tmp != 0)

	test	eax, eax
	jne	SHORT $LN81@xmlSchemaV

; 2060 : 	    break;
; 2061 : 	while (*cur != 0) cur++;

	cmp	BYTE PTR [edi], al
	je	SHORT $LL16@xmlSchemaV
$LL14@xmlSchemaV:
	inc	edi
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LL14@xmlSchemaV
	npad	4
$LL16@xmlSchemaV:

; 2062 : 	while ((*cur == 0) && (cur != endval)) cur++;

	cmp	edi, esi
	je	SHORT $LN81@xmlSchemaV
	inc	edi
	mov	eax, edi
	cmp	BYTE PTR [edi], 0
	je	SHORT $LL16@xmlSchemaV

; 2057 :     while (cur != endval) {

	cmp	eax, esi
	jne	SHORT $LL12@xmlSchemaV
$LN81@xmlSchemaV:
	mov	ebx, DWORD PTR _nb_values$1$[ebp]
	mov	edx, DWORD PTR _val$1$[ebp]
$LN46@xmlSchemaV:

; 2063 :     }
; 2064 :     /* TODO what return value ? c.f. bug #158628
; 2065 :     if (ret != NULL) {
; 2066 : 	TODO
; 2067 :     } */
; 2068 :     xmlFree(val);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2069 :     if (tmp == 0)

	cmp	DWORD PTR _tmp$1$[ebp], 0
	pop	edi
	jne	SHORT $LN32@xmlSchemaV

; 2070 : 	return(nb_values);

	pop	esi
	mov	eax, ebx

; 2072 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlSchemaV:

; 2051 : 	xmlFree(val);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2052 : 	return(nb_values);

	xor	eax, eax
	pop	esi

; 2072 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlSchemaV:
	pop	esi

; 2071 :     return(-1);

	or	eax, -1

; 2072 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValAtomicListNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaStrip
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaStrip PROC					; COMDAT

; 1904 : xmlSchemaStrip(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	test	esi, esi
	je	SHORT $LN27@xmlSchemaS

; 1905 :     const xmlChar *start = value, *end, *f;
; 1906 : 
; 1907 :     if (value == NULL) return(NULL);
; 1908 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN28@xmlSchemaS
	npad	2
$LL2@xmlSchemaS:
	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlSchemaS
	cmp	al, 9
	jb	SHORT $LN10@xmlSchemaS
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN9@xmlSchemaS
$LN10@xmlSchemaS:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN28@xmlSchemaS
$LN9@xmlSchemaS:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlSchemaS
$LN28@xmlSchemaS:

; 1909 :     end = start;
; 1910 :     while (*end != 0) end++;

	cmp	BYTE PTR [ecx], 0
	mov	eax, ecx
	je	SHORT $LN5@xmlSchemaS
	npad	1
$LL4@xmlSchemaS:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL4@xmlSchemaS
$LN5@xmlSchemaS:

; 1911 :     f = end;

	mov	edi, eax

; 1912 :     end--;

	dec	eax

; 1913 :     while ((end > start) && (IS_BLANK_CH(*end))) end--;

	cmp	eax, ecx
	jbe	SHORT $LN29@xmlSchemaS
	npad	3
$LL6@xmlSchemaS:
	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN11@xmlSchemaS
	cmp	dl, 9
	jb	SHORT $LN12@xmlSchemaS
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlSchemaS
$LN12@xmlSchemaS:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN29@xmlSchemaS
$LN11@xmlSchemaS:
	dec	eax
	cmp	eax, ecx
	ja	SHORT $LL6@xmlSchemaS
$LN29@xmlSchemaS:

; 1914 :     end++;

	inc	eax

; 1915 :     if ((start == value) && (f == end)) return(NULL);

	cmp	ecx, esi
	jne	SHORT $LN13@xmlSchemaS
	cmp	edi, eax
	je	SHORT $LN27@xmlSchemaS
$LN13@xmlSchemaS:

; 1916 :     return(xmlStrndup(start, end - start));

	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	pop	edi

; 1917 : }

	pop	esi
	pop	ebp
	ret	0
$LN27@xmlSchemaS:
	pop	edi

; 1915 :     if ((start == value) && (f == end)) return(NULL);

	xor	eax, eax

; 1917 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaStrip ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateDuration
_TEXT	SEGMENT
_multi$ = -72						; size = 56
_desig$ = -16						; size = 6
_isneg$1$ = -8						; size = 4
_dur$1$ = -4						; size = 4
_type$ = 8						; size = 4
_num_type$1$ = 12					; size = 4
_duration$ = 12						; size = 4
_val$ = 16						; size = 4
_collapse$ = 20						; size = 4
_xmlSchemaValidateDuration PROC				; COMDAT

; 1789 : 			   int collapse) {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _duration$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _multi$[ebp], xmm0
	xor	eax, eax
	xor	edi, edi
	movaps	xmm0, XMMWORD PTR __xmm@40ac20000000000040f5180000000000
	mov	DWORD PTR _isneg$1$[ebp], 0
	mov	DWORD PTR _num_type$1$[ebp], eax
	mov	DWORD PTR _desig$[ebp], 1212435801	; 48444d59H
	mov	WORD PTR _desig$[ebp+4], 21325		; 0000534dH
	movups	XMMWORD PTR _multi$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ff0000000000000404e000000000000
	movups	XMMWORD PTR _multi$[ebp+32], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _multi$[ebp+48], xmm0
	test	ecx, ecx
	je	$LN82@xmlSchemaV

; 1790 :     const xmlChar  *cur = duration;
; 1791 :     xmlSchemaValPtr dur;
; 1792 :     int isneg = 0;
; 1793 :     unsigned int seq = 0;
; 1794 :     double         num;
; 1795 :     int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */
; 1796 :     const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};
; 1797 :     const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};
; 1798 : 
; 1799 :     if (duration == NULL)
; 1800 : 	return -1;
; 1801 : 
; 1802 :     if (collapse)

	cmp	DWORD PTR _collapse$[ebp], eax
	je	SHORT $LN83@xmlSchemaV
$LL2@xmlSchemaV:

; 1803 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN19@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN18@xmlSchemaV
$LN19@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN83@xmlSchemaV
$LN18@xmlSchemaV:
	inc	ecx
	jmp	SHORT $LL2@xmlSchemaV
$LN83@xmlSchemaV:

; 1804 : 
; 1805 :     if (*cur == '-') {

	mov	al, BYTE PTR [ecx]
	mov	dl, al
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN20@xmlSchemaV

; 1806 :         isneg = 1;
; 1807 :         cur++;

	mov	dl, BYTE PTR [ecx+1]
	mov	DWORD PTR _isneg$1$[ebp], 1
$LN20@xmlSchemaV:

; 1808 :     }
; 1809 : 
; 1810 :     /* duration must start with 'P' (after sign) */
; 1811 :     if (*cur++ != 'P')

	cmp	al, 45					; 0000002dH
	lea	esi, DWORD PTR [ecx+1]
	cmovne	esi, ecx
	inc	esi
	cmp	dl, 80					; 00000050H
	jne	$LN27@xmlSchemaV

; 1812 : 	return 1;
; 1813 : 
; 1814 :     if (*cur == 0)

	cmp	BYTE PTR [esi], 0
	je	$LN27@xmlSchemaV

; 1815 : 	return 1;
; 1816 : 
; 1817 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);

	push	12					; 0000000cH
	call	_xmlSchemaNewValue
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _dur$1$[ebp], edx

; 1818 :     if (dur == NULL)

	test	edx, edx
	je	$LN82@xmlSchemaV

; 1820 : 
; 1821 :     while (*cur != 0) {

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	$LN5@xmlSchemaV
$LL4@xmlSchemaV:

; 1822 : 
; 1823 :         /* input string should be empty or invalid date/time item */
; 1824 :         if (seq >= sizeof(desig))

	cmp	edi, 6
	jae	$error$88

; 1825 :             goto error;
; 1826 : 
; 1827 :         /* T designator must be present for time items */
; 1828 :         if (*cur == 'T') {

	cmp	cl, 84					; 00000054H
	jne	SHORT $LN25@xmlSchemaV

; 1829 :             if (seq <= 3) {

	cmp	edi, 3
	ja	$LN27@xmlSchemaV

; 1830 :                 seq = 3;
; 1831 :                 cur++;

	mov	cl, BYTE PTR [esi+1]
	inc	esi
	mov	edi, 3

; 1832 :             } else
; 1833 :                 return 1;
; 1834 :         } else if (seq == 3)

	jmp	SHORT $LN29@xmlSchemaV
$LN25@xmlSchemaV:
	cmp	edi, 3
	je	$error$88
$LN29@xmlSchemaV:

; 1835 :             goto error;
; 1836 : 
; 1837 :         /* parse the number portion of the item */
; 1838 :         PARSE_NUM(num, cur, num_type);

	lea	eax, DWORD PTR [ecx-48]
	xorps	xmm1, xmm1
	cmp	al, 9
	ja	$error$88
	npad	2
$LL6@xmlSchemaV:
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN7@xmlSchemaV
	mulsd	xmm1, QWORD PTR __real@4024000000000000
	inc	esi
	movzx	eax, cl
	sub	eax, 48					; 00000030H
	mov	cl, BYTE PTR [esi]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	addsd	xmm1, xmm0
	cmp	cl, 48					; 00000030H
	jae	SHORT $LL6@xmlSchemaV
$LN7@xmlSchemaV:
	mov	eax, DWORD PTR _num_type$1$[ebp]
	test	eax, eax
	jne	SHORT $LN9@xmlSchemaV
	cmp	BYTE PTR [esi], 46			; 0000002eH
	jne	SHORT $LN80@xmlSchemaV
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	mov	dl, 9
	lea	eax, DWORD PTR [ecx-48]
	cmp	dl, al
	sbb	edx, edx
	and	edx, -2					; fffffffeH
	inc	edx
	mov	eax, edx
	mov	DWORD PTR _num_type$1$[ebp], eax
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN86@xmlSchemaV
$LL8@xmlSchemaV:
	mov	eax, edx
	mov	DWORD PTR _num_type$1$[ebp], eax
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN86@xmlSchemaV
	divsd	xmm2, QWORD PTR __real@4024000000000000
	movzx	eax, cl
	inc	esi
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _num_type$1$[ebp], edx
	mov	cl, BYTE PTR [esi]
	movd	xmm0, eax
	mov	eax, edx
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	addsd	xmm1, xmm0
	cmp	cl, 48					; 00000030H
	jae	SHORT $LL8@xmlSchemaV
$LN86@xmlSchemaV:

; 1839 : 
; 1840 :         if ((num_type == -1) || (*cur == 0))

	mov	edx, DWORD PTR _dur$1$[ebp]
$LN9@xmlSchemaV:
	cmp	eax, -1
	je	$error$88
$LN80@xmlSchemaV:
	mov	al, BYTE PTR [esi]
	test	al, al
	je	$error$88

; 1841 :             goto error;
; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {

	cmp	edi, 6
	jae	SHORT $LN12@xmlSchemaV
$LL10@xmlSchemaV:

; 1845 :             if (*cur == desig[seq]) {

	cmp	al, BYTE PTR _desig$[ebp+edi]
	je	SHORT $LN60@xmlSchemaV

; 1862 :                         break;
; 1863 :                 }
; 1864 : 
; 1865 :                 break;          /* exit loop */
; 1866 :             }
; 1867 :             /* no date designators found? */
; 1868 :             if ((++seq == 3) || (seq == 6))

	inc	edi
	cmp	edi, 3
	je	$error$88
	cmp	edi, 6
	je	$error$88

; 1841 :             goto error;
; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {

	jb	SHORT $LL10@xmlSchemaV

; 1846 : 
; 1847 :                 /* verify numeric type; only seconds can be float */
; 1848 :                 if ((num_type != 0) && (seq < (sizeof(desig)-1)))

	jmp	SHORT $LN12@xmlSchemaV
$LN60@xmlSchemaV:
	cmp	DWORD PTR _num_type$1$[ebp], 0
	je	SHORT $LN40@xmlSchemaV
	cmp	edi, 5
	jb	$error$88
$LN40@xmlSchemaV:

; 1849 :                     goto error;
; 1850 : 
; 1851 :                 switch (seq) {

	mov	eax, edi
	sub	eax, 0
	je	SHORT $LN41@xmlSchemaV
	sub	eax, 1
	je	SHORT $LN42@xmlSchemaV

; 1858 :                     default:
; 1859 :                         /* convert to seconds using multiplier */
; 1860 :                         dur->value.dur.sec += num * multi[seq];

	movsd	xmm0, QWORD PTR _multi$[ebp+edi*8]

; 1861 :                         seq++;

	inc	edi
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [edx+16]
	movsd	QWORD PTR [edx+16], xmm0
	jmp	SHORT $LN12@xmlSchemaV
$LN42@xmlSchemaV:

; 1854 :                         break;
; 1855 :                     case 1:
; 1856 :                         dur->value.dur.mon += (long)num;

	cvttsd2si eax, xmm1
	add	DWORD PTR [edx+8], eax

; 1857 :                         break;

	jmp	SHORT $LN12@xmlSchemaV
$LN41@xmlSchemaV:

; 1852 :                     case 0:
; 1853 :                         dur->value.dur.mon = (long)num * 12;

	cvttsd2si eax, xmm1
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	mov	DWORD PTR [edx+8], eax
$LN12@xmlSchemaV:

; 1869 :                 goto error;
; 1870 :         }
; 1871 : 	cur++;

	inc	esi

; 1872 : 	if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN85@xmlSchemaV
$LL14@xmlSchemaV:

; 1873 : 	    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN47@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN48@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN47@xmlSchemaV
$LN48@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN85@xmlSchemaV
$LN47@xmlSchemaV:
	inc	esi
	jmp	SHORT $LL14@xmlSchemaV
$LN85@xmlSchemaV:

; 1820 : 
; 1821 :     while (*cur != 0) {

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	jne	$LL4@xmlSchemaV
$LN5@xmlSchemaV:

; 1874 :     }
; 1875 : 
; 1876 :     if (isneg) {

	cmp	DWORD PTR _isneg$1$[ebp], 0
	je	SHORT $LN49@xmlSchemaV

; 1877 :         dur->value.dur.mon = -dur->value.dur.mon;

	mov	eax, DWORD PTR [edx+8]

; 1878 :         dur->value.dur.day = -dur->value.dur.day;
; 1879 :         dur->value.dur.sec = -dur->value.dur.sec;

	movsd	xmm0, QWORD PTR [edx+16]
	neg	eax
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [edx+12]
	neg	eax
	movsd	QWORD PTR [edx+16], xmm0
	mov	DWORD PTR [edx+12], eax
$LN49@xmlSchemaV:

; 1880 :     }
; 1881 : 
; 1882 :     if (val != NULL)

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN50@xmlSchemaV

; 1883 :         *val = dur;

	pop	edi
	mov	DWORD PTR [eax], edx

; 1886 : 
; 1887 :     return 0;

	xor	eax, eax

; 1892 :     return 1;
; 1893 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$error$88:

; 1888 : 
; 1889 : error:
; 1890 :     if (dur != NULL)
; 1891 : 	xmlSchemaFreeValue(dur);

	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN27@xmlSchemaV:

; 1892 :     return 1;
; 1893 : }

	pop	edi
	mov	eax, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlSchemaV:

; 1884 :     else
; 1885 : 	xmlSchemaFreeValue(dur);

	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 1886 : 
; 1887 :     return 0;

	xor	eax, eax
	pop	edi

; 1892 :     return 1;
; 1893 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@xmlSchemaV:
	pop	edi

; 1819 : 	return -1;

	or	eax, -1

; 1892 :     return 1;
; 1893 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValidateDuration ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateDates
_TEXT	SEGMENT
tv1487 = -8						; size = 4
_digcnt$1$ = -4						; size = 4
_cur$ = -4						; size = 4
_type$ = 8						; size = 4
_firstChar$1$ = 12					; size = 4
tv1486 = 12						; size = 4
tv1444 = 12						; size = 4
_dateTime$ = 12						; size = 4
_val$ = 16						; size = 4
_collapse$ = 20						; size = 4
_xmlSchemaValidateDates PROC				; COMDAT

; 1566 : 			int collapse) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dateTime$[ebp]
	mov	esi, eax
	mov	DWORD PTR _cur$[ebp], esi
	test	eax, eax
	je	$LN110@xmlSchemaV

; 1567 :     xmlSchemaValPtr dt;
; 1568 :     int ret;
; 1569 :     const xmlChar *cur = dateTime;
; 1570 : 
; 1571 : #define RETURN_TYPE_IF_VALID(t)					\
; 1572 :     if (IS_TZO_CHAR(*cur)) {					\
; 1573 : 	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
; 1574 : 	if (ret == 0) {						\
; 1575 : 	    if (*cur != 0)					\
; 1576 : 		goto error;					\
; 1577 : 	    dt->type = t;					\
; 1578 : 	    goto done;						\
; 1579 : 	}							\
; 1580 :     }
; 1581 : 
; 1582 :     if (dateTime == NULL)
; 1583 : 	return -1;
; 1584 : 
; 1585 :     if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	mov	ebx, eax
	je	SHORT $LN3@xmlSchemaV
	npad	5
$LL2@xmlSchemaV:

; 1586 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaV
	cmp	al, 9
	jb	SHORT $LN9@xmlSchemaV
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlSchemaV
$LN9@xmlSchemaV:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN116@xmlSchemaV
$LN8@xmlSchemaV:
	lea	esi, DWORD PTR [ebx+1]
	mov	ebx, esi
	jmp	SHORT $LL2@xmlSchemaV
$LN116@xmlSchemaV:
	mov	DWORD PTR _cur$[ebp], esi
$LN3@xmlSchemaV:

; 1587 : 
; 1588 :     if ((*cur != '-') && (*cur < '0') && (*cur > '9'))

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	je	SHORT $LN10@xmlSchemaV
	cmp	al, 48					; 00000030H
	jae	SHORT $LN10@xmlSchemaV
	cmp	al, 57					; 00000039H
	ja	$LN125@xmlSchemaV
$LN10@xmlSchemaV:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	edi, edi
	je	$LN110@xmlSchemaV
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [edi], xmm0
	movups	XMMWORD PTR [edi+16], xmm0

; 1589 : 	return 1;
; 1590 : 
; 1591 :     dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);
; 1592 :     if (dt == NULL)
; 1593 : 	return -1;
; 1594 : 
; 1595 :     if ((cur[0] == '-') && (cur[1] == '-')) {

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	jne	$LN12@xmlSchemaV
	cmp	BYTE PTR [esi+1], al
	jne	$LN12@xmlSchemaV

; 1596 : 	/*
; 1597 : 	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
; 1598 : 	 * xs:gDay)
; 1599 : 	 */
; 1600 : 	cur += 2;
; 1601 : 
; 1602 : 	/* is it an xs:gDay? */
; 1603 : 	if (*cur == '-') {

	cmp	BYTE PTR [ebx+2], 45			; 0000002dH
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR _cur$[ebp], eax
	jne	SHORT $LN13@xmlSchemaV

; 1604 : 	    if (type == XML_SCHEMAS_GMONTH)

	cmp	DWORD PTR _type$[ebp], 6
	je	$error$127

; 1605 : 		goto error;
; 1606 : 	  ++cur;

	inc	eax

; 1607 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	esi, DWORD PTR [edi+8]
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseGDay
	add	esp, 8

; 1608 : 	    if (ret != 0)

	test	eax, eax
	jne	$error$127

; 1609 : 		goto error;
; 1610 : 
; 1611 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [eax]
	test	al, al
	je	SHORT $LN17@xmlSchemaV
	cmp	al, 90					; 0000005aH
	je	SHORT $LN17@xmlSchemaV
	cmp	al, 43					; 0000002bH
	je	SHORT $LN17@xmlSchemaV
	cmp	al, 45					; 0000002dH
	jne	$error$127
$LN17@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	jne	$error$127
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 5
	mov	eax, 5
	jmp	$done$128
$LN13@xmlSchemaV:

; 1612 : 
; 1613 : 	    goto error;
; 1614 : 	}
; 1615 : 
; 1616 : 	/*
; 1617 : 	 * it should be an xs:gMonthDay or xs:gMonth
; 1618 : 	 */
; 1619 : 	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	lea	ebx, DWORD PTR [edi+8]
	push	ebx
	call	__xmlSchemaParseGMonth
	add	esp, 8

; 1620 : 	if (ret != 0)

	test	eax, eax
	jne	$error$127

; 1621 : 	    goto error;
; 1622 : 
; 1623 :         /*
; 1624 :          * a '-' char could indicate this type is xs:gMonthDay or
; 1625 :          * a negative time zone offset. Check for xs:gMonthDay first.
; 1626 :          * Also the first three char's of a negative tzo (-MM:SS) can
; 1627 :          * appear to be a valid day; so even if the day portion
; 1628 :          * of the xs:gMonthDay verifies, we must insure it was not
; 1629 :          * a tzo.
; 1630 :          */
; 1631 :         if (*cur == '-') {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 45			; 0000002dH
	jne	$LN21@xmlSchemaV

; 1632 :             const xmlChar *rewnd = cur;

	lea	eax, DWORD PTR [esi+1]

; 1633 :             cur++;

	mov	DWORD PTR _cur$[ebp], eax

; 1634 : 
; 1635 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	ebx
	call	__xmlSchemaParseGDay
	add	esp, 8

; 1636 :             if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {

	test	eax, eax
	jne	$LN24@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	mov	bl, BYTE PTR [eax]
	test	bl, bl
	je	SHORT $LN23@xmlSchemaV
	cmp	bl, 58					; 0000003aH
	je	$LN118@xmlSchemaV
$LN23@xmlSchemaV:

; 1637 : 
; 1638 :                 /*
; 1639 :                  * we can use the VALID_MDAY macro to validate the month
; 1640 :                  * and day because the leap year test will flag year zero
; 1641 :                  * as a leap year (even though zero is an invalid year).
; 1642 : 		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
; 1643 : 		 * probably.
; 1644 :                  */
; 1645 :                 if (VALID_MDAY((&(dt->value.date)))) {

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, ecx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN119@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN119@xmlSchemaV:
	jne	SHORT $LN76@xmlSchemaV
	mov	eax, ecx
	mov	DWORD PTR tv1444[ebp], 100		; 00000064H
	cdq
	idiv	DWORD PTR tv1444[ebp]
	test	edx, edx
	jne	SHORT $LN77@xmlSchemaV
$LN76@xmlSchemaV:
	mov	eax, ecx
	mov	ecx, 400				; 00000190H
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN77@xmlSchemaV
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonth[eax*4-4], ecx
	jmp	SHORT $LN122@xmlSchemaV
$LN77@xmlSchemaV:
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, ecx
	and	eax, 15					; 0000000fH
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonthLeap[eax*4-4], ecx
$LN122@xmlSchemaV:
	sbb	eax, eax
	inc	eax
	test	eax, eax
	je	SHORT $LN118@xmlSchemaV

; 1646 : 
; 1647 : 	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);

	test	bl, bl
	je	SHORT $LN26@xmlSchemaV
	cmp	bl, 90					; 0000005aH
	je	SHORT $LN26@xmlSchemaV
	cmp	bl, 43					; 0000002bH
	je	SHORT $LN26@xmlSchemaV
	cmp	bl, 45					; 0000002dH
	jne	$error$127
$LN26@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	jne	$error$127
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 7
	mov	eax, 7
	jmp	$done$128
$LN118@xmlSchemaV:

; 1648 : 
; 1649 :                     goto error;
; 1650 :                 }
; 1651 :             }
; 1652 : 
; 1653 :             /*
; 1654 :              * not xs:gMonthDay so rewind and check if just xs:gMonth
; 1655 :              * with an optional time zone.
; 1656 :              */
; 1657 :             cur = rewnd;

	lea	ebx, DWORD PTR [edi+8]
$LN24@xmlSchemaV:
	mov	DWORD PTR _cur$[ebp], esi
$LN21@xmlSchemaV:

; 1658 :         }
; 1659 : 
; 1660 : 	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN30@xmlSchemaV
	cmp	al, 90					; 0000005aH
	je	SHORT $LN30@xmlSchemaV
	cmp	al, 43					; 0000002bH
	je	SHORT $LN30@xmlSchemaV
	cmp	al, 45					; 0000002dH
	jne	$error$127
$LN30@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	ebx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	jne	$error$127
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 6
	mov	eax, 6
	jmp	$done$128
$LN12@xmlSchemaV:

; 1661 : 
; 1662 : 	goto error;
; 1663 :     }
; 1664 : 
; 1665 :     /*
; 1666 :      * It's a right-truncated date or an xs:time.
; 1667 :      * Try to parse an xs:time then fallback on right-truncated dates.
; 1668 :      */
; 1669 :     if ((*cur >= '0') && (*cur <= '9')) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LN37@xmlSchemaV
	cmp	al, 57					; 00000039H
	ja	SHORT $LN37@xmlSchemaV

; 1670 : 	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	lea	esi, DWORD PTR [edi+8]
	push	esi
	call	__xmlSchemaParseTime
	add	esp, 8

; 1671 : 	if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN37@xmlSchemaV

; 1672 : 	    /* it's an xs:time */
; 1673 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [eax]
	test	al, al
	je	SHORT $LN36@xmlSchemaV
	cmp	al, 90					; 0000005aH
	je	SHORT $LN36@xmlSchemaV
	cmp	al, 43					; 0000002bH
	je	SHORT $LN36@xmlSchemaV
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN37@xmlSchemaV
$LN36@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN37@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 4
	mov	eax, 4
	jmp	$done$128
$LN37@xmlSchemaV:

; 1214 : 	(*cur != '-') && (*cur != '+'))

	mov	eax, DWORD PTR _dateTime$[ebp]

; 1674 : 	}
; 1675 :     }
; 1676 : 
; 1677 :     /* fallback on date parsing */
; 1678 :     cur = dateTime;
; 1679 : 
; 1680 :     ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);

	lea	esi, DWORD PTR [edi+8]

; 1211 :     int isneg = 0, digcnt = 0;

	xor	ecx, ecx
	mov	DWORD PTR _digcnt$1$[ebp], ecx

; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))

	mov	bh, BYTE PTR [eax]
	cmp	bh, 48					; 00000030H
	jb	SHORT $LN92@xmlSchemaV
	cmp	bh, 57					; 00000039H
	jbe	SHORT $LN91@xmlSchemaV
$LN92@xmlSchemaV:
	cmp	bh, 45					; 0000002dH
	je	SHORT $LN91@xmlSchemaV
	cmp	bh, 43					; 0000002bH
	jne	$error$127
$LN91@xmlSchemaV:

; 1215 : 	return -1;
; 1216 : 
; 1217 :     if (*cur == '-') {
; 1218 : 	isneg = 1;
; 1219 : 	cur++;
; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;

	cmp	bh, 45					; 0000002dH
	lea	edx, DWORD PTR [eax+1]
	cmovne	edx, eax
	mov	DWORD PTR _firstChar$1$[ebp], edx

; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {

	mov	bl, BYTE PTR [edx]
	cmp	bl, 48					; 00000030H
	jb	$error$127
$LL89@xmlSchemaV:
	cmp	bl, 57					; 00000039H
	ja	SHORT $LN112@xmlSchemaV

; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');

	mov	eax, DWORD PTR [esi]

; 1226 : 	cur++;

	inc	edx
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, bl
	lea	eax, DWORD PTR [eax+ecx*2]

; 1227 : 	digcnt++;

	mov	ecx, DWORD PTR _digcnt$1$[ebp]
	add	eax, -48				; ffffffd0H
	inc	ecx
	mov	DWORD PTR [esi], eax
	mov	bl, BYTE PTR [edx]
	mov	DWORD PTR _digcnt$1$[ebp], ecx
	cmp	bl, 48					; 00000030H
	jae	SHORT $LL89@xmlSchemaV
$LN112@xmlSchemaV:

; 1228 :     }
; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))

	cmp	ecx, 4
	jl	$error$127
	jle	SHORT $LN94@xmlSchemaV
	mov	eax, DWORD PTR _firstChar$1$[ebp]
	cmp	BYTE PTR [eax], 48			; 00000030H
	je	$error$127
$LN94@xmlSchemaV:

; 1233 : 	return 1;
; 1234 : 
; 1235 :     if (isneg)

	mov	eax, DWORD PTR [esi]
	cmp	bh, 45					; 0000002dH
	jne	SHORT $LN106@xmlSchemaV

; 1236 : 	dt->year = - dt->year;

	neg	eax
	mov	DWORD PTR [esi], eax
$LN106@xmlSchemaV:

; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))

	test	eax, eax
	je	$error$127

; 1681 :     if (ret != 0)
; 1682 : 	goto error;
; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);

	mov	al, BYTE PTR [edx]

; 1241 :     *str = cur;

	mov	DWORD PTR _cur$[ebp], edx

; 1681 :     if (ret != 0)
; 1682 : 	goto error;
; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);

	test	al, al
	je	SHORT $LN41@xmlSchemaV
	cmp	al, 90					; 0000005aH
	je	SHORT $LN41@xmlSchemaV
	cmp	al, 43					; 0000002bH
	je	SHORT $LN41@xmlSchemaV
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN42@xmlSchemaV
$LN41@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN113@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 8
	mov	eax, 8
	jmp	$done$128
$LN113@xmlSchemaV:
	mov	edx, DWORD PTR _cur$[ebp]
$LN42@xmlSchemaV:

; 1686 : 
; 1687 :     if (*cur != '-')

	cmp	BYTE PTR [edx], 45			; 0000002dH
	jne	$error$127

; 1688 : 	goto error;
; 1689 :     cur++;
; 1690 : 
; 1691 :     ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	inc	edx
	push	eax
	push	esi
	mov	DWORD PTR _cur$[ebp], edx
	call	__xmlSchemaParseGMonth
	add	esp, 8

; 1692 :     if (ret != 0)

	test	eax, eax
	jne	$error$127

; 1693 : 	goto error;
; 1694 : 
; 1695 :     /* is it an xs:gYearMonth? */
; 1696 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [eax]
	test	al, al
	je	SHORT $LN47@xmlSchemaV
	cmp	al, 90					; 0000005aH
	je	SHORT $LN47@xmlSchemaV
	cmp	al, 43					; 0000002bH
	je	SHORT $LN47@xmlSchemaV
	cmp	al, 45					; 0000002dH
	jne	$error$127
$LN47@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _cur$[ebp]
	jne	SHORT $LN48@xmlSchemaV
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 9
	mov	eax, 9
	jmp	$done$128
$LN48@xmlSchemaV:

; 1697 : 
; 1698 :     if (*cur != '-')

	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	$error$127

; 1699 : 	goto error;
; 1700 :     cur++;

	inc	eax
	mov	DWORD PTR _cur$[ebp], eax

; 1701 : 
; 1702 :     ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseGDay
	add	esp, 8

; 1703 :     if ((ret != 0) || !VALID_DATE((&(dt->value.date))))

	test	eax, eax
	jne	$error$127
	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	$error$127
	mov	ecx, DWORD PTR [edi+12]
	mov	ebx, ecx
	and	ebx, 15					; 0000000fH
	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, 11					; 0000000bH
	ja	$error$127
	mov	eax, edx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN120@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN120@xmlSchemaV:
	mov	DWORD PTR tv1487[ebp], 400		; 00000190H
	mov	DWORD PTR tv1486[ebp], 100		; 00000064H
	jne	SHORT $LN79@xmlSchemaV
	mov	eax, edx
	cdq
	idiv	DWORD PTR tv1486[ebp]
	test	edx, edx
	jne	SHORT $LN80@xmlSchemaV
	mov	edx, DWORD PTR [esi]
$LN79@xmlSchemaV:
	mov	eax, edx
	cdq
	idiv	DWORD PTR tv1487[ebp]
	test	edx, edx
	je	SHORT $LN80@xmlSchemaV
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonth[ebx*4-4], ecx
	jmp	SHORT $LN123@xmlSchemaV
$LN80@xmlSchemaV:
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonthLeap[ebx*4-4], ecx
$LN123@xmlSchemaV:
	sbb	eax, eax
	inc	eax
	test	eax, eax
	je	$error$127

; 1704 : 	goto error;
; 1705 : 
; 1706 :     /* is it an xs:date? */
; 1707 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN55@xmlSchemaV
	cmp	cl, 90					; 0000005aH
	je	SHORT $LN55@xmlSchemaV
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN55@xmlSchemaV
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN56@xmlSchemaV
$LN55@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _cur$[ebp]
	jne	SHORT $LN56@xmlSchemaV
	cmp	BYTE PTR [eax], 0
	jne	$error$127
	mov	DWORD PTR [edi], 10			; 0000000aH
	mov	eax, 10					; 0000000aH
	jmp	$done$128
$LN56@xmlSchemaV:

; 1708 : 
; 1709 :     if (*cur != 'T')

	cmp	BYTE PTR [eax], 84			; 00000054H
	jne	$error$127

; 1710 : 	goto error;
; 1711 :     cur++;

	inc	eax
	mov	DWORD PTR _cur$[ebp], eax

; 1712 : 
; 1713 :     /* it should be an xs:dateTime */
; 1714 :     ret = _xmlSchemaParseTime(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTime
	add	esp, 8

; 1715 :     if (ret != 0)

	test	eax, eax
	jne	$error$127

; 1716 : 	goto error;
; 1717 : 
; 1718 :     ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	__xmlSchemaParseTimeZone

; 1719 :     if (collapse)

	mov	edx, DWORD PTR _cur$[ebp]
	add	esp, 8
	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN5@xmlSchemaV
	npad	5
$LL4@xmlSchemaV:

; 1720 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN61@xmlSchemaV
	cmp	cl, 9
	jb	SHORT $LN62@xmlSchemaV
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN61@xmlSchemaV
$LN62@xmlSchemaV:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN5@xmlSchemaV
$LN61@xmlSchemaV:
	inc	edx
	jmp	SHORT $LL4@xmlSchemaV
$LN5@xmlSchemaV:

; 1721 :     if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))

	test	eax, eax
	jne	$error$127
	cmp	BYTE PTR [edx], al
	jne	$error$127
	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	$error$127
	mov	ecx, DWORD PTR [edi+12]
	mov	esi, ecx
	and	esi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 11					; 0000000bH
	ja	$error$127
	mov	eax, ebx
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN121@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	add	eax, 1
$LN121@xmlSchemaV:
	jne	SHORT $LN82@xmlSchemaV
	mov	eax, ebx
	cdq
	idiv	DWORD PTR tv1486[ebp]
	test	edx, edx
	jne	SHORT $LN83@xmlSchemaV
$LN82@xmlSchemaV:
	mov	eax, ebx
	mov	ebx, 400				; 00000190H
	cdq
	idiv	ebx
	test	edx, edx
	je	SHORT $LN83@xmlSchemaV
	mov	eax, ecx
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonth[esi*4-4], eax
	jmp	SHORT $LN124@xmlSchemaV
$LN83@xmlSchemaV:
	mov	eax, ecx
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	DWORD PTR _daysInMonthLeap[esi*4-4], eax
$LN124@xmlSchemaV:
	sbb	eax, eax
	inc	eax
	test	eax, eax
	je	$error$127
	mov	edx, ecx
	and	edx, 15872				; 00003e00H
	cmp	edx, 11776				; 00002e00H
	ja	SHORT $LN69@xmlSchemaV
	mov	eax, ecx
	and	eax, 1032192				; 000fc000H
	cmp	eax, 966656				; 000ec000H
	ja	SHORT $LN69@xmlSchemaV
	movsd	xmm1, QWORD PTR [edi+16]
	comisd	xmm1, QWORD PTR __real@0000000000000000
	jb	SHORT $LN69@xmlSchemaV
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, xmm1
	ja	SHORT $LN67@xmlSchemaV
$LN69@xmlSchemaV:
	cmp	edx, 12288				; 00003000H
	jne	SHORT $error$127
	test	ecx, 1032192				; 000fc000H
	jne	SHORT $error$127
	movsd	xmm0, QWORD PTR [edi+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $error$127
$LN67@xmlSchemaV:
	mov	eax, DWORD PTR [edi+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	add	eax, 839				; 00000347H
	cmp	eax, 1678				; 0000068eH
	ja	SHORT $error$127

; 1722 : 	goto error;
; 1723 : 
; 1724 : 
; 1725 :     dt->type = XML_SCHEMAS_DATETIME;

	mov	DWORD PTR [edi], 11			; 0000000bH
	mov	eax, 11					; 0000000bH
$done$128:

; 1726 : 
; 1727 : done:
; 1728 : #if 1
; 1729 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))

	mov	ecx, DWORD PTR _type$[ebp]
	test	ecx, ecx
	je	SHORT $LN71@xmlSchemaV
	cmp	ecx, eax
	jne	SHORT $error$127
$LN71@xmlSchemaV:

; 1730 :         goto error;
; 1731 : #else
; 1732 :     /*
; 1733 :      * insure the parsed type is equal to or less significant (right
; 1734 :      * truncated) than the desired type.
; 1735 :      */
; 1736 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
; 1737 : 
; 1738 :         /* time only matches time */
; 1739 :         if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
; 1740 :             goto error;
; 1741 : 
; 1742 :         if ((type == XML_SCHEMAS_DATETIME) &&
; 1743 :             ((dt->type != XML_SCHEMAS_DATE) ||
; 1744 :              (dt->type != XML_SCHEMAS_GYEARMONTH) ||
; 1745 :              (dt->type != XML_SCHEMAS_GYEAR)))
; 1746 :             goto error;
; 1747 : 
; 1748 :         if ((type == XML_SCHEMAS_DATE) &&
; 1749 :             ((dt->type != XML_SCHEMAS_GYEAR) ||
; 1750 :              (dt->type != XML_SCHEMAS_GYEARMONTH)))
; 1751 :             goto error;
; 1752 : 
; 1753 :         if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
; 1754 :             goto error;
; 1755 : 
; 1756 :         if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
; 1757 :             goto error;
; 1758 :     }
; 1759 : #endif
; 1760 : 
; 1761 :     if (val != NULL)

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN72@xmlSchemaV

; 1762 :         *val = dt;

	mov	DWORD PTR [eax], edi

; 1765 : 
; 1766 :     return 0;

	xor	eax, eax
	pop	edi

; 1771 :     return 1;
; 1772 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlSchemaV:

; 1763 :     else
; 1764 : 	xmlSchemaFreeValue(dt);

	push	edi
	call	_xmlSchemaFreeValue
	add	esp, 4

; 1765 : 
; 1766 :     return 0;

	xor	eax, eax
	pop	edi

; 1771 :     return 1;
; 1772 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$error$127:

; 1767 : 
; 1768 : error:
; 1769 :     if (dt != NULL)
; 1770 : 	xmlSchemaFreeValue(dt);

	push	edi
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN125@xmlSchemaV:

; 1771 :     return 1;
; 1772 : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN110@xmlSchemaV:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValidateDates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaBase64Decode
_TEXT	SEGMENT
_ch$ = 8						; size = 1
__xmlSchemaBase64Decode PROC				; COMDAT

; 1485 : _xmlSchemaBase64Decode (const xmlChar ch) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	cl, BYTE PTR _ch$[ebp]
	lea	eax, DWORD PTR [ecx-65]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN2@xmlSchemaB

; 1486 :     if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';

	movzx	eax, cl
	sub	eax, 65					; 00000041H

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaB:

; 1487 :     if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;

	lea	eax, DWORD PTR [ecx-97]
	cmp	al, 25					; 00000019H
	ja	SHORT $LN3@xmlSchemaB
	movzx	eax, cl
	sub	eax, 71					; 00000047H

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaB:

; 1488 :     if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;

	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlSchemaB
	movzx	eax, cl
	add	eax, 4

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaB:

; 1489 :     if ('+' == ch) return 62;

	cmp	cl, 43					; 0000002bH
	jne	SHORT $LN5@xmlSchemaB
	mov	eax, 62					; 0000003eH

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaB:

; 1490 :     if ('/' == ch) return 63;

	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN6@xmlSchemaB
	mov	eax, 63					; 0000003fH

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaB:

; 1491 :     if ('=' == ch) return 64;

	or	eax, -1
	mov	edx, 64					; 00000040H
	cmp	cl, 61					; 0000003dH
	cmove	eax, edx

; 1492 :     return -1;
; 1493 : }

	pop	ebp
	ret	0
__xmlSchemaBase64Decode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseTimeZone
_TEXT	SEGMENT
tv520 = -2						; size = 1
tv511 = -1						; size = 1
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseTimeZone PROC				; COMDAT

; 1413 : _xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	xor	esi, esi
	test	eax, eax
	jne	SHORT $LN4@xmlSchemaP

; 1414 :     const xmlChar *cur;
; 1415 :     int ret = 0;
; 1416 : 
; 1417 :     if (str == NULL)
; 1418 : 	return -1;

	or	eax, -1
	pop	esi

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 1419 :     cur = *str;

	mov	edx, DWORD PTR [eax]
	push	ebx
	push	edi

; 1420 : 
; 1421 :     switch (*cur) {

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv520[ebp], al
	movzx	eax, al
	cmp	eax, 90					; 0000005aH
	ja	$LN24@xmlSchemaP
	movzx	eax, BYTE PTR $LN26@xmlSchemaP[eax]
	jmp	DWORD PTR $LN31@xmlSchemaP[eax*4]
$LN5@xmlSchemaP:

; 1422 :     case 0:
; 1423 : 	dt->tz_flag = 0;

	mov	eax, DWORD PTR _dt$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 1424 : 	dt->tzo = 0;

	and	DWORD PTR [eax+16], -8192		; ffffe000H

; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [eax], edx

; 1473 :     return 0;

	xor	eax, eax

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaP:

; 1425 : 	break;
; 1426 : 
; 1427 :     case 'Z':
; 1428 : 	dt->tz_flag = 1;

	mov	ecx, DWORD PTR _dt$[ebp]

; 1429 : 	dt->tzo = 0;
; 1430 : 	cur++;

	inc	edx
	pop	edi
	pop	ebx
	pop	esi
	mov	eax, DWORD PTR [ecx+16]
	and	eax, -8191				; ffffe001H
	or	eax, 1
	mov	DWORD PTR [ecx+16], eax

; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [eax], edx

; 1473 :     return 0;

	xor	eax, eax

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaP:

; 1431 : 	break;
; 1432 : 
; 1433 :     case '+':
; 1434 :     case '-': {
; 1435 : 	int isneg = 0, tmp = 0;
; 1436 : 	isneg = (*cur == '-');
; 1437 : 
; 1438 : 	cur++;
; 1439 : 
; 1440 : 	PARSE_2_DIGITS(tmp, cur, ret);

	mov	bl, BYTE PTR [edx+1]
	xor	ecx, ecx
	mov	al, bl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN10@xmlSchemaP
	mov	bh, BYTE PTR [edx+2]
	mov	al, bh
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN10@xmlSchemaP
	movzx	eax, bl
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, bh
	lea	ecx, DWORD PTR [ecx-264]
	lea	ecx, DWORD PTR [eax+ecx*2]
	jmp	SHORT $LN9@xmlSchemaP
$LN10@xmlSchemaP:
	mov	esi, 1
$LN9@xmlSchemaP:

; 1441 : 	if (ret != 0)

	test	esi, esi
	jne	SHORT $LN29@xmlSchemaP

; 1442 : 	    return ret;
; 1443 : 	if (!VALID_HOUR(tmp))

	cmp	ecx, 23					; 00000017H
	ja	$LN13@xmlSchemaP

; 1445 : 
; 1446 : 	if (*cur != ':')

	cmp	BYTE PTR [edx+3], 58			; 0000003aH
	jne	$LN24@xmlSchemaP

; 1447 : 	    return 1;
; 1448 : 	cur++;
; 1449 : 
; 1450 : 	dt->tzo = tmp * 60;

	mov	ebx, DWORD PTR _dt$[ebp]
	mov	edi, ecx
	shl	edi, 4
	sub	edi, ecx
	shl	edi, 3
	xor	edi, DWORD PTR [ebx+16]
	and	edi, 8190				; 00001ffeH
	xor	edi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+16], edi

; 1451 : 
; 1452 : 	PARSE_2_DIGITS(tmp, cur, ret);

	mov	ah, BYTE PTR [edx+4]
	mov	al, ah
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN17@xmlSchemaP
	mov	al, BYTE PTR [edx+5]
	mov	BYTE PTR tv511[ebp], al
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN17@xmlSchemaP
	movzx	eax, ah
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR tv511[ebp]
	lea	ecx, DWORD PTR [ecx-264]
	lea	ecx, DWORD PTR [eax+ecx*2]
	jmp	SHORT $LN16@xmlSchemaP
$LN17@xmlSchemaP:
	mov	esi, 1
$LN16@xmlSchemaP:
	add	edx, 6

; 1453 : 	if (ret != 0)

	test	esi, esi
	je	SHORT $LN18@xmlSchemaP
$LN29@xmlSchemaP:
	pop	edi
	pop	ebx

; 1454 : 	    return ret;

	mov	eax, esi
	pop	esi

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemaP:

; 1455 : 	if (!VALID_MIN(tmp))

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN13@xmlSchemaP

; 1456 : 	    return 2;
; 1457 : 
; 1458 : 	dt->tzo += tmp;

	mov	eax, edi
	and	eax, -2					; fffffffeH
	lea	ecx, DWORD PTR [eax+ecx*2]
	xor	ecx, edi
	and	ecx, 8190				; 00001ffeH
	xor	ecx, edi

; 1459 : 	if (isneg)

	cmp	BYTE PTR tv520[ebp], 45			; 0000002dH
	mov	DWORD PTR [ebx+16], ecx
	jne	SHORT $LN21@xmlSchemaP

; 1460 : 	    dt->tzo = - dt->tzo;

	mov	eax, ecx
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	neg	eax
	add	eax, eax
	xor	eax, ecx
	and	eax, 8190				; 00001ffeH
	xor	eax, ecx
	mov	DWORD PTR [ebx+16], eax
	mov	ecx, eax
$LN21@xmlSchemaP:

; 1461 : 
; 1462 : 	if (!VALID_TZO(dt->tzo))

	mov	eax, ecx
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	add	eax, 839				; 00000347H
	cmp	eax, 1678				; 0000068eH
	ja	SHORT $LN13@xmlSchemaP

; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	or	ecx, 1
	pop	edi
	mov	DWORD PTR [ebx+16], ecx
	pop	ebx
	mov	DWORD PTR [eax], edx

; 1473 :     return 0;

	xor	eax, eax
	pop	esi

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSchemaP:
	pop	edi
	pop	ebx

; 1444 : 	    return 2;

	mov	eax, 2
	pop	esi

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlSchemaP:
	pop	edi
	pop	ebx

; 1463 : 	    return 2;
; 1464 : 
; 1465 : 	dt->tz_flag = 1;
; 1466 : 	break;
; 1467 :       }
; 1468 :     default:
; 1469 : 	return 1;

	mov	eax, 1
	pop	esi

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN31@xmlSchemaP:
	DD	$LN5@xmlSchemaP
	DD	$LN7@xmlSchemaP
	DD	$LN6@xmlSchemaP
	DD	$LN24@xmlSchemaP
$LN26@xmlSchemaP:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
__xmlSchemaParseTimeZone ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseTime
_TEXT	SEGMENT
tv622 = -8						; size = 4
tv614 = -1						; size = 1
tv613 = -1						; size = 1
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseTime PROC				; COMDAT

; 1362 : _xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _str$[ebp]
	xor	edi, edi
	xor	esi, esi
	mov	edx, DWORD PTR [edx]
	mov	cl, BYTE PTR [edx]
	mov	al, cl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN6@xmlSchemaP

; 1363 :     const xmlChar *cur = *str;
; 1364 :     int ret = 0;
; 1365 :     int value = 0;
; 1366 : 
; 1367 :     PARSE_2_DIGITS(value, cur, ret);

	mov	bl, BYTE PTR [edx+1]
	mov	al, bl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN6@xmlSchemaP
	movzx	eax, cl
	lea	esi, DWORD PTR [eax+eax*4]
	movzx	eax, bl
	lea	esi, DWORD PTR [esi-264]
	lea	esi, DWORD PTR [eax+esi*2]
	jmp	SHORT $LN5@xmlSchemaP
$LN6@xmlSchemaP:
	mov	edi, 1
$LN5@xmlSchemaP:

; 1368 :     if (ret != 0)

	test	edi, edi
	je	SHORT $LN7@xmlSchemaP
$LN39@xmlSchemaP:

; 1398 :     return 0;
; 1399 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaP:

; 1369 : 	return ret;
; 1370 :     if (*cur != ':')

	cmp	BYTE PTR [edx+2], 58			; 0000003aH
	jne	$LN37@xmlSchemaP

; 1371 : 	return 1;
; 1372 :     if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)

	test	esi, esi
	js	SHORT $LN10@xmlSchemaP
	cmp	esi, 23					; 00000017H
	jle	SHORT $LN9@xmlSchemaP
$LN10@xmlSchemaP:
	cmp	esi, 24					; 00000018H
	jne	$LN16@xmlSchemaP
$LN9@xmlSchemaP:

; 1373 : 	return 2;
; 1374 :     cur++;
; 1375 : 
; 1376 :     /* the ':' insures this string is xs:time */
; 1377 :     dt->hour = value;

	mov	ebx, DWORD PTR _dt$[ebp]
	mov	ecx, esi
	shl	ecx, 9
	xor	ecx, DWORD PTR [ebx+4]
	and	ecx, 15872				; 00003e00H
	xor	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx+4], ecx

; 1378 : 
; 1379 :     PARSE_2_DIGITS(value, cur, ret);

	mov	ah, BYTE PTR [edx+3]
	mov	al, ah
	mov	DWORD PTR tv622[ebp], ecx
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN13@xmlSchemaP
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR tv614[ebp], al
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN13@xmlSchemaP
	movzx	eax, ah
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR tv614[ebp]
	lea	ecx, DWORD PTR [ecx-264]
	lea	esi, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR tv622[ebp]
	jmp	SHORT $LN12@xmlSchemaP
$LN13@xmlSchemaP:
	mov	edi, 1
$LN12@xmlSchemaP:

; 1380 :     if (ret != 0)

	test	edi, edi
	jne	SHORT $LN39@xmlSchemaP

; 1381 : 	return ret;
; 1382 :     if (!VALID_MIN(value))

	cmp	esi, 59					; 0000003bH
	ja	$LN16@xmlSchemaP

; 1383 : 	return 2;
; 1384 :     dt->min = value;

	shl	esi, 14					; 0000000eH
	xor	esi, ecx
	and	esi, 1032192				; 000fc000H
	xor	esi, ecx
	mov	DWORD PTR [ebx+4], esi

; 1385 : 
; 1386 :     if (*cur != ':')

	cmp	BYTE PTR [edx+5], 58			; 0000003aH
	jne	$LN37@xmlSchemaP

; 1387 : 	return 1;
; 1388 :     cur++;
; 1389 : 
; 1390 :     PARSE_FLOAT(dt->sec, cur, ret);

	mov	cl, BYTE PTR [edx+6]
	mov	al, cl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN20@xmlSchemaP
	mov	al, BYTE PTR [edx+7]
	mov	BYTE PTR tv613[ebp], al
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN20@xmlSchemaP
	movzx	eax, cl
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR tv613[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -528				; fffffdf0H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [ebx+8], xmm0
	jmp	SHORT $LN19@xmlSchemaP
$LN20@xmlSchemaP:
	mov	edi, 1
$LN19@xmlSchemaP:
	add	edx, 8
	test	edi, edi
	jne	$LN39@xmlSchemaP
	cmp	BYTE PTR [edx], 46			; 0000002eH
	jne	SHORT $LN24@xmlSchemaP
	mov	al, BYTE PTR [edx+1]
	inc	edx
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	cmp	al, 48					; 00000030H
	jb	SHORT $LN23@xmlSchemaP
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN32@xmlSchemaP
$LN23@xmlSchemaP:
	mov	edi, 1
$LN32@xmlSchemaP:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN38@xmlSchemaP
$LL2@xmlSchemaP:
	cmp	al, 57					; 00000039H
	ja	SHORT $LN38@xmlSchemaP
	divsd	xmm1, QWORD PTR __real@4024000000000000
	movzx	eax, al
	inc	edx
	sub	eax, 48					; 00000030H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [ebx+8]
	movsd	QWORD PTR [ebx+8], xmm0
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jae	SHORT $LL2@xmlSchemaP
$LN38@xmlSchemaP:

; 1391 :     if (ret != 0)

	test	edi, edi
	jne	$LN39@xmlSchemaP
$LN24@xmlSchemaP:

; 1392 : 	return ret;
; 1393 : 
; 1394 :     if (!VALID_TIME(dt))

	mov	ecx, esi
	and	ecx, 15872				; 00003e00H
	cmp	ecx, 11776				; 00002e00H
	ja	SHORT $LN29@xmlSchemaP
	mov	eax, esi
	and	eax, 1032192				; 000fc000H
	cmp	eax, 966656				; 000ec000H
	ja	SHORT $LN29@xmlSchemaP
	movsd	xmm1, QWORD PTR [ebx+8]
	comisd	xmm1, QWORD PTR __real@0000000000000000
	jb	SHORT $LN29@xmlSchemaP
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, xmm1
	ja	SHORT $LN27@xmlSchemaP
$LN29@xmlSchemaP:
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN16@xmlSchemaP
	test	esi, 1032192				; 000fc000H
	jne	SHORT $LN16@xmlSchemaP
	movsd	xmm0, QWORD PTR [ebx+8]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@xmlSchemaP
$LN27@xmlSchemaP:
	mov	eax, DWORD PTR [ebx+16]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	add	eax, 839				; 00000347H
	cmp	eax, 1678				; 0000068eH
	ja	SHORT $LN16@xmlSchemaP

; 1395 : 	return 2;
; 1396 : 
; 1397 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	pop	edi

; 1398 :     return 0;
; 1399 : }

	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], edx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlSchemaP:
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlSchemaP:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGDay
_TEXT	SEGMENT
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGDay PROC				; COMDAT

; 1332 : _xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR [edx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlSchemaP

; 1333 :     const xmlChar *cur = *str;
; 1334 :     int ret = 0;
; 1335 :     unsigned int value = 0;
; 1336 : 
; 1337 :     PARSE_2_DIGITS(value, cur, ret);

	mov	bl, BYTE PTR [edx+1]
	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlSchemaP
	movzx	eax, cl
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, bl
	lea	ecx, DWORD PTR [ecx-264]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 1340 : 
; 1341 :     if (!VALID_DAY(value))

	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 30					; 0000001eH
	ja	SHORT $LN7@xmlSchemaP

; 1343 : 
; 1344 :     dt->day = value;

	mov	eax, DWORD PTR _dt$[ebp]
	shl	ecx, 4
	xor	ecx, DWORD PTR [eax+4]
	and	ecx, 496				; 000001f0H
	xor	DWORD PTR [eax+4], ecx
	lea	eax, DWORD PTR [edx+2]

; 1345 :     *str = cur;

	mov	DWORD PTR [esi], eax

; 1346 :     return 0;

	xor	eax, eax
	pop	esi

; 1347 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemaP:
	pop	esi

; 1342 : 	return 2;

	mov	eax, 2

; 1347 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaP:
	pop	esi

; 1338 :     if (ret != 0)
; 1339 : 	return ret;

	mov	eax, 1

; 1347 : }

	pop	ebx
	pop	ebp
	ret	0
__xmlSchemaParseGDay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGMonth
_TEXT	SEGMENT
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGMonth PROC				; COMDAT

; 1302 : _xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR [edx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlSchemaP

; 1303 :     const xmlChar *cur = *str;
; 1304 :     int ret = 0;
; 1305 :     unsigned int value = 0;
; 1306 : 
; 1307 :     PARSE_2_DIGITS(value, cur, ret);

	mov	bl, BYTE PTR [edx+1]
	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlSchemaP
	movzx	eax, cl
	push	edi
	lea	edi, DWORD PTR [eax+eax*4]
	movzx	eax, bl
	lea	edi, DWORD PTR [edi-264]
	lea	edi, DWORD PTR [eax+edi*2]

; 1310 : 
; 1311 :     if (!VALID_MONTH(value))

	lea	eax, DWORD PTR [edi-1]
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN7@xmlSchemaP

; 1313 : 
; 1314 :     dt->mon = value;

	mov	ecx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	eax, edi
	and	eax, 15					; 0000000fH
	xor	DWORD PTR [ecx+4], eax
	lea	eax, DWORD PTR [edx+2]
	pop	edi

; 1315 : 
; 1316 :     *str = cur;

	mov	DWORD PTR [esi], eax

; 1317 :     return 0;

	xor	eax, eax
	pop	esi

; 1318 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemaP:
	pop	edi
	pop	esi

; 1312 : 	return 2;

	mov	eax, 2

; 1318 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemaP:
	pop	esi

; 1308 :     if (ret != 0)
; 1309 : 	return ret;

	mov	eax, 1

; 1318 : }

	pop	ebx
	pop	ebp
	ret	0
__xmlSchemaParseGMonth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGYear
_TEXT	SEGMENT
_firstChar$1$ = -8					; size = 4
_isneg$1$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGYear PROC				; COMDAT

; 1209 : _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _dt$[ebp]
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _str$[ebp]
	xor	edi, edi
	mov	DWORD PTR _isneg$1$[ebp], 0
	mov	ecx, DWORD PTR [ecx]
	mov	al, BYTE PTR [ecx]
	cmp	al, 48					; 00000030H
	jb	SHORT $LN5@xmlSchemaP

; 1210 :     const xmlChar *cur = *str, *firstChar;
; 1211 :     int isneg = 0, digcnt = 0;
; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))

	cmp	al, 57					; 00000039H
	jbe	SHORT $LN4@xmlSchemaP
$LN5@xmlSchemaP:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN4@xmlSchemaP
	cmp	al, 43					; 0000002bH
	je	SHORT $LN4@xmlSchemaP

; 1215 : 	return -1;

	pop	edi
	mov	eax, -1

; 1243 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSchemaP:

; 1216 : 
; 1217 :     if (*cur == '-') {

	mov	dl, al
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN6@xmlSchemaP

; 1218 : 	isneg = 1;
; 1219 : 	cur++;

	mov	dl, BYTE PTR [ecx+1]
	mov	DWORD PTR _isneg$1$[ebp], 1
$LN6@xmlSchemaP:

; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;

	push	esi
	lea	esi, DWORD PTR [ecx+1]
	cmovne	esi, ecx
	mov	DWORD PTR _firstChar$1$[ebp], esi

; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {

	cmp	dl, 48					; 00000030H
	jb	SHORT $LN8@xmlSchemaP
	npad	1
$LL2@xmlSchemaP:
	cmp	dl, 57					; 00000039H
	ja	SHORT $LN17@xmlSchemaP

; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');

	mov	eax, DWORD PTR [ebx]

; 1226 : 	cur++;

	inc	esi

; 1227 : 	digcnt++;

	inc	edi
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, dl
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	mov	DWORD PTR [ebx], eax
	mov	dl, BYTE PTR [esi]
	cmp	dl, 48					; 00000030H
	jae	SHORT $LL2@xmlSchemaP
$LN17@xmlSchemaP:

; 1228 :     }
; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))

	cmp	edi, 4
	jl	SHORT $LN8@xmlSchemaP
	jle	SHORT $LN7@xmlSchemaP
	mov	eax, DWORD PTR _firstChar$1$[ebp]
	cmp	BYTE PTR [eax], 48			; 00000030H
	je	SHORT $LN8@xmlSchemaP
$LN7@xmlSchemaP:

; 1234 : 
; 1235 :     if (isneg)

	cmp	DWORD PTR _isneg$1$[ebp], 0
	mov	eax, DWORD PTR [ebx]
	je	SHORT $LN15@xmlSchemaP

; 1236 : 	dt->year = - dt->year;

	neg	eax
	mov	DWORD PTR [ebx], eax
$LN15@xmlSchemaP:

; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))

	test	eax, eax
	jne	SHORT $LN10@xmlSchemaP

; 1239 : 	return 2;

	pop	esi
	pop	edi
	mov	eax, 2

; 1243 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSchemaP:

; 1240 : 
; 1241 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [eax], esi

; 1242 :     return 0;

	xor	eax, eax
	pop	esi
	pop	edi

; 1243 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlSchemaP:
	pop	esi
	pop	edi

; 1233 : 	return 1;

	mov	eax, 1

; 1243 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseGYear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaFreeTypeEntry
_TEXT	SEGMENT
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaFreeTypeEntry PROC				; COMDAT

; 623  : xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaFreeType
	add	esp, 4

; 624  :     xmlSchemaFreeType((xmlSchemaTypePtr) type);
; 625  : }

	pop	ebp
	ret	0
_xmlSchemaFreeTypeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaAddParticle
_TEXT	SEGMENT
_xmlSchemaAddParticle PROC				; COMDAT
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaA

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 375  :     xmlSchemaParticlePtr ret = NULL;
; 376  : 
; 377  :     ret = (xmlSchemaParticlePtr)
; 378  : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 379  :     if (ret == NULL) {
; 380  : 	xmlSchemaTypeErrMemory(NULL, "allocating particle component");
; 381  : 	return (NULL);

	xor	eax, eax

; 387  :     return (ret);
; 388  : }

	ret	0
$LN2@xmlSchemaA:

; 382  :     }
; 383  :     memset(ret, 0, sizeof(xmlSchemaParticle));

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+24], 0

; 384  :     ret->type = XML_SCHEMA_TYPE_PARTICLE;

	mov	DWORD PTR [eax], 25			; 00000019H

; 385  :     ret->minOccurs = 1;

	mov	DWORD PTR [eax+16], 1

; 386  :     ret->maxOccurs = 1;

	mov	DWORD PTR [eax+20], 1

; 387  :     return (ret);
; 388  : }

	ret	0
_xmlSchemaAddParticle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaInitBasicType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_type$ = 12						; size = 4
_baseType$ = 16						; size = 4
_xmlSchemaInitBasicType PROC				; COMDAT

; 267  : 		       xmlSchemaTypePtr baseType) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN6@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 268  :     xmlSchemaTypePtr ret;
; 269  : 
; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
; 271  :     if (ret == NULL) {
; 272  :         xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");
; 273  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 331  : }

	pop	ebp
	ret	0
$LN6@xmlSchemaI:
	push	ebx

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {

	mov	ebx, DWORD PTR _type$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _baseType$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+64], eax
	lea	eax, DWORD PTR [ebx-1]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+52], 6
	cmp	eax, 43					; 0000002bH
	ja	SHORT $LN8@xmlSchemaI
	movzx	eax, BYTE PTR $LN22@xmlSchemaI[eax]
	jmp	DWORD PTR $LN26@xmlSchemaI[eax*4]
$LN7@xmlSchemaI:

; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;

	or	DWORD PTR [esi+48], 16384		; 00004000H
$LN8@xmlSchemaI:

; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {

	lea	eax, DWORD PTR [ebx-19]
	cmp	eax, 27					; 0000001bH
	ja	SHORT $LN11@xmlSchemaI
	movzx	eax, BYTE PTR $LN23@xmlSchemaI[eax]
	jmp	DWORD PTR $LN27@xmlSchemaI[eax*4]
$LN10@xmlSchemaI:

; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	or	DWORD PTR [esi+48], 64			; 00000040H
	push	edi

; 244  :     ret = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	edi, eax

; 245  :     if (ret == NULL) {

	test	edi, edi
	je	SHORT $LN24@xmlSchemaI

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN19@xmlSchemaI
$LN20@xmlSchemaI:
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 33			; 00000021H
$LN19@xmlSchemaI:

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	mov	DWORD PTR [edi+32], eax

; 250  :     if (ret->val == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlSchemaI

; 251  :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlSchemaI:

; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);
; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	mov	ecx, DWORD PTR [esi+8]
	xor	edi, edi
	or	DWORD PTR [esi+48], 134217728		; 08000000H
	mov	DWORD PTR [esi+68], edi
	pop	edi

; 322  : 	    break;

	jmp	SHORT $LN4@xmlSchemaI
$LN17@xmlSchemaI:

; 254  :     ret->val->value.decimal.lo = value;

	mov	DWORD PTR [eax+8], 1

; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);
; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [esi+48], 134217728		; 08000000H
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+68], edi
	pop	edi

; 322  : 	    break;

	jmp	SHORT $LN4@xmlSchemaI
$LN11@xmlSchemaI:

; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H
$LN4@xmlSchemaI:

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	ecx
	push	DWORD PTR _xmlSchemaTypesBank
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], ebx

; 330  :     return(ret);

	mov	eax, esi
	pop	ebx
	pop	esi

; 331  : }

	pop	ebp
	ret	0
	npad	1
$LN26@xmlSchemaI:
	DD	$LN7@xmlSchemaI
	DD	$LN8@xmlSchemaI
$LN22@xmlSchemaI:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
$LN27@xmlSchemaI:
	DD	$LN10@xmlSchemaI
	DD	$LN4@xmlSchemaI
	DD	$LN11@xmlSchemaI
$LN23@xmlSchemaI:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
_xmlSchemaInitBasicType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewMinLengthFacet
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaNewMinLengthFacet PROC			; COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlSchemaNewFacet
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN8@xmlSchemaN

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 242  :     xmlSchemaFacetPtr ret;
; 243  : 
; 244  :     ret = xmlSchemaNewFacet();
; 245  :     if (ret == NULL) {
; 246  :         return(NULL);
; 247  :     }
; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [esi], 1011			; 000003f3H

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaN
$LN6@xmlSchemaN:
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [ecx], 33			; 00000021H
$LN5@xmlSchemaN:

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	mov	DWORD PTR [esi+32], ecx

; 250  :     if (ret->val == NULL) {

	test	ecx, ecx
	jne	SHORT $LN3@xmlSchemaN

; 251  :         xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlSchemaN:

; 256  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemaN:

; 252  : 	return(NULL);
; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 255  :     return (ret);

	mov	eax, esi
	pop	esi

; 256  : }

	pop	ebp
	ret	0
_xmlSchemaNewMinLengthFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewValue
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaNewValue PROC					; COMDAT

; 227  : xmlSchemaNewValue(xmlSchemaValType type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@xmlSchemaN

; 237  : }

	pop	ebp
	ret	0
$LN2@xmlSchemaN:

; 228  :     xmlSchemaValPtr value;
; 229  : 
; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));
; 231  :     if (value == NULL) {
; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));
; 235  :     value->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx], eax

; 236  :     return(value);

	mov	eax, ecx

; 237  : }

	pop	ebp
	ret	0
_xmlSchemaNewValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaTypeErrMemory
_TEXT	SEGMENT
_node$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlSchemaTypeErrMemory PROC				; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);
; 210  : }

	pop	ebp
	ret	0
_xmlSchemaTypeErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetValType
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSchemaGetValType PROC				; COMDAT

; 6154 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaG

; 6158 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 6155 :     if (val == NULL)
; 6156 :         return(XML_SCHEMAS_UNKNOWN);
; 6157 :     return (val->type);

	mov	eax, DWORD PTR [eax]

; 6158 : }

	pop	ebp
	ret	0
_xmlSchemaGetValType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCopyValue
_TEXT	SEGMENT
_prev$1$ = -4						; size = 4
tv350 = 8						; size = 4
_val$ = 8						; size = 4
_xmlSchemaCopyValue PROC				; COMDAT

; 3690 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _prev$1$[ebp], ebx
	test	edi, edi
	je	$LN45@xmlSchemaC
$LL2@xmlSchemaC:

; 3691 :     xmlSchemaValPtr ret = NULL, prev = NULL, cur;
; 3692 : 
; 3693 :     /*
; 3694 :     * Copy the string values.
; 3695 :     */
; 3696 :     while (val != NULL) {
; 3697 : 	switch (val->type) {

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR tv350[ebp], eax
	dec	eax
	cmp	eax, 45					; 0000002dH
	ja	$LN16@xmlSchemaC
	movzx	eax, BYTE PTR $LN46@xmlSchemaC[eax]
	jmp	DWORD PTR $LN48@xmlSchemaC[eax*4]
$LN7@xmlSchemaC:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	esi, esi
	je	SHORT $LN42@xmlSchemaC

; 235  :     value->type = type;

	mov	eax, DWORD PTR tv350[ebp]
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [esi], eax

; 3675 :     memcpy(ret, v, sizeof(xmlSchemaVal));

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [edi+16]
	movups	XMMWORD PTR [esi+16], xmm0

; 3676 :     ret->next = NULL;

	mov	DWORD PTR [esi+4], 0

; 3677 :     return ret;

	jmp	SHORT $LN20@xmlSchemaC
$LN42@xmlSchemaC:

; 236  :     return(value);
; 237  : }
; 238  : 
; 239  : static xmlSchemaFacetPtr
; 240  : xmlSchemaNewMinLengthFacet(int value)
; 241  : {
; 242  :     xmlSchemaFacetPtr ret;
; 243  : 
; 244  :     ret = xmlSchemaNewFacet();
; 245  :     if (ret == NULL) {
; 246  :         return(NULL);
; 247  :     }
; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;
; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);
; 250  :     if (ret->val == NULL) {
; 251  :         xmlFree(ret);
; 252  : 	return(NULL);
; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;
; 255  :     return (ret);
; 256  : }
; 257  : 
; 258  : /*
; 259  :  * xmlSchemaInitBasicType:
; 260  :  * @name:  the type name
; 261  :  * @type:  the value type associated
; 262  :  *
; 263  :  * Initialize one primitive built-in type
; 264  :  */
; 265  : static xmlSchemaTypePtr
; 266  : xmlSchemaInitBasicType(const char *name, xmlSchemaValType type,
; 267  : 		       xmlSchemaTypePtr baseType) {
; 268  :     xmlSchemaTypePtr ret;
; 269  : 
; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
; 271  :     if (ret == NULL) {
; 272  :         xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");
; 273  : 	return(NULL);
; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));
; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);
; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;
; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;
; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,
; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;
; 330  :     return(ret);
; 331  : }
; 332  : 
; 333  : /*
; 334  : * WARNING: Those type reside normally in xmlschemas.c but are
; 335  : * redefined here locally in oder of being able to use them for xs:anyType-
; 336  : * TODO: Remove those definition if we move the types to a header file.
; 337  : * TODO: Always keep those structs up-to-date with the originals.
; 338  : */
; 339  : #define UNBOUNDED (1 << 30)
; 340  : 
; 341  : typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;
; 342  : typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;
; 343  : struct _xmlSchemaTreeItem {
; 344  :     xmlSchemaTypeType type;
; 345  :     xmlSchemaAnnotPtr annot;
; 346  :     xmlSchemaTreeItemPtr next;
; 347  :     xmlSchemaTreeItemPtr children;
; 348  : };
; 349  : 
; 350  : typedef struct _xmlSchemaParticle xmlSchemaParticle;
; 351  : typedef xmlSchemaParticle *xmlSchemaParticlePtr;
; 352  : struct _xmlSchemaParticle {
; 353  :     xmlSchemaTypeType type;
; 354  :     xmlSchemaAnnotPtr annot;
; 355  :     xmlSchemaTreeItemPtr next;
; 356  :     xmlSchemaTreeItemPtr children;
; 357  :     int minOccurs;
; 358  :     int maxOccurs;
; 359  :     xmlNodePtr node;
; 360  : };
; 361  : 
; 362  : typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;
; 363  : typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;
; 364  : struct _xmlSchemaModelGroup {
; 365  :     xmlSchemaTypeType type;
; 366  :     xmlSchemaAnnotPtr annot;
; 367  :     xmlSchemaTreeItemPtr next;
; 368  :     xmlSchemaTreeItemPtr children;
; 369  :     xmlNodePtr node;
; 370  : };
; 371  : 
; 372  : static xmlSchemaParticlePtr
; 373  : xmlSchemaAddParticle(void)
; 374  : {
; 375  :     xmlSchemaParticlePtr ret = NULL;
; 376  : 
; 377  :     ret = (xmlSchemaParticlePtr)
; 378  : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 379  :     if (ret == NULL) {
; 380  : 	xmlSchemaTypeErrMemory(NULL, "allocating particle component");
; 381  : 	return (NULL);
; 382  :     }
; 383  :     memset(ret, 0, sizeof(xmlSchemaParticle));
; 384  :     ret->type = XML_SCHEMA_TYPE_PARTICLE;
; 385  :     ret->minOccurs = 1;
; 386  :     ret->maxOccurs = 1;
; 387  :     return (ret);
; 388  : }
; 389  : 
; 390  : /*
; 391  :  * xmlSchemaInitTypes:
; 392  :  *
; 393  :  * Initialize the default XML Schemas type library
; 394  :  */
; 395  : void
; 396  : xmlSchemaInitTypes(void)
; 397  : {
; 398  :     if (xmlSchemaTypesInitialized != 0)
; 399  :         return;
; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);
; 401  : 
; 402  : 
; 403  :     /*
; 404  :     * 3.4.7 Built-in Complex Type Definition
; 405  :     */
; 406  :     xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",
; 407  :                                                      XML_SCHEMAS_ANYTYPE,
; 408  : 						     NULL);
; 409  :     xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;
; 410  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 411  :     /*
; 412  :     * Init the content type.
; 413  :     */
; 414  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 415  :     {
; 416  : 	xmlSchemaParticlePtr particle;
; 417  : 	xmlSchemaModelGroupPtr sequence;
; 418  : 	xmlSchemaWildcardPtr wild;
; 419  : 	/* First particle. */
; 420  : 	particle = xmlSchemaAddParticle();
; 421  : 	if (particle == NULL)
; 422  : 	    return;
; 423  : 	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;
; 424  : 	/* Sequence model group. */
; 425  : 	sequence = (xmlSchemaModelGroupPtr)
; 426  : 	    xmlMalloc(sizeof(xmlSchemaModelGroup));
; 427  : 	if (sequence == NULL) {
; 428  : 	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");
; 429  : 	    return;
; 430  : 	}
; 431  : 	memset(sequence, 0, sizeof(xmlSchemaModelGroup));
; 432  : 	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;
; 433  : 	particle->children = (xmlSchemaTreeItemPtr) sequence;
; 434  : 	/* Second particle. */
; 435  : 	particle = xmlSchemaAddParticle();
; 436  : 	if (particle == NULL)
; 437  : 	    return;
; 438  : 	particle->minOccurs = 0;
; 439  : 	particle->maxOccurs = UNBOUNDED;
; 440  : 	sequence->children = (xmlSchemaTreeItemPtr) particle;
; 441  : 	/* The wildcard */
; 442  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 443  : 	if (wild == NULL) {
; 444  : 	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");
; 445  : 	    return;
; 446  : 	}
; 447  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 448  : 	wild->type = XML_SCHEMA_TYPE_ANY;
; 449  : 	wild->any = 1;
; 450  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 451  : 	particle->children = (xmlSchemaTreeItemPtr) wild;
; 452  : 	/*
; 453  : 	* Create the attribute wildcard.
; 454  : 	*/
; 455  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 456  : 	if (wild == NULL) {
; 457  : 	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "
; 458  : 		"wildcard on anyType");
; 459  : 	    return;
; 460  : 	}
; 461  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 462  : 	wild->any = 1;
; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;
; 465  :     }
; 466  :     xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",
; 467  :                                                            XML_SCHEMAS_ANYSIMPLETYPE,
; 468  : 							   xmlSchemaTypeAnyTypeDef);
; 469  :     /*
; 470  :     * primitive datatypes
; 471  :     */
; 472  :     xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",
; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",
; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",
; 479  :                                                   XML_SCHEMAS_DATE,
; 480  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 481  :     xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",
; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",
; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",
; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",
; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",
; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",
; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",
; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",
; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",
; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",
; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",
; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",
; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",
; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,
; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",
; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",
; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",
; 534  :                                                      XML_SCHEMAS_INTEGER,
; 535  : 						     xmlSchemaTypeDecimalDef);
; 536  :     xmlSchemaTypeNonPositiveIntegerDef =
; 537  :         xmlSchemaInitBasicType("nonPositiveInteger",
; 538  :                                XML_SCHEMAS_NPINTEGER,
; 539  : 			       xmlSchemaTypeIntegerDef);
; 540  :     xmlSchemaTypeNegativeIntegerDef =
; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =
; 544  :         xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
; 545  : 	xmlSchemaTypeIntegerDef);
; 546  :     xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,
; 547  : 	xmlSchemaTypeLongDef);
; 548  :     xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",
; 549  :                                                    XML_SCHEMAS_SHORT,
; 550  : 						   xmlSchemaTypeIntDef);
; 551  :     xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",
; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =
; 555  :         xmlSchemaInitBasicType("nonNegativeInteger",
; 556  :                                XML_SCHEMAS_NNINTEGER,
; 557  : 			       xmlSchemaTypeIntegerDef);
; 558  :     xmlSchemaTypeUnsignedLongDef =
; 559  :         xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
; 560  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 561  :     xmlSchemaTypeUnsignedIntDef =
; 562  :         xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
; 563  : 	xmlSchemaTypeUnsignedLongDef);
; 564  :     xmlSchemaTypeUnsignedShortDef =
; 565  :         xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
; 566  : 	xmlSchemaTypeUnsignedIntDef);
; 567  :     xmlSchemaTypeUnsignedByteDef =
; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =
; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",
; 574  :                                                         XML_SCHEMAS_NORMSTRING,
; 575  : 							xmlSchemaTypeStringDef);
; 576  :     xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",
; 577  :                                                    XML_SCHEMAS_TOKEN,
; 578  : 						   xmlSchemaTypeNormStringDef);
; 579  :     xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",
; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",
; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",
; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",
; 589  :                                                     XML_SCHEMAS_NCNAME,
; 590  : 						    xmlSchemaTypeNameDef);
; 591  :     xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,
; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",
; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",
; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",
; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;
; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",
; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;
; 612  : 
; 613  :     /* NMTOKENS */
; 614  :     xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",
; 615  :                                                       XML_SCHEMAS_NMTOKENS,
; 616  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 617  :     xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;
; 618  : 
; 619  :     xmlSchemaTypesInitialized = 1;
; 620  : }
; 621  : 
; 622  : static void
; 623  : xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {
; 624  :     xmlSchemaFreeType((xmlSchemaTypePtr) type);
; 625  : }
; 626  : 
; 627  : /**
; 628  :  * xmlSchemaCleanupTypes:
; 629  :  *
; 630  :  * Cleanup the default XML Schemas type library
; 631  :  */
; 632  : void
; 633  : xmlSchemaCleanupTypes(void) {
; 634  :     if (xmlSchemaTypesInitialized == 0)
; 635  : 	return;
; 636  :     /*
; 637  :     * Free xs:anyType.
; 638  :     */
; 639  :     {
; 640  : 	xmlSchemaParticlePtr particle;
; 641  : 	/* Attribute wildcard. */
; 642  : 	xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);
; 643  : 	/* Content type. */
; 644  : 	particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;
; 645  : 	/* Wildcard. */
; 646  : 	xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)
; 647  : 	    particle->children->children->children);
; 648  : 	xmlFree((xmlSchemaParticlePtr) particle->children->children);
; 649  : 	/* Sequence model group. */
; 650  : 	xmlFree((xmlSchemaModelGroupPtr) particle->children);
; 651  : 	xmlFree((xmlSchemaParticlePtr) particle);
; 652  : 	xmlSchemaTypeAnyTypeDef->subtypes = NULL;
; 653  :     }
; 654  :     xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);
; 655  :     xmlSchemaTypesInitialized = 0;
; 656  : }
; 657  : 
; 658  : /**
; 659  :  * xmlSchemaIsBuiltInTypeFacet:
; 660  :  * @type: the built-in type
; 661  :  * @facetType:  the facet type
; 662  :  *
; 663  :  * Evaluates if a specific facet can be
; 664  :  * used in conjunction with a type.
; 665  :  *
; 666  :  * Returns 1 if the facet can be used with the given built-in type,
; 667  :  * 0 otherwise and -1 in case the type is not a built-in type.
; 668  :  */
; 669  : int
; 670  : xmlSchemaIsBuiltInTypeFacet(xmlSchemaTypePtr type, int facetType)
; 671  : {
; 672  :     if (type == NULL)
; 673  : 	return (-1);
; 674  :     if (type->type != XML_SCHEMA_TYPE_BASIC)
; 675  : 	return (-1);
; 676  :     switch (type->builtInType) {
; 677  : 	case XML_SCHEMAS_BOOLEAN:
; 678  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 679  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 680  : 		return (1);
; 681  : 	    else
; 682  : 		return (0);
; 683  : 	case XML_SCHEMAS_STRING:
; 684  : 	case XML_SCHEMAS_NOTATION:
; 685  : 	case XML_SCHEMAS_QNAME:
; 686  : 	case XML_SCHEMAS_ANYURI:
; 687  : 	case XML_SCHEMAS_BASE64BINARY:
; 688  : 	case XML_SCHEMAS_HEXBINARY:
; 689  : 	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 690  : 		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
; 691  : 		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
; 692  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 693  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 694  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 695  : 		return (1);
; 696  : 	    else
; 697  : 		return (0);
; 698  : 	case XML_SCHEMAS_DECIMAL:
; 699  : 	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
; 700  : 		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
; 701  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 702  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 703  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 704  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 705  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 706  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 707  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 708  : 		return (1);
; 709  : 	    else
; 710  : 		return (0);
; 711  : 	case XML_SCHEMAS_TIME:
; 712  : 	case XML_SCHEMAS_GDAY:
; 713  : 	case XML_SCHEMAS_GMONTH:
; 714  : 	case XML_SCHEMAS_GMONTHDAY:
; 715  : 	case XML_SCHEMAS_GYEAR:
; 716  : 	case XML_SCHEMAS_GYEARMONTH:
; 717  : 	case XML_SCHEMAS_DATE:
; 718  : 	case XML_SCHEMAS_DATETIME:
; 719  : 	case XML_SCHEMAS_DURATION:
; 720  : 	case XML_SCHEMAS_FLOAT:
; 721  : 	case XML_SCHEMAS_DOUBLE:
; 722  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 723  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 724  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 725  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 726  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 727  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 728  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 729  : 		return (1);
; 730  : 	    else
; 731  : 		return (0);
; 732  : 	default:
; 733  : 	    break;
; 734  :     }
; 735  :     return (0);
; 736  : }
; 737  : 
; 738  : /**
; 739  :  * xmlSchemaGetBuiltInType:
; 740  :  * @type:  the type of the built in type
; 741  :  *
; 742  :  * Gives you the type struct for a built-in
; 743  :  * type by its type id.
; 744  :  *
; 745  :  * Returns the type if found, NULL otherwise.
; 746  :  */
; 747  : xmlSchemaTypePtr
; 748  : xmlSchemaGetBuiltInType(xmlSchemaValType type)
; 749  : {
; 750  :     if (xmlSchemaTypesInitialized == 0)
; 751  : 	xmlSchemaInitTypes();
; 752  :     switch (type) {
; 753  : 
; 754  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 755  : 	    return (xmlSchemaTypeAnySimpleTypeDef);
; 756  : 	case XML_SCHEMAS_STRING:
; 757  : 	    return (xmlSchemaTypeStringDef);
; 758  : 	case XML_SCHEMAS_NORMSTRING:
; 759  : 	    return (xmlSchemaTypeNormStringDef);
; 760  : 	case XML_SCHEMAS_DECIMAL:
; 761  : 	    return (xmlSchemaTypeDecimalDef);
; 762  : 	case XML_SCHEMAS_TIME:
; 763  : 	    return (xmlSchemaTypeTimeDef);
; 764  : 	case XML_SCHEMAS_GDAY:
; 765  : 	    return (xmlSchemaTypeGDayDef);
; 766  : 	case XML_SCHEMAS_GMONTH:
; 767  : 	    return (xmlSchemaTypeGMonthDef);
; 768  : 	case XML_SCHEMAS_GMONTHDAY:
; 769  : 	    return (xmlSchemaTypeGMonthDayDef);
; 770  : 	case XML_SCHEMAS_GYEAR:
; 771  : 	    return (xmlSchemaTypeGYearDef);
; 772  : 	case XML_SCHEMAS_GYEARMONTH:
; 773  : 	    return (xmlSchemaTypeGYearMonthDef);
; 774  : 	case XML_SCHEMAS_DATE:
; 775  : 	    return (xmlSchemaTypeDateDef);
; 776  : 	case XML_SCHEMAS_DATETIME:
; 777  : 	    return (xmlSchemaTypeDatetimeDef);
; 778  : 	case XML_SCHEMAS_DURATION:
; 779  : 	    return (xmlSchemaTypeDurationDef);
; 780  : 	case XML_SCHEMAS_FLOAT:
; 781  : 	    return (xmlSchemaTypeFloatDef);
; 782  : 	case XML_SCHEMAS_DOUBLE:
; 783  : 	    return (xmlSchemaTypeDoubleDef);
; 784  : 	case XML_SCHEMAS_BOOLEAN:
; 785  : 	    return (xmlSchemaTypeBooleanDef);
; 786  : 	case XML_SCHEMAS_TOKEN:
; 787  : 	    return (xmlSchemaTypeTokenDef);
; 788  : 	case XML_SCHEMAS_LANGUAGE:
; 789  : 	    return (xmlSchemaTypeLanguageDef);
; 790  : 	case XML_SCHEMAS_NMTOKEN:
; 791  : 	    return (xmlSchemaTypeNmtokenDef);
; 792  : 	case XML_SCHEMAS_NMTOKENS:
; 793  : 	    return (xmlSchemaTypeNmtokensDef);
; 794  : 	case XML_SCHEMAS_NAME:
; 795  : 	    return (xmlSchemaTypeNameDef);
; 796  : 	case XML_SCHEMAS_QNAME:
; 797  : 	    return (xmlSchemaTypeQNameDef);
; 798  : 	case XML_SCHEMAS_NCNAME:
; 799  : 	    return (xmlSchemaTypeNCNameDef);
; 800  : 	case XML_SCHEMAS_ID:
; 801  : 	    return (xmlSchemaTypeIdDef);
; 802  : 	case XML_SCHEMAS_IDREF:
; 803  : 	    return (xmlSchemaTypeIdrefDef);
; 804  : 	case XML_SCHEMAS_IDREFS:
; 805  : 	    return (xmlSchemaTypeIdrefsDef);
; 806  : 	case XML_SCHEMAS_ENTITY:
; 807  : 	    return (xmlSchemaTypeEntityDef);
; 808  : 	case XML_SCHEMAS_ENTITIES:
; 809  : 	    return (xmlSchemaTypeEntitiesDef);
; 810  : 	case XML_SCHEMAS_NOTATION:
; 811  : 	    return (xmlSchemaTypeNotationDef);
; 812  : 	case XML_SCHEMAS_ANYURI:
; 813  : 	    return (xmlSchemaTypeAnyURIDef);
; 814  : 	case XML_SCHEMAS_INTEGER:
; 815  : 	    return (xmlSchemaTypeIntegerDef);
; 816  : 	case XML_SCHEMAS_NPINTEGER:
; 817  : 	    return (xmlSchemaTypeNonPositiveIntegerDef);
; 818  : 	case XML_SCHEMAS_NINTEGER:
; 819  : 	    return (xmlSchemaTypeNegativeIntegerDef);
; 820  : 	case XML_SCHEMAS_NNINTEGER:
; 821  : 	    return (xmlSchemaTypeNonNegativeIntegerDef);
; 822  : 	case XML_SCHEMAS_PINTEGER:
; 823  : 	    return (xmlSchemaTypePositiveIntegerDef);
; 824  : 	case XML_SCHEMAS_INT:
; 825  : 	    return (xmlSchemaTypeIntDef);
; 826  : 	case XML_SCHEMAS_UINT:
; 827  : 	    return (xmlSchemaTypeUnsignedIntDef);
; 828  : 	case XML_SCHEMAS_LONG:
; 829  : 	    return (xmlSchemaTypeLongDef);
; 830  : 	case XML_SCHEMAS_ULONG:
; 831  : 	    return (xmlSchemaTypeUnsignedLongDef);
; 832  : 	case XML_SCHEMAS_SHORT:
; 833  : 	    return (xmlSchemaTypeShortDef);
; 834  : 	case XML_SCHEMAS_USHORT:
; 835  : 	    return (xmlSchemaTypeUnsignedShortDef);
; 836  : 	case XML_SCHEMAS_BYTE:
; 837  : 	    return (xmlSchemaTypeByteDef);
; 838  : 	case XML_SCHEMAS_UBYTE:
; 839  : 	    return (xmlSchemaTypeUnsignedByteDef);
; 840  : 	case XML_SCHEMAS_HEXBINARY:
; 841  : 	    return (xmlSchemaTypeHexBinaryDef);
; 842  : 	case XML_SCHEMAS_BASE64BINARY:
; 843  : 	    return (xmlSchemaTypeBase64BinaryDef);
; 844  : 	case XML_SCHEMAS_ANYTYPE:
; 845  : 	    return (xmlSchemaTypeAnyTypeDef);
; 846  : 	default:
; 847  : 	    return (NULL);
; 848  :     }
; 849  : }
; 850  : 
; 851  : /**
; 852  :  * xmlSchemaValueAppend:
; 853  :  * @prev: the value
; 854  :  * @cur: the value to be appended
; 855  :  *
; 856  :  * Appends a next sibling to a list of computed values.
; 857  :  *
; 858  :  * Returns 0 if succeeded and -1 on API errors.
; 859  :  */
; 860  : int
; 861  : xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {
; 862  : 
; 863  :     if ((prev == NULL) || (cur == NULL))
; 864  : 	return (-1);
; 865  :     prev->next = cur;
; 866  :     return (0);
; 867  : }
; 868  : 
; 869  : /**
; 870  :  * xmlSchemaValueGetNext:
; 871  :  * @cur: the value
; 872  :  *
; 873  :  * Accessor for the next sibling of a list of computed values.
; 874  :  *
; 875  :  * Returns the next value or NULL if there was none, or on
; 876  :  *         API errors.
; 877  :  */
; 878  : xmlSchemaValPtr
; 879  : xmlSchemaValueGetNext(xmlSchemaValPtr cur) {
; 880  : 
; 881  :     if (cur == NULL)
; 882  : 	return (NULL);
; 883  :     return (cur->next);
; 884  : }
; 885  : 
; 886  : /**
; 887  :  * xmlSchemaValueGetAsString:
; 888  :  * @val: the value
; 889  :  *
; 890  :  * Accessor for the string value of a computed value.
; 891  :  *
; 892  :  * Returns the string value or NULL if there was none, or on
; 893  :  *         API errors.
; 894  :  */
; 895  : const xmlChar *
; 896  : xmlSchemaValueGetAsString(xmlSchemaValPtr val)
; 897  : {
; 898  :     if (val == NULL)
; 899  : 	return (NULL);
; 900  :     switch (val->type) {
; 901  : 	case XML_SCHEMAS_STRING:
; 902  : 	case XML_SCHEMAS_NORMSTRING:
; 903  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 904  : 	case XML_SCHEMAS_TOKEN:
; 905  :         case XML_SCHEMAS_LANGUAGE:
; 906  :         case XML_SCHEMAS_NMTOKEN:
; 907  :         case XML_SCHEMAS_NAME:
; 908  :         case XML_SCHEMAS_NCNAME:
; 909  :         case XML_SCHEMAS_ID:
; 910  :         case XML_SCHEMAS_IDREF:
; 911  :         case XML_SCHEMAS_ENTITY:
; 912  :         case XML_SCHEMAS_ANYURI:
; 913  : 	    return (BAD_CAST val->value.str);
; 914  : 	default:
; 915  : 	    break;
; 916  :     }
; 917  :     return (NULL);
; 918  : }
; 919  : 
; 920  : /**
; 921  :  * xmlSchemaValueGetAsBoolean:
; 922  :  * @val: the value
; 923  :  *
; 924  :  * Accessor for the boolean value of a computed value.
; 925  :  *
; 926  :  * Returns 1 if true and 0 if false, or in case of an error. Hmm.
; 927  :  */
; 928  : int
; 929  : xmlSchemaValueGetAsBoolean(xmlSchemaValPtr val)
; 930  : {
; 931  :     if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))
; 932  : 	return (0);
; 933  :     return (val->value.b);
; 934  : }
; 935  : 
; 936  : /**
; 937  :  * xmlSchemaNewStringValue:
; 938  :  * @type:  the value type
; 939  :  * @value:  the value
; 940  :  *
; 941  :  * Allocate a new simple type value. The type can be
; 942  :  * of XML_SCHEMAS_STRING.
; 943  :  * WARNING: This one is intended to be expanded for other
; 944  :  * string based types. We need this for anySimpleType as well.
; 945  :  * The given value is consumed and freed with the struct.
; 946  :  *
; 947  :  * Returns a pointer to the new value or NULL in case of error
; 948  :  */
; 949  : xmlSchemaValPtr
; 950  : xmlSchemaNewStringValue(xmlSchemaValType type,
; 951  : 			const xmlChar *value)
; 952  : {
; 953  :     xmlSchemaValPtr val;
; 954  : 
; 955  :     if (type != XML_SCHEMAS_STRING)
; 956  : 	return(NULL);
; 957  :     val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));
; 958  :     if (val == NULL) {
; 959  : 	return(NULL);
; 960  :     }
; 961  :     memset(val, 0, sizeof(xmlSchemaVal));
; 962  :     val->type = type;
; 963  :     val->value.str = (xmlChar *) value;
; 964  :     return(val);
; 965  : }
; 966  : 
; 967  : /**
; 968  :  * xmlSchemaNewNOTATIONValue:
; 969  :  * @name:  the notation name
; 970  :  * @ns: the notation namespace name or NULL
; 971  :  *
; 972  :  * Allocate a new NOTATION value.
; 973  :  * The given values are consumed and freed with the struct.
; 974  :  *
; 975  :  * Returns a pointer to the new value or NULL in case of error
; 976  :  */
; 977  : xmlSchemaValPtr
; 978  : xmlSchemaNewNOTATIONValue(const xmlChar *name,
; 979  : 			  const xmlChar *ns)
; 980  : {
; 981  :     xmlSchemaValPtr val;
; 982  : 
; 983  :     val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 984  :     if (val == NULL)
; 985  : 	return (NULL);
; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;
; 988  :     if (ns != NULL)
; 989  : 	val->value.qname.uri = (xmlChar *)ns;
; 990  :     return(val);
; 991  : }
; 992  : 
; 993  : /**
; 994  :  * xmlSchemaNewQNameValue:
; 995  :  * @namespaceName: the namespace name
; 996  :  * @localName: the local name
; 997  :  *
; 998  :  * Allocate a new QName value.
; 999  :  * The given values are consumed and freed with the struct.
; 1000 :  *
; 1001 :  * Returns a pointer to the new value or NULL in case of an error.
; 1002 :  */
; 1003 : xmlSchemaValPtr
; 1004 : xmlSchemaNewQNameValue(const xmlChar *namespaceName,
; 1005 : 		       const xmlChar *localName)
; 1006 : {
; 1007 :     xmlSchemaValPtr val;
; 1008 : 
; 1009 :     val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 1010 :     if (val == NULL)
; 1011 : 	return (NULL);
; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;
; 1014 :     val->value.qname.uri = (xmlChar *) namespaceName;
; 1015 :     return(val);
; 1016 : }
; 1017 : 
; 1018 : /**
; 1019 :  * xmlSchemaFreeValue:
; 1020 :  * @value:  the value to free
; 1021 :  *
; 1022 :  * Cleanup the default XML Schemas type library
; 1023 :  */
; 1024 : void
; 1025 : xmlSchemaFreeValue(xmlSchemaValPtr value) {
; 1026 :     xmlSchemaValPtr prev;
; 1027 : 
; 1028 :     while (value != NULL) {
; 1029 : 	switch (value->type) {
; 1030 : 	    case XML_SCHEMAS_STRING:
; 1031 : 	    case XML_SCHEMAS_NORMSTRING:
; 1032 : 	    case XML_SCHEMAS_TOKEN:
; 1033 : 	    case XML_SCHEMAS_LANGUAGE:
; 1034 : 	    case XML_SCHEMAS_NMTOKEN:
; 1035 : 	    case XML_SCHEMAS_NMTOKENS:
; 1036 : 	    case XML_SCHEMAS_NAME:
; 1037 : 	    case XML_SCHEMAS_NCNAME:
; 1038 : 	    case XML_SCHEMAS_ID:
; 1039 : 	    case XML_SCHEMAS_IDREF:
; 1040 : 	    case XML_SCHEMAS_IDREFS:
; 1041 : 	    case XML_SCHEMAS_ENTITY:
; 1042 : 	    case XML_SCHEMAS_ENTITIES:
; 1043 : 	    case XML_SCHEMAS_ANYURI:
; 1044 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1045 : 		if (value->value.str != NULL)
; 1046 : 		    xmlFree(value->value.str);
; 1047 : 		break;
; 1048 : 	    case XML_SCHEMAS_NOTATION:
; 1049 : 	    case XML_SCHEMAS_QNAME:
; 1050 : 		if (value->value.qname.uri != NULL)
; 1051 : 		    xmlFree(value->value.qname.uri);
; 1052 : 		if (value->value.qname.name != NULL)
; 1053 : 		    xmlFree(value->value.qname.name);
; 1054 : 		break;
; 1055 : 	    case XML_SCHEMAS_HEXBINARY:
; 1056 : 		if (value->value.hex.str != NULL)
; 1057 : 		    xmlFree(value->value.hex.str);
; 1058 : 		break;
; 1059 : 	    case XML_SCHEMAS_BASE64BINARY:
; 1060 : 		if (value->value.base64.str != NULL)
; 1061 : 		    xmlFree(value->value.base64.str);
; 1062 : 		break;
; 1063 : 	    default:
; 1064 : 		break;
; 1065 : 	}
; 1066 : 	prev = value;
; 1067 : 	value = value->next;
; 1068 : 	xmlFree(prev);
; 1069 :     }
; 1070 : }
; 1071 : 
; 1072 : /**
; 1073 :  * xmlSchemaGetPredefinedType:
; 1074 :  * @name: the type name
; 1075 :  * @ns:  the URI of the namespace usually "http://www.w3.org/2001/XMLSchema"
; 1076 :  *
; 1077 :  * Lookup a type in the default XML Schemas type library
; 1078 :  *
; 1079 :  * Returns the type if found, NULL otherwise
; 1080 :  */
; 1081 : xmlSchemaTypePtr
; 1082 : xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {
; 1083 :     if (xmlSchemaTypesInitialized == 0)
; 1084 : 	xmlSchemaInitTypes();
; 1085 :     if (name == NULL)
; 1086 : 	return(NULL);
; 1087 :     return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));
; 1088 : }
; 1089 : 
; 1090 : /**
; 1091 :  * xmlSchemaGetBuiltInListSimpleTypeItemType:
; 1092 :  * @type: the built-in simple type.
; 1093 :  *
; 1094 :  * Lookup function
; 1095 :  *
; 1096 :  * Returns the item type of @type as defined by the built-in datatype
; 1097 :  * hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.
; 1098 :  */
; 1099 : xmlSchemaTypePtr
; 1100 : xmlSchemaGetBuiltInListSimpleTypeItemType(xmlSchemaTypePtr type)
; 1101 : {
; 1102 :     if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))
; 1103 : 	return (NULL);
; 1104 :     switch (type->builtInType) {
; 1105 : 	case XML_SCHEMAS_NMTOKENS:
; 1106 : 	    return (xmlSchemaTypeNmtokenDef );
; 1107 : 	case XML_SCHEMAS_IDREFS:
; 1108 : 	    return (xmlSchemaTypeIdrefDef);
; 1109 : 	case XML_SCHEMAS_ENTITIES:
; 1110 : 	    return (xmlSchemaTypeEntityDef);
; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }
; 1115 : 
; 1116 : /****************************************************************
; 1117 :  *								*
; 1118 :  *		Convenience macros and functions		*
; 1119 :  *								*
; 1120 :  ****************************************************************/
; 1121 : 
; 1122 : #define IS_TZO_CHAR(c)						\
; 1123 : 	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
; 1124 : 
; 1125 : #define VALID_YEAR(yr)          (yr != 0)
; 1126 : #define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
; 1127 : /* VALID_DAY should only be used when month is unknown */
; 1128 : #define VALID_DAY(day)          ((day >= 1) && (day <= 31))
; 1129 : #define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
; 1130 : #define VALID_MIN(min)          ((min >= 0) && (min <= 59))
; 1131 : #define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))
; 1132 : #define VALID_TZO(tzo)          ((tzo > -840) && (tzo < 840))
; 1133 : #define IS_LEAP(y)						\
; 1134 : 	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
; 1135 : 
; 1136 : static const unsigned int daysInMonth[12] =
; 1137 : 	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1138 : static const unsigned int daysInMonthLeap[12] =
; 1139 : 	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1140 : 
; 1141 : #define MAX_DAYINMONTH(yr,mon)                                  \
; 1142 :         (IS_LEAP(yr) ? daysInMonthLeap[mon - 1] : daysInMonth[mon - 1])
; 1143 : 
; 1144 : #define VALID_MDAY(dt)						\
; 1145 : 	(IS_LEAP(dt->year) ?				        \
; 1146 : 	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
; 1147 : 	    (dt->day <= daysInMonth[dt->mon - 1]))
; 1148 : 
; 1149 : #define VALID_DATE(dt)						\
; 1150 : 	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
; 1151 : 
; 1152 : #define VALID_END_OF_DAY(dt)					\
; 1153 : 	((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)
; 1154 : 
; 1155 : #define VALID_TIME(dt)						\
; 1156 : 	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
; 1157 : 	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
; 1158 : 	 VALID_TZO(dt->tzo))
; 1159 : 
; 1160 : #define VALID_DATETIME(dt)					\
; 1161 : 	(VALID_DATE(dt) && VALID_TIME(dt))
; 1162 : 
; 1163 : #define SECS_PER_MIN            (60)
; 1164 : #define SECS_PER_HOUR           (60 * SECS_PER_MIN)
; 1165 : #define SECS_PER_DAY            (24 * SECS_PER_HOUR)
; 1166 : 
; 1167 : static const long dayInYearByMonth[12] =
; 1168 : 	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
; 1169 : static const long dayInLeapYearByMonth[12] =
; 1170 : 	{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };
; 1171 : 
; 1172 : #define DAY_IN_YEAR(day, month, year)				\
; 1173 :         ((IS_LEAP(year) ?					\
; 1174 :                 dayInLeapYearByMonth[month - 1] :		\
; 1175 :                 dayInYearByMonth[month - 1]) + day)
; 1176 : 
; 1177 : #ifdef DEBUG
; 1178 : #define DEBUG_DATE(dt)                                                  \
; 1179 :     xmlGenericError(xmlGenericErrorContext,                             \
; 1180 :         "type=%o %04ld-%02u-%02uT%02u:%02u:%03f",                       \
; 1181 :         dt->type,dt->value.date.year,dt->value.date.mon,                \
; 1182 :         dt->value.date.day,dt->value.date.hour,dt->value.date.min,      \
; 1183 :         dt->value.date.sec);                                            \
; 1184 :     if (dt->value.date.tz_flag)                                         \
; 1185 :         if (dt->value.date.tzo != 0)                                    \
; 1186 :             xmlGenericError(xmlGenericErrorContext,                     \
; 1187 :                 "%+05d\n",dt->value.date.tzo);                          \
; 1188 :         else                                                            \
; 1189 :             xmlGenericError(xmlGenericErrorContext, "Z\n");             \
; 1190 :     else                                                                \
; 1191 :         xmlGenericError(xmlGenericErrorContext,"\n")
; 1192 : #else
; 1193 : #define DEBUG_DATE(dt)
; 1194 : #endif
; 1195 : 
; 1196 : /**
; 1197 :  * _xmlSchemaParseGYear:
; 1198 :  * @dt:  pointer to a date structure
; 1199 :  * @str: pointer to the string to analyze
; 1200 :  *
; 1201 :  * Parses a xs:gYear without time zone and fills in the appropriate
; 1202 :  * field of the @dt structure. @str is updated to point just after the
; 1203 :  * xs:gYear. It is supposed that @dt->year is big enough to contain
; 1204 :  * the year.
; 1205 :  *
; 1206 :  * Returns 0 or the error code
; 1207 :  */
; 1208 : static int
; 1209 : _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1210 :     const xmlChar *cur = *str, *firstChar;
; 1211 :     int isneg = 0, digcnt = 0;
; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))
; 1215 : 	return -1;
; 1216 : 
; 1217 :     if (*cur == '-') {
; 1218 : 	isneg = 1;
; 1219 : 	cur++;
; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;
; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {
; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');
; 1226 : 	cur++;
; 1227 : 	digcnt++;
; 1228 :     }
; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))
; 1233 : 	return 1;
; 1234 : 
; 1235 :     if (isneg)
; 1236 : 	dt->year = - dt->year;
; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))
; 1239 : 	return 2;
; 1240 : 
; 1241 :     *str = cur;
; 1242 :     return 0;
; 1243 : }
; 1244 : 
; 1245 : /**
; 1246 :  * PARSE_2_DIGITS:
; 1247 :  * @num:  the integer to fill in
; 1248 :  * @cur:  an #xmlChar *
; 1249 :  * @invalid: an integer
; 1250 :  *
; 1251 :  * Parses a 2-digits integer and updates @num with the value. @cur is
; 1252 :  * updated to point just after the integer.
; 1253 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1254 :  * @cur are undefined.
; 1255 :  */
; 1256 : #define PARSE_2_DIGITS(num, cur, invalid)			\
; 1257 : 	if ((cur[0] < '0') || (cur[0] > '9') ||			\
; 1258 : 	    (cur[1] < '0') || (cur[1] > '9'))			\
; 1259 : 	    invalid = 1;					\
; 1260 : 	else							\
; 1261 : 	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
; 1262 : 	cur += 2;
; 1263 : 
; 1264 : /**
; 1265 :  * PARSE_FLOAT:
; 1266 :  * @num:  the double to fill in
; 1267 :  * @cur:  an #xmlChar *
; 1268 :  * @invalid: an integer
; 1269 :  *
; 1270 :  * Parses a float and updates @num with the value. @cur is
; 1271 :  * updated to point just after the float. The float must have a
; 1272 :  * 2-digits integer part and may or may not have a decimal part.
; 1273 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1274 :  * @cur are undefined.
; 1275 :  */
; 1276 : #define PARSE_FLOAT(num, cur, invalid)				\
; 1277 : 	PARSE_2_DIGITS(num, cur, invalid);			\
; 1278 : 	if (!invalid && (*cur == '.')) {			\
; 1279 : 	    double mult = 1;				        \
; 1280 : 	    cur++;						\
; 1281 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1282 : 		invalid = 1;					\
; 1283 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1284 : 		mult /= 10;					\
; 1285 : 		num += (*cur - '0') * mult;			\
; 1286 : 		cur++;						\
; 1287 : 	    }							\
; 1288 : 	}
; 1289 : 
; 1290 : /**
; 1291 :  * _xmlSchemaParseGMonth:
; 1292 :  * @dt:  pointer to a date structure
; 1293 :  * @str: pointer to the string to analyze
; 1294 :  *
; 1295 :  * Parses a xs:gMonth without time zone and fills in the appropriate
; 1296 :  * field of the @dt structure. @str is updated to point just after the
; 1297 :  * xs:gMonth.
; 1298 :  *
; 1299 :  * Returns 0 or the error code
; 1300 :  */
; 1301 : static int
; 1302 : _xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1303 :     const xmlChar *cur = *str;
; 1304 :     int ret = 0;
; 1305 :     unsigned int value = 0;
; 1306 : 
; 1307 :     PARSE_2_DIGITS(value, cur, ret);
; 1308 :     if (ret != 0)
; 1309 : 	return ret;
; 1310 : 
; 1311 :     if (!VALID_MONTH(value))
; 1312 : 	return 2;
; 1313 : 
; 1314 :     dt->mon = value;
; 1315 : 
; 1316 :     *str = cur;
; 1317 :     return 0;
; 1318 : }
; 1319 : 
; 1320 : /**
; 1321 :  * _xmlSchemaParseGDay:
; 1322 :  * @dt:  pointer to a date structure
; 1323 :  * @str: pointer to the string to analyze
; 1324 :  *
; 1325 :  * Parses a xs:gDay without time zone and fills in the appropriate
; 1326 :  * field of the @dt structure. @str is updated to point just after the
; 1327 :  * xs:gDay.
; 1328 :  *
; 1329 :  * Returns 0 or the error code
; 1330 :  */
; 1331 : static int
; 1332 : _xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1333 :     const xmlChar *cur = *str;
; 1334 :     int ret = 0;
; 1335 :     unsigned int value = 0;
; 1336 : 
; 1337 :     PARSE_2_DIGITS(value, cur, ret);
; 1338 :     if (ret != 0)
; 1339 : 	return ret;
; 1340 : 
; 1341 :     if (!VALID_DAY(value))
; 1342 : 	return 2;
; 1343 : 
; 1344 :     dt->day = value;
; 1345 :     *str = cur;
; 1346 :     return 0;
; 1347 : }
; 1348 : 
; 1349 : /**
; 1350 :  * _xmlSchemaParseTime:
; 1351 :  * @dt:  pointer to a date structure
; 1352 :  * @str: pointer to the string to analyze
; 1353 :  *
; 1354 :  * Parses a xs:time without time zone and fills in the appropriate
; 1355 :  * fields of the @dt structure. @str is updated to point just after the
; 1356 :  * xs:time.
; 1357 :  * In case of error, values of @dt fields are undefined.
; 1358 :  *
; 1359 :  * Returns 0 or the error code
; 1360 :  */
; 1361 : static int
; 1362 : _xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1363 :     const xmlChar *cur = *str;
; 1364 :     int ret = 0;
; 1365 :     int value = 0;
; 1366 : 
; 1367 :     PARSE_2_DIGITS(value, cur, ret);
; 1368 :     if (ret != 0)
; 1369 : 	return ret;
; 1370 :     if (*cur != ':')
; 1371 : 	return 1;
; 1372 :     if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)
; 1373 : 	return 2;
; 1374 :     cur++;
; 1375 : 
; 1376 :     /* the ':' insures this string is xs:time */
; 1377 :     dt->hour = value;
; 1378 : 
; 1379 :     PARSE_2_DIGITS(value, cur, ret);
; 1380 :     if (ret != 0)
; 1381 : 	return ret;
; 1382 :     if (!VALID_MIN(value))
; 1383 : 	return 2;
; 1384 :     dt->min = value;
; 1385 : 
; 1386 :     if (*cur != ':')
; 1387 : 	return 1;
; 1388 :     cur++;
; 1389 : 
; 1390 :     PARSE_FLOAT(dt->sec, cur, ret);
; 1391 :     if (ret != 0)
; 1392 : 	return ret;
; 1393 : 
; 1394 :     if (!VALID_TIME(dt))
; 1395 : 	return 2;
; 1396 : 
; 1397 :     *str = cur;
; 1398 :     return 0;
; 1399 : }
; 1400 : 
; 1401 : /**
; 1402 :  * _xmlSchemaParseTimeZone:
; 1403 :  * @dt:  pointer to a date structure
; 1404 :  * @str: pointer to the string to analyze
; 1405 :  *
; 1406 :  * Parses a time zone without time zone and fills in the appropriate
; 1407 :  * field of the @dt structure. @str is updated to point just after the
; 1408 :  * time zone.
; 1409 :  *
; 1410 :  * Returns 0 or the error code
; 1411 :  */
; 1412 : static int
; 1413 : _xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1414 :     const xmlChar *cur;
; 1415 :     int ret = 0;
; 1416 : 
; 1417 :     if (str == NULL)
; 1418 : 	return -1;
; 1419 :     cur = *str;
; 1420 : 
; 1421 :     switch (*cur) {
; 1422 :     case 0:
; 1423 : 	dt->tz_flag = 0;
; 1424 : 	dt->tzo = 0;
; 1425 : 	break;
; 1426 : 
; 1427 :     case 'Z':
; 1428 : 	dt->tz_flag = 1;
; 1429 : 	dt->tzo = 0;
; 1430 : 	cur++;
; 1431 : 	break;
; 1432 : 
; 1433 :     case '+':
; 1434 :     case '-': {
; 1435 : 	int isneg = 0, tmp = 0;
; 1436 : 	isneg = (*cur == '-');
; 1437 : 
; 1438 : 	cur++;
; 1439 : 
; 1440 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1441 : 	if (ret != 0)
; 1442 : 	    return ret;
; 1443 : 	if (!VALID_HOUR(tmp))
; 1444 : 	    return 2;
; 1445 : 
; 1446 : 	if (*cur != ':')
; 1447 : 	    return 1;
; 1448 : 	cur++;
; 1449 : 
; 1450 : 	dt->tzo = tmp * 60;
; 1451 : 
; 1452 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1453 : 	if (ret != 0)
; 1454 : 	    return ret;
; 1455 : 	if (!VALID_MIN(tmp))
; 1456 : 	    return 2;
; 1457 : 
; 1458 : 	dt->tzo += tmp;
; 1459 : 	if (isneg)
; 1460 : 	    dt->tzo = - dt->tzo;
; 1461 : 
; 1462 : 	if (!VALID_TZO(dt->tzo))
; 1463 : 	    return 2;
; 1464 : 
; 1465 : 	dt->tz_flag = 1;
; 1466 : 	break;
; 1467 :       }
; 1468 :     default:
; 1469 : 	return 1;
; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;
; 1473 :     return 0;
; 1474 : }
; 1475 : 
; 1476 : /**
; 1477 :  * _xmlSchemaBase64Decode:
; 1478 :  * @ch: a character
; 1479 :  *
; 1480 :  * Converts a base64 encoded character to its base 64 value.
; 1481 :  *
; 1482 :  * Returns 0-63 (value), 64 (pad), or -1 (not recognized)
; 1483 :  */
; 1484 : static int
; 1485 : _xmlSchemaBase64Decode (const xmlChar ch) {
; 1486 :     if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';
; 1487 :     if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;
; 1488 :     if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;
; 1489 :     if ('+' == ch) return 62;
; 1490 :     if ('/' == ch) return 63;
; 1491 :     if ('=' == ch) return 64;
; 1492 :     return -1;
; 1493 : }
; 1494 : 
; 1495 : /****************************************************************
; 1496 :  *								*
; 1497 :  *	XML Schema Dates/Times Datatypes Handling		*
; 1498 :  *								*
; 1499 :  ****************************************************************/
; 1500 : 
; 1501 : /**
; 1502 :  * PARSE_DIGITS:
; 1503 :  * @num:  the integer to fill in
; 1504 :  * @cur:  an #xmlChar *
; 1505 :  * @num_type: an integer flag
; 1506 :  *
; 1507 :  * Parses a digits integer and updates @num with the value. @cur is
; 1508 :  * updated to point just after the integer.
; 1509 :  * In case of error, @num_type is set to -1, values of @num and
; 1510 :  * @cur are undefined.
; 1511 :  */
; 1512 : #define PARSE_DIGITS(num, cur, num_type)	                \
; 1513 : 	if ((*cur < '0') || (*cur > '9'))			\
; 1514 : 	    num_type = -1;					\
; 1515 :         else                                                    \
; 1516 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1517 : 	        num = num * 10 + (*cur - '0');		        \
; 1518 : 	        cur++;                                          \
; 1519 :             }
; 1520 : 
; 1521 : /**
; 1522 :  * PARSE_NUM:
; 1523 :  * @num:  the double to fill in
; 1524 :  * @cur:  an #xmlChar *
; 1525 :  * @num_type: an integer flag
; 1526 :  *
; 1527 :  * Parses a float or integer and updates @num with the value. @cur is
; 1528 :  * updated to point just after the number. If the number is a float,
; 1529 :  * then it must have an integer part and a decimal part; @num_type will
; 1530 :  * be set to 1. If there is no decimal part, @num_type is set to zero.
; 1531 :  * In case of error, @num_type is set to -1, values of @num and
; 1532 :  * @cur are undefined.
; 1533 :  */
; 1534 : #define PARSE_NUM(num, cur, num_type)				\
; 1535 :         num = 0;                                                \
; 1536 : 	PARSE_DIGITS(num, cur, num_type);	                \
; 1537 : 	if (!num_type && (*cur == '.')) {			\
; 1538 : 	    double mult = 1;				        \
; 1539 : 	    cur++;						\
; 1540 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1541 : 		num_type = -1;					\
; 1542 :             else                                                \
; 1543 :                 num_type = 1;                                   \
; 1544 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1545 : 		mult /= 10;					\
; 1546 : 		num += (*cur - '0') * mult;			\
; 1547 : 		cur++;						\
; 1548 : 	    }							\
; 1549 : 	}
; 1550 : 
; 1551 : /**
; 1552 :  * xmlSchemaValidateDates:
; 1553 :  * @type: the expected type or XML_SCHEMAS_UNKNOWN
; 1554 :  * @dateTime:  string to analyze
; 1555 :  * @val:  the return computed value
; 1556 :  *
; 1557 :  * Check that @dateTime conforms to the lexical space of one of the date types.
; 1558 :  * if true a value is computed and returned in @val.
; 1559 :  *
; 1560 :  * Returns 0 if this validates, a positive error code number otherwise
; 1561 :  *         and -1 in case of internal or API error.
; 1562 :  */
; 1563 : static int
; 1564 : xmlSchemaValidateDates (xmlSchemaValType type,
; 1565 : 	                const xmlChar *dateTime, xmlSchemaValPtr *val,
; 1566 : 			int collapse) {
; 1567 :     xmlSchemaValPtr dt;
; 1568 :     int ret;
; 1569 :     const xmlChar *cur = dateTime;
; 1570 : 
; 1571 : #define RETURN_TYPE_IF_VALID(t)					\
; 1572 :     if (IS_TZO_CHAR(*cur)) {					\
; 1573 : 	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
; 1574 : 	if (ret == 0) {						\
; 1575 : 	    if (*cur != 0)					\
; 1576 : 		goto error;					\
; 1577 : 	    dt->type = t;					\
; 1578 : 	    goto done;						\
; 1579 : 	}							\
; 1580 :     }
; 1581 : 
; 1582 :     if (dateTime == NULL)
; 1583 : 	return -1;
; 1584 : 
; 1585 :     if (collapse)
; 1586 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1587 : 
; 1588 :     if ((*cur != '-') && (*cur < '0') && (*cur > '9'))
; 1589 : 	return 1;
; 1590 : 
; 1591 :     dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);
; 1592 :     if (dt == NULL)
; 1593 : 	return -1;
; 1594 : 
; 1595 :     if ((cur[0] == '-') && (cur[1] == '-')) {
; 1596 : 	/*
; 1597 : 	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
; 1598 : 	 * xs:gDay)
; 1599 : 	 */
; 1600 : 	cur += 2;
; 1601 : 
; 1602 : 	/* is it an xs:gDay? */
; 1603 : 	if (*cur == '-') {
; 1604 : 	    if (type == XML_SCHEMAS_GMONTH)
; 1605 : 		goto error;
; 1606 : 	  ++cur;
; 1607 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1608 : 	    if (ret != 0)
; 1609 : 		goto error;
; 1610 : 
; 1611 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);
; 1612 : 
; 1613 : 	    goto error;
; 1614 : 	}
; 1615 : 
; 1616 : 	/*
; 1617 : 	 * it should be an xs:gMonthDay or xs:gMonth
; 1618 : 	 */
; 1619 : 	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1620 : 	if (ret != 0)
; 1621 : 	    goto error;
; 1622 : 
; 1623 :         /*
; 1624 :          * a '-' char could indicate this type is xs:gMonthDay or
; 1625 :          * a negative time zone offset. Check for xs:gMonthDay first.
; 1626 :          * Also the first three char's of a negative tzo (-MM:SS) can
; 1627 :          * appear to be a valid day; so even if the day portion
; 1628 :          * of the xs:gMonthDay verifies, we must insure it was not
; 1629 :          * a tzo.
; 1630 :          */
; 1631 :         if (*cur == '-') {
; 1632 :             const xmlChar *rewnd = cur;
; 1633 :             cur++;
; 1634 : 
; 1635 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1636 :             if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {
; 1637 : 
; 1638 :                 /*
; 1639 :                  * we can use the VALID_MDAY macro to validate the month
; 1640 :                  * and day because the leap year test will flag year zero
; 1641 :                  * as a leap year (even though zero is an invalid year).
; 1642 : 		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
; 1643 : 		 * probably.
; 1644 :                  */
; 1645 :                 if (VALID_MDAY((&(dt->value.date)))) {
; 1646 : 
; 1647 : 	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);
; 1648 : 
; 1649 :                     goto error;
; 1650 :                 }
; 1651 :             }
; 1652 : 
; 1653 :             /*
; 1654 :              * not xs:gMonthDay so rewind and check if just xs:gMonth
; 1655 :              * with an optional time zone.
; 1656 :              */
; 1657 :             cur = rewnd;
; 1658 :         }
; 1659 : 
; 1660 : 	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);
; 1661 : 
; 1662 : 	goto error;
; 1663 :     }
; 1664 : 
; 1665 :     /*
; 1666 :      * It's a right-truncated date or an xs:time.
; 1667 :      * Try to parse an xs:time then fallback on right-truncated dates.
; 1668 :      */
; 1669 :     if ((*cur >= '0') && (*cur <= '9')) {
; 1670 : 	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1671 : 	if (ret == 0) {
; 1672 : 	    /* it's an xs:time */
; 1673 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);
; 1674 : 	}
; 1675 :     }
; 1676 : 
; 1677 :     /* fallback on date parsing */
; 1678 :     cur = dateTime;
; 1679 : 
; 1680 :     ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);
; 1681 :     if (ret != 0)
; 1682 : 	goto error;
; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);
; 1686 : 
; 1687 :     if (*cur != '-')
; 1688 : 	goto error;
; 1689 :     cur++;
; 1690 : 
; 1691 :     ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1692 :     if (ret != 0)
; 1693 : 	goto error;
; 1694 : 
; 1695 :     /* is it an xs:gYearMonth? */
; 1696 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);
; 1697 : 
; 1698 :     if (*cur != '-')
; 1699 : 	goto error;
; 1700 :     cur++;
; 1701 : 
; 1702 :     ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1703 :     if ((ret != 0) || !VALID_DATE((&(dt->value.date))))
; 1704 : 	goto error;
; 1705 : 
; 1706 :     /* is it an xs:date? */
; 1707 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);
; 1708 : 
; 1709 :     if (*cur != 'T')
; 1710 : 	goto error;
; 1711 :     cur++;
; 1712 : 
; 1713 :     /* it should be an xs:dateTime */
; 1714 :     ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1715 :     if (ret != 0)
; 1716 : 	goto error;
; 1717 : 
; 1718 :     ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);
; 1719 :     if (collapse)
; 1720 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1721 :     if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))
; 1722 : 	goto error;
; 1723 : 
; 1724 : 
; 1725 :     dt->type = XML_SCHEMAS_DATETIME;
; 1726 : 
; 1727 : done:
; 1728 : #if 1
; 1729 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))
; 1730 :         goto error;
; 1731 : #else
; 1732 :     /*
; 1733 :      * insure the parsed type is equal to or less significant (right
; 1734 :      * truncated) than the desired type.
; 1735 :      */
; 1736 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
; 1737 : 
; 1738 :         /* time only matches time */
; 1739 :         if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
; 1740 :             goto error;
; 1741 : 
; 1742 :         if ((type == XML_SCHEMAS_DATETIME) &&
; 1743 :             ((dt->type != XML_SCHEMAS_DATE) ||
; 1744 :              (dt->type != XML_SCHEMAS_GYEARMONTH) ||
; 1745 :              (dt->type != XML_SCHEMAS_GYEAR)))
; 1746 :             goto error;
; 1747 : 
; 1748 :         if ((type == XML_SCHEMAS_DATE) &&
; 1749 :             ((dt->type != XML_SCHEMAS_GYEAR) ||
; 1750 :              (dt->type != XML_SCHEMAS_GYEARMONTH)))
; 1751 :             goto error;
; 1752 : 
; 1753 :         if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
; 1754 :             goto error;
; 1755 : 
; 1756 :         if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
; 1757 :             goto error;
; 1758 :     }
; 1759 : #endif
; 1760 : 
; 1761 :     if (val != NULL)
; 1762 :         *val = dt;
; 1763 :     else
; 1764 : 	xmlSchemaFreeValue(dt);
; 1765 : 
; 1766 :     return 0;
; 1767 : 
; 1768 : error:
; 1769 :     if (dt != NULL)
; 1770 : 	xmlSchemaFreeValue(dt);
; 1771 :     return 1;
; 1772 : }
; 1773 : 
; 1774 : /**
; 1775 :  * xmlSchemaValidateDuration:
; 1776 :  * @type: the predefined type
; 1777 :  * @duration:  string to analyze
; 1778 :  * @val:  the return computed value
; 1779 :  *
; 1780 :  * Check that @duration conforms to the lexical space of the duration type.
; 1781 :  * if true a value is computed and returned in @val.
; 1782 :  *
; 1783 :  * Returns 0 if this validates, a positive error code number otherwise
; 1784 :  *         and -1 in case of internal or API error.
; 1785 :  */
; 1786 : static int
; 1787 : xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
; 1788 : 	                   const xmlChar *duration, xmlSchemaValPtr *val,
; 1789 : 			   int collapse) {
; 1790 :     const xmlChar  *cur = duration;
; 1791 :     xmlSchemaValPtr dur;
; 1792 :     int isneg = 0;
; 1793 :     unsigned int seq = 0;
; 1794 :     double         num;
; 1795 :     int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */
; 1796 :     const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};
; 1797 :     const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};
; 1798 : 
; 1799 :     if (duration == NULL)
; 1800 : 	return -1;
; 1801 : 
; 1802 :     if (collapse)
; 1803 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1804 : 
; 1805 :     if (*cur == '-') {
; 1806 :         isneg = 1;
; 1807 :         cur++;
; 1808 :     }
; 1809 : 
; 1810 :     /* duration must start with 'P' (after sign) */
; 1811 :     if (*cur++ != 'P')
; 1812 : 	return 1;
; 1813 : 
; 1814 :     if (*cur == 0)
; 1815 : 	return 1;
; 1816 : 
; 1817 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
; 1818 :     if (dur == NULL)
; 1819 : 	return -1;
; 1820 : 
; 1821 :     while (*cur != 0) {
; 1822 : 
; 1823 :         /* input string should be empty or invalid date/time item */
; 1824 :         if (seq >= sizeof(desig))
; 1825 :             goto error;
; 1826 : 
; 1827 :         /* T designator must be present for time items */
; 1828 :         if (*cur == 'T') {
; 1829 :             if (seq <= 3) {
; 1830 :                 seq = 3;
; 1831 :                 cur++;
; 1832 :             } else
; 1833 :                 return 1;
; 1834 :         } else if (seq == 3)
; 1835 :             goto error;
; 1836 : 
; 1837 :         /* parse the number portion of the item */
; 1838 :         PARSE_NUM(num, cur, num_type);
; 1839 : 
; 1840 :         if ((num_type == -1) || (*cur == 0))
; 1841 :             goto error;
; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {
; 1845 :             if (*cur == desig[seq]) {
; 1846 : 
; 1847 :                 /* verify numeric type; only seconds can be float */
; 1848 :                 if ((num_type != 0) && (seq < (sizeof(desig)-1)))
; 1849 :                     goto error;
; 1850 : 
; 1851 :                 switch (seq) {
; 1852 :                     case 0:
; 1853 :                         dur->value.dur.mon = (long)num * 12;
; 1854 :                         break;
; 1855 :                     case 1:
; 1856 :                         dur->value.dur.mon += (long)num;
; 1857 :                         break;
; 1858 :                     default:
; 1859 :                         /* convert to seconds using multiplier */
; 1860 :                         dur->value.dur.sec += num * multi[seq];
; 1861 :                         seq++;
; 1862 :                         break;
; 1863 :                 }
; 1864 : 
; 1865 :                 break;          /* exit loop */
; 1866 :             }
; 1867 :             /* no date designators found? */
; 1868 :             if ((++seq == 3) || (seq == 6))
; 1869 :                 goto error;
; 1870 :         }
; 1871 : 	cur++;
; 1872 : 	if (collapse)
; 1873 : 	    while IS_WSP_BLANK_CH(*cur) cur++;
; 1874 :     }
; 1875 : 
; 1876 :     if (isneg) {
; 1877 :         dur->value.dur.mon = -dur->value.dur.mon;
; 1878 :         dur->value.dur.day = -dur->value.dur.day;
; 1879 :         dur->value.dur.sec = -dur->value.dur.sec;
; 1880 :     }
; 1881 : 
; 1882 :     if (val != NULL)
; 1883 :         *val = dur;
; 1884 :     else
; 1885 : 	xmlSchemaFreeValue(dur);
; 1886 : 
; 1887 :     return 0;
; 1888 : 
; 1889 : error:
; 1890 :     if (dur != NULL)
; 1891 : 	xmlSchemaFreeValue(dur);
; 1892 :     return 1;
; 1893 : }
; 1894 : 
; 1895 : /**
; 1896 :  * xmlSchemaStrip:
; 1897 :  * @value: a value
; 1898 :  *
; 1899 :  * Removes the leading and ending spaces of a string
; 1900 :  *
; 1901 :  * Returns the new string or NULL if no change was required.
; 1902 :  */
; 1903 : static xmlChar *
; 1904 : xmlSchemaStrip(const xmlChar *value) {
; 1905 :     const xmlChar *start = value, *end, *f;
; 1906 : 
; 1907 :     if (value == NULL) return(NULL);
; 1908 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1909 :     end = start;
; 1910 :     while (*end != 0) end++;
; 1911 :     f = end;
; 1912 :     end--;
; 1913 :     while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1914 :     end++;
; 1915 :     if ((start == value) && (f == end)) return(NULL);
; 1916 :     return(xmlStrndup(start, end - start));
; 1917 : }
; 1918 : 
; 1919 : /**
; 1920 :  * xmlSchemaWhiteSpaceReplace:
; 1921 :  * @value: a value
; 1922 :  *
; 1923 :  * Replaces 0xd, 0x9 and 0xa with a space.
; 1924 :  *
; 1925 :  * Returns the new string or NULL if no change was required.
; 1926 :  */
; 1927 : xmlChar *
; 1928 : xmlSchemaWhiteSpaceReplace(const xmlChar *value) {
; 1929 :     const xmlChar *cur = value;
; 1930 :     xmlChar *ret = NULL, *mcur;
; 1931 : 
; 1932 :     if (value == NULL)
; 1933 : 	return(NULL);
; 1934 : 
; 1935 :     while ((*cur != 0) &&
; 1936 : 	(((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {
; 1937 : 	cur++;
; 1938 :     }
; 1939 :     if (*cur == 0)
; 1940 : 	return (NULL);
; 1941 :     ret = xmlStrdup(value);
; 1942 :     /* TODO FIXME: I guess gcc will bark at this. */
; 1943 :     mcur = (xmlChar *)  (ret + (cur - value));
; 1944 :     do {
; 1945 : 	if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )
; 1946 : 	    *mcur = ' ';
; 1947 : 	mcur++;
; 1948 :     } while (*mcur != 0);
; 1949 :     return(ret);
; 1950 : }
; 1951 : 
; 1952 : /**
; 1953 :  * xmlSchemaCollapseString:
; 1954 :  * @value: a value
; 1955 :  *
; 1956 :  * Removes and normalize white spaces in the string
; 1957 :  *
; 1958 :  * Returns the new string or NULL if no change was required.
; 1959 :  */
; 1960 : xmlChar *
; 1961 : xmlSchemaCollapseString(const xmlChar *value) {
; 1962 :     const xmlChar *start = value, *end, *f;
; 1963 :     xmlChar *g;
; 1964 :     int col = 0;
; 1965 : 
; 1966 :     if (value == NULL) return(NULL);
; 1967 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1968 :     end = start;
; 1969 :     while (*end != 0) {
; 1970 : 	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {
; 1971 : 	    col = end - start;
; 1972 : 	    break;
; 1973 : 	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {
; 1974 : 	    col = end - start;
; 1975 : 	    break;
; 1976 : 	}
; 1977 : 	end++;
; 1978 :     }
; 1979 :     if (col == 0) {
; 1980 : 	f = end;
; 1981 : 	end--;
; 1982 : 	while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1983 : 	end++;
; 1984 : 	if ((start == value) && (f == end)) return(NULL);
; 1985 : 	return(xmlStrndup(start, end - start));
; 1986 :     }
; 1987 :     start = xmlStrdup(start);
; 1988 :     if (start == NULL) return(NULL);
; 1989 :     g = (xmlChar *) (start + col);
; 1990 :     end = g;
; 1991 :     while (*end != 0) {
; 1992 : 	if (IS_BLANK_CH(*end)) {
; 1993 : 	    end++;
; 1994 : 	    while (IS_BLANK_CH(*end)) end++;
; 1995 : 	    if (*end != 0)
; 1996 : 		*g++ = ' ';
; 1997 : 	} else
; 1998 : 	    *g++ = *end++;
; 1999 :     }
; 2000 :     *g = 0;
; 2001 :     return((xmlChar *) start);
; 2002 : }
; 2003 : 
; 2004 : /**
; 2005 :  * xmlSchemaValAtomicListNode:
; 2006 :  * @type: the predefined atomic type for a token in the list
; 2007 :  * @value: the list value to check
; 2008 :  * @ret:  the return computed value
; 2009 :  * @node:  the node containing the value
; 2010 :  *
; 2011 :  * Check that a value conforms to the lexical space of the predefined
; 2012 :  * list type. if true a value is computed and returned in @ret.
; 2013 :  *
; 2014 :  * Returns the number of items if this validates, a negative error code
; 2015 :  *         number otherwise
; 2016 :  */
; 2017 : static int
; 2018 : xmlSchemaValAtomicListNode(xmlSchemaTypePtr type, const xmlChar *value,
; 2019 : 	                   xmlSchemaValPtr *ret, xmlNodePtr node) {
; 2020 :     xmlChar *val, *cur, *endval;
; 2021 :     int nb_values = 0;
; 2022 :     int tmp = 0;
; 2023 : 
; 2024 :     if (value == NULL) {
; 2025 : 	return(-1);
; 2026 :     }
; 2027 :     val = xmlStrdup(value);
; 2028 :     if (val == NULL) {
; 2029 : 	return(-1);
; 2030 :     }
; 2031 :     if (ret != NULL) {
; 2032 :         *ret = NULL;
; 2033 :     }
; 2034 :     cur = val;
; 2035 :     /*
; 2036 :      * Split the list
; 2037 :      */
; 2038 :     while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2039 :     while (*cur != 0) {
; 2040 : 	if (IS_BLANK_CH(*cur)) {
; 2041 : 	    *cur = 0;
; 2042 : 	    cur++;
; 2043 : 	    while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2044 : 	} else {
; 2045 : 	    nb_values++;
; 2046 : 	    cur++;
; 2047 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
; 2048 : 	}
; 2049 :     }
; 2050 :     if (nb_values == 0) {
; 2051 : 	xmlFree(val);
; 2052 : 	return(nb_values);
; 2053 :     }
; 2054 :     endval = cur;
; 2055 :     cur = val;
; 2056 :     while ((*cur == 0) && (cur != endval)) cur++;
; 2057 :     while (cur != endval) {
; 2058 : 	tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);
; 2059 : 	if (tmp != 0)
; 2060 : 	    break;
; 2061 : 	while (*cur != 0) cur++;
; 2062 : 	while ((*cur == 0) && (cur != endval)) cur++;
; 2063 :     }
; 2064 :     /* TODO what return value ? c.f. bug #158628
; 2065 :     if (ret != NULL) {
; 2066 : 	TODO
; 2067 :     } */
; 2068 :     xmlFree(val);
; 2069 :     if (tmp == 0)
; 2070 : 	return(nb_values);
; 2071 :     return(-1);
; 2072 : }
; 2073 : 
; 2074 : /**
; 2075 :  * xmlSchemaParseUInt:
; 2076 :  * @str: pointer to the string R/W
; 2077 :  * @llo: pointer to the low result
; 2078 :  * @lmi: pointer to the mid result
; 2079 :  * @lhi: pointer to the high result
; 2080 :  *
; 2081 :  * Parse an unsigned long into 3 fields.
; 2082 :  *
; 2083 :  * Returns the number of significant digits in the number or
; 2084 :  * -1 if overflow of the capacity and -2 if it's not a number.
; 2085 :  */
; 2086 : static int
; 2087 : xmlSchemaParseUInt(const xmlChar **str, unsigned long *llo,
; 2088 :                    unsigned long *lmi, unsigned long *lhi) {
; 2089 :     unsigned long lo = 0, mi = 0, hi = 0;
; 2090 :     const xmlChar *tmp, *cur = *str;
; 2091 :     int ret = 0, i = 0;
; 2092 : 
; 2093 :     if (!((*cur >= '0') && (*cur <= '9')))
; 2094 :         return(-2);
; 2095 : 
; 2096 :     while (*cur == '0') {        /* ignore leading zeroes */
; 2097 :         cur++;
; 2098 :     }
; 2099 :     tmp = cur;
; 2100 :     while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {
; 2101 :         i++;tmp++;ret++;
; 2102 :     }
; 2103 :     if (i > 24) {
; 2104 :         *str = tmp;
; 2105 :         return(-1);
; 2106 :     }
; 2107 :     while (i > 16) {
; 2108 :         hi = hi * 10 + (*cur++ - '0');
; 2109 :         i--;
; 2110 :     }
; 2111 :     while (i > 8) {
; 2112 :         mi = mi * 10 + (*cur++ - '0');
; 2113 :         i--;
; 2114 :     }
; 2115 :     while (i > 0) {
; 2116 :         lo = lo * 10 + (*cur++ - '0');
; 2117 :         i--;
; 2118 :     }
; 2119 : 
; 2120 :     *str = cur;
; 2121 :     *llo = lo;
; 2122 :     *lmi = mi;
; 2123 :     *lhi = hi;
; 2124 :     return(ret);
; 2125 : }
; 2126 : 
; 2127 : /**
; 2128 :  * xmlSchemaValAtomicType:
; 2129 :  * @type: the predefined type
; 2130 :  * @value: the value to check
; 2131 :  * @val:  the return computed value
; 2132 :  * @node:  the node containing the value
; 2133 :  * flags:  flags to control the vlidation
; 2134 :  *
; 2135 :  * Check that a value conforms to the lexical space of the atomic type.
; 2136 :  * if true a value is computed and returned in @val.
; 2137 :  * This checks the value space for list types as well (IDREFS, NMTOKENS).
; 2138 :  *
; 2139 :  * Returns 0 if this validates, a positive error code number otherwise
; 2140 :  *         and -1 in case of internal or API error.
; 2141 :  */
; 2142 : static int
; 2143 : xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
; 2144 :                        xmlSchemaValPtr * val, xmlNodePtr node, int flags,
; 2145 : 		       xmlSchemaWhitespaceValueType ws,
; 2146 : 		       int normOnTheFly, int applyNorm, int createStringValue)
; 2147 : {
; 2148 :     xmlSchemaValPtr v;
; 2149 :     xmlChar *norm = NULL;
; 2150 :     int ret = 0;
; 2151 : 
; 2152 :     if (xmlSchemaTypesInitialized == 0)
; 2153 :         xmlSchemaInitTypes();
; 2154 :     if (type == NULL)
; 2155 :         return (-1);
; 2156 : 
; 2157 :     /*
; 2158 :      * validating a non existant text node is similar to validating
; 2159 :      * an empty one.
; 2160 :      */
; 2161 :     if (value == NULL)
; 2162 :         value = BAD_CAST "";
; 2163 : 
; 2164 :     if (val != NULL)
; 2165 :         *val = NULL;
; 2166 :     if ((flags == 0) && (value != NULL)) {
; 2167 : 
; 2168 :         if ((type->builtInType != XML_SCHEMAS_STRING) &&
; 2169 : 	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&
; 2170 : 	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
; 2171 : 	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)
; 2172 : 		norm = xmlSchemaWhiteSpaceReplace(value);
; 2173 :             else
; 2174 : 		norm = xmlSchemaCollapseString(value);
; 2175 :             if (norm != NULL)
; 2176 :                 value = norm;
; 2177 :         }
; 2178 :     }
; 2179 : 
; 2180 :     switch (type->builtInType) {
; 2181 :         case XML_SCHEMAS_UNKNOWN:
; 2182 :             goto error;
; 2183 : 	case XML_SCHEMAS_ANYTYPE:
; 2184 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 2185 : 	    if ((createStringValue) && (val != NULL)) {
; 2186 : 		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);
; 2187 : 		if (v != NULL) {
; 2188 : 		    v->value.str = xmlStrdup(value);
; 2189 : 		    *val = v;
; 2190 : 		} else {
; 2191 : 		    goto error;
; 2192 : 		}
; 2193 : 	    }
; 2194 : 	    goto return0;
; 2195 :         case XML_SCHEMAS_STRING:
; 2196 : 	    if (! normOnTheFly) {
; 2197 : 		const xmlChar *cur = value;
; 2198 : 
; 2199 : 		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {
; 2200 : 		    while (*cur != 0) {
; 2201 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2202 : 			    goto return1;
; 2203 : 			} else {
; 2204 : 			    cur++;
; 2205 : 			}
; 2206 : 		    }
; 2207 : 		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {
; 2208 : 		    while (*cur != 0) {
; 2209 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2210 : 			    goto return1;
; 2211 : 			} else if IS_WSP_SPACE_CH(*cur) {
; 2212 : 			    cur++;
; 2213 : 			    if IS_WSP_SPACE_CH(*cur)
; 2214 : 				goto return1;
; 2215 : 			} else {
; 2216 : 			    cur++;
; 2217 : 			}
; 2218 : 		    }
; 2219 : 		}
; 2220 : 	    }
; 2221 : 	    if (createStringValue && (val != NULL)) {
; 2222 : 		if (applyNorm) {
; 2223 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2224 : 			norm = xmlSchemaCollapseString(value);
; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)
; 2226 : 			norm = xmlSchemaWhiteSpaceReplace(value);
; 2227 : 		    if (norm != NULL)
; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);
; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {
; 2235 : 		    goto error;
; 2236 : 		}
; 2237 : 	    }
; 2238 :             goto return0;
; 2239 :         case XML_SCHEMAS_NORMSTRING:{
; 2240 : 		if (normOnTheFly) {
; 2241 : 		    if (applyNorm) {
; 2242 : 			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2243 : 			    norm = xmlSchemaCollapseString(value);
; 2244 : 			else
; 2245 : 			    norm = xmlSchemaWhiteSpaceReplace(value);
; 2246 : 			if (norm != NULL)
; 2247 : 			    value = norm;
; 2248 : 		    }
; 2249 : 		} else {
; 2250 : 		    const xmlChar *cur = value;
; 2251 : 		    while (*cur != 0) {
; 2252 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2253 : 			    goto return1;
; 2254 : 			} else {
; 2255 : 			    cur++;
; 2256 : 			}
; 2257 : 		    }
; 2258 : 		}
; 2259 :                 if (val != NULL) {
; 2260 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);
; 2261 :                     if (v != NULL) {
; 2262 :                         v->value.str = xmlStrdup(value);
; 2263 :                         *val = v;
; 2264 :                     } else {
; 2265 :                         goto error;
; 2266 :                     }
; 2267 :                 }
; 2268 :                 goto return0;
; 2269 :             }
; 2270 :         case XML_SCHEMAS_DECIMAL:{
; 2271 :                 const xmlChar *cur = value;
; 2272 :                 unsigned int len, neg, integ, hasLeadingZeroes;
; 2273 : 		xmlChar cval[25];
; 2274 : 		xmlChar *cptr = cval;
; 2275 : 
; 2276 :                 if ((cur == NULL) || (*cur == 0))
; 2277 :                     goto return1;
; 2278 : 
; 2279 : 		/*
; 2280 : 		* xs:decimal has a whitespace-facet value of 'collapse'.
; 2281 : 		*/
; 2282 : 		if (normOnTheFly)
; 2283 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2284 : 
; 2285 : 		/*
; 2286 : 		* First we handle an optional sign.
; 2287 : 		*/
; 2288 : 		neg = 0;
; 2289 :                 if (*cur == '-') {
; 2290 : 		    neg = 1;
; 2291 :                     cur++;
; 2292 : 		} else if (*cur == '+')
; 2293 :                     cur++;
; 2294 : 		/*
; 2295 : 		* Disallow: "", "-", "- "
; 2296 : 		*/
; 2297 : 		if (*cur == 0)
; 2298 : 		    goto return1;
; 2299 : 		/*
; 2300 : 		 * Next we "pre-parse" the number, in preparation for calling
; 2301 : 		 * the common routine xmlSchemaParseUInt.  We get rid of any
; 2302 : 		 * leading zeroes (because we have reserved only 25 chars),
; 2303 : 		 * and note the position of a decimal point.
; 2304 : 		 */
; 2305 : 		len = 0;
; 2306 : 		integ = ~0u;
; 2307 : 		hasLeadingZeroes = 0;
; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {
; 2312 : 		    cur++;
; 2313 : 		    hasLeadingZeroes = 1;
; 2314 : 		}
; 2315 : 		if (*cur != 0) {
; 2316 : 		    do {
; 2317 : 			if ((*cur >= '0') && (*cur <= '9')) {
; 2318 : 			    *cptr++ = *cur++;
; 2319 : 			    len++;
; 2320 : 			} else if (*cur == '.') {
; 2321 : 			    cur++;
; 2322 : 			    integ = len;
; 2323 : 			    do {
; 2324 : 				if ((*cur >= '0') && (*cur <= '9')) {
; 2325 : 				    *cptr++ = *cur++;
; 2326 : 				    len++;
; 2327 : 				} else
; 2328 : 				    break;
; 2329 : 			    } while (len < 24);
; 2330 : 			    /*
; 2331 : 			    * Disallow "." but allow "00."
; 2332 : 			    */
; 2333 : 			    if ((len == 0) && (!hasLeadingZeroes))
; 2334 : 				goto return1;
; 2335 : 			    break;
; 2336 : 			} else
; 2337 : 			    break;
; 2338 : 		    } while (len < 24);
; 2339 : 		}
; 2340 : 		if (normOnTheFly)
; 2341 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2342 : 		if (*cur != 0)
; 2343 : 		    goto return1; /* error if any extraneous chars */
; 2344 :                 if (val != NULL) {
; 2345 :                     v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);
; 2346 :                     if (v != NULL) {
; 2347 : 			/*
; 2348 : 			* Now evaluate the significant digits of the number
; 2349 : 			*/
; 2350 : 			if (len != 0) {
; 2351 : 
; 2352 : 			    if (integ != ~0u) {
; 2353 : 				/*
; 2354 : 				* Get rid of trailing zeroes in the
; 2355 : 				* fractional part.
; 2356 : 				*/
; 2357 : 				while ((len != integ) && (*(cptr-1) == '0')) {
; 2358 : 				    cptr--;
; 2359 : 				    len--;
; 2360 : 				}
; 2361 : 			    }
; 2362 : 			    /*
; 2363 : 			    * Terminate the (preparsed) string.
; 2364 : 			    */
; 2365 : 			    if (len != 0) {
; 2366 : 				*cptr = 0;
; 2367 : 				cptr = cval;
; 2368 : 
; 2369 : 				xmlSchemaParseUInt((const xmlChar **)&cptr,
; 2370 : 				    &v->value.decimal.lo,
; 2371 : 				    &v->value.decimal.mi,
; 2372 : 				    &v->value.decimal.hi);
; 2373 : 			    }
; 2374 : 			}
; 2375 : 			/*
; 2376 : 			* Set the total digits to 1 if a zero value.
; 2377 : 			*/
; 2378 :                         v->value.decimal.sign = neg;
; 2379 : 			if (len == 0) {
; 2380 : 			    /* Speedup for zero values. */
; 2381 : 			    v->value.decimal.total = 1;
; 2382 : 			} else {
; 2383 : 			    v->value.decimal.total = len;
; 2384 : 			    if (integ == ~0u)
; 2385 : 				v->value.decimal.frac = 0;
; 2386 : 			    else
; 2387 : 				v->value.decimal.frac = len - integ;
; 2388 : 			}
; 2389 :                         *val = v;
; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;
; 2393 :             }
; 2394 :         case XML_SCHEMAS_TIME:
; 2395 :         case XML_SCHEMAS_GDAY:
; 2396 :         case XML_SCHEMAS_GMONTH:
; 2397 :         case XML_SCHEMAS_GMONTHDAY:
; 2398 :         case XML_SCHEMAS_GYEAR:
; 2399 :         case XML_SCHEMAS_GYEARMONTH:
; 2400 :         case XML_SCHEMAS_DATE:
; 2401 :         case XML_SCHEMAS_DATETIME:
; 2402 :             ret = xmlSchemaValidateDates(type->builtInType, value, val,
; 2403 : 		normOnTheFly);
; 2404 :             break;
; 2405 :         case XML_SCHEMAS_DURATION:
; 2406 :             ret = xmlSchemaValidateDuration(type, value, val,
; 2407 : 		normOnTheFly);
; 2408 :             break;
; 2409 :         case XML_SCHEMAS_FLOAT:
; 2410 :         case XML_SCHEMAS_DOUBLE: {
; 2411 :                 const xmlChar *cur = value;
; 2412 :                 int neg = 0;
; 2413 :                 int digits_before = 0;
; 2414 :                 int digits_after = 0;
; 2415 : 
; 2416 : 		if (normOnTheFly)
; 2417 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2418 : 
; 2419 :                 if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {
; 2420 :                     cur += 3;
; 2421 :                     if (*cur != 0)
; 2422 :                         goto return1;
; 2423 :                     if (val != NULL) {
; 2424 :                         if (type == xmlSchemaTypeFloatDef) {
; 2425 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2426 :                             if (v != NULL) {
; 2427 :                                 v->value.f = (float) xmlXPathNAN;
; 2428 :                             } else {
; 2429 :                                 xmlSchemaFreeValue(v);
; 2430 :                                 goto error;
; 2431 :                             }
; 2432 :                         } else {
; 2433 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2434 :                             if (v != NULL) {
; 2435 :                                 v->value.d = xmlXPathNAN;
; 2436 :                             } else {
; 2437 :                                 xmlSchemaFreeValue(v);
; 2438 :                                 goto error;
; 2439 :                             }
; 2440 :                         }
; 2441 :                         *val = v;
; 2442 :                     }
; 2443 :                     goto return0;
; 2444 :                 }
; 2445 :                 if (*cur == '-') {
; 2446 :                     neg = 1;
; 2447 :                     cur++;
; 2448 :                 }
; 2449 :                 if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {
; 2450 :                     cur += 3;
; 2451 :                     if (*cur != 0)
; 2452 :                         goto return1;
; 2453 :                     if (val != NULL) {
; 2454 :                         if (type == xmlSchemaTypeFloatDef) {
; 2455 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2456 :                             if (v != NULL) {
; 2457 :                                 if (neg)
; 2458 :                                     v->value.f = (float) xmlXPathNINF;
; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;
; 2461 :                             } else {
; 2462 :                                 xmlSchemaFreeValue(v);
; 2463 :                                 goto error;
; 2464 :                             }
; 2465 :                         } else {
; 2466 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2467 :                             if (v != NULL) {
; 2468 :                                 if (neg)
; 2469 :                                     v->value.d = xmlXPathNINF;
; 2470 :                                 else
; 2471 :                                     v->value.d = xmlXPathPINF;
; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;
; 2478 :                     }
; 2479 :                     goto return0;
; 2480 :                 }
; 2481 :                 if ((neg == 0) && (*cur == '+'))
; 2482 :                     cur++;
; 2483 :                 if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))
; 2484 :                     goto return1;
; 2485 :                 while ((*cur >= '0') && (*cur <= '9')) {
; 2486 :                     cur++;
; 2487 :                     digits_before++;
; 2488 :                 }
; 2489 :                 if (*cur == '.') {
; 2490 :                     cur++;
; 2491 :                     while ((*cur >= '0') && (*cur <= '9')) {
; 2492 :                         cur++;
; 2493 :                         digits_after++;
; 2494 :                     }
; 2495 :                 }
; 2496 :                 if ((digits_before == 0) && (digits_after == 0))
; 2497 :                     goto return1;
; 2498 :                 if ((*cur == 'e') || (*cur == 'E')) {
; 2499 :                     cur++;
; 2500 :                     if ((*cur == '-') || (*cur == '+'))
; 2501 :                         cur++;
; 2502 :                     while ((*cur >= '0') && (*cur <= '9'))
; 2503 :                         cur++;
; 2504 :                 }
; 2505 : 		if (normOnTheFly)
; 2506 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2507 : 
; 2508 :                 if (*cur != 0)
; 2509 :                     goto return1;
; 2510 :                 if (val != NULL) {
; 2511 :                     if (type == xmlSchemaTypeFloatDef) {
; 2512 :                         v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2513 :                         if (v != NULL) {
; 2514 : 			    /*
; 2515 : 			    * TODO: sscanf seems not to give the correct
; 2516 : 			    * value for extremely high/low values.
; 2517 : 			    * E.g. "1E-149" results in zero.
; 2518 : 			    */
; 2519 :                             if (sscanf((const char *) value, "%f",
; 2520 :                                  &(v->value.f)) == 1) {
; 2521 :                                 *val = v;
; 2522 :                             } else {
; 2523 :                                 xmlSchemaFreeValue(v);
; 2524 :                                 goto return1;
; 2525 :                             }
; 2526 :                         } else {
; 2527 :                             goto error;
; 2528 :                         }
; 2529 :                     } else {
; 2530 :                         v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2531 :                         if (v != NULL) {
; 2532 : 			    /*
; 2533 : 			    * TODO: sscanf seems not to give the correct
; 2534 : 			    * value for extremely high/low values.
; 2535 : 			    */
; 2536 :                             if (sscanf((const char *) value, "%lf",
; 2537 :                                  &(v->value.d)) == 1) {
; 2538 :                                 *val = v;
; 2539 :                             } else {
; 2540 :                                 xmlSchemaFreeValue(v);
; 2541 :                                 goto return1;
; 2542 :                             }
; 2543 :                         } else {
; 2544 :                             goto error;
; 2545 :                         }
; 2546 :                     }
; 2547 :                 }
; 2548 :                 goto return0;
; 2549 :             }
; 2550 :         case XML_SCHEMAS_BOOLEAN:{
; 2551 :                 const xmlChar *cur = value;
; 2552 : 
; 2553 : 		if (normOnTheFly) {
; 2554 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2555 : 		    if (*cur == '0') {
; 2556 : 			ret = 0;
; 2557 : 			cur++;
; 2558 : 		    } else if (*cur == '1') {
; 2559 : 			ret = 1;
; 2560 : 			cur++;
; 2561 : 		    } else if (*cur == 't') {
; 2562 : 			cur++;
; 2563 : 			if ((*cur++ == 'r') && (*cur++ == 'u') &&
; 2564 : 			    (*cur++ == 'e')) {
; 2565 : 			    ret = 1;
; 2566 : 			} else
; 2567 : 			    goto return1;
; 2568 : 		    } else if (*cur == 'f') {
; 2569 : 			cur++;
; 2570 : 			if ((*cur++ == 'a') && (*cur++ == 'l') &&
; 2571 : 			    (*cur++ == 's') && (*cur++ == 'e')) {
; 2572 : 			    ret = 0;
; 2573 : 			} else
; 2574 : 			    goto return1;
; 2575 : 		    } else
; 2576 : 			goto return1;
; 2577 : 		    if (*cur != 0) {
; 2578 : 			while IS_WSP_BLANK_CH(*cur) cur++;
; 2579 : 			if (*cur != 0)
; 2580 : 			    goto return1;
; 2581 : 		    }
; 2582 : 		} else {
; 2583 : 		    if ((cur[0] == '0') && (cur[1] == 0))
; 2584 : 			ret = 0;
; 2585 : 		    else if ((cur[0] == '1') && (cur[1] == 0))
; 2586 : 			ret = 1;
; 2587 : 		    else if ((cur[0] == 't') && (cur[1] == 'r')
; 2588 : 			&& (cur[2] == 'u') && (cur[3] == 'e')
; 2589 : 			&& (cur[4] == 0))
; 2590 : 			ret = 1;
; 2591 : 		    else if ((cur[0] == 'f') && (cur[1] == 'a')
; 2592 : 			&& (cur[2] == 'l') && (cur[3] == 's')
; 2593 : 			&& (cur[4] == 'e') && (cur[5] == 0))
; 2594 : 			ret = 0;
; 2595 : 		    else
; 2596 : 			goto return1;
; 2597 : 		}
; 2598 :                 if (val != NULL) {
; 2599 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);
; 2600 :                     if (v != NULL) {
; 2601 :                         v->value.b = ret;
; 2602 :                         *val = v;
; 2603 :                     } else {
; 2604 :                         goto error;
; 2605 :                     }
; 2606 :                 }
; 2607 :                 goto return0;
; 2608 :             }
; 2609 :         case XML_SCHEMAS_TOKEN:{
; 2610 :                 const xmlChar *cur = value;
; 2611 : 
; 2612 : 		if (! normOnTheFly) {
; 2613 : 		    while (*cur != 0) {
; 2614 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2615 : 			    goto return1;
; 2616 : 			} else if (*cur == ' ') {
; 2617 : 			    cur++;
; 2618 : 			    if (*cur == 0)
; 2619 : 				goto return1;
; 2620 : 			    if (*cur == ' ')
; 2621 : 				goto return1;
; 2622 : 			} else {
; 2623 : 			    cur++;
; 2624 : 			}
; 2625 : 		    }
; 2626 : 		}
; 2627 :                 if (val != NULL) {
; 2628 :                     v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);
; 2629 :                     if (v != NULL) {
; 2630 :                         v->value.str = xmlStrdup(value);
; 2631 :                         *val = v;
; 2632 :                     } else {
; 2633 :                         goto error;
; 2634 :                     }
; 2635 :                 }
; 2636 :                 goto return0;
; 2637 :             }
; 2638 :         case XML_SCHEMAS_LANGUAGE:
; 2639 : 	    if (normOnTheFly) {
; 2640 : 		norm = xmlSchemaCollapseString(value);
; 2641 : 		if (norm != NULL)
; 2642 : 		    value = norm;
; 2643 : 	    }
; 2644 :             if (xmlCheckLanguageID(value) == 1) {
; 2645 :                 if (val != NULL) {
; 2646 :                     v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);
; 2647 :                     if (v != NULL) {
; 2648 :                         v->value.str = xmlStrdup(value);
; 2649 :                         *val = v;
; 2650 :                     } else {
; 2651 :                         goto error;
; 2652 :                     }
; 2653 :                 }
; 2654 :                 goto return0;
; 2655 :             }
; 2656 :             goto return1;
; 2657 :         case XML_SCHEMAS_NMTOKEN:
; 2658 :             if (xmlValidateNMToken(value, 1) == 0) {
; 2659 :                 if (val != NULL) {
; 2660 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);
; 2661 :                     if (v != NULL) {
; 2662 :                         v->value.str = xmlStrdup(value);
; 2663 :                         *val = v;
; 2664 :                     } else {
; 2665 :                         goto error;
; 2666 :                     }
; 2667 :                 }
; 2668 :                 goto return0;
; 2669 :             }
; 2670 :             goto return1;
; 2671 :         case XML_SCHEMAS_NMTOKENS:
; 2672 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,
; 2673 :                                              value, val, node);
; 2674 :             if (ret > 0)
; 2675 :                 ret = 0;
; 2676 :             else
; 2677 :                 ret = 1;
; 2678 :             goto done;
; 2679 :         case XML_SCHEMAS_NAME:
; 2680 :             ret = xmlValidateName(value, 1);
; 2681 :             if ((ret == 0) && (val != NULL) && (value != NULL)) {
; 2682 : 		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);
; 2683 : 		if (v != NULL) {
; 2684 : 		     const xmlChar *start = value, *end;
; 2685 : 		     while (IS_BLANK_CH(*start)) start++;
; 2686 : 		     end = start;
; 2687 : 		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;
; 2688 : 		     v->value.str = xmlStrndup(start, end - start);
; 2689 : 		    *val = v;
; 2690 : 		} else {
; 2691 : 		    goto error;
; 2692 : 		}
; 2693 :             }
; 2694 :             goto done;
; 2695 :         case XML_SCHEMAS_QNAME:{
; 2696 :                 const xmlChar *uri = NULL;
; 2697 :                 xmlChar *local = NULL;
; 2698 : 
; 2699 :                 ret = xmlValidateQName(value, 1);
; 2700 : 		if (ret != 0)
; 2701 : 		    goto done;
; 2702 :                 if (node != NULL) {
; 2703 :                     xmlChar *prefix;
; 2704 : 		    xmlNsPtr ns;
; 2705 : 
; 2706 :                     local = xmlSplitQName2(value, &prefix);
; 2707 : 		    ns = xmlSearchNs(node->doc, node, prefix);
; 2708 : 		    if ((ns == NULL) && (prefix != NULL)) {
; 2709 : 			xmlFree(prefix);
; 2710 : 			if (local != NULL)
; 2711 : 			    xmlFree(local);
; 2712 : 			goto return1;
; 2713 : 		    }
; 2714 : 		    if (ns != NULL)
; 2715 : 			uri = ns->href;
; 2716 :                     if (prefix != NULL)
; 2717 :                         xmlFree(prefix);
; 2718 :                 }
; 2719 :                 if (val != NULL) {
; 2720 :                     v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 2721 :                     if (v == NULL) {
; 2722 : 			if (local != NULL)
; 2723 : 			    xmlFree(local);
; 2724 : 			goto error;
; 2725 : 		    }
; 2726 : 		    if (local != NULL)
; 2727 : 			v->value.qname.name = local;
; 2728 : 		    else
; 2729 : 			v->value.qname.name = xmlStrdup(value);
; 2730 : 		    if (uri != NULL)
; 2731 : 			v->value.qname.uri = xmlStrdup(uri);
; 2732 : 		    *val = v;
; 2733 :                 } else
; 2734 : 		    if (local != NULL)
; 2735 : 			xmlFree(local);
; 2736 :                 goto done;
; 2737 :             }
; 2738 :         case XML_SCHEMAS_NCNAME:
; 2739 :             ret = xmlValidateNCName(value, 1);
; 2740 :             if ((ret == 0) && (val != NULL)) {
; 2741 :                 v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);
; 2742 :                 if (v != NULL) {
; 2743 :                     v->value.str = xmlStrdup(value);
; 2744 :                     *val = v;
; 2745 :                 } else {
; 2746 :                     goto error;
; 2747 :                 }
; 2748 :             }
; 2749 :             goto done;
; 2750 :         case XML_SCHEMAS_ID:
; 2751 :             ret = xmlValidateNCName(value, 1);
; 2752 :             if ((ret == 0) && (val != NULL)) {
; 2753 :                 v = xmlSchemaNewValue(XML_SCHEMAS_ID);
; 2754 :                 if (v != NULL) {
; 2755 :                     v->value.str = xmlStrdup(value);
; 2756 :                     *val = v;
; 2757 :                 } else {
; 2758 :                     goto error;
; 2759 :                 }
; 2760 :             }
; 2761 :             if ((ret == 0) && (node != NULL) &&
; 2762 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2763 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2764 : 
; 2765 :                 /*
; 2766 :                  * NOTE: the IDness might have already be declared in the DTD
; 2767 :                  */
; 2768 :                 if (attr->atype != XML_ATTRIBUTE_ID) {
; 2769 :                     xmlIDPtr res;
; 2770 :                     xmlChar *strip;
; 2771 : 
; 2772 :                     strip = xmlSchemaStrip(value);
; 2773 :                     if (strip != NULL) {
; 2774 :                         res = xmlAddID(NULL, node->doc, strip, attr);
; 2775 :                         xmlFree(strip);
; 2776 :                     } else
; 2777 :                         res = xmlAddID(NULL, node->doc, value, attr);
; 2778 :                     if (res == NULL) {
; 2779 :                         ret = 2;
; 2780 :                     } else {
; 2781 :                         attr->atype = XML_ATTRIBUTE_ID;
; 2782 :                     }
; 2783 :                 }
; 2784 :             }
; 2785 :             goto done;
; 2786 :         case XML_SCHEMAS_IDREF:
; 2787 :             ret = xmlValidateNCName(value, 1);
; 2788 :             if ((ret == 0) && (val != NULL)) {
; 2789 : 		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);
; 2790 : 		if (v == NULL)
; 2791 : 		    goto error;
; 2792 : 		v->value.str = xmlStrdup(value);
; 2793 : 		*val = v;
; 2794 :             }
; 2795 :             if ((ret == 0) && (node != NULL) &&
; 2796 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2797 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2798 :                 xmlChar *strip;
; 2799 : 
; 2800 :                 strip = xmlSchemaStrip(value);
; 2801 :                 if (strip != NULL) {
; 2802 :                     xmlAddRef(NULL, node->doc, strip, attr);
; 2803 :                     xmlFree(strip);
; 2804 :                 } else
; 2805 :                     xmlAddRef(NULL, node->doc, value, attr);
; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;
; 2807 :             }
; 2808 :             goto done;
; 2809 :         case XML_SCHEMAS_IDREFS:
; 2810 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,
; 2811 :                                              value, val, node);
; 2812 :             if (ret < 0)
; 2813 :                 ret = 2;
; 2814 :             else
; 2815 :                 ret = 0;
; 2816 :             if ((ret == 0) && (node != NULL) &&
; 2817 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2818 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2819 : 
; 2820 :                 attr->atype = XML_ATTRIBUTE_IDREFS;
; 2821 :             }
; 2822 :             goto done;
; 2823 :         case XML_SCHEMAS_ENTITY:{
; 2824 :                 xmlChar *strip;
; 2825 : 
; 2826 :                 ret = xmlValidateNCName(value, 1);
; 2827 :                 if ((node == NULL) || (node->doc == NULL))
; 2828 :                     ret = 3;
; 2829 :                 if (ret == 0) {
; 2830 :                     xmlEntityPtr ent;
; 2831 : 
; 2832 :                     strip = xmlSchemaStrip(value);
; 2833 :                     if (strip != NULL) {
; 2834 :                         ent = xmlGetDocEntity(node->doc, strip);
; 2835 :                         xmlFree(strip);
; 2836 :                     } else {
; 2837 :                         ent = xmlGetDocEntity(node->doc, value);
; 2838 :                     }
; 2839 :                     if ((ent == NULL) ||
; 2840 :                         (ent->etype !=
; 2841 :                          XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
; 2842 :                         ret = 4;
; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {
; 2845 :                     TODO;
; 2846 :                 }
; 2847 :                 if ((ret == 0) && (node != NULL) &&
; 2848 :                     (node->type == XML_ATTRIBUTE_NODE)) {
; 2849 :                     xmlAttrPtr attr = (xmlAttrPtr) node;
; 2850 : 
; 2851 :                     attr->atype = XML_ATTRIBUTE_ENTITY;
; 2852 :                 }
; 2853 :                 goto done;
; 2854 :             }
; 2855 :         case XML_SCHEMAS_ENTITIES:
; 2856 :             if ((node == NULL) || (node->doc == NULL))
; 2857 :                 goto return3;
; 2858 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,
; 2859 :                                              value, val, node);
; 2860 :             if (ret <= 0)
; 2861 :                 ret = 1;
; 2862 :             else
; 2863 :                 ret = 0;
; 2864 :             if ((ret == 0) && (node != NULL) &&
; 2865 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2866 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2867 : 
; 2868 :                 attr->atype = XML_ATTRIBUTE_ENTITIES;
; 2869 :             }
; 2870 :             goto done;
; 2871 :         case XML_SCHEMAS_NOTATION:{
; 2872 :                 xmlChar *uri = NULL;
; 2873 :                 xmlChar *local = NULL;
; 2874 : 
; 2875 :                 ret = xmlValidateQName(value, 1);
; 2876 :                 if ((ret == 0) && (node != NULL)) {
; 2877 :                     xmlChar *prefix;
; 2878 : 
; 2879 :                     local = xmlSplitQName2(value, &prefix);
; 2880 :                     if (prefix != NULL) {
; 2881 :                         xmlNsPtr ns;
; 2882 : 
; 2883 :                         ns = xmlSearchNs(node->doc, node, prefix);
; 2884 :                         if (ns == NULL)
; 2885 :                             ret = 1;
; 2886 :                         else if (val != NULL)
; 2887 :                             uri = xmlStrdup(ns->href);
; 2888 :                     }
; 2889 :                     if ((local != NULL) && ((val == NULL) || (ret != 0)))
; 2890 :                         xmlFree(local);
; 2891 :                     if (prefix != NULL)
; 2892 :                         xmlFree(prefix);
; 2893 :                 }
; 2894 :                 if ((node == NULL) || (node->doc == NULL))
; 2895 :                     ret = 3;
; 2896 :                 if (ret == 0) {
; 2897 :                     ret = xmlValidateNotationUse(NULL, node->doc, value);
; 2898 :                     if (ret == 1)
; 2899 :                         ret = 0;
; 2900 :                     else
; 2901 :                         ret = 1;
; 2902 :                 }
; 2903 :                 if ((ret == 0) && (val != NULL)) {
; 2904 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 2905 :                     if (v != NULL) {
; 2906 :                         if (local != NULL)
; 2907 :                             v->value.qname.name = local;
; 2908 :                         else
; 2909 :                             v->value.qname.name = xmlStrdup(value);
; 2910 :                         if (uri != NULL)
; 2911 :                             v->value.qname.uri = uri;
; 2912 : 
; 2913 :                         *val = v;
; 2914 :                     } else {
; 2915 :                         if (local != NULL)
; 2916 :                             xmlFree(local);
; 2917 :                         if (uri != NULL)
; 2918 :                             xmlFree(uri);
; 2919 :                         goto error;
; 2920 :                     }
; 2921 :                 }
; 2922 :                 goto done;
; 2923 :             }
; 2924 :         case XML_SCHEMAS_ANYURI:{
; 2925 :                 if (*value != 0) {
; 2926 : 		    xmlURIPtr uri;
; 2927 : 		    xmlChar *tmpval, *cur;
; 2928 : 		    if (normOnTheFly) {
; 2929 : 			norm = xmlSchemaCollapseString(value);
; 2930 : 			if (norm != NULL)
; 2931 : 			    value = norm;
; 2932 : 		    }
; 2933 : 		    tmpval = xmlStrdup(value);
; 2934 : 		    for (cur = tmpval; *cur; ++cur) {
; 2935 : 			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
; 2936 : 			    *cur == '<' || *cur == '>' || *cur == '"' ||
; 2937 : 			    *cur == '{' || *cur == '}' || *cur == '|' ||
; 2938 : 			    *cur == '\\' || *cur == '^' || *cur == '`' ||
; 2939 : 			    *cur == '\'')
; 2940 : 			    *cur = '_';
; 2941 : 		    }
; 2942 :                     uri = xmlParseURI((const char *) tmpval);
; 2943 : 		    xmlFree(tmpval);
; 2944 :                     if (uri == NULL)
; 2945 :                         goto return1;
; 2946 :                     xmlFreeURI(uri);
; 2947 :                 }
; 2948 : 
; 2949 :                 if (val != NULL) {
; 2950 :                     v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);
; 2951 :                     if (v == NULL)
; 2952 :                         goto error;
; 2953 :                     v->value.str = xmlStrdup(value);
; 2954 :                     *val = v;
; 2955 :                 }
; 2956 :                 goto return0;
; 2957 :             }
; 2958 :         case XML_SCHEMAS_HEXBINARY:{
; 2959 :                 const xmlChar *cur = value, *start;
; 2960 :                 xmlChar *base;
; 2961 :                 int total, i = 0;
; 2962 : 
; 2963 :                 if (cur == NULL)
; 2964 :                     goto return1;
; 2965 : 
; 2966 : 		if (normOnTheFly)
; 2967 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2968 : 
; 2969 : 		start = cur;
; 2970 :                 while (((*cur >= '0') && (*cur <= '9')) ||
; 2971 :                        ((*cur >= 'A') && (*cur <= 'F')) ||
; 2972 :                        ((*cur >= 'a') && (*cur <= 'f'))) {
; 2973 :                     i++;
; 2974 :                     cur++;
; 2975 :                 }
; 2976 : 		if (normOnTheFly)
; 2977 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2978 : 
; 2979 :                 if (*cur != 0)
; 2980 :                     goto return1;
; 2981 :                 if ((i % 2) != 0)
; 2982 :                     goto return1;
; 2983 : 
; 2984 :                 if (val != NULL) {
; 2985 : 
; 2986 :                     v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);
; 2987 :                     if (v == NULL)
; 2988 :                         goto error;
; 2989 : 		    /*
; 2990 : 		    * Copy only the normalized piece.
; 2991 : 		    * CRITICAL TODO: Check this.
; 2992 : 		    */
; 2993 :                     cur = xmlStrndup(start, i);
; 2994 :                     if (cur == NULL) {
; 2995 : 		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");
; 2996 :                         xmlFree(v);
; 2997 :                         goto return1;
; 2998 :                     }
; 2999 : 
; 3000 :                     total = i / 2;      /* number of octets */
; 3001 : 
; 3002 :                     base = (xmlChar *) cur;
; 3003 :                     while (i-- > 0) {
; 3004 :                         if (*base >= 'a')
; 3005 :                             *base = *base - ('a' - 'A');
; 3006 :                         base++;
; 3007 :                     }
; 3008 : 
; 3009 :                     v->value.hex.str = (xmlChar *) cur;
; 3010 :                     v->value.hex.total = total;
; 3011 :                     *val = v;
; 3012 :                 }
; 3013 :                 goto return0;
; 3014 :             }
; 3015 :         case XML_SCHEMAS_BASE64BINARY:{
; 3016 :                 /* ISSUE:
; 3017 :                  *
; 3018 :                  * Ignore all stray characters? (yes, currently)
; 3019 :                  * Worry about long lines? (no, currently)
; 3020 :                  *
; 3021 :                  * rfc2045.txt:
; 3022 :                  *
; 3023 :                  * "The encoded output stream must be represented in lines of
; 3024 :                  * no more than 76 characters each.  All line breaks or other
; 3025 :                  * characters not found in Table 1 must be ignored by decoding
; 3026 :                  * software.  In base64 data, characters other than those in
; 3027 :                  * Table 1, line breaks, and other white space probably
; 3028 :                  * indicate a transmission error, about which a warning
; 3029 :                  * message or even a message rejection might be appropriate
; 3030 :                  * under some circumstances." */
; 3031 :                 const xmlChar *cur = value;
; 3032 :                 xmlChar *base;
; 3033 :                 int total, i = 0, pad = 0;
; 3034 : 
; 3035 :                 if (cur == NULL)
; 3036 :                     goto return1;
; 3037 : 
; 3038 :                 for (; *cur; ++cur) {
; 3039 :                     int decc;
; 3040 : 
; 3041 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3042 :                     if (decc < 0) ;
; 3043 :                     else if (decc < 64)
; 3044 :                         i++;
; 3045 :                     else
; 3046 :                         break;
; 3047 :                 }
; 3048 :                 for (; *cur; ++cur) {
; 3049 :                     int decc;
; 3050 : 
; 3051 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3052 :                     if (decc < 0) ;
; 3053 :                     else if (decc < 64)
; 3054 :                         goto return1;
; 3055 :                     if (decc == 64)
; 3056 :                         pad++;
; 3057 :                 }
; 3058 : 
; 3059 :                 /* rfc2045.txt: "Special processing is performed if fewer than
; 3060 :                  * 24 bits are available at the end of the data being encoded.
; 3061 :                  * A full encoding quantum is always completed at the end of a
; 3062 :                  * body.  When fewer than 24 input bits are available in an
; 3063 :                  * input group, zero bits are added (on the right) to form an
; 3064 :                  * integral number of 6-bit groups.  Padding at the end of the
; 3065 :                  * data is performed using the "=" character.  Since all
; 3066 :                  * base64 input is an integral number of octets, only the
; 3067 :                  * following cases can arise: (1) the final quantum of
; 3068 :                  * encoding input is an integral multiple of 24 bits; here,
; 3069 :                  * the final unit of encoded output will be an integral
; 3070 :                  * multiple ofindent: Standard input:701: Warning:old style
; 3071 : 		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
; 3072 : 		 * with no "=" padding, (2) the final
; 3073 :                  * quantum of encoding input is exactly 8 bits; here, the
; 3074 :                  * final unit of encoded output will be two characters
; 3075 :                  * followed by two "=" padding characters, or (3) the final
; 3076 :                  * quantum of encoding input is exactly 16 bits; here, the
; 3077 :                  * final unit of encoded output will be three characters
; 3078 :                  * followed by one "=" padding character." */
; 3079 : 
; 3080 :                 total = 3 * (i / 4);
; 3081 :                 if (pad == 0) {
; 3082 :                     if (i % 4 != 0)
; 3083 :                         goto return1;
; 3084 :                 } else if (pad == 1) {
; 3085 :                     int decc;
; 3086 : 
; 3087 :                     if (i % 4 != 3)
; 3088 :                         goto return1;
; 3089 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3090 :                          (decc < 0) || (decc > 63);
; 3091 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3092 :                         --cur;
; 3093 :                     /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
; 3094 :                     /* 00111100 -> 0x3c */
; 3095 :                     if (decc & ~0x3c)
; 3096 :                         goto return1;
; 3097 :                     total += 2;
; 3098 :                 } else if (pad == 2) {
; 3099 :                     int decc;
; 3100 : 
; 3101 :                     if (i % 4 != 2)
; 3102 :                         goto return1;
; 3103 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3104 :                          (decc < 0) || (decc > 63);
; 3105 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3106 :                         --cur;
; 3107 :                     /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
; 3108 :                     /* 00110000 -> 0x30 */
; 3109 :                     if (decc & ~0x30)
; 3110 :                         goto return1;
; 3111 :                     total += 1;
; 3112 :                 } else
; 3113 :                     goto return1;
; 3114 : 
; 3115 :                 if (val != NULL) {
; 3116 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);
; 3117 :                     if (v == NULL)
; 3118 :                         goto error;
; 3119 :                     base =
; 3120 :                         (xmlChar *) xmlMallocAtomic((i + pad + 1) *
; 3121 :                                                     sizeof(xmlChar));
; 3122 :                     if (base == NULL) {
; 3123 : 		        xmlSchemaTypeErrMemory(node, "allocating base64 data");
; 3124 :                         xmlFree(v);
; 3125 :                         goto return1;
; 3126 :                     }
; 3127 :                     v->value.base64.str = base;
; 3128 :                     for (cur = value; *cur; ++cur)
; 3129 :                         if (_xmlSchemaBase64Decode(*cur) >= 0) {
; 3130 :                             *base = *cur;
; 3131 :                             ++base;
; 3132 :                         }
; 3133 :                     *base = 0;
; 3134 :                     v->value.base64.total = total;
; 3135 :                     *val = v;
; 3136 :                 }
; 3137 :                 goto return0;
; 3138 :             }
; 3139 :         case XML_SCHEMAS_INTEGER:
; 3140 :         case XML_SCHEMAS_PINTEGER:
; 3141 :         case XML_SCHEMAS_NPINTEGER:
; 3142 :         case XML_SCHEMAS_NINTEGER:
; 3143 :         case XML_SCHEMAS_NNINTEGER:{
; 3144 :                 const xmlChar *cur = value;
; 3145 :                 unsigned long lo, mi, hi;
; 3146 :                 int sign = 0;
; 3147 : 
; 3148 :                 if (cur == NULL)
; 3149 :                     goto return1;
; 3150 : 		if (normOnTheFly)
; 3151 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3152 :                 if (*cur == '-') {
; 3153 :                     sign = 1;
; 3154 :                     cur++;
; 3155 :                 } else if (*cur == '+')
; 3156 :                     cur++;
; 3157 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3158 :                 if (ret < 0)
; 3159 :                     goto return1;
; 3160 : 		if (normOnTheFly)
; 3161 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3162 :                 if (*cur != 0)
; 3163 :                     goto return1;
; 3164 :                 if (type->builtInType == XML_SCHEMAS_NPINTEGER) {
; 3165 :                     if ((sign == 0) &&
; 3166 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3167 :                         goto return1;
; 3168 :                 } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {
; 3169 :                     if (sign == 1)
; 3170 :                         goto return1;
; 3171 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3172 :                         goto return1;
; 3173 :                 } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {
; 3174 :                     if (sign == 0)
; 3175 :                         goto return1;
; 3176 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3177 :                         goto return1;
; 3178 :                 } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {
; 3179 :                     if ((sign == 1) &&
; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;
; 3182 :                 }
; 3183 :                 if (val != NULL) {
; 3184 :                     v = xmlSchemaNewValue(type->builtInType);
; 3185 :                     if (v != NULL) {
; 3186 : 			if (ret == 0)
; 3187 : 			    ret++;
; 3188 :                         v->value.decimal.lo = lo;
; 3189 :                         v->value.decimal.mi = mi;
; 3190 :                         v->value.decimal.hi = hi;
; 3191 :                         v->value.decimal.sign = sign;
; 3192 :                         v->value.decimal.frac = 0;
; 3193 :                         v->value.decimal.total = ret;
; 3194 :                         *val = v;
; 3195 :                     }
; 3196 :                 }
; 3197 :                 goto return0;
; 3198 :             }
; 3199 :         case XML_SCHEMAS_LONG:
; 3200 :         case XML_SCHEMAS_BYTE:
; 3201 :         case XML_SCHEMAS_SHORT:
; 3202 :         case XML_SCHEMAS_INT:{
; 3203 :                 const xmlChar *cur = value;
; 3204 :                 unsigned long lo, mi, hi;
; 3205 :                 int sign = 0;
; 3206 : 
; 3207 :                 if (cur == NULL)
; 3208 :                     goto return1;
; 3209 :                 if (*cur == '-') {
; 3210 :                     sign = 1;
; 3211 :                     cur++;
; 3212 :                 } else if (*cur == '+')
; 3213 :                     cur++;
; 3214 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3215 :                 if (ret < 0)
; 3216 :                     goto return1;
; 3217 :                 if (*cur != 0)
; 3218 :                     goto return1;
; 3219 :                 if (type->builtInType == XML_SCHEMAS_LONG) {
; 3220 :                     if (hi >= 922) {
; 3221 :                         if (hi > 922)
; 3222 :                             goto return1;
; 3223 :                         if (mi >= 33720368) {
; 3224 :                             if (mi > 33720368)
; 3225 :                                 goto return1;
; 3226 :                             if ((sign == 0) && (lo > 54775807))
; 3227 :                                 goto return1;
; 3228 :                             if ((sign == 1) && (lo > 54775808))
; 3229 :                                 goto return1;
; 3230 :                         }
; 3231 :                     }
; 3232 :                 } else if (type->builtInType == XML_SCHEMAS_INT) {
; 3233 :                     if (hi != 0)
; 3234 :                         goto return1;
; 3235 :                     if (mi >= 21) {
; 3236 :                         if (mi > 21)
; 3237 :                             goto return1;
; 3238 :                         if ((sign == 0) && (lo > 47483647))
; 3239 :                             goto return1;
; 3240 :                         if ((sign == 1) && (lo > 47483648))
; 3241 :                             goto return1;
; 3242 :                     }
; 3243 :                 } else if (type->builtInType == XML_SCHEMAS_SHORT) {
; 3244 :                     if ((mi != 0) || (hi != 0))
; 3245 :                         goto return1;
; 3246 :                     if ((sign == 1) && (lo > 32768))
; 3247 :                         goto return1;
; 3248 :                     if ((sign == 0) && (lo > 32767))
; 3249 :                         goto return1;
; 3250 :                 } else if (type->builtInType == XML_SCHEMAS_BYTE) {
; 3251 :                     if ((mi != 0) || (hi != 0))
; 3252 :                         goto return1;
; 3253 :                     if ((sign == 1) && (lo > 128))
; 3254 :                         goto return1;
; 3255 :                     if ((sign == 0) && (lo > 127))
; 3256 :                         goto return1;
; 3257 :                 }
; 3258 :                 if (val != NULL) {
; 3259 :                     v = xmlSchemaNewValue(type->builtInType);
; 3260 :                     if (v != NULL) {
; 3261 :                         v->value.decimal.lo = lo;
; 3262 :                         v->value.decimal.mi = mi;
; 3263 :                         v->value.decimal.hi = hi;
; 3264 :                         v->value.decimal.sign = sign;
; 3265 :                         v->value.decimal.frac = 0;
; 3266 :                         v->value.decimal.total = ret;
; 3267 :                         *val = v;
; 3268 :                     }
; 3269 :                 }
; 3270 :                 goto return0;
; 3271 :             }
; 3272 :         case XML_SCHEMAS_UINT:
; 3273 :         case XML_SCHEMAS_ULONG:
; 3274 :         case XML_SCHEMAS_USHORT:
; 3275 :         case XML_SCHEMAS_UBYTE:{
; 3276 :                 const xmlChar *cur = value;
; 3277 :                 unsigned long lo, mi, hi;
; 3278 : 
; 3279 :                 if (cur == NULL)
; 3280 :                     goto return1;
; 3281 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3282 :                 if (ret < 0)
; 3283 :                     goto return1;
; 3284 :                 if (*cur != 0)
; 3285 :                     goto return1;
; 3286 :                 if (type->builtInType == XML_SCHEMAS_ULONG) {
; 3287 :                     if (hi >= 1844) {
; 3288 :                         if (hi > 1844)
; 3289 :                             goto return1;
; 3290 :                         if (mi >= 67440737) {
; 3291 :                             if (mi > 67440737)
; 3292 :                                 goto return1;
; 3293 :                             if (lo > 9551615)
; 3294 :                                 goto return1;
; 3295 :                         }
; 3296 :                     }
; 3297 :                 } else if (type->builtInType == XML_SCHEMAS_UINT) {
; 3298 :                     if (hi != 0)
; 3299 :                         goto return1;
; 3300 :                     if (mi >= 42) {
; 3301 :                         if (mi > 42)
; 3302 :                             goto return1;
; 3303 :                         if (lo > 94967295)
; 3304 :                             goto return1;
; 3305 :                     }
; 3306 :                 } else if (type->builtInType == XML_SCHEMAS_USHORT) {
; 3307 :                     if ((mi != 0) || (hi != 0))
; 3308 :                         goto return1;
; 3309 :                     if (lo > 65535)
; 3310 :                         goto return1;
; 3311 :                 } else if (type->builtInType == XML_SCHEMAS_UBYTE) {
; 3312 :                     if ((mi != 0) || (hi != 0))
; 3313 :                         goto return1;
; 3314 :                     if (lo > 255)
; 3315 :                         goto return1;
; 3316 :                 }
; 3317 :                 if (val != NULL) {
; 3318 :                     v = xmlSchemaNewValue(type->builtInType);
; 3319 :                     if (v != NULL) {
; 3320 :                         v->value.decimal.lo = lo;
; 3321 :                         v->value.decimal.mi = mi;
; 3322 :                         v->value.decimal.hi = hi;
; 3323 :                         v->value.decimal.sign = 0;
; 3324 :                         v->value.decimal.frac = 0;
; 3325 :                         v->value.decimal.total = ret;
; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)
; 3335 :         xmlFree(norm);
; 3336 :     return (ret);
; 3337 :   return3:
; 3338 :     if (norm != NULL)
; 3339 :         xmlFree(norm);
; 3340 :     return (3);
; 3341 :   return1:
; 3342 :     if (norm != NULL)
; 3343 :         xmlFree(norm);
; 3344 :     return (1);
; 3345 :   return0:
; 3346 :     if (norm != NULL)
; 3347 :         xmlFree(norm);
; 3348 :     return (0);
; 3349 :   error:
; 3350 :     if (norm != NULL)
; 3351 :         xmlFree(norm);
; 3352 :     return (-1);
; 3353 : }
; 3354 : 
; 3355 : /**
; 3356 :  * xmlSchemaValPredefTypeNode:
; 3357 :  * @type: the predefined type
; 3358 :  * @value: the value to check
; 3359 :  * @val:  the return computed value
; 3360 :  * @node:  the node containing the value
; 3361 :  *
; 3362 :  * Check that a value conforms to the lexical space of the predefined type.
; 3363 :  * if true a value is computed and returned in @val.
; 3364 :  *
; 3365 :  * Returns 0 if this validates, a positive error code number otherwise
; 3366 :  *         and -1 in case of internal or API error.
; 3367 :  */
; 3368 : int
; 3369 : xmlSchemaValPredefTypeNode(xmlSchemaTypePtr type, const xmlChar *value,
; 3370 : 	                   xmlSchemaValPtr *val, xmlNodePtr node) {
; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,
; 3372 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
; 3373 : }
; 3374 : 
; 3375 : /**
; 3376 :  * xmlSchemaValPredefTypeNodeNoNorm:
; 3377 :  * @type: the predefined type
; 3378 :  * @value: the value to check
; 3379 :  * @val:  the return computed value
; 3380 :  * @node:  the node containing the value
; 3381 :  *
; 3382 :  * Check that a value conforms to the lexical space of the predefined type.
; 3383 :  * if true a value is computed and returned in @val.
; 3384 :  * This one does apply any normalization to the value.
; 3385 :  *
; 3386 :  * Returns 0 if this validates, a positive error code number otherwise
; 3387 :  *         and -1 in case of internal or API error.
; 3388 :  */
; 3389 : int
; 3390 : xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, const xmlChar *value,
; 3391 : 				 xmlSchemaValPtr *val, xmlNodePtr node) {
; 3392 :     return(xmlSchemaValAtomicType(type, value, val, node, 1,
; 3393 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
; 3394 : }
; 3395 : 
; 3396 : /**
; 3397 :  * xmlSchemaValidatePredefinedType:
; 3398 :  * @type: the predefined type
; 3399 :  * @value: the value to check
; 3400 :  * @val:  the return computed value
; 3401 :  *
; 3402 :  * Check that a value conforms to the lexical space of the predefined type.
; 3403 :  * if true a value is computed and returned in @val.
; 3404 :  *
; 3405 :  * Returns 0 if this validates, a positive error code number otherwise
; 3406 :  *         and -1 in case of internal or API error.
; 3407 :  */
; 3408 : int
; 3409 : xmlSchemaValidatePredefinedType(xmlSchemaTypePtr type, const xmlChar *value,
; 3410 : 	                        xmlSchemaValPtr *val) {
; 3411 :     return(xmlSchemaValPredefTypeNode(type, value, val, NULL));
; 3412 : }
; 3413 : 
; 3414 : /**
; 3415 :  * xmlSchemaCompareDecimals:
; 3416 :  * @x:  a first decimal value
; 3417 :  * @y:  a second decimal value
; 3418 :  *
; 3419 :  * Compare 2 decimals
; 3420 :  *
; 3421 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error
; 3422 :  */
; 3423 : static int
; 3424 : xmlSchemaCompareDecimals(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3425 : {
; 3426 :     xmlSchemaValPtr swp;
; 3427 :     int order = 1, integx, integy, dlen;
; 3428 :     unsigned long hi, mi, lo;
; 3429 : 
; 3430 :     /*
; 3431 :      * First test: If x is -ve and not zero
; 3432 :      */
; 3433 :     if ((x->value.decimal.sign) &&
; 3434 : 	((x->value.decimal.lo != 0) ||
; 3435 : 	 (x->value.decimal.mi != 0) ||
; 3436 : 	 (x->value.decimal.hi != 0))) {
; 3437 : 	/*
; 3438 : 	 * Then if y is -ve and not zero reverse the compare
; 3439 : 	 */
; 3440 : 	if ((y->value.decimal.sign) &&
; 3441 : 	    ((y->value.decimal.lo != 0) ||
; 3442 : 	     (y->value.decimal.mi != 0) ||
; 3443 : 	     (y->value.decimal.hi != 0)))
; 3444 : 	    order = -1;
; 3445 : 	/*
; 3446 : 	 * Otherwise (y >= 0) we have the answer
; 3447 : 	 */
; 3448 : 	else
; 3449 : 	    return (-1);
; 3450 :     /*
; 3451 :      * If x is not -ve and y is -ve we have the answer
; 3452 :      */
; 3453 :     } else if ((y->value.decimal.sign) &&
; 3454 : 	       ((y->value.decimal.lo != 0) ||
; 3455 : 		(y->value.decimal.mi != 0) ||
; 3456 : 		(y->value.decimal.hi != 0))) {
; 3457 :         return (1);
; 3458 :     }
; 3459 :     /*
; 3460 :      * If it's not simply determined by a difference in sign,
; 3461 :      * then we need to compare the actual values of the two nums.
; 3462 :      * To do this, we start by looking at the integral parts.
; 3463 :      * If the number of integral digits differ, then we have our
; 3464 :      * answer.
; 3465 :      */
; 3466 :     integx = x->value.decimal.total - x->value.decimal.frac;
; 3467 :     integy = y->value.decimal.total - y->value.decimal.frac;
; 3468 :     /*
; 3469 :     * NOTE: We changed the "total" for values like "0.1"
; 3470 :     *   (or "-0.1" or ".1") to be 1, which was 2 previously.
; 3471 :     *   Therefore the special case, when such values are
; 3472 :     *   compared with 0, needs to be handled separately;
; 3473 :     *   otherwise a zero would be recognized incorrectly as
; 3474 :     *   greater than those values. This has the nice side effect
; 3475 :     *   that we gain an overall optimized comparison with zeroes.
; 3476 :     * Note that a "0" has a "total" of 1 already.
; 3477 :     */
; 3478 :     if (integx == 1) {
; 3479 : 	if (x->value.decimal.lo == 0) {
; 3480 : 	    if (integy != 1)
; 3481 : 		return -order;
; 3482 : 	    else if (y->value.decimal.lo != 0)
; 3483 : 		return -order;
; 3484 : 	    else
; 3485 : 		return(0);
; 3486 : 	}
; 3487 :     }
; 3488 :     if (integy == 1) {
; 3489 : 	if (y->value.decimal.lo == 0) {
; 3490 : 	    if (integx != 1)
; 3491 : 		return order;
; 3492 : 	    else if (x->value.decimal.lo != 0)
; 3493 : 		return order;
; 3494 : 	    else
; 3495 : 		return(0);
; 3496 : 	}
; 3497 :     }
; 3498 : 
; 3499 :     if (integx > integy)
; 3500 : 	return order;
; 3501 :     else if (integy > integx)
; 3502 : 	return -order;
; 3503 : 
; 3504 :     /*
; 3505 :      * If the number of integral digits is the same for both numbers,
; 3506 :      * then things get a little more complicated.  We need to "normalize"
; 3507 :      * the numbers in order to properly compare them.  To do this, we
; 3508 :      * look at the total length of each number (length => number of
; 3509 :      * significant digits), and divide the "shorter" by 10 (decreasing
; 3510 :      * the length) until they are of equal length.
; 3511 :      */
; 3512 :     dlen = x->value.decimal.total - y->value.decimal.total;
; 3513 :     if (dlen < 0) {	/* y has more digits than x */
; 3514 : 	swp = x;
; 3515 : 	hi = y->value.decimal.hi;
; 3516 : 	mi = y->value.decimal.mi;
; 3517 : 	lo = y->value.decimal.lo;
; 3518 : 	dlen = -dlen;
; 3519 : 	order = -order;
; 3520 :     } else {		/* x has more digits than y */
; 3521 : 	swp = y;
; 3522 : 	hi = x->value.decimal.hi;
; 3523 : 	mi = x->value.decimal.mi;
; 3524 : 	lo = x->value.decimal.lo;
; 3525 :     }
; 3526 :     while (dlen > 8) {	/* in effect, right shift by 10**8 */
; 3527 : 	lo = mi;
; 3528 : 	mi = hi;
; 3529 : 	hi = 0;
; 3530 : 	dlen -= 8;
; 3531 :     }
; 3532 :     while (dlen > 0) {
; 3533 : 	unsigned long rem1, rem2;
; 3534 : 	rem1 = (hi % 10) * 100000000L;
; 3535 : 	hi = hi / 10;
; 3536 : 	rem2 = (mi % 10) * 100000000L;
; 3537 : 	mi = (mi + rem1) / 10;
; 3538 : 	lo = (lo + rem2) / 10;
; 3539 : 	dlen--;
; 3540 :     }
; 3541 :     if (hi > swp->value.decimal.hi) {
; 3542 : 	return order;
; 3543 :     } else if (hi == swp->value.decimal.hi) {
; 3544 : 	if (mi > swp->value.decimal.mi) {
; 3545 : 	    return order;
; 3546 : 	} else if (mi == swp->value.decimal.mi) {
; 3547 : 	    if (lo > swp->value.decimal.lo) {
; 3548 : 		return order;
; 3549 : 	    } else if (lo == swp->value.decimal.lo) {
; 3550 : 		if (x->value.decimal.total == y->value.decimal.total) {
; 3551 : 		    return 0;
; 3552 : 		} else {
; 3553 : 		    return order;
; 3554 : 		}
; 3555 : 	    }
; 3556 : 	}
; 3557 :     }
; 3558 :     return -order;
; 3559 : }
; 3560 : 
; 3561 : /**
; 3562 :  * xmlSchemaCompareDurations:
; 3563 :  * @x:  a first duration value
; 3564 :  * @y:  a second duration value
; 3565 :  *
; 3566 :  * Compare 2 durations
; 3567 :  *
; 3568 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in
; 3569 :  * case of error
; 3570 :  */
; 3571 : static int
; 3572 : xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3573 : {
; 3574 :     long carry, mon, day;
; 3575 :     double sec;
; 3576 :     int invert = 1;
; 3577 :     long xmon, xday, myear, minday, maxday;
; 3578 :     static const long dayRange [2][12] = {
; 3579 :         { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
; 3580 :         { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
; 3581 : 
; 3582 :     if ((x == NULL) || (y == NULL))
; 3583 :         return -2;
; 3584 : 
; 3585 :     /* months */
; 3586 :     mon = x->value.dur.mon - y->value.dur.mon;
; 3587 : 
; 3588 :     /* seconds */
; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;
; 3590 :     carry = (long)(sec / SECS_PER_DAY);
; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;
; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;
; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {
; 3598 :         if (day == 0)
; 3599 :             if (sec == 0.0)
; 3600 :                 return 0;
; 3601 :             else if (sec < 0.0)
; 3602 :                 return -1;
; 3603 :             else
; 3604 :                 return 1;
; 3605 :         else if (day < 0)
; 3606 :             return -1;
; 3607 :         else
; 3608 :             return 1;
; 3609 :     }
; 3610 : 
; 3611 :     if (mon > 0) {
; 3612 :         if ((day >= 0) && (sec >= 0.0))
; 3613 :             return 1;
; 3614 :         else {
; 3615 :             xmon = mon;
; 3616 :             xday = -day;
; 3617 :         }
; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {
; 3619 :         return -1;
; 3620 :     } else {
; 3621 : 	invert = -1;
; 3622 :         xmon = -mon;
; 3623 :         xday = day;
; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;
; 3627 :     if (myear == 0) {
; 3628 : 	minday = 0;
; 3629 : 	maxday = 0;
; 3630 :     } else {
; 3631 : 	maxday = 366 * ((myear + 3) / 4) +
; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;
; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;
; 3637 :     minday += dayRange[0][xmon];
; 3638 :     maxday += dayRange[1][xmon];
; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))
; 3641 : 	return(0); /* can this really happen ? */
; 3642 :     if (maxday < xday)
; 3643 :         return(-invert);
; 3644 :     if (minday > xday)
; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }
; 3650 : 
; 3651 : /*
; 3652 :  * macros for adding date/times and durations
; 3653 :  */
; 3654 : #define FQUOTIENT(a,b)                  (floor(((double)a/(double)b)))
; 3655 : #define MODULO(a,b)                     (a - FQUOTIENT(a,b) * b)
; 3656 : #define FQUOTIENT_RANGE(a,low,high)     (FQUOTIENT((a-low),(high-low)))
; 3657 : #define MODULO_RANGE(a,low,high)        ((MODULO((a-low),(high-low)))+low)
; 3658 : 
; 3659 : /**
; 3660 :  * xmlSchemaDupVal:
; 3661 :  * @v: the #xmlSchemaValPtr value to duplicate
; 3662 :  *
; 3663 :  * Makes a copy of @v. The calling program is responsible for freeing
; 3664 :  * the returned value.
; 3665 :  *
; 3666 :  * returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error.
; 3667 :  */
; 3668 : static xmlSchemaValPtr
; 3669 : xmlSchemaDupVal (xmlSchemaValPtr v)
; 3670 : {
; 3671 :     xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);
; 3672 :     if (ret == NULL)
; 3673 :         return NULL;

	xor	esi, esi
$LN20@xmlSchemaC:

; 3704 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 3705 : 	    case XML_SCHEMAS_STRING:
; 3706 : 	    case XML_SCHEMAS_NORMSTRING:
; 3707 : 	    case XML_SCHEMAS_TOKEN:
; 3708 : 	    case XML_SCHEMAS_LANGUAGE:
; 3709 : 	    case XML_SCHEMAS_NAME:
; 3710 : 	    case XML_SCHEMAS_NCNAME:
; 3711 : 	    case XML_SCHEMAS_ID:
; 3712 : 	    case XML_SCHEMAS_IDREF:
; 3713 : 	    case XML_SCHEMAS_ENTITY:
; 3714 : 	    case XML_SCHEMAS_NMTOKEN:
; 3715 : 	    case XML_SCHEMAS_ANYURI:
; 3716 : 		cur = xmlSchemaDupVal(val);
; 3717 : 		if (val->value.str != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	$LN32@xmlSchemaC

; 3718 : 		    cur->value.str = xmlStrdup(BAD_CAST val->value.str);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3719 : 		break;

	jmp	$LN32@xmlSchemaC
$LN9@xmlSchemaC:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	esi, esi
	je	SHORT $LN43@xmlSchemaC

; 235  :     value->type = type;

	mov	eax, DWORD PTR tv350[ebp]
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [esi], eax

; 3675 :     memcpy(ret, v, sizeof(xmlSchemaVal));

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [edi+16]
	movups	XMMWORD PTR [esi+16], xmm0

; 3676 :     ret->next = NULL;

	mov	DWORD PTR [esi+4], 0

; 3677 :     return ret;

	jmp	SHORT $LN26@xmlSchemaC
$LN43@xmlSchemaC:

; 236  :     return(value);
; 237  : }
; 238  : 
; 239  : static xmlSchemaFacetPtr
; 240  : xmlSchemaNewMinLengthFacet(int value)
; 241  : {
; 242  :     xmlSchemaFacetPtr ret;
; 243  : 
; 244  :     ret = xmlSchemaNewFacet();
; 245  :     if (ret == NULL) {
; 246  :         return(NULL);
; 247  :     }
; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;
; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);
; 250  :     if (ret->val == NULL) {
; 251  :         xmlFree(ret);
; 252  : 	return(NULL);
; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;
; 255  :     return (ret);
; 256  : }
; 257  : 
; 258  : /*
; 259  :  * xmlSchemaInitBasicType:
; 260  :  * @name:  the type name
; 261  :  * @type:  the value type associated
; 262  :  *
; 263  :  * Initialize one primitive built-in type
; 264  :  */
; 265  : static xmlSchemaTypePtr
; 266  : xmlSchemaInitBasicType(const char *name, xmlSchemaValType type,
; 267  : 		       xmlSchemaTypePtr baseType) {
; 268  :     xmlSchemaTypePtr ret;
; 269  : 
; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
; 271  :     if (ret == NULL) {
; 272  :         xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");
; 273  : 	return(NULL);
; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));
; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);
; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;
; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;
; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,
; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;
; 330  :     return(ret);
; 331  : }
; 332  : 
; 333  : /*
; 334  : * WARNING: Those type reside normally in xmlschemas.c but are
; 335  : * redefined here locally in oder of being able to use them for xs:anyType-
; 336  : * TODO: Remove those definition if we move the types to a header file.
; 337  : * TODO: Always keep those structs up-to-date with the originals.
; 338  : */
; 339  : #define UNBOUNDED (1 << 30)
; 340  : 
; 341  : typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;
; 342  : typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;
; 343  : struct _xmlSchemaTreeItem {
; 344  :     xmlSchemaTypeType type;
; 345  :     xmlSchemaAnnotPtr annot;
; 346  :     xmlSchemaTreeItemPtr next;
; 347  :     xmlSchemaTreeItemPtr children;
; 348  : };
; 349  : 
; 350  : typedef struct _xmlSchemaParticle xmlSchemaParticle;
; 351  : typedef xmlSchemaParticle *xmlSchemaParticlePtr;
; 352  : struct _xmlSchemaParticle {
; 353  :     xmlSchemaTypeType type;
; 354  :     xmlSchemaAnnotPtr annot;
; 355  :     xmlSchemaTreeItemPtr next;
; 356  :     xmlSchemaTreeItemPtr children;
; 357  :     int minOccurs;
; 358  :     int maxOccurs;
; 359  :     xmlNodePtr node;
; 360  : };
; 361  : 
; 362  : typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;
; 363  : typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;
; 364  : struct _xmlSchemaModelGroup {
; 365  :     xmlSchemaTypeType type;
; 366  :     xmlSchemaAnnotPtr annot;
; 367  :     xmlSchemaTreeItemPtr next;
; 368  :     xmlSchemaTreeItemPtr children;
; 369  :     xmlNodePtr node;
; 370  : };
; 371  : 
; 372  : static xmlSchemaParticlePtr
; 373  : xmlSchemaAddParticle(void)
; 374  : {
; 375  :     xmlSchemaParticlePtr ret = NULL;
; 376  : 
; 377  :     ret = (xmlSchemaParticlePtr)
; 378  : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 379  :     if (ret == NULL) {
; 380  : 	xmlSchemaTypeErrMemory(NULL, "allocating particle component");
; 381  : 	return (NULL);
; 382  :     }
; 383  :     memset(ret, 0, sizeof(xmlSchemaParticle));
; 384  :     ret->type = XML_SCHEMA_TYPE_PARTICLE;
; 385  :     ret->minOccurs = 1;
; 386  :     ret->maxOccurs = 1;
; 387  :     return (ret);
; 388  : }
; 389  : 
; 390  : /*
; 391  :  * xmlSchemaInitTypes:
; 392  :  *
; 393  :  * Initialize the default XML Schemas type library
; 394  :  */
; 395  : void
; 396  : xmlSchemaInitTypes(void)
; 397  : {
; 398  :     if (xmlSchemaTypesInitialized != 0)
; 399  :         return;
; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);
; 401  : 
; 402  : 
; 403  :     /*
; 404  :     * 3.4.7 Built-in Complex Type Definition
; 405  :     */
; 406  :     xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",
; 407  :                                                      XML_SCHEMAS_ANYTYPE,
; 408  : 						     NULL);
; 409  :     xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;
; 410  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 411  :     /*
; 412  :     * Init the content type.
; 413  :     */
; 414  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 415  :     {
; 416  : 	xmlSchemaParticlePtr particle;
; 417  : 	xmlSchemaModelGroupPtr sequence;
; 418  : 	xmlSchemaWildcardPtr wild;
; 419  : 	/* First particle. */
; 420  : 	particle = xmlSchemaAddParticle();
; 421  : 	if (particle == NULL)
; 422  : 	    return;
; 423  : 	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;
; 424  : 	/* Sequence model group. */
; 425  : 	sequence = (xmlSchemaModelGroupPtr)
; 426  : 	    xmlMalloc(sizeof(xmlSchemaModelGroup));
; 427  : 	if (sequence == NULL) {
; 428  : 	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");
; 429  : 	    return;
; 430  : 	}
; 431  : 	memset(sequence, 0, sizeof(xmlSchemaModelGroup));
; 432  : 	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;
; 433  : 	particle->children = (xmlSchemaTreeItemPtr) sequence;
; 434  : 	/* Second particle. */
; 435  : 	particle = xmlSchemaAddParticle();
; 436  : 	if (particle == NULL)
; 437  : 	    return;
; 438  : 	particle->minOccurs = 0;
; 439  : 	particle->maxOccurs = UNBOUNDED;
; 440  : 	sequence->children = (xmlSchemaTreeItemPtr) particle;
; 441  : 	/* The wildcard */
; 442  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 443  : 	if (wild == NULL) {
; 444  : 	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");
; 445  : 	    return;
; 446  : 	}
; 447  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 448  : 	wild->type = XML_SCHEMA_TYPE_ANY;
; 449  : 	wild->any = 1;
; 450  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 451  : 	particle->children = (xmlSchemaTreeItemPtr) wild;
; 452  : 	/*
; 453  : 	* Create the attribute wildcard.
; 454  : 	*/
; 455  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 456  : 	if (wild == NULL) {
; 457  : 	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "
; 458  : 		"wildcard on anyType");
; 459  : 	    return;
; 460  : 	}
; 461  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 462  : 	wild->any = 1;
; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;
; 465  :     }
; 466  :     xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",
; 467  :                                                            XML_SCHEMAS_ANYSIMPLETYPE,
; 468  : 							   xmlSchemaTypeAnyTypeDef);
; 469  :     /*
; 470  :     * primitive datatypes
; 471  :     */
; 472  :     xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",
; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",
; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",
; 479  :                                                   XML_SCHEMAS_DATE,
; 480  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 481  :     xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",
; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",
; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",
; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",
; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",
; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",
; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",
; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",
; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",
; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",
; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",
; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",
; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",
; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,
; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",
; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",
; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",
; 534  :                                                      XML_SCHEMAS_INTEGER,
; 535  : 						     xmlSchemaTypeDecimalDef);
; 536  :     xmlSchemaTypeNonPositiveIntegerDef =
; 537  :         xmlSchemaInitBasicType("nonPositiveInteger",
; 538  :                                XML_SCHEMAS_NPINTEGER,
; 539  : 			       xmlSchemaTypeIntegerDef);
; 540  :     xmlSchemaTypeNegativeIntegerDef =
; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =
; 544  :         xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
; 545  : 	xmlSchemaTypeIntegerDef);
; 546  :     xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,
; 547  : 	xmlSchemaTypeLongDef);
; 548  :     xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",
; 549  :                                                    XML_SCHEMAS_SHORT,
; 550  : 						   xmlSchemaTypeIntDef);
; 551  :     xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",
; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =
; 555  :         xmlSchemaInitBasicType("nonNegativeInteger",
; 556  :                                XML_SCHEMAS_NNINTEGER,
; 557  : 			       xmlSchemaTypeIntegerDef);
; 558  :     xmlSchemaTypeUnsignedLongDef =
; 559  :         xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
; 560  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 561  :     xmlSchemaTypeUnsignedIntDef =
; 562  :         xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
; 563  : 	xmlSchemaTypeUnsignedLongDef);
; 564  :     xmlSchemaTypeUnsignedShortDef =
; 565  :         xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
; 566  : 	xmlSchemaTypeUnsignedIntDef);
; 567  :     xmlSchemaTypeUnsignedByteDef =
; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =
; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",
; 574  :                                                         XML_SCHEMAS_NORMSTRING,
; 575  : 							xmlSchemaTypeStringDef);
; 576  :     xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",
; 577  :                                                    XML_SCHEMAS_TOKEN,
; 578  : 						   xmlSchemaTypeNormStringDef);
; 579  :     xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",
; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",
; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",
; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",
; 589  :                                                     XML_SCHEMAS_NCNAME,
; 590  : 						    xmlSchemaTypeNameDef);
; 591  :     xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,
; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",
; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",
; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",
; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;
; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",
; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;
; 612  : 
; 613  :     /* NMTOKENS */
; 614  :     xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",
; 615  :                                                       XML_SCHEMAS_NMTOKENS,
; 616  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 617  :     xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;
; 618  : 
; 619  :     xmlSchemaTypesInitialized = 1;
; 620  : }
; 621  : 
; 622  : static void
; 623  : xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {
; 624  :     xmlSchemaFreeType((xmlSchemaTypePtr) type);
; 625  : }
; 626  : 
; 627  : /**
; 628  :  * xmlSchemaCleanupTypes:
; 629  :  *
; 630  :  * Cleanup the default XML Schemas type library
; 631  :  */
; 632  : void
; 633  : xmlSchemaCleanupTypes(void) {
; 634  :     if (xmlSchemaTypesInitialized == 0)
; 635  : 	return;
; 636  :     /*
; 637  :     * Free xs:anyType.
; 638  :     */
; 639  :     {
; 640  : 	xmlSchemaParticlePtr particle;
; 641  : 	/* Attribute wildcard. */
; 642  : 	xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);
; 643  : 	/* Content type. */
; 644  : 	particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;
; 645  : 	/* Wildcard. */
; 646  : 	xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)
; 647  : 	    particle->children->children->children);
; 648  : 	xmlFree((xmlSchemaParticlePtr) particle->children->children);
; 649  : 	/* Sequence model group. */
; 650  : 	xmlFree((xmlSchemaModelGroupPtr) particle->children);
; 651  : 	xmlFree((xmlSchemaParticlePtr) particle);
; 652  : 	xmlSchemaTypeAnyTypeDef->subtypes = NULL;
; 653  :     }
; 654  :     xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);
; 655  :     xmlSchemaTypesInitialized = 0;
; 656  : }
; 657  : 
; 658  : /**
; 659  :  * xmlSchemaIsBuiltInTypeFacet:
; 660  :  * @type: the built-in type
; 661  :  * @facetType:  the facet type
; 662  :  *
; 663  :  * Evaluates if a specific facet can be
; 664  :  * used in conjunction with a type.
; 665  :  *
; 666  :  * Returns 1 if the facet can be used with the given built-in type,
; 667  :  * 0 otherwise and -1 in case the type is not a built-in type.
; 668  :  */
; 669  : int
; 670  : xmlSchemaIsBuiltInTypeFacet(xmlSchemaTypePtr type, int facetType)
; 671  : {
; 672  :     if (type == NULL)
; 673  : 	return (-1);
; 674  :     if (type->type != XML_SCHEMA_TYPE_BASIC)
; 675  : 	return (-1);
; 676  :     switch (type->builtInType) {
; 677  : 	case XML_SCHEMAS_BOOLEAN:
; 678  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 679  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 680  : 		return (1);
; 681  : 	    else
; 682  : 		return (0);
; 683  : 	case XML_SCHEMAS_STRING:
; 684  : 	case XML_SCHEMAS_NOTATION:
; 685  : 	case XML_SCHEMAS_QNAME:
; 686  : 	case XML_SCHEMAS_ANYURI:
; 687  : 	case XML_SCHEMAS_BASE64BINARY:
; 688  : 	case XML_SCHEMAS_HEXBINARY:
; 689  : 	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 690  : 		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
; 691  : 		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
; 692  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 693  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 694  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 695  : 		return (1);
; 696  : 	    else
; 697  : 		return (0);
; 698  : 	case XML_SCHEMAS_DECIMAL:
; 699  : 	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
; 700  : 		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
; 701  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 702  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 703  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 704  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 705  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 706  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 707  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 708  : 		return (1);
; 709  : 	    else
; 710  : 		return (0);
; 711  : 	case XML_SCHEMAS_TIME:
; 712  : 	case XML_SCHEMAS_GDAY:
; 713  : 	case XML_SCHEMAS_GMONTH:
; 714  : 	case XML_SCHEMAS_GMONTHDAY:
; 715  : 	case XML_SCHEMAS_GYEAR:
; 716  : 	case XML_SCHEMAS_GYEARMONTH:
; 717  : 	case XML_SCHEMAS_DATE:
; 718  : 	case XML_SCHEMAS_DATETIME:
; 719  : 	case XML_SCHEMAS_DURATION:
; 720  : 	case XML_SCHEMAS_FLOAT:
; 721  : 	case XML_SCHEMAS_DOUBLE:
; 722  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 723  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 724  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 725  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 726  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 727  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 728  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 729  : 		return (1);
; 730  : 	    else
; 731  : 		return (0);
; 732  : 	default:
; 733  : 	    break;
; 734  :     }
; 735  :     return (0);
; 736  : }
; 737  : 
; 738  : /**
; 739  :  * xmlSchemaGetBuiltInType:
; 740  :  * @type:  the type of the built in type
; 741  :  *
; 742  :  * Gives you the type struct for a built-in
; 743  :  * type by its type id.
; 744  :  *
; 745  :  * Returns the type if found, NULL otherwise.
; 746  :  */
; 747  : xmlSchemaTypePtr
; 748  : xmlSchemaGetBuiltInType(xmlSchemaValType type)
; 749  : {
; 750  :     if (xmlSchemaTypesInitialized == 0)
; 751  : 	xmlSchemaInitTypes();
; 752  :     switch (type) {
; 753  : 
; 754  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 755  : 	    return (xmlSchemaTypeAnySimpleTypeDef);
; 756  : 	case XML_SCHEMAS_STRING:
; 757  : 	    return (xmlSchemaTypeStringDef);
; 758  : 	case XML_SCHEMAS_NORMSTRING:
; 759  : 	    return (xmlSchemaTypeNormStringDef);
; 760  : 	case XML_SCHEMAS_DECIMAL:
; 761  : 	    return (xmlSchemaTypeDecimalDef);
; 762  : 	case XML_SCHEMAS_TIME:
; 763  : 	    return (xmlSchemaTypeTimeDef);
; 764  : 	case XML_SCHEMAS_GDAY:
; 765  : 	    return (xmlSchemaTypeGDayDef);
; 766  : 	case XML_SCHEMAS_GMONTH:
; 767  : 	    return (xmlSchemaTypeGMonthDef);
; 768  : 	case XML_SCHEMAS_GMONTHDAY:
; 769  : 	    return (xmlSchemaTypeGMonthDayDef);
; 770  : 	case XML_SCHEMAS_GYEAR:
; 771  : 	    return (xmlSchemaTypeGYearDef);
; 772  : 	case XML_SCHEMAS_GYEARMONTH:
; 773  : 	    return (xmlSchemaTypeGYearMonthDef);
; 774  : 	case XML_SCHEMAS_DATE:
; 775  : 	    return (xmlSchemaTypeDateDef);
; 776  : 	case XML_SCHEMAS_DATETIME:
; 777  : 	    return (xmlSchemaTypeDatetimeDef);
; 778  : 	case XML_SCHEMAS_DURATION:
; 779  : 	    return (xmlSchemaTypeDurationDef);
; 780  : 	case XML_SCHEMAS_FLOAT:
; 781  : 	    return (xmlSchemaTypeFloatDef);
; 782  : 	case XML_SCHEMAS_DOUBLE:
; 783  : 	    return (xmlSchemaTypeDoubleDef);
; 784  : 	case XML_SCHEMAS_BOOLEAN:
; 785  : 	    return (xmlSchemaTypeBooleanDef);
; 786  : 	case XML_SCHEMAS_TOKEN:
; 787  : 	    return (xmlSchemaTypeTokenDef);
; 788  : 	case XML_SCHEMAS_LANGUAGE:
; 789  : 	    return (xmlSchemaTypeLanguageDef);
; 790  : 	case XML_SCHEMAS_NMTOKEN:
; 791  : 	    return (xmlSchemaTypeNmtokenDef);
; 792  : 	case XML_SCHEMAS_NMTOKENS:
; 793  : 	    return (xmlSchemaTypeNmtokensDef);
; 794  : 	case XML_SCHEMAS_NAME:
; 795  : 	    return (xmlSchemaTypeNameDef);
; 796  : 	case XML_SCHEMAS_QNAME:
; 797  : 	    return (xmlSchemaTypeQNameDef);
; 798  : 	case XML_SCHEMAS_NCNAME:
; 799  : 	    return (xmlSchemaTypeNCNameDef);
; 800  : 	case XML_SCHEMAS_ID:
; 801  : 	    return (xmlSchemaTypeIdDef);
; 802  : 	case XML_SCHEMAS_IDREF:
; 803  : 	    return (xmlSchemaTypeIdrefDef);
; 804  : 	case XML_SCHEMAS_IDREFS:
; 805  : 	    return (xmlSchemaTypeIdrefsDef);
; 806  : 	case XML_SCHEMAS_ENTITY:
; 807  : 	    return (xmlSchemaTypeEntityDef);
; 808  : 	case XML_SCHEMAS_ENTITIES:
; 809  : 	    return (xmlSchemaTypeEntitiesDef);
; 810  : 	case XML_SCHEMAS_NOTATION:
; 811  : 	    return (xmlSchemaTypeNotationDef);
; 812  : 	case XML_SCHEMAS_ANYURI:
; 813  : 	    return (xmlSchemaTypeAnyURIDef);
; 814  : 	case XML_SCHEMAS_INTEGER:
; 815  : 	    return (xmlSchemaTypeIntegerDef);
; 816  : 	case XML_SCHEMAS_NPINTEGER:
; 817  : 	    return (xmlSchemaTypeNonPositiveIntegerDef);
; 818  : 	case XML_SCHEMAS_NINTEGER:
; 819  : 	    return (xmlSchemaTypeNegativeIntegerDef);
; 820  : 	case XML_SCHEMAS_NNINTEGER:
; 821  : 	    return (xmlSchemaTypeNonNegativeIntegerDef);
; 822  : 	case XML_SCHEMAS_PINTEGER:
; 823  : 	    return (xmlSchemaTypePositiveIntegerDef);
; 824  : 	case XML_SCHEMAS_INT:
; 825  : 	    return (xmlSchemaTypeIntDef);
; 826  : 	case XML_SCHEMAS_UINT:
; 827  : 	    return (xmlSchemaTypeUnsignedIntDef);
; 828  : 	case XML_SCHEMAS_LONG:
; 829  : 	    return (xmlSchemaTypeLongDef);
; 830  : 	case XML_SCHEMAS_ULONG:
; 831  : 	    return (xmlSchemaTypeUnsignedLongDef);
; 832  : 	case XML_SCHEMAS_SHORT:
; 833  : 	    return (xmlSchemaTypeShortDef);
; 834  : 	case XML_SCHEMAS_USHORT:
; 835  : 	    return (xmlSchemaTypeUnsignedShortDef);
; 836  : 	case XML_SCHEMAS_BYTE:
; 837  : 	    return (xmlSchemaTypeByteDef);
; 838  : 	case XML_SCHEMAS_UBYTE:
; 839  : 	    return (xmlSchemaTypeUnsignedByteDef);
; 840  : 	case XML_SCHEMAS_HEXBINARY:
; 841  : 	    return (xmlSchemaTypeHexBinaryDef);
; 842  : 	case XML_SCHEMAS_BASE64BINARY:
; 843  : 	    return (xmlSchemaTypeBase64BinaryDef);
; 844  : 	case XML_SCHEMAS_ANYTYPE:
; 845  : 	    return (xmlSchemaTypeAnyTypeDef);
; 846  : 	default:
; 847  : 	    return (NULL);
; 848  :     }
; 849  : }
; 850  : 
; 851  : /**
; 852  :  * xmlSchemaValueAppend:
; 853  :  * @prev: the value
; 854  :  * @cur: the value to be appended
; 855  :  *
; 856  :  * Appends a next sibling to a list of computed values.
; 857  :  *
; 858  :  * Returns 0 if succeeded and -1 on API errors.
; 859  :  */
; 860  : int
; 861  : xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {
; 862  : 
; 863  :     if ((prev == NULL) || (cur == NULL))
; 864  : 	return (-1);
; 865  :     prev->next = cur;
; 866  :     return (0);
; 867  : }
; 868  : 
; 869  : /**
; 870  :  * xmlSchemaValueGetNext:
; 871  :  * @cur: the value
; 872  :  *
; 873  :  * Accessor for the next sibling of a list of computed values.
; 874  :  *
; 875  :  * Returns the next value or NULL if there was none, or on
; 876  :  *         API errors.
; 877  :  */
; 878  : xmlSchemaValPtr
; 879  : xmlSchemaValueGetNext(xmlSchemaValPtr cur) {
; 880  : 
; 881  :     if (cur == NULL)
; 882  : 	return (NULL);
; 883  :     return (cur->next);
; 884  : }
; 885  : 
; 886  : /**
; 887  :  * xmlSchemaValueGetAsString:
; 888  :  * @val: the value
; 889  :  *
; 890  :  * Accessor for the string value of a computed value.
; 891  :  *
; 892  :  * Returns the string value or NULL if there was none, or on
; 893  :  *         API errors.
; 894  :  */
; 895  : const xmlChar *
; 896  : xmlSchemaValueGetAsString(xmlSchemaValPtr val)
; 897  : {
; 898  :     if (val == NULL)
; 899  : 	return (NULL);
; 900  :     switch (val->type) {
; 901  : 	case XML_SCHEMAS_STRING:
; 902  : 	case XML_SCHEMAS_NORMSTRING:
; 903  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 904  : 	case XML_SCHEMAS_TOKEN:
; 905  :         case XML_SCHEMAS_LANGUAGE:
; 906  :         case XML_SCHEMAS_NMTOKEN:
; 907  :         case XML_SCHEMAS_NAME:
; 908  :         case XML_SCHEMAS_NCNAME:
; 909  :         case XML_SCHEMAS_ID:
; 910  :         case XML_SCHEMAS_IDREF:
; 911  :         case XML_SCHEMAS_ENTITY:
; 912  :         case XML_SCHEMAS_ANYURI:
; 913  : 	    return (BAD_CAST val->value.str);
; 914  : 	default:
; 915  : 	    break;
; 916  :     }
; 917  :     return (NULL);
; 918  : }
; 919  : 
; 920  : /**
; 921  :  * xmlSchemaValueGetAsBoolean:
; 922  :  * @val: the value
; 923  :  *
; 924  :  * Accessor for the boolean value of a computed value.
; 925  :  *
; 926  :  * Returns 1 if true and 0 if false, or in case of an error. Hmm.
; 927  :  */
; 928  : int
; 929  : xmlSchemaValueGetAsBoolean(xmlSchemaValPtr val)
; 930  : {
; 931  :     if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))
; 932  : 	return (0);
; 933  :     return (val->value.b);
; 934  : }
; 935  : 
; 936  : /**
; 937  :  * xmlSchemaNewStringValue:
; 938  :  * @type:  the value type
; 939  :  * @value:  the value
; 940  :  *
; 941  :  * Allocate a new simple type value. The type can be
; 942  :  * of XML_SCHEMAS_STRING.
; 943  :  * WARNING: This one is intended to be expanded for other
; 944  :  * string based types. We need this for anySimpleType as well.
; 945  :  * The given value is consumed and freed with the struct.
; 946  :  *
; 947  :  * Returns a pointer to the new value or NULL in case of error
; 948  :  */
; 949  : xmlSchemaValPtr
; 950  : xmlSchemaNewStringValue(xmlSchemaValType type,
; 951  : 			const xmlChar *value)
; 952  : {
; 953  :     xmlSchemaValPtr val;
; 954  : 
; 955  :     if (type != XML_SCHEMAS_STRING)
; 956  : 	return(NULL);
; 957  :     val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));
; 958  :     if (val == NULL) {
; 959  : 	return(NULL);
; 960  :     }
; 961  :     memset(val, 0, sizeof(xmlSchemaVal));
; 962  :     val->type = type;
; 963  :     val->value.str = (xmlChar *) value;
; 964  :     return(val);
; 965  : }
; 966  : 
; 967  : /**
; 968  :  * xmlSchemaNewNOTATIONValue:
; 969  :  * @name:  the notation name
; 970  :  * @ns: the notation namespace name or NULL
; 971  :  *
; 972  :  * Allocate a new NOTATION value.
; 973  :  * The given values are consumed and freed with the struct.
; 974  :  *
; 975  :  * Returns a pointer to the new value or NULL in case of error
; 976  :  */
; 977  : xmlSchemaValPtr
; 978  : xmlSchemaNewNOTATIONValue(const xmlChar *name,
; 979  : 			  const xmlChar *ns)
; 980  : {
; 981  :     xmlSchemaValPtr val;
; 982  : 
; 983  :     val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 984  :     if (val == NULL)
; 985  : 	return (NULL);
; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;
; 988  :     if (ns != NULL)
; 989  : 	val->value.qname.uri = (xmlChar *)ns;
; 990  :     return(val);
; 991  : }
; 992  : 
; 993  : /**
; 994  :  * xmlSchemaNewQNameValue:
; 995  :  * @namespaceName: the namespace name
; 996  :  * @localName: the local name
; 997  :  *
; 998  :  * Allocate a new QName value.
; 999  :  * The given values are consumed and freed with the struct.
; 1000 :  *
; 1001 :  * Returns a pointer to the new value or NULL in case of an error.
; 1002 :  */
; 1003 : xmlSchemaValPtr
; 1004 : xmlSchemaNewQNameValue(const xmlChar *namespaceName,
; 1005 : 		       const xmlChar *localName)
; 1006 : {
; 1007 :     xmlSchemaValPtr val;
; 1008 : 
; 1009 :     val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 1010 :     if (val == NULL)
; 1011 : 	return (NULL);
; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;
; 1014 :     val->value.qname.uri = (xmlChar *) namespaceName;
; 1015 :     return(val);
; 1016 : }
; 1017 : 
; 1018 : /**
; 1019 :  * xmlSchemaFreeValue:
; 1020 :  * @value:  the value to free
; 1021 :  *
; 1022 :  * Cleanup the default XML Schemas type library
; 1023 :  */
; 1024 : void
; 1025 : xmlSchemaFreeValue(xmlSchemaValPtr value) {
; 1026 :     xmlSchemaValPtr prev;
; 1027 : 
; 1028 :     while (value != NULL) {
; 1029 : 	switch (value->type) {
; 1030 : 	    case XML_SCHEMAS_STRING:
; 1031 : 	    case XML_SCHEMAS_NORMSTRING:
; 1032 : 	    case XML_SCHEMAS_TOKEN:
; 1033 : 	    case XML_SCHEMAS_LANGUAGE:
; 1034 : 	    case XML_SCHEMAS_NMTOKEN:
; 1035 : 	    case XML_SCHEMAS_NMTOKENS:
; 1036 : 	    case XML_SCHEMAS_NAME:
; 1037 : 	    case XML_SCHEMAS_NCNAME:
; 1038 : 	    case XML_SCHEMAS_ID:
; 1039 : 	    case XML_SCHEMAS_IDREF:
; 1040 : 	    case XML_SCHEMAS_IDREFS:
; 1041 : 	    case XML_SCHEMAS_ENTITY:
; 1042 : 	    case XML_SCHEMAS_ENTITIES:
; 1043 : 	    case XML_SCHEMAS_ANYURI:
; 1044 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1045 : 		if (value->value.str != NULL)
; 1046 : 		    xmlFree(value->value.str);
; 1047 : 		break;
; 1048 : 	    case XML_SCHEMAS_NOTATION:
; 1049 : 	    case XML_SCHEMAS_QNAME:
; 1050 : 		if (value->value.qname.uri != NULL)
; 1051 : 		    xmlFree(value->value.qname.uri);
; 1052 : 		if (value->value.qname.name != NULL)
; 1053 : 		    xmlFree(value->value.qname.name);
; 1054 : 		break;
; 1055 : 	    case XML_SCHEMAS_HEXBINARY:
; 1056 : 		if (value->value.hex.str != NULL)
; 1057 : 		    xmlFree(value->value.hex.str);
; 1058 : 		break;
; 1059 : 	    case XML_SCHEMAS_BASE64BINARY:
; 1060 : 		if (value->value.base64.str != NULL)
; 1061 : 		    xmlFree(value->value.base64.str);
; 1062 : 		break;
; 1063 : 	    default:
; 1064 : 		break;
; 1065 : 	}
; 1066 : 	prev = value;
; 1067 : 	value = value->next;
; 1068 : 	xmlFree(prev);
; 1069 :     }
; 1070 : }
; 1071 : 
; 1072 : /**
; 1073 :  * xmlSchemaGetPredefinedType:
; 1074 :  * @name: the type name
; 1075 :  * @ns:  the URI of the namespace usually "http://www.w3.org/2001/XMLSchema"
; 1076 :  *
; 1077 :  * Lookup a type in the default XML Schemas type library
; 1078 :  *
; 1079 :  * Returns the type if found, NULL otherwise
; 1080 :  */
; 1081 : xmlSchemaTypePtr
; 1082 : xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {
; 1083 :     if (xmlSchemaTypesInitialized == 0)
; 1084 : 	xmlSchemaInitTypes();
; 1085 :     if (name == NULL)
; 1086 : 	return(NULL);
; 1087 :     return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));
; 1088 : }
; 1089 : 
; 1090 : /**
; 1091 :  * xmlSchemaGetBuiltInListSimpleTypeItemType:
; 1092 :  * @type: the built-in simple type.
; 1093 :  *
; 1094 :  * Lookup function
; 1095 :  *
; 1096 :  * Returns the item type of @type as defined by the built-in datatype
; 1097 :  * hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.
; 1098 :  */
; 1099 : xmlSchemaTypePtr
; 1100 : xmlSchemaGetBuiltInListSimpleTypeItemType(xmlSchemaTypePtr type)
; 1101 : {
; 1102 :     if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))
; 1103 : 	return (NULL);
; 1104 :     switch (type->builtInType) {
; 1105 : 	case XML_SCHEMAS_NMTOKENS:
; 1106 : 	    return (xmlSchemaTypeNmtokenDef );
; 1107 : 	case XML_SCHEMAS_IDREFS:
; 1108 : 	    return (xmlSchemaTypeIdrefDef);
; 1109 : 	case XML_SCHEMAS_ENTITIES:
; 1110 : 	    return (xmlSchemaTypeEntityDef);
; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }
; 1115 : 
; 1116 : /****************************************************************
; 1117 :  *								*
; 1118 :  *		Convenience macros and functions		*
; 1119 :  *								*
; 1120 :  ****************************************************************/
; 1121 : 
; 1122 : #define IS_TZO_CHAR(c)						\
; 1123 : 	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
; 1124 : 
; 1125 : #define VALID_YEAR(yr)          (yr != 0)
; 1126 : #define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
; 1127 : /* VALID_DAY should only be used when month is unknown */
; 1128 : #define VALID_DAY(day)          ((day >= 1) && (day <= 31))
; 1129 : #define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
; 1130 : #define VALID_MIN(min)          ((min >= 0) && (min <= 59))
; 1131 : #define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))
; 1132 : #define VALID_TZO(tzo)          ((tzo > -840) && (tzo < 840))
; 1133 : #define IS_LEAP(y)						\
; 1134 : 	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
; 1135 : 
; 1136 : static const unsigned int daysInMonth[12] =
; 1137 : 	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1138 : static const unsigned int daysInMonthLeap[12] =
; 1139 : 	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1140 : 
; 1141 : #define MAX_DAYINMONTH(yr,mon)                                  \
; 1142 :         (IS_LEAP(yr) ? daysInMonthLeap[mon - 1] : daysInMonth[mon - 1])
; 1143 : 
; 1144 : #define VALID_MDAY(dt)						\
; 1145 : 	(IS_LEAP(dt->year) ?				        \
; 1146 : 	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
; 1147 : 	    (dt->day <= daysInMonth[dt->mon - 1]))
; 1148 : 
; 1149 : #define VALID_DATE(dt)						\
; 1150 : 	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
; 1151 : 
; 1152 : #define VALID_END_OF_DAY(dt)					\
; 1153 : 	((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)
; 1154 : 
; 1155 : #define VALID_TIME(dt)						\
; 1156 : 	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
; 1157 : 	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
; 1158 : 	 VALID_TZO(dt->tzo))
; 1159 : 
; 1160 : #define VALID_DATETIME(dt)					\
; 1161 : 	(VALID_DATE(dt) && VALID_TIME(dt))
; 1162 : 
; 1163 : #define SECS_PER_MIN            (60)
; 1164 : #define SECS_PER_HOUR           (60 * SECS_PER_MIN)
; 1165 : #define SECS_PER_DAY            (24 * SECS_PER_HOUR)
; 1166 : 
; 1167 : static const long dayInYearByMonth[12] =
; 1168 : 	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
; 1169 : static const long dayInLeapYearByMonth[12] =
; 1170 : 	{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };
; 1171 : 
; 1172 : #define DAY_IN_YEAR(day, month, year)				\
; 1173 :         ((IS_LEAP(year) ?					\
; 1174 :                 dayInLeapYearByMonth[month - 1] :		\
; 1175 :                 dayInYearByMonth[month - 1]) + day)
; 1176 : 
; 1177 : #ifdef DEBUG
; 1178 : #define DEBUG_DATE(dt)                                                  \
; 1179 :     xmlGenericError(xmlGenericErrorContext,                             \
; 1180 :         "type=%o %04ld-%02u-%02uT%02u:%02u:%03f",                       \
; 1181 :         dt->type,dt->value.date.year,dt->value.date.mon,                \
; 1182 :         dt->value.date.day,dt->value.date.hour,dt->value.date.min,      \
; 1183 :         dt->value.date.sec);                                            \
; 1184 :     if (dt->value.date.tz_flag)                                         \
; 1185 :         if (dt->value.date.tzo != 0)                                    \
; 1186 :             xmlGenericError(xmlGenericErrorContext,                     \
; 1187 :                 "%+05d\n",dt->value.date.tzo);                          \
; 1188 :         else                                                            \
; 1189 :             xmlGenericError(xmlGenericErrorContext, "Z\n");             \
; 1190 :     else                                                                \
; 1191 :         xmlGenericError(xmlGenericErrorContext,"\n")
; 1192 : #else
; 1193 : #define DEBUG_DATE(dt)
; 1194 : #endif
; 1195 : 
; 1196 : /**
; 1197 :  * _xmlSchemaParseGYear:
; 1198 :  * @dt:  pointer to a date structure
; 1199 :  * @str: pointer to the string to analyze
; 1200 :  *
; 1201 :  * Parses a xs:gYear without time zone and fills in the appropriate
; 1202 :  * field of the @dt structure. @str is updated to point just after the
; 1203 :  * xs:gYear. It is supposed that @dt->year is big enough to contain
; 1204 :  * the year.
; 1205 :  *
; 1206 :  * Returns 0 or the error code
; 1207 :  */
; 1208 : static int
; 1209 : _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1210 :     const xmlChar *cur = *str, *firstChar;
; 1211 :     int isneg = 0, digcnt = 0;
; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))
; 1215 : 	return -1;
; 1216 : 
; 1217 :     if (*cur == '-') {
; 1218 : 	isneg = 1;
; 1219 : 	cur++;
; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;
; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {
; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');
; 1226 : 	cur++;
; 1227 : 	digcnt++;
; 1228 :     }
; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))
; 1233 : 	return 1;
; 1234 : 
; 1235 :     if (isneg)
; 1236 : 	dt->year = - dt->year;
; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))
; 1239 : 	return 2;
; 1240 : 
; 1241 :     *str = cur;
; 1242 :     return 0;
; 1243 : }
; 1244 : 
; 1245 : /**
; 1246 :  * PARSE_2_DIGITS:
; 1247 :  * @num:  the integer to fill in
; 1248 :  * @cur:  an #xmlChar *
; 1249 :  * @invalid: an integer
; 1250 :  *
; 1251 :  * Parses a 2-digits integer and updates @num with the value. @cur is
; 1252 :  * updated to point just after the integer.
; 1253 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1254 :  * @cur are undefined.
; 1255 :  */
; 1256 : #define PARSE_2_DIGITS(num, cur, invalid)			\
; 1257 : 	if ((cur[0] < '0') || (cur[0] > '9') ||			\
; 1258 : 	    (cur[1] < '0') || (cur[1] > '9'))			\
; 1259 : 	    invalid = 1;					\
; 1260 : 	else							\
; 1261 : 	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
; 1262 : 	cur += 2;
; 1263 : 
; 1264 : /**
; 1265 :  * PARSE_FLOAT:
; 1266 :  * @num:  the double to fill in
; 1267 :  * @cur:  an #xmlChar *
; 1268 :  * @invalid: an integer
; 1269 :  *
; 1270 :  * Parses a float and updates @num with the value. @cur is
; 1271 :  * updated to point just after the float. The float must have a
; 1272 :  * 2-digits integer part and may or may not have a decimal part.
; 1273 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1274 :  * @cur are undefined.
; 1275 :  */
; 1276 : #define PARSE_FLOAT(num, cur, invalid)				\
; 1277 : 	PARSE_2_DIGITS(num, cur, invalid);			\
; 1278 : 	if (!invalid && (*cur == '.')) {			\
; 1279 : 	    double mult = 1;				        \
; 1280 : 	    cur++;						\
; 1281 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1282 : 		invalid = 1;					\
; 1283 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1284 : 		mult /= 10;					\
; 1285 : 		num += (*cur - '0') * mult;			\
; 1286 : 		cur++;						\
; 1287 : 	    }							\
; 1288 : 	}
; 1289 : 
; 1290 : /**
; 1291 :  * _xmlSchemaParseGMonth:
; 1292 :  * @dt:  pointer to a date structure
; 1293 :  * @str: pointer to the string to analyze
; 1294 :  *
; 1295 :  * Parses a xs:gMonth without time zone and fills in the appropriate
; 1296 :  * field of the @dt structure. @str is updated to point just after the
; 1297 :  * xs:gMonth.
; 1298 :  *
; 1299 :  * Returns 0 or the error code
; 1300 :  */
; 1301 : static int
; 1302 : _xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1303 :     const xmlChar *cur = *str;
; 1304 :     int ret = 0;
; 1305 :     unsigned int value = 0;
; 1306 : 
; 1307 :     PARSE_2_DIGITS(value, cur, ret);
; 1308 :     if (ret != 0)
; 1309 : 	return ret;
; 1310 : 
; 1311 :     if (!VALID_MONTH(value))
; 1312 : 	return 2;
; 1313 : 
; 1314 :     dt->mon = value;
; 1315 : 
; 1316 :     *str = cur;
; 1317 :     return 0;
; 1318 : }
; 1319 : 
; 1320 : /**
; 1321 :  * _xmlSchemaParseGDay:
; 1322 :  * @dt:  pointer to a date structure
; 1323 :  * @str: pointer to the string to analyze
; 1324 :  *
; 1325 :  * Parses a xs:gDay without time zone and fills in the appropriate
; 1326 :  * field of the @dt structure. @str is updated to point just after the
; 1327 :  * xs:gDay.
; 1328 :  *
; 1329 :  * Returns 0 or the error code
; 1330 :  */
; 1331 : static int
; 1332 : _xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1333 :     const xmlChar *cur = *str;
; 1334 :     int ret = 0;
; 1335 :     unsigned int value = 0;
; 1336 : 
; 1337 :     PARSE_2_DIGITS(value, cur, ret);
; 1338 :     if (ret != 0)
; 1339 : 	return ret;
; 1340 : 
; 1341 :     if (!VALID_DAY(value))
; 1342 : 	return 2;
; 1343 : 
; 1344 :     dt->day = value;
; 1345 :     *str = cur;
; 1346 :     return 0;
; 1347 : }
; 1348 : 
; 1349 : /**
; 1350 :  * _xmlSchemaParseTime:
; 1351 :  * @dt:  pointer to a date structure
; 1352 :  * @str: pointer to the string to analyze
; 1353 :  *
; 1354 :  * Parses a xs:time without time zone and fills in the appropriate
; 1355 :  * fields of the @dt structure. @str is updated to point just after the
; 1356 :  * xs:time.
; 1357 :  * In case of error, values of @dt fields are undefined.
; 1358 :  *
; 1359 :  * Returns 0 or the error code
; 1360 :  */
; 1361 : static int
; 1362 : _xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1363 :     const xmlChar *cur = *str;
; 1364 :     int ret = 0;
; 1365 :     int value = 0;
; 1366 : 
; 1367 :     PARSE_2_DIGITS(value, cur, ret);
; 1368 :     if (ret != 0)
; 1369 : 	return ret;
; 1370 :     if (*cur != ':')
; 1371 : 	return 1;
; 1372 :     if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)
; 1373 : 	return 2;
; 1374 :     cur++;
; 1375 : 
; 1376 :     /* the ':' insures this string is xs:time */
; 1377 :     dt->hour = value;
; 1378 : 
; 1379 :     PARSE_2_DIGITS(value, cur, ret);
; 1380 :     if (ret != 0)
; 1381 : 	return ret;
; 1382 :     if (!VALID_MIN(value))
; 1383 : 	return 2;
; 1384 :     dt->min = value;
; 1385 : 
; 1386 :     if (*cur != ':')
; 1387 : 	return 1;
; 1388 :     cur++;
; 1389 : 
; 1390 :     PARSE_FLOAT(dt->sec, cur, ret);
; 1391 :     if (ret != 0)
; 1392 : 	return ret;
; 1393 : 
; 1394 :     if (!VALID_TIME(dt))
; 1395 : 	return 2;
; 1396 : 
; 1397 :     *str = cur;
; 1398 :     return 0;
; 1399 : }
; 1400 : 
; 1401 : /**
; 1402 :  * _xmlSchemaParseTimeZone:
; 1403 :  * @dt:  pointer to a date structure
; 1404 :  * @str: pointer to the string to analyze
; 1405 :  *
; 1406 :  * Parses a time zone without time zone and fills in the appropriate
; 1407 :  * field of the @dt structure. @str is updated to point just after the
; 1408 :  * time zone.
; 1409 :  *
; 1410 :  * Returns 0 or the error code
; 1411 :  */
; 1412 : static int
; 1413 : _xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1414 :     const xmlChar *cur;
; 1415 :     int ret = 0;
; 1416 : 
; 1417 :     if (str == NULL)
; 1418 : 	return -1;
; 1419 :     cur = *str;
; 1420 : 
; 1421 :     switch (*cur) {
; 1422 :     case 0:
; 1423 : 	dt->tz_flag = 0;
; 1424 : 	dt->tzo = 0;
; 1425 : 	break;
; 1426 : 
; 1427 :     case 'Z':
; 1428 : 	dt->tz_flag = 1;
; 1429 : 	dt->tzo = 0;
; 1430 : 	cur++;
; 1431 : 	break;
; 1432 : 
; 1433 :     case '+':
; 1434 :     case '-': {
; 1435 : 	int isneg = 0, tmp = 0;
; 1436 : 	isneg = (*cur == '-');
; 1437 : 
; 1438 : 	cur++;
; 1439 : 
; 1440 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1441 : 	if (ret != 0)
; 1442 : 	    return ret;
; 1443 : 	if (!VALID_HOUR(tmp))
; 1444 : 	    return 2;
; 1445 : 
; 1446 : 	if (*cur != ':')
; 1447 : 	    return 1;
; 1448 : 	cur++;
; 1449 : 
; 1450 : 	dt->tzo = tmp * 60;
; 1451 : 
; 1452 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1453 : 	if (ret != 0)
; 1454 : 	    return ret;
; 1455 : 	if (!VALID_MIN(tmp))
; 1456 : 	    return 2;
; 1457 : 
; 1458 : 	dt->tzo += tmp;
; 1459 : 	if (isneg)
; 1460 : 	    dt->tzo = - dt->tzo;
; 1461 : 
; 1462 : 	if (!VALID_TZO(dt->tzo))
; 1463 : 	    return 2;
; 1464 : 
; 1465 : 	dt->tz_flag = 1;
; 1466 : 	break;
; 1467 :       }
; 1468 :     default:
; 1469 : 	return 1;
; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;
; 1473 :     return 0;
; 1474 : }
; 1475 : 
; 1476 : /**
; 1477 :  * _xmlSchemaBase64Decode:
; 1478 :  * @ch: a character
; 1479 :  *
; 1480 :  * Converts a base64 encoded character to its base 64 value.
; 1481 :  *
; 1482 :  * Returns 0-63 (value), 64 (pad), or -1 (not recognized)
; 1483 :  */
; 1484 : static int
; 1485 : _xmlSchemaBase64Decode (const xmlChar ch) {
; 1486 :     if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';
; 1487 :     if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;
; 1488 :     if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;
; 1489 :     if ('+' == ch) return 62;
; 1490 :     if ('/' == ch) return 63;
; 1491 :     if ('=' == ch) return 64;
; 1492 :     return -1;
; 1493 : }
; 1494 : 
; 1495 : /****************************************************************
; 1496 :  *								*
; 1497 :  *	XML Schema Dates/Times Datatypes Handling		*
; 1498 :  *								*
; 1499 :  ****************************************************************/
; 1500 : 
; 1501 : /**
; 1502 :  * PARSE_DIGITS:
; 1503 :  * @num:  the integer to fill in
; 1504 :  * @cur:  an #xmlChar *
; 1505 :  * @num_type: an integer flag
; 1506 :  *
; 1507 :  * Parses a digits integer and updates @num with the value. @cur is
; 1508 :  * updated to point just after the integer.
; 1509 :  * In case of error, @num_type is set to -1, values of @num and
; 1510 :  * @cur are undefined.
; 1511 :  */
; 1512 : #define PARSE_DIGITS(num, cur, num_type)	                \
; 1513 : 	if ((*cur < '0') || (*cur > '9'))			\
; 1514 : 	    num_type = -1;					\
; 1515 :         else                                                    \
; 1516 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1517 : 	        num = num * 10 + (*cur - '0');		        \
; 1518 : 	        cur++;                                          \
; 1519 :             }
; 1520 : 
; 1521 : /**
; 1522 :  * PARSE_NUM:
; 1523 :  * @num:  the double to fill in
; 1524 :  * @cur:  an #xmlChar *
; 1525 :  * @num_type: an integer flag
; 1526 :  *
; 1527 :  * Parses a float or integer and updates @num with the value. @cur is
; 1528 :  * updated to point just after the number. If the number is a float,
; 1529 :  * then it must have an integer part and a decimal part; @num_type will
; 1530 :  * be set to 1. If there is no decimal part, @num_type is set to zero.
; 1531 :  * In case of error, @num_type is set to -1, values of @num and
; 1532 :  * @cur are undefined.
; 1533 :  */
; 1534 : #define PARSE_NUM(num, cur, num_type)				\
; 1535 :         num = 0;                                                \
; 1536 : 	PARSE_DIGITS(num, cur, num_type);	                \
; 1537 : 	if (!num_type && (*cur == '.')) {			\
; 1538 : 	    double mult = 1;				        \
; 1539 : 	    cur++;						\
; 1540 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1541 : 		num_type = -1;					\
; 1542 :             else                                                \
; 1543 :                 num_type = 1;                                   \
; 1544 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1545 : 		mult /= 10;					\
; 1546 : 		num += (*cur - '0') * mult;			\
; 1547 : 		cur++;						\
; 1548 : 	    }							\
; 1549 : 	}
; 1550 : 
; 1551 : /**
; 1552 :  * xmlSchemaValidateDates:
; 1553 :  * @type: the expected type or XML_SCHEMAS_UNKNOWN
; 1554 :  * @dateTime:  string to analyze
; 1555 :  * @val:  the return computed value
; 1556 :  *
; 1557 :  * Check that @dateTime conforms to the lexical space of one of the date types.
; 1558 :  * if true a value is computed and returned in @val.
; 1559 :  *
; 1560 :  * Returns 0 if this validates, a positive error code number otherwise
; 1561 :  *         and -1 in case of internal or API error.
; 1562 :  */
; 1563 : static int
; 1564 : xmlSchemaValidateDates (xmlSchemaValType type,
; 1565 : 	                const xmlChar *dateTime, xmlSchemaValPtr *val,
; 1566 : 			int collapse) {
; 1567 :     xmlSchemaValPtr dt;
; 1568 :     int ret;
; 1569 :     const xmlChar *cur = dateTime;
; 1570 : 
; 1571 : #define RETURN_TYPE_IF_VALID(t)					\
; 1572 :     if (IS_TZO_CHAR(*cur)) {					\
; 1573 : 	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
; 1574 : 	if (ret == 0) {						\
; 1575 : 	    if (*cur != 0)					\
; 1576 : 		goto error;					\
; 1577 : 	    dt->type = t;					\
; 1578 : 	    goto done;						\
; 1579 : 	}							\
; 1580 :     }
; 1581 : 
; 1582 :     if (dateTime == NULL)
; 1583 : 	return -1;
; 1584 : 
; 1585 :     if (collapse)
; 1586 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1587 : 
; 1588 :     if ((*cur != '-') && (*cur < '0') && (*cur > '9'))
; 1589 : 	return 1;
; 1590 : 
; 1591 :     dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);
; 1592 :     if (dt == NULL)
; 1593 : 	return -1;
; 1594 : 
; 1595 :     if ((cur[0] == '-') && (cur[1] == '-')) {
; 1596 : 	/*
; 1597 : 	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
; 1598 : 	 * xs:gDay)
; 1599 : 	 */
; 1600 : 	cur += 2;
; 1601 : 
; 1602 : 	/* is it an xs:gDay? */
; 1603 : 	if (*cur == '-') {
; 1604 : 	    if (type == XML_SCHEMAS_GMONTH)
; 1605 : 		goto error;
; 1606 : 	  ++cur;
; 1607 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1608 : 	    if (ret != 0)
; 1609 : 		goto error;
; 1610 : 
; 1611 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);
; 1612 : 
; 1613 : 	    goto error;
; 1614 : 	}
; 1615 : 
; 1616 : 	/*
; 1617 : 	 * it should be an xs:gMonthDay or xs:gMonth
; 1618 : 	 */
; 1619 : 	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1620 : 	if (ret != 0)
; 1621 : 	    goto error;
; 1622 : 
; 1623 :         /*
; 1624 :          * a '-' char could indicate this type is xs:gMonthDay or
; 1625 :          * a negative time zone offset. Check for xs:gMonthDay first.
; 1626 :          * Also the first three char's of a negative tzo (-MM:SS) can
; 1627 :          * appear to be a valid day; so even if the day portion
; 1628 :          * of the xs:gMonthDay verifies, we must insure it was not
; 1629 :          * a tzo.
; 1630 :          */
; 1631 :         if (*cur == '-') {
; 1632 :             const xmlChar *rewnd = cur;
; 1633 :             cur++;
; 1634 : 
; 1635 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1636 :             if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {
; 1637 : 
; 1638 :                 /*
; 1639 :                  * we can use the VALID_MDAY macro to validate the month
; 1640 :                  * and day because the leap year test will flag year zero
; 1641 :                  * as a leap year (even though zero is an invalid year).
; 1642 : 		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
; 1643 : 		 * probably.
; 1644 :                  */
; 1645 :                 if (VALID_MDAY((&(dt->value.date)))) {
; 1646 : 
; 1647 : 	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);
; 1648 : 
; 1649 :                     goto error;
; 1650 :                 }
; 1651 :             }
; 1652 : 
; 1653 :             /*
; 1654 :              * not xs:gMonthDay so rewind and check if just xs:gMonth
; 1655 :              * with an optional time zone.
; 1656 :              */
; 1657 :             cur = rewnd;
; 1658 :         }
; 1659 : 
; 1660 : 	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);
; 1661 : 
; 1662 : 	goto error;
; 1663 :     }
; 1664 : 
; 1665 :     /*
; 1666 :      * It's a right-truncated date or an xs:time.
; 1667 :      * Try to parse an xs:time then fallback on right-truncated dates.
; 1668 :      */
; 1669 :     if ((*cur >= '0') && (*cur <= '9')) {
; 1670 : 	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1671 : 	if (ret == 0) {
; 1672 : 	    /* it's an xs:time */
; 1673 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);
; 1674 : 	}
; 1675 :     }
; 1676 : 
; 1677 :     /* fallback on date parsing */
; 1678 :     cur = dateTime;
; 1679 : 
; 1680 :     ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);
; 1681 :     if (ret != 0)
; 1682 : 	goto error;
; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);
; 1686 : 
; 1687 :     if (*cur != '-')
; 1688 : 	goto error;
; 1689 :     cur++;
; 1690 : 
; 1691 :     ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1692 :     if (ret != 0)
; 1693 : 	goto error;
; 1694 : 
; 1695 :     /* is it an xs:gYearMonth? */
; 1696 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);
; 1697 : 
; 1698 :     if (*cur != '-')
; 1699 : 	goto error;
; 1700 :     cur++;
; 1701 : 
; 1702 :     ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1703 :     if ((ret != 0) || !VALID_DATE((&(dt->value.date))))
; 1704 : 	goto error;
; 1705 : 
; 1706 :     /* is it an xs:date? */
; 1707 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);
; 1708 : 
; 1709 :     if (*cur != 'T')
; 1710 : 	goto error;
; 1711 :     cur++;
; 1712 : 
; 1713 :     /* it should be an xs:dateTime */
; 1714 :     ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1715 :     if (ret != 0)
; 1716 : 	goto error;
; 1717 : 
; 1718 :     ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);
; 1719 :     if (collapse)
; 1720 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1721 :     if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))
; 1722 : 	goto error;
; 1723 : 
; 1724 : 
; 1725 :     dt->type = XML_SCHEMAS_DATETIME;
; 1726 : 
; 1727 : done:
; 1728 : #if 1
; 1729 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))
; 1730 :         goto error;
; 1731 : #else
; 1732 :     /*
; 1733 :      * insure the parsed type is equal to or less significant (right
; 1734 :      * truncated) than the desired type.
; 1735 :      */
; 1736 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
; 1737 : 
; 1738 :         /* time only matches time */
; 1739 :         if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
; 1740 :             goto error;
; 1741 : 
; 1742 :         if ((type == XML_SCHEMAS_DATETIME) &&
; 1743 :             ((dt->type != XML_SCHEMAS_DATE) ||
; 1744 :              (dt->type != XML_SCHEMAS_GYEARMONTH) ||
; 1745 :              (dt->type != XML_SCHEMAS_GYEAR)))
; 1746 :             goto error;
; 1747 : 
; 1748 :         if ((type == XML_SCHEMAS_DATE) &&
; 1749 :             ((dt->type != XML_SCHEMAS_GYEAR) ||
; 1750 :              (dt->type != XML_SCHEMAS_GYEARMONTH)))
; 1751 :             goto error;
; 1752 : 
; 1753 :         if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
; 1754 :             goto error;
; 1755 : 
; 1756 :         if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
; 1757 :             goto error;
; 1758 :     }
; 1759 : #endif
; 1760 : 
; 1761 :     if (val != NULL)
; 1762 :         *val = dt;
; 1763 :     else
; 1764 : 	xmlSchemaFreeValue(dt);
; 1765 : 
; 1766 :     return 0;
; 1767 : 
; 1768 : error:
; 1769 :     if (dt != NULL)
; 1770 : 	xmlSchemaFreeValue(dt);
; 1771 :     return 1;
; 1772 : }
; 1773 : 
; 1774 : /**
; 1775 :  * xmlSchemaValidateDuration:
; 1776 :  * @type: the predefined type
; 1777 :  * @duration:  string to analyze
; 1778 :  * @val:  the return computed value
; 1779 :  *
; 1780 :  * Check that @duration conforms to the lexical space of the duration type.
; 1781 :  * if true a value is computed and returned in @val.
; 1782 :  *
; 1783 :  * Returns 0 if this validates, a positive error code number otherwise
; 1784 :  *         and -1 in case of internal or API error.
; 1785 :  */
; 1786 : static int
; 1787 : xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
; 1788 : 	                   const xmlChar *duration, xmlSchemaValPtr *val,
; 1789 : 			   int collapse) {
; 1790 :     const xmlChar  *cur = duration;
; 1791 :     xmlSchemaValPtr dur;
; 1792 :     int isneg = 0;
; 1793 :     unsigned int seq = 0;
; 1794 :     double         num;
; 1795 :     int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */
; 1796 :     const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};
; 1797 :     const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};
; 1798 : 
; 1799 :     if (duration == NULL)
; 1800 : 	return -1;
; 1801 : 
; 1802 :     if (collapse)
; 1803 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1804 : 
; 1805 :     if (*cur == '-') {
; 1806 :         isneg = 1;
; 1807 :         cur++;
; 1808 :     }
; 1809 : 
; 1810 :     /* duration must start with 'P' (after sign) */
; 1811 :     if (*cur++ != 'P')
; 1812 : 	return 1;
; 1813 : 
; 1814 :     if (*cur == 0)
; 1815 : 	return 1;
; 1816 : 
; 1817 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
; 1818 :     if (dur == NULL)
; 1819 : 	return -1;
; 1820 : 
; 1821 :     while (*cur != 0) {
; 1822 : 
; 1823 :         /* input string should be empty or invalid date/time item */
; 1824 :         if (seq >= sizeof(desig))
; 1825 :             goto error;
; 1826 : 
; 1827 :         /* T designator must be present for time items */
; 1828 :         if (*cur == 'T') {
; 1829 :             if (seq <= 3) {
; 1830 :                 seq = 3;
; 1831 :                 cur++;
; 1832 :             } else
; 1833 :                 return 1;
; 1834 :         } else if (seq == 3)
; 1835 :             goto error;
; 1836 : 
; 1837 :         /* parse the number portion of the item */
; 1838 :         PARSE_NUM(num, cur, num_type);
; 1839 : 
; 1840 :         if ((num_type == -1) || (*cur == 0))
; 1841 :             goto error;
; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {
; 1845 :             if (*cur == desig[seq]) {
; 1846 : 
; 1847 :                 /* verify numeric type; only seconds can be float */
; 1848 :                 if ((num_type != 0) && (seq < (sizeof(desig)-1)))
; 1849 :                     goto error;
; 1850 : 
; 1851 :                 switch (seq) {
; 1852 :                     case 0:
; 1853 :                         dur->value.dur.mon = (long)num * 12;
; 1854 :                         break;
; 1855 :                     case 1:
; 1856 :                         dur->value.dur.mon += (long)num;
; 1857 :                         break;
; 1858 :                     default:
; 1859 :                         /* convert to seconds using multiplier */
; 1860 :                         dur->value.dur.sec += num * multi[seq];
; 1861 :                         seq++;
; 1862 :                         break;
; 1863 :                 }
; 1864 : 
; 1865 :                 break;          /* exit loop */
; 1866 :             }
; 1867 :             /* no date designators found? */
; 1868 :             if ((++seq == 3) || (seq == 6))
; 1869 :                 goto error;
; 1870 :         }
; 1871 : 	cur++;
; 1872 : 	if (collapse)
; 1873 : 	    while IS_WSP_BLANK_CH(*cur) cur++;
; 1874 :     }
; 1875 : 
; 1876 :     if (isneg) {
; 1877 :         dur->value.dur.mon = -dur->value.dur.mon;
; 1878 :         dur->value.dur.day = -dur->value.dur.day;
; 1879 :         dur->value.dur.sec = -dur->value.dur.sec;
; 1880 :     }
; 1881 : 
; 1882 :     if (val != NULL)
; 1883 :         *val = dur;
; 1884 :     else
; 1885 : 	xmlSchemaFreeValue(dur);
; 1886 : 
; 1887 :     return 0;
; 1888 : 
; 1889 : error:
; 1890 :     if (dur != NULL)
; 1891 : 	xmlSchemaFreeValue(dur);
; 1892 :     return 1;
; 1893 : }
; 1894 : 
; 1895 : /**
; 1896 :  * xmlSchemaStrip:
; 1897 :  * @value: a value
; 1898 :  *
; 1899 :  * Removes the leading and ending spaces of a string
; 1900 :  *
; 1901 :  * Returns the new string or NULL if no change was required.
; 1902 :  */
; 1903 : static xmlChar *
; 1904 : xmlSchemaStrip(const xmlChar *value) {
; 1905 :     const xmlChar *start = value, *end, *f;
; 1906 : 
; 1907 :     if (value == NULL) return(NULL);
; 1908 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1909 :     end = start;
; 1910 :     while (*end != 0) end++;
; 1911 :     f = end;
; 1912 :     end--;
; 1913 :     while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1914 :     end++;
; 1915 :     if ((start == value) && (f == end)) return(NULL);
; 1916 :     return(xmlStrndup(start, end - start));
; 1917 : }
; 1918 : 
; 1919 : /**
; 1920 :  * xmlSchemaWhiteSpaceReplace:
; 1921 :  * @value: a value
; 1922 :  *
; 1923 :  * Replaces 0xd, 0x9 and 0xa with a space.
; 1924 :  *
; 1925 :  * Returns the new string or NULL if no change was required.
; 1926 :  */
; 1927 : xmlChar *
; 1928 : xmlSchemaWhiteSpaceReplace(const xmlChar *value) {
; 1929 :     const xmlChar *cur = value;
; 1930 :     xmlChar *ret = NULL, *mcur;
; 1931 : 
; 1932 :     if (value == NULL)
; 1933 : 	return(NULL);
; 1934 : 
; 1935 :     while ((*cur != 0) &&
; 1936 : 	(((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {
; 1937 : 	cur++;
; 1938 :     }
; 1939 :     if (*cur == 0)
; 1940 : 	return (NULL);
; 1941 :     ret = xmlStrdup(value);
; 1942 :     /* TODO FIXME: I guess gcc will bark at this. */
; 1943 :     mcur = (xmlChar *)  (ret + (cur - value));
; 1944 :     do {
; 1945 : 	if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )
; 1946 : 	    *mcur = ' ';
; 1947 : 	mcur++;
; 1948 :     } while (*mcur != 0);
; 1949 :     return(ret);
; 1950 : }
; 1951 : 
; 1952 : /**
; 1953 :  * xmlSchemaCollapseString:
; 1954 :  * @value: a value
; 1955 :  *
; 1956 :  * Removes and normalize white spaces in the string
; 1957 :  *
; 1958 :  * Returns the new string or NULL if no change was required.
; 1959 :  */
; 1960 : xmlChar *
; 1961 : xmlSchemaCollapseString(const xmlChar *value) {
; 1962 :     const xmlChar *start = value, *end, *f;
; 1963 :     xmlChar *g;
; 1964 :     int col = 0;
; 1965 : 
; 1966 :     if (value == NULL) return(NULL);
; 1967 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1968 :     end = start;
; 1969 :     while (*end != 0) {
; 1970 : 	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {
; 1971 : 	    col = end - start;
; 1972 : 	    break;
; 1973 : 	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {
; 1974 : 	    col = end - start;
; 1975 : 	    break;
; 1976 : 	}
; 1977 : 	end++;
; 1978 :     }
; 1979 :     if (col == 0) {
; 1980 : 	f = end;
; 1981 : 	end--;
; 1982 : 	while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1983 : 	end++;
; 1984 : 	if ((start == value) && (f == end)) return(NULL);
; 1985 : 	return(xmlStrndup(start, end - start));
; 1986 :     }
; 1987 :     start = xmlStrdup(start);
; 1988 :     if (start == NULL) return(NULL);
; 1989 :     g = (xmlChar *) (start + col);
; 1990 :     end = g;
; 1991 :     while (*end != 0) {
; 1992 : 	if (IS_BLANK_CH(*end)) {
; 1993 : 	    end++;
; 1994 : 	    while (IS_BLANK_CH(*end)) end++;
; 1995 : 	    if (*end != 0)
; 1996 : 		*g++ = ' ';
; 1997 : 	} else
; 1998 : 	    *g++ = *end++;
; 1999 :     }
; 2000 :     *g = 0;
; 2001 :     return((xmlChar *) start);
; 2002 : }
; 2003 : 
; 2004 : /**
; 2005 :  * xmlSchemaValAtomicListNode:
; 2006 :  * @type: the predefined atomic type for a token in the list
; 2007 :  * @value: the list value to check
; 2008 :  * @ret:  the return computed value
; 2009 :  * @node:  the node containing the value
; 2010 :  *
; 2011 :  * Check that a value conforms to the lexical space of the predefined
; 2012 :  * list type. if true a value is computed and returned in @ret.
; 2013 :  *
; 2014 :  * Returns the number of items if this validates, a negative error code
; 2015 :  *         number otherwise
; 2016 :  */
; 2017 : static int
; 2018 : xmlSchemaValAtomicListNode(xmlSchemaTypePtr type, const xmlChar *value,
; 2019 : 	                   xmlSchemaValPtr *ret, xmlNodePtr node) {
; 2020 :     xmlChar *val, *cur, *endval;
; 2021 :     int nb_values = 0;
; 2022 :     int tmp = 0;
; 2023 : 
; 2024 :     if (value == NULL) {
; 2025 : 	return(-1);
; 2026 :     }
; 2027 :     val = xmlStrdup(value);
; 2028 :     if (val == NULL) {
; 2029 : 	return(-1);
; 2030 :     }
; 2031 :     if (ret != NULL) {
; 2032 :         *ret = NULL;
; 2033 :     }
; 2034 :     cur = val;
; 2035 :     /*
; 2036 :      * Split the list
; 2037 :      */
; 2038 :     while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2039 :     while (*cur != 0) {
; 2040 : 	if (IS_BLANK_CH(*cur)) {
; 2041 : 	    *cur = 0;
; 2042 : 	    cur++;
; 2043 : 	    while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2044 : 	} else {
; 2045 : 	    nb_values++;
; 2046 : 	    cur++;
; 2047 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
; 2048 : 	}
; 2049 :     }
; 2050 :     if (nb_values == 0) {
; 2051 : 	xmlFree(val);
; 2052 : 	return(nb_values);
; 2053 :     }
; 2054 :     endval = cur;
; 2055 :     cur = val;
; 2056 :     while ((*cur == 0) && (cur != endval)) cur++;
; 2057 :     while (cur != endval) {
; 2058 : 	tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);
; 2059 : 	if (tmp != 0)
; 2060 : 	    break;
; 2061 : 	while (*cur != 0) cur++;
; 2062 : 	while ((*cur == 0) && (cur != endval)) cur++;
; 2063 :     }
; 2064 :     /* TODO what return value ? c.f. bug #158628
; 2065 :     if (ret != NULL) {
; 2066 : 	TODO
; 2067 :     } */
; 2068 :     xmlFree(val);
; 2069 :     if (tmp == 0)
; 2070 : 	return(nb_values);
; 2071 :     return(-1);
; 2072 : }
; 2073 : 
; 2074 : /**
; 2075 :  * xmlSchemaParseUInt:
; 2076 :  * @str: pointer to the string R/W
; 2077 :  * @llo: pointer to the low result
; 2078 :  * @lmi: pointer to the mid result
; 2079 :  * @lhi: pointer to the high result
; 2080 :  *
; 2081 :  * Parse an unsigned long into 3 fields.
; 2082 :  *
; 2083 :  * Returns the number of significant digits in the number or
; 2084 :  * -1 if overflow of the capacity and -2 if it's not a number.
; 2085 :  */
; 2086 : static int
; 2087 : xmlSchemaParseUInt(const xmlChar **str, unsigned long *llo,
; 2088 :                    unsigned long *lmi, unsigned long *lhi) {
; 2089 :     unsigned long lo = 0, mi = 0, hi = 0;
; 2090 :     const xmlChar *tmp, *cur = *str;
; 2091 :     int ret = 0, i = 0;
; 2092 : 
; 2093 :     if (!((*cur >= '0') && (*cur <= '9')))
; 2094 :         return(-2);
; 2095 : 
; 2096 :     while (*cur == '0') {        /* ignore leading zeroes */
; 2097 :         cur++;
; 2098 :     }
; 2099 :     tmp = cur;
; 2100 :     while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {
; 2101 :         i++;tmp++;ret++;
; 2102 :     }
; 2103 :     if (i > 24) {
; 2104 :         *str = tmp;
; 2105 :         return(-1);
; 2106 :     }
; 2107 :     while (i > 16) {
; 2108 :         hi = hi * 10 + (*cur++ - '0');
; 2109 :         i--;
; 2110 :     }
; 2111 :     while (i > 8) {
; 2112 :         mi = mi * 10 + (*cur++ - '0');
; 2113 :         i--;
; 2114 :     }
; 2115 :     while (i > 0) {
; 2116 :         lo = lo * 10 + (*cur++ - '0');
; 2117 :         i--;
; 2118 :     }
; 2119 : 
; 2120 :     *str = cur;
; 2121 :     *llo = lo;
; 2122 :     *lmi = mi;
; 2123 :     *lhi = hi;
; 2124 :     return(ret);
; 2125 : }
; 2126 : 
; 2127 : /**
; 2128 :  * xmlSchemaValAtomicType:
; 2129 :  * @type: the predefined type
; 2130 :  * @value: the value to check
; 2131 :  * @val:  the return computed value
; 2132 :  * @node:  the node containing the value
; 2133 :  * flags:  flags to control the vlidation
; 2134 :  *
; 2135 :  * Check that a value conforms to the lexical space of the atomic type.
; 2136 :  * if true a value is computed and returned in @val.
; 2137 :  * This checks the value space for list types as well (IDREFS, NMTOKENS).
; 2138 :  *
; 2139 :  * Returns 0 if this validates, a positive error code number otherwise
; 2140 :  *         and -1 in case of internal or API error.
; 2141 :  */
; 2142 : static int
; 2143 : xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
; 2144 :                        xmlSchemaValPtr * val, xmlNodePtr node, int flags,
; 2145 : 		       xmlSchemaWhitespaceValueType ws,
; 2146 : 		       int normOnTheFly, int applyNorm, int createStringValue)
; 2147 : {
; 2148 :     xmlSchemaValPtr v;
; 2149 :     xmlChar *norm = NULL;
; 2150 :     int ret = 0;
; 2151 : 
; 2152 :     if (xmlSchemaTypesInitialized == 0)
; 2153 :         xmlSchemaInitTypes();
; 2154 :     if (type == NULL)
; 2155 :         return (-1);
; 2156 : 
; 2157 :     /*
; 2158 :      * validating a non existant text node is similar to validating
; 2159 :      * an empty one.
; 2160 :      */
; 2161 :     if (value == NULL)
; 2162 :         value = BAD_CAST "";
; 2163 : 
; 2164 :     if (val != NULL)
; 2165 :         *val = NULL;
; 2166 :     if ((flags == 0) && (value != NULL)) {
; 2167 : 
; 2168 :         if ((type->builtInType != XML_SCHEMAS_STRING) &&
; 2169 : 	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&
; 2170 : 	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
; 2171 : 	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)
; 2172 : 		norm = xmlSchemaWhiteSpaceReplace(value);
; 2173 :             else
; 2174 : 		norm = xmlSchemaCollapseString(value);
; 2175 :             if (norm != NULL)
; 2176 :                 value = norm;
; 2177 :         }
; 2178 :     }
; 2179 : 
; 2180 :     switch (type->builtInType) {
; 2181 :         case XML_SCHEMAS_UNKNOWN:
; 2182 :             goto error;
; 2183 : 	case XML_SCHEMAS_ANYTYPE:
; 2184 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 2185 : 	    if ((createStringValue) && (val != NULL)) {
; 2186 : 		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);
; 2187 : 		if (v != NULL) {
; 2188 : 		    v->value.str = xmlStrdup(value);
; 2189 : 		    *val = v;
; 2190 : 		} else {
; 2191 : 		    goto error;
; 2192 : 		}
; 2193 : 	    }
; 2194 : 	    goto return0;
; 2195 :         case XML_SCHEMAS_STRING:
; 2196 : 	    if (! normOnTheFly) {
; 2197 : 		const xmlChar *cur = value;
; 2198 : 
; 2199 : 		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {
; 2200 : 		    while (*cur != 0) {
; 2201 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2202 : 			    goto return1;
; 2203 : 			} else {
; 2204 : 			    cur++;
; 2205 : 			}
; 2206 : 		    }
; 2207 : 		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {
; 2208 : 		    while (*cur != 0) {
; 2209 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2210 : 			    goto return1;
; 2211 : 			} else if IS_WSP_SPACE_CH(*cur) {
; 2212 : 			    cur++;
; 2213 : 			    if IS_WSP_SPACE_CH(*cur)
; 2214 : 				goto return1;
; 2215 : 			} else {
; 2216 : 			    cur++;
; 2217 : 			}
; 2218 : 		    }
; 2219 : 		}
; 2220 : 	    }
; 2221 : 	    if (createStringValue && (val != NULL)) {
; 2222 : 		if (applyNorm) {
; 2223 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2224 : 			norm = xmlSchemaCollapseString(value);
; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)
; 2226 : 			norm = xmlSchemaWhiteSpaceReplace(value);
; 2227 : 		    if (norm != NULL)
; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);
; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {
; 2235 : 		    goto error;
; 2236 : 		}
; 2237 : 	    }
; 2238 :             goto return0;
; 2239 :         case XML_SCHEMAS_NORMSTRING:{
; 2240 : 		if (normOnTheFly) {
; 2241 : 		    if (applyNorm) {
; 2242 : 			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2243 : 			    norm = xmlSchemaCollapseString(value);
; 2244 : 			else
; 2245 : 			    norm = xmlSchemaWhiteSpaceReplace(value);
; 2246 : 			if (norm != NULL)
; 2247 : 			    value = norm;
; 2248 : 		    }
; 2249 : 		} else {
; 2250 : 		    const xmlChar *cur = value;
; 2251 : 		    while (*cur != 0) {
; 2252 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2253 : 			    goto return1;
; 2254 : 			} else {
; 2255 : 			    cur++;
; 2256 : 			}
; 2257 : 		    }
; 2258 : 		}
; 2259 :                 if (val != NULL) {
; 2260 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);
; 2261 :                     if (v != NULL) {
; 2262 :                         v->value.str = xmlStrdup(value);
; 2263 :                         *val = v;
; 2264 :                     } else {
; 2265 :                         goto error;
; 2266 :                     }
; 2267 :                 }
; 2268 :                 goto return0;
; 2269 :             }
; 2270 :         case XML_SCHEMAS_DECIMAL:{
; 2271 :                 const xmlChar *cur = value;
; 2272 :                 unsigned int len, neg, integ, hasLeadingZeroes;
; 2273 : 		xmlChar cval[25];
; 2274 : 		xmlChar *cptr = cval;
; 2275 : 
; 2276 :                 if ((cur == NULL) || (*cur == 0))
; 2277 :                     goto return1;
; 2278 : 
; 2279 : 		/*
; 2280 : 		* xs:decimal has a whitespace-facet value of 'collapse'.
; 2281 : 		*/
; 2282 : 		if (normOnTheFly)
; 2283 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2284 : 
; 2285 : 		/*
; 2286 : 		* First we handle an optional sign.
; 2287 : 		*/
; 2288 : 		neg = 0;
; 2289 :                 if (*cur == '-') {
; 2290 : 		    neg = 1;
; 2291 :                     cur++;
; 2292 : 		} else if (*cur == '+')
; 2293 :                     cur++;
; 2294 : 		/*
; 2295 : 		* Disallow: "", "-", "- "
; 2296 : 		*/
; 2297 : 		if (*cur == 0)
; 2298 : 		    goto return1;
; 2299 : 		/*
; 2300 : 		 * Next we "pre-parse" the number, in preparation for calling
; 2301 : 		 * the common routine xmlSchemaParseUInt.  We get rid of any
; 2302 : 		 * leading zeroes (because we have reserved only 25 chars),
; 2303 : 		 * and note the position of a decimal point.
; 2304 : 		 */
; 2305 : 		len = 0;
; 2306 : 		integ = ~0u;
; 2307 : 		hasLeadingZeroes = 0;
; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {
; 2312 : 		    cur++;
; 2313 : 		    hasLeadingZeroes = 1;
; 2314 : 		}
; 2315 : 		if (*cur != 0) {
; 2316 : 		    do {
; 2317 : 			if ((*cur >= '0') && (*cur <= '9')) {
; 2318 : 			    *cptr++ = *cur++;
; 2319 : 			    len++;
; 2320 : 			} else if (*cur == '.') {
; 2321 : 			    cur++;
; 2322 : 			    integ = len;
; 2323 : 			    do {
; 2324 : 				if ((*cur >= '0') && (*cur <= '9')) {
; 2325 : 				    *cptr++ = *cur++;
; 2326 : 				    len++;
; 2327 : 				} else
; 2328 : 				    break;
; 2329 : 			    } while (len < 24);
; 2330 : 			    /*
; 2331 : 			    * Disallow "." but allow "00."
; 2332 : 			    */
; 2333 : 			    if ((len == 0) && (!hasLeadingZeroes))
; 2334 : 				goto return1;
; 2335 : 			    break;
; 2336 : 			} else
; 2337 : 			    break;
; 2338 : 		    } while (len < 24);
; 2339 : 		}
; 2340 : 		if (normOnTheFly)
; 2341 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2342 : 		if (*cur != 0)
; 2343 : 		    goto return1; /* error if any extraneous chars */
; 2344 :                 if (val != NULL) {
; 2345 :                     v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);
; 2346 :                     if (v != NULL) {
; 2347 : 			/*
; 2348 : 			* Now evaluate the significant digits of the number
; 2349 : 			*/
; 2350 : 			if (len != 0) {
; 2351 : 
; 2352 : 			    if (integ != ~0u) {
; 2353 : 				/*
; 2354 : 				* Get rid of trailing zeroes in the
; 2355 : 				* fractional part.
; 2356 : 				*/
; 2357 : 				while ((len != integ) && (*(cptr-1) == '0')) {
; 2358 : 				    cptr--;
; 2359 : 				    len--;
; 2360 : 				}
; 2361 : 			    }
; 2362 : 			    /*
; 2363 : 			    * Terminate the (preparsed) string.
; 2364 : 			    */
; 2365 : 			    if (len != 0) {
; 2366 : 				*cptr = 0;
; 2367 : 				cptr = cval;
; 2368 : 
; 2369 : 				xmlSchemaParseUInt((const xmlChar **)&cptr,
; 2370 : 				    &v->value.decimal.lo,
; 2371 : 				    &v->value.decimal.mi,
; 2372 : 				    &v->value.decimal.hi);
; 2373 : 			    }
; 2374 : 			}
; 2375 : 			/*
; 2376 : 			* Set the total digits to 1 if a zero value.
; 2377 : 			*/
; 2378 :                         v->value.decimal.sign = neg;
; 2379 : 			if (len == 0) {
; 2380 : 			    /* Speedup for zero values. */
; 2381 : 			    v->value.decimal.total = 1;
; 2382 : 			} else {
; 2383 : 			    v->value.decimal.total = len;
; 2384 : 			    if (integ == ~0u)
; 2385 : 				v->value.decimal.frac = 0;
; 2386 : 			    else
; 2387 : 				v->value.decimal.frac = len - integ;
; 2388 : 			}
; 2389 :                         *val = v;
; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;
; 2393 :             }
; 2394 :         case XML_SCHEMAS_TIME:
; 2395 :         case XML_SCHEMAS_GDAY:
; 2396 :         case XML_SCHEMAS_GMONTH:
; 2397 :         case XML_SCHEMAS_GMONTHDAY:
; 2398 :         case XML_SCHEMAS_GYEAR:
; 2399 :         case XML_SCHEMAS_GYEARMONTH:
; 2400 :         case XML_SCHEMAS_DATE:
; 2401 :         case XML_SCHEMAS_DATETIME:
; 2402 :             ret = xmlSchemaValidateDates(type->builtInType, value, val,
; 2403 : 		normOnTheFly);
; 2404 :             break;
; 2405 :         case XML_SCHEMAS_DURATION:
; 2406 :             ret = xmlSchemaValidateDuration(type, value, val,
; 2407 : 		normOnTheFly);
; 2408 :             break;
; 2409 :         case XML_SCHEMAS_FLOAT:
; 2410 :         case XML_SCHEMAS_DOUBLE: {
; 2411 :                 const xmlChar *cur = value;
; 2412 :                 int neg = 0;
; 2413 :                 int digits_before = 0;
; 2414 :                 int digits_after = 0;
; 2415 : 
; 2416 : 		if (normOnTheFly)
; 2417 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2418 : 
; 2419 :                 if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {
; 2420 :                     cur += 3;
; 2421 :                     if (*cur != 0)
; 2422 :                         goto return1;
; 2423 :                     if (val != NULL) {
; 2424 :                         if (type == xmlSchemaTypeFloatDef) {
; 2425 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2426 :                             if (v != NULL) {
; 2427 :                                 v->value.f = (float) xmlXPathNAN;
; 2428 :                             } else {
; 2429 :                                 xmlSchemaFreeValue(v);
; 2430 :                                 goto error;
; 2431 :                             }
; 2432 :                         } else {
; 2433 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2434 :                             if (v != NULL) {
; 2435 :                                 v->value.d = xmlXPathNAN;
; 2436 :                             } else {
; 2437 :                                 xmlSchemaFreeValue(v);
; 2438 :                                 goto error;
; 2439 :                             }
; 2440 :                         }
; 2441 :                         *val = v;
; 2442 :                     }
; 2443 :                     goto return0;
; 2444 :                 }
; 2445 :                 if (*cur == '-') {
; 2446 :                     neg = 1;
; 2447 :                     cur++;
; 2448 :                 }
; 2449 :                 if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {
; 2450 :                     cur += 3;
; 2451 :                     if (*cur != 0)
; 2452 :                         goto return1;
; 2453 :                     if (val != NULL) {
; 2454 :                         if (type == xmlSchemaTypeFloatDef) {
; 2455 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2456 :                             if (v != NULL) {
; 2457 :                                 if (neg)
; 2458 :                                     v->value.f = (float) xmlXPathNINF;
; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;
; 2461 :                             } else {
; 2462 :                                 xmlSchemaFreeValue(v);
; 2463 :                                 goto error;
; 2464 :                             }
; 2465 :                         } else {
; 2466 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2467 :                             if (v != NULL) {
; 2468 :                                 if (neg)
; 2469 :                                     v->value.d = xmlXPathNINF;
; 2470 :                                 else
; 2471 :                                     v->value.d = xmlXPathPINF;
; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;
; 2478 :                     }
; 2479 :                     goto return0;
; 2480 :                 }
; 2481 :                 if ((neg == 0) && (*cur == '+'))
; 2482 :                     cur++;
; 2483 :                 if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))
; 2484 :                     goto return1;
; 2485 :                 while ((*cur >= '0') && (*cur <= '9')) {
; 2486 :                     cur++;
; 2487 :                     digits_before++;
; 2488 :                 }
; 2489 :                 if (*cur == '.') {
; 2490 :                     cur++;
; 2491 :                     while ((*cur >= '0') && (*cur <= '9')) {
; 2492 :                         cur++;
; 2493 :                         digits_after++;
; 2494 :                     }
; 2495 :                 }
; 2496 :                 if ((digits_before == 0) && (digits_after == 0))
; 2497 :                     goto return1;
; 2498 :                 if ((*cur == 'e') || (*cur == 'E')) {
; 2499 :                     cur++;
; 2500 :                     if ((*cur == '-') || (*cur == '+'))
; 2501 :                         cur++;
; 2502 :                     while ((*cur >= '0') && (*cur <= '9'))
; 2503 :                         cur++;
; 2504 :                 }
; 2505 : 		if (normOnTheFly)
; 2506 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2507 : 
; 2508 :                 if (*cur != 0)
; 2509 :                     goto return1;
; 2510 :                 if (val != NULL) {
; 2511 :                     if (type == xmlSchemaTypeFloatDef) {
; 2512 :                         v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2513 :                         if (v != NULL) {
; 2514 : 			    /*
; 2515 : 			    * TODO: sscanf seems not to give the correct
; 2516 : 			    * value for extremely high/low values.
; 2517 : 			    * E.g. "1E-149" results in zero.
; 2518 : 			    */
; 2519 :                             if (sscanf((const char *) value, "%f",
; 2520 :                                  &(v->value.f)) == 1) {
; 2521 :                                 *val = v;
; 2522 :                             } else {
; 2523 :                                 xmlSchemaFreeValue(v);
; 2524 :                                 goto return1;
; 2525 :                             }
; 2526 :                         } else {
; 2527 :                             goto error;
; 2528 :                         }
; 2529 :                     } else {
; 2530 :                         v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2531 :                         if (v != NULL) {
; 2532 : 			    /*
; 2533 : 			    * TODO: sscanf seems not to give the correct
; 2534 : 			    * value for extremely high/low values.
; 2535 : 			    */
; 2536 :                             if (sscanf((const char *) value, "%lf",
; 2537 :                                  &(v->value.d)) == 1) {
; 2538 :                                 *val = v;
; 2539 :                             } else {
; 2540 :                                 xmlSchemaFreeValue(v);
; 2541 :                                 goto return1;
; 2542 :                             }
; 2543 :                         } else {
; 2544 :                             goto error;
; 2545 :                         }
; 2546 :                     }
; 2547 :                 }
; 2548 :                 goto return0;
; 2549 :             }
; 2550 :         case XML_SCHEMAS_BOOLEAN:{
; 2551 :                 const xmlChar *cur = value;
; 2552 : 
; 2553 : 		if (normOnTheFly) {
; 2554 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2555 : 		    if (*cur == '0') {
; 2556 : 			ret = 0;
; 2557 : 			cur++;
; 2558 : 		    } else if (*cur == '1') {
; 2559 : 			ret = 1;
; 2560 : 			cur++;
; 2561 : 		    } else if (*cur == 't') {
; 2562 : 			cur++;
; 2563 : 			if ((*cur++ == 'r') && (*cur++ == 'u') &&
; 2564 : 			    (*cur++ == 'e')) {
; 2565 : 			    ret = 1;
; 2566 : 			} else
; 2567 : 			    goto return1;
; 2568 : 		    } else if (*cur == 'f') {
; 2569 : 			cur++;
; 2570 : 			if ((*cur++ == 'a') && (*cur++ == 'l') &&
; 2571 : 			    (*cur++ == 's') && (*cur++ == 'e')) {
; 2572 : 			    ret = 0;
; 2573 : 			} else
; 2574 : 			    goto return1;
; 2575 : 		    } else
; 2576 : 			goto return1;
; 2577 : 		    if (*cur != 0) {
; 2578 : 			while IS_WSP_BLANK_CH(*cur) cur++;
; 2579 : 			if (*cur != 0)
; 2580 : 			    goto return1;
; 2581 : 		    }
; 2582 : 		} else {
; 2583 : 		    if ((cur[0] == '0') && (cur[1] == 0))
; 2584 : 			ret = 0;
; 2585 : 		    else if ((cur[0] == '1') && (cur[1] == 0))
; 2586 : 			ret = 1;
; 2587 : 		    else if ((cur[0] == 't') && (cur[1] == 'r')
; 2588 : 			&& (cur[2] == 'u') && (cur[3] == 'e')
; 2589 : 			&& (cur[4] == 0))
; 2590 : 			ret = 1;
; 2591 : 		    else if ((cur[0] == 'f') && (cur[1] == 'a')
; 2592 : 			&& (cur[2] == 'l') && (cur[3] == 's')
; 2593 : 			&& (cur[4] == 'e') && (cur[5] == 0))
; 2594 : 			ret = 0;
; 2595 : 		    else
; 2596 : 			goto return1;
; 2597 : 		}
; 2598 :                 if (val != NULL) {
; 2599 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);
; 2600 :                     if (v != NULL) {
; 2601 :                         v->value.b = ret;
; 2602 :                         *val = v;
; 2603 :                     } else {
; 2604 :                         goto error;
; 2605 :                     }
; 2606 :                 }
; 2607 :                 goto return0;
; 2608 :             }
; 2609 :         case XML_SCHEMAS_TOKEN:{
; 2610 :                 const xmlChar *cur = value;
; 2611 : 
; 2612 : 		if (! normOnTheFly) {
; 2613 : 		    while (*cur != 0) {
; 2614 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2615 : 			    goto return1;
; 2616 : 			} else if (*cur == ' ') {
; 2617 : 			    cur++;
; 2618 : 			    if (*cur == 0)
; 2619 : 				goto return1;
; 2620 : 			    if (*cur == ' ')
; 2621 : 				goto return1;
; 2622 : 			} else {
; 2623 : 			    cur++;
; 2624 : 			}
; 2625 : 		    }
; 2626 : 		}
; 2627 :                 if (val != NULL) {
; 2628 :                     v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);
; 2629 :                     if (v != NULL) {
; 2630 :                         v->value.str = xmlStrdup(value);
; 2631 :                         *val = v;
; 2632 :                     } else {
; 2633 :                         goto error;
; 2634 :                     }
; 2635 :                 }
; 2636 :                 goto return0;
; 2637 :             }
; 2638 :         case XML_SCHEMAS_LANGUAGE:
; 2639 : 	    if (normOnTheFly) {
; 2640 : 		norm = xmlSchemaCollapseString(value);
; 2641 : 		if (norm != NULL)
; 2642 : 		    value = norm;
; 2643 : 	    }
; 2644 :             if (xmlCheckLanguageID(value) == 1) {
; 2645 :                 if (val != NULL) {
; 2646 :                     v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);
; 2647 :                     if (v != NULL) {
; 2648 :                         v->value.str = xmlStrdup(value);
; 2649 :                         *val = v;
; 2650 :                     } else {
; 2651 :                         goto error;
; 2652 :                     }
; 2653 :                 }
; 2654 :                 goto return0;
; 2655 :             }
; 2656 :             goto return1;
; 2657 :         case XML_SCHEMAS_NMTOKEN:
; 2658 :             if (xmlValidateNMToken(value, 1) == 0) {
; 2659 :                 if (val != NULL) {
; 2660 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);
; 2661 :                     if (v != NULL) {
; 2662 :                         v->value.str = xmlStrdup(value);
; 2663 :                         *val = v;
; 2664 :                     } else {
; 2665 :                         goto error;
; 2666 :                     }
; 2667 :                 }
; 2668 :                 goto return0;
; 2669 :             }
; 2670 :             goto return1;
; 2671 :         case XML_SCHEMAS_NMTOKENS:
; 2672 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,
; 2673 :                                              value, val, node);
; 2674 :             if (ret > 0)
; 2675 :                 ret = 0;
; 2676 :             else
; 2677 :                 ret = 1;
; 2678 :             goto done;
; 2679 :         case XML_SCHEMAS_NAME:
; 2680 :             ret = xmlValidateName(value, 1);
; 2681 :             if ((ret == 0) && (val != NULL) && (value != NULL)) {
; 2682 : 		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);
; 2683 : 		if (v != NULL) {
; 2684 : 		     const xmlChar *start = value, *end;
; 2685 : 		     while (IS_BLANK_CH(*start)) start++;
; 2686 : 		     end = start;
; 2687 : 		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;
; 2688 : 		     v->value.str = xmlStrndup(start, end - start);
; 2689 : 		    *val = v;
; 2690 : 		} else {
; 2691 : 		    goto error;
; 2692 : 		}
; 2693 :             }
; 2694 :             goto done;
; 2695 :         case XML_SCHEMAS_QNAME:{
; 2696 :                 const xmlChar *uri = NULL;
; 2697 :                 xmlChar *local = NULL;
; 2698 : 
; 2699 :                 ret = xmlValidateQName(value, 1);
; 2700 : 		if (ret != 0)
; 2701 : 		    goto done;
; 2702 :                 if (node != NULL) {
; 2703 :                     xmlChar *prefix;
; 2704 : 		    xmlNsPtr ns;
; 2705 : 
; 2706 :                     local = xmlSplitQName2(value, &prefix);
; 2707 : 		    ns = xmlSearchNs(node->doc, node, prefix);
; 2708 : 		    if ((ns == NULL) && (prefix != NULL)) {
; 2709 : 			xmlFree(prefix);
; 2710 : 			if (local != NULL)
; 2711 : 			    xmlFree(local);
; 2712 : 			goto return1;
; 2713 : 		    }
; 2714 : 		    if (ns != NULL)
; 2715 : 			uri = ns->href;
; 2716 :                     if (prefix != NULL)
; 2717 :                         xmlFree(prefix);
; 2718 :                 }
; 2719 :                 if (val != NULL) {
; 2720 :                     v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 2721 :                     if (v == NULL) {
; 2722 : 			if (local != NULL)
; 2723 : 			    xmlFree(local);
; 2724 : 			goto error;
; 2725 : 		    }
; 2726 : 		    if (local != NULL)
; 2727 : 			v->value.qname.name = local;
; 2728 : 		    else
; 2729 : 			v->value.qname.name = xmlStrdup(value);
; 2730 : 		    if (uri != NULL)
; 2731 : 			v->value.qname.uri = xmlStrdup(uri);
; 2732 : 		    *val = v;
; 2733 :                 } else
; 2734 : 		    if (local != NULL)
; 2735 : 			xmlFree(local);
; 2736 :                 goto done;
; 2737 :             }
; 2738 :         case XML_SCHEMAS_NCNAME:
; 2739 :             ret = xmlValidateNCName(value, 1);
; 2740 :             if ((ret == 0) && (val != NULL)) {
; 2741 :                 v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);
; 2742 :                 if (v != NULL) {
; 2743 :                     v->value.str = xmlStrdup(value);
; 2744 :                     *val = v;
; 2745 :                 } else {
; 2746 :                     goto error;
; 2747 :                 }
; 2748 :             }
; 2749 :             goto done;
; 2750 :         case XML_SCHEMAS_ID:
; 2751 :             ret = xmlValidateNCName(value, 1);
; 2752 :             if ((ret == 0) && (val != NULL)) {
; 2753 :                 v = xmlSchemaNewValue(XML_SCHEMAS_ID);
; 2754 :                 if (v != NULL) {
; 2755 :                     v->value.str = xmlStrdup(value);
; 2756 :                     *val = v;
; 2757 :                 } else {
; 2758 :                     goto error;
; 2759 :                 }
; 2760 :             }
; 2761 :             if ((ret == 0) && (node != NULL) &&
; 2762 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2763 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2764 : 
; 2765 :                 /*
; 2766 :                  * NOTE: the IDness might have already be declared in the DTD
; 2767 :                  */
; 2768 :                 if (attr->atype != XML_ATTRIBUTE_ID) {
; 2769 :                     xmlIDPtr res;
; 2770 :                     xmlChar *strip;
; 2771 : 
; 2772 :                     strip = xmlSchemaStrip(value);
; 2773 :                     if (strip != NULL) {
; 2774 :                         res = xmlAddID(NULL, node->doc, strip, attr);
; 2775 :                         xmlFree(strip);
; 2776 :                     } else
; 2777 :                         res = xmlAddID(NULL, node->doc, value, attr);
; 2778 :                     if (res == NULL) {
; 2779 :                         ret = 2;
; 2780 :                     } else {
; 2781 :                         attr->atype = XML_ATTRIBUTE_ID;
; 2782 :                     }
; 2783 :                 }
; 2784 :             }
; 2785 :             goto done;
; 2786 :         case XML_SCHEMAS_IDREF:
; 2787 :             ret = xmlValidateNCName(value, 1);
; 2788 :             if ((ret == 0) && (val != NULL)) {
; 2789 : 		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);
; 2790 : 		if (v == NULL)
; 2791 : 		    goto error;
; 2792 : 		v->value.str = xmlStrdup(value);
; 2793 : 		*val = v;
; 2794 :             }
; 2795 :             if ((ret == 0) && (node != NULL) &&
; 2796 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2797 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2798 :                 xmlChar *strip;
; 2799 : 
; 2800 :                 strip = xmlSchemaStrip(value);
; 2801 :                 if (strip != NULL) {
; 2802 :                     xmlAddRef(NULL, node->doc, strip, attr);
; 2803 :                     xmlFree(strip);
; 2804 :                 } else
; 2805 :                     xmlAddRef(NULL, node->doc, value, attr);
; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;
; 2807 :             }
; 2808 :             goto done;
; 2809 :         case XML_SCHEMAS_IDREFS:
; 2810 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,
; 2811 :                                              value, val, node);
; 2812 :             if (ret < 0)
; 2813 :                 ret = 2;
; 2814 :             else
; 2815 :                 ret = 0;
; 2816 :             if ((ret == 0) && (node != NULL) &&
; 2817 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2818 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2819 : 
; 2820 :                 attr->atype = XML_ATTRIBUTE_IDREFS;
; 2821 :             }
; 2822 :             goto done;
; 2823 :         case XML_SCHEMAS_ENTITY:{
; 2824 :                 xmlChar *strip;
; 2825 : 
; 2826 :                 ret = xmlValidateNCName(value, 1);
; 2827 :                 if ((node == NULL) || (node->doc == NULL))
; 2828 :                     ret = 3;
; 2829 :                 if (ret == 0) {
; 2830 :                     xmlEntityPtr ent;
; 2831 : 
; 2832 :                     strip = xmlSchemaStrip(value);
; 2833 :                     if (strip != NULL) {
; 2834 :                         ent = xmlGetDocEntity(node->doc, strip);
; 2835 :                         xmlFree(strip);
; 2836 :                     } else {
; 2837 :                         ent = xmlGetDocEntity(node->doc, value);
; 2838 :                     }
; 2839 :                     if ((ent == NULL) ||
; 2840 :                         (ent->etype !=
; 2841 :                          XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
; 2842 :                         ret = 4;
; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {
; 2845 :                     TODO;
; 2846 :                 }
; 2847 :                 if ((ret == 0) && (node != NULL) &&
; 2848 :                     (node->type == XML_ATTRIBUTE_NODE)) {
; 2849 :                     xmlAttrPtr attr = (xmlAttrPtr) node;
; 2850 : 
; 2851 :                     attr->atype = XML_ATTRIBUTE_ENTITY;
; 2852 :                 }
; 2853 :                 goto done;
; 2854 :             }
; 2855 :         case XML_SCHEMAS_ENTITIES:
; 2856 :             if ((node == NULL) || (node->doc == NULL))
; 2857 :                 goto return3;
; 2858 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,
; 2859 :                                              value, val, node);
; 2860 :             if (ret <= 0)
; 2861 :                 ret = 1;
; 2862 :             else
; 2863 :                 ret = 0;
; 2864 :             if ((ret == 0) && (node != NULL) &&
; 2865 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2866 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2867 : 
; 2868 :                 attr->atype = XML_ATTRIBUTE_ENTITIES;
; 2869 :             }
; 2870 :             goto done;
; 2871 :         case XML_SCHEMAS_NOTATION:{
; 2872 :                 xmlChar *uri = NULL;
; 2873 :                 xmlChar *local = NULL;
; 2874 : 
; 2875 :                 ret = xmlValidateQName(value, 1);
; 2876 :                 if ((ret == 0) && (node != NULL)) {
; 2877 :                     xmlChar *prefix;
; 2878 : 
; 2879 :                     local = xmlSplitQName2(value, &prefix);
; 2880 :                     if (prefix != NULL) {
; 2881 :                         xmlNsPtr ns;
; 2882 : 
; 2883 :                         ns = xmlSearchNs(node->doc, node, prefix);
; 2884 :                         if (ns == NULL)
; 2885 :                             ret = 1;
; 2886 :                         else if (val != NULL)
; 2887 :                             uri = xmlStrdup(ns->href);
; 2888 :                     }
; 2889 :                     if ((local != NULL) && ((val == NULL) || (ret != 0)))
; 2890 :                         xmlFree(local);
; 2891 :                     if (prefix != NULL)
; 2892 :                         xmlFree(prefix);
; 2893 :                 }
; 2894 :                 if ((node == NULL) || (node->doc == NULL))
; 2895 :                     ret = 3;
; 2896 :                 if (ret == 0) {
; 2897 :                     ret = xmlValidateNotationUse(NULL, node->doc, value);
; 2898 :                     if (ret == 1)
; 2899 :                         ret = 0;
; 2900 :                     else
; 2901 :                         ret = 1;
; 2902 :                 }
; 2903 :                 if ((ret == 0) && (val != NULL)) {
; 2904 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 2905 :                     if (v != NULL) {
; 2906 :                         if (local != NULL)
; 2907 :                             v->value.qname.name = local;
; 2908 :                         else
; 2909 :                             v->value.qname.name = xmlStrdup(value);
; 2910 :                         if (uri != NULL)
; 2911 :                             v->value.qname.uri = uri;
; 2912 : 
; 2913 :                         *val = v;
; 2914 :                     } else {
; 2915 :                         if (local != NULL)
; 2916 :                             xmlFree(local);
; 2917 :                         if (uri != NULL)
; 2918 :                             xmlFree(uri);
; 2919 :                         goto error;
; 2920 :                     }
; 2921 :                 }
; 2922 :                 goto done;
; 2923 :             }
; 2924 :         case XML_SCHEMAS_ANYURI:{
; 2925 :                 if (*value != 0) {
; 2926 : 		    xmlURIPtr uri;
; 2927 : 		    xmlChar *tmpval, *cur;
; 2928 : 		    if (normOnTheFly) {
; 2929 : 			norm = xmlSchemaCollapseString(value);
; 2930 : 			if (norm != NULL)
; 2931 : 			    value = norm;
; 2932 : 		    }
; 2933 : 		    tmpval = xmlStrdup(value);
; 2934 : 		    for (cur = tmpval; *cur; ++cur) {
; 2935 : 			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
; 2936 : 			    *cur == '<' || *cur == '>' || *cur == '"' ||
; 2937 : 			    *cur == '{' || *cur == '}' || *cur == '|' ||
; 2938 : 			    *cur == '\\' || *cur == '^' || *cur == '`' ||
; 2939 : 			    *cur == '\'')
; 2940 : 			    *cur = '_';
; 2941 : 		    }
; 2942 :                     uri = xmlParseURI((const char *) tmpval);
; 2943 : 		    xmlFree(tmpval);
; 2944 :                     if (uri == NULL)
; 2945 :                         goto return1;
; 2946 :                     xmlFreeURI(uri);
; 2947 :                 }
; 2948 : 
; 2949 :                 if (val != NULL) {
; 2950 :                     v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);
; 2951 :                     if (v == NULL)
; 2952 :                         goto error;
; 2953 :                     v->value.str = xmlStrdup(value);
; 2954 :                     *val = v;
; 2955 :                 }
; 2956 :                 goto return0;
; 2957 :             }
; 2958 :         case XML_SCHEMAS_HEXBINARY:{
; 2959 :                 const xmlChar *cur = value, *start;
; 2960 :                 xmlChar *base;
; 2961 :                 int total, i = 0;
; 2962 : 
; 2963 :                 if (cur == NULL)
; 2964 :                     goto return1;
; 2965 : 
; 2966 : 		if (normOnTheFly)
; 2967 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2968 : 
; 2969 : 		start = cur;
; 2970 :                 while (((*cur >= '0') && (*cur <= '9')) ||
; 2971 :                        ((*cur >= 'A') && (*cur <= 'F')) ||
; 2972 :                        ((*cur >= 'a') && (*cur <= 'f'))) {
; 2973 :                     i++;
; 2974 :                     cur++;
; 2975 :                 }
; 2976 : 		if (normOnTheFly)
; 2977 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2978 : 
; 2979 :                 if (*cur != 0)
; 2980 :                     goto return1;
; 2981 :                 if ((i % 2) != 0)
; 2982 :                     goto return1;
; 2983 : 
; 2984 :                 if (val != NULL) {
; 2985 : 
; 2986 :                     v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);
; 2987 :                     if (v == NULL)
; 2988 :                         goto error;
; 2989 : 		    /*
; 2990 : 		    * Copy only the normalized piece.
; 2991 : 		    * CRITICAL TODO: Check this.
; 2992 : 		    */
; 2993 :                     cur = xmlStrndup(start, i);
; 2994 :                     if (cur == NULL) {
; 2995 : 		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");
; 2996 :                         xmlFree(v);
; 2997 :                         goto return1;
; 2998 :                     }
; 2999 : 
; 3000 :                     total = i / 2;      /* number of octets */
; 3001 : 
; 3002 :                     base = (xmlChar *) cur;
; 3003 :                     while (i-- > 0) {
; 3004 :                         if (*base >= 'a')
; 3005 :                             *base = *base - ('a' - 'A');
; 3006 :                         base++;
; 3007 :                     }
; 3008 : 
; 3009 :                     v->value.hex.str = (xmlChar *) cur;
; 3010 :                     v->value.hex.total = total;
; 3011 :                     *val = v;
; 3012 :                 }
; 3013 :                 goto return0;
; 3014 :             }
; 3015 :         case XML_SCHEMAS_BASE64BINARY:{
; 3016 :                 /* ISSUE:
; 3017 :                  *
; 3018 :                  * Ignore all stray characters? (yes, currently)
; 3019 :                  * Worry about long lines? (no, currently)
; 3020 :                  *
; 3021 :                  * rfc2045.txt:
; 3022 :                  *
; 3023 :                  * "The encoded output stream must be represented in lines of
; 3024 :                  * no more than 76 characters each.  All line breaks or other
; 3025 :                  * characters not found in Table 1 must be ignored by decoding
; 3026 :                  * software.  In base64 data, characters other than those in
; 3027 :                  * Table 1, line breaks, and other white space probably
; 3028 :                  * indicate a transmission error, about which a warning
; 3029 :                  * message or even a message rejection might be appropriate
; 3030 :                  * under some circumstances." */
; 3031 :                 const xmlChar *cur = value;
; 3032 :                 xmlChar *base;
; 3033 :                 int total, i = 0, pad = 0;
; 3034 : 
; 3035 :                 if (cur == NULL)
; 3036 :                     goto return1;
; 3037 : 
; 3038 :                 for (; *cur; ++cur) {
; 3039 :                     int decc;
; 3040 : 
; 3041 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3042 :                     if (decc < 0) ;
; 3043 :                     else if (decc < 64)
; 3044 :                         i++;
; 3045 :                     else
; 3046 :                         break;
; 3047 :                 }
; 3048 :                 for (; *cur; ++cur) {
; 3049 :                     int decc;
; 3050 : 
; 3051 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3052 :                     if (decc < 0) ;
; 3053 :                     else if (decc < 64)
; 3054 :                         goto return1;
; 3055 :                     if (decc == 64)
; 3056 :                         pad++;
; 3057 :                 }
; 3058 : 
; 3059 :                 /* rfc2045.txt: "Special processing is performed if fewer than
; 3060 :                  * 24 bits are available at the end of the data being encoded.
; 3061 :                  * A full encoding quantum is always completed at the end of a
; 3062 :                  * body.  When fewer than 24 input bits are available in an
; 3063 :                  * input group, zero bits are added (on the right) to form an
; 3064 :                  * integral number of 6-bit groups.  Padding at the end of the
; 3065 :                  * data is performed using the "=" character.  Since all
; 3066 :                  * base64 input is an integral number of octets, only the
; 3067 :                  * following cases can arise: (1) the final quantum of
; 3068 :                  * encoding input is an integral multiple of 24 bits; here,
; 3069 :                  * the final unit of encoded output will be an integral
; 3070 :                  * multiple ofindent: Standard input:701: Warning:old style
; 3071 : 		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
; 3072 : 		 * with no "=" padding, (2) the final
; 3073 :                  * quantum of encoding input is exactly 8 bits; here, the
; 3074 :                  * final unit of encoded output will be two characters
; 3075 :                  * followed by two "=" padding characters, or (3) the final
; 3076 :                  * quantum of encoding input is exactly 16 bits; here, the
; 3077 :                  * final unit of encoded output will be three characters
; 3078 :                  * followed by one "=" padding character." */
; 3079 : 
; 3080 :                 total = 3 * (i / 4);
; 3081 :                 if (pad == 0) {
; 3082 :                     if (i % 4 != 0)
; 3083 :                         goto return1;
; 3084 :                 } else if (pad == 1) {
; 3085 :                     int decc;
; 3086 : 
; 3087 :                     if (i % 4 != 3)
; 3088 :                         goto return1;
; 3089 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3090 :                          (decc < 0) || (decc > 63);
; 3091 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3092 :                         --cur;
; 3093 :                     /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
; 3094 :                     /* 00111100 -> 0x3c */
; 3095 :                     if (decc & ~0x3c)
; 3096 :                         goto return1;
; 3097 :                     total += 2;
; 3098 :                 } else if (pad == 2) {
; 3099 :                     int decc;
; 3100 : 
; 3101 :                     if (i % 4 != 2)
; 3102 :                         goto return1;
; 3103 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3104 :                          (decc < 0) || (decc > 63);
; 3105 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3106 :                         --cur;
; 3107 :                     /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
; 3108 :                     /* 00110000 -> 0x30 */
; 3109 :                     if (decc & ~0x30)
; 3110 :                         goto return1;
; 3111 :                     total += 1;
; 3112 :                 } else
; 3113 :                     goto return1;
; 3114 : 
; 3115 :                 if (val != NULL) {
; 3116 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);
; 3117 :                     if (v == NULL)
; 3118 :                         goto error;
; 3119 :                     base =
; 3120 :                         (xmlChar *) xmlMallocAtomic((i + pad + 1) *
; 3121 :                                                     sizeof(xmlChar));
; 3122 :                     if (base == NULL) {
; 3123 : 		        xmlSchemaTypeErrMemory(node, "allocating base64 data");
; 3124 :                         xmlFree(v);
; 3125 :                         goto return1;
; 3126 :                     }
; 3127 :                     v->value.base64.str = base;
; 3128 :                     for (cur = value; *cur; ++cur)
; 3129 :                         if (_xmlSchemaBase64Decode(*cur) >= 0) {
; 3130 :                             *base = *cur;
; 3131 :                             ++base;
; 3132 :                         }
; 3133 :                     *base = 0;
; 3134 :                     v->value.base64.total = total;
; 3135 :                     *val = v;
; 3136 :                 }
; 3137 :                 goto return0;
; 3138 :             }
; 3139 :         case XML_SCHEMAS_INTEGER:
; 3140 :         case XML_SCHEMAS_PINTEGER:
; 3141 :         case XML_SCHEMAS_NPINTEGER:
; 3142 :         case XML_SCHEMAS_NINTEGER:
; 3143 :         case XML_SCHEMAS_NNINTEGER:{
; 3144 :                 const xmlChar *cur = value;
; 3145 :                 unsigned long lo, mi, hi;
; 3146 :                 int sign = 0;
; 3147 : 
; 3148 :                 if (cur == NULL)
; 3149 :                     goto return1;
; 3150 : 		if (normOnTheFly)
; 3151 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3152 :                 if (*cur == '-') {
; 3153 :                     sign = 1;
; 3154 :                     cur++;
; 3155 :                 } else if (*cur == '+')
; 3156 :                     cur++;
; 3157 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3158 :                 if (ret < 0)
; 3159 :                     goto return1;
; 3160 : 		if (normOnTheFly)
; 3161 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3162 :                 if (*cur != 0)
; 3163 :                     goto return1;
; 3164 :                 if (type->builtInType == XML_SCHEMAS_NPINTEGER) {
; 3165 :                     if ((sign == 0) &&
; 3166 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3167 :                         goto return1;
; 3168 :                 } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {
; 3169 :                     if (sign == 1)
; 3170 :                         goto return1;
; 3171 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3172 :                         goto return1;
; 3173 :                 } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {
; 3174 :                     if (sign == 0)
; 3175 :                         goto return1;
; 3176 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3177 :                         goto return1;
; 3178 :                 } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {
; 3179 :                     if ((sign == 1) &&
; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;
; 3182 :                 }
; 3183 :                 if (val != NULL) {
; 3184 :                     v = xmlSchemaNewValue(type->builtInType);
; 3185 :                     if (v != NULL) {
; 3186 : 			if (ret == 0)
; 3187 : 			    ret++;
; 3188 :                         v->value.decimal.lo = lo;
; 3189 :                         v->value.decimal.mi = mi;
; 3190 :                         v->value.decimal.hi = hi;
; 3191 :                         v->value.decimal.sign = sign;
; 3192 :                         v->value.decimal.frac = 0;
; 3193 :                         v->value.decimal.total = ret;
; 3194 :                         *val = v;
; 3195 :                     }
; 3196 :                 }
; 3197 :                 goto return0;
; 3198 :             }
; 3199 :         case XML_SCHEMAS_LONG:
; 3200 :         case XML_SCHEMAS_BYTE:
; 3201 :         case XML_SCHEMAS_SHORT:
; 3202 :         case XML_SCHEMAS_INT:{
; 3203 :                 const xmlChar *cur = value;
; 3204 :                 unsigned long lo, mi, hi;
; 3205 :                 int sign = 0;
; 3206 : 
; 3207 :                 if (cur == NULL)
; 3208 :                     goto return1;
; 3209 :                 if (*cur == '-') {
; 3210 :                     sign = 1;
; 3211 :                     cur++;
; 3212 :                 } else if (*cur == '+')
; 3213 :                     cur++;
; 3214 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3215 :                 if (ret < 0)
; 3216 :                     goto return1;
; 3217 :                 if (*cur != 0)
; 3218 :                     goto return1;
; 3219 :                 if (type->builtInType == XML_SCHEMAS_LONG) {
; 3220 :                     if (hi >= 922) {
; 3221 :                         if (hi > 922)
; 3222 :                             goto return1;
; 3223 :                         if (mi >= 33720368) {
; 3224 :                             if (mi > 33720368)
; 3225 :                                 goto return1;
; 3226 :                             if ((sign == 0) && (lo > 54775807))
; 3227 :                                 goto return1;
; 3228 :                             if ((sign == 1) && (lo > 54775808))
; 3229 :                                 goto return1;
; 3230 :                         }
; 3231 :                     }
; 3232 :                 } else if (type->builtInType == XML_SCHEMAS_INT) {
; 3233 :                     if (hi != 0)
; 3234 :                         goto return1;
; 3235 :                     if (mi >= 21) {
; 3236 :                         if (mi > 21)
; 3237 :                             goto return1;
; 3238 :                         if ((sign == 0) && (lo > 47483647))
; 3239 :                             goto return1;
; 3240 :                         if ((sign == 1) && (lo > 47483648))
; 3241 :                             goto return1;
; 3242 :                     }
; 3243 :                 } else if (type->builtInType == XML_SCHEMAS_SHORT) {
; 3244 :                     if ((mi != 0) || (hi != 0))
; 3245 :                         goto return1;
; 3246 :                     if ((sign == 1) && (lo > 32768))
; 3247 :                         goto return1;
; 3248 :                     if ((sign == 0) && (lo > 32767))
; 3249 :                         goto return1;
; 3250 :                 } else if (type->builtInType == XML_SCHEMAS_BYTE) {
; 3251 :                     if ((mi != 0) || (hi != 0))
; 3252 :                         goto return1;
; 3253 :                     if ((sign == 1) && (lo > 128))
; 3254 :                         goto return1;
; 3255 :                     if ((sign == 0) && (lo > 127))
; 3256 :                         goto return1;
; 3257 :                 }
; 3258 :                 if (val != NULL) {
; 3259 :                     v = xmlSchemaNewValue(type->builtInType);
; 3260 :                     if (v != NULL) {
; 3261 :                         v->value.decimal.lo = lo;
; 3262 :                         v->value.decimal.mi = mi;
; 3263 :                         v->value.decimal.hi = hi;
; 3264 :                         v->value.decimal.sign = sign;
; 3265 :                         v->value.decimal.frac = 0;
; 3266 :                         v->value.decimal.total = ret;
; 3267 :                         *val = v;
; 3268 :                     }
; 3269 :                 }
; 3270 :                 goto return0;
; 3271 :             }
; 3272 :         case XML_SCHEMAS_UINT:
; 3273 :         case XML_SCHEMAS_ULONG:
; 3274 :         case XML_SCHEMAS_USHORT:
; 3275 :         case XML_SCHEMAS_UBYTE:{
; 3276 :                 const xmlChar *cur = value;
; 3277 :                 unsigned long lo, mi, hi;
; 3278 : 
; 3279 :                 if (cur == NULL)
; 3280 :                     goto return1;
; 3281 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3282 :                 if (ret < 0)
; 3283 :                     goto return1;
; 3284 :                 if (*cur != 0)
; 3285 :                     goto return1;
; 3286 :                 if (type->builtInType == XML_SCHEMAS_ULONG) {
; 3287 :                     if (hi >= 1844) {
; 3288 :                         if (hi > 1844)
; 3289 :                             goto return1;
; 3290 :                         if (mi >= 67440737) {
; 3291 :                             if (mi > 67440737)
; 3292 :                                 goto return1;
; 3293 :                             if (lo > 9551615)
; 3294 :                                 goto return1;
; 3295 :                         }
; 3296 :                     }
; 3297 :                 } else if (type->builtInType == XML_SCHEMAS_UINT) {
; 3298 :                     if (hi != 0)
; 3299 :                         goto return1;
; 3300 :                     if (mi >= 42) {
; 3301 :                         if (mi > 42)
; 3302 :                             goto return1;
; 3303 :                         if (lo > 94967295)
; 3304 :                             goto return1;
; 3305 :                     }
; 3306 :                 } else if (type->builtInType == XML_SCHEMAS_USHORT) {
; 3307 :                     if ((mi != 0) || (hi != 0))
; 3308 :                         goto return1;
; 3309 :                     if (lo > 65535)
; 3310 :                         goto return1;
; 3311 :                 } else if (type->builtInType == XML_SCHEMAS_UBYTE) {
; 3312 :                     if ((mi != 0) || (hi != 0))
; 3313 :                         goto return1;
; 3314 :                     if (lo > 255)
; 3315 :                         goto return1;
; 3316 :                 }
; 3317 :                 if (val != NULL) {
; 3318 :                     v = xmlSchemaNewValue(type->builtInType);
; 3319 :                     if (v != NULL) {
; 3320 :                         v->value.decimal.lo = lo;
; 3321 :                         v->value.decimal.mi = mi;
; 3322 :                         v->value.decimal.hi = hi;
; 3323 :                         v->value.decimal.sign = 0;
; 3324 :                         v->value.decimal.frac = 0;
; 3325 :                         v->value.decimal.total = ret;
; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)
; 3335 :         xmlFree(norm);
; 3336 :     return (ret);
; 3337 :   return3:
; 3338 :     if (norm != NULL)
; 3339 :         xmlFree(norm);
; 3340 :     return (3);
; 3341 :   return1:
; 3342 :     if (norm != NULL)
; 3343 :         xmlFree(norm);
; 3344 :     return (1);
; 3345 :   return0:
; 3346 :     if (norm != NULL)
; 3347 :         xmlFree(norm);
; 3348 :     return (0);
; 3349 :   error:
; 3350 :     if (norm != NULL)
; 3351 :         xmlFree(norm);
; 3352 :     return (-1);
; 3353 : }
; 3354 : 
; 3355 : /**
; 3356 :  * xmlSchemaValPredefTypeNode:
; 3357 :  * @type: the predefined type
; 3358 :  * @value: the value to check
; 3359 :  * @val:  the return computed value
; 3360 :  * @node:  the node containing the value
; 3361 :  *
; 3362 :  * Check that a value conforms to the lexical space of the predefined type.
; 3363 :  * if true a value is computed and returned in @val.
; 3364 :  *
; 3365 :  * Returns 0 if this validates, a positive error code number otherwise
; 3366 :  *         and -1 in case of internal or API error.
; 3367 :  */
; 3368 : int
; 3369 : xmlSchemaValPredefTypeNode(xmlSchemaTypePtr type, const xmlChar *value,
; 3370 : 	                   xmlSchemaValPtr *val, xmlNodePtr node) {
; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,
; 3372 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
; 3373 : }
; 3374 : 
; 3375 : /**
; 3376 :  * xmlSchemaValPredefTypeNodeNoNorm:
; 3377 :  * @type: the predefined type
; 3378 :  * @value: the value to check
; 3379 :  * @val:  the return computed value
; 3380 :  * @node:  the node containing the value
; 3381 :  *
; 3382 :  * Check that a value conforms to the lexical space of the predefined type.
; 3383 :  * if true a value is computed and returned in @val.
; 3384 :  * This one does apply any normalization to the value.
; 3385 :  *
; 3386 :  * Returns 0 if this validates, a positive error code number otherwise
; 3387 :  *         and -1 in case of internal or API error.
; 3388 :  */
; 3389 : int
; 3390 : xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, const xmlChar *value,
; 3391 : 				 xmlSchemaValPtr *val, xmlNodePtr node) {
; 3392 :     return(xmlSchemaValAtomicType(type, value, val, node, 1,
; 3393 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
; 3394 : }
; 3395 : 
; 3396 : /**
; 3397 :  * xmlSchemaValidatePredefinedType:
; 3398 :  * @type: the predefined type
; 3399 :  * @value: the value to check
; 3400 :  * @val:  the return computed value
; 3401 :  *
; 3402 :  * Check that a value conforms to the lexical space of the predefined type.
; 3403 :  * if true a value is computed and returned in @val.
; 3404 :  *
; 3405 :  * Returns 0 if this validates, a positive error code number otherwise
; 3406 :  *         and -1 in case of internal or API error.
; 3407 :  */
; 3408 : int
; 3409 : xmlSchemaValidatePredefinedType(xmlSchemaTypePtr type, const xmlChar *value,
; 3410 : 	                        xmlSchemaValPtr *val) {
; 3411 :     return(xmlSchemaValPredefTypeNode(type, value, val, NULL));
; 3412 : }
; 3413 : 
; 3414 : /**
; 3415 :  * xmlSchemaCompareDecimals:
; 3416 :  * @x:  a first decimal value
; 3417 :  * @y:  a second decimal value
; 3418 :  *
; 3419 :  * Compare 2 decimals
; 3420 :  *
; 3421 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error
; 3422 :  */
; 3423 : static int
; 3424 : xmlSchemaCompareDecimals(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3425 : {
; 3426 :     xmlSchemaValPtr swp;
; 3427 :     int order = 1, integx, integy, dlen;
; 3428 :     unsigned long hi, mi, lo;
; 3429 : 
; 3430 :     /*
; 3431 :      * First test: If x is -ve and not zero
; 3432 :      */
; 3433 :     if ((x->value.decimal.sign) &&
; 3434 : 	((x->value.decimal.lo != 0) ||
; 3435 : 	 (x->value.decimal.mi != 0) ||
; 3436 : 	 (x->value.decimal.hi != 0))) {
; 3437 : 	/*
; 3438 : 	 * Then if y is -ve and not zero reverse the compare
; 3439 : 	 */
; 3440 : 	if ((y->value.decimal.sign) &&
; 3441 : 	    ((y->value.decimal.lo != 0) ||
; 3442 : 	     (y->value.decimal.mi != 0) ||
; 3443 : 	     (y->value.decimal.hi != 0)))
; 3444 : 	    order = -1;
; 3445 : 	/*
; 3446 : 	 * Otherwise (y >= 0) we have the answer
; 3447 : 	 */
; 3448 : 	else
; 3449 : 	    return (-1);
; 3450 :     /*
; 3451 :      * If x is not -ve and y is -ve we have the answer
; 3452 :      */
; 3453 :     } else if ((y->value.decimal.sign) &&
; 3454 : 	       ((y->value.decimal.lo != 0) ||
; 3455 : 		(y->value.decimal.mi != 0) ||
; 3456 : 		(y->value.decimal.hi != 0))) {
; 3457 :         return (1);
; 3458 :     }
; 3459 :     /*
; 3460 :      * If it's not simply determined by a difference in sign,
; 3461 :      * then we need to compare the actual values of the two nums.
; 3462 :      * To do this, we start by looking at the integral parts.
; 3463 :      * If the number of integral digits differ, then we have our
; 3464 :      * answer.
; 3465 :      */
; 3466 :     integx = x->value.decimal.total - x->value.decimal.frac;
; 3467 :     integy = y->value.decimal.total - y->value.decimal.frac;
; 3468 :     /*
; 3469 :     * NOTE: We changed the "total" for values like "0.1"
; 3470 :     *   (or "-0.1" or ".1") to be 1, which was 2 previously.
; 3471 :     *   Therefore the special case, when such values are
; 3472 :     *   compared with 0, needs to be handled separately;
; 3473 :     *   otherwise a zero would be recognized incorrectly as
; 3474 :     *   greater than those values. This has the nice side effect
; 3475 :     *   that we gain an overall optimized comparison with zeroes.
; 3476 :     * Note that a "0" has a "total" of 1 already.
; 3477 :     */
; 3478 :     if (integx == 1) {
; 3479 : 	if (x->value.decimal.lo == 0) {
; 3480 : 	    if (integy != 1)
; 3481 : 		return -order;
; 3482 : 	    else if (y->value.decimal.lo != 0)
; 3483 : 		return -order;
; 3484 : 	    else
; 3485 : 		return(0);
; 3486 : 	}
; 3487 :     }
; 3488 :     if (integy == 1) {
; 3489 : 	if (y->value.decimal.lo == 0) {
; 3490 : 	    if (integx != 1)
; 3491 : 		return order;
; 3492 : 	    else if (x->value.decimal.lo != 0)
; 3493 : 		return order;
; 3494 : 	    else
; 3495 : 		return(0);
; 3496 : 	}
; 3497 :     }
; 3498 : 
; 3499 :     if (integx > integy)
; 3500 : 	return order;
; 3501 :     else if (integy > integx)
; 3502 : 	return -order;
; 3503 : 
; 3504 :     /*
; 3505 :      * If the number of integral digits is the same for both numbers,
; 3506 :      * then things get a little more complicated.  We need to "normalize"
; 3507 :      * the numbers in order to properly compare them.  To do this, we
; 3508 :      * look at the total length of each number (length => number of
; 3509 :      * significant digits), and divide the "shorter" by 10 (decreasing
; 3510 :      * the length) until they are of equal length.
; 3511 :      */
; 3512 :     dlen = x->value.decimal.total - y->value.decimal.total;
; 3513 :     if (dlen < 0) {	/* y has more digits than x */
; 3514 : 	swp = x;
; 3515 : 	hi = y->value.decimal.hi;
; 3516 : 	mi = y->value.decimal.mi;
; 3517 : 	lo = y->value.decimal.lo;
; 3518 : 	dlen = -dlen;
; 3519 : 	order = -order;
; 3520 :     } else {		/* x has more digits than y */
; 3521 : 	swp = y;
; 3522 : 	hi = x->value.decimal.hi;
; 3523 : 	mi = x->value.decimal.mi;
; 3524 : 	lo = x->value.decimal.lo;
; 3525 :     }
; 3526 :     while (dlen > 8) {	/* in effect, right shift by 10**8 */
; 3527 : 	lo = mi;
; 3528 : 	mi = hi;
; 3529 : 	hi = 0;
; 3530 : 	dlen -= 8;
; 3531 :     }
; 3532 :     while (dlen > 0) {
; 3533 : 	unsigned long rem1, rem2;
; 3534 : 	rem1 = (hi % 10) * 100000000L;
; 3535 : 	hi = hi / 10;
; 3536 : 	rem2 = (mi % 10) * 100000000L;
; 3537 : 	mi = (mi + rem1) / 10;
; 3538 : 	lo = (lo + rem2) / 10;
; 3539 : 	dlen--;
; 3540 :     }
; 3541 :     if (hi > swp->value.decimal.hi) {
; 3542 : 	return order;
; 3543 :     } else if (hi == swp->value.decimal.hi) {
; 3544 : 	if (mi > swp->value.decimal.mi) {
; 3545 : 	    return order;
; 3546 : 	} else if (mi == swp->value.decimal.mi) {
; 3547 : 	    if (lo > swp->value.decimal.lo) {
; 3548 : 		return order;
; 3549 : 	    } else if (lo == swp->value.decimal.lo) {
; 3550 : 		if (x->value.decimal.total == y->value.decimal.total) {
; 3551 : 		    return 0;
; 3552 : 		} else {
; 3553 : 		    return order;
; 3554 : 		}
; 3555 : 	    }
; 3556 : 	}
; 3557 :     }
; 3558 :     return -order;
; 3559 : }
; 3560 : 
; 3561 : /**
; 3562 :  * xmlSchemaCompareDurations:
; 3563 :  * @x:  a first duration value
; 3564 :  * @y:  a second duration value
; 3565 :  *
; 3566 :  * Compare 2 durations
; 3567 :  *
; 3568 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in
; 3569 :  * case of error
; 3570 :  */
; 3571 : static int
; 3572 : xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3573 : {
; 3574 :     long carry, mon, day;
; 3575 :     double sec;
; 3576 :     int invert = 1;
; 3577 :     long xmon, xday, myear, minday, maxday;
; 3578 :     static const long dayRange [2][12] = {
; 3579 :         { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
; 3580 :         { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
; 3581 : 
; 3582 :     if ((x == NULL) || (y == NULL))
; 3583 :         return -2;
; 3584 : 
; 3585 :     /* months */
; 3586 :     mon = x->value.dur.mon - y->value.dur.mon;
; 3587 : 
; 3588 :     /* seconds */
; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;
; 3590 :     carry = (long)(sec / SECS_PER_DAY);
; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;
; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;
; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {
; 3598 :         if (day == 0)
; 3599 :             if (sec == 0.0)
; 3600 :                 return 0;
; 3601 :             else if (sec < 0.0)
; 3602 :                 return -1;
; 3603 :             else
; 3604 :                 return 1;
; 3605 :         else if (day < 0)
; 3606 :             return -1;
; 3607 :         else
; 3608 :             return 1;
; 3609 :     }
; 3610 : 
; 3611 :     if (mon > 0) {
; 3612 :         if ((day >= 0) && (sec >= 0.0))
; 3613 :             return 1;
; 3614 :         else {
; 3615 :             xmon = mon;
; 3616 :             xday = -day;
; 3617 :         }
; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {
; 3619 :         return -1;
; 3620 :     } else {
; 3621 : 	invert = -1;
; 3622 :         xmon = -mon;
; 3623 :         xday = day;
; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;
; 3627 :     if (myear == 0) {
; 3628 : 	minday = 0;
; 3629 : 	maxday = 0;
; 3630 :     } else {
; 3631 : 	maxday = 366 * ((myear + 3) / 4) +
; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;
; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;
; 3637 :     minday += dayRange[0][xmon];
; 3638 :     maxday += dayRange[1][xmon];
; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))
; 3641 : 	return(0); /* can this really happen ? */
; 3642 :     if (maxday < xday)
; 3643 :         return(-invert);
; 3644 :     if (minday > xday)
; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }
; 3650 : 
; 3651 : /*
; 3652 :  * macros for adding date/times and durations
; 3653 :  */
; 3654 : #define FQUOTIENT(a,b)                  (floor(((double)a/(double)b)))
; 3655 : #define MODULO(a,b)                     (a - FQUOTIENT(a,b) * b)
; 3656 : #define FQUOTIENT_RANGE(a,low,high)     (FQUOTIENT((a-low),(high-low)))
; 3657 : #define MODULO_RANGE(a,low,high)        ((MODULO((a-low),(high-low)))+low)
; 3658 : 
; 3659 : /**
; 3660 :  * xmlSchemaDupVal:
; 3661 :  * @v: the #xmlSchemaValPtr value to duplicate
; 3662 :  *
; 3663 :  * Makes a copy of @v. The calling program is responsible for freeing
; 3664 :  * the returned value.
; 3665 :  *
; 3666 :  * returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error.
; 3667 :  */
; 3668 : static xmlSchemaValPtr
; 3669 : xmlSchemaDupVal (xmlSchemaValPtr v)
; 3670 : {
; 3671 :     xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);
; 3672 :     if (ret == NULL)
; 3673 :         return NULL;

	xor	esi, esi
$LN26@xmlSchemaC:

; 3720 : 	    case XML_SCHEMAS_QNAME:
; 3721 : 	    case XML_SCHEMAS_NOTATION:
; 3722 : 		cur = xmlSchemaDupVal(val);
; 3723 : 		if (val->value.qname.name != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaC

; 3724 : 		    cur->value.qname.name =

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN10@xmlSchemaC:

; 3725 :                     xmlStrdup(BAD_CAST val->value.qname.name);
; 3726 : 		if (val->value.qname.uri != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaC

; 3727 : 		    cur->value.qname.uri =

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 3728 :                     xmlStrdup(BAD_CAST val->value.qname.uri);
; 3729 : 		break;

	jmp	SHORT $LN32@xmlSchemaC
$LN12@xmlSchemaC:

; 3730 : 	    case XML_SCHEMAS_HEXBINARY:
; 3731 : 		cur = xmlSchemaDupVal(val);
; 3732 : 		if (val->value.hex.str != NULL)
; 3733 : 		    cur->value.hex.str = xmlStrdup(BAD_CAST val->value.hex.str);
; 3734 : 		break;
; 3735 : 	    case XML_SCHEMAS_BASE64BINARY:
; 3736 : 		cur = xmlSchemaDupVal(val);
; 3737 : 		if (val->value.base64.str != NULL)
; 3738 : 		    cur->value.base64.str =
; 3739 :                     xmlStrdup(BAD_CAST val->value.base64.str);
; 3740 : 		break;
; 3741 : 	    default:
; 3742 : 		cur = xmlSchemaDupVal(val);
; 3743 : 		break;
; 3744 : 	}
; 3745 : 	if (ret == NULL)

	push	edi
	call	_xmlSchemaDupVal
	mov	esi, eax
	add	esp, 4
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaC
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
	jmp	SHORT $LN32@xmlSchemaC
$LN16@xmlSchemaC:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 231  :     if (value == NULL) {

	test	esi, esi
	je	SHORT $LN44@xmlSchemaC

; 235  :     value->type = type;

	mov	eax, DWORD PTR tv350[ebp]
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [esi], eax

; 3675 :     memcpy(ret, v, sizeof(xmlSchemaVal));

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [edi+16]
	movups	XMMWORD PTR [esi+16], xmm0

; 3676 :     ret->next = NULL;

	mov	DWORD PTR [esi+4], 0

; 3677 :     return ret;

	jmp	SHORT $LN32@xmlSchemaC
$LN44@xmlSchemaC:

; 236  :     return(value);
; 237  : }
; 238  : 
; 239  : static xmlSchemaFacetPtr
; 240  : xmlSchemaNewMinLengthFacet(int value)
; 241  : {
; 242  :     xmlSchemaFacetPtr ret;
; 243  : 
; 244  :     ret = xmlSchemaNewFacet();
; 245  :     if (ret == NULL) {
; 246  :         return(NULL);
; 247  :     }
; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;
; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);
; 250  :     if (ret->val == NULL) {
; 251  :         xmlFree(ret);
; 252  : 	return(NULL);
; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;
; 255  :     return (ret);
; 256  : }
; 257  : 
; 258  : /*
; 259  :  * xmlSchemaInitBasicType:
; 260  :  * @name:  the type name
; 261  :  * @type:  the value type associated
; 262  :  *
; 263  :  * Initialize one primitive built-in type
; 264  :  */
; 265  : static xmlSchemaTypePtr
; 266  : xmlSchemaInitBasicType(const char *name, xmlSchemaValType type,
; 267  : 		       xmlSchemaTypePtr baseType) {
; 268  :     xmlSchemaTypePtr ret;
; 269  : 
; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));
; 271  :     if (ret == NULL) {
; 272  :         xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");
; 273  : 	return(NULL);
; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));
; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;
; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);
; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;
; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;
; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,
; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;
; 330  :     return(ret);
; 331  : }
; 332  : 
; 333  : /*
; 334  : * WARNING: Those type reside normally in xmlschemas.c but are
; 335  : * redefined here locally in oder of being able to use them for xs:anyType-
; 336  : * TODO: Remove those definition if we move the types to a header file.
; 337  : * TODO: Always keep those structs up-to-date with the originals.
; 338  : */
; 339  : #define UNBOUNDED (1 << 30)
; 340  : 
; 341  : typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;
; 342  : typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;
; 343  : struct _xmlSchemaTreeItem {
; 344  :     xmlSchemaTypeType type;
; 345  :     xmlSchemaAnnotPtr annot;
; 346  :     xmlSchemaTreeItemPtr next;
; 347  :     xmlSchemaTreeItemPtr children;
; 348  : };
; 349  : 
; 350  : typedef struct _xmlSchemaParticle xmlSchemaParticle;
; 351  : typedef xmlSchemaParticle *xmlSchemaParticlePtr;
; 352  : struct _xmlSchemaParticle {
; 353  :     xmlSchemaTypeType type;
; 354  :     xmlSchemaAnnotPtr annot;
; 355  :     xmlSchemaTreeItemPtr next;
; 356  :     xmlSchemaTreeItemPtr children;
; 357  :     int minOccurs;
; 358  :     int maxOccurs;
; 359  :     xmlNodePtr node;
; 360  : };
; 361  : 
; 362  : typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;
; 363  : typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;
; 364  : struct _xmlSchemaModelGroup {
; 365  :     xmlSchemaTypeType type;
; 366  :     xmlSchemaAnnotPtr annot;
; 367  :     xmlSchemaTreeItemPtr next;
; 368  :     xmlSchemaTreeItemPtr children;
; 369  :     xmlNodePtr node;
; 370  : };
; 371  : 
; 372  : static xmlSchemaParticlePtr
; 373  : xmlSchemaAddParticle(void)
; 374  : {
; 375  :     xmlSchemaParticlePtr ret = NULL;
; 376  : 
; 377  :     ret = (xmlSchemaParticlePtr)
; 378  : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 379  :     if (ret == NULL) {
; 380  : 	xmlSchemaTypeErrMemory(NULL, "allocating particle component");
; 381  : 	return (NULL);
; 382  :     }
; 383  :     memset(ret, 0, sizeof(xmlSchemaParticle));
; 384  :     ret->type = XML_SCHEMA_TYPE_PARTICLE;
; 385  :     ret->minOccurs = 1;
; 386  :     ret->maxOccurs = 1;
; 387  :     return (ret);
; 388  : }
; 389  : 
; 390  : /*
; 391  :  * xmlSchemaInitTypes:
; 392  :  *
; 393  :  * Initialize the default XML Schemas type library
; 394  :  */
; 395  : void
; 396  : xmlSchemaInitTypes(void)
; 397  : {
; 398  :     if (xmlSchemaTypesInitialized != 0)
; 399  :         return;
; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);
; 401  : 
; 402  : 
; 403  :     /*
; 404  :     * 3.4.7 Built-in Complex Type Definition
; 405  :     */
; 406  :     xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",
; 407  :                                                      XML_SCHEMAS_ANYTYPE,
; 408  : 						     NULL);
; 409  :     xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;
; 410  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 411  :     /*
; 412  :     * Init the content type.
; 413  :     */
; 414  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 415  :     {
; 416  : 	xmlSchemaParticlePtr particle;
; 417  : 	xmlSchemaModelGroupPtr sequence;
; 418  : 	xmlSchemaWildcardPtr wild;
; 419  : 	/* First particle. */
; 420  : 	particle = xmlSchemaAddParticle();
; 421  : 	if (particle == NULL)
; 422  : 	    return;
; 423  : 	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;
; 424  : 	/* Sequence model group. */
; 425  : 	sequence = (xmlSchemaModelGroupPtr)
; 426  : 	    xmlMalloc(sizeof(xmlSchemaModelGroup));
; 427  : 	if (sequence == NULL) {
; 428  : 	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");
; 429  : 	    return;
; 430  : 	}
; 431  : 	memset(sequence, 0, sizeof(xmlSchemaModelGroup));
; 432  : 	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;
; 433  : 	particle->children = (xmlSchemaTreeItemPtr) sequence;
; 434  : 	/* Second particle. */
; 435  : 	particle = xmlSchemaAddParticle();
; 436  : 	if (particle == NULL)
; 437  : 	    return;
; 438  : 	particle->minOccurs = 0;
; 439  : 	particle->maxOccurs = UNBOUNDED;
; 440  : 	sequence->children = (xmlSchemaTreeItemPtr) particle;
; 441  : 	/* The wildcard */
; 442  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 443  : 	if (wild == NULL) {
; 444  : 	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");
; 445  : 	    return;
; 446  : 	}
; 447  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 448  : 	wild->type = XML_SCHEMA_TYPE_ANY;
; 449  : 	wild->any = 1;
; 450  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 451  : 	particle->children = (xmlSchemaTreeItemPtr) wild;
; 452  : 	/*
; 453  : 	* Create the attribute wildcard.
; 454  : 	*/
; 455  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));
; 456  : 	if (wild == NULL) {
; 457  : 	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "
; 458  : 		"wildcard on anyType");
; 459  : 	    return;
; 460  : 	}
; 461  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));
; 462  : 	wild->any = 1;
; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;
; 465  :     }
; 466  :     xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",
; 467  :                                                            XML_SCHEMAS_ANYSIMPLETYPE,
; 468  : 							   xmlSchemaTypeAnyTypeDef);
; 469  :     /*
; 470  :     * primitive datatypes
; 471  :     */
; 472  :     xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",
; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",
; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",
; 479  :                                                   XML_SCHEMAS_DATE,
; 480  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 481  :     xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",
; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",
; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",
; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",
; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",
; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",
; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",
; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",
; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",
; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",
; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",
; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",
; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",
; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,
; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",
; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",
; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",
; 534  :                                                      XML_SCHEMAS_INTEGER,
; 535  : 						     xmlSchemaTypeDecimalDef);
; 536  :     xmlSchemaTypeNonPositiveIntegerDef =
; 537  :         xmlSchemaInitBasicType("nonPositiveInteger",
; 538  :                                XML_SCHEMAS_NPINTEGER,
; 539  : 			       xmlSchemaTypeIntegerDef);
; 540  :     xmlSchemaTypeNegativeIntegerDef =
; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =
; 544  :         xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
; 545  : 	xmlSchemaTypeIntegerDef);
; 546  :     xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,
; 547  : 	xmlSchemaTypeLongDef);
; 548  :     xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",
; 549  :                                                    XML_SCHEMAS_SHORT,
; 550  : 						   xmlSchemaTypeIntDef);
; 551  :     xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",
; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =
; 555  :         xmlSchemaInitBasicType("nonNegativeInteger",
; 556  :                                XML_SCHEMAS_NNINTEGER,
; 557  : 			       xmlSchemaTypeIntegerDef);
; 558  :     xmlSchemaTypeUnsignedLongDef =
; 559  :         xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
; 560  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 561  :     xmlSchemaTypeUnsignedIntDef =
; 562  :         xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
; 563  : 	xmlSchemaTypeUnsignedLongDef);
; 564  :     xmlSchemaTypeUnsignedShortDef =
; 565  :         xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
; 566  : 	xmlSchemaTypeUnsignedIntDef);
; 567  :     xmlSchemaTypeUnsignedByteDef =
; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =
; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",
; 574  :                                                         XML_SCHEMAS_NORMSTRING,
; 575  : 							xmlSchemaTypeStringDef);
; 576  :     xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",
; 577  :                                                    XML_SCHEMAS_TOKEN,
; 578  : 						   xmlSchemaTypeNormStringDef);
; 579  :     xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",
; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",
; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",
; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",
; 589  :                                                     XML_SCHEMAS_NCNAME,
; 590  : 						    xmlSchemaTypeNameDef);
; 591  :     xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,
; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",
; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",
; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",
; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;
; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",
; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;
; 612  : 
; 613  :     /* NMTOKENS */
; 614  :     xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",
; 615  :                                                       XML_SCHEMAS_NMTOKENS,
; 616  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 617  :     xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;
; 618  : 
; 619  :     xmlSchemaTypesInitialized = 1;
; 620  : }
; 621  : 
; 622  : static void
; 623  : xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {
; 624  :     xmlSchemaFreeType((xmlSchemaTypePtr) type);
; 625  : }
; 626  : 
; 627  : /**
; 628  :  * xmlSchemaCleanupTypes:
; 629  :  *
; 630  :  * Cleanup the default XML Schemas type library
; 631  :  */
; 632  : void
; 633  : xmlSchemaCleanupTypes(void) {
; 634  :     if (xmlSchemaTypesInitialized == 0)
; 635  : 	return;
; 636  :     /*
; 637  :     * Free xs:anyType.
; 638  :     */
; 639  :     {
; 640  : 	xmlSchemaParticlePtr particle;
; 641  : 	/* Attribute wildcard. */
; 642  : 	xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);
; 643  : 	/* Content type. */
; 644  : 	particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;
; 645  : 	/* Wildcard. */
; 646  : 	xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)
; 647  : 	    particle->children->children->children);
; 648  : 	xmlFree((xmlSchemaParticlePtr) particle->children->children);
; 649  : 	/* Sequence model group. */
; 650  : 	xmlFree((xmlSchemaModelGroupPtr) particle->children);
; 651  : 	xmlFree((xmlSchemaParticlePtr) particle);
; 652  : 	xmlSchemaTypeAnyTypeDef->subtypes = NULL;
; 653  :     }
; 654  :     xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);
; 655  :     xmlSchemaTypesInitialized = 0;
; 656  : }
; 657  : 
; 658  : /**
; 659  :  * xmlSchemaIsBuiltInTypeFacet:
; 660  :  * @type: the built-in type
; 661  :  * @facetType:  the facet type
; 662  :  *
; 663  :  * Evaluates if a specific facet can be
; 664  :  * used in conjunction with a type.
; 665  :  *
; 666  :  * Returns 1 if the facet can be used with the given built-in type,
; 667  :  * 0 otherwise and -1 in case the type is not a built-in type.
; 668  :  */
; 669  : int
; 670  : xmlSchemaIsBuiltInTypeFacet(xmlSchemaTypePtr type, int facetType)
; 671  : {
; 672  :     if (type == NULL)
; 673  : 	return (-1);
; 674  :     if (type->type != XML_SCHEMA_TYPE_BASIC)
; 675  : 	return (-1);
; 676  :     switch (type->builtInType) {
; 677  : 	case XML_SCHEMAS_BOOLEAN:
; 678  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 679  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 680  : 		return (1);
; 681  : 	    else
; 682  : 		return (0);
; 683  : 	case XML_SCHEMAS_STRING:
; 684  : 	case XML_SCHEMAS_NOTATION:
; 685  : 	case XML_SCHEMAS_QNAME:
; 686  : 	case XML_SCHEMAS_ANYURI:
; 687  : 	case XML_SCHEMAS_BASE64BINARY:
; 688  : 	case XML_SCHEMAS_HEXBINARY:
; 689  : 	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 690  : 		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
; 691  : 		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
; 692  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 693  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 694  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 695  : 		return (1);
; 696  : 	    else
; 697  : 		return (0);
; 698  : 	case XML_SCHEMAS_DECIMAL:
; 699  : 	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
; 700  : 		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
; 701  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 702  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 703  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 704  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 705  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 706  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 707  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 708  : 		return (1);
; 709  : 	    else
; 710  : 		return (0);
; 711  : 	case XML_SCHEMAS_TIME:
; 712  : 	case XML_SCHEMAS_GDAY:
; 713  : 	case XML_SCHEMAS_GMONTH:
; 714  : 	case XML_SCHEMAS_GMONTHDAY:
; 715  : 	case XML_SCHEMAS_GYEAR:
; 716  : 	case XML_SCHEMAS_GYEARMONTH:
; 717  : 	case XML_SCHEMAS_DATE:
; 718  : 	case XML_SCHEMAS_DATETIME:
; 719  : 	case XML_SCHEMAS_DURATION:
; 720  : 	case XML_SCHEMAS_FLOAT:
; 721  : 	case XML_SCHEMAS_DOUBLE:
; 722  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 723  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 724  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 725  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 726  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 727  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||
; 728  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 729  : 		return (1);
; 730  : 	    else
; 731  : 		return (0);
; 732  : 	default:
; 733  : 	    break;
; 734  :     }
; 735  :     return (0);
; 736  : }
; 737  : 
; 738  : /**
; 739  :  * xmlSchemaGetBuiltInType:
; 740  :  * @type:  the type of the built in type
; 741  :  *
; 742  :  * Gives you the type struct for a built-in
; 743  :  * type by its type id.
; 744  :  *
; 745  :  * Returns the type if found, NULL otherwise.
; 746  :  */
; 747  : xmlSchemaTypePtr
; 748  : xmlSchemaGetBuiltInType(xmlSchemaValType type)
; 749  : {
; 750  :     if (xmlSchemaTypesInitialized == 0)
; 751  : 	xmlSchemaInitTypes();
; 752  :     switch (type) {
; 753  : 
; 754  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 755  : 	    return (xmlSchemaTypeAnySimpleTypeDef);
; 756  : 	case XML_SCHEMAS_STRING:
; 757  : 	    return (xmlSchemaTypeStringDef);
; 758  : 	case XML_SCHEMAS_NORMSTRING:
; 759  : 	    return (xmlSchemaTypeNormStringDef);
; 760  : 	case XML_SCHEMAS_DECIMAL:
; 761  : 	    return (xmlSchemaTypeDecimalDef);
; 762  : 	case XML_SCHEMAS_TIME:
; 763  : 	    return (xmlSchemaTypeTimeDef);
; 764  : 	case XML_SCHEMAS_GDAY:
; 765  : 	    return (xmlSchemaTypeGDayDef);
; 766  : 	case XML_SCHEMAS_GMONTH:
; 767  : 	    return (xmlSchemaTypeGMonthDef);
; 768  : 	case XML_SCHEMAS_GMONTHDAY:
; 769  : 	    return (xmlSchemaTypeGMonthDayDef);
; 770  : 	case XML_SCHEMAS_GYEAR:
; 771  : 	    return (xmlSchemaTypeGYearDef);
; 772  : 	case XML_SCHEMAS_GYEARMONTH:
; 773  : 	    return (xmlSchemaTypeGYearMonthDef);
; 774  : 	case XML_SCHEMAS_DATE:
; 775  : 	    return (xmlSchemaTypeDateDef);
; 776  : 	case XML_SCHEMAS_DATETIME:
; 777  : 	    return (xmlSchemaTypeDatetimeDef);
; 778  : 	case XML_SCHEMAS_DURATION:
; 779  : 	    return (xmlSchemaTypeDurationDef);
; 780  : 	case XML_SCHEMAS_FLOAT:
; 781  : 	    return (xmlSchemaTypeFloatDef);
; 782  : 	case XML_SCHEMAS_DOUBLE:
; 783  : 	    return (xmlSchemaTypeDoubleDef);
; 784  : 	case XML_SCHEMAS_BOOLEAN:
; 785  : 	    return (xmlSchemaTypeBooleanDef);
; 786  : 	case XML_SCHEMAS_TOKEN:
; 787  : 	    return (xmlSchemaTypeTokenDef);
; 788  : 	case XML_SCHEMAS_LANGUAGE:
; 789  : 	    return (xmlSchemaTypeLanguageDef);
; 790  : 	case XML_SCHEMAS_NMTOKEN:
; 791  : 	    return (xmlSchemaTypeNmtokenDef);
; 792  : 	case XML_SCHEMAS_NMTOKENS:
; 793  : 	    return (xmlSchemaTypeNmtokensDef);
; 794  : 	case XML_SCHEMAS_NAME:
; 795  : 	    return (xmlSchemaTypeNameDef);
; 796  : 	case XML_SCHEMAS_QNAME:
; 797  : 	    return (xmlSchemaTypeQNameDef);
; 798  : 	case XML_SCHEMAS_NCNAME:
; 799  : 	    return (xmlSchemaTypeNCNameDef);
; 800  : 	case XML_SCHEMAS_ID:
; 801  : 	    return (xmlSchemaTypeIdDef);
; 802  : 	case XML_SCHEMAS_IDREF:
; 803  : 	    return (xmlSchemaTypeIdrefDef);
; 804  : 	case XML_SCHEMAS_IDREFS:
; 805  : 	    return (xmlSchemaTypeIdrefsDef);
; 806  : 	case XML_SCHEMAS_ENTITY:
; 807  : 	    return (xmlSchemaTypeEntityDef);
; 808  : 	case XML_SCHEMAS_ENTITIES:
; 809  : 	    return (xmlSchemaTypeEntitiesDef);
; 810  : 	case XML_SCHEMAS_NOTATION:
; 811  : 	    return (xmlSchemaTypeNotationDef);
; 812  : 	case XML_SCHEMAS_ANYURI:
; 813  : 	    return (xmlSchemaTypeAnyURIDef);
; 814  : 	case XML_SCHEMAS_INTEGER:
; 815  : 	    return (xmlSchemaTypeIntegerDef);
; 816  : 	case XML_SCHEMAS_NPINTEGER:
; 817  : 	    return (xmlSchemaTypeNonPositiveIntegerDef);
; 818  : 	case XML_SCHEMAS_NINTEGER:
; 819  : 	    return (xmlSchemaTypeNegativeIntegerDef);
; 820  : 	case XML_SCHEMAS_NNINTEGER:
; 821  : 	    return (xmlSchemaTypeNonNegativeIntegerDef);
; 822  : 	case XML_SCHEMAS_PINTEGER:
; 823  : 	    return (xmlSchemaTypePositiveIntegerDef);
; 824  : 	case XML_SCHEMAS_INT:
; 825  : 	    return (xmlSchemaTypeIntDef);
; 826  : 	case XML_SCHEMAS_UINT:
; 827  : 	    return (xmlSchemaTypeUnsignedIntDef);
; 828  : 	case XML_SCHEMAS_LONG:
; 829  : 	    return (xmlSchemaTypeLongDef);
; 830  : 	case XML_SCHEMAS_ULONG:
; 831  : 	    return (xmlSchemaTypeUnsignedLongDef);
; 832  : 	case XML_SCHEMAS_SHORT:
; 833  : 	    return (xmlSchemaTypeShortDef);
; 834  : 	case XML_SCHEMAS_USHORT:
; 835  : 	    return (xmlSchemaTypeUnsignedShortDef);
; 836  : 	case XML_SCHEMAS_BYTE:
; 837  : 	    return (xmlSchemaTypeByteDef);
; 838  : 	case XML_SCHEMAS_UBYTE:
; 839  : 	    return (xmlSchemaTypeUnsignedByteDef);
; 840  : 	case XML_SCHEMAS_HEXBINARY:
; 841  : 	    return (xmlSchemaTypeHexBinaryDef);
; 842  : 	case XML_SCHEMAS_BASE64BINARY:
; 843  : 	    return (xmlSchemaTypeBase64BinaryDef);
; 844  : 	case XML_SCHEMAS_ANYTYPE:
; 845  : 	    return (xmlSchemaTypeAnyTypeDef);
; 846  : 	default:
; 847  : 	    return (NULL);
; 848  :     }
; 849  : }
; 850  : 
; 851  : /**
; 852  :  * xmlSchemaValueAppend:
; 853  :  * @prev: the value
; 854  :  * @cur: the value to be appended
; 855  :  *
; 856  :  * Appends a next sibling to a list of computed values.
; 857  :  *
; 858  :  * Returns 0 if succeeded and -1 on API errors.
; 859  :  */
; 860  : int
; 861  : xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {
; 862  : 
; 863  :     if ((prev == NULL) || (cur == NULL))
; 864  : 	return (-1);
; 865  :     prev->next = cur;
; 866  :     return (0);
; 867  : }
; 868  : 
; 869  : /**
; 870  :  * xmlSchemaValueGetNext:
; 871  :  * @cur: the value
; 872  :  *
; 873  :  * Accessor for the next sibling of a list of computed values.
; 874  :  *
; 875  :  * Returns the next value or NULL if there was none, or on
; 876  :  *         API errors.
; 877  :  */
; 878  : xmlSchemaValPtr
; 879  : xmlSchemaValueGetNext(xmlSchemaValPtr cur) {
; 880  : 
; 881  :     if (cur == NULL)
; 882  : 	return (NULL);
; 883  :     return (cur->next);
; 884  : }
; 885  : 
; 886  : /**
; 887  :  * xmlSchemaValueGetAsString:
; 888  :  * @val: the value
; 889  :  *
; 890  :  * Accessor for the string value of a computed value.
; 891  :  *
; 892  :  * Returns the string value or NULL if there was none, or on
; 893  :  *         API errors.
; 894  :  */
; 895  : const xmlChar *
; 896  : xmlSchemaValueGetAsString(xmlSchemaValPtr val)
; 897  : {
; 898  :     if (val == NULL)
; 899  : 	return (NULL);
; 900  :     switch (val->type) {
; 901  : 	case XML_SCHEMAS_STRING:
; 902  : 	case XML_SCHEMAS_NORMSTRING:
; 903  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 904  : 	case XML_SCHEMAS_TOKEN:
; 905  :         case XML_SCHEMAS_LANGUAGE:
; 906  :         case XML_SCHEMAS_NMTOKEN:
; 907  :         case XML_SCHEMAS_NAME:
; 908  :         case XML_SCHEMAS_NCNAME:
; 909  :         case XML_SCHEMAS_ID:
; 910  :         case XML_SCHEMAS_IDREF:
; 911  :         case XML_SCHEMAS_ENTITY:
; 912  :         case XML_SCHEMAS_ANYURI:
; 913  : 	    return (BAD_CAST val->value.str);
; 914  : 	default:
; 915  : 	    break;
; 916  :     }
; 917  :     return (NULL);
; 918  : }
; 919  : 
; 920  : /**
; 921  :  * xmlSchemaValueGetAsBoolean:
; 922  :  * @val: the value
; 923  :  *
; 924  :  * Accessor for the boolean value of a computed value.
; 925  :  *
; 926  :  * Returns 1 if true and 0 if false, or in case of an error. Hmm.
; 927  :  */
; 928  : int
; 929  : xmlSchemaValueGetAsBoolean(xmlSchemaValPtr val)
; 930  : {
; 931  :     if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))
; 932  : 	return (0);
; 933  :     return (val->value.b);
; 934  : }
; 935  : 
; 936  : /**
; 937  :  * xmlSchemaNewStringValue:
; 938  :  * @type:  the value type
; 939  :  * @value:  the value
; 940  :  *
; 941  :  * Allocate a new simple type value. The type can be
; 942  :  * of XML_SCHEMAS_STRING.
; 943  :  * WARNING: This one is intended to be expanded for other
; 944  :  * string based types. We need this for anySimpleType as well.
; 945  :  * The given value is consumed and freed with the struct.
; 946  :  *
; 947  :  * Returns a pointer to the new value or NULL in case of error
; 948  :  */
; 949  : xmlSchemaValPtr
; 950  : xmlSchemaNewStringValue(xmlSchemaValType type,
; 951  : 			const xmlChar *value)
; 952  : {
; 953  :     xmlSchemaValPtr val;
; 954  : 
; 955  :     if (type != XML_SCHEMAS_STRING)
; 956  : 	return(NULL);
; 957  :     val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));
; 958  :     if (val == NULL) {
; 959  : 	return(NULL);
; 960  :     }
; 961  :     memset(val, 0, sizeof(xmlSchemaVal));
; 962  :     val->type = type;
; 963  :     val->value.str = (xmlChar *) value;
; 964  :     return(val);
; 965  : }
; 966  : 
; 967  : /**
; 968  :  * xmlSchemaNewNOTATIONValue:
; 969  :  * @name:  the notation name
; 970  :  * @ns: the notation namespace name or NULL
; 971  :  *
; 972  :  * Allocate a new NOTATION value.
; 973  :  * The given values are consumed and freed with the struct.
; 974  :  *
; 975  :  * Returns a pointer to the new value or NULL in case of error
; 976  :  */
; 977  : xmlSchemaValPtr
; 978  : xmlSchemaNewNOTATIONValue(const xmlChar *name,
; 979  : 			  const xmlChar *ns)
; 980  : {
; 981  :     xmlSchemaValPtr val;
; 982  : 
; 983  :     val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 984  :     if (val == NULL)
; 985  : 	return (NULL);
; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;
; 988  :     if (ns != NULL)
; 989  : 	val->value.qname.uri = (xmlChar *)ns;
; 990  :     return(val);
; 991  : }
; 992  : 
; 993  : /**
; 994  :  * xmlSchemaNewQNameValue:
; 995  :  * @namespaceName: the namespace name
; 996  :  * @localName: the local name
; 997  :  *
; 998  :  * Allocate a new QName value.
; 999  :  * The given values are consumed and freed with the struct.
; 1000 :  *
; 1001 :  * Returns a pointer to the new value or NULL in case of an error.
; 1002 :  */
; 1003 : xmlSchemaValPtr
; 1004 : xmlSchemaNewQNameValue(const xmlChar *namespaceName,
; 1005 : 		       const xmlChar *localName)
; 1006 : {
; 1007 :     xmlSchemaValPtr val;
; 1008 : 
; 1009 :     val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 1010 :     if (val == NULL)
; 1011 : 	return (NULL);
; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;
; 1014 :     val->value.qname.uri = (xmlChar *) namespaceName;
; 1015 :     return(val);
; 1016 : }
; 1017 : 
; 1018 : /**
; 1019 :  * xmlSchemaFreeValue:
; 1020 :  * @value:  the value to free
; 1021 :  *
; 1022 :  * Cleanup the default XML Schemas type library
; 1023 :  */
; 1024 : void
; 1025 : xmlSchemaFreeValue(xmlSchemaValPtr value) {
; 1026 :     xmlSchemaValPtr prev;
; 1027 : 
; 1028 :     while (value != NULL) {
; 1029 : 	switch (value->type) {
; 1030 : 	    case XML_SCHEMAS_STRING:
; 1031 : 	    case XML_SCHEMAS_NORMSTRING:
; 1032 : 	    case XML_SCHEMAS_TOKEN:
; 1033 : 	    case XML_SCHEMAS_LANGUAGE:
; 1034 : 	    case XML_SCHEMAS_NMTOKEN:
; 1035 : 	    case XML_SCHEMAS_NMTOKENS:
; 1036 : 	    case XML_SCHEMAS_NAME:
; 1037 : 	    case XML_SCHEMAS_NCNAME:
; 1038 : 	    case XML_SCHEMAS_ID:
; 1039 : 	    case XML_SCHEMAS_IDREF:
; 1040 : 	    case XML_SCHEMAS_IDREFS:
; 1041 : 	    case XML_SCHEMAS_ENTITY:
; 1042 : 	    case XML_SCHEMAS_ENTITIES:
; 1043 : 	    case XML_SCHEMAS_ANYURI:
; 1044 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1045 : 		if (value->value.str != NULL)
; 1046 : 		    xmlFree(value->value.str);
; 1047 : 		break;
; 1048 : 	    case XML_SCHEMAS_NOTATION:
; 1049 : 	    case XML_SCHEMAS_QNAME:
; 1050 : 		if (value->value.qname.uri != NULL)
; 1051 : 		    xmlFree(value->value.qname.uri);
; 1052 : 		if (value->value.qname.name != NULL)
; 1053 : 		    xmlFree(value->value.qname.name);
; 1054 : 		break;
; 1055 : 	    case XML_SCHEMAS_HEXBINARY:
; 1056 : 		if (value->value.hex.str != NULL)
; 1057 : 		    xmlFree(value->value.hex.str);
; 1058 : 		break;
; 1059 : 	    case XML_SCHEMAS_BASE64BINARY:
; 1060 : 		if (value->value.base64.str != NULL)
; 1061 : 		    xmlFree(value->value.base64.str);
; 1062 : 		break;
; 1063 : 	    default:
; 1064 : 		break;
; 1065 : 	}
; 1066 : 	prev = value;
; 1067 : 	value = value->next;
; 1068 : 	xmlFree(prev);
; 1069 :     }
; 1070 : }
; 1071 : 
; 1072 : /**
; 1073 :  * xmlSchemaGetPredefinedType:
; 1074 :  * @name: the type name
; 1075 :  * @ns:  the URI of the namespace usually "http://www.w3.org/2001/XMLSchema"
; 1076 :  *
; 1077 :  * Lookup a type in the default XML Schemas type library
; 1078 :  *
; 1079 :  * Returns the type if found, NULL otherwise
; 1080 :  */
; 1081 : xmlSchemaTypePtr
; 1082 : xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {
; 1083 :     if (xmlSchemaTypesInitialized == 0)
; 1084 : 	xmlSchemaInitTypes();
; 1085 :     if (name == NULL)
; 1086 : 	return(NULL);
; 1087 :     return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));
; 1088 : }
; 1089 : 
; 1090 : /**
; 1091 :  * xmlSchemaGetBuiltInListSimpleTypeItemType:
; 1092 :  * @type: the built-in simple type.
; 1093 :  *
; 1094 :  * Lookup function
; 1095 :  *
; 1096 :  * Returns the item type of @type as defined by the built-in datatype
; 1097 :  * hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.
; 1098 :  */
; 1099 : xmlSchemaTypePtr
; 1100 : xmlSchemaGetBuiltInListSimpleTypeItemType(xmlSchemaTypePtr type)
; 1101 : {
; 1102 :     if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))
; 1103 : 	return (NULL);
; 1104 :     switch (type->builtInType) {
; 1105 : 	case XML_SCHEMAS_NMTOKENS:
; 1106 : 	    return (xmlSchemaTypeNmtokenDef );
; 1107 : 	case XML_SCHEMAS_IDREFS:
; 1108 : 	    return (xmlSchemaTypeIdrefDef);
; 1109 : 	case XML_SCHEMAS_ENTITIES:
; 1110 : 	    return (xmlSchemaTypeEntityDef);
; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }
; 1115 : 
; 1116 : /****************************************************************
; 1117 :  *								*
; 1118 :  *		Convenience macros and functions		*
; 1119 :  *								*
; 1120 :  ****************************************************************/
; 1121 : 
; 1122 : #define IS_TZO_CHAR(c)						\
; 1123 : 	((c == 0) || (c == 'Z') || (c == '+') || (c == '-'))
; 1124 : 
; 1125 : #define VALID_YEAR(yr)          (yr != 0)
; 1126 : #define VALID_MONTH(mon)        ((mon >= 1) && (mon <= 12))
; 1127 : /* VALID_DAY should only be used when month is unknown */
; 1128 : #define VALID_DAY(day)          ((day >= 1) && (day <= 31))
; 1129 : #define VALID_HOUR(hr)          ((hr >= 0) && (hr <= 23))
; 1130 : #define VALID_MIN(min)          ((min >= 0) && (min <= 59))
; 1131 : #define VALID_SEC(sec)          ((sec >= 0) && (sec < 60))
; 1132 : #define VALID_TZO(tzo)          ((tzo > -840) && (tzo < 840))
; 1133 : #define IS_LEAP(y)						\
; 1134 : 	(((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
; 1135 : 
; 1136 : static const unsigned int daysInMonth[12] =
; 1137 : 	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1138 : static const unsigned int daysInMonthLeap[12] =
; 1139 : 	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
; 1140 : 
; 1141 : #define MAX_DAYINMONTH(yr,mon)                                  \
; 1142 :         (IS_LEAP(yr) ? daysInMonthLeap[mon - 1] : daysInMonth[mon - 1])
; 1143 : 
; 1144 : #define VALID_MDAY(dt)						\
; 1145 : 	(IS_LEAP(dt->year) ?				        \
; 1146 : 	    (dt->day <= daysInMonthLeap[dt->mon - 1]) :	        \
; 1147 : 	    (dt->day <= daysInMonth[dt->mon - 1]))
; 1148 : 
; 1149 : #define VALID_DATE(dt)						\
; 1150 : 	(VALID_YEAR(dt->year) && VALID_MONTH(dt->mon) && VALID_MDAY(dt))
; 1151 : 
; 1152 : #define VALID_END_OF_DAY(dt)					\
; 1153 : 	((dt)->hour == 24 && (dt)->min == 0 && (dt)->sec == 0)
; 1154 : 
; 1155 : #define VALID_TIME(dt)						\
; 1156 : 	(((VALID_HOUR(dt->hour) && VALID_MIN(dt->min) &&	\
; 1157 : 	  VALID_SEC(dt->sec)) || VALID_END_OF_DAY(dt)) &&	\
; 1158 : 	 VALID_TZO(dt->tzo))
; 1159 : 
; 1160 : #define VALID_DATETIME(dt)					\
; 1161 : 	(VALID_DATE(dt) && VALID_TIME(dt))
; 1162 : 
; 1163 : #define SECS_PER_MIN            (60)
; 1164 : #define SECS_PER_HOUR           (60 * SECS_PER_MIN)
; 1165 : #define SECS_PER_DAY            (24 * SECS_PER_HOUR)
; 1166 : 
; 1167 : static const long dayInYearByMonth[12] =
; 1168 : 	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
; 1169 : static const long dayInLeapYearByMonth[12] =
; 1170 : 	{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };
; 1171 : 
; 1172 : #define DAY_IN_YEAR(day, month, year)				\
; 1173 :         ((IS_LEAP(year) ?					\
; 1174 :                 dayInLeapYearByMonth[month - 1] :		\
; 1175 :                 dayInYearByMonth[month - 1]) + day)
; 1176 : 
; 1177 : #ifdef DEBUG
; 1178 : #define DEBUG_DATE(dt)                                                  \
; 1179 :     xmlGenericError(xmlGenericErrorContext,                             \
; 1180 :         "type=%o %04ld-%02u-%02uT%02u:%02u:%03f",                       \
; 1181 :         dt->type,dt->value.date.year,dt->value.date.mon,                \
; 1182 :         dt->value.date.day,dt->value.date.hour,dt->value.date.min,      \
; 1183 :         dt->value.date.sec);                                            \
; 1184 :     if (dt->value.date.tz_flag)                                         \
; 1185 :         if (dt->value.date.tzo != 0)                                    \
; 1186 :             xmlGenericError(xmlGenericErrorContext,                     \
; 1187 :                 "%+05d\n",dt->value.date.tzo);                          \
; 1188 :         else                                                            \
; 1189 :             xmlGenericError(xmlGenericErrorContext, "Z\n");             \
; 1190 :     else                                                                \
; 1191 :         xmlGenericError(xmlGenericErrorContext,"\n")
; 1192 : #else
; 1193 : #define DEBUG_DATE(dt)
; 1194 : #endif
; 1195 : 
; 1196 : /**
; 1197 :  * _xmlSchemaParseGYear:
; 1198 :  * @dt:  pointer to a date structure
; 1199 :  * @str: pointer to the string to analyze
; 1200 :  *
; 1201 :  * Parses a xs:gYear without time zone and fills in the appropriate
; 1202 :  * field of the @dt structure. @str is updated to point just after the
; 1203 :  * xs:gYear. It is supposed that @dt->year is big enough to contain
; 1204 :  * the year.
; 1205 :  *
; 1206 :  * Returns 0 or the error code
; 1207 :  */
; 1208 : static int
; 1209 : _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1210 :     const xmlChar *cur = *str, *firstChar;
; 1211 :     int isneg = 0, digcnt = 0;
; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))
; 1215 : 	return -1;
; 1216 : 
; 1217 :     if (*cur == '-') {
; 1218 : 	isneg = 1;
; 1219 : 	cur++;
; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;
; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {
; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');
; 1226 : 	cur++;
; 1227 : 	digcnt++;
; 1228 :     }
; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))
; 1233 : 	return 1;
; 1234 : 
; 1235 :     if (isneg)
; 1236 : 	dt->year = - dt->year;
; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))
; 1239 : 	return 2;
; 1240 : 
; 1241 :     *str = cur;
; 1242 :     return 0;
; 1243 : }
; 1244 : 
; 1245 : /**
; 1246 :  * PARSE_2_DIGITS:
; 1247 :  * @num:  the integer to fill in
; 1248 :  * @cur:  an #xmlChar *
; 1249 :  * @invalid: an integer
; 1250 :  *
; 1251 :  * Parses a 2-digits integer and updates @num with the value. @cur is
; 1252 :  * updated to point just after the integer.
; 1253 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1254 :  * @cur are undefined.
; 1255 :  */
; 1256 : #define PARSE_2_DIGITS(num, cur, invalid)			\
; 1257 : 	if ((cur[0] < '0') || (cur[0] > '9') ||			\
; 1258 : 	    (cur[1] < '0') || (cur[1] > '9'))			\
; 1259 : 	    invalid = 1;					\
; 1260 : 	else							\
; 1261 : 	    num = (cur[0] - '0') * 10 + (cur[1] - '0');		\
; 1262 : 	cur += 2;
; 1263 : 
; 1264 : /**
; 1265 :  * PARSE_FLOAT:
; 1266 :  * @num:  the double to fill in
; 1267 :  * @cur:  an #xmlChar *
; 1268 :  * @invalid: an integer
; 1269 :  *
; 1270 :  * Parses a float and updates @num with the value. @cur is
; 1271 :  * updated to point just after the float. The float must have a
; 1272 :  * 2-digits integer part and may or may not have a decimal part.
; 1273 :  * In case of error, @invalid is set to %TRUE, values of @num and
; 1274 :  * @cur are undefined.
; 1275 :  */
; 1276 : #define PARSE_FLOAT(num, cur, invalid)				\
; 1277 : 	PARSE_2_DIGITS(num, cur, invalid);			\
; 1278 : 	if (!invalid && (*cur == '.')) {			\
; 1279 : 	    double mult = 1;				        \
; 1280 : 	    cur++;						\
; 1281 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1282 : 		invalid = 1;					\
; 1283 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1284 : 		mult /= 10;					\
; 1285 : 		num += (*cur - '0') * mult;			\
; 1286 : 		cur++;						\
; 1287 : 	    }							\
; 1288 : 	}
; 1289 : 
; 1290 : /**
; 1291 :  * _xmlSchemaParseGMonth:
; 1292 :  * @dt:  pointer to a date structure
; 1293 :  * @str: pointer to the string to analyze
; 1294 :  *
; 1295 :  * Parses a xs:gMonth without time zone and fills in the appropriate
; 1296 :  * field of the @dt structure. @str is updated to point just after the
; 1297 :  * xs:gMonth.
; 1298 :  *
; 1299 :  * Returns 0 or the error code
; 1300 :  */
; 1301 : static int
; 1302 : _xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1303 :     const xmlChar *cur = *str;
; 1304 :     int ret = 0;
; 1305 :     unsigned int value = 0;
; 1306 : 
; 1307 :     PARSE_2_DIGITS(value, cur, ret);
; 1308 :     if (ret != 0)
; 1309 : 	return ret;
; 1310 : 
; 1311 :     if (!VALID_MONTH(value))
; 1312 : 	return 2;
; 1313 : 
; 1314 :     dt->mon = value;
; 1315 : 
; 1316 :     *str = cur;
; 1317 :     return 0;
; 1318 : }
; 1319 : 
; 1320 : /**
; 1321 :  * _xmlSchemaParseGDay:
; 1322 :  * @dt:  pointer to a date structure
; 1323 :  * @str: pointer to the string to analyze
; 1324 :  *
; 1325 :  * Parses a xs:gDay without time zone and fills in the appropriate
; 1326 :  * field of the @dt structure. @str is updated to point just after the
; 1327 :  * xs:gDay.
; 1328 :  *
; 1329 :  * Returns 0 or the error code
; 1330 :  */
; 1331 : static int
; 1332 : _xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1333 :     const xmlChar *cur = *str;
; 1334 :     int ret = 0;
; 1335 :     unsigned int value = 0;
; 1336 : 
; 1337 :     PARSE_2_DIGITS(value, cur, ret);
; 1338 :     if (ret != 0)
; 1339 : 	return ret;
; 1340 : 
; 1341 :     if (!VALID_DAY(value))
; 1342 : 	return 2;
; 1343 : 
; 1344 :     dt->day = value;
; 1345 :     *str = cur;
; 1346 :     return 0;
; 1347 : }
; 1348 : 
; 1349 : /**
; 1350 :  * _xmlSchemaParseTime:
; 1351 :  * @dt:  pointer to a date structure
; 1352 :  * @str: pointer to the string to analyze
; 1353 :  *
; 1354 :  * Parses a xs:time without time zone and fills in the appropriate
; 1355 :  * fields of the @dt structure. @str is updated to point just after the
; 1356 :  * xs:time.
; 1357 :  * In case of error, values of @dt fields are undefined.
; 1358 :  *
; 1359 :  * Returns 0 or the error code
; 1360 :  */
; 1361 : static int
; 1362 : _xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1363 :     const xmlChar *cur = *str;
; 1364 :     int ret = 0;
; 1365 :     int value = 0;
; 1366 : 
; 1367 :     PARSE_2_DIGITS(value, cur, ret);
; 1368 :     if (ret != 0)
; 1369 : 	return ret;
; 1370 :     if (*cur != ':')
; 1371 : 	return 1;
; 1372 :     if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)
; 1373 : 	return 2;
; 1374 :     cur++;
; 1375 : 
; 1376 :     /* the ':' insures this string is xs:time */
; 1377 :     dt->hour = value;
; 1378 : 
; 1379 :     PARSE_2_DIGITS(value, cur, ret);
; 1380 :     if (ret != 0)
; 1381 : 	return ret;
; 1382 :     if (!VALID_MIN(value))
; 1383 : 	return 2;
; 1384 :     dt->min = value;
; 1385 : 
; 1386 :     if (*cur != ':')
; 1387 : 	return 1;
; 1388 :     cur++;
; 1389 : 
; 1390 :     PARSE_FLOAT(dt->sec, cur, ret);
; 1391 :     if (ret != 0)
; 1392 : 	return ret;
; 1393 : 
; 1394 :     if (!VALID_TIME(dt))
; 1395 : 	return 2;
; 1396 : 
; 1397 :     *str = cur;
; 1398 :     return 0;
; 1399 : }
; 1400 : 
; 1401 : /**
; 1402 :  * _xmlSchemaParseTimeZone:
; 1403 :  * @dt:  pointer to a date structure
; 1404 :  * @str: pointer to the string to analyze
; 1405 :  *
; 1406 :  * Parses a time zone without time zone and fills in the appropriate
; 1407 :  * field of the @dt structure. @str is updated to point just after the
; 1408 :  * time zone.
; 1409 :  *
; 1410 :  * Returns 0 or the error code
; 1411 :  */
; 1412 : static int
; 1413 : _xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {
; 1414 :     const xmlChar *cur;
; 1415 :     int ret = 0;
; 1416 : 
; 1417 :     if (str == NULL)
; 1418 : 	return -1;
; 1419 :     cur = *str;
; 1420 : 
; 1421 :     switch (*cur) {
; 1422 :     case 0:
; 1423 : 	dt->tz_flag = 0;
; 1424 : 	dt->tzo = 0;
; 1425 : 	break;
; 1426 : 
; 1427 :     case 'Z':
; 1428 : 	dt->tz_flag = 1;
; 1429 : 	dt->tzo = 0;
; 1430 : 	cur++;
; 1431 : 	break;
; 1432 : 
; 1433 :     case '+':
; 1434 :     case '-': {
; 1435 : 	int isneg = 0, tmp = 0;
; 1436 : 	isneg = (*cur == '-');
; 1437 : 
; 1438 : 	cur++;
; 1439 : 
; 1440 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1441 : 	if (ret != 0)
; 1442 : 	    return ret;
; 1443 : 	if (!VALID_HOUR(tmp))
; 1444 : 	    return 2;
; 1445 : 
; 1446 : 	if (*cur != ':')
; 1447 : 	    return 1;
; 1448 : 	cur++;
; 1449 : 
; 1450 : 	dt->tzo = tmp * 60;
; 1451 : 
; 1452 : 	PARSE_2_DIGITS(tmp, cur, ret);
; 1453 : 	if (ret != 0)
; 1454 : 	    return ret;
; 1455 : 	if (!VALID_MIN(tmp))
; 1456 : 	    return 2;
; 1457 : 
; 1458 : 	dt->tzo += tmp;
; 1459 : 	if (isneg)
; 1460 : 	    dt->tzo = - dt->tzo;
; 1461 : 
; 1462 : 	if (!VALID_TZO(dt->tzo))
; 1463 : 	    return 2;
; 1464 : 
; 1465 : 	dt->tz_flag = 1;
; 1466 : 	break;
; 1467 :       }
; 1468 :     default:
; 1469 : 	return 1;
; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;
; 1473 :     return 0;
; 1474 : }
; 1475 : 
; 1476 : /**
; 1477 :  * _xmlSchemaBase64Decode:
; 1478 :  * @ch: a character
; 1479 :  *
; 1480 :  * Converts a base64 encoded character to its base 64 value.
; 1481 :  *
; 1482 :  * Returns 0-63 (value), 64 (pad), or -1 (not recognized)
; 1483 :  */
; 1484 : static int
; 1485 : _xmlSchemaBase64Decode (const xmlChar ch) {
; 1486 :     if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';
; 1487 :     if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;
; 1488 :     if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;
; 1489 :     if ('+' == ch) return 62;
; 1490 :     if ('/' == ch) return 63;
; 1491 :     if ('=' == ch) return 64;
; 1492 :     return -1;
; 1493 : }
; 1494 : 
; 1495 : /****************************************************************
; 1496 :  *								*
; 1497 :  *	XML Schema Dates/Times Datatypes Handling		*
; 1498 :  *								*
; 1499 :  ****************************************************************/
; 1500 : 
; 1501 : /**
; 1502 :  * PARSE_DIGITS:
; 1503 :  * @num:  the integer to fill in
; 1504 :  * @cur:  an #xmlChar *
; 1505 :  * @num_type: an integer flag
; 1506 :  *
; 1507 :  * Parses a digits integer and updates @num with the value. @cur is
; 1508 :  * updated to point just after the integer.
; 1509 :  * In case of error, @num_type is set to -1, values of @num and
; 1510 :  * @cur are undefined.
; 1511 :  */
; 1512 : #define PARSE_DIGITS(num, cur, num_type)	                \
; 1513 : 	if ((*cur < '0') || (*cur > '9'))			\
; 1514 : 	    num_type = -1;					\
; 1515 :         else                                                    \
; 1516 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1517 : 	        num = num * 10 + (*cur - '0');		        \
; 1518 : 	        cur++;                                          \
; 1519 :             }
; 1520 : 
; 1521 : /**
; 1522 :  * PARSE_NUM:
; 1523 :  * @num:  the double to fill in
; 1524 :  * @cur:  an #xmlChar *
; 1525 :  * @num_type: an integer flag
; 1526 :  *
; 1527 :  * Parses a float or integer and updates @num with the value. @cur is
; 1528 :  * updated to point just after the number. If the number is a float,
; 1529 :  * then it must have an integer part and a decimal part; @num_type will
; 1530 :  * be set to 1. If there is no decimal part, @num_type is set to zero.
; 1531 :  * In case of error, @num_type is set to -1, values of @num and
; 1532 :  * @cur are undefined.
; 1533 :  */
; 1534 : #define PARSE_NUM(num, cur, num_type)				\
; 1535 :         num = 0;                                                \
; 1536 : 	PARSE_DIGITS(num, cur, num_type);	                \
; 1537 : 	if (!num_type && (*cur == '.')) {			\
; 1538 : 	    double mult = 1;				        \
; 1539 : 	    cur++;						\
; 1540 : 	    if ((*cur < '0') || (*cur > '9'))			\
; 1541 : 		num_type = -1;					\
; 1542 :             else                                                \
; 1543 :                 num_type = 1;                                   \
; 1544 : 	    while ((*cur >= '0') && (*cur <= '9')) {		\
; 1545 : 		mult /= 10;					\
; 1546 : 		num += (*cur - '0') * mult;			\
; 1547 : 		cur++;						\
; 1548 : 	    }							\
; 1549 : 	}
; 1550 : 
; 1551 : /**
; 1552 :  * xmlSchemaValidateDates:
; 1553 :  * @type: the expected type or XML_SCHEMAS_UNKNOWN
; 1554 :  * @dateTime:  string to analyze
; 1555 :  * @val:  the return computed value
; 1556 :  *
; 1557 :  * Check that @dateTime conforms to the lexical space of one of the date types.
; 1558 :  * if true a value is computed and returned in @val.
; 1559 :  *
; 1560 :  * Returns 0 if this validates, a positive error code number otherwise
; 1561 :  *         and -1 in case of internal or API error.
; 1562 :  */
; 1563 : static int
; 1564 : xmlSchemaValidateDates (xmlSchemaValType type,
; 1565 : 	                const xmlChar *dateTime, xmlSchemaValPtr *val,
; 1566 : 			int collapse) {
; 1567 :     xmlSchemaValPtr dt;
; 1568 :     int ret;
; 1569 :     const xmlChar *cur = dateTime;
; 1570 : 
; 1571 : #define RETURN_TYPE_IF_VALID(t)					\
; 1572 :     if (IS_TZO_CHAR(*cur)) {					\
; 1573 : 	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
; 1574 : 	if (ret == 0) {						\
; 1575 : 	    if (*cur != 0)					\
; 1576 : 		goto error;					\
; 1577 : 	    dt->type = t;					\
; 1578 : 	    goto done;						\
; 1579 : 	}							\
; 1580 :     }
; 1581 : 
; 1582 :     if (dateTime == NULL)
; 1583 : 	return -1;
; 1584 : 
; 1585 :     if (collapse)
; 1586 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1587 : 
; 1588 :     if ((*cur != '-') && (*cur < '0') && (*cur > '9'))
; 1589 : 	return 1;
; 1590 : 
; 1591 :     dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);
; 1592 :     if (dt == NULL)
; 1593 : 	return -1;
; 1594 : 
; 1595 :     if ((cur[0] == '-') && (cur[1] == '-')) {
; 1596 : 	/*
; 1597 : 	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
; 1598 : 	 * xs:gDay)
; 1599 : 	 */
; 1600 : 	cur += 2;
; 1601 : 
; 1602 : 	/* is it an xs:gDay? */
; 1603 : 	if (*cur == '-') {
; 1604 : 	    if (type == XML_SCHEMAS_GMONTH)
; 1605 : 		goto error;
; 1606 : 	  ++cur;
; 1607 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1608 : 	    if (ret != 0)
; 1609 : 		goto error;
; 1610 : 
; 1611 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);
; 1612 : 
; 1613 : 	    goto error;
; 1614 : 	}
; 1615 : 
; 1616 : 	/*
; 1617 : 	 * it should be an xs:gMonthDay or xs:gMonth
; 1618 : 	 */
; 1619 : 	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1620 : 	if (ret != 0)
; 1621 : 	    goto error;
; 1622 : 
; 1623 :         /*
; 1624 :          * a '-' char could indicate this type is xs:gMonthDay or
; 1625 :          * a negative time zone offset. Check for xs:gMonthDay first.
; 1626 :          * Also the first three char's of a negative tzo (-MM:SS) can
; 1627 :          * appear to be a valid day; so even if the day portion
; 1628 :          * of the xs:gMonthDay verifies, we must insure it was not
; 1629 :          * a tzo.
; 1630 :          */
; 1631 :         if (*cur == '-') {
; 1632 :             const xmlChar *rewnd = cur;
; 1633 :             cur++;
; 1634 : 
; 1635 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1636 :             if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {
; 1637 : 
; 1638 :                 /*
; 1639 :                  * we can use the VALID_MDAY macro to validate the month
; 1640 :                  * and day because the leap year test will flag year zero
; 1641 :                  * as a leap year (even though zero is an invalid year).
; 1642 : 		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
; 1643 : 		 * probably.
; 1644 :                  */
; 1645 :                 if (VALID_MDAY((&(dt->value.date)))) {
; 1646 : 
; 1647 : 	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);
; 1648 : 
; 1649 :                     goto error;
; 1650 :                 }
; 1651 :             }
; 1652 : 
; 1653 :             /*
; 1654 :              * not xs:gMonthDay so rewind and check if just xs:gMonth
; 1655 :              * with an optional time zone.
; 1656 :              */
; 1657 :             cur = rewnd;
; 1658 :         }
; 1659 : 
; 1660 : 	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);
; 1661 : 
; 1662 : 	goto error;
; 1663 :     }
; 1664 : 
; 1665 :     /*
; 1666 :      * It's a right-truncated date or an xs:time.
; 1667 :      * Try to parse an xs:time then fallback on right-truncated dates.
; 1668 :      */
; 1669 :     if ((*cur >= '0') && (*cur <= '9')) {
; 1670 : 	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1671 : 	if (ret == 0) {
; 1672 : 	    /* it's an xs:time */
; 1673 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);
; 1674 : 	}
; 1675 :     }
; 1676 : 
; 1677 :     /* fallback on date parsing */
; 1678 :     cur = dateTime;
; 1679 : 
; 1680 :     ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);
; 1681 :     if (ret != 0)
; 1682 : 	goto error;
; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);
; 1686 : 
; 1687 :     if (*cur != '-')
; 1688 : 	goto error;
; 1689 :     cur++;
; 1690 : 
; 1691 :     ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);
; 1692 :     if (ret != 0)
; 1693 : 	goto error;
; 1694 : 
; 1695 :     /* is it an xs:gYearMonth? */
; 1696 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);
; 1697 : 
; 1698 :     if (*cur != '-')
; 1699 : 	goto error;
; 1700 :     cur++;
; 1701 : 
; 1702 :     ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);
; 1703 :     if ((ret != 0) || !VALID_DATE((&(dt->value.date))))
; 1704 : 	goto error;
; 1705 : 
; 1706 :     /* is it an xs:date? */
; 1707 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);
; 1708 : 
; 1709 :     if (*cur != 'T')
; 1710 : 	goto error;
; 1711 :     cur++;
; 1712 : 
; 1713 :     /* it should be an xs:dateTime */
; 1714 :     ret = _xmlSchemaParseTime(&(dt->value.date), &cur);
; 1715 :     if (ret != 0)
; 1716 : 	goto error;
; 1717 : 
; 1718 :     ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);
; 1719 :     if (collapse)
; 1720 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1721 :     if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))
; 1722 : 	goto error;
; 1723 : 
; 1724 : 
; 1725 :     dt->type = XML_SCHEMAS_DATETIME;
; 1726 : 
; 1727 : done:
; 1728 : #if 1
; 1729 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))
; 1730 :         goto error;
; 1731 : #else
; 1732 :     /*
; 1733 :      * insure the parsed type is equal to or less significant (right
; 1734 :      * truncated) than the desired type.
; 1735 :      */
; 1736 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
; 1737 : 
; 1738 :         /* time only matches time */
; 1739 :         if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
; 1740 :             goto error;
; 1741 : 
; 1742 :         if ((type == XML_SCHEMAS_DATETIME) &&
; 1743 :             ((dt->type != XML_SCHEMAS_DATE) ||
; 1744 :              (dt->type != XML_SCHEMAS_GYEARMONTH) ||
; 1745 :              (dt->type != XML_SCHEMAS_GYEAR)))
; 1746 :             goto error;
; 1747 : 
; 1748 :         if ((type == XML_SCHEMAS_DATE) &&
; 1749 :             ((dt->type != XML_SCHEMAS_GYEAR) ||
; 1750 :              (dt->type != XML_SCHEMAS_GYEARMONTH)))
; 1751 :             goto error;
; 1752 : 
; 1753 :         if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
; 1754 :             goto error;
; 1755 : 
; 1756 :         if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
; 1757 :             goto error;
; 1758 :     }
; 1759 : #endif
; 1760 : 
; 1761 :     if (val != NULL)
; 1762 :         *val = dt;
; 1763 :     else
; 1764 : 	xmlSchemaFreeValue(dt);
; 1765 : 
; 1766 :     return 0;
; 1767 : 
; 1768 : error:
; 1769 :     if (dt != NULL)
; 1770 : 	xmlSchemaFreeValue(dt);
; 1771 :     return 1;
; 1772 : }
; 1773 : 
; 1774 : /**
; 1775 :  * xmlSchemaValidateDuration:
; 1776 :  * @type: the predefined type
; 1777 :  * @duration:  string to analyze
; 1778 :  * @val:  the return computed value
; 1779 :  *
; 1780 :  * Check that @duration conforms to the lexical space of the duration type.
; 1781 :  * if true a value is computed and returned in @val.
; 1782 :  *
; 1783 :  * Returns 0 if this validates, a positive error code number otherwise
; 1784 :  *         and -1 in case of internal or API error.
; 1785 :  */
; 1786 : static int
; 1787 : xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
; 1788 : 	                   const xmlChar *duration, xmlSchemaValPtr *val,
; 1789 : 			   int collapse) {
; 1790 :     const xmlChar  *cur = duration;
; 1791 :     xmlSchemaValPtr dur;
; 1792 :     int isneg = 0;
; 1793 :     unsigned int seq = 0;
; 1794 :     double         num;
; 1795 :     int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */
; 1796 :     const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};
; 1797 :     const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};
; 1798 : 
; 1799 :     if (duration == NULL)
; 1800 : 	return -1;
; 1801 : 
; 1802 :     if (collapse)
; 1803 : 	while IS_WSP_BLANK_CH(*cur) cur++;
; 1804 : 
; 1805 :     if (*cur == '-') {
; 1806 :         isneg = 1;
; 1807 :         cur++;
; 1808 :     }
; 1809 : 
; 1810 :     /* duration must start with 'P' (after sign) */
; 1811 :     if (*cur++ != 'P')
; 1812 : 	return 1;
; 1813 : 
; 1814 :     if (*cur == 0)
; 1815 : 	return 1;
; 1816 : 
; 1817 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);
; 1818 :     if (dur == NULL)
; 1819 : 	return -1;
; 1820 : 
; 1821 :     while (*cur != 0) {
; 1822 : 
; 1823 :         /* input string should be empty or invalid date/time item */
; 1824 :         if (seq >= sizeof(desig))
; 1825 :             goto error;
; 1826 : 
; 1827 :         /* T designator must be present for time items */
; 1828 :         if (*cur == 'T') {
; 1829 :             if (seq <= 3) {
; 1830 :                 seq = 3;
; 1831 :                 cur++;
; 1832 :             } else
; 1833 :                 return 1;
; 1834 :         } else if (seq == 3)
; 1835 :             goto error;
; 1836 : 
; 1837 :         /* parse the number portion of the item */
; 1838 :         PARSE_NUM(num, cur, num_type);
; 1839 : 
; 1840 :         if ((num_type == -1) || (*cur == 0))
; 1841 :             goto error;
; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {
; 1845 :             if (*cur == desig[seq]) {
; 1846 : 
; 1847 :                 /* verify numeric type; only seconds can be float */
; 1848 :                 if ((num_type != 0) && (seq < (sizeof(desig)-1)))
; 1849 :                     goto error;
; 1850 : 
; 1851 :                 switch (seq) {
; 1852 :                     case 0:
; 1853 :                         dur->value.dur.mon = (long)num * 12;
; 1854 :                         break;
; 1855 :                     case 1:
; 1856 :                         dur->value.dur.mon += (long)num;
; 1857 :                         break;
; 1858 :                     default:
; 1859 :                         /* convert to seconds using multiplier */
; 1860 :                         dur->value.dur.sec += num * multi[seq];
; 1861 :                         seq++;
; 1862 :                         break;
; 1863 :                 }
; 1864 : 
; 1865 :                 break;          /* exit loop */
; 1866 :             }
; 1867 :             /* no date designators found? */
; 1868 :             if ((++seq == 3) || (seq == 6))
; 1869 :                 goto error;
; 1870 :         }
; 1871 : 	cur++;
; 1872 : 	if (collapse)
; 1873 : 	    while IS_WSP_BLANK_CH(*cur) cur++;
; 1874 :     }
; 1875 : 
; 1876 :     if (isneg) {
; 1877 :         dur->value.dur.mon = -dur->value.dur.mon;
; 1878 :         dur->value.dur.day = -dur->value.dur.day;
; 1879 :         dur->value.dur.sec = -dur->value.dur.sec;
; 1880 :     }
; 1881 : 
; 1882 :     if (val != NULL)
; 1883 :         *val = dur;
; 1884 :     else
; 1885 : 	xmlSchemaFreeValue(dur);
; 1886 : 
; 1887 :     return 0;
; 1888 : 
; 1889 : error:
; 1890 :     if (dur != NULL)
; 1891 : 	xmlSchemaFreeValue(dur);
; 1892 :     return 1;
; 1893 : }
; 1894 : 
; 1895 : /**
; 1896 :  * xmlSchemaStrip:
; 1897 :  * @value: a value
; 1898 :  *
; 1899 :  * Removes the leading and ending spaces of a string
; 1900 :  *
; 1901 :  * Returns the new string or NULL if no change was required.
; 1902 :  */
; 1903 : static xmlChar *
; 1904 : xmlSchemaStrip(const xmlChar *value) {
; 1905 :     const xmlChar *start = value, *end, *f;
; 1906 : 
; 1907 :     if (value == NULL) return(NULL);
; 1908 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1909 :     end = start;
; 1910 :     while (*end != 0) end++;
; 1911 :     f = end;
; 1912 :     end--;
; 1913 :     while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1914 :     end++;
; 1915 :     if ((start == value) && (f == end)) return(NULL);
; 1916 :     return(xmlStrndup(start, end - start));
; 1917 : }
; 1918 : 
; 1919 : /**
; 1920 :  * xmlSchemaWhiteSpaceReplace:
; 1921 :  * @value: a value
; 1922 :  *
; 1923 :  * Replaces 0xd, 0x9 and 0xa with a space.
; 1924 :  *
; 1925 :  * Returns the new string or NULL if no change was required.
; 1926 :  */
; 1927 : xmlChar *
; 1928 : xmlSchemaWhiteSpaceReplace(const xmlChar *value) {
; 1929 :     const xmlChar *cur = value;
; 1930 :     xmlChar *ret = NULL, *mcur;
; 1931 : 
; 1932 :     if (value == NULL)
; 1933 : 	return(NULL);
; 1934 : 
; 1935 :     while ((*cur != 0) &&
; 1936 : 	(((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {
; 1937 : 	cur++;
; 1938 :     }
; 1939 :     if (*cur == 0)
; 1940 : 	return (NULL);
; 1941 :     ret = xmlStrdup(value);
; 1942 :     /* TODO FIXME: I guess gcc will bark at this. */
; 1943 :     mcur = (xmlChar *)  (ret + (cur - value));
; 1944 :     do {
; 1945 : 	if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )
; 1946 : 	    *mcur = ' ';
; 1947 : 	mcur++;
; 1948 :     } while (*mcur != 0);
; 1949 :     return(ret);
; 1950 : }
; 1951 : 
; 1952 : /**
; 1953 :  * xmlSchemaCollapseString:
; 1954 :  * @value: a value
; 1955 :  *
; 1956 :  * Removes and normalize white spaces in the string
; 1957 :  *
; 1958 :  * Returns the new string or NULL if no change was required.
; 1959 :  */
; 1960 : xmlChar *
; 1961 : xmlSchemaCollapseString(const xmlChar *value) {
; 1962 :     const xmlChar *start = value, *end, *f;
; 1963 :     xmlChar *g;
; 1964 :     int col = 0;
; 1965 : 
; 1966 :     if (value == NULL) return(NULL);
; 1967 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;
; 1968 :     end = start;
; 1969 :     while (*end != 0) {
; 1970 : 	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {
; 1971 : 	    col = end - start;
; 1972 : 	    break;
; 1973 : 	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {
; 1974 : 	    col = end - start;
; 1975 : 	    break;
; 1976 : 	}
; 1977 : 	end++;
; 1978 :     }
; 1979 :     if (col == 0) {
; 1980 : 	f = end;
; 1981 : 	end--;
; 1982 : 	while ((end > start) && (IS_BLANK_CH(*end))) end--;
; 1983 : 	end++;
; 1984 : 	if ((start == value) && (f == end)) return(NULL);
; 1985 : 	return(xmlStrndup(start, end - start));
; 1986 :     }
; 1987 :     start = xmlStrdup(start);
; 1988 :     if (start == NULL) return(NULL);
; 1989 :     g = (xmlChar *) (start + col);
; 1990 :     end = g;
; 1991 :     while (*end != 0) {
; 1992 : 	if (IS_BLANK_CH(*end)) {
; 1993 : 	    end++;
; 1994 : 	    while (IS_BLANK_CH(*end)) end++;
; 1995 : 	    if (*end != 0)
; 1996 : 		*g++ = ' ';
; 1997 : 	} else
; 1998 : 	    *g++ = *end++;
; 1999 :     }
; 2000 :     *g = 0;
; 2001 :     return((xmlChar *) start);
; 2002 : }
; 2003 : 
; 2004 : /**
; 2005 :  * xmlSchemaValAtomicListNode:
; 2006 :  * @type: the predefined atomic type for a token in the list
; 2007 :  * @value: the list value to check
; 2008 :  * @ret:  the return computed value
; 2009 :  * @node:  the node containing the value
; 2010 :  *
; 2011 :  * Check that a value conforms to the lexical space of the predefined
; 2012 :  * list type. if true a value is computed and returned in @ret.
; 2013 :  *
; 2014 :  * Returns the number of items if this validates, a negative error code
; 2015 :  *         number otherwise
; 2016 :  */
; 2017 : static int
; 2018 : xmlSchemaValAtomicListNode(xmlSchemaTypePtr type, const xmlChar *value,
; 2019 : 	                   xmlSchemaValPtr *ret, xmlNodePtr node) {
; 2020 :     xmlChar *val, *cur, *endval;
; 2021 :     int nb_values = 0;
; 2022 :     int tmp = 0;
; 2023 : 
; 2024 :     if (value == NULL) {
; 2025 : 	return(-1);
; 2026 :     }
; 2027 :     val = xmlStrdup(value);
; 2028 :     if (val == NULL) {
; 2029 : 	return(-1);
; 2030 :     }
; 2031 :     if (ret != NULL) {
; 2032 :         *ret = NULL;
; 2033 :     }
; 2034 :     cur = val;
; 2035 :     /*
; 2036 :      * Split the list
; 2037 :      */
; 2038 :     while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2039 :     while (*cur != 0) {
; 2040 : 	if (IS_BLANK_CH(*cur)) {
; 2041 : 	    *cur = 0;
; 2042 : 	    cur++;
; 2043 : 	    while (IS_BLANK_CH(*cur)) *cur++ = 0;
; 2044 : 	} else {
; 2045 : 	    nb_values++;
; 2046 : 	    cur++;
; 2047 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;
; 2048 : 	}
; 2049 :     }
; 2050 :     if (nb_values == 0) {
; 2051 : 	xmlFree(val);
; 2052 : 	return(nb_values);
; 2053 :     }
; 2054 :     endval = cur;
; 2055 :     cur = val;
; 2056 :     while ((*cur == 0) && (cur != endval)) cur++;
; 2057 :     while (cur != endval) {
; 2058 : 	tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);
; 2059 : 	if (tmp != 0)
; 2060 : 	    break;
; 2061 : 	while (*cur != 0) cur++;
; 2062 : 	while ((*cur == 0) && (cur != endval)) cur++;
; 2063 :     }
; 2064 :     /* TODO what return value ? c.f. bug #158628
; 2065 :     if (ret != NULL) {
; 2066 : 	TODO
; 2067 :     } */
; 2068 :     xmlFree(val);
; 2069 :     if (tmp == 0)
; 2070 : 	return(nb_values);
; 2071 :     return(-1);
; 2072 : }
; 2073 : 
; 2074 : /**
; 2075 :  * xmlSchemaParseUInt:
; 2076 :  * @str: pointer to the string R/W
; 2077 :  * @llo: pointer to the low result
; 2078 :  * @lmi: pointer to the mid result
; 2079 :  * @lhi: pointer to the high result
; 2080 :  *
; 2081 :  * Parse an unsigned long into 3 fields.
; 2082 :  *
; 2083 :  * Returns the number of significant digits in the number or
; 2084 :  * -1 if overflow of the capacity and -2 if it's not a number.
; 2085 :  */
; 2086 : static int
; 2087 : xmlSchemaParseUInt(const xmlChar **str, unsigned long *llo,
; 2088 :                    unsigned long *lmi, unsigned long *lhi) {
; 2089 :     unsigned long lo = 0, mi = 0, hi = 0;
; 2090 :     const xmlChar *tmp, *cur = *str;
; 2091 :     int ret = 0, i = 0;
; 2092 : 
; 2093 :     if (!((*cur >= '0') && (*cur <= '9')))
; 2094 :         return(-2);
; 2095 : 
; 2096 :     while (*cur == '0') {        /* ignore leading zeroes */
; 2097 :         cur++;
; 2098 :     }
; 2099 :     tmp = cur;
; 2100 :     while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {
; 2101 :         i++;tmp++;ret++;
; 2102 :     }
; 2103 :     if (i > 24) {
; 2104 :         *str = tmp;
; 2105 :         return(-1);
; 2106 :     }
; 2107 :     while (i > 16) {
; 2108 :         hi = hi * 10 + (*cur++ - '0');
; 2109 :         i--;
; 2110 :     }
; 2111 :     while (i > 8) {
; 2112 :         mi = mi * 10 + (*cur++ - '0');
; 2113 :         i--;
; 2114 :     }
; 2115 :     while (i > 0) {
; 2116 :         lo = lo * 10 + (*cur++ - '0');
; 2117 :         i--;
; 2118 :     }
; 2119 : 
; 2120 :     *str = cur;
; 2121 :     *llo = lo;
; 2122 :     *lmi = mi;
; 2123 :     *lhi = hi;
; 2124 :     return(ret);
; 2125 : }
; 2126 : 
; 2127 : /**
; 2128 :  * xmlSchemaValAtomicType:
; 2129 :  * @type: the predefined type
; 2130 :  * @value: the value to check
; 2131 :  * @val:  the return computed value
; 2132 :  * @node:  the node containing the value
; 2133 :  * flags:  flags to control the vlidation
; 2134 :  *
; 2135 :  * Check that a value conforms to the lexical space of the atomic type.
; 2136 :  * if true a value is computed and returned in @val.
; 2137 :  * This checks the value space for list types as well (IDREFS, NMTOKENS).
; 2138 :  *
; 2139 :  * Returns 0 if this validates, a positive error code number otherwise
; 2140 :  *         and -1 in case of internal or API error.
; 2141 :  */
; 2142 : static int
; 2143 : xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
; 2144 :                        xmlSchemaValPtr * val, xmlNodePtr node, int flags,
; 2145 : 		       xmlSchemaWhitespaceValueType ws,
; 2146 : 		       int normOnTheFly, int applyNorm, int createStringValue)
; 2147 : {
; 2148 :     xmlSchemaValPtr v;
; 2149 :     xmlChar *norm = NULL;
; 2150 :     int ret = 0;
; 2151 : 
; 2152 :     if (xmlSchemaTypesInitialized == 0)
; 2153 :         xmlSchemaInitTypes();
; 2154 :     if (type == NULL)
; 2155 :         return (-1);
; 2156 : 
; 2157 :     /*
; 2158 :      * validating a non existant text node is similar to validating
; 2159 :      * an empty one.
; 2160 :      */
; 2161 :     if (value == NULL)
; 2162 :         value = BAD_CAST "";
; 2163 : 
; 2164 :     if (val != NULL)
; 2165 :         *val = NULL;
; 2166 :     if ((flags == 0) && (value != NULL)) {
; 2167 : 
; 2168 :         if ((type->builtInType != XML_SCHEMAS_STRING) &&
; 2169 : 	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&
; 2170 : 	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
; 2171 : 	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)
; 2172 : 		norm = xmlSchemaWhiteSpaceReplace(value);
; 2173 :             else
; 2174 : 		norm = xmlSchemaCollapseString(value);
; 2175 :             if (norm != NULL)
; 2176 :                 value = norm;
; 2177 :         }
; 2178 :     }
; 2179 : 
; 2180 :     switch (type->builtInType) {
; 2181 :         case XML_SCHEMAS_UNKNOWN:
; 2182 :             goto error;
; 2183 : 	case XML_SCHEMAS_ANYTYPE:
; 2184 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 2185 : 	    if ((createStringValue) && (val != NULL)) {
; 2186 : 		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);
; 2187 : 		if (v != NULL) {
; 2188 : 		    v->value.str = xmlStrdup(value);
; 2189 : 		    *val = v;
; 2190 : 		} else {
; 2191 : 		    goto error;
; 2192 : 		}
; 2193 : 	    }
; 2194 : 	    goto return0;
; 2195 :         case XML_SCHEMAS_STRING:
; 2196 : 	    if (! normOnTheFly) {
; 2197 : 		const xmlChar *cur = value;
; 2198 : 
; 2199 : 		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {
; 2200 : 		    while (*cur != 0) {
; 2201 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2202 : 			    goto return1;
; 2203 : 			} else {
; 2204 : 			    cur++;
; 2205 : 			}
; 2206 : 		    }
; 2207 : 		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {
; 2208 : 		    while (*cur != 0) {
; 2209 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2210 : 			    goto return1;
; 2211 : 			} else if IS_WSP_SPACE_CH(*cur) {
; 2212 : 			    cur++;
; 2213 : 			    if IS_WSP_SPACE_CH(*cur)
; 2214 : 				goto return1;
; 2215 : 			} else {
; 2216 : 			    cur++;
; 2217 : 			}
; 2218 : 		    }
; 2219 : 		}
; 2220 : 	    }
; 2221 : 	    if (createStringValue && (val != NULL)) {
; 2222 : 		if (applyNorm) {
; 2223 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2224 : 			norm = xmlSchemaCollapseString(value);
; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)
; 2226 : 			norm = xmlSchemaWhiteSpaceReplace(value);
; 2227 : 		    if (norm != NULL)
; 2228 : 			value = norm;
; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);
; 2231 : 		if (v != NULL) {
; 2232 : 		    v->value.str = xmlStrdup(value);
; 2233 : 		    *val = v;
; 2234 : 		} else {
; 2235 : 		    goto error;
; 2236 : 		}
; 2237 : 	    }
; 2238 :             goto return0;
; 2239 :         case XML_SCHEMAS_NORMSTRING:{
; 2240 : 		if (normOnTheFly) {
; 2241 : 		    if (applyNorm) {
; 2242 : 			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)
; 2243 : 			    norm = xmlSchemaCollapseString(value);
; 2244 : 			else
; 2245 : 			    norm = xmlSchemaWhiteSpaceReplace(value);
; 2246 : 			if (norm != NULL)
; 2247 : 			    value = norm;
; 2248 : 		    }
; 2249 : 		} else {
; 2250 : 		    const xmlChar *cur = value;
; 2251 : 		    while (*cur != 0) {
; 2252 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2253 : 			    goto return1;
; 2254 : 			} else {
; 2255 : 			    cur++;
; 2256 : 			}
; 2257 : 		    }
; 2258 : 		}
; 2259 :                 if (val != NULL) {
; 2260 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);
; 2261 :                     if (v != NULL) {
; 2262 :                         v->value.str = xmlStrdup(value);
; 2263 :                         *val = v;
; 2264 :                     } else {
; 2265 :                         goto error;
; 2266 :                     }
; 2267 :                 }
; 2268 :                 goto return0;
; 2269 :             }
; 2270 :         case XML_SCHEMAS_DECIMAL:{
; 2271 :                 const xmlChar *cur = value;
; 2272 :                 unsigned int len, neg, integ, hasLeadingZeroes;
; 2273 : 		xmlChar cval[25];
; 2274 : 		xmlChar *cptr = cval;
; 2275 : 
; 2276 :                 if ((cur == NULL) || (*cur == 0))
; 2277 :                     goto return1;
; 2278 : 
; 2279 : 		/*
; 2280 : 		* xs:decimal has a whitespace-facet value of 'collapse'.
; 2281 : 		*/
; 2282 : 		if (normOnTheFly)
; 2283 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2284 : 
; 2285 : 		/*
; 2286 : 		* First we handle an optional sign.
; 2287 : 		*/
; 2288 : 		neg = 0;
; 2289 :                 if (*cur == '-') {
; 2290 : 		    neg = 1;
; 2291 :                     cur++;
; 2292 : 		} else if (*cur == '+')
; 2293 :                     cur++;
; 2294 : 		/*
; 2295 : 		* Disallow: "", "-", "- "
; 2296 : 		*/
; 2297 : 		if (*cur == 0)
; 2298 : 		    goto return1;
; 2299 : 		/*
; 2300 : 		 * Next we "pre-parse" the number, in preparation for calling
; 2301 : 		 * the common routine xmlSchemaParseUInt.  We get rid of any
; 2302 : 		 * leading zeroes (because we have reserved only 25 chars),
; 2303 : 		 * and note the position of a decimal point.
; 2304 : 		 */
; 2305 : 		len = 0;
; 2306 : 		integ = ~0u;
; 2307 : 		hasLeadingZeroes = 0;
; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {
; 2312 : 		    cur++;
; 2313 : 		    hasLeadingZeroes = 1;
; 2314 : 		}
; 2315 : 		if (*cur != 0) {
; 2316 : 		    do {
; 2317 : 			if ((*cur >= '0') && (*cur <= '9')) {
; 2318 : 			    *cptr++ = *cur++;
; 2319 : 			    len++;
; 2320 : 			} else if (*cur == '.') {
; 2321 : 			    cur++;
; 2322 : 			    integ = len;
; 2323 : 			    do {
; 2324 : 				if ((*cur >= '0') && (*cur <= '9')) {
; 2325 : 				    *cptr++ = *cur++;
; 2326 : 				    len++;
; 2327 : 				} else
; 2328 : 				    break;
; 2329 : 			    } while (len < 24);
; 2330 : 			    /*
; 2331 : 			    * Disallow "." but allow "00."
; 2332 : 			    */
; 2333 : 			    if ((len == 0) && (!hasLeadingZeroes))
; 2334 : 				goto return1;
; 2335 : 			    break;
; 2336 : 			} else
; 2337 : 			    break;
; 2338 : 		    } while (len < 24);
; 2339 : 		}
; 2340 : 		if (normOnTheFly)
; 2341 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2342 : 		if (*cur != 0)
; 2343 : 		    goto return1; /* error if any extraneous chars */
; 2344 :                 if (val != NULL) {
; 2345 :                     v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);
; 2346 :                     if (v != NULL) {
; 2347 : 			/*
; 2348 : 			* Now evaluate the significant digits of the number
; 2349 : 			*/
; 2350 : 			if (len != 0) {
; 2351 : 
; 2352 : 			    if (integ != ~0u) {
; 2353 : 				/*
; 2354 : 				* Get rid of trailing zeroes in the
; 2355 : 				* fractional part.
; 2356 : 				*/
; 2357 : 				while ((len != integ) && (*(cptr-1) == '0')) {
; 2358 : 				    cptr--;
; 2359 : 				    len--;
; 2360 : 				}
; 2361 : 			    }
; 2362 : 			    /*
; 2363 : 			    * Terminate the (preparsed) string.
; 2364 : 			    */
; 2365 : 			    if (len != 0) {
; 2366 : 				*cptr = 0;
; 2367 : 				cptr = cval;
; 2368 : 
; 2369 : 				xmlSchemaParseUInt((const xmlChar **)&cptr,
; 2370 : 				    &v->value.decimal.lo,
; 2371 : 				    &v->value.decimal.mi,
; 2372 : 				    &v->value.decimal.hi);
; 2373 : 			    }
; 2374 : 			}
; 2375 : 			/*
; 2376 : 			* Set the total digits to 1 if a zero value.
; 2377 : 			*/
; 2378 :                         v->value.decimal.sign = neg;
; 2379 : 			if (len == 0) {
; 2380 : 			    /* Speedup for zero values. */
; 2381 : 			    v->value.decimal.total = 1;
; 2382 : 			} else {
; 2383 : 			    v->value.decimal.total = len;
; 2384 : 			    if (integ == ~0u)
; 2385 : 				v->value.decimal.frac = 0;
; 2386 : 			    else
; 2387 : 				v->value.decimal.frac = len - integ;
; 2388 : 			}
; 2389 :                         *val = v;
; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;
; 2393 :             }
; 2394 :         case XML_SCHEMAS_TIME:
; 2395 :         case XML_SCHEMAS_GDAY:
; 2396 :         case XML_SCHEMAS_GMONTH:
; 2397 :         case XML_SCHEMAS_GMONTHDAY:
; 2398 :         case XML_SCHEMAS_GYEAR:
; 2399 :         case XML_SCHEMAS_GYEARMONTH:
; 2400 :         case XML_SCHEMAS_DATE:
; 2401 :         case XML_SCHEMAS_DATETIME:
; 2402 :             ret = xmlSchemaValidateDates(type->builtInType, value, val,
; 2403 : 		normOnTheFly);
; 2404 :             break;
; 2405 :         case XML_SCHEMAS_DURATION:
; 2406 :             ret = xmlSchemaValidateDuration(type, value, val,
; 2407 : 		normOnTheFly);
; 2408 :             break;
; 2409 :         case XML_SCHEMAS_FLOAT:
; 2410 :         case XML_SCHEMAS_DOUBLE: {
; 2411 :                 const xmlChar *cur = value;
; 2412 :                 int neg = 0;
; 2413 :                 int digits_before = 0;
; 2414 :                 int digits_after = 0;
; 2415 : 
; 2416 : 		if (normOnTheFly)
; 2417 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2418 : 
; 2419 :                 if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {
; 2420 :                     cur += 3;
; 2421 :                     if (*cur != 0)
; 2422 :                         goto return1;
; 2423 :                     if (val != NULL) {
; 2424 :                         if (type == xmlSchemaTypeFloatDef) {
; 2425 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2426 :                             if (v != NULL) {
; 2427 :                                 v->value.f = (float) xmlXPathNAN;
; 2428 :                             } else {
; 2429 :                                 xmlSchemaFreeValue(v);
; 2430 :                                 goto error;
; 2431 :                             }
; 2432 :                         } else {
; 2433 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2434 :                             if (v != NULL) {
; 2435 :                                 v->value.d = xmlXPathNAN;
; 2436 :                             } else {
; 2437 :                                 xmlSchemaFreeValue(v);
; 2438 :                                 goto error;
; 2439 :                             }
; 2440 :                         }
; 2441 :                         *val = v;
; 2442 :                     }
; 2443 :                     goto return0;
; 2444 :                 }
; 2445 :                 if (*cur == '-') {
; 2446 :                     neg = 1;
; 2447 :                     cur++;
; 2448 :                 }
; 2449 :                 if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {
; 2450 :                     cur += 3;
; 2451 :                     if (*cur != 0)
; 2452 :                         goto return1;
; 2453 :                     if (val != NULL) {
; 2454 :                         if (type == xmlSchemaTypeFloatDef) {
; 2455 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2456 :                             if (v != NULL) {
; 2457 :                                 if (neg)
; 2458 :                                     v->value.f = (float) xmlXPathNINF;
; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;
; 2461 :                             } else {
; 2462 :                                 xmlSchemaFreeValue(v);
; 2463 :                                 goto error;
; 2464 :                             }
; 2465 :                         } else {
; 2466 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2467 :                             if (v != NULL) {
; 2468 :                                 if (neg)
; 2469 :                                     v->value.d = xmlXPathNINF;
; 2470 :                                 else
; 2471 :                                     v->value.d = xmlXPathPINF;
; 2472 :                             } else {
; 2473 :                                 xmlSchemaFreeValue(v);
; 2474 :                                 goto error;
; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;
; 2478 :                     }
; 2479 :                     goto return0;
; 2480 :                 }
; 2481 :                 if ((neg == 0) && (*cur == '+'))
; 2482 :                     cur++;
; 2483 :                 if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))
; 2484 :                     goto return1;
; 2485 :                 while ((*cur >= '0') && (*cur <= '9')) {
; 2486 :                     cur++;
; 2487 :                     digits_before++;
; 2488 :                 }
; 2489 :                 if (*cur == '.') {
; 2490 :                     cur++;
; 2491 :                     while ((*cur >= '0') && (*cur <= '9')) {
; 2492 :                         cur++;
; 2493 :                         digits_after++;
; 2494 :                     }
; 2495 :                 }
; 2496 :                 if ((digits_before == 0) && (digits_after == 0))
; 2497 :                     goto return1;
; 2498 :                 if ((*cur == 'e') || (*cur == 'E')) {
; 2499 :                     cur++;
; 2500 :                     if ((*cur == '-') || (*cur == '+'))
; 2501 :                         cur++;
; 2502 :                     while ((*cur >= '0') && (*cur <= '9'))
; 2503 :                         cur++;
; 2504 :                 }
; 2505 : 		if (normOnTheFly)
; 2506 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2507 : 
; 2508 :                 if (*cur != 0)
; 2509 :                     goto return1;
; 2510 :                 if (val != NULL) {
; 2511 :                     if (type == xmlSchemaTypeFloatDef) {
; 2512 :                         v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);
; 2513 :                         if (v != NULL) {
; 2514 : 			    /*
; 2515 : 			    * TODO: sscanf seems not to give the correct
; 2516 : 			    * value for extremely high/low values.
; 2517 : 			    * E.g. "1E-149" results in zero.
; 2518 : 			    */
; 2519 :                             if (sscanf((const char *) value, "%f",
; 2520 :                                  &(v->value.f)) == 1) {
; 2521 :                                 *val = v;
; 2522 :                             } else {
; 2523 :                                 xmlSchemaFreeValue(v);
; 2524 :                                 goto return1;
; 2525 :                             }
; 2526 :                         } else {
; 2527 :                             goto error;
; 2528 :                         }
; 2529 :                     } else {
; 2530 :                         v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);
; 2531 :                         if (v != NULL) {
; 2532 : 			    /*
; 2533 : 			    * TODO: sscanf seems not to give the correct
; 2534 : 			    * value for extremely high/low values.
; 2535 : 			    */
; 2536 :                             if (sscanf((const char *) value, "%lf",
; 2537 :                                  &(v->value.d)) == 1) {
; 2538 :                                 *val = v;
; 2539 :                             } else {
; 2540 :                                 xmlSchemaFreeValue(v);
; 2541 :                                 goto return1;
; 2542 :                             }
; 2543 :                         } else {
; 2544 :                             goto error;
; 2545 :                         }
; 2546 :                     }
; 2547 :                 }
; 2548 :                 goto return0;
; 2549 :             }
; 2550 :         case XML_SCHEMAS_BOOLEAN:{
; 2551 :                 const xmlChar *cur = value;
; 2552 : 
; 2553 : 		if (normOnTheFly) {
; 2554 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2555 : 		    if (*cur == '0') {
; 2556 : 			ret = 0;
; 2557 : 			cur++;
; 2558 : 		    } else if (*cur == '1') {
; 2559 : 			ret = 1;
; 2560 : 			cur++;
; 2561 : 		    } else if (*cur == 't') {
; 2562 : 			cur++;
; 2563 : 			if ((*cur++ == 'r') && (*cur++ == 'u') &&
; 2564 : 			    (*cur++ == 'e')) {
; 2565 : 			    ret = 1;
; 2566 : 			} else
; 2567 : 			    goto return1;
; 2568 : 		    } else if (*cur == 'f') {
; 2569 : 			cur++;
; 2570 : 			if ((*cur++ == 'a') && (*cur++ == 'l') &&
; 2571 : 			    (*cur++ == 's') && (*cur++ == 'e')) {
; 2572 : 			    ret = 0;
; 2573 : 			} else
; 2574 : 			    goto return1;
; 2575 : 		    } else
; 2576 : 			goto return1;
; 2577 : 		    if (*cur != 0) {
; 2578 : 			while IS_WSP_BLANK_CH(*cur) cur++;
; 2579 : 			if (*cur != 0)
; 2580 : 			    goto return1;
; 2581 : 		    }
; 2582 : 		} else {
; 2583 : 		    if ((cur[0] == '0') && (cur[1] == 0))
; 2584 : 			ret = 0;
; 2585 : 		    else if ((cur[0] == '1') && (cur[1] == 0))
; 2586 : 			ret = 1;
; 2587 : 		    else if ((cur[0] == 't') && (cur[1] == 'r')
; 2588 : 			&& (cur[2] == 'u') && (cur[3] == 'e')
; 2589 : 			&& (cur[4] == 0))
; 2590 : 			ret = 1;
; 2591 : 		    else if ((cur[0] == 'f') && (cur[1] == 'a')
; 2592 : 			&& (cur[2] == 'l') && (cur[3] == 's')
; 2593 : 			&& (cur[4] == 'e') && (cur[5] == 0))
; 2594 : 			ret = 0;
; 2595 : 		    else
; 2596 : 			goto return1;
; 2597 : 		}
; 2598 :                 if (val != NULL) {
; 2599 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);
; 2600 :                     if (v != NULL) {
; 2601 :                         v->value.b = ret;
; 2602 :                         *val = v;
; 2603 :                     } else {
; 2604 :                         goto error;
; 2605 :                     }
; 2606 :                 }
; 2607 :                 goto return0;
; 2608 :             }
; 2609 :         case XML_SCHEMAS_TOKEN:{
; 2610 :                 const xmlChar *cur = value;
; 2611 : 
; 2612 : 		if (! normOnTheFly) {
; 2613 : 		    while (*cur != 0) {
; 2614 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {
; 2615 : 			    goto return1;
; 2616 : 			} else if (*cur == ' ') {
; 2617 : 			    cur++;
; 2618 : 			    if (*cur == 0)
; 2619 : 				goto return1;
; 2620 : 			    if (*cur == ' ')
; 2621 : 				goto return1;
; 2622 : 			} else {
; 2623 : 			    cur++;
; 2624 : 			}
; 2625 : 		    }
; 2626 : 		}
; 2627 :                 if (val != NULL) {
; 2628 :                     v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);
; 2629 :                     if (v != NULL) {
; 2630 :                         v->value.str = xmlStrdup(value);
; 2631 :                         *val = v;
; 2632 :                     } else {
; 2633 :                         goto error;
; 2634 :                     }
; 2635 :                 }
; 2636 :                 goto return0;
; 2637 :             }
; 2638 :         case XML_SCHEMAS_LANGUAGE:
; 2639 : 	    if (normOnTheFly) {
; 2640 : 		norm = xmlSchemaCollapseString(value);
; 2641 : 		if (norm != NULL)
; 2642 : 		    value = norm;
; 2643 : 	    }
; 2644 :             if (xmlCheckLanguageID(value) == 1) {
; 2645 :                 if (val != NULL) {
; 2646 :                     v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);
; 2647 :                     if (v != NULL) {
; 2648 :                         v->value.str = xmlStrdup(value);
; 2649 :                         *val = v;
; 2650 :                     } else {
; 2651 :                         goto error;
; 2652 :                     }
; 2653 :                 }
; 2654 :                 goto return0;
; 2655 :             }
; 2656 :             goto return1;
; 2657 :         case XML_SCHEMAS_NMTOKEN:
; 2658 :             if (xmlValidateNMToken(value, 1) == 0) {
; 2659 :                 if (val != NULL) {
; 2660 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);
; 2661 :                     if (v != NULL) {
; 2662 :                         v->value.str = xmlStrdup(value);
; 2663 :                         *val = v;
; 2664 :                     } else {
; 2665 :                         goto error;
; 2666 :                     }
; 2667 :                 }
; 2668 :                 goto return0;
; 2669 :             }
; 2670 :             goto return1;
; 2671 :         case XML_SCHEMAS_NMTOKENS:
; 2672 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,
; 2673 :                                              value, val, node);
; 2674 :             if (ret > 0)
; 2675 :                 ret = 0;
; 2676 :             else
; 2677 :                 ret = 1;
; 2678 :             goto done;
; 2679 :         case XML_SCHEMAS_NAME:
; 2680 :             ret = xmlValidateName(value, 1);
; 2681 :             if ((ret == 0) && (val != NULL) && (value != NULL)) {
; 2682 : 		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);
; 2683 : 		if (v != NULL) {
; 2684 : 		     const xmlChar *start = value, *end;
; 2685 : 		     while (IS_BLANK_CH(*start)) start++;
; 2686 : 		     end = start;
; 2687 : 		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;
; 2688 : 		     v->value.str = xmlStrndup(start, end - start);
; 2689 : 		    *val = v;
; 2690 : 		} else {
; 2691 : 		    goto error;
; 2692 : 		}
; 2693 :             }
; 2694 :             goto done;
; 2695 :         case XML_SCHEMAS_QNAME:{
; 2696 :                 const xmlChar *uri = NULL;
; 2697 :                 xmlChar *local = NULL;
; 2698 : 
; 2699 :                 ret = xmlValidateQName(value, 1);
; 2700 : 		if (ret != 0)
; 2701 : 		    goto done;
; 2702 :                 if (node != NULL) {
; 2703 :                     xmlChar *prefix;
; 2704 : 		    xmlNsPtr ns;
; 2705 : 
; 2706 :                     local = xmlSplitQName2(value, &prefix);
; 2707 : 		    ns = xmlSearchNs(node->doc, node, prefix);
; 2708 : 		    if ((ns == NULL) && (prefix != NULL)) {
; 2709 : 			xmlFree(prefix);
; 2710 : 			if (local != NULL)
; 2711 : 			    xmlFree(local);
; 2712 : 			goto return1;
; 2713 : 		    }
; 2714 : 		    if (ns != NULL)
; 2715 : 			uri = ns->href;
; 2716 :                     if (prefix != NULL)
; 2717 :                         xmlFree(prefix);
; 2718 :                 }
; 2719 :                 if (val != NULL) {
; 2720 :                     v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 2721 :                     if (v == NULL) {
; 2722 : 			if (local != NULL)
; 2723 : 			    xmlFree(local);
; 2724 : 			goto error;
; 2725 : 		    }
; 2726 : 		    if (local != NULL)
; 2727 : 			v->value.qname.name = local;
; 2728 : 		    else
; 2729 : 			v->value.qname.name = xmlStrdup(value);
; 2730 : 		    if (uri != NULL)
; 2731 : 			v->value.qname.uri = xmlStrdup(uri);
; 2732 : 		    *val = v;
; 2733 :                 } else
; 2734 : 		    if (local != NULL)
; 2735 : 			xmlFree(local);
; 2736 :                 goto done;
; 2737 :             }
; 2738 :         case XML_SCHEMAS_NCNAME:
; 2739 :             ret = xmlValidateNCName(value, 1);
; 2740 :             if ((ret == 0) && (val != NULL)) {
; 2741 :                 v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);
; 2742 :                 if (v != NULL) {
; 2743 :                     v->value.str = xmlStrdup(value);
; 2744 :                     *val = v;
; 2745 :                 } else {
; 2746 :                     goto error;
; 2747 :                 }
; 2748 :             }
; 2749 :             goto done;
; 2750 :         case XML_SCHEMAS_ID:
; 2751 :             ret = xmlValidateNCName(value, 1);
; 2752 :             if ((ret == 0) && (val != NULL)) {
; 2753 :                 v = xmlSchemaNewValue(XML_SCHEMAS_ID);
; 2754 :                 if (v != NULL) {
; 2755 :                     v->value.str = xmlStrdup(value);
; 2756 :                     *val = v;
; 2757 :                 } else {
; 2758 :                     goto error;
; 2759 :                 }
; 2760 :             }
; 2761 :             if ((ret == 0) && (node != NULL) &&
; 2762 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2763 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2764 : 
; 2765 :                 /*
; 2766 :                  * NOTE: the IDness might have already be declared in the DTD
; 2767 :                  */
; 2768 :                 if (attr->atype != XML_ATTRIBUTE_ID) {
; 2769 :                     xmlIDPtr res;
; 2770 :                     xmlChar *strip;
; 2771 : 
; 2772 :                     strip = xmlSchemaStrip(value);
; 2773 :                     if (strip != NULL) {
; 2774 :                         res = xmlAddID(NULL, node->doc, strip, attr);
; 2775 :                         xmlFree(strip);
; 2776 :                     } else
; 2777 :                         res = xmlAddID(NULL, node->doc, value, attr);
; 2778 :                     if (res == NULL) {
; 2779 :                         ret = 2;
; 2780 :                     } else {
; 2781 :                         attr->atype = XML_ATTRIBUTE_ID;
; 2782 :                     }
; 2783 :                 }
; 2784 :             }
; 2785 :             goto done;
; 2786 :         case XML_SCHEMAS_IDREF:
; 2787 :             ret = xmlValidateNCName(value, 1);
; 2788 :             if ((ret == 0) && (val != NULL)) {
; 2789 : 		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);
; 2790 : 		if (v == NULL)
; 2791 : 		    goto error;
; 2792 : 		v->value.str = xmlStrdup(value);
; 2793 : 		*val = v;
; 2794 :             }
; 2795 :             if ((ret == 0) && (node != NULL) &&
; 2796 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2797 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2798 :                 xmlChar *strip;
; 2799 : 
; 2800 :                 strip = xmlSchemaStrip(value);
; 2801 :                 if (strip != NULL) {
; 2802 :                     xmlAddRef(NULL, node->doc, strip, attr);
; 2803 :                     xmlFree(strip);
; 2804 :                 } else
; 2805 :                     xmlAddRef(NULL, node->doc, value, attr);
; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;
; 2807 :             }
; 2808 :             goto done;
; 2809 :         case XML_SCHEMAS_IDREFS:
; 2810 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,
; 2811 :                                              value, val, node);
; 2812 :             if (ret < 0)
; 2813 :                 ret = 2;
; 2814 :             else
; 2815 :                 ret = 0;
; 2816 :             if ((ret == 0) && (node != NULL) &&
; 2817 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2818 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2819 : 
; 2820 :                 attr->atype = XML_ATTRIBUTE_IDREFS;
; 2821 :             }
; 2822 :             goto done;
; 2823 :         case XML_SCHEMAS_ENTITY:{
; 2824 :                 xmlChar *strip;
; 2825 : 
; 2826 :                 ret = xmlValidateNCName(value, 1);
; 2827 :                 if ((node == NULL) || (node->doc == NULL))
; 2828 :                     ret = 3;
; 2829 :                 if (ret == 0) {
; 2830 :                     xmlEntityPtr ent;
; 2831 : 
; 2832 :                     strip = xmlSchemaStrip(value);
; 2833 :                     if (strip != NULL) {
; 2834 :                         ent = xmlGetDocEntity(node->doc, strip);
; 2835 :                         xmlFree(strip);
; 2836 :                     } else {
; 2837 :                         ent = xmlGetDocEntity(node->doc, value);
; 2838 :                     }
; 2839 :                     if ((ent == NULL) ||
; 2840 :                         (ent->etype !=
; 2841 :                          XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
; 2842 :                         ret = 4;
; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {
; 2845 :                     TODO;
; 2846 :                 }
; 2847 :                 if ((ret == 0) && (node != NULL) &&
; 2848 :                     (node->type == XML_ATTRIBUTE_NODE)) {
; 2849 :                     xmlAttrPtr attr = (xmlAttrPtr) node;
; 2850 : 
; 2851 :                     attr->atype = XML_ATTRIBUTE_ENTITY;
; 2852 :                 }
; 2853 :                 goto done;
; 2854 :             }
; 2855 :         case XML_SCHEMAS_ENTITIES:
; 2856 :             if ((node == NULL) || (node->doc == NULL))
; 2857 :                 goto return3;
; 2858 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,
; 2859 :                                              value, val, node);
; 2860 :             if (ret <= 0)
; 2861 :                 ret = 1;
; 2862 :             else
; 2863 :                 ret = 0;
; 2864 :             if ((ret == 0) && (node != NULL) &&
; 2865 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2866 :                 xmlAttrPtr attr = (xmlAttrPtr) node;
; 2867 : 
; 2868 :                 attr->atype = XML_ATTRIBUTE_ENTITIES;
; 2869 :             }
; 2870 :             goto done;
; 2871 :         case XML_SCHEMAS_NOTATION:{
; 2872 :                 xmlChar *uri = NULL;
; 2873 :                 xmlChar *local = NULL;
; 2874 : 
; 2875 :                 ret = xmlValidateQName(value, 1);
; 2876 :                 if ((ret == 0) && (node != NULL)) {
; 2877 :                     xmlChar *prefix;
; 2878 : 
; 2879 :                     local = xmlSplitQName2(value, &prefix);
; 2880 :                     if (prefix != NULL) {
; 2881 :                         xmlNsPtr ns;
; 2882 : 
; 2883 :                         ns = xmlSearchNs(node->doc, node, prefix);
; 2884 :                         if (ns == NULL)
; 2885 :                             ret = 1;
; 2886 :                         else if (val != NULL)
; 2887 :                             uri = xmlStrdup(ns->href);
; 2888 :                     }
; 2889 :                     if ((local != NULL) && ((val == NULL) || (ret != 0)))
; 2890 :                         xmlFree(local);
; 2891 :                     if (prefix != NULL)
; 2892 :                         xmlFree(prefix);
; 2893 :                 }
; 2894 :                 if ((node == NULL) || (node->doc == NULL))
; 2895 :                     ret = 3;
; 2896 :                 if (ret == 0) {
; 2897 :                     ret = xmlValidateNotationUse(NULL, node->doc, value);
; 2898 :                     if (ret == 1)
; 2899 :                         ret = 0;
; 2900 :                     else
; 2901 :                         ret = 1;
; 2902 :                 }
; 2903 :                 if ((ret == 0) && (val != NULL)) {
; 2904 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 2905 :                     if (v != NULL) {
; 2906 :                         if (local != NULL)
; 2907 :                             v->value.qname.name = local;
; 2908 :                         else
; 2909 :                             v->value.qname.name = xmlStrdup(value);
; 2910 :                         if (uri != NULL)
; 2911 :                             v->value.qname.uri = uri;
; 2912 : 
; 2913 :                         *val = v;
; 2914 :                     } else {
; 2915 :                         if (local != NULL)
; 2916 :                             xmlFree(local);
; 2917 :                         if (uri != NULL)
; 2918 :                             xmlFree(uri);
; 2919 :                         goto error;
; 2920 :                     }
; 2921 :                 }
; 2922 :                 goto done;
; 2923 :             }
; 2924 :         case XML_SCHEMAS_ANYURI:{
; 2925 :                 if (*value != 0) {
; 2926 : 		    xmlURIPtr uri;
; 2927 : 		    xmlChar *tmpval, *cur;
; 2928 : 		    if (normOnTheFly) {
; 2929 : 			norm = xmlSchemaCollapseString(value);
; 2930 : 			if (norm != NULL)
; 2931 : 			    value = norm;
; 2932 : 		    }
; 2933 : 		    tmpval = xmlStrdup(value);
; 2934 : 		    for (cur = tmpval; *cur; ++cur) {
; 2935 : 			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
; 2936 : 			    *cur == '<' || *cur == '>' || *cur == '"' ||
; 2937 : 			    *cur == '{' || *cur == '}' || *cur == '|' ||
; 2938 : 			    *cur == '\\' || *cur == '^' || *cur == '`' ||
; 2939 : 			    *cur == '\'')
; 2940 : 			    *cur = '_';
; 2941 : 		    }
; 2942 :                     uri = xmlParseURI((const char *) tmpval);
; 2943 : 		    xmlFree(tmpval);
; 2944 :                     if (uri == NULL)
; 2945 :                         goto return1;
; 2946 :                     xmlFreeURI(uri);
; 2947 :                 }
; 2948 : 
; 2949 :                 if (val != NULL) {
; 2950 :                     v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);
; 2951 :                     if (v == NULL)
; 2952 :                         goto error;
; 2953 :                     v->value.str = xmlStrdup(value);
; 2954 :                     *val = v;
; 2955 :                 }
; 2956 :                 goto return0;
; 2957 :             }
; 2958 :         case XML_SCHEMAS_HEXBINARY:{
; 2959 :                 const xmlChar *cur = value, *start;
; 2960 :                 xmlChar *base;
; 2961 :                 int total, i = 0;
; 2962 : 
; 2963 :                 if (cur == NULL)
; 2964 :                     goto return1;
; 2965 : 
; 2966 : 		if (normOnTheFly)
; 2967 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2968 : 
; 2969 : 		start = cur;
; 2970 :                 while (((*cur >= '0') && (*cur <= '9')) ||
; 2971 :                        ((*cur >= 'A') && (*cur <= 'F')) ||
; 2972 :                        ((*cur >= 'a') && (*cur <= 'f'))) {
; 2973 :                     i++;
; 2974 :                     cur++;
; 2975 :                 }
; 2976 : 		if (normOnTheFly)
; 2977 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 2978 : 
; 2979 :                 if (*cur != 0)
; 2980 :                     goto return1;
; 2981 :                 if ((i % 2) != 0)
; 2982 :                     goto return1;
; 2983 : 
; 2984 :                 if (val != NULL) {
; 2985 : 
; 2986 :                     v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);
; 2987 :                     if (v == NULL)
; 2988 :                         goto error;
; 2989 : 		    /*
; 2990 : 		    * Copy only the normalized piece.
; 2991 : 		    * CRITICAL TODO: Check this.
; 2992 : 		    */
; 2993 :                     cur = xmlStrndup(start, i);
; 2994 :                     if (cur == NULL) {
; 2995 : 		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");
; 2996 :                         xmlFree(v);
; 2997 :                         goto return1;
; 2998 :                     }
; 2999 : 
; 3000 :                     total = i / 2;      /* number of octets */
; 3001 : 
; 3002 :                     base = (xmlChar *) cur;
; 3003 :                     while (i-- > 0) {
; 3004 :                         if (*base >= 'a')
; 3005 :                             *base = *base - ('a' - 'A');
; 3006 :                         base++;
; 3007 :                     }
; 3008 : 
; 3009 :                     v->value.hex.str = (xmlChar *) cur;
; 3010 :                     v->value.hex.total = total;
; 3011 :                     *val = v;
; 3012 :                 }
; 3013 :                 goto return0;
; 3014 :             }
; 3015 :         case XML_SCHEMAS_BASE64BINARY:{
; 3016 :                 /* ISSUE:
; 3017 :                  *
; 3018 :                  * Ignore all stray characters? (yes, currently)
; 3019 :                  * Worry about long lines? (no, currently)
; 3020 :                  *
; 3021 :                  * rfc2045.txt:
; 3022 :                  *
; 3023 :                  * "The encoded output stream must be represented in lines of
; 3024 :                  * no more than 76 characters each.  All line breaks or other
; 3025 :                  * characters not found in Table 1 must be ignored by decoding
; 3026 :                  * software.  In base64 data, characters other than those in
; 3027 :                  * Table 1, line breaks, and other white space probably
; 3028 :                  * indicate a transmission error, about which a warning
; 3029 :                  * message or even a message rejection might be appropriate
; 3030 :                  * under some circumstances." */
; 3031 :                 const xmlChar *cur = value;
; 3032 :                 xmlChar *base;
; 3033 :                 int total, i = 0, pad = 0;
; 3034 : 
; 3035 :                 if (cur == NULL)
; 3036 :                     goto return1;
; 3037 : 
; 3038 :                 for (; *cur; ++cur) {
; 3039 :                     int decc;
; 3040 : 
; 3041 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3042 :                     if (decc < 0) ;
; 3043 :                     else if (decc < 64)
; 3044 :                         i++;
; 3045 :                     else
; 3046 :                         break;
; 3047 :                 }
; 3048 :                 for (; *cur; ++cur) {
; 3049 :                     int decc;
; 3050 : 
; 3051 :                     decc = _xmlSchemaBase64Decode(*cur);
; 3052 :                     if (decc < 0) ;
; 3053 :                     else if (decc < 64)
; 3054 :                         goto return1;
; 3055 :                     if (decc == 64)
; 3056 :                         pad++;
; 3057 :                 }
; 3058 : 
; 3059 :                 /* rfc2045.txt: "Special processing is performed if fewer than
; 3060 :                  * 24 bits are available at the end of the data being encoded.
; 3061 :                  * A full encoding quantum is always completed at the end of a
; 3062 :                  * body.  When fewer than 24 input bits are available in an
; 3063 :                  * input group, zero bits are added (on the right) to form an
; 3064 :                  * integral number of 6-bit groups.  Padding at the end of the
; 3065 :                  * data is performed using the "=" character.  Since all
; 3066 :                  * base64 input is an integral number of octets, only the
; 3067 :                  * following cases can arise: (1) the final quantum of
; 3068 :                  * encoding input is an integral multiple of 24 bits; here,
; 3069 :                  * the final unit of encoded output will be an integral
; 3070 :                  * multiple ofindent: Standard input:701: Warning:old style
; 3071 : 		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
; 3072 : 		 * with no "=" padding, (2) the final
; 3073 :                  * quantum of encoding input is exactly 8 bits; here, the
; 3074 :                  * final unit of encoded output will be two characters
; 3075 :                  * followed by two "=" padding characters, or (3) the final
; 3076 :                  * quantum of encoding input is exactly 16 bits; here, the
; 3077 :                  * final unit of encoded output will be three characters
; 3078 :                  * followed by one "=" padding character." */
; 3079 : 
; 3080 :                 total = 3 * (i / 4);
; 3081 :                 if (pad == 0) {
; 3082 :                     if (i % 4 != 0)
; 3083 :                         goto return1;
; 3084 :                 } else if (pad == 1) {
; 3085 :                     int decc;
; 3086 : 
; 3087 :                     if (i % 4 != 3)
; 3088 :                         goto return1;
; 3089 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3090 :                          (decc < 0) || (decc > 63);
; 3091 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3092 :                         --cur;
; 3093 :                     /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
; 3094 :                     /* 00111100 -> 0x3c */
; 3095 :                     if (decc & ~0x3c)
; 3096 :                         goto return1;
; 3097 :                     total += 2;
; 3098 :                 } else if (pad == 2) {
; 3099 :                     int decc;
; 3100 : 
; 3101 :                     if (i % 4 != 2)
; 3102 :                         goto return1;
; 3103 :                     for (decc = _xmlSchemaBase64Decode(*cur);
; 3104 :                          (decc < 0) || (decc > 63);
; 3105 :                          decc = _xmlSchemaBase64Decode(*cur))
; 3106 :                         --cur;
; 3107 :                     /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
; 3108 :                     /* 00110000 -> 0x30 */
; 3109 :                     if (decc & ~0x30)
; 3110 :                         goto return1;
; 3111 :                     total += 1;
; 3112 :                 } else
; 3113 :                     goto return1;
; 3114 : 
; 3115 :                 if (val != NULL) {
; 3116 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);
; 3117 :                     if (v == NULL)
; 3118 :                         goto error;
; 3119 :                     base =
; 3120 :                         (xmlChar *) xmlMallocAtomic((i + pad + 1) *
; 3121 :                                                     sizeof(xmlChar));
; 3122 :                     if (base == NULL) {
; 3123 : 		        xmlSchemaTypeErrMemory(node, "allocating base64 data");
; 3124 :                         xmlFree(v);
; 3125 :                         goto return1;
; 3126 :                     }
; 3127 :                     v->value.base64.str = base;
; 3128 :                     for (cur = value; *cur; ++cur)
; 3129 :                         if (_xmlSchemaBase64Decode(*cur) >= 0) {
; 3130 :                             *base = *cur;
; 3131 :                             ++base;
; 3132 :                         }
; 3133 :                     *base = 0;
; 3134 :                     v->value.base64.total = total;
; 3135 :                     *val = v;
; 3136 :                 }
; 3137 :                 goto return0;
; 3138 :             }
; 3139 :         case XML_SCHEMAS_INTEGER:
; 3140 :         case XML_SCHEMAS_PINTEGER:
; 3141 :         case XML_SCHEMAS_NPINTEGER:
; 3142 :         case XML_SCHEMAS_NINTEGER:
; 3143 :         case XML_SCHEMAS_NNINTEGER:{
; 3144 :                 const xmlChar *cur = value;
; 3145 :                 unsigned long lo, mi, hi;
; 3146 :                 int sign = 0;
; 3147 : 
; 3148 :                 if (cur == NULL)
; 3149 :                     goto return1;
; 3150 : 		if (normOnTheFly)
; 3151 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3152 :                 if (*cur == '-') {
; 3153 :                     sign = 1;
; 3154 :                     cur++;
; 3155 :                 } else if (*cur == '+')
; 3156 :                     cur++;
; 3157 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3158 :                 if (ret < 0)
; 3159 :                     goto return1;
; 3160 : 		if (normOnTheFly)
; 3161 : 		    while IS_WSP_BLANK_CH(*cur) cur++;
; 3162 :                 if (*cur != 0)
; 3163 :                     goto return1;
; 3164 :                 if (type->builtInType == XML_SCHEMAS_NPINTEGER) {
; 3165 :                     if ((sign == 0) &&
; 3166 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3167 :                         goto return1;
; 3168 :                 } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {
; 3169 :                     if (sign == 1)
; 3170 :                         goto return1;
; 3171 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3172 :                         goto return1;
; 3173 :                 } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {
; 3174 :                     if (sign == 0)
; 3175 :                         goto return1;
; 3176 :                     if ((hi == 0) && (mi == 0) && (lo == 0))
; 3177 :                         goto return1;
; 3178 :                 } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {
; 3179 :                     if ((sign == 1) &&
; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;
; 3182 :                 }
; 3183 :                 if (val != NULL) {
; 3184 :                     v = xmlSchemaNewValue(type->builtInType);
; 3185 :                     if (v != NULL) {
; 3186 : 			if (ret == 0)
; 3187 : 			    ret++;
; 3188 :                         v->value.decimal.lo = lo;
; 3189 :                         v->value.decimal.mi = mi;
; 3190 :                         v->value.decimal.hi = hi;
; 3191 :                         v->value.decimal.sign = sign;
; 3192 :                         v->value.decimal.frac = 0;
; 3193 :                         v->value.decimal.total = ret;
; 3194 :                         *val = v;
; 3195 :                     }
; 3196 :                 }
; 3197 :                 goto return0;
; 3198 :             }
; 3199 :         case XML_SCHEMAS_LONG:
; 3200 :         case XML_SCHEMAS_BYTE:
; 3201 :         case XML_SCHEMAS_SHORT:
; 3202 :         case XML_SCHEMAS_INT:{
; 3203 :                 const xmlChar *cur = value;
; 3204 :                 unsigned long lo, mi, hi;
; 3205 :                 int sign = 0;
; 3206 : 
; 3207 :                 if (cur == NULL)
; 3208 :                     goto return1;
; 3209 :                 if (*cur == '-') {
; 3210 :                     sign = 1;
; 3211 :                     cur++;
; 3212 :                 } else if (*cur == '+')
; 3213 :                     cur++;
; 3214 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3215 :                 if (ret < 0)
; 3216 :                     goto return1;
; 3217 :                 if (*cur != 0)
; 3218 :                     goto return1;
; 3219 :                 if (type->builtInType == XML_SCHEMAS_LONG) {
; 3220 :                     if (hi >= 922) {
; 3221 :                         if (hi > 922)
; 3222 :                             goto return1;
; 3223 :                         if (mi >= 33720368) {
; 3224 :                             if (mi > 33720368)
; 3225 :                                 goto return1;
; 3226 :                             if ((sign == 0) && (lo > 54775807))
; 3227 :                                 goto return1;
; 3228 :                             if ((sign == 1) && (lo > 54775808))
; 3229 :                                 goto return1;
; 3230 :                         }
; 3231 :                     }
; 3232 :                 } else if (type->builtInType == XML_SCHEMAS_INT) {
; 3233 :                     if (hi != 0)
; 3234 :                         goto return1;
; 3235 :                     if (mi >= 21) {
; 3236 :                         if (mi > 21)
; 3237 :                             goto return1;
; 3238 :                         if ((sign == 0) && (lo > 47483647))
; 3239 :                             goto return1;
; 3240 :                         if ((sign == 1) && (lo > 47483648))
; 3241 :                             goto return1;
; 3242 :                     }
; 3243 :                 } else if (type->builtInType == XML_SCHEMAS_SHORT) {
; 3244 :                     if ((mi != 0) || (hi != 0))
; 3245 :                         goto return1;
; 3246 :                     if ((sign == 1) && (lo > 32768))
; 3247 :                         goto return1;
; 3248 :                     if ((sign == 0) && (lo > 32767))
; 3249 :                         goto return1;
; 3250 :                 } else if (type->builtInType == XML_SCHEMAS_BYTE) {
; 3251 :                     if ((mi != 0) || (hi != 0))
; 3252 :                         goto return1;
; 3253 :                     if ((sign == 1) && (lo > 128))
; 3254 :                         goto return1;
; 3255 :                     if ((sign == 0) && (lo > 127))
; 3256 :                         goto return1;
; 3257 :                 }
; 3258 :                 if (val != NULL) {
; 3259 :                     v = xmlSchemaNewValue(type->builtInType);
; 3260 :                     if (v != NULL) {
; 3261 :                         v->value.decimal.lo = lo;
; 3262 :                         v->value.decimal.mi = mi;
; 3263 :                         v->value.decimal.hi = hi;
; 3264 :                         v->value.decimal.sign = sign;
; 3265 :                         v->value.decimal.frac = 0;
; 3266 :                         v->value.decimal.total = ret;
; 3267 :                         *val = v;
; 3268 :                     }
; 3269 :                 }
; 3270 :                 goto return0;
; 3271 :             }
; 3272 :         case XML_SCHEMAS_UINT:
; 3273 :         case XML_SCHEMAS_ULONG:
; 3274 :         case XML_SCHEMAS_USHORT:
; 3275 :         case XML_SCHEMAS_UBYTE:{
; 3276 :                 const xmlChar *cur = value;
; 3277 :                 unsigned long lo, mi, hi;
; 3278 : 
; 3279 :                 if (cur == NULL)
; 3280 :                     goto return1;
; 3281 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);
; 3282 :                 if (ret < 0)
; 3283 :                     goto return1;
; 3284 :                 if (*cur != 0)
; 3285 :                     goto return1;
; 3286 :                 if (type->builtInType == XML_SCHEMAS_ULONG) {
; 3287 :                     if (hi >= 1844) {
; 3288 :                         if (hi > 1844)
; 3289 :                             goto return1;
; 3290 :                         if (mi >= 67440737) {
; 3291 :                             if (mi > 67440737)
; 3292 :                                 goto return1;
; 3293 :                             if (lo > 9551615)
; 3294 :                                 goto return1;
; 3295 :                         }
; 3296 :                     }
; 3297 :                 } else if (type->builtInType == XML_SCHEMAS_UINT) {
; 3298 :                     if (hi != 0)
; 3299 :                         goto return1;
; 3300 :                     if (mi >= 42) {
; 3301 :                         if (mi > 42)
; 3302 :                             goto return1;
; 3303 :                         if (lo > 94967295)
; 3304 :                             goto return1;
; 3305 :                     }
; 3306 :                 } else if (type->builtInType == XML_SCHEMAS_USHORT) {
; 3307 :                     if ((mi != 0) || (hi != 0))
; 3308 :                         goto return1;
; 3309 :                     if (lo > 65535)
; 3310 :                         goto return1;
; 3311 :                 } else if (type->builtInType == XML_SCHEMAS_UBYTE) {
; 3312 :                     if ((mi != 0) || (hi != 0))
; 3313 :                         goto return1;
; 3314 :                     if (lo > 255)
; 3315 :                         goto return1;
; 3316 :                 }
; 3317 :                 if (val != NULL) {
; 3318 :                     v = xmlSchemaNewValue(type->builtInType);
; 3319 :                     if (v != NULL) {
; 3320 :                         v->value.decimal.lo = lo;
; 3321 :                         v->value.decimal.mi = mi;
; 3322 :                         v->value.decimal.hi = hi;
; 3323 :                         v->value.decimal.sign = 0;
; 3324 :                         v->value.decimal.frac = 0;
; 3325 :                         v->value.decimal.total = ret;
; 3326 :                         *val = v;
; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;
; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)
; 3335 :         xmlFree(norm);
; 3336 :     return (ret);
; 3337 :   return3:
; 3338 :     if (norm != NULL)
; 3339 :         xmlFree(norm);
; 3340 :     return (3);
; 3341 :   return1:
; 3342 :     if (norm != NULL)
; 3343 :         xmlFree(norm);
; 3344 :     return (1);
; 3345 :   return0:
; 3346 :     if (norm != NULL)
; 3347 :         xmlFree(norm);
; 3348 :     return (0);
; 3349 :   error:
; 3350 :     if (norm != NULL)
; 3351 :         xmlFree(norm);
; 3352 :     return (-1);
; 3353 : }
; 3354 : 
; 3355 : /**
; 3356 :  * xmlSchemaValPredefTypeNode:
; 3357 :  * @type: the predefined type
; 3358 :  * @value: the value to check
; 3359 :  * @val:  the return computed value
; 3360 :  * @node:  the node containing the value
; 3361 :  *
; 3362 :  * Check that a value conforms to the lexical space of the predefined type.
; 3363 :  * if true a value is computed and returned in @val.
; 3364 :  *
; 3365 :  * Returns 0 if this validates, a positive error code number otherwise
; 3366 :  *         and -1 in case of internal or API error.
; 3367 :  */
; 3368 : int
; 3369 : xmlSchemaValPredefTypeNode(xmlSchemaTypePtr type, const xmlChar *value,
; 3370 : 	                   xmlSchemaValPtr *val, xmlNodePtr node) {
; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,
; 3372 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
; 3373 : }
; 3374 : 
; 3375 : /**
; 3376 :  * xmlSchemaValPredefTypeNodeNoNorm:
; 3377 :  * @type: the predefined type
; 3378 :  * @value: the value to check
; 3379 :  * @val:  the return computed value
; 3380 :  * @node:  the node containing the value
; 3381 :  *
; 3382 :  * Check that a value conforms to the lexical space of the predefined type.
; 3383 :  * if true a value is computed and returned in @val.
; 3384 :  * This one does apply any normalization to the value.
; 3385 :  *
; 3386 :  * Returns 0 if this validates, a positive error code number otherwise
; 3387 :  *         and -1 in case of internal or API error.
; 3388 :  */
; 3389 : int
; 3390 : xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, const xmlChar *value,
; 3391 : 				 xmlSchemaValPtr *val, xmlNodePtr node) {
; 3392 :     return(xmlSchemaValAtomicType(type, value, val, node, 1,
; 3393 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
; 3394 : }
; 3395 : 
; 3396 : /**
; 3397 :  * xmlSchemaValidatePredefinedType:
; 3398 :  * @type: the predefined type
; 3399 :  * @value: the value to check
; 3400 :  * @val:  the return computed value
; 3401 :  *
; 3402 :  * Check that a value conforms to the lexical space of the predefined type.
; 3403 :  * if true a value is computed and returned in @val.
; 3404 :  *
; 3405 :  * Returns 0 if this validates, a positive error code number otherwise
; 3406 :  *         and -1 in case of internal or API error.
; 3407 :  */
; 3408 : int
; 3409 : xmlSchemaValidatePredefinedType(xmlSchemaTypePtr type, const xmlChar *value,
; 3410 : 	                        xmlSchemaValPtr *val) {
; 3411 :     return(xmlSchemaValPredefTypeNode(type, value, val, NULL));
; 3412 : }
; 3413 : 
; 3414 : /**
; 3415 :  * xmlSchemaCompareDecimals:
; 3416 :  * @x:  a first decimal value
; 3417 :  * @y:  a second decimal value
; 3418 :  *
; 3419 :  * Compare 2 decimals
; 3420 :  *
; 3421 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y and -2 in case of error
; 3422 :  */
; 3423 : static int
; 3424 : xmlSchemaCompareDecimals(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3425 : {
; 3426 :     xmlSchemaValPtr swp;
; 3427 :     int order = 1, integx, integy, dlen;
; 3428 :     unsigned long hi, mi, lo;
; 3429 : 
; 3430 :     /*
; 3431 :      * First test: If x is -ve and not zero
; 3432 :      */
; 3433 :     if ((x->value.decimal.sign) &&
; 3434 : 	((x->value.decimal.lo != 0) ||
; 3435 : 	 (x->value.decimal.mi != 0) ||
; 3436 : 	 (x->value.decimal.hi != 0))) {
; 3437 : 	/*
; 3438 : 	 * Then if y is -ve and not zero reverse the compare
; 3439 : 	 */
; 3440 : 	if ((y->value.decimal.sign) &&
; 3441 : 	    ((y->value.decimal.lo != 0) ||
; 3442 : 	     (y->value.decimal.mi != 0) ||
; 3443 : 	     (y->value.decimal.hi != 0)))
; 3444 : 	    order = -1;
; 3445 : 	/*
; 3446 : 	 * Otherwise (y >= 0) we have the answer
; 3447 : 	 */
; 3448 : 	else
; 3449 : 	    return (-1);
; 3450 :     /*
; 3451 :      * If x is not -ve and y is -ve we have the answer
; 3452 :      */
; 3453 :     } else if ((y->value.decimal.sign) &&
; 3454 : 	       ((y->value.decimal.lo != 0) ||
; 3455 : 		(y->value.decimal.mi != 0) ||
; 3456 : 		(y->value.decimal.hi != 0))) {
; 3457 :         return (1);
; 3458 :     }
; 3459 :     /*
; 3460 :      * If it's not simply determined by a difference in sign,
; 3461 :      * then we need to compare the actual values of the two nums.
; 3462 :      * To do this, we start by looking at the integral parts.
; 3463 :      * If the number of integral digits differ, then we have our
; 3464 :      * answer.
; 3465 :      */
; 3466 :     integx = x->value.decimal.total - x->value.decimal.frac;
; 3467 :     integy = y->value.decimal.total - y->value.decimal.frac;
; 3468 :     /*
; 3469 :     * NOTE: We changed the "total" for values like "0.1"
; 3470 :     *   (or "-0.1" or ".1") to be 1, which was 2 previously.
; 3471 :     *   Therefore the special case, when such values are
; 3472 :     *   compared with 0, needs to be handled separately;
; 3473 :     *   otherwise a zero would be recognized incorrectly as
; 3474 :     *   greater than those values. This has the nice side effect
; 3475 :     *   that we gain an overall optimized comparison with zeroes.
; 3476 :     * Note that a "0" has a "total" of 1 already.
; 3477 :     */
; 3478 :     if (integx == 1) {
; 3479 : 	if (x->value.decimal.lo == 0) {
; 3480 : 	    if (integy != 1)
; 3481 : 		return -order;
; 3482 : 	    else if (y->value.decimal.lo != 0)
; 3483 : 		return -order;
; 3484 : 	    else
; 3485 : 		return(0);
; 3486 : 	}
; 3487 :     }
; 3488 :     if (integy == 1) {
; 3489 : 	if (y->value.decimal.lo == 0) {
; 3490 : 	    if (integx != 1)
; 3491 : 		return order;
; 3492 : 	    else if (x->value.decimal.lo != 0)
; 3493 : 		return order;
; 3494 : 	    else
; 3495 : 		return(0);
; 3496 : 	}
; 3497 :     }
; 3498 : 
; 3499 :     if (integx > integy)
; 3500 : 	return order;
; 3501 :     else if (integy > integx)
; 3502 : 	return -order;
; 3503 : 
; 3504 :     /*
; 3505 :      * If the number of integral digits is the same for both numbers,
; 3506 :      * then things get a little more complicated.  We need to "normalize"
; 3507 :      * the numbers in order to properly compare them.  To do this, we
; 3508 :      * look at the total length of each number (length => number of
; 3509 :      * significant digits), and divide the "shorter" by 10 (decreasing
; 3510 :      * the length) until they are of equal length.
; 3511 :      */
; 3512 :     dlen = x->value.decimal.total - y->value.decimal.total;
; 3513 :     if (dlen < 0) {	/* y has more digits than x */
; 3514 : 	swp = x;
; 3515 : 	hi = y->value.decimal.hi;
; 3516 : 	mi = y->value.decimal.mi;
; 3517 : 	lo = y->value.decimal.lo;
; 3518 : 	dlen = -dlen;
; 3519 : 	order = -order;
; 3520 :     } else {		/* x has more digits than y */
; 3521 : 	swp = y;
; 3522 : 	hi = x->value.decimal.hi;
; 3523 : 	mi = x->value.decimal.mi;
; 3524 : 	lo = x->value.decimal.lo;
; 3525 :     }
; 3526 :     while (dlen > 8) {	/* in effect, right shift by 10**8 */
; 3527 : 	lo = mi;
; 3528 : 	mi = hi;
; 3529 : 	hi = 0;
; 3530 : 	dlen -= 8;
; 3531 :     }
; 3532 :     while (dlen > 0) {
; 3533 : 	unsigned long rem1, rem2;
; 3534 : 	rem1 = (hi % 10) * 100000000L;
; 3535 : 	hi = hi / 10;
; 3536 : 	rem2 = (mi % 10) * 100000000L;
; 3537 : 	mi = (mi + rem1) / 10;
; 3538 : 	lo = (lo + rem2) / 10;
; 3539 : 	dlen--;
; 3540 :     }
; 3541 :     if (hi > swp->value.decimal.hi) {
; 3542 : 	return order;
; 3543 :     } else if (hi == swp->value.decimal.hi) {
; 3544 : 	if (mi > swp->value.decimal.mi) {
; 3545 : 	    return order;
; 3546 : 	} else if (mi == swp->value.decimal.mi) {
; 3547 : 	    if (lo > swp->value.decimal.lo) {
; 3548 : 		return order;
; 3549 : 	    } else if (lo == swp->value.decimal.lo) {
; 3550 : 		if (x->value.decimal.total == y->value.decimal.total) {
; 3551 : 		    return 0;
; 3552 : 		} else {
; 3553 : 		    return order;
; 3554 : 		}
; 3555 : 	    }
; 3556 : 	}
; 3557 :     }
; 3558 :     return -order;
; 3559 : }
; 3560 : 
; 3561 : /**
; 3562 :  * xmlSchemaCompareDurations:
; 3563 :  * @x:  a first duration value
; 3564 :  * @y:  a second duration value
; 3565 :  *
; 3566 :  * Compare 2 durations
; 3567 :  *
; 3568 :  * Returns -1 if x < y, 0 if x == y, 1 if x > y, 2 if x <> y, and -2 in
; 3569 :  * case of error
; 3570 :  */
; 3571 : static int
; 3572 : xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y)
; 3573 : {
; 3574 :     long carry, mon, day;
; 3575 :     double sec;
; 3576 :     int invert = 1;
; 3577 :     long xmon, xday, myear, minday, maxday;
; 3578 :     static const long dayRange [2][12] = {
; 3579 :         { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
; 3580 :         { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
; 3581 : 
; 3582 :     if ((x == NULL) || (y == NULL))
; 3583 :         return -2;
; 3584 : 
; 3585 :     /* months */
; 3586 :     mon = x->value.dur.mon - y->value.dur.mon;
; 3587 : 
; 3588 :     /* seconds */
; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;
; 3590 :     carry = (long)(sec / SECS_PER_DAY);
; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;
; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;
; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {
; 3598 :         if (day == 0)
; 3599 :             if (sec == 0.0)
; 3600 :                 return 0;
; 3601 :             else if (sec < 0.0)
; 3602 :                 return -1;
; 3603 :             else
; 3604 :                 return 1;
; 3605 :         else if (day < 0)
; 3606 :             return -1;
; 3607 :         else
; 3608 :             return 1;
; 3609 :     }
; 3610 : 
; 3611 :     if (mon > 0) {
; 3612 :         if ((day >= 0) && (sec >= 0.0))
; 3613 :             return 1;
; 3614 :         else {
; 3615 :             xmon = mon;
; 3616 :             xday = -day;
; 3617 :         }
; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {
; 3619 :         return -1;
; 3620 :     } else {
; 3621 : 	invert = -1;
; 3622 :         xmon = -mon;
; 3623 :         xday = day;
; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;
; 3627 :     if (myear == 0) {
; 3628 : 	minday = 0;
; 3629 : 	maxday = 0;
; 3630 :     } else {
; 3631 : 	maxday = 366 * ((myear + 3) / 4) +
; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;
; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;
; 3637 :     minday += dayRange[0][xmon];
; 3638 :     maxday += dayRange[1][xmon];
; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))
; 3641 : 	return(0); /* can this really happen ? */
; 3642 :     if (maxday < xday)
; 3643 :         return(-invert);
; 3644 :     if (minday > xday)
; 3645 :         return(invert);
; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;
; 3649 : }
; 3650 : 
; 3651 : /*
; 3652 :  * macros for adding date/times and durations
; 3653 :  */
; 3654 : #define FQUOTIENT(a,b)                  (floor(((double)a/(double)b)))
; 3655 : #define MODULO(a,b)                     (a - FQUOTIENT(a,b) * b)
; 3656 : #define FQUOTIENT_RANGE(a,low,high)     (FQUOTIENT((a-low),(high-low)))
; 3657 : #define MODULO_RANGE(a,low,high)        ((MODULO((a-low),(high-low)))+low)
; 3658 : 
; 3659 : /**
; 3660 :  * xmlSchemaDupVal:
; 3661 :  * @v: the #xmlSchemaValPtr value to duplicate
; 3662 :  *
; 3663 :  * Makes a copy of @v. The calling program is responsible for freeing
; 3664 :  * the returned value.
; 3665 :  *
; 3666 :  * returns a pointer to a duplicated #xmlSchemaValPtr or NULL if error.
; 3667 :  */
; 3668 : static xmlSchemaValPtr
; 3669 : xmlSchemaDupVal (xmlSchemaValPtr v)
; 3670 : {
; 3671 :     xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);
; 3672 :     if (ret == NULL)
; 3673 :         return NULL;

	xor	esi, esi
$LN32@xmlSchemaC:

; 3730 : 	    case XML_SCHEMAS_HEXBINARY:
; 3731 : 		cur = xmlSchemaDupVal(val);
; 3732 : 		if (val->value.hex.str != NULL)
; 3733 : 		    cur->value.hex.str = xmlStrdup(BAD_CAST val->value.hex.str);
; 3734 : 		break;
; 3735 : 	    case XML_SCHEMAS_BASE64BINARY:
; 3736 : 		cur = xmlSchemaDupVal(val);
; 3737 : 		if (val->value.base64.str != NULL)
; 3738 : 		    cur->value.base64.str =
; 3739 :                     xmlStrdup(BAD_CAST val->value.base64.str);
; 3740 : 		break;
; 3741 : 	    default:
; 3742 : 		cur = xmlSchemaDupVal(val);
; 3743 : 		break;
; 3744 : 	}
; 3745 : 	if (ret == NULL)

	test	ebx, ebx
	jne	SHORT $LN17@xmlSchemaC

; 3746 : 	    ret = cur;

	mov	ebx, esi
	jmp	SHORT $LN18@xmlSchemaC
$LN17@xmlSchemaC:

; 3747 : 	else
; 3748 : 	    prev->next = cur;

	mov	eax, DWORD PTR _prev$1$[ebp]
	mov	DWORD PTR [eax+4], esi
$LN18@xmlSchemaC:

; 3749 : 	prev = cur;
; 3750 : 	val = val->next;

	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR _prev$1$[ebp], esi
	test	edi, edi
	jne	$LL2@xmlSchemaC
$LN45@xmlSchemaC:
	pop	edi

; 3751 :     }
; 3752 :     return (ret);
; 3753 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemaC:

; 3698 : 	    case XML_SCHEMAS_ANYTYPE:
; 3699 : 	    case XML_SCHEMAS_IDREFS:
; 3700 : 	    case XML_SCHEMAS_ENTITIES:
; 3701 : 	    case XML_SCHEMAS_NMTOKENS:
; 3702 : 		xmlSchemaFreeValue(ret);

	push	ebx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3703 : 		return (NULL);

	xor	eax, eax
	pop	edi

; 3751 :     }
; 3752 :     return (ret);
; 3753 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlSchemaC:
	DD	$LN7@xmlSchemaC
	DD	$LN6@xmlSchemaC
	DD	$LN9@xmlSchemaC
	DD	$LN12@xmlSchemaC
	DD	$LN16@xmlSchemaC
$LN46@xmlSchemaC:
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	2
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	3
	DB	1
	DB	0
_xmlSchemaCopyValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesWhtsp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xws$ = 12						; size = 4
_y$ = 16						; size = 4
_yws$ = 20						; size = 4
_xmlSchemaCompareValuesWhtsp PROC			; COMDAT

; 4977 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _x$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaC

; 4978 :     if ((x == NULL) || (y == NULL))

	mov	eax, DWORD PTR _y$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaC

; 4980 :     return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,

	push	DWORD PTR _yws$[ebp]
	push	0
	push	eax
	push	DWORD PTR [eax]
	push	DWORD PTR _xws$[ebp]
	push	0
	push	ecx
	push	DWORD PTR [ecx]
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H

; 4981 : 	y, NULL, yws));
; 4982 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 4979 : 	return(-2);

	mov	eax, -2					; fffffffeH

; 4981 : 	y, NULL, yws));
; 4982 : }

	pop	ebp
	ret	0
_xmlSchemaCompareValuesWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewQNameValue
_TEXT	SEGMENT
_namespaceName$ = 8					; size = 4
_localName$ = 12					; size = 4
_xmlSchemaNewQNameValue PROC				; COMDAT

; 1006 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlSchemaN

; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;

	mov	ecx, DWORD PTR _localName$[ebp]

; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 21			; 00000015H

; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;

	mov	DWORD PTR [eax+8], ecx

; 1014 :     val->value.qname.uri = (xmlChar *) namespaceName;

	mov	ecx, DWORD PTR _namespaceName$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1015 :     return(val);
; 1016 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaN:

; 1007 :     xmlSchemaValPtr val;
; 1008 : 
; 1009 :     val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);
; 1010 :     if (val == NULL)
; 1011 : 	return (NULL);

	xor	eax, eax

; 1015 :     return(val);
; 1016 : }

	pop	ebp
	ret	0
_xmlSchemaNewQNameValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewNOTATIONValue
_TEXT	SEGMENT
_name$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSchemaNewNOTATIONValue PROC				; COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlSchemaN

; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;

	mov	ecx, DWORD PTR _name$[ebp]
	xorps	xmm0, xmm0

; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 28			; 0000001cH

; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;

	mov	DWORD PTR [eax+8], ecx

; 988  :     if (ns != NULL)

	mov	ecx, DWORD PTR _ns$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlSchemaN

; 989  : 	val->value.qname.uri = (xmlChar *)ns;

	mov	DWORD PTR [eax+12], ecx

; 990  :     return(val);
; 991  : }

	pop	ebp
	ret	0
$LN8@xmlSchemaN:

; 981  :     xmlSchemaValPtr val;
; 982  : 
; 983  :     val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);
; 984  :     if (val == NULL)
; 985  : 	return (NULL);

	xor	eax, eax
$LN1@xmlSchemaN:

; 990  :     return(val);
; 991  : }

	pop	ebp
	ret	0
_xmlSchemaNewNOTATIONValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewStringValue
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlSchemaNewStringValue PROC				; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN5@xmlSchemaN

; 953  :     xmlSchemaValPtr val;
; 954  : 
; 955  :     if (type != XML_SCHEMAS_STRING)
; 956  : 	return(NULL);
; 957  :     val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 958  :     if (val == NULL) {

	test	eax, eax
	je	SHORT $LN5@xmlSchemaN

; 960  :     }
; 961  :     memset(val, 0, sizeof(xmlSchemaVal));
; 962  :     val->type = type;
; 963  :     val->value.str = (xmlChar *) value;

	mov	ecx, DWORD PTR _value$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+8], ecx

; 964  :     return(val);
; 965  : }

	pop	ebp
	ret	0
$LN5@xmlSchemaN:

; 959  : 	return(NULL);

	xor	eax, eax

; 964  :     return(val);
; 965  : }

	pop	ebp
	ret	0
_xmlSchemaNewStringValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetAsBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSchemaValueGetAsBoolean PROC			; COMDAT

; 930  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 931  :     if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))

	cmp	DWORD PTR [eax], 15			; 0000000fH
	jne	SHORT $LN3@xmlSchemaV

; 933  :     return (val->value.b);

	mov	eax, DWORD PTR [eax+8]

; 934  : }

	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 932  : 	return (0);

	xor	eax, eax

; 934  : }

	pop	ebp
	ret	0
_xmlSchemaValueGetAsBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetAsString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSchemaValueGetAsString PROC				; COMDAT

; 897  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaV

; 898  :     if (val == NULL)
; 899  : 	return (NULL);
; 900  :     switch (val->type) {

	mov	ecx, DWORD PTR [eax]
	dec	ecx
	cmp	ecx, 45					; 0000002dH
	ja	SHORT $LN6@xmlSchemaV
	movzx	ecx, BYTE PTR $LN8@xmlSchemaV[ecx]
	jmp	DWORD PTR $LN10@xmlSchemaV[ecx*4]
$LN5@xmlSchemaV:

; 901  : 	case XML_SCHEMAS_STRING:
; 902  : 	case XML_SCHEMAS_NORMSTRING:
; 903  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 904  : 	case XML_SCHEMAS_TOKEN:
; 905  :         case XML_SCHEMAS_LANGUAGE:
; 906  :         case XML_SCHEMAS_NMTOKEN:
; 907  :         case XML_SCHEMAS_NAME:
; 908  :         case XML_SCHEMAS_NCNAME:
; 909  :         case XML_SCHEMAS_ID:
; 910  :         case XML_SCHEMAS_IDREF:
; 911  :         case XML_SCHEMAS_ENTITY:
; 912  :         case XML_SCHEMAS_ANYURI:
; 913  : 	    return (BAD_CAST val->value.str);

	mov	eax, DWORD PTR [eax+8]

; 918  : }

	pop	ebp
	ret	0
$LN6@xmlSchemaV:

; 914  : 	default:
; 915  : 	    break;
; 916  :     }
; 917  :     return (NULL);

	xor	eax, eax

; 918  : }

	pop	ebp
	ret	0
	npad	1
$LN10@xmlSchemaV:
	DD	$LN5@xmlSchemaV
	DD	$LN6@xmlSchemaV
$LN8@xmlSchemaV:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlSchemaValueGetAsString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetNext
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlSchemaValueGetNext PROC				; COMDAT

; 879  : xmlSchemaValueGetNext(xmlSchemaValPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaV

; 884  : }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 880  : 
; 881  :     if (cur == NULL)
; 882  : 	return (NULL);
; 883  :     return (cur->next);

	mov	eax, DWORD PTR [eax+4]

; 884  : }

	pop	ebp
	ret	0
_xmlSchemaValueGetNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueAppend
_TEXT	SEGMENT
_prev$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlSchemaValueAppend PROC				; COMDAT

; 861  : xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _prev$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemaV

; 862  : 
; 863  :     if ((prev == NULL) || (cur == NULL))

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSchemaV

; 865  :     prev->next = cur;

	mov	DWORD PTR [ecx+4], eax

; 866  :     return (0);

	xor	eax, eax

; 867  : }

	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 864  : 	return (-1);

	or	eax, -1

; 867  : }

	pop	ebp
	ret	0
_xmlSchemaValueAppend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetCanonValueWhtsp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_retValue$ = 12						; size = 4
_ws$ = 16						; size = 4
_xmlSchemaGetCanonValueWhtsp PROC			; COMDAT

; 6107 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _retValue$[ebp]
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN5@xmlSchemaG

; 6108 :     if ((retValue == NULL) || (val == NULL))

	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	$LN5@xmlSchemaG

; 6110 :     if ((ws == XML_SCHEMA_WHITESPACE_UNKNOWN) ||

	mov	eax, DWORD PTR _ws$[ebp]
	test	eax, eax
	je	$LN5@xmlSchemaG
	cmp	eax, 3
	jg	$LN5@xmlSchemaG

; 6111 : 	(ws > XML_SCHEMA_WHITESPACE_COLLAPSE))
; 6112 : 	return (-1);
; 6113 : 
; 6114 :     *retValue = NULL;

	mov	DWORD PTR [esi], 0

; 6115 :     switch (val->type) {

	mov	ecx, DWORD PTR [edi]
	sub	ecx, 1
	je	SHORT $LN8@xmlSchemaG
	sub	ecx, 1
	je	SHORT $LN15@xmlSchemaG

; 6132 : 		else
; 6133 : 		    *retValue = xmlSchemaWhiteSpaceReplace(val->value.str);
; 6134 : 		if ((*retValue) == NULL)
; 6135 : 		    *retValue = BAD_CAST xmlStrdup(val->value.str);
; 6136 : 	    }
; 6137 : 	    break;
; 6138 : 	default:
; 6139 : 	    return (xmlSchemaGetCanonValue(val, retValue));

	push	esi
	push	edi
	call	_xmlSchemaGetCanonValue
	add	esp, 8
	pop	edi

; 6142 : }

	pop	esi
	pop	ebp
	ret	0
$LN15@xmlSchemaG:

; 6123 : 	    if ((*retValue) == NULL)
; 6124 : 		*retValue = BAD_CAST xmlStrdup(val->value.str);
; 6125 : 	    break;
; 6126 : 	case XML_SCHEMAS_NORMSTRING:
; 6127 : 	    if (val->value.str == NULL)

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	jne	SHORT $LN16@xmlSchemaG

; 6128 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@

; 6140 :     }
; 6141 :     return (0);

	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	pop	edi

; 6142 : }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlSchemaG:

; 6129 : 	    else {
; 6130 : 		if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	push	ecx
	cmp	eax, 3
	jne	SHORT $LN18@xmlSchemaG

; 6131 : 		    *retValue = xmlSchemaCollapseString(val->value.str);

	call	_xmlSchemaCollapseString
	jmp	SHORT $LN25@xmlSchemaG
$LN8@xmlSchemaG:

; 6116 : 	case XML_SCHEMAS_STRING:
; 6117 : 	    if (val->value.str == NULL)

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	jne	SHORT $LN9@xmlSchemaG

; 6118 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	jmp	SHORT $LN25@xmlSchemaG
$LN9@xmlSchemaG:

; 6119 : 	    else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	eax, 3
	jne	SHORT $LN11@xmlSchemaG

; 6120 : 		*retValue = xmlSchemaCollapseString(val->value.str);

	push	ecx
	call	_xmlSchemaCollapseString
	jmp	SHORT $LN25@xmlSchemaG
$LN11@xmlSchemaG:

; 6121 : 	    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	eax, 2
	jne	SHORT $LN23@xmlSchemaG

; 6122 : 		*retValue = xmlSchemaWhiteSpaceReplace(val->value.str);

	push	ecx
$LN18@xmlSchemaG:

; 6140 :     }
; 6141 :     return (0);

	call	_xmlSchemaWhiteSpaceReplace
$LN25@xmlSchemaG:
	add	esp, 4
	mov	DWORD PTR [esi], eax
	test	eax, eax
	jne	SHORT $LN14@xmlSchemaG
$LN23@xmlSchemaG:
	push	DWORD PTR [edi+8]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax
$LN14@xmlSchemaG:
	pop	edi
	xor	eax, eax

; 6142 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlSchemaG:
	pop	edi

; 6109 : 	return (-1);

	or	eax, -1

; 6142 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaGetCanonValueWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetCanonValue
_TEXT	SEGMENT
_buf$1 = -136						; size = 100
_buf$2 = -88						; size = 50
_buf$3 = -76						; size = 40
_buf$4 = -72						; size = 35
_buf$5 = -68						; size = 30
_buf$6 = -68						; size = 30
_buf$7 = -68						; size = 30
_buf$8 = -68						; size = 30
_dec$9 = -56						; size = 20
_dec$10 = -56						; size = 20
_sec$1$ = -36						; size = 8
tv1448 = -36						; size = 8
tv1442 = -36						; size = 8
tv1465 = -28						; size = 8
tv1459 = -28						; size = 8
_hour$1$ = -24						; size = 4
_dec$1$ = -24						; size = 4
_left$2$ = -20						; size = 8
$T11 = -16						; size = 4
tv1499 = -12						; size = 8
tv1493 = -12						; size = 8
tv1483 = -12						; size = 8
tv1477 = -12						; size = 8
tv1314 = -8						; size = 4
tv1302 = -8						; size = 4
tv1305 = -4						; size = 4
_bufsize$1$ = -4					; size = 4
_val$ = 8						; size = 4
tv1310 = 12						; size = 4
tv1303 = 12						; size = 4
_diff$1$ = 12						; size = 4
_retValue$ = 12						; size = 4
_xmlSchemaGetCanonValue PROC				; COMDAT

; 5691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _retValue$[ebp]
	test	edi, edi
	je	$LN7@xmlSchemaG

; 5692 :     if ((retValue == NULL) || (val == NULL))

	mov	esi, DWORD PTR _val$[ebp]
	test	esi, esi
	je	$LN7@xmlSchemaG

; 5694 :     *retValue = NULL;

	mov	DWORD PTR [edi], 0

; 5695 :     switch (val->type) {

	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	eax, 43					; 0000002bH
	ja	$LN89@xmlSchemaG
	movzx	eax, BYTE PTR $LN96@xmlSchemaG[eax]
	jmp	DWORD PTR $LN106@xmlSchemaG[eax*4]
$LN8@xmlSchemaG:

; 5696 : 	case XML_SCHEMAS_STRING:
; 5697 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@@
	test	eax, eax
	cmovne	ecx, eax

; 5698 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");
; 5699 : 	    else
; 5700 : 		*retValue =
; 5701 : 		    BAD_CAST xmlStrdup((const xmlChar *) val->value.str);
; 5702 : 	    break;

	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN11@xmlSchemaG:

; 5703 : 	case XML_SCHEMAS_NORMSTRING:
; 5704 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN12@xmlSchemaG

; 5705 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN12@xmlSchemaG:

; 5706 : 	    else {
; 5707 : 		*retValue = xmlSchemaWhiteSpaceReplace(

	push	eax
	call	_xmlSchemaWhiteSpaceReplace
$LN103@xmlSchemaG:

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	add	esp, 4
	mov	DWORD PTR [edi], eax
	test	eax, eax
	jne	$LN2@xmlSchemaG
$LN85@xmlSchemaG:
	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN15@xmlSchemaG:

; 5708 : 		    (const xmlChar *) val->value.str);
; 5709 : 		if ((*retValue) == NULL)
; 5710 : 		    *retValue = BAD_CAST xmlStrdup(
; 5711 : 			(const xmlChar *) val->value.str);
; 5712 : 	    }
; 5713 : 	    break;
; 5714 : 	case XML_SCHEMAS_TOKEN:
; 5715 : 	case XML_SCHEMAS_LANGUAGE:
; 5716 : 	case XML_SCHEMAS_NMTOKEN:
; 5717 : 	case XML_SCHEMAS_NAME:
; 5718 : 	case XML_SCHEMAS_NCNAME:
; 5719 : 	case XML_SCHEMAS_ID:
; 5720 : 	case XML_SCHEMAS_IDREF:
; 5721 : 	case XML_SCHEMAS_ENTITY:
; 5722 : 	case XML_SCHEMAS_NOTATION: /* Unclear */
; 5723 : 	case XML_SCHEMAS_ANYURI:   /* Unclear */
; 5724 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN7@xmlSchemaG

; 5725 : 		return (-1);
; 5726 : 	    *retValue =

	push	eax
	call	_xmlSchemaCollapseString

; 5727 : 		BAD_CAST xmlSchemaCollapseString(BAD_CAST val->value.str);
; 5728 : 	    if (*retValue == NULL)
; 5729 : 		*retValue =
; 5730 : 		    BAD_CAST xmlStrdup((const xmlChar *) val->value.str);
; 5731 : 	    break;

	jmp	SHORT $LN103@xmlSchemaG
$LN18@xmlSchemaG:

; 5732 : 	case XML_SCHEMAS_QNAME:
; 5733 : 	    /* TODO: Unclear in XML Schema 1.0. */
; 5734 : 	    if (val->value.qname.uri == NULL) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN19@xmlSchemaG

; 5735 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.qname.name);

	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 5736 : 		return (0);

	xor	eax, eax
	pop	edi

; 6089 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSchemaG:

; 5737 : 	    } else {
; 5738 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup
	mov	DWORD PTR [edi], eax

; 5739 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlStrcat

; 5740 : 		    BAD_CAST val->value.qname.uri);
; 5741 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	push	eax
	mov	DWORD PTR [edi], eax
	call	_xmlStrcat
	mov	DWORD PTR [edi], eax

; 5742 : 		    BAD_CAST "}");
; 5743 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlStrcat
	add	esp, 28					; 0000001cH

; 5744 : 		    BAD_CAST val->value.qname.uri);
; 5745 : 	    }
; 5746 : 	    break;

	jmp	$LN100@xmlSchemaG
$LN21@xmlSchemaG:

; 5747 : 	case XML_SCHEMAS_DECIMAL:
; 5748 : 	    /*
; 5749 : 	    * TODO: Lookout for a more simple implementation.
; 5750 : 	    */
; 5751 : 	    if ((val->value.decimal.total == 1) &&

	cmp	BYTE PTR [esi+25], 1
	jne	SHORT $LN22@xmlSchemaG
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN22@xmlSchemaG

; 5752 : 		(val->value.decimal.lo == 0)) {
; 5753 : 		*retValue = xmlStrdup(BAD_CAST "0.0");

	push	OFFSET ??_C@_03MDAFIFFL@0?40@
	call	_xmlStrdup
	mov	ecx, eax
	add	esp, 4

; 5814 : 		}
; 5815 : 		*retValue = BAD_CAST buf;
; 5816 : 	    }
; 5817 : 	    break;

	mov	DWORD PTR [edi], ecx
	jmp	$LN2@xmlSchemaG
$LN22@xmlSchemaG:

; 5754 : 	    } else {
; 5755 : 		xmlSchemaValDecimal dec = val->value.decimal;

	mov	ecx, DWORD PTR [esi+24]

; 5756 : 		int bufsize;
; 5757 : 		char *buf = NULL, *offs;
; 5758 : 
; 5759 : 		/* Add room for the decimal point as well. */
; 5760 : 		bufsize = dec.total + 2;

	mov	eax, ecx
	movups	xmm0, XMMWORD PTR [esi+8]

; 5761 : 		if (dec.sign)

	mov	edx, ecx
	shr	eax, 8
	and	edx, 1
	movzx	eax, al
	mov	DWORD PTR tv1314[ebp], edx

; 5762 : 		    bufsize++;
; 5763 : 		/* Add room for leading/trailing zero. */
; 5764 : 		if ((dec.frac == 0) || (dec.frac == dec.total))

	add	edx, 2
	add	edx, eax
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	mov	DWORD PTR _diff$1$[ebp], eax
	movups	XMMWORD PTR _dec$10[ebp], xmm0
	mov	DWORD PTR _bufsize$1$[ebp], edx
	mov	DWORD PTR _dec$1$[ebp], ecx
	je	SHORT $LN26@xmlSchemaG
	cmp	ecx, eax
	jne	SHORT $LN25@xmlSchemaG
$LN26@xmlSchemaG:

; 5765 : 		    bufsize++;

	inc	edx
	mov	DWORD PTR _bufsize$1$[ebp], edx
$LN25@xmlSchemaG:

; 5766 : 		buf = xmlMalloc(bufsize);

	push	edx
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T11[ebp], ecx

; 5767 : 		if (buf == NULL)

	test	ecx, ecx
	je	$LN7@xmlSchemaG

; 5768 : 		    return(-1);
; 5769 : 		offs = buf;
; 5770 : 		if (dec.sign)

	cmp	DWORD PTR tv1314[ebp], 0
	mov	esi, ecx
	je	SHORT $LN28@xmlSchemaG

; 5771 : 		    *offs++ = '-';

	mov	BYTE PTR [ecx], 45			; 0000002dH
	lea	esi, DWORD PTR [ecx+1]
$LN28@xmlSchemaG:

; 5772 : 		if (dec.frac == dec.total) {

	mov	eax, DWORD PTR _dec$1$[ebp]
	cmp	eax, DWORD PTR _diff$1$[ebp]
	jne	SHORT $LN29@xmlSchemaG

; 5773 : 		    *offs++ = '0';

	mov	WORD PTR [esi], 11824			; 00002e30H

; 5774 : 		    *offs++ = '.';

	add	esi, 2
$LN29@xmlSchemaG:

; 5775 : 		}
; 5776 : 		if (dec.hi != 0)

	mov	eax, DWORD PTR _dec$10[ebp+8]
	sub	ecx, esi
	add	ecx, DWORD PTR _bufsize$1$[ebp]
	push	DWORD PTR _dec$10[ebp]
	test	eax, eax
	je	SHORT $LN30@xmlSchemaG

; 5777 : 		    snprintf(offs, bufsize - (offs - buf),

	push	DWORD PTR _dec$10[ebp+4]
	push	eax
	push	OFFSET ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
	push	ecx
	push	esi
	call	_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN33@xmlSchemaG
$LN30@xmlSchemaG:

; 5778 : 			"%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5779 : 		else if (dec.mi != 0)

	mov	eax, DWORD PTR _dec$10[ebp+4]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaG

; 5780 : 		    snprintf(offs, bufsize - (offs - buf),

	push	eax
	push	OFFSET ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
	push	ecx
	push	esi
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN33@xmlSchemaG
$LN32@xmlSchemaG:

; 5781 : 			"%lu%lu", dec.mi, dec.lo);
; 5782 : 		else
; 5783 : 		    snprintf(offs, bufsize - (offs - buf),

	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	push	ecx
	push	esi
	call	_snprintf
	add	esp, 16					; 00000010H
$LN33@xmlSchemaG:

; 5784 : 			"%lu", dec.lo);
; 5785 : 
; 5786 : 		if (dec.frac != 0) {

	mov	eax, DWORD PTR _dec$1$[ebp]
	test	eax, eax
	je	SHORT $LN34@xmlSchemaG

; 5787 : 		    if (dec.frac != dec.total) {

	mov	ecx, DWORD PTR _diff$1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN36@xmlSchemaG

; 5788 : 			int diff = dec.total - dec.frac;

	sub	ecx, eax

; 5789 : 			/*
; 5790 : 			* Insert the decimal point.
; 5791 : 			*/
; 5792 : 			memmove(offs + diff + 1, offs + diff, dec.frac +1);

	inc	eax
	add	esi, ecx
	push	eax
	push	esi
	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 5793 : 			offs[diff] = '.';

	mov	BYTE PTR [esi], 46			; 0000002eH
$LN99@xmlSchemaG:

; 5814 : 		}
; 5815 : 		*retValue = BAD_CAST buf;
; 5816 : 	    }
; 5817 : 	    break;

	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR [edi], ecx
	jmp	$LN2@xmlSchemaG
$LN36@xmlSchemaG:

; 5794 : 		    } else {
; 5795 : 			unsigned int i = 0;

	xor	eax, eax

; 5796 : 			/*
; 5797 : 			* Insert missing zeroes behind the decimal point.
; 5798 : 			*/
; 5799 : 			while (*(offs + i) != 0)

	cmp	BYTE PTR [esi], al
	je	SHORT $LN5@xmlSchemaG
$LL4@xmlSchemaG:

; 5800 : 			    i++;

	inc	eax
	cmp	BYTE PTR [eax+esi], 0
	jne	SHORT $LL4@xmlSchemaG
$LN5@xmlSchemaG:

; 5801 : 			if (i < dec.total) {

	cmp	eax, ecx
	jae	SHORT $LN99@xmlSchemaG

; 5802 : 			    memmove(offs + (dec.total - i), offs, i +1);

	sub	ecx, eax
	inc	eax
	push	eax
	push	esi
	mov	DWORD PTR _diff$1$[ebp], ecx
	lea	eax, DWORD PTR [ecx+esi]
	push	eax
	call	_memmove

; 5803 : 			    memset(offs, '0', dec.total - i);

	push	DWORD PTR _diff$1$[ebp]
	push	48					; 00000030H
	push	esi
	call	_memset

; 5814 : 		}
; 5815 : 		*retValue = BAD_CAST buf;
; 5816 : 	    }
; 5817 : 	    break;

	mov	ecx, DWORD PTR $T11[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi], ecx
	jmp	$LN2@xmlSchemaG
$LN34@xmlSchemaG:

; 5804 : 			}
; 5805 : 		    }
; 5806 : 		} else {
; 5807 : 		    /*
; 5808 : 		    * Append decimal point and zero.
; 5809 : 		    */
; 5810 : 		    offs = buf + bufsize - 1;

	mov	ecx, DWORD PTR $T11[ebp]
	mov	eax, DWORD PTR _bufsize$1$[ebp]

; 5811 : 		    *offs-- = 0;
; 5812 : 		    *offs-- = '0';

	mov	WORD PTR [eax+ecx-2], 48		; 00000030H

; 5813 : 		    *offs-- = '.';

	mov	BYTE PTR [eax+ecx-3], 46		; 0000002eH

; 5814 : 		}
; 5815 : 		*retValue = BAD_CAST buf;
; 5816 : 	    }
; 5817 : 	    break;

	mov	DWORD PTR [edi], ecx
	jmp	$LN2@xmlSchemaG
$LN39@xmlSchemaG:

; 5818 : 	case XML_SCHEMAS_INTEGER:
; 5819 :         case XML_SCHEMAS_PINTEGER:
; 5820 :         case XML_SCHEMAS_NPINTEGER:
; 5821 :         case XML_SCHEMAS_NINTEGER:
; 5822 :         case XML_SCHEMAS_NNINTEGER:
; 5823 : 	case XML_SCHEMAS_LONG:
; 5824 :         case XML_SCHEMAS_BYTE:
; 5825 :         case XML_SCHEMAS_SHORT:
; 5826 :         case XML_SCHEMAS_INT:
; 5827 : 	case XML_SCHEMAS_UINT:
; 5828 :         case XML_SCHEMAS_ULONG:
; 5829 :         case XML_SCHEMAS_USHORT:
; 5830 :         case XML_SCHEMAS_UBYTE:
; 5831 : 	    if ((val->value.decimal.total == 1) &&

	cmp	BYTE PTR [esi+25], 1
	jne	SHORT $LN40@xmlSchemaG
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN40@xmlSchemaG

; 5832 : 		(val->value.decimal.lo == 0))
; 5833 : 		*retValue = xmlStrdup(BAD_CAST "0");

	push	OFFSET ??_C@_01GBGANLPD@0@

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN40@xmlSchemaG:

; 5834 : 	    else {
; 5835 : 		xmlSchemaValDecimal dec = val->value.decimal;

	mov	eax, DWORD PTR [esi+24]

; 5836 : 		int bufsize = dec.total + 1;
; 5837 : 
; 5838 : 		/* Add room for the decimal point as well. */
; 5839 : 		if (dec.sign)

	mov	ecx, eax
	movups	xmm0, XMMWORD PTR [esi+8]
	and	ecx, 1
	shr	eax, 8
	movzx	eax, al
	movups	XMMWORD PTR _dec$9[ebp], xmm0
	mov	DWORD PTR tv1310[ebp], ecx

; 5840 : 		    bufsize++;
; 5841 : 		*retValue = xmlMalloc(bufsize);

	lea	esi, DWORD PTR [ecx+1]
	add	esi, eax
	push	esi
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 5842 : 		if (*retValue == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaG

; 5843 : 		    return(-1);
; 5844 : 		if (dec.hi != 0) {

	mov	ecx, DWORD PTR _dec$9[ebp+8]
	push	DWORD PTR _dec$9[ebp]
	test	ecx, ecx
	je	SHORT $LN44@xmlSchemaG

; 5845 : 		    if (dec.sign)

	cmp	DWORD PTR tv1310[ebp], 0
	push	DWORD PTR _dec$9[ebp+4]
	push	ecx
	je	SHORT $LN46@xmlSchemaG

; 5846 : 			snprintf((char *) *retValue, bufsize,

	push	OFFSET ??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H
	jmp	$LN2@xmlSchemaG
$LN46@xmlSchemaG:

; 5847 : 			    "-%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5848 : 		    else
; 5849 : 			snprintf((char *) *retValue, bufsize,

	push	OFFSET ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H

; 5850 : 			    "%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5851 : 		} else if (dec.mi != 0) {

	jmp	$LN2@xmlSchemaG
$LN44@xmlSchemaG:
	mov	ecx, DWORD PTR _dec$9[ebp+4]
	test	ecx, ecx
	je	SHORT $LN48@xmlSchemaG

; 5852 : 		    if (dec.sign)

	cmp	DWORD PTR tv1310[ebp], 0
	push	ecx
	je	SHORT $LN50@xmlSchemaG

; 5853 : 			snprintf((char *) *retValue, bufsize,

	push	OFFSET ??_C@_07KPEGABEP@?9?$CFlu?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	$LN2@xmlSchemaG
$LN50@xmlSchemaG:

; 5854 : 			    "-%lu%lu", dec.mi, dec.lo);
; 5855 : 		    else
; 5856 : 			snprintf((char *) *retValue, bufsize,

	push	OFFSET ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 5857 : 			    "%lu%lu", dec.mi, dec.lo);
; 5858 : 		} else {

	jmp	$LN2@xmlSchemaG
$LN48@xmlSchemaG:

; 5859 : 		    if (dec.sign)

	cmp	DWORD PTR tv1310[ebp], 0
	je	SHORT $LN52@xmlSchemaG

; 5860 : 			snprintf((char *) *retValue, bufsize, "-%lu", dec.lo);

	push	OFFSET ??_C@_04IEOFADKM@?9?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	$LN2@xmlSchemaG
$LN52@xmlSchemaG:

; 5861 : 		    else
; 5862 : 			snprintf((char *) *retValue, bufsize, "%lu", dec.lo);

	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	push	esi
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 5863 : 		}
; 5864 : 	    }
; 5865 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN54@xmlSchemaG:

; 5866 : 	case XML_SCHEMAS_BOOLEAN:
; 5867 : 	    if (val->value.b)
; 5868 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "true");
; 5869 : 	    else
; 5870 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "false");
; 5871 : 	    break;

	cmp	DWORD PTR [esi+8], 0
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true@
	mov	eax, OFFSET ??_C@_05LAPONLG@false@
	cmovne	eax, ecx
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN57@xmlSchemaG:

; 5872 : 	case XML_SCHEMAS_DURATION: {
; 5873 : 		char buf[100];
; 5874 : 		unsigned long year;
; 5875 : 		unsigned long mon, day, hour = 0, min = 0;
; 5876 : 		double sec = 0, left;
; 5877 : 
; 5878 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5879 : 		/*
; 5880 : 		* TODO: This results in a normalized output of the value
; 5881 : 		* - which is NOT conformant to the spec -
; 5882 : 		* since the exact values of each property are not
; 5883 : 		* recoverable. Think about extending the structure to
; 5884 : 		* provide a field for every property.
; 5885 : 		*/
; 5886 : 		year = (unsigned long) FQUOTIENT(labs(val->value.dur.mon), 12);

	mov	eax, DWORD PTR [esi+8]
	xorps	xmm0, xmm0
	cdq
	sub	esp, 8
	xor	eax, edx
	movsd	QWORD PTR _sec$1$[ebp], xmm0
	sub	eax, edx
	mov	DWORD PTR _hour$1$[ebp], 0
	mov	DWORD PTR tv1303[ebp], eax
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv1499[ebp], xmm0
	fld	QWORD PTR tv1499[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv1493[ebp]
	movsd	xmm0, QWORD PTR tv1493[ebp]
	call	__dtoui3

; 5887 : 		mon = labs(val->value.dur.mon) - 12 * year;
; 5888 : 
; 5889 : 		day = (unsigned long) FQUOTIENT(fabs(val->value.dur.sec), 86400);

	movsd	xmm0, QWORD PTR [esi+16]
	sub	esp, 8
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR _left$2$[ebp], xmm0
	divsd	xmm0, QWORD PTR __real@40f5180000000000
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR tv1305[ebp], eax
	shl	ecx, 2
	sub	DWORD PTR tv1303[ebp], ecx
	movsd	QWORD PTR tv1483[ebp], xmm0
	fld	QWORD PTR tv1483[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv1477[ebp]
	movsd	xmm0, QWORD PTR tv1477[ebp]
	call	__dtoui3

; 5890 : 		left = fabs(val->value.dur.sec) - day * 86400;

	movsd	xmm1, QWORD PTR _left$2$[ebp]
	imul	ecx, eax, 86400
	mov	DWORD PTR tv1302[ebp], eax
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0

; 5891 : 		if (left > 0) {

	comisd	xmm1, xmm0
	movsd	QWORD PTR _left$2$[ebp], xmm1
	jbe	$LN98@xmlSchemaG

; 5892 : 		    hour = (unsigned long) FQUOTIENT(left, 3600);

	movaps	xmm0, xmm1
	sub	esp, 8
	divsd	xmm0, QWORD PTR __real@40ac200000000000
	movsd	QWORD PTR tv1465[ebp], xmm0
	fld	QWORD PTR tv1465[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv1459[ebp]
	movsd	xmm0, QWORD PTR tv1459[ebp]
	call	__dtoui3

; 5893 : 		    left = left - (hour * 3600);

	movsd	xmm1, QWORD PTR _left$2$[ebp]
	imul	ecx, eax, 3600
	mov	DWORD PTR _hour$1$[ebp], eax
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0

; 5894 : 		    if (left > 0) {

	comisd	xmm1, xmm0
	movsd	QWORD PTR _left$2$[ebp], xmm1
	jbe	SHORT $LN98@xmlSchemaG

; 5895 : 			min = (unsigned long) FQUOTIENT(left, 60);

	movaps	xmm0, xmm1
	sub	esp, 8
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv1448[ebp], xmm0
	fld	QWORD PTR tv1448[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv1442[ebp]
	movsd	xmm0, QWORD PTR tv1442[ebp]
	call	__dtoui3

; 5896 : 			sec = left - (min * 60);

	movsd	xmm1, QWORD PTR _left$2$[ebp]
	mov	edx, eax
	mov	ecx, edx
	shl	ecx, 4
	sub	ecx, edx
	shl	ecx, 2
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	subsd	xmm1, xmm0
	xorps	xmm0, xmm0
	jmp	SHORT $LN59@xmlSchemaG
$LN98@xmlSchemaG:

; 5897 : 		    }
; 5898 : 		}
; 5899 : 		if ((val->value.dur.mon < 0) || (val->value.dur.sec < 0))

	movsd	xmm1, QWORD PTR _sec$1$[ebp]
	xor	edx, edx
$LN59@xmlSchemaG:
	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN62@xmlSchemaG
	comisd	xmm0, QWORD PTR [esi+16]

; 5901 : 			year, mon, day, hour, min, sec);
; 5902 : 		else
; 5903 : 		    snprintf(buf, 100, "-P%luY%luM%luDT%luH%luM%.14gS",

	mov	eax, OFFSET ??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
	jbe	SHORT $LN61@xmlSchemaG
$LN62@xmlSchemaG:

; 5900 : 		    snprintf(buf, 100, "P%luY%luM%luDT%luH%luM%.14gS",

	mov	eax, OFFSET ??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
$LN61@xmlSchemaG:

; 5904 : 			year, mon, day, hour, min, sec);
; 5905 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	push	edx
	push	DWORD PTR _hour$1$[ebp]
	push	DWORD PTR tv1302[ebp]
	push	DWORD PTR tv1303[ebp]
	push	DWORD PTR tv1305[ebp]
	push	eax
	lea	eax, DWORD PTR _buf$1[ebp]
	push	100					; 00000064H
	push	eax
	call	_snprintf
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 44					; 0000002cH

; 5906 : 	    }
; 5907 : 	    break;

	jmp	$LN100@xmlSchemaG
$LN63@xmlSchemaG:

; 5908 : 	case XML_SCHEMAS_GYEAR: {
; 5909 : 		char buf[30];
; 5910 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5911 : 		/* TODO: What to do with the timezone? */
; 5912 : 		snprintf(buf, 30, "%04ld", val->value.date.year);

	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _buf$8[ebp]
	push	OFFSET ??_C@_05IHGIIBEO@?$CF04ld@
	push	30					; 0000001eH
	push	eax
	call	_snprintf

; 5913 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$8[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 20					; 00000014H

; 5914 : 	    }
; 5915 : 	    break;

	jmp	$LN100@xmlSchemaG
$LN64@xmlSchemaG:

; 5916 : 	case XML_SCHEMAS_GMONTH: {
; 5917 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5918 : 		/* TODO: What to do with the timezone? */
; 5919 : 		*retValue = xmlMalloc(6);

	push	6
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 5920 : 		if (*retValue == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaG

; 5921 : 		    return(-1);
; 5922 : 		snprintf((char *) *retValue, 6, "--%02u",

	mov	ecx, DWORD PTR [esi+12]
	and	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET ??_C@_06PLGGIKKN@?9?9?$CF02u@
	push	6
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 5923 : 		    val->value.date.mon);
; 5924 : 	    }
; 5925 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN66@xmlSchemaG:

; 5926 :         case XML_SCHEMAS_GDAY: {
; 5927 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5928 : 		/* TODO: What to do with the timezone? */
; 5929 : 		*retValue = xmlMalloc(6);

	push	6
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 5930 : 		if (*retValue == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaG

; 5931 : 		    return(-1);
; 5932 : 		snprintf((char *) *retValue, 6, "---%02u",

	mov	ecx, DWORD PTR [esi+12]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	push	ecx
	push	OFFSET ??_C@_07GBFLPNDN@?9?9?9?$CF02u@
	push	6
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 5933 : 		    val->value.date.day);
; 5934 : 	    }
; 5935 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN68@xmlSchemaG:

; 5936 :         case XML_SCHEMAS_GMONTHDAY: {
; 5937 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5938 : 		/* TODO: What to do with the timezone? */
; 5939 : 		*retValue = xmlMalloc(8);

	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 5940 : 		if (*retValue == NULL)

	test	eax, eax
	je	$LN7@xmlSchemaG

; 5941 : 		    return(-1);
; 5942 : 		snprintf((char *) *retValue, 8, "--%02u-%02u",

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, edx
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	and	ecx, 31					; 0000001fH
	push	ecx
	push	edx
	push	OFFSET ??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@
	push	8
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 5943 : 		    val->value.date.mon, val->value.date.day);
; 5944 : 	    }
; 5945 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN70@xmlSchemaG:

; 5946 :         case XML_SCHEMAS_GYEARMONTH: {
; 5947 : 		char buf[35];
; 5948 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5949 : 		/* TODO: What to do with the timezone? */
; 5950 : 		if (val->value.date.year < 0)

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+8]
	and	ecx, 15					; 0000000fH
	push	ecx
	test	eax, eax
	jns	SHORT $LN71@xmlSchemaG

; 5951 : 		    snprintf(buf, 35, "-%04ld-%02u",

	cdq
	xor	eax, edx
	sub	eax, edx
	push	eax
	push	OFFSET ??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@
	jmp	SHORT $LN101@xmlSchemaG
$LN71@xmlSchemaG:

; 5952 : 			labs(val->value.date.year),
; 5953 : 			val->value.date.mon);
; 5954 : 		else
; 5955 : 		    snprintf(buf, 35, "%04ld-%02u",

	push	eax
	push	OFFSET ??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@
$LN101@xmlSchemaG:

; 5956 : 			val->value.date.year, val->value.date.mon);
; 5957 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$4[ebp]
	push	35					; 00000023H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR _buf$4[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN73@xmlSchemaG:

; 5958 : 	    }
; 5959 : 	    break;
; 5960 : 	case XML_SCHEMAS_TIME:
; 5961 : 	    {
; 5962 : 		char buf[30];
; 5963 : 
; 5964 : 		if (val->value.date.tz_flag) {

	sub	esp, 8
	test	BYTE PTR [esi+24], 1
	je	SHORT $LN74@xmlSchemaG

; 5965 : 		    xmlSchemaValPtr norm;
; 5966 : 
; 5967 : 		    norm = xmlSchemaDateNormalize(val, 0);

	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	call	_xmlSchemaDateNormalize
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 5968 : 		    if (norm == NULL)

	test	esi, esi
	je	$LN7@xmlSchemaG

; 5969 : 			return (-1);
; 5970 : 		    /*
; 5971 : 		    * TODO: Check if "%.14g" is portable.
; 5972 : 		    */
; 5973 : 		    snprintf(buf, 30,

	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR _buf$7[ebp]
	movsd	xmm0, QWORD PTR [esi+16]
	sub	esp, 8
	mov	ecx, edx
	shr	edx, 9
	shr	ecx, 14					; 0000000eH
	and	edx, 31					; 0000001fH
	and	ecx, 63					; 0000003fH
	movsd	QWORD PTR [esp], xmm0
	push	ecx
	push	edx
	push	OFFSET ??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@
	push	30					; 0000001eH
	push	eax
	call	_snprintf

; 5974 : 			"%02u:%02u:%02.14gZ",
; 5975 : 			norm->value.date.hour,
; 5976 : 			norm->value.date.min,
; 5977 : 			norm->value.date.sec);
; 5978 : 		    xmlSchemaFreeValue(norm);

	push	esi
	call	_xmlSchemaFreeValue
	add	esp, 32					; 00000020H

; 5981 : 			"%02u:%02u:%02.14g",
; 5982 : 			val->value.date.hour,
; 5983 : 			val->value.date.min,
; 5984 : 			val->value.date.sec);
; 5985 : 		}
; 5986 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$7[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN74@xmlSchemaG:

; 5979 : 		} else {
; 5980 : 		    snprintf(buf, 30,

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, ecx
	movsd	xmm0, QWORD PTR [esi+16]
	movsd	QWORD PTR [esp], xmm0
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	shr	ecx, 9
	push	eax
	and	ecx, 31					; 0000001fH
	lea	eax, DWORD PTR _buf$7[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@
	push	30					; 0000001eH
	push	eax
	call	_snprintf
	add	esp, 28					; 0000001cH

; 5981 : 			"%02u:%02u:%02.14g",
; 5982 : 			val->value.date.hour,
; 5983 : 			val->value.date.min,
; 5984 : 			val->value.date.sec);
; 5985 : 		}
; 5986 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$7[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN77@xmlSchemaG:

; 5987 : 	    }
; 5988 : 	    break;
; 5989 :         case XML_SCHEMAS_DATE:
; 5990 : 	    {
; 5991 : 		char buf[30];
; 5992 : 
; 5993 : 		if (val->value.date.tz_flag) {

	test	BYTE PTR [esi+24], 1
	je	SHORT $LN78@xmlSchemaG

; 5994 : 		    xmlSchemaValPtr norm;
; 5995 : 
; 5996 : 		    norm = xmlSchemaDateNormalize(val, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	call	_xmlSchemaDateNormalize
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 5997 : 		    if (norm == NULL)

	test	esi, esi
	je	$LN7@xmlSchemaG

; 5998 : 			return (-1);
; 5999 : 		    /*
; 6000 : 		    * TODO: Append the canonical value of the
; 6001 : 		    * recoverable timezone and not "Z".
; 6002 : 		    */
; 6003 : 		    snprintf(buf, 30,

	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR _buf$6[ebp]
	mov	ecx, edx
	and	edx, 15					; 0000000fH
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	push	ecx
	push	edx
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@
	push	30					; 0000001eH
	push	eax
	call	_snprintf

; 6004 : 			"%04ld:%02u:%02uZ",
; 6005 : 			norm->value.date.year, norm->value.date.mon,
; 6006 : 			norm->value.date.day);
; 6007 : 		    xmlSchemaFreeValue(norm);

	push	esi
	call	_xmlSchemaFreeValue
	add	esp, 28					; 0000001cH

; 6010 : 			"%04ld:%02u:%02u",
; 6011 : 			val->value.date.year, val->value.date.mon,
; 6012 : 			val->value.date.day);
; 6013 : 		}
; 6014 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$6[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN78@xmlSchemaG:

; 6008 : 		} else {
; 6009 : 		    snprintf(buf, 30,

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, ecx
	shr	eax, 4
	and	ecx, 15					; 0000000fH
	and	eax, 31					; 0000001fH
	push	eax
	push	ecx
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _buf$6[ebp]
	push	OFFSET ??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@
	push	30					; 0000001eH
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H

; 6010 : 			"%04ld:%02u:%02u",
; 6011 : 			val->value.date.year, val->value.date.mon,
; 6012 : 			val->value.date.day);
; 6013 : 		}
; 6014 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$6[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN81@xmlSchemaG:

; 6015 : 	    }
; 6016 : 	    break;
; 6017 :         case XML_SCHEMAS_DATETIME:
; 6018 : 	    {
; 6019 : 		char buf[50];
; 6020 : 
; 6021 : 		if (val->value.date.tz_flag) {

	sub	esp, 8
	test	BYTE PTR [esi+24], 1
	je	SHORT $LN82@xmlSchemaG

; 6022 : 		    xmlSchemaValPtr norm;
; 6023 : 
; 6024 : 		    norm = xmlSchemaDateNormalize(val, 0);

	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	call	_xmlSchemaDateNormalize
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 6025 : 		    if (norm == NULL)

	test	esi, esi
	je	$LN7@xmlSchemaG

; 6026 : 			return (-1);
; 6027 : 		    /*
; 6028 : 		    * TODO: Check if "%.14g" is portable.
; 6029 : 		    */
; 6030 : 		    snprintf(buf, 50,

	mov	edx, DWORD PTR [esi+12]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [esi+16]
	mov	ecx, edx
	mov	eax, edx
	shr	ecx, 14					; 0000000eH
	shr	eax, 9
	and	ecx, 63					; 0000003fH
	movsd	QWORD PTR [esp], xmm0
	and	eax, 31					; 0000001fH
	push	ecx
	push	eax
	mov	eax, edx
	and	edx, 15					; 0000000fH
	shr	eax, 4
	and	eax, 31					; 0000001fH
	push	eax
	push	edx
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _buf$2[ebp]
	push	OFFSET ??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
	push	50					; 00000032H
	push	eax
	call	_snprintf

; 6031 : 			"%04ld:%02u:%02uT%02u:%02u:%02.14gZ",
; 6032 : 			norm->value.date.year, norm->value.date.mon,
; 6033 : 			norm->value.date.day, norm->value.date.hour,
; 6034 : 			norm->value.date.min, norm->value.date.sec);
; 6035 : 		    xmlSchemaFreeValue(norm);

	push	esi
	call	_xmlSchemaFreeValue
	add	esp, 44					; 0000002cH

; 6038 : 			"%04ld:%02u:%02uT%02u:%02u:%02.14g",
; 6039 : 			val->value.date.year, val->value.date.mon,
; 6040 : 			val->value.date.day, val->value.date.hour,
; 6041 : 			val->value.date.min, val->value.date.sec);
; 6042 : 		}
; 6043 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	$LN100@xmlSchemaG
$LN82@xmlSchemaG:

; 6036 : 		} else {
; 6037 : 		    snprintf(buf, 50,

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, ecx
	movsd	xmm0, QWORD PTR [esi+16]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	movsd	QWORD PTR [esp], xmm0
	push	eax
	mov	eax, ecx
	shr	eax, 9
	and	eax, 31					; 0000001fH
	push	eax
	mov	eax, ecx
	and	ecx, 15					; 0000000fH
	shr	eax, 4
	and	eax, 31					; 0000001fH
	push	eax
	push	ecx
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR _buf$2[ebp]
	push	OFFSET ??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 40					; 00000028H

; 6038 : 			"%04ld:%02u:%02uT%02u:%02u:%02.14g",
; 6039 : 			val->value.date.year, val->value.date.mon,
; 6040 : 			val->value.date.day, val->value.date.hour,
; 6041 : 			val->value.date.min, val->value.date.sec);
; 6042 : 		}
; 6043 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN100@xmlSchemaG
$LN87@xmlSchemaG:
	movss	xmm0, DWORD PTR [esi+8]

; 6044 : 	    }
; 6045 : 	    break;
; 6046 : 	case XML_SCHEMAS_HEXBINARY:
; 6047 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.hex.str);
; 6048 : 	    break;
; 6049 : 	case XML_SCHEMAS_BASE64BINARY:
; 6050 : 	    /*
; 6051 : 	    * TODO: Is the following spec piece implemented?:
; 6052 : 	    * SPEC: "Note: For some values the canonical form defined
; 6053 : 	    * above does not conform to [RFC 2045], which requires breaking
; 6054 : 	    * with linefeeds at appropriate intervals."
; 6055 : 	    */
; 6056 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.base64.str);
; 6057 : 	    break;
; 6058 : 	case XML_SCHEMAS_FLOAT: {
; 6059 : 		char buf[30];
; 6060 : 		/*
; 6061 : 		* |m| < 16777216, -149 <= e <= 104.
; 6062 : 		* TODO: Handle, NaN, INF, -INF. The format is not
; 6063 : 		* yet conformant. The c type float does not cover
; 6064 : 		* the whole range.
; 6065 : 		*/
; 6066 : 		snprintf(buf, 30, "%01.14e", val->value.f);

	lea	eax, DWORD PTR _buf$5[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07EBIAOBPB@?$CF01?414e@
	push	30					; 0000001eH
	push	eax
	call	_snprintf

; 6067 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$5[ebp]

; 6068 : 	    }
; 6069 : 	    break;

	jmp	SHORT $LN102@xmlSchemaG
$LN88@xmlSchemaG:

; 6070 : 	case XML_SCHEMAS_DOUBLE: {
; 6071 : 		char buf[40];
; 6072 : 		/* |m| < 9007199254740992, -1075 <= e <= 970 */
; 6073 : 		/*
; 6074 : 		* TODO: Handle, NaN, INF, -INF. The format is not
; 6075 : 		* yet conformant. The c type float does not cover
; 6076 : 		* the whole range.
; 6077 : 		*/
; 6078 : 		snprintf(buf, 40, "%01.14e", val->value.d);

	movsd	xmm0, QWORD PTR [esi+8]
	lea	eax, DWORD PTR _buf$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07EBIAOBPB@?$CF01?414e@
	push	40					; 00000028H
	push	eax
	call	_snprintf

; 6079 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$3[ebp]
$LN102@xmlSchemaG:

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	push	eax
	call	_xmlStrdup
	add	esp, 24					; 00000018H
$LN100@xmlSchemaG:
	mov	DWORD PTR [edi], eax
$LN2@xmlSchemaG:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN7@xmlSchemaG

; 6087 : 	return(-1);
; 6088 :     return (0);

	pop	edi
	xor	eax, eax

; 6089 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@xmlSchemaG:

; 6080 : 	    }
; 6081 : 	    break;
; 6082 : 	default:
; 6083 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST "???");

	push	OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 6084 : 	    return (1);

	mov	eax, 1
	pop	edi

; 6089 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSchemaG:
	pop	edi

; 5693 : 	return (-1);

	or	eax, -1

; 6089 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN106@xmlSchemaG:
	DD	$LN8@xmlSchemaG
	DD	$LN11@xmlSchemaG
	DD	$LN21@xmlSchemaG
	DD	$LN73@xmlSchemaG
	DD	$LN66@xmlSchemaG
	DD	$LN64@xmlSchemaG
	DD	$LN68@xmlSchemaG
	DD	$LN63@xmlSchemaG
	DD	$LN70@xmlSchemaG
	DD	$LN77@xmlSchemaG
	DD	$LN81@xmlSchemaG
	DD	$LN57@xmlSchemaG
	DD	$LN87@xmlSchemaG
	DD	$LN88@xmlSchemaG
	DD	$LN54@xmlSchemaG
	DD	$LN15@xmlSchemaG
	DD	$LN18@xmlSchemaG
	DD	$LN39@xmlSchemaG
	DD	$LN85@xmlSchemaG
	DD	$LN89@xmlSchemaG
$LN96@xmlSchemaG:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	18					; 00000012H
_xmlSchemaGetCanonValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValPredefTypeNodeNoNorm
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValPredefTypeNodeNoNorm PROC			; COMDAT

; 3391 : 				 xmlSchemaValPtr *val, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	0
	push	1
	push	0
	push	1
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 3392 :     return(xmlSchemaValAtomicType(type, value, val, node, 1,
; 3393 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
; 3394 : }

	pop	ebp
	ret	0
_xmlSchemaValPredefTypeNodeNoNorm ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacetWhtsp
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_valType$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateLengthFacetWhtsp PROC			; COMDAT

; 5292 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5294 : 	length, ws));
; 5295 : }

	pop	ebp

; 5293 :     return (xmlSchemaValidateLengthFacetInternal(facet, valType, value, val,

	jmp	_xmlSchemaValidateLengthFacetInternal
_xmlSchemaValidateLengthFacetWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacet
_TEXT	SEGMENT
_type$ = 8						; size = 4
_facet$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_xmlSchemaValidateLengthFacet PROC			; COMDAT

; 5262 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaV

; 5263 :     if (type == NULL)
; 5264 :         return(-1);

	or	eax, -1

; 5266 : 	type->builtInType, value, val, length,
; 5267 : 	XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5268 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 5265 :     return (xmlSchemaValidateLengthFacetInternal(facet,

	push	0
	push	DWORD PTR _length$[ebp]
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [eax+88]
	push	DWORD PTR _facet$[ebp]
	call	_xmlSchemaValidateLengthFacetInternal
	add	esp, 24					; 00000018H

; 5266 : 	type->builtInType, value, val, length,
; 5267 : 	XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5268 : }

	pop	ebp
	ret	0
_xmlSchemaValidateLengthFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetFacetValueAsULong
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_xmlSchemaGetFacetValueAsULong PROC			; COMDAT

; 5066 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _facet$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSchemaG

; 5073 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaG:

; 5067 :     /*
; 5068 :     * TODO: Check if this is a decimal.
; 5069 :     */
; 5070 :     if (facet == NULL)
; 5071 :         return 0;
; 5072 :     return ((unsigned long) facet->val->value.decimal.lo);

	mov	eax, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+8]

; 5073 : }

	pop	ebp
	ret	0
_xmlSchemaGetFacetValueAsULong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaWhiteSpaceReplace
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaWhiteSpaceReplace PROC			; COMDAT

; 1928 : xmlSchemaWhiteSpaceReplace(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	esi, edi
	test	edi, edi
	je	SHORT $LN19@xmlSchemaW

; 1929 :     const xmlChar *cur = value;
; 1930 :     xmlChar *ret = NULL, *mcur;
; 1931 : 
; 1932 :     if (value == NULL)
; 1933 : 	return(NULL);
; 1934 : 
; 1935 :     while ((*cur != 0) &&

	mov	cl, BYTE PTR [edi]
	test	cl, cl
	je	SHORT $LN19@xmlSchemaW
	mov	al, cl
$LL2@xmlSchemaW:
	mov	cl, al
	cmp	al, 13					; 0000000dH
	je	SHORT $LN20@xmlSchemaW
	cmp	al, 9
	je	SHORT $LN20@xmlSchemaW
	cmp	al, 10					; 0000000aH
	je	SHORT $LN20@xmlSchemaW
	mov	cl, BYTE PTR [esi+1]

; 1936 : 	(((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {
; 1937 : 	cur++;

	inc	esi
	mov	al, cl
	test	cl, cl
	jne	SHORT $LL2@xmlSchemaW
$LN20@xmlSchemaW:

; 1938 :     }
; 1939 :     if (*cur == 0)

	test	cl, cl
	je	SHORT $LN19@xmlSchemaW

; 1941 :     ret = xmlStrdup(value);

	push	edi
	call	_xmlStrdup

; 1942 :     /* TODO FIXME: I guess gcc will bark at this. */
; 1943 :     mcur = (xmlChar *)  (ret + (cur - value));

	mov	ecx, eax
	add	esp, 4
	sub	ecx, edi
	lea	edx, DWORD PTR [ecx+esi]
	mov	cl, BYTE PTR [edx]
	npad	2
$LL6@xmlSchemaW:

; 1944 :     do {
; 1945 : 	if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )

	cmp	cl, 13					; 0000000dH
	je	SHORT $LN10@xmlSchemaW
	cmp	cl, 9
	je	SHORT $LN10@xmlSchemaW
	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN9@xmlSchemaW
$LN10@xmlSchemaW:

; 1946 : 	    *mcur = ' ';

	mov	BYTE PTR [edx], 32			; 00000020H
$LN9@xmlSchemaW:

; 1947 : 	mcur++;
; 1948 :     } while (*mcur != 0);

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	test	cl, cl
	jne	SHORT $LL6@xmlSchemaW

; 1949 :     return(ret);
; 1950 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN19@xmlSchemaW:
	pop	edi

; 1940 : 	return (NULL);

	xor	eax, eax

; 1949 :     return(ret);
; 1950 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaWhiteSpaceReplace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCollapseString
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaCollapseString PROC				; COMDAT

; 1961 : xmlSchemaCollapseString(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	edx, edi
	test	edi, edi
	je	$LN59@xmlSchemaC

; 1962 :     const xmlChar *start = value, *end, *f;
; 1963 :     xmlChar *g;
; 1964 :     int col = 0;
; 1965 : 
; 1966 :     if (value == NULL) return(NULL);
; 1967 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;

	mov	al, BYTE PTR [edi]
	test	al, al
	je	SHORT $LN67@xmlSchemaC
$LL2@xmlSchemaC:
	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlSchemaC
	cmp	al, 9
	jb	SHORT $LN14@xmlSchemaC
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlSchemaC
$LN14@xmlSchemaC:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN67@xmlSchemaC
$LN13@xmlSchemaC:
	mov	al, BYTE PTR [edx+1]
	inc	edx
	test	al, al
	jne	SHORT $LL2@xmlSchemaC
$LN67@xmlSchemaC:

; 1968 :     end = start;
; 1969 :     while (*end != 0) {

	mov	cl, BYTE PTR [edx]
	mov	eax, edx
	test	cl, cl
	je	SHORT $LN55@xmlSchemaC
$LL4@xmlSchemaC:

; 1970 : 	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {

	cmp	cl, 32					; 00000020H
	jne	SHORT $LN49@xmlSchemaC
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN40@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN18@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	ja	SHORT $LN18@xmlSchemaC
$LN40@xmlSchemaC:

; 1978 :     }
; 1979 :     if (col == 0) {

	mov	esi, eax
	sub	esi, edx
	test	esi, esi
	je	SHORT $LN55@xmlSchemaC

; 1986 :     }
; 1987 :     start = xmlStrdup(start);

	push	edx
	call	_xmlStrdup
	add	esp, 4

; 1988 :     if (start == NULL) return(NULL);

	test	eax, eax
	je	$LN59@xmlSchemaC

; 1989 :     g = (xmlChar *) (start + col);
; 1990 :     end = g;
; 1991 :     while (*end != 0) {

	mov	cl, BYTE PTR [esi+eax]
	add	esi, eax
	mov	edx, esi
	test	cl, cl
	je	$LN66@xmlSchemaC
$LL8@xmlSchemaC:

; 1992 : 	if (IS_BLANK_CH(*end)) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN28@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN29@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN28@xmlSchemaC
$LN29@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN28@xmlSchemaC

; 1997 : 	} else
; 1998 : 	    *g++ = *end++;

	mov	BYTE PTR [esi], cl
	inc	esi
	inc	edx
	jmp	SHORT $LN69@xmlSchemaC
$LN49@xmlSchemaC:

; 1971 : 	    col = end - start;
; 1972 : 	    break;
; 1973 : 	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {

	cmp	cl, 10					; 0000000aH
	je	SHORT $LN40@xmlSchemaC
	cmp	cl, 9
	je	SHORT $LN40@xmlSchemaC
$LN18@xmlSchemaC:

; 1974 : 	    col = end - start;
; 1975 : 	    break;
; 1976 : 	}
; 1977 : 	end++;

	cmp	cl, 13					; 0000000dH
	je	SHORT $LN40@xmlSchemaC
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL4@xmlSchemaC
$LN55@xmlSchemaC:

; 1980 : 	f = end;

	mov	esi, eax

; 1981 : 	end--;

	dec	eax

; 1982 : 	while ((end > start) && (IS_BLANK_CH(*end))) end--;

	cmp	eax, edx
	jbe	SHORT $LN68@xmlSchemaC
	npad	7
$LL6@xmlSchemaC:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN22@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN23@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN22@xmlSchemaC
$LN23@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN68@xmlSchemaC
$LN22@xmlSchemaC:
	dec	eax
	cmp	eax, edx
	ja	SHORT $LL6@xmlSchemaC
$LN68@xmlSchemaC:

; 1983 : 	end++;

	inc	eax

; 1984 : 	if ((start == value) && (f == end)) return(NULL);

	cmp	edx, edi
	jne	SHORT $LN24@xmlSchemaC
	cmp	esi, eax
	je	SHORT $LN59@xmlSchemaC
$LN24@xmlSchemaC:

; 1985 : 	return(xmlStrndup(start, end - start));

	sub	eax, edx
	push	eax
	push	edx
	call	_xmlStrndup
	add	esp, 8
	pop	edi

; 2001 :     return((xmlChar *) start);
; 2002 : }

	pop	esi
	pop	ebp
	ret	0
$LN28@xmlSchemaC:

; 1993 : 	    end++;
; 1994 : 	    while (IS_BLANK_CH(*end)) end++;

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	cmp	cl, 32					; 00000020H
	je	SHORT $LN28@xmlSchemaC
	cmp	cl, 9
	jb	SHORT $LN31@xmlSchemaC
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN28@xmlSchemaC
$LN31@xmlSchemaC:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN28@xmlSchemaC

; 1995 : 	    if (*end != 0)

	test	cl, cl
	je	SHORT $LN66@xmlSchemaC

; 1996 : 		*g++ = ' ';

	mov	BYTE PTR [esi], 32			; 00000020H
	inc	esi
$LN69@xmlSchemaC:

; 1989 :     g = (xmlChar *) (start + col);
; 1990 :     end = g;
; 1991 :     while (*end != 0) {

	mov	cl, BYTE PTR [edx]
	test	cl, cl
	jne	$LL8@xmlSchemaC
$LN66@xmlSchemaC:
	pop	edi

; 1999 :     }
; 2000 :     *g = 0;

	mov	BYTE PTR [esi], 0

; 2001 :     return((xmlChar *) start);
; 2002 : }

	pop	esi
	pop	ebp
	ret	0
$LN59@xmlSchemaC:
	pop	edi

; 1988 :     if (start == NULL) return(NULL);

	xor	eax, eax

; 2001 :     return((xmlChar *) start);
; 2002 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchemaCollapseString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaIsBuiltInTypeFacet
_TEXT	SEGMENT
_type$ = 8						; size = 4
_facetType$ = 12					; size = 4
_xmlSchemaIsBuiltInTypeFacet PROC			; COMDAT

; 671  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	$LN24@xmlSchemaI

; 672  :     if (type == NULL)
; 673  : 	return (-1);
; 674  :     if (type->type != XML_SCHEMA_TYPE_BASIC)

	cmp	DWORD PTR [eax], 1
	jne	$LN24@xmlSchemaI

; 676  :     switch (type->builtInType) {

	mov	eax, DWORD PTR [eax+88]
	dec	eax
	cmp	eax, 43					; 0000002bH
	ja	SHORT $LN20@xmlSchemaI
	movzx	eax, BYTE PTR $LN25@xmlSchemaI[eax]
	jmp	DWORD PTR $LN29@xmlSchemaI[eax*4]
$LN6@xmlSchemaI:

; 677  : 	case XML_SCHEMAS_BOOLEAN:
; 678  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||

	mov	eax, DWORD PTR _facetType$[ebp]
	cmp	eax, 1006				; 000003eeH
	jmp	SHORT $LN26@xmlSchemaI
$LN8@xmlSchemaI:

; 679  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 680  : 		return (1);
; 681  : 	    else
; 682  : 		return (0);
; 683  : 	case XML_SCHEMAS_STRING:
; 684  : 	case XML_SCHEMAS_NOTATION:
; 685  : 	case XML_SCHEMAS_QNAME:
; 686  : 	case XML_SCHEMAS_ANYURI:
; 687  : 	case XML_SCHEMAS_BASE64BINARY:
; 688  : 	case XML_SCHEMAS_HEXBINARY:
; 689  : 	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 690  : 		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
; 691  : 		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
; 692  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 693  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||

	mov	eax, DWORD PTR _facetType$[ebp]
	cmp	eax, 1009				; 000003f1H
	je	$LN21@xmlSchemaI
	cmp	eax, 1011				; 000003f3H
	je	$LN21@xmlSchemaI
	cmp	eax, 1010				; 000003f2H
	je	$LN21@xmlSchemaI
	cmp	eax, 1006				; 000003eeH
	je	$LN21@xmlSchemaI
	cmp	eax, 1007				; 000003efH
$LN26@xmlSchemaI:

; 730  : 	    else
; 731  : 		return (0);
; 732  : 	default:
; 733  : 	    break;
; 734  :     }
; 735  :     return (0);

	je	$LN21@xmlSchemaI
	cmp	eax, 1008				; 000003f0H
$LN27@xmlSchemaI:
	je	SHORT $LN21@xmlSchemaI
$LN20@xmlSchemaI:
	xor	eax, eax

; 736  : }

	pop	ebp
	ret	0
$LN12@xmlSchemaI:

; 694  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 695  : 		return (1);
; 696  : 	    else
; 697  : 		return (0);
; 698  : 	case XML_SCHEMAS_DECIMAL:
; 699  : 	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
; 700  : 		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
; 701  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 702  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 703  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 704  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 705  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 706  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||

	mov	eax, DWORD PTR _facetType$[ebp]
	cmp	eax, 1004				; 000003ecH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1005				; 000003edH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1006				; 000003eeH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1008				; 000003f0H
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1007				; 000003efH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1002				; 000003eaH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1003				; 000003ebH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1000				; 000003e8H
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1001				; 000003e9H
	jmp	SHORT $LN27@xmlSchemaI
$LN16@xmlSchemaI:

; 707  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 708  : 		return (1);
; 709  : 	    else
; 710  : 		return (0);
; 711  : 	case XML_SCHEMAS_TIME:
; 712  : 	case XML_SCHEMAS_GDAY:
; 713  : 	case XML_SCHEMAS_GMONTH:
; 714  : 	case XML_SCHEMAS_GMONTHDAY:
; 715  : 	case XML_SCHEMAS_GYEAR:
; 716  : 	case XML_SCHEMAS_GYEARMONTH:
; 717  : 	case XML_SCHEMAS_DATE:
; 718  : 	case XML_SCHEMAS_DATETIME:
; 719  : 	case XML_SCHEMAS_DURATION:
; 720  : 	case XML_SCHEMAS_FLOAT:
; 721  : 	case XML_SCHEMAS_DOUBLE:
; 722  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 723  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 724  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 725  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 726  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 727  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||

	mov	eax, DWORD PTR _facetType$[ebp]
	cmp	eax, 1006				; 000003eeH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1007				; 000003efH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1008				; 000003f0H
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1002				; 000003eaH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1003				; 000003ebH
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1000				; 000003e8H
	je	SHORT $LN21@xmlSchemaI
	cmp	eax, 1001				; 000003e9H
	jne	SHORT $LN20@xmlSchemaI
$LN21@xmlSchemaI:

; 728  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 729  : 		return (1);

	mov	eax, 1

; 736  : }

	pop	ebp
	ret	0
$LN24@xmlSchemaI:

; 675  : 	return (-1);

	or	eax, -1

; 736  : }

	pop	ebp
	ret	0
	npad	3
$LN29@xmlSchemaI:
	DD	$LN8@xmlSchemaI
	DD	$LN12@xmlSchemaI
	DD	$LN16@xmlSchemaI
	DD	$LN6@xmlSchemaI
	DD	$LN20@xmlSchemaI
$LN25@xmlSchemaI:
	DB	0
	DB	4
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
_xmlSchemaIsBuiltInTypeFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetBuiltInType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaGetBuiltInType PROC				; COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN4@xmlSchemaG

; 750  :     if (xmlSchemaTypesInitialized == 0)
; 751  : 	xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN4@xmlSchemaG:

; 752  :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 45					; 0000002dH
	ja	$LN51@xmlSchemaG
	jmp	DWORD PTR $LN54@xmlSchemaG[eax*4]
$LN5@xmlSchemaG:

; 753  : 
; 754  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 755  : 	    return (xmlSchemaTypeAnySimpleTypeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN6@xmlSchemaG:

; 756  : 	case XML_SCHEMAS_STRING:
; 757  : 	    return (xmlSchemaTypeStringDef);

	mov	eax, DWORD PTR _xmlSchemaTypeStringDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN7@xmlSchemaG:

; 758  : 	case XML_SCHEMAS_NORMSTRING:
; 759  : 	    return (xmlSchemaTypeNormStringDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNormStringDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN8@xmlSchemaG:

; 760  : 	case XML_SCHEMAS_DECIMAL:
; 761  : 	    return (xmlSchemaTypeDecimalDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDecimalDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN9@xmlSchemaG:

; 762  : 	case XML_SCHEMAS_TIME:
; 763  : 	    return (xmlSchemaTypeTimeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeTimeDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN10@xmlSchemaG:

; 764  : 	case XML_SCHEMAS_GDAY:
; 765  : 	    return (xmlSchemaTypeGDayDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGDayDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN11@xmlSchemaG:

; 766  : 	case XML_SCHEMAS_GMONTH:
; 767  : 	    return (xmlSchemaTypeGMonthDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGMonthDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN12@xmlSchemaG:

; 768  : 	case XML_SCHEMAS_GMONTHDAY:
; 769  : 	    return (xmlSchemaTypeGMonthDayDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGMonthDayDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN13@xmlSchemaG:

; 770  : 	case XML_SCHEMAS_GYEAR:
; 771  : 	    return (xmlSchemaTypeGYearDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGYearDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN14@xmlSchemaG:

; 772  : 	case XML_SCHEMAS_GYEARMONTH:
; 773  : 	    return (xmlSchemaTypeGYearMonthDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGYearMonthDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN15@xmlSchemaG:

; 774  : 	case XML_SCHEMAS_DATE:
; 775  : 	    return (xmlSchemaTypeDateDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDateDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN16@xmlSchemaG:

; 776  : 	case XML_SCHEMAS_DATETIME:
; 777  : 	    return (xmlSchemaTypeDatetimeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDatetimeDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN17@xmlSchemaG:

; 778  : 	case XML_SCHEMAS_DURATION:
; 779  : 	    return (xmlSchemaTypeDurationDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDurationDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN18@xmlSchemaG:

; 780  : 	case XML_SCHEMAS_FLOAT:
; 781  : 	    return (xmlSchemaTypeFloatDef);

	mov	eax, DWORD PTR _xmlSchemaTypeFloatDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN19@xmlSchemaG:

; 782  : 	case XML_SCHEMAS_DOUBLE:
; 783  : 	    return (xmlSchemaTypeDoubleDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDoubleDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN20@xmlSchemaG:

; 784  : 	case XML_SCHEMAS_BOOLEAN:
; 785  : 	    return (xmlSchemaTypeBooleanDef);

	mov	eax, DWORD PTR _xmlSchemaTypeBooleanDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN21@xmlSchemaG:

; 786  : 	case XML_SCHEMAS_TOKEN:
; 787  : 	    return (xmlSchemaTypeTokenDef);

	mov	eax, DWORD PTR _xmlSchemaTypeTokenDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN22@xmlSchemaG:

; 788  : 	case XML_SCHEMAS_LANGUAGE:
; 789  : 	    return (xmlSchemaTypeLanguageDef);

	mov	eax, DWORD PTR _xmlSchemaTypeLanguageDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN23@xmlSchemaG:

; 790  : 	case XML_SCHEMAS_NMTOKEN:
; 791  : 	    return (xmlSchemaTypeNmtokenDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokenDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN24@xmlSchemaG:

; 792  : 	case XML_SCHEMAS_NMTOKENS:
; 793  : 	    return (xmlSchemaTypeNmtokensDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokensDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN25@xmlSchemaG:

; 794  : 	case XML_SCHEMAS_NAME:
; 795  : 	    return (xmlSchemaTypeNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNameDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN26@xmlSchemaG:

; 796  : 	case XML_SCHEMAS_QNAME:
; 797  : 	    return (xmlSchemaTypeQNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeQNameDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN27@xmlSchemaG:

; 798  : 	case XML_SCHEMAS_NCNAME:
; 799  : 	    return (xmlSchemaTypeNCNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNCNameDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN28@xmlSchemaG:

; 800  : 	case XML_SCHEMAS_ID:
; 801  : 	    return (xmlSchemaTypeIdDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN29@xmlSchemaG:

; 802  : 	case XML_SCHEMAS_IDREF:
; 803  : 	    return (xmlSchemaTypeIdrefDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN30@xmlSchemaG:

; 804  : 	case XML_SCHEMAS_IDREFS:
; 805  : 	    return (xmlSchemaTypeIdrefsDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefsDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN31@xmlSchemaG:

; 806  : 	case XML_SCHEMAS_ENTITY:
; 807  : 	    return (xmlSchemaTypeEntityDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN32@xmlSchemaG:

; 808  : 	case XML_SCHEMAS_ENTITIES:
; 809  : 	    return (xmlSchemaTypeEntitiesDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntitiesDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN33@xmlSchemaG:

; 810  : 	case XML_SCHEMAS_NOTATION:
; 811  : 	    return (xmlSchemaTypeNotationDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNotationDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN34@xmlSchemaG:

; 812  : 	case XML_SCHEMAS_ANYURI:
; 813  : 	    return (xmlSchemaTypeAnyURIDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyURIDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN35@xmlSchemaG:

; 814  : 	case XML_SCHEMAS_INTEGER:
; 815  : 	    return (xmlSchemaTypeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIntegerDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN36@xmlSchemaG:

; 816  : 	case XML_SCHEMAS_NPINTEGER:
; 817  : 	    return (xmlSchemaTypeNonPositiveIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNonPositiveIntegerDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN37@xmlSchemaG:

; 818  : 	case XML_SCHEMAS_NINTEGER:
; 819  : 	    return (xmlSchemaTypeNegativeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNegativeIntegerDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN38@xmlSchemaG:

; 820  : 	case XML_SCHEMAS_NNINTEGER:
; 821  : 	    return (xmlSchemaTypeNonNegativeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN39@xmlSchemaG:

; 822  : 	case XML_SCHEMAS_PINTEGER:
; 823  : 	    return (xmlSchemaTypePositiveIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypePositiveIntegerDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN40@xmlSchemaG:

; 824  : 	case XML_SCHEMAS_INT:
; 825  : 	    return (xmlSchemaTypeIntDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIntDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN41@xmlSchemaG:

; 826  : 	case XML_SCHEMAS_UINT:
; 827  : 	    return (xmlSchemaTypeUnsignedIntDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedIntDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN42@xmlSchemaG:

; 828  : 	case XML_SCHEMAS_LONG:
; 829  : 	    return (xmlSchemaTypeLongDef);

	mov	eax, DWORD PTR _xmlSchemaTypeLongDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN43@xmlSchemaG:

; 830  : 	case XML_SCHEMAS_ULONG:
; 831  : 	    return (xmlSchemaTypeUnsignedLongDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedLongDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN44@xmlSchemaG:

; 832  : 	case XML_SCHEMAS_SHORT:
; 833  : 	    return (xmlSchemaTypeShortDef);

	mov	eax, DWORD PTR _xmlSchemaTypeShortDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN45@xmlSchemaG:

; 834  : 	case XML_SCHEMAS_USHORT:
; 835  : 	    return (xmlSchemaTypeUnsignedShortDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedShortDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN46@xmlSchemaG:

; 836  : 	case XML_SCHEMAS_BYTE:
; 837  : 	    return (xmlSchemaTypeByteDef);

	mov	eax, DWORD PTR _xmlSchemaTypeByteDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN47@xmlSchemaG:

; 838  : 	case XML_SCHEMAS_UBYTE:
; 839  : 	    return (xmlSchemaTypeUnsignedByteDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedByteDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN48@xmlSchemaG:

; 840  : 	case XML_SCHEMAS_HEXBINARY:
; 841  : 	    return (xmlSchemaTypeHexBinaryDef);

	mov	eax, DWORD PTR _xmlSchemaTypeHexBinaryDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN49@xmlSchemaG:

; 842  : 	case XML_SCHEMAS_BASE64BINARY:
; 843  : 	    return (xmlSchemaTypeBase64BinaryDef);

	mov	eax, DWORD PTR _xmlSchemaTypeBase64BinaryDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN50@xmlSchemaG:

; 844  : 	case XML_SCHEMAS_ANYTYPE:
; 845  : 	    return (xmlSchemaTypeAnyTypeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
$LN51@xmlSchemaG:

; 846  : 	default:
; 847  : 	    return (NULL);

	xor	eax, eax

; 848  :     }
; 849  : }

	pop	ebp
	ret	0
	npad	3
$LN54@xmlSchemaG:
	DD	$LN6@xmlSchemaG
	DD	$LN7@xmlSchemaG
	DD	$LN8@xmlSchemaG
	DD	$LN9@xmlSchemaG
	DD	$LN10@xmlSchemaG
	DD	$LN11@xmlSchemaG
	DD	$LN12@xmlSchemaG
	DD	$LN13@xmlSchemaG
	DD	$LN14@xmlSchemaG
	DD	$LN15@xmlSchemaG
	DD	$LN16@xmlSchemaG
	DD	$LN17@xmlSchemaG
	DD	$LN18@xmlSchemaG
	DD	$LN19@xmlSchemaG
	DD	$LN20@xmlSchemaG
	DD	$LN21@xmlSchemaG
	DD	$LN22@xmlSchemaG
	DD	$LN23@xmlSchemaG
	DD	$LN24@xmlSchemaG
	DD	$LN25@xmlSchemaG
	DD	$LN26@xmlSchemaG
	DD	$LN27@xmlSchemaG
	DD	$LN28@xmlSchemaG
	DD	$LN29@xmlSchemaG
	DD	$LN30@xmlSchemaG
	DD	$LN31@xmlSchemaG
	DD	$LN32@xmlSchemaG
	DD	$LN33@xmlSchemaG
	DD	$LN34@xmlSchemaG
	DD	$LN35@xmlSchemaG
	DD	$LN36@xmlSchemaG
	DD	$LN37@xmlSchemaG
	DD	$LN38@xmlSchemaG
	DD	$LN39@xmlSchemaG
	DD	$LN40@xmlSchemaG
	DD	$LN41@xmlSchemaG
	DD	$LN42@xmlSchemaG
	DD	$LN43@xmlSchemaG
	DD	$LN44@xmlSchemaG
	DD	$LN45@xmlSchemaG
	DD	$LN46@xmlSchemaG
	DD	$LN47@xmlSchemaG
	DD	$LN48@xmlSchemaG
	DD	$LN49@xmlSchemaG
	DD	$LN50@xmlSchemaG
	DD	$LN5@xmlSchemaG
_xmlSchemaGetBuiltInType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateListSimpleTypeFacet
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_value$ = 12						; size = 4
_actualLen$ = 16					; size = 4
_expectedLen$ = 20					; size = 4
_xmlSchemaValidateListSimpleTypeFacet PROC		; COMDAT

; 5092 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _facet$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlSchemaV

; 5093 :     if (facet == NULL)
; 5094 :         return(-1);
; 5095 :     /*
; 5096 :     * TODO: Check if this will work with large numbers.
; 5097 :     * (compare value.decimal.mi and value.decimal.hi as well?).
; 5098 :     */
; 5099 :     if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1009				; 000003f1H
	jne	SHORT $LN3@xmlSchemaV

; 5100 : 	if (actualLen != facet->val->value.decimal.lo) {

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR _actualLen$[ebp], ecx
	je	SHORT $LN13@xmlSchemaV

; 5101 : 	    if (expectedLen != NULL)

	mov	eax, DWORD PTR _expectedLen$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlSchemaV

; 5102 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	DWORD PTR [eax], ecx
$LN6@xmlSchemaV:

; 5103 : 	    return (XML_SCHEMAV_CVC_LENGTH_VALID);

	mov	eax, 1830				; 00000726H

; 5125 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaV:

; 5104 : 	}
; 5105 :     } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	cmp	ecx, 1011				; 000003f3H
	jne	SHORT $LN7@xmlSchemaV

; 5106 : 	if (actualLen < facet->val->value.decimal.lo) {

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR _actualLen$[ebp], ecx
	jae	SHORT $LN13@xmlSchemaV

; 5107 : 	    if (expectedLen != NULL)

	mov	eax, DWORD PTR _expectedLen$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlSchemaV

; 5108 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	DWORD PTR [eax], ecx
$LN10@xmlSchemaV:

; 5109 : 	    return (XML_SCHEMAV_CVC_MINLENGTH_VALID);

	mov	eax, 1831				; 00000727H

; 5125 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaV:

; 5110 : 	}
; 5111 :     } else if (facet->type == XML_SCHEMA_FACET_MAXLENGTH) {

	cmp	ecx, 1010				; 000003f2H
	jne	SHORT $LN11@xmlSchemaV

; 5112 : 	if (actualLen > facet->val->value.decimal.lo) {

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR _actualLen$[ebp], ecx
	jbe	SHORT $LN13@xmlSchemaV

; 5113 : 	    if (expectedLen != NULL)

	mov	eax, DWORD PTR _expectedLen$[ebp]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaV

; 5114 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	DWORD PTR [eax], ecx
$LN14@xmlSchemaV:

; 5115 : 	    return (XML_SCHEMAV_CVC_MAXLENGTH_VALID);

	mov	eax, 1832				; 00000728H

; 5125 : }

	pop	ebp
	ret	0
$LN13@xmlSchemaV:

; 5124 :     return (0);

	xor	eax, eax

; 5125 : }

	pop	ebp
	ret	0
$LN11@xmlSchemaV:

; 5116 : 	}
; 5117 :     } else
; 5118 : 	/*
; 5119 : 	* NOTE: That we can pass NULL as xmlSchemaValPtr to
; 5120 : 	* xmlSchemaValidateFacet, since the remaining facet types
; 5121 : 	* are: XML_SCHEMA_FACET_PATTERN, XML_SCHEMA_FACET_ENUMERATION.
; 5122 : 	*/
; 5123 : 	return(xmlSchemaValidateFacet(NULL, facet, value, NULL));

	or	eax, -1

; 5125 : }

	pop	ebp
	ret	0
_xmlSchemaValidateListSimpleTypeFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetBuiltInListSimpleTypeItemType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_xmlSchemaGetBuiltInListSimpleTypeItemType PROC		; COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaG

; 1102 :     if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@xmlSchemaG

; 1104 :     switch (type->builtInType) {

	mov	eax, DWORD PTR [eax+88]
	sub	eax, 19					; 00000013H
	je	SHORT $LN6@xmlSchemaG
	sub	eax, 6
	je	SHORT $LN7@xmlSchemaG
	sub	eax, 2
	jne	SHORT $LN5@xmlSchemaG

; 1109 : 	case XML_SCHEMAS_ENTITIES:
; 1110 : 	    return (xmlSchemaTypeEntityDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef

; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }

	pop	ebp
	ret	0
$LN7@xmlSchemaG:

; 1107 : 	case XML_SCHEMAS_IDREFS:
; 1108 : 	    return (xmlSchemaTypeIdrefDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef

; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }

	pop	ebp
	ret	0
$LN6@xmlSchemaG:

; 1105 : 	case XML_SCHEMAS_NMTOKENS:
; 1106 : 	    return (xmlSchemaTypeNmtokenDef );

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokenDef

; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }

	pop	ebp
	ret	0
$LN5@xmlSchemaG:

; 1103 : 	return (NULL);

	xor	eax, eax

; 1111 : 	default:
; 1112 : 	    return (NULL);
; 1113 :     }
; 1114 : }

	pop	ebp
	ret	0
_xmlSchemaGetBuiltInListSimpleTypeItemType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValues
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareValues PROC				; COMDAT

; 4937 : xmlSchemaCompareValues(xmlSchemaValPtr x, xmlSchemaValPtr y) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _x$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaC

; 4938 :     xmlSchemaWhitespaceValueType xws, yws;
; 4939 : 
; 4940 :     if ((x == NULL) || (y == NULL))

	mov	esi, DWORD PTR _y$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaC

; 4942 :     if (x->type == XML_SCHEMAS_STRING)

	push	ebx
	push	edi
	mov	edi, DWORD PTR [edx]
	cmp	edi, 1
	jne	SHORT $LN4@xmlSchemaC

; 4943 : 	xws = XML_SCHEMA_WHITESPACE_PRESERVE;

	mov	eax, edi
	jmp	SHORT $LN6@xmlSchemaC
$LN4@xmlSchemaC:

; 4944 :     else if (x->type == XML_SCHEMAS_NORMSTRING)

	xor	eax, eax
	cmp	edi, 2
	setne	al
	add	eax, 2
$LN6@xmlSchemaC:

; 4945 :         xws = XML_SCHEMA_WHITESPACE_REPLACE;
; 4946 :     else
; 4947 :         xws = XML_SCHEMA_WHITESPACE_COLLAPSE;
; 4948 : 
; 4949 :     if (y->type == XML_SCHEMAS_STRING)

	mov	ebx, DWORD PTR [esi]
	cmp	ebx, 1
	jne	SHORT $LN8@xmlSchemaC

; 4950 : 	yws = XML_SCHEMA_WHITESPACE_PRESERVE;

	mov	ecx, ebx
	jmp	SHORT $LN10@xmlSchemaC
$LN8@xmlSchemaC:

; 4951 :     else if (y->type == XML_SCHEMAS_NORMSTRING)

	xor	ecx, ecx
	cmp	ebx, 2
	setne	cl
	add	ecx, 2
$LN10@xmlSchemaC:

; 4952 :         yws = XML_SCHEMA_WHITESPACE_REPLACE;
; 4953 :     else
; 4954 :         yws = XML_SCHEMA_WHITESPACE_COLLAPSE;
; 4955 : 
; 4956 :     return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,

	push	ecx
	push	0
	push	esi
	push	ebx
	push	eax
	push	0
	push	edx
	push	edi
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H
	pop	edi
	pop	ebx
	pop	esi

; 4957 : 	y, NULL, yws));
; 4958 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaC:

; 4941 :         return(-2);

	mov	eax, -2					; fffffffeH
	pop	esi

; 4957 : 	y, NULL, yws));
; 4958 : }

	pop	ebp
	ret	0
_xmlSchemaCompareValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaFreeValue
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlSchemaFreeValue PROC				; COMDAT

; 1025 : xmlSchemaFreeValue(xmlSchemaValPtr value) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemaF
$LL2@xmlSchemaF:

; 1026 :     xmlSchemaValPtr prev;
; 1027 : 
; 1028 :     while (value != NULL) {
; 1029 : 	switch (value->type) {

	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	eax, 45					; 0000002dH
	ja	SHORT $LN14@xmlSchemaF
	movzx	eax, BYTE PTR $LN21@xmlSchemaF[eax]
	jmp	DWORD PTR $LN24@xmlSchemaF[eax*4]
$LN8@xmlSchemaF:

; 1030 : 	    case XML_SCHEMAS_STRING:
; 1031 : 	    case XML_SCHEMAS_NORMSTRING:
; 1032 : 	    case XML_SCHEMAS_TOKEN:
; 1033 : 	    case XML_SCHEMAS_LANGUAGE:
; 1034 : 	    case XML_SCHEMAS_NMTOKEN:
; 1035 : 	    case XML_SCHEMAS_NMTOKENS:
; 1036 : 	    case XML_SCHEMAS_NAME:
; 1037 : 	    case XML_SCHEMAS_NCNAME:
; 1038 : 	    case XML_SCHEMAS_ID:
; 1039 : 	    case XML_SCHEMAS_IDREF:
; 1040 : 	    case XML_SCHEMAS_IDREFS:
; 1041 : 	    case XML_SCHEMAS_ENTITY:
; 1042 : 	    case XML_SCHEMAS_ENTITIES:
; 1043 : 	    case XML_SCHEMAS_ANYURI:
; 1044 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1045 : 		if (value->value.str != NULL)
; 1046 : 		    xmlFree(value->value.str);
; 1047 : 		break;
; 1048 : 	    case XML_SCHEMAS_NOTATION:
; 1049 : 	    case XML_SCHEMAS_QNAME:
; 1050 : 		if (value->value.qname.uri != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN13@xmlSchemaF

; 1051 : 		    xmlFree(value->value.qname.uri);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlSchemaF:

; 1052 : 		if (value->value.qname.name != NULL)
; 1053 : 		    xmlFree(value->value.qname.name);
; 1054 : 		break;
; 1055 : 	    case XML_SCHEMAS_HEXBINARY:
; 1056 : 		if (value->value.hex.str != NULL)
; 1057 : 		    xmlFree(value->value.hex.str);
; 1058 : 		break;
; 1059 : 	    case XML_SCHEMAS_BASE64BINARY:
; 1060 : 		if (value->value.base64.str != NULL)
; 1061 : 		    xmlFree(value->value.base64.str);
; 1062 : 		break;
; 1063 : 	    default:
; 1064 : 		break;
; 1065 : 	}
; 1066 : 	prev = value;
; 1067 : 	value = value->next;
; 1068 : 	xmlFree(prev);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN14@xmlSchemaF
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlSchemaF:
	push	esi
	mov	esi, DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL2@xmlSchemaF
$LN3@xmlSchemaF:
	pop	esi

; 1069 :     }
; 1070 : }

	pop	ebp
	ret	0
	npad	3
$LN24@xmlSchemaF:
	DD	$LN13@xmlSchemaF
	DD	$LN8@xmlSchemaF
	DD	$LN14@xmlSchemaF
$LN21@xmlSchemaF:
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	2
	DB	0
_xmlSchemaFreeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacetWhtsp
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_fws$ = 12						; size = 4
_valType$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateFacetWhtsp PROC			; COMDAT

; 5585 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5587 : 	 value, val, ws));
; 5588 : }

	pop	ebp

; 5586 :      return(xmlSchemaValidateFacetInternal(facet, fws, valType,

	jmp	_xmlSchemaValidateFacetInternal
_xmlSchemaValidateFacetWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacet
_TEXT	SEGMENT
_base$ = 8						; size = 4
_facet$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlSchemaValidateFacet PROC				; COMDAT

; 5544 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemaV

; 5545 :     /*
; 5546 :     * This tries to ensure API compatibility regarding the old
; 5547 :     * xmlSchemaValidateFacet() and the new xmlSchemaValidateFacetInternal() and
; 5548 :     * xmlSchemaValidateFacetWhtsp().
; 5549 :     */
; 5550 :     if (val != NULL)
; 5551 : 	return(xmlSchemaValidateFacetInternal(facet,

	push	0
	push	eax
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [eax]
	push	0
	push	DWORD PTR _facet$[ebp]
	call	_xmlSchemaValidateFacetInternal
	add	esp, 24					; 00000018H

; 5559 : }

	pop	ebp
	ret	0
$LN2@xmlSchemaV:

; 5552 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN, val->type, value, val,
; 5553 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5554 :     else if (base != NULL)

	mov	eax, DWORD PTR _base$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSchemaV

; 5555 : 	return(xmlSchemaValidateFacetInternal(facet,

	push	0
	push	0
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [eax+88]
	push	0
	push	DWORD PTR _facet$[ebp]
	call	_xmlSchemaValidateFacetInternal
	add	esp, 24					; 00000018H

; 5559 : }

	pop	ebp
	ret	0
$LN4@xmlSchemaV:

; 5556 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN, base->builtInType, value, val,
; 5557 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5558 :     return(-1);

	or	eax, -1

; 5559 : }

	pop	ebp
	ret	0
_xmlSchemaValidateFacet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValPredefTypeNode
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValPredefTypeNode PROC			; COMDAT

; 3370 : 	                   xmlSchemaValPtr *val, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	1
	push	1
	push	0
	push	0
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,
; 3372 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
; 3373 : }

	pop	ebp
	ret	0
_xmlSchemaValPredefTypeNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidatePredefinedType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlSchemaValidatePredefinedType PROC			; COMDAT

; 3410 : 	                        xmlSchemaValPtr *val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,

	push	0
	push	1
	push	1
	push	0
	push	0
	push	0
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _type$[ebp]
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 3411 :     return(xmlSchemaValPredefTypeNode(type, value, val, NULL));
; 3412 : }

	pop	ebp
	ret	0
_xmlSchemaValidatePredefinedType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetPredefinedType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSchemaGetPredefinedType PROC			; COMDAT

; 1082 : xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN2@xmlSchemaG

; 1083 :     if (xmlSchemaTypesInitialized == 0)
; 1084 : 	xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN2@xmlSchemaG:

; 1085 :     if (name == NULL)

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlSchemaG

; 1088 : }

	pop	ebp
	ret	0
$LN3@xmlSchemaG:

; 1086 : 	return(NULL);
; 1087 :     return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));

	push	DWORD PTR _ns$[ebp]
	push	eax
	push	DWORD PTR _xmlSchemaTypesBank
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH

; 1088 : }

	pop	ebp
	ret	0
_xmlSchemaGetPredefinedType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCleanupTypes
_TEXT	SEGMENT
_xmlSchemaCleanupTypes PROC				; COMDAT
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	je	SHORT $LN1@xmlSchemaC

; 634  :     if (xmlSchemaTypesInitialized == 0)
; 635  : 	return;
; 636  :     /*
; 637  :     * Free xs:anyType.
; 638  :     */
; 639  :     {
; 640  : 	xmlSchemaParticlePtr particle;
; 641  : 	/* Attribute wildcard. */
; 642  : 	xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	push	esi
	push	DWORD PTR [eax+84]
	call	_xmlSchemaFreeWildcard

; 643  : 	/* Content type. */
; 644  : 	particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	esi, DWORD PTR [eax+28]

; 645  : 	/* Wildcard. */
; 646  : 	xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+12]
	push	DWORD PTR [eax+12]
	call	_xmlSchemaFreeWildcard

; 647  : 	    particle->children->children->children);
; 648  : 	xmlFree((xmlSchemaParticlePtr) particle->children->children);

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+12]
	call	DWORD PTR _xmlFree

; 649  : 	/* Sequence model group. */
; 650  : 	xmlFree((xmlSchemaModelGroupPtr) particle->children);

	push	DWORD PTR [esi+12]
	call	DWORD PTR _xmlFree

; 651  : 	xmlFree((xmlSchemaParticlePtr) particle);

	push	esi
	call	DWORD PTR _xmlFree

; 652  : 	xmlSchemaTypeAnyTypeDef->subtypes = NULL;

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef

; 653  :     }
; 654  :     xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);

	push	OFFSET _xmlSchemaFreeTypeEntry
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [eax+28], 0
	call	_xmlHashFree
	add	esp, 28					; 0000001cH

; 655  :     xmlSchemaTypesInitialized = 0;

	mov	DWORD PTR _xmlSchemaTypesInitialized, 0
	pop	esi
$LN1@xmlSchemaC:

; 656  : }

	ret	0
_xmlSchemaCleanupTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaInitTypes
_TEXT	SEGMENT
_xmlSchemaInitTypes PROC				; COMDAT
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	$LN1@xmlSchemaI

; 398  :     if (xmlSchemaTypesInitialized != 0)
; 399  :         return;
; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);

	push	esi
	push	40					; 00000028H
	call	_xmlHashCreate

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 398  :     if (xmlSchemaTypesInitialized != 0)
; 399  :         return;
; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);

	mov	DWORD PTR _xmlSchemaTypesBank, eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 8

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN14@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN9@xmlSchemaI
$LN14@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_07OGOHJKKN@anyType@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_07OGOHJKKN@anyType@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 45			; 0000002dH
$LN9@xmlSchemaI:
	push	edi

; 401  : 
; 402  : 
; 403  :     /*
; 404  :     * 3.4.7 Built-in Complex Type Definition
; 405  :     */
; 406  :     xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",

	mov	DWORD PTR _xmlSchemaTypeAnyTypeDef, esi

; 407  :                                                      XML_SCHEMAS_ANYTYPE,
; 408  : 						     NULL);
; 409  :     xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;

	mov	DWORD PTR [esi+64], esi

; 410  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;
; 411  :     /*
; 412  :     * Init the content type.
; 413  :     */
; 414  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	DWORD PTR [esi+52], 3

; 415  :     {
; 416  : 	xmlSchemaParticlePtr particle;
; 417  : 	xmlSchemaModelGroupPtr sequence;
; 418  : 	xmlSchemaWildcardPtr wild;
; 419  : 	/* First particle. */
; 420  : 	particle = xmlSchemaAddParticle();

	call	_xmlSchemaAddParticle
	mov	edi, eax

; 421  : 	if (particle == NULL)

	test	edi, edi
	je	$LN915@xmlSchemaI

; 422  : 	    return;
; 423  : 	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;

	mov	ecx, DWORD PTR _xmlSchemaTypeAnyTypeDef

; 424  : 	/* Sequence model group. */
; 425  : 	sequence = (xmlSchemaModelGroupPtr)

	push	20					; 00000014H
	mov	DWORD PTR [ecx+28], edi
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 426  : 	    xmlMalloc(sizeof(xmlSchemaModelGroup));
; 427  : 	if (sequence == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 620  : }

	ret	0
$LN4@xmlSchemaI:

; 428  : 	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");
; 429  : 	    return;
; 430  : 	}
; 431  : 	memset(sequence, 0, sizeof(xmlSchemaModelGroup));

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0

; 432  : 	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;

	mov	DWORD PTR [esi], 6

; 433  : 	particle->children = (xmlSchemaTreeItemPtr) sequence;

	mov	DWORD PTR [edi+12], esi

; 434  : 	/* Second particle. */
; 435  : 	particle = xmlSchemaAddParticle();

	call	_xmlSchemaAddParticle
	mov	edi, eax

; 436  : 	if (particle == NULL)

	test	edi, edi
	je	$LN915@xmlSchemaI

; 437  : 	    return;
; 438  : 	particle->minOccurs = 0;

	mov	DWORD PTR [edi+16], 0

; 439  : 	particle->maxOccurs = UNBOUNDED;

	mov	DWORD PTR [edi+20], 1073741824		; 40000000H

; 440  : 	sequence->children = (xmlSchemaTreeItemPtr) particle;
; 441  : 	/* The wildcard */
; 442  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));

	push	44					; 0000002cH
	mov	DWORD PTR [esi+12], edi
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 443  : 	if (wild == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemaI

; 444  : 	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");

	push	OFFSET ??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@
	push	eax
	call	_xmlSchemaTypeErrMemory
	add	esp, 8
	pop	edi
	pop	esi

; 620  : }

	ret	0
$LN6@xmlSchemaI:

; 445  : 	    return;
; 446  : 	}
; 447  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0

; 448  : 	wild->type = XML_SCHEMA_TYPE_ANY;

	mov	DWORD PTR [eax], 2

; 449  : 	wild->any = 1;

	mov	DWORD PTR [eax+28], 1

; 450  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;

	mov	DWORD PTR [eax+24], 2

; 451  : 	particle->children = (xmlSchemaTreeItemPtr) wild;
; 452  : 	/*
; 453  : 	* Create the attribute wildcard.
; 454  : 	*/
; 455  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));

	push	44					; 0000002cH
	mov	DWORD PTR [edi+12], eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 456  : 	if (wild == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlSchemaI

; 457  : 	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "

	push	OFFSET ??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@
	push	eax
	call	_xmlSchemaTypeErrMemory
	add	esp, 8
	pop	edi
	pop	esi

; 620  : }

	ret	0
$LN7@xmlSchemaI:

; 458  : 		"wildcard on anyType");
; 459  : 	    return;
; 460  : 	}
; 461  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0

; 462  : 	wild->any = 1;
; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;

	mov	edi, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	DWORD PTR [eax+28], 1
	mov	DWORD PTR [eax+24], 2

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 462  : 	wild->any = 1;
; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;
; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;

	mov	DWORD PTR [edi+84], eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN37@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN32@xmlSchemaI
$LN37@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0O@DMECCPMH@anySimpleType@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0O@DMECCPMH@anySimpleType@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 46			; 0000002eH
$LN32@xmlSchemaI:

; 465  :     }
; 466  :     xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",
; 467  :                                                            XML_SCHEMAS_ANYSIMPLETYPE,
; 468  : 							   xmlSchemaTypeAnyTypeDef);
; 469  :     /*
; 470  :     * primitive datatypes
; 471  :     */
; 472  :     xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",

	push	esi
	push	1
	push	OFFSET ??_C@_06ICGJLFIM@string@
	mov	DWORD PTR _xmlSchemaTypeAnySimpleTypeDef, esi
	call	_xmlSchemaInitBasicType

; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",

	push	DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	mov	DWORD PTR _xmlSchemaTypeStringDef, eax
	push	3
	push	OFFSET ??_C@_07EEKBCPDP@decimal@
	call	_xmlSchemaInitBasicType

; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",

	mov	DWORD PTR _xmlSchemaTypeDecimalDef, eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN58@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN53@xmlSchemaI
$LN58@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_04JNIHBGGH@date@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_04JNIHBGGH@date@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 10			; 0000000aH
$LN53@xmlSchemaI:

; 479  :                                                   XML_SCHEMAS_DATE,
; 480  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 481  :     xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",

	mov	DWORD PTR _xmlSchemaTypeDateDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN79@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN74@xmlSchemaI
$LN79@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_08JHBOOHBO@dateTime@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_08JHBOOHBO@dateTime@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 11			; 0000000bH
$LN74@xmlSchemaI:

; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",

	push	DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	mov	DWORD PTR _xmlSchemaTypeDatetimeDef, esi
	push	4
	push	OFFSET ??_C@_04CLCEDBPF@time@
	call	_xmlSchemaInitBasicType

; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",

	mov	DWORD PTR _xmlSchemaTypeTimeDef, eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN100@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN95@xmlSchemaI
$LN100@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05DGCLHBFG@gYear@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_05DGCLHBFG@gYear@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 8
$LN95@xmlSchemaI:

; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",

	mov	DWORD PTR _xmlSchemaTypeGYearDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN121@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN116@xmlSchemaI
$LN121@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0L@FEFFJNNL@gYearMonth@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0L@FEFFJNNL@gYearMonth@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 9
$LN116@xmlSchemaI:

; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",

	mov	DWORD PTR _xmlSchemaTypeGYearMonthDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN142@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN137@xmlSchemaI
$LN142@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_06KBADAKNH@gMonth@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06KBADAKNH@gMonth@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 6
$LN137@xmlSchemaI:

; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",

	mov	DWORD PTR _xmlSchemaTypeGMonthDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN163@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN158@xmlSchemaI
$LN163@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_09EILODGOG@gMonthDay@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_09EILODGOG@gMonthDay@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 7
$LN158@xmlSchemaI:

; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",

	mov	DWORD PTR _xmlSchemaTypeGMonthDayDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN184@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN179@xmlSchemaI
$LN184@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_04LBFBAPHN@gDay@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_04LBFBAPHN@gDay@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 5
$LN179@xmlSchemaI:

; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",

	mov	DWORD PTR _xmlSchemaTypeGDayDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN205@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN200@xmlSchemaI
$LN205@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_08LGBPINEC@duration@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_08LGBPINEC@duration@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 12			; 0000000cH
$LN200@xmlSchemaI:

; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",

	mov	DWORD PTR _xmlSchemaTypeDurationDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN226@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN221@xmlSchemaI
$LN226@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05KNFBNCOH@float@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_05KNFBNCOH@float@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 13			; 0000000dH
$LN221@xmlSchemaI:

; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",

	mov	DWORD PTR _xmlSchemaTypeFloatDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN247@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN242@xmlSchemaI
$LN247@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_06BNJCAIGJ@double@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06BNJCAIGJ@double@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 14			; 0000000eH
$LN242@xmlSchemaI:

; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",

	mov	DWORD PTR _xmlSchemaTypeDoubleDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN268@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN263@xmlSchemaI
$LN268@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_07GOBOHMJA@boolean@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_07GOBOHMJA@boolean@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 15			; 0000000fH
$LN263@xmlSchemaI:

; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",

	mov	DWORD PTR _xmlSchemaTypeBooleanDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN289@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN284@xmlSchemaI
$LN289@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_06DLDOHKEG@anyURI@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06DLDOHKEG@anyURI@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 29			; 0000001dH
$LN284@xmlSchemaI:

; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",

	mov	DWORD PTR _xmlSchemaTypeAnyURIDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN310@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN305@xmlSchemaI
$LN310@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_09EHHLIAMK@hexBinary@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_09EHHLIAMK@hexBinary@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 43			; 0000002bH
$LN305@xmlSchemaI:

; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",

	mov	DWORD PTR _xmlSchemaTypeHexBinaryDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN331@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN326@xmlSchemaI
$LN331@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0N@NBAOPEBP@base64Binary@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0N@NBAOPEBP@base64Binary@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 44			; 0000002cH
$LN326@xmlSchemaI:

; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,

	mov	DWORD PTR _xmlSchemaTypeBase64BinaryDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN352@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN347@xmlSchemaI
$LN352@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_08NCDGCBCC@NOTATION@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 28			; 0000001cH
$LN347@xmlSchemaI:

; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",

	mov	DWORD PTR _xmlSchemaTypeNotationDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN373@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN368@xmlSchemaI
$LN373@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 16640		; 00004100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05LFDDDENB@QName@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_05LFDDDENB@QName@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 21			; 00000015H
$LN368@xmlSchemaI:

; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",

	mov	DWORD PTR _xmlSchemaTypeQNameDef, esi

; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",

	mov	esi, DWORD PTR _xmlSchemaTypeDecimalDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN394@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN389@xmlSchemaI
$LN394@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_07LKHFMGFB@integer@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_07LKHFMGFB@integer@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 30			; 0000001eH
$LN389@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",

	mov	DWORD PTR _xmlSchemaTypeIntegerDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN415@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN410@xmlSchemaI
$LN415@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0BD@FMNGDL@nonPositiveInteger@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0BD@FMNGDL@nonPositiveInteger@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 31			; 0000001fH
$LN410@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 534  :                                                      XML_SCHEMAS_INTEGER,
; 535  : 						     xmlSchemaTypeDecimalDef);
; 536  :     xmlSchemaTypeNonPositiveIntegerDef =

	mov	DWORD PTR _xmlSchemaTypeNonPositiveIntegerDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN436@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN431@xmlSchemaI
$LN436@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0BA@HJODLFEP@negativeInteger@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0BA@HJODLFEP@negativeInteger@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 32			; 00000020H
$LN431@xmlSchemaI:

; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =

	mov	esi, DWORD PTR _xmlSchemaTypeIntegerDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 537  :         xmlSchemaInitBasicType("nonPositiveInteger",
; 538  :                                XML_SCHEMAS_NPINTEGER,
; 539  : 			       xmlSchemaTypeIntegerDef);
; 540  :     xmlSchemaTypeNegativeIntegerDef =

	mov	DWORD PTR _xmlSchemaTypeNegativeIntegerDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN457@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN452@xmlSchemaI
$LN457@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_04GOKPGOLB@long@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_04GOKPGOLB@long@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 37			; 00000025H
$LN452@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =

	mov	DWORD PTR _xmlSchemaTypeLongDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN478@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN473@xmlSchemaI
$LN478@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_03JBIPMCLC@int@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_03JBIPMCLC@int@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 35			; 00000023H
$LN473@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 544  :         xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
; 545  : 	xmlSchemaTypeIntegerDef);
; 546  :     xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,

	mov	DWORD PTR _xmlSchemaTypeIntDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN499@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN494@xmlSchemaI
$LN499@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05BFKKPKCG@short@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_05BFKKPKCG@short@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 39			; 00000027H
$LN494@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 547  : 	xmlSchemaTypeLongDef);
; 548  :     xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",

	mov	DWORD PTR _xmlSchemaTypeShortDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN520@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN515@xmlSchemaI
$LN520@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_04IHGKJMLH@byte@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_04IHGKJMLH@byte@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 41			; 00000029H
$LN515@xmlSchemaI:

; 549  :                                                    XML_SCHEMAS_SHORT,
; 550  : 						   xmlSchemaTypeIntDef);
; 551  :     xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",

	mov	DWORD PTR _xmlSchemaTypeByteDef, esi

; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =

	mov	esi, DWORD PTR _xmlSchemaTypeIntegerDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN541@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN536@xmlSchemaI
$LN541@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0BD@IEOLADAC@nonNegativeInteger@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0BD@IEOLADAC@nonNegativeInteger@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 33			; 00000021H
$LN536@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =

	mov	DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN562@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN557@xmlSchemaI
$LN562@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0N@PNDKOLAJ@unsignedLong@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0N@PNDKOLAJ@unsignedLong@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 38			; 00000026H
$LN557@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 555  :         xmlSchemaInitBasicType("nonNegativeInteger",
; 556  :                                XML_SCHEMAS_NNINTEGER,
; 557  : 			       xmlSchemaTypeIntegerDef);
; 558  :     xmlSchemaTypeUnsignedLongDef =

	mov	DWORD PTR _xmlSchemaTypeUnsignedLongDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN583@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN578@xmlSchemaI
$LN583@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0M@NPFOHDP@unsignedInt@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0M@NPFOHDP@unsignedInt@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 36			; 00000024H
$LN578@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 559  :         xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
; 560  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 561  :     xmlSchemaTypeUnsignedIntDef =

	mov	DWORD PTR _xmlSchemaTypeUnsignedIntDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN604@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN599@xmlSchemaI
$LN604@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0O@NAIDFEBN@unsignedShort@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0O@NAIDFEBN@unsignedShort@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 40			; 00000028H
$LN599@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 562  :         xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
; 563  : 	xmlSchemaTypeUnsignedLongDef);
; 564  :     xmlSchemaTypeUnsignedShortDef =

	mov	DWORD PTR _xmlSchemaTypeUnsignedShortDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN625@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN620@xmlSchemaI
$LN625@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0N@BEPPBJAP@unsignedByte@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0N@BEPPBJAP@unsignedByte@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 42			; 0000002aH
$LN620@xmlSchemaI:

; 565  :         xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
; 566  : 	xmlSchemaTypeUnsignedIntDef);
; 567  :     xmlSchemaTypeUnsignedByteDef =

	mov	DWORD PTR _xmlSchemaTypeUnsignedByteDef, edi

; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =

	mov	edi, DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN646@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN641@xmlSchemaI
$LN646@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0BA@PNFEGAHG@positiveInteger@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_0BA@PNFEGAHG@positiveInteger@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 34			; 00000022H
$LN641@xmlSchemaI:

; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =

	mov	DWORD PTR _xmlSchemaTypePositiveIntegerDef, esi

; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",

	mov	esi, DWORD PTR _xmlSchemaTypeStringDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN667@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN662@xmlSchemaI
$LN667@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_0BB@HPFKIGKN@normalizedString@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_0BB@HPFKIGKN@normalizedString@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 2
$LN662@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",

	mov	DWORD PTR _xmlSchemaTypeNormStringDef, edi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN688@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN683@xmlSchemaI
$LN688@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05JMKJMOPH@token@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_05JMKJMOPH@token@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 16			; 00000010H
$LN683@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 574  :                                                         XML_SCHEMAS_NORMSTRING,
; 575  : 							xmlSchemaTypeStringDef);
; 576  :     xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",

	mov	DWORD PTR _xmlSchemaTypeTokenDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN709@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN704@xmlSchemaI
$LN709@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_08JGCCIMAA@language@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_08JGCCIMAA@language@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 17			; 00000011H
$LN704@xmlSchemaI:

; 577  :                                                    XML_SCHEMAS_TOKEN,
; 578  : 						   xmlSchemaTypeNormStringDef);
; 579  :     xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",

	mov	DWORD PTR _xmlSchemaTypeLanguageDef, edi

; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",

	mov	edi, DWORD PTR _xmlSchemaTypeTokenDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN730@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN725@xmlSchemaI
$LN730@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_04FABLJDN@Name@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_04FABLJDN@Name@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 20			; 00000014H
$LN725@xmlSchemaI:

; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",

	mov	edi, DWORD PTR _xmlSchemaTypeTokenDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",

	mov	DWORD PTR _xmlSchemaTypeNameDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN751@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN746@xmlSchemaI
$LN751@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_07JKBEJDBF@NMTOKEN@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_07JKBEJDBF@NMTOKEN@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 18			; 00000012H
$LN746@xmlSchemaI:

; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",

	mov	edi, DWORD PTR _xmlSchemaTypeNameDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",

	mov	DWORD PTR _xmlSchemaTypeNmtokenDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN772@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN767@xmlSchemaI
$LN772@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06MDLHOHLI@NCName@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 22			; 00000016H
$LN767@xmlSchemaI:

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",

	mov	DWORD PTR _xmlSchemaTypeNCNameDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN793@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN788@xmlSchemaI
$LN793@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	edi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [edi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	edi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_02OLOABKKD@ID@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [edi+8], OFFSET ??_C@_02OLOABKKD@ID@
	mov	DWORD PTR [edi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [edi+88], 23			; 00000017H
$LN788@xmlSchemaI:

; 589  :                                                     XML_SCHEMAS_NCNAME,
; 590  : 						    xmlSchemaTypeNameDef);
; 591  :     xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,

	mov	DWORD PTR _xmlSchemaTypeIdDef, edi

; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",

	mov	edi, DWORD PTR _xmlSchemaTypeNCNameDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN814@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN809@xmlSchemaI
$LN814@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_05HKGPJLPA@IDREF@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_05HKGPJLPA@IDREF@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 24			; 00000018H
$LN809@xmlSchemaI:

; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",

	mov	edi, DWORD PTR _xmlSchemaTypeNCNameDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",

	mov	DWORD PTR _xmlSchemaTypeIdrefDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN835@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	SHORT $LN830@xmlSchemaI
$LN835@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 322  : 	    break;
; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	or	DWORD PTR [esi+48], 256			; 00000100H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	push	DWORD PTR _xmlSchemaTypesBank
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06GKLBAPIO@ENTITY@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6
	call	_xmlHashAddEntry2
	add	esp, 28					; 0000001cH

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 26			; 0000001aH
$LN830@xmlSchemaI:

; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",

	mov	DWORD PTR _xmlSchemaTypeEntityDef, esi

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN856@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	$LN851@xmlSchemaI
$LN856@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	or	DWORD PTR [esi+48], 64			; 00000040H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], OFFSET ??_C@_08ICGBNEMG@ENTITIES@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6

; 244  :     ret = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	edi, eax

; 245  :     if (ret == NULL) {

	test	edi, edi
	je	SHORT $LN865@xmlSchemaI
$LN866@xmlSchemaI:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN869@xmlSchemaI
$LN870@xmlSchemaI:
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 33			; 00000021H
$LN869@xmlSchemaI:

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	mov	DWORD PTR [edi+32], eax

; 250  :     if (ret->val == NULL) {

	test	eax, eax
	jne	SHORT $LN867@xmlSchemaI

; 251  :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 252  : 	return(NULL);

	xor	edi, edi
	jmp	SHORT $LN865@xmlSchemaI
$LN867@xmlSchemaI:

; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;

	mov	DWORD PTR [eax+8], 1
$LN865@xmlSchemaI:

; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [esi+48], 134217728		; 08000000H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	DWORD PTR [esi+8]
	mov	DWORD PTR [esi+68], edi
	push	DWORD PTR _xmlSchemaTypesBank
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 27			; 0000001bH
$LN851@xmlSchemaI:

; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;

	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef

; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",

	mov	DWORD PTR _xmlSchemaTypeEntitiesDef, esi

; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;

	mov	DWORD PTR [esi+28], eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN877@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	$LN872@xmlSchemaI
$LN877@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	or	DWORD PTR [esi+48], 64			; 00000040H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], OFFSET ??_C@_06CMFBJDBA@IDREFS@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6

; 244  :     ret = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	edi, eax

; 245  :     if (ret == NULL) {

	test	edi, edi
	je	SHORT $LN886@xmlSchemaI
$LN887@xmlSchemaI:

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN890@xmlSchemaI
$LN891@xmlSchemaI:
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 33			; 00000021H
$LN890@xmlSchemaI:

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	mov	DWORD PTR [edi+32], eax

; 250  :     if (ret->val == NULL) {

	test	eax, eax
	jne	SHORT $LN888@xmlSchemaI

; 251  :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 252  : 	return(NULL);

	xor	edi, edi
	jmp	SHORT $LN886@xmlSchemaI
$LN888@xmlSchemaI:

; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;

	mov	DWORD PTR [eax+8], 1
$LN886@xmlSchemaI:

; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [esi+48], 134217728		; 08000000H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	DWORD PTR [esi+8]
	mov	DWORD PTR [esi+68], edi
	push	DWORD PTR _xmlSchemaTypesBank
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 25			; 00000019H
$LN872@xmlSchemaI:

; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef

; 612  : 
; 613  :     /* NMTOKENS */
; 614  :     xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",

	mov	edi, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	push	120					; 00000078H

; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",

	mov	DWORD PTR _xmlSchemaTypeIdrefsDef, esi

; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;

	mov	DWORD PTR [esi+28], eax

; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN898@xmlSchemaI

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	eax
	push	eax
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 273  : 	return(NULL);

	jmp	$LN893@xmlSchemaI
$LN898@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	push	esi
	call	_memset

; 276  :     ret->name = (const xmlChar *)name;
; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;
; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;
; 279  :     ret->baseType = baseType;
; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;
; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {
; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;
; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {
; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;
; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	or	DWORD PTR [esi+48], 64			; 00000040H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], OFFSET ??_C@_08PMNBPOOP@NMTOKENS@
	mov	DWORD PTR [esi+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+52], 6

; 244  :     ret = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	edi, eax

; 245  :     if (ret == NULL) {

	test	edi, edi
	je	SHORT $LN916@xmlSchemaI

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	push	32					; 00000020H

; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	DWORD PTR [edi], 1011			; 000003f3H

; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 231  :     if (value == NULL) {

	test	eax, eax
	je	SHORT $LN911@xmlSchemaI
$LN912@xmlSchemaI:
	xorps	xmm0, xmm0

; 232  : 	return(NULL);
; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0

; 235  :     value->type = type;

	mov	DWORD PTR [eax], 33			; 00000021H
$LN911@xmlSchemaI:

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	mov	DWORD PTR [edi+32], eax

; 250  :     if (ret->val == NULL) {

	test	eax, eax
	jne	SHORT $LN909@xmlSchemaI

; 251  :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN916@xmlSchemaI:

; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);

	xor	edi, edi
	jmp	SHORT $LN907@xmlSchemaI
$LN909@xmlSchemaI:

; 254  :     ret->val->value.decimal.lo = value;

	mov	DWORD PTR [eax+8], 1
$LN907@xmlSchemaI:

; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	or	DWORD PTR [esi+48], 134217728		; 08000000H

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	push	esi
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	push	DWORD PTR [esi+8]
	mov	DWORD PTR [esi+68], edi
	push	DWORD PTR _xmlSchemaTypesBank
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	DWORD PTR [esi+88], 19			; 00000013H
$LN893@xmlSchemaI:

; 615  :                                                       XML_SCHEMAS_NMTOKENS,
; 616  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 617  :     xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokenDef
	mov	DWORD PTR _xmlSchemaTypeNmtokensDef, esi
	mov	DWORD PTR [esi+28], eax

; 618  : 
; 619  :     xmlSchemaTypesInitialized = 1;

	mov	DWORD PTR _xmlSchemaTypesInitialized, 1
$LN915@xmlSchemaI:
	pop	edi
	pop	esi
$LN1@xmlSchemaI:

; 620  : }

	ret	0
_xmlSchemaInitTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 2176 :         return __stdio_common_vsscanf(

	call	___local_stdio_scanf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);
; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2275 :         __crt_va_end(_ArgList);
; 2276 :         return _Result;

	pop	esi

; 2277 :     }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_scanf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2176 :         return __stdio_common_vsscanf(
; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
