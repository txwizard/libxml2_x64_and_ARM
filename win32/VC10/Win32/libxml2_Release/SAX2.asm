; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\SAX2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__A8525CDE_sax2@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlSAX2GetPublicId
PUBLIC	_xmlSAX2GetSystemId
PUBLIC	_xmlSAX2SetDocumentLocator
PUBLIC	_xmlSAX2GetLineNumber
PUBLIC	_xmlSAX2GetColumnNumber
PUBLIC	_xmlSAX2IsStandalone
PUBLIC	_xmlSAX2HasInternalSubset
PUBLIC	_xmlSAX2HasExternalSubset
PUBLIC	_xmlSAX2InternalSubset
PUBLIC	_xmlSAX2ExternalSubset
PUBLIC	_xmlSAX2GetEntity
PUBLIC	_xmlSAX2GetParameterEntity
PUBLIC	_xmlSAX2ResolveEntity
PUBLIC	_xmlSAX2EntityDecl
PUBLIC	_xmlSAX2AttributeDecl
PUBLIC	_xmlSAX2ElementDecl
PUBLIC	_xmlSAX2NotationDecl
PUBLIC	_xmlSAX2UnparsedEntityDecl
PUBLIC	_xmlSAX2StartDocument
PUBLIC	_xmlSAX2EndDocument
PUBLIC	_xmlSAX2StartElement
PUBLIC	_xmlSAX2EndElement
PUBLIC	_xmlSAX2StartElementNs
PUBLIC	_xmlSAX2EndElementNs
PUBLIC	_xmlSAX2Reference
PUBLIC	_xmlSAX2Characters
PUBLIC	_xmlSAX2IgnorableWhitespace
PUBLIC	_xmlSAX2ProcessingInstruction
PUBLIC	_xmlSAX2Comment
PUBLIC	_xmlSAX2CDataBlock
PUBLIC	_xmlSAXDefaultVersion
PUBLIC	_xmlSAXVersion
PUBLIC	_xmlSAX2InitDefaultSAXHandler
PUBLIC	_xmlSAX2InitHtmlDefaultSAXHandler
PUBLIC	_htmlDefaultSAXHandlerInit
PUBLIC	_xmlSAX2InitDocbDefaultSAXHandler
PUBLIC	_docbDefaultSAXHandlerInit
PUBLIC	_xmlDefaultSAXHandlerInit
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0P@PCJPAHLM@out?5of?5memory?6@		; `string'
PUBLIC	??_C@_0BG@CKPEJCG@xmlSAX2InternalSubset@	; `string'
PUBLIC	??_C@_0BG@NJCKJHBI@xmlSAX2ExternalSubset@	; `string'
PUBLIC	??_C@_0EE@PPDHKGIC@Entity?$CI?$CFs?$CJ?5document?5marked?5stan@ ; `string'
PUBLIC	??_C@_0BO@LDENBHGA@Failure?5to?5process?5entity?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DD@GCBFDMPE@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@ ; `string'
PUBLIC	??_C@_0DD@ECLLADNP@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@ ; `string'
PUBLIC	??_C@_0DG@EGJGBEOC@SAX?4xmlSAX2EntityDecl?$CI?$CFs?$CJ?5calle@ ; `string'
PUBLIC	??_C@_06IMLNHOMM@xml?3id@			; `string'
PUBLIC	??_C@_0CG@DOFEKNB@xml?3id?5?3?5attribute?5type?5should?5@ ; `string'
PUBLIC	??_C@_0DJ@CKOJIFJI@SAX?4xmlSAX2AttributeDecl?$CI?$CFs?$CJ?5ca@ ; `string'
PUBLIC	??_C@_0DH@FINDFGFC@SAX?4xmlSAX2ElementDecl?$CI?$CFs?$CJ?5call@ ; `string'
PUBLIC	??_C@_0DM@OMFMKHI@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5ext@ ; `string'
PUBLIC	??_C@_0DI@MAMMGJDO@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5cal@ ; `string'
PUBLIC	??_C@_0DO@IABCNOGI@SAX?4xmlSAX2UnparsedEntityDecl?$CI?$CF@ ; `string'
PUBLIC	??_C@_0BF@BOIPPPAK@xmlSAX2StartDocument@	; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0CE@IJLGNIDG@invalid?5namespace?5declaration?5?8@ ; `string'
PUBLIC	??_C@_0CL@HKIDFKGE@Avoid?5attribute?5ending?5with?5?8?3?8@ ; `string'
PUBLIC	??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@		; `string'
PUBLIC	??_C@_0BL@KIHPGOD@xmlns?3?5?$CFs?5not?5a?5valid?5URI?6@ ; `string'
PUBLIC	??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ ; `string'
PUBLIC	??_C@_0CE@LNIJHMCD@Empty?5namespace?5name?5for?5prefix@ ; `string'
PUBLIC	??_C@_0BO@MNIAHAOJ@xmlns?3?$CFs?3?5?$CFs?5not?5a?5valid?5URI?6@ ; `string'
PUBLIC	??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ ; `string'
PUBLIC	??_C@_0DE@HNKDFNKM@Namespace?5prefix?5?$CFs?5of?5attribut@ ; `string'
PUBLIC	??_C@_0BO@PGCJKKMF@Attribute?5?$CFs?5in?5?$CFs?5redefined?6@ ; `string'
PUBLIC	??_C@_0CO@CCGEJOB@xml?3id?5?3?5attribute?5value?5?$CFs?5is?5@ ; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0CC@LPGBEFAE@Validation?5failed?3?5no?5DTD?5found@ ; `string'
PUBLIC	??_C@_0CE@HAGAOPBB@Namespace?5prefix?5?$CFs?5is?5not?5defi@ ; `string'
PUBLIC	??_C@_0BC@IJLHKBBO@xmlSAX2Characters@		; `string'
PUBLIC	??_C@_0BA@DNIHONAO@xmlSAX2TextNode@		; `string'
PUBLIC	??_C@_0BD@HFPHEGLL@xmlSAX2AttributeNs@		; `string'
PUBLIC	??_C@_0BG@CNBDKEMA@xmlSAX2StartElementNs@	; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_0CD@HMPDFDML@Namespace?5prefix?5?$CFs?5was?5not?5fou@ ; `string'
PUBLIC	??_C@_0CI@JKKHNIFK@Namespace?5default?5prefix?5was?5no@ ; `string'
PUBLIC	??_C@_0CL@EDPCIJGK@xmlSAX2Characters?3?5xmlStrdup?5re@ ; `string'
PUBLIC	??_C@_0CC@PCIHKIPC@xmlSAX2Characters?3?5huge?5text?5no@ ; `string'
PUBLIC	??_C@_0CF@EADJOGLP@xmlSAX2Characters?5overflow?5prev@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictQLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlValidateNCName:PROC
EXTRN	_xmlBuildQName:PROC
EXTRN	_xmlCreateIntSubset:PROC
EXTRN	_xmlNewDtd:PROC
EXTRN	_xmlGetIntSubset:PROC
EXTRN	_xmlFreeDtd:PROC
EXTRN	_xmlNewNs:PROC
EXTRN	_xmlNewDoc:PROC
EXTRN	_xmlNewNsProp:PROC
EXTRN	_xmlNewNsPropEatName:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlNewDocNodeEatName:PROC
EXTRN	_xmlNewDocText:PROC
EXTRN	_xmlNewDocPI:PROC
EXTRN	_xmlNewDocComment:PROC
EXTRN	_xmlNewCDataBlock:PROC
EXTRN	_xmlNewCharRef:PROC
EXTRN	_xmlNewReference:PROC
EXTRN	_xmlGetLastChild:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddChildList:PROC
EXTRN	_xmlAddSibling:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlTextConcat:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlSetNs:PROC
EXTRN	_xmlStringGetNodeList:PROC
EXTRN	_xmlStringLenGetNodeList:PROC
EXTRN	_xmlParserError:PROC
EXTRN	_xmlParserWarning:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlAddNotationDecl:PROC
EXTRN	_xmlAddElementDecl:PROC
EXTRN	_xmlFreeEnumeration:PROC
EXTRN	_xmlAddAttributeDecl:PROC
EXTRN	_xmlAddID:PROC
EXTRN	_xmlIsID:PROC
EXTRN	_xmlAddRef:PROC
EXTRN	_xmlIsRef:PROC
EXTRN	_xmlValidateRoot:PROC
EXTRN	_xmlValidateElementDecl:PROC
EXTRN	_xmlValidNormalizeAttributeValue:PROC
EXTRN	_xmlValidCtxtNormalizeAttributeValue:PROC
EXTRN	_xmlValidateAttributeDecl:PROC
EXTRN	_xmlValidateNotationDecl:PROC
EXTRN	_xmlValidateDtdFinal:PROC
EXTRN	_xmlValidateOneElement:PROC
EXTRN	_xmlValidateOneAttribute:PROC
EXTRN	_xmlValidateOneNamespace:PROC
EXTRN	_xmlValidateDocumentFinal:PROC
EXTRN	_xmlGetDtdQAttrDesc:PROC
EXTRN	_xmlGetDtdQElementDesc:PROC
EXTRN	_xmlAddDocEntity:PROC
EXTRN	_xmlAddDtdEntity:PROC
EXTRN	_xmlGetPredefinedEntity:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlGetParameterEntity:PROC
EXTRN	_xmlDetectCharEncoding:PROC
EXTRN	_xmlParseCtxtExternalEntity:PROC
EXTRN	_xmlParserAddNodeInfo:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	___docbDefaultSAXHandler:PROC
EXTRN	___htmlDefaultSAXHandler:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlRegisterNodeDefaultValue:PROC
EXTRN	_xmlSwitchEncoding:PROC
EXTRN	_xmlPushInput:PROC
EXTRN	_xmlPopInput:PROC
EXTRN	_xmlFreeInputStream:PROC
EXTRN	_xmlSplitQName:PROC
EXTRN	_xmlParseExternalSubset:PROC
EXTRN	_xmlStringDecodeEntities:PROC
EXTRN	_xmlStringLenDecodeEntities:PROC
EXTRN	_nodePush:PROC
EXTRN	_nodePop:PROC
EXTRN	_xmlErrMemory:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlPathToURI:PROC
EXTRN	_htmlNewDocNoDtD:PROC
EXTRN	_htmlIsBooleanAttr:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___xmlRegisterCallbacks:DWORD
EXTRN	_xmlStringText:BYTE
_DATA	SEGMENT
_xmlSAX2DefaultVersionValue DD 02H
_DATA	ENDS
;	COMDAT ??_C@_0CF@EADJOGLP@xmlSAX2Characters?5overflow?5prev@
CONST	SEGMENT
??_C@_0CF@EADJOGLP@xmlSAX2Characters?5overflow?5prev@ DB 'xmlSAX2Characte'
	DB	'rs overflow prevented', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PCIHKIPC@xmlSAX2Characters?3?5huge?5text?5no@
CONST	SEGMENT
??_C@_0CC@PCIHKIPC@xmlSAX2Characters?3?5huge?5text?5no@ DB 'xmlSAX2Charac'
	DB	'ters: huge text node', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EDPCIJGK@xmlSAX2Characters?3?5xmlStrdup?5re@
CONST	SEGMENT
??_C@_0CL@EDPCIJGK@xmlSAX2Characters?3?5xmlStrdup?5re@ DB 'xmlSAX2Charact'
	DB	'ers: xmlStrdup returned NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JKKHNIFK@Namespace?5default?5prefix?5was?5no@
CONST	SEGMENT
??_C@_0CI@JKKHNIFK@Namespace?5default?5prefix?5was?5no@ DB 'Namespace def'
	DB	'ault prefix was not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HMPDFDML@Namespace?5prefix?5?$CFs?5was?5not?5fou@
CONST	SEGMENT
??_C@_0CD@HMPDFDML@Namespace?5prefix?5?$CFs?5was?5not?5fou@ DB 'Namespace'
	DB	' prefix %s was not found', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNBDKEMA@xmlSAX2StartElementNs@
CONST	SEGMENT
??_C@_0BG@CNBDKEMA@xmlSAX2StartElementNs@ DB 'xmlSAX2StartElementNs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFPHEGLL@xmlSAX2AttributeNs@
CONST	SEGMENT
??_C@_0BD@HFPHEGLL@xmlSAX2AttributeNs@ DB 'xmlSAX2AttributeNs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNIHONAO@xmlSAX2TextNode@
CONST	SEGMENT
??_C@_0BA@DNIHONAO@xmlSAX2TextNode@ DB 'xmlSAX2TextNode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJLHKBBO@xmlSAX2Characters@
CONST	SEGMENT
??_C@_0BC@IJLHKBBO@xmlSAX2Characters@ DB 'xmlSAX2Characters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HAGAOPBB@Namespace?5prefix?5?$CFs?5is?5not?5defi@
CONST	SEGMENT
??_C@_0CE@HAGAOPBB@Namespace?5prefix?5?$CFs?5is?5not?5defi@ DB 'Namespace'
	DB	' prefix %s is not defined', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LPGBEFAE@Validation?5failed?3?5no?5DTD?5found@
CONST	SEGMENT
??_C@_0CC@LPGBEFAE@Validation?5failed?3?5no?5DTD?5found@ DB 'Validation f'
	DB	'ailed: no DTD found !', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
CONST	SEGMENT
??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ DB 'stand'
	DB	'alone: attribute %s on %s defaulted from external subset', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CCGEJOB@xml?3id?5?3?5attribute?5value?5?$CFs?5is?5@
CONST	SEGMENT
??_C@_0CO@CCGEJOB@xml?3id?5?3?5attribute?5value?5?$CFs?5is?5@ DB 'xml:id '
	DB	': attribute value %s is not an NCName', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PGCJKKMF@Attribute?5?$CFs?5in?5?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BO@PGCJKKMF@Attribute?5?$CFs?5in?5?$CFs?5redefined?6@ DB 'Attribut'
	DB	'e %s in %s redefined', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HNKDFNKM@Namespace?5prefix?5?$CFs?5of?5attribut@
CONST	SEGMENT
??_C@_0DE@HNKDFNKM@Namespace?5prefix?5?$CFs?5of?5attribut@ DB 'Namespace '
	DB	'prefix %s of attribute %s is not defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
CONST	SEGMENT
??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ DB 'xmln'
	DB	's:%s: URI %s is not absolute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MNIAHAOJ@xmlns?3?$CFs?3?5?$CFs?5not?5a?5valid?5URI?6@
CONST	SEGMENT
??_C@_0BO@MNIAHAOJ@xmlns?3?$CFs?3?5?$CFs?5not?5a?5valid?5URI?6@ DB 'xmlns'
	DB	':%s: %s not a valid URI', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LNIJHMCD@Empty?5namespace?5name?5for?5prefix@
CONST	SEGMENT
??_C@_0CE@LNIJHMCD@Empty?5namespace?5name?5for?5prefix@ DB 'Empty namespa'
	DB	'ce name for prefix %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
CONST	SEGMENT
??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ DB 'xmlns: U'
	DB	'RI %s is not absolute', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KIHPGOD@xmlns?3?5?$CFs?5not?5a?5valid?5URI?6@
CONST	SEGMENT
??_C@_0BL@KIHPGOD@xmlns?3?5?$CFs?5not?5a?5valid?5URI?6@ DB 'xmlns: %s not'
	DB	' a valid URI', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
CONST	SEGMENT
??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@ DB 'xmlSAX2StartElement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HKIDFKGE@Avoid?5attribute?5ending?5with?5?8?3?8@
CONST	SEGMENT
??_C@_0CL@HKIDFKGE@Avoid?5attribute?5ending?5with?5?8?3?8@ DB 'Avoid attr'
	DB	'ibute ending with '':'' like ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IJLGNIDG@invalid?5namespace?5declaration?5?8@
CONST	SEGMENT
??_C@_0CE@IJLGNIDG@invalid?5namespace?5declaration?5?8@ DB 'invalid names'
	DB	'pace declaration ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOIPPPAK@xmlSAX2StartDocument@
CONST	SEGMENT
??_C@_0BF@BOIPPPAK@xmlSAX2StartDocument@ DB 'xmlSAX2StartDocument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IABCNOGI@SAX?4xmlSAX2UnparsedEntityDecl?$CI?$CF@
CONST	SEGMENT
??_C@_0DO@IABCNOGI@SAX?4xmlSAX2UnparsedEntityDecl?$CI?$CF@ DB 'SAX.xmlSAX'
	DB	'2UnparsedEntityDecl(%s) called while not in subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MAMMGJDO@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5cal@
CONST	SEGMENT
??_C@_0DI@MAMMGJDO@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5cal@ DB 'SAX.xm'
	DB	'lSAX2NotationDecl(%s) called while not in subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@OMFMKHI@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5ext@
CONST	SEGMENT
??_C@_0DM@OMFMKHI@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5ext@ DB 'SAX.xml'
	DB	'SAX2NotationDecl(%s) externalID or PublicID missing', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FINDFGFC@SAX?4xmlSAX2ElementDecl?$CI?$CFs?$CJ?5call@
CONST	SEGMENT
??_C@_0DH@FINDFGFC@SAX?4xmlSAX2ElementDecl?$CI?$CFs?$CJ?5call@ DB 'SAX.xm'
	DB	'lSAX2ElementDecl(%s) called while not in subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CKOJIFJI@SAX?4xmlSAX2AttributeDecl?$CI?$CFs?$CJ?5ca@
CONST	SEGMENT
??_C@_0DJ@CKOJIFJI@SAX?4xmlSAX2AttributeDecl?$CI?$CFs?$CJ?5ca@ DB 'SAX.xm'
	DB	'lSAX2AttributeDecl(%s) called while not in subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DOFEKNB@xml?3id?5?3?5attribute?5type?5should?5@
CONST	SEGMENT
??_C@_0CG@DOFEKNB@xml?3id?5?3?5attribute?5type?5should?5@ DB 'xml:id : at'
	DB	'tribute type should be ID', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IMLNHOMM@xml?3id@
CONST	SEGMENT
??_C@_06IMLNHOMM@xml?3id@ DB 'xml:id', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EGJGBEOC@SAX?4xmlSAX2EntityDecl?$CI?$CFs?$CJ?5calle@
CONST	SEGMENT
??_C@_0DG@EGJGBEOC@SAX?4xmlSAX2EntityDecl?$CI?$CFs?$CJ?5calle@ DB 'SAX.xm'
	DB	'lSAX2EntityDecl(%s) called while not in subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ECLLADNP@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@
CONST	SEGMENT
??_C@_0DD@ECLLADNP@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@ DB 'Enti'
	DB	'ty(%s) already defined in the external subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GCBFDMPE@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@
CONST	SEGMENT
??_C@_0DD@GCBFDMPE@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@ DB 'Enti'
	DB	'ty(%s) already defined in the internal subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDENBHGA@Failure?5to?5process?5entity?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@LDENBHGA@Failure?5to?5process?5entity?5?$CFs?6@ DB 'Failure to '
	DB	'process entity %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PPDHKGIC@Entity?$CI?$CFs?$CJ?5document?5marked?5stan@
CONST	SEGMENT
??_C@_0EE@PPDHKGIC@Entity?$CI?$CFs?$CJ?5document?5marked?5stan@ DB 'Entit'
	DB	'y(%s) document marked standalone but requires external subset'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJCKJHBI@xmlSAX2ExternalSubset@
CONST	SEGMENT
??_C@_0BG@NJCKJHBI@xmlSAX2ExternalSubset@ DB 'xmlSAX2ExternalSubset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CKPEJCG@xmlSAX2InternalSubset@
CONST	SEGMENT
??_C@_0BG@CKPEJCG@xmlSAX2InternalSubset@ DB 'xmlSAX2InternalSubset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
CONST	SEGMENT
??_C@_0P@PCJPAHLM@out?5of?5memory?6@ DB 'out of memory', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2AttributeNs
_TEXT	SEGMENT
_fn$1 = -52						; size = 50
tv962 = 8						; size = 4
_fullname$1$ = 8					; size = 4
_namespace$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_localname$ = 12					; size = 4
_nvalnorm$1$ = 16					; size = 4
_prefix$ = 16						; size = 4
_value$ = 20						; size = 4
_valueend$ = 24						; size = 4
_xmlSAX2AttributeNs PROC				; COMDAT

; 1983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __A8525CDE_sax2@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _prefix$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _namespace$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN6@xmlSAX2Att

; 1984 :     xmlAttrPtr ret;
; 1985 :     xmlNsPtr namespace = NULL;
; 1986 :     xmlChar *dup = NULL;
; 1987 : 
; 1988 :     /*
; 1989 :      * Note: if prefix == NULL, the attribute is not in the default namespace
; 1990 :      */
; 1991 :     if (prefix != NULL)
; 1992 : 	namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);

	push	eax
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _namespace$1$[ebp], eax
	mov	ecx, eax
$LN6@xmlSAX2Att:

; 1993 : 
; 1994 :     /*
; 1995 :      * allocate the node
; 1996 :      */
; 1997 :     if (ctxt->freeAttrs != NULL) {

	mov	edi, DWORD PTR [esi+380]
	test	edi, edi
	je	$LN7@xmlSAX2Att

; 1998 :         ret = ctxt->freeAttrs;
; 1999 : 	ctxt->freeAttrs = ret->next;

	mov	eax, DWORD PTR [edi+24]

; 2000 : 	ctxt->freeAttrsNr--;

	dec	DWORD PTR [esi+376]

; 2001 : 	memset(ret, 0, sizeof(xmlAttr));

	push	48					; 00000030H
	push	0
	push	edi
	mov	DWORD PTR [esi+380], eax
	call	_memset

; 2002 : 	ret->type = XML_ATTRIBUTE_NODE;

	mov	DWORD PTR [edi+4], 2
	add	esp, 12					; 0000000cH

; 2003 : 
; 2004 : 	ret->parent = ctxt->node;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+20], eax

; 2005 : 	ret->doc = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+32], eax

; 2006 : 	ret->ns = namespace;

	mov	eax, DWORD PTR _namespace$1$[ebp]
	mov	DWORD PTR [edi+36], eax

; 2007 : 
; 2008 : 	if (ctxt->dictNames)

	cmp	DWORD PTR [esi+364], 0
	mov	eax, DWORD PTR _localname$[ebp]
	jne	SHORT $LN10@xmlSAX2Att

; 2009 : 	    ret->name = localname;
; 2010 : 	else
; 2011 : 	    ret->name = xmlStrdup(localname);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN10@xmlSAX2Att:

; 2012 : 
; 2013 :         /* link at the end to preserv order, TODO speed up with a last */
; 2014 : 	if (ctxt->node->properties == NULL) {

	mov	DWORD PTR [edi+8], eax
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ecx+44]
	test	eax, eax
	jne	SHORT $LN11@xmlSAX2Att

; 2015 : 	    ctxt->node->properties = ret;

	mov	DWORD PTR [ecx+44], edi

; 2016 : 	} else {

	jmp	SHORT $LN12@xmlSAX2Att
$LN11@xmlSAX2Att:

; 2017 : 	    xmlAttrPtr prev = ctxt->node->properties;
; 2018 : 
; 2019 : 	    while (prev->next != NULL) prev = prev->next;

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN3@xmlSAX2Att
$LL2@xmlSAX2Att:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LL2@xmlSAX2Att
$LN3@xmlSAX2Att:

; 2020 : 	    prev->next = ret;

	mov	DWORD PTR [eax+24], edi

; 2021 : 	    ret->prev = prev;

	mov	DWORD PTR [edi+28], eax
$LN12@xmlSAX2Att:

; 2022 : 	}
; 2023 : 
; 2024 : 	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN16@xmlSAX2Att
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@xmlSAX2Att

; 2025 : 	    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);

	call	___xmlRegisterNodeDefaultValue
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN16@xmlSAX2Att:

; 2034 : 	    return;
; 2035 : 	}
; 2036 :     }
; 2037 : 
; 2038 :     if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {

	cmp	DWORD PTR [esi+16], 0
	jne	$LN77@xmlSAX2Att
	cmp	DWORD PTR [esi+32], 0
	jne	$LN77@xmlSAX2Att

; 2039 : 	xmlNodePtr tmp;
; 2040 : 
; 2041 : 	/*
; 2042 : 	 * We know that if there is an entity reference, then
; 2043 : 	 * the string has been dup'ed and terminates with 0
; 2044 : 	 * otherwise with ' or "
; 2045 : 	 */
; 2046 : 	if (*valueend != 0) {

	mov	ebx, DWORD PTR _valueend$[ebp]
	mov	ecx, ebx
	mov	eax, DWORD PTR _value$[ebp]
	sub	ecx, eax
	push	ecx
	push	eax
	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN19@xmlSAX2Att

; 2047 : 	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);

	push	esi
	call	_xmlSAX2TextNode

; 2048 : 	    ret->children = tmp;
; 2049 : 	    ret->last = tmp;
; 2050 : 	    if (tmp != NULL) {

	mov	edx, DWORD PTR _value$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	je	$LN24@xmlSAX2Att

; 2051 : 		tmp->doc = ret->doc;

	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [eax+32], ecx

; 2052 : 		tmp->parent = (xmlNodePtr) ret;

	mov	DWORD PTR [eax+20], edi

; 2053 : 	    }
; 2054 : 	} else {

	jmp	$LN24@xmlSAX2Att
$LN7@xmlSAX2Att:

; 2026 :     } else {
; 2027 : 	if (ctxt->dictNames)

	cmp	DWORD PTR [esi+364], 0
	mov	edx, DWORD PTR [esi+52]
	push	0
	je	SHORT $LN14@xmlSAX2Att

; 2028 : 	    ret = xmlNewNsPropEatName(ctxt->node, namespace,

	mov	ebx, DWORD PTR _localname$[ebp]
	push	ebx
	push	ecx
	push	edx
	call	_xmlNewNsPropEatName
	jmp	SHORT $LN84@xmlSAX2Att
$LN14@xmlSAX2Att:

; 2029 : 	                              (xmlChar *) localname, NULL);
; 2030 : 	else
; 2031 : 	    ret = xmlNewNsProp(ctxt->node, namespace, localname, NULL);

	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_xmlNewNsProp
$LN84@xmlSAX2Att:

; 2032 : 	if (ret == NULL) {

	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	jne	SHORT $LN16@xmlSAX2Att

; 2033 : 	    xmlErrMemory(ctxt, "xmlSAX2AttributeNs");

	push	OFFSET ??_C@_0BD@HFPHEGLL@xmlSAX2AttributeNs@
	push	esi
	call	_xmlErrMemory
	add	esp, 8
	pop	edi

; 2188 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlSAX2Att:

; 2055 : 	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,

	push	DWORD PTR [esi+8]
	call	_xmlStringLenGetNodeList
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+12], ecx

; 2056 : 						    valueend - value);
; 2057 : 	    tmp = ret->children;
; 2058 : 	    while (tmp != NULL) {

	test	ecx, ecx
	je	SHORT $LN83@xmlSAX2Att
	npad	5
$LL4@xmlSAX2Att:

; 2059 : 	        tmp->doc = ret->doc;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [ecx+32], eax

; 2060 : 		tmp->parent = (xmlNodePtr) ret;
; 2061 : 		if (tmp->next == NULL)

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+20], edi
	test	eax, eax
	jne	SHORT $LN76@xmlSAX2Att

; 2062 : 		    ret->last = tmp;

	mov	DWORD PTR [edi+16], ecx
	mov	eax, DWORD PTR [ecx+24]
$LN76@xmlSAX2Att:

; 2063 : 		tmp = tmp->next;

	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL4@xmlSAX2Att

; 2064 : 	    }
; 2065 : 	}

	jmp	SHORT $LN83@xmlSAX2Att
$LN77@xmlSAX2Att:

; 2066 :     } else if (value != NULL) {

	mov	edx, DWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _valueend$[ebp]
	test	edx, edx
	je	SHORT $LN24@xmlSAX2Att

; 2067 : 	xmlNodePtr tmp;
; 2068 : 
; 2069 : 	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);

	mov	eax, ebx
	sub	eax, edx
	push	eax
	push	edx
	push	esi
	call	_xmlSAX2TextNode
	add	esp, 12					; 0000000cH

; 2070 : 	ret->children = tmp;

	mov	DWORD PTR [edi+12], eax

; 2071 : 	ret->last = tmp;

	mov	DWORD PTR [edi+16], eax

; 2072 : 	if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN83@xmlSAX2Att

; 2073 : 	    tmp->doc = ret->doc;

	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [eax+32], ecx

; 2074 : 	    tmp->parent = (xmlNodePtr) ret;

	mov	DWORD PTR [eax+20], edi
$LN83@xmlSAX2Att:

; 2075 : 	}
; 2076 :     }
; 2077 : 
; 2078 : #ifdef LIBXML_VALID_ENABLED
; 2079 :     if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
; 2080 :         ctxt->myDoc && ctxt->myDoc->intSubset) {

	mov	edx, DWORD PTR _value$[ebp]
$LN24@xmlSAX2Att:
	cmp	DWORD PTR [esi+32], 0
	jne	$LN25@xmlSAX2Att
	cmp	DWORD PTR [esi+104], 0
	je	$LN25@xmlSAX2Att
	cmp	DWORD PTR [esi+12], 0
	je	$LN25@xmlSAX2Att
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN25@xmlSAX2Att
	cmp	DWORD PTR [eax+44], 0
	je	$LN25@xmlSAX2Att

; 2081 : 	/*
; 2082 : 	 * If we don't substitute entities, the validation should be
; 2083 : 	 * done on a value with replaced entities anyway.
; 2084 : 	 */
; 2085 :         if (!ctxt->replaceEntities) {

	cmp	DWORD PTR [esi+16], 0
	jne	$LN27@xmlSAX2Att

; 1949 :     in = str;

	mov	ecx, edx

; 1950 :     while (in < end)

	cmp	edx, ebx
	jae	SHORT $LN54@xmlSAX2Att
$LL53@xmlSAX2Att:

; 1951 :         if (*in++ == '&')

	mov	al, BYTE PTR [ecx]
	inc	ecx
	cmp	al, 38					; 00000026H
	je	SHORT $decode$87

; 1950 :     while (in < end)

	cmp	ecx, ebx
	jb	SHORT $LL53@xmlSAX2Att
$LN54@xmlSAX2Att:

; 1952 : 	    goto decode;
; 1953 :     return(NULL);

	mov	eax, ebx
	sub	eax, edx

; 2086 : 	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
; 2087 : 	    if (dup == NULL) {

	jmp	$LN72@xmlSAX2Att
$decode$87:

; 1955 :     ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 1956 :     ret = xmlStringLenDecodeEntities(ctxt, str, end - str,

	sub	ebx, edx
	push	0
	push	0
	push	0
	push	1
	push	ebx
	push	edx
	push	esi
	mov	DWORD PTR tv962[ebp], ebx
	call	_xmlStringLenDecodeEntities

; 1957 : 				     XML_SUBSTITUTE_REF, 0,0,0);
; 1958 :     ctxt->depth--;

	dec	DWORD PTR [esi+248]
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 2086 : 	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
; 2087 : 	    if (dup == NULL) {

	test	ebx, ebx
	je	$LN79@xmlSAX2Att

; 2103 : 	        /*
; 2104 : 		 * dup now contains a string of the flattened attribute
; 2105 : 		 * content with entities substitued. Check if we need to
; 2106 : 		 * apply an extra layer of normalization.
; 2107 : 		 * It need to be done twice ... it's an extra burden related
; 2108 : 		 * to the ability to keep references in attributes
; 2109 : 		 */
; 2110 : 		if (ctxt->attsSpecial != NULL) {

	cmp	DWORD PTR [esi+352], 0
	je	SHORT $LN37@xmlSAX2Att

; 2111 : 		    xmlChar *nvalnorm;
; 2112 : 		    xmlChar fn[50];
; 2113 : 		    xmlChar *fullname;
; 2114 : 
; 2115 : 		    fullname = xmlBuildQName(localname, prefix, fn, 50);

	push	50					; 00000032H
	lea	eax, DWORD PTR _fn$1[ebp]
	push	eax
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	DWORD PTR _localname$[ebp]
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fullname$1$[ebp], eax

; 2116 : 		    if (fullname != NULL) {

	test	eax, eax
	je	SHORT $LN37@xmlSAX2Att

; 2117 : 			ctxt->vctxt.valid = 1;
; 2118 : 		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(

	push	ebx
	push	eax
	push	DWORD PTR [esi+52]
	lea	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+144], 1
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidCtxtNormalizeAttributeValue
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nvalnorm$1$[ebp], eax

; 2119 : 			                 &ctxt->vctxt, ctxt->myDoc,
; 2120 : 					 ctxt->node, fullname, dup);
; 2121 : 			if (ctxt->vctxt.valid != 1)

	cmp	DWORD PTR [esi+144], 1
	je	SHORT $LN78@xmlSAX2Att

; 2122 : 			    ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
$LN78@xmlSAX2Att:

; 2123 : 
; 2124 : 			if ((fullname != fn) && (fullname != localname))

	mov	eax, DWORD PTR _fullname$1$[ebp]
	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN36@xmlSAX2Att
	cmp	eax, DWORD PTR _localname$[ebp]
	je	SHORT $LN36@xmlSAX2Att

; 2125 : 			    xmlFree(fullname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlSAX2Att:

; 2126 : 			if (nvalnorm != NULL) {

	cmp	DWORD PTR _nvalnorm$1$[ebp], 0
	je	SHORT $LN37@xmlSAX2Att

; 2127 : 			    xmlFree(dup);

	push	ebx
	call	DWORD PTR _xmlFree

; 2128 : 			    dup = nvalnorm;

	mov	ebx, DWORD PTR _nvalnorm$1$[ebp]
	add	esp, 4
$LN37@xmlSAX2Att:

; 2129 : 			}
; 2130 : 		    }
; 2131 : 		}
; 2132 : 
; 2133 : 		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	push	ebx
	push	edi
	push	DWORD PTR [esi+52]
	lea	eax, DWORD PTR [esi+108]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidateOneAttribute
	add	esp, 20					; 00000014H
	and	DWORD PTR [esi+100], eax

; 2134 : 			        ctxt->myDoc, ctxt->node, ret, dup);
; 2135 : 	    }
; 2136 : 	} else {

	jmp	$LN48@xmlSAX2Att
$LN79@xmlSAX2Att:

; 2086 : 	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
; 2087 : 	    if (dup == NULL) {

	mov	ebx, DWORD PTR _valueend$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR tv962[ebp]
$LN72@xmlSAX2Att:

; 2088 : 	        if (*valueend == 0) {

	cmp	BYTE PTR [ebx], 0
	lea	ecx, DWORD PTR [esi+108]
	jne	SHORT $LN31@xmlSAX2Att

; 2089 : 		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	push	edx
	push	edi
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	push	ecx
	call	_xmlValidateOneAttribute
	add	esp, 20					; 00000014H
	and	DWORD PTR [esi+100], eax
	pop	edi

; 2188 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlSAX2Att:

; 2090 : 				    ctxt->myDoc, ctxt->node, ret, value);
; 2091 : 		} else {
; 2092 : 		    /*
; 2093 : 		     * That should already be normalized.
; 2094 : 		     * cheaper to finally allocate here than duplicate
; 2095 : 		     * entry points in the full validation code
; 2096 : 		     */
; 2097 : 		    dup = xmlStrndup(value, valueend - value);

	push	eax
	push	edx
	call	_xmlStrndup
	mov	ebx, eax

; 2098 : 
; 2099 : 		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	lea	eax, DWORD PTR [esi+108]
	push	ebx
	push	edi
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidateOneAttribute
	add	esp, 28					; 0000001cH
	and	DWORD PTR [esi+100], eax

; 2100 : 				    ctxt->myDoc, ctxt->node, ret, dup);
; 2101 : 		}
; 2102 : 	    } else {

	jmp	$LN48@xmlSAX2Att
$LN27@xmlSAX2Att:

; 2137 : 	    /*
; 2138 : 	     * if entities already have been substitued, then
; 2139 : 	     * the attribute as passed is already normalized
; 2140 : 	     */
; 2141 : 	    dup = xmlStrndup(value, valueend - value);

	sub	ebx, edx
	push	ebx
	push	edx
	call	_xmlStrndup
	mov	ebx, eax

; 2142 : 
; 2143 : 	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	lea	eax, DWORD PTR [esi+108]
	push	ebx
	push	edi
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidateOneAttribute
	add	esp, 28					; 0000001cH
	and	DWORD PTR [esi+100], eax

; 2144 : 	                             ctxt->myDoc, ctxt->node, ret, dup);
; 2145 : 	}
; 2146 :     } else

	jmp	$LN48@xmlSAX2Att
$LN25@xmlSAX2Att:

; 2147 : #endif /* LIBXML_VALID_ENABLED */
; 2148 :            if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&

	test	BYTE PTR [esi+276], 8
	jne	$LN50@xmlSAX2Att
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN71@xmlSAX2Att
	cmp	DWORD PTR [esi+96], 2
	jne	SHORT $LN39@xmlSAX2Att

; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlSAX2Att:

; 2147 : #endif /* LIBXML_VALID_ENABLED */
; 2148 :            if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&

	cmp	DWORD PTR [esi+216], 0
	jne	$LN50@xmlSAX2Att
$LN39@xmlSAX2Att:

; 2149 : 	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
; 2150 : 	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {
; 2151 :         /*
; 2152 : 	 * when validating, the ID registration is done at the attribute
; 2153 : 	 * validation level. Otherwise we have to do specific handling here.
; 2154 : 	 */
; 2155 :         if ((prefix == ctxt->str_xml) &&
; 2156 : 	           (localname[0] == 'i') && (localname[1] == 'd') &&

	mov	eax, DWORD PTR _prefix$[ebp]
	cmp	eax, DWORD PTR [esi+312]
	jne	SHORT $LN41@xmlSAX2Att
	mov	eax, DWORD PTR _localname$[ebp]
	cmp	BYTE PTR [eax], 105			; 00000069H
	jne	SHORT $LN41@xmlSAX2Att
	cmp	BYTE PTR [eax+1], 100			; 00000064H
	jne	SHORT $LN41@xmlSAX2Att
	cmp	BYTE PTR [eax+2], 0
	jne	SHORT $LN41@xmlSAX2Att

; 2157 : 		   (localname[2] == 0)) {
; 2158 : 	    /*
; 2159 : 	     * Add the xml:id value
; 2160 : 	     *
; 2161 : 	     * Open issue: normalization of the value.
; 2162 : 	     */
; 2163 : 	    if (dup == NULL)
; 2164 : 	        dup = xmlStrndup(value, valueend - value);

	sub	ebx, edx
	push	ebx
	push	edx
	call	_xmlStrndup
	mov	ebx, eax

; 2165 : #if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
; 2166 : #ifdef LIBXML_VALID_ENABLED
; 2167 : 	    if (xmlValidateNCName(dup, 1) != 0) {

	push	1
	push	ebx
	call	_xmlValidateNCName
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN44@xmlSAX2Att

; 2168 : 	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,

	push	0
	push	ebx
	push	OFFSET ??_C@_0CO@CCGEJOB@xml?3id?5?3?5attribute?5value?5?$CFs?5is?5@
	push	539					; 0000021bH
	push	esi
	call	_xmlErrValid
	add	esp, 20					; 00000014H
$LN44@xmlSAX2Att:

; 2169 : 		      "xml:id : attribute value %s is not an NCName\n",
; 2170 : 			    (const char *) dup, NULL);
; 2171 : 	    }
; 2172 : #endif
; 2173 : #endif
; 2174 : 	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);

	push	edi
	push	ebx
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlAddID
	add	esp, 16					; 00000010H
	jmp	SHORT $LN48@xmlSAX2Att
$LN41@xmlSAX2Att:

; 2175 : 	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {

	push	edi
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN45@xmlSAX2Att

; 2176 : 	    /* might be worth duplicate entry points and not copy */
; 2177 : 	    if (dup == NULL)
; 2178 : 	        dup = xmlStrndup(value, valueend - value);

	mov	eax, DWORD PTR _value$[ebp]
	sub	ebx, eax
	push	ebx
	push	eax
	call	_xmlStrndup
	mov	ebx, eax

; 2179 : 	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);

	lea	eax, DWORD PTR [esi+108]
	push	edi
	push	ebx
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlAddID
	jmp	SHORT $LN85@xmlSAX2Att
$LN45@xmlSAX2Att:

; 2180 : 	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {

	push	edi
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlIsRef
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN50@xmlSAX2Att

; 2181 : 	    if (dup == NULL)
; 2182 : 	        dup = xmlStrndup(value, valueend - value);

	mov	eax, DWORD PTR _value$[ebp]
	sub	ebx, eax
	push	ebx
	push	eax
	call	_xmlStrndup
	mov	ebx, eax

; 2183 : 	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, dup, ret);

	lea	eax, DWORD PTR [esi+108]
	push	edi
	push	ebx
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlAddRef
$LN85@xmlSAX2Att:

; 2184 : 	}
; 2185 :     }
; 2186 :     if (dup != NULL)

	add	esp, 24					; 00000018H
$LN48@xmlSAX2Att:
	test	ebx, ebx
	je	SHORT $LN50@xmlSAX2Att

; 2187 : 	xmlFree(dup);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlSAX2Att:

; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2AttributeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2DecodeAttrEntities
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_end$ = 16						; size = 4
_xmlSAX2DecodeAttrEntities PROC				; COMDAT

; 1945 :                           const xmlChar *end) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	mov	eax, edi
	mov	edx, DWORD PTR _end$[ebp]
	cmp	edi, edx
	jae	SHORT $LN3@xmlSAX2Dec
	npad	6
$LL2@xmlSAX2Dec:

; 1951 :         if (*in++ == '&')

	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, 38					; 00000026H
	je	SHORT $decode$11

; 1946 :     const xmlChar *in;
; 1947 :     xmlChar *ret;
; 1948 : 
; 1949 :     in = str;
; 1950 :     while (in < end)

	cmp	eax, edx
	jb	SHORT $LL2@xmlSAX2Dec
$LN3@xmlSAX2Dec:

; 1952 : 	    goto decode;
; 1953 :     return(NULL);

	xor	eax, eax
	pop	edi

; 1960 : }

	pop	ebp
	ret	0
$decode$11:
	push	esi

; 1954 : decode:
; 1955 :     ctxt->depth++;

	mov	esi, DWORD PTR _ctxt$[ebp]

; 1956 :     ret = xmlStringLenDecodeEntities(ctxt, str, end - str,

	sub	edx, edi
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+248]
	push	1
	push	edx
	push	edi
	push	esi
	call	_xmlStringLenDecodeEntities
	add	esp, 28					; 0000001cH

; 1957 : 				     XML_SUBSTITUTE_REF, 0,0,0);
; 1958 :     ctxt->depth--;

	dec	DWORD PTR [esi+248]

; 1959 :     return(ret);

	pop	esi
	pop	edi

; 1960 : }

	pop	ebp
	ret	0
_xmlSAX2DecodeAttrEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2TextNode
_TEXT	SEGMENT
_intern$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSAX2TextNode PROC					; COMDAT

; 1855 : xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [edi+372]
	test	esi, esi
	je	SHORT $LN5@xmlSAX2Tex

; 1856 :     xmlNodePtr ret;
; 1857 :     const xmlChar *intern = NULL;
; 1858 : 
; 1859 :     /*
; 1860 :      * Allocate
; 1861 :      */
; 1862 :     if (ctxt->freeElems != NULL) {
; 1863 : 	ret = ctxt->freeElems;
; 1864 : 	ctxt->freeElems = ret->next;
; 1865 : 	ctxt->freeElemsNr--;

	mov	eax, DWORD PTR [esi+24]
	dec	DWORD PTR [edi+368]
	mov	DWORD PTR [edi+372], eax

; 1866 :     } else {

	jmp	SHORT $LN6@xmlSAX2Tex
$LN5@xmlSAX2Tex:

; 1867 : 	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	esi, eax
$LN6@xmlSAX2Tex:

; 1868 :     }
; 1869 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlSAX2Tex

; 1870 :         xmlErrMemory(ctxt, "xmlSAX2Characters");

	push	OFFSET ??_C@_0BC@IJLHKBBO@xmlSAX2Characters@
	push	edi
	call	_xmlErrMemory
	add	esp, 8

; 1871 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 1930 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlSAX2Tex:
	push	ebx

; 1872 :     }
; 1873 :     memset(ret, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	esi
	call	_memset

; 1874 :     /*
; 1875 :      * intern the formatting blanks found between tags, or the
; 1876 :      * very short strings
; 1877 :      */
; 1878 :     if (ctxt->dictNames) {

	mov	ebx, DWORD PTR _len$[ebp]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [edi+364], 0
	mov	edx, DWORD PTR _str$[ebp]
	je	$LN39@xmlSAX2Tex

; 1879 :         xmlChar cur = str[len];

	mov	cl, BYTE PTR [edx+ebx]

; 1880 : 
; 1881 : 	if ((len < (int) (2 * sizeof(void *))) &&

	cmp	ebx, 8
	jge	SHORT $LN9@xmlSAX2Tex
	test	DWORD PTR [edi+360], 65536		; 00010000H
	je	SHORT $LN9@xmlSAX2Tex

; 1882 : 	    (ctxt->options & XML_PARSE_COMPACT)) {
; 1883 : 	    /* store the string in the node overriding properties and nsDef */
; 1884 : 	    xmlChar *tmp = (xmlChar *) &(ret->properties);
; 1885 : 	    memcpy(tmp, str, len);

	push	ebx
	lea	eax, DWORD PTR [esi+44]
	push	edx
	push	eax
	mov	DWORD PTR _intern$1$[ebp], eax
	call	_memcpy

; 1886 : 	    tmp[len] = 0;

	mov	eax, DWORD PTR _intern$1$[ebp]
	add	esp, 12					; 0000000cH

; 1887 : 	    intern = tmp;

	mov	edx, DWORD PTR _str$[ebp]
	mov	BYTE PTR [eax+ebx], 0
	jmp	SHORT $skip$43
$LN9@xmlSAX2Tex:

; 1888 : 	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||

	cmp	ebx, 3
	jg	SHORT $LN11@xmlSAX2Tex
	cmp	cl, 34					; 00000022H
	je	SHORT $LN13@xmlSAX2Tex
	cmp	cl, 39					; 00000027H
	je	SHORT $LN13@xmlSAX2Tex
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN11@xmlSAX2Tex
	cmp	BYTE PTR [edx+ebx+1], 33		; 00000021H
	je	SHORT $LN11@xmlSAX2Tex
$LN13@xmlSAX2Tex:

; 1897 : 	    }
; 1898 : 	    intern = xmlDictLookup(ctxt->dict, str, len);
; 1899 : 	}
; 1900 :     }
; 1901 : skip:
; 1902 :     ret->type = XML_TEXT_NODE;

	push	ebx
	push	edx
	push	DWORD PTR [edi+296]
	call	_xmlDictLookup
	mov	edx, DWORD PTR _str$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $skip$43
$LN11@xmlSAX2Tex:

; 1889 : 	    ((cur == '<') && (str[len + 1] != '!')))) {
; 1890 : 	    intern = xmlDictLookup(ctxt->dict, str, len);
; 1891 : 	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlSAX2Tex
	cmp	al, 9
	jb	SHORT $LN16@xmlSAX2Tex
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlSAX2Tex
$LN16@xmlSAX2Tex:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN39@xmlSAX2Tex
$LN15@xmlSAX2Tex:
	cmp	ebx, 60					; 0000003cH
	jge	SHORT $LN39@xmlSAX2Tex
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN39@xmlSAX2Tex
	cmp	BYTE PTR [edx+ebx+1], 33		; 00000021H
	je	SHORT $LN39@xmlSAX2Tex

; 1892 : 	           (str[len + 1] != '!')) {
; 1893 : 	    int i;
; 1894 : 
; 1895 : 	    for (i = 1;i < len;i++) {

	mov	ecx, 1
	cmp	ebx, ecx
	jle	SHORT $LN13@xmlSAX2Tex
$LL4@xmlSAX2Tex:

; 1896 : 		if (!IS_BLANK_CH(str[i])) goto skip;

	mov	al, BYTE PTR [ecx+edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN2@xmlSAX2Tex
	cmp	al, 9
	jb	SHORT $LN18@xmlSAX2Tex
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN2@xmlSAX2Tex
$LN18@xmlSAX2Tex:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN39@xmlSAX2Tex
$LN2@xmlSAX2Tex:

; 1892 : 	           (str[len + 1] != '!')) {
; 1893 : 	    int i;
; 1894 : 
; 1895 : 	    for (i = 1;i < len;i++) {

	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL4@xmlSAX2Tex

; 1874 :     /*
; 1875 :      * intern the formatting blanks found between tags, or the
; 1876 :      * very short strings
; 1877 :      */
; 1878 :     if (ctxt->dictNames) {

	jmp	SHORT $LN13@xmlSAX2Tex
$LN39@xmlSAX2Tex:

; 1897 : 	    }
; 1898 : 	    intern = xmlDictLookup(ctxt->dict, str, len);
; 1899 : 	}
; 1900 :     }
; 1901 : skip:
; 1902 :     ret->type = XML_TEXT_NODE;

	xor	eax, eax
$skip$43:
	mov	DWORD PTR [esi+4], 3

; 1903 : 
; 1904 :     ret->name = xmlStringText;

	mov	DWORD PTR [esi+8], OFFSET _xmlStringText

; 1905 :     if (intern == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlSAX2Tex

; 1906 : 	ret->content = xmlStrndup(str, len);

	push	ebx
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [esi+40], eax

; 1907 : 	if (ret->content == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlSAX2Tex

; 1908 : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");

	push	OFFSET ??_C@_0BA@DNIHONAO@xmlSAX2TextNode@
	push	edi
	call	_xmlSAX2ErrMemory

; 1909 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 1910 : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1930 : }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlSAX2Tex:

; 1911 : 	}
; 1912 :     } else
; 1913 : 	ret->content = (xmlChar *) intern;

	mov	DWORD PTR [esi+40], eax
$LN20@xmlSAX2Tex:

; 1914 : 
; 1915 :     if (ctxt->linenumbers) {

	cmp	DWORD PTR [edi+280], 0
	je	SHORT $LN26@xmlSAX2Tex

; 1916 : 	if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN26@xmlSAX2Tex

; 1917 : 	    if (ctxt->input->line < 65535)

	mov	eax, DWORD PTR [eax+28]
	cmp	eax, 65535				; 0000ffffH
	jge	SHORT $LN24@xmlSAX2Tex

; 1918 : 		ret->line = (short) ctxt->input->line;

	mov	WORD PTR [esi+56], ax
	jmp	SHORT $LN26@xmlSAX2Tex
$LN24@xmlSAX2Tex:

; 1919 : 	    else {
; 1920 : 	        ret->line = 65535;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR [esi+56], ax

; 1921 : 		if (ctxt->options & XML_PARSE_BIG_LINES)

	test	DWORD PTR [edi+360], 4194304		; 00400000H
	je	SHORT $LN26@xmlSAX2Tex

; 1922 : 		    ret->psvi = (void *) (ptrdiff_t) ctxt->input->line;

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [esi+52], eax
$LN26@xmlSAX2Tex:

; 1923 : 	    }
; 1924 : 	}
; 1925 :     }
; 1926 : 
; 1927 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN27@xmlSAX2Tex
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN27@xmlSAX2Tex

; 1928 : 	xmlRegisterNodeDefaultValue(ret);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN27@xmlSAX2Tex:

; 1929 :     return(ret);

	pop	ebx
	pop	edi
	mov	eax, esi

; 1930 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSAX2TextNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlCheckDefaultedAttributes
_TEXT	SEGMENT
_fn$1 = -64						; size = 50
_internal$1$ = -12					; size = 4
_elemDecl$1$ = -8					; size = 4
_fulln$1$ = -4						; size = 4
_fulln$3$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_prefix$ = 16						; size = 4
_atts$ = 20						; size = 4
_xmlCheckDefaultedAttributes PROC			; COMDAT

; 1437 : 	const xmlChar *prefix, const xmlChar **atts) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR _prefix$[ebp]
	mov	esi, DWORD PTR _name$[ebp]
	push	ebx
	mov	eax, DWORD PTR [edi+8]
	push	esi
	mov	DWORD PTR _internal$1$[ebp], 1
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQElementDesc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _elemDecl$1$[ebp], eax
	test	eax, eax
	jne	SHORT $process_external_subset$110

; 1438 :     xmlElementPtr elemDecl;
; 1439 :     const xmlChar *att;
; 1440 :     int internal = 1;
; 1441 :     int i;
; 1442 : 
; 1443 :     elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->intSubset, name, prefix);
; 1444 :     if (elemDecl == NULL) {
; 1445 : 	elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix);

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	push	esi
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdQElementDesc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _elemDecl$1$[ebp], eax

; 1446 : 	internal = 0;

	mov	DWORD PTR _internal$1$[ebp], 0

; 1447 :     }
; 1448 : 
; 1449 : process_external_subset:
; 1450 : 
; 1451 :     if (elemDecl != NULL) {

	test	eax, eax
	je	$LN87@xmlCheckDe
	npad	4
$process_external_subset$110:

; 1452 : 	xmlAttributePtr attr = elemDecl->attributes;

	mov	ebx, DWORD PTR [eax+44]

; 1453 : 	/*
; 1454 : 	 * Check against defaulted attributes from the external subset
; 1455 : 	 * if the document is stamped as standalone
; 1456 : 	 */
; 1457 : 	if ((ctxt->myDoc->standalone == 1) &&
; 1458 : 	    (ctxt->myDoc->extSubset != NULL) &&

	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax+40], 1
	jne	$LN86@xmlCheckDe
	cmp	DWORD PTR [eax+48], 0
	je	$LN86@xmlCheckDe
	cmp	DWORD PTR [edi+104], 0
	je	$LN86@xmlCheckDe

; 1459 : 	    (ctxt->validate)) {
; 1460 : 	    while (attr != NULL) {

	test	ebx, ebx
	je	$LN86@xmlCheckDe
	npad	4
$LL2@xmlCheckDe:

; 1461 : 		if ((attr->defaultValue != NULL) &&
; 1462 : 		    (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset,
; 1463 : 					attr->elem, attr->name,
; 1464 : 					attr->prefix) == attr) &&

	cmp	DWORD PTR [ebx+48], 0
	je	$LN13@xmlCheckDe
	push	DWORD PTR [ebx+56]
	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+60]
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jne	$LN13@xmlCheckDe
	push	DWORD PTR [ebx+56]
	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+60]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN13@xmlCheckDe

; 1465 : 		    (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,
; 1466 : 					attr->elem, attr->name,
; 1467 : 					attr->prefix) == NULL)) {
; 1468 : 		    xmlChar *fulln;
; 1469 : 
; 1470 : 		    if (attr->prefix != NULL) {

	mov	eax, DWORD PTR [ebx+56]
	test	eax, eax
	je	SHORT $LN14@xmlCheckDe

; 1471 : 			fulln = xmlStrdup(attr->prefix);

	push	eax
	call	_xmlStrdup

; 1472 : 			fulln = xmlStrcat(fulln, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 1473 : 			fulln = xmlStrcat(fulln, attr->name);

	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H

; 1474 : 		    } else {

	jmp	SHORT $LN106@xmlCheckDe
$LN14@xmlCheckDe:

; 1475 : 			fulln = xmlStrdup(attr->name);

	push	DWORD PTR [ebx+8]
	call	_xmlStrdup
	add	esp, 4
$LN106@xmlCheckDe:

; 1476 : 		    }
; 1477 :                     if (fulln == NULL) {

	mov	DWORD PTR _fulln$3$[ebp], eax
	test	eax, eax
	je	SHORT $LN40@xmlCheckDe

; 1479 :                         break;
; 1480 :                     }
; 1481 : 
; 1482 : 		    /*
; 1483 : 		     * Check that the attribute is not declared in the
; 1484 : 		     * serialization
; 1485 : 		     */
; 1486 : 		    att = NULL;
; 1487 : 		    if (atts != NULL) {

	mov	ecx, DWORD PTR _atts$[ebp]
	test	ecx, ecx
	je	SHORT $LN59@xmlCheckDe

; 1488 : 			i = 0;
; 1489 : 			att = atts[i];

	mov	esi, DWORD PTR [ecx]

; 1490 : 			while (att != NULL) {

	test	esi, esi
	je	SHORT $LN59@xmlCheckDe

; 1488 : 			i = 0;
; 1489 : 			att = atts[i];

	mov	edi, ecx
	npad	1
$LL4@xmlCheckDe:

; 1491 : 			    if (xmlStrEqual(att, fulln))

	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN39@xmlCheckDe

; 1492 : 				break;
; 1493 : 			    i += 2;
; 1494 : 			    att = atts[i];

	mov	esi, DWORD PTR [edi+8]
	add	edi, 8
	mov	eax, DWORD PTR _fulln$3$[ebp]
	test	esi, esi
	jne	SHORT $LL4@xmlCheckDe

; 1495 : 			}
; 1496 : 		    }
; 1497 : 		    if (att == NULL) {

	jmp	SHORT $LN107@xmlCheckDe
$LN39@xmlCheckDe:
	test	esi, esi
	jne	SHORT $LN100@xmlCheckDe
$LN107@xmlCheckDe:

; 1498 : 		        xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _fulln$3$[ebp]
$LN59@xmlCheckDe:
	push	DWORD PTR [ebx+60]
	push	eax
	push	OFFSET ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
	push	538					; 0000021aH
	push	edi
	call	_xmlErrValid
	add	esp, 20					; 00000014H
	jmp	SHORT $LN19@xmlCheckDe
$LN100@xmlCheckDe:

; 1495 : 			}
; 1496 : 		    }
; 1497 : 		    if (att == NULL) {

	mov	edi, DWORD PTR _ctxt$[ebp]
$LN19@xmlCheckDe:

; 1499 :       "standalone: attribute %s on %s defaulted from external subset\n",
; 1500 : 				    (const char *)fulln,
; 1501 : 				    (const char *)attr->elem);
; 1502 : 		    }
; 1503 :                     xmlFree(fulln);

	push	DWORD PTR _fulln$3$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlCheckDe:

; 1504 : 		}
; 1505 : 		attr = attr->nexth;

	mov	ebx, DWORD PTR [ebx+36]
	test	ebx, ebx
	jne	$LL2@xmlCheckDe

; 1459 : 	    (ctxt->validate)) {
; 1460 : 	    while (attr != NULL) {

	jmp	SHORT $LN86@xmlCheckDe
$LN40@xmlCheckDe:

; 1478 :                         xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	edi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN86@xmlCheckDe:

; 1506 : 	    }
; 1507 : 	}
; 1508 : 
; 1509 : 	/*
; 1510 : 	 * Actually insert defaulted values when needed
; 1511 : 	 */
; 1512 : 	attr = elemDecl->attributes;

	mov	edi, DWORD PTR _elemDecl$1$[ebp]
	mov	edi, DWORD PTR [edi+44]

; 1513 : 	while (attr != NULL) {

	test	edi, edi
	je	$LN7@xmlCheckDe
	npad	8
$LL6@xmlCheckDe:

; 1514 : 	    /*
; 1515 : 	     * Make sure that attributes redefinition occuring in the
; 1516 : 	     * internal subset are not overriden by definitions in the
; 1517 : 	     * external subset.
; 1518 : 	     */
; 1519 : 	    if (attr->defaultValue != NULL) {

	cmp	DWORD PTR [edi+48], 0
	je	$LN31@xmlCheckDe

; 1520 : 		/*
; 1521 : 		 * the element should be instantiated in the tree if:
; 1522 : 		 *  - this is a namespace prefix
; 1523 : 		 *  - the user required for completion in the tree
; 1524 : 		 *    like XSLT
; 1525 : 		 *  - there isn't already an attribute definition
; 1526 : 		 *    in the internal subset overriding it.
; 1527 : 		 */
; 1528 : 		if (((attr->prefix != NULL) &&
; 1529 : 		     (xmlStrEqual(attr->prefix, BAD_CAST "xmlns"))) ||
; 1530 : 		    ((attr->prefix == NULL) &&
; 1531 : 		     (xmlStrEqual(attr->name, BAD_CAST "xmlns"))) ||

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN23@xmlCheckDe
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN99@xmlCheckDe
$LN23@xmlCheckDe:
	cmp	DWORD PTR [edi+56], 0
	jne	SHORT $LN24@xmlCheckDe
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN99@xmlCheckDe
$LN24@xmlCheckDe:
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	BYTE PTR [eax+276], 4
	je	$LN31@xmlCheckDe
	jmp	SHORT $LN22@xmlCheckDe
$LN99@xmlCheckDe:

; 1532 : 		    (ctxt->loadsubset & XML_COMPLETE_ATTRS)) {
; 1533 : 		    xmlAttributePtr tst;
; 1534 : 
; 1535 : 		    tst = xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN22@xmlCheckDe:
	push	DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+60]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H

; 1536 : 					     attr->elem, attr->name,
; 1537 : 					     attr->prefix);
; 1538 : 		    if ((tst == attr) || (tst == NULL)) {

	cmp	eax, edi
	je	SHORT $LN26@xmlCheckDe
	test	eax, eax
	jne	SHORT $LN31@xmlCheckDe
$LN26@xmlCheckDe:

; 1539 : 		        xmlChar fn[50];
; 1540 : 			xmlChar *fulln;
; 1541 : 
; 1542 :                         fulln = xmlBuildQName(attr->name, attr->prefix, fn, 50);

	push	50					; 00000032H
	lea	eax, DWORD PTR _fn$1[ebp]
	push	eax
	push	DWORD PTR [edi+56]
	push	DWORD PTR [edi+8]
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fulln$1$[ebp], eax

; 1543 : 			if (fulln == NULL) {

	test	eax, eax
	je	$LN42@xmlCheckDe

; 1545 : 			    return;
; 1546 : 			}
; 1547 : 
; 1548 : 			/*
; 1549 : 			 * Check that the attribute is not declared in the
; 1550 : 			 * serialization
; 1551 : 			 */
; 1552 : 			att = NULL;
; 1553 : 			if (atts != NULL) {

	mov	ecx, DWORD PTR _atts$[ebp]
	test	ecx, ecx
	je	SHORT $LN58@xmlCheckDe

; 1554 : 			    i = 0;
; 1555 : 			    att = atts[i];

	mov	esi, DWORD PTR [ecx]

; 1556 : 			    while (att != NULL) {

	test	esi, esi
	je	SHORT $LN58@xmlCheckDe

; 1554 : 			    i = 0;
; 1555 : 			    att = atts[i];

	mov	ebx, ecx
	npad	1
$LL8@xmlCheckDe:

; 1557 : 				if (xmlStrEqual(att, fulln))

	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@xmlCheckDe

; 1558 : 				    break;
; 1559 : 				i += 2;
; 1560 : 				att = atts[i];

	mov	esi, DWORD PTR [ebx+8]
	add	ebx, 8
	mov	eax, DWORD PTR _fulln$1$[ebp]
	test	esi, esi
	jne	SHORT $LL8@xmlCheckDe

; 1561 : 			    }
; 1562 : 			}
; 1563 : 			if (att == NULL) {

	jmp	SHORT $LN108@xmlCheckDe
$LN41@xmlCheckDe:
	test	esi, esi
	jne	SHORT $LN30@xmlCheckDe
$LN108@xmlCheckDe:

; 1564 : 			    xmlSAX2AttributeInternal(ctxt, fulln,

	mov	eax, DWORD PTR _fulln$1$[ebp]
$LN58@xmlCheckDe:
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR [edi+48]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSAX2AttributeInternal
	add	esp, 16					; 00000010H
$LN30@xmlCheckDe:

; 1565 : 						 attr->defaultValue, prefix);
; 1566 : 			}
; 1567 : 			if ((fulln != fn) && (fulln != attr->name))

	mov	eax, DWORD PTR _fulln$1$[ebp]
	lea	ecx, DWORD PTR _fn$1[ebp]
	cmp	eax, ecx
	je	SHORT $LN31@xmlCheckDe
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN31@xmlCheckDe

; 1568 : 			    xmlFree(fulln);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlCheckDe:

; 1569 : 		    }
; 1570 : 		}
; 1571 : 	    }
; 1572 : 	    attr = attr->nexth;

	mov	edi, DWORD PTR [edi+36]
	test	edi, edi
	jne	$LL6@xmlCheckDe
$LN7@xmlCheckDe:

; 1573 : 	}
; 1574 : 	if (internal == 1) {

	cmp	DWORD PTR _internal$1$[ebp], 1
	jne	SHORT $LN87@xmlCheckDe

; 1575 : 	    elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset,

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [eax+48]
	call	_xmlGetDtdQElementDesc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _elemDecl$1$[ebp], eax

; 1576 : 		                             name, prefix);
; 1577 : 	    internal = 0;

	mov	DWORD PTR _internal$1$[ebp], 0
	test	eax, eax
	jne	$process_external_subset$110

; 1578 : 	    goto process_external_subset;
; 1579 : 	}
; 1580 :     }
; 1581 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlCheckDe:

; 1544 : 			    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN87@xmlCheckDe:

; 1578 : 	    goto process_external_subset;
; 1579 : 	}
; 1580 :     }
; 1581 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckDefaultedAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2AttributeInternal
_TEXT	SEGMENT
_nvalnorm$1$ = -12					; size = 4
_nsret$1$ = -12						; size = 4
_uri$1$ = -12						; size = 4
_uri$1$ = -12						; size = 4
_nval$1$ = -8						; size = 4
_ns$ = -4						; size = 4
_val$1$ = 8						; size = 4
_val$1$ = 8						; size = 4
_val$1$ = 8						; size = 4
_namespace$1$ = 8					; size = 4
_ctx$ = 8						; size = 4
_fullname$ = 12						; size = 4
_value$ = 16						; size = 4
_prefix$ = 20						; size = 4
_xmlSAX2AttributeInternal PROC				; COMDAT

; 1098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __A8525CDE_sax2@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	ebx, DWORD PTR _fullname$[ebp]
	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN6@xmlSAX2Att

; 1099 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 1100 :     xmlAttrPtr ret;
; 1101 :     xmlChar *name;
; 1102 :     xmlChar *ns;
; 1103 :     xmlChar *nval;
; 1104 :     xmlNsPtr namespace;
; 1105 : 
; 1106 :     if (ctxt->html) {
; 1107 : 	name = xmlStrdup(fullname);

	push	ebx
	call	_xmlStrdup
	add	esp, 4

; 1108 : 	ns = NULL;

	mov	DWORD PTR _ns$[ebp], 0

; 1109 : 	namespace = NULL;
; 1110 :     } else {

	jmp	SHORT $LN103@xmlSAX2Att
$LN6@xmlSAX2Att:

; 1111 : 	/*
; 1112 : 	 * Split the full name into a namespace prefix and the tag name
; 1113 : 	 */
; 1114 : 	name = xmlSplitQName(ctxt, fullname, &ns);

	lea	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	ebx
	push	esi
	call	_xmlSplitQName
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1115 : 	if ((name != NULL) && (name[0] == 0)) {

	test	edi, edi
	je	$LN92@xmlSAX2Att
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN8@xmlSAX2Att

; 1116 : 	    if (xmlStrEqual(ns, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR _ns$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	push	0
	push	ebx
	test	eax, eax
	je	SHORT $LN9@xmlSAX2Att

; 1117 : 		xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,

	push	OFFSET ??_C@_0CE@IJLGNIDG@invalid?5namespace?5declaration?5?8@
	push	35					; 00000023H
	push	esi
	call	_xmlNsErrMsg

; 1118 : 			    "invalid namespace declaration '%s'\n",
; 1119 : 			    fullname, NULL);
; 1120 : 	    } else {

	jmp	SHORT $LN104@xmlSAX2Att
$LN9@xmlSAX2Att:

; 1121 : 		xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,

	push	OFFSET ??_C@_0CL@HKIDFKGE@Avoid?5attribute?5ending?5with?5?8?3?8@
	push	106					; 0000006aH
	push	esi
	call	_xmlNsWarnMsg
$LN104@xmlSAX2Att:

; 1122 : 			     "Avoid attribute ending with ':' like '%s'\n",
; 1123 : 			     fullname, NULL);
; 1124 : 	    }
; 1125 : 	    if (ns != NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN11@xmlSAX2Att

; 1126 : 		xmlFree(ns);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSAX2Att:

; 1127 : 	    ns = NULL;
; 1128 : 	    xmlFree(name);

	push	edi
	mov	DWORD PTR _ns$[ebp], 0
	call	DWORD PTR _xmlFree

; 1129 : 	    name = xmlStrdup(fullname);

	push	ebx
	call	_xmlStrdup
	add	esp, 8
$LN103@xmlSAX2Att:

; 1130 : 	}
; 1131 :     }
; 1132 :     if (name == NULL) {

	mov	edi, eax
$LN8@xmlSAX2Att:
	test	edi, edi
	je	$LN92@xmlSAX2Att

; 1134 : 	if (ns != NULL)
; 1135 : 	    xmlFree(ns);
; 1136 : 	return;
; 1137 :     }
; 1138 : 
; 1139 : #ifdef LIBXML_HTML_ENABLED
; 1140 :     if ((ctxt->html) &&
; 1141 :         (value == NULL) && (htmlIsBooleanAttr(fullname))) {

	cmp	DWORD PTR [esi+32], 0
	mov	ebx, DWORD PTR _value$[ebp]
	je	SHORT $LN14@xmlSAX2Att
	test	ebx, ebx
	jne	SHORT $LN14@xmlSAX2Att
	push	DWORD PTR _fullname$[ebp]
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@xmlSAX2Att

; 1142 :             nval = xmlStrdup(fullname);

	push	DWORD PTR _fullname$[ebp]
	call	_xmlStrdup
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _nval$1$[ebp], ecx

; 1143 :             value = (const xmlChar *) nval;

	mov	ebx, ecx
	mov	DWORD PTR _value$[ebp], ecx

; 1144 :     } else

	jmp	SHORT $LN17@xmlSAX2Att
$LN14@xmlSAX2Att:

; 1145 : #endif
; 1146 :     {
; 1147 : #ifdef LIBXML_VALID_ENABLED
; 1148 :         /*
; 1149 :          * Do the last stage of the attribute normalization
; 1150 :          * Needed for HTML too:
; 1151 :          *   http://www.w3.org/TR/html4/types.html#h-6.2
; 1152 :          */
; 1153 :         ctxt->vctxt.valid = 1;
; 1154 :         nval = xmlValidCtxtNormalizeAttributeValue(&ctxt->vctxt,

	push	ebx
	push	DWORD PTR _fullname$[ebp]
	lea	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+144], 1
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidCtxtNormalizeAttributeValue
	add	esp, 20					; 00000014H
	mov	ecx, eax

; 1155 :                                                ctxt->myDoc, ctxt->node,
; 1156 :                                                fullname, value);
; 1157 :         if (ctxt->vctxt.valid != 1) {

	cmp	DWORD PTR [esi+144], 1
	mov	DWORD PTR _nval$1$[ebp], ecx
	je	SHORT $LN16@xmlSAX2Att

; 1158 :             ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
$LN16@xmlSAX2Att:

; 1159 :         }
; 1160 :         if (nval != NULL)

	test	ecx, ecx
	cmovne	ebx, ecx
	mov	DWORD PTR _value$[ebp], ebx
$LN17@xmlSAX2Att:

; 1161 :             value = nval;
; 1162 : #else
; 1163 :         nval = NULL;
; 1164 : #endif /* LIBXML_VALID_ENABLED */
; 1165 :     }
; 1166 : 
; 1167 :     /*
; 1168 :      * Check whether it's a namespace definition
; 1169 :      */
; 1170 :     if ((!ctxt->html) && (ns == NULL) &&
; 1171 :         (name[0] == 'x') && (name[1] == 'm') && (name[2] == 'l') &&
; 1172 :         (name[3] == 'n') && (name[4] == 's') && (name[5] == 0)) {

	cmp	DWORD PTR [esi+32], 0
	mov	eax, DWORD PTR _ns$[ebp]
	jne	$LN34@xmlSAX2Att
	test	eax, eax
	jne	$LN93@xmlSAX2Att
	cmp	BYTE PTR [edi], 120			; 00000078H
	jne	$LN49@xmlSAX2Att
	cmp	BYTE PTR [edi+1], 109			; 0000006dH
	jne	$LN49@xmlSAX2Att
	cmp	BYTE PTR [edi+2], 108			; 0000006cH
	jne	$LN49@xmlSAX2Att
	cmp	BYTE PTR [edi+3], 110			; 0000006eH
	jne	$LN49@xmlSAX2Att
	cmp	BYTE PTR [edi+4], 115			; 00000073H
	jne	$LN49@xmlSAX2Att
	cmp	BYTE PTR [edi+5], al
	jne	$LN49@xmlSAX2Att

; 1173 : 	xmlNsPtr nsret;
; 1174 : 	xmlChar *val;
; 1175 : 
; 1176 :         if (!ctxt->replaceEntities) {

	cmp	DWORD PTR [esi+16], eax
	jne	SHORT $LN19@xmlSAX2Att

; 1177 : 	    ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 1178 : 	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,

	push	eax
	push	eax
	push	eax
	push	1
	push	ebx
	push	esi
	call	_xmlStringDecodeEntities

; 1179 : 		                          0,0,0);
; 1180 : 	    ctxt->depth--;

	dec	DWORD PTR [esi+248]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _val$1$[ebp], eax

; 1181 : 	    if (val == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlSAX2Att

; 1182 : 	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	esi
	call	_xmlSAX2ErrMemory

; 1183 : 		if (name != NULL)
; 1184 : 		    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 1185 :                 if (nval != NULL)

	mov	eax, DWORD PTR _nval$1$[ebp]
	add	esp, 12					; 0000000cH

; 1186 :                     xmlFree(nval);
; 1187 : 		return;

	jmp	$LN106@xmlSAX2Att
$LN19@xmlSAX2Att:

; 1188 : 	    }
; 1189 : 	} else {
; 1190 : 	    val = (xmlChar *) value;

	mov	eax, ebx
	mov	DWORD PTR _val$1$[ebp], ebx
$LN20@xmlSAX2Att:

; 1191 : 	}
; 1192 : 
; 1193 : 	if (val[0] != 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN26@xmlSAX2Att

; 1194 : 	    xmlURIPtr uri;
; 1195 : 
; 1196 : 	    uri = xmlParseURI((const char *)val);

	push	eax
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], eax

; 1197 : 	    if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN25@xmlSAX2Att

; 1198 : 		if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN99@xmlSAX2Att
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	je	SHORT $LN99@xmlSAX2Att

; 1199 : 		    ctxt->sax->warning(ctxt->userData,

	push	DWORD PTR _val$1$[ebp]
	push	OFFSET ??_C@_0BL@KIHPGOD@xmlns?3?5?$CFs?5not?5a?5valid?5URI?6@
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH

; 1200 : 			 "xmlns: %s not a valid URI\n", val);
; 1201 : 	    } else {

	jmp	SHORT $LN99@xmlSAX2Att
$LN25@xmlSAX2Att:

; 1202 : 		if (uri->scheme == NULL) {

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN29@xmlSAX2Att

; 1203 : 		    if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN29@xmlSAX2Att
	mov	ecx, DWORD PTR [ecx+84]
	test	ecx, ecx
	je	SHORT $LN29@xmlSAX2Att

; 1204 : 			ctxt->sax->warning(ctxt->userData,

	push	DWORD PTR _val$1$[ebp]
	push	OFFSET ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
	push	DWORD PTR [esi+4]
	call	ecx
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 12					; 0000000cH
$LN29@xmlSAX2Att:

; 1205 : 			     "xmlns: URI %s is not absolute\n", val);
; 1206 : 		}
; 1207 : 		xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN99@xmlSAX2Att:

; 1208 : 	    }
; 1209 : 	}
; 1210 : 
; 1211 : 	/* a default namespace definition */
; 1212 : 	nsret = xmlNewNs(ctxt->node, val, NULL);

	mov	eax, DWORD PTR _val$1$[ebp]
$LN26@xmlSAX2Att:
	push	0
	push	eax
	push	DWORD PTR [esi+52]
	call	_xmlNewNs
	mov	ecx, eax
	add	esp, 12					; 0000000cH

; 1213 : 
; 1214 : #ifdef LIBXML_VALID_ENABLED
; 1215 : 	/*
; 1216 : 	 * Validate also for namespace decls, they are attributes from
; 1217 : 	 * an XML-1.0 perspective
; 1218 : 	 */
; 1219 :         if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
; 1220 : 	    ctxt->myDoc && ctxt->myDoc->intSubset)

	test	ecx, ecx
	je	SHORT $LN30@xmlSAX2Att
	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN30@xmlSAX2Att
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN30@xmlSAX2Att
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN30@xmlSAX2Att
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN30@xmlSAX2Att

; 1221 : 	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,

	push	DWORD PTR _val$1$[ebp]
	push	ecx
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR [esi+52]
	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneNamespace
	add	esp, 24					; 00000018H
	and	DWORD PTR [esi+100], eax
$LN30@xmlSAX2Att:

; 1222 : 					   ctxt->node, prefix, nsret, val);
; 1223 : #endif /* LIBXML_VALID_ENABLED */
; 1224 : 	if (name != NULL)
; 1225 : 	    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 1226 : 	if (nval != NULL)

	mov	eax, DWORD PTR _nval$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@xmlSAX2Att

; 1227 : 	    xmlFree(nval);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlSAX2Att:

; 1228 : 	if (val != value)

	mov	eax, DWORD PTR _val$1$[ebp]
	cmp	eax, ebx

; 1229 : 	    xmlFree(val);
; 1230 : 	return;

	jmp	$LN105@xmlSAX2Att
$LN93@xmlSAX2Att:

; 1231 :     }
; 1232 :     if ((!ctxt->html) &&
; 1233 : 	(ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&
; 1234 :         (ns[3] == 'n') && (ns[4] == 's') && (ns[5] == 0)) {

	cmp	BYTE PTR [eax], 120			; 00000078H
	jne	$LN34@xmlSAX2Att
	cmp	BYTE PTR [eax+1], 109			; 0000006dH
	jne	$LN34@xmlSAX2Att
	cmp	BYTE PTR [eax+2], 108			; 0000006cH
	jne	$LN34@xmlSAX2Att
	cmp	BYTE PTR [eax+3], 110			; 0000006eH
	jne	$LN34@xmlSAX2Att
	cmp	BYTE PTR [eax+4], 115			; 00000073H
	jne	$LN34@xmlSAX2Att
	cmp	BYTE PTR [eax+5], 0
	jne	$LN34@xmlSAX2Att

; 1235 : 	xmlNsPtr nsret;
; 1236 : 	xmlChar *val;
; 1237 : 
; 1238 :         if (!ctxt->replaceEntities) {

	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN35@xmlSAX2Att

; 1239 : 	    ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 1240 : 	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,

	push	0
	push	0
	push	0
	push	1
	push	ebx
	push	esi
	call	_xmlStringDecodeEntities

; 1241 : 		                          0,0,0);
; 1242 : 	    ctxt->depth--;

	dec	DWORD PTR [esi+248]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _val$1$[ebp], eax

; 1243 : 	    if (val == NULL) {

	test	eax, eax
	jne	SHORT $LN36@xmlSAX2Att

; 1244 : 	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	esi
	call	_xmlSAX2ErrMemory

; 1245 : 	        xmlFree(ns);

	push	DWORD PTR _ns$[ebp]
	call	DWORD PTR _xmlFree

; 1246 : 		if (name != NULL)
; 1247 : 		    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 1248 :                 if (nval != NULL)

	mov	eax, DWORD PTR _nval$1$[ebp]
	add	esp, 16					; 00000010H

; 1249 :                     xmlFree(nval);
; 1250 : 		return;

	jmp	$LN106@xmlSAX2Att
$LN35@xmlSAX2Att:

; 1251 : 	    }
; 1252 : 	} else {
; 1253 : 	    val = (xmlChar *) value;

	mov	eax, ebx
	mov	DWORD PTR _val$1$[ebp], ebx
$LN36@xmlSAX2Att:

; 1254 : 	}
; 1255 : 
; 1256 : 	if (val[0] == 0) {

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN40@xmlSAX2Att

; 1257 : 	    xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,

	push	0
	push	edi
	push	OFFSET ??_C@_0CE@LNIJHMCD@Empty?5namespace?5name?5for?5prefix@
	push	204					; 000000ccH
	push	esi
	call	_xmlNsErrMsg
	mov	eax, DWORD PTR _val$1$[ebp]
	add	esp, 20					; 00000014H
$LN40@xmlSAX2Att:

; 1258 : 		        "Empty namespace name for prefix %s\n", name, NULL);
; 1259 : 	}
; 1260 : 	if ((ctxt->pedantic != 0) && (val[0] != 0)) {

	cmp	DWORD PTR [esi+268], 0
	je	SHORT $LN43@xmlSAX2Att
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN43@xmlSAX2Att

; 1261 : 	    xmlURIPtr uri;
; 1262 : 
; 1263 : 	    uri = xmlParseURI((const char *)val);

	push	eax
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], eax

; 1264 : 	    if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN42@xmlSAX2Att

; 1265 : 	        xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,

	push	ebx
	push	edi
	push	OFFSET ??_C@_0BO@MNIAHAOJ@xmlns?3?$CFs?3?5?$CFs?5not?5a?5valid?5URI?6@
	push	99					; 00000063H
	push	esi
	call	_xmlNsWarnMsg
	add	esp, 20					; 00000014H

; 1266 : 			 "xmlns:%s: %s not a valid URI\n", name, value);
; 1267 : 	    } else {

	jmp	SHORT $LN43@xmlSAX2Att
$LN42@xmlSAX2Att:

; 1268 : 		if (uri->scheme == NULL) {

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN44@xmlSAX2Att

; 1269 : 		    xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,

	push	ebx
	push	edi
	push	OFFSET ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
	push	100					; 00000064H
	push	esi
	call	_xmlNsWarnMsg
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 20					; 00000014H
$LN44@xmlSAX2Att:

; 1270 : 			   "xmlns:%s: URI %s is not absolute\n", name, value);
; 1271 : 		}
; 1272 : 		xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN43@xmlSAX2Att:

; 1273 : 	    }
; 1274 : 	}
; 1275 : 
; 1276 : 	/* a standard namespace definition */
; 1277 : 	nsret = xmlNewNs(ctxt->node, val, name);

	push	edi
	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR [esi+52]
	call	_xmlNewNs

; 1278 : 	xmlFree(ns);

	push	DWORD PTR _ns$[ebp]
	mov	DWORD PTR _nsret$1$[ebp], eax
	call	DWORD PTR _xmlFree

; 1279 : #ifdef LIBXML_VALID_ENABLED
; 1280 : 	/*
; 1281 : 	 * Validate also for namespace decls, they are attributes from
; 1282 : 	 * an XML-1.0 perspective
; 1283 : 	 */
; 1284 :         if (nsret != NULL && ctxt->validate && ctxt->wellFormed &&
; 1285 : 	    ctxt->myDoc && ctxt->myDoc->intSubset)

	mov	ecx, DWORD PTR _nsret$1$[ebp]
	add	esp, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $LN45@xmlSAX2Att
	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN45@xmlSAX2Att
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN45@xmlSAX2Att
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN45@xmlSAX2Att
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN45@xmlSAX2Att

; 1286 : 	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,

	push	ebx
	push	ecx
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR [esi+52]
	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneNamespace
	add	esp, 24					; 00000018H
	and	DWORD PTR [esi+100], eax
$LN45@xmlSAX2Att:

; 1287 : 					   ctxt->node, prefix, nsret, value);
; 1288 : #endif /* LIBXML_VALID_ENABLED */
; 1289 : 	if (name != NULL)
; 1290 : 	    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 1291 : 	if (nval != NULL)

	mov	eax, DWORD PTR _nval$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN32@xmlSAX2Att

; 1292 : 	    xmlFree(nval);

	push	eax
	call	DWORD PTR _xmlFree

; 1293 : 	if (val != value)

	mov	eax, DWORD PTR _val$1$[ebp]
	add	esp, 4
	cmp	eax, ebx

; 1294 : 	    xmlFree(val);
; 1295 : 	return;

	jmp	$LN105@xmlSAX2Att
$LN34@xmlSAX2Att:

; 1296 :     }
; 1297 : 
; 1298 :     if (ns != NULL) {

	test	eax, eax
	je	$LN49@xmlSAX2Att

; 1299 : 	namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns);

	push	eax
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _namespace$1$[ebp], eax

; 1300 : 
; 1301 : 	if (namespace == NULL) {

	test	eax, eax
	jne	SHORT $LN51@xmlSAX2Att

; 1302 : 	    xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	push	edi
	push	DWORD PTR _ns$[ebp]
	push	OFFSET ??_C@_0DE@HNKDFNKM@Namespace?5prefix?5?$CFs?5of?5attribut@
	push	201					; 000000c9H
	push	esi
	call	_xmlNsErrMsg
	add	esp, 20					; 00000014H
$LN100@xmlSAX2Att:

; 1329 :     }
; 1330 : 
; 1331 :     /* !!!!!! <a toto:arg="" xmlns:toto="http://toto.com"> */
; 1332 :     ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL);

	mov	eax, DWORD PTR _namespace$1$[ebp]
$LN50@xmlSAX2Att:
	push	0
	push	edi
	push	eax
	push	DWORD PTR [esi+52]
	call	_xmlNewNsPropEatName
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 1333 : 
; 1334 :     if (ret != NULL) {

	test	ebx, ebx
	je	$LN96@xmlSAX2Att

; 1335 :         if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {

	cmp	DWORD PTR [esi+16], 0
	jne	$LN59@xmlSAX2Att
	cmp	DWORD PTR [esi+32], 0
	jne	$LN59@xmlSAX2Att

; 1336 : 	    xmlNodePtr tmp;
; 1337 : 
; 1338 : 	    ret->children = xmlStringGetNodeList(ctxt->myDoc, value);

	mov	edi, DWORD PTR _value$[ebp]
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [ebx+12], eax

; 1339 : 	    tmp = ret->children;
; 1340 : 	    while (tmp != NULL) {

	test	eax, eax
	je	$LN63@xmlSAX2Att
	npad	2
$LL4@xmlSAX2Att:

; 1341 : 		tmp->parent = (xmlNodePtr) ret;
; 1342 : 		if (tmp->next == NULL)

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], ebx
	test	ecx, ecx
	jne	SHORT $LN94@xmlSAX2Att

; 1343 : 		    ret->last = tmp;

	mov	DWORD PTR [ebx+16], eax
	mov	ecx, DWORD PTR [eax+24]
$LN94@xmlSAX2Att:

; 1344 : 		tmp = tmp->next;

	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LL4@xmlSAX2Att

; 1345 : 	    }
; 1346 : 	} else if (value != NULL) {

	jmp	$LN63@xmlSAX2Att
$LN51@xmlSAX2Att:

; 1303 : 		    "Namespace prefix %s of attribute %s is not defined\n",
; 1304 : 		             ns, name);
; 1305 : 	} else {
; 1306 :             xmlAttrPtr prop;
; 1307 : 
; 1308 :             prop = ctxt->node->properties;

	mov	eax, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [eax+44]

; 1309 :             while (prop != NULL) {

	test	ebx, ebx
	je	SHORT $LN100@xmlSAX2Att
$LL2@xmlSAX2Att:

; 1310 :                 if (prop->ns != NULL) {

	cmp	DWORD PTR [ebx+36], 0
	je	SHORT $LN54@xmlSAX2Att

; 1311 :                     if ((xmlStrEqual(name, prop->name)) &&

	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN54@xmlSAX2Att
	mov	eax, DWORD PTR [ebx+36]
	mov	ecx, DWORD PTR _namespace$1$[ebp]
	cmp	ecx, eax
	je	SHORT $LN55@xmlSAX2Att
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ecx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN101@xmlSAX2Att
$LN54@xmlSAX2Att:

; 1322 :                     }
; 1323 :                 }
; 1324 :                 prop = prop->next;

	mov	ebx, DWORD PTR [ebx+24]
	test	ebx, ebx
	jne	SHORT $LL2@xmlSAX2Att

; 1309 :             while (prop != NULL) {

	jmp	$LN100@xmlSAX2Att
$LN101@xmlSAX2Att:

; 1311 :                     if ((xmlStrEqual(name, prop->name)) &&

	mov	ecx, DWORD PTR _namespace$1$[ebp]
$LN55@xmlSAX2Att:

; 1312 :                         ((namespace == prop->ns) ||
; 1313 :                          (xmlStrEqual(namespace->href, prop->ns->href)))) {
; 1314 :                             xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,

	push	DWORD PTR [ecx+8]
	push	edi
	push	OFFSET ??_C@_0BO@PGCJKKMF@Attribute?5?$CFs?5in?5?$CFs?5redefined?6@
	push	42					; 0000002aH
	push	esi
	call	_xmlNsErrMsg
	add	esp, 20					; 00000014H

; 1315 :                                     "Attribute %s in %s redefined\n",
; 1316 :                                              name, namespace->href);
; 1317 :                         ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0

; 1318 :                         if (ctxt->recovery == 0) ctxt->disableSAX = 1;

	cmp	DWORD PTR [esi+288], 0
	jne	SHORT $LN56@xmlSAX2Att
	mov	DWORD PTR [esi+212], 1
$LN56@xmlSAX2Att:

; 1319 :                         if (name != NULL)
; 1320 :                             xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1321 :                         goto error;

	jmp	$error$109
$LN49@xmlSAX2Att:

; 1325 :             }
; 1326 :         }
; 1327 :     } else {
; 1328 : 	namespace = NULL;

	xor	eax, eax
	jmp	$LN50@xmlSAX2Att
$LN59@xmlSAX2Att:

; 1345 : 	    }
; 1346 : 	} else if (value != NULL) {

	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	SHORT $LN63@xmlSAX2Att

; 1347 : 	    ret->children = xmlNewDocText(ctxt->myDoc, value);

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlNewDocText
	add	esp, 8
	mov	DWORD PTR [ebx+12], eax

; 1348 : 	    ret->last = ret->children;

	mov	DWORD PTR [ebx+16], eax

; 1349 : 	    if (ret->children != NULL)

	test	eax, eax
	je	SHORT $LN63@xmlSAX2Att

; 1350 : 		ret->children->parent = (xmlNodePtr) ret;

	mov	DWORD PTR [eax+20], ebx
	jmp	SHORT $LN63@xmlSAX2Att
$LN96@xmlSAX2Att:

; 1333 : 
; 1334 :     if (ret != NULL) {

	mov	edi, DWORD PTR _value$[ebp]
$LN63@xmlSAX2Att:

; 1351 : 	}
; 1352 :     }
; 1353 : 
; 1354 : #ifdef LIBXML_VALID_ENABLED
; 1355 :     if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
; 1356 :         ctxt->myDoc && ctxt->myDoc->intSubset) {

	cmp	DWORD PTR [esi+32], 0
	jne	$LN64@xmlSAX2Att
	cmp	DWORD PTR [esi+104], 0
	je	$LN64@xmlSAX2Att
	cmp	DWORD PTR [esi+12], 0
	je	$LN64@xmlSAX2Att
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN64@xmlSAX2Att
	cmp	DWORD PTR [eax+44], 0
	je	$LN64@xmlSAX2Att

; 1357 : 
; 1358 : 	/*
; 1359 : 	 * If we don't substitute entities, the validation should be
; 1360 : 	 * done on a value with replaced entities anyway.
; 1361 : 	 */
; 1362 :         if (!ctxt->replaceEntities) {

	cmp	DWORD PTR [esi+16], 0
	jne	$LN66@xmlSAX2Att

; 1363 : 	    xmlChar *val;
; 1364 : 
; 1365 : 	    ctxt->depth++;

	inc	DWORD PTR [esi+248]

; 1366 : 	    val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,

	push	0
	push	0
	push	0
	push	1
	push	edi
	push	esi
	call	_xmlStringDecodeEntities

; 1367 : 		                          0,0,0);
; 1368 : 	    ctxt->depth--;

	dec	DWORD PTR [esi+248]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR _val$1$[ebp], eax

; 1369 : 
; 1370 : 	    if (val == NULL)

	test	eax, eax
	jne	SHORT $LN68@xmlSAX2Att

; 1371 : 		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	push	edi
	push	ebx
	push	ecx
	push	edx
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneAttribute
	add	esp, 20					; 00000014H
	and	DWORD PTR [esi+100], eax
	jmp	$error$109
$LN68@xmlSAX2Att:

; 1372 : 				ctxt->myDoc, ctxt->node, ret, value);
; 1373 : 	    else {
; 1374 : 		xmlChar *nvalnorm;
; 1375 : 
; 1376 : 		/*
; 1377 : 		 * Do the last stage of the attribute normalization
; 1378 : 		 * It need to be done twice ... it's an extra burden related
; 1379 : 		 * to the ability to keep xmlSAX2References in attributes
; 1380 : 		 */
; 1381 : 		nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc,

	push	eax
	push	DWORD PTR _fullname$[ebp]
	push	ecx
	push	edx
	call	_xmlValidNormalizeAttributeValue

; 1382 : 					    ctxt->node, fullname, val);
; 1383 : 		if (nvalnorm != NULL) {

	mov	edi, DWORD PTR _val$1$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nvalnorm$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN70@xmlSAX2Att

; 1384 : 		    xmlFree(val);

	push	edi
	call	DWORD PTR _xmlFree

; 1385 : 		    val = nvalnorm;

	mov	edi, DWORD PTR _nvalnorm$1$[ebp]
	add	esp, 4
$LN70@xmlSAX2Att:

; 1386 : 		}
; 1387 : 
; 1388 : 		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,

	push	edi
	push	ebx
	push	DWORD PTR [esi+52]
	lea	eax, DWORD PTR [esi+108]
	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlValidateOneAttribute
	and	DWORD PTR [esi+100], eax

; 1389 : 			        ctxt->myDoc, ctxt->node, ret, val);
; 1390 :                 xmlFree(val);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 1391 : 	    }
; 1392 : 	} else {

	jmp	$error$109
$LN66@xmlSAX2Att:

; 1393 : 	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,

	push	edi
	push	ebx
	push	DWORD PTR [esi+52]
	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneAttribute
	add	esp, 20					; 00000014H
	and	DWORD PTR [esi+100], eax

; 1394 : 					       ctxt->node, ret, value);
; 1395 : 	}
; 1396 :     } else

	jmp	$error$109
$LN64@xmlSAX2Att:

; 1397 : #endif /* LIBXML_VALID_ENABLED */
; 1398 :            if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&

	test	BYTE PTR [esi+276], 8
	jne	$error$109
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN91@xmlSAX2Att
	cmp	DWORD PTR [esi+96], 2
	jne	SHORT $LN72@xmlSAX2Att
	jmp	$error$109
$LN91@xmlSAX2Att:
	cmp	DWORD PTR [esi+216], 0
	jne	$error$109
$LN72@xmlSAX2Att:

; 1399 : 	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
; 1400 : 	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {
; 1401 :         /*
; 1402 : 	 * when validating, the ID registration is done at the attribute
; 1403 : 	 * validation level. Otherwise we have to do specific handling here.
; 1404 : 	 */
; 1405 : 	if (xmlStrEqual(fullname, BAD_CAST "xml:id")) {

	push	OFFSET ??_C@_06IMLNHOMM@xml?3id@
	push	DWORD PTR _fullname$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN74@xmlSAX2Att

; 1406 : 	    /*
; 1407 : 	     * Add the xml:id value
; 1408 : 	     *
; 1409 : 	     * Open issue: normalization of the value.
; 1410 : 	     */
; 1411 : 	    if (xmlValidateNCName(value, 1) != 0) {

	push	1
	push	edi
	call	_xmlValidateNCName
	add	esp, 8
	test	eax, eax
	je	SHORT $LN76@xmlSAX2Att

; 1412 : 	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,

	push	0
	push	edi
	push	OFFSET ??_C@_0CO@CCGEJOB@xml?3id?5?3?5attribute?5value?5?$CFs?5is?5@
	push	539					; 0000021bH
	push	esi
	call	_xmlErrValid
	add	esp, 20					; 00000014H
$LN76@xmlSAX2Att:

; 1413 : 		      "xml:id : attribute value %s is not an NCName\n",
; 1414 : 			    (const char *) value, NULL);
; 1415 : 	    }
; 1416 : 	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);

	push	ebx
	push	edi
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlAddID
	jmp	SHORT $LN107@xmlSAX2Att
$LN74@xmlSAX2Att:

; 1417 : 	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret))

	push	ebx
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlIsID
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	push	ebx
	test	eax, eax
	je	SHORT $LN77@xmlSAX2Att

; 1418 : 	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);

	push	edi
	push	ecx
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlAddID
	jmp	SHORT $LN107@xmlSAX2Att
$LN77@xmlSAX2Att:

; 1419 : 	else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret))

	push	DWORD PTR [esi+52]
	push	ecx
	call	_xmlIsRef
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $error$109

; 1420 : 	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, value, ret);

	push	ebx
	push	edi
	push	DWORD PTR [esi+8]
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlAddRef
$LN107@xmlSAX2Att:

; 1421 :     }
; 1422 : 
; 1423 : error:
; 1424 :     if (nval != NULL)

	add	esp, 16					; 00000010H
$error$109:
	mov	eax, DWORD PTR _nval$1$[ebp]
	test	eax, eax
	je	SHORT $LN80@xmlSAX2Att

; 1425 : 	xmlFree(nval);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1426 :     if (ns != NULL)
; 1427 : 	xmlFree(ns);

	jmp	SHORT $LN80@xmlSAX2Att
$LN92@xmlSAX2Att:

; 1133 :         xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN80@xmlSAX2Att:

; 1428 : }

	mov	eax, DWORD PTR _ns$[ebp]
$LN106@xmlSAX2Att:
	test	eax, eax
$LN105@xmlSAX2Att:
	je	SHORT $LN81@xmlSAX2Att
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN81@xmlSAX2Att:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2AttributeInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlNsWarnMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlNsWarnMsg PROC					; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _error$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlNsWarnM

; 221  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edx+212], 0
	je	SHORT $LN2@xmlNsWarnM
	cmp	DWORD PTR [edx+172], -1
	je	SHORT $LN1@xmlNsWarnM
$LN2@xmlNsWarnM:

; 222  :         (ctxt->instate == XML_PARSER_EOF))
; 223  : 	return;
; 224  :     if (ctxt != NULL)
; 225  : 	ctxt->errNo = error;

	mov	DWORD PTR [edx+84], esi
$LN3@xmlNsWarnM:

; 226  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	1
	push	esi
	push	3
	push	0
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN1@xmlNsWarnM:
	pop	esi

; 227  :                     XML_ERR_WARNING, NULL, 0,
; 228  : 		    (const char *) str1, (const char *) str2,
; 229  : 		    NULL, 0, 0, msg, str1, str2);
; 230  : }

	pop	ebp
	ret	0
_xmlNsWarnMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlNsErrMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlNsErrMsg PROC					; COMDAT

; 196  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _error$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlNsErrMs

; 197  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [edx+212], 0
	je	SHORT $LN2@xmlNsErrMs
	cmp	DWORD PTR [edx+172], -1
	je	SHORT $LN1@xmlNsErrMs
$LN2@xmlNsErrMs:

; 198  :         (ctxt->instate == XML_PARSER_EOF))
; 199  : 	return;
; 200  :     if (ctxt != NULL)
; 201  : 	ctxt->errNo = error;

	mov	DWORD PTR [edx+84], esi
$LN3@xmlNsErrMs:

; 202  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	esi
	push	3
	push	0
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN1@xmlNsErrMs:
	pop	esi

; 203  :                     XML_ERR_ERROR, NULL, 0,
; 204  : 		    (const char *) str1, (const char *) str2,
; 205  : 		    NULL, 0, 0, msg, str1, str2);
; 206  : }

	pop	ebp
	ret	0
_xmlNsErrMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlWarnMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_xmlWarnMsg PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlWarnMsg

; 172  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [ecx+212], 0
	je	SHORT $LN2@xmlWarnMsg
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN1@xmlWarnMsg
$LN2@xmlWarnMsg:

; 173  :         (ctxt->instate == XML_PARSER_EOF))
; 174  : 	return;
; 175  :     if (ctxt != NULL)
; 176  : 	ctxt->errNo = error;

	mov	DWORD PTR [ecx+84], edx
$LN3@xmlWarnMsg:

; 177  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	1
	push	edx
	push	1
	push	0
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlWarnMsg:

; 178  :                     XML_ERR_WARNING, NULL, 0,
; 179  : 		    (const char *) str1, NULL,
; 180  : 		    NULL, 0, 0, msg, str1);
; 181  : }

	pop	ebp
	ret	0
_xmlWarnMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlFatalErrMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlFatalErrMsg PROC					; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFatalEr

; 141  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlFatalEr
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlFatalEr
$LN2@xmlFatalEr:

; 142  :         (ctxt->instate == XML_PARSER_EOF))
; 143  : 	return;
; 144  :     if (ctxt != NULL)
; 145  : 	ctxt->errNo = error;

	mov	DWORD PTR [esi+84], edx
$LN3@xmlFatalEr:

; 146  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	3
	push	edx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 147  :                     XML_ERR_FATAL, NULL, 0,
; 148  : 		    (const char *) str1, (const char *) str2,
; 149  : 		    NULL, 0, 0, msg, str1, str2);
; 150  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlFatalEr

; 151  : 	ctxt->wellFormed = 0;
; 152  : 	ctxt->valid = 0;
; 153  : 	if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+100], 0
	jne	SHORT $LN5@xmlFatalEr

; 154  : 	    ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlFatalEr:
	pop	esi

; 155  :     }
; 156  : }

	pop	ebp
	ret	0
_xmlFatalErrMsg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlErrValid
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlErrValid PROC					; COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	test	esi, esi
	je	SHORT $LN3@xmlErrVali

; 101  :     xmlStructuredErrorFunc schannel = NULL;
; 102  : 
; 103  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], edx
	je	SHORT $LN2@xmlErrVali
	cmp	DWORD PTR [esi+172], -1
	je	$LN4@xmlErrVali
$LN2@xmlErrVali:

; 104  :         (ctxt->instate == XML_PARSER_EOF))
; 105  : 	return;
; 106  :     if (ctxt != NULL) {
; 107  : 	ctxt->errNo = error;
; 108  : 	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR _error$[ebp]
	mov	DWORD PTR [esi+84], edi
	test	eax, eax
	je	SHORT $LN5@xmlErrVali
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN5@xmlErrVali

; 109  : 	    schannel = ctxt->sax->serror;

	mov	edx, DWORD PTR [eax+124]
$LN5@xmlErrVali:

; 110  : 	__xmlRaiseError(schannel,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	edi
	push	4
	push	0
	push	esi
	push	DWORD PTR [esi+108]
	push	DWORD PTR [esi+112]
	push	edx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 111  : 			ctxt->vctxt.error, ctxt->vctxt.userData,
; 112  : 			ctxt, NULL, XML_FROM_DTD, error,
; 113  : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 114  : 			(const char *) str2, NULL, 0, 0,
; 115  : 			msg, (const char *) str1, (const char *) str2);
; 116  : 	ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
	pop	edi
	pop	esi

; 119  : 			NULL, NULL,
; 120  : 			ctxt, NULL, XML_FROM_DTD, error,
; 121  : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 122  : 			(const char *) str2, NULL, 0, 0,
; 123  : 			msg, (const char *) str1, (const char *) str2);
; 124  :     }
; 125  : }

	pop	ebp
	ret	0
$LN3@xmlErrVali:

; 117  :     } else {
; 118  : 	__xmlRaiseError(schannel,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	4
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN4@xmlErrVali:
	pop	esi

; 119  : 			NULL, NULL,
; 120  : 			ctxt, NULL, XML_FROM_DTD, error,
; 121  : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 122  : 			(const char *) str2, NULL, 0, 0,
; 123  : 			msg, (const char *) str1, (const char *) str2);
; 124  :     }
; 125  : }

	pop	ebp
	ret	0
_xmlErrValid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2ErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlSAX2ErrMemory PROC					; COMDAT

; 60   : xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	esi, esi
	je	SHORT $LN2@xmlSAX2Err

; 61   :     xmlStructuredErrorFunc schannel = NULL;
; 62   :     const char *str1 = "out of memory\n";
; 63   : 
; 64   :     if (ctxt != NULL) {
; 65   : 	ctxt->errNo = XML_ERR_NO_MEMORY;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+84], 2

; 66   : 	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))

	test	eax, eax
	je	SHORT $LN4@xmlSAX2Err
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN4@xmlSAX2Err

; 67   : 	    schannel = ctxt->sax->serror;

	mov	ecx, DWORD PTR [eax+124]
$LN4@xmlSAX2Err:

; 68   : 	__xmlRaiseError(schannel,

	push	0
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	0
	push	0
	push	2
	push	2
	push	1
	push	0
	push	esi
	push	DWORD PTR [esi+108]
	push	DWORD PTR [esi+112]
	push	ecx
	call	___xmlRaiseError

; 79   : 			NULL, NULL,
; 80   : 			ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
; 81   : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 82   : 			NULL, NULL, 0, 0,
; 83   : 			msg, (const char *) str1, NULL);
; 84   :     }
; 85   : }

	add	esp, 72					; 00000048H
	mov	DWORD PTR [esi+84], 2
	mov	DWORD PTR [esi+172], -1
	mov	DWORD PTR [esi+212], 1
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlSAX2Err:

; 69   : 			ctxt->vctxt.error, ctxt->vctxt.userData,
; 70   : 			ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
; 71   : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 72   : 			NULL, NULL, 0, 0,
; 73   : 			msg, (const char *) str1, NULL);
; 74   : 	ctxt->errNo = XML_ERR_NO_MEMORY;
; 75   : 	ctxt->instate = XML_PARSER_EOF;
; 76   : 	ctxt->disableSAX = 1;
; 77   :     } else {
; 78   : 	__xmlRaiseError(schannel,

	push	0
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	0
	push	0
	push	2
	push	2
	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 79   : 			NULL, NULL,
; 80   : 			ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
; 81   : 			XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 82   : 			NULL, NULL, 0, 0,
; 83   : 			msg, (const char *) str1, NULL);
; 84   :     }
; 85   : }

	add	esp, 72					; 00000048H
	pop	esi
	pop	ebp
	ret	0
_xmlSAX2ErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlDefaultSAXHandlerInit
_TEXT	SEGMENT
_xmlDefaultSAXHandlerInit PROC				; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	call	___xmlDefaultSAXHandler
	push	eax
	call	_xmlSAXVersion
	add	esp, 8
	ret	0
_xmlDefaultSAXHandlerInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _docbDefaultSAXHandlerInit
_TEXT	SEGMENT
_docbDefaultSAXHandlerInit PROC				; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___docbDefaultSAXHandler
	push	eax
	call	_xmlSAX2InitDocbDefaultSAXHandler
	pop	ecx
	ret	0
_docbDefaultSAXHandlerInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2InitDocbDefaultSAXHandler
_TEXT	SEGMENT
_hdlr$ = 8						; size = 4
_xmlSAX2InitDocbDefaultSAXHandler PROC			; COMDAT

; 3014 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _hdlr$[ebp]
	test	eax, eax
	je	$LN3@xmlSAX2Ini

; 3015 :     if ((hdlr == NULL) || (hdlr->initialized != 0))

	cmp	DWORD PTR [eax+108], 0
	jne	$LN3@xmlSAX2Ini

; 3016 : 	return;
; 3017 : 
; 3018 :     hdlr->internalSubset = xmlSAX2InternalSubset;

	mov	DWORD PTR [eax], OFFSET _xmlSAX2InternalSubset

; 3019 :     hdlr->externalSubset = NULL;

	mov	DWORD PTR [eax+104], 0

; 3020 :     hdlr->isStandalone = xmlSAX2IsStandalone;

	mov	DWORD PTR [eax+4], OFFSET _xmlSAX2IsStandalone

; 3021 :     hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;

	mov	DWORD PTR [eax+8], OFFSET _xmlSAX2HasInternalSubset

; 3022 :     hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;

	mov	DWORD PTR [eax+12], OFFSET _xmlSAX2HasExternalSubset

; 3023 :     hdlr->resolveEntity = xmlSAX2ResolveEntity;

	mov	DWORD PTR [eax+16], OFFSET _xmlSAX2ResolveEntity

; 3024 :     hdlr->getEntity = xmlSAX2GetEntity;

	mov	DWORD PTR [eax+20], OFFSET _xmlSAX2GetEntity

; 3025 :     hdlr->getParameterEntity = NULL;

	mov	DWORD PTR [eax+96], 0

; 3026 :     hdlr->entityDecl = xmlSAX2EntityDecl;

	mov	DWORD PTR [eax+24], OFFSET _xmlSAX2EntityDecl

; 3027 :     hdlr->attributeDecl = NULL;

	mov	DWORD PTR [eax+32], 0

; 3028 :     hdlr->elementDecl = NULL;

	mov	DWORD PTR [eax+36], 0

; 3029 :     hdlr->notationDecl = NULL;

	mov	DWORD PTR [eax+28], 0

; 3030 :     hdlr->unparsedEntityDecl = NULL;

	mov	DWORD PTR [eax+40], 0

; 3031 :     hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;

	mov	DWORD PTR [eax+44], OFFSET _xmlSAX2SetDocumentLocator

; 3032 :     hdlr->startDocument = xmlSAX2StartDocument;

	mov	DWORD PTR [eax+48], OFFSET _xmlSAX2StartDocument

; 3033 :     hdlr->endDocument = xmlSAX2EndDocument;

	mov	DWORD PTR [eax+52], OFFSET _xmlSAX2EndDocument

; 3034 :     hdlr->startElement = xmlSAX2StartElement;

	mov	DWORD PTR [eax+56], OFFSET _xmlSAX2StartElement

; 3035 :     hdlr->endElement = xmlSAX2EndElement;

	mov	DWORD PTR [eax+60], OFFSET _xmlSAX2EndElement

; 3036 :     hdlr->reference = xmlSAX2Reference;

	mov	DWORD PTR [eax+64], OFFSET _xmlSAX2Reference

; 3037 :     hdlr->characters = xmlSAX2Characters;

	mov	DWORD PTR [eax+68], OFFSET _xmlSAX2Characters

; 3038 :     hdlr->cdataBlock = NULL;

	mov	DWORD PTR [eax+100], 0

; 3039 :     hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	DWORD PTR [eax+72], OFFSET _xmlSAX2IgnorableWhitespace

; 3040 :     hdlr->processingInstruction = NULL;

	mov	DWORD PTR [eax+76], 0

; 3041 :     hdlr->comment = xmlSAX2Comment;

	mov	DWORD PTR [eax+80], OFFSET _xmlSAX2Comment

; 3042 :     hdlr->warning = xmlParserWarning;

	mov	DWORD PTR [eax+84], OFFSET _xmlParserWarning

; 3043 :     hdlr->error = xmlParserError;

	mov	DWORD PTR [eax+88], OFFSET _xmlParserError

; 3044 :     hdlr->fatalError = xmlParserError;

	mov	DWORD PTR [eax+92], OFFSET _xmlParserError

; 3045 : 
; 3046 :     hdlr->initialized = 1;

	mov	DWORD PTR [eax+108], 1
$LN3@xmlSAX2Ini:

; 3047 : }

	pop	ebp
	ret	0
_xmlSAX2InitDocbDefaultSAXHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _htmlDefaultSAXHandlerInit
_TEXT	SEGMENT
_htmlDefaultSAXHandlerInit PROC				; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___htmlDefaultSAXHandler
	push	eax
	call	_xmlSAX2InitHtmlDefaultSAXHandler
	pop	ecx
	ret	0
_htmlDefaultSAXHandlerInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2InitHtmlDefaultSAXHandler
_TEXT	SEGMENT
_hdlr$ = 8						; size = 4
_xmlSAX2InitHtmlDefaultSAXHandler PROC			; COMDAT

; 2956 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _hdlr$[ebp]
	test	eax, eax
	je	$LN3@xmlSAX2Ini

; 2957 :     if ((hdlr == NULL) || (hdlr->initialized != 0))

	cmp	DWORD PTR [eax+108], 0
	jne	$LN3@xmlSAX2Ini

; 2958 : 	return;
; 2959 : 
; 2960 :     hdlr->internalSubset = xmlSAX2InternalSubset;

	mov	DWORD PTR [eax], OFFSET _xmlSAX2InternalSubset

; 2961 :     hdlr->externalSubset = NULL;

	mov	DWORD PTR [eax+104], 0

; 2962 :     hdlr->isStandalone = NULL;

	mov	DWORD PTR [eax+4], 0

; 2963 :     hdlr->hasInternalSubset = NULL;

	mov	DWORD PTR [eax+8], 0

; 2964 :     hdlr->hasExternalSubset = NULL;

	mov	DWORD PTR [eax+12], 0

; 2965 :     hdlr->resolveEntity = NULL;

	mov	DWORD PTR [eax+16], 0

; 2966 :     hdlr->getEntity = xmlSAX2GetEntity;

	mov	DWORD PTR [eax+20], OFFSET _xmlSAX2GetEntity

; 2967 :     hdlr->getParameterEntity = NULL;

	mov	DWORD PTR [eax+96], 0

; 2968 :     hdlr->entityDecl = NULL;

	mov	DWORD PTR [eax+24], 0

; 2969 :     hdlr->attributeDecl = NULL;

	mov	DWORD PTR [eax+32], 0

; 2970 :     hdlr->elementDecl = NULL;

	mov	DWORD PTR [eax+36], 0

; 2971 :     hdlr->notationDecl = NULL;

	mov	DWORD PTR [eax+28], 0

; 2972 :     hdlr->unparsedEntityDecl = NULL;

	mov	DWORD PTR [eax+40], 0

; 2973 :     hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;

	mov	DWORD PTR [eax+44], OFFSET _xmlSAX2SetDocumentLocator

; 2974 :     hdlr->startDocument = xmlSAX2StartDocument;

	mov	DWORD PTR [eax+48], OFFSET _xmlSAX2StartDocument

; 2975 :     hdlr->endDocument = xmlSAX2EndDocument;

	mov	DWORD PTR [eax+52], OFFSET _xmlSAX2EndDocument

; 2976 :     hdlr->startElement = xmlSAX2StartElement;

	mov	DWORD PTR [eax+56], OFFSET _xmlSAX2StartElement

; 2977 :     hdlr->endElement = xmlSAX2EndElement;

	mov	DWORD PTR [eax+60], OFFSET _xmlSAX2EndElement

; 2978 :     hdlr->reference = NULL;

	mov	DWORD PTR [eax+64], 0

; 2979 :     hdlr->characters = xmlSAX2Characters;

	mov	DWORD PTR [eax+68], OFFSET _xmlSAX2Characters

; 2980 :     hdlr->cdataBlock = xmlSAX2CDataBlock;

	mov	DWORD PTR [eax+100], OFFSET _xmlSAX2CDataBlock

; 2981 :     hdlr->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	DWORD PTR [eax+72], OFFSET _xmlSAX2IgnorableWhitespace

; 2982 :     hdlr->processingInstruction = xmlSAX2ProcessingInstruction;

	mov	DWORD PTR [eax+76], OFFSET _xmlSAX2ProcessingInstruction

; 2983 :     hdlr->comment = xmlSAX2Comment;

	mov	DWORD PTR [eax+80], OFFSET _xmlSAX2Comment

; 2984 :     hdlr->warning = xmlParserWarning;

	mov	DWORD PTR [eax+84], OFFSET _xmlParserWarning

; 2985 :     hdlr->error = xmlParserError;

	mov	DWORD PTR [eax+88], OFFSET _xmlParserError

; 2986 :     hdlr->fatalError = xmlParserError;

	mov	DWORD PTR [eax+92], OFFSET _xmlParserError

; 2987 : 
; 2988 :     hdlr->initialized = 1;

	mov	DWORD PTR [eax+108], 1
$LN3@xmlSAX2Ini:

; 2989 : }

	pop	ebp
	ret	0
_xmlSAX2InitHtmlDefaultSAXHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2InitDefaultSAXHandler
_TEXT	SEGMENT
_hdlr$ = 8						; size = 4
_warning$ = 12						; size = 4
_xmlSAX2InitDefaultSAXHandler PROC			; COMDAT

; 2922 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _hdlr$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlSAX2Ini

; 2923 :     if ((hdlr == NULL) || (hdlr->initialized != 0))

	cmp	DWORD PTR [esi+108], 0
	jne	SHORT $LN4@xmlSAX2Ini

; 2924 : 	return;
; 2925 : 
; 2926 :     xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);

	push	DWORD PTR _xmlSAX2DefaultVersionValue
	push	esi
	call	_xmlSAXVersion

; 2927 :     if (warning == 0)

	xor	ecx, ecx
	add	esp, 8
	cmp	DWORD PTR _warning$[ebp], ecx
	mov	eax, OFFSET _xmlParserWarning
	cmove	eax, ecx
	mov	DWORD PTR [esi+84], eax
$LN4@xmlSAX2Ini:
	pop	esi

; 2928 : 	hdlr->warning = NULL;
; 2929 :     else
; 2930 : 	hdlr->warning = xmlParserWarning;
; 2931 : }

	pop	ebp
	ret	0
_xmlSAX2InitDefaultSAXHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAXVersion
_TEXT	SEGMENT
_hdlr$ = 8						; size = 4
_version$ = 12						; size = 4
_xmlSAXVersion PROC					; COMDAT

; 2867 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _hdlr$[ebp]
	test	eax, eax
	je	$LN5@xmlSAXVers

; 2868 :     if (hdlr == NULL) return(-1);
; 2869 :     if (version == 2) {

	mov	ecx, DWORD PTR _version$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN3@xmlSAXVers

; 2870 : 	hdlr->startElement = NULL;
; 2871 : 	hdlr->endElement = NULL;
; 2872 : 	hdlr->startElementNs = xmlSAX2StartElementNs;
; 2873 : 	hdlr->endElementNs = xmlSAX2EndElementNs;
; 2874 : 	hdlr->serror = NULL;
; 2875 : 	hdlr->initialized = XML_SAX2_MAGIC;

	xor	edx, edx
	mov	DWORD PTR [eax+116], OFFSET _xmlSAX2StartElementNs
	mov	DWORD PTR [eax+120], OFFSET _xmlSAX2EndElementNs
	mov	ecx, -554844497				; deedbeafH
	mov	DWORD PTR [eax+124], 0
	xor	esi, esi
	jmp	SHORT $LN6@xmlSAXVers
$LN3@xmlSAXVers:

; 2876 : #ifdef LIBXML_SAX1_ENABLED
; 2877 :     } else if (version == 1) {

	cmp	ecx, 1
	jne	$LN5@xmlSAXVers

; 2878 : 	hdlr->startElement = xmlSAX2StartElement;
; 2879 : 	hdlr->endElement = xmlSAX2EndElement;
; 2880 : 	hdlr->initialized = 1;

	mov	edx, OFFSET _xmlSAX2EndElement
	mov	esi, OFFSET _xmlSAX2StartElement
$LN6@xmlSAXVers:

; 2884 :     hdlr->internalSubset = xmlSAX2InternalSubset;

	mov	DWORD PTR [eax+56], esi
	mov	DWORD PTR [eax+60], edx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax], OFFSET _xmlSAX2InternalSubset

; 2885 :     hdlr->externalSubset = xmlSAX2ExternalSubset;

	mov	DWORD PTR [eax+104], OFFSET _xmlSAX2ExternalSubset

; 2886 :     hdlr->isStandalone = xmlSAX2IsStandalone;

	mov	DWORD PTR [eax+4], OFFSET _xmlSAX2IsStandalone

; 2887 :     hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;

	mov	DWORD PTR [eax+8], OFFSET _xmlSAX2HasInternalSubset

; 2888 :     hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;

	mov	DWORD PTR [eax+12], OFFSET _xmlSAX2HasExternalSubset

; 2889 :     hdlr->resolveEntity = xmlSAX2ResolveEntity;

	mov	DWORD PTR [eax+16], OFFSET _xmlSAX2ResolveEntity

; 2890 :     hdlr->getEntity = xmlSAX2GetEntity;

	mov	DWORD PTR [eax+20], OFFSET _xmlSAX2GetEntity

; 2891 :     hdlr->getParameterEntity = xmlSAX2GetParameterEntity;

	mov	DWORD PTR [eax+96], OFFSET _xmlSAX2GetParameterEntity

; 2892 :     hdlr->entityDecl = xmlSAX2EntityDecl;

	mov	DWORD PTR [eax+24], OFFSET _xmlSAX2EntityDecl

; 2893 :     hdlr->attributeDecl = xmlSAX2AttributeDecl;

	mov	DWORD PTR [eax+32], OFFSET _xmlSAX2AttributeDecl

; 2894 :     hdlr->elementDecl = xmlSAX2ElementDecl;

	mov	DWORD PTR [eax+36], OFFSET _xmlSAX2ElementDecl

; 2895 :     hdlr->notationDecl = xmlSAX2NotationDecl;

	mov	DWORD PTR [eax+28], OFFSET _xmlSAX2NotationDecl

; 2896 :     hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;

	mov	DWORD PTR [eax+40], OFFSET _xmlSAX2UnparsedEntityDecl

; 2897 :     hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;

	mov	DWORD PTR [eax+44], OFFSET _xmlSAX2SetDocumentLocator

; 2898 :     hdlr->startDocument = xmlSAX2StartDocument;

	mov	DWORD PTR [eax+48], OFFSET _xmlSAX2StartDocument

; 2899 :     hdlr->endDocument = xmlSAX2EndDocument;

	mov	DWORD PTR [eax+52], OFFSET _xmlSAX2EndDocument

; 2900 :     hdlr->reference = xmlSAX2Reference;

	mov	DWORD PTR [eax+64], OFFSET _xmlSAX2Reference

; 2901 :     hdlr->characters = xmlSAX2Characters;

	mov	DWORD PTR [eax+68], OFFSET _xmlSAX2Characters

; 2902 :     hdlr->cdataBlock = xmlSAX2CDataBlock;

	mov	DWORD PTR [eax+100], OFFSET _xmlSAX2CDataBlock

; 2903 :     hdlr->ignorableWhitespace = xmlSAX2Characters;

	mov	DWORD PTR [eax+72], OFFSET _xmlSAX2Characters

; 2904 :     hdlr->processingInstruction = xmlSAX2ProcessingInstruction;

	mov	DWORD PTR [eax+76], OFFSET _xmlSAX2ProcessingInstruction

; 2905 :     hdlr->comment = xmlSAX2Comment;

	mov	DWORD PTR [eax+80], OFFSET _xmlSAX2Comment

; 2906 :     hdlr->warning = xmlParserWarning;

	mov	DWORD PTR [eax+84], OFFSET _xmlParserWarning

; 2907 :     hdlr->error = xmlParserError;

	mov	DWORD PTR [eax+88], OFFSET _xmlParserError

; 2908 :     hdlr->fatalError = xmlParserError;

	mov	DWORD PTR [eax+92], OFFSET _xmlParserError

; 2909 : 
; 2910 :     return(0);

	xor	eax, eax
	pop	esi

; 2911 : }

	pop	ebp
	ret	0
$LN5@xmlSAXVers:

; 2881 : #endif /* LIBXML_SAX1_ENABLED */
; 2882 :     } else
; 2883 :         return(-1);

	or	eax, -1
	pop	esi

; 2911 : }

	pop	ebp
	ret	0
_xmlSAXVersion ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAXDefaultVersion
_TEXT	SEGMENT
_version$ = 8						; size = 4
_xmlSAXDefaultVersion PROC				; COMDAT

; 2846 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _version$[ebp]
	mov	ecx, DWORD PTR _xmlSAX2DefaultVersionValue
	cmp	eax, 1
	je	SHORT $LN2@xmlSAXDefa

; 2847 :     int ret = xmlSAX2DefaultVersionValue;
; 2848 : 
; 2849 :     if ((version != 1) && (version != 2))

	cmp	eax, 2
	je	SHORT $LN2@xmlSAXDefa

; 2850 :         return(-1);

	or	eax, -1

; 2853 : }

	pop	ebp
	ret	0
$LN2@xmlSAXDefa:

; 2851 :     xmlSAX2DefaultVersionValue = version;

	mov	DWORD PTR _xmlSAX2DefaultVersionValue, eax

; 2852 :     return(ret);

	mov	eax, ecx

; 2853 : }

	pop	ebp
	ret	0
_xmlSAXDefaultVersion ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2CDataBlock
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_value$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSAX2CDataBlock PROC					; COMDAT

; 2805 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSAX2CDa

; 2806 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2807 :     xmlNodePtr ret, lastChild;
; 2808 : 
; 2809 :     if (ctx == NULL) return;
; 2810 : #ifdef DEBUG_SAX
; 2811 :     xmlGenericError(xmlGenericErrorContext,
; 2812 : 	    "SAX.pcdata(%.10s, %d)\n", value, len);
; 2813 : #endif
; 2814 :     lastChild = xmlGetLastChild(ctxt->node);

	push	DWORD PTR [esi+52]
	call	_xmlGetLastChild
	add	esp, 4

; 2815 : #ifdef DEBUG_SAX_TREE
; 2816 :     xmlGenericError(xmlGenericErrorContext,
; 2817 : 	    "add chars to %s \n", ctxt->node->name);
; 2818 : #endif
; 2819 :     if ((lastChild != NULL) &&

	test	eax, eax
	je	SHORT $LN3@xmlSAX2CDa
	cmp	DWORD PTR [eax+4], 4
	jne	SHORT $LN3@xmlSAX2CDa
	pop	esi

; 2820 :         (lastChild->type == XML_CDATA_SECTION_NODE)) {
; 2821 : 	xmlTextConcat(lastChild, value, len);

	mov	DWORD PTR _ctx$[ebp], eax

; 2826 :     }
; 2827 : }

	pop	ebp

; 2820 :         (lastChild->type == XML_CDATA_SECTION_NODE)) {
; 2821 : 	xmlTextConcat(lastChild, value, len);

	jmp	_xmlTextConcat
$LN3@xmlSAX2CDa:
	push	edi

; 2822 :     } else {
; 2823 : 	ret = xmlNewCDataBlock(ctxt->myDoc, value, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlNewCDataBlock
	mov	edi, eax

; 2824 : 	if (xmlAddChild(ctxt->node, ret) == NULL)

	push	edi
	push	DWORD PTR [esi+52]
	call	_xmlAddChild
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN7@xmlSAX2CDa

; 2825 : 		xmlFreeNode(ret);

	push	edi
	call	_xmlFreeNode
	add	esp, 4
$LN7@xmlSAX2CDa:
	pop	edi
$LN5@xmlSAX2CDa:
	pop	esi

; 2826 :     }
; 2827 : }

	pop	ebp
	ret	0
_xmlSAX2CDataBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2Comment
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlSAX2Comment PROC					; COMDAT

; 2743 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN13@xmlSAX2Com

; 2744 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2745 :     xmlNodePtr ret;
; 2746 :     xmlNodePtr parent;
; 2747 : 
; 2748 :     if (ctx == NULL) return;
; 2749 :     parent = ctxt->node;
; 2750 : #ifdef DEBUG_SAX
; 2751 :     xmlGenericError(xmlGenericErrorContext, "SAX.xmlSAX2Comment(%s)\n", value);
; 2752 : #endif
; 2753 :     ret = xmlNewDocComment(ctxt->myDoc, value);

	push	edi
	push	DWORD PTR _value$[ebp]
	mov	edi, DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	call	_xmlNewDocComment
	add	esp, 8

; 2754 :     if (ret == NULL) return;

	test	eax, eax
	je	SHORT $LN15@xmlSAX2Com

; 2755 :     if (ctxt->linenumbers) {

	cmp	DWORD PTR [esi+280], 0
	je	SHORT $LN7@xmlSAX2Com

; 2756 : 	if (ctxt->input != NULL) {

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN7@xmlSAX2Com

; 2757 : 	    if (ctxt->input->line < 65535)

	mov	ecx, DWORD PTR [ecx+28]
	cmp	ecx, 65535				; 0000ffffH
	jl	SHORT $LN16@xmlSAX2Com

; 2758 : 		ret->line = (short) ctxt->input->line;
; 2759 : 	    else
; 2760 : 	        ret->line = 65535;

	mov	ecx, 65535				; 0000ffffH
$LN16@xmlSAX2Com:

; 2761 : 	}
; 2762 :     }
; 2763 : 
; 2764 :     if (ctxt->inSubset == 1) {

	mov	WORD PTR [eax+56], cx
$LN7@xmlSAX2Com:
	mov	ecx, DWORD PTR [esi+216]
	push	eax
	cmp	ecx, 1
	jne	SHORT $LN8@xmlSAX2Com

; 2765 : 	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+44]
$LN18@xmlSAX2Com:

; 2780 : #ifdef DEBUG_SAX_TREE
; 2781 : 	xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"adding xmlSAX2Comment child to %s\n", parent->name);
; 2783 : #endif
; 2784 : 	xmlAddChild(parent, ret);
; 2785 :     } else {
; 2786 : #ifdef DEBUG_SAX_TREE
; 2787 : 	xmlGenericError(xmlGenericErrorContext,
; 2788 : 		"adding xmlSAX2Comment sibling to ");
; 2789 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2790 : #endif
; 2791 : 	xmlAddSibling(parent, ret);

	call	_xmlAddChild
	add	esp, 8
	pop	edi
	pop	esi

; 2792 :     }
; 2793 : }

	pop	ebp
	ret	0
$LN8@xmlSAX2Com:

; 2766 : 	return;
; 2767 :     } else if (ctxt->inSubset == 2) {

	cmp	ecx, 2
	jne	SHORT $LN10@xmlSAX2Com

; 2768 : 	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlAddChild

; 2780 : #ifdef DEBUG_SAX_TREE
; 2781 : 	xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"adding xmlSAX2Comment child to %s\n", parent->name);
; 2783 : #endif
; 2784 : 	xmlAddChild(parent, ret);
; 2785 :     } else {
; 2786 : #ifdef DEBUG_SAX_TREE
; 2787 : 	xmlGenericError(xmlGenericErrorContext,
; 2788 : 		"adding xmlSAX2Comment sibling to ");
; 2789 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2790 : #endif
; 2791 : 	xmlAddSibling(parent, ret);

	add	esp, 8
	pop	edi
	pop	esi

; 2792 :     }
; 2793 : }

	pop	ebp
	ret	0
$LN10@xmlSAX2Com:

; 2769 : 	return;
; 2770 :     }
; 2771 :     if (parent == NULL) {

	test	edi, edi
	jne	SHORT $LN11@xmlSAX2Com

; 2772 : #ifdef DEBUG_SAX_TREE
; 2773 : 	    xmlGenericError(xmlGenericErrorContext,
; 2774 : 		    "Setting xmlSAX2Comment as root\n");
; 2775 : #endif
; 2776 :         xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);

	push	DWORD PTR [esi+8]
	call	_xmlAddChild

; 2780 : #ifdef DEBUG_SAX_TREE
; 2781 : 	xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"adding xmlSAX2Comment child to %s\n", parent->name);
; 2783 : #endif
; 2784 : 	xmlAddChild(parent, ret);
; 2785 :     } else {
; 2786 : #ifdef DEBUG_SAX_TREE
; 2787 : 	xmlGenericError(xmlGenericErrorContext,
; 2788 : 		"adding xmlSAX2Comment sibling to ");
; 2789 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2790 : #endif
; 2791 : 	xmlAddSibling(parent, ret);

	add	esp, 8
	pop	edi
	pop	esi

; 2792 :     }
; 2793 : }

	pop	ebp
	ret	0
$LN11@xmlSAX2Com:

; 2777 : 	return;
; 2778 :     }
; 2779 :     if (parent->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1
	push	edi
	je	SHORT $LN18@xmlSAX2Com

; 2780 : #ifdef DEBUG_SAX_TREE
; 2781 : 	xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"adding xmlSAX2Comment child to %s\n", parent->name);
; 2783 : #endif
; 2784 : 	xmlAddChild(parent, ret);
; 2785 :     } else {
; 2786 : #ifdef DEBUG_SAX_TREE
; 2787 : 	xmlGenericError(xmlGenericErrorContext,
; 2788 : 		"adding xmlSAX2Comment sibling to ");
; 2789 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2790 : #endif
; 2791 : 	xmlAddSibling(parent, ret);

	call	_xmlAddSibling
	add	esp, 8
$LN15@xmlSAX2Com:
	pop	edi
$LN13@xmlSAX2Com:
	pop	esi

; 2792 :     }
; 2793 : }

	pop	ebp
	ret	0
_xmlSAX2Comment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2ProcessingInstruction
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_target$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlSAX2ProcessingInstruction PROC			; COMDAT

; 2680 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN13@xmlSAX2Pro

; 2681 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2682 :     xmlNodePtr ret;
; 2683 :     xmlNodePtr parent;
; 2684 : 
; 2685 :     if (ctx == NULL) return;
; 2686 :     parent = ctxt->node;
; 2687 : #ifdef DEBUG_SAX
; 2688 :     xmlGenericError(xmlGenericErrorContext,
; 2689 : 	    "SAX.xmlSAX2ProcessingInstruction(%s, %s)\n", target, data);
; 2690 : #endif
; 2691 : 
; 2692 :     ret = xmlNewDocPI(ctxt->myDoc, target, data);

	push	edi
	push	DWORD PTR _data$[ebp]
	mov	edi, DWORD PTR [esi+52]
	push	DWORD PTR _target$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlNewDocPI
	add	esp, 12					; 0000000cH

; 2693 :     if (ret == NULL) return;

	test	eax, eax
	je	SHORT $LN15@xmlSAX2Pro

; 2694 : 
; 2695 :     if (ctxt->linenumbers) {

	cmp	DWORD PTR [esi+280], 0
	je	SHORT $LN7@xmlSAX2Pro

; 2696 : 	if (ctxt->input != NULL) {

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN7@xmlSAX2Pro

; 2697 : 	    if (ctxt->input->line < 65535)

	mov	ecx, DWORD PTR [ecx+28]
	cmp	ecx, 65535				; 0000ffffH
	jl	SHORT $LN16@xmlSAX2Pro

; 2698 : 		ret->line = (short) ctxt->input->line;
; 2699 : 	    else
; 2700 : 	        ret->line = 65535;

	mov	ecx, 65535				; 0000ffffH
$LN16@xmlSAX2Pro:

; 2701 : 	}
; 2702 :     }
; 2703 :     if (ctxt->inSubset == 1) {

	mov	WORD PTR [eax+56], cx
$LN7@xmlSAX2Pro:
	mov	ecx, DWORD PTR [esi+216]
	push	eax
	cmp	ecx, 1
	jne	SHORT $LN8@xmlSAX2Pro

; 2704 : 	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+44]
$LN18@xmlSAX2Pro:

; 2719 : #ifdef DEBUG_SAX_TREE
; 2720 : 	xmlGenericError(xmlGenericErrorContext,
; 2721 : 		"adding PI %s child to %s\n", target, parent->name);
; 2722 : #endif
; 2723 : 	xmlAddChild(parent, ret);
; 2724 :     } else {
; 2725 : #ifdef DEBUG_SAX_TREE
; 2726 : 	xmlGenericError(xmlGenericErrorContext,
; 2727 : 		"adding PI %s sibling to ", target);
; 2728 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2729 : #endif
; 2730 : 	xmlAddSibling(parent, ret);

	call	_xmlAddChild
	add	esp, 8
	pop	edi
	pop	esi

; 2731 :     }
; 2732 : }

	pop	ebp
	ret	0
$LN8@xmlSAX2Pro:

; 2705 : 	return;
; 2706 :     } else if (ctxt->inSubset == 2) {

	cmp	ecx, 2
	jne	SHORT $LN10@xmlSAX2Pro

; 2707 : 	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlAddChild

; 2719 : #ifdef DEBUG_SAX_TREE
; 2720 : 	xmlGenericError(xmlGenericErrorContext,
; 2721 : 		"adding PI %s child to %s\n", target, parent->name);
; 2722 : #endif
; 2723 : 	xmlAddChild(parent, ret);
; 2724 :     } else {
; 2725 : #ifdef DEBUG_SAX_TREE
; 2726 : 	xmlGenericError(xmlGenericErrorContext,
; 2727 : 		"adding PI %s sibling to ", target);
; 2728 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2729 : #endif
; 2730 : 	xmlAddSibling(parent, ret);

	add	esp, 8
	pop	edi
	pop	esi

; 2731 :     }
; 2732 : }

	pop	ebp
	ret	0
$LN10@xmlSAX2Pro:

; 2708 : 	return;
; 2709 :     }
; 2710 :     if (parent == NULL) {

	test	edi, edi
	jne	SHORT $LN11@xmlSAX2Pro

; 2711 : #ifdef DEBUG_SAX_TREE
; 2712 : 	    xmlGenericError(xmlGenericErrorContext,
; 2713 : 		    "Setting PI %s as root\n", target);
; 2714 : #endif
; 2715 :         xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);

	push	DWORD PTR [esi+8]
	call	_xmlAddChild

; 2719 : #ifdef DEBUG_SAX_TREE
; 2720 : 	xmlGenericError(xmlGenericErrorContext,
; 2721 : 		"adding PI %s child to %s\n", target, parent->name);
; 2722 : #endif
; 2723 : 	xmlAddChild(parent, ret);
; 2724 :     } else {
; 2725 : #ifdef DEBUG_SAX_TREE
; 2726 : 	xmlGenericError(xmlGenericErrorContext,
; 2727 : 		"adding PI %s sibling to ", target);
; 2728 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2729 : #endif
; 2730 : 	xmlAddSibling(parent, ret);

	add	esp, 8
	pop	edi
	pop	esi

; 2731 :     }
; 2732 : }

	pop	ebp
	ret	0
$LN11@xmlSAX2Pro:

; 2716 : 	return;
; 2717 :     }
; 2718 :     if (parent->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1
	push	edi
	je	SHORT $LN18@xmlSAX2Pro

; 2719 : #ifdef DEBUG_SAX_TREE
; 2720 : 	xmlGenericError(xmlGenericErrorContext,
; 2721 : 		"adding PI %s child to %s\n", target, parent->name);
; 2722 : #endif
; 2723 : 	xmlAddChild(parent, ret);
; 2724 :     } else {
; 2725 : #ifdef DEBUG_SAX_TREE
; 2726 : 	xmlGenericError(xmlGenericErrorContext,
; 2727 : 		"adding PI %s sibling to ", target);
; 2728 : 	xmlDebugDumpOneNode(stderr, parent, 0);
; 2729 : #endif
; 2730 : 	xmlAddSibling(parent, ret);

	call	_xmlAddSibling
	add	esp, 8
$LN15@xmlSAX2Pro:
	pop	edi
$LN13@xmlSAX2Pro:
	pop	esi

; 2731 :     }
; 2732 : }

	pop	ebp
	ret	0
_xmlSAX2ProcessingInstruction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2IgnorableWhitespace
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSAX2IgnorableWhitespace PROC			; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlSAX2IgnorableWhitespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2Characters
_TEXT	SEGMENT
tv605 = 8						; size = 4
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSAX2Characters PROC					; COMDAT

; 2533 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN24@xmlSAX2Cha

; 2534 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2535 :     xmlNodePtr lastChild;
; 2536 : 
; 2537 :     if (ctx == NULL) return;
; 2538 : #ifdef DEBUG_SAX
; 2539 :     xmlGenericError(xmlGenericErrorContext,
; 2540 : 	    "SAX.xmlSAX2Characters(%.30s, %d)\n", ch, len);
; 2541 : #endif
; 2542 :     /*
; 2543 :      * Handle the data if any. If there is no child
; 2544 :      * add it as content, otherwise if the last child is text,
; 2545 :      * concatenate it, else create a new node of type text.
; 2546 :      */
; 2547 : 
; 2548 :     if (ctxt->node == NULL) {

	push	edi
	mov	edi, DWORD PTR [esi+52]
	test	edi, edi
	je	$LN30@xmlSAX2Cha

; 2549 : #ifdef DEBUG_SAX_TREE
; 2550 : 	xmlGenericError(xmlGenericErrorContext,
; 2551 : 		"add chars: ctxt->node == NULL !\n");
; 2552 : #endif
; 2553 :         return;
; 2554 :     }
; 2555 :     lastChild = ctxt->node->last;

	mov	edi, DWORD PTR [edi+16]
	push	ebx

; 2556 : #ifdef DEBUG_SAX_TREE
; 2557 :     xmlGenericError(xmlGenericErrorContext,
; 2558 : 	    "add chars to %s \n", ctxt->node->name);
; 2559 : #endif
; 2560 : 
; 2561 :     /*
; 2562 :      * Here we needed an accelerator mechanism in case of very large
; 2563 :      * elements. Use an attribute in the structure !!!
; 2564 :      */
; 2565 :     if (lastChild == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlSAX2Cha

; 2566 :         lastChild = xmlSAX2TextNode(ctxt, ch, len);

	mov	edi, DWORD PTR _len$[ebp]
	push	edi
	push	DWORD PTR _ch$[ebp]
	push	esi
	call	_xmlSAX2TextNode
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 2567 : 	if (lastChild != NULL) {

	test	edx, edx
	je	$LN29@xmlSAX2Cha

; 2568 : 	    ctxt->node->children = lastChild;

	mov	ecx, DWORD PTR [esi+52]
	pop	ebx
	mov	DWORD PTR [ecx+12], edx

; 2569 : 	    ctxt->node->last = lastChild;

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+16], edx

; 2570 : 	    lastChild->parent = ctxt->node;

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+20], ecx

; 2571 : 	    lastChild->doc = ctxt->node->doc;

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], eax

; 2642 : 		    ctxt->nodelen = len;
; 2643 : 		    ctxt->nodemem = len + 1;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [esi+260], edi
	pop	edi
	mov	DWORD PTR [esi+264], eax
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN4@xmlSAX2Cha:

; 2572 : 	    ctxt->nodelen = len;
; 2573 : 	    ctxt->nodemem = len + 1;
; 2574 : 	} else {
; 2575 : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
; 2576 : 	    return;
; 2577 : 	}
; 2578 :     } else {
; 2579 : 	int coalesceText = (lastChild != NULL) &&

	cmp	DWORD PTR [edi+4], 3
	jne	$LN19@xmlSAX2Cha
	cmp	DWORD PTR [edi+8], OFFSET _xmlStringText
	jne	$LN19@xmlSAX2Cha

; 2580 : 	    (lastChild->type == XML_TEXT_NODE) &&
; 2581 : 	    (lastChild->name == xmlStringText);
; 2582 : 	if ((coalesceText) && (ctxt->nodemem != 0)) {

	mov	edx, DWORD PTR [esi+264]
	test	edx, edx
	je	$LN8@xmlSAX2Cha

; 2583 : 	    /*
; 2584 : 	     * The whole point of maintaining nodelen and nodemem,
; 2585 : 	     * xmlTextConcat is too costly, i.e. compute length,
; 2586 : 	     * reallocate a new buffer, move data, append ch. Here
; 2587 : 	     * We try to minimaze realloc() uses and avoid copying
; 2588 : 	     * and recomputing length over and over.
; 2589 : 	     */
; 2590 : 	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {

	mov	ecx, DWORD PTR [edi+40]
	lea	ebx, DWORD PTR [edi+44]
	cmp	ecx, ebx
	jne	SHORT $LN10@xmlSAX2Cha

; 2591 : 		lastChild->content = xmlStrdup(lastChild->content);

	push	ecx
	call	_xmlStrdup

; 2592 : 		lastChild->properties = NULL;

	mov	DWORD PTR [ebx], 0
	jmp	SHORT $LN33@xmlSAX2Cha
$LN10@xmlSAX2Cha:

; 2593 : 	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&

	mov	eax, DWORD PTR [esi+260]
	inc	eax
	cmp	edx, eax
	jne	SHORT $LN12@xmlSAX2Cha
	push	ecx
	push	DWORD PTR [esi+296]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSAX2Cha

; 2594 : 	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
; 2595 : 		lastChild->content = xmlStrdup(lastChild->content);

	push	DWORD PTR [edi+40]
	call	_xmlStrdup
$LN33@xmlSAX2Cha:

; 2596 : 	    }
; 2597 : 	    if (lastChild->content == NULL) {

	mov	DWORD PTR [edi+40], eax
	add	esp, 4
$LN12@xmlSAX2Cha:
	mov	ecx, DWORD PTR [edi+40]
	test	ecx, ecx
	jne	SHORT $LN13@xmlSAX2Cha

; 2598 : 		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");

	push	OFFSET ??_C@_0CL@EDPCIJGK@xmlSAX2Characters?3?5xmlStrdup?5re@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN13@xmlSAX2Cha:

; 2599 : 		return;
; 2600 :  	    }
; 2601 :             if (((size_t)ctxt->nodelen + (size_t)len > XML_MAX_TEXT_LENGTH) &&

	mov	edx, DWORD PTR [esi+260]
	mov	ebx, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR [edx+ebx]
	cmp	eax, 10000000				; 00989680H
	jbe	SHORT $LN14@xmlSAX2Cha
	test	DWORD PTR [esi+360], 524288		; 00080000H
	jne	SHORT $LN14@xmlSAX2Cha

; 2602 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 2603 :                 xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");

	push	OFFSET ??_C@_0CC@PCIHKIPC@xmlSAX2Characters?3?5huge?5text?5no@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN14@xmlSAX2Cha:

; 2604 :                 return;
; 2605 :             }
; 2606 : 	    if ((size_t)ctxt->nodelen > SIZE_T_MAX - (size_t)len ||

	mov	eax, ebx
	not	eax
	cmp	edx, eax
	ja	$LN16@xmlSAX2Cha
	mov	eax, DWORD PTR [esi+264]
	add	eax, ebx
	mov	DWORD PTR tv605[ebp], eax
	cmp	eax, 2147483647				; 7fffffffH
	ja	SHORT $LN16@xmlSAX2Cha

; 2609 :                 return;
; 2610 : 	    }
; 2611 : 	    if (ctxt->nodelen + len >= ctxt->nodemem) {

	lea	eax, DWORD PTR [edx+ebx]
	cmp	eax, DWORD PTR [esi+264]
	jl	SHORT $LN17@xmlSAX2Cha

; 2612 : 		xmlChar *newbuf;
; 2613 : 		size_t size;
; 2614 : 
; 2615 : 		size = ctxt->nodemem + len;
; 2616 : 		size *= 2;

	mov	eax, DWORD PTR tv605[ebp]
	add	eax, eax

; 2617 :                 newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);

	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 2618 : 		if (newbuf == NULL) {

	test	ecx, ecx
	jne	SHORT $LN18@xmlSAX2Cha
$LN29@xmlSAX2Cha:

; 2619 : 		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");

	push	OFFSET ??_C@_0BC@IJLHKBBO@xmlSAX2Characters@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN18@xmlSAX2Cha:

; 2620 : 		    return;
; 2621 : 		}
; 2622 : 		ctxt->nodemem = size;

	mov	edx, DWORD PTR tv605[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [esi+264], eax

; 2623 : 		lastChild->content = newbuf;

	mov	DWORD PTR [edi+40], ecx
	mov	edx, DWORD PTR [esi+260]
$LN17@xmlSAX2Cha:

; 2624 : 	    }
; 2625 : 	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);

	push	ebx
	push	DWORD PTR _ch$[ebp]
	lea	eax, DWORD PTR [ecx+edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2626 : 	    ctxt->nodelen += len;

	add	DWORD PTR [esi+260], ebx
	mov	ecx, DWORD PTR [esi+260]

; 2627 : 	    lastChild->content[ctxt->nodelen] = 0;

	mov	eax, DWORD PTR [edi+40]
	pop	ebx
	pop	edi
	mov	BYTE PTR [ecx+eax], 0
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN16@xmlSAX2Cha:

; 2607 : 	        (size_t)ctxt->nodemem + (size_t)len > SIZE_T_MAX / 2) {
; 2608 :                 xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");

	push	OFFSET ??_C@_0CF@EADJOGLP@xmlSAX2Characters?5overflow?5prev@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN8@xmlSAX2Cha:

; 2628 : 	} else if (coalesceText) {
; 2629 : 	    if (xmlTextConcat(lastChild, ch, len)) {

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _ch$[ebp]
	push	edi
	call	_xmlTextConcat
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@xmlSAX2Cha

; 2630 : 		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");

	push	OFFSET ??_C@_0BC@IJLHKBBO@xmlSAX2Characters@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN21@xmlSAX2Cha:

; 2631 : 	    }
; 2632 : 	    if (ctxt->node->children != NULL) {

	mov	eax, DWORD PTR [esi+52]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN31@xmlSAX2Cha

; 2633 : 		ctxt->nodelen = xmlStrlen(lastChild->content);

	push	DWORD PTR [edi+40]
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR [esi+260], eax

; 2634 : 		ctxt->nodemem = ctxt->nodelen + 1;

	inc	eax

; 2642 : 		    ctxt->nodelen = len;
; 2643 : 		    ctxt->nodemem = len + 1;

	mov	DWORD PTR [esi+264], eax
	pop	ebx
	pop	edi
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
$LN19@xmlSAX2Cha:

; 2635 : 	    }
; 2636 : 	} else {
; 2637 : 	    /* Mixed content, first time */
; 2638 : 	    lastChild = xmlSAX2TextNode(ctxt, ch, len);

	mov	edi, DWORD PTR _len$[ebp]
	push	edi
	push	DWORD PTR _ch$[ebp]
	push	esi
	call	_xmlSAX2TextNode
	add	esp, 12					; 0000000cH

; 2639 : 	    if (lastChild != NULL) {

	test	eax, eax
	je	SHORT $LN31@xmlSAX2Cha

; 2640 : 		xmlAddChild(ctxt->node, lastChild);

	push	eax
	push	DWORD PTR [esi+52]
	call	_xmlAddChild

; 2641 : 		if (ctxt->node->children != NULL) {

	mov	eax, DWORD PTR [esi+52]
	add	esp, 8
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN31@xmlSAX2Cha

; 2642 : 		    ctxt->nodelen = len;
; 2643 : 		    ctxt->nodemem = len + 1;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [esi+260], edi
	mov	DWORD PTR [esi+264], eax
$LN31@xmlSAX2Cha:
	pop	ebx
$LN30@xmlSAX2Cha:
	pop	edi
$LN24@xmlSAX2Cha:
	pop	esi

; 2644 : 		}
; 2645 : 	    }
; 2646 : 	}
; 2647 :     }
; 2648 : }

	pop	ebp
	ret	0
_xmlSAX2Characters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2Reference
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSAX2Reference PROC					; COMDAT

; 2501 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSAX2Ref

; 2502 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2503 :     xmlNodePtr ret;
; 2504 : 
; 2505 :     if (ctx == NULL) return;
; 2506 : #ifdef DEBUG_SAX
; 2507 :     xmlGenericError(xmlGenericErrorContext,
; 2508 : 	    "SAX.xmlSAX2Reference(%s)\n", name);
; 2509 : #endif
; 2510 :     if (name[0] == '#')

	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	push	eax
	cmp	BYTE PTR [eax], 35			; 00000023H
	push	ecx
	jne	SHORT $LN3@xmlSAX2Ref

; 2511 : 	ret = xmlNewCharRef(ctxt->myDoc, name);

	call	_xmlNewCharRef
	jmp	SHORT $LN8@xmlSAX2Ref
$LN3@xmlSAX2Ref:

; 2512 :     else
; 2513 : 	ret = xmlNewReference(ctxt->myDoc, name);

	call	_xmlNewReference
$LN8@xmlSAX2Ref:

; 2514 : #ifdef DEBUG_SAX_TREE
; 2515 :     xmlGenericError(xmlGenericErrorContext,
; 2516 : 	    "add xmlSAX2Reference %s to %s \n", name, ctxt->node->name);
; 2517 : #endif
; 2518 :     if (xmlAddChild(ctxt->node, ret) == NULL) {

	add	esp, 8
	mov	edi, eax
	push	edi
	push	DWORD PTR [esi+52]
	call	_xmlAddChild
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlSAX2Ref

; 2519 :         xmlFreeNode(ret);

	push	edi
	call	_xmlFreeNode
	add	esp, 4
$LN7@xmlSAX2Ref:
	pop	edi
$LN5@xmlSAX2Ref:
	pop	esi

; 2520 :     }
; 2521 : }

	pop	ebp
	ret	0
_xmlSAX2Reference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2EndElementNs
_TEXT	SEGMENT
_node_info$ = -20					; size = 20
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_xmlSAX2EndElementNs PROC				; COMDAT

; 2464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __A8525CDE_sax2@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSAX2End

; 2465 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2466 :     xmlParserNodeInfo node_info;
; 2467 :     xmlNodePtr cur;
; 2468 : 
; 2469 :     if (ctx == NULL) return;
; 2470 :     cur = ctxt->node;

	cmp	DWORD PTR [esi+68], 0
	push	edi
	mov	edi, DWORD PTR [esi+52]

; 2471 :     /* Capture end position and add node */
; 2472 :     if ((ctxt->record_info) && (cur != NULL)) {

	je	SHORT $LN3@xmlSAX2End
	test	edi, edi
	je	SHORT $LN3@xmlSAX2End

; 2473 :         node_info.end_pos = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _node_info$[ebp+12], eax

; 2474 :         node_info.end_line = ctxt->input->line;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _node_info$[ebp+16], eax

; 2475 :         node_info.node = cur;
; 2476 :         xmlParserAddNodeInfo(ctxt, &node_info);

	lea	eax, DWORD PTR _node_info$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _node_info$[ebp], edi
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN3@xmlSAX2End:

; 2477 :     }
; 2478 :     ctxt->nodemem = -1;
; 2479 : 
; 2480 : #ifdef LIBXML_VALID_ENABLED
; 2481 :     if (ctxt->validate && ctxt->wellFormed &&
; 2482 :         ctxt->myDoc && ctxt->myDoc->intSubset)

	cmp	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+264], -1
	je	SHORT $LN4@xmlSAX2End
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN4@xmlSAX2End
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlSAX2End
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@xmlSAX2End

; 2483 :         ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc, cur);

	push	edi
	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneElement
	add	esp, 12					; 0000000cH
	and	DWORD PTR [esi+100], eax
$LN4@xmlSAX2End:

; 2484 : #endif /* LIBXML_VALID_ENABLED */
; 2485 : 
; 2486 :     /*
; 2487 :      * end of parsing of this node.
; 2488 :      */
; 2489 :     nodePop(ctxt);

	push	esi
	call	_nodePop
	add	esp, 4
	pop	edi
$LN1@xmlSAX2End:
	pop	esi

; 2490 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2EndElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2StartElementNs
_TEXT	SEGMENT
_i$1$ = -12						; size = 4
$T1 = -8						; size = 4
_uri$1$ = -8						; size = 4
_last$1$ = -4						; size = 4
_parent$1$ = 8						; size = 4
_nb_attributes$1$ = 8					; size = 4
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nb_namespaces$ = 24					; size = 4
_namespaces$ = 28					; size = 4
_nb_attributes$ = 32					; size = 4
_nb_defaulted$ = 36					; size = 4
_attributes$ = 40					; size = 4
_xmlSAX2StartElementNs PROC				; COMDAT

; 2217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	DWORD PTR _last$1$[ebp], 0
	mov	DWORD PTR $T1[ebp], eax
	test	esi, esi
	je	$LN56@xmlSAX2Sta

; 2218 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 2219 :     xmlNodePtr ret;
; 2220 :     xmlNodePtr parent;
; 2221 :     xmlNsPtr last = NULL, ns;
; 2222 :     const xmlChar *uri, *pref;
; 2223 :     xmlChar *lname = NULL;
; 2224 :     int i, j;
; 2225 : 
; 2226 :     if (ctx == NULL) return;
; 2227 :     parent = ctxt->node;

	cmp	DWORD PTR [esi+104], 0
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR _parent$1$[ebp], eax

; 2228 :     /*
; 2229 :      * First check on validity:
; 2230 :      */
; 2231 :     if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&

	je	SHORT $LN9@xmlSAX2Sta
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN9@xmlSAX2Sta
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN10@xmlSAX2Sta
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN9@xmlSAX2Sta
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN9@xmlSAX2Sta
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN9@xmlSAX2Sta
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN9@xmlSAX2Sta
$LN10@xmlSAX2Sta:

; 2232 :         ((ctxt->myDoc->intSubset == NULL) ||
; 2233 : 	 ((ctxt->myDoc->intSubset->notations == NULL) &&
; 2234 : 	  (ctxt->myDoc->intSubset->elements == NULL) &&
; 2235 : 	  (ctxt->myDoc->intSubset->attributes == NULL) &&
; 2236 : 	  (ctxt->myDoc->intSubset->entities == NULL)))) {
; 2237 : 	xmlErrValid(ctxt, XML_DTD_NO_DTD,

	push	0
	push	0
	push	OFFSET ??_C@_0CC@LPGBEFAE@Validation?5failed?3?5no?5DTD?5found@
	push	522					; 0000020aH
	push	esi
	call	_xmlErrValid
	add	esp, 20					; 00000014H

; 2238 : 	  "Validation failed: no DTD found !", NULL, NULL);
; 2239 : 	ctxt->validate = 0;

	mov	DWORD PTR [esi+104], 0
$LN9@xmlSAX2Sta:

; 2240 :     }
; 2241 : 
; 2242 :     /*
; 2243 :      * Take care of the rare case of an undefined namespace prefix
; 2244 :      */
; 2245 :     if ((prefix != NULL) && (URI == NULL)) {

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ebx
	test	eax, eax
	je	SHORT $LN72@xmlSAX2Sta
	test	ecx, ecx
	jne	SHORT $LN72@xmlSAX2Sta

; 2246 :         if (ctxt->dictNames) {

	mov	ebx, DWORD PTR _localname$[ebp]
	cmp	DWORD PTR [esi+364], ecx
	je	SHORT $LN12@xmlSAX2Sta

; 2247 : 	    const xmlChar *fullname;
; 2248 : 
; 2249 : 	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);

	push	ebx
	push	eax
	push	DWORD PTR [esi+296]
	call	_xmlDictQLookup
	add	esp, 12					; 0000000cH

; 2250 : 	    if (fullname != NULL)

	test	eax, eax
	je	SHORT $LN75@xmlSAX2Sta

; 2251 : 	        localname = fullname;

	mov	ebx, eax

; 2252 : 	} else {

	jmp	SHORT $LN75@xmlSAX2Sta
$LN12@xmlSAX2Sta:

; 2253 : 	    lname = xmlBuildQName(localname, prefix, NULL, 0);

	push	0
	push	0
	push	eax
	push	ebx
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN13@xmlSAX2Sta
$LN72@xmlSAX2Sta:

; 2240 :     }
; 2241 : 
; 2242 :     /*
; 2243 :      * Take care of the rare case of an undefined namespace prefix
; 2244 :      */
; 2245 :     if ((prefix != NULL) && (URI == NULL)) {

	mov	ebx, DWORD PTR _localname$[ebp]
$LN75@xmlSAX2Sta:

; 2254 : 	}
; 2255 :     }
; 2256 :     /*
; 2257 :      * allocate the node
; 2258 :      */
; 2259 :     if (ctxt->freeElems != NULL) {

	xor	eax, eax
$LN13@xmlSAX2Sta:
	push	edi
	mov	edi, DWORD PTR [esi+372]
	test	edi, edi
	je	SHORT $LN15@xmlSAX2Sta

; 2260 :         ret = ctxt->freeElems;
; 2261 : 	ctxt->freeElems = ret->next;

	mov	eax, DWORD PTR [edi+24]

; 2262 : 	ctxt->freeElemsNr--;

	dec	DWORD PTR [esi+368]

; 2263 : 	memset(ret, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	edi
	mov	DWORD PTR [esi+372], eax
	call	_memset

; 2264 :         ret->doc = ctxt->myDoc;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+32], eax

; 2265 : 	ret->type = XML_ELEMENT_NODE;

	mov	DWORD PTR [edi+4], 1

; 2266 : 
; 2267 : 	if (ctxt->dictNames)

	cmp	DWORD PTR [esi+364], 0
	je	SHORT $LN17@xmlSAX2Sta

; 2268 : 	    ret->name = localname;

	mov	DWORD PTR [edi+8], ebx
	jmp	SHORT $LN21@xmlSAX2Sta
$LN17@xmlSAX2Sta:

; 2269 : 	else {
; 2270 : 	    if (lname == NULL)

	mov	eax, DWORD PTR $T1[ebp]
	test	eax, eax
	jne	SHORT $LN19@xmlSAX2Sta

; 2271 : 		ret->name = xmlStrdup(localname);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
$LN19@xmlSAX2Sta:

; 2272 : 	    else
; 2273 : 	        ret->name = lname;
; 2274 : 	    if (ret->name == NULL) {

	mov	DWORD PTR [edi+8], eax
	test	eax, eax
	je	$LN71@xmlSAX2Sta
$LN21@xmlSAX2Sta:

; 2275 : 	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
; 2276 : 		return;
; 2277 : 	    }
; 2278 : 	}
; 2279 : 	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN27@xmlSAX2Sta
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN27@xmlSAX2Sta

; 2280 : 	    xmlRegisterNodeDefaultValue(ret);

	call	___xmlRegisterNodeDefaultValue
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4

; 2281 :     } else {

	jmp	SHORT $LN27@xmlSAX2Sta
$LN15@xmlSAX2Sta:

; 2282 : 	if (ctxt->dictNames)

	cmp	DWORD PTR [esi+364], 0
	mov	ecx, DWORD PTR [esi+8]
	push	0
	je	SHORT $LN23@xmlSAX2Sta

; 2283 : 	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,

	push	ebx
	jmp	SHORT $LN79@xmlSAX2Sta
$LN23@xmlSAX2Sta:

; 2284 : 	                               (xmlChar *) localname, NULL);
; 2285 : 	else if (lname == NULL)

	test	eax, eax
	jne	SHORT $LN25@xmlSAX2Sta

; 2286 : 	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);

	push	ebx
	push	eax
	push	ecx
	call	_xmlNewDocNode
	jmp	SHORT $LN80@xmlSAX2Sta
$LN25@xmlSAX2Sta:

; 2287 : 	else
; 2288 : 	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,

	push	eax
$LN79@xmlSAX2Sta:

; 2289 : 	                               (xmlChar *) lname, NULL);
; 2290 : 	if (ret == NULL) {

	push	0
	push	ecx
	call	_xmlNewDocNodeEatName
$LN80@xmlSAX2Sta:
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	je	$LN71@xmlSAX2Sta
$LN27@xmlSAX2Sta:

; 2291 : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
; 2292 : 	    return;
; 2293 : 	}
; 2294 :     }
; 2295 :     if (ctxt->linenumbers) {

	cmp	DWORD PTR [esi+280], 0
	je	SHORT $LN31@xmlSAX2Sta

; 2296 : 	if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN31@xmlSAX2Sta

; 2297 : 	    if (ctxt->input->line < 65535)

	mov	eax, DWORD PTR [eax+28]
	cmp	eax, 65535				; 0000ffffH
	jl	SHORT $LN81@xmlSAX2Sta

; 2298 : 		ret->line = (short) ctxt->input->line;
; 2299 : 	    else
; 2300 : 	        ret->line = 65535;

	mov	eax, 65535				; 0000ffffH
$LN81@xmlSAX2Sta:

; 2301 : 	}
; 2302 :     }
; 2303 : 
; 2304 :     if (parent == NULL) {

	mov	WORD PTR [edi+56], ax
$LN31@xmlSAX2Sta:
	cmp	DWORD PTR _parent$1$[ebp], 0
	jne	SHORT $LN32@xmlSAX2Sta

; 2305 :         xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlAddChild
	add	esp, 8
$LN32@xmlSAX2Sta:

; 2306 :     }
; 2307 :     /*
; 2308 :      * Build the namespace list
; 2309 :      */
; 2310 :     for (i = 0,j = 0;j < nb_namespaces;j++) {

	xor	ecx, ecx
	cmp	DWORD PTR _nb_namespaces$[ebp], ecx
	jle	$LN3@xmlSAX2Sta
	npad	8
$LL4@xmlSAX2Sta:

; 2311 :         pref = namespaces[i++];

	mov	eax, DWORD PTR _namespaces$[ebp]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 2312 : 	uri = namespaces[i++];

	mov	eax, DWORD PTR [eax+ecx*4+4]
	add	ecx, 2

; 2313 : 	ns = xmlNewNs(NULL, uri, pref);

	push	ebx
	push	eax
	push	0
	mov	DWORD PTR _uri$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 2314 : 	if (ns != NULL) {

	test	eax, eax
	je	SHORT $LN2@xmlSAX2Sta

; 2315 : 	    if (last == NULL) {

	mov	ecx, DWORD PTR _last$1$[ebp]
	mov	DWORD PTR _last$1$[ebp], eax
	test	ecx, ecx
	jne	SHORT $LN35@xmlSAX2Sta

; 2316 : 	        ret->nsDef = last = ns;

	mov	DWORD PTR [edi+48], eax

; 2317 : 	    } else {

	jmp	SHORT $LN36@xmlSAX2Sta
$LN35@xmlSAX2Sta:

; 2318 : 	        last->next = ns;

	mov	DWORD PTR [ecx], eax
$LN36@xmlSAX2Sta:

; 2319 : 		last = ns;
; 2320 : 	    }
; 2321 : 	    if ((URI != NULL) && (prefix == pref))

	cmp	DWORD PTR _URI$[ebp], 0
	mov	edx, DWORD PTR _prefix$[ebp]
	je	SHORT $LN37@xmlSAX2Sta
	cmp	edx, ebx
	jne	SHORT $LN37@xmlSAX2Sta

; 2322 : 		ret->ns = ns;

	mov	DWORD PTR [edi+36], eax
$LN37@xmlSAX2Sta:

; 2323 : 	} else {
; 2324 :             /*
; 2325 :              * any out of memory error would already have been raised
; 2326 :              * but we can't be guaranteed it's the actual error due to the
; 2327 :              * API, best is to skip in this case
; 2328 :              */
; 2329 : 	    continue;
; 2330 : 	}
; 2331 : #ifdef LIBXML_VALID_ENABLED
; 2332 : 	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
; 2333 : 	    ctxt->myDoc && ctxt->myDoc->intSubset) {

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN2@xmlSAX2Sta
	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN2@xmlSAX2Sta
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN2@xmlSAX2Sta
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN2@xmlSAX2Sta
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN2@xmlSAX2Sta

; 2334 : 	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,

	push	DWORD PTR _uri$1$[ebp]
	push	eax
	push	edx
	push	edi
	push	ecx
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneNamespace
	add	esp, 24					; 00000018H
	and	DWORD PTR [esi+100], eax
$LN2@xmlSAX2Sta:

; 2306 :     }
; 2307 :     /*
; 2308 :      * Build the namespace list
; 2309 :      */
; 2310 :     for (i = 0,j = 0;j < nb_namespaces;j++) {

	sub	DWORD PTR _nb_namespaces$[ebp], 1
	mov	ecx, DWORD PTR _i$1$[ebp]
	jne	$LL4@xmlSAX2Sta
$LN3@xmlSAX2Sta:

; 2335 : 	                                           ret, prefix, ns, uri);
; 2336 : 	}
; 2337 : #endif /* LIBXML_VALID_ENABLED */
; 2338 :     }
; 2339 :     ctxt->nodemem = -1;
; 2340 : 
; 2341 :     /*
; 2342 :      * We are parsing a new node.
; 2343 :      */
; 2344 :     if (nodePush(ctxt, ret) < 0) {

	push	edi
	push	esi
	mov	DWORD PTR [esi+264], -1
	call	_nodePush
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN39@xmlSAX2Sta

; 2345 :         xmlUnlinkNode(ret);

	push	edi
	call	_xmlUnlinkNode

; 2346 :         xmlFreeNode(ret);

	push	edi
	call	_xmlFreeNode

; 2380 : 
; 2381 : 	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");

	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 2445 :     }
; 2446 : #endif /* LIBXML_VALID_ENABLED */
; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlSAX2Sta:

; 2347 :         return;
; 2348 :     }
; 2349 : 
; 2350 :     /*
; 2351 :      * Link the child element
; 2352 :      */
; 2353 :     if (parent != NULL) {

	mov	ecx, DWORD PTR _parent$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN42@xmlSAX2Sta

; 2354 :         if (parent->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [ecx+4], 1
	push	edi
	push	ecx
	jne	SHORT $LN41@xmlSAX2Sta

; 2355 : 	    xmlAddChild(parent, ret);

	call	_xmlAddChild

; 2356 : 	} else {

	jmp	SHORT $LN83@xmlSAX2Sta
$LN41@xmlSAX2Sta:

; 2357 : 	    xmlAddSibling(parent, ret);

	call	_xmlAddSibling
$LN83@xmlSAX2Sta:

; 2358 : 	}
; 2359 :     }
; 2360 : 
; 2361 :     /*
; 2362 :      * Insert the defaulted attributes from the DTD only if requested:
; 2363 :      */
; 2364 :     if ((nb_defaulted != 0) &&

	mov	ecx, DWORD PTR _parent$1$[ebp]
	add	esp, 8
$LN42@xmlSAX2Sta:
	mov	eax, DWORD PTR _nb_defaulted$[ebp]
	test	eax, eax
	je	SHORT $LN73@xmlSAX2Sta
	test	BYTE PTR [esi+276], 4
	jne	SHORT $LN73@xmlSAX2Sta

; 2365 :         ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
; 2366 : 	nb_attributes -= nb_defaulted;

	mov	ebx, DWORD PTR _nb_attributes$[ebp]
	sub	ebx, eax
	jmp	SHORT $LN84@xmlSAX2Sta
$LN73@xmlSAX2Sta:

; 2358 : 	}
; 2359 :     }
; 2360 : 
; 2361 :     /*
; 2362 :      * Insert the defaulted attributes from the DTD only if requested:
; 2363 :      */
; 2364 :     if ((nb_defaulted != 0) &&

	mov	ebx, DWORD PTR _nb_attributes$[ebp]
$LN84@xmlSAX2Sta:

; 2367 : 
; 2368 :     /*
; 2369 :      * Search the namespace if it wasn't already found
; 2370 :      * Note that, if prefix is NULL, this searches for the default Ns
; 2371 :      */
; 2372 :     if ((URI != NULL) && (ret->ns == NULL)) {

	cmp	DWORD PTR _URI$[ebp], 0
	mov	DWORD PTR _nb_attributes$1$[ebp], ebx
	je	$LN49@xmlSAX2Sta
	cmp	DWORD PTR [edi+36], 0
	jne	SHORT $LN49@xmlSAX2Sta

; 2373 :         ret->ns = xmlSearchNs(ctxt->myDoc, parent, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	ecx
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+36], eax

; 2374 : 	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {

	test	eax, eax
	jne	SHORT $LN45@xmlSAX2Sta
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlSAX2Sta

; 2375 : 	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+36], eax
$LN45@xmlSAX2Sta:

; 2376 : 	}
; 2377 : 	if (ret->ns == NULL) {

	cmp	DWORD PTR [edi+36], 0
	jne	SHORT $LN49@xmlSAX2Sta

; 2378 : 	    ns = xmlNewNs(ret, NULL, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	0
	push	edi
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 2379 : 	    if (ns == NULL) {

	test	eax, eax
	je	$LN71@xmlSAX2Sta

; 2382 : 		return;
; 2383 : 	    }
; 2384 :             if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	push	0
	test	eax, eax
	je	SHORT $LN48@xmlSAX2Sta

; 2385 :                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	push	eax
	push	OFFSET ??_C@_0CD@HMPDFDML@Namespace?5prefix?5?$CFs?5was?5not?5fou@
	jmp	SHORT $LN85@xmlSAX2Sta
$LN48@xmlSAX2Sta:

; 2386 :                              "Namespace prefix %s was not found\n",
; 2387 :                              prefix, NULL);
; 2388 :             else
; 2389 :                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	push	0
	push	OFFSET ??_C@_0CI@JKKHNIFK@Namespace?5default?5prefix?5was?5no@
$LN85@xmlSAX2Sta:

; 2390 :                              "Namespace default prefix was not found\n",
; 2391 :                              NULL, NULL);
; 2392 : 	}
; 2393 :     }
; 2394 : 
; 2395 :     /*
; 2396 :      * process all the other attributes
; 2397 :      */
; 2398 :     if (nb_attributes > 0) {

	push	201					; 000000c9H
	push	esi
	call	_xmlNsWarnMsg
	add	esp, 20					; 00000014H
$LN49@xmlSAX2Sta:
	test	ebx, ebx
	jle	$LN6@xmlSAX2Sta

; 2399 :         for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {

	mov	edi, DWORD PTR _attributes$[ebp]
	add	edi, 16					; 00000010H
	npad	2
$LL7@xmlSAX2Sta:

; 2400 : 	    /*
; 2401 : 	     * Handle the rare case of an undefined atribute prefix
; 2402 : 	     */
; 2403 : 	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {

	mov	eax, DWORD PTR [edi-12]
	test	eax, eax
	je	SHORT $LN55@xmlSAX2Sta
	cmp	DWORD PTR [edi-8], 0
	jne	SHORT $LN55@xmlSAX2Sta

; 2404 : 		if (ctxt->dictNames) {

	cmp	DWORD PTR [esi+364], 0
	mov	ecx, DWORD PTR [edi-16]
	je	SHORT $LN52@xmlSAX2Sta

; 2405 : 		    const xmlChar *fullname;
; 2406 : 
; 2407 : 		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],

	push	ecx
	push	eax
	push	DWORD PTR [esi+296]
	call	_xmlDictQLookup
	add	esp, 12					; 0000000cH

; 2408 : 		                              attributes[j]);
; 2409 : 		    if (fullname != NULL) {

	test	eax, eax
	je	SHORT $LN55@xmlSAX2Sta

; 2410 : 			xmlSAX2AttributeNs(ctxt, fullname, NULL,

	push	DWORD PTR [edi]
	push	DWORD PTR [edi-4]
	push	0
	push	eax

; 2411 : 			                   attributes[j+3], attributes[j+4]);
; 2412 : 		        continue;

	jmp	SHORT $LN86@xmlSAX2Sta
$LN52@xmlSAX2Sta:

; 2413 : 		    }
; 2414 : 		} else {
; 2415 : 		    lname = xmlBuildQName(attributes[j], attributes[j+1],

	push	0
	push	0
	push	eax
	push	ecx
	call	_xmlBuildQName
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 2416 : 		                          NULL, 0);
; 2417 : 		    if (lname != NULL) {

	test	ebx, ebx
	je	SHORT $LN74@xmlSAX2Sta

; 2418 : 			xmlSAX2AttributeNs(ctxt, lname, NULL,

	push	DWORD PTR [edi]
	push	DWORD PTR [edi-4]
	push	0
	push	ebx
	push	esi
	call	_xmlSAX2AttributeNs

; 2419 : 			                   attributes[j+3], attributes[j+4]);
; 2420 : 			xmlFree(lname);

	push	ebx
	call	DWORD PTR _xmlFree

; 2421 : 		        continue;

	mov	ebx, DWORD PTR _nb_attributes$1$[ebp]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN5@xmlSAX2Sta
$LN74@xmlSAX2Sta:

; 2416 : 		                          NULL, 0);
; 2417 : 		    if (lname != NULL) {

	mov	ebx, DWORD PTR _nb_attributes$1$[ebp]
$LN55@xmlSAX2Sta:

; 2422 : 		    }
; 2423 : 		}
; 2424 : 	    }
; 2425 : 	    xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],

	push	DWORD PTR [edi]
	push	DWORD PTR [edi-4]
	push	DWORD PTR [edi-12]
	push	DWORD PTR [edi-16]
$LN86@xmlSAX2Sta:

; 2399 :         for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {

	push	esi
	call	_xmlSAX2AttributeNs
	add	esp, 20					; 00000014H
$LN5@xmlSAX2Sta:
	add	edi, 20					; 00000014H
	sub	ebx, 1
	mov	DWORD PTR _nb_attributes$1$[ebp], ebx
	jne	$LL7@xmlSAX2Sta
$LN6@xmlSAX2Sta:

; 2426 : 			       attributes[j+3], attributes[j+4]);
; 2427 : 	}
; 2428 :     }
; 2429 : 
; 2430 : #ifdef LIBXML_VALID_ENABLED
; 2431 :     /*
; 2432 :      * If it's the Document root, finish the DTD validation and
; 2433 :      * check the document root element for validity
; 2434 :      */
; 2435 :     if ((ctxt->validate) && (ctxt->vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN78@xmlSAX2Sta
	cmp	DWORD PTR [esi+136], -1412623820	; abcd1234H
	jne	SHORT $LN78@xmlSAX2Sta

; 2436 : 	int chk;
; 2437 : 
; 2438 : 	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);

	push	DWORD PTR [esi+8]
	lea	edi, DWORD PTR [esi+108]
	push	edi
	call	_xmlValidateDtdFinal
	add	esp, 8

; 2439 : 	if (chk <= 0)

	test	eax, eax
	jg	SHORT $LN87@xmlSAX2Sta

; 2440 : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
$LN87@xmlSAX2Sta:

; 2441 : 	if (chk < 0)

	jns	SHORT $LN58@xmlSAX2Sta

; 2442 : 	    ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0
$LN58@xmlSAX2Sta:

; 2443 : 	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlValidateRoot
	add	esp, 8

; 2444 : 	ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;

	mov	DWORD PTR [esi+136], -1412623819	; abcd1235H
	and	DWORD PTR [esi+100], eax
	pop	edi
	pop	ebx
	pop	esi

; 2445 :     }
; 2446 : #endif /* LIBXML_VALID_ENABLED */
; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlSAX2Sta:

; 2380 : 
; 2381 : 	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");

	push	OFFSET ??_C@_0BG@CNBDKEMA@xmlSAX2StartElementNs@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN78@xmlSAX2Sta:
	pop	edi
	pop	ebx
$LN56@xmlSAX2Sta:
	pop	esi

; 2445 :     }
; 2446 : #endif /* LIBXML_VALID_ENABLED */
; 2447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2StartElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2EndElement
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSAX2EndElement PROC					; COMDAT

; 1804 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN1@xmlSAX2End

; 1805 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 1806 :     xmlNodePtr cur;
; 1807 : 
; 1808 :     if (ctx == NULL) return;
; 1809 :     cur = ctxt->node;

	push	edi
	mov	edi, DWORD PTR [esi+52]

; 1810 : #ifdef DEBUG_SAX
; 1811 :     if (name == NULL)
; 1812 :         xmlGenericError(xmlGenericErrorContext, "SAX.xmlSAX2EndElement(NULL)\n");
; 1813 :     else
; 1814 : 	xmlGenericError(xmlGenericErrorContext, "SAX.xmlSAX2EndElement(%s)\n", name);
; 1815 : #endif
; 1816 : 
; 1817 :     /* Capture end position and add node */
; 1818 :     if (cur != NULL && ctxt->record_info) {

	test	edi, edi
	je	SHORT $LN3@xmlSAX2End
	cmp	DWORD PTR [esi+68], 0
	je	SHORT $LN3@xmlSAX2End

; 1819 :       ctxt->nodeInfo->end_pos = ctxt->input->cur - ctxt->input->base;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [eax+12], ecx

; 1820 :       ctxt->nodeInfo->end_line = ctxt->input->line;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+448]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+16], eax

; 1821 :       ctxt->nodeInfo->node = cur;

	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [eax], edi

; 1822 :       xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);

	push	DWORD PTR [esi+448]
	push	esi
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN3@xmlSAX2End:

; 1823 :     }
; 1824 :     ctxt->nodemem = -1;
; 1825 : 
; 1826 : #ifdef LIBXML_VALID_ENABLED
; 1827 :     if (ctxt->validate && ctxt->wellFormed &&
; 1828 :         ctxt->myDoc && ctxt->myDoc->intSubset)

	cmp	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+264], -1
	je	SHORT $LN4@xmlSAX2End
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN4@xmlSAX2End
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlSAX2End
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@xmlSAX2End

; 1829 :         ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,

	push	edi
	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateOneElement
	add	esp, 12					; 0000000cH
	and	DWORD PTR [esi+100], eax
$LN4@xmlSAX2End:

; 1830 : 					     cur);
; 1831 : #endif /* LIBXML_VALID_ENABLED */
; 1832 : 
; 1833 : 
; 1834 :     /*
; 1835 :      * end of parsing of this node.
; 1836 :      */
; 1837 : #ifdef DEBUG_SAX_TREE
; 1838 :     xmlGenericError(xmlGenericErrorContext, "popping(%s)\n", cur->name);
; 1839 : #endif
; 1840 :     nodePop(ctxt);

	push	esi
	call	_nodePop
	add	esp, 4
	pop	edi
$LN1@xmlSAX2End:
	pop	esi

; 1841 : }

	pop	ebp
	ret	0
_xmlSAX2EndElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2StartElement
_TEXT	SEGMENT
_name$1$ = -8						; size = 4
_prefix$ = -4						; size = 4
_parent$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_fullname$ = 12						; size = 4
_atts$ = 16						; size = 4
_xmlSAX2StartElement PROC				; COMDAT

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __A8525CDE_sax2@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN9@xmlSAX2Sta

; 1594 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 1595 :     xmlNodePtr ret;
; 1596 :     xmlNodePtr parent;
; 1597 :     xmlNsPtr ns;
; 1598 :     xmlChar *name;
; 1599 :     xmlChar *prefix;
; 1600 :     const xmlChar *att;
; 1601 :     const xmlChar *value;
; 1602 :     int i;
; 1603 : 
; 1604 :     if ((ctx == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL)) return;

	push	edi
	mov	edi, DWORD PTR _fullname$[ebp]
	test	edi, edi
	je	$LN64@xmlSAX2Sta
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN64@xmlSAX2Sta

; 1605 :     parent = ctxt->node;
; 1606 : #ifdef DEBUG_SAX
; 1607 :     xmlGenericError(xmlGenericErrorContext,
; 1608 : 	    "SAX.xmlSAX2StartElement(%s)\n", fullname);
; 1609 : #endif
; 1610 : 
; 1611 :     /*
; 1612 :      * First check on validity:
; 1613 :      */
; 1614 :     if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&

	cmp	DWORD PTR [esi+104], 0
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _parent$1$[ebp], ecx
	je	SHORT $LN10@xmlSAX2Sta
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN10@xmlSAX2Sta
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN11@xmlSAX2Sta
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN10@xmlSAX2Sta
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN10@xmlSAX2Sta
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN10@xmlSAX2Sta
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN10@xmlSAX2Sta
$LN11@xmlSAX2Sta:

; 1615 :         ((ctxt->myDoc->intSubset == NULL) ||
; 1616 : 	 ((ctxt->myDoc->intSubset->notations == NULL) &&
; 1617 : 	  (ctxt->myDoc->intSubset->elements == NULL) &&
; 1618 : 	  (ctxt->myDoc->intSubset->attributes == NULL) &&
; 1619 : 	  (ctxt->myDoc->intSubset->entities == NULL)))) {
; 1620 : 	xmlErrValid(ctxt, XML_ERR_NO_DTD,

	push	0
	push	0
	push	OFFSET ??_C@_0CC@LPGBEFAE@Validation?5failed?3?5no?5DTD?5found@
	push	94					; 0000005eH
	push	esi
	call	_xmlErrValid
	add	esp, 20					; 00000014H

; 1621 : 	  "Validation failed: no DTD found !", NULL, NULL);
; 1622 : 	ctxt->validate = 0;

	mov	DWORD PTR [esi+104], 0
$LN10@xmlSAX2Sta:

; 1623 :     }
; 1624 : 
; 1625 : 
; 1626 :     /*
; 1627 :      * Split the full name into a namespace prefix and the tag name
; 1628 :      */
; 1629 :     name = xmlSplitQName(ctxt, fullname, &prefix);

	push	ebx
	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	edi
	push	esi
	call	_xmlSplitQName

; 1630 : 
; 1631 : 
; 1632 :     /*
; 1633 :      * Note : the namespace resolution is deferred until the end of the
; 1634 :      *        attributes parsing, since local namespace can be defined as
; 1635 :      *        an attribute at this level.
; 1636 :      */
; 1637 :     ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, name, NULL);

	push	0
	push	eax
	push	0
	push	DWORD PTR [esi+8]
	mov	DWORD PTR _name$1$[ebp], eax
	call	_xmlNewDocNodeEatName
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 1638 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN12@xmlSAX2Sta

; 1639 :         if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlSAX2Sta

; 1640 : 	    xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlSAX2Sta:

; 1641 : 	xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElement");

	push	OFFSET ??_C@_0BE@NLCCMPDP@xmlSAX2StartElement@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 1792 : 
; 1793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSAX2Sta:

; 1642 :         return;
; 1643 :     }
; 1644 :     if (ctxt->myDoc->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN14@xmlSAX2Sta

; 1645 : #ifdef DEBUG_SAX_TREE
; 1646 : 	xmlGenericError(xmlGenericErrorContext, "Setting %s as root\n", name);
; 1647 : #endif
; 1648 :         xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);

	push	ebx
	push	eax
	call	_xmlAddChild
	mov	edi, DWORD PTR _parent$1$[ebp]
	add	esp, 8
	jmp	SHORT $LN16@xmlSAX2Sta
$LN14@xmlSAX2Sta:

; 1649 :     } else if (parent == NULL) {

	mov	edi, DWORD PTR _parent$1$[ebp]
	test	edi, edi
	cmove	edi, ecx
	mov	DWORD PTR _parent$1$[ebp], edi
$LN16@xmlSAX2Sta:

; 1650 :         parent = ctxt->myDoc->children;
; 1651 :     }
; 1652 :     ctxt->nodemem = -1;
; 1653 :     if (ctxt->linenumbers) {

	cmp	DWORD PTR [esi+280], 0
	mov	DWORD PTR [esi+264], -1
	je	SHORT $LN20@xmlSAX2Sta

; 1654 : 	if (ctxt->input != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN20@xmlSAX2Sta

; 1655 : 	    if (ctxt->input->line < 65535)

	mov	eax, DWORD PTR [eax+28]
	cmp	eax, 65535				; 0000ffffH
	jl	SHORT $LN66@xmlSAX2Sta

; 1656 : 		ret->line = (short) ctxt->input->line;
; 1657 : 	    else
; 1658 : 	        ret->line = 65535;

	mov	eax, 65535				; 0000ffffH
$LN66@xmlSAX2Sta:

; 1659 : 	}
; 1660 :     }
; 1661 : 
; 1662 :     /*
; 1663 :      * We are parsing a new node.
; 1664 :      */
; 1665 : #ifdef DEBUG_SAX_TREE
; 1666 :     xmlGenericError(xmlGenericErrorContext, "pushing(%s)\n", name);
; 1667 : #endif
; 1668 :     if (nodePush(ctxt, ret) < 0) {

	mov	WORD PTR [ebx+56], ax
$LN20@xmlSAX2Sta:
	push	ebx
	push	esi
	call	_nodePush
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN21@xmlSAX2Sta

; 1669 :         xmlUnlinkNode(ret);

	push	ebx
	call	_xmlUnlinkNode

; 1670 :         xmlFreeNode(ret);

	push	ebx
	call	_xmlFreeNode
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 1792 : 
; 1793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSAX2Sta:

; 1671 :         return;
; 1672 :     }
; 1673 : 
; 1674 :     /*
; 1675 :      * Link the child element
; 1676 :      */
; 1677 :     if (parent != NULL) {

	test	edi, edi
	je	SHORT $LN24@xmlSAX2Sta

; 1678 :         if (parent->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1
	push	ebx
	push	edi
	jne	SHORT $LN23@xmlSAX2Sta

; 1679 : #ifdef DEBUG_SAX_TREE
; 1680 : 	    xmlGenericError(xmlGenericErrorContext,
; 1681 : 		    "adding child %s to %s\n", name, parent->name);
; 1682 : #endif
; 1683 : 	    xmlAddChild(parent, ret);

	call	_xmlAddChild

; 1684 : 	} else {

	jmp	SHORT $LN67@xmlSAX2Sta
$LN23@xmlSAX2Sta:

; 1685 : #ifdef DEBUG_SAX_TREE
; 1686 : 	    xmlGenericError(xmlGenericErrorContext,
; 1687 : 		    "adding sibling %s to ", name);
; 1688 : 	    xmlDebugDumpOneNode(stderr, parent, 0);
; 1689 : #endif
; 1690 : 	    xmlAddSibling(parent, ret);

	call	_xmlAddSibling
$LN67@xmlSAX2Sta:

; 1691 : 	}
; 1692 :     }
; 1693 : 
; 1694 :     /*
; 1695 :      * Insert all the defaulted attributes from the DTD especially namespaces
; 1696 :      */
; 1697 :     if ((!ctxt->html) &&

	add	esp, 8
$LN24@xmlSAX2Sta:
	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN63@xmlSAX2Sta
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN26@xmlSAX2Sta
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN63@xmlSAX2Sta
$LN26@xmlSAX2Sta:

; 1698 : 	((ctxt->myDoc->intSubset != NULL) ||
; 1699 : 	 (ctxt->myDoc->extSubset != NULL))) {
; 1700 : 	xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);

	mov	edi, DWORD PTR _atts$[ebp]
	push	edi
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _name$1$[ebp]
	push	esi
	call	_xmlCheckDefaultedAttributes
	add	esp, 16					; 00000010H
	jmp	SHORT $LN25@xmlSAX2Sta
$LN63@xmlSAX2Sta:

; 1701 :     }
; 1702 : 
; 1703 :     /*
; 1704 :      * process all the attributes whose name start with "xmlns"
; 1705 :      */
; 1706 :     if (atts != NULL) {

	mov	edi, DWORD PTR _atts$[ebp]
$LN25@xmlSAX2Sta:
	test	edi, edi
	je	SHORT $LN60@xmlSAX2Sta

; 1709 : 	value = atts[i++];
; 1710 : 	if (!ctxt->html) {

	cmp	DWORD PTR [esi+32], 0
	mov	ecx, DWORD PTR [edi+4]
	jne	SHORT $LN60@xmlSAX2Sta

; 1711 : 	    while ((att != NULL) && (value != NULL)) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN60@xmlSAX2Sta

; 1707 :         i = 0;
; 1708 : 	att = atts[i++];

	add	edi, 8
	npad	3
$LL2@xmlSAX2Sta:

; 1711 : 	    while ((att != NULL) && (value != NULL)) {

	test	ecx, ecx
	je	SHORT $LN60@xmlSAX2Sta

; 1712 : 		if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
; 1713 : 		    (att[3] == 'n') && (att[4] == 's'))

	cmp	BYTE PTR [eax], 120			; 00000078H
	jne	SHORT $LN29@xmlSAX2Sta
	cmp	BYTE PTR [eax+1], 109			; 0000006dH
	jne	SHORT $LN29@xmlSAX2Sta
	cmp	BYTE PTR [eax+2], 108			; 0000006cH
	jne	SHORT $LN29@xmlSAX2Sta
	cmp	BYTE PTR [eax+3], 110			; 0000006eH
	jne	SHORT $LN29@xmlSAX2Sta
	cmp	BYTE PTR [eax+4], 115			; 00000073H
	jne	SHORT $LN29@xmlSAX2Sta

; 1714 : 		    xmlSAX2AttributeInternal(ctxt, att, value, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	ecx
	push	eax
	push	esi
	call	_xmlSAX2AttributeInternal
	add	esp, 16					; 00000010H
$LN29@xmlSAX2Sta:

; 1715 : 
; 1716 : 		att = atts[i++];

	mov	eax, DWORD PTR [edi]

; 1717 : 		value = atts[i++];

	mov	ecx, DWORD PTR [edi+4]
	add	edi, 8
	test	eax, eax
	jne	SHORT $LL2@xmlSAX2Sta
$LN60@xmlSAX2Sta:

; 1718 : 	    }
; 1719 : 	}
; 1720 :     }
; 1721 : 
; 1722 :     /*
; 1723 :      * Search the namespace, note that since the attributes have been
; 1724 :      * processed, the local namespaces are available.
; 1725 :      */
; 1726 :     ns = xmlSearchNs(ctxt->myDoc, ret, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1727 :     if ((ns == NULL) && (parent != NULL))

	test	edi, edi
	jne	SHORT $LN30@xmlSAX2Sta
	mov	ecx, DWORD PTR _parent$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@xmlSAX2Sta

; 1728 : 	ns = xmlSearchNs(ctxt->myDoc, parent, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	ecx
	push	DWORD PTR [esi+8]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN30@xmlSAX2Sta:

; 1729 :     if ((prefix != NULL) && (ns == NULL)) {

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN31@xmlSAX2Sta
	test	edi, edi
	jne	SHORT $LN57@xmlSAX2Sta

; 1730 : 	ns = xmlNewNs(ret, NULL, prefix);

	push	eax
	push	edi
	push	ebx
	call	_xmlNewNs

; 1731 : 	xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	push	0
	push	DWORD PTR _prefix$[ebp]
	mov	edi, eax
	push	OFFSET ??_C@_0CE@HAGAOPBB@Namespace?5prefix?5?$CFs?5is?5not?5defi@
	push	201					; 000000c9H
	push	esi
	call	_xmlNsWarnMsg
	add	esp, 32					; 00000020H
$LN31@xmlSAX2Sta:

; 1732 : 		     "Namespace prefix %s is not defined\n",
; 1733 : 		     prefix, NULL);
; 1734 :     }
; 1735 : 
; 1736 :     /*
; 1737 :      * set the namespace node, making sure that if the default namspace
; 1738 :      * is unbound on a parent we simply kee it NULL
; 1739 :      */
; 1740 :     if ((ns != NULL) && (ns->href != NULL) &&

	test	edi, edi
	je	SHORT $LN32@xmlSAX2Sta
$LN57@xmlSAX2Sta:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN32@xmlSAX2Sta
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN33@xmlSAX2Sta
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN32@xmlSAX2Sta
$LN33@xmlSAX2Sta:

; 1741 : 	((ns->href[0] != 0) || (ns->prefix != NULL)))
; 1742 : 	xmlSetNs(ret, ns);

	push	edi
	push	ebx
	call	_xmlSetNs
	add	esp, 8
$LN32@xmlSAX2Sta:

; 1743 : 
; 1744 :     /*
; 1745 :      * process all the other attributes
; 1746 :      */
; 1747 :     if (atts != NULL) {

	mov	edx, DWORD PTR _atts$[ebp]
	test	edx, edx
	je	SHORT $LN61@xmlSAX2Sta

; 1748 :         i = 0;
; 1749 : 	att = atts[i++];

	mov	eax, DWORD PTR [edx]

; 1750 : 	value = atts[i++];

	mov	ecx, DWORD PTR [edx+4]

; 1752 : 	    while (att != NULL) {

	test	eax, eax
	je	SHORT $LN61@xmlSAX2Sta

; 1751 : 	if (ctxt->html) {

	cmp	DWORD PTR [esi+32], 0
	lea	edi, DWORD PTR [edx+8]
	je	SHORT $LL6@xmlSAX2Sta
	npad	2
$LL4@xmlSAX2Sta:

; 1753 : 		xmlSAX2AttributeInternal(ctxt, att, value, NULL);

	push	0
	push	ecx
	push	eax
	push	esi
	call	_xmlSAX2AttributeInternal

; 1754 : 		att = atts[i++];

	mov	eax, DWORD PTR [edi]

; 1755 : 		value = atts[i++];

	lea	edi, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi-4]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL4@xmlSAX2Sta

; 1756 : 	    }
; 1757 : 	} else {

	jmp	SHORT $LN61@xmlSAX2Sta
	npad	5
$LL6@xmlSAX2Sta:

; 1758 : 	    while ((att != NULL) && (value != NULL)) {

	test	ecx, ecx
	je	SHORT $LN61@xmlSAX2Sta

; 1759 : 		if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||
; 1760 : 		    (att[3] != 'n') || (att[4] != 's'))

	cmp	BYTE PTR [eax], 120			; 00000078H
	jne	SHORT $LN38@xmlSAX2Sta
	cmp	BYTE PTR [eax+1], 109			; 0000006dH
	jne	SHORT $LN38@xmlSAX2Sta
	cmp	BYTE PTR [eax+2], 108			; 0000006cH
	jne	SHORT $LN38@xmlSAX2Sta
	cmp	BYTE PTR [eax+3], 110			; 0000006eH
	jne	SHORT $LN38@xmlSAX2Sta
	cmp	BYTE PTR [eax+4], 115			; 00000073H
	je	SHORT $LN37@xmlSAX2Sta
$LN38@xmlSAX2Sta:

; 1761 : 		    xmlSAX2AttributeInternal(ctxt, att, value, NULL);

	push	0
	push	ecx
	push	eax
	push	esi
	call	_xmlSAX2AttributeInternal
	add	esp, 16					; 00000010H
$LN37@xmlSAX2Sta:

; 1762 : 
; 1763 : 		/*
; 1764 : 		 * Next ones
; 1765 : 		 */
; 1766 : 		att = atts[i++];

	mov	eax, DWORD PTR [edi]

; 1767 : 		value = atts[i++];

	mov	ecx, DWORD PTR [edi+4]
	add	edi, 8
	test	eax, eax
	jne	SHORT $LL6@xmlSAX2Sta
$LN61@xmlSAX2Sta:

; 1768 : 	    }
; 1769 : 	}
; 1770 :     }
; 1771 : 
; 1772 : #ifdef LIBXML_VALID_ENABLED
; 1773 :     /*
; 1774 :      * If it's the Document root, finish the DTD validation and
; 1775 :      * check the document root element for validity
; 1776 :      */
; 1777 :     if ((ctxt->validate) && (ctxt->vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN39@xmlSAX2Sta
	cmp	DWORD PTR [esi+136], -1412623820	; abcd1234H
	jne	SHORT $LN39@xmlSAX2Sta

; 1778 : 	int chk;
; 1779 : 
; 1780 : 	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);

	push	DWORD PTR [esi+8]
	lea	edi, DWORD PTR [esi+108]
	push	edi
	call	_xmlValidateDtdFinal
	add	esp, 8

; 1781 : 	if (chk <= 0)

	test	eax, eax
	jg	SHORT $LN68@xmlSAX2Sta

; 1782 : 	    ctxt->valid = 0;

	mov	DWORD PTR [esi+100], 0
$LN68@xmlSAX2Sta:

; 1783 : 	if (chk < 0)

	jns	SHORT $LN41@xmlSAX2Sta

; 1784 : 	    ctxt->wellFormed = 0;

	mov	DWORD PTR [esi+12], 0
$LN41@xmlSAX2Sta:

; 1785 : 	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlValidateRoot
	add	esp, 8

; 1786 : 	ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;

	mov	DWORD PTR [esi+136], -1412623819	; abcd1235H
	and	DWORD PTR [esi+100], eax
$LN39@xmlSAX2Sta:

; 1787 :     }
; 1788 : #endif /* LIBXML_VALID_ENABLED */
; 1789 : 
; 1790 :     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN65@xmlSAX2Sta

; 1791 : 	xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN65@xmlSAX2Sta:
	pop	ebx
$LN64@xmlSAX2Sta:
	pop	edi
$LN9@xmlSAX2Sta:
	pop	esi

; 1792 : 
; 1793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2StartElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2EndDocument
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2EndDocument PROC				; COMDAT

; 1049 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN6@xmlSAX2End

; 1050 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 1051 : #ifdef DEBUG_SAX
; 1052 :     xmlGenericError(xmlGenericErrorContext,
; 1053 : 	    "SAX.xmlSAX2EndDocument()\n");
; 1054 : #endif
; 1055 :     if (ctx == NULL) return;
; 1056 : #ifdef LIBXML_VALID_ENABLED
; 1057 :     if (ctxt->validate && ctxt->wellFormed &&
; 1058 :         ctxt->myDoc && ctxt->myDoc->intSubset)

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN3@xmlSAX2End
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN3@xmlSAX2End
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2End
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@xmlSAX2End

; 1059 : 	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);

	push	eax
	lea	eax, DWORD PTR [esi+108]
	push	eax
	call	_xmlValidateDocumentFinal
	add	esp, 8
	and	DWORD PTR [esi+100], eax
$LN3@xmlSAX2End:

; 1060 : #endif /* LIBXML_VALID_ENABLED */
; 1061 : 
; 1062 :     /*
; 1063 :      * Grab the encoding if it was added on-the-fly
; 1064 :      */
; 1065 :     if ((ctxt->encoding != NULL) && (ctxt->myDoc != NULL) &&

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN4@xmlSAX2End
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlSAX2End
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN4@xmlSAX2End

; 1066 : 	(ctxt->myDoc->encoding == NULL)) {
; 1067 : 	ctxt->myDoc->encoding = ctxt->encoding;

	mov	DWORD PTR [eax+60], ecx

; 1068 : 	ctxt->encoding = NULL;

	mov	DWORD PTR [esi+24], 0
$LN4@xmlSAX2End:

; 1069 :     }
; 1070 :     if ((ctxt->inputTab != NULL) &&
; 1071 :         (ctxt->inputNr > 0) && (ctxt->inputTab[0] != NULL) &&
; 1072 :         (ctxt->inputTab[0]->encoding != NULL) && (ctxt->myDoc != NULL) &&

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN5@xmlSAX2End
	cmp	DWORD PTR [esi+40], 0
	jle	SHORT $LN5@xmlSAX2End
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN5@xmlSAX2End
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN5@xmlSAX2End
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN5@xmlSAX2End
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $LN5@xmlSAX2End

; 1073 : 	(ctxt->myDoc->encoding == NULL)) {
; 1074 : 	ctxt->myDoc->encoding = xmlStrdup(ctxt->inputTab[0]->encoding);

	push	eax
	call	_xmlStrdup
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR [ecx+60], eax
$LN5@xmlSAX2End:

; 1075 :     }
; 1076 :     if ((ctxt->charset != XML_CHAR_ENCODING_NONE) && (ctxt->myDoc != NULL) &&

	mov	ecx, DWORD PTR [esi+256]
	test	ecx, ecx
	je	SHORT $LN6@xmlSAX2End
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@xmlSAX2End
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN6@xmlSAX2End

; 1077 : 	(ctxt->myDoc->charset == XML_CHAR_ENCODING_NONE)) {
; 1078 : 	ctxt->myDoc->charset = ctxt->charset;

	mov	DWORD PTR [eax+76], ecx
$LN6@xmlSAX2End:
	pop	esi

; 1079 :     }
; 1080 : }

	pop	ebp
	ret	0
_xmlSAX2EndDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2StartDocument
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2StartDocument PROC				; COMDAT

; 984  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN14@xmlSAX2Sta

; 985  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 986  :     xmlDocPtr doc;
; 987  : 
; 988  :     if (ctx == NULL) return;
; 989  : 
; 990  : #ifdef DEBUG_SAX
; 991  :     xmlGenericError(xmlGenericErrorContext,
; 992  : 	    "SAX.xmlSAX2StartDocument()\n");
; 993  : #endif
; 994  :     if (ctxt->html) {

	cmp	DWORD PTR [esi+32], 0
	push	edi
	je	SHORT $LN3@xmlSAX2Sta

; 995  : #ifdef LIBXML_HTML_ENABLED
; 996  : 	if (ctxt->myDoc == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN18@xmlSAX2Sta

; 997  : 	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);

	push	eax
	push	eax
	call	_htmlNewDocNoDtD
	add	esp, 8
	mov	DWORD PTR [esi+8], eax

; 998  : 	if (ctxt->myDoc == NULL) {

	test	eax, eax
	je	$LN7@xmlSAX2Sta
$LN18@xmlSAX2Sta:

; 999  : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
; 1000 : 	    return;
; 1001 : 	}
; 1002 : 	ctxt->myDoc->properties = XML_DOC_HTML;

	mov	DWORD PTR [eax+92], 128			; 00000080H

; 1003 : 	ctxt->myDoc->parseFlags = ctxt->options;

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+360]
	mov	DWORD PTR [ecx+88], eax

; 1004 : #else
; 1005 :         xmlGenericError(xmlGenericErrorContext,
; 1006 : 		"libxml2 built without HTML support\n");
; 1007 : 	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
; 1008 : 	ctxt->instate = XML_PARSER_EOF;
; 1009 : 	ctxt->disableSAX = 1;
; 1010 : 	return;
; 1011 : #endif
; 1012 :     } else {

	jmp	SHORT $LN12@xmlSAX2Sta
$LN3@xmlSAX2Sta:

; 1013 : 	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);

	push	DWORD PTR [esi+20]
	call	_xmlNewDoc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi+8], edi

; 1014 : 	if (doc != NULL) {

	test	edi, edi
	je	$LN7@xmlSAX2Sta

; 1015 : 	    doc->properties = 0;

	mov	DWORD PTR [edi+92], 0

; 1016 : 	    if (ctxt->options & XML_PARSE_OLD10)

	mov	eax, DWORD PTR [esi+360]
	test	eax, 131072				; 00020000H
	je	SHORT $LN9@xmlSAX2Sta

; 1017 : 	        doc->properties |= XML_DOC_OLD10;

	mov	DWORD PTR [edi+92], 4
	mov	eax, DWORD PTR [esi+360]
$LN9@xmlSAX2Sta:

; 1018 : 	    doc->parseFlags = ctxt->options;

	mov	DWORD PTR [edi+88], eax

; 1019 : 	    if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN10@xmlSAX2Sta

; 1020 : 		doc->encoding = xmlStrdup(ctxt->encoding);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN11@xmlSAX2Sta
$LN10@xmlSAX2Sta:

; 1021 : 	    else
; 1022 : 		doc->encoding = NULL;

	xor	eax, eax
$LN11@xmlSAX2Sta:

; 1023 : 	    doc->standalone = ctxt->standalone;

	mov	DWORD PTR [edi+60], eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+40], eax

; 1026 : 	    return;
; 1027 : 	}
; 1028 : 	if ((ctxt->dictNames) && (doc != NULL)) {

	cmp	DWORD PTR [esi+364], 0
	je	SHORT $LN12@xmlSAX2Sta

; 1029 : 	    doc->dict = ctxt->dict;

	mov	eax, DWORD PTR [esi+296]

; 1030 : 	    xmlDictReference(doc->dict);

	push	eax
	mov	DWORD PTR [edi+80], eax
	call	_xmlDictReference
	add	esp, 4
$LN12@xmlSAX2Sta:

; 1031 : 	}
; 1032 :     }
; 1033 :     if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
; 1034 : 	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN16@xmlSAX2Sta
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN16@xmlSAX2Sta
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN16@xmlSAX2Sta
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN16@xmlSAX2Sta

; 1035 : 	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);

	push	eax
	call	_xmlPathToURI
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR [ecx+72], eax

; 1036 : 	if (ctxt->myDoc->URL == NULL)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN16@xmlSAX2Sta
$LN7@xmlSAX2Sta:

; 1024 : 	} else {
; 1025 : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");

	push	OFFSET ??_C@_0BF@BOIPPPAK@xmlSAX2StartDocument@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN16@xmlSAX2Sta:
	pop	edi
$LN14@xmlSAX2Sta:
	pop	esi

; 1037 : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
; 1038 :     }
; 1039 : }

	pop	ebp
	ret	0
_xmlSAX2StartDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2UnparsedEntityDecl
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_publicId$ = 16						; size = 4
_systemId$ = 20						; size = 4
_notationName$ = 24					; size = 4
_xmlSAX2UnparsedEntityDecl PROC				; COMDAT

; 902  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN10@xmlSAX2Unp

; 903  :     xmlEntityPtr ent;
; 904  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 905  :     if (ctx == NULL) return;
; 906  : #ifdef DEBUG_SAX
; 907  :     xmlGenericError(xmlGenericErrorContext,
; 908  : 	    "SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\n",
; 909  :             name, publicId, systemId, notationName);
; 910  : #endif
; 911  :     if (ctxt->inSubset == 1) {

	mov	eax, DWORD PTR [esi+216]
	push	ebx
	push	edi
	cmp	eax, 1
	jne	SHORT $LN3@xmlSAX2Unp

; 912  : 	ent = xmlAddDocEntity(ctxt->myDoc, name,

	push	DWORD PTR _notationName$[ebp]
	mov	edi, DWORD PTR _systemId$[ebp]
	push	edi
	push	DWORD PTR _publicId$[ebp]
	push	3
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlAddDocEntity
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 913  : 			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
; 914  : 			publicId, systemId, notationName);
; 915  : 	if ((ent == NULL) && (ctxt->pedantic) &&
; 916  : 	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))

	test	ebx, ebx
	jne	$LN16@xmlSAX2Unp
	cmp	DWORD PTR [esi+268], eax
	je	$LN20@xmlSAX2Unp
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN20@xmlSAX2Unp
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	je	$LN20@xmlSAX2Unp

; 917  : 	    ctxt->sax->warning(ctxt->userData,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DD@GCBFDMPE@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@

; 938  : 	     "Entity(%s) already defined in the external subset\n", name);
; 939  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
; 940  : 	    xmlChar *URI;
; 941  : 	    const char *base = NULL;
; 942  : 
; 943  : 	    if (ctxt->input != NULL)
; 944  : 		base = ctxt->input->filename;
; 945  : 	    if (base == NULL)
; 946  : 		base = ctxt->directory;

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 953  : 	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
; 954  : 	               name, NULL);
; 955  :     }
; 956  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Unp:

; 918  : 	     "Entity(%s) already defined in the internal subset\n", name);
; 919  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
; 920  : 	    xmlChar *URI;
; 921  : 	    const char *base = NULL;
; 922  : 
; 923  : 	    if (ctxt->input != NULL)
; 924  : 		base = ctxt->input->filename;
; 925  : 	    if (base == NULL)
; 926  : 		base = ctxt->directory;
; 927  : 
; 928  : 	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
; 929  : 	    ent->URI = URI;
; 930  : 	}
; 931  :     } else if (ctxt->inSubset == 2) {

	cmp	eax, 2
	jne	SHORT $LN9@xmlSAX2Unp

; 932  : 	ent = xmlAddDtdEntity(ctxt->myDoc, name,

	push	DWORD PTR _notationName$[ebp]
	mov	edi, DWORD PTR _systemId$[ebp]
	push	edi
	push	DWORD PTR _publicId$[ebp]
	push	3
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlAddDtdEntity
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 933  : 			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
; 934  : 			publicId, systemId, notationName);
; 935  : 	if ((ent == NULL) && (ctxt->pedantic) &&
; 936  : 	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))

	test	ebx, ebx
	jne	SHORT $LN16@xmlSAX2Unp
	cmp	DWORD PTR [esi+268], eax
	je	SHORT $LN20@xmlSAX2Unp
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@xmlSAX2Unp
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	je	SHORT $LN20@xmlSAX2Unp

; 937  : 	    ctxt->sax->warning(ctxt->userData,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DD@ECLLADNP@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@

; 938  : 	     "Entity(%s) already defined in the external subset\n", name);
; 939  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
; 940  : 	    xmlChar *URI;
; 941  : 	    const char *base = NULL;
; 942  : 
; 943  : 	    if (ctxt->input != NULL)
; 944  : 		base = ctxt->input->filename;
; 945  : 	    if (base == NULL)
; 946  : 		base = ctxt->directory;

	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 953  : 	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
; 954  : 	               name, NULL);
; 955  :     }
; 956  : }

	pop	ebp
	ret	0
$LN16@xmlSAX2Unp:

; 938  : 	     "Entity(%s) already defined in the external subset\n", name);
; 939  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
; 940  : 	    xmlChar *URI;
; 941  : 	    const char *base = NULL;
; 942  : 
; 943  : 	    if (ctxt->input != NULL)
; 944  : 		base = ctxt->input->filename;
; 945  : 	    if (base == NULL)
; 946  : 		base = ctxt->directory;

	cmp	DWORD PTR [ebx+64], 0
	jne	SHORT $LN20@xmlSAX2Unp
	test	edi, edi
	je	SHORT $LN20@xmlSAX2Unp
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN19@xmlSAX2Unp
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	jne	SHORT $LN14@xmlSAX2Unp
$LN19@xmlSAX2Unp:
	mov	eax, DWORD PTR [esi+180]
$LN14@xmlSAX2Unp:

; 947  : 
; 948  : 	    URI = xmlBuildURI(systemId, (const xmlChar *) base);

	push	eax
	push	edi
	call	_xmlBuildURI
	add	esp, 8

; 949  : 	    ent->URI = URI;

	mov	DWORD PTR [ebx+64], eax
	pop	edi
	pop	ebx
	pop	esi

; 953  : 	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
; 954  : 	               name, NULL);
; 955  :     }
; 956  : }

	pop	ebp
	ret	0
$LN9@xmlSAX2Unp:

; 950  : 	}
; 951  :     } else {
; 952  :         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DO@IABCNOGI@SAX?4xmlSAX2UnparsedEntityDecl?$CI?$CF@
	push	1
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
$LN20@xmlSAX2Unp:
	pop	edi
	pop	ebx
$LN10@xmlSAX2Unp:
	pop	esi

; 953  : 	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
; 954  : 	               name, NULL);
; 955  :     }
; 956  : }

	pop	ebp
	ret	0
_xmlSAX2UnparsedEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2NotationDecl
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_publicId$ = 16						; size = 4
_systemId$ = 20						; size = 4
_xmlSAX2NotationDecl PROC				; COMDAT

; 850  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN3@xmlSAX2Not

; 851  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 852  :     xmlNotationPtr nota = NULL;
; 853  : 
; 854  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL))

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Not

; 855  :         return;
; 856  : 
; 857  : #ifdef DEBUG_SAX
; 858  :     xmlGenericError(xmlGenericErrorContext,
; 859  : 	    "SAX.xmlSAX2NotationDecl(%s, %s, %s)\n", name, publicId, systemId);
; 860  : #endif
; 861  : 
; 862  :     if ((publicId == NULL) && (systemId == NULL)) {

	cmp	DWORD PTR _publicId$[ebp], 0
	mov	edx, DWORD PTR _systemId$[ebp]
	jne	SHORT $LN4@xmlSAX2Not
	test	edx, edx
	jne	SHORT $LN4@xmlSAX2Not

; 863  : 	xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,

	push	edx
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DM@OMFMKHI@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5ext@
	push	105					; 00000069H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
	pop	esi

; 884  : 	                                       nota);
; 885  : #endif /* LIBXML_VALID_ENABLED */
; 886  : }

	pop	ebp
	ret	0
$LN4@xmlSAX2Not:

; 864  : 	     "SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n",
; 865  : 	               name, NULL);
; 866  : 	return;
; 867  :     } else if (ctxt->inSubset == 1)

	mov	ecx, DWORD PTR [esi+216]
	cmp	ecx, 1
	jne	SHORT $LN6@xmlSAX2Not

; 868  : 	nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, name,

	mov	eax, DWORD PTR [eax+44]
	jmp	SHORT $LN9@xmlSAX2Not
$LN6@xmlSAX2Not:

; 869  :                               publicId, systemId);
; 870  :     else if (ctxt->inSubset == 2)

	cmp	ecx, 2
	jne	SHORT $LN8@xmlSAX2Not

; 871  : 	nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, name,

	mov	eax, DWORD PTR [eax+48]
$LN9@xmlSAX2Not:
	push	ebx

; 875  : 	     "SAX.xmlSAX2NotationDecl(%s) called while not in subset\n",
; 876  : 	               name, NULL);
; 877  : 	return;
; 878  :     }
; 879  : #ifdef LIBXML_VALID_ENABLED
; 880  :     if (nota == NULL) ctxt->valid = 0;

	push	edx
	push	DWORD PTR _publicId$[ebp]
	lea	ebx, DWORD PTR [esi+108]
	push	DWORD PTR _name$[ebp]
	push	eax
	push	ebx
	call	_xmlAddNotationDecl
	mov	ecx, eax
	add	esp, 20					; 00000014H
	test	ecx, ecx
	jne	SHORT $LN14@xmlSAX2Not
	mov	DWORD PTR [esi+100], eax
$LN14@xmlSAX2Not:

; 881  :     if ((ctxt->validate) && (ctxt->wellFormed) &&

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN15@xmlSAX2Not
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN15@xmlSAX2Not
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN15@xmlSAX2Not

; 882  :         (ctxt->myDoc->intSubset != NULL))
; 883  : 	ctxt->valid &= xmlValidateNotationDecl(&ctxt->vctxt, ctxt->myDoc,

	push	ecx
	push	eax
	push	ebx
	call	_xmlValidateNotationDecl
	add	esp, 12					; 0000000cH
	and	DWORD PTR [esi+100], eax
$LN15@xmlSAX2Not:
	pop	ebx
$LN3@xmlSAX2Not:
	pop	esi

; 884  : 	                                       nota);
; 885  : #endif /* LIBXML_VALID_ENABLED */
; 886  : }

	pop	ebp
	ret	0
$LN8@xmlSAX2Not:

; 872  :                               publicId, systemId);
; 873  :     else {
; 874  : 	xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DI@MAMMGJDO@SAX?4xmlSAX2NotationDecl?$CI?$CFs?$CJ?5cal@
	push	105					; 00000069H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
	pop	esi

; 884  : 	                                       nota);
; 885  : #endif /* LIBXML_VALID_ENABLED */
; 886  : }

	pop	ebp
	ret	0
_xmlSAX2NotationDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2ElementDecl
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlSAX2ElementDecl PROC				; COMDAT

; 804  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSAX2Ele

; 805  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 806  :     xmlElementPtr elem = NULL;
; 807  : 
; 808  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL))

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Ele

; 809  :         return;
; 810  : 
; 811  : #ifdef DEBUG_SAX
; 812  :     xmlGenericError(xmlGenericErrorContext,
; 813  :                     "SAX.xmlSAX2ElementDecl(%s, %d, ...)\n", name, type);
; 814  : #endif
; 815  : 
; 816  :     if (ctxt->inSubset == 1)

	mov	ecx, DWORD PTR [esi+216]
	cmp	ecx, 1
	jne	SHORT $LN4@xmlSAX2Ele

; 817  :         elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->intSubset,

	mov	eax, DWORD PTR [eax+44]
	jmp	SHORT $LN7@xmlSAX2Ele
$LN4@xmlSAX2Ele:

; 818  :                                  name, (xmlElementTypeVal) type, content);
; 819  :     else if (ctxt->inSubset == 2)

	cmp	ecx, 2
	jne	SHORT $LN6@xmlSAX2Ele

; 820  :         elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->extSubset,

	mov	eax, DWORD PTR [eax+48]
$LN7@xmlSAX2Ele:
	push	edi

; 824  : 	     "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
; 825  : 	               name, NULL);
; 826  :         return;
; 827  :     }
; 828  : #ifdef LIBXML_VALID_ENABLED
; 829  :     if (elem == NULL)

	push	DWORD PTR _content$[ebp]
	lea	edi, DWORD PTR [esi+108]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	eax
	push	edi
	call	_xmlAddElementDecl
	mov	ecx, eax
	add	esp, 20					; 00000014H
	test	ecx, ecx
	jne	SHORT $LN12@xmlSAX2Ele

; 830  :         ctxt->valid = 0;

	mov	DWORD PTR [esi+100], eax
$LN12@xmlSAX2Ele:

; 831  :     if (ctxt->validate && ctxt->wellFormed &&
; 832  :         ctxt->myDoc && ctxt->myDoc->intSubset)

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN13@xmlSAX2Ele
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN13@xmlSAX2Ele
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN13@xmlSAX2Ele
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN13@xmlSAX2Ele

; 833  :         ctxt->valid &=

	push	ecx
	push	eax
	push	edi
	call	_xmlValidateElementDecl
	add	esp, 12					; 0000000cH
	and	DWORD PTR [esi+100], eax
$LN13@xmlSAX2Ele:
	pop	edi
$LN3@xmlSAX2Ele:
	pop	esi

; 834  :             xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
; 835  : #endif /* LIBXML_VALID_ENABLED */
; 836  : }

	pop	ebp
	ret	0
$LN6@xmlSAX2Ele:

; 821  :                                  name, (xmlElementTypeVal) type, content);
; 822  :     else {
; 823  :         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DH@FINDFGFC@SAX?4xmlSAX2ElementDecl?$CI?$CFs?$CJ?5call@
	push	1
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
	pop	esi

; 834  :             xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
; 835  : #endif /* LIBXML_VALID_ENABLED */
; 836  : }

	pop	ebp
	ret	0
_xmlSAX2ElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2AttributeDecl
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_ctx$ = 8						; size = 4
_elem$ = 12						; size = 4
_fullname$ = 16						; size = 4
_type$ = 20						; size = 4
_def$ = 24						; size = 4
_defaultValue$ = 28					; size = 4
_tree$ = 32						; size = 4
_xmlSAX2AttributeDecl PROC				; COMDAT

; 737  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	edi, edi
	je	$LN3@xmlSAX2Att

; 738  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 739  :     xmlAttributePtr attr;
; 740  :     xmlChar *name = NULL, *prefix = NULL;
; 741  : 
; 742  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL))

	cmp	DWORD PTR [edi+8], 0
	je	$LN3@xmlSAX2Att

; 743  :         return;
; 744  : 
; 745  : #ifdef DEBUG_SAX
; 746  :     xmlGenericError(xmlGenericErrorContext,
; 747  : 	    "SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\n",
; 748  :             elem, fullname, type, def, defaultValue);
; 749  : #endif
; 750  :     if ((xmlStrEqual(fullname, BAD_CAST "xml:id")) &&

	push	ebx
	mov	ebx, DWORD PTR _fullname$[ebp]
	push	esi
	push	OFFSET ??_C@_06IMLNHOMM@xml?3id@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlSAX2Att
	cmp	DWORD PTR _type$[ebp], 2
	je	SHORT $LN4@xmlSAX2Att

; 751  :         (type != XML_ATTRIBUTE_ID)) {
; 752  : 	/*
; 753  : 	 * Raise the error but keep the validity flag
; 754  : 	 */
; 755  : 	int tmp = ctxt->valid;

	mov	esi, DWORD PTR [edi+100]

; 756  : 	xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@DOFEKNB@xml?3id?5?3?5attribute?5type?5should?5@
	push	540					; 0000021cH
	push	edi
	call	_xmlErrValid
	add	esp, 20					; 00000014H

; 757  : 	      "xml:id : attribute type should be ID\n", NULL, NULL);
; 758  : 	ctxt->valid = tmp;

	mov	DWORD PTR [edi+100], esi
$LN4@xmlSAX2Att:

; 759  :     }
; 760  :     /* TODO: optimize name/prefix allocation */
; 761  :     name = xmlSplitQName(ctxt, fullname, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_xmlSplitQName
	mov	esi, eax

; 762  :     ctxt->vctxt.valid = 1;

	mov	DWORD PTR [edi+144], 1

; 763  :     if (ctxt->inSubset == 1)

	mov	eax, DWORD PTR [edi+216]
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN5@xmlSAX2Att

; 764  : 	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,

	push	DWORD PTR _tree$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	push	DWORD PTR _defaultValue$[ebp]
	push	DWORD PTR _def$[ebp]
	push	eax
	push	DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR [edi+8]
	push	esi
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+44]
	jmp	SHORT $LN18@xmlSAX2Att
$LN5@xmlSAX2Att:

; 765  : 	       name, prefix, (xmlAttributeType) type,
; 766  : 	       (xmlAttributeDefault) def, defaultValue, tree);
; 767  :     else if (ctxt->inSubset == 2)

	cmp	eax, 2
	jne	$LN7@xmlSAX2Att

; 768  : 	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,

	push	DWORD PTR _tree$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	push	DWORD PTR _defaultValue$[ebp]
	push	DWORD PTR _def$[ebp]
	push	eax
	push	DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR [edi+8]
	push	esi
	push	DWORD PTR _elem$[ebp]
	push	DWORD PTR [eax+48]
$LN18@xmlSAX2Att:

; 776  : 	return;
; 777  :     }
; 778  : #ifdef LIBXML_VALID_ENABLED
; 779  :     if (ctxt->vctxt.valid == 0)

	lea	ebx, DWORD PTR [edi+108]
	push	ebx
	call	_xmlAddAttributeDecl
	add	esp, 36					; 00000024H
	mov	ecx, eax
	cmp	DWORD PTR [edi+144], 0
	jne	SHORT $LN15@xmlSAX2Att

; 780  : 	ctxt->valid = 0;

	mov	DWORD PTR [edi+100], 0
$LN15@xmlSAX2Att:

; 781  :     if ((attr != NULL) && (ctxt->validate) && (ctxt->wellFormed) &&

	test	ecx, ecx
	je	SHORT $LN10@xmlSAX2Att
	cmp	DWORD PTR [edi+104], 0
	je	SHORT $LN10@xmlSAX2Att
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN10@xmlSAX2Att
	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN10@xmlSAX2Att

; 782  :         (ctxt->myDoc->intSubset != NULL))
; 783  : 	ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,

	push	ecx
	push	eax
	push	ebx
	call	_xmlValidateAttributeDecl
	add	esp, 12					; 0000000cH
	and	DWORD PTR [edi+100], eax
$LN10@xmlSAX2Att:

; 784  : 	                                        attr);
; 785  : #endif /* LIBXML_VALID_ENABLED */
; 786  :     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlSAX2Att

; 787  : 	xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlSAX2Att:

; 788  :     if (name != NULL)

	test	esi, esi
	je	SHORT $LN16@xmlSAX2Att

; 789  : 	xmlFree(name);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
	pop	ebx
	pop	edi

; 790  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlSAX2Att:

; 769  : 	   name, prefix, (xmlAttributeType) type,
; 770  : 	   (xmlAttributeDefault) def, defaultValue, tree);
; 771  :     else {
; 772  :         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	esi
	push	OFFSET ??_C@_0DJ@CKOJIFJI@SAX?4xmlSAX2AttributeDecl?$CI?$CFs?$CJ?5ca@
	push	1
	push	edi
	call	_xmlFatalErrMsg

; 773  : 	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
; 774  : 	               name, NULL);
; 775  : 	xmlFreeEnumeration(tree);

	push	DWORD PTR _tree$[ebp]
	call	_xmlFreeEnumeration
	add	esp, 24					; 00000018H
$LN16@xmlSAX2Att:
	pop	esi
	pop	ebx
$LN3@xmlSAX2Att:
	pop	edi

; 790  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2AttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2EntityDecl
_TEXT	SEGMENT
_ent$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_publicId$ = 20						; size = 4
_systemId$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlSAX2EntityDecl PROC					; COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN10@xmlSAX2Ent

; 667  :     xmlEntityPtr ent;
; 668  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 669  : 
; 670  :     if (ctx == NULL) return;
; 671  : #ifdef DEBUG_SAX
; 672  :     xmlGenericError(xmlGenericErrorContext,
; 673  : 	    "SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\n",
; 674  :             name, type, publicId, systemId, content);
; 675  : #endif
; 676  :     if (ctxt->inSubset == 1) {

	mov	eax, DWORD PTR [esi+216]
	push	ebx
	push	edi
	cmp	eax, 1
	jne	$LN3@xmlSAX2Ent

; 677  : 	ent = xmlAddDocEntity(ctxt->myDoc, name, type, publicId,

	push	DWORD PTR _content$[ebp]
	mov	ebx, DWORD PTR _systemId$[ebp]
	mov	edi, DWORD PTR _name$[ebp]
	push	ebx
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR _type$[ebp]
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlAddDocEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ent$1$[ebp], eax

; 678  : 		              systemId, content);
; 679  : 	if ((ent == NULL) && (ctxt->pedantic))

	test	eax, eax
	jne	SHORT $LN21@xmlSAX2Ent
	cmp	DWORD PTR [esi+268], eax
	je	$LN24@xmlSAX2Ent

; 172  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], eax
	je	SHORT $LN17@xmlSAX2Ent
	cmp	DWORD PTR [esi+172], -1
	je	$LN24@xmlSAX2Ent
$LN17@xmlSAX2Ent:

; 173  :         (ctxt->instate == XML_PARSER_EOF))
; 174  : 	return;
; 175  :     if (ctxt != NULL)
; 176  : 	ctxt->errNo = error;
; 177  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	push	edi
	push	OFFSET ??_C@_0DD@GCBFDMPE@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@
	push	0
	push	0
	push	0
	push	0
	push	edi
	push	0
	push	0
	push	1
	push	107					; 0000006bH
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+84], 107			; 0000006bH
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi
	pop	ebx
	pop	esi

; 716  : 	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
; 717  : 		       name, NULL);
; 718  :     }
; 719  : }

	pop	ebp
	ret	0
$LN21@xmlSAX2Ent:

; 680  : 	    xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,
; 681  : 	     "Entity(%s) already defined in the internal subset\n",
; 682  : 	               name);
; 683  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {

	cmp	DWORD PTR [eax+64], 0
	jne	$LN24@xmlSAX2Ent
	test	ebx, ebx
	je	$LN24@xmlSAX2Ent

; 684  : 	    xmlChar *URI;
; 685  : 	    const char *base = NULL;
; 686  : 
; 687  : 	    if (ctxt->input != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN22@xmlSAX2Ent

; 688  : 		base = ctxt->input->filename;

	mov	eax, DWORD PTR [eax+4]

; 689  : 	    if (base == NULL)

	test	eax, eax
	jne	SHORT $LN8@xmlSAX2Ent
$LN22@xmlSAX2Ent:

; 690  : 		base = ctxt->directory;

	mov	eax, DWORD PTR [esi+180]
$LN8@xmlSAX2Ent:

; 691  : 
; 692  : 	    URI = xmlBuildURI(systemId, (const xmlChar *) base);

	push	eax
	push	ebx
	call	_xmlBuildURI

; 693  : 	    ent->URI = URI;

	mov	ecx, DWORD PTR _ent$1$[ebp]
	add	esp, 8
	pop	edi
	pop	ebx
	mov	DWORD PTR [ecx+64], eax
	pop	esi

; 716  : 	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
; 717  : 		       name, NULL);
; 718  :     }
; 719  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Ent:

; 694  : 	}
; 695  :     } else if (ctxt->inSubset == 2) {

	cmp	eax, 2
	jne	SHORT $LN9@xmlSAX2Ent

; 696  : 	ent = xmlAddDtdEntity(ctxt->myDoc, name, type, publicId,

	push	DWORD PTR _content$[ebp]
	mov	edi, DWORD PTR _systemId$[ebp]
	push	edi
	push	DWORD PTR _publicId$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlAddDtdEntity
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 697  : 		              systemId, content);
; 698  : 	if ((ent == NULL) && (ctxt->pedantic) &&
; 699  : 	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))

	test	ebx, ebx
	jne	SHORT $LN20@xmlSAX2Ent
	cmp	DWORD PTR [esi+268], eax
	je	SHORT $LN24@xmlSAX2Ent
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN24@xmlSAX2Ent
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	je	SHORT $LN24@xmlSAX2Ent

; 700  : 	    ctxt->sax->warning(ctxt->userData,

	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DD@ECLLADNP@Entity?$CI?$CFs?$CJ?5already?5defined?5in?5t@
	push	DWORD PTR [esi+4]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 716  : 	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
; 717  : 		       name, NULL);
; 718  :     }
; 719  : }

	pop	ebp
	ret	0
$LN20@xmlSAX2Ent:

; 701  : 	     "Entity(%s) already defined in the external subset\n", name);
; 702  : 	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {

	cmp	DWORD PTR [ebx+64], 0
	jne	SHORT $LN24@xmlSAX2Ent
	test	edi, edi
	je	SHORT $LN24@xmlSAX2Ent

; 703  : 	    xmlChar *URI;
; 704  : 	    const char *base = NULL;
; 705  : 
; 706  : 	    if (ctxt->input != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN23@xmlSAX2Ent

; 707  : 		base = ctxt->input->filename;

	mov	eax, DWORD PTR [eax+4]

; 708  : 	    if (base == NULL)

	test	eax, eax
	jne	SHORT $LN14@xmlSAX2Ent
$LN23@xmlSAX2Ent:

; 709  : 		base = ctxt->directory;

	mov	eax, DWORD PTR [esi+180]
$LN14@xmlSAX2Ent:

; 710  : 
; 711  : 	    URI = xmlBuildURI(systemId, (const xmlChar *) base);

	push	eax
	push	edi
	call	_xmlBuildURI
	add	esp, 8

; 712  : 	    ent->URI = URI;

	mov	DWORD PTR [ebx+64], eax
	pop	edi
	pop	ebx
	pop	esi

; 716  : 	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
; 717  : 		       name, NULL);
; 718  :     }
; 719  : }

	pop	ebp
	ret	0
$LN9@xmlSAX2Ent:

; 713  : 	}
; 714  :     } else {
; 715  : 	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,

	push	0
	push	DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0DG@EGJGBEOC@SAX?4xmlSAX2EntityDecl?$CI?$CFs?$CJ?5calle@
	push	104					; 00000068H
	push	esi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
$LN24@xmlSAX2Ent:
	pop	edi
	pop	ebx
$LN10@xmlSAX2Ent:
	pop	esi

; 716  : 	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
; 717  : 		       name, NULL);
; 718  :     }
; 719  : }

	pop	ebp
	ret	0
_xmlSAX2EntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2ResolveEntity
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_publicId$ = 12						; size = 4
_systemId$ = 16						; size = 4
_xmlSAX2ResolveEntity PROC				; COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlSAX2Res

; 521  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 522  :     xmlParserInputPtr ret;
; 523  :     xmlChar *URI;
; 524  :     const char *base = NULL;
; 525  : 
; 526  :     if (ctx == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 544  : }

	pop	ebp
	ret	0
$LN2@xmlSAX2Res:

; 527  :     if (ctxt->input != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN7@xmlSAX2Res

; 528  : 	base = ctxt->input->filename;

	mov	eax, DWORD PTR [eax+4]

; 529  :     if (base == NULL)

	test	eax, eax
	jne	SHORT $LN4@xmlSAX2Res
$LN7@xmlSAX2Res:

; 530  : 	base = ctxt->directory;

	mov	eax, DWORD PTR [esi+180]
$LN4@xmlSAX2Res:
	push	edi

; 531  : 
; 532  :     URI = xmlBuildURI(systemId, (const xmlChar *) base);

	push	eax
	push	DWORD PTR _systemId$[ebp]
	call	_xmlBuildURI

; 533  : 
; 534  : #ifdef DEBUG_SAX
; 535  :     xmlGenericError(xmlGenericErrorContext,
; 536  : 	    "SAX.xmlSAX2ResolveEntity(%s, %s)\n", publicId, systemId);
; 537  : #endif
; 538  : 
; 539  :     ret = xmlLoadExternalEntity((const char *) URI,

	push	esi
	push	DWORD PTR _publicId$[ebp]
	mov	edi, eax
	push	edi
	call	_xmlLoadExternalEntity
	add	esp, 20					; 00000014H
	mov	esi, eax

; 540  : 				(const char *) publicId, ctxt);
; 541  :     if (URI != NULL)

	test	edi, edi
	je	SHORT $LN5@xmlSAX2Res

; 542  : 	xmlFree(URI);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSAX2Res:

; 543  :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 544  : }

	pop	ebp
	ret	0
_xmlSAX2ResolveEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetParameterEntity
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSAX2GetParameterEntity PROC				; COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlSAX2Get

; 648  :     return(ret);
; 649  : }

	pop	ebp
	ret	0
$LN2@xmlSAX2Get:

; 638  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 639  :     xmlEntityPtr ret;
; 640  : 
; 641  :     if (ctx == NULL) return(NULL);
; 642  : #ifdef DEBUG_SAX
; 643  :     xmlGenericError(xmlGenericErrorContext,
; 644  : 	    "SAX.xmlSAX2GetParameterEntity(%s)\n", name);
; 645  : #endif
; 646  : 
; 647  :     ret = xmlGetParameterEntity(ctxt->myDoc, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [eax+8]
	call	_xmlGetParameterEntity
	add	esp, 8

; 648  :     return(ret);
; 649  : }

	pop	ebp
	ret	0
_xmlSAX2GetParameterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetEntity
_TEXT	SEGMENT
_oldnbent$1$ = -4					; size = 4
_children$1 = 8						; size = 4
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSAX2GetEntity PROC					; COMDAT

; 557  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlSAX2Get

; 558  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 559  :     xmlEntityPtr ret = NULL;
; 560  : 
; 561  :     if (ctx == NULL) return(NULL);

	xor	eax, eax
	pop	edi

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSAX2Get:

; 562  : #ifdef DEBUG_SAX
; 563  :     xmlGenericError(xmlGenericErrorContext,
; 564  : 	    "SAX.xmlSAX2GetEntity(%s)\n", name);
; 565  : #endif
; 566  : 
; 567  :     if (ctxt->inSubset == 0) {

	cmp	DWORD PTR [edi+216], 0
	push	ebx
	mov	ebx, DWORD PTR _name$[ebp]
	jne	SHORT $LN20@xmlSAX2Get

; 568  : 	ret = xmlGetPredefinedEntity(name);

	push	ebx
	call	_xmlGetPredefinedEntity
	add	esp, 4

; 569  : 	if (ret != NULL)

	test	eax, eax
	jne	$LN21@xmlSAX2Get
$LN20@xmlSAX2Get:

; 570  : 	    return(ret);
; 571  :     }
; 572  :     if ((ctxt->myDoc != NULL) && (ctxt->myDoc->standalone == 1)) {

	mov	eax, DWORD PTR [edi+8]
	push	esi
	test	eax, eax
	je	SHORT $LN5@xmlSAX2Get
	cmp	DWORD PTR [eax+40], 1
	jne	SHORT $LN5@xmlSAX2Get

; 573  : 	if (ctxt->inSubset == 2) {

	cmp	DWORD PTR [edi+216], 2
	push	ebx
	jne	SHORT $LN7@xmlSAX2Get

; 574  : 	    ctxt->myDoc->standalone = 0;

	mov	DWORD PTR [eax+40], 0

; 575  : 	    ret = xmlGetDocEntity(ctxt->myDoc, name);

	push	DWORD PTR [edi+8]
	call	_xmlGetDocEntity

; 576  : 	    ctxt->myDoc->standalone = 1;

	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+40], 1

; 577  : 	} else {

	jmp	SHORT $LN23@xmlSAX2Get
$LN7@xmlSAX2Get:

; 578  : 	    ret = xmlGetDocEntity(ctxt->myDoc, name);

	push	eax
	call	_xmlGetDocEntity
	mov	esi, eax
	add	esp, 8

; 579  : 	    if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN19@xmlSAX2Get

; 580  : 		ctxt->myDoc->standalone = 0;

	mov	eax, DWORD PTR [edi+8]

; 581  : 		ret = xmlGetDocEntity(ctxt->myDoc, name);

	push	ebx
	mov	DWORD PTR [eax+40], esi
	push	DWORD PTR [edi+8]
	call	_xmlGetDocEntity
	mov	esi, eax
	add	esp, 8

; 582  : 		if (ret != NULL) {

	test	esi, esi
	je	SHORT $LN10@xmlSAX2Get

; 583  : 		    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,

	push	0
	push	ebx
	push	OFFSET ??_C@_0EE@PPDHKGIC@Entity?$CI?$CFs?$CJ?5document?5marked?5stan@
	push	103					; 00000067H
	push	edi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H
$LN10@xmlSAX2Get:

; 584  : 	 "Entity(%s) document marked standalone but requires external subset\n",
; 585  : 				   name, NULL);
; 586  : 		}
; 587  : 		ctxt->myDoc->standalone = 1;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+40], 1

; 588  : 	    }
; 589  : 	}
; 590  :     } else {

	jmp	SHORT $LN6@xmlSAX2Get
$LN5@xmlSAX2Get:

; 591  : 	ret = xmlGetDocEntity(ctxt->myDoc, name);

	push	ebx
	push	eax
	call	_xmlGetDocEntity
$LN23@xmlSAX2Get:

; 592  :     }
; 593  :     if ((ret != NULL) &&
; 594  : 	((ctxt->validate) || (ctxt->replaceEntities)) &&
; 595  : 	(ret->children == NULL) &&

	mov	esi, eax
	add	esp, 8
$LN6@xmlSAX2Get:
	test	esi, esi
	je	SHORT $LN16@xmlSAX2Get
$LN19@xmlSAX2Get:
	cmp	DWORD PTR [edi+104], 0
	jne	SHORT $LN12@xmlSAX2Get
	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN16@xmlSAX2Get
$LN12@xmlSAX2Get:
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN16@xmlSAX2Get
	cmp	DWORD PTR [esi+48], 2
	jne	SHORT $LN16@xmlSAX2Get

; 596  : 	(ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
; 597  : 	int val;
; 598  : 
; 599  : 	/*
; 600  : 	 * for validation purposes we really need to fetch and
; 601  : 	 * parse the external entity
; 602  : 	 */
; 603  : 	xmlNodePtr children;
; 604  : 	unsigned long oldnbent = ctxt->nbentities;

	mov	eax, DWORD PTR [edi+440]
	mov	DWORD PTR _oldnbent$1$[ebp], eax

; 605  : 
; 606  :         val = xmlParseCtxtExternalEntity(ctxt, ret->URI,

	lea	eax, DWORD PTR _children$1[ebp]
	push	eax
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+64]
	push	edi
	call	_xmlParseCtxtExternalEntity
	add	esp, 16					; 00000010H

; 607  : 		                         ret->ExternalID, &children);
; 608  : 	if (val == 0) {

	test	eax, eax
	jne	SHORT $LN13@xmlSAX2Get

; 609  : 	    xmlAddChildList((xmlNodePtr) ret, children);

	push	DWORD PTR _children$1[ebp]
	push	esi
	call	_xmlAddChildList
	add	esp, 8

; 615  : 	}
; 616  : 	ret->owner = 1;

	mov	DWORD PTR [esi+68], 1

; 617  : 	if (ret->checked == 0) {

	cmp	DWORD PTR [esi+72], 0
	jne	SHORT $LN16@xmlSAX2Get

; 618  : 	    ret->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	eax, DWORD PTR [edi+440]
	sub	eax, DWORD PTR _oldnbent$1$[ebp]
	lea	eax, DWORD PTR [eax*2+2]
	mov	DWORD PTR [esi+72], eax

; 619  : 	    if ((ret->content != NULL) && (xmlStrchr(ret->content, '<')))

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN16@xmlSAX2Get
	push	60					; 0000003cH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlSAX2Get

; 620  : 	        ret->checked |= 1;

	or	DWORD PTR [esi+72], 1
$LN16@xmlSAX2Get:

; 621  : 	}
; 622  :     }
; 623  :     return(ret);

	mov	eax, esi
	pop	esi
$LN21@xmlSAX2Get:
	pop	ebx
	pop	edi

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlSAX2Get:

; 610  : 	} else {
; 611  : 	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,

	push	0
	push	ebx
	push	OFFSET ??_C@_0BO@LDENBHGA@Failure?5to?5process?5entity?5?$CFs?6@
	push	104					; 00000068H
	push	edi
	call	_xmlFatalErrMsg
	add	esp, 20					; 00000014H

; 612  : 		           "Failure to process entity %s\n", name, NULL);
; 613  : 	    ctxt->validate = 0;

	mov	DWORD PTR [edi+104], 0

; 614  : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2GetEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2ExternalSubset
_TEXT	SEGMENT
_oldencoding$1$ = -20					; size = 4
_oldcharset$1$ = -16					; size = 4
_oldinputTab$1$ = -12					; size = 4
_oldinputMax$1$ = -8					; size = 4
_oldinputNr$1$ = -4					; size = 4
_oldinput$1$ = 8					; size = 4
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_xmlSAX2ExternalSubset PROC				; COMDAT

; 394  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __A8525CDE_sax2@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN5@xmlSAX2Ext

; 395  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 396  :     if (ctx == NULL) return;
; 397  : #ifdef DEBUG_SAX
; 398  :     xmlGenericError(xmlGenericErrorContext,
; 399  : 	    "SAX.xmlSAX2ExternalSubset(%s, %s, %s)\n",
; 400  :             name, ExternalID, SystemID);
; 401  : #endif
; 402  :     if (((ExternalID != NULL) || (SystemID != NULL)) &&

	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _SystemID$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@xmlSAX2Ext
	test	ebx, ebx
	je	$LN20@xmlSAX2Ext
$LN6@xmlSAX2Ext:
	cmp	DWORD PTR [esi+104], 0
	jne	SHORT $LN7@xmlSAX2Ext
	cmp	DWORD PTR [esi+276], 0
	je	$LN20@xmlSAX2Ext
$LN7@xmlSAX2Ext:
	cmp	DWORD PTR [esi+12], 0
	je	$LN20@xmlSAX2Ext
	cmp	DWORD PTR [esi+8], 0
	je	$LN20@xmlSAX2Ext

; 403  :         (((ctxt->validate) || (ctxt->loadsubset != 0)) &&
; 404  : 	 (ctxt->wellFormed && ctxt->myDoc))) {
; 405  : 	/*
; 406  : 	 * Try to fetch and parse the external subset.
; 407  : 	 */
; 408  : 	xmlParserInputPtr oldinput;
; 409  : 	int oldinputNr;
; 410  : 	int oldinputMax;
; 411  : 	xmlParserInputPtr *oldinputTab;
; 412  : 	xmlParserInputPtr input = NULL;
; 413  : 	xmlCharEncoding enc;
; 414  : 	int oldcharset;
; 415  : 	const xmlChar *oldencoding;
; 416  : 
; 417  : 	/*
; 418  : 	 * Ask the Entity resolver to load the damn thing
; 419  : 	 */
; 420  : 	if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN20@xmlSAX2Ext
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	$LN20@xmlSAX2Ext

; 421  : 	    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,

	push	edi
	push	ebx
	push	ecx
	push	DWORD PTR [esi+4]
	call	eax
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 422  : 	                                        SystemID);
; 423  : 	if (input == NULL) {

	test	edi, edi
	je	$LN21@xmlSAX2Ext

; 424  : 	    return;
; 425  : 	}
; 426  : 
; 427  : 	xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);

	push	ebx
	push	DWORD PTR _ExternalID$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlNewDtd

; 428  : 
; 429  : 	/*
; 430  : 	 * make sure we won't destroy the main document context
; 431  : 	 */
; 432  : 	oldinput = ctxt->input;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _oldinput$1$[ebp], eax

; 433  : 	oldinputNr = ctxt->inputNr;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _oldinputNr$1$[ebp], eax

; 434  : 	oldinputMax = ctxt->inputMax;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR _oldinputMax$1$[ebp], eax

; 435  : 	oldinputTab = ctxt->inputTab;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _oldinputTab$1$[ebp], eax

; 436  : 	oldcharset = ctxt->charset;

	mov	eax, DWORD PTR [esi+256]
	mov	DWORD PTR _oldcharset$1$[ebp], eax

; 437  : 	oldencoding = ctxt->encoding;

	mov	eax, DWORD PTR [esi+24]

; 438  : 	ctxt->encoding = NULL;
; 439  : 
; 440  : 	ctxt->inputTab = (xmlParserInputPtr *)

	push	20					; 00000014H
	mov	DWORD PTR _oldencoding$1$[ebp], eax
	mov	DWORD PTR [esi+24], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+48], eax

; 441  : 	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
; 442  : 	if (ctxt->inputTab == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlSAX2Ext

; 443  : 	    xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset");

	push	OFFSET ??_C@_0BG@NJCKJHBI@xmlSAX2ExternalSubset@
	push	esi
	call	_xmlSAX2ErrMemory

; 444  : 	    ctxt->input = oldinput;

	mov	eax, DWORD PTR _oldinput$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [esi+36], eax

; 445  : 	    ctxt->inputNr = oldinputNr;

	mov	eax, DWORD PTR _oldinputNr$1$[ebp]
	mov	DWORD PTR [esi+40], eax

; 446  : 	    ctxt->inputMax = oldinputMax;

	mov	eax, DWORD PTR _oldinputMax$1$[ebp]
	mov	DWORD PTR [esi+44], eax

; 447  : 	    ctxt->inputTab = oldinputTab;

	mov	eax, DWORD PTR _oldinputTab$1$[ebp]
	mov	DWORD PTR [esi+48], eax

; 448  : 	    ctxt->charset = oldcharset;

	mov	eax, DWORD PTR _oldcharset$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi+256], eax

; 499  : 	ctxt->encoding = oldencoding;

	mov	eax, DWORD PTR _oldencoding$1$[ebp]
	pop	ebx
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 500  : 	/* ctxt->wellFormed = oldwellFormed; */
; 501  :     }
; 502  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSAX2Ext:

; 449  : 	    ctxt->encoding = oldencoding;
; 450  : 	    return;
; 451  : 	}
; 452  : 	ctxt->inputNr = 0;
; 453  : 	ctxt->inputMax = 5;
; 454  : 	ctxt->input = NULL;
; 455  : 	xmlPushInput(ctxt, input);

	push	edi
	push	esi
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 5
	mov	DWORD PTR [esi+36], 0
	call	_xmlPushInput

; 456  : 
; 457  : 	/*
; 458  : 	 * On the fly encoding conversion if needed
; 459  : 	 */
; 460  : 	if (ctxt->input->length >= 4) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	cmp	DWORD PTR [eax+24], 4
	jl	SHORT $LN11@xmlSAX2Ext

; 461  : 	    enc = xmlDetectCharEncoding(ctxt->input->cur, 4);

	push	4
	push	DWORD PTR [eax+16]
	call	_xmlDetectCharEncoding

; 462  : 	    xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	esi
	call	_xmlSwitchEncoding
	add	esp, 16					; 00000010H
$LN11@xmlSAX2Ext:

; 463  : 	}
; 464  : 
; 465  : 	if (input->filename == NULL)

	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN12@xmlSAX2Ext

; 466  : 	    input->filename = (char *) xmlCanonicPath(SystemID);

	push	ebx
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR [edi+4], eax
$LN12@xmlSAX2Ext:

; 467  : 	input->line = 1;

	mov	DWORD PTR [edi+28], 1

; 468  : 	input->col = 1;

	mov	DWORD PTR [edi+32], 1

; 469  : 	input->base = ctxt->input->cur;

	mov	eax, DWORD PTR [esi+36]

; 470  : 	input->cur = ctxt->input->cur;
; 471  : 	input->free = NULL;
; 472  : 
; 473  : 	/*
; 474  : 	 * let's parse that entity knowing it's an external subset.
; 475  : 	 */
; 476  : 	xmlParseExternalSubset(ctxt, ExternalID, SystemID);

	push	ebx
	push	DWORD PTR _ExternalID$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+36]
	push	esi
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+40], 0
	call	_xmlParseExternalSubset
	add	esp, 12					; 0000000cH

; 477  : 
; 478  :         /*
; 479  : 	 * Free up the external entities
; 480  : 	 */
; 481  : 
; 482  : 	while (ctxt->inputNr > 1)

	cmp	DWORD PTR [esi+40], 1
	jle	SHORT $LN3@xmlSAX2Ext
$LL2@xmlSAX2Ext:

; 483  : 	    xmlPopInput(ctxt);

	push	esi
	call	_xmlPopInput
	add	esp, 4
	cmp	DWORD PTR [esi+40], 1
	jg	SHORT $LL2@xmlSAX2Ext
$LN3@xmlSAX2Ext:

; 484  : 	xmlFreeInputStream(ctxt->input);

	push	DWORD PTR [esi+36]
	call	_xmlFreeInputStream

; 485  :         xmlFree(ctxt->inputTab);

	push	DWORD PTR [esi+48]
	call	DWORD PTR _xmlFree

; 486  : 
; 487  : 	/*
; 488  : 	 * Restore the parsing context of the main entity
; 489  : 	 */
; 490  : 	ctxt->input = oldinput;

	mov	eax, DWORD PTR _oldinput$1$[ebp]
	add	esp, 8

; 491  : 	ctxt->inputNr = oldinputNr;
; 492  : 	ctxt->inputMax = oldinputMax;
; 493  : 	ctxt->inputTab = oldinputTab;
; 494  : 	ctxt->charset = oldcharset;
; 495  : 	if ((ctxt->encoding != NULL) &&

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR _oldinputNr$1$[ebp]
	mov	DWORD PTR [esi+40], eax
	mov	eax, DWORD PTR _oldinputMax$1$[ebp]
	mov	DWORD PTR [esi+44], eax
	mov	eax, DWORD PTR _oldinputTab$1$[ebp]
	mov	DWORD PTR [esi+48], eax
	mov	eax, DWORD PTR _oldcharset$1$[ebp]
	mov	DWORD PTR [esi+256], eax
	test	ecx, ecx
	je	SHORT $LN13@xmlSAX2Ext
	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN14@xmlSAX2Ext
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlSAX2Ext
$LN14@xmlSAX2Ext:

; 496  : 	    ((ctxt->dict == NULL) ||
; 497  : 	     (!xmlDictOwns(ctxt->dict, ctxt->encoding))))
; 498  : 	    xmlFree((xmlChar *) ctxt->encoding);

	push	DWORD PTR [esi+24]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlSAX2Ext:

; 499  : 	ctxt->encoding = oldencoding;

	mov	eax, DWORD PTR _oldencoding$1$[ebp]
	mov	DWORD PTR [esi+24], eax
$LN21@xmlSAX2Ext:
	pop	edi
$LN20@xmlSAX2Ext:
	pop	ebx
$LN5@xmlSAX2Ext:
	pop	esi

; 500  : 	/* ctxt->wellFormed = oldwellFormed; */
; 501  :     }
; 502  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAX2ExternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2InternalSubset
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_xmlSAX2InternalSubset PROC				; COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlSAX2Int

; 357  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 358  :     xmlDtdPtr dtd;
; 359  :     if (ctx == NULL) return;
; 360  : #ifdef DEBUG_SAX
; 361  :     xmlGenericError(xmlGenericErrorContext,
; 362  : 	    "SAX.xmlSAX2InternalSubset(%s, %s, %s)\n",
; 363  :             name, ExternalID, SystemID);
; 364  : #endif
; 365  : 
; 366  :     if (ctxt->myDoc == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@xmlSAX2Int

; 367  : 	return;
; 368  :     dtd = xmlGetIntSubset(ctxt->myDoc);

	push	edi
	push	eax
	call	_xmlGetIntSubset
	mov	edi, eax
	add	esp, 4

; 369  :     if (dtd != NULL) {

	test	edi, edi
	je	SHORT $LN4@xmlSAX2Int

; 370  : 	if (ctxt->html)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN8@xmlSAX2Int

; 371  : 	    return;
; 372  : 	xmlUnlinkNode((xmlNodePtr) dtd);

	push	edi
	call	_xmlUnlinkNode

; 373  : 	xmlFreeDtd(dtd);

	push	edi
	call	_xmlFreeDtd

; 374  : 	ctxt->myDoc->intSubset = NULL;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	DWORD PTR [eax+44], 0
$LN4@xmlSAX2Int:

; 375  :     }
; 376  :     ctxt->myDoc->intSubset =

	push	DWORD PTR _SystemID$[ebp]
	push	DWORD PTR _ExternalID$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+8]
	call	_xmlCreateIntSubset
	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+44], eax

; 377  : 	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
; 378  :     if (ctxt->myDoc->intSubset == NULL)

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN8@xmlSAX2Int

; 379  :         xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");

	push	OFFSET ??_C@_0BG@CKPEJCG@xmlSAX2InternalSubset@
	push	esi
	call	_xmlSAX2ErrMemory
	add	esp, 8
$LN8@xmlSAX2Int:
	pop	edi
$LN6@xmlSAX2Int:
	pop	esi

; 380  : }

	pop	ebp
	ret	0
_xmlSAX2InternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2HasExternalSubset
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2HasExternalSubset PROC				; COMDAT

; 338  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Has

; 339  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 340  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL)) return(0);

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlSAX2Has

; 341  :     return(ctxt->myDoc->extSubset != NULL);

	xor	eax, eax
	cmp	DWORD PTR [ecx+48], eax
	setne	al

; 342  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Has:

; 339  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 340  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL)) return(0);

	xor	eax, eax

; 342  : }

	pop	ebp
	ret	0
_xmlSAX2HasExternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2HasInternalSubset
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2HasInternalSubset PROC				; COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Has

; 323  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 324  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL)) return(0);

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlSAX2Has

; 325  :     return(ctxt->myDoc->intSubset != NULL);

	xor	eax, eax
	cmp	DWORD PTR [ecx+44], eax
	setne	al

; 326  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Has:

; 323  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 324  :     if ((ctxt == NULL) || (ctxt->myDoc == NULL)) return(0);

	xor	eax, eax

; 326  : }

	pop	ebp
	ret	0
_xmlSAX2HasInternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2IsStandalone
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2IsStandalone PROC				; COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2IsS

; 307  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 308  :     if ((ctx == NULL) || (ctxt->myDoc == NULL)) return(0);

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlSAX2IsS

; 309  :     return(ctxt->myDoc->standalone == 1);

	xor	eax, eax
	cmp	DWORD PTR [ecx+40], 1
	sete	al

; 310  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2IsS:

; 307  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 308  :     if ((ctx == NULL) || (ctxt->myDoc == NULL)) return(0);

	xor	eax, eax

; 310  : }

	pop	ebp
	ret	0
_xmlSAX2IsStandalone ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetColumnNumber
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2GetColumnNumber PROC				; COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 291  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 292  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(0);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 293  :     return(ctxt->input->col);

	mov	eax, DWORD PTR [eax+32]

; 294  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Get:

; 291  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 292  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(0);

	xor	eax, eax

; 294  : }

	pop	ebp
	ret	0
_xmlSAX2GetColumnNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetLineNumber
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2GetLineNumber PROC				; COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 275  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 276  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(0);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 277  :     return(ctxt->input->line);

	mov	eax, DWORD PTR [eax+28]

; 278  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Get:

; 275  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 276  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(0);

	xor	eax, eax

; 278  : }

	pop	ebp
	ret	0
_xmlSAX2GetLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2SetDocumentLocator
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_loc$ = 12						; size = 4
_xmlSAX2SetDocumentLocator PROC				; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlSAX2SetDocumentLocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetSystemId
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2GetSystemId PROC				; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 259  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 260  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(NULL);

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN3@xmlSAX2Get

; 261  :     return((const xmlChar *) ctxt->input->filename);

	mov	eax, DWORD PTR [eax+4]

; 262  : }

	pop	ebp
	ret	0
$LN3@xmlSAX2Get:

; 259  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 260  :     if ((ctx == NULL) || (ctxt->input == NULL)) return(NULL);

	xor	eax, eax

; 262  : }

	pop	ebp
	ret	0
_xmlSAX2GetSystemId ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\sax2.c
;	COMDAT _xmlSAX2GetPublicId
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlSAX2GetPublicId PROC				; COMDAT
	mov	ecx, OFFSET __A8525CDE_sax2@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	ret	0
_xmlSAX2GetPublicId ENDP
_TEXT	ENDS
END
