; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\c14n.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__27F3A1DF_c14n@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlC14NDocSaveTo
PUBLIC	_xmlC14NDocDumpMemory
PUBLIC	_xmlC14NDocSave
PUBLIC	_xmlC14NExecute
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@KAEIDNN@Internal?5error?5?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BO@DIKCFALP@Node?5?$CFs?5is?5invalid?5here?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CB@LPHDJOLE@Unknown?5node?5type?5?$CFd?5found?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BK@MOKDAME@creating?5namespaces?5stack@	; `string'
PUBLIC	??_C@_0BM@PPKFPLDI@destroying?5namespaces?5stack@ ; `string'
PUBLIC	??_C@_0BK@NHMKFMOM@adding?5namespace?5to?5stack@ ; `string'
PUBLIC	??_C@_0BF@EOOBKFEO@adding?5node?5to?5stack@	; `string'
PUBLIC	??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@	; `string'
PUBLIC	??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@ ; `string'
PUBLIC	??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@	; `string'
PUBLIC	??_C@_0CC@HHELCFAC@searching?5namespaces?5stack?5?$CIc14@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0CG@DGFPKBDK@searching?5namespaces?5stack?5?$CIexc@ ; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_0BD@MCMJLIHF@writing?5namespaces@		; `string'
PUBLIC	??_C@_07PMGDNCAE@?5xmlns?3@			; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_07LDCCEEMD@?5xmlns?$DN@			; `string'
PUBLIC	??_C@_02JMMFPCED@?$CC?$CC@			; `string'
PUBLIC	??_C@_0CC@LGNLNPPM@processing?5namespaces?5axis?5?$CIc14@ ; `string'
PUBLIC	??_C@_0CA@IIFGGKIF@creating?5namespaces?5list?5?$CIc14n?$CJ@ ; `string'
PUBLIC	??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@ ; `string'
PUBLIC	??_C@_0CE@OPHJGGNE@creating?5namespaces?5list?5?$CIexc?5c@ ; `string'
PUBLIC	??_C@_08DCFPEJG@?$CDdefault@			; `string'
PUBLIC	??_C@_0BD@DDLFPEHD@writing?5attributes@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC@			; `string'
PUBLIC	??_C@_0BM@MNCHFEBF@normalizing?5attributes?5axis@ ; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_0BO@CEOJEMPO@processing?5xml?3base?5attribute@ ; `string'
PUBLIC	??_C@_0DF@JNOKNNOH@processing?5xml?3base?5attribute?5?9@ ; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0DB@PAHKMMOF@processing?5xml?3base?5attribute?5?9@ ; `string'
PUBLIC	??_C@_0DE@JBJEENHA@processing?5xml?3base?5attribute?5?9@ ; `string'
PUBLIC	??_C@_0DK@HPDOPNJC@processing?5xml?3base?5attribute?5?9@ ; `string'
PUBLIC	??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@ ; `string'
PUBLIC	??_C@_0BJ@NCGHGLGP@creating?5attributes?5list@	; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_05OLNILLAB@space@				; `string'
PUBLIC	??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@ ; `string'
PUBLIC	??_C@_0BG@JBCPGIOB@parsing?5namespace?5uri@	; `string'
PUBLIC	??_C@_0BI@JAMIDBLC@processing?5element?5node@	; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_0BL@BCEIHHDE@processing?5namespaces?5axis@ ; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_0BK@FJJBBBML@processing?5childrens?5list@	; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1@			; `string'
PUBLIC	??_C@_0BA@KPMINAPM@processing?5node@		; `string'
PUBLIC	??_C@_0BG@FEJMMCLE@normalizing?5text?5node@	; `string'
PUBLIC	??_C@_03MEKJPGEP@?6?$DM?$DP@			; `string'
PUBLIC	??_C@_02HFBBBACF@?$DM?$DP@			; `string'
PUBLIC	??_C@_0BE@NALCHLAN@normalizing?5pi?5node@	; `string'
PUBLIC	??_C@_03KCOJOIAE@?$DP?$DO?6@			; `string'
PUBLIC	??_C@_02GOEMJPDN@?$DP?$DO@			; `string'
PUBLIC	??_C@_05IDEGGPLK@?6?$DM?$CB?9?9@		; `string'
PUBLIC	??_C@_04FFDNBKGC@?$DM?$CB?9?9@			; `string'
PUBLIC	??_C@_0BJ@MDKPFKCP@normalizing?5comment?5node@	; `string'
PUBLIC	??_C@_04IGMOLEKE@?9?9?$DO?6@			; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0BD@KCCEFDB@XML_ATTRIBUTE_NODE@		; `string'
PUBLIC	??_C@_0BD@OOHJMPDA@XML_NAMESPACE_DECL@		; `string'
PUBLIC	??_C@_0BE@NCHPKEOD@XML_ENTITY_REF_NODE@		; `string'
PUBLIC	??_C@_0BA@HBKNNEGK@XML_ENTITY_NODE@		; `string'
PUBLIC	??_C@_0BF@BNBHCOBD@processing?5node?5list@	; `string'
PUBLIC	??_C@_0BA@MKAAPEKK@freeing?5context@		; `string'
PUBLIC	??_C@_0BF@IOABGFCG@creating?5new?5context@	; `string'
PUBLIC	??_C@_0EM@ECCNBEBO@xmlC14NNewCtx?3?5output?5buffer?5en@ ; `string'
PUBLIC	??_C@_0BB@FCGDFAMA@creating?5context@		; `string'
PUBLIC	??_C@_0DD@MDGGAHKJ@xmlC14NNewCtx?3?5xmlC14NVisibleNs@ ; `string'
PUBLIC	??_C@_0P@IOGBMNPC@executing?5c14n@		; `string'
PUBLIC	??_C@_0CA@INCMFAFG@invalid?5mode?5for?5executing?5c14n@ ; `string'
PUBLIC	??_C@_0EN@NONIGHAH@xmlC14NExecute?3?5output?5buffer?5e@ ; `string'
PUBLIC	??_C@_0CP@LLPDGIDM@xmlC14NExecute?3?5unable?5to?5creat@ ; `string'
PUBLIC	??_C@_0BO@LANGFLMG@processing?5docs?5children?5list@ ; `string'
PUBLIC	??_C@_0BH@PKBMLLNP@flushing?5output?5buffer@	; `string'
PUBLIC	??_C@_0BG@JFDMFMGH@dumping?5doc?5to?5memory@	; `string'
PUBLIC	??_C@_0BH@JBBBCCHB@creating?5output?5buffer@	; `string'
PUBLIC	??_C@_0BM@DBHHIABI@saving?5doc?5to?5output?5buffer@ ; `string'
PUBLIC	??_C@_0BO@FJFGKMEA@coping?5canonicanized?5document@ ; `string'
PUBLIC	??_C@_0L@DHCGOHBD@saving?5doc@			; `string'
PUBLIC	??_C@_0BM@LBLOCGLL@creating?5temporary?5filename@ ; `string'
PUBLIC	??_C@_0BP@ODPNHIDP@cannicanize?5document?5to?5buffer@ ; `string'
PUBLIC	??_C@_0BC@MDOPFBLJ@allocating?5buffer@		; `string'
PUBLIC	??_C@_0P@LKGMENGP@growing?5buffer@		; `string'
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlNewNsProp:PROC
EXTRN	_xmlFreePropList:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlHasNsProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	_xmlGetCompressMode:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlListCreate:PROC
EXTRN	_xmlListDelete:PROC
EXTRN	_xmlListSearch:PROC
EXTRN	_xmlListInsert:PROC
EXTRN	_xmlListWalk:PROC
EXTRN	_xmlAllocOutputBuffer:PROC
EXTRN	_xmlOutputBufferCreateFilename:PROC
EXTRN	_xmlOutputBufferWriteString:PROC
EXTRN	_xmlOutputBufferFlush:PROC
EXTRN	_xmlOutputBufferClose:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlXPathNodeSetContains:PROC
EXTRN	_xmlBufWriteQuotedString:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
?ns_default@?N@??xmlC14NProcessNamespacesAxis@@9@9 DB 018H DUP (?) ; `xmlC14NProcessNamespacesAxis'::`13'::ns_default
?ns_default@?BL@??xmlExcC14NProcessNamespacesAxis@@9@9 DB 018H DUP (?) ; `xmlExcC14NProcessNamespacesAxis'::`27'::ns_default
?ns_default@?BN@??xmlExcC14NProcessNamespacesAxis@@9@9 DB 018H DUP (?) ; `xmlExcC14NProcessNamespacesAxis'::`29'::ns_default
_BSS	ENDS
;	COMDAT ??_C@_0P@LKGMENGP@growing?5buffer@
CONST	SEGMENT
??_C@_0P@LKGMENGP@growing?5buffer@ DB 'growing buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
CONST	SEGMENT
??_C@_0BC@MDOPFBLJ@allocating?5buffer@ DB 'allocating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODPNHIDP@cannicanize?5document?5to?5buffer@
CONST	SEGMENT
??_C@_0BP@ODPNHIDP@cannicanize?5document?5to?5buffer@ DB 'cannicanize doc'
	DB	'ument to buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LBLOCGLL@creating?5temporary?5filename@
CONST	SEGMENT
??_C@_0BM@LBLOCGLL@creating?5temporary?5filename@ DB 'creating temporary '
	DB	'filename', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHCGOHBD@saving?5doc@
CONST	SEGMENT
??_C@_0L@DHCGOHBD@saving?5doc@ DB 'saving doc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FJFGKMEA@coping?5canonicanized?5document@
CONST	SEGMENT
??_C@_0BO@FJFGKMEA@coping?5canonicanized?5document@ DB 'coping canonicani'
	DB	'zed document', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DBHHIABI@saving?5doc?5to?5output?5buffer@
CONST	SEGMENT
??_C@_0BM@DBHHIABI@saving?5doc?5to?5output?5buffer@ DB 'saving doc to out'
	DB	'put buffer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
CONST	SEGMENT
??_C@_0BH@JBBBCCHB@creating?5output?5buffer@ DB 'creating output buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JFDMFMGH@dumping?5doc?5to?5memory@
CONST	SEGMENT
??_C@_0BG@JFDMFMGH@dumping?5doc?5to?5memory@ DB 'dumping doc to memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PKBMLLNP@flushing?5output?5buffer@
CONST	SEGMENT
??_C@_0BH@PKBMLLNP@flushing?5output?5buffer@ DB 'flushing output buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LANGFLMG@processing?5docs?5children?5list@
CONST	SEGMENT
??_C@_0BO@LANGFLMG@processing?5docs?5children?5list@ DB 'processing docs '
	DB	'children list', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LLPDGIDM@xmlC14NExecute?3?5unable?5to?5creat@
CONST	SEGMENT
??_C@_0CP@LLPDGIDM@xmlC14NExecute?3?5unable?5to?5creat@ DB 'xmlC14NExecut'
	DB	'e: unable to create C14N context', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@NONIGHAH@xmlC14NExecute?3?5output?5buffer?5e@
CONST	SEGMENT
??_C@_0EN@NONIGHAH@xmlC14NExecute?3?5output?5buffer?5e@ DB 'xmlC14NExecut'
	DB	'e: output buffer encoder != NULL but C14N requires UTF8 outpu'
	DB	't', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@INCMFAFG@invalid?5mode?5for?5executing?5c14n@
CONST	SEGMENT
??_C@_0CA@INCMFAFG@invalid?5mode?5for?5executing?5c14n@ DB 'invalid mode '
	DB	'for executing c14n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOGBMNPC@executing?5c14n@
CONST	SEGMENT
??_C@_0P@IOGBMNPC@executing?5c14n@ DB 'executing c14n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MDGGAHKJ@xmlC14NNewCtx?3?5xmlC14NVisibleNs@
CONST	SEGMENT
??_C@_0DD@MDGGAHKJ@xmlC14NNewCtx?3?5xmlC14NVisibleNs@ DB 'xmlC14NNewCtx: '
	DB	'xmlC14NVisibleNsStackCreate failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCGDFAMA@creating?5context@
CONST	SEGMENT
??_C@_0BB@FCGDFAMA@creating?5context@ DB 'creating context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@ECCNBEBO@xmlC14NNewCtx?3?5output?5buffer?5en@
CONST	SEGMENT
??_C@_0EM@ECCNBEBO@xmlC14NNewCtx?3?5output?5buffer?5en@ DB 'xmlC14NNewCtx'
	DB	': output buffer encoder != NULL but C14N requires UTF8 output'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOABGFCG@creating?5new?5context@
CONST	SEGMENT
??_C@_0BF@IOABGFCG@creating?5new?5context@ DB 'creating new context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKAAPEKK@freeing?5context@
CONST	SEGMENT
??_C@_0BA@MKAAPEKK@freeing?5context@ DB 'freeing context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BNBHCOBD@processing?5node?5list@
CONST	SEGMENT
??_C@_0BF@BNBHCOBD@processing?5node?5list@ DB 'processing node list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBKNNEGK@XML_ENTITY_NODE@
CONST	SEGMENT
??_C@_0BA@HBKNNEGK@XML_ENTITY_NODE@ DB 'XML_ENTITY_NODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NCHPKEOD@XML_ENTITY_REF_NODE@
CONST	SEGMENT
??_C@_0BE@NCHPKEOD@XML_ENTITY_REF_NODE@ DB 'XML_ENTITY_REF_NODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OOHJMPDA@XML_NAMESPACE_DECL@
CONST	SEGMENT
??_C@_0BD@OOHJMPDA@XML_NAMESPACE_DECL@ DB 'XML_NAMESPACE_DECL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCCEFDB@XML_ATTRIBUTE_NODE@
CONST	SEGMENT
??_C@_0BD@KCCEFDB@XML_ATTRIBUTE_NODE@ DB 'XML_ATTRIBUTE_NODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IGMOLEKE@?9?9?$DO?6@
CONST	SEGMENT
??_C@_04IGMOLEKE@?9?9?$DO?6@ DB '-->', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MDKPFKCP@normalizing?5comment?5node@
CONST	SEGMENT
??_C@_0BJ@MDKPFKCP@normalizing?5comment?5node@ DB 'normalizing comment no'
	DB	'de', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_04FFDNBKGC@?$DM?$CB?9?9@ DB '<!--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IDEGGPLK@?6?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_05IDEGGPLK@?6?$DM?$CB?9?9@ DB 0aH, '<!--', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GOEMJPDN@?$DP?$DO@
CONST	SEGMENT
??_C@_02GOEMJPDN@?$DP?$DO@ DB '?>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCOJOIAE@?$DP?$DO?6@
CONST	SEGMENT
??_C@_03KCOJOIAE@?$DP?$DO?6@ DB '?>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NALCHLAN@normalizing?5pi?5node@
CONST	SEGMENT
??_C@_0BE@NALCHLAN@normalizing?5pi?5node@ DB 'normalizing pi node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02HFBBBACF@?$DM?$DP@
CONST	SEGMENT
??_C@_02HFBBBACF@?$DM?$DP@ DB '<?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEKJPGEP@?6?$DM?$DP@
CONST	SEGMENT
??_C@_03MEKJPGEP@?6?$DM?$DP@ DB 0aH, '<?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FEJMMCLE@normalizing?5text?5node@
CONST	SEGMENT
??_C@_0BG@FEJMMCLE@normalizing?5text?5node@ DB 'normalizing text node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPMINAPM@processing?5node@
CONST	SEGMENT
??_C@_0BA@KPMINAPM@processing?5node@ DB 'processing node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1@ DB '</', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FJJBBBML@processing?5childrens?5list@
CONST	SEGMENT
??_C@_0BK@FJJBBBML@processing?5childrens?5list@ DB 'processing childrens '
	DB	'list', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BCEIHHDE@processing?5namespaces?5axis@
CONST	SEGMENT
??_C@_0BL@BCEIHHDE@processing?5namespaces?5axis@ DB 'processing namespace'
	DB	's axis', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JAMIDBLC@processing?5element?5node@
CONST	SEGMENT
??_C@_0BI@JAMIDBLC@processing?5element?5node@ DB 'processing element node'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JBCPGIOB@parsing?5namespace?5uri@
CONST	SEGMENT
??_C@_0BG@JBCPGIOB@parsing?5namespace?5uri@ DB 'parsing namespace uri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@
CONST	SEGMENT
??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@ DB 'checking for r'
	DB	'elative namespaces', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLNILLAB@space@
CONST	SEGMENT
??_C@_05OLNILLAB@space@ DB 'space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NCGHGLGP@creating?5attributes?5list@
CONST	SEGMENT
??_C@_0BJ@NCGHGLGP@creating?5attributes?5list@ DB 'creating attributes li'
	DB	'st', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@
CONST	SEGMENT
??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@ DB 'processing attribute'
	DB	's axis', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HPDOPNJC@processing?5xml?3base?5attribute?5?9@
CONST	SEGMENT
??_C@_0DK@HPDOPNJC@processing?5xml?3base?5attribute?5?9@ DB 'processing x'
	DB	'ml:base attribute - can''t construct attribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JBJEENHA@processing?5xml?3base?5attribute?5?9@
CONST	SEGMENT
??_C@_0DE@JBJEENHA@processing?5xml?3base?5attribute?5?9@ DB 'processing x'
	DB	'ml:base attribute - can''t construct uri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PAHKMMOF@processing?5xml?3base?5attribute?5?9@
CONST	SEGMENT
??_C@_0DB@PAHKMMOF@processing?5xml?3base?5attribute?5?9@ DB 'processing x'
	DB	'ml:base attribute - can''t modify uri', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JNOKNNOH@processing?5xml?3base?5attribute?5?9@
CONST	SEGMENT
??_C@_0DF@JNOKNNOH@processing?5xml?3base?5attribute?5?9@ DB 'processing x'
	DB	'ml:base attribute - can''t get attr value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CEOJEMPO@processing?5xml?3base?5attribute@
CONST	SEGMENT
??_C@_0BO@CEOJEMPO@processing?5xml?3base?5attribute@ DB 'processing xml:b'
	DB	'ase attribute', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MNCHFEBF@normalizing?5attributes?5axis@
CONST	SEGMENT
??_C@_0BM@MNCHFEBF@normalizing?5attributes?5axis@ DB 'normalizing attribu'
	DB	'tes axis', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC@ DB '="', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DDLFPEHD@writing?5attributes@
CONST	SEGMENT
??_C@_0BD@DDLFPEHD@writing?5attributes@ DB 'writing attributes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCFPEJG@?$CDdefault@
CONST	SEGMENT
??_C@_08DCFPEJG@?$CDdefault@ DB '#default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OPHJGGNE@creating?5namespaces?5list?5?$CIexc?5c@
CONST	SEGMENT
??_C@_0CE@OPHJGGNE@creating?5namespaces?5list?5?$CIexc?5c@ DB 'creating n'
	DB	'amespaces list (exc c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@
CONST	SEGMENT
??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@ DB 'processing '
	DB	'namespaces axis (exc c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IIFGGKIF@creating?5namespaces?5list?5?$CIc14n?$CJ@
CONST	SEGMENT
??_C@_0CA@IIFGGKIF@creating?5namespaces?5list?5?$CIc14n?$CJ@ DB 'creating'
	DB	' namespaces list (c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LGNLNPPM@processing?5namespaces?5axis?5?$CIc14@
CONST	SEGMENT
??_C@_0CC@LGNLNPPM@processing?5namespaces?5axis?5?$CIc14@ DB 'processing '
	DB	'namespaces axis (c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFPCED@?$CC?$CC@
CONST	SEGMENT
??_C@_02JMMFPCED@?$CC?$CC@ DB '""', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDCCEEMD@?5xmlns?$DN@
CONST	SEGMENT
??_C@_07LDCCEEMD@?5xmlns?$DN@ DB ' xmlns=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PMGDNCAE@?5xmlns?3@
CONST	SEGMENT
??_C@_07PMGDNCAE@?5xmlns?3@ DB ' xmlns:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MCMJLIHF@writing?5namespaces@
CONST	SEGMENT
??_C@_0BD@MCMJLIHF@writing?5namespaces@ DB 'writing namespaces', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DGFPKBDK@searching?5namespaces?5stack?5?$CIexc@
CONST	SEGMENT
??_C@_0CG@DGFPKBDK@searching?5namespaces?5stack?5?$CIexc@ DB 'searching n'
	DB	'amespaces stack (exc c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HHELCFAC@searching?5namespaces?5stack?5?$CIc14@
CONST	SEGMENT
??_C@_0CC@HHELCFAC@searching?5namespaces?5stack?5?$CIc14@ DB 'searching n'
	DB	'amespaces stack (c14n)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@
CONST	SEGMENT
??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@ DB 'shifting namespaces s'
	DB	'tack', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@
CONST	SEGMENT
??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@ DB 'restoring namespaces'
	DB	' stack', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@
CONST	SEGMENT
??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@ DB 'saving namespaces stack'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EOOBKFEO@adding?5node?5to?5stack@
CONST	SEGMENT
??_C@_0BF@EOOBKFEO@adding?5node?5to?5stack@ DB 'adding node to stack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NHMKFMOM@adding?5namespace?5to?5stack@
CONST	SEGMENT
??_C@_0BK@NHMKFMOM@adding?5namespace?5to?5stack@ DB 'adding namespace to '
	DB	'stack', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPKFPLDI@destroying?5namespaces?5stack@
CONST	SEGMENT
??_C@_0BM@PPKFPLDI@destroying?5namespaces?5stack@ DB 'destroying namespac'
	DB	'es stack', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
CONST	SEGMENT
??_C@_0BK@MOKDAME@creating?5namespaces?5stack@ DB 'creating namespaces st'
	DB	'ack', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@
CONST	SEGMENT
??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@ DB 'Relative name'
	DB	'space UR is invalid here : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LPHDJOLE@Unknown?5node?5type?5?$CFd?5found?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0CB@LPHDJOLE@Unknown?5node?5type?5?$CFd?5found?5?3?5?$CFs@ DB 'Unkn'
	DB	'own node type %d found : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DIKCFALP@Node?5?$CFs?5is?5invalid?5here?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@DIKCFALP@Node?5?$CFs?5is?5invalid?5here?5?3?5?$CFs?6@ DB 'Node '
	DB	'%s is invalid here : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAEIDNN@Internal?5error?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@KAEIDNN@Internal?5error?5?3?5?$CFs?6@ DB 'Internal error : %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@ DB 'Invalid parameter'
	DB	' : %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NNewCtx
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_is_visible_callback$ = 12				; size = 4
_user_data$ = 16					; size = 4
_mode$ = 20						; size = 4
_inclusive_ns_prefixes$ = 24				; size = 4
_with_comments$ = 28					; size = 4
_buf$ = 32						; size = 4
_xmlC14NNewCtx PROC					; COMDAT

; 1783 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN3@xmlC14NNew

; 1784 :     xmlC14NCtxPtr ctx = NULL;
; 1785 : 
; 1786 :     if ((doc == NULL) || (buf == NULL)) {

	mov	ebx, DWORD PTR _buf$[ebp]
	test	ebx, ebx
	je	$LN3@xmlC14NNew

; 1789 :     }
; 1790 : 
; 1791 :     /*
; 1792 :      *  Validate the encoding output buffer encoding
; 1793 :      */
; 1794 :     if (buf->encoder != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN4@xmlC14NNew

; 1795 :         xmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,

	push	OFFSET ??_C@_0EM@ECCNBEBO@xmlC14NNewCtx?3?5output?5buffer?5en@
	push	1951					; 0000079fH
	push	edi
	push	0
	call	_xmlC14NErr
	add	esp, 16					; 00000010H

; 1796 : "xmlC14NNewCtx: output buffer encoder != NULL but C14N requires UTF8 output\n");
; 1797 :         return (NULL);

	xor	eax, eax
	pop	edi

; 1838 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlC14NNew:
	push	esi

; 1798 :     }
; 1799 : 
; 1800 :     /*
; 1801 :      * Allocate a new xmlC14NCtxPtr and fill the fields.
; 1802 :      */
; 1803 :     ctx = (xmlC14NCtxPtr) xmlMalloc(sizeof(xmlC14NCtx));

	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1804 :     if (ctx == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlC14NNew

; 1805 : 	xmlC14NErrMemory("creating context");

	push	OFFSET ??_C@_0BB@FCGDFAMA@creating?5context@
	call	_xmlC14NErrMemory
	add	esp, 4

; 1806 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1838 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlC14NNew:

; 1814 :     ctx->with_comments = with_comments;

	mov	eax, DWORD PTR _with_comments$[ebp]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+12], eax

; 1815 :     ctx->is_visible_callback = is_visible_callback;

	mov	eax, DWORD PTR _is_visible_callback$[ebp]
	mov	DWORD PTR [esi+4], eax

; 1816 :     ctx->user_data = user_data;

	mov	eax, DWORD PTR _user_data$[ebp]

; 286  :     ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));

	push	24					; 00000018H

; 1807 :     }
; 1808 :     memset(ctx, 0, sizeof(xmlC14NCtx));
; 1809 : 
; 1810 :     /*
; 1811 :      * initialize C14N context
; 1812 :      */
; 1813 :     ctx->doc = doc;

	mov	DWORD PTR [esi], edi

; 1816 :     ctx->user_data = user_data;

	mov	DWORD PTR [esi+8], eax

; 1817 :     ctx->buf = buf;

	mov	DWORD PTR [esi+16], ebx

; 1818 :     ctx->parent_is_doc = 1;

	mov	DWORD PTR [esi+24], 1

; 1819 :     ctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;

	mov	DWORD PTR [esi+20], 0

; 286  :     ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 287  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlC14NNew

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 289  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN11@xmlC14NNew
$LN12@xmlC14NNew:
	xorps	xmm0, xmm0

; 290  :     }
; 291  :     memset(ret, 0 , (size_t) sizeof(xmlC14NVisibleNsStack));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
$LN11@xmlC14NNew:

; 1820 :     ctx->ns_rendered = xmlC14NVisibleNsStackCreate();

	mov	DWORD PTR [esi+28], eax

; 1821 : 
; 1822 :     if(ctx->ns_rendered == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlC14NNew

; 1823 :         xmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_CREATE_STACK,

	push	OFFSET ??_C@_0DD@MDGGAHKJ@xmlC14NNewCtx?3?5xmlC14NVisibleNs@
	push	1952					; 000007a0H
	push	edi
	push	esi
	call	_xmlC14NErr

; 1824 : 		   "xmlC14NNewCtx: xmlC14NVisibleNsStackCreate failed\n");
; 1825 : 	xmlC14NFreeCtx(ctx);

	push	esi
	call	_xmlC14NFreeCtx
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	esi
	pop	edi

; 1838 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlC14NNew:

; 1826 :         return (NULL);
; 1827 :     }
; 1828 : 
; 1829 :     /*
; 1830 :      * Set "mode" flag and remember list of incluseve prefixes
; 1831 :      * for exclusive c14n
; 1832 :      */
; 1833 :     ctx->mode = mode;

	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [esi+32], ecx

; 1834 :     if(xmlC14NIsExclusive(ctx)) {

	cmp	ecx, 1
	jne	SHORT $LN7@xmlC14NNew

; 1835 :         ctx->inclusive_ns_prefixes = inclusive_ns_prefixes;

	mov	ecx, DWORD PTR _inclusive_ns_prefixes$[ebp]
	mov	DWORD PTR [esi+36], ecx
$LN7@xmlC14NNew:

; 1836 :     }
; 1837 :     return (ctx);

	mov	eax, esi
	pop	esi
	pop	edi

; 1838 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlC14NNew:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BF@IOABGFCG@creating?5new?5context@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BF@IOABGFCG@creating?5new?5context@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1787 :         xmlC14NErrParam("creating new context");
; 1788 :         return (NULL);

	xor	eax, eax
	pop	edi

; 1838 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlC14NNewCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NFreeCtx
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlC14NFreeCtx PROC					; COMDAT

; 1745 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlC14NFre

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BA@MKAAPEKK@freeing?5context@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	edi
	push	edi
	push	edi
	push	edi
	push	OFFSET ??_C@_0BA@MKAAPEKK@freeing?5context@
	push	edi
	push	edi
	push	2
	push	1
	push	21					; 00000015H
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 1755 : }

	pop	ebp
	ret	0
$LN2@xmlC14NFre:
	push	esi

; 1746 :     if (ctx == NULL) {
; 1747 :         xmlC14NErrParam("freeing context");
; 1748 :         return;
; 1749 :     }
; 1750 : 
; 1751 :     if (ctx->ns_rendered != NULL) {

	mov	esi, DWORD PTR [edi+28]
	test	esi, esi
	je	SHORT $LN7@xmlC14NFre

; 301  :     if(cur->nsTab != NULL) {

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN9@xmlC14NFre

; 302  : 	memset(cur->nsTab, 0, cur->nsMax * sizeof(xmlNsPtr));

	mov	eax, DWORD PTR [esi+12]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset

; 303  : 	xmlFree(cur->nsTab);

	push	DWORD PTR [esi+16]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN9@xmlC14NFre:

; 304  :     }
; 305  :     if(cur->nodeTab != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN10@xmlC14NFre

; 306  : 	memset(cur->nodeTab, 0, cur->nsMax * sizeof(xmlNodePtr));

	mov	eax, DWORD PTR [esi+12]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset

; 307  : 	xmlFree(cur->nodeTab);

	push	DWORD PTR [esi+20]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN10@xmlC14NFre:
	xorps	xmm0, xmm0

; 308  :     }
; 309  :     memset(cur, 0, sizeof(xmlC14NVisibleNsStack));

	movups	XMMWORD PTR [esi], xmm0

; 310  :     xmlFree(cur);

	push	esi
	movq	QWORD PTR [esi+16], xmm0
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlC14NFre:

; 1752 :         xmlC14NVisibleNsStackDestroy(ctx->ns_rendered);
; 1753 :     }
; 1754 :     xmlFree(ctx);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
	pop	edi

; 1755 : }

	pop	ebp
	ret	0
_xmlC14NFreeCtx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NProcessElementNode
_TEXT	SEGMENT
_state$ = -36						; size = 24
_state$3$ = -12						; size = 4
_state$2$ = -8						; size = 4
_parent_is_doc$1$ = -4					; size = 4
_state$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_visible$ = 16						; size = 4
_xmlC14NProcessElementNode PROC				; COMDAT

; 1422 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	xor	eax, eax
	mov	DWORD PTR _parent_is_doc$1$[ebp], eax
	test	ebx, ebx
	je	$LN3@xmlC14NPro

; 1423 :     int ret;
; 1424 :     xmlC14NVisibleNsStack state;
; 1425 :     int parent_is_doc = 0;
; 1426 : 
; 1427 :     if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN3@xmlC14NPro
	cmp	DWORD PTR [edi+4], 1
	jne	$LN3@xmlC14NPro

; 1375 :     ns = cur->nsDef;

	push	esi
	mov	esi, DWORD PTR [edi+48]

; 1376 :     while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN68@xmlC14NPro
	npad	1
$LL23@xmlC14NPro:

; 1377 :         if (xmlStrlen(ns->href) > 0) {

	push	DWORD PTR [esi+8]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN27@xmlC14NPro

; 1378 :             xmlURIPtr uri;
; 1379 : 
; 1380 :             uri = xmlParseURI((const char *) ns->href);

	push	DWORD PTR [esi+8]
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4

; 1381 :             if (uri == NULL) {

	test	edi, edi
	je	$LN61@xmlC14NPro

; 1383 :                 return (-1);
; 1384 :             }
; 1385 :             if (xmlStrlen((const xmlChar *) uri->scheme) == 0) {

	push	DWORD PTR [edi]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN62@xmlC14NPro

; 1388 :                 return (-1);
; 1389 :             }
; 1390 :             xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN27@xmlC14NPro:

; 1391 :         }
; 1392 :         ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL23@xmlC14NPro

; 1376 :     while (ns != NULL) {

	mov	edi, DWORD PTR _cur$[ebp]
$LN68@xmlC14NPro:

; 1439 :         return (-1);
; 1440 :     }
; 1441 : 
; 1442 : 
; 1443 :     /*
; 1444 :      * Save ns_rendered stack position
; 1445 :      */
; 1446 :     memset(&state, 0, sizeof(state));
; 1447 :     xmlC14NVisibleNsStackSave(ctx->ns_rendered, &state);

	mov	eax, DWORD PTR [ebx+28]
	xorps	xmm0, xmm0
	movq	QWORD PTR _state$[ebp+16], xmm0
	movups	XMMWORD PTR _state$[ebp], xmm0

; 362  :     if((cur == NULL) || (state == NULL)) {

	test	eax, eax
	je	SHORT $LN37@xmlC14NPro

; 363  :         xmlC14NErrParam("saving namespaces stack");
; 364  : 	return;
; 365  :     }
; 366  : 
; 367  :     state->nsCurEnd = cur->nsCurEnd;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _state$1$[ebp], ecx

; 368  :     state->nsPrevStart = cur->nsPrevStart;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _state$2$[ebp], ecx

; 369  :     state->nsPrevEnd = cur->nsPrevEnd;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _state$3$[ebp], ecx
	jmp	$LN35@xmlC14NPro
$LN62@xmlC14NPro:

; 217  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	DWORD PTR [edi]
	push	OFFSET ??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1955					; 000007a3H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1387 :                 xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 72					; 00000048H
	jmp	SHORT $LN67@xmlC14NPro
$LN61@xmlC14NPro:

; 1382 :                 xmlC14NErrInternal("parsing namespace uri");

	push	OFFSET ??_C@_0BG@JBCPGIOB@parsing?5namespace?5uri@
	call	_xmlC14NErrInternal
	add	esp, 4
$LN67@xmlC14NPro:

; 1430 :     }
; 1431 : 
; 1432 :     /*
; 1433 :      * Check relative relative namespaces:
; 1434 :      * implementations of XML canonicalization MUST report an operation
; 1435 :      * failure on documents containing relative namespace URIs.
; 1436 :      */
; 1437 :     if (xmlC14NCheckForRelativeNamespaces(ctx, cur) < 0) {
; 1438 :         xmlC14NErrInternal("checking for relative namespaces");

	push	OFFSET ??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@

; 1482 : 	xmlC14NErrInternal("processing attributes axis");

	call	_xmlC14NErrInternal
	add	esp, 4

; 1483 : 	return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	mov	eax, DWORD PTR _state$[ebp+8]
	add	esp, 68					; 00000044H
	mov	DWORD PTR _state$3$[ebp], eax
	mov	eax, DWORD PTR _state$[ebp+4]
	mov	DWORD PTR _state$2$[ebp], eax
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR _state$1$[ebp], eax
$LN35@xmlC14NPro:

; 1448 : 
; 1449 :     if (visible) {

	mov	esi, DWORD PTR _visible$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlC14NPro

; 1450 :         if (ctx->parent_is_doc) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN6@xmlC14NPro

; 1451 : 	    /* save this flag into the stack */
; 1452 : 	    parent_is_doc = ctx->parent_is_doc;

	mov	DWORD PTR _parent_is_doc$1$[ebp], eax

; 1453 : 	    ctx->parent_is_doc = 0;

	mov	DWORD PTR [ebx+24], 0

; 1454 :             ctx->pos = XMLC14N_INSIDE_DOCUMENT_ELEMENT;

	mov	DWORD PTR [ebx+20], 1
$LN6@xmlC14NPro:

; 1455 :         }
; 1456 :         xmlOutputBufferWriteString(ctx->buf, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1457 : 
; 1458 :         if ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlC14NPro
	push	DWORD PTR [eax+12]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN7@xmlC14NPro

; 1459 :             xmlOutputBufferWriteString(ctx->buf,

	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1460 :                                        (const char *) cur->ns->prefix);
; 1461 :             xmlOutputBufferWriteString(ctx->buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN7@xmlC14NPro:

; 1462 :         }
; 1463 :         xmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN5@xmlC14NPro:

; 1464 :     }
; 1465 : 
; 1466 :     if (!xmlC14NIsExclusive(ctx)) {

	cmp	DWORD PTR [ebx+32], 1
	push	esi
	push	edi
	push	ebx
	je	SHORT $LN8@xmlC14NPro

; 1467 :         ret = xmlC14NProcessNamespacesAxis(ctx, cur, visible);

	call	_xmlC14NProcessNamespacesAxis

; 1468 :     } else {

	jmp	SHORT $LN71@xmlC14NPro
$LN8@xmlC14NPro:

; 1469 :         ret = xmlExcC14NProcessNamespacesAxis(ctx, cur, visible);

	call	_xmlExcC14NProcessNamespacesAxis
$LN71@xmlC14NPro:

; 1470 :     }
; 1471 :     if (ret < 0) {

	add	esp, 12					; 0000000cH
	test	eax, eax
	jns	SHORT $LN10@xmlC14NPro

; 1472 :         xmlC14NErrInternal("processing namespaces axis");

	push	OFFSET ??_C@_0BL@BCEIHHDE@processing?5namespaces?5axis@

; 1482 : 	xmlC14NErrInternal("processing attributes axis");

	call	_xmlC14NErrInternal
	add	esp, 4

; 1483 : 	return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlC14NPro:

; 1473 :         return (-1);
; 1474 :     }
; 1475 :     /* todo: shouldn't this go to "visible only"? */
; 1476 :     if(visible) {

	test	esi, esi
	je	SHORT $LN41@xmlC14NPro

; 1477 : 	xmlC14NVisibleNsStackShift(ctx->ns_rendered);

	mov	ecx, DWORD PTR [ebx+28]

; 385  :     if(cur == NULL) {

	test	ecx, ecx
	jne	SHORT $LN42@xmlC14NPro

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@
	push	ecx
	push	ecx
	push	2
	push	1
	push	21					; 00000015H
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 387  : 	return;

	jmp	SHORT $LN41@xmlC14NPro
$LN42@xmlC14NPro:

; 388  :     }
; 389  :     cur->nsPrevStart = cur->nsPrevEnd;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+4], eax

; 390  :     cur->nsPrevEnd = cur->nsCurEnd;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax
$LN41@xmlC14NPro:

; 1478 :     }
; 1479 : 
; 1480 :     ret = xmlC14NProcessAttrsAxis(ctx, cur, visible);

	push	esi
	push	edi
	push	ebx
	call	_xmlC14NProcessAttrsAxis
	add	esp, 12					; 0000000cH

; 1481 :     if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN12@xmlC14NPro

; 1482 : 	xmlC14NErrInternal("processing attributes axis");

	push	OFFSET ??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1483 : 	return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlC14NPro:

; 1484 :     }
; 1485 : 
; 1486 :     if (visible) {

	test	esi, esi
	je	SHORT $LN13@xmlC14NPro

; 1487 :         xmlOutputBufferWriteString(ctx->buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN13@xmlC14NPro:

; 1488 :     }
; 1489 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN15@xmlC14NPro

; 1490 :         ret = xmlC14NProcessNodeList(ctx, cur->children);

	push	eax
	push	ebx
	call	_xmlC14NProcessNodeList
	add	esp, 8

; 1491 :         if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN15@xmlC14NPro

; 1492 :             xmlC14NErrInternal("processing childrens list");

	push	OFFSET ??_C@_0BK@FJJBBBML@processing?5childrens?5list@
	call	_xmlC14NErrInternal
	add	esp, 4
	or	eax, -1
	pop	esi
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlC14NPro:

; 1493 :             return (-1);
; 1494 :         }
; 1495 :     }
; 1496 :     if (visible) {

	test	esi, esi
	je	SHORT $LN18@xmlC14NPro

; 1497 :         xmlOutputBufferWriteString(ctx->buf, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1498 :         if ((cur->ns != NULL) && (xmlStrlen(cur->ns->prefix) > 0)) {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlC14NPro
	push	DWORD PTR [eax+12]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN17@xmlC14NPro

; 1499 :             xmlOutputBufferWriteString(ctx->buf,

	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1500 :                                        (const char *) cur->ns->prefix);
; 1501 :             xmlOutputBufferWriteString(ctx->buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN17@xmlC14NPro:

; 1502 :         }
; 1503 :         xmlOutputBufferWriteString(ctx->buf, (const char *) cur->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1504 :         xmlOutputBufferWriteString(ctx->buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1505 :         if (parent_is_doc) {

	mov	eax, DWORD PTR _parent_is_doc$1$[ebp]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN18@xmlC14NPro

; 1506 : 	    /* restore this flag from the stack for next node */
; 1507 :             ctx->parent_is_doc = parent_is_doc;

	mov	DWORD PTR [ebx+24], eax

; 1508 : 	    ctx->pos = XMLC14N_AFTER_DOCUMENT_ELEMENT;

	mov	DWORD PTR [ebx+20], 2
$LN18@xmlC14NPro:

; 1509 :         }
; 1510 :     }
; 1511 : 
; 1512 :     /*
; 1513 :      * Restore ns_rendered stack position
; 1514 :      */
; 1515 :     xmlC14NVisibleNsStackRestore(ctx->ns_rendered, &state);

	mov	eax, DWORD PTR [ebx+28]

; 374  :     if((cur == NULL) || (state == NULL)) {

	test	eax, eax
	je	SHORT $LN56@xmlC14NPro

; 375  :         xmlC14NErrParam("restoring namespaces stack");
; 376  : 	return;
; 377  :     }
; 378  :     cur->nsCurEnd = state->nsCurEnd;

	mov	ecx, DWORD PTR _state$1$[ebp]
	mov	DWORD PTR [eax], ecx

; 379  :     cur->nsPrevStart = state->nsPrevStart;

	mov	ecx, DWORD PTR _state$2$[ebp]
	pop	esi
	mov	DWORD PTR [eax+4], ecx

; 380  :     cur->nsPrevEnd = state->nsPrevEnd;

	mov	ecx, DWORD PTR _state$3$[ebp]
	pop	edi
	mov	DWORD PTR [eax+8], ecx

; 1516 :     return (0);

	xor	eax, eax

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1516 :     return (0);

	xor	eax, eax
	pop	esi
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BI@JAMIDBLC@processing?5element?5node@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BI@JAMIDBLC@processing?5element?5node@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1428 :         xmlC14NErrParam("processing element node");
; 1429 :         return (-1);

	or	eax, -1
	pop	edi

; 1517 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NProcessElementNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NCheckForRelativeNamespaces
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlC14NCheckForRelativeNamespaces PROC			; COMDAT

; 1367 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctx$[ebp], 0
	je	$LN5@xmlC14NChe

; 1368 :     xmlNsPtr ns;
; 1369 : 
; 1370 :     if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN5@xmlC14NChe
	cmp	DWORD PTR [esi+4], 1
	jne	$LN5@xmlC14NChe

; 1373 :     }
; 1374 : 
; 1375 :     ns = cur->nsDef;

	mov	esi, DWORD PTR [esi+48]
	push	edi

; 1376 :     while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN20@xmlC14NChe
$LL2@xmlC14NChe:

; 1377 :         if (xmlStrlen(ns->href) > 0) {

	push	DWORD PTR [esi+8]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN6@xmlC14NChe

; 1378 :             xmlURIPtr uri;
; 1379 : 
; 1380 :             uri = xmlParseURI((const char *) ns->href);

	push	DWORD PTR [esi+8]
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4

; 1381 :             if (uri == NULL) {

	test	edi, edi
	je	SHORT $LN15@xmlC14NChe

; 1383 :                 return (-1);
; 1384 :             }
; 1385 :             if (xmlStrlen((const xmlChar *) uri->scheme) == 0) {

	push	DWORD PTR [edi]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@xmlC14NChe

; 1389 :             }
; 1390 :             xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN6@xmlC14NChe:

; 1391 :         }
; 1392 :         ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlC14NChe
$LN20@xmlC14NChe:
	pop	edi

; 1393 :     }
; 1394 :     return (0);

	xor	eax, eax
	pop	esi

; 1395 : }

	pop	ebp
	ret	0
$LN16@xmlC14NChe:

; 217  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	DWORD PTR [edi]
	push	OFFSET ??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1955					; 000007a3H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1386 :                 xmlC14NErrRelativeNamespace(uri->scheme);
; 1387 :                 xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 72					; 00000048H

; 1388 :                 return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1395 : }

	pop	ebp
	ret	0
$LN15@xmlC14NChe:

; 1382 :                 xmlC14NErrInternal("parsing namespace uri");

	push	OFFSET ??_C@_0BG@JBCPGIOB@parsing?5namespace?5uri@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1388 :                 return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1395 : }

	pop	ebp
	ret	0
$LN5@xmlC14NChe:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CB@NOENIPIC@checking?5for?5relative?5namespace@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1371 :         xmlC14NErrParam("checking for relative namespaces");
; 1372 :         return (-1);

	or	eax, -1
	pop	esi

; 1395 : }

	pop	ebp
	ret	0
_xmlC14NCheckForRelativeNamespaces ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NProcessAttrsAxis
_TEXT	SEGMENT
_attrs_to_delete$1$ = -16				; size = 4
_xml_base_attr$1$ = -12					; size = 4
_xml_space_attr$1$ = -8					; size = 4
_xml_lang_attr$1$ = -4					; size = 4
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_parent_visible$ = 16					; size = 4
_xmlC14NProcessAttrsAxis PROC				; COMDAT

; 1139 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _attrs_to_delete$1$[ebp], 0
	mov	DWORD PTR _xml_base_attr$1$[ebp], 0
	mov	DWORD PTR _xml_lang_attr$1$[ebp], 0
	mov	DWORD PTR _xml_space_attr$1$[ebp], 0
	test	ebx, ebx
	je	$LN15@xmlC14NPro

; 1140 :     xmlAttrPtr attr;
; 1141 :     xmlListPtr list;
; 1142 :     xmlAttrPtr attrs_to_delete = NULL;
; 1143 : 
; 1144 :     /* special processing for 1.1 spec */
; 1145 :     xmlAttrPtr xml_base_attr = NULL;
; 1146 :     xmlAttrPtr xml_lang_attr = NULL;
; 1147 :     xmlAttrPtr xml_space_attr = NULL;
; 1148 : 
; 1149 :     if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	je	$LN15@xmlC14NPro
	cmp	DWORD PTR [eax+4], 1
	jne	$LN15@xmlC14NPro

; 1152 :     }
; 1153 : 
; 1154 :     /*
; 1155 :      * Create a sorted list to store element attributes
; 1156 :      */
; 1157 :     list = xmlListCreate(NULL, xmlC14NAttrsCompare);

	push	edi
	push	OFFSET _xmlC14NAttrsCompare
	push	0
	call	_xmlListCreate
	mov	edi, eax
	add	esp, 8

; 1158 :     if (list == NULL) {

	test	edi, edi
	jne	SHORT $LN16@xmlC14NPro

; 1159 :         xmlC14NErrInternal("creating attributes list");

	push	OFFSET ??_C@_0BJ@NCGHGLGP@creating?5attributes?5list@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1160 :         return (-1);

	or	eax, -1
	pop	edi
	pop	ebx

; 1354 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlC14NPro:

; 1161 :     }
; 1162 : 
; 1163 :     switch(ctx->mode) {

	mov	eax, DWORD PTR [ebx+32]
	push	esi
	sub	eax, 0
	je	$LN17@xmlC14NPro
	sub	eax, 1
	je	$LN22@xmlC14NPro
	sub	eax, 1
	jne	$LN7@xmlC14NPro

; 1236 :     case XML_C14N_1_1:
; 1237 :         /* The processing of an element node E MUST be modified slightly when an XPath node-set is
; 1238 :          * given as input and some of the element's ancestors are omitted from the node-set.
; 1239 :          *
; 1240 :          * Simple inheritable attributes are attributes that have a value that requires at most a simple
; 1241 :          * redeclaration. This redeclaration is done by supplying a new value in the child axis. The
; 1242 :          * redeclaration of a simple inheritable attribute A contained in one of E's ancestors is done
; 1243 :          * by supplying a value to an attribute Ae inside E with the same name. Simple inheritable attributes
; 1244 :          * are xml:lang and xml:space.
; 1245 :          *
; 1246 :          * The method for processing the attribute axis of an element E in the node-set is hence enhanced.
; 1247 :          * All element nodes along E's ancestor axis are examined for the nearest occurrences of simple
; 1248 :          * inheritable attributes in the xml namespace, such as xml:lang and xml:space (whether or not they
; 1249 :          * are in the node-set). From this list of attributes, any simple inheritable attributes that are
; 1250 :          * already in E's attribute axis (whether or not they are in the node-set) are removed. Then,
; 1251 :          * lexicographically merge this attribute list with the nodes of E's attribute axis that are in
; 1252 :          * the node-set. The result of visiting the attribute axis is computed by processing the attribute
; 1253 :          * nodes in this merged attribute list.
; 1254 :          *
; 1255 :          * The xml:id attribute is not a simple inheritable attribute and no processing of these attributes is
; 1256 :          * performed.
; 1257 :          *
; 1258 :          * The xml:base attribute is not a simple inheritable attribute and requires special processing beyond
; 1259 :          * a simple redeclaration.
; 1260 :          *
; 1261 :          * Attributes in the XML namespace other than xml:base, xml:id, xml:lang, and xml:space MUST be processed
; 1262 :          * as ordinary attributes.
; 1263 :          */
; 1264 : 
; 1265 :         /*
; 1266 :          * Add all visible attributes from current node.
; 1267 :          */
; 1268 :         attr = cur->properties;

	mov	eax, DWORD PTR _cur$[ebp]

; 1269 :         while (attr != NULL) {

	mov	ecx, DWORD PTR _parent_visible$[ebp]
	mov	esi, DWORD PTR [eax+44]
	test	esi, esi
	je	$LN13@xmlC14NPro
	npad	7
$LL12@xmlC14NPro:

; 1270 :             /* special processing for XML attribute kiks in only when we have invisible parents */
; 1271 :             if ((!parent_visible) || (xmlC14NIsXmlAttr(attr) == 0)) {

	test	ecx, ecx
	je	SHORT $LN27@xmlC14NPro
	push	esi
	call	_xmlC14NIsXmlAttr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN86@xmlC14NPro

; 1274 :                     xmlListInsert(list, attr);
; 1275 :                 }
; 1276 :             } else {
; 1277 :                 int matched = 0;
; 1278 : 
; 1279 :                 /* check for simple inheritance attributes */
; 1280 :                 if((!matched) && (xml_lang_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST "lang")) {

	cmp	DWORD PTR _xml_lang_attr$1$[ebp], 0
	jne	SHORT $LN81@xmlC14NPro
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN81@xmlC14NPro

; 1281 :                     xml_lang_attr = attr;

	mov	DWORD PTR _xml_lang_attr$1$[ebp], esi

; 1282 :                     matched = 1;
; 1283 :                 }
; 1284 :                 if((!matched) && (xml_space_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST "space")) {

	jmp	SHORT $LN28@xmlC14NPro
$LN81@xmlC14NPro:
	cmp	DWORD PTR _xml_space_attr$1$[ebp], 0
	jne	SHORT $LN82@xmlC14NPro
	push	OFFSET ??_C@_05OLNILLAB@space@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN82@xmlC14NPro

; 1285 :                     xml_space_attr = attr;

	mov	DWORD PTR _xml_space_attr$1$[ebp], esi

; 1286 :                     matched = 1;
; 1287 :                 }
; 1288 : 
; 1289 :                 /* check for base attr */
; 1290 :                 if((!matched) && (xml_base_attr == NULL) && xmlStrEqual(attr->name, BAD_CAST "base")) {

	jmp	SHORT $LN28@xmlC14NPro
$LN82@xmlC14NPro:
	cmp	DWORD PTR _xml_base_attr$1$[ebp], 0
	jne	SHORT $LN83@xmlC14NPro
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN83@xmlC14NPro

; 1291 :                     xml_base_attr = attr;

	mov	DWORD PTR _xml_base_attr$1$[ebp], esi

; 1292 :                     matched = 1;
; 1293 :                 }
; 1294 : 
; 1295 :                 /* otherwise, it is a normal attribute, so just check if it is visible */
; 1296 :                 if((!matched) && xmlC14NIsVisible(ctx, attr, cur)) {

	jmp	SHORT $LN28@xmlC14NPro
$LN83@xmlC14NPro:
	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN78@xmlC14NPro
	mov	eax, DWORD PTR _cur$[ebp]

; 1297 :                     xmlListInsert(list, attr);

	jmp	SHORT $LN90@xmlC14NPro
$LN86@xmlC14NPro:

; 1270 :             /* special processing for XML attribute kiks in only when we have invisible parents */
; 1271 :             if ((!parent_visible) || (xmlC14NIsXmlAttr(attr) == 0)) {

	mov	eax, DWORD PTR _cur$[ebp]
$LN27@xmlC14NPro:

; 1272 :                 /* check that attribute is visible */
; 1273 :                 if (xmlC14NIsVisible(ctx, attr, cur)) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN78@xmlC14NPro
$LN90@xmlC14NPro:

; 1298 :                 }
; 1299 :             }
; 1300 : 
; 1301 :             /* move to the next one */
; 1302 :             attr = attr->next;

	push	eax
	push	esi
	push	DWORD PTR [ebx+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN28@xmlC14NPro
$LN78@xmlC14NPro:
	push	esi
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN28@xmlC14NPro:
	mov	esi, DWORD PTR [esi+24]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _parent_visible$[ebp]
	test	esi, esi
	jne	$LL12@xmlC14NPro
$LN13@xmlC14NPro:

; 1303 :         }
; 1304 : 
; 1305 :         /* special processing for XML attribute kiks in only when we have invisible parents */
; 1306 :         if ((parent_visible)) {

	test	ecx, ecx
	je	$LN7@xmlC14NPro

; 1307 : 
; 1308 :             /* simple inheritance attributes - copy */
; 1309 :             if(xml_lang_attr == NULL) {

	cmp	DWORD PTR _xml_lang_attr$1$[ebp], 0
	jne	SHORT $LN87@xmlC14NPro

; 1310 :                 xml_lang_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST "lang", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [eax+20]
	push	ebx
	call	_xmlC14NFindHiddenParentAttr
	add	esp, 16					; 00000010H

; 1311 :             }
; 1312 :             if(xml_lang_attr != NULL) {

	test	eax, eax
	je	SHORT $LN35@xmlC14NPro

; 1307 : 
; 1308 :             /* simple inheritance attributes - copy */
; 1309 :             if(xml_lang_attr == NULL) {

	jmp	SHORT $LN76@xmlC14NPro
$LN87@xmlC14NPro:
	mov	eax, DWORD PTR _xml_lang_attr$1$[ebp]
$LN76@xmlC14NPro:

; 1313 :                 xmlListInsert(list, xml_lang_attr);

	push	eax
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN35@xmlC14NPro:

; 1314 :             }
; 1315 :             if(xml_space_attr == NULL) {

	mov	eax, DWORD PTR _xml_space_attr$1$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN75@xmlC14NPro

; 1316 :                 xml_space_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST "space", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_05OLNILLAB@space@
	push	DWORD PTR [esi+20]
	push	ebx
	call	_xmlC14NFindHiddenParentAttr
	add	esp, 16					; 00000010H

; 1317 :             }
; 1318 :             if(xml_space_attr != NULL) {

	test	eax, eax
	je	SHORT $LN37@xmlC14NPro
$LN75@xmlC14NPro:

; 1319 :                 xmlListInsert(list, xml_space_attr);

	push	eax
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN37@xmlC14NPro:

; 1320 :             }
; 1321 : 
; 1322 :             /* base uri attribute - fix up */
; 1323 :             if(xml_base_attr == NULL) {

	mov	eax, DWORD PTR _xml_base_attr$1$[ebp]
	test	eax, eax
	jne	SHORT $LN74@xmlC14NPro

; 1324 :                 /* if we don't have base uri attribute, check if we have a "hidden" one above */
; 1325 :                 xml_base_attr = xmlC14NFindHiddenParentAttr(ctx, cur->parent, BAD_CAST "base", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+20]
	push	ebx
	call	_xmlC14NFindHiddenParentAttr
	add	esp, 16					; 00000010H

; 1326 :             }
; 1327 :             if(xml_base_attr != NULL) {

	test	eax, eax
	je	$LN7@xmlC14NPro
$LN74@xmlC14NPro:

; 1328 :                 xml_base_attr = xmlC14NFixupBaseAttr(ctx, xml_base_attr);

	push	eax
	push	ebx
	call	_xmlC14NFixupBaseAttr
	mov	esi, eax
	add	esp, 8

; 1329 :                 if(xml_base_attr != NULL) {

	test	esi, esi
	je	$LN7@xmlC14NPro

; 1330 :                     xmlListInsert(list, xml_base_attr);

	push	esi
	push	edi
	call	_xmlListInsert
	add	esp, 8

; 1331 : 
; 1332 :                     /* note that we MUST delete returned attr node ourselves! */
; 1333 :                     xml_base_attr->next = attrs_to_delete;

	mov	DWORD PTR [esi+24], 0

; 1334 :                     attrs_to_delete = xml_base_attr;

	mov	DWORD PTR _attrs_to_delete$1$[ebp], esi
	jmp	$LN7@xmlC14NPro
$LN22@xmlC14NPro:

; 1212 :             }
; 1213 :         }
; 1214 : 
; 1215 :         /* done */
; 1216 :         break;
; 1217 :     case XML_C14N_EXCLUSIVE_1_0:
; 1218 :         /* attributes in the XML namespace, such as xml:lang and xml:space
; 1219 :          * are not imported into orphan nodes of the document subset
; 1220 :          */
; 1221 : 
; 1222 :         /*
; 1223 :          * Add all visible attributes from current node.
; 1224 :          */
; 1225 :         attr = cur->properties;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR [ecx+44]

; 1226 :         while (attr != NULL) {

	test	esi, esi
	je	$LN7@xmlC14NPro
$LL10@xmlC14NPro:

; 1227 :             /* check that attribute is visible */
; 1228 :             if (xmlC14NIsVisible(ctx, attr, cur)) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN79@xmlC14NPro
	push	ecx
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@xmlC14NPro
$LN79@xmlC14NPro:

; 1229 :                 xmlListInsert(list, attr);

	push	esi
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN23@xmlC14NPro:

; 1230 :             }
; 1231 :             attr = attr->next;

	mov	esi, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LL10@xmlC14NPro

; 1232 :         }
; 1233 : 
; 1234 :         /* do nothing special for xml attributes */
; 1235 :         break;

	jmp	$LN7@xmlC14NPro
$LN17@xmlC14NPro:

; 1164 :     case XML_C14N_1_0:
; 1165 :         /* The processing of an element node E MUST be modified slightly when an XPath node-set is
; 1166 :          * given as input and the element's parent is omitted from the node-set. The method for processing
; 1167 :          * the attribute axis of an element E in the node-set is enhanced. All element nodes along E's
; 1168 :          * ancestor axis are examined for nearest occurrences of attributes in the xml namespace, such
; 1169 :          * as xml:lang and xml:space (whether or not they are in the node-set). From this list of attributes,
; 1170 :          * remove any that are in E's attribute axis (whether or not they are in the node-set). Then,
; 1171 :          * lexicographically merge this attribute list with the nodes of E's attribute axis that are in
; 1172 :          * the node-set. The result of visiting the attribute axis is computed by processing the attribute
; 1173 :          * nodes in this merged attribute list.
; 1174 :          */
; 1175 : 
; 1176 :         /*
; 1177 :          * Add all visible attributes from current node.
; 1178 :          */
; 1179 :         attr = cur->properties;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR [ecx+44]

; 1180 :         while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlC14NPro
	npad	6
$LL4@xmlC14NPro:

; 1181 :             /* check that attribute is visible */
; 1182 :             if (xmlC14NIsVisible(ctx, attr, cur)) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN80@xmlC14NPro
	push	ecx
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@xmlC14NPro
$LN80@xmlC14NPro:

; 1183 :                 xmlListInsert(list, attr);

	push	esi
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN18@xmlC14NPro:

; 1184 :             }
; 1185 :             attr = attr->next;

	mov	esi, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LL4@xmlC14NPro
$LN5@xmlC14NPro:

; 1186 :         }
; 1187 : 
; 1188 :         /*
; 1189 :          * Handle xml attributes
; 1190 :          */
; 1191 :         if (parent_visible && (cur->parent != NULL) &&

	cmp	DWORD PTR _parent_visible$[ebp], 0
	je	SHORT $LN7@xmlC14NPro
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN7@xmlC14NPro
	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN7@xmlC14NPro
	push	DWORD PTR [eax+20]
	push	eax
	push	DWORD PTR [ebx+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@xmlC14NPro

; 1192 :             (!xmlC14NIsVisible(ctx, cur->parent, cur->parent->parent)))
; 1193 :         {
; 1194 :             xmlNodePtr tmp;
; 1195 : 
; 1196 :             /*
; 1197 :              * If XPath node-set is not specified then the parent is always
; 1198 :              * visible!
; 1199 :              */
; 1200 :             tmp = cur->parent;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ebx, DWORD PTR [eax+20]

; 1201 :             while (tmp != NULL) {

	test	ebx, ebx
	je	SHORT $LN84@xmlC14NPro
$LL6@xmlC14NPro:

; 1202 :                 attr = tmp->properties;

	mov	esi, DWORD PTR [ebx+44]

; 1203 :                 while (attr != NULL) {

	test	esi, esi
	je	SHORT $LN9@xmlC14NPro
	npad	2
$LL8@xmlC14NPro:

; 1204 :                     if (xmlC14NIsXmlAttr(attr) != 0) {

	push	esi
	call	_xmlC14NIsXmlAttr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@xmlC14NPro

; 1205 :                         if (xmlListSearch(list, attr) == NULL) {

	push	esi
	push	edi
	call	_xmlListSearch
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlC14NPro

; 1206 :                             xmlListInsert(list, attr);

	push	esi
	push	edi
	call	_xmlListInsert
	add	esp, 8
$LN21@xmlC14NPro:

; 1207 :                         }
; 1208 :                     }
; 1209 :                     attr = attr->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL8@xmlC14NPro
$LN9@xmlC14NPro:

; 1210 :                 }
; 1211 :                 tmp = tmp->parent;

	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	SHORT $LL6@xmlC14NPro
$LN84@xmlC14NPro:

; 1335 :                 }
; 1336 :             }
; 1337 :         }
; 1338 : 
; 1339 :         /* done */
; 1340 :         break;
; 1341 :     }
; 1342 : 
; 1343 :     /*
; 1344 :      * print out all elements from list
; 1345 :      */
; 1346 :     xmlListWalk(list, xmlC14NPrintAttrs, (void *) ctx);

	mov	ebx, DWORD PTR _ctx$[ebp]
$LN7@xmlC14NPro:
	push	ebx
	push	OFFSET _xmlC14NPrintAttrs
	push	edi
	call	_xmlListWalk

; 1347 : 
; 1348 :     /*
; 1349 :      * Cleanup
; 1350 :      */
; 1351 :     xmlFreePropList(attrs_to_delete);

	push	DWORD PTR _attrs_to_delete$1$[ebp]
	call	_xmlFreePropList

; 1352 :     xmlListDelete(list);

	push	edi
	call	_xmlListDelete
	add	esp, 20					; 00000014H

; 1353 :     return (0);

	xor	eax, eax
	pop	esi
	pop	edi
	pop	ebx

; 1354 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@BMIGCENJ@processing?5attributes?5axis@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1150 :         xmlC14NErrParam("processing attributes axis");
; 1151 :         return (-1);

	or	eax, -1
	pop	ebx

; 1354 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NProcessAttrsAxis ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NFixupBaseAttr
_TEXT	SEGMENT
tv283 = -4						; size = 4
_ctx$ = 8						; size = 4
_xml_base_attr$ = 12					; size = 4
_xmlC14NFixupBaseAttr PROC				; COMDAT

; 1014 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	test	ebx, ebx
	je	$LN5@xmlC14NFix

; 1015 :     xmlChar * res = NULL;
; 1016 :     xmlNodePtr cur;
; 1017 :     xmlAttrPtr attr;
; 1018 :     xmlChar * tmp_str;
; 1019 :     xmlChar * tmp_str2;
; 1020 :     int tmp_str_len;
; 1021 : 
; 1022 :     if ((ctx == NULL) || (xml_base_attr == NULL) || (xml_base_attr->parent == NULL)) {

	mov	esi, DWORD PTR _xml_base_attr$[ebp]
	test	esi, esi
	je	$LN5@xmlC14NFix
	cmp	DWORD PTR [esi+20], 0
	je	$LN5@xmlC14NFix

; 1025 :     }
; 1026 : 
; 1027 :     /* start from current value */
; 1028 :     res = xmlNodeListGetString(ctx->doc, xml_base_attr->children, 1);

	push	edi
	push	1
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx]
	call	_xmlNodeListGetString
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1029 :     if(res == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlC14NFix

; 1030 :         xmlC14NErrInternal("processing xml:base attribute - can't get attr value");

	push	OFFSET ??_C@_0DF@JNOKNNOH@processing?5xml?3base?5attribute?5?9@
	call	_xmlC14NErrInternal

; 1096 :         return (NULL);

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlC14NFix:

; 1031 :         return (NULL);
; 1032 :     }
; 1033 : 
; 1034 :     /* go up the stack until we find a node that we rendered already */
; 1035 :     cur = xml_base_attr->parent->parent;

	mov	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR [eax+20]

; 1036 :     while((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {

	test	esi, esi
	je	$LN3@xmlC14NFix
	npad	6
$LL2@xmlC14NFix:
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	$LN3@xmlC14NFix
	push	DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [esi+20]
	push	esi
	push	DWORD PTR [ebx+8]
	mov	DWORD PTR tv283[ebp], ecx
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN3@xmlC14NFix

; 1037 :         attr = xmlHasNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	esi
	call	_xmlHasNsProp
	add	esp, 12					; 0000000cH

; 1038 :         if(attr != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlC14NFix

; 1039 :             /* get attr value */
; 1040 :             tmp_str = xmlNodeListGetString(ctx->doc, attr->children, 1);

	push	1
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ebx]
	call	_xmlNodeListGetString
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1041 :             if(tmp_str == NULL) {

	test	esi, esi
	je	$LN21@xmlC14NFix

; 1045 :                 return (NULL);
; 1046 :             }
; 1047 : 
; 1048 :             /* we need to add '/' if our current base uri ends with '..' or '.'
; 1049 :             to ensure that we are forced to go "up" all the time */
; 1050 :             tmp_str_len = xmlStrlen(tmp_str);

	push	esi
	call	_xmlStrlen
	add	esp, 4

; 1051 :             if(tmp_str_len > 1 && tmp_str[tmp_str_len - 2] == '.') {

	cmp	eax, 1
	jle	SHORT $LN9@xmlC14NFix
	cmp	BYTE PTR [eax+esi-2], 46		; 0000002eH
	jne	SHORT $LN9@xmlC14NFix

; 1052 :                 tmp_str2 = xmlStrcat(tmp_str, BAD_CAST "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
	push	esi
	call	_xmlStrcat
	add	esp, 8

; 1053 :                 if(tmp_str2 == NULL) {

	test	eax, eax
	je	$LN22@xmlC14NFix

; 1058 :                     return (NULL);
; 1059 :                 }
; 1060 : 
; 1061 :                 tmp_str = tmp_str2;

	mov	esi, eax
$LN9@xmlC14NFix:

; 1062 :             }
; 1063 : 
; 1064 :             /* build uri */
; 1065 :             tmp_str2 = xmlBuildURI(res, tmp_str);

	push	esi
	push	edi
	call	_xmlBuildURI
	add	esp, 8
	mov	ebx, eax

; 1066 :             if(tmp_str2 == NULL) {

	push	esi
	call	DWORD PTR _xmlFree
	push	edi
	call	DWORD PTR _xmlFree
	test	ebx, ebx
	je	$LN23@xmlC14NFix

; 1071 :                 return (NULL);
; 1072 :             }
; 1073 : 
; 1074 :             /* cleanup and set the new res */
; 1075 :             xmlFree(tmp_str);
; 1076 :             xmlFree(res);
; 1077 :             res = tmp_str2;

	mov	edi, ebx
	add	esp, 8
	mov	ebx, DWORD PTR _ctx$[ebp]
$LN7@xmlC14NFix:

; 1078 :         }
; 1079 : 
; 1080 :         /* next */
; 1081 :         cur = cur->parent;

	mov	esi, DWORD PTR tv283[ebp]
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL2@xmlC14NFix
$LN3@xmlC14NFix:

; 1082 :     }
; 1083 : 
; 1084 :     /* check if result uri is empty or not */
; 1085 :     if((res == NULL) || xmlStrEqual(res, BAD_CAST "")) {

	test	edi, edi
	je	$LN13@xmlC14NFix
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN13@xmlC14NFix

; 1087 :         return (NULL);
; 1088 :     }
; 1089 : 
; 1090 :     /* create and return the new attribute node */
; 1091 :     attr = xmlNewNsProp(NULL, xml_base_attr->ns, BAD_CAST "base", res);

	mov	eax, DWORD PTR _xml_base_attr$[ebp]
	push	edi
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [eax+36]
	push	0
	call	_xmlNewNsProp
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1092 :     if(attr == NULL) {

	push	edi
	call	DWORD PTR _xmlFree
	test	esi, esi
	jne	SHORT $LN14@xmlC14NFix

; 1093 :         xmlFree(res);
; 1094 : 
; 1095 :         xmlC14NErrInternal("processing xml:base attribute - can't construct attribute");

	push	OFFSET ??_C@_0DK@HPDOPNJC@processing?5xml?3base?5attribute?5?9@
	call	_xmlC14NErrInternal
	add	esp, 8

; 1096 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlC14NFix:

; 1054 :                     xmlFree(tmp_str);

	push	esi
	call	DWORD PTR _xmlFree

; 1055 :                     xmlFree(res);

	push	edi
	call	DWORD PTR _xmlFree

; 1056 : 
; 1057 :                     xmlC14NErrInternal("processing xml:base attribute - can't modify uri");

	push	OFFSET ??_C@_0DB@PAHKMMOF@processing?5xml?3base?5attribute?5?9@
	call	_xmlC14NErrInternal
	add	esp, 12					; 0000000cH

; 1096 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlC14NFix:

; 1067 :                 xmlFree(tmp_str);
; 1068 :                 xmlFree(res);
; 1069 : 
; 1070 :                 xmlC14NErrInternal("processing xml:base attribute - can't construct uri");

	push	OFFSET ??_C@_0DE@JBJEENHA@processing?5xml?3base?5attribute?5?9@
	call	_xmlC14NErrInternal
	add	esp, 12					; 0000000cH

; 1096 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlC14NFix:

; 1042 :                 xmlFree(res);

	push	edi
	call	DWORD PTR _xmlFree

; 1043 : 
; 1044 :                 xmlC14NErrInternal("processing xml:base attribute - can't get attr value");

	push	OFFSET ??_C@_0DF@JNOKNNOH@processing?5xml?3base?5attribute?5?9@
	call	_xmlC14NErrInternal
	add	esp, 8

; 1096 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlC14NFix:

; 1097 :     }
; 1098 : 
; 1099 :     /* done */
; 1100 :     xmlFree(res);

	add	esp, 4

; 1101 :     return (attr);

	mov	eax, esi
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlC14NFix:

; 1086 :         xmlFree(res);

	push	edi
	call	DWORD PTR _xmlFree

; 1096 :         return (NULL);

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlC14NFix:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BO@CEOJEMPO@processing?5xml?3base?5attribute@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BO@CEOJEMPO@processing?5xml?3base?5attribute@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1023 :         xmlC14NErrParam("processing xml:base attribute");
; 1024 :         return (NULL);

	xor	eax, eax
	pop	esi

; 1102 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NFixupBaseAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NFindHiddenParentAttr
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_name$ = 16						; size = 4
_ns$ = 20						; size = 4
_xmlC14NFindHiddenParentAttr PROC			; COMDAT

; 991  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlC14NFin
	mov	ebx, DWORD PTR _ctx$[ebp]
	npad	6
$LL2@xmlC14NFin:

; 992  :     xmlAttrPtr res;
; 993  :     while((cur != NULL) && (!xmlC14NIsVisible(ctx, cur, cur->parent))) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN3@xmlC14NFin
	push	DWORD PTR [esi+20]
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@xmlC14NFin

; 994  :         res = xmlHasNsProp(cur, name, ns);

	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _name$[ebp]
	push	esi
	call	_xmlHasNsProp
	add	esp, 12					; 0000000cH

; 995  :         if(res != NULL) {

	test	eax, eax
	jne	SHORT $LN1@xmlC14NFin

; 996  :             return res;
; 997  :         }
; 998  : 
; 999  :         cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL2@xmlC14NFin
$LN3@xmlC14NFin:

; 1000 :     }
; 1001 : 
; 1002 :     return NULL;

	xor	eax, eax
$LN1@xmlC14NFin:
	pop	edi

; 1003 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlC14NFindHiddenParentAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NPrintAttrs
_TEXT	SEGMENT
_data$ = 8						; size = 4
_user$ = 12						; size = 4
_xmlC14NPrintAttrs PROC					; COMDAT

; 945  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _data$[ebp]
	test	edi, edi
	je	$LN3@xmlC14NPri

; 946  :     const xmlAttrPtr attr = (const xmlAttrPtr) data;
; 947  :     xmlC14NCtxPtr ctx = (xmlC14NCtxPtr) user;
; 948  :     xmlChar *value;
; 949  :     xmlChar *buffer;
; 950  : 
; 951  :     if ((attr == NULL) || (ctx == NULL)) {

	mov	esi, DWORD PTR _user$[ebp]
	test	esi, esi
	je	$LN3@xmlC14NPri

; 954  :     }
; 955  : 
; 956  :     xmlOutputBufferWriteString(ctx->buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 957  :     if (attr->ns != NULL && xmlStrlen(attr->ns->prefix) > 0) {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlC14NPri
	push	DWORD PTR [eax+12]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN4@xmlC14NPri

; 958  :         xmlOutputBufferWriteString(ctx->buf,

	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 959  :                                    (const char *) attr->ns->prefix);
; 960  :         xmlOutputBufferWriteString(ctx->buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN4@xmlC14NPri:

; 961  :     }
; 962  :     xmlOutputBufferWriteString(ctx->buf, (const char *) attr->name);

	push	ebx
	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 963  :     xmlOutputBufferWriteString(ctx->buf, "=\"");

	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC@
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 964  : 
; 965  :     value = xmlNodeListGetString(ctx->doc, attr->children, 1);

	push	1
	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi]
	call	_xmlNodeListGetString
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 966  :     /* todo: should we log an error if value==NULL ? */
; 967  :     if (value != NULL) {

	test	ebx, ebx
	je	SHORT $LN7@xmlC14NPri

; 968  :         buffer = xmlC11NNormalizeAttr(value);

	push	0
	push	ebx
	call	_xmlC11NNormalizeString

; 969  :         xmlFree(value);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 970  :         if (buffer != NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlC14NPri

; 971  :             xmlOutputBufferWriteString(ctx->buf, (const char *) buffer);

	push	edi
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 972  :             xmlFree(buffer);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN7@xmlC14NPri:

; 976  :         }
; 977  :     }
; 978  :     xmlOutputBufferWriteString(ctx->buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 979  :     return (1);

	mov	eax, 1
	pop	ebx
	pop	edi

; 980  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlC14NPri:

; 973  :         } else {
; 974  :             xmlC14NErrInternal("normalizing attributes axis");

	push	OFFSET ??_C@_0BM@MNCHFEBF@normalizing?5attributes?5axis@
	call	_xmlC14NErrInternal
	add	esp, 4

; 975  :             return (0);

	xor	eax, eax
	pop	ebx
	pop	edi

; 980  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlC14NPri:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BD@DDLFPEHD@writing?5attributes@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BD@DDLFPEHD@writing?5attributes@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 952  :         xmlC14NErrParam("writing attributes");
; 953  :         return (0);

	xor	eax, eax
	pop	edi

; 980  : }

	pop	esi
	pop	ebp
	ret	0
_xmlC14NPrintAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NAttrsCompare
_TEXT	SEGMENT
_data1$ = 8						; size = 4
_data2$ = 12						; size = 4
_xmlC14NAttrsCompare PROC				; COMDAT

; 891  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _data1$[ebp]
	mov	edi, DWORD PTR _data2$[ebp]
	cmp	esi, edi
	jne	SHORT $LN2@xmlC14NAtt

; 892  :     const xmlAttrPtr attr1 = (const xmlAttrPtr) data1;
; 893  :     const xmlAttrPtr attr2 = (const xmlAttrPtr) data2;
; 894  :     int ret = 0;
; 895  : 
; 896  :     /*
; 897  :      * Simple cases
; 898  :      */
; 899  :     if (attr1 == attr2)
; 900  :         return (0);

	pop	edi
	xor	eax, eax

; 925  :         ret = xmlStrcmp(attr1->name, attr2->name);
; 926  :     }
; 927  :     return (ret);
; 928  : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlC14NAtt:

; 901  :     if (attr1 == NULL)

	test	esi, esi
	je	SHORT $LN13@xmlC14NAtt

; 902  :         return (-1);
; 903  :     if (attr2 == NULL)

	test	edi, edi
	je	SHORT $LN12@xmlC14NAtt

; 904  :         return (1);
; 905  :     if (attr1->ns == attr2->ns) {

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [edi+36]
	cmp	eax, ecx
	je	SHORT $LN14@xmlC14NAtt

; 906  :         return (xmlStrcmp(attr1->name, attr2->name));
; 907  :     }
; 908  : 
; 909  :     /*
; 910  :      * Attributes in the default namespace are first
; 911  :      * because the default namespace is not applied to
; 912  :      * unqualified attributes
; 913  :      */
; 914  :     if (attr1->ns == NULL)

	test	eax, eax
	je	SHORT $LN13@xmlC14NAtt

; 915  :         return (-1);
; 916  :     if (attr2->ns == NULL)

	test	ecx, ecx
	je	SHORT $LN12@xmlC14NAtt

; 917  :         return (1);
; 918  :     if (attr1->ns->prefix == NULL)

	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN13@xmlC14NAtt

; 920  :     if (attr2->ns->prefix == NULL)

	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN12@xmlC14NAtt

; 922  : 
; 923  :     ret = xmlStrcmp(attr1->ns->href, attr2->ns->href);

	push	DWORD PTR [ecx+8]
	push	DWORD PTR [eax+8]
	call	_xmlStrcmp
	add	esp, 8

; 924  :     if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN1@xmlC14NAtt
$LN14@xmlC14NAtt:

; 925  :         ret = xmlStrcmp(attr1->name, attr2->name);
; 926  :     }
; 927  :     return (ret);
; 928  : }

	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+8]
	call	_xmlStrcmp
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlC14NAtt:
	pop	edi

; 921  :         return (1);

	mov	eax, 1

; 925  :         ret = xmlStrcmp(attr1->name, attr2->name);
; 926  :     }
; 927  :     return (ret);
; 928  : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlC14NAtt:

; 919  :         return (-1);

	or	eax, -1
$LN1@xmlC14NAtt:
	pop	edi

; 925  :         ret = xmlStrcmp(attr1->name, attr2->name);
; 926  :     }
; 927  :     return (ret);
; 928  : }

	pop	esi
	pop	ebp
	ret	0
_xmlC14NAttrsCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NIsXmlAttr
_TEXT	SEGMENT
_attr$ = 8						; size = 4
_xmlC14NIsXmlAttr PROC					; COMDAT

; 874  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _attr$[ebp]
	mov	esi, DWORD PTR [eax+36]
	test	esi, esi
	je	SHORT $LN3@xmlC14NIsX

; 501  :     return ((ns != NULL) &&

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlC14NIsX
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlC14NIsX

; 875  :     return ((attr->ns != NULL) &&

	mov	eax, 1
	pop	esi

; 876  :            (xmlC14NIsXmlNs(attr->ns) != 0));
; 877  : }

	pop	ebp
	ret	0
$LN3@xmlC14NIsX:

; 875  :     return ((attr->ns != NULL) &&

	xor	eax, eax
	pop	esi

; 876  :            (xmlC14NIsXmlNs(attr->ns) != 0));
; 877  : }

	pop	ebp
	ret	0
_xmlC14NIsXmlAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlExcC14NProcessNamespacesAxis
_TEXT	SEGMENT
_already_rendered$1$ = -20				; size = 4
_i$1$ = -16						; size = 4
_has_empty_ns_in_inclusive_list$1$ = -12		; size = 4
_has_visibly_utilized_empty_ns$1$ = -8			; size = 4
_has_empty_ns$1$ = -4					; size = 4
_list$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_visible$ = 16						; size = 4
_xmlExcC14NProcessNamespacesAxis PROC			; COMDAT

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _has_empty_ns$1$[ebp], 0
	mov	DWORD PTR _has_visibly_utilized_empty_ns$1$[ebp], 0
	mov	DWORD PTR _has_empty_ns_in_inclusive_list$1$[ebp], 0
	test	ebx, ebx
	je	$LN9@xmlExcC14N

; 717  :     xmlNsPtr ns;
; 718  :     xmlListPtr list;
; 719  :     xmlAttrPtr attr;
; 720  :     int already_rendered;
; 721  :     int has_empty_ns = 0;
; 722  :     int has_visibly_utilized_empty_ns = 0;
; 723  :     int has_empty_ns_in_inclusive_list = 0;
; 724  : 
; 725  :     if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN9@xmlExcC14N
	cmp	DWORD PTR [edi+4], 1
	jne	$LN9@xmlExcC14N

; 726  :         xmlC14NErrParam("processing namespaces axis (exc c14n)");
; 727  :         return (-1);
; 728  :     }
; 729  : 
; 730  :     if(!xmlC14NIsExclusive(ctx)) {

	cmp	DWORD PTR [ebx+32], 1
	je	SHORT $LN10@xmlExcC14N

; 731  :         xmlC14NErrParam("processing namespaces axis (exc c14n)");

	push	OFFSET ??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@
	call	_xmlC14NErrParam
	add	esp, 4

; 858  : }

	or	eax, -1
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlExcC14N:

; 732  :         return (-1);
; 733  : 
; 734  :     }
; 735  : 
; 736  :     /*
; 737  :      * Create a sorted list to store element namespaces
; 738  :      */
; 739  :     list = xmlListCreate(NULL, xmlC14NNsCompare);

	push	OFFSET _xmlC14NNsCompare
	push	0
	call	_xmlListCreate
	add	esp, 8
	mov	DWORD PTR _list$1$[ebp], eax

; 740  :     if (list == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlExcC14N

; 741  :         xmlC14NErrInternal("creating namespaces list (exc c14n)");

	push	OFFSET ??_C@_0CE@OPHJGGNE@creating?5namespaces?5list?5?$CIexc?5c@
	call	_xmlC14NErrInternal
	add	esp, 4

; 858  : }

	or	eax, -1
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlExcC14N:

; 742  :         return (-1);
; 743  :     }
; 744  : 
; 745  :     /*
; 746  :      * process inclusive namespaces:
; 747  :      * All namespace nodes appearing on inclusive ns list are
; 748  :      * handled as provided in Canonical XML
; 749  :      */
; 750  :     if(ctx->inclusive_ns_prefixes != NULL) {

	mov	eax, DWORD PTR [ebx+36]
	push	esi
	test	eax, eax
	je	$LN3@xmlExcC14N

; 751  : 	xmlChar *prefix;
; 752  : 	int i;
; 753  : 
; 754  : 	for (i = 0; ctx->inclusive_ns_prefixes[i] != NULL; ++i) {

	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR _i$1$[ebp], 0
	je	$LN3@xmlExcC14N
	xor	ecx, ecx
	npad	3
$LL4@xmlExcC14N:

; 755  : 	    prefix = ctx->inclusive_ns_prefixes[i];

	mov	esi, DWORD PTR [ecx+eax]

; 756  : 	    /*
; 757  : 	     * Special values for namespace with empty prefix
; 758  : 	     */
; 759  :             if (xmlStrEqual(prefix, BAD_CAST "#default")
; 760  :                 || xmlStrEqual(prefix, BAD_CAST "")) {

	push	OFFSET ??_C@_08DCFPEJG@?$CDdefault@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlExcC14N
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlExcC14N
$LN14@xmlExcC14N:

; 761  :                 prefix = NULL;

	xor	esi, esi

; 762  : 		has_empty_ns_in_inclusive_list = 1;

	mov	DWORD PTR _has_empty_ns_in_inclusive_list$1$[ebp], 1
$LN13@xmlExcC14N:

; 763  :             }
; 764  : 
; 765  : 	    ns = xmlSearchNs(cur->doc, cur, prefix);

	push	esi
	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlSearchNs
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 766  : 	    if((ns != NULL) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {

	test	esi, esi
	je	SHORT $LN2@xmlExcC14N
	push	esi
	call	_xmlC14NIsXmlNs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlExcC14N
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN53@xmlExcC14N
	push	edi
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlExcC14N
$LN53@xmlExcC14N:

; 767  : 		already_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);

	push	esi
	push	DWORD PTR [ebx+28]
	call	_xmlC14NVisibleNsStackFind
	add	esp, 8
	mov	DWORD PTR _already_rendered$1$[ebp], eax

; 768  : 		if(visible) {

	cmp	DWORD PTR _visible$[ebp], 0
	je	SHORT $LN16@xmlExcC14N

; 769  : 		    xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);

	push	edi
	push	esi
	push	DWORD PTR [ebx+28]
	call	_xmlC14NVisibleNsStackAdd
	mov	eax, DWORD PTR _already_rendered$1$[ebp]
	add	esp, 12					; 0000000cH
$LN16@xmlExcC14N:

; 770  : 		}
; 771  : 		if(!already_rendered) {

	test	eax, eax
	jne	SHORT $LN17@xmlExcC14N

; 772  : 		    xmlListInsert(list, ns);

	push	esi
	push	DWORD PTR _list$1$[ebp]
	call	_xmlListInsert
	add	esp, 8
$LN17@xmlExcC14N:

; 773  : 		}
; 774  : 		if(xmlStrlen(ns->prefix) == 0) {

	push	DWORD PTR [esi+12]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _has_empty_ns$1$[ebp]
	add	esp, 4
	test	eax, eax
	mov	eax, 1
	cmove	ecx, eax
	mov	DWORD PTR _has_empty_ns$1$[ebp], ecx
$LN2@xmlExcC14N:

; 751  : 	xmlChar *prefix;
; 752  : 	int i;
; 753  : 
; 754  : 	for (i = 0; ctx->inclusive_ns_prefixes[i] != NULL; ++i) {

	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [ebx+36]
	cmp	DWORD PTR [ecx+eax], 0
	jne	$LL4@xmlExcC14N
$LN3@xmlExcC14N:

; 775  : 		    has_empty_ns = 1;
; 776  : 		}
; 777  : 	    }
; 778  : 	}
; 779  :     }
; 780  : 
; 781  :     /* add node namespace */
; 782  :     if(cur->ns != NULL) {

	mov	esi, DWORD PTR [edi+36]
	test	esi, esi
	jne	SHORT $LN65@xmlExcC14N

; 783  : 	ns = cur->ns;
; 784  :     } else {
; 785  :         ns = xmlSearchNs(cur->doc, cur, NULL);

	push	esi
	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlSearchNs
	mov	esi, eax

; 786  : 	has_visibly_utilized_empty_ns = 1;

	mov	DWORD PTR _has_visibly_utilized_empty_ns$1$[ebp], 1
	add	esp, 12					; 0000000cH

; 787  :     }
; 788  :     if((ns != NULL) && !xmlC14NIsXmlNs(ns)) {

	test	esi, esi
	je	SHORT $LN62@xmlExcC14N
$LN65@xmlExcC14N:
	push	esi
	call	_xmlC14NIsXmlNs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN62@xmlExcC14N

; 789  : 	if(visible && xmlC14NIsVisible(ctx, ns, cur)) {

	cmp	DWORD PTR _visible$[ebp], eax
	je	SHORT $LN24@xmlExcC14N
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN54@xmlExcC14N
	push	edi
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@xmlExcC14N
$LN54@xmlExcC14N:

; 790  : 	    if(!xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, ns, ctx)) {

	push	ebx
	push	esi
	push	DWORD PTR [ebx+28]
	call	_xmlExcC14NVisibleNsStackFind
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@xmlExcC14N

; 791  : 		xmlListInsert(list, ns);

	push	esi
	push	DWORD PTR _list$1$[ebp]
	call	_xmlListInsert
	add	esp, 8
$LN23@xmlExcC14N:

; 792  : 	    }
; 793  : 	}
; 794  : 	if(visible) {
; 795  : 	    xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);

	push	edi
	push	esi
	push	DWORD PTR [ebx+28]
	call	_xmlC14NVisibleNsStackAdd
	add	esp, 12					; 0000000cH
$LN24@xmlExcC14N:

; 796  : 	}
; 797  : 	if(xmlStrlen(ns->prefix) == 0) {

	push	DWORD PTR [esi+12]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _has_empty_ns$1$[ebp]
	add	esp, 4
	test	eax, eax
	mov	eax, 1
	cmove	ecx, eax
	mov	DWORD PTR _has_empty_ns$1$[ebp], ecx
	jmp	SHORT $LN25@xmlExcC14N
$LN62@xmlExcC14N:

; 798  : 	    has_empty_ns = 1;
; 799  : 	}
; 800  :     }
; 801  : 
; 802  : 
; 803  :     /* add attributes */
; 804  :     for(attr = cur->properties; attr != NULL; attr = attr->next) {

	mov	ecx, DWORD PTR _has_empty_ns$1$[ebp]
$LN25@xmlExcC14N:
	mov	edi, DWORD PTR [edi+44]
	test	edi, edi
	je	$LN6@xmlExcC14N
	mov	esi, DWORD PTR _cur$[ebp]
$LL7@xmlExcC14N:

; 805  :         /*
; 806  :          * we need to check that attribute is visible and has non
; 807  :          * default namespace (XML Namespaces: "default namespaces
; 808  : 	 * do not apply directly to attributes")
; 809  :          */
; 810  : 	if((attr->ns != NULL) && !xmlC14NIsXmlNs(attr->ns) && xmlC14NIsVisible(ctx, attr, cur)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN26@xmlExcC14N
	push	eax
	call	_xmlC14NIsXmlNs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@xmlExcC14N
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN55@xmlExcC14N
	push	esi
	push	edi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@xmlExcC14N
$LN55@xmlExcC14N:

; 811  : 	    already_rendered = xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, attr->ns, ctx);

	push	ebx
	push	DWORD PTR [edi+36]
	push	DWORD PTR [ebx+28]
	call	_xmlExcC14NVisibleNsStackFind

; 812  : 	    xmlC14NVisibleNsStackAdd(ctx->ns_rendered, attr->ns, cur);

	push	DWORD PTR _cur$[ebp]
	mov	esi, eax
	push	DWORD PTR [edi+36]
	push	DWORD PTR [ebx+28]
	call	_xmlC14NVisibleNsStackAdd
	add	esp, 24					; 00000018H

; 813  : 	    if(!already_rendered && visible) {

	test	esi, esi
	jne	SHORT $LN28@xmlExcC14N
	cmp	DWORD PTR _visible$[ebp], esi
	je	SHORT $LN28@xmlExcC14N

; 814  : 		xmlListInsert(list, attr->ns);

	push	DWORD PTR [edi+36]
	push	DWORD PTR _list$1$[ebp]
	call	_xmlListInsert
	add	esp, 8
$LN28@xmlExcC14N:

; 815  : 	    }
; 816  : 	    if(xmlStrlen(attr->ns->prefix) == 0) {

	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+12]
	call	_xmlStrlen
	mov	esi, DWORD PTR _cur$[ebp]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN60@xmlExcC14N

; 817  : 		has_empty_ns = 1;

	mov	ecx, 1
	mov	DWORD PTR _has_empty_ns$1$[ebp], ecx

; 818  : 	    }

	jmp	SHORT $LN5@xmlExcC14N
$LN26@xmlExcC14N:

; 819  : 	} else if((attr->ns != NULL) && (xmlStrlen(attr->ns->prefix) == 0) && (xmlStrlen(attr->ns->href) == 0)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN60@xmlExcC14N
	push	DWORD PTR [eax+12]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN60@xmlExcC14N
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _has_visibly_utilized_empty_ns$1$[ebp]
	add	esp, 4
	test	eax, eax
	mov	eax, 1
	cmove	ecx, eax
	mov	DWORD PTR _has_visibly_utilized_empty_ns$1$[ebp], ecx
$LN60@xmlExcC14N:

; 798  : 	    has_empty_ns = 1;
; 799  : 	}
; 800  :     }
; 801  : 
; 802  : 
; 803  :     /* add attributes */
; 804  :     for(attr = cur->properties; attr != NULL; attr = attr->next) {

	mov	ecx, DWORD PTR _has_empty_ns$1$[ebp]
$LN5@xmlExcC14N:
	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	$LL7@xmlExcC14N
$LN6@xmlExcC14N:

; 820  : 	    has_visibly_utilized_empty_ns = 1;
; 821  : 	}
; 822  :     }
; 823  : 
; 824  :     /*
; 825  :      * Process xmlns=""
; 826  :      */
; 827  :     if(visible && has_visibly_utilized_empty_ns &&
; 828  : 	    !has_empty_ns && !has_empty_ns_in_inclusive_list) {

	cmp	DWORD PTR _visible$[ebp], 0
	pop	esi
	je	SHORT $LN35@xmlExcC14N
	test	ecx, ecx
	jne	SHORT $LN35@xmlExcC14N
	cmp	DWORD PTR _has_visibly_utilized_empty_ns$1$[ebp], ecx
	je	SHORT $LN31@xmlExcC14N
	cmp	DWORD PTR _has_empty_ns_in_inclusive_list$1$[ebp], ecx
	jne	SHORT $LN57@xmlExcC14N

; 829  :         static xmlNs ns_default;
; 830  : 
; 831  :         memset(&ns_default, 0, sizeof(ns_default));
; 832  : 
; 833  :         already_rendered = xmlExcC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default, ctx);

	xorps	xmm0, xmm0
	push	ebx
	movups	XMMWORD PTR ?ns_default@?BL@??xmlExcC14NProcessNamespacesAxis@@9@9, xmm0
	push	OFFSET ?ns_default@?BL@??xmlExcC14NProcessNamespacesAxis@@9@9
	movq	QWORD PTR ?ns_default@?BL@??xmlExcC14NProcessNamespacesAxis@@9@9+16, xmm0
	push	DWORD PTR [ebx+28]
	call	_xmlExcC14NVisibleNsStackFind
	add	esp, 12					; 0000000cH

; 834  : 	if(!already_rendered) {

	test	eax, eax
	jne	SHORT $LN35@xmlExcC14N

; 835  : 	    xmlC14NPrintNamespaces(&ns_default, ctx);

	push	ebx
	push	OFFSET ?ns_default@?BL@??xmlExcC14NProcessNamespacesAxis@@9@9

; 836  : 	}

	jmp	SHORT $LN66@xmlExcC14N
$LN31@xmlExcC14N:

; 837  :     } else if(visible && !has_empty_ns && has_empty_ns_in_inclusive_list) {

	cmp	DWORD PTR _has_empty_ns_in_inclusive_list$1$[ebp], 0
	je	SHORT $LN35@xmlExcC14N
$LN57@xmlExcC14N:
	xorps	xmm0, xmm0

; 838  :         static xmlNs ns_default;
; 839  : 
; 840  :         memset(&ns_default, 0, sizeof(ns_default));

	movups	XMMWORD PTR ?ns_default@?BN@??xmlExcC14NProcessNamespacesAxis@@9@9, xmm0

; 841  :         if(!xmlC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default)) {

	push	OFFSET ?ns_default@?BN@??xmlExcC14NProcessNamespacesAxis@@9@9
	movq	QWORD PTR ?ns_default@?BN@??xmlExcC14NProcessNamespacesAxis@@9@9+16, xmm0
	push	DWORD PTR [ebx+28]
	call	_xmlC14NVisibleNsStackFind
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@xmlExcC14N

; 842  : 	    xmlC14NPrintNamespaces(&ns_default, ctx);

	push	ebx
	push	OFFSET ?ns_default@?BN@??xmlExcC14NProcessNamespacesAxis@@9@9
$LN66@xmlExcC14N:

; 843  : 	}
; 844  :     }
; 845  : 
; 846  : 
; 847  : 
; 848  :     /*
; 849  :      * print out all elements from list
; 850  :      */
; 851  :     xmlListWalk(list, xmlC14NPrintNamespacesWalker, (void *) ctx);

	call	_xmlC14NPrintNamespaces
	add	esp, 8
$LN35@xmlExcC14N:
	push	ebx
	mov	ebx, DWORD PTR _list$1$[ebp]
	push	OFFSET _xmlC14NPrintNamespacesWalker
	push	ebx
	call	_xmlListWalk

; 852  : 
; 853  :     /*
; 854  :      * Cleanup
; 855  :      */
; 856  :     xmlListDelete(list);

	push	ebx
	call	_xmlListDelete
	add	esp, 16					; 00000010H

; 857  :     return (0);

	xor	eax, eax
	pop	edi

; 858  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlExcC14N:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CG@HFJHEOJE@processing?5namespaces?5axis?5?$CIexc@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 858  : }

	or	eax, -1
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExcC14NProcessNamespacesAxis ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NProcessNamespacesAxis
_TEXT	SEGMENT
_already_rendered$1$ = -12				; size = 4
_list$1$ = -8						; size = 4
_has_empty_ns$1$ = -4					; size = 4
_n$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_visible$ = 16						; size = 4
_xmlC14NProcessNamespacesAxis PROC			; COMDAT

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	xor	eax, eax
	mov	DWORD PTR _has_empty_ns$1$[ebp], eax
	test	edi, edi
	je	$LN9@xmlC14NPro

; 612  :     xmlNodePtr n;
; 613  :     xmlNsPtr ns, tmp;
; 614  :     xmlListPtr list;
; 615  :     int already_rendered;
; 616  :     int has_empty_ns = 0;
; 617  : 
; 618  :     if ((ctx == NULL) || (cur == NULL) || (cur->type != XML_ELEMENT_NODE)) {

	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN9@xmlC14NPro
	cmp	DWORD PTR [ebx+4], 1
	jne	$LN9@xmlC14NPro

; 619  :         xmlC14NErrParam("processing namespaces axis (c14n)");
; 620  :         return (-1);
; 621  :     }
; 622  : 
; 623  :     /*
; 624  :      * Create a sorted list to store element namespaces
; 625  :      */
; 626  :     list = xmlListCreate(NULL, xmlC14NNsCompare);

	push	OFFSET _xmlC14NNsCompare
	push	eax
	call	_xmlListCreate
	add	esp, 8
	mov	DWORD PTR _list$1$[ebp], eax

; 627  :     if (list == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlC14NPro

; 628  :         xmlC14NErrInternal("creating namespaces list (c14n)");

	push	OFFSET ??_C@_0CA@IIFGGKIF@creating?5namespaces?5list?5?$CIc14n?$CJ@
	call	_xmlC14NErrInternal
	add	esp, 4

; 681  : }

	or	eax, -1
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlC14NPro:

; 629  :         return (-1);
; 630  :     }
; 631  : 
; 632  :     /* check all namespaces */
; 633  :     for(n = cur; n != NULL; n = n->parent) {

	mov	eax, ebx
	mov	DWORD PTR _n$1$[ebp], eax
	push	esi
	npad	8
$LL4@xmlC14NPro:

; 634  : 	for(ns = n->nsDef; ns != NULL; ns = ns->next) {

	mov	esi, DWORD PTR [eax+48]
	test	esi, esi
	je	$LN2@xmlC14NPro
	npad	5
$LL7@xmlC14NPro:

; 635  : 	    tmp = xmlSearchNs(cur->doc, cur, ns->prefix);

	push	DWORD PTR [esi+12]
	push	ebx
	push	DWORD PTR [ebx+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 636  : 
; 637  : 	    if((tmp == ns) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {

	cmp	eax, esi
	jne	$LN5@xmlC14NPro

; 501  :     return ((ns != NULL) &&

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlC14NPro
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlC14NPro
$LN24@xmlC14NPro:

; 636  : 
; 637  : 	    if((tmp == ns) && !xmlC14NIsXmlNs(ns) && xmlC14NIsVisible(ctx, ns, cur)) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN34@xmlC14NPro
	push	ebx
	push	esi
	push	DWORD PTR [edi+8]
	call	eax
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@xmlC14NPro
$LN34@xmlC14NPro:

; 638  : 		already_rendered = xmlC14NVisibleNsStackFind(ctx->ns_rendered, ns);

	push	esi
	push	DWORD PTR [edi+28]
	call	_xmlC14NVisibleNsStackFind
	add	esp, 8
	mov	DWORD PTR _already_rendered$1$[ebp], eax

; 639  : 		if(visible) {

	cmp	DWORD PTR _visible$[ebp], 0
	je	SHORT $LN12@xmlC14NPro

; 640  : 	    xmlC14NVisibleNsStackAdd(ctx->ns_rendered, ns, cur);

	push	ebx
	push	esi
	push	DWORD PTR [edi+28]
	call	_xmlC14NVisibleNsStackAdd
	mov	eax, DWORD PTR _already_rendered$1$[ebp]
	add	esp, 12					; 0000000cH
$LN12@xmlC14NPro:

; 641  : 		}
; 642  : 		if(!already_rendered) {

	test	eax, eax
	jne	SHORT $LN13@xmlC14NPro

; 643  : 		    xmlListInsert(list, ns);

	push	esi
	push	DWORD PTR _list$1$[ebp]
	call	_xmlListInsert
	add	esp, 8
$LN13@xmlC14NPro:

; 644  : 		}
; 645  : 		if(xmlStrlen(ns->prefix) == 0) {

	push	DWORD PTR [esi+12]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _has_empty_ns$1$[ebp]
	add	esp, 4
	test	eax, eax
	mov	eax, 1
	cmove	ecx, eax
	mov	DWORD PTR _has_empty_ns$1$[ebp], ecx
$LN5@xmlC14NPro:

; 634  : 	for(ns = n->nsDef; ns != NULL; ns = ns->next) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL7@xmlC14NPro
	mov	eax, DWORD PTR _n$1$[ebp]
$LN2@xmlC14NPro:

; 629  :         return (-1);
; 630  :     }
; 631  : 
; 632  :     /* check all namespaces */
; 633  :     for(n = cur; n != NULL; n = n->parent) {

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _n$1$[ebp], eax
	test	eax, eax
	jne	$LL4@xmlC14NPro

; 646  : 		    has_empty_ns = 1;
; 647  : 		}
; 648  : 	    }
; 649  : 	}
; 650  :     }
; 651  : 
; 652  :     /**
; 653  :      * if the first node is not the default namespace node (a node with no
; 654  :      * namespace URI and no local name), then generate a space followed by
; 655  :      * xmlns="" if and only if the following conditions are met:
; 656  :      *  - the element E that owns the axis is in the node-set
; 657  :      *  - the nearest ancestor element of E in the node-set has a default
; 658  :      *     namespace node in the node-set (default namespace nodes always
; 659  :      *     have non-empty values in XPath)
; 660  :      */
; 661  :     if(visible && !has_empty_ns) {

	pop	esi
	cmp	DWORD PTR _visible$[ebp], eax
	je	SHORT $LN16@xmlC14NPro
	cmp	DWORD PTR _has_empty_ns$1$[ebp], eax
	jne	SHORT $LN16@xmlC14NPro

; 662  :         static xmlNs ns_default;
; 663  : 
; 664  :         memset(&ns_default, 0, sizeof(ns_default));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR ?ns_default@?N@??xmlC14NProcessNamespacesAxis@@9@9, xmm0

; 665  :         if(!xmlC14NVisibleNsStackFind(ctx->ns_rendered, &ns_default)) {

	push	OFFSET ?ns_default@?N@??xmlC14NProcessNamespacesAxis@@9@9
	movq	QWORD PTR ?ns_default@?N@??xmlC14NProcessNamespacesAxis@@9@9+16, xmm0
	push	DWORD PTR [edi+28]
	call	_xmlC14NVisibleNsStackFind
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlC14NPro

; 666  : 	    xmlC14NPrintNamespaces(&ns_default, ctx);

	push	edi
	push	OFFSET ?ns_default@?N@??xmlC14NProcessNamespacesAxis@@9@9
	call	_xmlC14NPrintNamespaces
	add	esp, 8
$LN16@xmlC14NPro:

; 667  : 	}
; 668  :     }
; 669  : 
; 670  : 
; 671  :     /*
; 672  :      * print out all elements from list
; 673  :      */
; 674  :     xmlListWalk(list, xmlC14NPrintNamespacesWalker, (void *) ctx);

	mov	ebx, DWORD PTR _list$1$[ebp]
	push	edi
	push	OFFSET _xmlC14NPrintNamespacesWalker
	push	ebx
	call	_xmlListWalk

; 675  : 
; 676  :     /*
; 677  :      * Cleanup
; 678  :      */
; 679  :     xmlListDelete(list);

	push	ebx
	call	_xmlListDelete
	add	esp, 16					; 00000010H

; 680  :     return (0);

	xor	eax, eax
	pop	edi

; 681  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0CC@LGNLNPPM@processing?5namespaces?5axis?5?$CIc14@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CC@LGNLNPPM@processing?5namespaces?5axis?5?$CIc14@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 681  : }

	or	eax, -1
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NProcessNamespacesAxis ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NPrintNamespacesWalker
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlC14NPrintNamespacesWalker PROC			; COMDAT

; 566  : xmlC14NPrintNamespacesWalker(const void *ns, void *ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4

; 568  : }

	pop	ebp

; 567  :     return xmlC14NPrintNamespaces((const xmlNsPtr) ns, (xmlC14NCtxPtr) ctx);

	jmp	_xmlC14NPrintNamespaces
_xmlC14NPrintNamespacesWalker ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NPrintNamespaces
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlC14NPrintNamespaces PROC				; COMDAT

; 543  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlC14NPri

; 544  : 
; 545  :     if ((ns == NULL) || (ctx == NULL)) {

	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlC14NPri

; 548  :     }
; 549  : 
; 550  :     if (ns->prefix != NULL) {

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN4@xmlC14NPri

; 551  :         xmlOutputBufferWriteString(ctx->buf, " xmlns:");

	push	OFFSET ??_C@_07PMGDNCAE@?5xmlns?3@
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString

; 552  :         xmlOutputBufferWriteString(ctx->buf, (const char *) ns->prefix);

	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+16]
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H

; 553  :         xmlOutputBufferWriteString(ctx->buf, "=");

	mov	eax, OFFSET ??_C@_01NEMOKFLO@?$DN@

; 554  :     } else {

	jmp	SHORT $LN5@xmlC14NPri
$LN4@xmlC14NPri:

; 555  :         xmlOutputBufferWriteString(ctx->buf, " xmlns=");

	mov	eax, OFFSET ??_C@_07LDCCEEMD@?5xmlns?$DN@
$LN5@xmlC14NPri:

; 556  :     }
; 557  :     if(ns->href != NULL) {

	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_xmlOutputBufferWriteString
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 8
	mov	eax, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN6@xmlC14NPri

; 558  : 	xmlBufWriteQuotedString(ctx->buf->buffer, ns->href);

	push	ecx
	push	DWORD PTR [eax+16]
	call	_xmlBufWriteQuotedString

; 561  :     }
; 562  :     return (1);

	add	esp, 8
	mov	eax, 1
	pop	edi

; 563  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlC14NPri:

; 559  :     } else {
; 560  :     	xmlOutputBufferWriteString(ctx->buf, "\"\"");

	push	OFFSET ??_C@_02JMMFPCED@?$CC?$CC@
	push	eax
	call	_xmlOutputBufferWriteString

; 561  :     }
; 562  :     return (1);

	add	esp, 8
	mov	eax, 1
	pop	edi

; 563  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlC14NPri:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BD@MCMJLIHF@writing?5namespaces@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BD@MCMJLIHF@writing?5namespaces@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 546  :         xmlC14NErrParam("writing namespaces");
; 547  :         return 0;

	xor	eax, eax
	pop	edi

; 563  : }

	pop	esi
	pop	ebp
	ret	0
_xmlC14NPrintNamespaces ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NNsCompare
_TEXT	SEGMENT
_data1$ = 8						; size = 4
_data2$ = 12						; size = 4
_xmlC14NNsCompare PROC					; COMDAT

; 518  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _data1$[ebp]
	mov	ecx, DWORD PTR _data2$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN2@xmlC14NNsC

; 519  :     const xmlNsPtr ns1 = (const xmlNsPtr) data1;
; 520  :     const xmlNsPtr ns2 = (const xmlNsPtr) data2;
; 521  :     if (ns1 == ns2)
; 522  :         return (0);

	xor	eax, eax

; 529  : }

	pop	ebp
	ret	0
$LN2@xmlC14NNsC:

; 523  :     if (ns1 == NULL)

	test	eax, eax
	jne	SHORT $LN3@xmlC14NNsC

; 524  :         return (-1);

	or	eax, -1

; 529  : }

	pop	ebp
	ret	0
$LN3@xmlC14NNsC:

; 525  :     if (ns2 == NULL)

	test	ecx, ecx
	jne	SHORT $LN4@xmlC14NNsC

; 526  :         return (1);

	mov	eax, 1

; 529  : }

	pop	ebp
	ret	0
$LN4@xmlC14NNsC:

; 527  : 
; 528  :     return (xmlStrcmp(ns1->prefix, ns2->prefix));

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [eax+12]
	call	_xmlStrcmp
	add	esp, 8

; 529  : }

	pop	ebp
	ret	0
_xmlC14NNsCompare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NIsXmlNs
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_xmlC14NIsXmlNs PROC					; COMDAT

; 500  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ns$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlC14NIsX

; 501  :     return ((ns != NULL) &&

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlC14NIsX
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlC14NIsX
	mov	eax, 1
	pop	esi

; 502  :             (xmlStrEqual(ns->prefix, BAD_CAST "xml")) &&
; 503  :             (xmlStrEqual(ns->href, XML_XML_NAMESPACE)));
; 504  : }

	pop	ebp
	ret	0
$LN3@xmlC14NIsX:

; 501  :     return ((ns != NULL) &&

	xor	eax, eax
	pop	esi

; 502  :             (xmlStrEqual(ns->prefix, BAD_CAST "xml")) &&
; 503  :             (xmlStrEqual(ns->href, XML_XML_NAMESPACE)));
; 504  : }

	pop	ebp
	ret	0
_xmlC14NIsXmlNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NStrEqual
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlC14NStrEqual PROC					; COMDAT

; 394  : xmlC14NStrEqual(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	edx, ecx
	je	SHORT $LN12@xmlC14NStr

; 395  :     if (str1 == str2) return(1);
; 396  :     if (str1 == NULL) return((*str2) == '\0');

	test	edx, edx
	jne	SHORT $LN6@xmlC14NStr
	xor	eax, eax
	cmp	BYTE PTR [ecx], al
	pop	ebx
	sete	al

; 402  : }

	pop	ebp
	ret	0
$LN6@xmlC14NStr:

; 397  :     if (str2 == NULL) return((*str1) == '\0');

	test	ecx, ecx
	jne	SHORT $LL4@xmlC14NStr
	xor	eax, eax
	cmp	BYTE PTR [edx], al
	pop	ebx
	sete	al

; 402  : }

	pop	ebp
	ret	0
$LL4@xmlC14NStr:

; 398  :     do {
; 399  : 	if (*str1++ != *str2) return(0);

	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	bl, BYTE PTR [ecx]
	cmp	al, bl
	jne	SHORT $LN11@xmlC14NStr

; 400  :     } while (*str2++);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlC14NStr
$LN12@xmlC14NStr:

; 401  :     return(1);

	mov	eax, 1
	pop	ebx

; 402  : }

	pop	ebp
	ret	0
$LN11@xmlC14NStr:

; 398  :     do {
; 399  : 	if (*str1++ != *str2) return(0);

	xor	eax, eax
	pop	ebx

; 402  : }

	pop	ebp
	ret	0
_xmlC14NStrEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_xmlC14NErr PROC					; COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlC14NErr

; 239  :     if (ctxt != NULL)
; 240  :         ctxt->error = error;

	mov	DWORD PTR [eax+40], ecx
$LN2@xmlC14NErr:

; 241  :     __xmlRaiseError(NULL, NULL, NULL,

	push	DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	ecx
	push	21					; 00000015H
	push	DWORD PTR _node$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 242  : 		    ctxt, node, XML_FROM_C14N, error,
; 243  : 		    XML_ERR_ERROR, NULL, 0,
; 244  : 		    NULL, NULL, NULL, 0, 0, "%s", msg);
; 245  : }

	pop	ebp
	ret	0
_xmlC14NErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrRelativeNamespace
_TEXT	SEGMENT
_ns_uri$ = 8						; size = 4
_xmlC14NErrRelativeNamespace PROC			; COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _ns_uri$[ebp]
	push	OFFSET ??_C@_0CM@HOAPKNKJ@Relative?5namespace?5UR?5is?5invali@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1955					; 000007a3H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 217  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 218  : 		    XML_C14N_RELATIVE_NAMESPACE, XML_ERR_ERROR, NULL, 0, NULL,
; 219  : 		    NULL, NULL, 0, 0,
; 220  : 		    "Relative namespace UR is invalid here : %s\n", ns_uri);
; 221  : }

	pop	ebp
	ret	0
_xmlC14NErrRelativeNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrUnknownNode
_TEXT	SEGMENT
_node_type$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlC14NErrUnknownNode PROC				; COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	DWORD PTR _node_type$[ebp]
	push	OFFSET ??_C@_0CB@LPHDJOLE@Unknown?5node?5type?5?$CFd?5found?5?3?5?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	1954					; 000007a2H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 202  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 203  : 		    XML_C14N_UNKNOW_NODE, XML_ERR_ERROR, NULL, 0, extra,
; 204  : 		    NULL, NULL, 0, 0,
; 205  : 		    "Unknown node type %d found : %s\n", node_type, extra);
; 206  : }

	pop	ebp
	ret	0
_xmlC14NErrUnknownNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrInvalidNode
_TEXT	SEGMENT
_node_type$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlC14NErrInvalidNode PROC				; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	DWORD PTR _node_type$[ebp]
	push	OFFSET ??_C@_0BO@DIKCFALP@Node?5?$CFs?5is?5invalid?5here?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	1953					; 000007a1H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 187  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 188  : 		    XML_C14N_INVALID_NODE, XML_ERR_ERROR, NULL, 0, extra,
; 189  : 		    NULL, NULL, 0, 0,
; 190  : 		    "Node %s is invalid here : %s\n", node_type, extra);
; 191  : }

	pop	ebp
	ret	0
_xmlC14NErrInvalidNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrInternal
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlC14NErrInternal PROC				; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@KAEIDNN@Internal?5error?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 172  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 173  : 		    XML_ERR_INTERNAL_ERROR, XML_ERR_ERROR, NULL, 0, extra,
; 174  : 		    NULL, NULL, 0, 0,
; 175  : 		    "Internal error : %s\n", extra);
; 176  : }

	pop	ebp
	ret	0
_xmlC14NErrInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrParam
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlC14NErrParam PROC					; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 158  : 		    XML_ERR_INTERNAL_ERROR, XML_ERR_ERROR, NULL, 0, extra,
; 159  : 		    NULL, NULL, 0, 0,
; 160  : 		    "Invalid parameter : %s\n", extra);
; 161  : }

	pop	ebp
	ret	0
_xmlC14NErrParam ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlC14NErrMemory PROC					; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	2
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,
; 143  : 		    XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0, extra,
; 144  : 		    NULL, NULL, 0, 0,
; 145  : 		    "Memory allocation failed : %s\n", extra);
; 146  : }

	pop	ebp
	ret	0
_xmlC14NErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC11NNormalizeString
_TEXT	SEGMENT
_buffer_size$1$ = 8					; size = 4
_input$ = 8						; size = 4
_mode$ = 12						; size = 4
_xmlC11NNormalizeString PROC				; COMDAT

; 2145 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _input$[ebp]
	test	ebx, ebx
	je	SHORT $LN36@xmlC11NNor

; 2146 :     const xmlChar *cur = input;
; 2147 :     xmlChar *buffer = NULL;
; 2148 :     xmlChar *out = NULL;
; 2149 :     int buffer_size = 0;
; 2150 : 
; 2151 :     if (input == NULL)
; 2152 :         return (NULL);
; 2153 : 
; 2154 :     /*
; 2155 :      * allocate an translation buffer.
; 2156 :      */
; 2157 :     buffer_size = 1000;

	push	1000					; 000003e8H
	mov	DWORD PTR _buffer_size$1$[ebp], 1000	; 000003e8H

; 2158 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));

	call	DWORD PTR _xmlMallocAtomic
	mov	edx, eax
	add	esp, 4

; 2159 :     if (buffer == NULL) {

	test	edx, edx
	jne	SHORT $LN5@xmlC11NNor

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN36@xmlC11NNor:

; 2230 : }

	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlC11NNor:

; 2160 : 	xmlC14NErrMemory("allocating buffer");
; 2161 :         return (NULL);
; 2162 :     }
; 2163 :     out = buffer;
; 2164 : 
; 2165 :     while (*cur != '\0') {

	cmp	BYTE PTR [ebx], 0
	push	esi
	push	edi
	je	$LN33@xmlC11NNor
	mov	esi, DWORD PTR _mode$[ebp]
	npad	5
$LL2@xmlC11NNor:

; 2166 :         if ((out - buffer) > (buffer_size - 10)) {

	mov	ecx, DWORD PTR _buffer_size$1$[ebp]
	mov	edi, eax
	sub	edi, edx
	add	ecx, -10				; fffffff6H
	cmp	edi, ecx
	jle	SHORT $LN6@xmlC11NNor

; 2167 :             int indx = out - buffer;
; 2168 : 
; 2169 :             growBufferReentrant();

	mov	eax, DWORD PTR _buffer_size$1$[ebp]
	add	eax, eax
	push	eax
	push	edx
	mov	DWORD PTR _buffer_size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	test	edx, edx
	je	$LN29@xmlC11NNor

; 2170 :             out = &buffer[indx];

	lea	eax, DWORD PTR [edi+edx]
$LN6@xmlC11NNor:

; 2171 :         }
; 2172 : 
; 2173 :         if ((*cur == '<') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN8@xmlC11NNor
	test	esi, esi
	je	SHORT $LN10@xmlC11NNor
	cmp	esi, 3
	jne	$LN22@xmlC11NNor
$LN10@xmlC11NNor:

; 2174 :                               (mode == XMLC14N_NORMALIZE_TEXT))) {
; 2175 :             *out++ = '&';

	mov	WORD PTR [eax], 27686			; 00006c26H

; 2176 :             *out++ = 'l';
; 2177 :             *out++ = 't';

	mov	BYTE PTR [eax+2], 116			; 00000074H
	add	eax, 3

; 2178 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	$LN23@xmlC11NNor
$LN8@xmlC11NNor:

; 2179 :         } else if ((*cur == '>') && (mode == XMLC14N_NORMALIZE_TEXT)) {

	cmp	cl, 62					; 0000003eH
	jne	SHORT $LN11@xmlC11NNor
	cmp	esi, 3
	jne	$LN22@xmlC11NNor

; 2180 :             *out++ = '&';

	mov	WORD PTR [eax], 26406			; 00006726H

; 2181 :             *out++ = 'g';
; 2182 :             *out++ = 't';

	mov	BYTE PTR [eax+2], 116			; 00000074H
	add	eax, esi

; 2183 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	$LN23@xmlC11NNor
$LN11@xmlC11NNor:

; 2184 :         } else if ((*cur == '&') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	cmp	cl, 38					; 00000026H
	jne	SHORT $LN13@xmlC11NNor
	test	esi, esi
	je	SHORT $LN15@xmlC11NNor
	cmp	esi, 3
	jne	SHORT $LN22@xmlC11NNor
$LN15@xmlC11NNor:

; 2185 :                                      (mode == XMLC14N_NORMALIZE_TEXT))) {
; 2186 :             *out++ = '&';

	mov	DWORD PTR [eax], 1886216486		; 706d6126H

; 2187 :             *out++ = 'a';
; 2188 :             *out++ = 'm';
; 2189 :             *out++ = 'p';

	add	eax, 4

; 2190 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN23@xmlC11NNor
$LN13@xmlC11NNor:

; 2191 :         } else if ((*cur == '"') && (mode == XMLC14N_NORMALIZE_ATTR)) {

	cmp	cl, 34					; 00000022H
	jne	SHORT $LN16@xmlC11NNor
	test	esi, esi
	jne	SHORT $LN22@xmlC11NNor

; 2192 :             *out++ = '&';

	mov	DWORD PTR [eax], 1869967654		; 6f757126H

; 2193 :             *out++ = 'q';
; 2194 :             *out++ = 'u';
; 2195 :             *out++ = 'o';
; 2196 :             *out++ = 't';

	mov	BYTE PTR [eax+4], 116			; 00000074H
	add	eax, 5

; 2197 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN23@xmlC11NNor
$LN16@xmlC11NNor:

; 2198 :         } else if ((*cur == '\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {

	cmp	cl, 9
	jne	SHORT $LN18@xmlC11NNor
	test	esi, esi
	jne	SHORT $LN22@xmlC11NNor

; 2199 :             *out++ = '&';

	mov	DWORD PTR [eax], 964174630		; 39782326H

; 2200 :             *out++ = '#';
; 2201 :             *out++ = 'x';
; 2202 :             *out++ = '9';

	add	eax, 4

; 2203 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN23@xmlC11NNor
$LN18@xmlC11NNor:

; 2204 :         } else if ((*cur == '\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {

	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN20@xmlC11NNor
	test	esi, esi
	jne	SHORT $LN22@xmlC11NNor

; 2205 :             *out++ = '&';

	mov	DWORD PTR [eax], 1098392358		; 41782326H

; 2206 :             *out++ = '#';
; 2207 :             *out++ = 'x';
; 2208 :             *out++ = 'A';

	add	eax, 4

; 2209 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN23@xmlC11NNor
$LN20@xmlC11NNor:

; 2210 :         } else if ((*cur == '\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN22@xmlC11NNor
	test	esi, esi
	je	SHORT $LN24@xmlC11NNor
	cmp	esi, 3
	je	SHORT $LN24@xmlC11NNor
	cmp	esi, 1
	je	SHORT $LN24@xmlC11NNor
	cmp	esi, 2
	jne	SHORT $LN22@xmlC11NNor
$LN24@xmlC11NNor:

; 2211 :                                         (mode == XMLC14N_NORMALIZE_TEXT) ||
; 2212 :                                         (mode == XMLC14N_NORMALIZE_COMMENT) ||
; 2213 : 					(mode == XMLC14N_NORMALIZE_PI))) {
; 2214 :             *out++ = '&';

	mov	DWORD PTR [eax], 1148724006		; 44782326H

; 2215 :             *out++ = '#';
; 2216 :             *out++ = 'x';
; 2217 :             *out++ = 'D';

	add	eax, 4

; 2218 :             *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH

; 2219 :         } else {

	jmp	SHORT $LN23@xmlC11NNor
$LN22@xmlC11NNor:

; 2220 :             /*
; 2221 :              * Works because on UTF-8, all extended sequences cannot
; 2222 :              * result in bytes in the ASCII range.
; 2223 :              */
; 2224 :             *out++ = *cur;

	mov	BYTE PTR [eax], cl
$LN23@xmlC11NNor:

; 2225 :         }
; 2226 :         cur++;

	inc	ebx
	inc	eax
	cmp	BYTE PTR [ebx], 0
	jne	$LL2@xmlC11NNor
$LN33@xmlC11NNor:
	pop	edi
	pop	esi

; 2227 :     }
; 2228 :     *out = 0;

	mov	BYTE PTR [eax], 0

; 2229 :     return (buffer);

	mov	eax, edx
	pop	ebx

; 2230 : }

	pop	ebp
	ret	0
$LN29@xmlC11NNor:

; 2167 :             int indx = out - buffer;
; 2168 : 
; 2169 :             growBufferReentrant();

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlC14NErrMemory
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 2230 : }

	pop	ebp
	ret	0
_xmlC11NNormalizeString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NProcessNodeList
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlC14NProcessNodeList PROC				; COMDAT

; 1721 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	test	edi, edi
	jne	SHORT $LN5@xmlC14NPro

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BF@BNBHCOBD@processing?5node?5list@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	edi
	push	edi
	push	edi
	push	edi
	push	OFFSET ??_C@_0BF@BNBHCOBD@processing?5node?5list@
	push	edi
	push	edi
	push	2
	push	1
	push	21					; 00000015H
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1722 :     int ret;
; 1723 : 
; 1724 :     if (ctx == NULL) {
; 1725 :         xmlC14NErrParam("processing node list");
; 1726 :         return (-1);

	or	eax, -1
	pop	edi

; 1733 : }

	pop	ebp
	ret	0
$LN5@xmlC14NPro:
	push	esi

; 1727 :     }
; 1728 : 
; 1729 :     for (ret = 0; cur != NULL && ret >= 0; cur = cur->next) {

	mov	esi, DWORD PTR _cur$[ebp]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN13@xmlC14NPro
	npad	3
$LL4@xmlC14NPro:
	test	eax, eax
	js	SHORT $LN13@xmlC14NPro

; 1730 :         ret = xmlC14NProcessNode(ctx, cur);

	push	esi
	push	edi
	call	_xmlC14NProcessNode
	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL4@xmlC14NPro
$LN13@xmlC14NPro:

; 1731 :     }
; 1732 :     return (ret);

	pop	esi
	pop	edi

; 1733 : }

	pop	ebp
	ret	0
_xmlC14NProcessNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NProcessNode
_TEXT	SEGMENT
_buffer_size$1$ = -4					; size = 4
_buffer_size$1$ = -4					; size = 4
_buffer_size$1$ = -4					; size = 4
_ctx$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlC14NProcessNode PROC				; COMDAT

; 1530 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	test	ebx, ebx
	je	$LN5@xmlC14NPro

; 1531 :     int ret = 0;
; 1532 :     int visible;
; 1533 : 
; 1534 :     if ((ctx == NULL) || (cur == NULL)) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN5@xmlC14NPro

; 1537 :     }
; 1538 : 
; 1539 :     visible = xmlC14NIsVisible(ctx, cur, cur->parent);

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN38@xmlC14NPro
	push	DWORD PTR [esi+20]
	push	esi
	push	DWORD PTR [ebx+8]
	call	eax
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	jmp	SHORT $LN39@xmlC14NPro
$LN38@xmlC14NPro:
	mov	ecx, 1
$LN39@xmlC14NPro:

; 1540 :     switch (cur->type) {

	mov	edx, DWORD PTR [esi+4]
	push	edi
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 20					; 00000014H
	ja	$LN36@xmlC14NPro
	movzx	eax, BYTE PTR $LN145@xmlC14NPro[eax]
	jmp	DWORD PTR $LN160@xmlC14NPro[eax*4]
$LN6@xmlC14NPro:

; 1541 :         case XML_ELEMENT_NODE:
; 1542 :             ret = xmlC14NProcessElementNode(ctx, cur, visible);

	push	ecx
	push	esi
	push	ebx
	call	_xmlC14NProcessElementNode
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlC14NPro:

; 1543 :             break;
; 1544 :         case XML_CDATA_SECTION_NODE:
; 1545 :         case XML_TEXT_NODE:
; 1546 :             /*
; 1547 :              * Text Nodes
; 1548 :              * the string value, except all ampersands are replaced
; 1549 :              * by &amp;, all open angle brackets (<) are replaced by &lt;, all closing
; 1550 :              * angle brackets (>) are replaced by &gt;, and all #xD characters are
; 1551 :              * replaced by &#xD;.
; 1552 :              */
; 1553 :             /* cdata sections are processed as text nodes */
; 1554 :             /* todo: verify that cdata sections are included in XPath nodes set */
; 1555 :             if ((visible) && (cur->content != NULL)) {

	test	ecx, ecx
	je	$LN154@xmlC14NPro
	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	je	$LN154@xmlC14NPro

; 2158 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));

	push	1000					; 000003e8H
	mov	DWORD PTR _buffer_size$1$[ebp], 1000	; 000003e8H
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 2159 :     if (buffer == NULL) {

	test	ebx, ebx
	jne	SHORT $LN46@xmlC14NPro

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1563 :                 } else {
; 1564 :                     xmlC14NErrInternal("normalizing text node");

	push	OFFSET ??_C@_0BG@FEJMMCLE@normalizing?5text?5node@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlC14NPro:

; 2165 :     while (*cur != '\0') {

	cmp	BYTE PTR [edi], 0
	mov	eax, ebx
	je	SHORT $LN142@xmlC14NPro
$LL43@xmlC14NPro:

; 2166 :         if ((out - buffer) > (buffer_size - 10)) {

	mov	edx, DWORD PTR _buffer_size$1$[ebp]
	mov	esi, eax
	sub	esi, ebx
	lea	ecx, DWORD PTR [edx-10]
	cmp	esi, ecx
	jle	SHORT $LN47@xmlC14NPro

; 2167 :             int indx = out - buffer;
; 2168 : 
; 2169 :             growBufferReentrant();

	add	edx, edx
	push	edx
	push	ebx
	mov	DWORD PTR _buffer_size$1$[ebp], edx
	call	DWORD PTR _xmlRealloc
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN128@xmlC14NPro

; 2170 :             out = &buffer[indx];

	lea	eax, DWORD PTR [esi+ebx]
$LN47@xmlC14NPro:

; 2171 :         }
; 2172 : 
; 2173 :         if ((*cur == '<') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	mov	cl, BYTE PTR [edi]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN49@xmlC14NPro

; 2174 :                               (mode == XMLC14N_NORMALIZE_TEXT))) {
; 2175 :             *out++ = '&';

	mov	DWORD PTR [eax], 997485606		; 3b746c26H

; 2176 :             *out++ = 'l';
; 2177 :             *out++ = 't';
; 2178 :             *out++ = ';';

	add	eax, 4
	jmp	SHORT $LN64@xmlC14NPro
$LN49@xmlC14NPro:

; 2179 :         } else if ((*cur == '>') && (mode == XMLC14N_NORMALIZE_TEXT)) {

	cmp	cl, 62					; 0000003eH
	jne	SHORT $LN52@xmlC14NPro

; 2180 :             *out++ = '&';

	mov	DWORD PTR [eax], 997484326		; 3b746726H

; 2181 :             *out++ = 'g';
; 2182 :             *out++ = 't';
; 2183 :             *out++ = ';';

	add	eax, 4
	jmp	SHORT $LN64@xmlC14NPro
$LN52@xmlC14NPro:

; 2184 :         } else if ((*cur == '&') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	cmp	cl, 38					; 00000026H
	jne	SHORT $LN54@xmlC14NPro

; 2185 :                                      (mode == XMLC14N_NORMALIZE_TEXT))) {
; 2186 :             *out++ = '&';

	mov	DWORD PTR [eax], 1886216486		; 706d6126H

; 2187 :             *out++ = 'a';
; 2188 :             *out++ = 'm';
; 2189 :             *out++ = 'p';
; 2190 :             *out++ = ';';

	mov	BYTE PTR [eax+4], 59			; 0000003bH
	add	eax, 5
	jmp	SHORT $LN64@xmlC14NPro
$LN54@xmlC14NPro:

; 2191 :         } else if ((*cur == '"') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2192 :             *out++ = '&';
; 2193 :             *out++ = 'q';
; 2194 :             *out++ = 'u';
; 2195 :             *out++ = 'o';
; 2196 :             *out++ = 't';
; 2197 :             *out++ = ';';
; 2198 :         } else if ((*cur == '\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2199 :             *out++ = '&';
; 2200 :             *out++ = '#';
; 2201 :             *out++ = 'x';
; 2202 :             *out++ = '9';
; 2203 :             *out++ = ';';
; 2204 :         } else if ((*cur == '\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2205 :             *out++ = '&';
; 2206 :             *out++ = '#';
; 2207 :             *out++ = 'x';
; 2208 :             *out++ = 'A';
; 2209 :             *out++ = ';';
; 2210 :         } else if ((*cur == '\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN63@xmlC14NPro

; 2211 :                                         (mode == XMLC14N_NORMALIZE_TEXT) ||
; 2212 :                                         (mode == XMLC14N_NORMALIZE_COMMENT) ||
; 2213 : 					(mode == XMLC14N_NORMALIZE_PI))) {
; 2214 :             *out++ = '&';

	mov	DWORD PTR [eax], 1148724006		; 44782326H

; 2215 :             *out++ = '#';
; 2216 :             *out++ = 'x';
; 2217 :             *out++ = 'D';
; 2218 :             *out++ = ';';

	mov	BYTE PTR [eax+4], 59			; 0000003bH
	add	eax, 5

; 2219 :         } else {

	jmp	SHORT $LN64@xmlC14NPro
$LN63@xmlC14NPro:

; 2220 :             /*
; 2221 :              * Works because on UTF-8, all extended sequences cannot
; 2222 :              * result in bytes in the ASCII range.
; 2223 :              */
; 2224 :             *out++ = *cur;

	mov	BYTE PTR [eax], cl
	inc	eax
$LN64@xmlC14NPro:

; 2225 :         }
; 2226 :         cur++;

	inc	edi
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LL43@xmlC14NPro
$LN142@xmlC14NPro:

; 2227 :     }
; 2228 :     *out = 0;

	mov	BYTE PTR [eax], 0

; 1556 :                 xmlChar *buffer;
; 1557 : 
; 1558 :                 buffer = xmlC11NNormalizeText(cur->content);
; 1559 :                 if (buffer != NULL) {
; 1560 :                     xmlOutputBufferWriteString(ctx->buf,

	mov	eax, DWORD PTR _ctx$[ebp]
	push	ebx
	push	DWORD PTR [eax+16]
	call	_xmlOutputBufferWriteString

; 1561 :                                                (const char *) buffer);
; 1562 :                     xmlFree(buffer);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 1687 : 
; 1688 :         case XML_DOCUMENT_TYPE_NODE:
; 1689 :         case XML_NOTATION_NODE:
; 1690 :         case XML_DTD_NODE:
; 1691 :         case XML_ELEMENT_DECL:
; 1692 :         case XML_ATTRIBUTE_DECL:
; 1693 :         case XML_ENTITY_DECL:
; 1694 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1695 :         case XML_XINCLUDE_START:
; 1696 :         case XML_XINCLUDE_END:
; 1697 : #endif
; 1698 :             /*
; 1699 :              * should be ignored according to "W3C Canonical XML"
; 1700 :              */
; 1701 :             break;
; 1702 :         default:
; 1703 :             xmlC14NErrUnknownNode(cur->type, "processing node");
; 1704 :             return (-1);
; 1705 :     }
; 1706 : 
; 1707 :     return (ret);

	xor	eax, eax
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN128@xmlC14NPro:

; 2169 :             growBufferReentrant();

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlC14NErrMemory
	add	esp, 4

; 1563 :                 } else {
; 1564 :                     xmlC14NErrInternal("normalizing text node");

	push	OFFSET ??_C@_0BG@FEJMMCLE@normalizing?5text?5node@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlC14NPro:

; 1565 :                     return (-1);
; 1566 :                 }
; 1567 :             }
; 1568 :             break;
; 1569 :         case XML_PI_NODE:
; 1570 :             /*
; 1571 :              * Processing Instruction (PI) Nodes-
; 1572 :              * The opening PI symbol (<?), the PI target name of the node,
; 1573 :              * a leading space and the string value if it is not empty, and
; 1574 :              * the closing PI symbol (?>). If the string value is empty,
; 1575 :              * then the leading space is not added. Also, a trailing #xA is
; 1576 :              * rendered after the closing PI symbol for PI children of the
; 1577 :              * root node with a lesser document order than the document
; 1578 :              * element, and a leading #xA is rendered before the opening PI
; 1579 :              * symbol of PI children of the root node with a greater document
; 1580 :              * order than the document element.
; 1581 :              */
; 1582 :             if (visible) {

	test	ecx, ecx
	je	$LN154@xmlC14NPro

; 1583 :                 if (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {
; 1584 :                     xmlOutputBufferWriteString(ctx->buf, "\x0A<?");
; 1585 :                 } else {
; 1586 :                     xmlOutputBufferWriteString(ctx->buf, "<?");
; 1587 :                 }
; 1588 : 
; 1589 :                 xmlOutputBufferWriteString(ctx->buf,

	cmp	DWORD PTR [ebx+20], 2
	mov	ecx, OFFSET ??_C@_03MEKJPGEP@?6?$DM?$DP@
	mov	eax, OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	cmove	eax, ecx
	push	eax
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	push	DWORD PTR [esi+8]
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1590 :                                            (const char *) cur->name);
; 1591 :                 if ((cur->content != NULL) && (*(cur->content) != '\0')) {

	mov	eax, DWORD PTR [esi+40]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN17@xmlC14NPro
	cmp	BYTE PTR [eax], 0
	je	$LN17@xmlC14NPro

; 1592 :                     xmlChar *buffer;
; 1593 : 
; 1594 :                     xmlOutputBufferWriteString(ctx->buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1595 : 
; 1596 :                     /* todo: do we need to normalize pi? */
; 1597 :                     buffer = xmlC11NNormalizePI(cur->content);

	mov	esi, DWORD PTR [esi+40]
	add	esp, 8

; 2151 :     if (input == NULL)

	test	esi, esi
	je	SHORT $LN16@xmlC14NPro

; 2152 :         return (NULL);
; 2153 : 
; 2154 :     /*
; 2155 :      * allocate an translation buffer.
; 2156 :      */
; 2157 :     buffer_size = 1000;
; 2158 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));

	push	1000					; 000003e8H
	mov	DWORD PTR _buffer_size$1$[ebp], 1000	; 000003e8H
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 2159 :     if (buffer == NULL) {

	test	edi, edi
	jne	SHORT $LN73@xmlC14NPro

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN16@xmlC14NPro:

; 1602 :                     } else {
; 1603 :                         xmlC14NErrInternal("normalizing pi node");

	push	OFFSET ??_C@_0BE@NALCHLAN@normalizing?5pi?5node@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlC14NPro:

; 2165 :     while (*cur != '\0') {

	cmp	BYTE PTR [esi], 0
	mov	ecx, edi
	je	SHORT $LN143@xmlC14NPro
$LL70@xmlC14NPro:

; 2166 :         if ((out - buffer) > (buffer_size - 10)) {

	mov	edx, DWORD PTR _buffer_size$1$[ebp]
	mov	ebx, ecx
	sub	ebx, edi
	lea	eax, DWORD PTR [edx-10]
	cmp	ebx, eax
	jle	SHORT $LN137@xmlC14NPro

; 2167 :             int indx = out - buffer;
; 2168 : 
; 2169 :             growBufferReentrant();

	add	edx, edx
	push	edx
	push	edi
	mov	DWORD PTR _buffer_size$1$[ebp], edx
	call	DWORD PTR _xmlRealloc
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN129@xmlC14NPro

; 2170 :             out = &buffer[indx];

	lea	ecx, DWORD PTR [ebx+edi]
$LN137@xmlC14NPro:

; 2191 :         } else if ((*cur == '"') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2192 :             *out++ = '&';
; 2193 :             *out++ = 'q';
; 2194 :             *out++ = 'u';
; 2195 :             *out++ = 'o';
; 2196 :             *out++ = 't';
; 2197 :             *out++ = ';';
; 2198 :         } else if ((*cur == '\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2199 :             *out++ = '&';
; 2200 :             *out++ = '#';
; 2201 :             *out++ = 'x';
; 2202 :             *out++ = '9';
; 2203 :             *out++ = ';';
; 2204 :         } else if ((*cur == '\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2205 :             *out++ = '&';
; 2206 :             *out++ = '#';
; 2207 :             *out++ = 'x';
; 2208 :             *out++ = 'A';
; 2209 :             *out++ = ';';
; 2210 :         } else if ((*cur == '\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	mov	al, BYTE PTR [esi]
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN90@xmlC14NPro

; 2211 :                                         (mode == XMLC14N_NORMALIZE_TEXT) ||
; 2212 :                                         (mode == XMLC14N_NORMALIZE_COMMENT) ||
; 2213 : 					(mode == XMLC14N_NORMALIZE_PI))) {
; 2214 :             *out++ = '&';

	mov	DWORD PTR [ecx], 1148724006		; 44782326H

; 2215 :             *out++ = '#';
; 2216 :             *out++ = 'x';
; 2217 :             *out++ = 'D';
; 2218 :             *out++ = ';';

	mov	BYTE PTR [ecx+4], 59			; 0000003bH
	add	ecx, 5

; 2219 :         } else {

	jmp	SHORT $LN91@xmlC14NPro
$LN90@xmlC14NPro:

; 2220 :             /*
; 2221 :              * Works because on UTF-8, all extended sequences cannot
; 2222 :              * result in bytes in the ASCII range.
; 2223 :              */
; 2224 :             *out++ = *cur;

	mov	BYTE PTR [ecx], al
	inc	ecx
$LN91@xmlC14NPro:

; 2225 :         }
; 2226 :         cur++;

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL70@xmlC14NPro

; 2160 : 	xmlC14NErrMemory("allocating buffer");
; 2161 :         return (NULL);
; 2162 :     }
; 2163 :     out = buffer;
; 2164 : 
; 2165 :     while (*cur != '\0') {

	mov	ebx, DWORD PTR _ctx$[ebp]
$LN143@xmlC14NPro:

; 2227 :     }
; 2228 :     *out = 0;

	mov	BYTE PTR [ecx], 0

; 1598 :                     if (buffer != NULL) {
; 1599 :                         xmlOutputBufferWriteString(ctx->buf,

	push	edi
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1600 :                                                    (const char *) buffer);
; 1601 :                         xmlFree(buffer);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN17@xmlC14NPro:

; 1604 :                         return (-1);
; 1605 :                     }
; 1606 :                 }
; 1607 : 
; 1608 :                 if (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {

	cmp	DWORD PTR [ebx+20], 0
	mov	eax, DWORD PTR [ebx+16]
	jne	SHORT $LN18@xmlC14NPro

; 1609 :                     xmlOutputBufferWriteString(ctx->buf, "?>\x0A");

	push	OFFSET ??_C@_03KCOJOIAE@?$DP?$DO?6@

; 1687 : 
; 1688 :         case XML_DOCUMENT_TYPE_NODE:
; 1689 :         case XML_NOTATION_NODE:
; 1690 :         case XML_DTD_NODE:
; 1691 :         case XML_ELEMENT_DECL:
; 1692 :         case XML_ATTRIBUTE_DECL:
; 1693 :         case XML_ENTITY_DECL:
; 1694 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1695 :         case XML_XINCLUDE_START:
; 1696 :         case XML_XINCLUDE_END:
; 1697 : #endif
; 1698 :             /*
; 1699 :              * should be ignored according to "W3C Canonical XML"
; 1700 :              */
; 1701 :             break;
; 1702 :         default:
; 1703 :             xmlC14NErrUnknownNode(cur->type, "processing node");
; 1704 :             return (-1);
; 1705 :     }
; 1706 : 
; 1707 :     return (ret);

	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN154@xmlC14NPro:
	pop	edi
	pop	esi
	xor	eax, eax

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN129@xmlC14NPro:

; 2169 :             growBufferReentrant();

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlC14NErrMemory
	add	esp, 4
	jmp	$LN16@xmlC14NPro
$LN18@xmlC14NPro:

; 1610 :                 } else {
; 1611 :                     xmlOutputBufferWriteString(ctx->buf, "?>");

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@

; 1687 : 
; 1688 :         case XML_DOCUMENT_TYPE_NODE:
; 1689 :         case XML_NOTATION_NODE:
; 1690 :         case XML_DTD_NODE:
; 1691 :         case XML_ELEMENT_DECL:
; 1692 :         case XML_ATTRIBUTE_DECL:
; 1693 :         case XML_ENTITY_DECL:
; 1694 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1695 :         case XML_XINCLUDE_START:
; 1696 :         case XML_XINCLUDE_END:
; 1697 : #endif
; 1698 :             /*
; 1699 :              * should be ignored according to "W3C Canonical XML"
; 1700 :              */
; 1701 :             break;
; 1702 :         default:
; 1703 :             xmlC14NErrUnknownNode(cur->type, "processing node");
; 1704 :             return (-1);
; 1705 :     }
; 1706 : 
; 1707 :     return (ret);

	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlC14NPro:

; 1612 :                 }
; 1613 :             }
; 1614 :             break;
; 1615 :         case XML_COMMENT_NODE:
; 1616 :             /*
; 1617 :              * Comment Nodes
; 1618 :              * Nothing if generating canonical XML without  comments. For
; 1619 :              * canonical XML with comments, generate the opening comment
; 1620 :              * symbol (<!--), the string value of the node, and the
; 1621 :              * closing comment symbol (-->). Also, a trailing #xA is rendered
; 1622 :              * after the closing comment symbol for comment children of the
; 1623 :              * root node with a lesser document order than the document
; 1624 :              * element, and a leading #xA is rendered before the opening
; 1625 :              * comment symbol of comment children of the root node with a
; 1626 :              * greater document order than the document element. (Comment
; 1627 :              * children of the root node represent comments outside of the
; 1628 :              * top-level document element and outside of the document type
; 1629 :              * declaration).
; 1630 :              */
; 1631 :             if (visible && ctx->with_comments) {

	test	ecx, ecx
	je	SHORT $LN154@xmlC14NPro
	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN154@xmlC14NPro

; 1632 :                 if (ctx->pos == XMLC14N_AFTER_DOCUMENT_ELEMENT) {
; 1633 :                     xmlOutputBufferWriteString(ctx->buf, "\x0A<!--");
; 1634 :                 } else {
; 1635 :                     xmlOutputBufferWriteString(ctx->buf, "<!--");
; 1636 :                 }
; 1637 : 
; 1638 :                 if (cur->content != NULL) {

	cmp	DWORD PTR [ebx+20], 2
	mov	ecx, OFFSET ??_C@_05IDEGGPLK@?6?$DM?$CB?9?9@
	mov	eax, OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	cmove	eax, ecx
	push	eax
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString
	mov	esi, DWORD PTR [esi+40]
	add	esp, 8
	test	esi, esi
	je	$LN26@xmlC14NPro

; 2158 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));

	push	1000					; 000003e8H
	mov	DWORD PTR _buffer_size$1$[ebp], 1000	; 000003e8H
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 2159 :     if (buffer == NULL) {

	test	edi, edi
	jne	SHORT $LN100@xmlC14NPro

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1647 :                     } else {
; 1648 :                         xmlC14NErrInternal("normalizing comment node");

	push	OFFSET ??_C@_0BJ@MDKPFKCP@normalizing?5comment?5node@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlC14NPro:

; 2165 :     while (*cur != '\0') {

	cmp	BYTE PTR [esi], 0
	mov	ecx, edi
	je	SHORT $LN144@xmlC14NPro
	npad	4
$LL97@xmlC14NPro:

; 2166 :         if ((out - buffer) > (buffer_size - 10)) {

	mov	edx, DWORD PTR _buffer_size$1$[ebp]
	mov	ebx, ecx
	sub	ebx, edi
	lea	eax, DWORD PTR [edx-10]
	cmp	ebx, eax
	jle	SHORT $LN138@xmlC14NPro

; 2167 :             int indx = out - buffer;
; 2168 : 
; 2169 :             growBufferReentrant();

	add	edx, edx
	push	edx
	push	edi
	mov	DWORD PTR _buffer_size$1$[ebp], edx
	call	DWORD PTR _xmlRealloc
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN130@xmlC14NPro

; 2170 :             out = &buffer[indx];

	lea	ecx, DWORD PTR [ebx+edi]
$LN138@xmlC14NPro:

; 2191 :         } else if ((*cur == '"') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2192 :             *out++ = '&';
; 2193 :             *out++ = 'q';
; 2194 :             *out++ = 'u';
; 2195 :             *out++ = 'o';
; 2196 :             *out++ = 't';
; 2197 :             *out++ = ';';
; 2198 :         } else if ((*cur == '\x09') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2199 :             *out++ = '&';
; 2200 :             *out++ = '#';
; 2201 :             *out++ = 'x';
; 2202 :             *out++ = '9';
; 2203 :             *out++ = ';';
; 2204 :         } else if ((*cur == '\x0A') && (mode == XMLC14N_NORMALIZE_ATTR)) {
; 2205 :             *out++ = '&';
; 2206 :             *out++ = '#';
; 2207 :             *out++ = 'x';
; 2208 :             *out++ = 'A';
; 2209 :             *out++ = ';';
; 2210 :         } else if ((*cur == '\x0D') && ((mode == XMLC14N_NORMALIZE_ATTR) ||

	mov	al, BYTE PTR [esi]
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN117@xmlC14NPro

; 2211 :                                         (mode == XMLC14N_NORMALIZE_TEXT) ||
; 2212 :                                         (mode == XMLC14N_NORMALIZE_COMMENT) ||
; 2213 : 					(mode == XMLC14N_NORMALIZE_PI))) {
; 2214 :             *out++ = '&';

	mov	DWORD PTR [ecx], 1148724006		; 44782326H

; 2215 :             *out++ = '#';
; 2216 :             *out++ = 'x';
; 2217 :             *out++ = 'D';
; 2218 :             *out++ = ';';

	mov	BYTE PTR [ecx+4], 59			; 0000003bH
	add	ecx, 5

; 2219 :         } else {

	jmp	SHORT $LN118@xmlC14NPro
$LN117@xmlC14NPro:

; 2220 :             /*
; 2221 :              * Works because on UTF-8, all extended sequences cannot
; 2222 :              * result in bytes in the ASCII range.
; 2223 :              */
; 2224 :             *out++ = *cur;

	mov	BYTE PTR [ecx], al
	inc	ecx
$LN118@xmlC14NPro:

; 2225 :         }
; 2226 :         cur++;

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL97@xmlC14NPro

; 2160 : 	xmlC14NErrMemory("allocating buffer");
; 2161 :         return (NULL);
; 2162 :     }
; 2163 :     out = buffer;
; 2164 : 
; 2165 :     while (*cur != '\0') {

	mov	ebx, DWORD PTR _ctx$[ebp]
$LN144@xmlC14NPro:

; 2227 :     }
; 2228 :     *out = 0;

	mov	BYTE PTR [ecx], 0

; 1639 :                     xmlChar *buffer;
; 1640 : 
; 1641 :                     /* todo: do we need to normalize comment? */
; 1642 :                     buffer = xmlC11NNormalizeComment(cur->content);
; 1643 :                     if (buffer != NULL) {
; 1644 :                         xmlOutputBufferWriteString(ctx->buf,

	push	edi
	push	DWORD PTR [ebx+16]
	call	_xmlOutputBufferWriteString

; 1645 :                                                    (const char *) buffer);
; 1646 :                         xmlFree(buffer);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN26@xmlC14NPro:

; 1649 :                         return (-1);
; 1650 :                     }
; 1651 :                 }
; 1652 : 
; 1653 :                 if (ctx->pos == XMLC14N_BEFORE_DOCUMENT_ELEMENT) {

	cmp	DWORD PTR [ebx+20], 0
	mov	eax, DWORD PTR [ebx+16]
	jne	SHORT $LN27@xmlC14NPro

; 1654 :                     xmlOutputBufferWriteString(ctx->buf, "-->\x0A");

	push	OFFSET ??_C@_04IGMOLEKE@?9?9?$DO?6@

; 1687 : 
; 1688 :         case XML_DOCUMENT_TYPE_NODE:
; 1689 :         case XML_NOTATION_NODE:
; 1690 :         case XML_DTD_NODE:
; 1691 :         case XML_ELEMENT_DECL:
; 1692 :         case XML_ATTRIBUTE_DECL:
; 1693 :         case XML_ENTITY_DECL:
; 1694 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1695 :         case XML_XINCLUDE_START:
; 1696 :         case XML_XINCLUDE_END:
; 1697 : #endif
; 1698 :             /*
; 1699 :              * should be ignored according to "W3C Canonical XML"
; 1700 :              */
; 1701 :             break;
; 1702 :         default:
; 1703 :             xmlC14NErrUnknownNode(cur->type, "processing node");
; 1704 :             return (-1);
; 1705 :     }
; 1706 : 
; 1707 :     return (ret);

	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@xmlC14NPro:

; 2169 :             growBufferReentrant();

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlC14NErrMemory
	add	esp, 4

; 1647 :                     } else {
; 1648 :                         xmlC14NErrInternal("normalizing comment node");

	push	OFFSET ??_C@_0BJ@MDKPFKCP@normalizing?5comment?5node@
	call	_xmlC14NErrInternal
	add	esp, 4

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlC14NPro:

; 1655 :                 } else {
; 1656 :                     xmlOutputBufferWriteString(ctx->buf, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@

; 1687 : 
; 1688 :         case XML_DOCUMENT_TYPE_NODE:
; 1689 :         case XML_NOTATION_NODE:
; 1690 :         case XML_DTD_NODE:
; 1691 :         case XML_ELEMENT_DECL:
; 1692 :         case XML_ATTRIBUTE_DECL:
; 1693 :         case XML_ENTITY_DECL:
; 1694 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1695 :         case XML_XINCLUDE_START:
; 1696 :         case XML_XINCLUDE_END:
; 1697 : #endif
; 1698 :             /*
; 1699 :              * should be ignored according to "W3C Canonical XML"
; 1700 :              */
; 1701 :             break;
; 1702 :         default:
; 1703 :             xmlC14NErrUnknownNode(cur->type, "processing node");
; 1704 :             return (-1);
; 1705 :     }
; 1706 : 
; 1707 :     return (ret);

	push	eax
	call	_xmlOutputBufferWriteString
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlC14NPro:

; 1657 :                 }
; 1658 :             }
; 1659 :             break;
; 1660 :         case XML_DOCUMENT_NODE:
; 1661 :         case XML_DOCUMENT_FRAG_NODE:   /* should be processed as document? */
; 1662 : #ifdef LIBXML_DOCB_ENABLED
; 1663 :         case XML_DOCB_DOCUMENT_NODE:   /* should be processed as document? */
; 1664 : #endif
; 1665 : #ifdef LIBXML_HTML_ENABLED
; 1666 :         case XML_HTML_DOCUMENT_NODE:   /* should be processed as document? */
; 1667 : #endif
; 1668 :             if (cur->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN154@xmlC14NPro

; 1669 :                 ctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;

	mov	DWORD PTR [ebx+20], 0

; 1670 :                 ctx->parent_is_doc = 1;

	mov	DWORD PTR [ebx+24], 1

; 1671 :                 ret = xmlC14NProcessNodeList(ctx, cur->children);

	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlC14NProcessNodeList
	add	esp, 8
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlC14NPro:

; 1672 :             }
; 1673 :             break;
; 1674 : 
; 1675 :         case XML_ATTRIBUTE_NODE:
; 1676 :             xmlC14NErrInvalidNode("XML_ATTRIBUTE_NODE", "processing node");

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	OFFSET ??_C@_0BD@KCCEFDB@XML_ATTRIBUTE_NODE@

; 1686 :             return (-1);

	call	_xmlC14NErrInvalidNode
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlC14NPro:

; 1677 :             return (-1);
; 1678 :         case XML_NAMESPACE_DECL:
; 1679 :             xmlC14NErrInvalidNode("XML_NAMESPACE_DECL", "processing node");

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	OFFSET ??_C@_0BD@OOHJMPDA@XML_NAMESPACE_DECL@

; 1686 :             return (-1);

	call	_xmlC14NErrInvalidNode
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlC14NPro:

; 1680 :             return (-1);
; 1681 :         case XML_ENTITY_REF_NODE:
; 1682 :             xmlC14NErrInvalidNode("XML_ENTITY_REF_NODE", "processing node");

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	OFFSET ??_C@_0BE@NCHPKEOD@XML_ENTITY_REF_NODE@

; 1686 :             return (-1);

	call	_xmlC14NErrInvalidNode
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlC14NPro:

; 1683 :             return (-1);
; 1684 :         case XML_ENTITY_NODE:
; 1685 :             xmlC14NErrInvalidNode("XML_ENTITY_NODE", "processing node");

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	OFFSET ??_C@_0BA@HBKNNEGK@XML_ENTITY_NODE@

; 1686 :             return (-1);

	call	_xmlC14NErrInvalidNode
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlC14NPro:

; 202  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	edx
	push	OFFSET ??_C@_0CB@LPHDJOLE@Unknown?5node?5type?5?$CFd?5found?5?3?5?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	0
	push	0
	push	2
	push	1954					; 000007a2H
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 1686 :             return (-1);

	or	eax, -1
	pop	edi
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlC14NPro:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@KPMINAPM@processing?5node@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1535 :         xmlC14NErrParam("processing node");
; 1536 :         return (-1);

	or	eax, -1
	pop	esi

; 1708 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN160@xmlC14NPro:
	DD	$LN6@xmlC14NPro
	DD	$LN31@xmlC14NPro
	DD	$LN7@xmlC14NPro
	DD	$LN33@xmlC14NPro
	DD	$LN34@xmlC14NPro
	DD	$LN11@xmlC14NPro
	DD	$LN20@xmlC14NPro
	DD	$LN29@xmlC14NPro
	DD	$LN154@xmlC14NPro
	DD	$LN32@xmlC14NPro
$LN145@xmlC14NPro:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	7
	DB	8
	DB	7
	DB	8
	DB	8
	DB	8
	DB	8
	DB	9
	DB	8
	DB	8
	DB	7
_xmlC14NProcessNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NIsNodeInNodeset
_TEXT	SEGMENT
_ns$1 = -24						; size = 24
_user_data$ = 8						; size = 4
_node$ = 12						; size = 4
_parent$ = 16						; size = 4
_xmlC14NIsNodeInNodeset PROC				; COMDAT

; 255  : xmlC14NIsNodeInNodeset(void *user_data, xmlNodePtr node, xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _user_data$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlC14NIsN

; 256  :     xmlNodeSetPtr nodes = (xmlNodeSetPtr) user_data;
; 257  :     if((nodes != NULL) && (node != NULL)) {

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlC14NIsN

; 258  : 	if(node->type != XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN8@xmlC14NIsN

; 259  : 	    return(xmlXPathNodeSetContains(nodes, node));
; 260  : 	} else {
; 261  : 	    xmlNs ns;
; 262  : 
; 263  : 	    memcpy(&ns, node, sizeof(ns));

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _ns$1[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]

; 264  : 
; 265  : 	    /* this is a libxml hack! check xpath.c for details */
; 266  : 	    if((parent != NULL) && (parent->type == XML_ATTRIBUTE_NODE)) {

	mov	eax, DWORD PTR _parent$[ebp]
	movq	QWORD PTR _ns$1[ebp+16], xmm0
	test	eax, eax
	je	SHORT $LN5@xmlC14NIsN
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN5@xmlC14NIsN

; 267  : 		ns.next = (xmlNsPtr)parent->parent;

	mov	eax, DWORD PTR [eax+20]
$LN5@xmlC14NIsN:

; 268  : 	    } else {
; 269  : 		ns.next = (xmlNsPtr)parent;
; 270  : 	    }
; 271  : 
; 272  : 	    /*
; 273  : 	     * If the input is an XPath node-set, then the node-set must explicitly
; 274  : 	     * contain every node to be rendered to the canonical form.
; 275  : 	     */
; 276  : 	    return(xmlXPathNodeSetContains(nodes, (xmlNodePtr)&ns));

	mov	DWORD PTR _ns$1[ebp], eax
	lea	eax, DWORD PTR _ns$1[ebp]
$LN8@xmlC14NIsN:

; 280  : }

	push	eax
	push	ecx
	call	_xmlXPathNodeSetContains
	add	esp, 8
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlC14NIsN:

; 277  : 	}
; 278  :     }
; 279  :     return(1);

	mov	eax, 1

; 280  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NIsNodeInNodeset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlExcC14NVisibleNsStackFind
_TEXT	SEGMENT
_has_empty_ns$1$ = -8					; size = 4
_href$1$ = -4						; size = 4
_cur$ = 8						; size = 4
_ns$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlExcC14NVisibleNsStackFind PROC			; COMDAT

; 448  : xmlExcC14NVisibleNsStackFind(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlC14NCtxPtr ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@xmlExcC14N

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0CG@DGFPKBDK@searching?5namespaces?5stack?5?$CIexc@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0CG@DGFPKBDK@searching?5namespaces?5stack?5?$CIexc@
	push	ecx
	push	ecx
	push	2
	push	1
	push	21					; 00000015H
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 449  :     int i;
; 450  :     const xmlChar *prefix;
; 451  :     const xmlChar *href;
; 452  :     int has_empty_ns;
; 453  : 
; 454  :     if(cur == NULL) {
; 455  :         xmlC14NErrParam("searching namespaces stack (exc c14n)");
; 456  :         return (0);

	xor	eax, eax

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlExcC14N:

; 457  :     }
; 458  : 
; 459  :     /*
; 460  :      * if the default namespace xmlns="" is not defined yet then
; 461  :      * we do not want to print it out
; 462  :      */
; 463  :     prefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST "" : ns->prefix;

	mov	eax, DWORD PTR _ns$[ebp]
	push	ebx
	test	eax, eax
	je	SHORT $LN11@xmlExcC14N
	mov	ebx, DWORD PTR [eax+12]
	test	ebx, ebx
	jne	SHORT $LN12@xmlExcC14N
$LN11@xmlExcC14N:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@@
$LN12@xmlExcC14N:

; 464  :     href = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST "" : ns->href;

	test	eax, eax
	je	SHORT $LN13@xmlExcC14N
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _href$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN14@xmlExcC14N
$LN13@xmlExcC14N:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	mov	DWORD PTR _href$1$[ebp], eax
$LN14@xmlExcC14N:

; 395  :     if (str1 == str2) return(1);

	test	ebx, ebx
	je	SHORT $LN66@xmlExcC14N

; 465  :     has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));

	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN15@xmlExcC14N
$LN66@xmlExcC14N:

; 395  :     if (str1 == str2) return(1);

	test	eax, eax
	je	SHORT $LN67@xmlExcC14N

; 465  :     has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN67@xmlExcC14N
$LN15@xmlExcC14N:
	mov	DWORD PTR _has_empty_ns$1$[ebp], 0
	jmp	SHORT $LN16@xmlExcC14N
$LN67@xmlExcC14N:
	mov	DWORD PTR _has_empty_ns$1$[ebp], 1
$LN16@xmlExcC14N:

; 466  : 
; 467  :     if (cur->nsTab != NULL) {

	cmp	DWORD PTR [ecx+16], 0
	push	esi
	push	edi
	je	SHORT $LN3@xmlExcC14N

; 468  : 	int start = 0;
; 469  :         for (i = cur->nsCurEnd - 1; i >= start; --i) {

	mov	esi, DWORD PTR [ecx]
	sub	esi, 1
	js	SHORT $LN3@xmlExcC14N
$LL4@xmlExcC14N:

; 470  :             xmlNsPtr ns1 = cur->nsTab[i];

	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [eax+esi*4]

; 471  : 
; 472  : 	    if(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {

	test	edi, edi
	je	SHORT $LN17@xmlExcC14N
	mov	eax, DWORD PTR [edi+12]
	jmp	SHORT $LN18@xmlExcC14N
$LN17@xmlExcC14N:
	xor	eax, eax
$LN18@xmlExcC14N:
	push	eax
	push	ebx
	call	_xmlC14NStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN50@xmlExcC14N

; 468  : 	int start = 0;
; 469  :         for (i = cur->nsCurEnd - 1; i >= start; --i) {

	sub	esi, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	jns	SHORT $LL4@xmlExcC14N
$LN3@xmlExcC14N:

; 477  : 		}
; 478  : 	    }
; 479  :         }
; 480  :     }
; 481  :     return(has_empty_ns);

	mov	eax, DWORD PTR _has_empty_ns$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlExcC14N:

; 473  : 		if(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL)) {

	test	edi, edi
	je	SHORT $LN19@xmlExcC14N
	mov	eax, DWORD PTR [edi+8]
	jmp	SHORT $LN20@xmlExcC14N
$LN19@xmlExcC14N:
	xor	eax, eax
$LN20@xmlExcC14N:
	push	eax
	push	DWORD PTR _href$1$[ebp]
	call	_xmlC14NStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlExcC14N

; 474  : 		    return(xmlC14NIsVisible(ctx, ns1, cur->nodeTab[i]));

	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN21@xmlExcC14N
	mov	eax, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR [eax+esi*4]
	push	edi
	push	DWORD PTR [ecx+8]
	call	edx
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlExcC14N:
	pop	edi
	pop	esi

; 474  : 		    return(xmlC14NIsVisible(ctx, ns1, cur->nodeTab[i]));

	mov	eax, 1
	pop	ebx

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlExcC14N:
	pop	edi
	pop	esi

; 475  : 		} else {
; 476  : 		    return(0);

	xor	eax, eax
	pop	ebx

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExcC14NVisibleNsStackFind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackFind
_TEXT	SEGMENT
_has_empty_ns$1$ = -12					; size = 4
_href$1$ = -8						; size = 4
_start$1$ = -4						; size = 4
_cur$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlC14NVisibleNsStackFind PROC				; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@xmlC14NVis

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0CC@HHELCFAC@searching?5namespaces?5stack?5?$CIc14@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0CC@HHELCFAC@searching?5namespaces?5stack?5?$CIc14@
	push	ecx
	push	ecx
	push	2
	push	1
	push	21					; 00000015H
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 416  :     int i;
; 417  :     const xmlChar *prefix;
; 418  :     const xmlChar *href;
; 419  :     int has_empty_ns;
; 420  : 
; 421  :     if(cur == NULL) {
; 422  :         xmlC14NErrParam("searching namespaces stack (c14n)");
; 423  :         return (0);

	xor	eax, eax

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlC14NVis:

; 424  :     }
; 425  : 
; 426  :     /*
; 427  :      * if the default namespace xmlns="" is not defined yet then
; 428  :      * we do not want to print it out
; 429  :      */
; 430  :     prefix = ((ns == NULL) || (ns->prefix == NULL)) ? BAD_CAST "" : ns->prefix;

	mov	eax, DWORD PTR _ns$[ebp]
	push	ebx
	test	eax, eax
	je	SHORT $LN9@xmlC14NVis
	mov	ebx, DWORD PTR [eax+12]
	test	ebx, ebx
	jne	SHORT $LN10@xmlC14NVis
$LN9@xmlC14NVis:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@@
$LN10@xmlC14NVis:

; 431  :     href = ((ns == NULL) || (ns->href == NULL)) ? BAD_CAST "" : ns->href;

	test	eax, eax
	je	SHORT $LN11@xmlC14NVis
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _href$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN12@xmlC14NVis
$LN11@xmlC14NVis:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	mov	DWORD PTR _href$1$[ebp], eax
$LN12@xmlC14NVis:

; 395  :     if (str1 == str2) return(1);

	test	ebx, ebx
	je	SHORT $LN64@xmlC14NVis

; 432  :     has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));

	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN13@xmlC14NVis
$LN64@xmlC14NVis:

; 395  :     if (str1 == str2) return(1);

	test	eax, eax
	je	SHORT $LN65@xmlC14NVis

; 432  :     has_empty_ns = (xmlC14NStrEqual(prefix, NULL) && xmlC14NStrEqual(href, NULL));

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN65@xmlC14NVis
$LN13@xmlC14NVis:
	xor	eax, eax
	jmp	SHORT $LN69@xmlC14NVis
$LN65@xmlC14NVis:
	mov	eax, 1
$LN69@xmlC14NVis:

; 433  : 
; 434  :     if (cur->nsTab != NULL) {

	cmp	DWORD PTR [ecx+16], 0
	push	esi
	mov	DWORD PTR _has_empty_ns$1$[ebp], eax
	push	edi
	je	SHORT $LN3@xmlC14NVis

; 435  : 	int start = (has_empty_ns) ? 0 : cur->nsPrevStart;

	test	eax, eax
	je	SHORT $LN15@xmlC14NVis
	xor	eax, eax
	jmp	SHORT $LN70@xmlC14NVis
$LN15@xmlC14NVis:
	mov	eax, DWORD PTR [ecx+4]
$LN70@xmlC14NVis:

; 436  :         for (i = cur->nsCurEnd - 1; i >= start; --i) {

	mov	esi, DWORD PTR [ecx]
	dec	esi
	mov	DWORD PTR _start$1$[ebp], eax
	cmp	esi, eax
	jl	SHORT $LN3@xmlC14NVis
	npad	6
$LL4@xmlC14NVis:

; 437  :             xmlNsPtr ns1 = cur->nsTab[i];

	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [eax+esi*4]

; 438  : 
; 439  : 	    if(xmlC14NStrEqual(prefix, (ns1 != NULL) ? ns1->prefix : NULL)) {

	test	edi, edi
	je	SHORT $LN17@xmlC14NVis
	mov	eax, DWORD PTR [edi+12]
	jmp	SHORT $LN18@xmlC14NVis
$LN17@xmlC14NVis:
	xor	eax, eax
$LN18@xmlC14NVis:
	push	eax
	push	ebx
	call	_xmlC14NStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN48@xmlC14NVis

; 436  :         for (i = cur->nsCurEnd - 1; i >= start; --i) {

	mov	ecx, DWORD PTR _cur$[ebp]
	dec	esi
	cmp	esi, DWORD PTR _start$1$[ebp]
	jge	SHORT $LL4@xmlC14NVis
$LN3@xmlC14NVis:

; 441  : 	    }
; 442  :         }
; 443  :     }
; 444  :     return(has_empty_ns);

	mov	eax, DWORD PTR _has_empty_ns$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlC14NVis:

; 440  : 		return(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL));

	test	edi, edi
	je	SHORT $LN19@xmlC14NVis
	mov	eax, DWORD PTR [edi+8]
	push	eax
	push	DWORD PTR _href$1$[ebp]
	call	_xmlC14NStrEqual
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlC14NVis:

; 440  : 		return(xmlC14NStrEqual(href, (ns1 != NULL) ? ns1->href : NULL));

	xor	eax, eax
	push	eax
	push	DWORD PTR _href$1$[ebp]
	call	_xmlC14NStrEqual
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlC14NVisibleNsStackFind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackShift
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlC14NVisibleNsStackShift PROC			; COMDAT

; 384  : xmlC14NVisibleNsStackShift(xmlC14NVisibleNsStackPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlC14NVis

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0BK@IPHAMDHH@shifting?5namespaces?5stack@
	push	ecx
	push	ecx
	push	2
	push	1
	push	21					; 00000015H
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 391  : }

	pop	ebp
	ret	0
$LN2@xmlC14NVis:

; 385  :     if(cur == NULL) {
; 386  :         xmlC14NErrParam("shifting namespaces stack");
; 387  : 	return;
; 388  :     }
; 389  :     cur->nsPrevStart = cur->nsPrevEnd;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+4], eax

; 390  :     cur->nsPrevEnd = cur->nsCurEnd;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax

; 391  : }

	pop	ebp
	ret	0
_xmlC14NVisibleNsStackShift ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackRestore
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlC14NVisibleNsStackRestore PROC			; COMDAT

; 373  : xmlC14NVisibleNsStackRestore(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _cur$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlC14NVis

; 374  :     if((cur == NULL) || (state == NULL)) {

	mov	ecx, DWORD PTR _state$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlC14NVis

; 375  :         xmlC14NErrParam("restoring namespaces stack");
; 376  : 	return;
; 377  :     }
; 378  :     cur->nsCurEnd = state->nsCurEnd;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 379  :     cur->nsPrevStart = state->nsPrevStart;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 380  :     cur->nsPrevEnd = state->nsPrevEnd;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 381  : }

	pop	ebp
	ret	0
$LN3@xmlC14NVis:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@NPMDIAFE@restoring?5namespaces?5stack@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 381  : }

	pop	ebp
	ret	0
_xmlC14NVisibleNsStackRestore ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackSave
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlC14NVisibleNsStackSave PROC				; COMDAT

; 361  : xmlC14NVisibleNsStackSave(xmlC14NVisibleNsStackPtr cur, xmlC14NVisibleNsStackPtr state) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _cur$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlC14NVis

; 362  :     if((cur == NULL) || (state == NULL)) {

	mov	ecx, DWORD PTR _state$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlC14NVis

; 363  :         xmlC14NErrParam("saving namespaces stack");
; 364  : 	return;
; 365  :     }
; 366  : 
; 367  :     state->nsCurEnd = cur->nsCurEnd;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 368  :     state->nsPrevStart = cur->nsPrevStart;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 369  :     state->nsPrevEnd = cur->nsPrevEnd;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 370  : }

	pop	ebp
	ret	0
$LN3@xmlC14NVis:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BI@JLOLEOEH@saving?5namespaces?5stack@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 370  : }

	pop	ebp
	ret	0
_xmlC14NVisibleNsStackSave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackAdd
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_ns$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlC14NVisibleNsStackAdd PROC				; COMDAT

; 315  : xmlC14NVisibleNsStackAdd(xmlC14NVisibleNsStackPtr cur, xmlNsPtr ns, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN3@xmlC14NVis

; 316  :     if((cur == NULL) ||
; 317  :        ((cur->nsTab == NULL) && (cur->nodeTab != NULL)) ||

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+20]
	test	ecx, ecx
	jne	SHORT $LN18@xmlC14NVis
	test	eax, eax
	jne	$LN3@xmlC14NVis

; 318  :        ((cur->nsTab != NULL) && (cur->nodeTab == NULL))) {
; 319  :         xmlC14NErrParam("adding namespace to stack");
; 320  : 	return;
; 321  :     }
; 322  : 
; 323  :     if ((cur->nsTab == NULL) && (cur->nodeTab == NULL)) {
; 324  :         cur->nsTab = (xmlNsPtr*) xmlMalloc(XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));

	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc

; 325  :         cur->nodeTab = (xmlNodePtr*) xmlMalloc(XML_NAMESPACES_DEFAULT * sizeof(xmlNodePtr));

	push	64					; 00000040H
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR _xmlMalloc

; 326  : 	if ((cur->nsTab == NULL) || (cur->nodeTab == NULL)) {

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 8
	mov	DWORD PTR [esi+20], eax
	test	ecx, ecx
	je	$LN20@xmlC14NVis
	test	eax, eax
	je	SHORT $LN20@xmlC14NVis

; 327  : 	    xmlC14NErrMemory("adding node to stack");
; 328  : 	    return;
; 329  : 	}
; 330  : 	memset(cur->nsTab, 0 , XML_NAMESPACES_DEFAULT * sizeof(xmlNsPtr));

	push	64					; 00000040H
	push	0
	push	ecx
	call	_memset

; 331  : 	memset(cur->nodeTab, 0 , XML_NAMESPACES_DEFAULT * sizeof(xmlNodePtr));

	push	64					; 00000040H
	push	0
	push	DWORD PTR [esi+20]
	call	_memset
	add	esp, 24					; 00000018H

; 332  :         cur->nsMax = XML_NAMESPACES_DEFAULT;

	mov	DWORD PTR [esi+12], 16			; 00000010H
$LN9@xmlC14NVis:

; 353  :     }
; 354  :     cur->nsTab[cur->nsCurEnd] = ns;

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR _ns$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+edx*4], eax

; 355  :     cur->nodeTab[cur->nsCurEnd] = node;

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 356  : 
; 357  :     ++cur->nsCurEnd;

	inc	DWORD PTR [esi]

; 358  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlC14NVis:

; 316  :     if((cur == NULL) ||
; 317  :        ((cur->nsTab == NULL) && (cur->nodeTab != NULL)) ||

	test	eax, eax
	je	SHORT $LN3@xmlC14NVis

; 333  :     } else if(cur->nsMax == cur->nsCurEnd) {

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN9@xmlC14NVis

; 334  : 	void *tmp;
; 335  : 	int tmpSize;
; 336  : 
; 337  : 	tmpSize = 2 * cur->nsMax;

	lea	edi, DWORD PTR [eax+eax]

; 338  : 	tmp = xmlRealloc(cur->nsTab, tmpSize * sizeof(xmlNsPtr));

	lea	ebx, DWORD PTR [edi*4]
	push	ebx
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 339  : 	if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN20@xmlC14NVis

; 340  : 	    xmlC14NErrMemory("adding node to stack");
; 341  : 	    return;
; 342  : 	}
; 343  : 	cur->nsTab = (xmlNsPtr*)tmp;
; 344  : 
; 345  : 	tmp = xmlRealloc(cur->nodeTab, tmpSize * sizeof(xmlNodePtr));

	push	ebx
	push	DWORD PTR [esi+20]
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 346  : 	if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN20@xmlC14NVis

; 348  : 	    return;
; 349  : 	}
; 350  : 	cur->nodeTab = (xmlNodePtr*)tmp;

	mov	DWORD PTR [esi+20], eax

; 351  : 
; 352  : 	cur->nsMax = tmpSize;

	mov	DWORD PTR [esi+12], edi
	jmp	SHORT $LN9@xmlC14NVis
$LN20@xmlC14NVis:

; 347  : 	    xmlC14NErrMemory("adding node to stack");

	push	OFFSET ??_C@_0BF@EOOBKFEO@adding?5node?5to?5stack@
	call	_xmlC14NErrMemory
	add	esp, 4
	pop	edi

; 358  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlC14NVis:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@NHMKFMOM@adding?5namespace?5to?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BK@NHMKFMOM@adding?5namespace?5to?5stack@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 358  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlC14NVisibleNsStackAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackDestroy
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlC14NVisibleNsStackDestroy PROC			; COMDAT

; 296  : xmlC14NVisibleNsStackDestroy(xmlC14NVisibleNsStackPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlC14NVis

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BM@PPKFPLDI@destroying?5namespaces?5stack@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	esi
	push	esi
	push	esi
	push	esi
	push	OFFSET ??_C@_0BM@PPKFPLDI@destroying?5namespaces?5stack@
	push	esi
	push	esi
	push	2
	push	1
	push	21					; 00000015H
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 311  : 
; 312  : }

	pop	ebp
	ret	0
$LN2@xmlC14NVis:

; 297  :     if(cur == NULL) {
; 298  :         xmlC14NErrParam("destroying namespaces stack");
; 299  :         return;
; 300  :     }
; 301  :     if(cur->nsTab != NULL) {

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN3@xmlC14NVis

; 302  : 	memset(cur->nsTab, 0, cur->nsMax * sizeof(xmlNsPtr));

	mov	eax, DWORD PTR [esi+12]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset

; 303  : 	xmlFree(cur->nsTab);

	push	DWORD PTR [esi+16]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN3@xmlC14NVis:

; 304  :     }
; 305  :     if(cur->nodeTab != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN4@xmlC14NVis

; 306  : 	memset(cur->nodeTab, 0, cur->nsMax * sizeof(xmlNodePtr));

	mov	eax, DWORD PTR [esi+12]
	shl	eax, 2
	push	eax
	push	0
	push	ecx
	call	_memset

; 307  : 	xmlFree(cur->nodeTab);

	push	DWORD PTR [esi+20]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN4@xmlC14NVis:

; 308  :     }
; 309  :     memset(cur, 0, sizeof(xmlC14NVisibleNsStack));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0

; 310  :     xmlFree(cur);

	push	esi
	movq	QWORD PTR [esi+16], xmm0
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 311  : 
; 312  : }

	pop	ebp
	ret	0
_xmlC14NVisibleNsStackDestroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NVisibleNsStackCreate
_TEXT	SEGMENT
_xmlC14NVisibleNsStackCreate PROC			; COMDAT
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlC14NVis

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 284  :     xmlC14NVisibleNsStackPtr ret;
; 285  : 
; 286  :     ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));
; 287  :     if (ret == NULL) {
; 288  :         xmlC14NErrMemory("creating namespaces stack");
; 289  : 	return(NULL);

	xor	eax, eax

; 292  :     return(ret);
; 293  : }

	ret	0
$LN2@xmlC14NVis:
	xorps	xmm0, xmm0

; 290  :     }
; 291  :     memset(ret, 0 , (size_t) sizeof(xmlC14NVisibleNsStack));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0

; 292  :     return(ret);
; 293  : }

	ret	0
_xmlC14NVisibleNsStackCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NExecute
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_is_visible_callback$ = 12				; size = 4
_user_data$ = 16					; size = 4
_mode$ = 20						; size = 4
_inclusive_ns_prefixes$ = 24				; size = 4
_with_comments$ = 28					; size = 4
_buf$ = 32						; size = 4
_xmlC14NExecute PROC					; COMDAT

; 1866 : 	 int with_comments, xmlOutputBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _buf$[ebp]
	test	ebx, ebx
	je	$LN5@xmlC14NExe

; 1867 : 
; 1868 :     xmlC14NCtxPtr ctx;
; 1869 :     xmlC14NMode c14n_mode = XML_C14N_1_0;
; 1870 :     int ret;
; 1871 : 
; 1872 :     if ((buf == NULL) || (doc == NULL)) {

	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN5@xmlC14NExe

; 1873 :         xmlC14NErrParam("executing c14n");
; 1874 :         return (-1);
; 1875 :     }
; 1876 : 
; 1877 :     /* for backward compatibility, we have to have "mode" as "int"
; 1878 :        and here we check that user gives valid value */
; 1879 :     switch(mode) {

	cmp	DWORD PTR _mode$[ebp], 2
	ja	$LN7@xmlC14NExe

; 1888 :     }
; 1889 : 
; 1890 :     /*
; 1891 :      *  Validate the encoding output buffer encoding
; 1892 :      */
; 1893 :     if (buf->encoder != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN8@xmlC14NExe

; 241  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0EN@NONIGHAH@xmlC14NExecute?3?5output?5buffer?5e@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1951					; 0000079fH
	push	21					; 00000015H
	push	edi
$LN41@xmlC14NExe:

; 1942 : }

	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	or	eax, -1
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlC14NExe:
	push	esi

; 1803 :     ctx = (xmlC14NCtxPtr) xmlMalloc(sizeof(xmlC14NCtx));

	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1804 :     if (ctx == NULL) {

	test	esi, esi
	jne	SHORT $LN23@xmlC14NExe

; 1805 : 	xmlC14NErrMemory("creating context");

	push	OFFSET ??_C@_0BB@FCGDFAMA@creating?5context@
	call	_xmlC14NErrMemory
	add	esp, 4

; 1806 :         return (NULL);

	jmp	$LN37@xmlC14NExe
$LN23@xmlC14NExe:

; 1814 :     ctx->with_comments = with_comments;

	mov	eax, DWORD PTR _with_comments$[ebp]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+12], eax

; 1815 :     ctx->is_visible_callback = is_visible_callback;

	mov	eax, DWORD PTR _is_visible_callback$[ebp]
	mov	DWORD PTR [esi+4], eax

; 1816 :     ctx->user_data = user_data;

	mov	eax, DWORD PTR _user_data$[ebp]

; 286  :     ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));

	push	24					; 00000018H

; 1813 :     ctx->doc = doc;

	mov	DWORD PTR [esi], edi

; 1816 :     ctx->user_data = user_data;

	mov	DWORD PTR [esi+8], eax

; 1817 :     ctx->buf = buf;

	mov	DWORD PTR [esi+16], ebx

; 1818 :     ctx->parent_is_doc = 1;

	mov	DWORD PTR [esi+24], 1

; 1819 :     ctx->pos = XMLC14N_BEFORE_DOCUMENT_ELEMENT;

	mov	DWORD PTR [esi+20], 0

; 286  :     ret = (xmlC14NVisibleNsStackPtr) xmlMalloc(sizeof(xmlC14NVisibleNsStack));

	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 287  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN30@xmlC14NExe

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BK@MOKDAME@creating?5namespaces?5stack@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 289  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN29@xmlC14NExe
$LN30@xmlC14NExe:
	xorps	xmm0, xmm0

; 290  :     }
; 291  :     memset(ret, 0 , (size_t) sizeof(xmlC14NVisibleNsStack));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
$LN29@xmlC14NExe:

; 1820 :     ctx->ns_rendered = xmlC14NVisibleNsStackCreate();

	mov	DWORD PTR [esi+28], eax

; 1821 : 
; 1822 :     if(ctx->ns_rendered == NULL) {

	test	eax, eax
	jne	SHORT $LN24@xmlC14NExe

; 1823 :         xmlC14NErr(ctx, (xmlNodePtr) doc, XML_C14N_CREATE_STACK,

	push	OFFSET ??_C@_0DD@MDGGAHKJ@xmlC14NNewCtx?3?5xmlC14NVisibleNs@
	push	1952					; 000007a0H
	push	edi
	push	esi
	call	_xmlC14NErr

; 1824 : 		   "xmlC14NNewCtx: xmlC14NVisibleNsStackCreate failed\n");
; 1825 : 	xmlC14NFreeCtx(ctx);

	push	esi
	call	_xmlC14NFreeCtx
	add	esp, 20					; 00000014H
$LN37@xmlC14NExe:

; 241  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CP@LLPDGIDM@xmlC14NExecute?3?5unable?5to?5creat@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	1950					; 0000079eH
	push	21					; 00000015H
	push	edi
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1934 :         return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1942 : }

	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlC14NExe:

; 1833 :     ctx->mode = mode;

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [esi+32], eax

; 1834 :     if(xmlC14NIsExclusive(ctx)) {

	cmp	eax, 1
	jne	SHORT $LN9@xmlC14NExe

; 1835 :         ctx->inclusive_ns_prefixes = inclusive_ns_prefixes;

	mov	eax, DWORD PTR _inclusive_ns_prefixes$[ebp]
	mov	DWORD PTR [esi+36], eax
$LN9@xmlC14NExe:

; 1894 :         xmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_REQUIRES_UTF8,
; 1895 : "xmlC14NExecute: output buffer encoder != NULL but C14N requires UTF8 output\n");
; 1896 :         return (-1);
; 1897 :     }
; 1898 : 
; 1899 :     ctx = xmlC14NNewCtx(doc, is_visible_callback, user_data,
; 1900 : 	            c14n_mode, inclusive_ns_prefixes,
; 1901 :                     with_comments, buf);
; 1902 :     if (ctx == NULL) {
; 1903 :         xmlC14NErr(NULL, (xmlNodePtr) doc, XML_C14N_CREATE_CTXT,
; 1904 : 		   "xmlC14NExecute: unable to create C14N context\n");
; 1905 :         return (-1);
; 1906 :     }
; 1907 : 
; 1908 : 
; 1909 : 
; 1910 :     /*
; 1911 :      * Root Node
; 1912 :      * The root node is the parent of the top-level document element. The
; 1913 :      * result of processing each of its child nodes that is in the node-set
; 1914 :      * in document order. The root node does not generate a byte order mark,
; 1915 :      * XML declaration, nor anything from within the document type
; 1916 :      * declaration.
; 1917 :      */
; 1918 :     if (doc->children != NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN11@xmlC14NExe

; 1919 :         ret = xmlC14NProcessNodeList(ctx, doc->children);

	push	eax
	push	esi
	call	_xmlC14NProcessNodeList
	add	esp, 8

; 1920 :         if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN11@xmlC14NExe

; 1921 :             xmlC14NErrInternal("processing docs children list");

	push	OFFSET ??_C@_0BO@LANGFLMG@processing?5docs?5children?5list@

; 1922 :             xmlC14NFreeCtx(ctx);
; 1923 :             return (-1);

	jmp	SHORT $LN39@xmlC14NExe
$LN11@xmlC14NExe:

; 1924 :         }
; 1925 :     }
; 1926 : 
; 1927 :     /*
; 1928 :      * Flush buffer to get number of bytes written
; 1929 :      */
; 1930 :     ret = xmlOutputBufferFlush(buf);

	push	ebx
	call	_xmlOutputBufferFlush
	mov	edi, eax
	add	esp, 4

; 1931 :     if (ret < 0) {

	test	edi, edi
	jns	SHORT $LN12@xmlC14NExe

; 1932 :         xmlC14NErrInternal("flushing output buffer");

	push	OFFSET ??_C@_0BH@PKBMLLNP@flushing?5output?5buffer@
$LN39@xmlC14NExe:
	call	_xmlC14NErrInternal

; 1933 :         xmlC14NFreeCtx(ctx);

	push	esi
	call	_xmlC14NFreeCtx
	add	esp, 8

; 1934 :         return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1942 : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlC14NExe:

; 1935 :     }
; 1936 : 
; 1937 :     /*
; 1938 :      * Cleanup
; 1939 :      */
; 1940 :     xmlC14NFreeCtx(ctx);

	push	esi
	call	_xmlC14NFreeCtx
	add	esp, 4

; 1941 :     return (ret);

	mov	eax, edi
	pop	esi
	pop	edi

; 1942 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlC14NExe:

; 1880 :     case XML_C14N_1_0:
; 1881 :     case XML_C14N_EXCLUSIVE_1_0:
; 1882 :     case XML_C14N_1_1:
; 1883 :          c14n_mode = (xmlC14NMode)mode;
; 1884 :          break;
; 1885 :     default:
; 1886 :         xmlC14NErrParam("invalid mode for executing c14n");

	push	OFFSET ??_C@_0CA@INCMFAFG@invalid?5mode?5for?5executing?5c14n@
	call	_xmlC14NErrParam
	add	esp, 4

; 1887 :         return (-1);

	or	eax, -1
	pop	edi

; 1942 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlC14NExe:

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0P@IOGBMNPC@executing?5c14n@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0P@IOGBMNPC@executing?5c14n@
	push	0
	push	0
	push	2
	push	1
	push	21					; 00000015H
	push	0
	jmp	$LN41@xmlC14NExe
_xmlC14NExecute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NDocSave
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_nodes$ = 12						; size = 4
_mode$ = 16						; size = 4
_inclusive_ns_prefixes$ = 20				; size = 4
_with_comments$ = 24					; size = 4
_filename$ = 28						; size = 4
_compression$ = 32					; size = 4
_xmlC14NDocSave PROC					; COMDAT

; 2075 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlC14NDoc

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0L@DHCGOHBD@saving?5doc@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	esi
	push	esi
	push	esi
	push	esi
	push	OFFSET ??_C@_0L@DHCGOHBD@saving?5doc@
	push	esi
	push	esi
	push	2
	push	1
	push	21					; 00000015H
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2076 :     xmlOutputBufferPtr buf;
; 2077 :     int ret;
; 2078 : 
; 2079 :     if (filename == NULL) {
; 2080 :         xmlC14NErrParam("saving doc");
; 2081 :         return (-1);

	or	eax, -1
	pop	esi

; 2112 :     return (ret);
; 2113 : }

	pop	ebp
	ret	0
$LN2@xmlC14NDoc:

; 2082 :     }
; 2083 : #ifdef LIBXML_ZLIB_ENABLED
; 2084 :     if (compression < 0)

	mov	eax, DWORD PTR _compression$[ebp]
	test	eax, eax
	jns	SHORT $LN3@xmlC14NDoc

; 2085 :         compression = xmlGetCompressMode();

	call	_xmlGetCompressMode
$LN3@xmlC14NDoc:

; 2086 : #endif
; 2087 : 
; 2088 :     /*
; 2089 :      * save the content to a temp buffer, use default UTF8 encoding.
; 2090 :      */
; 2091 :     buf = xmlOutputBufferCreateFilename(filename, NULL, compression);

	push	eax
	push	0
	push	esi
	call	_xmlOutputBufferCreateFilename
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2092 :     if (buf == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlC14NDoc

; 172  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BM@LBLOCGLL@creating?5temporary?5filename@
	push	OFFSET ??_C@_0BF@KAEIDNN@Internal?5error?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BM@LBLOCGLL@creating?5temporary?5filename@
	push	eax
	push	eax
	push	2
	push	1
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2093 :         xmlC14NErrInternal("creating temporary filename");
; 2094 :         return (-1);

	or	eax, -1
	pop	esi

; 2112 :     return (ret);
; 2113 : }

	pop	ebp
	ret	0
$LN4@xmlC14NDoc:

; 1969 :     return(xmlC14NExecute(doc,

	push	esi
	push	DWORD PTR _with_comments$[ebp]
	push	DWORD PTR _inclusive_ns_prefixes$[ebp]
	push	DWORD PTR _mode$[ebp]
	push	DWORD PTR _nodes$[ebp]
	push	OFFSET _xmlC14NIsNodeInNodeset
	push	DWORD PTR _doc$[ebp]
	call	_xmlC14NExecute
	add	esp, 28					; 0000001cH

; 2095 :     }
; 2096 : 
; 2097 :     /*
; 2098 :      * canonize document and write to buffer
; 2099 :      */
; 2100 :     ret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,
; 2101 :                            with_comments, buf);
; 2102 :     if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN5@xmlC14NDoc

; 2103 :         xmlC14NErrInternal("cannicanize document to buffer");

	push	OFFSET ??_C@_0BP@ODPNHIDP@cannicanize?5document?5to?5buffer@
	call	_xmlC14NErrInternal

; 2104 :         (void) xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 8

; 2105 :         return (-1);

	or	eax, -1
	pop	esi

; 2112 :     return (ret);
; 2113 : }

	pop	ebp
	ret	0
$LN5@xmlC14NDoc:

; 2106 :     }
; 2107 : 
; 2108 :     /*
; 2109 :      * get the numbers of bytes written
; 2110 :      */
; 2111 :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4
	pop	esi

; 2112 :     return (ret);
; 2113 : }

	pop	ebp
	ret	0
_xmlC14NDocSave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NDocDumpMemory
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_nodes$ = 12						; size = 4
_mode$ = 16						; size = 4
_inclusive_ns_prefixes$ = 20				; size = 4
_with_comments$ = 24					; size = 4
_doc_txt_ptr$ = 28					; size = 4
_xmlC14NDocDumpMemory PROC				; COMDAT

; 2004 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc_txt_ptr$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlC14NDoc

; 157  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BG@JFDMFMGH@dumping?5doc?5to?5memory@
	push	OFFSET ??_C@_0BI@NBDMDFEL@Invalid?5parameter?5?3?5?$CFs?6@
	push	edi
	push	edi
	push	edi
	push	edi
	push	OFFSET ??_C@_0BG@JFDMFMGH@dumping?5doc?5to?5memory@
	push	edi
	push	edi
	push	2
	push	1
	push	21					; 00000015H
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2005 :     int ret;
; 2006 :     xmlOutputBufferPtr buf;
; 2007 : 
; 2008 :     if (doc_txt_ptr == NULL) {
; 2009 :         xmlC14NErrParam("dumping doc to memory");
; 2010 :         return (-1);

	or	eax, -1
	pop	edi

; 2046 : }

	pop	ebp
	ret	0
$LN2@xmlC14NDoc:
	push	esi

; 2011 :     }
; 2012 : 
; 2013 :     *doc_txt_ptr = NULL;
; 2014 : 
; 2015 :     /*
; 2016 :      * create memory buffer with UTF8 (default) encoding
; 2017 :      */
; 2018 :     buf = xmlAllocOutputBuffer(NULL);

	push	0
	mov	DWORD PTR [edi], 0
	call	_xmlAllocOutputBuffer
	mov	esi, eax
	add	esp, 4

; 2019 :     if (buf == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlC14NDoc

; 142  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_C14N,

	push	OFFSET ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	push	21					; 00000015H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2020 :         xmlC14NErrMemory("creating output buffer");
; 2021 :         return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 2046 : }

	pop	ebp
	ret	0
$LN3@xmlC14NDoc:

; 1969 :     return(xmlC14NExecute(doc,

	push	esi
	push	DWORD PTR _with_comments$[ebp]
	push	DWORD PTR _inclusive_ns_prefixes$[ebp]
	push	DWORD PTR _mode$[ebp]
	push	DWORD PTR _nodes$[ebp]
	push	OFFSET _xmlC14NIsNodeInNodeset
	push	DWORD PTR _doc$[ebp]
	call	_xmlC14NExecute
	add	esp, 28					; 0000001cH

; 2022 :     }
; 2023 : 
; 2024 :     /*
; 2025 :      * canonize document and write to buffer
; 2026 :      */
; 2027 :     ret = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes,
; 2028 :                            with_comments, buf);
; 2029 :     if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN4@xmlC14NDoc

; 2030 :         xmlC14NErrInternal("saving doc to output buffer");

	push	OFFSET ??_C@_0BM@DBHHIABI@saving?5doc?5to?5output?5buffer@
	call	_xmlC14NErrInternal

; 2031 :         (void) xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 8

; 2032 :         return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 2046 : }

	pop	ebp
	ret	0
$LN4@xmlC14NDoc:
	push	ebx

; 2033 :     }
; 2034 : 
; 2035 :     ret = xmlBufUse(buf->buffer);

	push	DWORD PTR [esi+16]
	call	_xmlBufUse
	mov	ebx, eax
	add	esp, 4

; 2036 :     if (ret > 0) {

	test	ebx, ebx
	jle	SHORT $LN5@xmlC14NDoc

; 2037 :         *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), ret);

	push	ebx
	push	DWORD PTR [esi+16]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN5@xmlC14NDoc:

; 2038 :     }
; 2039 :     (void) xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4

; 2040 : 
; 2041 :     if ((*doc_txt_ptr == NULL) && (ret > 0)) {

	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN6@xmlC14NDoc
	test	ebx, ebx
	jle	SHORT $LN6@xmlC14NDoc

; 2042 :         xmlC14NErrMemory("coping canonicanized document");

	push	OFFSET ??_C@_0BO@FJFGKMEA@coping?5canonicanized?5document@
	call	_xmlC14NErrMemory
	add	esp, 4

; 2043 :         return (-1);

	or	eax, -1
	pop	ebx
	pop	esi
	pop	edi

; 2046 : }

	pop	ebp
	ret	0
$LN6@xmlC14NDoc:

; 2044 :     }
; 2045 :     return (ret);

	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi

; 2046 : }

	pop	ebp
	ret	0
_xmlC14NDocDumpMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\c14n.c
;	COMDAT _xmlC14NDocSaveTo
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_nodes$ = 12						; size = 4
_mode$ = 16						; size = 4
_inclusive_ns_prefixes$ = 20				; size = 4
_with_comments$ = 24					; size = 4
_buf$ = 28						; size = 4
_xmlC14NDocSaveTo PROC					; COMDAT

; 1968 :                  int with_comments, xmlOutputBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __27F3A1DF_c14n@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _buf$[ebp]
	push	DWORD PTR _with_comments$[ebp]
	push	DWORD PTR _inclusive_ns_prefixes$[ebp]
	push	DWORD PTR _mode$[ebp]
	push	DWORD PTR _nodes$[ebp]
	push	OFFSET _xmlC14NIsNodeInNodeset
	push	DWORD PTR _doc$[ebp]
	call	_xmlC14NExecute
	add	esp, 28					; 0000001cH

; 1969 :     return(xmlC14NExecute(doc,
; 1970 : 			xmlC14NIsNodeInNodeset,
; 1971 : 			nodes,
; 1972 : 			mode,
; 1973 : 			inclusive_ns_prefixes,
; 1974 : 			with_comments,
; 1975 : 			buf));
; 1976 : }

	pop	ebp
	ret	0
_xmlC14NDocSaveTo ENDP
_TEXT	ENDS
END
