; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlregexp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_forbiddenExp
PUBLIC	_emptyExp
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__F6DD4902_xmlregexp@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
_forbiddenExp DD FLAT:_forbiddenExpNode
_emptyExp DD	FLAT:_emptyExpNode
_forbiddenExpNode DB 01H
	DB	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_emptyExpNode DB 00H
	DB	01H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_snprintf
PUBLIC	_xmlRegexpCompile
PUBLIC	_xmlRegFreeRegexp
PUBLIC	_xmlRegexpExec
PUBLIC	_xmlRegexpPrint
PUBLIC	_xmlRegexpIsDeterminist
PUBLIC	_xmlRegNewExecCtxt
PUBLIC	_xmlRegFreeExecCtxt
PUBLIC	_xmlRegExecPushString
PUBLIC	_xmlRegExecPushString2
PUBLIC	_xmlRegExecNextValues
PUBLIC	_xmlRegExecErrInfo
PUBLIC	_xmlExpFreeCtxt
PUBLIC	_xmlExpNewCtxt
PUBLIC	_xmlExpCtxtNbNodes
PUBLIC	_xmlExpCtxtNbCons
PUBLIC	_xmlExpFree
PUBLIC	_xmlExpRef
PUBLIC	_xmlExpParse
PUBLIC	_xmlExpNewAtom
PUBLIC	_xmlExpNewOr
PUBLIC	_xmlExpNewSeq
PUBLIC	_xmlExpNewRange
PUBLIC	_xmlExpIsNillable
PUBLIC	_xmlExpMaxToken
PUBLIC	_xmlExpGetLanguage
PUBLIC	_xmlExpGetStart
PUBLIC	_xmlExpStringDerive
PUBLIC	_xmlExpExpDerive
PUBLIC	_xmlExpSubsume
PUBLIC	_xmlExpDump
PUBLIC	_xmlNewAutomata
PUBLIC	_xmlFreeAutomata
PUBLIC	_xmlAutomataGetInitState
PUBLIC	_xmlAutomataSetFinalState
PUBLIC	_xmlAutomataNewState
PUBLIC	_xmlAutomataNewTransition
PUBLIC	_xmlAutomataNewTransition2
PUBLIC	_xmlAutomataNewNegTrans
PUBLIC	_xmlAutomataNewCountTrans
PUBLIC	_xmlAutomataNewCountTrans2
PUBLIC	_xmlAutomataNewOnceTrans
PUBLIC	_xmlAutomataNewOnceTrans2
PUBLIC	_xmlAutomataNewAllTrans
PUBLIC	_xmlAutomataNewEpsilon
PUBLIC	_xmlAutomataNewCountedTrans
PUBLIC	_xmlAutomataNewCounterTrans
PUBLIC	_xmlAutomataNewCounter
PUBLIC	_xmlAutomataCompile
PUBLIC	_xmlAutomataIsDeterminist
PUBLIC	_xmlAutomataSetFlags
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BB@FJPDMDM@compiling?5regexp@		; `string'
PUBLIC	??_C@_0BB@PBEHJOM@allocating?5range@		; `string'
PUBLIC	??_C@_0BA@JCPCIFNM@allocating?5atom@		; `string'
PUBLIC	??_C@_0N@ECMBACNP@copying?5atom@		; `string'
PUBLIC	??_C@_0BB@CKELLPME@allocating?5state@		; `string'
PUBLIC	??_C@_08LJGDJFJP@epsilon?5@			; `string'
PUBLIC	??_C@_08DFHMJFEK@charval?5@			; `string'
PUBLIC	??_C@_07IPEOMBMH@ranges?5@			; `string'
PUBLIC	??_C@_08BABENLJO@subexpr?5@			; `string'
PUBLIC	??_C@_07HBAIICBM@string?5@			; `string'
PUBLIC	??_C@_08IIDGBAEF@anychar?5@			; `string'
PUBLIC	??_C@_09IFBFMEEE@anyspace?5@			; `string'
PUBLIC	??_C@_09PIGAJOFL@notspace?5@			; `string'
PUBLIC	??_C@_09PGNNJPMN@initname?5@			; `string'
PUBLIC	??_C@_0N@PKALLFNP@notinitname?5@		; `string'
PUBLIC	??_C@_09GMGKKJAH@namechar?5@			; `string'
PUBLIC	??_C@_0N@GALMIDBF@notnamechar?5@		; `string'
PUBLIC	??_C@_08CDKGKILA@decimal?5@			; `string'
PUBLIC	??_C@_0M@EDJHICHL@notdecimal?5@			; `string'
PUBLIC	??_C@_09MOCDMJPB@realchar?5@			; `string'
PUBLIC	??_C@_0N@MCPFODOD@notrealchar?5@		; `string'
PUBLIC	??_C@_07POCGPIHD@LETTER?5@			; `string'
PUBLIC	??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@		; `string'
PUBLIC	??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@		; `string'
PUBLIC	??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@		; `string'
PUBLIC	??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@		; `string'
PUBLIC	??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@		; `string'
PUBLIC	??_C@_05BACHLHLN@MARK?5@			; `string'
PUBLIC	??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@		; `string'
PUBLIC	??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@	; `string'
PUBLIC	??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@		; `string'
PUBLIC	??_C@_07BAKEFCLB@NUMBER?5@			; `string'
PUBLIC	??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@		; `string'
PUBLIC	??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@		; `string'
PUBLIC	??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@		; `string'
PUBLIC	??_C@_06INFGODEH@PUNCT?5@			; `string'
PUBLIC	??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@		; `string'
PUBLIC	??_C@_0M@BBMKBPFM@PUNCT_DASH?5@			; `string'
PUBLIC	??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@			; `string'
PUBLIC	??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@		; `string'
PUBLIC	??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@		; `string'
PUBLIC	??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@		; `string'
PUBLIC	??_C@_0O@FIEDELON@PUNCT_OTHERS?5@		; `string'
PUBLIC	??_C@_06MODMGGJL@SEPAR?5@			; `string'
PUBLIC	??_C@_0N@CEDLANHM@SEPAR_SPACE?5@		; `string'
PUBLIC	??_C@_0M@GPNEEMIA@SEPAR_LINE?5@			; `string'
PUBLIC	??_C@_0M@DGHGIFFK@SEPAR_PARA?5@			; `string'
PUBLIC	??_C@_07EJLPHCCB@SYMBOL?5@			; `string'
PUBLIC	??_C@_0N@LBDJILGE@SYMBOL_MATH?5@		; `string'
PUBLIC	??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@		; `string'
PUBLIC	??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@		; `string'
PUBLIC	??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@		; `string'
PUBLIC	??_C@_06HJDKAKAL@OTHER?5@			; `string'
PUBLIC	??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@		; `string'
PUBLIC	??_C@_0O@BACNFCMB@OTHER_FORMAT?5@		; `string'
PUBLIC	??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@		; `string'
PUBLIC	??_C@_09NECDEFOF@OTHER_NA?5@			; `string'
PUBLIC	??_C@_06HDNEPAAO@BLOCK?5@			; `string'
PUBLIC	??_C@_05GDJGFPHL@once?5@			; `string'
PUBLIC	??_C@_02LKANKAOC@?$DP?5@			; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5@			; `string'
PUBLIC	??_C@_02KBCCKLEO@?$CL?5@			; `string'
PUBLIC	??_C@_06IBKHBGID@range?5@			; `string'
PUBLIC	??_C@_09EPCGBNDN@onceonly?5@			; `string'
PUBLIC	??_C@_04DIDGAIEC@all?5@				; `string'
PUBLIC	??_C@_09LLABEBOE@?5?5range?3?5@			; `string'
PUBLIC	??_C@_09KDBNABJA@negative?5@			; `string'
PUBLIC	??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@		; `string'
PUBLIC	??_C@_07LAIPMBOA@?5atom?3?5@			; `string'
PUBLIC	??_C@_05NJDBAOFA@NULL?6@			; `string'
PUBLIC	??_C@_04LKOGMCLF@not?5@				; `string'
PUBLIC	??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@		; `string'
PUBLIC	??_C@_05IMLJLABD@?8?$CFs?8?5@			; `string'
PUBLIC	??_C@_08PCGOOLFO@char?5?$CFc?6@			; `string'
PUBLIC	??_C@_0M@BCDCHBAM@?$CFd?5entries?6@		; `string'
PUBLIC	??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_09KCGMBGNH@?5?5trans?3?5@			; `string'
PUBLIC	??_C@_08IDDAKHFP@removed?6@			; `string'
PUBLIC	??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@	; `string'
PUBLIC	??_C@_0BC@EKCPHBCA@not?5determinist?0?5@	; `string'
PUBLIC	??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@		; `string'
PUBLIC	??_C@_0BB@CPMJDJHN@all?5transition?0?5@		; `string'
PUBLIC	??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@	; `string'
PUBLIC	??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@		; `string'
PUBLIC	??_C@_08JNAFCHHG@char?5?$CFc?5@			; `string'
PUBLIC	??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@	; `string'
PUBLIC	??_C@_08NOIFNCJM@?5state?3?5@			; `string'
PUBLIC	??_C@_06BNBHINFE@START?5@			; `string'
PUBLIC	??_C@_06EFHALCBA@FINAL?5@			; `string'
PUBLIC	??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@ ; `string'
PUBLIC	??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@	; `string'
PUBLIC	??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@ ; `string'
PUBLIC	??_C@_0O@INOJCFAI@adding?5ranges@		; `string'
PUBLIC	??_C@_0BD@OEINICOI@allocating?5counter@		; `string'
PUBLIC	??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@ ; `string'
PUBLIC	??_C@_0N@PMKNEBIB@pushing?5atom@		; `string'
PUBLIC	??_C@_0BC@FHJHIDDF@adding?5transition@		; `string'
PUBLIC	??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@ ; `string'
PUBLIC	??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@ ; `string'
PUBLIC	??_C@_0N@NHLBLLB@adding?5state@			; `string'
PUBLIC	??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@ ; `string'
PUBLIC	??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@	; `string'
PUBLIC	??_C@_0O@PEGCJGLF@saving?5regexp@		; `string'
PUBLIC	??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@ ; `string'
PUBLIC	??_C@_0P@IJHGICCJ@running?5regexp@		; `string'
PUBLIC	??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@ ; `string'
PUBLIC	??_C@_0BL@LMPHHOAL@creating?5execution?5context@ ; `string'
PUBLIC	??_C@_0BF@FEDDAGIG@pushing?5input?5string@	; `string'
PUBLIC	??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BA@KPLOEDJN@IsXXXX?5expected@		; `string'
PUBLIC	??_C@_0BG@ECFAFFBF@Unknown?5char?5property@	; `string'
PUBLIC	??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@ ; `string'
PUBLIC	??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@		; `string'
PUBLIC	??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@		; `string'
PUBLIC	??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@ ; `string'
PUBLIC	??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@		; `string'
PUBLIC	??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@	; `string'
PUBLIC	??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@	; `string'
PUBLIC	??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@ ; `string'
PUBLIC	??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@ ; `string'
PUBLIC	??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@ ; `string'
PUBLIC	??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@ ; `string'
PUBLIC	??_C@_0BE@PGBJEMPN@Improper?5quantifier@	; `string'
PUBLIC	??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@	; `string'
PUBLIC	??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@ ; `string'
PUBLIC	??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@ ; `string'
PUBLIC	??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@ ; `string'
PUBLIC	??_C@_09BNLLHCCB@?5regexp?3?5@			; `string'
PUBLIC	??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@		; `string'
PUBLIC	??_C@_06NLBGECGK@?5?$CF02d?5@			; `string'
PUBLIC	??_C@_0L@LDKKLMNF@?$CFd?5states?3@		; `string'
PUBLIC	??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@		; `string'
PUBLIC	??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@ ; `string'
PUBLIC	??_C@_06NGEMONLJ@not?5?$CFs@			; `string'
PUBLIC	??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI@				; `string'
PUBLIC	??_C@_05LBJMNBOG@empty@				; `string'
PUBLIC	??_C@_09PDGFMGED@forbidden@			; `string'
PUBLIC	??_C@_03NKFKBEPL@?5?0?5@			; `string'
PUBLIC	??_C@_03LGOGDKEL@?5?$HM?5@			; `string'
PUBLIC	??_C@_04PFHMOCHH@?$HL?$CFd?$HN@			; `string'
PUBLIC	??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@		; `string'
PUBLIC	??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@		; `string'
PUBLIC	??_C@_0P@OCJKDKLA@Error?5in?5tree?6@		; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictExists:PROC
EXTRN	_xmlBufferWriteCHAR:PROC
EXTRN	_xmlBufferWriteChar:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlUCSIsBlock:PROC
EXTRN	_xmlUCSIsCatC:PROC
EXTRN	_xmlUCSIsCatCc:PROC
EXTRN	_xmlUCSIsCatCf:PROC
EXTRN	_xmlUCSIsCatCo:PROC
EXTRN	_xmlUCSIsCatL:PROC
EXTRN	_xmlUCSIsCatLl:PROC
EXTRN	_xmlUCSIsCatLm:PROC
EXTRN	_xmlUCSIsCatLo:PROC
EXTRN	_xmlUCSIsCatLt:PROC
EXTRN	_xmlUCSIsCatLu:PROC
EXTRN	_xmlUCSIsCatM:PROC
EXTRN	_xmlUCSIsCatMc:PROC
EXTRN	_xmlUCSIsCatMe:PROC
EXTRN	_xmlUCSIsCatMn:PROC
EXTRN	_xmlUCSIsCatN:PROC
EXTRN	_xmlUCSIsCatNd:PROC
EXTRN	_xmlUCSIsCatNl:PROC
EXTRN	_xmlUCSIsCatNo:PROC
EXTRN	_xmlUCSIsCatP:PROC
EXTRN	_xmlUCSIsCatPc:PROC
EXTRN	_xmlUCSIsCatPd:PROC
EXTRN	_xmlUCSIsCatPe:PROC
EXTRN	_xmlUCSIsCatPf:PROC
EXTRN	_xmlUCSIsCatPi:PROC
EXTRN	_xmlUCSIsCatPo:PROC
EXTRN	_xmlUCSIsCatPs:PROC
EXTRN	_xmlUCSIsCatS:PROC
EXTRN	_xmlUCSIsCatSc:PROC
EXTRN	_xmlUCSIsCatSk:PROC
EXTRN	_xmlUCSIsCatSm:PROC
EXTRN	_xmlUCSIsCatSo:PROC
EXTRN	_xmlUCSIsCatZ:PROC
EXTRN	_xmlUCSIsCatZl:PROC
EXTRN	_xmlUCSIsCatZp:PROC
EXTRN	_xmlUCSIsCatZs:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OCJKDKLA@Error?5in?5tree?6@
CONST	SEGMENT
??_C@_0P@OCJKDKLA@Error?5in?5tree?6@ DB 'Error in tree', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@
CONST	SEGMENT
??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@ DB '{%d,%d}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@
CONST	SEGMENT
??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@ DB '{%d,inf}', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFHMOCHH@?$HL?$CFd?$HN@
CONST	SEGMENT
??_C@_04PFHMOCHH@?$HL?$CFd?$HN@ DB '{%d}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGOGDKEL@?5?$HM?5@
CONST	SEGMENT
??_C@_03LGOGDKEL@?5?$HM?5@ DB ' | ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKFKBEPL@?5?0?5@
CONST	SEGMENT
??_C@_03NKFKBEPL@?5?0?5@ DB ' , ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDGFMGED@forbidden@
CONST	SEGMENT
??_C@_09PDGFMGED@forbidden@ DB 'forbidden', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBJMNBOG@empty@
CONST	SEGMENT
??_C@_05LBJMNBOG@empty@ DB 'empty', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@ DB 'unbalanced ''('''
	DB	' : %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06NGEMONLJ@not?5?$CFs@
CONST	SEGMENT
??_C@_06NGEMONLJ@not?5?$CFs@ DB 'not %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@
CONST	SEGMENT
??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@ DB 'xmlFAParseRegE'
	DB	'xp: extra characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@
CONST	SEGMENT
??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@ DB ' %d: min %d m'
	DB	'ax %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@
CONST	SEGMENT
??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@ DB '%d counters:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LDKKLMNF@?$CFd?5states?3@
CONST	SEGMENT
??_C@_0L@LDKKLMNF@?$CFd?5states?3@ DB '%d states:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLBGECGK@?5?$CF02d?5@
CONST	SEGMENT
??_C@_06NLBGECGK@?5?$CF02d?5@ DB ' %02d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@
CONST	SEGMENT
??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@ DB '%d atoms:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNLLHCCB@?5regexp?3?5@
CONST	SEGMENT
??_C@_09BNLLHCCB@?5regexp?3?5@ DB ' regexp: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@
CONST	SEGMENT
??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@ DB 'expecting a bra'
	DB	'nch after |', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@
CONST	SEGMENT
??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@ DB 'internal: no atom'
	DB	' generated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@
CONST	SEGMENT
??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@ DB 'xmlFAParseA'
	DB	'tom: expecting '')''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@
CONST	SEGMENT
??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@ DB 'Unterminated quantifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGBJEMPN@Improper?5quantifier@
CONST	SEGMENT
??_C@_0BE@PGBJEMPN@Improper?5quantifier@ DB 'Improper quantifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@
CONST	SEGMENT
??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@ DB 'xmlFAPars'
	DB	'eCharClass: '']'' expected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@
CONST	SEGMENT
??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@ DB 'charClassExpr'
	DB	': '']'' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@
CONST	SEGMENT
??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@ DB 'End of rang'
	DB	'e is before start of range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@
CONST	SEGMENT
??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@ DB 'Expecting t'
	DB	'he end of a char range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@
CONST	SEGMENT
??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@ DB 'Expecting a char range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@
CONST	SEGMENT
??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@ DB 'Invalid escape value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@
CONST	SEGMENT
??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@ DB 'Expecting '']''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@
CONST	SEGMENT
??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@ DB 'Wrong escape'
	DB	' sequence, misuse of character ''\''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@
CONST	SEGMENT
??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@ DB 'Expecting ''}''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@
CONST	SEGMENT
??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@ DB 'Expecting ''{''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@
CONST	SEGMENT
??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@ DB 'Escaped sequen'
	DB	'ce: expecting \', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECFAFFBF@Unknown?5char?5property@
CONST	SEGMENT
??_C@_0BG@ECFAFFBF@Unknown?5char?5property@ DB 'Unknown char property', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPLOEDJN@IsXXXX?5expected@
CONST	SEGMENT
??_C@_0BA@KPLOEDJN@IsXXXX?5expected@ DB 'IsXXXX expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlregexp.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
CONST	SEGMENT
??_C@_0BF@FEDDAGIG@pushing?5input?5string@ DB 'pushing input string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
CONST	SEGMENT
??_C@_0BL@LMPHHOAL@creating?5execution?5context@ DB 'creating execution c'
	DB	'ontext', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
CONST	SEGMENT
??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@ DB 'epsilon trans'
	DB	'ition left at runtime', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IJHGICCJ@running?5regexp@
CONST	SEGMENT
??_C@_0P@IJHGICCJ@running?5regexp@ DB 'running regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@
CONST	SEGMENT
??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@ DB 'exec save: alloc'
	DB	'ation failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEGCJGLF@saving?5regexp@
CONST	SEGMENT
??_C@_0O@PEGCJGLF@saving?5regexp@ DB 'saving regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@
CONST	SEGMENT
??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@ DB 'TODO: XML_REGEXP_STRI'
	DB	'NG', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@
CONST	SEGMENT
??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@ DB 'genrat'
	DB	'e transition: atom == NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHLBLLB@adding?5state@
CONST	SEGMENT
??_C@_0N@NHLBLLB@adding?5state@ DB 'adding state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@
CONST	SEGMENT
??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@ DB 'add state: target '
	DB	'is NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@
CONST	SEGMENT
??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@ DB 'add state: state is'
	DB	' NULL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FHJHIDDF@adding?5transition@
CONST	SEGMENT
??_C@_0BC@FHJHIDDF@adding?5transition@ DB 'adding transition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PMKNEBIB@pushing?5atom@
CONST	SEGMENT
??_C@_0N@PMKNEBIB@pushing?5atom@ DB 'pushing atom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@
CONST	SEGMENT
??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@ DB 'atom push: atom is N'
	DB	'ULL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEINICOI@allocating?5counter@
CONST	SEGMENT
??_C@_0BD@OEINICOI@allocating?5counter@ DB 'allocating counter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INOJCFAI@adding?5ranges@
CONST	SEGMENT
??_C@_0O@INOJCFAI@adding?5ranges@ DB 'adding ranges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@
CONST	SEGMENT
??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@ DB 'add range: at'
	DB	'om is not ranges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@
CONST	SEGMENT
??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@ DB 'add range: atom is NUL'
	DB	'L', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@
CONST	SEGMENT
??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@ DB '%d, %d transition'
	DB	's:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFHALCBA@FINAL?5@
CONST	SEGMENT
??_C@_06EFHALCBA@FINAL?5@ DB 'FINAL ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNBHINFE@START?5@
CONST	SEGMENT
??_C@_06BNBHINFE@START?5@ DB 'START ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOIFNCJM@?5state?3?5@
CONST	SEGMENT
??_C@_08NOIFNCJM@?5state?3?5@ DB ' state: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@ DB 'atom %d, to %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNAFCHHG@char?5?$CFc?5@
CONST	SEGMENT
??_C@_08JNAFCHHG@char?5?$CFc?5@ DB 'char %c ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@ DB 'epsilon to %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@ DB 'count based %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPMJDJHN@all?5transition?0?5@
CONST	SEGMENT
??_C@_0BB@CPMJDJHN@all?5transition?0?5@ DB 'all transition, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@ DB 'counted %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EKCPHBCA@not?5determinist?0?5@
CONST	SEGMENT
??_C@_0BC@EKCPHBCA@not?5determinist?0?5@ DB 'not determinist, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@
CONST	SEGMENT
??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@ DB 'last not determinist, '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDDAKHFP@removed?6@
CONST	SEGMENT
??_C@_08IDDAKHFP@removed?6@ DB 'removed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCGMBGNH@?5?5trans?3?5@
CONST	SEGMENT
??_C@_09KCGMBGNH@?5?5trans?3?5@ DB '  trans: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@
CONST	SEGMENT
??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@ DB 'start %d end %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCDCHBAM@?$CFd?5entries?6@
CONST	SEGMENT
??_C@_0M@BCDCHBAM@?$CFd?5entries?6@ DB '%d entries', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PCGOOLFO@char?5?$CFc?6@
CONST	SEGMENT
??_C@_08PCGOOLFO@char?5?$CFc?6@ DB 'char %c', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IMLJLABD@?8?$CFs?8?5@
CONST	SEGMENT
??_C@_05IMLJLABD@?8?$CFs?8?5@ DB '''%s'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@
CONST	SEGMENT
??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@ DB '%d-%d ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKOGMCLF@not?5@
CONST	SEGMENT
??_C@_04LKOGMCLF@not?5@ DB 'not ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJDBAOFA@NULL?6@
CONST	SEGMENT
??_C@_05NJDBAOFA@NULL?6@ DB 'NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LAIPMBOA@?5atom?3?5@
CONST	SEGMENT
??_C@_07LAIPMBOA@?5atom?3?5@ DB ' atom: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@
CONST	SEGMENT
??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@ DB '%c - %c', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDBNABJA@negative?5@
CONST	SEGMENT
??_C@_09KDBNABJA@negative?5@ DB 'negative ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLABEBOE@?5?5range?3?5@
CONST	SEGMENT
??_C@_09LLABEBOE@?5?5range?3?5@ DB '  range: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIDGAIEC@all?5@
CONST	SEGMENT
??_C@_04DIDGAIEC@all?5@ DB 'all ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPCGBNDN@onceonly?5@
CONST	SEGMENT
??_C@_09EPCGBNDN@onceonly?5@ DB 'onceonly ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBKHBGID@range?5@
CONST	SEGMENT
??_C@_06IBKHBGID@range?5@ DB 'range ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KBCCKLEO@?$CL?5@
CONST	SEGMENT
??_C@_02KBCCKLEO@?$CL?5@ DB '+ ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5@ DB '* ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LKANKAOC@?$DP?5@
CONST	SEGMENT
??_C@_02LKANKAOC@?$DP?5@ DB '? ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GDJGFPHL@once?5@
CONST	SEGMENT
??_C@_05GDJGFPHL@once?5@ DB 'once ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDNEPAAO@BLOCK?5@
CONST	SEGMENT
??_C@_06HDNEPAAO@BLOCK?5@ DB 'BLOCK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NECDEFOF@OTHER_NA?5@
CONST	SEGMENT
??_C@_09NECDEFOF@OTHER_NA?5@ DB 'OTHER_NA ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@
CONST	SEGMENT
??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@ DB 'OTHER_PRIVATE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BACNFCMB@OTHER_FORMAT?5@
CONST	SEGMENT
??_C@_0O@BACNFCMB@OTHER_FORMAT?5@ DB 'OTHER_FORMAT ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@
CONST	SEGMENT
??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@ DB 'OTHER_CONTROL ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJDKAKAL@OTHER?5@
CONST	SEGMENT
??_C@_06HJDKAKAL@OTHER?5@ DB 'OTHER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@
CONST	SEGMENT
??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@ DB 'SYMBOL_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@
CONST	SEGMENT
??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@ DB 'SYMBOL_MODIFIER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@
CONST	SEGMENT
??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@ DB 'SYMBOL_CURRENCY ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LBDJILGE@SYMBOL_MATH?5@
CONST	SEGMENT
??_C@_0N@LBDJILGE@SYMBOL_MATH?5@ DB 'SYMBOL_MATH ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJLPHCCB@SYMBOL?5@
CONST	SEGMENT
??_C@_07EJLPHCCB@SYMBOL?5@ DB 'SYMBOL ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGHGIFFK@SEPAR_PARA?5@
CONST	SEGMENT
??_C@_0M@DGHGIFFK@SEPAR_PARA?5@ DB 'SEPAR_PARA ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPNEEMIA@SEPAR_LINE?5@
CONST	SEGMENT
??_C@_0M@GPNEEMIA@SEPAR_LINE?5@ DB 'SEPAR_LINE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CEDLANHM@SEPAR_SPACE?5@
CONST	SEGMENT
??_C@_0N@CEDLANHM@SEPAR_SPACE?5@ DB 'SEPAR_SPACE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MODMGGJL@SEPAR?5@
CONST	SEGMENT
??_C@_06MODMGGJL@SEPAR?5@ DB 'SEPAR ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIEDELON@PUNCT_OTHERS?5@
CONST	SEGMENT
??_C@_0O@FIEDELON@PUNCT_OTHERS?5@ DB 'PUNCT_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@
CONST	SEGMENT
??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@ DB 'PUNCT_FINQUOTE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@
CONST	SEGMENT
??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@ DB 'PUNCT_INITQUOTE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@
CONST	SEGMENT
??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@ DB 'PUNCT_CLOSE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@
CONST	SEGMENT
??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@ DB 'PUNCT_OPEN ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBMKBPFM@PUNCT_DASH?5@
CONST	SEGMENT
??_C@_0M@BBMKBPFM@PUNCT_DASH?5@ DB 'PUNCT_DASH ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@
CONST	SEGMENT
??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@ DB 'PUNCT_CONNECTOR ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06INFGODEH@PUNCT?5@
CONST	SEGMENT
??_C@_06INFGODEH@PUNCT?5@ DB 'PUNCT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@
CONST	SEGMENT
??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@ DB 'NUMBER_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@
CONST	SEGMENT
??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@ DB 'NUMBER_LETTER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@
CONST	SEGMENT
??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@ DB 'NUMBER_DECIMAL ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BAKEFCLB@NUMBER?5@
CONST	SEGMENT
??_C@_07BAKEFCLB@NUMBER?5@ DB 'NUMBER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@
CONST	SEGMENT
??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@ DB 'MARK_ENCLOSING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@
CONST	SEGMENT
??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@ DB 'MARK_SPACECOMBINING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@
CONST	SEGMENT
??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@ DB 'MARK_NONSPACING ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BACHLHLN@MARK?5@
CONST	SEGMENT
??_C@_05BACHLHLN@MARK?5@ DB 'MARK ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@
CONST	SEGMENT
??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@ DB 'LETTER_OTHERS ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@
CONST	SEGMENT
??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@ DB 'LETTER_MODIFIER ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@
CONST	SEGMENT
??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@ DB 'LETTER_TITLECASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@
CONST	SEGMENT
??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@ DB 'LETTER_LOWERCASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@
CONST	SEGMENT
??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@ DB 'LETTER_UPPERCASE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07POCGPIHD@LETTER?5@
CONST	SEGMENT
??_C@_07POCGPIHD@LETTER?5@ DB 'LETTER ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCPFODOD@notrealchar?5@
CONST	SEGMENT
??_C@_0N@MCPFODOD@notrealchar?5@ DB 'notrealchar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOCDMJPB@realchar?5@
CONST	SEGMENT
??_C@_09MOCDMJPB@realchar?5@ DB 'realchar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EDJHICHL@notdecimal?5@
CONST	SEGMENT
??_C@_0M@EDJHICHL@notdecimal?5@ DB 'notdecimal ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CDKGKILA@decimal?5@
CONST	SEGMENT
??_C@_08CDKGKILA@decimal?5@ DB 'decimal ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GALMIDBF@notnamechar?5@
CONST	SEGMENT
??_C@_0N@GALMIDBF@notnamechar?5@ DB 'notnamechar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GMGKKJAH@namechar?5@
CONST	SEGMENT
??_C@_09GMGKKJAH@namechar?5@ DB 'namechar ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PKALLFNP@notinitname?5@
CONST	SEGMENT
??_C@_0N@PKALLFNP@notinitname?5@ DB 'notinitname ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGNNJPMN@initname?5@
CONST	SEGMENT
??_C@_09PGNNJPMN@initname?5@ DB 'initname ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PIGAJOFL@notspace?5@
CONST	SEGMENT
??_C@_09PIGAJOFL@notspace?5@ DB 'notspace ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFBFMEEE@anyspace?5@
CONST	SEGMENT
??_C@_09IFBFMEEE@anyspace?5@ DB 'anyspace ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIDGBAEF@anychar?5@
CONST	SEGMENT
??_C@_08IIDGBAEF@anychar?5@ DB 'anychar ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBAIICBM@string?5@
CONST	SEGMENT
??_C@_07HBAIICBM@string?5@ DB 'string ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BABENLJO@subexpr?5@
CONST	SEGMENT
??_C@_08BABENLJO@subexpr?5@ DB 'subexpr ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPEOMBMH@ranges?5@
CONST	SEGMENT
??_C@_07IPEOMBMH@ranges?5@ DB 'ranges ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DFHMJFEK@charval?5@
CONST	SEGMENT
??_C@_08DFHMJFEK@charval?5@ DB 'charval ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJGDJFJP@epsilon?5@
CONST	SEGMENT
??_C@_08LJGDJFJP@epsilon?5@ DB 'epsilon ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CKELLPME@allocating?5state@
CONST	SEGMENT
??_C@_0BB@CKELLPME@allocating?5state@ DB 'allocating state', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECMBACNP@copying?5atom@
CONST	SEGMENT
??_C@_0N@ECMBACNP@copying?5atom@ DB 'copying atom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCPCIFNM@allocating?5atom@
CONST	SEGMENT
??_C@_0BA@JCPCIFNM@allocating?5atom@ DB 'allocating atom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBEHJOM@allocating?5range@
CONST	SEGMENT
??_C@_0BB@PBEHJOM@allocating?5range@ DB 'allocating range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJPDMDM@compiling?5regexp@
CONST	SEGMENT
??_C@_0BB@FJPDMDM@compiling?5regexp@ DB 'compiling regexp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@ DB 'failed to compile:'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDumpInt
_TEXT	SEGMENT
_rep$1 = -40						; size = 40
_buf$ = 8						; size = 4
_expr$ = 12						; size = 4
_glob$ = 16						; size = 4
_xmlExpDumpInt PROC					; COMDAT

; 8043 : xmlExpDumpInt(xmlBufferPtr buf, xmlExpNodePtr expr, int glob) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _expr$[ebp]
	test	edi, edi
	je	$LN38@xmlExpDump

; 8044 :     xmlExpNodePtr c;
; 8045 : 
; 8046 :     if (expr == NULL) return;
; 8047 :     if (glob) xmlBufferWriteChar(buf, "(");

	cmp	DWORD PTR _glob$[ebp], 0
	push	esi
	mov	esi, DWORD PTR _buf$[ebp]
	je	SHORT $LN5@xmlExpDump
	push	OFFSET ??_C@_01ODHLEDKK@?$CI@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN5@xmlExpDump:

; 8048 :     switch (expr->type) {

	movzx	eax, BYTE PTR [edi]
	cmp	eax, 5
	ja	$LN37@xmlExpDump
	jmp	DWORD PTR $LN48@xmlExpDump[eax*4]
$LN6@xmlExpDump:

; 8049 :         case XML_EXP_EMPTY:
; 8050 : 	    xmlBufferWriteChar(buf, "empty");

	push	OFFSET ??_C@_05LBJMNBOG@empty@
	push	esi
	call	_xmlBufferWriteChar

; 8051 : 	    break;

	jmp	$LN45@xmlExpDump
$LN7@xmlExpDump:

; 8052 :         case XML_EXP_FORBID:
; 8053 : 	    xmlBufferWriteChar(buf, "forbidden");

	push	OFFSET ??_C@_09PDGFMGED@forbidden@
	push	esi
	call	_xmlBufferWriteChar

; 8054 : 	    break;

	jmp	$LN45@xmlExpDump
$LN8@xmlExpDump:

; 8055 :         case XML_EXP_ATOM:
; 8056 : 	    xmlBufferWriteCHAR(buf, expr->exp_str);

	push	DWORD PTR [edi+20]
	push	esi
	call	_xmlBufferWriteCHAR

; 8057 : 	    break;

	jmp	$LN45@xmlExpDump
$LN9@xmlExpDump:

; 8058 :         case XML_EXP_SEQ:
; 8059 : 	    c = expr->exp_left;

	mov	ecx, DWORD PTR [edi+12]

; 8060 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	al, BYTE PTR [ecx]
	cmp	al, 3
	je	SHORT $LN12@xmlExpDump
	cmp	al, 4
	je	SHORT $LN12@xmlExpDump

; 8062 : 	    else
; 8063 : 	        xmlExpDumpInt(buf, c, 0);

	xor	eax, eax
	jmp	SHORT $LN11@xmlExpDump
$LN12@xmlExpDump:

; 8061 : 	        xmlExpDumpInt(buf, c, 1);

	mov	eax, 1
$LN11@xmlExpDump:

; 8064 : 	    xmlBufferWriteChar(buf, " , ");

	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	push	OFFSET ??_C@_03NKFKBEPL@?5?0?5@
$LN46@xmlExpDump:

; 8114 :     }
; 8115 :     if (glob)

	push	esi
	call	_xmlBufferWriteChar
	mov	ecx, DWORD PTR [edi+20]
	add	esp, 20					; 00000014H
	mov	al, BYTE PTR [ecx]
	cmp	al, 3
	je	SHORT $LN15@xmlExpDump
	cmp	al, 4
	je	SHORT $LN15@xmlExpDump
	xor	eax, eax
	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	$LN2@xmlExpDump
$LN15@xmlExpDump:
	mov	eax, 1
	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
	jmp	$LN2@xmlExpDump
$LN16@xmlExpDump:

; 8065 : 	    c = expr->exp_right;
; 8066 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))
; 8067 : 	        xmlExpDumpInt(buf, c, 1);
; 8068 : 	    else
; 8069 : 	        xmlExpDumpInt(buf, c, 0);
; 8070 :             break;
; 8071 :         case XML_EXP_OR:
; 8072 : 	    c = expr->exp_left;

	mov	ecx, DWORD PTR [edi+12]

; 8073 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	al, BYTE PTR [ecx]
	cmp	al, 3
	je	SHORT $LN19@xmlExpDump
	cmp	al, 4
	je	SHORT $LN19@xmlExpDump

; 8075 : 	    else
; 8076 : 	        xmlExpDumpInt(buf, c, 0);

	xor	eax, eax

; 8077 : 	    xmlBufferWriteChar(buf, " | ");

	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	push	OFFSET ??_C@_03LGOGDKEL@?5?$HM?5@

; 8078 : 	    c = expr->exp_right;
; 8079 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))
; 8080 : 	        xmlExpDumpInt(buf, c, 1);
; 8081 : 	    else
; 8082 : 	        xmlExpDumpInt(buf, c, 0);

	jmp	SHORT $LN46@xmlExpDump
$LN19@xmlExpDump:

; 8074 : 	        xmlExpDumpInt(buf, c, 1);

	mov	eax, 1

; 8077 : 	    xmlBufferWriteChar(buf, " | ");

	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	push	OFFSET ??_C@_03LGOGDKEL@?5?$HM?5@

; 8078 : 	    c = expr->exp_right;
; 8079 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))
; 8080 : 	        xmlExpDumpInt(buf, c, 1);
; 8081 : 	    else
; 8082 : 	        xmlExpDumpInt(buf, c, 0);

	jmp	SHORT $LN46@xmlExpDump
$LN23@xmlExpDump:

; 8083 :             break;
; 8084 :         case XML_EXP_COUNT: {
; 8085 : 	    char rep[40];
; 8086 : 
; 8087 : 	    c = expr->exp_left;

	mov	ecx, DWORD PTR [edi+12]

; 8088 : 	    if ((c->type == XML_EXP_SEQ) || (c->type == XML_EXP_OR))

	mov	al, BYTE PTR [ecx]
	cmp	al, 3
	je	SHORT $LN26@xmlExpDump
	cmp	al, 4
	je	SHORT $LN26@xmlExpDump

; 8090 : 	    else
; 8091 : 	        xmlExpDumpInt(buf, c, 0);

	xor	eax, eax
	jmp	SHORT $LN25@xmlExpDump
$LN26@xmlExpDump:

; 8089 : 	        xmlExpDumpInt(buf, c, 1);

	mov	eax, 1
$LN25@xmlExpDump:

; 8092 : 	    if ((expr->exp_min == 0) && (expr->exp_max == 1)) {

	push	eax
	push	ecx
	push	esi
	call	_xmlExpDumpInt
	mov	eax, DWORD PTR [edi+20]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN41@xmlExpDump
	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, 1
	jne	SHORT $LN43@xmlExpDump

; 8107 : 	    }
; 8108 : 	    rep[39] = 0;

	mov	BYTE PTR _rep$1[ebp+39], al

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	push	esi
	mov	WORD PTR _rep$1[ebp], 63		; 0000003fH
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	$LN45@xmlExpDump
$LN43@xmlExpDump:

; 8093 : 		rep[0] = '?';
; 8094 : 		rep[1] = 0;
; 8095 : 	    } else if ((expr->exp_min == 0) && (expr->exp_max == -1)) {

	cmp	ecx, -1
	jne	SHORT $LN42@xmlExpDump

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	mov	WORD PTR _rep$1[ebp], 42		; 0000002aH
	push	eax
	push	esi
	mov	BYTE PTR _rep$1[ebp+39], 0
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	$LN45@xmlExpDump
$LN41@xmlExpDump:

; 8096 : 		rep[0] = '*';
; 8097 : 		rep[1] = 0;
; 8098 : 	    } else if ((expr->exp_min == 1) && (expr->exp_max == -1)) {

	cmp	eax, 1
	jne	SHORT $LN42@xmlExpDump
	cmp	DWORD PTR [edi+24], -1
	jne	SHORT $LN42@xmlExpDump

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	mov	WORD PTR _rep$1[ebp], 43		; 0000002bH
	push	eax
	push	esi
	mov	BYTE PTR _rep$1[ebp+39], 0
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	$LN45@xmlExpDump
$LN42@xmlExpDump:

; 8099 : 		rep[0] = '+';
; 8100 : 		rep[1] = 0;
; 8101 : 	    } else if (expr->exp_max == expr->exp_min) {

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, eax
	jne	SHORT $LN33@xmlExpDump

; 8102 : 	        snprintf(rep, 39, "{%d}", expr->exp_min);

	push	eax
	push	OFFSET ??_C@_04PFHMOCHH@?$HL?$CFd?$HN@
	lea	eax, DWORD PTR _rep$1[ebp]
	push	39					; 00000027H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 8107 : 	    }
; 8108 : 	    rep[39] = 0;

	mov	BYTE PTR _rep$1[ebp+39], 0

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	push	esi
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	SHORT $LN45@xmlExpDump
$LN33@xmlExpDump:

; 8103 : 	    } else if (expr->exp_max < 0) {

	test	ecx, ecx
	jns	SHORT $LN35@xmlExpDump

; 8104 : 	        snprintf(rep, 39, "{%d,inf}", expr->exp_min);

	push	eax
	push	OFFSET ??_C@_08EMBBFCPF@?$HL?$CFd?0inf?$HN@
	lea	eax, DWORD PTR _rep$1[ebp]
	push	39					; 00000027H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 8107 : 	    }
; 8108 : 	    rep[39] = 0;

	mov	BYTE PTR _rep$1[ebp+39], 0

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	push	esi
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	SHORT $LN45@xmlExpDump
$LN35@xmlExpDump:

; 8105 : 	    } else {
; 8106 : 	        snprintf(rep, 39, "{%d,%d}", expr->exp_min, expr->exp_max);

	push	ecx
	push	eax
	push	OFFSET ??_C@_07CDJFAPGJ@?$HL?$CFd?0?$CFd?$HN@
	lea	eax, DWORD PTR _rep$1[ebp]
	push	39					; 00000027H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 8107 : 	    }
; 8108 : 	    rep[39] = 0;

	mov	BYTE PTR _rep$1[ebp+39], 0

; 8109 : 	    xmlBufferWriteChar(buf, rep);

	lea	eax, DWORD PTR _rep$1[ebp]
	push	eax
	push	esi
	call	_xmlBufferWriteChar

; 8110 : 	    break;

	jmp	SHORT $LN45@xmlExpDump
$LN37@xmlExpDump:

; 8111 : 	}
; 8112 : 	default:
; 8113 : 	    fprintf(stderr, "Error in tree\n");

	push	OFFSET ??_C@_0P@OCJKDKLA@Error?5in?5tree?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
$LN45@xmlExpDump:

; 8114 :     }
; 8115 :     if (glob)

	add	esp, 8
$LN2@xmlExpDump:
	cmp	DWORD PTR _glob$[ebp], 0
	je	SHORT $LN44@xmlExpDump

; 8116 :         xmlBufferWriteChar(buf, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	push	esi
	call	_xmlBufferWriteChar
	add	esp, 8
$LN44@xmlExpDump:
	pop	esi
$LN38@xmlExpDump:
	pop	edi

; 8117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlExpDump:
	DD	$LN6@xmlExpDump
	DD	$LN7@xmlExpDump
	DD	$LN8@xmlExpDump
	DD	$LN9@xmlExpDump
	DD	$LN16@xmlExpDump
	DD	$LN23@xmlExpDump
_xmlExpDumpInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseSeq
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpParseSeq PROC					; COMDAT

; 7970 : xmlExpParseSeq(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlExpParseOr
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 4
	mov	edi, eax
$LL2@xmlExpPars:

; 7971 :     xmlExpNodePtr ret, right;
; 7972 : 
; 7973 :     ret = xmlExpParseOr(ctxt);
; 7974 :     SKIP_BLANKS

	mov	dl, BYTE PTR [ecx]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 9
	jne	SHORT $LN12@xmlExpPars
$LN6@xmlExpPars:
	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LL2@xmlExpPars
$LN12@xmlExpPars:

; 7975 :     while (CUR == '|') {

	cmp	dl, 124					; 0000007cH
	jne	SHORT $LN5@xmlExpPars
$LL4@xmlExpPars:

; 7976 :         NEXT

	lea	eax, DWORD PTR [ecx+1]

; 7977 : 	right = xmlExpParseOr(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseOr
	add	esp, 4

; 7978 : 	if (right == NULL) {

	test	eax, eax
	je	SHORT $LN13@xmlExpPars

; 7980 : 	    return(NULL);
; 7981 : 	}
; 7982 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, right, NULL, 0, 0);

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	4
	push	esi
	call	_xmlExpHashGetEntry
	mov	edi, eax
	add	esp, 28					; 0000001cH

; 7983 : 	if (ret == NULL)

	test	edi, edi
	je	SHORT $LN14@xmlExpPars

; 7975 :     while (CUR == '|') {

	mov	ecx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ecx], 124			; 0000007cH
	je	SHORT $LL4@xmlExpPars
$LN5@xmlExpPars:

; 7984 : 	    return(NULL);
; 7985 :     }
; 7986 :     return(ret);

	mov	eax, edi
	pop	edi

; 7987 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlExpPars:

; 7979 : 	    xmlExpFree(ctxt, ret);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 8
$LN14@xmlExpPars:

; 7987 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlExpParseSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseOr
_TEXT	SEGMENT
tv3237 = 8						; size = 4
tv3230 = 8						; size = 4
tv3227 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlExpParseOr PROC					; COMDAT

; 7893 : xmlExpParseOr(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [esi+28]
$LN491@xmlExpPars:

; 7894 :     const char *base;
; 7895 :     xmlExpNodePtr ret;
; 7896 :     const xmlChar *val;
; 7897 : 
; 7898 :     SKIP_BLANKS

	mov	al, BYTE PTR [ebx]
	mov	ecx, ebx
	cmp	al, 32					; 00000020H
	je	SHORT $LN24@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN24@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN24@xmlExpPars
	cmp	al, 9
	jne	SHORT $LN3@xmlExpPars
$LN24@xmlExpPars:
	inc	ebx
	mov	DWORD PTR [esi+28], ebx
	jmp	SHORT $LN491@xmlExpPars
$LN3@xmlExpPars:

; 7899 :     base = ctxt->cur;
; 7900 :     if (*ctxt->cur == '(') {

	cmp	al, 40					; 00000028H
	jne	$LN357@xmlExpPars

; 7901 :         NEXT

	lea	eax, DWORD PTR [ebx+1]

; 7902 : 	ret = xmlExpParseExpr(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseExpr
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 4
	mov	edi, eax
	npad	4
$LL4@xmlExpPars:

; 7903 : 	SKIP_BLANKS

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN26@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN26@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN26@xmlExpPars
	cmp	al, 9
	jne	SHORT $LN5@xmlExpPars
$LN26@xmlExpPars:
	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LL4@xmlExpPars
$LN5@xmlExpPars:

; 7904 : 	if (*ctxt->cur != ')') {

	cmp	al, 41					; 00000029H
	je	SHORT $LN27@xmlExpPars

; 7905 : 	    fprintf(stderr, "unbalanced '(' : %s\n", base);

	push	ebx
	push	OFFSET ??_C@_0BF@FNELPLND@unbalanced?5?8?$CI?8?5?3?5?$CFs?6@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf

; 7906 : 	    xmlExpFree(ctxt, ret);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 20					; 00000014H
$LN442@xmlExpPars:

; 7966 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN27@xmlExpPars:

; 7907 : 	    return(NULL);
; 7908 : 	}
; 7909 : 	NEXT;
; 7910 : 	SKIP_BLANKS

	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN27@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN27@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN27@xmlExpPars
	cmp	al, 9
	je	SHORT $LN27@xmlExpPars
$parse_quantifier$493:

; 7924 : parse_quantifier:
; 7925 :     if (CUR == '{') {

	cmp	al, 123					; 0000007bH
	jne	$LN32@xmlExpPars

; 7926 :         int min, max;
; 7927 : 
; 7928 :         NEXT

	lea	eax, DWORD PTR [ecx+1]

; 7929 : 	min = xmlExpParseNumber(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseNumber
	mov	ebx, eax
	add	esp, 4

; 7930 : 	if (min < 0) {

	test	ebx, ebx
	js	$LN441@xmlExpPars
	mov	eax, DWORD PTR [esi+28]
	npad	2
$LL12@xmlExpPars:

; 7931 : 	    xmlExpFree(ctxt, ret);
; 7932 : 	    return(NULL);
; 7933 : 	}
; 7934 : 	SKIP_BLANKS

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN35@xmlExpPars
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN35@xmlExpPars
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN35@xmlExpPars
	cmp	cl, 9
	jne	$LN13@xmlExpPars
$LN35@xmlExpPars:
	inc	eax
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LL12@xmlExpPars
$LN357@xmlExpPars:

; 7911 : 	goto parse_quantifier;
; 7912 :     }
; 7913 :     while ((CUR != 0) && (!(IS_BLANK(CUR))) && (CUR != '(') &&
; 7914 :            (CUR != ')') && (CUR != '|') && (CUR != ',') && (CUR != '{') &&
; 7915 : 	   (CUR != '*') && (CUR != '+') && (CUR != '?') && (CUR != '}'))

	test	al, al
	je	SHORT $LN483@xmlExpPars
	mov	edi, ebx
$LL8@xmlExpPars:
	mov	edx, ecx
	cmp	al, 32					; 00000020H
	je	SHORT $LN483@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 9
	je	SHORT $LN483@xmlExpPars
	cmp	al, 40					; 00000028H
	je	SHORT $LN483@xmlExpPars
	cmp	al, 41					; 00000029H
	je	SHORT $LN483@xmlExpPars
	cmp	al, 124					; 0000007cH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 44					; 0000002cH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 123					; 0000007bH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 42					; 0000002aH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 43					; 0000002bH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 63					; 0000003fH
	je	SHORT $LN483@xmlExpPars
	cmp	al, 125					; 0000007dH
	je	SHORT $LN483@xmlExpPars

; 7916 : 	NEXT;

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR [esi+28], ecx
	mov	edi, ecx
	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL8@xmlExpPars
$LN483@xmlExpPars:

; 7917 :     val = xmlDictLookup(ctxt->dict, BAD_CAST base, ctxt->cur - base);

	sub	ecx, ebx
	push	ecx
	push	ebx
	push	DWORD PTR [esi]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 7918 :     if (val == NULL)

	test	eax, eax
	je	$LN442@xmlExpPars

; 7919 :         return(NULL);
; 7920 :     ret = xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, val, 0, 0);

	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	esi
	call	_xmlExpHashGetEntry
	mov	edi, eax
	add	esp, 28					; 0000001cH

; 7921 :     if (ret == NULL)

	test	edi, edi
	je	$LN442@xmlExpPars
	npad	2
$LL10@xmlExpPars:

; 7922 :         return(NULL);
; 7923 :     SKIP_BLANKS

	mov	ecx, DWORD PTR [esi+28]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN31@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN31@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN31@xmlExpPars
	cmp	al, 9
	jne	$parse_quantifier$493
$LN31@xmlExpPars:
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LL10@xmlExpPars
$LN13@xmlExpPars:

; 7935 : 	if (CUR == ',') {

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN36@xmlExpPars

; 7936 : 	    NEXT

	inc	eax

; 7937 : 	    max = xmlExpParseNumber(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseNumber
	mov	edx, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+28]
$LL14@xmlExpPars:

; 7938 : 	    SKIP_BLANKS

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN38@xmlExpPars
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN38@xmlExpPars
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN38@xmlExpPars
	cmp	cl, 9
	jne	SHORT $LN37@xmlExpPars
$LN38@xmlExpPars:
	inc	eax
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LL14@xmlExpPars
$LN36@xmlExpPars:

; 7939 : 	} else
; 7940 : 	    max = min;

	mov	edx, ebx
$LN37@xmlExpPars:

; 7941 : 	if (CUR != '}') {

	cmp	cl, 125					; 0000007dH
	jne	SHORT $LN441@xmlExpPars

; 7943 : 	    return(NULL);
; 7944 : 	}
; 7945 :         NEXT
; 7946 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,

	push	edx
	push	ebx
	push	0
	push	0
	push	edi
	inc	eax
	push	5
	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpHashGetEntry
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 28					; 0000001cH
	mov	edi, eax
$LL16@xmlExpPars:

; 7947 : 	                         min, max);
; 7948 : 	SKIP_BLANKS

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN40@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN40@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN40@xmlExpPars
	cmp	al, 9
	jne	$LN485@xmlExpPars
$LN40@xmlExpPars:
	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LL16@xmlExpPars
$LN441@xmlExpPars:

; 7942 : 	    xmlExpFree(ctxt, ret);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 8

; 7966 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlExpPars:

; 7949 :     } else if (CUR == '?') {

	cmp	al, 63					; 0000003fH
	jne	$LN41@xmlExpPars

; 7950 :         NEXT

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax

; 6604 : 	kbase += left->key;

	mov	ax, WORD PTR [edi+2]
	inc	ax
	movzx	ebx, ax

; 6605 :     } else if (type == XML_EXP_OR) {
; 6606 :         /* Forbid reduction rules */
; 6607 :         if (left->type == XML_EXP_FORBID) {
; 6608 : 	    xmlExpFree(ctxt, left);
; 6609 : 	    return(right);
; 6610 : 	}
; 6611 :         if (right->type == XML_EXP_FORBID) {
; 6612 : 	    xmlExpFree(ctxt, right);
; 6613 : 	    return(left);
; 6614 : 	}
; 6615 : 
; 6616 :         /* OR reduction rule 1 */
; 6617 : 	/* a | a reduced to a */
; 6618 :         if (left == right) {
; 6619 : 	    left->ref--;
; 6620 : 	    return(left);
; 6621 : 	}
; 6622 :         /* OR canonicalization rule 1 */
; 6623 : 	/* linearize (a | b) | c into a | (b | c) */
; 6624 :         if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {
; 6625 : 	    xmlExpNodePtr tmp = left;
; 6626 :             left = right;
; 6627 : 	    right = tmp;
; 6628 : 	}
; 6629 :         /* OR reduction rule 2 */
; 6630 : 	/* a | (a | b) and b | (a | b) are reduced to a | b */
; 6631 :         if (right->type == XML_EXP_OR) {
; 6632 : 	    if ((left == right->exp_left) ||
; 6633 : 	        (left == right->exp_right)) {
; 6634 : 		xmlExpFree(ctxt, left);
; 6635 : 		return(right);
; 6636 : 	    }
; 6637 : 	}
; 6638 :         /* OR canonicalization rule 2 */
; 6639 : 	/* linearize (a | b) | c into a | (b | c) */
; 6640 :         if (left->type == XML_EXP_OR) {
; 6641 : 	    xmlExpNodePtr tmp;
; 6642 : 
; 6643 : 	    /* OR canonicalization rule 2 */
; 6644 : 	    if ((left->exp_right->type != XML_EXP_OR) &&
; 6645 : 	        (left->exp_right->key < left->exp_left->key)) {
; 6646 : 	        tmp = left->exp_right;
; 6647 : 		left->exp_right = left->exp_left;
; 6648 : 		left->exp_left = tmp;
; 6649 : 	    }
; 6650 : 	    left->exp_right->ref++;
; 6651 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,
; 6652 : 	                             NULL, 0, 0);
; 6653 : 	    left->exp_left->ref++;
; 6654 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,
; 6655 : 	                             NULL, 0, 0);
; 6656 : 
; 6657 : 	    xmlExpFree(ctxt, left);
; 6658 : 	    return(tmp);
; 6659 : 	}
; 6660 : 	if (right->type == XML_EXP_OR) {
; 6661 : 	    /* Ordering in the tree */
; 6662 : 	    /* C | (A | B) -> A | (B | C) */
; 6663 : 	    if (left->key > right->exp_right->key) {
; 6664 : 		xmlExpNodePtr tmp;
; 6665 : 		right->exp_right->ref++;
; 6666 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,
; 6667 : 		                         left, NULL, 0, 0);
; 6668 : 		right->exp_left->ref++;
; 6669 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6670 : 		                         tmp, NULL, 0, 0);
; 6671 : 		xmlExpFree(ctxt, right);
; 6672 : 		return(tmp);
; 6673 : 	    }
; 6674 : 	    /* Ordering in the tree */
; 6675 : 	    /* B | (A | C) -> A | (B | C) */
; 6676 : 	    if (left->key > right->exp_left->key) {
; 6677 : 		xmlExpNodePtr tmp;
; 6678 : 		right->exp_right->ref++;
; 6679 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,
; 6680 : 		                         right->exp_right, NULL, 0, 0);
; 6681 : 		right->exp_left->ref++;
; 6682 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6683 : 		                         tmp, NULL, 0, 0);
; 6684 : 		xmlExpFree(ctxt, right);
; 6685 : 		return(tmp);
; 6686 : 	    }
; 6687 : 	}
; 6688 : 	/* we know both types are != XML_EXP_OR here */
; 6689 :         else if (left->key > right->key) {
; 6690 : 	    xmlExpNodePtr tmp = left;
; 6691 :             left = right;
; 6692 : 	    right = tmp;
; 6693 : 	}
; 6694 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6695 :     } else if (type == XML_EXP_SEQ) {
; 6696 :         /* Forbid reduction rules */
; 6697 :         if (left->type == XML_EXP_FORBID) {
; 6698 : 	    xmlExpFree(ctxt, right);
; 6699 : 	    return(left);
; 6700 : 	}
; 6701 :         if (right->type == XML_EXP_FORBID) {
; 6702 : 	    xmlExpFree(ctxt, left);
; 6703 : 	    return(right);
; 6704 : 	}
; 6705 :         /* Empty reduction rules */
; 6706 :         if (right->type == XML_EXP_EMPTY) {
; 6707 : 	    return(left);
; 6708 : 	}
; 6709 :         if (left->type == XML_EXP_EMPTY) {
; 6710 : 	    return(right);
; 6711 : 	}
; 6712 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6713 :     } else
; 6714 :         return(NULL);
; 6715 : 
; 6716 :     key = kbase % ctxt->size;

	mov	eax, ebx
	cdq
	idiv	DWORD PTR [esi+8]

; 6717 :     if (ctxt->table[key] != NULL) {

	mov	eax, DWORD PTR [esi+4]
	movzx	ecx, dx
	shl	ecx, 2
	mov	DWORD PTR tv3237[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	test	eax, eax
	je	SHORT $LN464@xmlExpPars
$LL71@xmlExpPars:

; 6720 : 	    if ((insert->key == kbase) &&

	cmp	WORD PTR [eax+2], bx
	jne	SHORT $LN69@xmlExpPars
	cmp	BYTE PTR [eax], 5
	jne	SHORT $LN69@xmlExpPars

; 6721 : 	        (insert->type == type)) {
; 6722 : 		if (type == XML_EXP_ATOM) {
; 6723 : 		    if (name == insert->exp_str) {
; 6724 : 			insert->ref++;
; 6725 : 			return(insert);
; 6726 : 		    }
; 6727 : 		} else if (type == XML_EXP_COUNT) {
; 6728 : 		    if ((insert->exp_min == min) && (insert->exp_max == max) &&

	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN69@xmlExpPars
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN69@xmlExpPars
	cmp	DWORD PTR [eax+12], edi
	je	$LN368@xmlExpPars
$LN69@xmlExpPars:

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;
; 6719 : 	     insert = insert->next) {

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	jne	SHORT $LL71@xmlExpPars
$LN464@xmlExpPars:

; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)

	cmp	DWORD PTR [esi+16], 10000		; 00002710H
	jge	SHORT $LN423@xmlExpPars

; 6546 :         return(NULL);
; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 6548 :     if (ret == NULL)

	test	ecx, ecx
	je	SHORT $LN423@xmlExpPars
	xorps	xmm0, xmm0

; 6549 :         return(NULL);
; 6550 :     memset(ret, 0, sizeof(xmlExpNode));

	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx+24], 0

; 6551 :     ret->type = type;

	mov	BYTE PTR [ecx], 5

; 6552 :     ret->next = NULL;
; 6553 :     ctxt->nb_nodes++;

	inc	DWORD PTR [esi+16]

; 6554 :     ctxt->nb_cons++;

	inc	DWORD PTR [esi+32]

; 6757 : 	    entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [ecx+1], 1
	mov	DWORD PTR [ecx+12], edi
	mov	WORD PTR [ecx+2], bx
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 1

; 6758 : 	if (max < 0)
; 6759 : 	    entry->c_max = -1;
; 6760 : 	else
; 6761 : 	    entry->c_max = max * entry->exp_left->c_max;

	mov	eax, DWORD PTR [edi+8]

; 6762 :     } else {
; 6763 : 	entry->exp_left = left;
; 6764 : 	entry->exp_right = right;
; 6765 : 	if (type == XML_EXP_OR) {
; 6766 : 	    if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))
; 6767 : 		entry->info |= XML_EXP_NILABLE;
; 6768 : 	    if ((entry->exp_left->c_max == -1) ||
; 6769 : 	        (entry->exp_right->c_max == -1))
; 6770 : 		entry->c_max = -1;
; 6771 : 	    else if (entry->exp_left->c_max > entry->exp_right->c_max)
; 6772 : 	        entry->c_max = entry->exp_left->c_max;
; 6773 : 	    else
; 6774 : 	        entry->c_max = entry->exp_right->c_max;
; 6775 : 	} else {
; 6776 : 	    if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))
; 6777 : 		entry->info |= XML_EXP_NILABLE;
; 6778 : 	    if ((entry->exp_left->c_max == -1) ||
; 6779 : 	        (entry->exp_right->c_max == -1))
; 6780 : 		entry->c_max = -1;
; 6781 : 	    else
; 6782 : 	        entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;
; 6783 : 	}
; 6784 :     }
; 6785 :     entry->ref = 1;
; 6786 :     if (ctxt->table[key] != NULL)

	mov	edi, DWORD PTR tv3237[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+4], 1
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+eax]
	test	edx, edx
	je	SHORT $LN136@xmlExpPars

; 6787 :         entry->next = ctxt->table[key];

	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [esi+4]
$LN136@xmlExpPars:

; 6788 : 
; 6789 :     ctxt->table[key] = entry;

	mov	DWORD PTR [eax+edi], ecx

; 6790 :     ctxt->nbElems++;
; 6791 : 
; 6792 :     return(entry);

	mov	edi, ecx
	inc	DWORD PTR [esi+12]
	jmp	SHORT $LL18@xmlExpPars
$LN368@xmlExpPars:

; 6729 : 		        (insert->exp_left == left)) {
; 6730 : 			insert->ref++;

	inc	DWORD PTR [eax+4]

; 6731 : 			left->ref--;

	dec	DWORD PTR [edi+4]

; 6732 : 			return(insert);

	mov	edi, eax
	jmp	SHORT $LL18@xmlExpPars
$LN423@xmlExpPars:

; 6733 : 		    }
; 6734 : 		} else if ((insert->exp_left == left) &&
; 6735 : 			   (insert->exp_right == right)) {
; 6736 : 		    insert->ref++;
; 6737 : 		    left->ref--;
; 6738 : 		    right->ref--;
; 6739 : 		    return(insert);
; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}
; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);
; 6746 :     if (entry == NULL)
; 6747 :         return(NULL);

	xor	edi, edi
	npad	2
$LL18@xmlExpPars:

; 7951 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,
; 7952 : 	                         0, 1);
; 7953 : 	SKIP_BLANKS

	mov	ecx, DWORD PTR [esi+28]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN43@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN43@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN43@xmlExpPars
	cmp	al, 9
	jne	$LN485@xmlExpPars
$LN43@xmlExpPars:
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LL18@xmlExpPars
$LN41@xmlExpPars:

; 7954 :     } else if (CUR == '+') {

	cmp	al, 43					; 0000002bH
	jne	$LN44@xmlExpPars

; 7955 :         NEXT

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax

; 6604 : 	kbase += left->key;

	mov	ax, WORD PTR [edi+2]
	add	ax, 80					; 00000050H
	movzx	ebx, ax

; 6605 :     } else if (type == XML_EXP_OR) {
; 6606 :         /* Forbid reduction rules */
; 6607 :         if (left->type == XML_EXP_FORBID) {
; 6608 : 	    xmlExpFree(ctxt, left);
; 6609 : 	    return(right);
; 6610 : 	}
; 6611 :         if (right->type == XML_EXP_FORBID) {
; 6612 : 	    xmlExpFree(ctxt, right);
; 6613 : 	    return(left);
; 6614 : 	}
; 6615 : 
; 6616 :         /* OR reduction rule 1 */
; 6617 : 	/* a | a reduced to a */
; 6618 :         if (left == right) {
; 6619 : 	    left->ref--;
; 6620 : 	    return(left);
; 6621 : 	}
; 6622 :         /* OR canonicalization rule 1 */
; 6623 : 	/* linearize (a | b) | c into a | (b | c) */
; 6624 :         if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {
; 6625 : 	    xmlExpNodePtr tmp = left;
; 6626 :             left = right;
; 6627 : 	    right = tmp;
; 6628 : 	}
; 6629 :         /* OR reduction rule 2 */
; 6630 : 	/* a | (a | b) and b | (a | b) are reduced to a | b */
; 6631 :         if (right->type == XML_EXP_OR) {
; 6632 : 	    if ((left == right->exp_left) ||
; 6633 : 	        (left == right->exp_right)) {
; 6634 : 		xmlExpFree(ctxt, left);
; 6635 : 		return(right);
; 6636 : 	    }
; 6637 : 	}
; 6638 :         /* OR canonicalization rule 2 */
; 6639 : 	/* linearize (a | b) | c into a | (b | c) */
; 6640 :         if (left->type == XML_EXP_OR) {
; 6641 : 	    xmlExpNodePtr tmp;
; 6642 : 
; 6643 : 	    /* OR canonicalization rule 2 */
; 6644 : 	    if ((left->exp_right->type != XML_EXP_OR) &&
; 6645 : 	        (left->exp_right->key < left->exp_left->key)) {
; 6646 : 	        tmp = left->exp_right;
; 6647 : 		left->exp_right = left->exp_left;
; 6648 : 		left->exp_left = tmp;
; 6649 : 	    }
; 6650 : 	    left->exp_right->ref++;
; 6651 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,
; 6652 : 	                             NULL, 0, 0);
; 6653 : 	    left->exp_left->ref++;
; 6654 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,
; 6655 : 	                             NULL, 0, 0);
; 6656 : 
; 6657 : 	    xmlExpFree(ctxt, left);
; 6658 : 	    return(tmp);
; 6659 : 	}
; 6660 : 	if (right->type == XML_EXP_OR) {
; 6661 : 	    /* Ordering in the tree */
; 6662 : 	    /* C | (A | B) -> A | (B | C) */
; 6663 : 	    if (left->key > right->exp_right->key) {
; 6664 : 		xmlExpNodePtr tmp;
; 6665 : 		right->exp_right->ref++;
; 6666 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,
; 6667 : 		                         left, NULL, 0, 0);
; 6668 : 		right->exp_left->ref++;
; 6669 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6670 : 		                         tmp, NULL, 0, 0);
; 6671 : 		xmlExpFree(ctxt, right);
; 6672 : 		return(tmp);
; 6673 : 	    }
; 6674 : 	    /* Ordering in the tree */
; 6675 : 	    /* B | (A | C) -> A | (B | C) */
; 6676 : 	    if (left->key > right->exp_left->key) {
; 6677 : 		xmlExpNodePtr tmp;
; 6678 : 		right->exp_right->ref++;
; 6679 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,
; 6680 : 		                         right->exp_right, NULL, 0, 0);
; 6681 : 		right->exp_left->ref++;
; 6682 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6683 : 		                         tmp, NULL, 0, 0);
; 6684 : 		xmlExpFree(ctxt, right);
; 6685 : 		return(tmp);
; 6686 : 	    }
; 6687 : 	}
; 6688 : 	/* we know both types are != XML_EXP_OR here */
; 6689 :         else if (left->key > right->key) {
; 6690 : 	    xmlExpNodePtr tmp = left;
; 6691 :             left = right;
; 6692 : 	    right = tmp;
; 6693 : 	}
; 6694 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6695 :     } else if (type == XML_EXP_SEQ) {
; 6696 :         /* Forbid reduction rules */
; 6697 :         if (left->type == XML_EXP_FORBID) {
; 6698 : 	    xmlExpFree(ctxt, right);
; 6699 : 	    return(left);
; 6700 : 	}
; 6701 :         if (right->type == XML_EXP_FORBID) {
; 6702 : 	    xmlExpFree(ctxt, left);
; 6703 : 	    return(right);
; 6704 : 	}
; 6705 :         /* Empty reduction rules */
; 6706 :         if (right->type == XML_EXP_EMPTY) {
; 6707 : 	    return(left);
; 6708 : 	}
; 6709 :         if (left->type == XML_EXP_EMPTY) {
; 6710 : 	    return(right);
; 6711 : 	}
; 6712 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6713 :     } else
; 6714 :         return(NULL);
; 6715 : 
; 6716 :     key = kbase % ctxt->size;

	mov	eax, ebx
	cdq
	idiv	DWORD PTR [esi+8]

; 6717 :     if (ctxt->table[key] != NULL) {

	mov	eax, DWORD PTR [esi+4]
	movzx	ecx, dx
	shl	ecx, 2
	mov	DWORD PTR tv3230[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	test	eax, eax
	je	SHORT $LN465@xmlExpPars
$LL166@xmlExpPars:

; 6720 : 	    if ((insert->key == kbase) &&

	cmp	WORD PTR [eax+2], bx
	jne	SHORT $LN164@xmlExpPars
	cmp	BYTE PTR [eax], 5
	jne	SHORT $LN164@xmlExpPars

; 6721 : 	        (insert->type == type)) {
; 6722 : 		if (type == XML_EXP_ATOM) {
; 6723 : 		    if (name == insert->exp_str) {
; 6724 : 			insert->ref++;
; 6725 : 			return(insert);
; 6726 : 		    }
; 6727 : 		} else if (type == XML_EXP_COUNT) {
; 6728 : 		    if ((insert->exp_min == min) && (insert->exp_max == max) &&

	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LN164@xmlExpPars
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN164@xmlExpPars
	cmp	DWORD PTR [eax+12], edi
	je	$LN369@xmlExpPars
$LN164@xmlExpPars:

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;
; 6719 : 	     insert = insert->next) {

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	jne	SHORT $LL166@xmlExpPars
$LN465@xmlExpPars:

; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)

	cmp	DWORD PTR [esi+16], 10000		; 00002710H
	jge	SHORT $LN424@xmlExpPars

; 6546 :         return(NULL);
; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 6548 :     if (ret == NULL)

	test	eax, eax
	je	SHORT $LN424@xmlExpPars
	xorps	xmm0, xmm0

; 6549 :         return(NULL);
; 6550 :     memset(ret, 0, sizeof(xmlExpNode));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	mov	DWORD PTR [eax+24], 0

; 6551 :     ret->type = type;

	mov	BYTE PTR [eax], 5

; 6552 :     ret->next = NULL;
; 6553 :     ctxt->nb_nodes++;

	inc	DWORD PTR [esi+16]

; 6554 :     ctxt->nb_cons++;

	inc	DWORD PTR [esi+32]

; 6748 :     entry->key = kbase;

	mov	WORD PTR [eax+2], bx

; 6749 :     if (type == XML_EXP_ATOM) {
; 6750 : 	entry->exp_str = name;
; 6751 : 	entry->c_max = 1;
; 6752 :     } else if (type == XML_EXP_COUNT) {
; 6753 :         entry->exp_min = min;

	mov	DWORD PTR [eax+20], 1

; 6754 :         entry->exp_max = max;

	mov	DWORD PTR [eax+24], -1

; 6755 : 	entry->exp_left = left;

	mov	DWORD PTR [eax+12], edi

; 6756 : 	if ((min == 0) || (IS_NILLABLE(left)))

	test	BYTE PTR [edi+1], 1
	je	SHORT $LN214@xmlExpPars

; 6757 : 	    entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [eax+1], 1
$LN214@xmlExpPars:

; 6762 :     } else {
; 6763 : 	entry->exp_left = left;
; 6764 : 	entry->exp_right = right;
; 6765 : 	if (type == XML_EXP_OR) {
; 6766 : 	    if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))
; 6767 : 		entry->info |= XML_EXP_NILABLE;
; 6768 : 	    if ((entry->exp_left->c_max == -1) ||
; 6769 : 	        (entry->exp_right->c_max == -1))
; 6770 : 		entry->c_max = -1;
; 6771 : 	    else if (entry->exp_left->c_max > entry->exp_right->c_max)
; 6772 : 	        entry->c_max = entry->exp_left->c_max;
; 6773 : 	    else
; 6774 : 	        entry->c_max = entry->exp_right->c_max;
; 6775 : 	} else {
; 6776 : 	    if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))
; 6777 : 		entry->info |= XML_EXP_NILABLE;
; 6778 : 	    if ((entry->exp_left->c_max == -1) ||
; 6779 : 	        (entry->exp_right->c_max == -1))
; 6780 : 		entry->c_max = -1;
; 6781 : 	    else
; 6782 : 	        entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;
; 6783 : 	}
; 6784 :     }
; 6785 :     entry->ref = 1;
; 6786 :     if (ctxt->table[key] != NULL)

	mov	edi, DWORD PTR tv3230[ebp]
	mov	DWORD PTR [eax+8], -1
	mov	DWORD PTR [eax+4], 1
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+ecx]
	test	edx, edx
	je	SHORT $LN231@xmlExpPars

; 6787 :         entry->next = ctxt->table[key];

	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [esi+4]
$LN231@xmlExpPars:

; 6788 : 
; 6789 :     ctxt->table[key] = entry;

	mov	DWORD PTR [ecx+edi], eax

; 6790 :     ctxt->nbElems++;
; 6791 : 
; 6792 :     return(entry);

	mov	edi, eax
	inc	DWORD PTR [esi+12]
	jmp	SHORT $LN392@xmlExpPars
$LN369@xmlExpPars:

; 6729 : 		        (insert->exp_left == left)) {
; 6730 : 			insert->ref++;

	inc	DWORD PTR [eax+4]

; 6731 : 			left->ref--;

	dec	DWORD PTR [edi+4]

; 6732 : 			return(insert);

	mov	edi, eax
	jmp	SHORT $LN392@xmlExpPars
$LN424@xmlExpPars:

; 6733 : 		    }
; 6734 : 		} else if ((insert->exp_left == left) &&
; 6735 : 			   (insert->exp_right == right)) {
; 6736 : 		    insert->ref++;
; 6737 : 		    left->ref--;
; 6738 : 		    right->ref--;
; 6739 : 		    return(insert);
; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}
; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);
; 6746 :     if (entry == NULL)
; 6747 :         return(NULL);

	xor	edi, edi
$LN392@xmlExpPars:
	mov	ecx, DWORD PTR [esi+28]
$LL20@xmlExpPars:

; 7956 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,
; 7957 : 	                         1, -1);
; 7958 : 	SKIP_BLANKS

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN46@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN46@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN46@xmlExpPars
	cmp	al, 9
	jne	$LN485@xmlExpPars
$LN46@xmlExpPars:
	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LL20@xmlExpPars
$LN44@xmlExpPars:

; 7959 :     } else if (CUR == '*') {

	cmp	al, 42					; 0000002aH
	jne	$LN485@xmlExpPars

; 7960 :         NEXT

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax

; 6604 : 	kbase += left->key;

	mov	ax, WORD PTR [edi+2]
	add	ax, 79					; 0000004fH
	movzx	ebx, ax

; 6605 :     } else if (type == XML_EXP_OR) {
; 6606 :         /* Forbid reduction rules */
; 6607 :         if (left->type == XML_EXP_FORBID) {
; 6608 : 	    xmlExpFree(ctxt, left);
; 6609 : 	    return(right);
; 6610 : 	}
; 6611 :         if (right->type == XML_EXP_FORBID) {
; 6612 : 	    xmlExpFree(ctxt, right);
; 6613 : 	    return(left);
; 6614 : 	}
; 6615 : 
; 6616 :         /* OR reduction rule 1 */
; 6617 : 	/* a | a reduced to a */
; 6618 :         if (left == right) {
; 6619 : 	    left->ref--;
; 6620 : 	    return(left);
; 6621 : 	}
; 6622 :         /* OR canonicalization rule 1 */
; 6623 : 	/* linearize (a | b) | c into a | (b | c) */
; 6624 :         if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {
; 6625 : 	    xmlExpNodePtr tmp = left;
; 6626 :             left = right;
; 6627 : 	    right = tmp;
; 6628 : 	}
; 6629 :         /* OR reduction rule 2 */
; 6630 : 	/* a | (a | b) and b | (a | b) are reduced to a | b */
; 6631 :         if (right->type == XML_EXP_OR) {
; 6632 : 	    if ((left == right->exp_left) ||
; 6633 : 	        (left == right->exp_right)) {
; 6634 : 		xmlExpFree(ctxt, left);
; 6635 : 		return(right);
; 6636 : 	    }
; 6637 : 	}
; 6638 :         /* OR canonicalization rule 2 */
; 6639 : 	/* linearize (a | b) | c into a | (b | c) */
; 6640 :         if (left->type == XML_EXP_OR) {
; 6641 : 	    xmlExpNodePtr tmp;
; 6642 : 
; 6643 : 	    /* OR canonicalization rule 2 */
; 6644 : 	    if ((left->exp_right->type != XML_EXP_OR) &&
; 6645 : 	        (left->exp_right->key < left->exp_left->key)) {
; 6646 : 	        tmp = left->exp_right;
; 6647 : 		left->exp_right = left->exp_left;
; 6648 : 		left->exp_left = tmp;
; 6649 : 	    }
; 6650 : 	    left->exp_right->ref++;
; 6651 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,
; 6652 : 	                             NULL, 0, 0);
; 6653 : 	    left->exp_left->ref++;
; 6654 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,
; 6655 : 	                             NULL, 0, 0);
; 6656 : 
; 6657 : 	    xmlExpFree(ctxt, left);
; 6658 : 	    return(tmp);
; 6659 : 	}
; 6660 : 	if (right->type == XML_EXP_OR) {
; 6661 : 	    /* Ordering in the tree */
; 6662 : 	    /* C | (A | B) -> A | (B | C) */
; 6663 : 	    if (left->key > right->exp_right->key) {
; 6664 : 		xmlExpNodePtr tmp;
; 6665 : 		right->exp_right->ref++;
; 6666 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,
; 6667 : 		                         left, NULL, 0, 0);
; 6668 : 		right->exp_left->ref++;
; 6669 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6670 : 		                         tmp, NULL, 0, 0);
; 6671 : 		xmlExpFree(ctxt, right);
; 6672 : 		return(tmp);
; 6673 : 	    }
; 6674 : 	    /* Ordering in the tree */
; 6675 : 	    /* B | (A | C) -> A | (B | C) */
; 6676 : 	    if (left->key > right->exp_left->key) {
; 6677 : 		xmlExpNodePtr tmp;
; 6678 : 		right->exp_right->ref++;
; 6679 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,
; 6680 : 		                         right->exp_right, NULL, 0, 0);
; 6681 : 		right->exp_left->ref++;
; 6682 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,
; 6683 : 		                         tmp, NULL, 0, 0);
; 6684 : 		xmlExpFree(ctxt, right);
; 6685 : 		return(tmp);
; 6686 : 	    }
; 6687 : 	}
; 6688 : 	/* we know both types are != XML_EXP_OR here */
; 6689 :         else if (left->key > right->key) {
; 6690 : 	    xmlExpNodePtr tmp = left;
; 6691 :             left = right;
; 6692 : 	    right = tmp;
; 6693 : 	}
; 6694 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6695 :     } else if (type == XML_EXP_SEQ) {
; 6696 :         /* Forbid reduction rules */
; 6697 :         if (left->type == XML_EXP_FORBID) {
; 6698 : 	    xmlExpFree(ctxt, right);
; 6699 : 	    return(left);
; 6700 : 	}
; 6701 :         if (right->type == XML_EXP_FORBID) {
; 6702 : 	    xmlExpFree(ctxt, left);
; 6703 : 	    return(right);
; 6704 : 	}
; 6705 :         /* Empty reduction rules */
; 6706 :         if (right->type == XML_EXP_EMPTY) {
; 6707 : 	    return(left);
; 6708 : 	}
; 6709 :         if (left->type == XML_EXP_EMPTY) {
; 6710 : 	    return(right);
; 6711 : 	}
; 6712 : 	kbase = xmlExpHashComputeKey(type, left, right);
; 6713 :     } else
; 6714 :         return(NULL);
; 6715 : 
; 6716 :     key = kbase % ctxt->size;

	mov	eax, ebx
	cdq
	idiv	DWORD PTR [esi+8]

; 6717 :     if (ctxt->table[key] != NULL) {

	mov	eax, DWORD PTR [esi+4]
	movzx	ecx, dx
	shl	ecx, 2
	mov	DWORD PTR tv3227[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	test	eax, eax
	je	SHORT $LN466@xmlExpPars
$LL261@xmlExpPars:

; 6720 : 	    if ((insert->key == kbase) &&

	cmp	WORD PTR [eax+2], bx
	jne	SHORT $LN259@xmlExpPars
	cmp	BYTE PTR [eax], 5
	jne	SHORT $LN259@xmlExpPars

; 6721 : 	        (insert->type == type)) {
; 6722 : 		if (type == XML_EXP_ATOM) {
; 6723 : 		    if (name == insert->exp_str) {
; 6724 : 			insert->ref++;
; 6725 : 			return(insert);
; 6726 : 		    }
; 6727 : 		} else if (type == XML_EXP_COUNT) {
; 6728 : 		    if ((insert->exp_min == min) && (insert->exp_max == max) &&

	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN259@xmlExpPars
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN259@xmlExpPars
	cmp	DWORD PTR [eax+12], edi
	je	SHORT $LN370@xmlExpPars
$LN259@xmlExpPars:

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;
; 6719 : 	     insert = insert->next) {

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	jne	SHORT $LL261@xmlExpPars
$LN466@xmlExpPars:

; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)

	cmp	DWORD PTR [esi+16], 10000		; 00002710H
	jge	SHORT $LN425@xmlExpPars

; 6546 :         return(NULL);
; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 6548 :     if (ret == NULL)

	test	eax, eax
	je	SHORT $LN425@xmlExpPars
	xorps	xmm0, xmm0

; 6549 :         return(NULL);
; 6550 :     memset(ret, 0, sizeof(xmlExpNode));

	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	mov	DWORD PTR [eax+24], 0

; 6551 :     ret->type = type;

	mov	BYTE PTR [eax], 5

; 6552 :     ret->next = NULL;
; 6553 :     ctxt->nb_nodes++;

	inc	DWORD PTR [esi+16]

; 6554 :     ctxt->nb_cons++;

	inc	DWORD PTR [esi+32]

; 6757 : 	    entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [eax+1], 1
	mov	DWORD PTR [eax+12], edi

; 6762 :     } else {
; 6763 : 	entry->exp_left = left;
; 6764 : 	entry->exp_right = right;
; 6765 : 	if (type == XML_EXP_OR) {
; 6766 : 	    if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))
; 6767 : 		entry->info |= XML_EXP_NILABLE;
; 6768 : 	    if ((entry->exp_left->c_max == -1) ||
; 6769 : 	        (entry->exp_right->c_max == -1))
; 6770 : 		entry->c_max = -1;
; 6771 : 	    else if (entry->exp_left->c_max > entry->exp_right->c_max)
; 6772 : 	        entry->c_max = entry->exp_left->c_max;
; 6773 : 	    else
; 6774 : 	        entry->c_max = entry->exp_right->c_max;
; 6775 : 	} else {
; 6776 : 	    if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))
; 6777 : 		entry->info |= XML_EXP_NILABLE;
; 6778 : 	    if ((entry->exp_left->c_max == -1) ||
; 6779 : 	        (entry->exp_right->c_max == -1))
; 6780 : 		entry->c_max = -1;
; 6781 : 	    else
; 6782 : 	        entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;
; 6783 : 	}
; 6784 :     }
; 6785 :     entry->ref = 1;
; 6786 :     if (ctxt->table[key] != NULL)

	mov	edi, DWORD PTR tv3227[ebp]
	mov	WORD PTR [eax+2], bx
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], -1
	mov	DWORD PTR [eax+8], -1
	mov	DWORD PTR [eax+4], 1
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+ecx]
	test	edx, edx
	je	SHORT $LN326@xmlExpPars

; 6787 :         entry->next = ctxt->table[key];

	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [esi+4]
$LN326@xmlExpPars:

; 6788 : 
; 6789 :     ctxt->table[key] = entry;

	mov	DWORD PTR [ecx+edi], eax

; 6790 :     ctxt->nbElems++;
; 6791 : 
; 6792 :     return(entry);

	mov	edi, eax
	inc	DWORD PTR [esi+12]
	jmp	SHORT $LL22@xmlExpPars
$LN370@xmlExpPars:

; 6729 : 		        (insert->exp_left == left)) {
; 6730 : 			insert->ref++;

	inc	DWORD PTR [eax+4]

; 6731 : 			left->ref--;

	dec	DWORD PTR [edi+4]

; 6732 : 			return(insert);

	mov	edi, eax
	jmp	SHORT $LL22@xmlExpPars
$LN425@xmlExpPars:

; 6733 : 		    }
; 6734 : 		} else if ((insert->exp_left == left) &&
; 6735 : 			   (insert->exp_right == right)) {
; 6736 : 		    insert->ref++;
; 6737 : 		    left->ref--;
; 6738 : 		    right->ref--;
; 6739 : 		    return(insert);
; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}
; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);
; 6746 :     if (entry == NULL)
; 6747 :         return(NULL);

	xor	edi, edi
	npad	6
$LL22@xmlExpPars:

; 7961 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, ret, NULL, NULL,
; 7962 : 	                         0, -1);
; 7963 : 	SKIP_BLANKS

	mov	ecx, DWORD PTR [esi+28]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN48@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN48@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN48@xmlExpPars
	cmp	al, 9
	jne	SHORT $LN485@xmlExpPars
$LN48@xmlExpPars:
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LL22@xmlExpPars
$LN485@xmlExpPars:

; 7964 :     }
; 7965 :     return(ret);

	mov	eax, edi
	pop	edi

; 7966 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlExpParseOr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseNumber
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpParseNumber PROC					; COMDAT

; 7875 : xmlExpParseNumber(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR [esi+28]
$LL2@xmlExpPars:

; 7876 :     int ret = 0;
; 7877 : 
; 7878 :     SKIP_BLANKS

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	cmp	al, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	cmp	al, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	cmp	al, 9
	jne	SHORT $LN3@xmlExpPars
$LN6@xmlExpPars:
	inc	edx
	mov	DWORD PTR [esi+28], edx
	jmp	SHORT $LL2@xmlExpPars
$LN3@xmlExpPars:

; 7879 :     if (CUR == '*') {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN7@xmlExpPars

; 7880 : 	NEXT

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+28], eax
$LN9@xmlExpPars:

; 7890 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlExpPars:

; 7881 : 	return(-1);
; 7882 :     }
; 7883 :     if ((CUR < '0') || (CUR > '9'))

	cmp	al, 48					; 00000030H
	jl	SHORT $LN9@xmlExpPars
	cmp	al, 57					; 00000039H
	jg	SHORT $LN9@xmlExpPars
$LL4@xmlExpPars:

; 7884 :         return(-1);
; 7885 :     while ((CUR >= '0') && (CUR <= '9')) {

	cmp	al, 57					; 00000039H
	jg	SHORT $LN5@xmlExpPars

; 7886 :         ret = ret * 10 + (CUR - '0');

	movsx	eax, al
	lea	ecx, DWORD PTR [ecx+ecx*4]

; 7887 : 	NEXT

	inc	edx
	lea	ecx, DWORD PTR [ecx-24]
	mov	DWORD PTR [esi+28], edx
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL4@xmlExpPars
$LN5@xmlExpPars:

; 7888 :     }
; 7889 :     return(ret);

	mov	eax, ecx
	pop	esi

; 7890 : }

	pop	ebp
	ret	0
_xmlExpParseNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParseExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpParseExpr PROC					; COMDAT

; 7990 : xmlExpParseExpr(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlExpParseSeq
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 4
	mov	edi, eax
$LL2@xmlExpPars:

; 7991 :     xmlExpNodePtr ret, right;
; 7992 : 
; 7993 :     ret = xmlExpParseSeq(ctxt);
; 7994 :     SKIP_BLANKS

	mov	dl, BYTE PTR [ecx]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN6@xmlExpPars
	cmp	dl, 9
	jne	SHORT $LN12@xmlExpPars
$LN6@xmlExpPars:
	inc	ecx
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LL2@xmlExpPars
$LN12@xmlExpPars:

; 7995 :     while (CUR == ',') {

	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN5@xmlExpPars
$LL4@xmlExpPars:

; 7996 :         NEXT

	lea	eax, DWORD PTR [ecx+1]

; 7997 : 	right = xmlExpParseSeq(ctxt);

	push	esi
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseSeq
	add	esp, 4

; 7998 : 	if (right == NULL) {

	test	eax, eax
	je	SHORT $LN13@xmlExpPars

; 8000 : 	    return(NULL);
; 8001 : 	}
; 8002 : 	ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, right, NULL, 0, 0);

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	3
	push	esi
	call	_xmlExpHashGetEntry
	mov	edi, eax
	add	esp, 28					; 0000001cH

; 8003 : 	if (ret == NULL)

	test	edi, edi
	je	SHORT $LN14@xmlExpPars

; 7995 :     while (CUR == ',') {

	mov	ecx, DWORD PTR [esi+28]
	cmp	BYTE PTR [ecx], 44			; 0000002cH
	je	SHORT $LL4@xmlExpPars
$LN5@xmlExpPars:

; 8004 : 	    return(NULL);
; 8005 :     }
; 8006 :     return(ret);

	mov	eax, edi
	pop	edi

; 8007 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlExpPars:

; 7999 : 	    xmlExpFree(ctxt, ret);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 8
$LN14@xmlExpPars:

; 8007 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlExpParseExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDivide
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_mult$ = 20						; size = 4
_remain$ = 24						; size = 4
_xmlExpDivide PROC					; COMDAT

; 7266 :              xmlExpNodePtr *mult, xmlExpNodePtr *remain) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _mult$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlExpDivi

; 7267 :     int i;
; 7268 :     xmlExpNodePtr tmp, tmp2;
; 7269 : 
; 7270 :     if (mult != NULL) *mult = NULL;

	mov	DWORD PTR [eax], 0
$LN5@xmlExpDivi:

; 7271 :     if (remain != NULL) *remain = NULL;

	mov	eax, DWORD PTR _remain$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlExpDivi
	mov	DWORD PTR [eax], 0
$LN6@xmlExpDivi:

; 7272 :     if (exp->c_max == -1) return(0);

	mov	eax, DWORD PTR _exp$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, -1
	je	$LN3@xmlExpDivi

; 7273 :     if (IS_NILLABLE(exp) && (!IS_NILLABLE(sub))) return(0);

	test	BYTE PTR [eax+1], 1
	mov	eax, DWORD PTR _sub$[ebp]
	je	SHORT $LN8@xmlExpDivi
	test	BYTE PTR [eax+1], 1
	je	$LN3@xmlExpDivi
$LN8@xmlExpDivi:

; 7274 : 
; 7275 :     for (i = 1;i <= exp->c_max;i++) {

	mov	ebx, 1
	cmp	ecx, ebx
	jl	$LN3@xmlExpDivi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	4
$LL4@xmlExpDivi:

; 7276 :         sub->ref++;

	inc	DWORD PTR [eax+4]

; 7277 :         tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,

	push	ebx
	push	ebx
	push	0
	push	0
	push	eax
	push	5
	push	edi
	call	_xmlExpHashGetEntry
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 7278 : 				 sub, NULL, NULL, i, i);
; 7279 : 	if (tmp == NULL) {

	test	esi, esi
	je	$LN25@xmlExpDivi

; 7234 :     if (sub->c_max == -1) {

	mov	edx, DWORD PTR _exp$[ebp]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, -1
	je	SHORT $LN22@xmlExpDivi

; 7235 :         if (exp->c_max != -1)
; 7236 : 	    ret = 0;
; 7237 :     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {

	test	eax, eax
	js	SHORT $LN10@xmlExpDivi
	cmp	eax, ecx
	jge	SHORT $LN10@xmlExpDivi

; 7280 : 	    return(-1);
; 7281 : 	}
; 7282 : 	if (!xmlExpCheckCard(tmp, exp)) {

	jmp	SHORT $LN2@xmlExpDivi
$LN22@xmlExpDivi:
	cmp	eax, -1
	jne	SHORT $LN2@xmlExpDivi
$LN10@xmlExpDivi:

; 7283 : 	    xmlExpFree(ctxt, tmp);
; 7284 : 	    continue;
; 7285 : 	}
; 7286 : 	tmp2 = xmlExpExpDeriveInt(ctxt, tmp, exp);

	push	edx
	push	esi
	push	edi
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7287 : 	if (tmp2 == NULL) {

	test	edi, edi
	je	SHORT $LN26@xmlExpDivi

; 7289 : 	    return(-1);
; 7290 : 	}
; 7291 : 	if ((tmp2 != forbiddenExp) && (IS_NILLABLE(tmp2))) {

	cmp	edi, DWORD PTR _forbiddenExp
	je	SHORT $LN12@xmlExpDivi
	test	BYTE PTR [edi+1], 1
	jne	SHORT $LN27@xmlExpDivi
$LN12@xmlExpDivi:

; 7304 : 	}
; 7305 : 	xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlExpFree

; 7306 : 	xmlExpFree(ctxt, tmp2);

	mov	esi, edi
	add	esp, 8
	mov	edi, DWORD PTR _ctxt$[ebp]
$LN2@xmlExpDivi:

; 7274 : 
; 7275 :     for (i = 1;i <= exp->c_max;i++) {

	push	esi
	push	edi
	call	_xmlExpFree
	mov	eax, DWORD PTR _exp$[ebp]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [eax+8]
	jg	SHORT $LN3@xmlExpDivi
	mov	eax, DWORD PTR _sub$[ebp]
	jmp	$LL4@xmlExpDivi
$LN27@xmlExpDivi:

; 7292 : 	    if (remain != NULL)

	mov	eax, DWORD PTR _remain$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlExpDivi

; 7293 : 	        *remain = tmp2;

	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	jmp	SHORT $LN14@xmlExpDivi
$LN13@xmlExpDivi:

; 7294 : 	    else
; 7295 : 	        xmlExpFree(ctxt, tmp2);

	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	_xmlExpFree
	add	esp, 8
$LN14@xmlExpDivi:

; 7296 : 	    if (mult != NULL)

	mov	eax, DWORD PTR _mult$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlExpDivi

; 7297 : 	        *mult = tmp;

	pop	edi
	mov	DWORD PTR [eax], esi

; 7300 : #ifdef DEBUG_DERIV
; 7301 : 	    printf("Divide succeeded %d\n", i);
; 7302 : #endif
; 7303 : 	    return(i);

	mov	eax, ebx

; 7307 :     }
; 7308 : #ifdef DEBUG_DERIV
; 7309 :     printf("Divide failed\n");
; 7310 : #endif
; 7311 :     return(0);
; 7312 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlExpDivi:

; 7298 : 	    else
; 7299 : 	        xmlExpFree(ctxt, tmp);

	push	esi
	push	edi
	call	_xmlExpFree
	add	esp, 8

; 7300 : #ifdef DEBUG_DERIV
; 7301 : 	    printf("Divide succeeded %d\n", i);
; 7302 : #endif
; 7303 : 	    return(i);

	mov	eax, ebx
	pop	edi

; 7307 :     }
; 7308 : #ifdef DEBUG_DERIV
; 7309 :     printf("Divide failed\n");
; 7310 : #endif
; 7311 :     return(0);
; 7312 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlExpDivi:

; 7288 : 	    xmlExpFree(ctxt, tmp);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlExpFree
	add	esp, 8
$LN25@xmlExpDivi:

; 7307 :     }
; 7308 : #ifdef DEBUG_DERIV
; 7309 :     printf("Divide failed\n");
; 7310 : #endif
; 7311 :     return(0);
; 7312 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlExpDivi:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlExpDivide ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpExpDeriveInt
_TEXT	SEGMENT
_tmp2$4$ = -20						; size = 4
_sub$1$ = -16						; size = 4
_tmp3$1$ = -16						; size = 4
tv1441 = -16						; size = 4
tv1407 = -16						; size = 4
_len$1$ = -12						; size = 4
_i$1$ = -8						; size = 4
$T1 = -4						; size = 4
_tmp$7$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_exp$1$ = 12						; size = 4
_tab$1$ = 12						; size = 4
_tmp2$1$ = 12						; size = 4
_ret$6$ = 12						; size = 4
_ret$4$ = 12						; size = 4
tv1450 = 12						; size = 4
tv1444 = 12						; size = 4
tv1434 = 12						; size = 4
tv1375 = 12						; size = 4
tv1364 = 12						; size = 4
_exp$ = 12						; size = 4
_i$1$ = 16						; size = 4
_ret$7$ = 16						; size = 4
tv1449 = 16						; size = 4
_sub$ = 16						; size = 4
_xmlExpExpDeriveInt PROC				; COMDAT

; 7326 : xmlExpExpDeriveInt(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _exp$[ebp]
	mov	esi, DWORD PTR _sub$[ebp]
	cmp	ebx, esi
	jne	SHORT $LN9@xmlExpExpD

; 7327 :     xmlExpNodePtr ret, tmp, tmp2, tmp3;
; 7328 :     const xmlChar **tab;
; 7329 :     int len, i;
; 7330 : 
; 7331 :     /*
; 7332 :      * In case of equality and if the expression can only consume a finite
; 7333 :      * amount, then the derivation is empty
; 7334 :      */
; 7335 :     if ((exp == sub) && (exp->c_max >= 0)) {

	cmp	DWORD PTR [ebx+8], 0
	jge	$LN155@xmlExpExpD
$LN9@xmlExpExpD:

; 7336 : #ifdef DEBUG_DERIV
; 7337 :         printf("Equal(exp, sub) and finite -> Empty\n");
; 7338 : #endif
; 7339 :         return(emptyExp);
; 7340 :     }
; 7341 :     /*
; 7342 :      * decompose sub sequence first
; 7343 :      */
; 7344 :     if (sub->type == XML_EXP_EMPTY) {

	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $LN10@xmlExpExpD

; 7345 : #ifdef DEBUG_DERIV
; 7346 :         printf("Empty(sub) -> Empty\n");
; 7347 : #endif
; 7348 : 	exp->ref++;

	inc	DWORD PTR [ebx+4]

; 7349 :         return(exp);

	mov	eax, ebx
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlExpExpD:

; 7350 :     }
; 7351 :     if (sub->type == XML_EXP_SEQ) {

	cmp	al, 3
	jne	SHORT $LN11@xmlExpExpD

; 7352 : #ifdef DEBUG_DERIV
; 7353 :         printf("Seq(sub) -> decompose\n");
; 7354 : #endif
; 7355 :         tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);

	push	DWORD PTR [esi+12]
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	ebx
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7356 : 	if (tmp == NULL)

	test	edi, edi
	je	$LN149@xmlExpExpD

; 7357 : 	    return(NULL);
; 7358 : 	if (tmp == forbiddenExp)

	cmp	edi, DWORD PTR _forbiddenExp
	je	$LN1@xmlExpExpD

; 7359 : 	    return(tmp);
; 7360 : 	ret = xmlExpExpDeriveInt(ctxt, tmp, sub->exp_right);

	push	DWORD PTR [esi+20]
	push	edi
	push	ebx
	call	_xmlExpExpDeriveInt

; 7361 : 	xmlExpFree(ctxt, tmp);

	push	edi
	push	ebx
	mov	esi, eax
	call	_xmlExpFree
	add	esp, 20					; 00000014H

; 7362 : 	return(ret);

	mov	eax, esi
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlExpExpD:

; 7363 :     }
; 7364 :     if (sub->type == XML_EXP_OR) {

	cmp	al, 4
	jne	SHORT $LN14@xmlExpExpD

; 7365 : #ifdef DEBUG_DERIV
; 7366 :         printf("Or(sub) -> decompose\n");
; 7367 : #endif
; 7368 :         tmp = xmlExpExpDeriveInt(ctxt, exp, sub->exp_left);

	push	DWORD PTR [esi+12]
	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7369 : 	if (tmp == forbiddenExp)

	cmp	edi, DWORD PTR _forbiddenExp
	je	$LN1@xmlExpExpD

; 7370 : 	    return(tmp);
; 7371 : 	if (tmp == NULL)

	test	edi, edi
	je	$LN149@xmlExpExpD

; 7372 : 	    return(NULL);
; 7373 : 	ret = xmlExpExpDeriveInt(ctxt, exp, sub->exp_right);

	push	DWORD PTR [esi+20]
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	ebx
	call	_xmlExpExpDeriveInt
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 7374 : 	if ((ret == NULL) || (ret == forbiddenExp)) {

	test	esi, esi
	je	SHORT $LN18@xmlExpExpD
	cmp	esi, DWORD PTR _forbiddenExp
	je	SHORT $LN18@xmlExpExpD

; 7377 : 	}
; 7378 : 	return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret, NULL, 0, 0));

	push	0
	push	0
	push	0
	push	esi
	push	edi
	push	4
	push	ebx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlExpExpD:

; 7375 : 	    xmlExpFree(ctxt, tmp);

	push	edi
	push	ebx
	call	_xmlExpFree
	add	esp, 8

; 7376 : 	    return(ret);

	mov	eax, esi
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlExpExpD:

; 7379 :     }
; 7380 :     if (!xmlExpCheckCard(exp, sub)) {

	push	esi
	push	ebx
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	je	$LN158@xmlExpExpD

; 7381 : #ifdef DEBUG_DERIV
; 7382 :         printf("CheckCard(exp, sub) failed -> Forbid\n");
; 7383 : #endif
; 7384 :         return(forbiddenExp);
; 7385 :     }
; 7386 :     switch (exp->type) {

	movzx	eax, BYTE PTR [ebx]
	mov	edi, DWORD PTR _ctxt$[ebp]
	cmp	eax, 5
	ja	$LN157@xmlExpExpD
	jmp	DWORD PTR $LN163@xmlExpExpD[eax*4]
$LN20@xmlExpExpD:

; 7387 :         case XML_EXP_EMPTY:
; 7388 : 	    if (sub == emptyExp)

	cmp	esi, DWORD PTR _emptyExp
	jmp	SHORT $LN159@xmlExpExpD
$LN23@xmlExpExpD:

; 7389 : 	        return(emptyExp);
; 7390 : #ifdef DEBUG_DERIV
; 7391 : 	    printf("Empty(exp) -> Forbid\n");
; 7392 : #endif
; 7393 : 	    return(forbiddenExp);
; 7394 :         case XML_EXP_FORBID:
; 7395 : #ifdef DEBUG_DERIV
; 7396 : 	    printf("Forbid(exp) -> Forbid\n");
; 7397 : #endif
; 7398 : 	    return(forbiddenExp);
; 7399 :         case XML_EXP_ATOM:
; 7400 : 	    if (sub->type == XML_EXP_ATOM) {

	mov	al, BYTE PTR [esi]
	cmp	al, 2
	jne	SHORT $LN24@xmlExpExpD

; 7401 : 	        /* TODO: handle wildcards */
; 7402 : 	        if (exp->exp_str == sub->exp_str) {

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [esi+20]
	jmp	SHORT $LN159@xmlExpExpD
$LN24@xmlExpExpD:

; 7403 : #ifdef DEBUG_DERIV
; 7404 : 		    printf("Atom match -> Empty\n");
; 7405 : #endif
; 7406 : 		    return(emptyExp);
; 7407 :                 }
; 7408 : #ifdef DEBUG_DERIV
; 7409 : 		printf("Atom mismatch -> Forbid\n");
; 7410 : #endif
; 7411 : 	        return(forbiddenExp);
; 7412 : 	    }
; 7413 : 	    if ((sub->type == XML_EXP_COUNT) &&
; 7414 : 	        (sub->exp_max == 1) &&

	cmp	al, 5
	jne	$LN158@xmlExpExpD
	cmp	DWORD PTR [esi+24], 1
	jne	$LN158@xmlExpExpD
	mov	ecx, DWORD PTR [esi+12]
	cmp	BYTE PTR [ecx], 2
	jne	$LN158@xmlExpExpD

; 7415 : 	        (sub->exp_left->type == XML_EXP_ATOM)) {
; 7416 : 	        /* TODO: handle wildcards */
; 7417 : 	        if (exp->exp_str == sub->exp_left->exp_str) {

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [ecx+20]
$LN159@xmlExpExpD:

; 7418 : #ifdef DEBUG_DERIV
; 7419 : 		    printf("Atom match -> Empty\n");
; 7420 : #endif
; 7421 : 		    return(emptyExp);

	jne	$LN158@xmlExpExpD
$LN155@xmlExpExpD:
	mov	eax, DWORD PTR _emptyExp
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlExpExpD:

; 7422 : 		}
; 7423 : #ifdef DEBUG_DERIV
; 7424 : 		printf("Atom mismatch -> Forbid\n");
; 7425 : #endif
; 7426 : 	        return(forbiddenExp);
; 7427 : 	    }
; 7428 : #ifdef DEBUG_DERIV
; 7429 : 	    printf("Compex exp vs Atom -> Forbid\n");
; 7430 : #endif
; 7431 : 	    return(forbiddenExp);
; 7432 :         case XML_EXP_SEQ:
; 7433 : 	    /* try to get the sequence consumed only if possible */
; 7434 : 	    if (xmlExpCheckCard(exp->exp_left, sub)) {

	push	esi
	push	DWORD PTR [ebx+12]
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	je	SHORT $LN156@xmlExpExpD

; 7435 : 		/* See if the sequence can be consumed directly */
; 7436 : #ifdef DEBUG_DERIV
; 7437 : 		printf("Seq trying left only\n");
; 7438 : #endif
; 7439 : 		ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	push	esi
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH

; 7440 : 		if ((ret != forbiddenExp) && (ret != NULL)) {

	cmp	eax, DWORD PTR _forbiddenExp
	je	SHORT $LN156@xmlExpExpD
	test	eax, eax
	je	SHORT $LN156@xmlExpExpD

; 7441 : #ifdef DEBUG_DERIV
; 7442 : 		    printf("Seq trying left only worked\n");
; 7443 : #endif
; 7444 : 		    /*
; 7445 : 		     * TODO: assumption here that we are determinist
; 7446 : 		     *       i.e. we won't get to a nillable exp left
; 7447 : 		     *       subset which could be matched by the right
; 7448 : 		     *       part too.
; 7449 : 		     * e.g.: (a | b)+,(a | c) and 'a+,a'
; 7450 : 		     */
; 7451 : 		    exp->exp_right->ref++;

	mov	ecx, DWORD PTR [ebx+20]

; 7452 : 		    return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,

	push	0
	push	0
	push	0
	inc	DWORD PTR [ecx+4]
	push	DWORD PTR [ebx+20]
	push	eax
	push	3
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN156@xmlExpExpD:

; 7453 : 					      exp->exp_right, NULL, 0, 0));
; 7454 : 		}
; 7455 : #ifdef DEBUG_DERIV
; 7456 : 	    } else {
; 7457 : 		printf("Seq: left too short\n");
; 7458 : #endif
; 7459 : 	    }
; 7460 : 	    /* Try instead to decompose */
; 7461 : 	    if (sub->type == XML_EXP_COUNT) {

	cmp	BYTE PTR [esi], 5
	jne	$LN157@xmlExpExpD

; 7462 : 		int min, max;
; 7463 : 
; 7464 : #ifdef DEBUG_DERIV
; 7465 : 		printf("Seq: sub is a count\n");
; 7466 : #endif
; 7467 : 	        ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);

	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$4$[ebp], eax

; 7468 : 		if (ret == NULL)

	test	eax, eax
	je	SHORT $LN149@xmlExpExpD

; 7469 : 		    return(NULL);
; 7470 : 		if (ret != forbiddenExp) {

	cmp	eax, DWORD PTR _forbiddenExp
	je	$LN157@xmlExpExpD

; 7471 : #ifdef DEBUG_DERIV
; 7472 : 		    printf("Seq , Count match on left\n");
; 7473 : #endif
; 7474 : 		    if (sub->exp_max < 0)

	mov	ecx, DWORD PTR [esi+24]

; 7475 : 		        max = -1;
; 7476 : 	            else
; 7477 : 		        max = sub->exp_max -1;
; 7478 : 		    if (sub->exp_min > 0)

	or	eax, -1
	test	ecx, ecx

; 7479 : 		        min = sub->exp_min -1;
; 7480 : 		    else
; 7481 : 		        min = 0;
; 7482 : 		    exp->exp_right->ref++;
; 7483 : 		    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret,

	push	0
	push	0
	lea	edx, DWORD PTR [ecx-1]
	cmovns	eax, edx
	mov	DWORD PTR tv1449[ebp], eax
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv1441[ebp], eax
	mov	eax, DWORD PTR [ebx+20]
	push	0
	inc	DWORD PTR [eax+4]
	push	DWORD PTR [ebx+20]
	push	DWORD PTR _ret$4$[ebp]
	push	3
	push	edi
	call	_xmlExpHashGetEntry
	mov	ebx, eax
	add	esp, 28					; 0000001cH

; 7484 : 		                             exp->exp_right, NULL, 0, 0);
; 7485 : 		    if (tmp == NULL)

	test	ebx, ebx
	je	SHORT $LN149@xmlExpExpD

; 7486 : 		        return(NULL);
; 7487 : 
; 7488 : 		    sub->exp_left->ref++;

	mov	ecx, DWORD PTR [esi+12]
	xor	edx, edx
	mov	eax, DWORD PTR tv1441[ebp]

; 7489 : 		    tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,

	push	DWORD PTR tv1449[ebp]
	inc	DWORD PTR [ecx+4]
	test	eax, eax
	lea	ecx, DWORD PTR [eax-1]
	cmovle	ecx, edx
	push	ecx
	push	edx
	push	edx
	push	DWORD PTR [esi+12]
	push	5
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tmp2$1$[ebp], eax

; 7490 : 				      sub->exp_left, NULL, NULL, min, max);
; 7491 : 		    if (tmp2 == NULL) {

	test	eax, eax
	jne	SHORT $LN39@xmlExpExpD

; 7492 : 		        xmlExpFree(ctxt, tmp);

	push	ebx
	push	edi
	call	_xmlExpFree
	add	esp, 8
$LN149@xmlExpExpD:

; 7763 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlExpExpD:

; 7493 : 			return(NULL);
; 7494 : 		    }
; 7495 : 		    ret = xmlExpExpDeriveInt(ctxt, tmp, tmp2);

	push	eax
	push	ebx
	push	edi
	call	_xmlExpExpDeriveInt

; 7496 : 		    xmlExpFree(ctxt, tmp);

	push	ebx
	push	edi
	mov	esi, eax
	call	_xmlExpFree

; 7497 : 		    xmlExpFree(ctxt, tmp2);

	push	DWORD PTR _tmp2$1$[ebp]
	push	edi
	call	_xmlExpFree
	add	esp, 28					; 0000001cH

; 7498 : 		    return(ret);

	mov	eax, esi
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlExpExpD:

; 7499 : 		}
; 7500 : 	    }
; 7501 : 	    /* we made no progress on structured operations */
; 7502 : 	    break;
; 7503 :         case XML_EXP_OR:
; 7504 : #ifdef DEBUG_DERIV
; 7505 : 	    printf("Or , trying both side\n");
; 7506 : #endif
; 7507 : 	    ret = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	push	esi
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$6$[ebp], eax

; 7508 : 	    if (ret == NULL)

	test	eax, eax
	je	SHORT $LN149@xmlExpExpD

; 7509 : 	        return(NULL);
; 7510 : 	    tmp = xmlExpExpDeriveInt(ctxt, exp->exp_right, sub);

	push	esi
	push	DWORD PTR [ebx+20]
	push	edi
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH

; 7511 : 	    if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN42@xmlExpExpD

; 7512 : 		xmlExpFree(ctxt, ret);

	push	DWORD PTR _ret$6$[ebp]
	push	edi
	call	_xmlExpFree
	add	esp, 8

; 7513 : 	        return(NULL);

	xor	eax, eax
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlExpExpD:

; 7514 : 	    }
; 7515 : 	    return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp, NULL, 0, 0));

	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _ret$6$[ebp]
	push	4
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlExpExpD:

; 7516 :         case XML_EXP_COUNT: {
; 7517 : 	    int min, max;
; 7518 : 
; 7519 : 	    if (sub->type == XML_EXP_COUNT) {

	cmp	BYTE PTR [esi], 5
	jne	$LN44@xmlExpExpD

; 7520 : 	        /*
; 7521 : 		 * Try to see if the loop is completely subsumed
; 7522 : 		 */
; 7523 : 	        tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub->exp_left);

	push	DWORD PTR [esi+12]
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7524 : 		if (tmp == NULL)

	test	edi, edi
	je	$LN149@xmlExpExpD

; 7525 : 		    return(NULL);
; 7526 : 		if (tmp == forbiddenExp) {

	cmp	edi, DWORD PTR _forbiddenExp
	jne	$LN46@xmlExpExpD

; 7527 : 		    int mult;
; 7528 : 
; 7529 : #ifdef DEBUG_DERIV
; 7530 : 		    printf("Count, Count inner don't subsume\n");
; 7531 : #endif
; 7532 : 		    mult = xmlExpDivide(ctxt, sub->exp_left, exp->exp_left,

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _sub$1$[ebp], ecx
	mov	DWORD PTR _exp$1$[ebp], eax

; 7272 :     if (exp->c_max == -1) return(0);

	mov	edx, DWORD PTR [eax+8]
	cmp	edx, -1
	je	$LN158@xmlExpExpD

; 7273 :     if (IS_NILLABLE(exp) && (!IS_NILLABLE(sub))) return(0);

	test	BYTE PTR [eax+1], 1
	je	SHORT $LN111@xmlExpExpD
	test	BYTE PTR [ecx+1], 1
	je	$LN158@xmlExpExpD
$LN111@xmlExpExpD:

; 7274 : 
; 7275 :     for (i = 1;i <= exp->c_max;i++) {

	mov	eax, 1
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	edx, eax
	jl	$LN158@xmlExpExpD
	mov	edi, DWORD PTR _ctxt$[ebp]
$LL107@xmlExpExpD:

; 7276 :         sub->ref++;

	inc	DWORD PTR [ecx+4]

; 7277 :         tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT,

	push	eax
	push	eax
	push	0
	push	0
	push	ecx
	push	5
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR $T1[ebp], eax

; 7278 : 				 sub, NULL, NULL, i, i);
; 7279 : 	if (tmp == NULL) {

	test	eax, eax
	je	$LN158@xmlExpExpD

; 7234 :     if (sub->c_max == -1) {

	mov	edx, DWORD PTR _exp$1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx+8]
	cmp	edx, -1
	je	SHORT $LN125@xmlExpExpD

; 7235 :         if (exp->c_max != -1)
; 7236 : 	    ret = 0;
; 7237 :     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {

	test	ecx, ecx
	js	SHORT $LN113@xmlExpExpD
	cmp	ecx, edx
	jge	SHORT $LN113@xmlExpExpD

; 7282 : 	if (!xmlExpCheckCard(tmp, exp)) {

	jmp	SHORT $LN105@xmlExpExpD
$LN125@xmlExpExpD:
	cmp	ecx, -1
	jne	SHORT $LN105@xmlExpExpD
$LN113@xmlExpExpD:

; 7283 : 	    xmlExpFree(ctxt, tmp);
; 7284 : 	    continue;
; 7285 : 	}
; 7286 : 	tmp2 = xmlExpExpDeriveInt(ctxt, tmp, exp);

	push	DWORD PTR _exp$1$[ebp]
	push	eax
	push	edi
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7287 : 	if (tmp2 == NULL) {

	test	edi, edi
	je	$LN131@xmlExpExpD

; 7290 : 	}
; 7291 : 	if ((tmp2 != forbiddenExp) && (IS_NILLABLE(tmp2))) {

	cmp	edi, DWORD PTR _forbiddenExp
	je	SHORT $LN115@xmlExpExpD
	test	BYTE PTR [edi+1], 1
	jne	SHORT $LN132@xmlExpExpD
$LN115@xmlExpExpD:

; 7300 : #ifdef DEBUG_DERIV
; 7301 : 	    printf("Divide succeeded %d\n", i);
; 7302 : #endif
; 7303 : 	    return(i);
; 7304 : 	}
; 7305 : 	xmlExpFree(ctxt, tmp);

	push	DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree

; 7306 : 	xmlExpFree(ctxt, tmp2);

	mov	eax, edi
	add	esp, 8
	mov	edi, DWORD PTR _ctxt$[ebp]
$LN105@xmlExpExpD:

; 7274 : 
; 7275 :     for (i = 1;i <= exp->c_max;i++) {

	push	eax
	push	edi
	call	_xmlExpFree
	mov	eax, DWORD PTR _i$1$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _exp$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [ecx+8]
	jg	$LN158@xmlExpExpD
	mov	ecx, DWORD PTR _sub$1$[ebp]
	jmp	$LL107@xmlExpExpD
$LN132@xmlExpExpD:

; 7292 : 	    if (remain != NULL)
; 7293 : 	        *remain = tmp2;
; 7294 : 	    else
; 7295 : 	        xmlExpFree(ctxt, tmp2);
; 7296 : 	    if (mult != NULL)
; 7297 : 	        *mult = tmp;
; 7298 : 	    else
; 7299 : 	        xmlExpFree(ctxt, tmp);

	push	DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlExpFree

; 7533 : 		                        NULL, &tmp);
; 7534 : 		    if (mult <= 0) {

	mov	eax, DWORD PTR _i$1$[ebp]

; 7299 : 	        xmlExpFree(ctxt, tmp);

	add	esp, 8

; 7533 : 		                        NULL, &tmp);
; 7534 : 		    if (mult <= 0) {

	test	eax, eax
	jle	SHORT $LN158@xmlExpExpD

; 7535 : #ifdef DEBUG_DERIV
; 7536 : 			printf("Count, Count not multiple => forbidden\n");
; 7537 : #endif
; 7538 :                         return(forbiddenExp);
; 7539 : 		    }
; 7540 : 		    if (sub->exp_max == -1) {

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ebx+24]
	cmp	ecx, -1
	jne	SHORT $LN49@xmlExpExpD

; 7541 : 		        max = -1;
; 7542 : 			if (exp->exp_max == -1) {

	cmp	edx, ecx
	jne	SHORT $LN152@xmlExpExpD

; 7543 : 			    if (exp->exp_min <= sub->exp_min * mult)

	mov	edx, DWORD PTR [esi+20]

; 7544 : 			        min = 0;
; 7545 : 			    else
; 7546 : 			        min = exp->exp_min - sub->exp_min * mult;
; 7547 : 			} else {
; 7548 : #ifdef DEBUG_DERIV
; 7549 : 			    printf("Count, Count finite can't subsume infinite\n");
; 7550 : #endif
; 7551 :                             xmlExpFree(ctxt, tmp);
; 7552 : 			    return(forbiddenExp);
; 7553 : 			}
; 7554 : 		    } else {

	xor	esi, esi
	mov	ecx, DWORD PTR [ebx+20]
	imul	edx, eax
	sub	ecx, edx
	cmp	DWORD PTR [ebx+20], edx
	cmovg	esi, ecx
	or	edx, -1
	jmp	$LN73@xmlExpExpD
$LN49@xmlExpExpD:

; 7555 : 			if (exp->exp_max == -1) {

	cmp	edx, -1
	jne	SHORT $LN55@xmlExpExpD

; 7556 : #ifdef DEBUG_DERIV
; 7557 : 			    printf("Infinite loop consume mult finite loop\n");
; 7558 : #endif
; 7559 : 			    if (exp->exp_min > sub->exp_min * mult) {

	mov	ecx, DWORD PTR [esi+20]

; 7560 : 				max = -1;
; 7561 : 				min = exp->exp_min - sub->exp_min * mult;
; 7562 : 			    } else {
; 7563 : 				max = -1;
; 7564 : 				min = 0;
; 7565 : 			    }
; 7566 : 			} else {

	or	edx, edx
	mov	esi, DWORD PTR [ebx+20]
	imul	ecx, eax
	mov	DWORD PTR tv1364[ebp], 0
	sub	esi, ecx
	cmp	DWORD PTR [ebx+20], ecx
	cmovle	esi, DWORD PTR tv1364[ebp]
	jmp	$LN73@xmlExpExpD
$LN55@xmlExpExpD:

; 7567 : 			    if (exp->exp_max < sub->exp_max * mult) {

	imul	ecx, eax
	mov	DWORD PTR tv1434[ebp], ecx
	cmp	edx, ecx
	jge	SHORT $LN59@xmlExpExpD
$LN152@xmlExpExpD:

; 7763 : }

	push	edi
$LN161@xmlExpExpD:
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpFree
	add	esp, 8
$LN158@xmlExpExpD:
	mov	eax, DWORD PTR _forbiddenExp
$LN1@xmlExpExpD:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlExpExpD:

; 7568 : #ifdef DEBUG_DERIV
; 7569 : 				printf("loops max mult mismatch => forbidden\n");
; 7570 : #endif
; 7571 : 				xmlExpFree(ctxt, tmp);
; 7572 : 				return(forbiddenExp);
; 7573 : 			    }
; 7574 : 			    if (sub->exp_max * mult > exp->exp_min)

	mov	ecx, DWORD PTR [ebx+20]

; 7575 : 				min = 0;
; 7576 : 			    else
; 7577 : 				min = exp->exp_min - sub->exp_max * mult;
; 7578 : 			    max = exp->exp_max - sub->exp_max * mult;

	xor	esi, esi
	sub	edx, DWORD PTR tv1434[ebp]
	mov	eax, ecx
	sub	eax, DWORD PTR tv1434[ebp]
	cmp	DWORD PTR tv1434[ebp], ecx

; 7579 : 			}
; 7580 : 		    }

	jmp	SHORT $LN160@xmlExpExpD
$LN131@xmlExpExpD:

; 7288 : 	    xmlExpFree(ctxt, tmp);

	push	DWORD PTR $T1[ebp]

; 7289 : 	    return(-1);

	jmp	SHORT $LN161@xmlExpExpD
$LN46@xmlExpExpD:

; 7581 : 		} else if (!IS_NILLABLE(tmp)) {

	test	BYTE PTR [edi+1], 1
	je	SHORT $LN152@xmlExpExpD

; 7582 : 		    /*
; 7583 : 		     * TODO: loop here to try to grow if working on finite
; 7584 : 		     *       blocks.
; 7585 : 		     */
; 7586 : #ifdef DEBUG_DERIV
; 7587 : 		    printf("Count, Count remain not nillable => forbidden\n");
; 7588 : #endif
; 7589 : 		    xmlExpFree(ctxt, tmp);
; 7590 : 		    return(forbiddenExp);
; 7591 : 		} else if (sub->exp_max == -1) {

	mov	eax, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ebx+24]
	mov	DWORD PTR tv1450[ebp], eax
	cmp	eax, -1
	jne	SHORT $LN64@xmlExpExpD

; 7592 : 		    if (exp->exp_max == -1) {

	mov	esi, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR tv1444[ebp], esi
	cmp	edx, eax
	jne	SHORT $LN66@xmlExpExpD

; 7593 : 		        if (exp->exp_min <= sub->exp_min) {
; 7594 : #ifdef DEBUG_DERIV
; 7595 : 			    printf("Infinite loops Okay => COUNT(0,Inf)\n");
; 7596 : #endif
; 7597 :                             max = -1;
; 7598 : 			    min = 0;
; 7599 : 			} else {
; 7600 : #ifdef DEBUG_DERIV
; 7601 : 			    printf("Infinite loops min => Count(X,Inf)\n");
; 7602 : #endif
; 7603 :                             max = -1;
; 7604 : 			    min = exp->exp_min - sub->exp_min;
; 7605 : 			}

	mov	eax, ecx
	sub	eax, esi
	xor	esi, esi
	cmp	ecx, DWORD PTR tv1444[ebp]
	cmovg	esi, eax

; 7615 : 		    }
; 7616 : 		} else {

	or	edx, -1
	jmp	SHORT $LN73@xmlExpExpD
$LN66@xmlExpExpD:

; 7606 : 		    } else if (exp->exp_min > sub->exp_min) {

	cmp	ecx, esi
	jg	SHORT $LN152@xmlExpExpD

; 7607 : #ifdef DEBUG_DERIV
; 7608 : 			printf("loops min mismatch 1 => forbidden ???\n");
; 7609 : #endif
; 7610 : 		        xmlExpFree(ctxt, tmp);
; 7611 : 		        return(forbiddenExp);
; 7612 : 		    } else {
; 7613 : 			max = -1;
; 7614 : 			min = 0;

	xor	esi, esi

; 7615 : 		    }
; 7616 : 		} else {

	or	edx, -1
	jmp	SHORT $LN73@xmlExpExpD
$LN64@xmlExpExpD:

; 7617 : 		    if (exp->exp_max == -1) {

	cmp	edx, -1
	jne	SHORT $LN72@xmlExpExpD

; 7618 : #ifdef DEBUG_DERIV
; 7619 : 			printf("Infinite loop consume finite loop\n");
; 7620 : #endif
; 7621 : 		        if (exp->exp_min > sub->exp_min) {

	mov	eax, DWORD PTR [esi+20]

; 7622 : 			    max = -1;
; 7623 : 			    min = exp->exp_min - sub->exp_min;
; 7624 : 			} else {
; 7625 : 			    max = -1;
; 7626 : 			    min = 0;
; 7627 : 			}
; 7628 : 		    } else {

	or	edx, edx
	mov	esi, DWORD PTR [ebx+20]
	sub	esi, eax
	mov	DWORD PTR tv1375[ebp], 0
	cmp	DWORD PTR [ebx+20], eax
	cmovle	esi, DWORD PTR tv1375[ebp]
	jmp	SHORT $LN73@xmlExpExpD
$LN72@xmlExpExpD:

; 7629 : 		        if (exp->exp_max < sub->exp_max) {

	cmp	edx, eax
	jl	$LN152@xmlExpExpD

; 7630 : #ifdef DEBUG_DERIV
; 7631 : 			    printf("loops max mismatch => forbidden\n");
; 7632 : #endif
; 7633 : 			    xmlExpFree(ctxt, tmp);
; 7634 : 			    return(forbiddenExp);
; 7635 : 			}
; 7636 : 			if (sub->exp_max > exp->exp_min)

	mov	ecx, DWORD PTR [ebx+20]

; 7637 : 			    min = 0;
; 7638 : 			else
; 7639 : 			    min = exp->exp_min - sub->exp_max;
; 7640 : 			max = exp->exp_max - sub->exp_max;

	sub	edx, eax
	mov	eax, ecx
	xor	esi, esi
	sub	eax, DWORD PTR tv1450[ebp]
	cmp	DWORD PTR tv1450[ebp], ecx
$LN160@xmlExpExpD:

; 7641 : 		    }
; 7642 : 		}
; 7643 : #ifdef DEBUG_DERIV
; 7644 : 		printf("loops match => SEQ(COUNT())\n");
; 7645 : #endif
; 7646 : 		exp->exp_left->ref++;

	cmovle	esi, eax
$LN73@xmlExpExpD:
	mov	eax, DWORD PTR [ebx+12]

; 7647 : 		tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,

	push	edx
	push	esi
	push	0
	inc	DWORD PTR [eax+4]
	push	0
	push	DWORD PTR [ebx+12]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	5
	push	ebx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH

; 7648 : 		                          NULL, NULL, min, max);
; 7649 : 		if (tmp2 == NULL) {

	test	eax, eax
	je	$LN149@xmlExpExpD

; 7650 : 		    return(NULL);
; 7651 : 		}
; 7652 :                 ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	3
	push	ebx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlExpExpD:

; 7653 : 		                         NULL, 0, 0);
; 7654 : 		return(ret);
; 7655 : 	    }
; 7656 : 	    tmp = xmlExpExpDeriveInt(ctxt, exp->exp_left, sub);

	push	esi
	push	DWORD PTR [ebx+12]
	push	edi
	call	_xmlExpExpDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7657 : 	    if (tmp == NULL)

	test	edi, edi
	je	$LN149@xmlExpExpD

; 7658 : 		return(NULL);
; 7659 : 	    if (tmp == forbiddenExp) {

	cmp	edi, DWORD PTR _forbiddenExp
	je	$LN158@xmlExpExpD

; 7660 : #ifdef DEBUG_DERIV
; 7661 : 		printf("loop mismatch => forbidden\n");
; 7662 : #endif
; 7663 : 		return(forbiddenExp);
; 7664 : 	    }
; 7665 : 	    if (exp->exp_min > 0)
; 7666 : 		min = exp->exp_min - 1;
; 7667 : 	    else
; 7668 : 		min = 0;
; 7669 : 	    if (exp->exp_max < 0)
; 7670 : 		max = -1;
; 7671 : 	    else
; 7672 : 		max = exp->exp_max - 1;
; 7673 : 
; 7674 : #ifdef DEBUG_DERIV
; 7675 : 	    printf("loop match => SEQ(COUNT())\n");
; 7676 : #endif
; 7677 : 	    exp->exp_left->ref++;

	mov	ecx, DWORD PTR [ebx+12]
	or	eax, -1
	mov	edx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ebx+20]
	inc	DWORD PTR [ecx+4]
	test	edx, edx
	lea	ecx, DWORD PTR [edx-1]
	cmovns	eax, ecx
	xor	ecx, ecx

; 7678 : 	    tmp2 = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left,

	push	eax
	test	esi, esi
	lea	eax, DWORD PTR [esi-1]
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmovle	eax, ecx
	push	eax
	push	ecx
	push	ecx
	push	DWORD PTR [ebx+12]
	push	5
	push	esi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH

; 7679 : 				      NULL, NULL, min, max);
; 7680 : 	    if (tmp2 == NULL)

	test	eax, eax
	je	$LN149@xmlExpExpD

; 7681 : 		return(NULL);
; 7682 : 	    ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, tmp, tmp2,

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	3
	push	esi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN157@xmlExpExpD:

; 7683 : 				     NULL, 0, 0);
; 7684 : 	    return(ret);
; 7685 : 	}
; 7686 :     }
; 7687 : 
; 7688 : #ifdef DEBUG_DERIV
; 7689 :     printf("Fallback to derivative\n");
; 7690 : #endif
; 7691 :     if (IS_NILLABLE(sub)) {

	test	BYTE PTR [esi+1], 1
	je	SHORT $LN87@xmlExpExpD

; 7692 :         if (!(IS_NILLABLE(exp)))

	test	BYTE PTR [ebx+1], 1
	je	$LN158@xmlExpExpD

; 7693 : 	    return(forbiddenExp);
; 7694 : 	else
; 7695 : 	    ret = emptyExp;

	mov	eax, DWORD PTR _emptyExp
	mov	DWORD PTR _ret$7$[ebp], eax

; 7696 :     } else

	jmp	SHORT $LN88@xmlExpExpD
$LN87@xmlExpExpD:

; 7697 : 	ret = NULL;

	mov	DWORD PTR _ret$7$[ebp], 0
$LN88@xmlExpExpD:

; 7698 :     /*
; 7699 :      * here the structured derivation made no progress so
; 7700 :      * we use the default token based derivation to force one more step
; 7701 :      */
; 7702 :     if (ctxt->tabSize == 0)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN91@xmlExpExpD

; 7703 :         ctxt->tabSize = 40;

	mov	DWORD PTR [edi+36], 40			; 00000028H
	mov	eax, 40					; 00000028H
$LN91@xmlExpExpD:

; 7704 : 
; 7705 :     tab = (const xmlChar **) xmlMalloc(ctxt->tabSize *

	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _tab$1$[ebp], eax

; 7706 : 	                               sizeof(const xmlChar *));
; 7707 :     if (tab == NULL) {

	test	eax, eax
	je	$LN149@xmlExpExpD

; 7708 : 	return(NULL);
; 7709 :     }
; 7710 : 
; 7711 :     /*
; 7712 :      * collect all the strings accepted by the subexpression on input
; 7713 :      */
; 7714 :     len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);

	push	0
	push	DWORD PTR [edi+36]
	push	eax
	push	esi
	push	edi
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _len$1$[ebp], eax

; 7715 :     while (len < 0) {

	test	eax, eax
	jns	SHORT $LN5@xmlExpExpD
	npad	4
$LL4@xmlExpExpD:

; 7716 :         const xmlChar **temp;
; 7717 : 	temp = (const xmlChar **) xmlRealloc((xmlChar **) tab, ctxt->tabSize * 2 *

	mov	eax, DWORD PTR [edi+36]
	shl	eax, 3
	push	eax
	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 7718 : 	                                     sizeof(const xmlChar *));
; 7719 : 	if (temp == NULL) {

	test	eax, eax
	je	$LN133@xmlExpExpD

; 7720 : 	    xmlFree((xmlChar **) tab);
; 7721 : 	    return(NULL);
; 7722 : 	}
; 7723 : 	tab = temp;
; 7724 : 	ctxt->tabSize *= 2;

	mov	ecx, DWORD PTR [edi+36]

; 7725 : 	len = xmlExpGetStartInt(ctxt, sub, tab, ctxt->tabSize, 0);

	push	0
	add	ecx, ecx
	mov	DWORD PTR _tab$1$[ebp], eax
	push	ecx
	push	eax
	push	esi
	push	edi
	mov	DWORD PTR [edi+36], ecx
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H
	mov	DWORD PTR _len$1$[ebp], eax
	test	eax, eax
	js	SHORT $LL4@xmlExpExpD
$LN5@xmlExpExpD:

; 7726 :     }
; 7727 :     for (i = 0;i < len;i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	test	eax, eax
	jle	$LN7@xmlExpExpD
	npad	8
$LL8@xmlExpExpD:

; 7728 :         tmp = xmlExpStringDeriveInt(ctxt, exp, tab[i]);

	mov	eax, DWORD PTR _tab$1$[ebp]
	push	DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	push	ebx
	push	edi
	mov	DWORD PTR tv1407[ebp], eax
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$7$[ebp], eax

; 7729 : 	if ((tmp == NULL) || (tmp == forbiddenExp)) {

	test	eax, eax
	je	$LN95@xmlExpExpD
	cmp	eax, DWORD PTR _forbiddenExp
	je	$LN95@xmlExpExpD

; 7733 : 	}
; 7734 : 	tmp2 = xmlExpStringDeriveInt(ctxt, sub, tab[i]);

	mov	eax, DWORD PTR tv1407[ebp]
	push	DWORD PTR [eax]
	push	esi
	push	edi
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp2$4$[ebp], eax

; 7735 : 	if ((tmp2 == NULL) || (tmp2 == forbiddenExp)) {

	test	eax, eax
	je	$LN97@xmlExpExpD
	cmp	eax, DWORD PTR _forbiddenExp
	je	$LN97@xmlExpExpD

; 7740 : 	}
; 7741 : 	tmp3 = xmlExpExpDeriveInt(ctxt, tmp, tmp2);

	push	eax
	push	DWORD PTR _tmp$7$[ebp]
	push	edi
	call	_xmlExpExpDeriveInt

; 7742 : 	xmlExpFree(ctxt, tmp);

	push	DWORD PTR _tmp$7$[ebp]
	mov	DWORD PTR _tmp3$1$[ebp], eax
	push	edi
	call	_xmlExpFree

; 7743 : 	xmlExpFree(ctxt, tmp2);

	push	DWORD PTR _tmp2$4$[ebp]
	push	edi
	call	_xmlExpFree

; 7744 : 
; 7745 : 	if ((tmp3 == NULL) || (tmp3 == forbiddenExp)) {

	mov	ecx, DWORD PTR _tmp3$1$[ebp]
	add	esp, 28					; 0000001cH
	test	ecx, ecx
	je	SHORT $LN99@xmlExpExpD
	cmp	ecx, DWORD PTR _forbiddenExp
	je	SHORT $LN99@xmlExpExpD

; 7749 : 	}
; 7750 : 
; 7751 : 	if (ret == NULL)

	mov	eax, DWORD PTR _ret$7$[ebp]
	test	eax, eax
	jne	SHORT $LN100@xmlExpExpD

; 7752 : 	    ret = tmp3;

	mov	DWORD PTR _ret$7$[ebp], ecx
	jmp	SHORT $LN6@xmlExpExpD
$LN133@xmlExpExpD:

; 7763 : }

	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlExpExpD:

; 7753 : 	else {
; 7754 : 	    ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, ret, tmp3, NULL, 0, 0);

	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	4
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$7$[ebp], eax

; 7755 : 	    if (ret == NULL) {

	test	eax, eax
	je	SHORT $LN133@xmlExpExpD
$LN6@xmlExpExpD:

; 7726 :     }
; 7727 :     for (i = 0;i < len;i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR _len$1$[ebp]
	jl	$LL8@xmlExpExpD
$LN7@xmlExpExpD:

; 7756 : 		xmlFree((xmlChar **) tab);
; 7757 : 	        return(NULL);
; 7758 : 	    }
; 7759 : 	}
; 7760 :     }
; 7761 :     xmlFree((xmlChar **) tab);

	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlFree

; 7762 :     return(ret);

	mov	eax, DWORD PTR _ret$7$[ebp]
	add	esp, 4
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@xmlExpExpD:

; 7746 : 	    xmlExpFree(ctxt, ret);

	push	DWORD PTR _ret$7$[ebp]
	push	edi
	call	_xmlExpFree

; 7747 : 	    xmlFree((xmlChar **) tab);

	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlFree

; 7748 : 	    return(tmp3);

	mov	eax, DWORD PTR _tmp3$1$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@xmlExpExpD:

; 7736 : 	    xmlExpFree(ctxt, tmp);

	mov	ebx, DWORD PTR _tmp$7$[ebp]
	push	ebx
	push	edi
	call	_xmlExpFree

; 7737 : 	    xmlExpFree(ctxt, ret);

	push	DWORD PTR _ret$7$[ebp]
	push	edi
	call	_xmlExpFree

; 7738 : 	    xmlFree((xmlChar **) tab);

	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 7739 : 	    return(tmp);

	mov	eax, ebx
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@xmlExpExpD:

; 7730 : 	    xmlExpFree(ctxt, ret);

	push	DWORD PTR _ret$7$[ebp]
	push	edi
	call	_xmlExpFree

; 7731 : 	    xmlFree((xmlChar **) tab);

	push	DWORD PTR _tab$1$[ebp]
	call	DWORD PTR _xmlFree

; 7732 : 	    return(tmp);

	mov	eax, DWORD PTR _tmp$7$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi

; 7763 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN163@xmlExpExpD:
	DD	$LN20@xmlExpExpD
	DD	$LN158@xmlExpExpD
	DD	$LN23@xmlExpExpD
	DD	$LN28@xmlExpExpD
	DD	$LN40@xmlExpExpD
	DD	$LN43@xmlExpExpD
_xmlExpExpDeriveInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCheckCard
_TEXT	SEGMENT
_exp$ = 8						; size = 4
_sub$ = 12						; size = 4
_xmlExpCheckCard PROC					; COMDAT

; 7231 : xmlExpCheckCard(xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _sub$[ebp]
	mov	ecx, 1
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _exp$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	esi, -1
	jne	SHORT $LN2@xmlExpChec

; 7232 :     int ret = 1;
; 7233 : 
; 7234 :     if (sub->c_max == -1) {
; 7235 :         if (exp->c_max != -1)
; 7236 : 	    ret = 0;
; 7237 :     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {

	xor	eax, eax
	cmp	edx, esi
	pop	esi
	sete	al

; 7238 :         ret = 0;
; 7239 :     }
; 7240 : #if 0
; 7241 :     if ((IS_NILLABLE(sub)) && (!IS_NILLABLE(exp)))
; 7242 :         ret = 0;
; 7243 : #endif
; 7244 :     return(ret);
; 7245 : }

	pop	ebp
	ret	0
$LN2@xmlExpChec:

; 7232 :     int ret = 1;
; 7233 : 
; 7234 :     if (sub->c_max == -1) {
; 7235 :         if (exp->c_max != -1)
; 7236 : 	    ret = 0;
; 7237 :     } else if ((exp->c_max >= 0) && (exp->c_max < sub->c_max)) {

	test	edx, edx
	js	SHORT $LN7@xmlExpChec
	xor	eax, eax
	cmp	edx, esi
	cmovl	ecx, eax
$LN7@xmlExpChec:

; 7238 :         ret = 0;
; 7239 :     }
; 7240 : #if 0
; 7241 :     if ((IS_NILLABLE(sub)) && (!IS_NILLABLE(exp)))
; 7242 :         ret = 0;
; 7243 : #endif
; 7244 :     return(ret);
; 7245 : }

	mov	eax, ecx
	pop	esi
	pop	ebp
	ret	0
_xmlExpCheckCard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpStringDeriveInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
tv358 = 12						; size = 4
_exp$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlExpStringDeriveInt PROC				; COMDAT

; 7091 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [esi]
	cmp	eax, 5
	ja	SHORT $LN2@xmlExpStri

; 7092 :     xmlExpNodePtr ret;
; 7093 : 
; 7094 :     switch (exp->type) {

	jmp	DWORD PTR $LN33@xmlExpStri[eax*4]
$LN6@xmlExpStri:

; 7095 : 	case XML_EXP_EMPTY:
; 7096 : 	    return(forbiddenExp);
; 7097 : 	case XML_EXP_FORBID:
; 7098 : 	    return(forbiddenExp);
; 7099 : 	case XML_EXP_ATOM:
; 7100 : 	    if (exp->exp_str == str) {

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _forbiddenExp
	cmove	eax, DWORD PTR _emptyExp
	pop	edi

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlExpStri:

; 7101 : #ifdef DEBUG_DERIV
; 7102 : 		printf("deriv atom: equal => Empty\n");
; 7103 : #endif
; 7104 : 	        ret = emptyExp;
; 7105 : 	    } else {
; 7106 : #ifdef DEBUG_DERIV
; 7107 : 		printf("deriv atom: mismatch => forbid\n");
; 7108 : #endif
; 7109 : 	        /* TODO wildcards here */
; 7110 : 		ret = forbiddenExp;
; 7111 : 	    }
; 7112 : 	    return(ret);
; 7113 : 	case XML_EXP_OR: {
; 7114 : 	    xmlExpNodePtr tmp;
; 7115 : 
; 7116 : #ifdef DEBUG_DERIV
; 7117 : 	    printf("deriv or: => or(derivs)\n");
; 7118 : #endif
; 7119 : 	    tmp = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	push	DWORD PTR _str$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlExpStringDeriveInt
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 7120 : 	    if (tmp == NULL) {

	test	ebx, ebx
	je	SHORT $LN2@xmlExpStri

; 7121 : 		return(NULL);
; 7122 : 	    }
; 7123 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);

	push	DWORD PTR _str$[ebp]
	push	DWORD PTR [esi+20]
	push	edi
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH

; 7124 : 	    if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlExpStri

; 7125 : 	        xmlExpFree(ctxt, tmp);

	push	ebx
	push	edi
	call	_xmlExpFree
	add	esp, 8
$LN2@xmlExpStri:

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	xor	eax, eax
$LN1@xmlExpStri:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlExpStri:

; 7126 : 		return(NULL);
; 7127 : 	    }
; 7128 :             ret = xmlExpHashGetEntry(ctxt, XML_EXP_OR, tmp, ret,

	push	0
	push	0
	push	0
	push	eax
	push	ebx
	push	4
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlExpStri:

; 7129 : 			     NULL, 0, 0);
; 7130 : 	    return(ret);
; 7131 : 	}
; 7132 : 	case XML_EXP_SEQ:
; 7133 : #ifdef DEBUG_DERIV
; 7134 : 	    printf("deriv seq: starting with left\n");
; 7135 : #endif
; 7136 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	mov	ebx, DWORD PTR _str$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlExpStringDeriveInt
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 7137 : 	    if (ret == NULL) {

	test	edx, edx
	je	SHORT $LN2@xmlExpStri

; 7138 : 	        return(NULL);
; 7139 : 	    } else if (ret == forbiddenExp) {

	cmp	edx, DWORD PTR _forbiddenExp
	jne	SHORT $LN15@xmlExpStri

; 7140 : 	        if (IS_NILLABLE(exp->exp_left)) {

	mov	ecx, DWORD PTR [esi+12]
	test	BYTE PTR [ecx+1], 1
	je	SHORT $LN16@xmlExpStri

; 7141 : #ifdef DEBUG_DERIV
; 7142 : 		    printf("deriv seq: left failed but nillable\n");
; 7143 : #endif
; 7144 : 		    ret = xmlExpStringDeriveInt(ctxt, exp->exp_right, str);

	push	ebx
	push	DWORD PTR [esi+20]
	push	edi
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH

; 7152 : 		                         NULL, 0, 0);
; 7153 : 	    }
; 7154 : 	    return(ret);

	mov	edx, eax
	pop	edi

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlExpStri:

; 7145 : 		}
; 7146 : 	    } else {
; 7147 : #ifdef DEBUG_DERIV
; 7148 : 		printf("deriv seq: left match => sequence\n");
; 7149 : #endif
; 7150 : 	        exp->exp_right->ref++;

	mov	eax, DWORD PTR [esi+20]

; 7151 : 	        ret = xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, exp->exp_right,

	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+4]
	push	DWORD PTR [esi+20]
	push	edx
	push	3
	push	edi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH

; 7152 : 		                         NULL, 0, 0);
; 7153 : 	    }
; 7154 : 	    return(ret);

	mov	edx, eax
$LN16@xmlExpStri:

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlExpStri:

; 7155 : 	case XML_EXP_COUNT: {
; 7156 : 	    int min, max;
; 7157 : 	    xmlExpNodePtr tmp;
; 7158 : 
; 7159 : 	    if (exp->exp_max == 0)

	cmp	DWORD PTR [esi+24], 0
	je	$LN30@xmlExpStri

; 7161 : 	    ret = xmlExpStringDeriveInt(ctxt, exp->exp_left, str);

	push	DWORD PTR _str$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlExpStringDeriveInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7162 : 	    if (ret == NULL)

	test	edi, edi
	je	$LN2@xmlExpStri

; 7163 : 	        return(NULL);
; 7164 : 	    if (ret == forbiddenExp) {

	cmp	edi, DWORD PTR _forbiddenExp
	je	$LN1@xmlExpStri

; 7165 : #ifdef DEBUG_DERIV
; 7166 : 		printf("deriv count: pattern mismatch => forbid\n");
; 7167 : #endif
; 7168 : 	        return(ret);
; 7169 : 	    }
; 7170 : 	    if (exp->exp_max == 1)

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR tv358[ebp], ecx
	cmp	ecx, 1
	je	$LN1@xmlExpStri

; 7171 : 		return(ret);
; 7172 : 	    if (exp->exp_max < 0) /* unbounded */
; 7173 : 		max = -1;
; 7174 : 	    else
; 7175 : 		max = exp->exp_max - 1;
; 7176 : 	    if (exp->exp_min > 0)
; 7177 : 		min = exp->exp_min - 1;
; 7178 : 	    else
; 7179 : 		min = 0;
; 7180 : 	    exp->exp_left->ref++;

	mov	eax, DWORD PTR [esi+12]
	dec	ecx
	mov	edx, DWORD PTR [esi+20]
	inc	DWORD PTR [eax+4]
	or	eax, -1
	cmp	DWORD PTR tv358[ebp], 0
	cmovge	eax, ecx
	xor	ecx, ecx

; 7181 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, exp->exp_left, NULL,

	push	eax
	test	edx, edx
	lea	eax, DWORD PTR [edx-1]
	cmovle	eax, ecx
	push	eax
	push	ecx
	push	ecx
	push	DWORD PTR [esi+12]
	push	5
	push	ebx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH

; 7182 : 				     NULL, min, max);
; 7183 : 	    if (ret == emptyExp) {

	cmp	edi, DWORD PTR _emptyExp
	je	$LN1@xmlExpStri

; 7184 : #ifdef DEBUG_DERIV
; 7185 : 		printf("deriv count: match to empty => new count\n");
; 7186 : #endif
; 7187 : 	        return(tmp);
; 7188 : 	    }
; 7189 : #ifdef DEBUG_DERIV
; 7190 : 	    printf("deriv count: match => sequence with new count\n");
; 7191 : #endif
; 7192 : 	    return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, ret, tmp,

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	3
	push	ebx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN30@xmlExpStri:

; 7160 : 		return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	pop	edi

; 7193 : 	                              NULL, 0, 0));
; 7194 : 	}
; 7195 :     }
; 7196 :     return(NULL);
; 7197 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN33@xmlExpStri:
	DD	$LN30@xmlExpStri
	DD	$LN30@xmlExpStri
	DD	$LN6@xmlExpStri
	DD	$LN12@xmlExpStri
	DD	$LN9@xmlExpStri
	DD	$LN18@xmlExpStri
_xmlExpStringDeriveInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetStartInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_list$ = 16						; size = 4
_len$ = 20						; size = 4
_nb$ = 24						; size = 4
_xmlExpGetStartInt PROC					; COMDAT

; 7008 :                   const xmlChar**list, int len, int nb) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [esi]
	cmp	eax, 5
	ja	SHORT $LN2@xmlExpGetS
	npad	5
$tail$32:

; 7009 :     int tmp, tmp2;
; 7010 : tail:
; 7011 :     switch (exp->type) {

	jmp	DWORD PTR $LN31@xmlExpGetS[eax*4]
$LN12@xmlExpGetS:

; 7023 : 	    return(1);
; 7024 :         case XML_EXP_COUNT:
; 7025 : 	    exp = exp->exp_left;

	mov	esi, DWORD PTR [esi+12]
	movzx	eax, BYTE PTR [esi]
	cmp	eax, 5
	jbe	SHORT $tail$32
$LN2@xmlExpGetS:

; 7048 :     }
; 7049 :     return(-1);

	or	eax, -1
$LN1@xmlExpGetS:
	pop	edi

; 7050 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlExpGetS:

; 7012 :         case XML_EXP_FORBID:
; 7013 : 	    return(0);
; 7014 :         case XML_EXP_EMPTY:
; 7015 : 	    return(0);
; 7016 :         case XML_EXP_ATOM:
; 7017 : 	    for (tmp = 0;tmp < nb;tmp++)

	mov	ecx, DWORD PTR _nb$[ebp]
	xor	eax, eax
	mov	edx, DWORD PTR _list$[ebp]
	test	ecx, ecx
	jle	SHORT $LN5@xmlExpGetS

; 7018 : 	        if (list[tmp] == exp->exp_str)

	mov	edi, DWORD PTR [esi+20]
	npad	7
$LL6@xmlExpGetS:
	cmp	DWORD PTR [edx+eax*4], edi
	je	SHORT $LN23@xmlExpGetS

; 7012 :         case XML_EXP_FORBID:
; 7013 : 	    return(0);
; 7014 :         case XML_EXP_EMPTY:
; 7015 : 	    return(0);
; 7016 :         case XML_EXP_ATOM:
; 7017 : 	    for (tmp = 0;tmp < nb;tmp++)

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL6@xmlExpGetS
$LN5@xmlExpGetS:

; 7019 : 		    return(0);
; 7020 :             if (nb >= len)

	cmp	ecx, DWORD PTR _len$[ebp]
	jl	SHORT $LN11@xmlExpGetS

; 7050 : }

	pop	edi
	pop	esi
	mov	eax, -2					; fffffffeH
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlExpGetS:

; 7021 : 	        return(-2);
; 7022 : 	    list[nb] = exp->exp_str;

	mov	eax, DWORD PTR [esi+20]
	pop	edi

; 7050 : }

	pop	esi
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlExpGetS:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlExpGetS:

; 7026 : 	    goto tail;
; 7027 :         case XML_EXP_SEQ:
; 7028 : 	    tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);

	mov	ebx, DWORD PTR _nb$[ebp]
	push	ebx
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetStartInt
	mov	edi, eax
	add	esp, 20					; 00000014H

; 7029 : 	    if (tmp < 0)

	test	edi, edi
	js	SHORT $LN15@xmlExpGetS

; 7030 : 	        return(tmp);
; 7031 : 	    if (IS_NILLABLE(exp->exp_left)) {

	mov	eax, DWORD PTR [esi+12]
	test	BYTE PTR [eax+1], 1
	je	SHORT $LN15@xmlExpGetS

; 7032 : 		tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,

	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+20]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H

; 7033 : 					    nb + tmp);
; 7034 : 		if (tmp2 < 0)

	test	eax, eax
	js	$LN1@xmlExpGetS

; 7035 : 		    return(tmp2);
; 7036 : 		tmp += tmp2;

	add	edi, eax
$LN15@xmlExpGetS:

; 7050 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlExpGetS:

; 7037 : 	    }
; 7038 :             return(tmp);
; 7039 :         case XML_EXP_OR:
; 7040 : 	    tmp = xmlExpGetStartInt(ctxt, exp->exp_left, list, len, nb);

	mov	ebx, DWORD PTR _nb$[ebp]
	push	ebx
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetStartInt
	mov	edi, eax
	add	esp, 20					; 00000014H

; 7041 : 	    if (tmp < 0)

	test	edi, edi
	js	SHORT $LN15@xmlExpGetS

; 7042 : 	        return(tmp);
; 7043 : 	    tmp2 = xmlExpGetStartInt(ctxt, exp->exp_right, list, len,

	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+20]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H

; 7044 : 	                                nb + tmp);
; 7045 : 	    if (tmp2 < 0)

	test	eax, eax
	js	$LN1@xmlExpGetS

; 7046 : 	        return(tmp2);
; 7047 :             return(tmp + tmp2);

	add	eax, edi
	pop	edi

; 7050 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN31@xmlExpGetS:
	DD	$LN23@xmlExpGetS
	DD	$LN23@xmlExpGetS
	DD	$LN9@xmlExpGetS
	DD	$LN13@xmlExpGetS
	DD	$LN17@xmlExpGetS
	DD	$LN12@xmlExpGetS
_xmlExpGetStartInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetLanguageInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_list$ = 16						; size = 4
_len$ = 20						; size = 4
_nb$ = 24						; size = 4
_xmlExpGetLanguageInt PROC				; COMDAT

; 6955 :                      const xmlChar**list, int len, int nb) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exp$[ebp]
	movzx	eax, BYTE PTR [esi]
	cmp	eax, 5
	ja	SHORT $LN2@xmlExpGetL
	npad	6
$tail$28:

; 6956 :     int tmp, tmp2;
; 6957 : tail:
; 6958 :     switch (exp->type) {

	jmp	DWORD PTR $LN27@xmlExpGetL[eax*4]
$LN11@xmlExpGetL:

; 6969 :         case XML_EXP_COUNT:
; 6970 : 	    exp = exp->exp_left;

	mov	esi, DWORD PTR [esi+12]
	movzx	eax, BYTE PTR [esi]
	cmp	eax, 5
	jbe	SHORT $tail$28
$LN2@xmlExpGetL:
	pop	edi

; 6982 :     }
; 6983 :     return(-1);

	or	eax, -1

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlExpGetL:

; 6959 :         case XML_EXP_EMPTY:
; 6960 : 	    return(0);
; 6961 :         case XML_EXP_ATOM:
; 6962 : 	    for (tmp = 0;tmp < nb;tmp++)

	mov	ecx, DWORD PTR _nb$[ebp]
	xor	eax, eax
	mov	edx, DWORD PTR _list$[ebp]
	test	ecx, ecx
	jle	SHORT $LN5@xmlExpGetL

; 6963 : 	        if (list[tmp] == exp->exp_str)

	mov	edi, DWORD PTR [esi+20]
$LL6@xmlExpGetL:
	cmp	DWORD PTR [edx+eax*4], edi
	je	SHORT $LN18@xmlExpGetL

; 6959 :         case XML_EXP_EMPTY:
; 6960 : 	    return(0);
; 6961 :         case XML_EXP_ATOM:
; 6962 : 	    for (tmp = 0;tmp < nb;tmp++)

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL6@xmlExpGetL
$LN5@xmlExpGetL:

; 6965 :             if (nb >= len)

	cmp	ecx, DWORD PTR _len$[ebp]
	jl	SHORT $LN10@xmlExpGetL

; 6966 : 	        return(-2);

	pop	edi
	mov	eax, -2					; fffffffeH

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlExpGetL:

; 6967 : 	    list[nb] = exp->exp_str;

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	mov	DWORD PTR [edx+ecx*4], eax

; 6968 : 	    return(1);

	mov	eax, 1

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN18@xmlExpGetL:
	pop	edi

; 6964 : 		    return(0);

	xor	eax, eax

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlExpGetL:
	push	ebx

; 6971 : 	    goto tail;
; 6972 :         case XML_EXP_SEQ:
; 6973 :         case XML_EXP_OR:
; 6974 : 	    tmp = xmlExpGetLanguageInt(ctxt, exp->exp_left, list, len, nb);

	mov	ebx, DWORD PTR _nb$[ebp]
	push	ebx
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetLanguageInt
	mov	edi, eax
	add	esp, 20					; 00000014H

; 6975 : 	    if (tmp < 0)

	test	edi, edi
	jns	SHORT $LN13@xmlExpGetL
$LN25@xmlExpGetL:
	pop	ebx
	pop	edi

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlExpGetL:

; 6976 : 	        return(tmp);
; 6977 : 	    tmp2 = xmlExpGetLanguageInt(ctxt, exp->exp_right, list, len,

	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _list$[ebp]
	push	DWORD PTR [esi+20]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpGetLanguageInt
	add	esp, 20					; 00000014H

; 6978 : 	                                nb + tmp);
; 6979 : 	    if (tmp2 < 0)

	test	eax, eax
	js	SHORT $LN25@xmlExpGetL

; 6980 : 	        return(tmp2);
; 6981 :             return(tmp + tmp2);

	pop	ebx
	add	eax, edi
	pop	edi

; 6984 : }

	pop	esi
	pop	ebp
	ret	0
$LN27@xmlExpGetL:
	DD	$LN18@xmlExpGetL
	DD	$LN2@xmlExpGetL
	DD	$LN8@xmlExpGetL
	DD	$LN12@xmlExpGetL
	DD	$LN12@xmlExpGetL
	DD	$LN11@xmlExpGetL
_xmlExpGetLanguageInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashGetEntry
_TEXT	SEGMENT
tv1599 = -12						; size = 4
_min$1$ = -8						; size = 4
_type$1$ = -4						; size = 4
tv1631 = -4						; size = 4
_kbase$ = 8						; size = 2
_value$1 = 8						; size = 2
_ctxt$ = 8						; size = 4
_kbase$1$ = 10						; size = 2
_type$ = 12						; size = 4
_left$ = 16						; size = 4
_right$ = 20						; size = 4
_name$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_xmlExpHashGetEntry PROC				; COMDAT

; 6571 : 		   const xmlChar *name, int min, int max) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN32@xmlExpHash

; 6572 :     unsigned short kbase, key;
; 6573 :     xmlExpNodePtr entry;
; 6574 :     xmlExpNodePtr insert;
; 6575 : 
; 6576 :     if (ctxt == NULL)
; 6577 : 	return(NULL);
; 6578 : 
; 6579 :     /*
; 6580 :      * Check for duplicate and insertion location.
; 6581 :      */
; 6582 :     if (type == XML_EXP_ATOM) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _min$[ebp]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR _type$1$[ebp], eax
	mov	DWORD PTR _min$1$[ebp], ecx
	cmp	eax, 2
	jne	SHORT $LN6@xmlExpHash

; 6583 : 	kbase = xmlExpHashNameComputeKey(name);

	mov	eax, DWORD PTR _name$[ebp]
	mov	edi, eax

; 6494 :     unsigned short value = 0L;

	mov	DWORD PTR _value$1[ebp], 0

; 6495 :     char ch;
; 6496 : 
; 6497 :     if (name != NULL) {

	test	eax, eax
	je	SHORT $LN100@xmlExpHash

; 6498 : 	value += 30 * (*name);

	mov	bl, BYTE PTR [eax]
	movzx	eax, bl
	mov	cx, ax
	shl	cx, 4
	sub	cx, ax
	add	cx, cx
	movzx	ecx, cx
	mov	DWORD PTR _value$1[ebp], ecx

; 6499 : 	while ((ch = *name++) != 0) {

	test	bl, bl
	je	SHORT $LN100@xmlExpHash
	mov	dx, cx
$LL72@xmlExpHash:

; 6500 : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ax, dx
	shl	ecx, 5
	shr	ax, 3
	lea	edi, DWORD PTR [edi+1]
	add	cx, ax
	movsx	ax, bl
	mov	bl, BYTE PTR [edi]
	add	cx, ax
	xor	dx, cx
	mov	WORD PTR _value$1[ebp], dx
	test	bl, bl
	je	SHORT $LN85@xmlExpHash

; 6499 : 	while ((ch = *name++) != 0) {

	mov	ecx, DWORD PTR _value$1[ebp]
	jmp	SHORT $LL72@xmlExpHash
$LN100@xmlExpHash:
	mov	dx, WORD PTR _value$1[ebp]
$LN85@xmlExpHash:

; 6583 : 	kbase = xmlExpHashNameComputeKey(name);

	mov	ebx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _left$[ebp]
	movzx	eax, dx
	jmp	$LN110@xmlExpHash
$LN6@xmlExpHash:

; 6584 :     } else if (type == XML_EXP_COUNT) {

	mov	edi, DWORD PTR _left$[ebp]
	cmp	eax, 5
	jne	SHORT $LN8@xmlExpHash

; 6585 :         /* COUNT reduction rule 1 */
; 6586 : 	/* a{1} -> a */
; 6587 : 	if (min == max) {

	cmp	ecx, edx
	jne	SHORT $LN12@xmlExpHash

; 6588 : 	    if (min == 1) {

	cmp	ecx, 1
	je	SHORT $LN97@xmlExpHash

; 6589 : 		return(left);
; 6590 : 	    }
; 6591 : 	    if (min == 0) {

	test	ecx, ecx
	jne	SHORT $LN111@xmlExpHash

; 6592 : 		xmlExpFree(ctxt, left);

	push	edi
	push	esi
	call	_xmlExpFree

; 6593 : 	        return(emptyExp);

	mov	eax, DWORD PTR _emptyExp
	add	esp, 8
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlExpHash:

; 6594 : 	    }
; 6595 : 	}
; 6596 : 	if (min < 0) {

	test	ecx, ecx
$LN111@xmlExpHash:
	jns	SHORT $LN13@xmlExpHash

; 6597 : 	    xmlExpFree(ctxt, left);

	push	edi
	push	esi
	call	_xmlExpFree

; 6598 : 	    return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	add	esp, 8
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlExpHash:

; 6599 : 	}
; 6600 :         if (max == -1)

	movzx	ecx, cx
	cmp	edx, -1
	jne	SHORT $LN14@xmlExpHash

; 6601 : 	    kbase = min + 79;

	lea	eax, DWORD PTR [ecx+79]
	jmp	SHORT $LN112@xmlExpHash
$LN14@xmlExpHash:

; 6602 : 	else
; 6603 : 	    kbase = max - min;

	mov	eax, edx
	sub	eax, ecx
$LN112@xmlExpHash:

; 6604 : 	kbase += left->key;

	mov	ebx, DWORD PTR _right$[ebp]
	movzx	eax, ax
	mov	DWORD PTR _kbase$[ebp], eax
	add	ax, WORD PTR [edi+2]
	jmp	$LN113@xmlExpHash
$LN8@xmlExpHash:

; 6605 :     } else if (type == XML_EXP_OR) {

	mov	ebx, DWORD PTR _right$[ebp]
	cmp	eax, 4
	jne	$LN16@xmlExpHash

; 6606 :         /* Forbid reduction rules */
; 6607 :         if (left->type == XML_EXP_FORBID) {

	mov	dl, BYTE PTR [edi]
	cmp	dl, 1
	je	SHORT $LN24@xmlExpHash

; 6608 : 	    xmlExpFree(ctxt, left);
; 6609 : 	    return(right);
; 6610 : 	}
; 6611 :         if (right->type == XML_EXP_FORBID) {

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 1
	je	$LN95@xmlExpHash

; 6612 : 	    xmlExpFree(ctxt, right);
; 6613 : 	    return(left);
; 6614 : 	}
; 6615 : 
; 6616 :         /* OR reduction rule 1 */
; 6617 : 	/* a | a reduced to a */
; 6618 :         if (left == right) {

	cmp	edi, ebx
	jne	SHORT $LN20@xmlExpHash

; 6619 : 	    left->ref--;

	dec	DWORD PTR [edi+4]
$LN97@xmlExpHash:

; 6793 : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlExpHash:

; 6620 : 	    return(left);
; 6621 : 	}
; 6622 :         /* OR canonicalization rule 1 */
; 6623 : 	/* linearize (a | b) | c into a | (b | c) */
; 6624 :         if ((left->type == XML_EXP_OR) && (right->type != XML_EXP_OR)) {

	mov	al, cl
	cmp	dl, 4
	jne	SHORT $LN21@xmlExpHash
	cmp	cl, dl
	je	SHORT $LN21@xmlExpHash

; 6625 : 	    xmlExpNodePtr tmp = left;

	mov	eax, edi

; 6626 :             left = right;

	mov	edi, ebx

; 6627 : 	    right = tmp;

	mov	ebx, eax
	mov	al, dl
$LN21@xmlExpHash:

; 6628 : 	}
; 6629 :         /* OR reduction rule 2 */
; 6630 : 	/* a | (a | b) and b | (a | b) are reduced to a | b */
; 6631 :         if (right->type == XML_EXP_OR) {

	cmp	al, 4
	jne	SHORT $LN94@xmlExpHash

; 6632 : 	    if ((left == right->exp_left) ||

	cmp	edi, DWORD PTR [ebx+12]
	je	SHORT $LN24@xmlExpHash
	cmp	edi, DWORD PTR [ebx+20]
	jne	SHORT $LN94@xmlExpHash
$LN24@xmlExpHash:

; 6793 : }

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 8
$LN116@xmlExpHash:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@xmlExpHash:

; 6633 : 	        (left == right->exp_right)) {
; 6634 : 		xmlExpFree(ctxt, left);
; 6635 : 		return(right);
; 6636 : 	    }
; 6637 : 	}
; 6638 :         /* OR canonicalization rule 2 */
; 6639 : 	/* linearize (a | b) | c into a | (b | c) */
; 6640 :         if (left->type == XML_EXP_OR) {

	cmp	BYTE PTR [edi], 4
	jne	SHORT $LN25@xmlExpHash

; 6641 : 	    xmlExpNodePtr tmp;
; 6642 : 
; 6643 : 	    /* OR canonicalization rule 2 */
; 6644 : 	    if ((left->exp_right->type != XML_EXP_OR) &&

	mov	ecx, DWORD PTR [edi+20]
	mov	edx, ecx
	cmp	BYTE PTR [ecx], 4
	je	SHORT $LN26@xmlExpHash
	mov	esi, DWORD PTR [edi+12]
	mov	ax, WORD PTR [ecx+2]
	cmp	ax, WORD PTR [esi+2]
	mov	esi, DWORD PTR _ctxt$[ebp]
	jae	SHORT $LN26@xmlExpHash

; 6645 : 	        (left->exp_right->key < left->exp_left->key)) {
; 6646 : 	        tmp = left->exp_right;
; 6647 : 		left->exp_right = left->exp_left;

	mov	eax, DWORD PTR [edi+12]

; 6648 : 		left->exp_left = tmp;

	mov	edx, eax
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+12], ecx
$LN26@xmlExpHash:

; 6649 : 	    }
; 6650 : 	    left->exp_right->ref++;

	inc	DWORD PTR [edx+4]

; 6651 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_right, right,

	push	0
	push	0
	push	0
	push	ebx
	push	DWORD PTR [edi+20]
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6652 : 	                             NULL, 0, 0);
; 6653 : 	    left->exp_left->ref++;

	mov	ecx, DWORD PTR [edi+12]

; 6654 : 	    tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left->exp_left, tmp,

	push	0
	push	0
	push	0
	inc	DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [edi+12]
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6655 : 	                             NULL, 0, 0);
; 6656 : 
; 6657 : 	    xmlExpFree(ctxt, left);

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlExpFree
	add	esp, 64					; 00000040H

; 6658 : 	    return(tmp);

	mov	eax, esi
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlExpHash:

; 6659 : 	}
; 6660 : 	if (right->type == XML_EXP_OR) {

	cmp	al, 4
	jne	$LN27@xmlExpHash

; 6661 : 	    /* Ordering in the tree */
; 6662 : 	    /* C | (A | B) -> A | (B | C) */
; 6663 : 	    if (left->key > right->exp_right->key) {

	mov	ecx, DWORD PTR [ebx+20]
	movzx	edx, WORD PTR [edi+2]
	cmp	dx, WORD PTR [ecx+2]
	jbe	SHORT $LN29@xmlExpHash

; 6664 : 		xmlExpNodePtr tmp;
; 6665 : 		right->exp_right->ref++;

	inc	DWORD PTR [ecx+4]

; 6666 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_right,

	push	0
	push	0
	push	0
	push	edi
	push	DWORD PTR [ebx+20]
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6667 : 		                         left, NULL, 0, 0);
; 6668 : 		right->exp_left->ref++;

	mov	ecx, DWORD PTR [ebx+12]

; 6669 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,

	push	0
	push	0
	push	0
	inc	DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [ebx+12]
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6670 : 		                         tmp, NULL, 0, 0);
; 6671 : 		xmlExpFree(ctxt, right);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlExpFree
	add	esp, 64					; 00000040H

; 6672 : 		return(tmp);

	mov	eax, esi
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlExpHash:

; 6673 : 	    }
; 6674 : 	    /* Ordering in the tree */
; 6675 : 	    /* B | (A | C) -> A | (B | C) */
; 6676 : 	    if (left->key > right->exp_left->key) {

	mov	eax, DWORD PTR [ebx+12]
	cmp	dx, WORD PTR [eax+2]
	jbe	SHORT $LN31@xmlExpHash

; 6677 : 		xmlExpNodePtr tmp;
; 6678 : 		right->exp_right->ref++;

	inc	DWORD PTR [ecx+4]

; 6679 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, left,

	push	0
	push	0
	push	0
	push	DWORD PTR [ebx+20]
	push	edi
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6680 : 		                         right->exp_right, NULL, 0, 0);
; 6681 : 		right->exp_left->ref++;

	mov	ecx, DWORD PTR [ebx+12]

; 6682 : 		tmp = xmlExpHashGetEntry(ctxt, XML_EXP_OR, right->exp_left,

	push	0
	push	0
	push	0
	inc	DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [ebx+12]
	push	4
	push	esi
	call	_xmlExpHashGetEntry

; 6683 : 		                         tmp, NULL, 0, 0);
; 6684 : 		xmlExpFree(ctxt, right);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlExpFree
	add	esp, 64					; 00000040H

; 6685 : 		return(tmp);

	mov	eax, esi
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlExpHash:

; 6686 : 	    }
; 6687 : 	}
; 6688 : 	/* we know both types are != XML_EXP_OR here */
; 6689 :         else if (left->key > right->key) {

	mov	ax, WORD PTR [edi+2]
	cmp	ax, WORD PTR [ebx+2]
	jbe	SHORT $LN31@xmlExpHash

; 6690 : 	    xmlExpNodePtr tmp = left;

	mov	eax, edi

; 6691 :             left = right;

	mov	edi, ebx

; 6692 : 	    right = tmp;

	mov	ebx, eax
$LN31@xmlExpHash:

; 6693 : 	}
; 6694 : 	kbase = xmlExpHashComputeKey(type, left, right);

	push	ebx
	push	edi
	push	4
	jmp	SHORT $LN114@xmlExpHash
$LN16@xmlExpHash:

; 6695 :     } else if (type == XML_EXP_SEQ) {

	cmp	eax, 3
	jne	$LN32@xmlExpHash

; 6696 :         /* Forbid reduction rules */
; 6697 :         if (left->type == XML_EXP_FORBID) {

	mov	al, BYTE PTR [edi]
	cmp	al, 1
	jne	SHORT $LN34@xmlExpHash
$LN95@xmlExpHash:

; 6698 : 	    xmlExpFree(ctxt, right);

	push	ebx
	push	esi
	call	_xmlExpFree
	add	esp, 8

; 6699 : 	    return(left);

	mov	eax, edi
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlExpHash:

; 6700 : 	}
; 6701 :         if (right->type == XML_EXP_FORBID) {

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 1
	je	$LN24@xmlExpHash

; 6702 : 	    xmlExpFree(ctxt, left);
; 6703 : 	    return(right);
; 6704 : 	}
; 6705 :         /* Empty reduction rules */
; 6706 :         if (right->type == XML_EXP_EMPTY) {

	test	cl, cl
	je	$LN97@xmlExpHash

; 6707 : 	    return(left);
; 6708 : 	}
; 6709 :         if (left->type == XML_EXP_EMPTY) {

	test	al, al
	je	$LN116@xmlExpHash

; 6710 : 	    return(right);
; 6711 : 	}
; 6712 : 	kbase = xmlExpHashComputeKey(type, left, right);

	push	ebx
	push	edi
	push	3
$LN114@xmlExpHash:

; 6713 :     } else
; 6714 :         return(NULL);
; 6715 : 
; 6716 :     key = kbase % ctxt->size;

	call	_xmlExpHashComputeKey
	movzx	eax, ax
	add	esp, 12					; 0000000cH
$LN110@xmlExpHash:
	mov	DWORD PTR _kbase$[ebp], eax
$LN113@xmlExpHash:
	mov	WORD PTR _kbase$1$[ebp], ax
	movzx	eax, ax
	cdq
	idiv	DWORD PTR [esi+8]

; 6717 :     if (ctxt->table[key] != NULL) {

	mov	eax, DWORD PTR [esi+4]
	movzx	ecx, dx
	shl	ecx, 2
	mov	DWORD PTR tv1599[ebp], ecx
	mov	ecx, DWORD PTR [ecx+eax]
	test	ecx, ecx
	je	SHORT $LN98@xmlExpHash
	mov	ax, WORD PTR _kbase$1$[ebp]
$LL4@xmlExpHash:

; 6720 : 	    if ((insert->key == kbase) &&

	cmp	WORD PTR [ecx+2], ax
	jne	SHORT $LN2@xmlExpHash
	movzx	eax, BYTE PTR [ecx]
	mov	edx, DWORD PTR _type$1$[ebp]
	cmp	eax, edx
	jne	SHORT $LN109@xmlExpHash

; 6721 : 	        (insert->type == type)) {
; 6722 : 		if (type == XML_EXP_ATOM) {

	cmp	edx, 2
	jne	SHORT $LN40@xmlExpHash

; 6723 : 		    if (name == insert->exp_str) {

	mov	eax, DWORD PTR _name$[ebp]
	cmp	eax, DWORD PTR [ecx+20]
	jne	SHORT $LN109@xmlExpHash

; 6724 : 			insert->ref++;

	inc	DWORD PTR [ecx+4]

; 6725 : 			return(insert);

	mov	eax, ecx
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlExpHash:

; 6726 : 		    }
; 6727 : 		} else if (type == XML_EXP_COUNT) {

	cmp	edx, 5
	jne	SHORT $LN43@xmlExpHash

; 6728 : 		    if ((insert->exp_min == min) && (insert->exp_max == max) &&

	mov	eax, DWORD PTR _min$1$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jne	SHORT $LN109@xmlExpHash
	mov	eax, DWORD PTR _max$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	jne	SHORT $LN109@xmlExpHash
	cmp	DWORD PTR [ecx+12], edi
	jne	SHORT $LN109@xmlExpHash

; 6729 : 		        (insert->exp_left == left)) {
; 6730 : 			insert->ref++;

	inc	DWORD PTR [ecx+4]

; 6731 : 			left->ref--;
; 6732 : 			return(insert);

	mov	eax, ecx
	dec	DWORD PTR [edi+4]
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlExpHash:

; 6733 : 		    }
; 6734 : 		} else if ((insert->exp_left == left) &&

	cmp	DWORD PTR [ecx+12], edi
	jne	SHORT $LN109@xmlExpHash
	cmp	DWORD PTR [ecx+20], ebx
	je	SHORT $LN84@xmlExpHash
$LN109@xmlExpHash:

; 6718 : 	for (insert = ctxt->table[key]; insert != NULL;
; 6719 : 	     insert = insert->next) {

	mov	ax, WORD PTR _kbase$1$[ebp]
$LN2@xmlExpHash:
	mov	ecx, DWORD PTR [ecx+16]
	test	ecx, ecx
	jne	SHORT $LL4@xmlExpHash
$LN98@xmlExpHash:

; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)

	cmp	DWORD PTR [esi+16], 10000		; 00002710H
	jge	$LN32@xmlExpHash

; 6546 :         return(NULL);
; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 6548 :     if (ret == NULL)

	test	ecx, ecx
	je	$LN32@xmlExpHash

; 6551 :     ret->type = type;

	mov	eax, DWORD PTR _type$1$[ebp]
	xorps	xmm0, xmm0

; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}
; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);
; 6746 :     if (entry == NULL)
; 6747 :         return(NULL);
; 6748 :     entry->key = kbase;

	mov	dx, WORD PTR _kbase$1$[ebp]

; 6550 :     memset(ret, 0, sizeof(xmlExpNode));

	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx+24], 0

; 6551 :     ret->type = type;

	mov	BYTE PTR [ecx], al

; 6552 :     ret->next = NULL;
; 6553 :     ctxt->nb_nodes++;

	inc	DWORD PTR [esi+16]

; 6554 :     ctxt->nb_cons++;

	inc	DWORD PTR [esi+32]

; 6740 : 		}
; 6741 : 	    }
; 6742 : 	}
; 6743 :     }
; 6744 : 
; 6745 :     entry = xmlExpNewNode(ctxt, type);
; 6746 :     if (entry == NULL)
; 6747 :         return(NULL);
; 6748 :     entry->key = kbase;

	mov	WORD PTR [ecx+2], dx

; 6749 :     if (type == XML_EXP_ATOM) {

	cmp	eax, 2
	jne	SHORT $LN48@xmlExpHash

; 6750 : 	entry->exp_str = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 6751 : 	entry->c_max = 1;

	mov	eax, 1
	jmp	$LN115@xmlExpHash
$LN84@xmlExpHash:

; 6735 : 			   (insert->exp_right == right)) {
; 6736 : 		    insert->ref++;

	inc	DWORD PTR [ecx+4]

; 6737 : 		    left->ref--;
; 6738 : 		    right->ref--;
; 6739 : 		    return(insert);

	mov	eax, ecx
	dec	DWORD PTR [edi+4]
	dec	DWORD PTR [ebx+4]
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlExpHash:

; 6752 :     } else if (type == XML_EXP_COUNT) {

	mov	DWORD PTR [ecx+12], edi
	cmp	eax, 5
	jne	SHORT $LN50@xmlExpHash

; 6753 :         entry->exp_min = min;

	mov	eax, DWORD PTR _min$1$[ebp]

; 6754 :         entry->exp_max = max;

	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], edx

; 6755 : 	entry->exp_left = left;
; 6756 : 	if ((min == 0) || (IS_NILLABLE(left)))

	test	eax, eax
	je	SHORT $LN53@xmlExpHash
	test	BYTE PTR [edi+1], 1
	je	SHORT $LN52@xmlExpHash
$LN53@xmlExpHash:

; 6757 : 	    entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [ecx+1], 1
$LN52@xmlExpHash:

; 6758 : 	if (max < 0)

	test	edx, edx
	js	SHORT $LN68@xmlExpHash

; 6759 : 	    entry->c_max = -1;
; 6760 : 	else
; 6761 : 	    entry->c_max = max * entry->exp_left->c_max;

	mov	eax, DWORD PTR [edi+8]
	imul	eax, edx

; 6762 :     } else {

	jmp	SHORT $LN115@xmlExpHash
$LN50@xmlExpHash:

; 6763 : 	entry->exp_left = left;
; 6764 : 	entry->exp_right = right;

	mov	DWORD PTR [ecx+20], ebx
	mov	dl, BYTE PTR [edi+1]
	and	dl, 1

; 6765 : 	if (type == XML_EXP_OR) {

	cmp	eax, 4
	jne	SHORT $LN56@xmlExpHash

; 6766 : 	    if ((IS_NILLABLE(left)) || (IS_NILLABLE(right)))

	test	dl, dl
	jne	SHORT $LN59@xmlExpHash
	test	BYTE PTR [ebx+1], 1
	je	SHORT $LN58@xmlExpHash
$LN59@xmlExpHash:

; 6767 : 		entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [ecx+1], 1
$LN58@xmlExpHash:

; 6768 : 	    if ((entry->exp_left->c_max == -1) ||

	mov	edx, DWORD PTR [edi+8]
	cmp	edx, -1
	je	SHORT $LN68@xmlExpHash
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, -1
	je	SHORT $LN68@xmlExpHash

; 6769 : 	        (entry->exp_right->c_max == -1))
; 6770 : 		entry->c_max = -1;
; 6771 : 	    else if (entry->exp_left->c_max > entry->exp_right->c_max)

	cmp	edx, eax
	cmovg	eax, edx

; 6772 : 	        entry->c_max = entry->exp_left->c_max;
; 6773 : 	    else
; 6774 : 	        entry->c_max = entry->exp_right->c_max;

	jmp	SHORT $LN115@xmlExpHash
$LN56@xmlExpHash:

; 6775 : 	} else {
; 6776 : 	    if ((IS_NILLABLE(left)) && (IS_NILLABLE(right)))

	test	dl, dl
	je	SHORT $LN65@xmlExpHash
	test	BYTE PTR [ebx+1], 1
	je	SHORT $LN65@xmlExpHash

; 6777 : 		entry->info |= XML_EXP_NILABLE;

	or	BYTE PTR [ecx+1], 1
$LN65@xmlExpHash:

; 6778 : 	    if ((entry->exp_left->c_max == -1) ||

	mov	edx, DWORD PTR [edi+8]
	cmp	edx, -1
	je	SHORT $LN68@xmlExpHash
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, -1
	je	SHORT $LN68@xmlExpHash

; 6779 : 	        (entry->exp_right->c_max == -1))
; 6780 : 		entry->c_max = -1;
; 6781 : 	    else
; 6782 : 	        entry->c_max = entry->exp_left->c_max + entry->exp_right->c_max;

	add	eax, edx
	jmp	SHORT $LN115@xmlExpHash
$LN68@xmlExpHash:

; 6783 : 	}
; 6784 :     }
; 6785 :     entry->ref = 1;

	or	eax, -1
$LN115@xmlExpHash:

; 6786 :     if (ctxt->table[key] != NULL)

	mov	edi, DWORD PTR tv1599[ebp]
	mov	edx, ecx
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx+4], 1
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+edi]
	test	edx, edx
	je	SHORT $LN69@xmlExpHash

; 6787 :         entry->next = ctxt->table[key];

	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [esi+4]
$LN69@xmlExpHash:

; 6788 : 
; 6789 :     ctxt->table[key] = entry;

	mov	DWORD PTR [eax+edi], ecx

; 6790 :     ctxt->nbElems++;
; 6791 : 
; 6792 :     return(entry);

	mov	eax, ecx
	inc	DWORD PTR [esi+12]
	pop	edi

; 6793 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlExpHash:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpHashGetEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashComputeKey
_TEXT	SEGMENT
_type$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpHashComputeKey PROC				; COMDAT

; 6512 :                      xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	sub	eax, 3
	je	SHORT $LN4@xmlExpHash

; 6513 :     unsigned long value;
; 6514 :     unsigned short ret;
; 6515 : 
; 6516 :     switch (type) {

	sub	eax, 1
	je	SHORT $LN5@xmlExpHash
	sub	eax, 1
	je	SHORT $LN6@xmlExpHash

; 6533 : 	    break;
; 6534 : 	default:
; 6535 : 	    ret = 0;

	xor	eax, eax

; 6536 :     }
; 6537 :     return(ret);
; 6538 : }

	pop	ebp
	ret	0
$LN6@xmlExpHash:

; 6527 : 	    ret = (unsigned short) value;
; 6528 : 	    break;
; 6529 :         case XML_EXP_COUNT:
; 6530 : 	    value = left->key;
; 6531 : 	    value += right->key;

	mov	eax, DWORD PTR _left$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	eax, DWORD PTR _right$[ebp]
	add	cx, WORD PTR [eax+2]

; 6532 : 	    ret = (unsigned short) value;

	movzx	eax, cx

; 6536 :     }
; 6537 :     return(ret);
; 6538 : }

	pop	ebp
	ret	0
$LN5@xmlExpHash:

; 6521 : 	    ret = (unsigned short) value;
; 6522 : 	    break;
; 6523 :         case XML_EXP_OR:
; 6524 : 	    value = left->key;
; 6525 : 	    value += right->key;
; 6526 : 	    value *= 7;

	mov	eax, DWORD PTR _left$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	eax, DWORD PTR _right$[ebp]
	add	cx, WORD PTR [eax+2]
	mov	ax, cx
	shl	ax, 3
	sub	ax, cx

; 6536 :     }
; 6537 :     return(ret);
; 6538 : }

	movzx	eax, ax
	pop	ebp
	ret	0
$LN4@xmlExpHash:

; 6517 :         case XML_EXP_SEQ:
; 6518 : 	    value = left->key;
; 6519 : 	    value += right->key;
; 6520 : 	    value *= 3;

	mov	eax, DWORD PTR _left$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	eax, DWORD PTR _right$[ebp]
	add	cx, WORD PTR [eax+2]
	mov	ax, cx
	add	cx, cx
	add	ax, cx

; 6536 :     }
; 6537 :     return(ret);
; 6538 : }

	movzx	eax, ax
	pop	ebp
	ret	0
_xmlExpHashComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpHashNameComputeKey
_TEXT	SEGMENT
_value$ = -4						; size = 2
_name$ = 8						; size = 4
_xmlExpHashNameComputeKey PROC				; COMDAT

; 6493 : xmlExpHashNameComputeKey(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	mov	DWORD PTR _value$[ebp], 0
	test	esi, esi
	je	SHORT $LN12@xmlExpHash

; 6494 :     unsigned short value = 0L;
; 6495 :     char ch;
; 6496 : 
; 6497 :     if (name != NULL) {
; 6498 : 	value += 30 * (*name);

	push	ebx
	mov	bl, BYTE PTR [esi]
	movzx	eax, bl
	mov	cx, ax
	shl	cx, 4
	sub	cx, ax
	add	cx, cx
	movzx	eax, cx
	mov	DWORD PTR _value$[ebp], eax

; 6499 : 	while ((ch = *name++) != 0) {

	test	bl, bl
	je	SHORT $LN11@xmlExpHash
	mov	dx, ax
	npad	3
$LL2@xmlExpHash:

; 6500 : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	cx, dx
	shl	eax, 5
	shr	cx, 3
	lea	esi, DWORD PTR [esi+1]
	add	ax, cx
	movsx	cx, bl
	mov	bl, BYTE PTR [esi]
	add	ax, cx
	xor	dx, ax
	mov	WORD PTR _value$[ebp], dx
	test	bl, bl
	je	SHORT $LN16@xmlExpHash

; 6499 : 	while ((ch = *name++) != 0) {

	mov	eax, DWORD PTR _value$[ebp]
	jmp	SHORT $LL2@xmlExpHash
$LN16@xmlExpHash:
	pop	ebx

; 6501 : 	}
; 6502 :     }
; 6503 :     return (value);

	mov	ax, dx
	pop	esi

; 6504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlExpHash:

; 6501 : 	}
; 6502 :     }
; 6503 :     return (value);

	mov	ax, WORD PTR _value$[ebp]
	pop	ebx
	pop	esi

; 6504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlExpHash:

; 6501 : 	}
; 6502 :     }
; 6503 :     return (value);

	mov	ax, WORD PTR _value$[ebp]
	pop	esi

; 6504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlExpHashNameComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlExpNewNode PROC					; COMDAT

; 6542 : xmlExpNewNode(xmlExpCtxtPtr ctxt, xmlExpNodeType type) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+16], 10000		; 00002710H
	jge	SHORT $LN5@xmlExpNewN

; 6543 :     xmlExpNodePtr ret;
; 6544 : 
; 6545 :     if (ctxt->nb_nodes >= MAX_NODES)
; 6546 :         return(NULL);
; 6547 :     ret = (xmlExpNodePtr) xmlMalloc(sizeof(xmlExpNode));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 6548 :     if (ret == NULL)

	test	eax, eax
	je	SHORT $LN5@xmlExpNewN

; 6550 :     memset(ret, 0, sizeof(xmlExpNode));
; 6551 :     ret->type = type;

	mov	cl, BYTE PTR _type$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	mov	DWORD PTR [eax+24], 0
	mov	BYTE PTR [eax], cl

; 6552 :     ret->next = NULL;
; 6553 :     ctxt->nb_nodes++;

	inc	DWORD PTR [esi+16]

; 6554 :     ctxt->nb_cons++;

	inc	DWORD PTR [esi+32]
	pop	esi

; 6555 :     return(ret);
; 6556 : }

	pop	ebp
	ret	0
$LN5@xmlExpNewN:

; 6549 :         return(NULL);

	xor	eax, eax
	pop	esi

; 6555 :     return(ret);
; 6556 : }

	pop	ebp
	ret	0
_xmlExpNewNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseBranch
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_to$ = 12						; size = 4
_xmlFAParseBranch PROC					; COMDAT

; 5344 : xmlFAParseBranch(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr to) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	mov	edi, DWORD PTR [esi+24]
	call	_xmlFAParsePiece
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlFAParse

; 5345 :     xmlRegStatePtr previous;
; 5346 :     int ret;
; 5347 : 
; 5348 :     previous = ctxt->state;
; 5349 :     ret = xmlFAParsePiece(ctxt);
; 5350 :     if (ret != 0) {
; 5351 : 	if (xmlFAGenerateTransitions(ctxt, previous,
; 5352 : 	        (CUR=='|' || CUR==')') ? to : NULL, ctxt->atom) < 0)

	mov	ebx, DWORD PTR _to$[ebp]
$LN21@xmlFAParse:

; 5353 : 	    return(-1);
; 5354 : 	previous = ctxt->state;
; 5355 : 	ctxt->atom = NULL;
; 5356 :     }
; 5357 :     while ((ret != 0) && (ctxt->error == 0)) {

	mov	eax, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax]
	cmp	al, 124					; 0000007cH
	je	SHORT $LN9@xmlFAParse
	cmp	al, 41					; 00000029H
	je	SHORT $LN9@xmlFAParse
	xor	eax, eax
	jmp	SHORT $LN10@xmlFAParse
$LN9@xmlFAParse:
	mov	eax, ebx
$LN10@xmlFAParse:
	push	DWORD PTR [esi+28]
	push	eax
	push	edi
	push	esi
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	js	SHORT $LN14@xmlFAParse
	cmp	DWORD PTR [esi+8], 0
	mov	edi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], 0
	jne	SHORT $LN3@xmlFAParse

; 5358 : 	ret = xmlFAParsePiece(ctxt);

	push	esi
	call	_xmlFAParsePiece
	add	esp, 4

; 5359 : 	if (ret != 0) {

	test	eax, eax
	jne	SHORT $LN21@xmlFAParse
$LN3@xmlFAParse:
	pop	edi

; 5360 : 	    if (xmlFAGenerateTransitions(ctxt, previous,
; 5361 : 	            (CUR=='|' || CUR==')') ? to : NULL, ctxt->atom) < 0)
; 5362 : 		    return(-1);
; 5363 : 	    previous = ctxt->state;
; 5364 : 	    ctxt->atom = NULL;
; 5365 : 	}
; 5366 :     }
; 5367 :     return(0);
; 5368 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlFAParse:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlFAParseBranch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParsePiece
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParsePiece PROC					; COMDAT

; 5319 : xmlFAParsePiece(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	mov	DWORD PTR [esi+28], 0
	call	_xmlFAParseAtom
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlFAParse
	pop	esi

; 5331 : }

	pop	ebp
	ret	0
$LN2@xmlFAParse:

; 5320 :     int ret;
; 5321 : 
; 5322 :     ctxt->atom = NULL;
; 5323 :     ret = xmlFAParseAtom(ctxt);
; 5324 :     if (ret == 0)
; 5325 : 	return(0);
; 5326 :     if (ctxt->atom == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN3@xmlFAParse

; 5327 : 	ERROR("internal: no atom generated");

	push	OFFSET ??_C@_0BM@PFFMPGPF@internal?3?5no?5atom?5generated@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN3@xmlFAParse:

; 5201 :     cur = CUR;

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	edi
	mov	al, BYTE PTR [ecx]

; 5202 :     if ((cur == '?') || (cur == '*') || (cur == '+')) {

	cmp	al, 63					; 0000003fH
	je	$LN7@xmlFAParse
	cmp	al, 42					; 0000002aH
	je	$LN7@xmlFAParse
	cmp	al, 43					; 0000002bH
	je	$LN7@xmlFAParse

; 5212 : 	return(1);
; 5213 :     }
; 5214 :     if (cur == '{') {

	cmp	al, 123					; 0000007bH
	jne	$LN14@xmlFAParse

; 5215 : 	int min = 0, max = 0;
; 5216 : 
; 5217 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	xor	edi, edi

; 5218 : 	cur = xmlFAParseQuantExact(ctxt);

	push	esi
	xor	ebx, ebx
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAParseQuantExact
	add	esp, 4

; 5219 : 	if (cur >= 0)

	test	eax, eax
	cmovns	edi, eax

; 5220 : 	    min = cur;
; 5221 : 	if (CUR == ',') {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 44			; 0000002cH
	jne	SHORT $LN20@xmlFAParse

; 5222 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5223 : 	    if (CUR == '}')

	cmp	BYTE PTR [eax], 125			; 0000007dH
	jne	SHORT $LN17@xmlFAParse

; 5224 : 	        max = INT_MAX;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN20@xmlFAParse
$LN17@xmlFAParse:

; 5225 : 	    else {
; 5226 : 	        cur = xmlFAParseQuantExact(ctxt);

	push	esi
	call	_xmlFAParseQuantExact
	add	esp, 4

; 5227 : 	        if (cur >= 0)

	test	eax, eax
	js	SHORT $LN19@xmlFAParse

; 5228 : 		    max = cur;

	mov	ebx, eax
	jmp	SHORT $LN20@xmlFAParse
$LN19@xmlFAParse:

; 5229 : 		else {
; 5230 : 		    ERROR("Improper quantifier");

	push	OFFSET ??_C@_0BE@PGBJEMPN@Improper?5quantifier@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN20@xmlFAParse:

; 5231 : 		}
; 5232 : 	    }
; 5233 : 	}
; 5234 : 	if (CUR == '}') {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 125			; 0000007dH
	jne	SHORT $LN21@xmlFAParse

; 5235 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5236 : 	} else {

	jmp	SHORT $LN22@xmlFAParse
$LN21@xmlFAParse:

; 5237 : 	    ERROR("Unterminated quantifier");

	push	OFFSET ??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN22@xmlFAParse:

; 5238 : 	}
; 5239 : 	if (max == 0)
; 5240 : 	    max = min;
; 5241 : 	if (ctxt->atom != NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN14@xmlFAParse

; 5242 : 	    ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;

	mov	DWORD PTR [eax+8], 8
	test	ebx, ebx

; 5243 : 	    ctxt->atom->min = min;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+12], edi
	cmovne	edi, ebx

; 5244 : 	    ctxt->atom->max = max;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+16], edi

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	mov	eax, 1
	pop	edi
	pop	ebx
	pop	esi

; 5331 : }

	pop	ebp
	ret	0
$LN7@xmlFAParse:

; 5203 : 	if (ctxt->atom != NULL) {

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN13@xmlFAParse

; 5204 : 	    if (cur == '?')

	cmp	al, 63					; 0000003fH
	jne	SHORT $LN9@xmlFAParse

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	pop	edi

; 5205 : 		ctxt->atom->quant = XML_REGEXP_QUANT_OPT;

	mov	DWORD PTR [ecx+8], 3

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	mov	eax, 1

; 5211 : 	NEXT;

	inc	DWORD PTR [esi+4]

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	pop	ebx
	pop	esi

; 5331 : }

	pop	ebp
	ret	0
$LN9@xmlFAParse:

; 5206 : 	    else if (cur == '*')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN11@xmlFAParse

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	pop	edi

; 5207 : 		ctxt->atom->quant = XML_REGEXP_QUANT_MULT;

	mov	DWORD PTR [ecx+8], 4

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	mov	eax, 1

; 5211 : 	NEXT;

	inc	DWORD PTR [esi+4]

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	pop	ebx
	pop	esi

; 5331 : }

	pop	ebp
	ret	0
$LN11@xmlFAParse:

; 5208 : 	    else if (cur == '+')

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN13@xmlFAParse

; 5209 : 		ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;

	mov	DWORD PTR [ecx+8], 5
$LN13@xmlFAParse:

; 5210 : 	}
; 5211 : 	NEXT;

	inc	DWORD PTR [esi+4]
$LN14@xmlFAParse:

; 5328 :     }
; 5329 :     xmlFAParseQuantifier(ctxt);
; 5330 :     return(1);

	pop	edi
	pop	ebx
	mov	eax, 1
	pop	esi

; 5331 : }

	pop	ebp
	ret	0
_xmlFAParsePiece ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseAtom
_TEXT	SEGMENT
_len$ = -4						; size = 4
_oldend$1$ = 8						; size = 4
_len$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseAtom PROC					; COMDAT

; 5258 : xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 4606 :     cur = CUR_SCHAR(ctxt->cur, len);

	mov	esi, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR _len$1[ebp]
	push	eax
	push	DWORD PTR [esi+4]
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH

; 4607 :     if ((cur == '.') || (cur == '\\') || (cur == '?') ||
; 4608 : 	(cur == '*') || (cur == '+') || (cur == '(') ||
; 4609 : 	(cur == ')') || (cur == '|') || (cur == 0x5B) ||
; 4610 : 	(cur == 0x5D) || (cur == 0))

	cmp	eax, 46					; 0000002eH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 40					; 00000028H
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 41					; 00000029H
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 124				; 0000007cH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN2@xmlFAParse
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN2@xmlFAParse
	test	eax, eax

; 5259 :     int codepoint, len;
; 5260 : 
; 5261 :     codepoint = xmlFAIsChar(ctxt);
; 5262 :     if (codepoint > 0) {

	jle	SHORT $LN2@xmlFAParse

; 5263 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);

	push	2
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 5264 : 	if (ctxt->atom == NULL)

	test	eax, eax
	je	$LN52@xmlFAParse

; 5265 : 	    return(-1);
; 5266 : 	codepoint = CUR_SCHAR(ctxt->cur, len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	DWORD PTR [esi+4]
	push	0
	call	_xmlStringCurrentChar

; 5267 : 	ctxt->atom->codepoint = codepoint;

	mov	ecx, DWORD PTR [esi+28]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+32], eax

; 5268 : 	NEXTL(len);

	mov	eax, DWORD PTR _len$[ebp]
	add	DWORD PTR [esi+4], eax

; 5269 : 	return(1);

	mov	eax, 1
	pop	edi

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlFAParse:

; 5270 :     } else if (CUR == '|') {

	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx]
	cmp	al, 124					; 0000007cH
	je	$LN51@xmlFAParse

; 5271 : 	return(0);
; 5272 :     } else if (CUR == 0) {

	test	al, al
	je	$LN51@xmlFAParse

; 5273 : 	return(0);
; 5274 :     } else if (CUR == ')') {

	cmp	al, 41					; 00000029H
	je	$LN51@xmlFAParse

; 5275 : 	return(0);
; 5276 :     } else if (CUR == '(') {

	cmp	al, 40					; 00000028H
	jne	$LN11@xmlFAParse

; 5277 : 	xmlRegStatePtr start, oldend, start0;
; 5278 : 
; 5279 : 	NEXT;
; 5280 : 	/*
; 5281 : 	 * this extra Epsilon transition is needed if we count with 0 allowed
; 5282 : 	 * unfortunately this can't be known at that point
; 5283 : 	 */
; 5284 : 	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);

	push	0
	push	DWORD PTR [esi+24]
	lea	eax, DWORD PTR [ecx+1]
	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAGenerateEpsilonTransition

; 5285 : 	start0 = ctxt->state;

	mov	edi, DWORD PTR [esi+24]

; 5286 : 	xmlFAGenerateEpsilonTransition(ctxt, ctxt->state, NULL);

	push	0
	push	edi
	push	esi
	call	_xmlFAGenerateEpsilonTransition

; 5287 : 	start = ctxt->state;
; 5288 : 	oldend = ctxt->end;

	mov	eax, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [esi+24]

; 5289 : 	ctxt->end = NULL;
; 5290 : 	ctxt->atom = NULL;
; 5291 : 	xmlFAParseRegExp(ctxt, 0);

	push	0
	push	esi
	mov	DWORD PTR _oldend$1$[ebp], eax
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+28], 0
	call	_xmlFAParseRegExp

; 5292 : 	if (CUR == ')') {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 32					; 00000020H
	cmp	BYTE PTR [eax], 41			; 00000029H
	jne	SHORT $LN13@xmlFAParse

; 5293 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5294 : 	} else {

	jmp	SHORT $LN14@xmlFAParse
$LN13@xmlFAParse:

; 5295 : 	    ERROR("xmlFAParseAtom: expecting ')'");

	push	OFFSET ??_C@_0BO@CCFFKIJF@xmlFAParseAtom?3?5expecting?5?8?$CJ?8@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN14@xmlFAParse:

; 5296 : 	}
; 5297 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_SUBREG);

	push	4
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 5298 : 	if (ctxt->atom == NULL)

	test	eax, eax
	jne	SHORT $LN15@xmlFAParse
$LN52@xmlFAParse:
	pop	edi

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlFAParse:

; 5299 : 	    return(-1);
; 5300 : 	ctxt->atom->start = start;

	mov	DWORD PTR [eax+36], ebx

; 5301 : 	ctxt->atom->start0 = start0;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+40], edi

; 5302 : 	ctxt->atom->stop = ctxt->state;

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+24]
	pop	edi
	mov	DWORD PTR [ecx+44], eax

; 5303 : 	ctxt->end = oldend;

	mov	eax, DWORD PTR _oldend$1$[ebp]
	mov	DWORD PTR [esi+20], eax

; 5304 : 	return(1);

	mov	eax, 1

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlFAParse:

; 5305 :     } else if ((CUR == '[') || (CUR == '\\') || (CUR == '.')) {

	cmp	al, 91					; 0000005bH
	je	SHORT $LN50@xmlFAParse
	cmp	al, 92					; 0000005cH
	je	SHORT $LN44@xmlFAParse
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN51@xmlFAParse
$LN44@xmlFAParse:

; 5159 : 	xmlFAParseCharClassEsc(ctxt);

	push	esi
	call	_xmlFAParseCharClassEsc
	add	esp, 4

; 5306 : 	xmlFAParseCharClass(ctxt);
; 5307 : 	return(1);

	mov	eax, 1
	pop	edi

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlFAParse:

; 5148 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]

; 5149 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);

	push	3
	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 5150 : 	if (ctxt->atom == NULL)

	test	eax, eax
	je	SHORT $LN45@xmlFAParse

; 5151 : 	    return;
; 5152 : 	xmlFAParseCharGroup(ctxt);

	push	esi
	call	_xmlFAParseCharGroup

; 5153 : 	if (CUR == ']') {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN47@xmlFAParse

; 5154 : 	    NEXT;

	inc	eax
	pop	edi
	mov	DWORD PTR [esi+4], eax

; 5306 : 	xmlFAParseCharClass(ctxt);
; 5307 : 	return(1);

	mov	eax, 1

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlFAParse:

; 5156 : 	    ERROR("xmlFAParseCharClass: ']' expected");

	push	OFFSET ??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN45@xmlFAParse:
	pop	edi

; 5308 :     }
; 5309 :     return(0);
; 5310 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlFAParse:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAParseAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseQuantifier
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseQuantifier PROC				; COMDAT

; 5198 : xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx]
	cmp	al, 63					; 0000003fH
	je	$LN3@xmlFAParse

; 5199 :     int cur;
; 5200 : 
; 5201 :     cur = CUR;
; 5202 :     if ((cur == '?') || (cur == '*') || (cur == '+')) {

	cmp	al, 42					; 0000002aH
	je	$LN3@xmlFAParse
	cmp	al, 43					; 0000002bH
	je	$LN3@xmlFAParse

; 5212 : 	return(1);
; 5213 :     }
; 5214 :     if (cur == '{') {

	cmp	al, 123					; 0000007bH
	jne	$LN10@xmlFAParse

; 5215 : 	int min = 0, max = 0;

	push	ebx
	push	edi

; 5216 : 
; 5217 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	xor	edi, edi

; 5218 : 	cur = xmlFAParseQuantExact(ctxt);

	push	esi
	xor	ebx, ebx
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAParseQuantExact
	add	esp, 4

; 5219 : 	if (cur >= 0)

	test	eax, eax
	cmovns	edi, eax

; 5220 : 	    min = cur;
; 5221 : 	if (CUR == ',') {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 44			; 0000002cH
	jne	SHORT $LN16@xmlFAParse

; 5222 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5223 : 	    if (CUR == '}')

	cmp	BYTE PTR [eax], 125			; 0000007dH
	jne	SHORT $LN13@xmlFAParse

; 5224 : 	        max = INT_MAX;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN16@xmlFAParse
$LN13@xmlFAParse:

; 5225 : 	    else {
; 5226 : 	        cur = xmlFAParseQuantExact(ctxt);

	push	esi
	call	_xmlFAParseQuantExact
	add	esp, 4

; 5227 : 	        if (cur >= 0)

	test	eax, eax
	js	SHORT $LN15@xmlFAParse

; 5228 : 		    max = cur;

	mov	ebx, eax
	jmp	SHORT $LN16@xmlFAParse
$LN15@xmlFAParse:

; 5229 : 		else {
; 5230 : 		    ERROR("Improper quantifier");

	push	OFFSET ??_C@_0BE@PGBJEMPN@Improper?5quantifier@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN16@xmlFAParse:

; 5231 : 		}
; 5232 : 	    }
; 5233 : 	}
; 5234 : 	if (CUR == '}') {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 125			; 0000007dH
	jne	SHORT $LN17@xmlFAParse

; 5235 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5236 : 	} else {

	jmp	SHORT $LN18@xmlFAParse
$LN17@xmlFAParse:

; 5237 : 	    ERROR("Unterminated quantifier");

	push	OFFSET ??_C@_0BI@HKPFPPFN@Unterminated?5quantifier@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN18@xmlFAParse:

; 5238 : 	}
; 5239 : 	if (max == 0)
; 5240 : 	    max = min;
; 5241 : 	if (ctxt->atom != NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN20@xmlFAParse

; 5242 : 	    ctxt->atom->quant = XML_REGEXP_QUANT_RANGE;

	mov	DWORD PTR [eax+8], 8
	test	ebx, ebx

; 5243 : 	    ctxt->atom->min = min;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+12], edi
	cmovne	edi, ebx

; 5244 : 	    ctxt->atom->max = max;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+16], edi
$LN20@xmlFAParse:

; 5245 : 	}
; 5246 : 	return(1);

	pop	edi
	pop	ebx

; 5249 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlFAParse:

; 5247 :     }
; 5248 :     return(0);

	xor	eax, eax
	pop	esi

; 5249 : }

	pop	ebp
	ret	0
$LN3@xmlFAParse:

; 5203 : 	if (ctxt->atom != NULL) {

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN9@xmlFAParse

; 5204 : 	    if (cur == '?')

	cmp	al, 63					; 0000003fH
	jne	SHORT $LN5@xmlFAParse

; 5205 : 		ctxt->atom->quant = XML_REGEXP_QUANT_OPT;

	mov	DWORD PTR [ecx+8], 3

; 5249 : }

	mov	eax, 1
	inc	DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlFAParse:

; 5206 : 	    else if (cur == '*')

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN7@xmlFAParse

; 5207 : 		ctxt->atom->quant = XML_REGEXP_QUANT_MULT;

	mov	DWORD PTR [ecx+8], 4

; 5249 : }

	mov	eax, 1
	inc	DWORD PTR [esi+4]
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlFAParse:

; 5208 : 	    else if (cur == '+')

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN9@xmlFAParse

; 5209 : 		ctxt->atom->quant = XML_REGEXP_QUANT_PLUS;

	mov	DWORD PTR [ecx+8], 5
$LN9@xmlFAParse:

; 5210 : 	}
; 5211 : 	NEXT;

	inc	DWORD PTR [esi+4]

; 5249 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
_xmlFAParseQuantifier ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseQuantExact
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseQuantExact PROC				; COMDAT

; 5172 : xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	xor	esi, esi
	mov	edx, DWORD PTR [edi+4]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jb	SHORT $LN10@xmlFAParse
	npad	1
$LL2@xmlFAParse:

; 5173 :     int ret = 0;
; 5174 :     int ok = 0;
; 5175 : 
; 5176 :     while ((CUR >= '0') && (CUR <= '9')) {

	cmp	al, 57					; 00000039H
	ja	SHORT $LN3@xmlFAParse

; 5177 : 	ret = ret * 10 + (CUR - '0');

	movzx	eax, al
	lea	ecx, DWORD PTR [ecx+ecx*4]

; 5178 : 	ok = 1;
; 5179 : 	NEXT;

	inc	edx
	lea	ecx, DWORD PTR [ecx-24]
	mov	DWORD PTR [edi+4], edx
	mov	esi, 1
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jae	SHORT $LL2@xmlFAParse

; 5183 :     }
; 5184 :     return(ret);

	pop	edi
	mov	eax, ecx

; 5185 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlFAParse:

; 5180 :     }
; 5181 :     if (ok != 1) {

	cmp	esi, 1
	jne	SHORT $LN10@xmlFAParse

; 5183 :     }
; 5184 :     return(ret);

	pop	edi
	mov	eax, ecx

; 5185 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlFAParse:
	pop	edi

; 5182 : 	return(-1);

	or	eax, -1

; 5185 : }

	pop	esi
	pop	ebp
	ret	0
_xmlFAParseQuantExact ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharClass
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseCharClass PROC				; COMDAT

; 5146 : xmlFAParseCharClass(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 91			; 0000005bH
	jne	SHORT $LN2@xmlFAParse

; 5147 :     if (CUR == '[') {
; 5148 : 	NEXT;
; 5149 : 	ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_RANGES);

	inc	eax
	push	3
	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 5150 : 	if (ctxt->atom == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlFAParse

; 5151 : 	    return;
; 5152 : 	xmlFAParseCharGroup(ctxt);

	push	esi
	call	_xmlFAParseCharGroup

; 5153 : 	if (CUR == ']') {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN5@xmlFAParse

; 5154 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 5160 :     }
; 5161 : }

	pop	ebp
	ret	0
$LN5@xmlFAParse:

; 5155 : 	} else {
; 5156 : 	    ERROR("xmlFAParseCharClass: ']' expected");

	push	OFFSET ??_C@_0CC@FKLKCEIP@xmlFAParseCharClass?3?5?8?$FN?8?5expect@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi

; 5160 :     }
; 5161 : }

	pop	ebp
	ret	0
$LN2@xmlFAParse:

; 5157 : 	}
; 5158 :     } else {
; 5159 : 	xmlFAParseCharClassEsc(ctxt);

	push	esi
	call	_xmlFAParseCharClassEsc
	add	esp, 4
$LN3@xmlFAParse:
	pop	esi

; 5160 :     }
; 5161 : }

	pop	ebp
	ret	0
_xmlFAParseCharClass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharGroup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseCharGroup PROC				; COMDAT

; 5107 : xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	je	$LN18@xmlFAParse
	push	edi
$LL2@xmlFAParse:

; 5108 :     int n = ctxt->neg;
; 5109 :     while ((CUR != ']') && (ctxt->error == 0)) {

	cmp	DWORD PTR [esi+8], 0
	jne	$LN19@xmlFAParse

; 5110 : 	if (CUR == '^') {

	mov	cl, BYTE PTR [eax]
	cmp	cl, 94					; 0000005eH
	jne	SHORT $LN4@xmlFAParse

; 5111 : 	    int neg = ctxt->neg;

	mov	edi, DWORD PTR [esi+12]

; 5112 : 
; 5113 : 	    NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5114 : 	    ctxt->neg = !ctxt->neg;

	xor	eax, eax
	test	edi, edi

; 5115 : 	    xmlFAParsePosCharGroup(ctxt);

	push	esi
	sete	al
	mov	DWORD PTR [esi+12], eax
	call	_xmlFAParsePosCharGroup

; 5116 : 	    ctxt->neg = neg;

	mov	DWORD PTR [esi+12], edi
	jmp	SHORT $LN21@xmlFAParse
$LN4@xmlFAParse:

; 5117 : 	} else if ((CUR == '-') && (NXT(1) == '[')) {

	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN6@xmlFAParse
	cmp	BYTE PTR [eax+1], 91			; 0000005bH
	je	SHORT $LN13@xmlFAParse
$LN6@xmlFAParse:

; 5127 : 		break;
; 5128 : 	    }
; 5129 : 	    ctxt->neg = neg;
; 5130 : 	    break;
; 5131 : 	} else if (CUR != ']') {

	cmp	cl, 93					; 0000005dH
	je	SHORT $LN10@xmlFAParse

; 5132 : 	    xmlFAParsePosCharGroup(ctxt);

	push	esi
	call	_xmlFAParsePosCharGroup
$LN21@xmlFAParse:

; 5108 :     int n = ctxt->neg;
; 5109 :     while ((CUR != ']') && (ctxt->error == 0)) {

	add	esp, 4
$LN10@xmlFAParse:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LL2@xmlFAParse

; 5133 : 	}
; 5134 :     }
; 5135 :     ctxt->neg = n;
; 5136 : }

	pop	edi
	mov	DWORD PTR [esi+12], ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlFAParse:

; 5118 : 	    int neg = ctxt->neg;
; 5119 : 	    ctxt->neg = 2;
; 5120 : 	    NEXT;	/* eat the '-' */
; 5121 : 	    NEXT;	/* eat the '[' */

	add	eax, 2
	mov	DWORD PTR [esi+12], 2

; 5122 : 	    xmlFAParseCharGroup(ctxt);

	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAParseCharGroup

; 5123 : 	    if (CUR == ']') {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN8@xmlFAParse

; 5124 : 		NEXT;

	inc	eax

; 5133 : 	}
; 5134 :     }
; 5135 :     ctxt->neg = n;
; 5136 : }

	mov	DWORD PTR [esi+12], ebx
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlFAParse:

; 5125 : 	    } else {
; 5126 : 		ERROR("charClassExpr: ']' expected");

	push	OFFSET ??_C@_0BM@FJAEMPFO@charClassExpr?3?5?8?$FN?8?5expected@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN19@xmlFAParse:
	pop	edi
$LN18@xmlFAParse:

; 5133 : 	}
; 5134 :     }
; 5135 :     ctxt->neg = n;
; 5136 : }

	mov	DWORD PTR [esi+12], ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlFAParseCharGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParsePosCharGroup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParsePosCharGroup PROC				; COMDAT

; 5086 : xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax]
$LL4@xmlFAParse:

; 5087 :     do {
; 5088 : 	if (CUR == '\\') {

	push	esi
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN5@xmlFAParse

; 5089 : 	    xmlFAParseCharClassEsc(ctxt);

	call	_xmlFAParseCharClassEsc

; 5090 : 	} else {

	jmp	SHORT $LN12@xmlFAParse
$LN5@xmlFAParse:

; 5091 : 	    xmlFAParseCharRange(ctxt);

	call	_xmlFAParseCharRange
$LN12@xmlFAParse:

; 5092 : 	}
; 5093 :     } while ((CUR != ']') && (CUR != '^') && (CUR != '-') &&
; 5094 :              (CUR != 0) && (ctxt->error == 0));

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	mov	al, BYTE PTR [eax]
	cmp	al, 93					; 0000005dH
	je	SHORT $LN7@xmlFAParse
	cmp	al, 94					; 0000005eH
	je	SHORT $LN7@xmlFAParse
	cmp	al, 45					; 0000002dH
	je	SHORT $LN7@xmlFAParse
	test	al, al
	je	SHORT $LN7@xmlFAParse
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LL4@xmlFAParse
$LN7@xmlFAParse:
	pop	esi

; 5095 : }

	pop	ebp
	ret	0
_xmlFAParsePosCharGroup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharRange
_TEXT	SEGMENT
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAParseCharRange PROC				; COMDAT

; 4994 : xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LN6@xmlFAParse

; 4995 :     int cur, len;
; 4996 :     int start = -1;
; 4997 :     int end = -1;
; 4998 : 
; 4999 :     if (CUR == '\0') {
; 5000 :         ERROR("Expecting ']'");

	push	OFFSET ??_C@_0O@NKKGCCKG@Expecting?5?8?$FN?8@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi

; 5074 : 		           XML_REGEXP_CHARVAL, start, end, NULL);
; 5075 :     }
; 5076 :     return;
; 5077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlFAParse:
	push	edi

; 5001 : 	return;
; 5002 :     }
; 5003 : 
; 5004 :     cur = CUR;
; 5005 :     if (cur == '\\') {

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN7@xmlFAParse

; 5006 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 5007 : 	cur = CUR;

	movzx	edi, BYTE PTR [eax]

; 5008 : 	switch (cur) {

	lea	eax, DWORD PTR [edi-40]
	cmp	eax, 85					; 00000055H
	ja	$LN25@xmlFAParse
	movzx	eax, BYTE PTR $LN31@xmlFAParse[eax]
	jmp	DWORD PTR $LN37@xmlFAParse[eax*4]
$LN9@xmlFAParse:

; 5012 : 	    case '\\': case '|': case '.': case '-': case '^': case '?':
; 5013 : 	    case '*': case '+': case '{': case '}': case '(': case ')':
; 5014 : 	    case '[': case ']':
; 5015 : 		start = cur; break;
; 5016 : 	    default:
; 5017 : 		ERROR("Invalid escape value");
; 5018 : 		return;
; 5019 : 	}
; 5020 : 	end = start;
; 5021 :         len = 1;

	mov	eax, 1
	mov	edi, 10					; 0000000aH
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN15@xmlFAParse
$LN10@xmlFAParse:
	mov	eax, 1
	mov	edi, 13					; 0000000dH
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN15@xmlFAParse
$LN11@xmlFAParse:

; 5009 : 	    case 'n': start = 0xA; break;
; 5010 : 	    case 'r': start = 0xD; break;
; 5011 : 	    case 't': start = 0x9; break;

	mov	edi, 9
$LN12@xmlFAParse:

; 5012 : 	    case '\\': case '|': case '.': case '-': case '^': case '?':
; 5013 : 	    case '*': case '+': case '{': case '}': case '(': case ')':
; 5014 : 	    case '[': case ']':
; 5015 : 		start = cur; break;
; 5016 : 	    default:
; 5017 : 		ERROR("Invalid escape value");
; 5018 : 		return;
; 5019 : 	}
; 5020 : 	end = start;
; 5021 :         len = 1;

	mov	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN15@xmlFAParse
$LN7@xmlFAParse:

; 5022 :     } else if ((cur != 0x5B) && (cur != 0x5D)) {

	cmp	al, 91					; 0000005bH
	je	$LN14@xmlFAParse
	cmp	al, 93					; 0000005dH
	je	$LN14@xmlFAParse

; 5023 :         end = start = CUR_SCHAR(ctxt->cur, len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	ecx
	push	0
	call	_xmlStringCurrentChar
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _len$[ebp]
$LN15@xmlFAParse:

; 5026 : 	return;
; 5027 :     }
; 5028 :     /*
; 5029 :      * Since we are "inside" a range, we can assume ctxt->cur is past
; 5030 :      * the start of ctxt->string, and PREV should be safe
; 5031 :      */
; 5032 :     if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {

	cmp	edi, 45					; 0000002dH
	jne	SHORT $LN16@xmlFAParse
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+1], 93			; 0000005dH
	je	SHORT $LN16@xmlFAParse
	mov	dl, BYTE PTR [ecx-1]
	cmp	dl, 91					; 0000005bH
	je	SHORT $LN16@xmlFAParse
	cmp	dl, 94					; 0000005eH
	je	SHORT $LN16@xmlFAParse

; 5033 : 	NEXTL(len);

	add	eax, ecx
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 5074 : 		           XML_REGEXP_CHARVAL, start, end, NULL);
; 5075 :     }
; 5076 :     return;
; 5077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlFAParse:

; 5034 : 	return;
; 5035 :     }
; 5036 :     NEXTL(len);

	add	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [esi+4]

; 5037 :     cur = CUR;
; 5038 :     if ((cur != '-') || (NXT(1) == ']')) {

	cmp	BYTE PTR [ecx], 45			; 0000002dH
	jne	$LN18@xmlFAParse
	inc	ecx
	cmp	BYTE PTR [ecx], 93			; 0000005dH
	je	$LN18@xmlFAParse

; 5040 : 		              XML_REGEXP_CHARVAL, start, end, NULL);
; 5041 : 	return;
; 5042 :     }
; 5043 :     NEXT;

	mov	DWORD PTR [esi+4], ecx

; 5044 :     cur = CUR;

	mov	al, BYTE PTR [ecx]

; 5045 :     if (cur == '\\') {

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN19@xmlFAParse

; 5046 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 5047 : 	cur = CUR;

	movzx	ecx, BYTE PTR [eax]

; 5048 : 	switch (cur) {

	lea	eax, DWORD PTR [ecx-40]
	cmp	eax, 85					; 00000055H
	ja	SHORT $LN25@xmlFAParse
	movzx	eax, BYTE PTR $LN32@xmlFAParse[eax]
	jmp	DWORD PTR $LN38@xmlFAParse[eax*4]
$LN21@xmlFAParse:

; 5059 : 	}
; 5060 :         len = 1;

	mov	eax, 1
	mov	ecx, 10					; 0000000aH
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN27@xmlFAParse
$LN22@xmlFAParse:
	mov	eax, 1
	mov	ecx, 13					; 0000000dH
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN27@xmlFAParse
$LN23@xmlFAParse:

; 5049 : 	    case 'n': end = 0xA; break;
; 5050 : 	    case 'r': end = 0xD; break;
; 5051 : 	    case 't': end = 0x9; break;

	mov	ecx, 9
$LN24@xmlFAParse:

; 5059 : 	}
; 5060 :         len = 1;

	mov	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN27@xmlFAParse
$LN25@xmlFAParse:

; 5052 : 	    case '\\': case '|': case '.': case '-': case '^': case '?':
; 5053 : 	    case '*': case '+': case '{': case '}': case '(': case ')':
; 5054 : 	    case '[': case ']':
; 5055 : 		end = cur; break;
; 5056 : 	    default:
; 5057 : 		ERROR("Invalid escape value");

	push	OFFSET ??_C@_0BF@HOMDEKLG@Invalid?5escape?5value@

; 5058 : 		return;

	jmp	SHORT $LN34@xmlFAParse
$LN19@xmlFAParse:

; 5061 :     } else if ((cur != '\0') && (cur != 0x5B) && (cur != 0x5D)) {

	test	al, al
	je	SHORT $LN26@xmlFAParse
	cmp	al, 91					; 0000005bH
	je	SHORT $LN26@xmlFAParse
	cmp	al, 93					; 0000005dH
	je	SHORT $LN26@xmlFAParse

; 5062 :         end = CUR_SCHAR(ctxt->cur, len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	ecx
	push	0
	call	_xmlStringCurrentChar
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _len$[ebp]
$LN27@xmlFAParse:

; 5066 :     }
; 5067 : 
; 5068 :     /* TODO check that the values are acceptable character ranges for XML */
; 5069 :     if (end < start) {

	cmp	ecx, edi
	jge	SHORT $LN28@xmlFAParse

; 5070 : 	ERROR("End of range is before start of range");

	push	OFFSET ??_C@_0CG@BKADGONK@End?5of?5range?5is?5before?5start?5of@

; 5071 :     } else {

	jmp	SHORT $LN34@xmlFAParse
$LN28@xmlFAParse:

; 5072 :         NEXTL(len);

	add	DWORD PTR [esi+4], eax

; 5073 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	ecx
	jmp	SHORT $LN35@xmlFAParse
$LN26@xmlFAParse:

; 5063 :     } else {
; 5064 : 	ERROR("Expecting the end of a char range");

	push	OFFSET ??_C@_0CC@JHFKDBIP@Expecting?5the?5end?5of?5a?5char?5ran@

; 5065 : 	return;

	jmp	SHORT $LN34@xmlFAParse
$LN18@xmlFAParse:

; 5039 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	edi
$LN35@xmlFAParse:
	push	edi
	push	2
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+28]
	push	esi
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 5074 : 		           XML_REGEXP_CHARVAL, start, end, NULL);
; 5075 :     }
; 5076 :     return;
; 5077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlFAParse:

; 5024 :     } else {
; 5025 : 	ERROR("Expecting a char range");

	push	OFFSET ??_C@_0BH@LOJMKNAD@Expecting?5a?5char?5range@
$LN34@xmlFAParse:
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi
	pop	esi

; 5074 : 		           XML_REGEXP_CHARVAL, start, end, NULL);
; 5075 :     }
; 5076 :     return;
; 5077 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN37@xmlFAParse:
	DD	$LN12@xmlFAParse
	DD	$LN9@xmlFAParse
	DD	$LN10@xmlFAParse
	DD	$LN11@xmlFAParse
	DD	$LN25@xmlFAParse
$LN31@xmlFAParse:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	npad	2
$LN38@xmlFAParse:
	DD	$LN24@xmlFAParse
	DD	$LN21@xmlFAParse
	DD	$LN22@xmlFAParse
	DD	$LN23@xmlFAParse
	DD	$LN25@xmlFAParse
$LN32@xmlFAParse:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
_xmlFAParseCharRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharClassEsc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseCharClassEsc PROC				; COMDAT

; 4849 : xmlFAParseCharClassEsc(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx]
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN8@xmlFAParse

; 4850 :     int cur;
; 4851 : 
; 4852 :     if (CUR == '.') {
; 4853 : 	if (ctxt->atom == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN9@xmlFAParse

; 4854 : 	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_ANYCHAR);

	push	6
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 4857 : 			       XML_REGEXP_ANYCHAR, 0, 0, NULL);
; 4858 : 	}
; 4859 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN9@xmlFAParse:

; 4855 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN11@xmlFAParse

; 4856 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	0
	push	0
	push	6
	push	DWORD PTR [esi+12]
	push	eax
	push	esi
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN11@xmlFAParse:

; 4857 : 			       XML_REGEXP_ANYCHAR, 0, 0, NULL);
; 4858 : 	}
; 4859 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN8@xmlFAParse:

; 4860 : 	return;
; 4861 :     }
; 4862 :     if (CUR != '\\') {

	cmp	al, 92					; 0000005cH
	je	SHORT $LN12@xmlFAParse

; 4863 : 	ERROR("Escaped sequence: expecting \\");

	push	OFFSET ??_C@_0BO@BOFONOMH@Escaped?5sequence?3?5expecting?5?2@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN12@xmlFAParse:

; 4864 : 	return;
; 4865 :     }
; 4866 :     NEXT;

	lea	edx, DWORD PTR [ecx+1]
	push	edi
	mov	DWORD PTR [esi+4], edx

; 4867 :     cur = CUR;

	movzx	edi, BYTE PTR [edx]

; 4868 :     if (cur == 'p') {

	cmp	edi, 112				; 00000070H
	jne	SHORT $LN13@xmlFAParse

; 4869 : 	NEXT;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+4], eax

; 4870 : 	if (CUR != '{') {

	cmp	BYTE PTR [eax], 123			; 0000007bH
	jne	SHORT $LN54@xmlFAParse

; 4871 : 	    ERROR("Expecting '{'");
; 4872 : 	    return;
; 4873 : 	}
; 4874 : 	NEXT;

	inc	eax

; 4875 : 	xmlFAParseCharProp(ctxt);

	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAParseCharProp

; 4876 : 	if (CUR != '}') {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	cmp	BYTE PTR [eax], 125			; 0000007dH
	jne	SHORT $LN53@xmlFAParse
$LN21@xmlFAParse:

; 4877 : 	    ERROR("Expecting '}'");
; 4878 : 	    return;
; 4879 : 	}
; 4880 : 	NEXT;

	inc	eax
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN13@xmlFAParse:

; 4881 :     } else if (cur == 'P') {

	cmp	edi, 80					; 00000050H
	jne	SHORT $LN17@xmlFAParse

; 4882 : 	NEXT;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+4], eax

; 4883 : 	if (CUR != '{') {

	cmp	BYTE PTR [eax], 123			; 0000007bH
	je	SHORT $LN19@xmlFAParse
$LN54@xmlFAParse:

; 4884 : 	    ERROR("Expecting '{'");

	push	OFFSET ??_C@_0O@OGGGBIPE@Expecting?5?8?$HL?8@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN19@xmlFAParse:

; 4885 : 	    return;
; 4886 : 	}
; 4887 : 	NEXT;

	inc	eax

; 4888 : 	xmlFAParseCharProp(ctxt);

	push	esi
	mov	DWORD PTR [esi+4], eax
	call	_xmlFAParseCharProp

; 4889 :         if (ctxt->atom != NULL)

	mov	eax, DWORD PTR [esi+28]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@xmlFAParse

; 4890 : 	    ctxt->atom->neg = 1;

	mov	DWORD PTR [eax+28], 1
$LN20@xmlFAParse:

; 4891 : 	if (CUR != '}') {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 125			; 0000007dH
	je	SHORT $LN21@xmlFAParse
$LN53@xmlFAParse:

; 4892 : 	    ERROR("Expecting '}'");

	push	OFFSET ??_C@_0O@OCOLGEEG@Expecting?5?8?$HN?8@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN17@xmlFAParse:

; 4893 : 	    return;
; 4894 : 	}
; 4895 : 	NEXT;
; 4896 :     } else if ((cur == 'n') || (cur == 'r') || (cur == 't') || (cur == '\\') ||
; 4897 : 	(cur == '|') || (cur == '.') || (cur == '?') || (cur == '*') ||
; 4898 : 	(cur == '+') || (cur == '(') || (cur == ')') || (cur == '{') ||
; 4899 : 	(cur == '}') || (cur == 0x2D) || (cur == 0x5B) || (cur == 0x5D) ||

	cmp	edi, 110				; 0000006eH
	je	$LN24@xmlFAParse
	cmp	edi, 114				; 00000072H
	je	$LN24@xmlFAParse
	cmp	edi, 116				; 00000074H
	je	$LN24@xmlFAParse
	cmp	edi, 92					; 0000005cH
	je	$LN24@xmlFAParse
	cmp	edi, 124				; 0000007cH
	je	$LN24@xmlFAParse
	cmp	edi, 46					; 0000002eH
	je	$LN24@xmlFAParse
	cmp	edi, 63					; 0000003fH
	je	$LN24@xmlFAParse
	cmp	edi, 42					; 0000002aH
	je	$LN24@xmlFAParse
	cmp	edi, 43					; 0000002bH
	je	$LN24@xmlFAParse
	cmp	edi, 40					; 00000028H
	je	$LN24@xmlFAParse
	cmp	edi, 41					; 00000029H
	je	$LN24@xmlFAParse
	cmp	edi, 123				; 0000007bH
	je	$LN24@xmlFAParse
	cmp	edi, 125				; 0000007dH
	je	$LN24@xmlFAParse
	cmp	edi, 45					; 0000002dH
	je	$LN24@xmlFAParse
	cmp	edi, 91					; 0000005bH
	je	$LN24@xmlFAParse
	cmp	edi, 93					; 0000005dH
	je	$LN24@xmlFAParse
	cmp	edi, 94					; 0000005eH
	je	$LN24@xmlFAParse

; 4934 :     } else if ((cur == 's') || (cur == 'S') || (cur == 'i') || (cur == 'I') ||
; 4935 : 	(cur == 'c') || (cur == 'C') || (cur == 'd') || (cur == 'D') ||
; 4936 : 	(cur == 'w') || (cur == 'W')) {

	cmp	edi, 115				; 00000073H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 83					; 00000053H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 105				; 00000069H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 73					; 00000049H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 99					; 00000063H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 67					; 00000043H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 100				; 00000064H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 68					; 00000044H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 119				; 00000077H
	je	SHORT $LN38@xmlFAParse
	cmp	edi, 87					; 00000057H
	je	SHORT $LN38@xmlFAParse

; 4976 : 			       type, 0, 0, NULL);
; 4977 : 	}
; 4978 :     } else {
; 4979 : 	ERROR("Wrong escape sequence, misuse of character '\\'");

	push	OFFSET ??_C@_0CP@BDPLJNDH@Wrong?5escape?5sequence?0?5misuse?5o@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN38@xmlFAParse:

; 4937 : 	xmlRegAtomType type = XML_REGEXP_ANYSPACE;
; 4938 : 
; 4939 : 	switch (cur) {

	add	edi, -67				; ffffffbdH
	mov	ecx, 7
	cmp	edi, 52					; 00000034H
	ja	SHORT $LN6@xmlFAParse
	movzx	eax, BYTE PTR $LN55@xmlFAParse[edi]
	jmp	DWORD PTR $LN58@xmlFAParse[eax*4]
$LN40@xmlFAParse:

; 4940 : 	    case 's':
; 4941 : 		type = XML_REGEXP_ANYSPACE;
; 4942 : 		break;
; 4943 : 	    case 'S':
; 4944 : 		type = XML_REGEXP_NOTSPACE;

	mov	ecx, 8

; 4945 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN41@xmlFAParse:

; 4946 : 	    case 'i':
; 4947 : 		type = XML_REGEXP_INITNAME;

	mov	ecx, 9

; 4948 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN42@xmlFAParse:

; 4949 : 	    case 'I':
; 4950 : 		type = XML_REGEXP_NOTINITNAME;

	mov	ecx, 10					; 0000000aH

; 4951 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN43@xmlFAParse:

; 4952 : 	    case 'c':
; 4953 : 		type = XML_REGEXP_NAMECHAR;

	mov	ecx, 11					; 0000000bH

; 4954 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN44@xmlFAParse:

; 4955 : 	    case 'C':
; 4956 : 		type = XML_REGEXP_NOTNAMECHAR;

	mov	ecx, 12					; 0000000cH

; 4957 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN45@xmlFAParse:

; 4958 : 	    case 'd':
; 4959 : 		type = XML_REGEXP_DECIMAL;

	mov	ecx, 13					; 0000000dH

; 4960 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN46@xmlFAParse:

; 4961 : 	    case 'D':
; 4962 : 		type = XML_REGEXP_NOTDECIMAL;

	mov	ecx, 14					; 0000000eH

; 4963 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN47@xmlFAParse:

; 4964 : 	    case 'w':
; 4965 : 		type = XML_REGEXP_REALCHAR;

	mov	ecx, 15					; 0000000fH

; 4966 : 		break;

	jmp	SHORT $LN6@xmlFAParse
$LN48@xmlFAParse:

; 4967 : 	    case 'W':
; 4968 : 		type = XML_REGEXP_NOTREALCHAR;

	mov	ecx, 16					; 00000010H
$LN6@xmlFAParse:

; 4969 : 		break;
; 4970 : 	}
; 4971 : 	NEXT;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+4], eax

; 4972 : 	if (ctxt->atom == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN49@xmlFAParse

; 4973 : 	    ctxt->atom = xmlRegNewAtom(ctxt, type);

	push	ecx
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN49@xmlFAParse:

; 4974 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	cmp	DWORD PTR [eax+4], 3
	jne	$LN56@xmlFAParse

; 4975 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	0
	push	0
	push	ecx
	push	DWORD PTR [esi+12]
	push	eax
	push	esi
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN24@xmlFAParse:

; 4900 : 	(cur == 0x5E)) {
; 4901 : 	if (ctxt->atom == NULL) {

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN25@xmlFAParse

; 4902 : 	    ctxt->atom = xmlRegNewAtom(ctxt, XML_REGEXP_CHARVAL);

	push	2
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 4903 : 	    if (ctxt->atom != NULL) {

	test	eax, eax
	je	$LN32@xmlFAParse

; 4904 : 	        switch (cur) {

	mov	ecx, edi
	sub	ecx, 110				; 0000006eH
	je	SHORT $LN28@xmlFAParse
	sub	ecx, 4
	je	SHORT $LN29@xmlFAParse
	sub	ecx, 2
	je	SHORT $LN30@xmlFAParse

; 4913 : 			break;
; 4914 : 		    default:
; 4915 : 			ctxt->atom->codepoint = cur;

	mov	DWORD PTR [eax+32], edi

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN30@xmlFAParse:

; 4910 : 			break;
; 4911 : 		    case 't':
; 4912 : 		        ctxt->atom->codepoint = '\t';

	mov	DWORD PTR [eax+32], 9

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN29@xmlFAParse:

; 4907 : 			break;
; 4908 : 		    case 'r':
; 4909 : 		        ctxt->atom->codepoint = '\r';

	mov	DWORD PTR [eax+32], 13			; 0000000dH

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN28@xmlFAParse:

; 4905 : 		    case 'n':
; 4906 : 		        ctxt->atom->codepoint = '\n';

	mov	DWORD PTR [eax+32], 10			; 0000000aH

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	inc	DWORD PTR [esi+4]
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
$LN25@xmlFAParse:

; 4916 : 		}
; 4917 : 	    }
; 4918 : 	} else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN32@xmlFAParse

; 4919 :             switch (cur) {

	mov	eax, edi
	sub	eax, 110				; 0000006eH
	je	SHORT $LN33@xmlFAParse
	sub	eax, 4
	je	SHORT $LN34@xmlFAParse
	sub	eax, 2
	jne	SHORT $LN4@xmlFAParse

; 4926 :                 case 't':
; 4927 :                     cur = '\t';

	lea	edi, DWORD PTR [eax+9]
	jmp	SHORT $LN4@xmlFAParse
$LN34@xmlFAParse:

; 4922 :                     break;
; 4923 :                 case 'r':
; 4924 :                     cur = '\r';

	mov	edi, 13					; 0000000dH

; 4925 :                     break;

	jmp	SHORT $LN4@xmlFAParse
$LN33@xmlFAParse:

; 4920 :                 case 'n':
; 4921 :                     cur = '\n';

	mov	edi, 10					; 0000000aH
$LN4@xmlFAParse:

; 4928 :                     break;
; 4929 :             }
; 4930 : 	    xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	0
	push	edi
	push	edi
	push	2
	push	DWORD PTR [esi+12]
	push	ecx
	push	esi
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
$LN32@xmlFAParse:

; 4931 : 			       XML_REGEXP_CHARVAL, cur, cur, NULL);
; 4932 : 	}
; 4933 : 	NEXT;

	inc	DWORD PTR [esi+4]
$LN56@xmlFAParse:
	pop	edi
	pop	esi

; 4980 :     }
; 4981 : }

	pop	ebp
	ret	0
	npad	2
$LN58@xmlFAParse:
	DD	$LN44@xmlFAParse
	DD	$LN46@xmlFAParse
	DD	$LN42@xmlFAParse
	DD	$LN40@xmlFAParse
	DD	$LN48@xmlFAParse
	DD	$LN43@xmlFAParse
	DD	$LN45@xmlFAParse
	DD	$LN41@xmlFAParse
	DD	$LN6@xmlFAParse
	DD	$LN47@xmlFAParse
	DD	$LN6@xmlFAParse
$LN55@xmlFAParse:
	DB	0
	DB	1
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	6
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
_xmlFAParseCharClassEsc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseCharProp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFAParseCharProp PROC				; COMDAT

; 4632 : xmlFAParseCharProp(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx]
	cmp	al, 76					; 0000004cH
	jne	SHORT $LN4@xmlFAParse

; 4633 :     int cur;
; 4634 :     xmlRegAtomType type = (xmlRegAtomType) 0;
; 4635 :     xmlChar *blockName = NULL;
; 4636 : 
; 4637 :     cur = CUR;
; 4638 :     if (cur == 'L') {
; 4639 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4640 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4641 : 	if (cur == 'u') {

	cmp	cl, 117					; 00000075H
	jne	SHORT $LN6@xmlFAParse

; 4642 : 	    NEXT;

	inc	eax

; 4643 : 	    type = XML_REGEXP_LETTER_UPPERCASE;

	lea	edi, DWORD PTR [ebx+101]
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN6@xmlFAParse:

; 4644 : 	} else if (cur == 'l') {

	cmp	cl, 108					; 0000006cH
	jne	SHORT $LN8@xmlFAParse

; 4645 : 	    NEXT;

	inc	eax

; 4646 : 	    type = XML_REGEXP_LETTER_LOWERCASE;

	mov	edi, 102				; 00000066H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN8@xmlFAParse:

; 4647 : 	} else if (cur == 't') {

	cmp	cl, 116					; 00000074H
	jne	SHORT $LN10@xmlFAParse

; 4648 : 	    NEXT;

	inc	eax

; 4649 : 	    type = XML_REGEXP_LETTER_TITLECASE;

	mov	edi, 103				; 00000067H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN10@xmlFAParse:

; 4650 : 	} else if (cur == 'm') {

	cmp	cl, 109					; 0000006dH
	jne	SHORT $LN12@xmlFAParse

; 4651 : 	    NEXT;

	inc	eax

; 4652 : 	    type = XML_REGEXP_LETTER_MODIFIER;

	mov	edi, 104				; 00000068H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN12@xmlFAParse:

; 4653 : 	} else if (cur == 'o') {

	cmp	cl, 111					; 0000006fH
	jne	SHORT $LN14@xmlFAParse

; 4654 : 	    NEXT;

	inc	eax

; 4655 : 	    type = XML_REGEXP_LETTER_OTHERS;

	mov	edi, 105				; 00000069H
	mov	DWORD PTR [esi+4], eax

; 4656 : 	} else {

	jmp	$LN77@xmlFAParse
$LN14@xmlFAParse:

; 4657 : 	    type = XML_REGEXP_LETTER;

	mov	edi, 100				; 00000064H

; 4658 : 	}

	jmp	$LN77@xmlFAParse
$LN4@xmlFAParse:

; 4659 :     } else if (cur == 'M') {

	cmp	al, 77					; 0000004dH
	jne	SHORT $LN16@xmlFAParse

; 4660 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4661 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4662 : 	if (cur == 'n') {

	cmp	cl, 110					; 0000006eH
	jne	SHORT $LN18@xmlFAParse

; 4663 : 	    NEXT;

	inc	eax

; 4664 : 	    /* nonspacing */
; 4665 : 	    type = XML_REGEXP_MARK_NONSPACING;

	mov	edi, 107				; 0000006bH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN18@xmlFAParse:

; 4666 : 	} else if (cur == 'c') {

	cmp	cl, 99					; 00000063H
	jne	SHORT $LN20@xmlFAParse

; 4667 : 	    NEXT;

	inc	eax

; 4668 : 	    /* spacing combining */
; 4669 : 	    type = XML_REGEXP_MARK_SPACECOMBINING;

	mov	edi, 108				; 0000006cH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN20@xmlFAParse:

; 4670 : 	} else if (cur == 'e') {

	cmp	cl, 101					; 00000065H
	jne	SHORT $LN22@xmlFAParse

; 4671 : 	    NEXT;

	inc	eax

; 4672 : 	    /* enclosing */
; 4673 : 	    type = XML_REGEXP_MARK_ENCLOSING;

	mov	edi, 109				; 0000006dH
	mov	DWORD PTR [esi+4], eax

; 4674 : 	} else {

	jmp	$LN77@xmlFAParse
$LN22@xmlFAParse:

; 4675 : 	    /* all marks */
; 4676 : 	    type = XML_REGEXP_MARK;

	mov	edi, 106				; 0000006aH

; 4677 : 	}

	jmp	$LN77@xmlFAParse
$LN16@xmlFAParse:

; 4678 :     } else if (cur == 'N') {

	cmp	al, 78					; 0000004eH
	jne	SHORT $LN24@xmlFAParse

; 4679 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4680 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4681 : 	if (cur == 'd') {

	cmp	cl, 100					; 00000064H
	jne	SHORT $LN26@xmlFAParse

; 4682 : 	    NEXT;

	inc	eax

; 4683 : 	    /* digital */
; 4684 : 	    type = XML_REGEXP_NUMBER_DECIMAL;

	mov	edi, 111				; 0000006fH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN26@xmlFAParse:

; 4685 : 	} else if (cur == 'l') {

	cmp	cl, 108					; 0000006cH
	jne	SHORT $LN28@xmlFAParse

; 4686 : 	    NEXT;

	inc	eax

; 4687 : 	    /* letter */
; 4688 : 	    type = XML_REGEXP_NUMBER_LETTER;

	mov	edi, 112				; 00000070H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN28@xmlFAParse:

; 4689 : 	} else if (cur == 'o') {

	cmp	cl, 111					; 0000006fH
	jne	SHORT $LN30@xmlFAParse

; 4690 : 	    NEXT;

	inc	eax

; 4691 : 	    /* other */
; 4692 : 	    type = XML_REGEXP_NUMBER_OTHERS;

	mov	edi, 113				; 00000071H
	mov	DWORD PTR [esi+4], eax

; 4693 : 	} else {

	jmp	$LN77@xmlFAParse
$LN30@xmlFAParse:

; 4694 : 	    /* all numbers */
; 4695 : 	    type = XML_REGEXP_NUMBER;

	mov	edi, 110				; 0000006eH

; 4696 : 	}

	jmp	$LN77@xmlFAParse
$LN24@xmlFAParse:

; 4697 :     } else if (cur == 'P') {

	cmp	al, 80					; 00000050H
	jne	$LN32@xmlFAParse

; 4698 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4699 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4700 : 	if (cur == 'c') {

	cmp	cl, 99					; 00000063H
	jne	SHORT $LN34@xmlFAParse

; 4701 : 	    NEXT;

	inc	eax

; 4702 : 	    /* connector */
; 4703 : 	    type = XML_REGEXP_PUNCT_CONNECTOR;

	mov	edi, 115				; 00000073H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN34@xmlFAParse:

; 4704 : 	} else if (cur == 'd') {

	cmp	cl, 100					; 00000064H
	jne	SHORT $LN36@xmlFAParse

; 4705 : 	    NEXT;

	inc	eax

; 4706 : 	    /* dash */
; 4707 : 	    type = XML_REGEXP_PUNCT_DASH;

	mov	edi, 116				; 00000074H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN36@xmlFAParse:

; 4708 : 	} else if (cur == 's') {

	cmp	cl, 115					; 00000073H
	jne	SHORT $LN38@xmlFAParse

; 4709 : 	    NEXT;

	inc	eax

; 4710 : 	    /* open */
; 4711 : 	    type = XML_REGEXP_PUNCT_OPEN;

	mov	edi, 117				; 00000075H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN38@xmlFAParse:

; 4712 : 	} else if (cur == 'e') {

	cmp	cl, 101					; 00000065H
	jne	SHORT $LN40@xmlFAParse

; 4713 : 	    NEXT;

	inc	eax

; 4714 : 	    /* close */
; 4715 : 	    type = XML_REGEXP_PUNCT_CLOSE;

	mov	edi, 118				; 00000076H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN40@xmlFAParse:

; 4716 : 	} else if (cur == 'i') {

	cmp	cl, 105					; 00000069H
	jne	SHORT $LN42@xmlFAParse

; 4717 : 	    NEXT;

	inc	eax

; 4718 : 	    /* initial quote */
; 4719 : 	    type = XML_REGEXP_PUNCT_INITQUOTE;

	mov	edi, 119				; 00000077H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN42@xmlFAParse:

; 4720 : 	} else if (cur == 'f') {

	cmp	cl, 102					; 00000066H
	jne	SHORT $LN44@xmlFAParse

; 4721 : 	    NEXT;

	inc	eax

; 4722 : 	    /* final quote */
; 4723 : 	    type = XML_REGEXP_PUNCT_FINQUOTE;

	mov	edi, 120				; 00000078H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN44@xmlFAParse:

; 4724 : 	} else if (cur == 'o') {

	cmp	cl, 111					; 0000006fH
	jne	SHORT $LN46@xmlFAParse

; 4725 : 	    NEXT;

	inc	eax

; 4726 : 	    /* other */
; 4727 : 	    type = XML_REGEXP_PUNCT_OTHERS;

	mov	edi, 121				; 00000079H
	mov	DWORD PTR [esi+4], eax

; 4728 : 	} else {

	jmp	$LN77@xmlFAParse
$LN46@xmlFAParse:

; 4729 : 	    /* all punctuation */
; 4730 : 	    type = XML_REGEXP_PUNCT;

	mov	edi, 114				; 00000072H

; 4731 : 	}

	jmp	$LN77@xmlFAParse
$LN32@xmlFAParse:

; 4732 :     } else if (cur == 'Z') {

	cmp	al, 90					; 0000005aH
	jne	SHORT $LN48@xmlFAParse

; 4733 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4734 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4735 : 	if (cur == 's') {

	cmp	cl, 115					; 00000073H
	jne	SHORT $LN50@xmlFAParse

; 4736 : 	    NEXT;

	inc	eax

; 4737 : 	    /* space */
; 4738 : 	    type = XML_REGEXP_SEPAR_SPACE;

	mov	edi, 123				; 0000007bH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN50@xmlFAParse:

; 4739 : 	} else if (cur == 'l') {

	cmp	cl, 108					; 0000006cH
	jne	SHORT $LN52@xmlFAParse

; 4740 : 	    NEXT;

	inc	eax

; 4741 : 	    /* line */
; 4742 : 	    type = XML_REGEXP_SEPAR_LINE;

	mov	edi, 124				; 0000007cH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN52@xmlFAParse:

; 4743 : 	} else if (cur == 'p') {

	cmp	cl, 112					; 00000070H
	jne	SHORT $LN54@xmlFAParse

; 4744 : 	    NEXT;

	inc	eax

; 4745 : 	    /* paragraph */
; 4746 : 	    type = XML_REGEXP_SEPAR_PARA;

	mov	edi, 125				; 0000007dH
	mov	DWORD PTR [esi+4], eax

; 4747 : 	} else {

	jmp	$LN77@xmlFAParse
$LN54@xmlFAParse:

; 4748 : 	    /* all separators */
; 4749 : 	    type = XML_REGEXP_SEPAR;

	mov	edi, 122				; 0000007aH

; 4750 : 	}

	jmp	$LN77@xmlFAParse
$LN48@xmlFAParse:

; 4751 :     } else if (cur == 'S') {

	cmp	al, 83					; 00000053H
	jne	SHORT $LN56@xmlFAParse

; 4752 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4753 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4754 : 	if (cur == 'm') {

	cmp	cl, 109					; 0000006dH
	jne	SHORT $LN58@xmlFAParse

; 4755 : 	    NEXT;

	inc	eax

; 4756 : 	    type = XML_REGEXP_SYMBOL_MATH;

	mov	edi, 127				; 0000007fH
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN58@xmlFAParse:

; 4757 : 	    /* math */
; 4758 : 	} else if (cur == 'c') {

	cmp	cl, 99					; 00000063H
	jne	SHORT $LN60@xmlFAParse

; 4759 : 	    NEXT;

	inc	eax

; 4760 : 	    type = XML_REGEXP_SYMBOL_CURRENCY;

	mov	edi, 128				; 00000080H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN60@xmlFAParse:

; 4761 : 	    /* currency */
; 4762 : 	} else if (cur == 'k') {

	cmp	cl, 107					; 0000006bH
	jne	SHORT $LN62@xmlFAParse

; 4763 : 	    NEXT;

	inc	eax

; 4764 : 	    type = XML_REGEXP_SYMBOL_MODIFIER;

	mov	edi, 129				; 00000081H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN62@xmlFAParse:

; 4765 : 	    /* modifiers */
; 4766 : 	} else if (cur == 'o') {

	cmp	cl, 111					; 0000006fH
	jne	SHORT $LN64@xmlFAParse

; 4767 : 	    NEXT;

	inc	eax

; 4768 : 	    type = XML_REGEXP_SYMBOL_OTHERS;

	mov	edi, 130				; 00000082H
	mov	DWORD PTR [esi+4], eax

; 4769 : 	    /* other */
; 4770 : 	} else {

	jmp	$LN77@xmlFAParse
$LN64@xmlFAParse:

; 4771 : 	    /* all symbols */
; 4772 : 	    type = XML_REGEXP_SYMBOL;

	mov	edi, 126				; 0000007eH

; 4773 : 	}

	jmp	$LN77@xmlFAParse
$LN56@xmlFAParse:

; 4774 :     } else if (cur == 'C') {

	cmp	al, 67					; 00000043H
	jne	SHORT $LN66@xmlFAParse

; 4775 : 	NEXT;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], eax

; 4776 : 	cur = CUR;

	mov	cl, BYTE PTR [eax]

; 4777 : 	if (cur == 'c') {

	cmp	cl, 99					; 00000063H
	jne	SHORT $LN68@xmlFAParse

; 4778 : 	    NEXT;

	inc	eax

; 4779 : 	    /* control */
; 4780 : 	    type = XML_REGEXP_OTHER_CONTROL;

	mov	edi, 132				; 00000084H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN68@xmlFAParse:

; 4781 : 	} else if (cur == 'f') {

	cmp	cl, 102					; 00000066H
	jne	SHORT $LN70@xmlFAParse

; 4782 : 	    NEXT;

	inc	eax

; 4783 : 	    /* format */
; 4784 : 	    type = XML_REGEXP_OTHER_FORMAT;

	mov	edi, 133				; 00000085H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN70@xmlFAParse:

; 4785 : 	} else if (cur == 'o') {

	cmp	cl, 111					; 0000006fH
	jne	SHORT $LN72@xmlFAParse

; 4786 : 	    NEXT;

	inc	eax

; 4787 : 	    /* private use */
; 4788 : 	    type = XML_REGEXP_OTHER_PRIVATE;

	mov	edi, 134				; 00000086H
	mov	DWORD PTR [esi+4], eax
	jmp	$LN77@xmlFAParse
$LN72@xmlFAParse:

; 4789 : 	} else if (cur == 'n') {

	cmp	cl, 110					; 0000006eH
	jne	SHORT $LN74@xmlFAParse

; 4790 : 	    NEXT;

	inc	eax

; 4791 : 	    /* not assigned */
; 4792 : 	    type = XML_REGEXP_OTHER_NA;

	mov	edi, 135				; 00000087H
	mov	DWORD PTR [esi+4], eax

; 4793 : 	} else {

	jmp	$LN77@xmlFAParse
$LN74@xmlFAParse:

; 4794 : 	    /* all others */
; 4795 : 	    type = XML_REGEXP_OTHER;

	mov	edi, 131				; 00000083H

; 4796 : 	}

	jmp	$LN77@xmlFAParse
$LN66@xmlFAParse:

; 4797 :     } else if (cur == 'I') {

	cmp	al, 73					; 00000049H
	jne	$LN76@xmlFAParse

; 4798 : 	const xmlChar *start;
; 4799 : 	NEXT;

	inc	ecx
	mov	DWORD PTR [esi+4], ecx

; 4800 : 	cur = CUR;
; 4801 : 	if (cur != 's') {

	cmp	BYTE PTR [ecx], 115			; 00000073H
	je	SHORT $LN78@xmlFAParse

; 4802 : 	    ERROR("IsXXXX expected");

	push	OFFSET ??_C@_0BA@KPLOEDJN@IsXXXX?5expected@

; 4803 : 	    return;

	jmp	$LN97@xmlFAParse
$LN78@xmlFAParse:

; 4804 : 	}
; 4805 : 	NEXT;

	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+4], edx

; 4806 : 	start = ctxt->cur;
; 4807 : 	cur = CUR;

	mov	cl, BYTE PTR [edx]

; 4808 : 	if (((cur >= 'a') && (cur <= 'z')) ||
; 4809 : 	    ((cur >= 'A') && (cur <= 'Z')) ||
; 4810 : 	    ((cur >= '0') && (cur <= '9')) ||

	cmp	cl, 97					; 00000061H
	jb	SHORT $LN81@xmlFAParse
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN80@xmlFAParse
$LN81@xmlFAParse:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN82@xmlFAParse
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN80@xmlFAParse
$LN82@xmlFAParse:
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN83@xmlFAParse
	cmp	cl, 57					; 00000039H
	jbe	SHORT $LN80@xmlFAParse
$LN83@xmlFAParse:
	mov	eax, edx
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN95@xmlFAParse
$LN80@xmlFAParse:

; 4811 : 	    (cur == 0x2D)) {
; 4812 : 	    NEXT;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+4], eax
$LN98@xmlFAParse:

; 4813 : 	    cur = CUR;
; 4814 : 	    while (((cur >= 'a') && (cur <= 'z')) ||
; 4815 : 		((cur >= 'A') && (cur <= 'Z')) ||
; 4816 : 		((cur >= '0') && (cur <= '9')) ||

	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jb	SHORT $LN85@xmlFAParse
	cmp	ecx, 122				; 0000007aH
	jbe	SHORT $LN84@xmlFAParse
$LN85@xmlFAParse:
	cmp	ecx, 65					; 00000041H
	jb	SHORT $LN86@xmlFAParse
	cmp	ecx, 90					; 0000005aH
	jbe	SHORT $LN84@xmlFAParse
$LN86@xmlFAParse:
	cmp	ecx, 48					; 00000030H
	jb	SHORT $LN87@xmlFAParse
	cmp	ecx, 57					; 00000039H
	jbe	SHORT $LN84@xmlFAParse
$LN87@xmlFAParse:
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN95@xmlFAParse
$LN84@xmlFAParse:

; 4817 : 		(cur == 0x2D)) {
; 4818 : 		NEXT;

	inc	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+4]

; 4819 : 		cur = CUR;
; 4820 : 	    }

	jmp	SHORT $LN98@xmlFAParse
$LN95@xmlFAParse:

; 4821 : 	}
; 4822 : 	type = XML_REGEXP_BLOCK_NAME;
; 4823 : 	blockName = xmlStrndup(start, ctxt->cur - start);

	sub	eax, edx
	mov	edi, 136				; 00000088H
	push	eax
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ebx, eax
$LN77@xmlFAParse:

; 4826 : 	return;
; 4827 :     }
; 4828 :     if (ctxt->atom == NULL) {

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN88@xmlFAParse

; 4829 : 	ctxt->atom = xmlRegNewAtom(ctxt, type);

	push	edi
	push	esi
	call	_xmlRegNewAtom
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 4830 : 	if (ctxt->atom != NULL)

	test	eax, eax
	je	SHORT $LN91@xmlFAParse

; 4834 : 		           type, 0, 0, blockName);
; 4835 :     }
; 4836 : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax+20], ebx
	pop	ebx
	pop	ebp
	ret	0
$LN88@xmlFAParse:

; 4831 : 	    ctxt->atom->valuep = blockName;
; 4832 :     } else if (ctxt->atom->type == XML_REGEXP_RANGES) {

	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN91@xmlFAParse

; 4833 :         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,

	push	ebx
	push	0
	push	0
	push	edi
	push	DWORD PTR [esi+12]
	push	ecx
	push	esi
	call	_xmlRegAtomAddRange
	add	esp, 28					; 0000001cH
	pop	edi

; 4834 : 		           type, 0, 0, blockName);
; 4835 :     }
; 4836 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN76@xmlFAParse:

; 4824 :     } else {
; 4825 : 	ERROR("Unknown char property");

	push	OFFSET ??_C@_0BG@ECFAFFBF@Unknown?5char?5property@
$LN97@xmlFAParse:

; 4834 : 		           type, 0, 0, blockName);
; 4835 :     }
; 4836 : }

	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN91@xmlFAParse:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlFAParseCharProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAIsChar
_TEXT	SEGMENT
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAIsChar PROC					; COMDAT

; 4602 : xmlFAIsChar(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+4]
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN3@xmlFAIsCha

; 4603 :     int cur;
; 4604 :     int len;
; 4605 : 
; 4606 :     cur = CUR_SCHAR(ctxt->cur, len);
; 4607 :     if ((cur == '.') || (cur == '\\') || (cur == '?') ||
; 4608 : 	(cur == '*') || (cur == '+') || (cur == '(') ||
; 4609 : 	(cur == ')') || (cur == '|') || (cur == 0x5B) ||
; 4610 : 	(cur == 0x5D) || (cur == 0))

	cmp	eax, 92					; 0000005cH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 40					; 00000028H
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 41					; 00000029H
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 124				; 0000007cH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN3@xmlFAIsCha
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN3@xmlFAIsCha
	test	eax, eax
	jne	SHORT $LN1@xmlFAIsCha
$LN3@xmlFAIsCha:

; 4611 : 	return(-1);

	or	eax, -1
$LN1@xmlFAIsCha:

; 4612 :     return(cur);
; 4613 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAIsChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecGetValues
_TEXT	SEGMENT
_transno$1$ = -16					; size = 4
tv1308 = -16						; size = 4
tv1301 = -16						; size = 4
tv1300 = -16						; size = 4
tv1297 = -12						; size = 4
tv1296 = -12						; size = 4
_state$1$ = -8						; size = 4
_maxval$1$ = -4						; size = 4
_state$1$ = 8						; size = 4
_exec$ = 8						; size = 4
_err$ = 12						; size = 4
_nbval$ = 16						; size = 4
_nbneg$ = 20						; size = 4
_values$ = 24						; size = 4
_terminal$ = 28						; size = 4
_xmlRegExecGetValues PROC				; COMDAT

; 4221 : 		    xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _exec$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN15@xmlRegExec

; 4222 :     int maxval;
; 4223 :     int nb = 0;
; 4224 : 
; 4225 :     if ((exec == NULL) || (nbval == NULL) || (nbneg == NULL) ||
; 4226 :         (values == NULL) || (*nbval <= 0))

	mov	ecx, DWORD PTR _nbval$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@xmlRegExec
	mov	ebx, DWORD PTR _nbneg$[ebp]
	test	ebx, ebx
	je	SHORT $LN15@xmlRegExec
	cmp	DWORD PTR _values$[ebp], edi
	je	SHORT $LN15@xmlRegExec
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR _maxval$1$[ebp], esi
	test	esi, esi
	jle	SHORT $LN15@xmlRegExec

; 4227 :         return(-1);
; 4228 : 
; 4229 :     maxval = *nbval;
; 4230 :     *nbval = 0;

	mov	DWORD PTR [ecx], edi

; 4231 :     *nbneg = 0;

	mov	DWORD PTR [ebx], edi

; 4232 :     if ((exec->comp != NULL) && (exec->comp->compact != NULL)) {

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	$LN16@xmlRegExec
	mov	ebx, DWORD PTR [edx+40]
	test	ebx, ebx
	je	$LN16@xmlRegExec

; 4233 :         xmlRegexpPtr comp;
; 4234 : 	int target, i, state;
; 4235 : 
; 4236 :         comp = exec->comp;
; 4237 : 
; 4238 : 	if (err) {

	cmp	DWORD PTR _err$[ebp], edi
	je	SHORT $LN18@xmlRegExec

; 4239 : 	    if (exec->errStateNo == -1) return(-1);

	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR _state$1$[ebp], eax
	cmp	eax, -1
	jne	SHORT $LN19@xmlRegExec
$LN15@xmlRegExec:
	pop	edi

; 4357 : 		}
; 4358 : 	    }
; 4359 : 	}
; 4360 :     }
; 4361 :     return(0);
; 4362 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlRegExec:

; 4240 : 	    state = exec->errStateNo;
; 4241 : 	} else {
; 4242 : 	    state = exec->index;

	mov	eax, DWORD PTR [eax+56]
	mov	DWORD PTR _state$1$[ebp], eax
$LN19@xmlRegExec:

; 4243 : 	}
; 4244 : 	if (terminal != NULL) {

	mov	esi, DWORD PTR _terminal$[ebp]
	test	esi, esi
	je	SHORT $LN22@xmlRegExec

; 4245 : 	    if (comp->compact[state * (comp->nbstrings + 1)] ==

	mov	ecx, DWORD PTR [edx+48]
	inc	ecx
	imul	ecx, eax
	xor	eax, eax
	cmp	DWORD PTR [ebx+ecx*4], 2
	sete	al
	mov	DWORD PTR [esi], eax
$LN22@xmlRegExec:

; 4246 : 	        XML_REGEXP_FINAL_STATE)
; 4247 : 		*terminal = 1;
; 4248 : 	    else
; 4249 : 		*terminal = 0;
; 4250 : 	}
; 4251 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	mov	ecx, DWORD PTR [edx+48]
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN81@xmlRegExec
	mov	esi, ecx
$LL4@xmlRegExec:
	mov	ecx, esi
	cmp	edi, DWORD PTR _maxval$1$[ebp]
	jge	SHORT $LN81@xmlRegExec

; 4252 : 	    target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	mov	ecx, DWORD PTR [edx+40]
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv1301[ebp], eax
	imul	eax, DWORD PTR _state$1$[ebp]
	add	eax, ebx
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	ecx, esi

; 4253 : 	    if ((target > 0) && (target <= comp->nbstates) &&

	test	eax, eax
	jle	SHORT $LN2@xmlRegExec
	cmp	eax, DWORD PTR [edx+36]
	jg	SHORT $LN2@xmlRegExec
	mov	esi, DWORD PTR [edx+40]
	lea	eax, DWORD PTR [eax*4-4]
	imul	eax, DWORD PTR tv1301[ebp]
	cmp	DWORD PTR [eax+esi], 4
	je	SHORT $LN2@xmlRegExec

; 4254 : 	        (comp->compact[(target - 1) * (comp->nbstrings + 1)] !=
; 4255 : 		 XML_REGEXP_SINK_STATE)) {
; 4256 : 	        values[nb++] = comp->stringMap[i];

	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi

; 4257 : 		(*nbval)++;

	mov	eax, DWORD PTR _nbval$[ebp]
	inc	DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+48]
$LN2@xmlRegExec:

; 4246 : 	        XML_REGEXP_FINAL_STATE)
; 4247 : 		*terminal = 1;
; 4248 : 	    else
; 4249 : 		*terminal = 0;
; 4250 : 	}
; 4251 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	inc	ebx
	mov	esi, ecx
	cmp	ebx, ecx
	jl	SHORT $LL4@xmlRegExec
$LN81@xmlRegExec:

; 4258 : 	    }
; 4259 : 	}
; 4260 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN83@xmlRegExec
$LL7@xmlRegExec:
	cmp	edi, DWORD PTR _maxval$1$[ebp]
	jge	$LN83@xmlRegExec

; 4261 : 	    target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	mov	esi, DWORD PTR [edx+40]
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv1300[ebp], eax
	imul	eax, DWORD PTR _state$1$[ebp]
	add	eax, ebx
	mov	eax, DWORD PTR [esi+eax*4+4]
	mov	esi, ecx

; 4262 : 	    if ((target > 0) && (target <= comp->nbstates) &&

	test	eax, eax
	jle	SHORT $LN5@xmlRegExec
	cmp	eax, DWORD PTR [edx+36]
	jg	SHORT $LN5@xmlRegExec
	mov	ecx, DWORD PTR [edx+40]
	lea	eax, DWORD PTR [eax*4-4]
	imul	eax, DWORD PTR tv1300[ebp]
	cmp	DWORD PTR [eax+ecx], 4
	jne	SHORT $LN5@xmlRegExec

; 4263 : 	        (comp->compact[(target - 1) * (comp->nbstrings + 1)] ==
; 4264 : 		 XML_REGEXP_SINK_STATE)) {
; 4265 : 	        values[nb++] = comp->stringMap[i];

	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _values$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi

; 4266 : 		(*nbneg)++;

	mov	eax, DWORD PTR _nbneg$[ebp]
	inc	DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+48]
$LN5@xmlRegExec:

; 4258 : 	    }
; 4259 : 	}
; 4260 : 	for (i = 0;(i < comp->nbstrings) && (nb < maxval);i++) {

	inc	ebx
	mov	ecx, esi
	cmp	ebx, esi
	jl	SHORT $LL7@xmlRegExec

; 4357 : 		}
; 4358 : 	    }
; 4359 : 	}
; 4360 :     }
; 4361 :     return(0);
; 4362 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlRegExec:

; 4267 : 	    }
; 4268 : 	}
; 4269 :     } else {
; 4270 :         int transno;
; 4271 : 	xmlRegTransPtr trans;
; 4272 : 	xmlRegAtomPtr atom;
; 4273 : 	xmlRegStatePtr state;
; 4274 : 
; 4275 : 	if (terminal != NULL) {

	mov	edx, DWORD PTR _terminal$[ebp]
	test	edx, edx
	je	SHORT $LN27@xmlRegExec

; 4276 : 	    if (exec->state->type == XML_REGEXP_FINAL_STATE)

	mov	eax, DWORD PTR [eax+20]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 2
	mov	eax, DWORD PTR _exec$[ebp]
	sete	cl
	mov	DWORD PTR [edx], ecx
$LN27@xmlRegExec:

; 4277 : 		*terminal = 1;
; 4278 : 	    else
; 4279 : 		*terminal = 0;
; 4280 : 	}
; 4281 : 
; 4282 : 	if (err) {

	cmp	DWORD PTR _err$[ebp], edi
	je	SHORT $LN29@xmlRegExec

; 4283 : 	    if (exec->errState == NULL) return(-1);

	mov	ebx, DWORD PTR [eax+76]

; 4284 : 	    state = exec->errState;
; 4285 : 	} else {

	jmp	SHORT $LN95@xmlRegExec
$LN29@xmlRegExec:

; 4286 : 	    if (exec->state == NULL) return(-1);

	mov	ebx, DWORD PTR [eax+20]
$LN95@xmlRegExec:

; 4287 : 	    state = exec->state;
; 4288 : 	}
; 4289 : 	for (transno = 0;

	mov	DWORD PTR _state$1$[ebp], ebx
	test	ebx, ebx
	je	$LN15@xmlRegExec

; 4290 : 	     (transno < state->nbTrans) && (nb < maxval);

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _transno$1$[ebp], edi
	test	eax, eax
	jle	$LN82@xmlRegExec
	xor	ecx, ecx
	mov	DWORD PTR tv1297[ebp], ecx
$LL10@xmlRegExec:
	cmp	edi, esi
	jge	$LN82@xmlRegExec

; 4292 : 	    trans = &state->trans[transno];

	mov	eax, DWORD PTR [ebx+28]

; 4293 : 	    if (trans->to < 0)

	mov	ebx, DWORD PTR [eax+ecx+4]
	add	eax, ecx
	test	ebx, ebx
	js	$LN8@xmlRegExec

; 4294 : 		continue;
; 4295 : 	    atom = trans->atom;

	mov	ecx, DWORD PTR [eax]

; 4296 : 	    if ((atom == NULL) || (atom->valuep == NULL))

	test	ecx, ecx
	je	$LN8@xmlRegExec
	mov	esi, DWORD PTR [ecx+20]
	test	esi, esi
	je	$LN93@xmlRegExec

; 4297 : 		continue;
; 4298 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	edx, DWORD PTR [eax+12]
	cmp	edx, 1193047				; 00123457H
	jne	SHORT $LN36@xmlRegExec

; 4299 : 	        /* this should not be reached but ... */
; 4300 : 	        TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	4300					; 000010ccH
$LN97@xmlRegExec:

; 4291 : 	     transno++) {

	push	OFFSET ??_C@_0GL@GCGJPEPF@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	jmp	$LN93@xmlRegExec
$LN36@xmlRegExec:

; 4301 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	cmp	edx, 1193046				; 00123456H
	jne	SHORT $LN38@xmlRegExec

; 4302 : 	        /* this should not be reached but ... */
; 4303 : 	        TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	4303					; 000010cfH
	jmp	SHORT $LN97@xmlRegExec
$LN38@xmlRegExec:

; 4304 : 	    } else if (trans->counter >= 0) {

	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _exec$[ebp]
	test	edx, edx
	js	SHORT $LN40@xmlRegExec

; 4305 : 		xmlRegCounterPtr counter = NULL;
; 4306 : 		int count;
; 4307 : 
; 4308 : 		if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN42@xmlRegExec

; 4309 : 		    count = exec->errCounts[trans->counter];

	mov	eax, DWORD PTR [eax+84]
	jmp	SHORT $LN96@xmlRegExec
$LN42@xmlRegExec:

; 4310 : 		else
; 4311 : 		    count = exec->counts[trans->counter];

	mov	eax, DWORD PTR [eax+44]
$LN96@xmlRegExec:

; 4312 : 		if (exec->comp != NULL)

	mov	ebx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN46@xmlRegExec

; 4313 : 		    counter = &exec->comp->counters[trans->counter];

	mov	eax, DWORD PTR [eax+24]
	lea	eax, DWORD PTR [eax+edx*8]

; 4314 : 		if ((counter == NULL) || (count < counter->max)) {

	test	eax, eax
	je	SHORT $LN46@xmlRegExec
	cmp	ebx, DWORD PTR [eax+4]
	jge	SHORT $LN93@xmlRegExec

; 4315 : 		    if (atom->neg)
; 4316 : 			values[nb++] = (xmlChar *) atom->valuep2;
; 4317 : 		    else
; 4318 : 			values[nb++] = (xmlChar *) atom->valuep;
; 4319 : 		    (*nbval)++;
; 4320 : 		}
; 4321 : 	    } else {

	jmp	SHORT $LN46@xmlRegExec
$LN40@xmlRegExec:

; 4322 :                 if ((exec->comp != NULL) && (exec->comp->states[trans->to] != NULL) &&

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN93@xmlRegExec
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ebx*4]
	test	eax, eax
	je	SHORT $LN93@xmlRegExec
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN93@xmlRegExec
$LN46@xmlRegExec:

; 4291 : 	     transno++) {

	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN50@xmlRegExec
	mov	esi, DWORD PTR [ecx+24]
$LN50@xmlRegExec:
	mov	ecx, DWORD PTR _values$[ebp]
	mov	DWORD PTR [ecx+edi*4], esi
	mov	ecx, DWORD PTR _nbval$[ebp]
	inc	DWORD PTR [ecx]
	inc	edi
$LN93@xmlRegExec:
	mov	esi, DWORD PTR _maxval$1$[ebp]
$LN8@xmlRegExec:

; 4290 : 	     (transno < state->nbTrans) && (nb < maxval);

	mov	ebx, DWORD PTR _state$1$[ebp]

; 4291 : 	     transno++) {

	mov	ecx, DWORD PTR _transno$1$[ebp]
	add	DWORD PTR tv1297[ebp], 20		; 00000014H
	inc	ecx
	mov	DWORD PTR _transno$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx+24]
	cmp	ecx, eax
	mov	ecx, DWORD PTR tv1297[ebp]
	jl	$LL10@xmlRegExec
$LN82@xmlRegExec:

; 4323 : 		    (exec->comp->states[trans->to]->type !=
; 4324 : 		     XML_REGEXP_SINK_STATE)) {
; 4325 : 		    if (atom->neg)
; 4326 : 			values[nb++] = (xmlChar *) atom->valuep2;
; 4327 : 		    else
; 4328 : 			values[nb++] = (xmlChar *) atom->valuep;
; 4329 : 		    (*nbval)++;
; 4330 : 		}
; 4331 : 	    }
; 4332 : 	}
; 4333 : 	for (transno = 0;

	xor	ebx, ebx

; 4334 : 	     (transno < state->nbTrans) && (nb < maxval);

	test	eax, eax
	jle	$LN83@xmlRegExec

; 4323 : 		    (exec->comp->states[trans->to]->type !=
; 4324 : 		     XML_REGEXP_SINK_STATE)) {
; 4325 : 		    if (atom->neg)
; 4326 : 			values[nb++] = (xmlChar *) atom->valuep2;
; 4327 : 		    else
; 4328 : 			values[nb++] = (xmlChar *) atom->valuep;
; 4329 : 		    (*nbval)++;
; 4330 : 		}
; 4331 : 	    }
; 4332 : 	}
; 4333 : 	for (transno = 0;

	mov	eax, DWORD PTR _state$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv1296[ebp], ecx
$LL13@xmlRegExec:

; 4334 : 	     (transno < state->nbTrans) && (nb < maxval);

	cmp	edi, esi
	jge	$LN83@xmlRegExec

; 4336 : 	    trans = &state->trans[transno];

	mov	eax, DWORD PTR [eax+28]
	add	eax, ecx

; 4337 : 	    if (trans->to < 0)

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv1308[ebp], ecx
	test	ecx, ecx
	js	SHORT $LN11@xmlRegExec

; 4338 : 		continue;
; 4339 : 	    atom = trans->atom;

	mov	ecx, DWORD PTR [eax]

; 4340 : 	    if ((atom == NULL) || (atom->valuep == NULL))

	test	ecx, ecx
	je	SHORT $LN11@xmlRegExec
	mov	edx, DWORD PTR [ecx+20]
	test	edx, edx
	je	SHORT $LN11@xmlRegExec

; 4341 : 		continue;
; 4342 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	esi, DWORD PTR [eax+12]
	cmp	esi, 1193047				; 00123457H
	je	SHORT $LN88@xmlRegExec

; 4343 : 	        continue;
; 4344 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	cmp	esi, 1193046				; 00123456H
	je	SHORT $LN88@xmlRegExec

; 4345 : 	        continue;
; 4346 : 	    } else if (trans->counter >= 0) {

	cmp	DWORD PTR [eax+8], 0
	jge	SHORT $LN88@xmlRegExec

; 4347 : 	        continue;
; 4348 : 	    } else {
; 4349 :                 if ((exec->comp->states[trans->to] != NULL) &&

	mov	eax, DWORD PTR _exec$[ebp]
	mov	esi, DWORD PTR tv1308[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN88@xmlRegExec
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN88@xmlRegExec

; 4350 : 		    (exec->comp->states[trans->to]->type ==
; 4351 : 		     XML_REGEXP_SINK_STATE)) {
; 4352 : 		    if (atom->neg)

	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN62@xmlRegExec

; 4353 : 			values[nb++] = (xmlChar *) atom->valuep2;

	mov	edx, DWORD PTR [ecx+24]
$LN62@xmlRegExec:

; 4354 : 		    else
; 4355 : 			values[nb++] = (xmlChar *) atom->valuep;
; 4356 : 		    (*nbneg)++;

	mov	ecx, DWORD PTR _values$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
	mov	ecx, DWORD PTR _nbneg$[ebp]
	inc	DWORD PTR [ecx]
	inc	edi
$LN88@xmlRegExec:

; 4335 : 	     transno++) {

	mov	esi, DWORD PTR _maxval$1$[ebp]
$LN11@xmlRegExec:

; 4334 : 	     (transno < state->nbTrans) && (nb < maxval);

	mov	eax, DWORD PTR _state$1$[ebp]

; 4335 : 	     transno++) {

	inc	ebx
	add	DWORD PTR tv1296[ebp], 20		; 00000014H
	mov	ecx, DWORD PTR tv1296[ebp]
	cmp	ebx, DWORD PTR [eax+24]
	jl	SHORT $LL13@xmlRegExec
$LN83@xmlRegExec:
	pop	edi

; 4357 : 		}
; 4358 : 	    }
; 4359 : 	}
; 4360 :     }
; 4361 :     return(0);
; 4362 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegExecGetValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushStringInternal
_TEXT	SEGMENT
_to$1$ = -36						; size = 4
_count$1$ = -36						; size = 4
tv1703 = -36						; size = 4
_i$1$ = -32						; size = 4
_final$1$ = -28						; size = 4
_progress$1$ = -24					; size = 4
tv1700 = -20						; size = 4
_trans$1$ = -16						; size = 4
_data$1$ = -12						; size = 4
tv1817 = -8						; size = 4
_atom$1$ = -4						; size = 4
_value$1$ = 8						; size = 4
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_compound$ = 20						; size = 4
_xmlRegExecPushStringInternal PROC			; COMDAT

; 3784 : 	                     void *data, int compound) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, DWORD PTR _exec$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	mov	DWORD PTR _progress$1$[ebp], 1
	mov	DWORD PTR _final$1$[ebp], edi
	test	esi, esi
	je	$LN132@xmlRegExec

; 3785 :     xmlRegTransPtr trans;
; 3786 :     xmlRegAtomPtr atom;
; 3787 :     int ret;
; 3788 :     int final = 0;
; 3789 :     int progress = 1;
; 3790 : 
; 3791 :     if (exec == NULL)
; 3792 : 	return(-1);
; 3793 :     if (exec->comp == NULL)

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	$LN132@xmlRegExec

; 3795 :     if (exec->status != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN1@xmlRegExec

; 3796 : 	return(exec->status);
; 3797 : 
; 3798 :     if (exec->comp->compact != NULL)

	cmp	DWORD PTR [ecx+40], edi
	je	SHORT $LN19@xmlRegExec

; 3799 : 	return(xmlRegCompactPushString(exec, exec->comp, value, data));

	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _value$[ebp]
	push	ecx
	push	esi
	call	_xmlRegCompactPushString
	add	esp, 16					; 00000010H
	pop	edi

; 4129 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlRegExec:
	push	ebx

; 3800 : 
; 3801 :     if (value == NULL) {

	mov	ebx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN128@xmlRegExec

; 3802 :         if (exec->state->type == XML_REGEXP_FINAL_STATE)

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN21@xmlRegExec

; 3803 : 	    return(1);

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx
$LN1@xmlRegExec:

; 4129 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRegExec:

; 3804 : 	final = 1;

	mov	edi, 1
	mov	DWORD PTR _final$1$[ebp], edi
$LN128@xmlRegExec:

; 3805 :     }
; 3806 : 
; 3807 : #ifdef DEBUG_PUSH
; 3808 :     printf("value pushed: %s\n", value);
; 3809 : #endif
; 3810 :     /*
; 3811 :      * If we have an active rollback stack push the new value there
; 3812 :      * and get back to where we were left
; 3813 :      */
; 3814 :     if ((value != NULL) && (exec->inputStackNr > 0)) {

	xor	ecx, ecx
	test	ebx, ebx
	je	SHORT $LN133@xmlRegExec
	cmp	DWORD PTR [esi+52], ecx
	jle	SHORT $LN133@xmlRegExec

; 3815 : 	xmlFARegExecSaveInputString(exec, value, data);

	push	DWORD PTR _data$[ebp]
	push	ebx
	push	esi
	call	_xmlFARegExecSaveInputString

; 3816 : 	value = exec->inputStack[exec->index].value;

	mov	ecx, DWORD PTR [esi+56]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+68]
	mov	ebx, DWORD PTR [eax+ecx*8]

; 3817 : 	data = exec->inputStack[exec->index].data;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _value$1$[ebp], ebx
	jmp	SHORT $LN149@xmlRegExec
$LN133@xmlRegExec:

; 3805 :     }
; 3806 : 
; 3807 : #ifdef DEBUG_PUSH
; 3808 :     printf("value pushed: %s\n", value);
; 3809 : #endif
; 3810 :     /*
; 3811 :      * If we have an active rollback stack push the new value there
; 3812 :      * and get back to where we were left
; 3813 :      */
; 3814 :     if ((value != NULL) && (exec->inputStackNr > 0)) {

	mov	eax, DWORD PTR _data$[ebp]
$LN149@xmlRegExec:

; 3818 : #ifdef DEBUG_PUSH
; 3819 : 	printf("value loaded: %s\n", value);
; 3820 : #endif
; 3821 :     }
; 3822 : 
; 3823 :     while ((exec->status == 0) &&

	mov	DWORD PTR _data$1$[ebp], eax
	test	ecx, ecx
	jne	$LN81@xmlRegExec

; 3900 : 		    count = exec->counts[t->counter];

	xor	eax, eax
$LL2@xmlRegExec:

; 3818 : #ifdef DEBUG_PUSH
; 3819 : 	printf("value loaded: %s\n", value);
; 3820 : #endif
; 3821 :     }
; 3822 : 
; 3823 :     while ((exec->status == 0) &&

	test	ebx, ebx
	jne	SHORT $LN130@xmlRegExec
	mov	ecx, eax
	cmp	edi, 1
	jne	$LN3@xmlRegExec
	mov	eax, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax], 2
	je	$LN3@xmlRegExec

; 3824 : 	   ((value != NULL) ||
; 3825 : 	    ((final == 1) &&
; 3826 : 	     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {
; 3827 : 
; 3828 : 	/*
; 3829 : 	 * End of input on non-terminal state, rollback, however we may
; 3830 : 	 * still have epsilon like transition for counted transitions
; 3831 : 	 * on counters, in that case don't break too early.
; 3832 : 	 */
; 3833 : 	if ((value == NULL) && (exec->counts == NULL))

	cmp	DWORD PTR [esi+44], ebx
	je	$rollback$151
	jmp	SHORT $LN112@xmlRegExec
$LN130@xmlRegExec:
	lea	edi, DWORD PTR [esi+20]
$LN112@xmlRegExec:

; 3834 : 	    goto rollback;
; 3835 : 
; 3836 : 	exec->transcount = 0;

	mov	eax, edi
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR tv1817[ebp], eax

; 3837 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [ecx+24]
	jge	$LN5@xmlRegExec
	npad	4
$LL6@xmlRegExec:

; 3838 : 	    trans = &exec->state->trans[exec->transno];

	mov	edx, DWORD PTR [ecx+28]
	lea	eax, DWORD PTR [eax+eax*4]

; 3839 : 	    if (trans->to < 0)

	cmp	DWORD PTR [edx+eax*4+4], 0
	lea	edi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _trans$1$[ebp], edi
	jl	$LN4@xmlRegExec

; 3840 : 		continue;
; 3841 : 	    atom = trans->atom;

	mov	eax, DWORD PTR [edi]

; 3842 : 	    ret = 0;
; 3843 : 	    if (trans->count == REGEXP_ALL_LAX_COUNTER) {

	mov	edi, DWORD PTR [edi+12]
	mov	DWORD PTR _atom$1$[ebp], eax
	cmp	edi, 1193047				; 00123457H
	jne	$LN26@xmlRegExec

; 3844 : 		int i;
; 3845 : 		int count;
; 3846 : 		xmlRegTransPtr t;
; 3847 : 		xmlRegCounterPtr counter;
; 3848 : 
; 3849 : 		ret = 0;
; 3850 : 
; 3851 : #ifdef DEBUG_PUSH
; 3852 : 		printf("testing all lax %d\n", trans->count);
; 3853 : #endif
; 3854 : 		/*
; 3855 : 		 * Check all counted transitions from the current state
; 3856 : 		 */
; 3857 : 		if ((value == NULL) && (final)) {

	test	ebx, ebx
	jne	SHORT $LN127@xmlRegExec
	cmp	DWORD PTR _final$1$[ebp], ebx
	jne	$LN142@xmlRegExec

; 3858 : 		    ret = 1;
; 3859 : 		} else if (value != NULL) {

	jmp	$LN4@xmlRegExec
$LN127@xmlRegExec:

; 3860 : 		    for (i = 0;i < exec->state->nbTrans;i++) {

	cmp	DWORD PTR [ecx+24], 0
	mov	DWORD PTR _i$1$[ebp], 0
	jle	$LN4@xmlRegExec

; 3818 : #ifdef DEBUG_PUSH
; 3819 : 	printf("value loaded: %s\n", value);
; 3820 : #endif
; 3821 :     }
; 3822 : 
; 3823 :     while ((exec->status == 0) &&

	mov	eax, DWORD PTR tv1817[ebp]
	xor	edx, edx
	mov	DWORD PTR tv1700[ebp], edx
$LL9@xmlRegExec:

; 3861 : 			t = &exec->state->trans[i];

	mov	edi, DWORD PTR [ecx+28]

; 3862 : 			if ((t->counter < 0) || (t == trans))

	mov	ecx, DWORD PTR [edi+edx+8]
	add	edi, edx
	test	ecx, ecx
	js	SHORT $LN7@xmlRegExec
	cmp	edi, DWORD PTR _trans$1$[ebp]
	je	SHORT $LN7@xmlRegExec

; 3863 : 			    continue;
; 3864 : 			counter = &exec->comp->counters[t->counter];

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+24]
	lea	ebx, DWORD PTR [eax+ecx*8]

; 3865 : 			count = exec->counts[t->counter];

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _count$1$[ebp], eax

; 3866 : 			if ((count < counter->max) &&
; 3867 : 		            (t->atom != NULL) &&

	cmp	eax, DWORD PTR [ebx+4]
	jge	SHORT $LN33@xmlRegExec
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN33@xmlRegExec
	push	DWORD PTR [ecx+20]
	push	DWORD PTR _value$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN4@xmlRegExec
	mov	eax, DWORD PTR _count$1$[ebp]
	mov	edx, DWORD PTR tv1700[ebp]
$LN33@xmlRegExec:

; 3868 : 			    (xmlStrEqual(value, t->atom->valuep))) {
; 3869 : 			    ret = 0;
; 3870 : 			    break;
; 3871 : 			}
; 3872 : 			if ((count >= counter->min) &&
; 3873 : 			    (count < counter->max) &&
; 3874 : 			    (t->atom != NULL) &&

	cmp	eax, DWORD PTR [ebx]
	jl	SHORT $LN145@xmlRegExec
	cmp	eax, DWORD PTR [ebx+4]
	jge	SHORT $LN145@xmlRegExec
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN145@xmlRegExec
	push	DWORD PTR [eax+20]
	mov	ebx, DWORD PTR _value$1$[ebp]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN142@xmlRegExec
	mov	edx, DWORD PTR tv1700[ebp]
$LN145@xmlRegExec:

; 3860 : 		    for (i = 0;i < exec->state->nbTrans;i++) {

	mov	eax, DWORD PTR tv1817[ebp]
$LN7@xmlRegExec:
	mov	edi, DWORD PTR _i$1$[ebp]
	add	edx, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	mov	DWORD PTR tv1700[ebp], edx
	cmp	edi, DWORD PTR [ecx+24]
	jl	$LL9@xmlRegExec

; 4064 : 			    value = NULL;
; 4065 : 			    data = NULL;
; 4066 : #ifdef DEBUG_PUSH
; 4067 : 			    printf("end of input\n");
; 4068 : #endif
; 4069 : 			}
; 4070 : 		    } else {
; 4071 : 			value = NULL;
; 4072 : 			data = NULL;
; 4073 : #ifdef DEBUG_PUSH
; 4074 : 			printf("end of input\n");
; 4075 : #endif
; 4076 : 		    }
; 4077 : 		}
; 4078 : 		goto progress;
; 4079 : 	    } else if (ret < 0) {

	jmp	$LN4@xmlRegExec
$LN26@xmlRegExec:

; 3875 : 			    (xmlStrEqual(value, t->atom->valuep))) {
; 3876 : 			    ret = 1;
; 3877 : 			    break;
; 3878 : 			}
; 3879 : 		    }
; 3880 : 		}
; 3881 : 	    } else if (trans->count == REGEXP_ALL_COUNTER) {

	cmp	edi, 1193046				; 00123456H
	jne	$LN35@xmlRegExec

; 3882 : 		int i;
; 3883 : 		int count;
; 3884 : 		xmlRegTransPtr t;
; 3885 : 		xmlRegCounterPtr counter;
; 3886 : 
; 3887 : 		ret = 1;
; 3888 : 
; 3889 : #ifdef DEBUG_PUSH
; 3890 : 		printf("testing all %d\n", trans->count);
; 3891 : #endif
; 3892 : 		/*
; 3893 : 		 * Check all counted transitions from the current state
; 3894 : 		 */
; 3895 : 		for (i = 0;i < exec->state->nbTrans;i++) {

	mov	eax, DWORD PTR [ecx+24]
	xor	edi, edi
	mov	DWORD PTR tv1703[ebp], eax
	test	eax, eax
	jle	SHORT $LN142@xmlRegExec
	npad	2
$LL12@xmlRegExec:

; 3896 :                     t = &exec->state->trans[i];
; 3897 : 		    if ((t->counter < 0) || (t == trans))

	mov	ecx, DWORD PTR [edx+8]
	test	ecx, ecx
	js	SHORT $LN10@xmlRegExec
	cmp	edx, DWORD PTR _trans$1$[ebp]
	je	SHORT $LN10@xmlRegExec

; 3898 : 			continue;
; 3899 :                     counter = &exec->comp->counters[t->counter];

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+24]
	lea	ebx, DWORD PTR [eax+ecx*8]

; 3900 : 		    count = exec->counts[t->counter];

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3901 : 		    if ((count < counter->min) || (count > counter->max)) {

	cmp	eax, DWORD PTR [ebx]
	jl	$LN4@xmlRegExec
	cmp	eax, DWORD PTR [ebx+4]
	jg	$LN4@xmlRegExec
	mov	eax, DWORD PTR tv1703[ebp]
$LN10@xmlRegExec:

; 3882 : 		int i;
; 3883 : 		int count;
; 3884 : 		xmlRegTransPtr t;
; 3885 : 		xmlRegCounterPtr counter;
; 3886 : 
; 3887 : 		ret = 1;
; 3888 : 
; 3889 : #ifdef DEBUG_PUSH
; 3890 : 		printf("testing all %d\n", trans->count);
; 3891 : #endif
; 3892 : 		/*
; 3893 : 		 * Check all counted transitions from the current state
; 3894 : 		 */
; 3895 : 		for (i = 0;i < exec->state->nbTrans;i++) {

	inc	edi
	add	edx, 20					; 00000014H
	cmp	edi, eax
	jl	SHORT $LL12@xmlRegExec
	mov	ebx, DWORD PTR _value$1$[ebp]
$LN142@xmlRegExec:

; 4010 : 		if ((exec->callback != NULL) && (atom != NULL) &&

	mov	ecx, DWORD PTR _atom$1$[ebp]
$LN100@xmlRegExec:
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _data$1$[ebp]
	test	eax, eax
	je	SHORT $LN62@xmlRegExec
	test	ecx, ecx
	je	SHORT $LN62@xmlRegExec
	test	edx, edx
	je	SHORT $LN62@xmlRegExec

; 4011 : 			(data != NULL)) {
; 4012 : 		    exec->callback(exec->data, atom->valuep,

	push	edx
	push	DWORD PTR [ecx+60]
	push	DWORD PTR [ecx+20]
	push	DWORD PTR [esi+16]
	call	eax
	mov	edx, DWORD PTR _data$1$[ebp]
	add	esp, 16					; 00000010H
$LN62@xmlRegExec:

; 4013 : 			           atom->data, data);
; 4014 : 		}
; 4015 : 		if (exec->state->nbTrans > exec->transno + 1) {

	mov	edi, DWORD PTR tv1817[ebp]
	mov	eax, DWORD PTR [esi+24]
	inc	eax
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN63@xmlRegExec

; 4016 : 		    if (exec->inputStackNr <= 0) {

	cmp	DWORD PTR [esi+52], 0
	jg	SHORT $LN64@xmlRegExec

; 4017 : 			xmlFARegExecSaveInputString(exec, value, data);

	push	edx
	push	ebx
	push	esi
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN64@xmlRegExec:

; 4018 : 		    }
; 4019 : 		    xmlFARegExecSave(exec);

	push	esi
	call	_xmlFARegExecSave
	add	esp, 4
$LN63@xmlRegExec:

; 4020 : 		}
; 4021 : 		if (trans->counter >= 0) {

	mov	edx, DWORD PTR _trans$1$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	test	ecx, ecx
	js	SHORT $LN65@xmlRegExec

; 4022 : #ifdef DEBUG_PUSH
; 4023 : 		    printf("Increasing count %d\n", trans->counter);
; 4024 : #endif
; 4025 : 		    exec->counts[trans->counter]++;

	mov	eax, DWORD PTR [esi+44]
	inc	DWORD PTR [eax+ecx*4]
$LN65@xmlRegExec:

; 4026 : 		}
; 4027 : 		if ((trans->count >= 0) &&

	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, 1193045				; 00123455H
	ja	SHORT $LN66@xmlRegExec

; 4028 : 		    (trans->count < REGEXP_ALL_COUNTER)) {
; 4029 : #ifdef DEBUG_REGEXP_EXEC
; 4030 : 		    printf("resetting count %d on transition\n",
; 4031 : 		           trans->count);
; 4032 : #endif
; 4033 : 		    exec->counts[trans->count] = 0;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+ecx*4], 0
$LN66@xmlRegExec:

; 4034 : 		}
; 4035 : #ifdef DEBUG_PUSH
; 4036 : 		printf("entering state %d\n", trans->to);
; 4037 : #endif
; 4038 :                 if ((exec->comp->states[trans->to] != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN67@xmlRegExec
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN67@xmlRegExec

; 4039 : 		    (exec->comp->states[trans->to]->type ==
; 4040 : 		     XML_REGEXP_SINK_STATE)) {
; 4041 : 		    /*
; 4042 : 		     * entering a sink state, save the current state as error
; 4043 : 		     * state.
; 4044 : 		     */
; 4045 : 		    if (exec->errString != NULL)

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	je	SHORT $LN68@xmlRegExec

; 4046 : 			xmlFree(exec->errString);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN68@xmlRegExec:

; 4047 : 		    exec->errString = xmlStrdup(value);

	push	ebx
	call	_xmlStrdup
	mov	DWORD PTR [esi+80], eax

; 4048 : 		    exec->errState = exec->state;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+76], eax

; 4049 : 		    memcpy(exec->errCounts, exec->counts,

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+20]
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+44]
	push	DWORD PTR [esi+84]
	call	_memcpy
	mov	edx, DWORD PTR _trans$1$[ebp]
	add	esp, 16					; 00000010H
$LN67@xmlRegExec:

; 4050 : 			   exec->comp->nbCounters * sizeof(int));
; 4051 : 		}
; 4052 : 		exec->state = exec->comp->states[trans->to];

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi], eax

; 4053 : 		exec->transno = 0;

	mov	DWORD PTR [esi+24], 0

; 4054 : 		if (trans->atom != NULL) {

	cmp	DWORD PTR [edx], 0
	je	$progress$152

; 4055 : 		    if (exec->inputStack != NULL) {

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	$LN70@xmlRegExec

; 4056 : 			exec->index++;

	inc	DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi+56]

; 4057 : 			if (exec->index < exec->inputStackNr) {

	cmp	ecx, DWORD PTR [esi+52]
	jge	$LN70@xmlRegExec

; 4058 : 			    value = exec->inputStack[exec->index].value;

	mov	edx, DWORD PTR [eax+ecx*8]

; 4059 : 			    data = exec->inputStack[exec->index].data;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _value$1$[ebp], edx
	mov	DWORD PTR _data$1$[ebp], eax

; 4060 : #ifdef DEBUG_PUSH
; 4061 : 			    printf("value loaded: %s\n", value);
; 4062 : #endif
; 4063 : 			} else {

	jmp	$progress$152
$LN35@xmlRegExec:

; 3902 : 			ret = 0;
; 3903 : 			break;
; 3904 : 		    }
; 3905 : 		}
; 3906 : 	    } else if (trans->count >= 0) {

	test	edi, edi
	js	SHORT $LN41@xmlRegExec

; 3907 : 		int count;
; 3908 : 		xmlRegCounterPtr counter;
; 3909 : 
; 3910 : 		/*
; 3911 : 		 * A counted transition.
; 3912 : 		 */
; 3913 : 
; 3914 : 		count = exec->counts[trans->count];

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [eax+edi*4]

; 3915 : 		counter = &exec->comp->counters[trans->count];

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+24]

; 3916 : #ifdef DEBUG_PUSH
; 3917 : 		printf("testing count %d: val %d, min %d, max %d\n",
; 3918 : 		       trans->count, count, counter->min,  counter->max);
; 3919 : #endif
; 3920 : 		ret = ((count >= counter->min) && (count <= counter->max));

	cmp	ecx, DWORD PTR [eax+edi*8]
	jl	$LN4@xmlRegExec
	cmp	ecx, DWORD PTR [eax+edi*8+4]
	jle	$LN142@xmlRegExec
	jmp	$LN4@xmlRegExec
$LN41@xmlRegExec:

; 3921 : 	    } else if (atom == NULL) {

	test	eax, eax
	je	$LN98@xmlRegExec

; 3924 : 		break;
; 3925 : 	    } else if (value != NULL) {

	test	ebx, ebx
	je	$LN4@xmlRegExec

; 3926 : 		ret = xmlRegStrEqualWildcard(atom->valuep, value);

	push	ebx
	push	DWORD PTR [eax+20]
	call	_xmlRegStrEqualWildcard

; 3927 : 		if (atom->neg) {

	mov	edx, DWORD PTR _atom$1$[ebp]
	add	esp, 8
	mov	edi, eax
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN47@xmlRegExec

; 3928 : 		    ret = !ret;

	xor	ecx, ecx
	test	edi, edi
	sete	cl

; 3929 : 		    if (!compound)

	cmp	DWORD PTR _compound$[ebp], 0
	mov	edi, ecx
	je	$LN4@xmlRegExec
$LN47@xmlRegExec:

; 3930 : 		        ret = 0;
; 3931 : 		}
; 3932 : 		if ((ret == 1) && (trans->counter >= 0)) {

	cmp	edi, 1
	jne	$LN120@xmlRegExec
	mov	eax, DWORD PTR _trans$1$[ebp]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	js	SHORT $LN131@xmlRegExec

; 3933 : 		    xmlRegCounterPtr counter;
; 3934 : 		    int count;
; 3935 : 
; 3936 : 		    count = exec->counts[trans->counter];
; 3937 : 		    counter = &exec->comp->counters[trans->counter];
; 3938 : 		    if (count >= counter->max)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax+edx*4]
	cmp	eax, DWORD PTR [ecx+edx*8+4]
	jge	$LN4@xmlRegExec
	mov	eax, DWORD PTR _trans$1$[ebp]
$LN131@xmlRegExec:

; 3939 : 			ret = 0;
; 3940 : 		}
; 3941 : 
; 3942 : 		if ((ret == 1) && (atom->min > 0) && (atom->max > 0)) {

	mov	ecx, DWORD PTR _atom$1$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jle	$LN100@xmlRegExec
	cmp	DWORD PTR [ecx+16], 0
	jle	$LN100@xmlRegExec

; 3943 : 		    xmlRegStatePtr to = exec->comp->states[trans->to];

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _to$1$[ebp], eax

; 3944 : 
; 3945 : 		    /*
; 3946 : 		     * this is a multiple input sequence
; 3947 : 		     */
; 3948 : 		    if (exec->state->nbTrans > exec->transno + 1) {

	mov	eax, DWORD PTR tv1817[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+24]
	inc	eax
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN51@xmlRegExec

; 3949 : 			if (exec->inputStackNr <= 0) {

	cmp	DWORD PTR [esi+52], 0
	jg	SHORT $LN52@xmlRegExec

; 3950 : 			    xmlFARegExecSaveInputString(exec, value, data);

	push	DWORD PTR _data$1$[ebp]
	push	ebx
	push	esi
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN52@xmlRegExec:

; 3951 : 			}
; 3952 : 			xmlFARegExecSave(exec);

	push	esi
	call	_xmlFARegExecSave
	add	esp, 4
$LN51@xmlRegExec:

; 3953 : 		    }
; 3954 : 		    exec->transcount = 1;
; 3955 : 		    do {
; 3956 : 			/*
; 3957 : 			 * Try to progress as much as possible on the input
; 3958 : 			 */
; 3959 : 			if (exec->transcount == atom->max) {

	mov	edx, DWORD PTR _atom$1$[ebp]
	mov	ecx, 1
	mov	DWORD PTR [esi+28], 1
	cmp	DWORD PTR [edx+16], ecx
	je	$LN14@xmlRegExec
	npad	3
$LL15@xmlRegExec:

; 3960 : 			    break;
; 3961 : 			}
; 3962 : 			exec->index++;

	inc	DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+56]

; 3963 : 			value = exec->inputStack[exec->index].value;

	mov	eax, DWORD PTR [esi+68]
	mov	ebx, DWORD PTR [eax+edx*8]

; 3964 : 			data = exec->inputStack[exec->index].data;

	mov	eax, DWORD PTR [eax+edx*8+4]
	mov	DWORD PTR _value$1$[ebp], ebx
	mov	DWORD PTR _data$1$[ebp], eax

; 3965 : #ifdef DEBUG_PUSH
; 3966 : 			printf("value loaded: %s\n", value);
; 3967 : #endif
; 3968 : 
; 3969 : 			/*
; 3970 : 			 * End of input: stop here
; 3971 : 			 */
; 3972 : 			if (value == NULL) {

	test	ebx, ebx
	je	SHORT $LN97@xmlRegExec

; 3974 : 			    break;
; 3975 : 			}
; 3976 : 			if (exec->transcount >= atom->min) {

	mov	eax, DWORD PTR _atom$1$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jl	SHORT $LN129@xmlRegExec

; 3977 : 			    int transno = exec->transno;
; 3978 : 			    xmlRegStatePtr state = exec->state;
; 3979 : 
; 3980 : 			    /*
; 3981 : 			     * The transition is acceptable save it
; 3982 : 			     */
; 3983 : 			    exec->transno = -1; /* trick */
; 3984 : 			    exec->state = to;
; 3985 : 			    if (exec->inputStackNr <= 0) {

	cmp	DWORD PTR [esi+52], 0
	mov	ecx, DWORD PTR tv1817[ebp]
	mov	edi, DWORD PTR [esi+24]
	mov	eax, DWORD PTR _to$1$[ebp]
	mov	DWORD PTR [esi+24], -1
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax
	jg	SHORT $LN56@xmlRegExec

; 3986 : 				xmlFARegExecSaveInputString(exec, value, data);

	push	DWORD PTR _data$1$[ebp]
	push	DWORD PTR _value$1$[ebp]
	push	esi
	call	_xmlFARegExecSaveInputString
	add	esp, 12					; 0000000cH
$LN56@xmlRegExec:

; 3987 : 			    }
; 3988 : 			    xmlFARegExecSave(exec);

	push	esi
	call	_xmlFARegExecSave

; 3989 : 			    exec->transno = transno;
; 3990 : 			    exec->state = state;

	mov	eax, DWORD PTR tv1817[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR _value$1$[ebp]
	mov	eax, DWORD PTR _atom$1$[ebp]
$LN129@xmlRegExec:

; 3991 : 			}
; 3992 : 			ret = xmlStrEqual(value, atom->valuep);

	push	DWORD PTR [eax+20]
	push	ebx
	call	_xmlStrEqual

; 3993 : 			exec->transcount++;

	mov	ecx, DWORD PTR [esi+28]
	mov	edi, eax
	inc	ecx
	add	esp, 8
	mov	DWORD PTR [esi+28], ecx

; 3994 : 		    } while (ret == 1);

	cmp	edi, 1
	jne	SHORT $LN137@xmlRegExec

; 3953 : 		    }
; 3954 : 		    exec->transcount = 1;
; 3955 : 		    do {
; 3956 : 			/*
; 3957 : 			 * Try to progress as much as possible on the input
; 3958 : 			 */
; 3959 : 			if (exec->transcount == atom->max) {

	mov	eax, DWORD PTR _atom$1$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	$LL15@xmlRegExec
	jmp	SHORT $LN137@xmlRegExec
$LN97@xmlRegExec:

; 3973 : 			    exec->index --;

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [esi+56], eax
$LN137@xmlRegExec:

; 3995 : 		    if (exec->transcount < atom->min)
; 3996 : 			ret = 0;
; 3997 : 
; 3998 : 		    /*
; 3999 : 		     * If the last check failed but one transition was found
; 4000 : 		     * possible, rollback
; 4001 : 		     */
; 4002 : 		    if (ret < 0)

	mov	edx, DWORD PTR _atom$1$[ebp]
$LN14@xmlRegExec:
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+12]
	cmovge	eax, edi

; 4003 : 			ret = 0;
; 4004 : 		    if (ret == 0) {

	xor	edi, edi
	test	eax, eax
	cmovns	edi, eax
	test	edi, edi
	je	SHORT $LN99@xmlRegExec

; 4006 : 		    }
; 4007 : 		}
; 4008 : 	    }
; 4009 : 	    if (ret == 1) {

	cmp	edi, 1
	je	$LN142@xmlRegExec
$LN120@xmlRegExec:

; 4064 : 			    value = NULL;
; 4065 : 			    data = NULL;
; 4066 : #ifdef DEBUG_PUSH
; 4067 : 			    printf("end of input\n");
; 4068 : #endif
; 4069 : 			}
; 4070 : 		    } else {
; 4071 : 			value = NULL;
; 4072 : 			data = NULL;
; 4073 : #ifdef DEBUG_PUSH
; 4074 : 			printf("end of input\n");
; 4075 : #endif
; 4076 : 		    }
; 4077 : 		}
; 4078 : 		goto progress;
; 4079 : 	    } else if (ret < 0) {

	test	edi, edi
	js	SHORT $LN101@xmlRegExec
$LN4@xmlRegExec:

; 3837 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR tv1817[ebp]
	inc	eax
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+24]
	jge	SHORT $LN5@xmlRegExec
	mov	ebx, DWORD PTR _value$1$[ebp]
	jmp	$LL6@xmlRegExec
$LN99@xmlRegExec:

; 4005 : 			goto rollback;

	mov	edi, DWORD PTR tv1817[ebp]
	jmp	$rollback$151
$LN70@xmlRegExec:

; 4110 : #ifdef DEBUG_PUSH
; 4111 : 		printf("value loaded: %s\n", value);
; 4112 : #endif
; 4113 : 	    }
; 4114 : 	}
; 4115 : 	continue;
; 4116 : progress:
; 4117 :         progress = 1;

	mov	DWORD PTR _data$1$[ebp], 0
	mov	DWORD PTR _value$1$[ebp], 0
$progress$152:
	mov	DWORD PTR _progress$1$[ebp], 1
$LN134@xmlRegExec:

; 3818 : #ifdef DEBUG_PUSH
; 3819 : 	printf("value loaded: %s\n", value);
; 3820 : #endif
; 3821 :     }
; 3822 : 
; 3823 :     while ((exec->status == 0) &&

	mov	ebx, DWORD PTR _value$1$[ebp]
$LN80@xmlRegExec:
	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	mov	edi, DWORD PTR _final$1$[ebp]
	test	ecx, ecx
	je	$LL2@xmlRegExec
$LN3@xmlRegExec:

; 4118 : 	continue;
; 4119 :     }
; 4120 :     if (exec->status == 0) {

	test	ecx, ecx
	jne	$LN81@xmlRegExec

; 4121 :         return(exec->state->type == XML_REGEXP_FINAL_STATE);

	mov	ecx, DWORD PTR [esi+20]
	xor	eax, eax
	pop	ebx
	pop	edi

; 4129 : }

	pop	esi
	cmp	DWORD PTR [ecx], 2
	sete	al
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@xmlRegExec:

; 4080 : 		exec->status = -4;

	mov	DWORD PTR [esi], -4			; fffffffcH
	jmp	SHORT $LN5@xmlRegExec
$LN98@xmlRegExec:

; 3922 : 		fprintf(stderr, "epsilon transition left at runtime\n");

	push	OFFSET ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 3923 : 		exec->status = -2;

	mov	DWORD PTR [esi], -2			; fffffffeH
$LN5@xmlRegExec:

; 4081 : 		break;
; 4082 : 	    }
; 4083 : 	}
; 4084 : 	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {

	cmp	DWORD PTR [esi+24], 0
	mov	eax, DWORD PTR tv1817[ebp]
	mov	edi, eax
	jne	SHORT $LN135@xmlRegExec
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN134@xmlRegExec
$LN135@xmlRegExec:

; 4085 : rollback:
; 4086 :             /*
; 4087 : 	     * if we didn't yet rollback on the current input
; 4088 : 	     * store the current state as the error state.
; 4089 : 	     */
; 4090 : 	    if ((progress) && (exec->state != NULL) &&

	mov	ebx, DWORD PTR _value$1$[ebp]
$rollback$151:
	cmp	DWORD PTR _progress$1$[ebp], 0
	je	SHORT $LN79@xmlRegExec
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN79@xmlRegExec
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN79@xmlRegExec

; 4091 : 	        (exec->state->type != XML_REGEXP_SINK_STATE)) {
; 4092 : 	        progress = 0;
; 4093 : 		if (exec->errString != NULL)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR _progress$1$[ebp], 0
	test	eax, eax
	je	SHORT $LN78@xmlRegExec

; 4094 : 		    xmlFree(exec->errString);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN78@xmlRegExec:

; 4095 : 		exec->errString = xmlStrdup(value);

	push	ebx
	call	_xmlStrdup
	mov	DWORD PTR [esi+80], eax
	add	esp, 4

; 4096 : 		exec->errState = exec->state;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+76], eax

; 4097 :                 if (exec->comp->nbCounters)

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN79@xmlRegExec

; 4098 :                     memcpy(exec->errCounts, exec->counts,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+44]
	push	DWORD PTR [esi+84]
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN79@xmlRegExec:

; 4099 :                            exec->comp->nbCounters * sizeof(int));
; 4100 : 	    }
; 4101 : 
; 4102 : 	    /*
; 4103 : 	     * Failed to find a way out
; 4104 : 	     */
; 4105 : 	    exec->determinist = 0;
; 4106 : 	    xmlFARegExecRollBack(exec);

	push	esi
	mov	DWORD PTR [esi+4], 0
	call	_xmlFARegExecRollBack

; 4107 : 	    if ((exec->inputStack != NULL ) && (exec->status == 0)) {

	mov	ecx, DWORD PTR [esi+68]
	add	esp, 4
	test	ecx, ecx
	je	$LN80@xmlRegExec
	cmp	DWORD PTR [esi], 0
	jne	$LN80@xmlRegExec

; 4108 : 		value = exec->inputStack[exec->index].value;

	mov	eax, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [ecx+eax*8]

; 4109 : 		data = exec->inputStack[exec->index].data;

	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _value$1$[ebp], ebx
	mov	DWORD PTR _data$1$[ebp], edx
	jmp	$LN80@xmlRegExec
$LN81@xmlRegExec:
	pop	ebx
	pop	edi

; 4122 :     }
; 4123 : #ifdef DEBUG_ERR
; 4124 :     if (exec->status < 0) {
; 4125 : 	testerr(exec);
; 4126 :     }
; 4127 : #endif
; 4128 :     return(exec->status);

	mov	eax, ecx

; 4129 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN132@xmlRegExec:
	pop	edi

; 3794 : 	return(-1);

	or	eax, -1

; 4129 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegExecPushStringInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCompactPushString
_TEXT	SEGMENT
_state$1$ = -4						; size = 4
_exec$ = 8						; size = 4
tv425 = 12						; size = 4
_comp$ = 12						; size = 4
_value$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlRegCompactPushString PROC				; COMDAT

; 3703 : 	                void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _exec$[ebp]
	mov	esi, DWORD PTR _comp$[ebp]
	mov	edi, DWORD PTR [eax+56]
	mov	DWORD PTR _state$1$[ebp], edi
	test	esi, esi
	je	$LN6@xmlRegComp

; 3704 :     int state = exec->index;
; 3705 :     int i, target;
; 3706 : 
; 3707 :     if ((comp == NULL) || (comp->compact == NULL) || (comp->stringMap == NULL))

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	$LN6@xmlRegComp
	cmp	DWORD PTR [esi+52], 0
	je	$LN6@xmlRegComp

; 3709 : 
; 3710 :     if (value == NULL) {

	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [esi+48]
	push	ebx
	test	edx, edx
	jne	SHORT $LN7@xmlRegComp

; 3711 : 	/*
; 3712 : 	 * are we at a final state ?
; 3713 : 	 */
; 3714 : 	if (comp->compact[state * (comp->nbstrings + 1)] ==

	inc	eax
	imul	eax, edi
	cmp	DWORD PTR [ecx+eax*4], 2
	jmp	$LN26@xmlRegComp
$LN7@xmlRegComp:

; 3715 :             XML_REGEXP_FINAL_STATE)
; 3716 : 	    return(1);
; 3717 : 	return(0);
; 3718 :     }
; 3719 : 
; 3720 : #ifdef DEBUG_PUSH
; 3721 :     printf("value pushed: %s\n", value);
; 3722 : #endif
; 3723 : 
; 3724 :     /*
; 3725 :      * Examine all outside transitions from current state
; 3726 :      */
; 3727 :     for (i = 0;i < comp->nbstrings;i++) {

	xor	ebx, ebx
	test	eax, eax
	jle	$error$28
	npad	5
$LL4@xmlRegComp:

; 3728 : 	target = comp->compact[state * (comp->nbstrings + 1) + i + 1];

	lea	ecx, DWORD PTR [eax+1]
	mov	eax, DWORD PTR [esi+40]
	imul	ecx, edi
	add	ecx, ebx
	mov	edi, DWORD PTR [eax+ecx*4+4]

; 3729 : 	if ((target > 0) && (target <= comp->nbstates)) {

	test	edi, edi
	jle	SHORT $LN2@xmlRegComp
	cmp	edi, DWORD PTR [esi+36]
	jg	SHORT $LN2@xmlRegComp

; 3730 : 	    target--; /* to avoid 0 */
; 3731 : 	    if (xmlRegStrEqualWildcard(comp->stringMap[i], value)) {

	mov	eax, DWORD PTR [esi+52]
	dec	edi
	push	edx
	push	DWORD PTR [eax+ebx*4]
	call	_xmlRegStrEqualWildcard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlRegComp
	mov	edx, DWORD PTR _value$[ebp]
$LN2@xmlRegComp:

; 3715 :             XML_REGEXP_FINAL_STATE)
; 3716 : 	    return(1);
; 3717 : 	return(0);
; 3718 :     }
; 3719 : 
; 3720 : #ifdef DEBUG_PUSH
; 3721 :     printf("value pushed: %s\n", value);
; 3722 : #endif
; 3723 : 
; 3724 :     /*
; 3725 :      * Examine all outside transitions from current state
; 3726 :      */
; 3727 :     for (i = 0;i < comp->nbstrings;i++) {

	mov	eax, DWORD PTR [esi+48]
	inc	ebx
	mov	edi, DWORD PTR _state$1$[ebp]
	cmp	ebx, eax
	jge	SHORT $error$28
	jmp	SHORT $LL4@xmlRegComp
$LN17@xmlRegComp:

; 3732 : 		exec->index = target;

	mov	ecx, DWORD PTR _exec$[ebp]

; 3733 : 		if ((exec->callback != NULL) && (comp->transdata != NULL)) {

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+56], edi
	mov	DWORD PTR tv425[ebp], eax
	test	eax, eax
	je	SHORT $LN11@xmlRegComp
	mov	edx, DWORD PTR [esi+44]
	test	edx, edx
	je	SHORT $LN11@xmlRegComp

; 3734 : 		    exec->callback(exec->data, value,

	mov	eax, DWORD PTR [esi+48]
	imul	eax, DWORD PTR _state$1$[ebp]
	push	DWORD PTR _data$[ebp]
	add	eax, ebx
	push	DWORD PTR [edx+eax*4]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR [ecx+16]
	call	DWORD PTR tv425[ebp]
	add	esp, 16					; 00000010H
$LN11@xmlRegComp:

; 3735 : 			  comp->transdata[state * comp->nbstrings + i], data);
; 3736 : 		}
; 3737 : #ifdef DEBUG_PUSH
; 3738 : 		printf("entering state %d\n", target);
; 3739 : #endif
; 3740 : 		if (comp->compact[target * (comp->nbstrings + 1)] ==

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+40]
	inc	ecx
	imul	ecx, edi
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, 4
	je	SHORT $LN24@xmlRegComp

; 3741 : 		    XML_REGEXP_SINK_STATE)
; 3742 : 		    goto error;
; 3743 : 
; 3744 : 		if (comp->compact[target * (comp->nbstrings + 1)] ==

	cmp	eax, 2
$LN26@xmlRegComp:

; 3745 : 		    XML_REGEXP_FINAL_STATE)
; 3746 : 		    return(1);

	jne	SHORT $LN13@xmlRegComp
	pop	ebx
	pop	edi
	mov	eax, 1

; 3768 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlRegComp:
	pop	ebx
	pop	edi

; 3747 : 		return(0);

	xor	eax, eax

; 3768 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlRegComp:

; 3735 : 			  comp->transdata[state * comp->nbstrings + i], data);
; 3736 : 		}
; 3737 : #ifdef DEBUG_PUSH
; 3738 : 		printf("entering state %d\n", target);
; 3739 : #endif
; 3740 : 		if (comp->compact[target * (comp->nbstrings + 1)] ==

	mov	edi, DWORD PTR _state$1$[ebp]
$error$28:

; 3748 : 	    }
; 3749 : 	}
; 3750 :     }
; 3751 :     /*
; 3752 :      * Failed to find an exit transition out from current state for the
; 3753 :      * current token
; 3754 :      */
; 3755 : #ifdef DEBUG_PUSH
; 3756 :     printf("failed to find a transition for %s on state %d\n", value, state);
; 3757 : #endif
; 3758 : error:
; 3759 :     if (exec->errString != NULL)

	mov	ebx, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [ebx+80]
	test	eax, eax
	je	SHORT $LN14@xmlRegComp

; 3760 :         xmlFree(exec->errString);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlRegComp:

; 3761 :     exec->errString = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+80], eax

; 3762 :     exec->errStateNo = state;

	mov	DWORD PTR [ebx+72], edi

; 3763 :     exec->status = -1;
; 3764 : #ifdef DEBUG_ERR
; 3765 :     testerr(exec);
; 3766 : #endif
; 3767 :     return(-1);

	or	eax, -1
	mov	DWORD PTR [ebx], -1
	pop	ebx
	pop	edi

; 3768 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRegComp:
	pop	edi

; 3708 : 	return(-1);

	or	eax, -1

; 3768 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegCompactPushString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecSaveInputString
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlFARegExecSaveInputString PROC			; COMDAT

; 3604 : 	                    void *data) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exec$[ebp]
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	jne	SHORT $LN2@xmlFARegEx

; 3605 : #ifdef DEBUG_PUSH
; 3606 :     printf("saving value: %d:%s\n", exec->inputStackNr, value);
; 3607 : #endif
; 3608 :     if (exec->inputStackMax == 0) {
; 3609 : 	exec->inputStackMax = 4;

	push	32					; 00000020H
	mov	DWORD PTR [esi+48], 4

; 3610 : 	exec->inputStack = (xmlRegInputTokenPtr)

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+68], eax

; 3611 : 	    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));
; 3612 : 	if (exec->inputStack == NULL) {

	test	eax, eax
	jne	$LN5@xmlFARegEx

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3613 : 	    xmlRegexpErrMemory(NULL, "pushing input string");
; 3614 : 	    exec->inputStackMax = 0;

	mov	DWORD PTR [esi+48], 0
	pop	esi

; 3635 : }

	pop	ebp
	ret	0
$LN2@xmlFARegEx:

; 3615 : 	    return;
; 3616 : 	}
; 3617 :     } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {

	mov	eax, DWORD PTR [esi+52]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN5@xmlFARegEx

; 3618 : 	xmlRegInputTokenPtr tmp;
; 3619 : 
; 3620 : 	exec->inputStackMax *= 2;

	lea	eax, DWORD PTR [ecx+ecx]
	mov	DWORD PTR [esi+48], eax

; 3621 : 	tmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+68]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3622 : 			exec->inputStackMax * sizeof(xmlRegInputToken));
; 3623 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlFARegEx

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BF@FEDDAGIG@pushing?5input?5string@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 3624 : 	    xmlRegexpErrMemory(NULL, "pushing input string");
; 3625 : 	    exec->inputStackMax /= 2;

	mov	eax, DWORD PTR [esi+48]

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	add	esp, 68					; 00000044H

; 3624 : 	    xmlRegexpErrMemory(NULL, "pushing input string");
; 3625 : 	    exec->inputStackMax /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+48], eax
	pop	esi

; 3635 : }

	pop	ebp
	ret	0
$LN6@xmlFARegEx:

; 3626 : 	    return;
; 3627 : 	}
; 3628 : 	exec->inputStack = tmp;

	mov	DWORD PTR [esi+68], eax
$LN5@xmlFARegEx:

; 3629 :     }
; 3630 :     exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	mov	edx, DWORD PTR [esi+52]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [ecx+edx*8], eax

; 3631 :     exec->inputStack[exec->inputStackNr].data = data;

	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 3632 :     exec->inputStackNr++;

	inc	DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+52]

; 3633 :     exec->inputStack[exec->inputStackNr].value = NULL;

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [eax+ecx*8], 0

; 3634 :     exec->inputStack[exec->inputStackNr].data = NULL;

	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [esi+68]
	pop	esi
	mov	DWORD PTR [eax+ecx*8+4], 0

; 3635 : }

	pop	ebp
	ret	0
_xmlFARegExecSaveInputString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExec
_TEXT	SEGMENT
_execval$ = -128					; size = 92
_to$1$ = -36						; size = 4
_atom$2$ = -32						; size = 4
tv1144 = -28						; size = 4
_ret$1$ = -24						; size = 4
_trans$2$ = -20						; size = 4
_deter$1$ = -16						; size = 4
_len$ = -12						; size = 4
_execval$5$ = -8					; size = 4
_execval$1$ = -4					; size = 4
_comp$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlFARegExec PROC					; COMDAT

; 3194 : xmlFARegExec(xmlRegexpPtr comp, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _comp$[ebp]
	xor	ebx, ebx
	mov	esi, DWORD PTR _content$[ebp]
	xor	edi, edi
	mov	DWORD PTR _execval$[ebp+8], ecx
	mov	DWORD PTR _execval$[ebp+64], esi
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _execval$[ebp+56], ebx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv1144[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _execval$[ebp+88], ebx
	mov	DWORD PTR _execval$[ebp+4], 1
	mov	DWORD PTR _execval$[ebp+32], ebx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _execval$[ebp+36], ebx
	mov	DWORD PTR _execval$[ebp+40], ebx
	mov	DWORD PTR _execval$[ebp], ebx
	mov	DWORD PTR _execval$1$[ebp], eax
	mov	DWORD PTR _execval$[ebp+20], eax
	mov	DWORD PTR _execval$5$[ebp], edi
	mov	DWORD PTR _execval$[ebp+24], edi
	mov	DWORD PTR _execval$[ebp+28], ebx
	mov	DWORD PTR _execval$[ebp+68], ebx
	mov	DWORD PTR _execval$[ebp+48], ebx
	test	ecx, ecx
	jle	SHORT $LN13@xmlFARegEx

; 3195 :     xmlRegExecCtxt execval;
; 3196 :     xmlRegExecCtxtPtr exec = &execval;
; 3197 :     int ret, codepoint = 0, len, deter;
; 3198 : 
; 3199 :     exec->inputString = content;
; 3200 :     exec->index = 0;
; 3201 :     exec->nbPush = 0;
; 3202 :     exec->determinist = 1;
; 3203 :     exec->maxRollbacks = 0;
; 3204 :     exec->nbRollbacks = 0;
; 3205 :     exec->rollbacks = NULL;
; 3206 :     exec->status = 0;
; 3207 :     exec->comp = comp;
; 3208 :     exec->state = comp->states[0];
; 3209 :     exec->transno = 0;
; 3210 :     exec->transcount = 0;
; 3211 :     exec->inputStack = NULL;
; 3212 :     exec->inputStackMax = 0;
; 3213 :     if (comp->nbCounters > 0) {
; 3214 : 	exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int));

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _execval$[ebp+44], esi

; 3215 : 	if (exec->counts == NULL) {

	test	esi, esi
	jne	SHORT $LN15@xmlFARegEx

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0P@IJHGICCJ@running?5regexp@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0P@IJHGICCJ@running?5regexp@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN112@xmlFARegEx:
	pop	edi

; 3488 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlFARegEx:

; 3216 : 	    xmlRegexpErrMemory(NULL, "running regexp");
; 3217 : 	    return(-1);
; 3218 : 	}
; 3219 :         memset(exec->counts, 0, comp->nbCounters * sizeof(int));

	mov	eax, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [eax+20]
	shl	eax, 2
	push	eax
	push	0
	push	esi
	call	_memset

; 3220 :     } else

	mov	edx, DWORD PTR _execval$[ebp+44]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _execval$1$[ebp]
	mov	esi, DWORD PTR _content$[ebp]
	jmp	SHORT $LL2@xmlFARegEx
$LN13@xmlFARegEx:

; 3221 : 	exec->counts = NULL;

	xor	edx, edx
	mov	DWORD PTR _execval$[ebp+44], edx
$LL2@xmlFARegEx:

; 3222 :     while ((exec->status == 0) && (exec->state != NULL) &&

	test	eax, eax
	je	$error$157
	cmp	BYTE PTR [esi+ebx], 0
	jne	SHORT $LN16@xmlFARegEx
	cmp	DWORD PTR [eax], 2
	je	$error$157
$LN16@xmlFARegEx:

; 3223 : 	   ((exec->inputString[exec->index] != 0) ||
; 3224 : 	    ((exec->state != NULL) &&
; 3225 : 	     (exec->state->type != XML_REGEXP_FINAL_STATE)))) {
; 3226 : 	xmlRegTransPtr trans;
; 3227 : 	xmlRegAtomPtr atom;
; 3228 : 
; 3229 : 	/*
; 3230 : 	 * If end of input on non-terminal state, rollback, however we may
; 3231 : 	 * still have epsilon like transition for counted transitions
; 3232 : 	 * on counters, in that case don't break too early.  Additionally,
; 3233 : 	 * if we are working on a range like "AB{0,2}", where B is not present,
; 3234 : 	 * we don't want to break.
; 3235 : 	 */
; 3236 : 	len = 1;

	mov	DWORD PTR _len$[ebp], 1

; 3237 : 	if ((exec->inputString[exec->index] == 0) && (exec->counts == NULL)) {

	cmp	BYTE PTR [esi+ebx], 0
	jne	SHORT $LN19@xmlFARegEx
	test	edx, edx
	jne	SHORT $LN19@xmlFARegEx

; 3238 : 	    /*
; 3239 : 	     * if there is a transition, we must check if
; 3240 : 	     *  atom allows minOccurs of 0
; 3241 : 	     */
; 3242 : 	    if (exec->transno < exec->state->nbTrans) {

	cmp	edi, DWORD PTR [eax+24]
	jge	$rollback$158

; 3243 : 	        trans = &exec->state->trans[exec->transno];

	mov	eax, DWORD PTR [eax+28]
	lea	ecx, DWORD PTR [edi+edi*4]

; 3244 : 		if (trans->to >=0) {

	cmp	DWORD PTR [eax+ecx*4+4], edx
	jl	SHORT $LN142@xmlFARegEx

; 3245 : 		    atom = trans->atom;

	mov	eax, DWORD PTR [eax+ecx*4]

; 3246 : 		    if (!((atom->min == 0) && (atom->max > 0)))

	cmp	DWORD PTR [eax+12], edx
	jne	$rollback$158
	cmp	DWORD PTR [eax+16], edx
	jle	$rollback$158
$LN142@xmlFARegEx:

; 3247 : 		        goto rollback;
; 3248 : 		}
; 3249 : 	    } else
; 3250 : 	        goto rollback;
; 3251 : 	}
; 3252 : 
; 3253 : 	exec->transcount = 0;

	mov	eax, DWORD PTR _execval$1$[ebp]
$LN19@xmlFARegEx:
	mov	DWORD PTR _execval$[ebp+28], 0

; 3254 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	cmp	edi, DWORD PTR [eax+24]
	jge	$LN135@xmlFARegEx
	npad	5
$LL6@xmlFARegEx:

; 3255 : 	    trans = &exec->state->trans[exec->transno];

	mov	eax, DWORD PTR [eax+28]
	lea	ecx, DWORD PTR [edi+edi*4]

; 3256 : 	    if (trans->to < 0)

	cmp	DWORD PTR [eax+ecx*4+4], 0
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _trans$2$[ebp], eax
	jl	$LN4@xmlFARegEx

; 3257 : 		continue;
; 3258 : 	    atom = trans->atom;
; 3259 : 	    ret = 0;
; 3260 : 	    deter = 1;
; 3261 : 	    if (trans->count >= 0) {

	mov	ecx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _atom$2$[ebp], esi
	mov	DWORD PTR _deter$1$[ebp], 1
	test	ecx, ecx
	js	SHORT $LN24@xmlFARegEx

; 3262 : 		int count;
; 3263 : 		xmlRegCounterPtr counter;
; 3264 : 
; 3265 : 		if (exec->counts == NULL) {

	test	edx, edx
	je	$LN92@xmlFARegEx

; 3266 : 		    exec->status = -1;
; 3267 : 		    goto error;
; 3268 : 		}
; 3269 : 		/*
; 3270 : 		 * A counted transition.
; 3271 : 		 */
; 3272 : 
; 3273 : 		count = exec->counts[trans->count];
; 3274 : 		counter = &exec->comp->counters[trans->count];

	mov	eax, DWORD PTR _comp$[ebp]
	mov	esi, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+24]
	lea	eax, DWORD PTR [eax+ecx*8]

; 3275 : #ifdef DEBUG_REGEXP_EXEC
; 3276 : 		printf("testing count %d: val %d, min %d, max %d\n",
; 3277 : 		       trans->count, count, counter->min,  counter->max);
; 3278 : #endif
; 3279 : 		ret = ((count >= counter->min) && (count <= counter->max));

	mov	ecx, DWORD PTR [eax]
	cmp	esi, ecx
	jl	$LN4@xmlFARegEx
	mov	eax, DWORD PTR [eax+4]
	cmp	esi, eax
	jg	$LN4@xmlFARegEx

; 3280 : 		if ((ret) && (counter->min != counter->max))

	cmp	ecx, eax
	je	$LN148@xmlFARegEx

; 3281 : 		    deter = 0;

	xor	eax, eax

; 3282 : 	    } else if (atom == NULL) {

	jmp	$LN105@xmlFARegEx
$LN24@xmlFARegEx:
	test	esi, esi
	je	$LN86@xmlFARegEx

; 3285 : 		break;
; 3286 : 	    } else if (exec->inputString[exec->index] != 0) {

	mov	eax, DWORD PTR _content$[ebp]
	add	eax, ebx
	cmp	BYTE PTR [eax], 0
	je	$LN30@xmlFARegEx

; 3287 :                 codepoint = CUR_SCHAR(&(exec->inputString[exec->index]), len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	eax
	push	0
	call	_xmlStringCurrentChar

; 3288 : 		ret = xmlRegCheckCharacter(atom, codepoint);

	push	eax
	push	esi
	call	_xmlRegCheckCharacter
	mov	ecx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$1$[ebp], ecx

; 3289 : 		if ((ret == 1) && (atom->min >= 0) && (atom->max > 0)) {

	cmp	ecx, 1
	jne	$LN32@xmlFARegEx
	cmp	DWORD PTR [esi+12], 0
	jl	$LN148@xmlFARegEx
	cmp	DWORD PTR [esi+16], 0
	jle	$LN148@xmlFARegEx

; 3290 : 		    xmlRegStatePtr to = comp->states[trans->to];

	mov	edx, DWORD PTR _trans$2$[ebp]
	mov	eax, DWORD PTR tv1144[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3291 : 
; 3292 : 		    /*
; 3293 : 		     * this is a multiple input sequence
; 3294 : 		     * If there is a counter associated increment it now.
; 3295 : 		     * before potentially saving and rollback
; 3296 : 		     * do not increment if the counter is already over the
; 3297 : 		     * maximum limit in which case get to next transition
; 3298 : 		     */
; 3299 : 		    if (trans->counter >= 0) {

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _to$1$[ebp], eax
	test	ecx, ecx
	js	SHORT $LN34@xmlFARegEx

; 3300 : 			xmlRegCounterPtr counter;
; 3301 : 
; 3302 : 			if ((exec->counts == NULL) ||
; 3303 : 			    (exec->comp == NULL) ||

	mov	edx, DWORD PTR _execval$[ebp+44]
	test	edx, edx
	je	$LN92@xmlFARegEx
	mov	eax, DWORD PTR _comp$[ebp]
	test	eax, eax
	je	$LN92@xmlFARegEx
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	$LN92@xmlFARegEx

; 3304 : 			    (exec->comp->counters == NULL)) {
; 3305 : 			    exec->status = -1;
; 3306 : 			    goto error;
; 3307 : 			}
; 3308 : 			counter = &exec->comp->counters[trans->counter];
; 3309 : 			if (exec->counts[trans->counter] >= counter->max)

	mov	esi, DWORD PTR _trans$2$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR _atom$2$[ebp]
	cmp	edx, DWORD PTR [eax+edi*8+4]
	mov	edi, DWORD PTR _execval$5$[ebp]
	mov	edx, DWORD PTR _execval$[ebp+44]
	jge	$LN4@xmlFARegEx

; 3310 : 			    continue; /* for loop on transitions */
; 3311 : 
; 3312 : #ifdef DEBUG_REGEXP_EXEC
; 3313 : 			printf("Increasing count %d\n", trans->counter);
; 3314 : #endif
; 3315 : 			exec->counts[trans->counter]++;

	inc	DWORD PTR [ecx]
$LN34@xmlFARegEx:

; 3316 : 		    }
; 3317 : 		    if (exec->state->nbTrans > exec->transno + 1) {

	mov	edx, DWORD PTR _execval$1$[ebp]
	lea	eax, DWORD PTR [edi+1]
	cmp	DWORD PTR [edx+24], eax
	jle	SHORT $LN137@xmlFARegEx

; 3318 : 			xmlFARegExecSave(exec);

	lea	eax, DWORD PTR _execval$[ebp]
	push	eax
	call	_xmlFARegExecSave
	mov	eax, DWORD PTR _execval$[ebp+64]
	add	esp, 4
	mov	ecx, DWORD PTR _execval$[ebp+24]
	mov	edx, DWORD PTR _execval$[ebp+20]
	mov	ebx, DWORD PTR _execval$[ebp+56]
	mov	DWORD PTR _content$[ebp], eax
	mov	DWORD PTR _execval$5$[ebp], ecx
	mov	DWORD PTR _execval$1$[ebp], edx
	jmp	SHORT $LN38@xmlFARegEx
$LN137@xmlFARegEx:

; 3316 : 		    }
; 3317 : 		    if (exec->state->nbTrans > exec->transno + 1) {

	mov	ecx, DWORD PTR _execval$5$[ebp]
$LN38@xmlFARegEx:

; 3319 : 		    }
; 3320 : 		    exec->transcount = 1;

	mov	edi, 1
	mov	DWORD PTR _execval$[ebp+28], edi
$LL9@xmlFARegEx:

; 3321 : 		    do {
; 3322 : 			/*
; 3323 : 			 * Try to progress as much as possible on the input
; 3324 : 			 */
; 3325 : 			if (exec->transcount == atom->max) {

	cmp	edi, DWORD PTR [esi+16]
	je	SHORT $LN8@xmlFARegEx

; 3326 : 			    break;
; 3327 : 			}
; 3328 : 			exec->index += len;

	add	ebx, DWORD PTR _len$[ebp]

; 3329 : 			/*
; 3330 : 			 * End of input: stop here
; 3331 : 			 */
; 3332 : 			if (exec->inputString[exec->index] == 0) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR _execval$[ebp+56], ebx
	cmp	BYTE PTR [eax+ebx], 0
	je	SHORT $LN84@xmlFARegEx

; 3334 : 			    break;
; 3335 : 			}
; 3336 : 			if (exec->transcount >= atom->min) {

	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LN41@xmlFARegEx

; 3337 : 			    int transno = exec->transno;
; 3338 : 			    xmlRegStatePtr state = exec->state;
; 3339 : 
; 3340 : 			    /*
; 3341 : 			     * The transition is acceptable save it
; 3342 : 			     */
; 3343 : 			    exec->transno = -1; /* trick */
; 3344 : 			    exec->state = to;

	mov	eax, DWORD PTR _to$1$[ebp]
	mov	DWORD PTR _execval$[ebp+20], eax

; 3345 : 			    xmlFARegExecSave(exec);

	lea	eax, DWORD PTR _execval$[ebp]
	push	eax
	mov	DWORD PTR _execval$5$[ebp], ecx
	mov	DWORD PTR _execval$1$[ebp], edx
	mov	DWORD PTR _execval$[ebp+24], -1
	call	_xmlFARegExecSave

; 3346 : 			    exec->transno = transno;

	mov	eax, DWORD PTR _execval$5$[ebp]
	add	esp, 4

; 3347 : 			    exec->state = state;

	mov	ebx, DWORD PTR _execval$[ebp+56]
	mov	edi, DWORD PTR _execval$[ebp+28]
	mov	DWORD PTR _execval$[ebp+24], eax
	mov	eax, DWORD PTR _execval$1$[ebp]
	mov	DWORD PTR _execval$[ebp+20], eax
	mov	eax, DWORD PTR _execval$[ebp+64]
	mov	DWORD PTR _content$[ebp], eax
$LN41@xmlFARegEx:

; 3348 : 			}
; 3349 : 			codepoint = CUR_SCHAR(&(exec->inputString[exec->index]),

	lea	ecx, DWORD PTR _len$[ebp]
	add	eax, ebx
	push	ecx
	push	eax
	push	0
	call	_xmlStringCurrentChar

; 3350 : 				              len);
; 3351 : 			ret = xmlRegCheckCharacter(atom, codepoint);

	push	eax
	push	esi
	call	_xmlRegCheckCharacter

; 3352 : 			exec->transcount++;

	inc	edi
	mov	DWORD PTR _ret$1$[ebp], eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _execval$[ebp+28], edi

; 3353 : 		    } while (ret == 1);

	cmp	eax, 1
	jne	SHORT $LN8@xmlFARegEx
	mov	ecx, DWORD PTR _execval$5$[ebp]
	mov	edx, DWORD PTR _execval$1$[ebp]
	jmp	SHORT $LL9@xmlFARegEx
$LN84@xmlFARegEx:

; 3333 : 			    exec->index -= len;

	sub	ebx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _execval$[ebp+56], ebx
$LN8@xmlFARegEx:

; 3354 : 		    if (exec->transcount < atom->min)
; 3355 : 			ret = 0;
; 3356 : 
; 3357 : 		    /*
; 3358 : 		     * If the last check failed but one transition was found
; 3359 : 		     * possible, rollback
; 3360 : 		     */
; 3361 : 		    if (ret < 0)

	xor	eax, eax
	cmp	edi, DWORD PTR [esi+12]
	cmovge	eax, DWORD PTR _ret$1$[ebp]

; 3362 : 			ret = 0;
; 3363 : 		    if (ret == 0) {

	xor	ecx, ecx
	test	eax, eax
	cmovns	ecx, eax
	test	ecx, ecx
	je	$rollback$158

; 3364 : 			goto rollback;
; 3365 : 		    }
; 3366 : 		    if (trans->counter >= 0) {

	mov	eax, DWORD PTR _trans$2$[ebp]
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	js	SHORT $LN45@xmlFARegEx

; 3367 : 			if (exec->counts == NULL) {

	mov	edx, DWORD PTR _execval$[ebp+44]
	test	edx, edx
	je	$LN92@xmlFARegEx

; 3368 : 			    exec->status = -1;
; 3369 : 			    goto error;
; 3370 : 			}
; 3371 : #ifdef DEBUG_REGEXP_EXEC
; 3372 : 			printf("Decreasing count %d\n", trans->counter);
; 3373 : #endif
; 3374 : 			exec->counts[trans->counter]--;

	dec	DWORD PTR [edx+eax*4]
$LN45@xmlFARegEx:

; 3375 : 		    }

	mov	eax, DWORD PTR _execval$[ebp+8]
	mov	edi, DWORD PTR _execval$5$[ebp]
	mov	DWORD PTR _comp$[ebp], eax
$LN132@xmlFARegEx:

; 3387 : 	        /* another spot to match when minOccurs is 0 */
; 3388 : 		exec->transcount = 1;
; 3389 : 		len = 0;
; 3390 : 		ret = 1;
; 3391 : 	    }
; 3392 : 	    if (ret == 1) {

	cmp	ecx, 1
	je	SHORT $LN148@xmlFARegEx

; 3445 : 	    } else if (ret < 0) {

	test	ecx, ecx
	js	$LN91@xmlFARegEx
$LN141@xmlFARegEx:

; 3254 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	mov	edx, DWORD PTR _execval$[ebp+44]
	jmp	$LN4@xmlFARegEx
$LN32@xmlFARegEx:

; 3376 : 		} else if ((ret == 0) && (atom->min == 0) && (atom->max > 0)) {

	test	ecx, ecx
	jne	SHORT $LN132@xmlFARegEx
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN141@xmlFARegEx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN141@xmlFARegEx

; 3377 : 		    /*
; 3378 : 		     * we don't match on the codepoint, but minOccurs of 0
; 3379 : 		     * says that's ok.  Setting len to 0 inhibits stepping
; 3380 : 		     * over the codepoint.
; 3381 : 		     */
; 3382 : 		    exec->transcount = 1;
; 3383 : 		    len = 0;
; 3384 : 		    ret = 1;
; 3385 : 		}

	jmp	SHORT $LN155@xmlFARegEx
$LN30@xmlFARegEx:

; 3386 : 	    } else if ((atom->min == 0) && (atom->max > 0)) {

	cmp	DWORD PTR [esi+12], 0
	jne	$LN4@xmlFARegEx
	cmp	DWORD PTR [esi+16], 0
	jle	$LN4@xmlFARegEx
$LN155@xmlFARegEx:

; 3393 : 		if ((trans->nd == 1) ||

	mov	DWORD PTR _len$[ebp], 0
	mov	DWORD PTR _execval$[ebp+28], 1
$LN148@xmlFARegEx:
	mov	eax, DWORD PTR _deter$1$[ebp]
$LN105@xmlFARegEx:
	mov	esi, DWORD PTR _trans$2$[ebp]
	cmp	DWORD PTR [esi+16], 1
	je	SHORT $LN111@xmlFARegEx
	cmp	DWORD PTR [esi+12], 0
	jl	SHORT $LN145@xmlFARegEx
	test	eax, eax
	jne	SHORT $LN145@xmlFARegEx
	mov	ecx, DWORD PTR _execval$1$[ebp]
	lea	eax, DWORD PTR [edi+1]
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN145@xmlFARegEx
$LN111@xmlFARegEx:

; 3394 : 		    ((trans->count >= 0) && (deter == 0) &&
; 3395 : 		     (exec->state->nbTrans > exec->transno + 1))) {
; 3396 : #ifdef DEBUG_REGEXP_EXEC
; 3397 : 		    if (trans->nd == 1)
; 3398 : 		        printf("Saving on nd transition atom %d for %c at %d\n",
; 3399 : 			       trans->atom->no, codepoint, exec->index);
; 3400 : 		    else
; 3401 : 		        printf("Saving on counted transition count %d for %c at %d\n",
; 3402 : 			       trans->count, codepoint, exec->index);
; 3403 : #endif
; 3404 : 		    xmlFARegExecSave(exec);

	lea	eax, DWORD PTR _execval$[ebp]
	push	eax
	call	_xmlFARegExecSave
	mov	eax, DWORD PTR _execval$[ebp+64]
	add	esp, 4
	mov	ebx, DWORD PTR _execval$[ebp+56]
	mov	edi, DWORD PTR _execval$[ebp+24]
	mov	DWORD PTR _content$[ebp], eax
	mov	eax, DWORD PTR _execval$[ebp+20]
	mov	DWORD PTR _execval$1$[ebp], eax
	mov	eax, DWORD PTR _execval$[ebp+8]
	mov	DWORD PTR _comp$[ebp], eax
	jmp	SHORT $LN51@xmlFARegEx
$LN145@xmlFARegEx:

; 3405 : 		}
; 3406 : 		if (trans->counter >= 0) {

	mov	eax, DWORD PTR _comp$[ebp]
$LN51@xmlFARegEx:
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _execval$[ebp+44]
	test	ecx, ecx
	js	SHORT $LN53@xmlFARegEx

; 3407 : 		    xmlRegCounterPtr counter;
; 3408 : 
; 3409 :                     /* make sure we don't go over the counter maximum value */
; 3410 : 		    if ((exec->counts == NULL) ||
; 3411 : 			(exec->comp == NULL) ||

	test	edx, edx
	je	$LN92@xmlFARegEx
	test	eax, eax
	je	$LN92@xmlFARegEx
	mov	esi, DWORD PTR [eax+24]
	test	esi, esi
	je	$LN92@xmlFARegEx

; 3412 : 			(exec->comp->counters == NULL)) {
; 3413 : 			exec->status = -1;
; 3414 : 			goto error;
; 3415 : 		    }
; 3416 : 		    counter = &exec->comp->counters[trans->counter];
; 3417 : 		    if (exec->counts[trans->counter] >= counter->max)

	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR [esi+ecx*8+4]
	jl	SHORT $LN56@xmlFARegEx
$LN4@xmlFARegEx:

; 3254 : 	for (;exec->transno < exec->state->nbTrans;exec->transno++) {

	mov	eax, DWORD PTR _execval$1$[ebp]
	inc	edi
	mov	DWORD PTR _execval$5$[ebp], edi
	mov	DWORD PTR _execval$[ebp+24], edi
	cmp	edi, DWORD PTR [eax+24]
	jl	$LL6@xmlFARegEx
	jmp	SHORT $LN135@xmlFARegEx
$LN91@xmlFARegEx:

; 3446 : 		exec->status = -4;

	mov	DWORD PTR _execval$[ebp], -4		; fffffffcH
	jmp	SHORT $LN154@xmlFARegEx
$LN56@xmlFARegEx:

; 3418 : 			continue; /* for loop on transitions */
; 3419 : #ifdef DEBUG_REGEXP_EXEC
; 3420 : 		    printf("Increasing count %d\n", trans->counter);
; 3421 : #endif
; 3422 : 		    exec->counts[trans->counter]++;

	inc	DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR _trans$2$[ebp]
$LN53@xmlFARegEx:

; 3423 : 		}
; 3424 : 		if ((trans->count >= 0) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 1193045				; 00123455H
	ja	SHORT $LN57@xmlFARegEx

; 3425 : 		    (trans->count < REGEXP_ALL_COUNTER)) {
; 3426 : 		    if (exec->counts == NULL) {

	test	edx, edx
	je	$LN92@xmlFARegEx

; 3428 : 			goto error;
; 3429 : 		    }
; 3430 : #ifdef DEBUG_REGEXP_EXEC
; 3431 : 		    printf("resetting count %d on transition\n",
; 3432 : 		           trans->count);
; 3433 : #endif
; 3434 : 		    exec->counts[trans->count] = 0;

	mov	DWORD PTR [edx+eax*4], 0
$LN57@xmlFARegEx:

; 3435 : 		}
; 3436 : #ifdef DEBUG_REGEXP_EXEC
; 3437 : 		printf("entering state %d\n", trans->to);
; 3438 : #endif
; 3439 : 		exec->state = comp->states[trans->to];

	mov	eax, DWORD PTR tv1144[ebp]

; 3440 : 		exec->transno = 0;

	xor	edi, edi
	mov	ecx, DWORD PTR [esi+4]

; 3441 : 		if (trans->atom != NULL) {

	cmp	DWORD PTR [esi], edi
	mov	esi, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _execval$5$[ebp], edi
	mov	DWORD PTR _execval$[ebp+24], edi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _execval$1$[ebp], eax
	mov	DWORD PTR _execval$[ebp+20], eax
	je	SHORT $progress$159

; 3442 : 		    exec->index += len;

	add	ebx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _execval$[ebp+56], ebx

; 3443 : 		}
; 3444 : 		goto progress;

	jmp	SHORT $progress$159
$LN86@xmlFARegEx:

; 3283 : 		fprintf(stderr, "epsilon transition left at runtime\n");

	push	OFFSET ??_C@_0CE@CMNJHAKA@epsilon?5transition?5left?5at?5runt@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 3284 : 		exec->status = -2;

	mov	DWORD PTR _execval$[ebp], -2		; fffffffeH
$LN154@xmlFARegEx:

; 3447 : 		break;
; 3448 : 	    }
; 3449 : 	}
; 3450 : 	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {

	mov	eax, DWORD PTR _execval$1$[ebp]
$LN135@xmlFARegEx:
	test	edi, edi
	jne	SHORT $rollback$158
	cmp	DWORD PTR [eax+24], edi
	jne	SHORT $LN146@xmlFARegEx
$rollback$158:

; 3451 : rollback:
; 3452 : 	    /*
; 3453 : 	     * Failed to find a way out
; 3454 : 	     */
; 3455 : 	    exec->determinist = 0;
; 3456 : #ifdef DEBUG_REGEXP_EXEC
; 3457 : 	    printf("rollback from state %d on %d:%c\n", exec->state->no,
; 3458 : 	           codepoint,codepoint);
; 3459 : #endif
; 3460 : 	    xmlFARegExecRollBack(exec);

	lea	eax, DWORD PTR _execval$[ebp]
	mov	DWORD PTR _execval$[ebp+4], 0
	push	eax
	call	_xmlFARegExecRollBack
	mov	esi, DWORD PTR _execval$[ebp+64]
	add	esp, 4
	mov	edi, DWORD PTR _execval$[ebp+24]
	mov	eax, DWORD PTR _execval$[ebp+20]
	mov	ecx, DWORD PTR _execval$[ebp+8]
	mov	ebx, DWORD PTR _execval$[ebp+56]
	mov	DWORD PTR _content$[ebp], esi
	mov	DWORD PTR _execval$5$[ebp], edi
	mov	DWORD PTR _execval$1$[ebp], eax
	mov	DWORD PTR _comp$[ebp], ecx
	jmp	SHORT $progress$159
$LN146@xmlFARegEx:

; 3447 : 		break;
; 3448 : 	    }
; 3449 : 	}
; 3450 : 	if ((exec->transno != 0) || (exec->state->nbTrans == 0)) {

	mov	esi, DWORD PTR _content$[ebp]
$progress$159:

; 3222 :     while ((exec->status == 0) && (exec->state != NULL) &&

	cmp	DWORD PTR _execval$[ebp], 0
	jne	SHORT $error$157
	mov	edx, DWORD PTR _execval$[ebp+44]
	jmp	$LL2@xmlFARegEx
$LN92@xmlFARegEx:

; 3427 : 		        exec->status = -1;

	mov	DWORD PTR _execval$[ebp], -1
$error$157:

; 3461 : 	}
; 3462 : progress:
; 3463 : 	continue;
; 3464 :     }
; 3465 : error:
; 3466 :     if (exec->rollbacks != NULL) {

	mov	eax, DWORD PTR _execval$[ebp+40]
	mov	esi, DWORD PTR _execval$[ebp+44]
	test	eax, eax
	je	SHORT $LN63@xmlFARegEx

; 3467 : 	if (exec->counts != NULL) {

	test	esi, esi
	je	SHORT $LN11@xmlFARegEx

; 3468 : 	    int i;
; 3469 : 
; 3470 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	mov	ebx, DWORD PTR _execval$[ebp+32]
	test	ebx, ebx
	jle	SHORT $LN11@xmlFARegEx
	lea	edi, DWORD PTR [eax+12]
	npad	3
$LL12@xmlFARegEx:

; 3471 : 		if (exec->rollbacks[i].counts != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@xmlFARegEx

; 3472 : 		    xmlFree(exec->rollbacks[i].counts);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlFARegEx:

; 3468 : 	    int i;
; 3469 : 
; 3470 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	add	edi, 16					; 00000010H
	sub	ebx, 1
	jne	SHORT $LL12@xmlFARegEx
	mov	eax, DWORD PTR _execval$[ebp+40]
$LN11@xmlFARegEx:

; 3473 : 	}
; 3474 : 	xmlFree(exec->rollbacks);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN63@xmlFARegEx:

; 3475 :     }
; 3476 :     if (exec->state == NULL)

	cmp	DWORD PTR _execval$1$[ebp], 0
	je	$LN112@xmlFARegEx

; 3477 :         return(-1);
; 3478 :     if (exec->counts != NULL)

	test	esi, esi
	je	SHORT $LN67@xmlFARegEx

; 3479 : 	xmlFree(exec->counts);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN67@xmlFARegEx:

; 3480 :     if (exec->status == 0)

	cmp	DWORD PTR _execval$[ebp], 0
	jne	SHORT $LN68@xmlFARegEx

; 3488 : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@xmlFARegEx:

; 3481 : 	return(1);
; 3482 :     if (exec->status == -1) {

	cmp	DWORD PTR _execval$[ebp], -1
	jne	SHORT $LN69@xmlFARegEx

; 3483 : 	if (exec->nbPush > MAX_PUSH)

	cmp	DWORD PTR _execval$[ebp+88], 10000000	; 00989680H
	jg	$LN112@xmlFARegEx

; 3488 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@xmlFARegEx:

; 3484 : 	    return(-1);
; 3485 : 	return(0);
; 3486 :     }
; 3487 :     return(exec->status);

	mov	eax, DWORD PTR _execval$[ebp]
	pop	edi

; 3488 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFARegExec ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecRollBack
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_xmlFARegExecRollBack PROC				; COMDAT

; 3157 : xmlFARegExecRollBack(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exec$[ebp]
	mov	edx, DWORD PTR [esi+36]
	test	edx, edx
	jg	SHORT $LN2@xmlFARegEx

; 3158 :     if (exec->nbRollbacks <= 0) {
; 3159 : 	exec->status = -1;

	mov	DWORD PTR [esi], -1
	pop	esi

; 3177 : 	       exec->comp->nbCounters * sizeof(int));
; 3178 : 	}
; 3179 :     }
; 3180 : 
; 3181 : #ifdef DEBUG_REGEXP_EXEC
; 3182 :     printf("restored ");
; 3183 :     xmlFARegDebugExec(exec);
; 3184 : #endif
; 3185 : }

	pop	ebp
	ret	0
$LN2@xmlFARegEx:

; 3160 : #ifdef DEBUG_REGEXP_EXEC
; 3161 : 	printf("rollback failed on empty stack\n");
; 3162 : #endif
; 3163 : 	return;
; 3164 :     }
; 3165 :     exec->nbRollbacks--;
; 3166 :     exec->state = exec->rollbacks[exec->nbRollbacks].state;

	mov	ecx, DWORD PTR [esi+40]
	dec	edx
	mov	DWORD PTR [esi+36], edx
	mov	eax, edx
	add	eax, eax

; 3167 :     exec->index = exec->rollbacks[exec->nbRollbacks].index;

	add	edx, edx
	mov	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR [esi+56], eax

; 3168 :     exec->transno = exec->rollbacks[exec->nbRollbacks].nextbranch;

	mov	eax, DWORD PTR [ecx+edx*8+8]
	mov	DWORD PTR [esi+24], eax

; 3169 :     if (exec->comp->nbCounters > 0) {

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jle	SHORT $LN5@xmlFARegEx

; 3170 : 	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	edx, DWORD PTR [ecx+edx*8+12]
	test	edx, edx
	jne	SHORT $LN4@xmlFARegEx

; 3171 : 	    fprintf(stderr, "exec save: allocation failed");

	push	OFFSET ??_C@_0BN@CPBANDJM@exec?5save?3?5allocation?5failed@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 3172 : 	    exec->status = -6;

	mov	DWORD PTR [esi], -6			; fffffffaH
	pop	esi

; 3177 : 	       exec->comp->nbCounters * sizeof(int));
; 3178 : 	}
; 3179 :     }
; 3180 : 
; 3181 : #ifdef DEBUG_REGEXP_EXEC
; 3182 :     printf("restored ");
; 3183 :     xmlFARegDebugExec(exec);
; 3184 : #endif
; 3185 : }

	pop	ebp
	ret	0
$LN4@xmlFARegEx:

; 3173 : 	    return;
; 3174 : 	}
; 3175 : 	if (exec->counts) {

	mov	ecx, DWORD PTR [esi+44]
	test	ecx, ecx
	je	SHORT $LN5@xmlFARegEx

; 3176 : 	    memcpy(exec->counts, exec->rollbacks[exec->nbRollbacks].counts,

	shl	eax, 2
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@xmlFARegEx:
	pop	esi

; 3177 : 	       exec->comp->nbCounters * sizeof(int));
; 3178 : 	}
; 3179 :     }
; 3180 : 
; 3181 : #ifdef DEBUG_REGEXP_EXEC
; 3182 :     printf("restored ");
; 3183 :     xmlFARegDebugExec(exec);
; 3184 : #endif
; 3185 : }

	pop	ebp
	ret	0
_xmlFARegExecRollBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARegExecSave
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_xmlFARegExecSave PROC					; COMDAT

; 3096 : xmlFARegExecSave(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exec$[ebp]
	mov	eax, DWORD PTR [esi+88]
	cmp	eax, 10000000				; 00989680H
	jg	$LN1@xmlFARegEx

; 3097 : #ifdef DEBUG_REGEXP_EXEC
; 3098 :     printf("saving ");
; 3099 :     exec->transno++;
; 3100 :     xmlFARegDebugExec(exec);
; 3101 :     exec->transno--;
; 3102 : #endif
; 3103 : #ifdef MAX_PUSH
; 3104 :     if (exec->nbPush > MAX_PUSH) {
; 3105 :         return;
; 3106 :     }
; 3107 :     exec->nbPush++;
; 3108 : #endif
; 3109 : 
; 3110 :     if (exec->maxRollbacks == 0) {

	push	edi
	mov	edi, DWORD PTR [esi+32]
	inc	eax
	mov	DWORD PTR [esi+88], eax
	test	edi, edi
	jne	SHORT $LN3@xmlFARegEx

; 3111 : 	exec->maxRollbacks = 4;
; 3112 : 	exec->rollbacks = (xmlRegExecRollback *) xmlMalloc(exec->maxRollbacks *

	push	64					; 00000040H
	mov	DWORD PTR [esi+32], 4
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+40], ecx

; 3113 : 		                             sizeof(xmlRegExecRollback));
; 3114 : 	if (exec->rollbacks == NULL) {

	test	ecx, ecx
	jne	SHORT $LN5@xmlFARegEx

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3115 : 	    xmlRegexpErrMemory(NULL, "saving regexp");
; 3116 : 	    exec->maxRollbacks = 0;

	mov	DWORD PTR [esi+32], edi
	pop	edi
	pop	esi

; 3154 : }

	pop	ebp
	ret	0
$LN5@xmlFARegEx:

; 3117 : 	    return;
; 3118 : 	}
; 3119 : 	memset(exec->rollbacks, 0,

	mov	eax, DWORD PTR [esi+32]
	shl	eax, 4
	push	eax
	push	0
	push	ecx
	jmp	SHORT $LN21@xmlFARegEx
$LN3@xmlFARegEx:

; 3120 : 	       exec->maxRollbacks * sizeof(xmlRegExecRollback));
; 3121 :     } else if (exec->nbRollbacks >= exec->maxRollbacks) {

	cmp	DWORD PTR [esi+36], edi
	jl	SHORT $LN6@xmlFARegEx

; 3122 : 	xmlRegExecRollback *tmp;
; 3123 : 	int len = exec->maxRollbacks;
; 3124 : 
; 3125 : 	exec->maxRollbacks *= 2;

	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR [esi+32], eax

; 3126 : 	tmp = (xmlRegExecRollback *) xmlRealloc(exec->rollbacks,

	shl	eax, 4
	push	eax
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 3127 : 			exec->maxRollbacks * sizeof(xmlRegExecRollback));
; 3128 : 	if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlFARegEx

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 3129 : 	    xmlRegexpErrMemory(NULL, "saving regexp");
; 3130 : 	    exec->maxRollbacks /= 2;

	mov	eax, DWORD PTR [esi+32]

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	add	esp, 68					; 00000044H

; 3129 : 	    xmlRegexpErrMemory(NULL, "saving regexp");
; 3130 : 	    exec->maxRollbacks /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	pop	edi
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 3154 : }

	pop	ebp
	ret	0
$LN7@xmlFARegEx:

; 3131 : 	    return;
; 3132 : 	}
; 3133 : 	exec->rollbacks = tmp;
; 3134 : 	tmp = &exec->rollbacks[len];
; 3135 : 	memset(tmp, 0, (exec->maxRollbacks - len) * sizeof(xmlRegExecRollback));

	mov	eax, DWORD PTR [esi+32]
	sub	eax, edi
	mov	DWORD PTR [esi+40], ecx
	shl	eax, 4
	push	eax
	shl	edi, 4
	push	0
	add	edi, ecx
	push	edi
$LN21@xmlFARegEx:

; 3136 :     }
; 3137 :     exec->rollbacks[exec->nbRollbacks].state = exec->state;

	call	_memset
	add	esp, 12					; 0000000cH
$LN6@xmlFARegEx:
	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
	add	edx, edx
	mov	eax, DWORD PTR [esi+20]
	push	ebx
	mov	DWORD PTR [ecx+edx*8], eax

; 3138 :     exec->rollbacks[exec->nbRollbacks].index = exec->index;

	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
	add	edx, edx
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 3139 :     exec->rollbacks[exec->nbRollbacks].nextbranch = exec->transno + 1;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+24]
	add	ecx, ecx
	mov	eax, DWORD PTR [esi+40]
	inc	edx
	mov	DWORD PTR [eax+ecx*8+8], edx

; 3140 :     if (exec->comp->nbCounters > 0) {

	mov	edi, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [edi+20]
	test	ebx, ebx
	jle	SHORT $LN8@xmlFARegEx

; 3141 : 	if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, ecx
	mov	edx, DWORD PTR [esi+40]
	add	eax, eax
	cmp	DWORD PTR [edx+eax*8+12], 0
	jne	SHORT $LN10@xmlFARegEx

; 3142 : 	    exec->rollbacks[exec->nbRollbacks].counts = (int *)

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edx, DWORD PTR [esi+36]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+40]
	add	edx, edx
	mov	DWORD PTR [ecx+edx*8+12], eax

; 3143 : 		xmlMalloc(exec->comp->nbCounters * sizeof(int));
; 3144 : 	    if (exec->rollbacks[exec->nbRollbacks].counts == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, ecx
	mov	edx, DWORD PTR [esi+40]
	add	eax, eax
	cmp	DWORD PTR [edx+eax*8+12], 0
	jne	SHORT $LN18@xmlFARegEx

; 3145 : 		xmlRegexpErrMemory(NULL, "saving regexp");

	push	OFFSET ??_C@_0O@PEGCJGLF@saving?5regexp@
	push	0
	call	_xmlRegexpErrMemory
	add	esp, 8

; 3146 : 		exec->status = -5;

	mov	DWORD PTR [esi], -5			; fffffffbH
	pop	ebx
	pop	edi
	pop	esi

; 3154 : }

	pop	ebp
	ret	0
$LN18@xmlFARegEx:
	mov	edi, DWORD PTR [esi+8]
$LN10@xmlFARegEx:

; 3147 : 		return;
; 3148 : 	    }
; 3149 : 	}
; 3150 : 	memcpy(exec->rollbacks[exec->nbRollbacks].counts, exec->counts,

	mov	eax, DWORD PTR [edi+20]
	add	ecx, ecx
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+44]
	push	DWORD PTR [edx+ecx*8+12]
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@xmlFARegEx:

; 3151 : 	       exec->comp->nbCounters * sizeof(int));
; 3152 :     }
; 3153 :     exec->nbRollbacks++;

	inc	DWORD PTR [esi+36]
	pop	ebx
	pop	edi
$LN1@xmlFARegEx:
	pop	esi

; 3154 : }

	pop	ebp
	ret	0
_xmlFARegExecSave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFARecurseDeterminism
_TEXT	SEGMENT
tv290 = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nbTrans$1$ = 12					; size = 4
_state$ = 12						; size = 4
_to$ = 16						; size = 4
_atom$ = 20						; size = 4
_xmlFARecurseDeterminism PROC				; COMDAT

; 2589 : 	                 int to, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	mov	ecx, 1
	mov	DWORD PTR _ret$1$[ebp], ecx
	test	edi, edi
	je	$LN18@xmlFARecur

; 2590 :     int ret = 1;
; 2591 :     int res;
; 2592 :     int transnr, nbTrans;
; 2593 :     xmlRegTransPtr t1;
; 2594 :     int deep = 1;
; 2595 : 
; 2596 :     if (state == NULL)
; 2597 : 	return(ret);
; 2598 :     if (state->markd == XML_REGEXP_MARK_VISITED)

	cmp	DWORD PTR [edi+8], 2
	je	$LN18@xmlFARecur

; 2602 :         deep = 0;
; 2603 : 
; 2604 :     /*
; 2605 :      * don't recurse on transitions potentially added in the course of
; 2606 :      * the elimination.
; 2607 :      */
; 2608 :     nbTrans = state->nbTrans;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+76]
	not	eax
	and	eax, ecx
	mov	DWORD PTR tv290[ebp], eax
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _nbTrans$1$[ebp], eax

; 2609 :     for (transnr = 0;transnr < nbTrans;transnr++) {

	test	eax, eax
	jle	$LN18@xmlFARecur

; 2599 : 	return(ret);
; 2600 : 
; 2601 :     if (ctxt->flags & AM_AUTOMATA_RNG)

	push	ebx
	push	esi
	xor	ebx, ebx
	npad	3
$LL4@xmlFARecur:

; 2610 : 	t1 = &(state->trans[transnr]);

	mov	esi, DWORD PTR [edi+28]
	add	esi, ebx

; 2611 : 	/*
; 2612 : 	 * check transitions conflicting with the one looked at
; 2613 : 	 */
; 2614 : 	if (t1->atom == NULL) {

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN8@xmlFARecur

; 2615 : 	    if (t1->to < 0)

	test	eax, eax
	js	SHORT $LN2@xmlFARecur

; 2616 : 		continue;
; 2617 : 	    state->markd = XML_REGEXP_MARK_VISITED;
; 2618 : 	    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _atom$[ebp]
	mov	DWORD PTR [edi+8], 2
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+52]
	push	DWORD PTR _to$[ebp]
	push	DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlFARecurseDeterminism
	add	esp, 16					; 00000010H

; 2619 : 		                           to, atom);
; 2620 : 	    state->markd = 0;

	mov	DWORD PTR [edi+8], 0

; 2621 : 	    if (res == 0) {

	test	eax, eax
	jne	SHORT $LN20@xmlFARecur

; 2622 : 	        ret = 0;

	xor	ecx, ecx
	mov	DWORD PTR _ret$1$[ebp], ecx

; 2623 : 		/* t1->nd = 1; */
; 2624 : 	    }
; 2625 : 	    continue;

	jmp	SHORT $LN2@xmlFARecur
$LN8@xmlFARecur:

; 2626 : 	}
; 2627 : 	if (t1->to != to)

	cmp	eax, DWORD PTR _to$[ebp]
	jne	SHORT $LN2@xmlFARecur

; 2628 : 	    continue;
; 2629 : 	if (xmlFACompareAtoms(t1->atom, atom, deep)) {

	push	DWORD PTR tv290[ebp]
	push	DWORD PTR _atom$[ebp]
	push	edx
	call	_xmlFACompareAtoms
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@xmlFARecur

; 2630 : 	    ret = 0;

	xor	ecx, ecx

; 2631 : 	    /* mark the transition as non-deterministic */
; 2632 : 	    t1->nd = 1;

	mov	DWORD PTR [esi+16], 1
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	SHORT $LN2@xmlFARecur
$LN20@xmlFARecur:

; 2609 :     for (transnr = 0;transnr < nbTrans;transnr++) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
$LN2@xmlFARecur:
	add	ebx, 20					; 00000014H
	sub	DWORD PTR _nbTrans$1$[ebp], 1
	jne	SHORT $LL4@xmlFARecur
	pop	esi
	pop	ebx
$LN18@xmlFARecur:

; 2633 : 	}
; 2634 :     }
; 2635 :     return(ret);
; 2636 : }

	mov	eax, ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFARecurseDeterminism ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareAtoms
_TEXT	SEGMENT
_i$1$ = 8						; size = 4
_atom1$ = 8						; size = 4
_atom2$ = 12						; size = 4
_deep$ = 16						; size = 4
_xmlFACompareAtoms PROC					; COMDAT

; 2501 : xmlFACompareAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _atom2$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	esi
	mov	esi, DWORD PTR _atom1$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, 1
	cmp	esi, ebx
	je	$LN14@xmlFACompa

; 2502 :     int ret = 1;
; 2503 : 
; 2504 :     if (atom1 == atom2)
; 2505 : 	return(1);
; 2506 :     if ((atom1 == NULL) || (atom2 == NULL))

	test	esi, esi
	je	$LN12@xmlFACompa
	test	ebx, ebx
	je	$LN12@xmlFACompa

; 2507 : 	return(0);
; 2508 : 
; 2509 :     if ((atom1->type == XML_REGEXP_ANYCHAR) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 6
	je	$LN14@xmlFACompa
	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, 6
	je	$LN14@xmlFACompa

; 2510 :         (atom2->type == XML_REGEXP_ANYCHAR))
; 2511 : 	return(1);
; 2512 : 
; 2513 :     if (atom1->type > atom2->type) {
; 2514 : 	xmlRegAtomPtr tmp;
; 2515 : 	tmp = atom1;
; 2516 : 	atom1 = atom2;
; 2517 : 	atom2 = tmp;
; 2518 :     }
; 2519 :     if (atom1->type != atom2->type) {

	cmp	eax, ecx
	mov	edi, esi
	cmovle	edi, ebx
	cmovle	ebx, esi
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [edi+4]
	cmp	eax, ecx
	je	SHORT $LN44@xmlFACompa

; 2520 :         ret = xmlFACompareAtomTypes(atom1->type, atom2->type);

	push	ecx
	push	eax
	call	_xmlFACompareAtomTypes
	mov	edx, eax
	add	esp, 8

; 2521 : 	/* if they can't intersect at the type level break now */
; 2522 : 	if (ret == 0)

	test	edx, edx
	je	$LN12@xmlFACompa
$LN44@xmlFACompa:

; 2523 : 	    return(0);
; 2524 :     }
; 2525 :     switch (atom1->type) {

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, 1
	sub	eax, 2
	je	$LN22@xmlFACompa
	sub	eax, esi
	je	SHORT $LN26@xmlFACompa
	sub	eax, 2
	jne	$not_determinist$48

; 2526 :         case XML_REGEXP_STRING:
; 2527 :             if (!deep)

	cmp	DWORD PTR _deep$[ebp], eax
	jne	SHORT $LN19@xmlFACompa

; 2528 :                 ret = (atom1->valuep != atom2->valuep);

	mov	eax, DWORD PTR [ebx+20]
	xor	edx, edx
	cmp	eax, DWORD PTR [edi+20]
	setne	dl
	jmp	$done$49
$LN19@xmlFACompa:

; 2529 :             else
; 2530 :                 ret = xmlRegStrEqualWildcard((xmlChar *)atom1->valuep,

	push	DWORD PTR [edi+20]
	push	DWORD PTR [ebx+20]
	call	_xmlRegStrEqualWildcard
	add	esp, 8
	mov	edx, eax

; 2531 :                                              (xmlChar *)atom2->valuep);
; 2532 : 	    break;

	jmp	SHORT $done$49
$LN26@xmlFACompa:

; 2541 : 		    ret = 1;
; 2542 : 	    }
; 2543 : 	    break;
; 2544 :         case XML_REGEXP_RANGES:
; 2545 : 	    if (atom2->type == XML_REGEXP_RANGES) {

	cmp	DWORD PTR [edi+4], 3
	jne	SHORT $done$49

; 2546 : 	        int i, j, res;
; 2547 : 		xmlRegRangePtr r1, r2;
; 2548 : 
; 2549 : 		/*
; 2550 : 		 * need to check that none of the ranges eventually matches
; 2551 : 		 */
; 2552 : 		for (i = 0;i < atom1->nbRanges;i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [ebx+52], ecx
	jle	SHORT $LN46@xmlFACompa
$LL6@xmlFACompa:

; 2553 : 		    for (j = 0;j < atom2->nbRanges;j++) {

	xor	esi, esi
	cmp	DWORD PTR [edi+52], esi
	jle	SHORT $LN4@xmlFACompa
	npad	1
$LL9@xmlFACompa:

; 2554 : 			r1 = atom1->ranges[i];

	mov	eax, DWORD PTR [ebx+56]
	mov	ecx, DWORD PTR [eax+ecx*4]

; 2555 : 			r2 = atom2->ranges[j];

	mov	eax, DWORD PTR [edi+56]

; 2556 : 			res = xmlFACompareRanges(r1, r2);

	push	DWORD PTR [eax+esi*4]
	push	ecx
	call	_xmlFACompareRanges
	add	esp, 8

; 2557 : 			if (res == 1) {

	cmp	eax, 1
	je	SHORT $LN35@xmlFACompa

; 2553 : 		    for (j = 0;j < atom2->nbRanges;j++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	esi
	cmp	esi, DWORD PTR [edi+52]
	jl	SHORT $LL9@xmlFACompa
$LN4@xmlFACompa:

; 2546 : 	        int i, j, res;
; 2547 : 		xmlRegRangePtr r1, r2;
; 2548 : 
; 2549 : 		/*
; 2550 : 		 * need to check that none of the ranges eventually matches
; 2551 : 		 */
; 2552 : 		for (i = 0;i < atom1->nbRanges;i++) {

	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+52]
	jl	SHORT $LL6@xmlFACompa
$LN46@xmlFACompa:

; 2560 : 			}
; 2561 : 		    }
; 2562 : 		}
; 2563 : 		ret = 0;

	xor	edx, edx

; 2564 : 	    }
; 2565 : 	    break;

	jmp	SHORT $done$49
$LN35@xmlFACompa:

; 2558 : 			    ret = 1;

	mov	edx, 1

; 2559 : 			    goto done;

	jmp	SHORT $done$49
$LN22@xmlFACompa:

; 2533 :         case XML_REGEXP_EPSILON:
; 2534 : 	    goto not_determinist;
; 2535 :         case XML_REGEXP_CHARVAL:
; 2536 : 	    if (atom2->type == XML_REGEXP_CHARVAL) {

	cmp	DWORD PTR [edi+4], 2
	mov	eax, DWORD PTR [ebx+32]
	jne	SHORT $LN23@xmlFACompa

; 2537 : 		ret = (atom1->codepoint == atom2->codepoint);

	xor	edx, edx
	cmp	eax, DWORD PTR [edi+32]
	sete	dl

; 2538 : 	    } else {

	jmp	SHORT $done$49
$LN23@xmlFACompa:

; 2539 : 	        ret = xmlRegCheckCharacter(atom2, atom1->codepoint);

	push	eax
	push	edi
	call	_xmlRegCheckCharacter
	mov	edx, eax
	add	esp, 8

; 2540 : 		if (ret < 0)

	test	edx, edx
	cmovs	edx, esi
$done$49:

; 2566 : 	default:
; 2567 : 	    goto not_determinist;
; 2568 :     }
; 2569 : done:
; 2570 :     if (atom1->neg != atom2->neg) {

	mov	eax, DWORD PTR [ebx+28]
	cmp	eax, DWORD PTR [edi+28]
	je	SHORT $LN30@xmlFACompa

; 2571 :         ret = !ret;

	xor	ecx, ecx
	test	edx, edx
	sete	cl
	mov	edx, ecx
$LN30@xmlFACompa:

; 2572 :     }
; 2573 :     if (ret == 0)

	test	edx, edx
	je	SHORT $LN12@xmlFACompa
	mov	esi, 1
$not_determinist$48:
	pop	edi

; 2574 :         return(0);
; 2575 : not_determinist:
; 2576 :     return(1);

	mov	eax, esi

; 2577 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlFACompa:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlFACompa:
	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
_xmlFACompareAtoms ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEqualAtoms
_TEXT	SEGMENT
_atom1$ = 8						; size = 4
_atom2$ = 12						; size = 4
_deep$ = 16						; size = 4
_xmlFAEqualAtoms PROC					; COMDAT

; 2456 : xmlFAEqualAtoms(xmlRegAtomPtr atom1, xmlRegAtomPtr atom2, int deep) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _atom1$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _atom2$[ebp]
	cmp	eax, edx
	jne	SHORT $LN4@xmlFAEqual

; 2457 :     int ret = 0;
; 2458 : 
; 2459 :     if (atom1 == atom2)
; 2460 : 	return(1);

	mov	eax, 1

; 2487 : }

	pop	ebp
	ret	0
$LN4@xmlFAEqual:
	push	esi

; 2461 :     if ((atom1 == NULL) || (atom2 == NULL))

	test	eax, eax
	je	SHORT $LN6@xmlFAEqual
	test	edx, edx
	je	SHORT $LN6@xmlFAEqual

; 2463 : 
; 2464 :     if (atom1->type != atom2->type)

	mov	esi, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [edx+4]
	jne	SHORT $LN6@xmlFAEqual

; 2465 :         return(0);
; 2466 :     switch (atom1->type) {

	dec	esi
	cmp	esi, 4
	ja	SHORT $LN14@xmlFAEqual
	jmp	DWORD PTR $LN18@xmlFAEqual[esi*4]
$LN9@xmlFAEqual:

; 2467 :         case XML_REGEXP_EPSILON:
; 2468 : 	    ret = 0;
; 2469 : 	    break;
; 2470 :         case XML_REGEXP_STRING:
; 2471 :             if (!deep)

	cmp	DWORD PTR _deep$[ebp], ecx
	jne	SHORT $LN10@xmlFAEqual

; 2472 :                 ret = (atom1->valuep == atom2->valuep);

	mov	eax, DWORD PTR [eax+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	pop	esi
	sete	cl

; 2479 : 	    break;
; 2480 : 	case XML_REGEXP_RANGES:
; 2481 : 	    /* too hard to do in the general case */
; 2482 : 	    ret = 0;
; 2483 : 	default:
; 2484 : 	    break;
; 2485 :     }
; 2486 :     return(ret);

	mov	eax, ecx

; 2487 : }

	pop	ebp
	ret	0
$LN10@xmlFAEqual:

; 2473 :             else
; 2474 :                 ret = xmlStrEqual((xmlChar *)atom1->valuep,

	push	DWORD PTR [edx+20]
	push	DWORD PTR [eax+20]
	call	_xmlStrEqual
	add	esp, 8
	mov	ecx, eax
	pop	esi

; 2487 : }

	pop	ebp
	ret	0
$LN12@xmlFAEqual:

; 2475 :                                   (xmlChar *)atom2->valuep);
; 2476 : 	    break;
; 2477 :         case XML_REGEXP_CHARVAL:
; 2478 : 	    ret = (atom1->codepoint == atom2->codepoint);

	mov	eax, DWORD PTR [eax+32]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+32]
	pop	esi
	sete	cl

; 2479 : 	    break;
; 2480 : 	case XML_REGEXP_RANGES:
; 2481 : 	    /* too hard to do in the general case */
; 2482 : 	    ret = 0;
; 2483 : 	default:
; 2484 : 	    break;
; 2485 :     }
; 2486 :     return(ret);

	mov	eax, ecx

; 2487 : }

	pop	ebp
	ret	0
$LN13@xmlFAEqual:

; 2479 : 	    break;
; 2480 : 	case XML_REGEXP_RANGES:
; 2481 : 	    /* too hard to do in the general case */
; 2482 : 	    ret = 0;
; 2483 : 	default:
; 2484 : 	    break;
; 2485 :     }
; 2486 :     return(ret);

	xor	ecx, ecx
$LN14@xmlFAEqual:
	mov	eax, ecx
	pop	esi

; 2487 : }

	pop	ebp
	ret	0
$LN6@xmlFAEqual:

; 2462 : 	return(0);

	xor	eax, eax
	pop	esi

; 2487 : }

	pop	ebp
	ret	0
	npad	2
$LN18@xmlFAEqual:
	DD	$LN13@xmlFAEqual
	DD	$LN12@xmlFAEqual
	DD	$LN13@xmlFAEqual
	DD	$LN14@xmlFAEqual
	DD	$LN9@xmlFAEqual
_xmlFAEqualAtoms ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareAtomTypes
_TEXT	SEGMENT
_type1$ = 8						; size = 4
_type2$ = 12						; size = 4
_xmlFACompareAtomTypes PROC				; COMDAT

; 2254 : xmlFACompareAtomTypes(xmlRegAtomType type1, xmlRegAtomType type2) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _type2$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	edi
	mov	edi, DWORD PTR _type1$[ebp]
	call	@__CheckForDebuggerJustMyCode@4
	cmp	edi, 1
	je	$LN5@xmlFACompa

; 2255 :     if ((type1 == XML_REGEXP_EPSILON) ||
; 2256 :         (type1 == XML_REGEXP_CHARVAL) ||
; 2257 : 	(type1 == XML_REGEXP_RANGES) ||
; 2258 : 	(type1 == XML_REGEXP_SUBREG) ||
; 2259 : 	(type1 == XML_REGEXP_STRING) ||

	cmp	edi, 2
	je	$LN5@xmlFACompa
	cmp	edi, 3
	je	$LN5@xmlFACompa
	cmp	edi, 4
	je	$LN5@xmlFACompa
	cmp	edi, 5
	je	$LN5@xmlFACompa
	cmp	edi, 6
	je	$LN5@xmlFACompa

; 2262 :     if ((type2 == XML_REGEXP_EPSILON) ||
; 2263 :         (type2 == XML_REGEXP_CHARVAL) ||
; 2264 : 	(type2 == XML_REGEXP_RANGES) ||
; 2265 : 	(type2 == XML_REGEXP_SUBREG) ||
; 2266 : 	(type2 == XML_REGEXP_STRING) ||

	cmp	esi, 1
	je	$LN5@xmlFACompa
	cmp	esi, 2
	je	$LN5@xmlFACompa
	cmp	esi, 3
	je	$LN5@xmlFACompa
	cmp	esi, 4
	je	$LN5@xmlFACompa
	cmp	esi, 5
	je	$LN5@xmlFACompa
	cmp	esi, 6
	je	$LN5@xmlFACompa

; 2267 : 	(type2 == XML_REGEXP_ANYCHAR))
; 2268 : 	return(1);
; 2269 : 
; 2270 :     if (type1 == type2) return(1);

	cmp	edi, esi
	je	$LN5@xmlFACompa

; 2271 : 
; 2272 :     /* simplify subsequent compares by making sure type1 < type2 */
; 2273 :     if (type1 > type2) {
; 2274 :         xmlRegAtomType tmp = type1;
; 2275 : 	type1 = type2;
; 2276 : 	type2 = tmp;
; 2277 :     }
; 2278 :     switch (type1) {

	mov	ecx, edi
	cmovle	ecx, esi
	cmovle	esi, edi
	add	esi, -7					; fffffff9H
	cmp	esi, 128				; 00000080H
	ja	$LN5@xmlFACompa
	movzx	eax, BYTE PTR $LN75@xmlFACompa[esi]
	jmp	DWORD PTR $LN89@xmlFACompa[eax*4]
$LN10@xmlFACompa:

; 2279 :         case XML_REGEXP_ANYSPACE: /* \s */
; 2280 : 	    /* can't be a letter, number, mark, pontuation, symbol */
; 2281 : 	    if ((type2 == XML_REGEXP_NOTSPACE) ||
; 2282 : 		((type2 >= XML_REGEXP_LETTER) &&
; 2283 : 		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
; 2284 : 	        ((type2 >= XML_REGEXP_NUMBER) &&
; 2285 : 		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
; 2286 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2287 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2288 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2289 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||

	cmp	ecx, 8
	je	$LN72@xmlFACompa
	cmp	ecx, 100				; 00000064H
	jl	SHORT $LN13@xmlFACompa
	cmp	ecx, 105				; 00000069H
	jle	$LN72@xmlFACompa
$LN13@xmlFACompa:
	cmp	ecx, 110				; 0000006eH
	jl	SHORT $LN14@xmlFACompa
	cmp	ecx, 113				; 00000071H
	jle	$LN72@xmlFACompa
$LN14@xmlFACompa:
	cmp	ecx, 106				; 0000006aH
	jl	SHORT $LN15@xmlFACompa
	cmp	ecx, 109				; 0000006dH
	jle	$LN72@xmlFACompa
$LN15@xmlFACompa:
	cmp	ecx, 114				; 00000072H
	jl	SHORT $LN16@xmlFACompa
	cmp	ecx, 121				; 00000079H
	jle	$LN72@xmlFACompa
$LN16@xmlFACompa:
	cmp	ecx, 126				; 0000007eH
	jl	$LN5@xmlFACompa
	cmp	ecx, 130				; 00000082H
	jle	$LN72@xmlFACompa

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	pop	edi
	mov	eax, 1

; 2438 : 	default:
; 2439 : 	    break;
; 2440 :     }
; 2441 :     return(1);
; 2442 : }

	pop	esi
	pop	ebp
	ret	0
$LN18@xmlFACompa:

; 2290 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2291 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS))
; 2292 : 	        ) return(0);
; 2293 : 	    break;
; 2294 :         case XML_REGEXP_NOTSPACE: /* \S */
; 2295 : 	    break;
; 2296 :         case XML_REGEXP_INITNAME: /* \l */
; 2297 : 	    /* can't be a number, mark, separator, pontuation, symbol or other */
; 2298 : 	    if ((type2 == XML_REGEXP_NOTINITNAME) ||
; 2299 : 	        ((type2 >= XML_REGEXP_NUMBER) &&
; 2300 : 		 (type2 <= XML_REGEXP_NUMBER_OTHERS)) ||
; 2301 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2302 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2303 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2304 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2305 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2306 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2307 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2308 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	ecx, 10					; 0000000aH
	je	$LN72@xmlFACompa
	cmp	ecx, 110				; 0000006eH
	jl	SHORT $LN21@xmlFACompa
	cmp	ecx, 113				; 00000071H
	jle	$LN72@xmlFACompa
$LN21@xmlFACompa:
	cmp	ecx, 106				; 0000006aH
	jl	SHORT $LN22@xmlFACompa
	cmp	ecx, 109				; 0000006dH
	jle	$LN72@xmlFACompa
$LN22@xmlFACompa:
	cmp	ecx, 122				; 0000007aH
	jl	SHORT $LN23@xmlFACompa
	cmp	ecx, 125				; 0000007dH
	jle	$LN72@xmlFACompa
$LN23@xmlFACompa:
	cmp	ecx, 114				; 00000072H
	jl	SHORT $LN24@xmlFACompa
	cmp	ecx, 121				; 00000079H
$LN81@xmlFACompa:

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	jle	$LN72@xmlFACompa
$LN24@xmlFACompa:
	cmp	ecx, 126				; 0000007eH
	jl	SHORT $LN25@xmlFACompa
	cmp	ecx, 130				; 00000082H
	jle	$LN72@xmlFACompa
$LN25@xmlFACompa:
	cmp	ecx, 131				; 00000083H
	jl	SHORT $LN5@xmlFACompa
	cmp	ecx, 135				; 00000087H
	jle	SHORT $LN72@xmlFACompa
	pop	edi
	mov	eax, 1

; 2438 : 	default:
; 2439 : 	    break;
; 2440 :     }
; 2441 :     return(1);
; 2442 : }

	pop	esi
	pop	ebp
	ret	0
$LN27@xmlFACompa:

; 2309 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2310 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2311 : 		) return(0);
; 2312 : 	    break;
; 2313 :         case XML_REGEXP_NOTINITNAME: /* \L */
; 2314 : 	    break;
; 2315 :         case XML_REGEXP_NAMECHAR: /* \c */
; 2316 : 	    /* can't be a mark, separator, pontuation, symbol or other */
; 2317 : 	    if ((type2 == XML_REGEXP_NOTNAMECHAR) ||
; 2318 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2319 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2320 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2321 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2322 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2323 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2324 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2325 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	ecx, 12					; 0000000cH
$LN87@xmlFACompa:

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	je	SHORT $LN72@xmlFACompa
$LN38@xmlFACompa:
	cmp	ecx, 106				; 0000006aH
	jl	SHORT $LN30@xmlFACompa
	cmp	ecx, 109				; 0000006dH
	jle	SHORT $LN72@xmlFACompa
$LN30@xmlFACompa:
	cmp	ecx, 114				; 00000072H
	jl	SHORT $LN31@xmlFACompa
	cmp	ecx, 121				; 00000079H
	jle	SHORT $LN72@xmlFACompa
$LN31@xmlFACompa:
	cmp	ecx, 122				; 0000007aH
	jl	SHORT $LN24@xmlFACompa
	cmp	ecx, 125				; 0000007dH
	jmp	SHORT $LN81@xmlFACompa
$LN35@xmlFACompa:

; 2326 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2327 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2328 : 		) return(0);
; 2329 : 	    break;
; 2330 :         case XML_REGEXP_NOTNAMECHAR: /* \C */
; 2331 : 	    break;
; 2332 :         case XML_REGEXP_DECIMAL: /* \d */
; 2333 : 	    /* can't be a letter, mark, separator, pontuation, symbol or other */
; 2334 : 	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
; 2335 : 	        (type2 == XML_REGEXP_REALCHAR) ||
; 2336 : 		((type2 >= XML_REGEXP_LETTER) &&
; 2337 : 		 (type2 <= XML_REGEXP_LETTER_OTHERS)) ||
; 2338 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2339 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2340 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2341 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2342 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2343 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2344 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2345 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN72@xmlFACompa
	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN72@xmlFACompa
	cmp	ecx, 100				; 00000064H
	jl	SHORT $LN38@xmlFACompa
	cmp	ecx, 105				; 00000069H
	jle	SHORT $LN72@xmlFACompa

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	jmp	SHORT $LN38@xmlFACompa
$LN44@xmlFACompa:

; 2346 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2347 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2348 : 		)return(0);
; 2349 : 	    break;
; 2350 :         case XML_REGEXP_NOTDECIMAL: /* \D */
; 2351 : 	    break;
; 2352 :         case XML_REGEXP_REALCHAR: /* \w */
; 2353 : 	    /* can't be a mark, separator, pontuation, symbol or other */
; 2354 : 	    if ((type2 == XML_REGEXP_NOTDECIMAL) ||
; 2355 : 	        ((type2 >= XML_REGEXP_MARK) &&
; 2356 : 		 (type2 <= XML_REGEXP_MARK_ENCLOSING)) ||
; 2357 : 	        ((type2 >= XML_REGEXP_PUNCT) &&
; 2358 : 		 (type2 <= XML_REGEXP_PUNCT_OTHERS)) ||
; 2359 : 	        ((type2 >= XML_REGEXP_SEPAR) &&
; 2360 : 		 (type2 <= XML_REGEXP_SEPAR_PARA)) ||
; 2361 : 	        ((type2 >= XML_REGEXP_SYMBOL) &&
; 2362 : 		 (type2 <= XML_REGEXP_SYMBOL_OTHERS)) ||

	cmp	ecx, 14					; 0000000eH

; 2363 : 	        ((type2 >= XML_REGEXP_OTHER) &&
; 2364 : 		 (type2 <= XML_REGEXP_OTHER_NA))
; 2365 : 		)return(0);
; 2366 : 	    break;

	jmp	SHORT $LN87@xmlFACompa
$LN52@xmlFACompa:

; 2367 :         case XML_REGEXP_NOTREALCHAR: /* \W */
; 2368 : 	    break;
; 2369 : 	/*
; 2370 : 	 * at that point we know both type 1 and type2 are from
; 2371 : 	 * character categories are ordered and are different,
; 2372 : 	 * it becomes simple because this is a partition
; 2373 : 	 */
; 2374 :         case XML_REGEXP_LETTER:
; 2375 : 	    if (type2 <= XML_REGEXP_LETTER_OTHERS)

	cmp	ecx, 105				; 00000069H
$LN77@xmlFACompa:

; 2260 : 	(type1 == XML_REGEXP_ANYCHAR))
; 2261 : 	return(1);

	jg	SHORT $LN72@xmlFACompa
$LN5@xmlFACompa:
	pop	edi
	mov	eax, 1

; 2438 : 	default:
; 2439 : 	    break;
; 2440 :     }
; 2441 :     return(1);
; 2442 : }

	pop	esi
	pop	ebp
	ret	0
$LN55@xmlFACompa:

; 2376 : 	        return(1);
; 2377 : 	    return(0);
; 2378 :         case XML_REGEXP_LETTER_UPPERCASE:
; 2379 :         case XML_REGEXP_LETTER_LOWERCASE:
; 2380 :         case XML_REGEXP_LETTER_TITLECASE:
; 2381 :         case XML_REGEXP_LETTER_MODIFIER:
; 2382 :         case XML_REGEXP_LETTER_OTHERS:
; 2383 : 	    return(0);
; 2384 :         case XML_REGEXP_MARK:
; 2385 : 	    if (type2 <= XML_REGEXP_MARK_ENCLOSING)

	cmp	ecx, 109				; 0000006dH
	jmp	SHORT $LN77@xmlFACompa
$LN58@xmlFACompa:

; 2386 : 	        return(1);
; 2387 : 	    return(0);
; 2388 :         case XML_REGEXP_MARK_NONSPACING:
; 2389 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 2390 :         case XML_REGEXP_MARK_ENCLOSING:
; 2391 : 	    return(0);
; 2392 :         case XML_REGEXP_NUMBER:
; 2393 : 	    if (type2 <= XML_REGEXP_NUMBER_OTHERS)

	cmp	ecx, 113				; 00000071H
	jmp	SHORT $LN77@xmlFACompa
$LN61@xmlFACompa:

; 2394 : 	        return(1);
; 2395 : 	    return(0);
; 2396 :         case XML_REGEXP_NUMBER_DECIMAL:
; 2397 :         case XML_REGEXP_NUMBER_LETTER:
; 2398 :         case XML_REGEXP_NUMBER_OTHERS:
; 2399 : 	    return(0);
; 2400 :         case XML_REGEXP_PUNCT:
; 2401 : 	    if (type2 <= XML_REGEXP_PUNCT_OTHERS)

	cmp	ecx, 121				; 00000079H
	jmp	SHORT $LN77@xmlFACompa
$LN64@xmlFACompa:

; 2402 : 	        return(1);
; 2403 : 	    return(0);
; 2404 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 2405 :         case XML_REGEXP_PUNCT_DASH:
; 2406 :         case XML_REGEXP_PUNCT_OPEN:
; 2407 :         case XML_REGEXP_PUNCT_CLOSE:
; 2408 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 2409 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 2410 :         case XML_REGEXP_PUNCT_OTHERS:
; 2411 : 	    return(0);
; 2412 :         case XML_REGEXP_SEPAR:
; 2413 : 	    if (type2 <= XML_REGEXP_SEPAR_PARA)

	cmp	ecx, 125				; 0000007dH
	jmp	SHORT $LN77@xmlFACompa
$LN67@xmlFACompa:

; 2414 : 	        return(1);
; 2415 : 	    return(0);
; 2416 :         case XML_REGEXP_SEPAR_SPACE:
; 2417 :         case XML_REGEXP_SEPAR_LINE:
; 2418 :         case XML_REGEXP_SEPAR_PARA:
; 2419 : 	    return(0);
; 2420 :         case XML_REGEXP_SYMBOL:
; 2421 : 	    if (type2 <= XML_REGEXP_SYMBOL_OTHERS)

	cmp	ecx, 130				; 00000082H
	jmp	SHORT $LN77@xmlFACompa
$LN70@xmlFACompa:

; 2422 : 	        return(1);
; 2423 : 	    return(0);
; 2424 :         case XML_REGEXP_SYMBOL_MATH:
; 2425 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 2426 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 2427 :         case XML_REGEXP_SYMBOL_OTHERS:
; 2428 : 	    return(0);
; 2429 :         case XML_REGEXP_OTHER:
; 2430 : 	    if (type2 <= XML_REGEXP_OTHER_NA)

	cmp	ecx, 135				; 00000087H
	jle	SHORT $LN5@xmlFACompa
$LN72@xmlFACompa:
	pop	edi

; 2431 : 	        return(1);
; 2432 : 	    return(0);
; 2433 :         case XML_REGEXP_OTHER_CONTROL:
; 2434 :         case XML_REGEXP_OTHER_FORMAT:
; 2435 :         case XML_REGEXP_OTHER_PRIVATE:
; 2436 :         case XML_REGEXP_OTHER_NA:
; 2437 : 	    return(0);

	xor	eax, eax

; 2438 : 	default:
; 2439 : 	    break;
; 2440 :     }
; 2441 :     return(1);
; 2442 : }

	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN89@xmlFACompa:
	DD	$LN10@xmlFACompa
	DD	$LN18@xmlFACompa
	DD	$LN27@xmlFACompa
	DD	$LN35@xmlFACompa
	DD	$LN44@xmlFACompa
	DD	$LN52@xmlFACompa
	DD	$LN72@xmlFACompa
	DD	$LN55@xmlFACompa
	DD	$LN58@xmlFACompa
	DD	$LN61@xmlFACompa
	DD	$LN64@xmlFACompa
	DD	$LN67@xmlFACompa
	DD	$LN70@xmlFACompa
	DD	$LN5@xmlFACompa
$LN75@xmlFACompa:
	DB	0
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	2
	DB	13					; 0000000dH
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	7
	DB	6
	DB	6
	DB	6
	DB	8
	DB	6
	DB	6
	DB	6
	DB	9
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	10					; 0000000aH
	DB	6
	DB	6
	DB	6
	DB	11					; 0000000bH
	DB	6
	DB	6
	DB	6
	DB	6
	DB	12					; 0000000cH
	DB	6
	DB	6
	DB	6
	DB	6
_xmlFACompareAtomTypes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFACompareRanges
_TEXT	SEGMENT
_neg$1$ = 8						; size = 4
_range1$ = 8						; size = 4
_range2$ = 12						; size = 4
_xmlFACompareRanges PROC				; COMDAT

; 2081 : xmlFACompareRanges(xmlRegRangePtr range1, xmlRegRangePtr range2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _range2$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	esi
	mov	esi, DWORD PTR _range1$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	je	$LN8@xmlFACompa

; 2082 :     int ret = 0;
; 2083 : 
; 2084 :     if ((range1->type == XML_REGEXP_RANGES) ||
; 2085 :         (range2->type == XML_REGEXP_RANGES) ||
; 2086 :         (range2->type == XML_REGEXP_SUBREG) ||
; 2087 :         (range1->type == XML_REGEXP_SUBREG) ||
; 2088 :         (range1->type == XML_REGEXP_STRING) ||

	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, 3
	je	$LN8@xmlFACompa
	cmp	ecx, 4
	je	$LN8@xmlFACompa
	cmp	eax, 4
	je	$LN8@xmlFACompa
	cmp	eax, 5
	je	$LN8@xmlFACompa
	cmp	ecx, 5
	je	$LN8@xmlFACompa

; 2089 :         (range2->type == XML_REGEXP_STRING))
; 2090 : 	return(-1);
; 2091 : 
; 2092 :     /* put them in order */
; 2093 :     if (range1->type > range2->type) {
; 2094 :         xmlRegRangePtr tmp;
; 2095 : 
; 2096 : 	tmp = range1;
; 2097 : 	range1 = range2;
; 2098 : 	range2 = tmp;
; 2099 :     }
; 2100 :     if ((range1->type == XML_REGEXP_ANYCHAR) ||

	cmp	eax, ecx
	mov	edi, esi
	cmovle	edi, ebx
	cmovle	ebx, esi
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 6
	je	$LN12@xmlFACompa
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, 6
	je	$LN12@xmlFACompa

; 2101 :         (range2->type == XML_REGEXP_ANYCHAR)) {
; 2102 : 	ret = 1;
; 2103 :     } else if ((range1->type == XML_REGEXP_EPSILON) ||

	cmp	eax, 1
	je	$LN15@xmlFACompa
	cmp	ecx, 1
	je	$LN15@xmlFACompa

; 2104 :                (range2->type == XML_REGEXP_EPSILON)) {
; 2105 : 	return(0);
; 2106 :     } else if (range1->type == range2->type) {

	cmp	eax, ecx
	jne	SHORT $LN16@xmlFACompa

; 2107 :         if (range1->type != XML_REGEXP_CHARVAL)

	cmp	eax, 2
	jne	$LN12@xmlFACompa

; 2108 :             ret = 1;
; 2109 :         else if ((range1->end < range2->start) ||

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [edi+8]
	jl	$LN49@xmlFACompa
	mov	eax, DWORD PTR [edi+12]
	cmp	eax, DWORD PTR [ebx+8]
	jge	$LN12@xmlFACompa

; 2110 : 	         (range2->end < range1->start))
; 2111 : 	    ret = 0;

	xor	edx, edx

; 2112 : 	else
; 2113 : 	    ret = 1;
; 2114 :     } else if (range1->type == XML_REGEXP_CHARVAL) {

	jmp	$LN73@xmlFACompa
$LN16@xmlFACompa:
	cmp	eax, 2
	jne	SHORT $LN23@xmlFACompa

; 2115 :         int codepoint;
; 2116 : 	int neg = 0;

	xor	eax, eax

; 2117 : 
; 2118 : 	/*
; 2119 : 	 * just check all codepoints in the range for acceptance,
; 2120 : 	 * this is usually way cheaper since done only once at
; 2121 : 	 * compilation than testing over and over at runtime or
; 2122 : 	 * pushing too many states when evaluating.
; 2123 : 	 */
; 2124 : 	if (((range1->neg == 0) && (range2->neg != 0)) ||

	cmp	DWORD PTR [ebx], 0
	mov	DWORD PTR _neg$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
	jne	SHORT $LN86@xmlFACompa
	test	eax, eax
	jne	SHORT $LN87@xmlFACompa
	jmp	SHORT $LN25@xmlFACompa
$LN86@xmlFACompa:
	test	eax, eax
	jne	SHORT $LN25@xmlFACompa
$LN87@xmlFACompa:

; 2125 : 	    ((range1->neg != 0) && (range2->neg == 0)))
; 2126 : 	    neg = 1;

	mov	DWORD PTR _neg$1$[ebp], 1
$LN25@xmlFACompa:

; 2127 : 
; 2128 : 	for (codepoint = range1->start;codepoint <= range1->end ;codepoint++) {

	mov	esi, DWORD PTR [ebx+8]
	cmp	esi, DWORD PTR [ebx+12]
	jg	SHORT $LN15@xmlFACompa
	npad	4
$LL4@xmlFACompa:

; 2129 : 	    ret = xmlRegCheckCharacterRange(range2->type, codepoint,

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	0
	push	esi
	push	DWORD PTR [edi+4]
	call	_xmlRegCheckCharacterRange
	add	esp, 24					; 00000018H

; 2130 : 					    0, range2->start, range2->end,
; 2131 : 					    range2->blockName);
; 2132 : 	    if (ret < 0)

	test	eax, eax
	js	$LN8@xmlFACompa

; 2133 : 	        return(-1);
; 2134 : 	    if (((neg == 1) && (ret == 0)) ||

	mov	ecx, DWORD PTR _neg$1$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN31@xmlFACompa
	test	eax, eax
	jmp	SHORT $LN89@xmlFACompa
$LN31@xmlFACompa:
	test	ecx, ecx
	jne	SHORT $LN2@xmlFACompa
	cmp	eax, 1
$LN89@xmlFACompa:

; 2127 : 
; 2128 : 	for (codepoint = range1->start;codepoint <= range1->end ;codepoint++) {

	je	$LN34@xmlFACompa
$LN2@xmlFACompa:
	inc	esi
	cmp	esi, DWORD PTR [ebx+12]
	jle	SHORT $LL4@xmlFACompa
$LN15@xmlFACompa:
	pop	edi

; 2240 :     return(ret);
; 2241 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlFACompa:

; 2135 : 	        ((neg == 0) && (ret == 1)))
; 2136 : 		return(1);
; 2137 : 	}
; 2138 : 	return(0);
; 2139 :     } else if ((range1->type == XML_REGEXP_BLOCK_NAME) ||

	cmp	eax, 136				; 00000088H
	je	$LN34@xmlFACompa
	cmp	ecx, 136				; 00000088H
	je	$LN34@xmlFACompa

; 2140 :                (range2->type == XML_REGEXP_BLOCK_NAME)) {
; 2141 : 	if (range1->type == range2->type) {
; 2142 : 	    ret = xmlStrEqual(range1->blockName, range2->blockName);
; 2143 : 	} else {
; 2144 : 	    /*
; 2145 : 	     * comparing a block range with anything else is way
; 2146 : 	     * too costly, and maintining the table is like too much
; 2147 : 	     * memory too, so let's force the automata to save state
; 2148 : 	     * here.
; 2149 : 	     */
; 2150 : 	    return(1);
; 2151 : 	}
; 2152 :     } else if ((range1->type < XML_REGEXP_LETTER) ||

	cmp	eax, 100				; 00000064H
	jl	$LN39@xmlFACompa
	cmp	ecx, 100				; 00000064H
	jl	$LN39@xmlFACompa

; 2174 :         ret = 0;
; 2175 :         /* range1->type < range2->type here */
; 2176 :         switch (range1->type) {

	add	eax, -100				; ffffff9cH
	xor	edx, edx
	cmp	eax, 31					; 0000001fH
	ja	$LN71@xmlFACompa
	movzx	eax, BYTE PTR $LN88@xmlFACompa[eax]
	jmp	DWORD PTR $LN92@xmlFACompa[eax*4]
$LN50@xmlFACompa:

; 2177 : 	    case XML_REGEXP_LETTER:
; 2178 : 	         /* all disjoint except in the subgroups */
; 2179 : 	         if ((range2->type == XML_REGEXP_LETTER_UPPERCASE) ||
; 2180 : 		     (range2->type == XML_REGEXP_LETTER_LOWERCASE) ||
; 2181 : 		     (range2->type == XML_REGEXP_LETTER_TITLECASE) ||
; 2182 : 		     (range2->type == XML_REGEXP_LETTER_MODIFIER) ||

	cmp	ecx, 101				; 00000065H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 102				; 00000066H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 103				; 00000067H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 104				; 00000068H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 105				; 00000069H
$LN90@xmlFACompa:

; 2231 : 		 else {
; 2232 : 		     /* safety net ! */
; 2233 : 		     return(1);
; 2234 : 		 }
; 2235 : 	}
; 2236 :     }
; 2237 :     if (((range1->neg == 0) && (range2->neg != 0)) ||

	jne	SHORT $LN73@xmlFACompa
$LN12@xmlFACompa:
	mov	edx, 1
$LN73@xmlFACompa:
	cmp	DWORD PTR [ebx], 0
	mov	eax, DWORD PTR [edi]
	jne	$LN85@xmlFACompa
	test	eax, eax
	jne	$LN75@xmlFACompa

; 2240 :     return(ret);
; 2241 : }

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
$LN53@xmlFACompa:

; 2183 : 		     (range2->type == XML_REGEXP_LETTER_OTHERS))
; 2184 : 		     ret = 1;
; 2185 : 		 break;
; 2186 : 	    case XML_REGEXP_MARK:
; 2187 : 	         if ((range2->type == XML_REGEXP_MARK_NONSPACING) ||
; 2188 : 		     (range2->type == XML_REGEXP_MARK_SPACECOMBINING) ||

	cmp	ecx, 107				; 0000006bH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 108				; 0000006cH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 109				; 0000006dH

; 2189 : 		     (range2->type == XML_REGEXP_MARK_ENCLOSING))
; 2190 : 		     ret = 1;
; 2191 : 		 break;

	jmp	SHORT $LN90@xmlFACompa
$LN56@xmlFACompa:

; 2192 : 	    case XML_REGEXP_NUMBER:
; 2193 : 	         if ((range2->type == XML_REGEXP_NUMBER_DECIMAL) ||
; 2194 : 		     (range2->type == XML_REGEXP_NUMBER_LETTER) ||

	cmp	ecx, 111				; 0000006fH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 112				; 00000070H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 113				; 00000071H

; 2195 : 		     (range2->type == XML_REGEXP_NUMBER_OTHERS))
; 2196 : 		     ret = 1;
; 2197 : 		 break;

	jmp	SHORT $LN90@xmlFACompa
$LN59@xmlFACompa:

; 2198 : 	    case XML_REGEXP_PUNCT:
; 2199 : 	         if ((range2->type == XML_REGEXP_PUNCT_CONNECTOR) ||
; 2200 : 		     (range2->type == XML_REGEXP_PUNCT_DASH) ||
; 2201 : 		     (range2->type == XML_REGEXP_PUNCT_OPEN) ||
; 2202 : 		     (range2->type == XML_REGEXP_PUNCT_CLOSE) ||
; 2203 : 		     (range2->type == XML_REGEXP_PUNCT_INITQUOTE) ||
; 2204 : 		     (range2->type == XML_REGEXP_PUNCT_FINQUOTE) ||

	cmp	ecx, 115				; 00000073H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 116				; 00000074H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 117				; 00000075H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 118				; 00000076H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 119				; 00000077H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 120				; 00000078H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 121				; 00000079H

; 2205 : 		     (range2->type == XML_REGEXP_PUNCT_OTHERS))
; 2206 : 		     ret = 1;
; 2207 : 		 break;

	jmp	SHORT $LN90@xmlFACompa
$LN62@xmlFACompa:

; 2208 : 	    case XML_REGEXP_SEPAR:
; 2209 : 	         if ((range2->type == XML_REGEXP_SEPAR_SPACE) ||
; 2210 : 		     (range2->type == XML_REGEXP_SEPAR_LINE) ||

	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 124				; 0000007cH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 125				; 0000007dH

; 2211 : 		     (range2->type == XML_REGEXP_SEPAR_PARA))
; 2212 : 		     ret = 1;
; 2213 : 		 break;

	jmp	SHORT $LN90@xmlFACompa
$LN65@xmlFACompa:

; 2214 : 	    case XML_REGEXP_SYMBOL:
; 2215 : 	         if ((range2->type == XML_REGEXP_SYMBOL_MATH) ||
; 2216 : 		     (range2->type == XML_REGEXP_SYMBOL_CURRENCY) ||
; 2217 : 		     (range2->type == XML_REGEXP_SYMBOL_MODIFIER) ||

	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN12@xmlFACompa
	cmp	ecx, 129				; 00000081H
	je	$LN12@xmlFACompa
	cmp	ecx, 130				; 00000082H

; 2218 : 		     (range2->type == XML_REGEXP_SYMBOL_OTHERS))
; 2219 : 		     ret = 1;
; 2220 : 		 break;

	jmp	$LN90@xmlFACompa
$LN68@xmlFACompa:

; 2221 : 	    case XML_REGEXP_OTHER:
; 2222 : 	         if ((range2->type == XML_REGEXP_OTHER_CONTROL) ||
; 2223 : 		     (range2->type == XML_REGEXP_OTHER_FORMAT) ||

	cmp	ecx, 132				; 00000084H
	je	$LN12@xmlFACompa
	cmp	ecx, 133				; 00000085H
	je	$LN12@xmlFACompa
	cmp	ecx, 134				; 00000086H

; 2224 : 		     (range2->type == XML_REGEXP_OTHER_PRIVATE))
; 2225 : 		     ret = 1;
; 2226 : 		 break;

	jmp	$LN90@xmlFACompa
$LN71@xmlFACompa:

; 2227 :             default:
; 2228 : 	         if ((range2->type >= XML_REGEXP_LETTER) &&

	cmp	ecx, 136				; 00000088H
	jge	SHORT $LN34@xmlFACompa

; 2229 : 		     (range2->type < XML_REGEXP_BLOCK_NAME))
; 2230 : 		     ret = 0;

	xor	edx, edx
	jmp	$LN73@xmlFACompa
$LN39@xmlFACompa:

; 2153 :                (range2->type < XML_REGEXP_LETTER)) {
; 2154 : 	if ((range1->type == XML_REGEXP_ANYSPACE) &&

	cmp	eax, 7
	jne	SHORT $LN40@xmlFACompa
	cmp	ecx, 8
	je	SHORT $LN49@xmlFACompa
$LN40@xmlFACompa:

; 2155 : 	    (range2->type == XML_REGEXP_NOTSPACE))
; 2156 : 	    ret = 0;
; 2157 : 	else if ((range1->type == XML_REGEXP_INITNAME) &&

	cmp	eax, 9
	jne	SHORT $LN42@xmlFACompa
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN49@xmlFACompa
$LN42@xmlFACompa:

; 2158 : 	         (range2->type == XML_REGEXP_NOTINITNAME))
; 2159 : 	    ret = 0;
; 2160 : 	else if ((range1->type == XML_REGEXP_NAMECHAR) &&

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN44@xmlFACompa
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN49@xmlFACompa
$LN44@xmlFACompa:

; 2161 : 	         (range2->type == XML_REGEXP_NOTNAMECHAR))
; 2162 : 	    ret = 0;
; 2163 : 	else if ((range1->type == XML_REGEXP_DECIMAL) &&

	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN46@xmlFACompa
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN49@xmlFACompa
$LN46@xmlFACompa:

; 2164 : 	         (range2->type == XML_REGEXP_NOTDECIMAL))
; 2165 : 	    ret = 0;
; 2166 : 	else if ((range1->type == XML_REGEXP_REALCHAR) &&

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN34@xmlFACompa
	cmp	ecx, 16					; 00000010H
	jne	SHORT $LN34@xmlFACompa
$LN49@xmlFACompa:

; 2167 : 	         (range2->type == XML_REGEXP_NOTREALCHAR))
; 2168 : 	    ret = 0;
; 2169 : 	else {
; 2170 : 	    /* same thing to limit complexity */
; 2171 : 	    return(1);
; 2172 : 	}
; 2173 :     } else {

	xor	edx, edx
	jmp	$LN73@xmlFACompa
$LN34@xmlFACompa:
	pop	edi

; 2240 :     return(ret);
; 2241 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN85@xmlFACompa:

; 2231 : 		 else {
; 2232 : 		     /* safety net ! */
; 2233 : 		     return(1);
; 2234 : 		 }
; 2235 : 	}
; 2236 :     }
; 2237 :     if (((range1->neg == 0) && (range2->neg != 0)) ||

	test	eax, eax
	jne	SHORT $LN74@xmlFACompa
$LN75@xmlFACompa:

; 2238 :         ((range1->neg != 0) && (range2->neg == 0)))
; 2239 : 	ret = !ret;

	xor	eax, eax
	test	edx, edx
	sete	al
	mov	edx, eax
$LN74@xmlFACompa:

; 2240 :     return(ret);
; 2241 : }

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlFACompa:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LN92@xmlFACompa:
	DD	$LN50@xmlFACompa
	DD	$LN53@xmlFACompa
	DD	$LN56@xmlFACompa
	DD	$LN59@xmlFACompa
	DD	$LN62@xmlFACompa
	DD	$LN65@xmlFACompa
	DD	$LN68@xmlFACompa
	DD	$LN71@xmlFACompa
$LN88@xmlFACompa:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	7
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_xmlFACompareRanges ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEliminateEpsilonTransitions
_TEXT	SEGMENT
_state$1$ = -16						; size = 4
_newto$1$ = -12						; size = 4
_has_epsilon$1$ = -12					; size = 4
_i$1$ = -8						; size = 4
_statenr$1$ = -4					; size = 4
_target$1$ = -4						; size = 4
_statenr$2$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlFAEliminateEpsilonTransitions PROC			; COMDAT

; 1929 : xmlFAEliminateEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	$LN29@xmlFAElimi

; 1869 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	eax, DWORD PTR [edx+48]
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _statenr$1$[ebp], ebx
	push	esi
	push	edi
	test	eax, eax
	jle	$LN54@xmlFAElimi
$LL55@xmlFAElimi:

; 1870 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _state$1$[ebp], ecx

; 1871 : 	if (state == NULL)

	test	ecx, ecx
	je	$LN53@xmlFAElimi

; 1872 : 	    continue;
; 1873 : 	if (state->nbTrans != 1)

	cmp	DWORD PTR [ecx+24], 1
	jne	$LN53@xmlFAElimi

; 1874 : 	    continue;
; 1875 : 	if (state->type == XML_REGEXP_UNREACH_STATE)

	mov	edi, DWORD PTR [ecx]
	cmp	edi, 5
	je	$LN53@xmlFAElimi

; 1876 : 	    continue;
; 1877 : 	/* is the only transition out a basic transition */
; 1878 : 	if ((state->trans[0].atom == NULL) &&
; 1879 : 	    (state->trans[0].to >= 0) &&
; 1880 : 	    (state->trans[0].to != statenr) &&
; 1881 : 	    (state->trans[0].counter < 0) &&

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	jne	$LN53@xmlFAElimi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _newto$1$[ebp], esi
	test	esi, esi
	js	$LN53@xmlFAElimi
	cmp	esi, ebx
	je	$LN53@xmlFAElimi
	cmp	DWORD PTR [eax+8], 0
	jge	$LN53@xmlFAElimi
	cmp	DWORD PTR [eax+12], 0
	jge	$LN53@xmlFAElimi

; 1882 : 	    (state->trans[0].count < 0)) {
; 1883 : 	    newto = state->trans[0].to;
; 1884 : 
; 1885 :             if (state->type == XML_REGEXP_START_STATE) {

	cmp	edi, 1
	je	$LN53@xmlFAElimi

; 1886 : #ifdef DEBUG_REGEXP_GRAPH
; 1887 : 		printf("Found simple epsilon trans from start %d to %d\n",
; 1888 : 		       statenr, newto);
; 1889 : #endif
; 1890 :             } else {
; 1891 : #ifdef DEBUG_REGEXP_GRAPH
; 1892 : 		printf("Found simple epsilon trans from %d to %d\n",
; 1893 : 		       statenr, newto);
; 1894 : #endif
; 1895 : 	        for (i = 0;i < state->nbTransTo;i++) {

	xor	esi, esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	DWORD PTR [ecx+36], esi
	jle	$LN57@xmlFAElimi
$LL58@xmlFAElimi:

; 1896 : 		    tmp = ctxt->states[state->transTo[i]];

	mov	eax, DWORD PTR [ecx+40]

; 1897 : 		    for (j = 0;j < tmp->nbTrans;j++) {

	xor	ebx, ebx
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+52]
	mov	edi, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edi+24], ebx
	jle	SHORT $LN56@xmlFAElimi
	mov	ecx, DWORD PTR _statenr$1$[ebp]

; 1896 : 		    tmp = ctxt->states[state->transTo[i]];

	xor	esi, esi
	npad	5
$LL61@xmlFAElimi:

; 1898 : 			if (tmp->trans[j].to == statenr) {

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [esi+eax+4], ecx
	jne	SHORT $LN59@xmlFAElimi

; 1899 : #ifdef DEBUG_REGEXP_GRAPH
; 1900 : 			    printf("Changed transition %d on %d to go to %d\n",
; 1901 : 				   j, tmp->no, newto);
; 1902 : #endif
; 1903 : 			    tmp->trans[j].to = -1;

	mov	DWORD PTR [esi+eax+4], -1

; 1904 : 			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,

	mov	ecx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edx+52]
	mov	edx, DWORD PTR _newto$1$[ebp]
	push	DWORD PTR [ecx+esi+12]
	push	DWORD PTR [ecx+esi+8]
	push	DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [ecx+esi]
	push	edi
	push	edx
	call	_xmlRegStateAddTrans
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _statenr$1$[ebp]
$LN59@xmlFAElimi:

; 1897 : 		    for (j = 0;j < tmp->nbTrans;j++) {

	inc	ebx
	add	esi, 20					; 00000014H
	cmp	ebx, DWORD PTR [edi+24]
	jl	SHORT $LL61@xmlFAElimi
	mov	esi, DWORD PTR _i$1$[ebp]
$LN56@xmlFAElimi:

; 1886 : #ifdef DEBUG_REGEXP_GRAPH
; 1887 : 		printf("Found simple epsilon trans from start %d to %d\n",
; 1888 : 		       statenr, newto);
; 1889 : #endif
; 1890 :             } else {
; 1891 : #ifdef DEBUG_REGEXP_GRAPH
; 1892 : 		printf("Found simple epsilon trans from %d to %d\n",
; 1893 : 		       statenr, newto);
; 1894 : #endif
; 1895 : 	        for (i = 0;i < state->nbTransTo;i++) {

	mov	ecx, DWORD PTR _state$1$[ebp]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [ecx+36]
	jl	SHORT $LL58@xmlFAElimi
	mov	edi, DWORD PTR [ecx]
	mov	ebx, DWORD PTR _statenr$1$[ebp]
$LN57@xmlFAElimi:

; 1905 : 						ctxt->states[newto],
; 1906 : 					        tmp->trans[j].counter,
; 1907 : 						tmp->trans[j].count);
; 1908 : 			}
; 1909 : 		    }
; 1910 : 		}
; 1911 : 		if (state->type == XML_REGEXP_FINAL_STATE)

	cmp	edi, 2
	jne	SHORT $LN69@xmlFAElimi

; 1912 : 		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR [edx+52]
	mov	esi, DWORD PTR _newto$1$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [eax], edi
$LN69@xmlFAElimi:

; 1913 : 		/* eliminate the transition completely */
; 1914 : 		state->nbTrans = 0;

	mov	DWORD PTR [ecx+24], 0

; 1915 : 
; 1916 :                 state->type = XML_REGEXP_UNREACH_STATE;

	mov	DWORD PTR [ecx], 5
$LN53@xmlFAElimi:

; 906  : }
; 907  : 
; 908  : /**
; 909  :  * xmlRegFreeParserCtxt:
; 910  :  * @ctxt:  the regexp parser context
; 911  :  *
; 912  :  * Free a regexp parser context
; 913  :  */
; 914  : static void
; 915  : xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {
; 916  :     int i;
; 917  :     if (ctxt == NULL)
; 918  : 	return;
; 919  : 
; 920  :     if (ctxt->string != NULL)
; 921  : 	xmlFree(ctxt->string);
; 922  :     if (ctxt->states != NULL) {
; 923  : 	for (i = 0;i < ctxt->nbStates;i++)
; 924  : 	    xmlRegFreeState(ctxt->states[i]);
; 925  : 	xmlFree(ctxt->states);
; 926  :     }
; 927  :     if (ctxt->atoms != NULL) {
; 928  : 	for (i = 0;i < ctxt->nbAtoms;i++)
; 929  : 	    xmlRegFreeAtom(ctxt->atoms[i]);
; 930  : 	xmlFree(ctxt->atoms);
; 931  :     }
; 932  :     if (ctxt->counters != NULL)
; 933  : 	xmlFree(ctxt->counters);
; 934  :     xmlFree(ctxt);
; 935  : }
; 936  : 
; 937  : /************************************************************************
; 938  :  *									*
; 939  :  *			Display of Data structures			*
; 940  :  *									*
; 941  :  ************************************************************************/
; 942  : 
; 943  : static void
; 944  : xmlRegPrintAtomType(FILE *output, xmlRegAtomType type) {
; 945  :     switch (type) {
; 946  :         case XML_REGEXP_EPSILON:
; 947  : 	    fprintf(output, "epsilon "); break;
; 948  :         case XML_REGEXP_CHARVAL:
; 949  : 	    fprintf(output, "charval "); break;
; 950  :         case XML_REGEXP_RANGES:
; 951  : 	    fprintf(output, "ranges "); break;
; 952  :         case XML_REGEXP_SUBREG:
; 953  : 	    fprintf(output, "subexpr "); break;
; 954  :         case XML_REGEXP_STRING:
; 955  : 	    fprintf(output, "string "); break;
; 956  :         case XML_REGEXP_ANYCHAR:
; 957  : 	    fprintf(output, "anychar "); break;
; 958  :         case XML_REGEXP_ANYSPACE:
; 959  : 	    fprintf(output, "anyspace "); break;
; 960  :         case XML_REGEXP_NOTSPACE:
; 961  : 	    fprintf(output, "notspace "); break;
; 962  :         case XML_REGEXP_INITNAME:
; 963  : 	    fprintf(output, "initname "); break;
; 964  :         case XML_REGEXP_NOTINITNAME:
; 965  : 	    fprintf(output, "notinitname "); break;
; 966  :         case XML_REGEXP_NAMECHAR:
; 967  : 	    fprintf(output, "namechar "); break;
; 968  :         case XML_REGEXP_NOTNAMECHAR:
; 969  : 	    fprintf(output, "notnamechar "); break;
; 970  :         case XML_REGEXP_DECIMAL:
; 971  : 	    fprintf(output, "decimal "); break;
; 972  :         case XML_REGEXP_NOTDECIMAL:
; 973  : 	    fprintf(output, "notdecimal "); break;
; 974  :         case XML_REGEXP_REALCHAR:
; 975  : 	    fprintf(output, "realchar "); break;
; 976  :         case XML_REGEXP_NOTREALCHAR:
; 977  : 	    fprintf(output, "notrealchar "); break;
; 978  :         case XML_REGEXP_LETTER:
; 979  :             fprintf(output, "LETTER "); break;
; 980  :         case XML_REGEXP_LETTER_UPPERCASE:
; 981  :             fprintf(output, "LETTER_UPPERCASE "); break;
; 982  :         case XML_REGEXP_LETTER_LOWERCASE:
; 983  :             fprintf(output, "LETTER_LOWERCASE "); break;
; 984  :         case XML_REGEXP_LETTER_TITLECASE:
; 985  :             fprintf(output, "LETTER_TITLECASE "); break;
; 986  :         case XML_REGEXP_LETTER_MODIFIER:
; 987  :             fprintf(output, "LETTER_MODIFIER "); break;
; 988  :         case XML_REGEXP_LETTER_OTHERS:
; 989  :             fprintf(output, "LETTER_OTHERS "); break;
; 990  :         case XML_REGEXP_MARK:
; 991  :             fprintf(output, "MARK "); break;
; 992  :         case XML_REGEXP_MARK_NONSPACING:
; 993  :             fprintf(output, "MARK_NONSPACING "); break;
; 994  :         case XML_REGEXP_MARK_SPACECOMBINING:
; 995  :             fprintf(output, "MARK_SPACECOMBINING "); break;
; 996  :         case XML_REGEXP_MARK_ENCLOSING:
; 997  :             fprintf(output, "MARK_ENCLOSING "); break;
; 998  :         case XML_REGEXP_NUMBER:
; 999  :             fprintf(output, "NUMBER "); break;
; 1000 :         case XML_REGEXP_NUMBER_DECIMAL:
; 1001 :             fprintf(output, "NUMBER_DECIMAL "); break;
; 1002 :         case XML_REGEXP_NUMBER_LETTER:
; 1003 :             fprintf(output, "NUMBER_LETTER "); break;
; 1004 :         case XML_REGEXP_NUMBER_OTHERS:
; 1005 :             fprintf(output, "NUMBER_OTHERS "); break;
; 1006 :         case XML_REGEXP_PUNCT:
; 1007 :             fprintf(output, "PUNCT "); break;
; 1008 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 1009 :             fprintf(output, "PUNCT_CONNECTOR "); break;
; 1010 :         case XML_REGEXP_PUNCT_DASH:
; 1011 :             fprintf(output, "PUNCT_DASH "); break;
; 1012 :         case XML_REGEXP_PUNCT_OPEN:
; 1013 :             fprintf(output, "PUNCT_OPEN "); break;
; 1014 :         case XML_REGEXP_PUNCT_CLOSE:
; 1015 :             fprintf(output, "PUNCT_CLOSE "); break;
; 1016 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 1017 :             fprintf(output, "PUNCT_INITQUOTE "); break;
; 1018 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 1019 :             fprintf(output, "PUNCT_FINQUOTE "); break;
; 1020 :         case XML_REGEXP_PUNCT_OTHERS:
; 1021 :             fprintf(output, "PUNCT_OTHERS "); break;
; 1022 :         case XML_REGEXP_SEPAR:
; 1023 :             fprintf(output, "SEPAR "); break;
; 1024 :         case XML_REGEXP_SEPAR_SPACE:
; 1025 :             fprintf(output, "SEPAR_SPACE "); break;
; 1026 :         case XML_REGEXP_SEPAR_LINE:
; 1027 :             fprintf(output, "SEPAR_LINE "); break;
; 1028 :         case XML_REGEXP_SEPAR_PARA:
; 1029 :             fprintf(output, "SEPAR_PARA "); break;
; 1030 :         case XML_REGEXP_SYMBOL:
; 1031 :             fprintf(output, "SYMBOL "); break;
; 1032 :         case XML_REGEXP_SYMBOL_MATH:
; 1033 :             fprintf(output, "SYMBOL_MATH "); break;
; 1034 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 1035 :             fprintf(output, "SYMBOL_CURRENCY "); break;
; 1036 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 1037 :             fprintf(output, "SYMBOL_MODIFIER "); break;
; 1038 :         case XML_REGEXP_SYMBOL_OTHERS:
; 1039 :             fprintf(output, "SYMBOL_OTHERS "); break;
; 1040 :         case XML_REGEXP_OTHER:
; 1041 :             fprintf(output, "OTHER "); break;
; 1042 :         case XML_REGEXP_OTHER_CONTROL:
; 1043 :             fprintf(output, "OTHER_CONTROL "); break;
; 1044 :         case XML_REGEXP_OTHER_FORMAT:
; 1045 :             fprintf(output, "OTHER_FORMAT "); break;
; 1046 :         case XML_REGEXP_OTHER_PRIVATE:
; 1047 :             fprintf(output, "OTHER_PRIVATE "); break;
; 1048 :         case XML_REGEXP_OTHER_NA:
; 1049 :             fprintf(output, "OTHER_NA "); break;
; 1050 :         case XML_REGEXP_BLOCK_NAME:
; 1051 : 	    fprintf(output, "BLOCK "); break;
; 1052 :     }
; 1053 : }
; 1054 : 
; 1055 : static void
; 1056 : xmlRegPrintQuantType(FILE *output, xmlRegQuantType type) {
; 1057 :     switch (type) {
; 1058 :         case XML_REGEXP_QUANT_EPSILON:
; 1059 : 	    fprintf(output, "epsilon "); break;
; 1060 :         case XML_REGEXP_QUANT_ONCE:
; 1061 : 	    fprintf(output, "once "); break;
; 1062 :         case XML_REGEXP_QUANT_OPT:
; 1063 : 	    fprintf(output, "? "); break;
; 1064 :         case XML_REGEXP_QUANT_MULT:
; 1065 : 	    fprintf(output, "* "); break;
; 1066 :         case XML_REGEXP_QUANT_PLUS:
; 1067 : 	    fprintf(output, "+ "); break;
; 1068 : 	case XML_REGEXP_QUANT_RANGE:
; 1069 : 	    fprintf(output, "range "); break;
; 1070 : 	case XML_REGEXP_QUANT_ONCEONLY:
; 1071 : 	    fprintf(output, "onceonly "); break;
; 1072 : 	case XML_REGEXP_QUANT_ALL:
; 1073 : 	    fprintf(output, "all "); break;
; 1074 :     }
; 1075 : }
; 1076 : static void
; 1077 : xmlRegPrintRange(FILE *output, xmlRegRangePtr range) {
; 1078 :     fprintf(output, "  range: ");
; 1079 :     if (range->neg)
; 1080 : 	fprintf(output, "negative ");
; 1081 :     xmlRegPrintAtomType(output, range->type);
; 1082 :     fprintf(output, "%c - %c\n", range->start, range->end);
; 1083 : }
; 1084 : 
; 1085 : static void
; 1086 : xmlRegPrintAtom(FILE *output, xmlRegAtomPtr atom) {
; 1087 :     fprintf(output, " atom: ");
; 1088 :     if (atom == NULL) {
; 1089 : 	fprintf(output, "NULL\n");
; 1090 : 	return;
; 1091 :     }
; 1092 :     if (atom->neg)
; 1093 :         fprintf(output, "not ");
; 1094 :     xmlRegPrintAtomType(output, atom->type);
; 1095 :     xmlRegPrintQuantType(output, atom->quant);
; 1096 :     if (atom->quant == XML_REGEXP_QUANT_RANGE)
; 1097 : 	fprintf(output, "%d-%d ", atom->min, atom->max);
; 1098 :     if (atom->type == XML_REGEXP_STRING)
; 1099 : 	fprintf(output, "'%s' ", (char *) atom->valuep);
; 1100 :     if (atom->type == XML_REGEXP_CHARVAL)
; 1101 : 	fprintf(output, "char %c\n", atom->codepoint);
; 1102 :     else if (atom->type == XML_REGEXP_RANGES) {
; 1103 : 	int i;
; 1104 : 	fprintf(output, "%d entries\n", atom->nbRanges);
; 1105 : 	for (i = 0; i < atom->nbRanges;i++)
; 1106 : 	    xmlRegPrintRange(output, atom->ranges[i]);
; 1107 :     } else if (atom->type == XML_REGEXP_SUBREG) {
; 1108 : 	fprintf(output, "start %d end %d\n", atom->start->no, atom->stop->no);
; 1109 :     } else {
; 1110 : 	fprintf(output, "\n");
; 1111 :     }
; 1112 : }
; 1113 : 
; 1114 : static void
; 1115 : xmlRegPrintTrans(FILE *output, xmlRegTransPtr trans) {
; 1116 :     fprintf(output, "  trans: ");
; 1117 :     if (trans == NULL) {
; 1118 : 	fprintf(output, "NULL\n");
; 1119 : 	return;
; 1120 :     }
; 1121 :     if (trans->to < 0) {
; 1122 : 	fprintf(output, "removed\n");
; 1123 : 	return;
; 1124 :     }
; 1125 :     if (trans->nd != 0) {
; 1126 : 	if (trans->nd == 2)
; 1127 : 	    fprintf(output, "last not determinist, ");
; 1128 : 	else
; 1129 : 	    fprintf(output, "not determinist, ");
; 1130 :     }
; 1131 :     if (trans->counter >= 0) {
; 1132 : 	fprintf(output, "counted %d, ", trans->counter);
; 1133 :     }
; 1134 :     if (trans->count == REGEXP_ALL_COUNTER) {
; 1135 : 	fprintf(output, "all transition, ");
; 1136 :     } else if (trans->count >= 0) {
; 1137 : 	fprintf(output, "count based %d, ", trans->count);
; 1138 :     }
; 1139 :     if (trans->atom == NULL) {
; 1140 : 	fprintf(output, "epsilon to %d\n", trans->to);
; 1141 : 	return;
; 1142 :     }
; 1143 :     if (trans->atom->type == XML_REGEXP_CHARVAL)
; 1144 : 	fprintf(output, "char %c ", trans->atom->codepoint);
; 1145 :     fprintf(output, "atom %d, to %d\n", trans->atom->no, trans->to);
; 1146 : }
; 1147 : 
; 1148 : static void
; 1149 : xmlRegPrintState(FILE *output, xmlRegStatePtr state) {
; 1150 :     int i;
; 1151 : 
; 1152 :     fprintf(output, " state: ");
; 1153 :     if (state == NULL) {
; 1154 : 	fprintf(output, "NULL\n");
; 1155 : 	return;
; 1156 :     }
; 1157 :     if (state->type == XML_REGEXP_START_STATE)
; 1158 : 	fprintf(output, "START ");
; 1159 :     if (state->type == XML_REGEXP_FINAL_STATE)
; 1160 : 	fprintf(output, "FINAL ");
; 1161 : 
; 1162 :     fprintf(output, "%d, %d transitions:\n", state->no, state->nbTrans);
; 1163 :     for (i = 0;i < state->nbTrans; i++) {
; 1164 : 	xmlRegPrintTrans(output, &(state->trans[i]));
; 1165 :     }
; 1166 : }
; 1167 : 
; 1168 : #ifdef DEBUG_REGEXP_GRAPH
; 1169 : static void
; 1170 : xmlRegPrintCtxt(FILE *output, xmlRegParserCtxtPtr ctxt) {
; 1171 :     int i;
; 1172 : 
; 1173 :     fprintf(output, " ctxt: ");
; 1174 :     if (ctxt == NULL) {
; 1175 : 	fprintf(output, "NULL\n");
; 1176 : 	return;
; 1177 :     }
; 1178 :     fprintf(output, "'%s' ", ctxt->string);
; 1179 :     if (ctxt->error)
; 1180 : 	fprintf(output, "error ");
; 1181 :     if (ctxt->neg)
; 1182 : 	fprintf(output, "neg ");
; 1183 :     fprintf(output, "\n");
; 1184 :     fprintf(output, "%d atoms:\n", ctxt->nbAtoms);
; 1185 :     for (i = 0;i < ctxt->nbAtoms; i++) {
; 1186 : 	fprintf(output, " %02d ", i);
; 1187 : 	xmlRegPrintAtom(output, ctxt->atoms[i]);
; 1188 :     }
; 1189 :     if (ctxt->atom != NULL) {
; 1190 : 	fprintf(output, "current atom:\n");
; 1191 : 	xmlRegPrintAtom(output, ctxt->atom);
; 1192 :     }
; 1193 :     fprintf(output, "%d states:", ctxt->nbStates);
; 1194 :     if (ctxt->start != NULL)
; 1195 : 	fprintf(output, " start: %d", ctxt->start->no);
; 1196 :     if (ctxt->end != NULL)
; 1197 : 	fprintf(output, " end: %d", ctxt->end->no);
; 1198 :     fprintf(output, "\n");
; 1199 :     for (i = 0;i < ctxt->nbStates; i++) {
; 1200 : 	xmlRegPrintState(output, ctxt->states[i]);
; 1201 :     }
; 1202 :     fprintf(output, "%d counters:\n", ctxt->nbCounters);
; 1203 :     for (i = 0;i < ctxt->nbCounters; i++) {
; 1204 : 	fprintf(output, " %d: min %d max %d\n", i, ctxt->counters[i].min,
; 1205 : 		                                ctxt->counters[i].max);
; 1206 :     }
; 1207 : }
; 1208 : #endif
; 1209 : 
; 1210 : /************************************************************************
; 1211 :  *									*
; 1212 :  *		 Finite Automata structures manipulations		*
; 1213 :  *									*
; 1214 :  ************************************************************************/
; 1215 : 
; 1216 : static void
; 1217 : xmlRegAtomAddRange(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom,
; 1218 : 	           int neg, xmlRegAtomType type, int start, int end,
; 1219 : 		   xmlChar *blockName) {
; 1220 :     xmlRegRangePtr range;
; 1221 : 
; 1222 :     if (atom == NULL) {
; 1223 : 	ERROR("add range: atom is NULL");
; 1224 : 	return;
; 1225 :     }
; 1226 :     if (atom->type != XML_REGEXP_RANGES) {
; 1227 : 	ERROR("add range: atom is not ranges");
; 1228 : 	return;
; 1229 :     }
; 1230 :     if (atom->maxRanges == 0) {
; 1231 : 	atom->maxRanges = 4;
; 1232 : 	atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *
; 1233 : 		                             sizeof(xmlRegRangePtr));
; 1234 : 	if (atom->ranges == NULL) {
; 1235 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");
; 1236 : 	    atom->maxRanges = 0;
; 1237 : 	    return;
; 1238 : 	}
; 1239 :     } else if (atom->nbRanges >= atom->maxRanges) {
; 1240 : 	xmlRegRangePtr *tmp;
; 1241 : 	atom->maxRanges *= 2;
; 1242 : 	tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *
; 1243 : 		                             sizeof(xmlRegRangePtr));
; 1244 : 	if (tmp == NULL) {
; 1245 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");
; 1246 : 	    atom->maxRanges /= 2;
; 1247 : 	    return;
; 1248 : 	}
; 1249 : 	atom->ranges = tmp;
; 1250 :     }
; 1251 :     range = xmlRegNewRange(ctxt, neg, type, start, end);
; 1252 :     if (range == NULL)
; 1253 : 	return;
; 1254 :     range->blockName = blockName;
; 1255 :     atom->ranges[atom->nbRanges++] = range;
; 1256 : 
; 1257 : }
; 1258 : 
; 1259 : static int
; 1260 : xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {
; 1261 :     if (ctxt->maxCounters == 0) {
; 1262 : 	ctxt->maxCounters = 4;
; 1263 : 	ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *
; 1264 : 		                             sizeof(xmlRegCounter));
; 1265 : 	if (ctxt->counters == NULL) {
; 1266 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");
; 1267 : 	    ctxt->maxCounters = 0;
; 1268 : 	    return(-1);
; 1269 : 	}
; 1270 :     } else if (ctxt->nbCounters >= ctxt->maxCounters) {
; 1271 : 	xmlRegCounter *tmp;
; 1272 : 	ctxt->maxCounters *= 2;
; 1273 : 	tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *
; 1274 : 		                           sizeof(xmlRegCounter));
; 1275 : 	if (tmp == NULL) {
; 1276 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");
; 1277 : 	    ctxt->maxCounters /= 2;
; 1278 : 	    return(-1);
; 1279 : 	}
; 1280 : 	ctxt->counters = tmp;
; 1281 :     }
; 1282 :     ctxt->counters[ctxt->nbCounters].min = -1;
; 1283 :     ctxt->counters[ctxt->nbCounters].max = -1;
; 1284 :     return(ctxt->nbCounters++);
; 1285 : }
; 1286 : 
; 1287 : static int
; 1288 : xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {
; 1289 :     if (atom == NULL) {
; 1290 : 	ERROR("atom push: atom is NULL");
; 1291 : 	return(-1);
; 1292 :     }
; 1293 :     if (ctxt->maxAtoms == 0) {
; 1294 : 	ctxt->maxAtoms = 4;
; 1295 : 	ctxt->atoms = (xmlRegAtomPtr *) xmlMalloc(ctxt->maxAtoms *
; 1296 : 		                             sizeof(xmlRegAtomPtr));
; 1297 : 	if (ctxt->atoms == NULL) {
; 1298 : 	    xmlRegexpErrMemory(ctxt, "pushing atom");
; 1299 : 	    ctxt->maxAtoms = 0;
; 1300 : 	    return(-1);
; 1301 : 	}
; 1302 :     } else if (ctxt->nbAtoms >= ctxt->maxAtoms) {
; 1303 : 	xmlRegAtomPtr *tmp;
; 1304 : 	ctxt->maxAtoms *= 2;
; 1305 : 	tmp = (xmlRegAtomPtr *) xmlRealloc(ctxt->atoms, ctxt->maxAtoms *
; 1306 : 		                             sizeof(xmlRegAtomPtr));
; 1307 : 	if (tmp == NULL) {
; 1308 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");
; 1309 : 	    ctxt->maxAtoms /= 2;
; 1310 : 	    return(-1);
; 1311 : 	}
; 1312 : 	ctxt->atoms = tmp;
; 1313 :     }
; 1314 :     atom->no = ctxt->nbAtoms;
; 1315 :     ctxt->atoms[ctxt->nbAtoms++] = atom;
; 1316 :     return(0);
; 1317 : }
; 1318 : 
; 1319 : static void
; 1320 : xmlRegStateAddTransTo(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr target,
; 1321 :                       int from) {
; 1322 :     if (target->maxTransTo == 0) {
; 1323 : 	target->maxTransTo = 8;
; 1324 : 	target->transTo = (int *) xmlMalloc(target->maxTransTo *
; 1325 : 		                             sizeof(int));
; 1326 : 	if (target->transTo == NULL) {
; 1327 : 	    xmlRegexpErrMemory(ctxt, "adding transition");
; 1328 : 	    target->maxTransTo = 0;
; 1329 : 	    return;
; 1330 : 	}
; 1331 :     } else if (target->nbTransTo >= target->maxTransTo) {
; 1332 : 	int *tmp;
; 1333 : 	target->maxTransTo *= 2;
; 1334 : 	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *
; 1335 : 		                             sizeof(int));
; 1336 : 	if (tmp == NULL) {
; 1337 : 	    xmlRegexpErrMemory(ctxt, "adding transition");
; 1338 : 	    target->maxTransTo /= 2;
; 1339 : 	    return;
; 1340 : 	}
; 1341 : 	target->transTo = tmp;
; 1342 :     }
; 1343 :     target->transTo[target->nbTransTo] = from;
; 1344 :     target->nbTransTo++;
; 1345 : }
; 1346 : 
; 1347 : static void
; 1348 : xmlRegStateAddTrans(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state,
; 1349 : 	            xmlRegAtomPtr atom, xmlRegStatePtr target,
; 1350 : 		    int counter, int count) {
; 1351 : 
; 1352 :     int nrtrans;
; 1353 : 
; 1354 :     if (state == NULL) {
; 1355 : 	ERROR("add state: state is NULL");
; 1356 : 	return;
; 1357 :     }
; 1358 :     if (target == NULL) {
; 1359 : 	ERROR("add state: target is NULL");
; 1360 : 	return;
; 1361 :     }
; 1362 :     /*
; 1363 :      * Other routines follow the philosophy 'When in doubt, add a transition'
; 1364 :      * so we check here whether such a transition is already present and, if
; 1365 :      * so, silently ignore this request.
; 1366 :      */
; 1367 : 
; 1368 :     for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {
; 1369 : 	xmlRegTransPtr trans = &(state->trans[nrtrans]);
; 1370 : 	if ((trans->atom == atom) &&
; 1371 : 	    (trans->to == target->no) &&
; 1372 : 	    (trans->counter == counter) &&
; 1373 : 	    (trans->count == count)) {
; 1374 : #ifdef DEBUG_REGEXP_GRAPH
; 1375 : 	    printf("Ignoring duplicate transition from %d to %d\n",
; 1376 : 		    state->no, target->no);
; 1377 : #endif
; 1378 : 	    return;
; 1379 : 	}
; 1380 :     }
; 1381 : 
; 1382 :     if (state->maxTrans == 0) {
; 1383 : 	state->maxTrans = 8;
; 1384 : 	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *
; 1385 : 		                             sizeof(xmlRegTrans));
; 1386 : 	if (state->trans == NULL) {
; 1387 : 	    xmlRegexpErrMemory(ctxt, "adding transition");
; 1388 : 	    state->maxTrans = 0;
; 1389 : 	    return;
; 1390 : 	}
; 1391 :     } else if (state->nbTrans >= state->maxTrans) {
; 1392 : 	xmlRegTrans *tmp;
; 1393 : 	state->maxTrans *= 2;
; 1394 : 	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *
; 1395 : 		                             sizeof(xmlRegTrans));
; 1396 : 	if (tmp == NULL) {
; 1397 : 	    xmlRegexpErrMemory(ctxt, "adding transition");
; 1398 : 	    state->maxTrans /= 2;
; 1399 : 	    return;
; 1400 : 	}
; 1401 : 	state->trans = tmp;
; 1402 :     }
; 1403 : #ifdef DEBUG_REGEXP_GRAPH
; 1404 :     printf("Add trans from %d to %d ", state->no, target->no);
; 1405 :     if (count == REGEXP_ALL_COUNTER)
; 1406 : 	printf("all transition\n");
; 1407 :     else if (count >= 0)
; 1408 : 	printf("count based %d\n", count);
; 1409 :     else if (counter >= 0)
; 1410 : 	printf("counted %d\n", counter);
; 1411 :     else if (atom == NULL)
; 1412 : 	printf("epsilon transition\n");
; 1413 :     else if (atom != NULL)
; 1414 :         xmlRegPrintAtom(stdout, atom);
; 1415 : #endif
; 1416 : 
; 1417 :     state->trans[state->nbTrans].atom = atom;
; 1418 :     state->trans[state->nbTrans].to = target->no;
; 1419 :     state->trans[state->nbTrans].counter = counter;
; 1420 :     state->trans[state->nbTrans].count = count;
; 1421 :     state->trans[state->nbTrans].nd = 0;
; 1422 :     state->nbTrans++;
; 1423 :     xmlRegStateAddTransTo(ctxt, target, state->no);
; 1424 : }
; 1425 : 
; 1426 : static int
; 1427 : xmlRegStatePush(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {
; 1428 :     if (state == NULL) return(-1);
; 1429 :     if (ctxt->maxStates == 0) {
; 1430 : 	ctxt->maxStates = 4;
; 1431 : 	ctxt->states = (xmlRegStatePtr *) xmlMalloc(ctxt->maxStates *
; 1432 : 		                             sizeof(xmlRegStatePtr));
; 1433 : 	if (ctxt->states == NULL) {
; 1434 : 	    xmlRegexpErrMemory(ctxt, "adding state");
; 1435 : 	    ctxt->maxStates = 0;
; 1436 : 	    return(-1);
; 1437 : 	}
; 1438 :     } else if (ctxt->nbStates >= ctxt->maxStates) {
; 1439 : 	xmlRegStatePtr *tmp;
; 1440 : 	ctxt->maxStates *= 2;
; 1441 : 	tmp = (xmlRegStatePtr *) xmlRealloc(ctxt->states, ctxt->maxStates *
; 1442 : 		                             sizeof(xmlRegStatePtr));
; 1443 : 	if (tmp == NULL) {
; 1444 : 	    xmlRegexpErrMemory(ctxt, "adding state");
; 1445 : 	    ctxt->maxStates /= 2;
; 1446 : 	    return(-1);
; 1447 : 	}
; 1448 : 	ctxt->states = tmp;
; 1449 :     }
; 1450 :     state->no = ctxt->nbStates;
; 1451 :     ctxt->states[ctxt->nbStates++] = state;
; 1452 :     return(0);
; 1453 : }
; 1454 : 
; 1455 : /**
; 1456 :  * xmlFAGenerateAllTransition:
; 1457 :  * @ctxt:  a regexp parser context
; 1458 :  * @from:  the from state
; 1459 :  * @to:  the target state or NULL for building a new one
; 1460 :  * @lax:
; 1461 :  *
; 1462 :  */
; 1463 : static void
; 1464 : xmlFAGenerateAllTransition(xmlRegParserCtxtPtr ctxt,
; 1465 : 			   xmlRegStatePtr from, xmlRegStatePtr to,
; 1466 : 			   int lax) {
; 1467 :     if (to == NULL) {
; 1468 : 	to = xmlRegNewState(ctxt);
; 1469 : 	xmlRegStatePush(ctxt, to);
; 1470 : 	ctxt->state = to;
; 1471 :     }
; 1472 :     if (lax)
; 1473 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_LAX_COUNTER);
; 1474 :     else
; 1475 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_COUNTER);
; 1476 : }
; 1477 : 
; 1478 : /**
; 1479 :  * xmlFAGenerateEpsilonTransition:
; 1480 :  * @ctxt:  a regexp parser context
; 1481 :  * @from:  the from state
; 1482 :  * @to:  the target state or NULL for building a new one
; 1483 :  *
; 1484 :  */
; 1485 : static void
; 1486 : xmlFAGenerateEpsilonTransition(xmlRegParserCtxtPtr ctxt,
; 1487 : 			       xmlRegStatePtr from, xmlRegStatePtr to) {
; 1488 :     if (to == NULL) {
; 1489 : 	to = xmlRegNewState(ctxt);
; 1490 : 	xmlRegStatePush(ctxt, to);
; 1491 : 	ctxt->state = to;
; 1492 :     }
; 1493 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);
; 1494 : }
; 1495 : 
; 1496 : /**
; 1497 :  * xmlFAGenerateCountedEpsilonTransition:
; 1498 :  * @ctxt:  a regexp parser context
; 1499 :  * @from:  the from state
; 1500 :  * @to:  the target state or NULL for building a new one
; 1501 :  * counter:  the counter for that transition
; 1502 :  *
; 1503 :  */
; 1504 : static void
; 1505 : xmlFAGenerateCountedEpsilonTransition(xmlRegParserCtxtPtr ctxt,
; 1506 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
; 1507 :     if (to == NULL) {
; 1508 : 	to = xmlRegNewState(ctxt);
; 1509 : 	xmlRegStatePush(ctxt, to);
; 1510 : 	ctxt->state = to;
; 1511 :     }
; 1512 :     xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);
; 1513 : }
; 1514 : 
; 1515 : /**
; 1516 :  * xmlFAGenerateCountedTransition:
; 1517 :  * @ctxt:  a regexp parser context
; 1518 :  * @from:  the from state
; 1519 :  * @to:  the target state or NULL for building a new one
; 1520 :  * counter:  the counter for that transition
; 1521 :  *
; 1522 :  */
; 1523 : static void
; 1524 : xmlFAGenerateCountedTransition(xmlRegParserCtxtPtr ctxt,
; 1525 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {
; 1526 :     if (to == NULL) {
; 1527 : 	to = xmlRegNewState(ctxt);
; 1528 : 	xmlRegStatePush(ctxt, to);
; 1529 : 	ctxt->state = to;
; 1530 :     }
; 1531 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);
; 1532 : }
; 1533 : 
; 1534 : /**
; 1535 :  * xmlFAGenerateTransitions:
; 1536 :  * @ctxt:  a regexp parser context
; 1537 :  * @from:  the from state
; 1538 :  * @to:  the target state or NULL for building a new one
; 1539 :  * @atom:  the atom generating the transition
; 1540 :  *
; 1541 :  * Returns 0 if success and -1 in case of error.
; 1542 :  */
; 1543 : static int
; 1544 : xmlFAGenerateTransitions(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr from,
; 1545 : 	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {
; 1546 :     xmlRegStatePtr end;
; 1547 :     int nullable = 0;
; 1548 : 
; 1549 :     if (atom == NULL) {
; 1550 : 	ERROR("genrate transition: atom == NULL");
; 1551 : 	return(-1);
; 1552 :     }
; 1553 :     if (atom->type == XML_REGEXP_SUBREG) {
; 1554 : 	/*
; 1555 : 	 * this is a subexpression handling one should not need to
; 1556 : 	 * create a new node except for XML_REGEXP_QUANT_RANGE.
; 1557 : 	 */
; 1558 : 	if (xmlRegAtomPush(ctxt, atom) < 0) {
; 1559 : 	    return(-1);
; 1560 : 	}
; 1561 : 	if ((to != NULL) && (atom->stop != to) &&
; 1562 : 	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
; 1563 : 	    /*
; 1564 : 	     * Generate an epsilon transition to link to the target
; 1565 : 	     */
; 1566 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
; 1567 : #ifdef DV
; 1568 : 	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
; 1569 : 		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
; 1570 : 	    to = xmlRegNewState(ctxt);
; 1571 : 	    xmlRegStatePush(ctxt, to);
; 1572 : 	    ctxt->state = to;
; 1573 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
; 1574 : #endif
; 1575 : 	}
; 1576 : 	switch (atom->quant) {
; 1577 : 	    case XML_REGEXP_QUANT_OPT:
; 1578 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1579 : 		/*
; 1580 : 		 * transition done to the state after end of atom.
; 1581 : 		 *      1. set transition from atom start to new state
; 1582 : 		 *      2. set transition from atom end to this state.
; 1583 : 		 */
; 1584 :                 if (to == NULL) {
; 1585 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);
; 1586 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->stop,
; 1587 :                                                    ctxt->state);
; 1588 :                 } else {
; 1589 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
; 1590 :                 }
; 1591 : 		break;
; 1592 : 	    case XML_REGEXP_QUANT_MULT:
; 1593 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1594 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);
; 1595 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
; 1596 : 		break;
; 1597 : 	    case XML_REGEXP_QUANT_PLUS:
; 1598 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1599 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);
; 1600 : 		break;
; 1601 : 	    case XML_REGEXP_QUANT_RANGE: {
; 1602 : 		int counter;
; 1603 : 		xmlRegStatePtr inter, newstate;
; 1604 : 
; 1605 : 		/*
; 1606 : 		 * create the final state now if needed
; 1607 : 		 */
; 1608 : 		if (to != NULL) {
; 1609 : 		    newstate = to;
; 1610 : 		} else {
; 1611 : 		    newstate = xmlRegNewState(ctxt);
; 1612 : 		    xmlRegStatePush(ctxt, newstate);
; 1613 : 		}
; 1614 : 
; 1615 : 		/*
; 1616 : 		 * The principle here is to use counted transition
; 1617 : 		 * to avoid explosion in the number of states in the
; 1618 : 		 * graph. This is clearly more complex but should not
; 1619 : 		 * be exploitable at runtime.
; 1620 : 		 */
; 1621 : 		if ((atom->min == 0) && (atom->start0 == NULL)) {
; 1622 : 		    xmlRegAtomPtr copy;
; 1623 : 		    /*
; 1624 : 		     * duplicate a transition based on atom to count next
; 1625 : 		     * occurences after 1. We cannot loop to atom->start
; 1626 : 		     * directly because we need an epsilon transition to
; 1627 : 		     * newstate.
; 1628 : 		     */
; 1629 : 		     /* ???? For some reason it seems we never reach that
; 1630 : 		        case, I suppose this got optimized out before when
; 1631 : 			building the automata */
; 1632 : 		    copy = xmlRegCopyAtom(ctxt, atom);
; 1633 : 		    if (copy == NULL)
; 1634 : 		        return(-1);
; 1635 : 		    copy->quant = XML_REGEXP_QUANT_ONCE;
; 1636 : 		    copy->min = 0;
; 1637 : 		    copy->max = 0;
; 1638 : 
; 1639 : 		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
; 1640 : 		        < 0)
; 1641 : 			return(-1);
; 1642 : 		    inter = ctxt->state;
; 1643 : 		    counter = xmlRegGetCounter(ctxt);
; 1644 : 		    ctxt->counters[counter].min = atom->min - 1;
; 1645 : 		    ctxt->counters[counter].max = atom->max - 1;
; 1646 : 		    /* count the number of times we see it again */
; 1647 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,
; 1648 : 						   atom->stop, counter);
; 1649 : 		    /* allow a way out based on the count */
; 1650 : 		    xmlFAGenerateCountedTransition(ctxt, inter,
; 1651 : 			                           newstate, counter);
; 1652 : 		    /* and also allow a direct exit for 0 */
; 1653 : 		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,
; 1654 : 		                                   newstate);
; 1655 : 		} else {
; 1656 : 		    /*
; 1657 : 		     * either we need the atom at least once or there
; 1658 : 		     * is an atom->start0 allowing to easilly plug the
; 1659 : 		     * epsilon transition.
; 1660 : 		     */
; 1661 : 		    counter = xmlRegGetCounter(ctxt);
; 1662 : 		    ctxt->counters[counter].min = atom->min - 1;
; 1663 : 		    ctxt->counters[counter].max = atom->max - 1;
; 1664 : 		    /* count the number of times we see it again */
; 1665 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,
; 1666 : 						   atom->start, counter);
; 1667 : 		    /* allow a way out based on the count */
; 1668 : 		    xmlFAGenerateCountedTransition(ctxt, atom->stop,
; 1669 : 			                           newstate, counter);
; 1670 : 		    /* and if needed allow a direct exit for 0 */
; 1671 : 		    if (atom->min == 0)
; 1672 : 			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,
; 1673 : 						       newstate);
; 1674 : 
; 1675 : 		}
; 1676 : 		atom->min = 0;
; 1677 : 		atom->max = 0;
; 1678 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1679 : 		ctxt->state = newstate;
; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);
; 1685 :     }
; 1686 :     if ((atom->min == 0) && (atom->max == 0) &&
; 1687 :                (atom->quant == XML_REGEXP_QUANT_RANGE)) {
; 1688 :         /*
; 1689 : 	 * we can discard the atom and generate an epsilon transition instead
; 1690 : 	 */
; 1691 : 	if (to == NULL) {
; 1692 : 	    to = xmlRegNewState(ctxt);
; 1693 : 	    if (to != NULL)
; 1694 : 		xmlRegStatePush(ctxt, to);
; 1695 : 	    else {
; 1696 : 		return(-1);
; 1697 : 	    }
; 1698 : 	}
; 1699 : 	xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1700 : 	ctxt->state = to;
; 1701 : 	xmlRegFreeAtom(atom);
; 1702 : 	return(0);
; 1703 :     }
; 1704 :     if (to == NULL) {
; 1705 : 	to = xmlRegNewState(ctxt);
; 1706 : 	if (to != NULL)
; 1707 : 	    xmlRegStatePush(ctxt, to);
; 1708 : 	else {
; 1709 : 	    return(-1);
; 1710 : 	}
; 1711 :     }
; 1712 :     end = to;
; 1713 :     if ((atom->quant == XML_REGEXP_QUANT_MULT) ||
; 1714 :         (atom->quant == XML_REGEXP_QUANT_PLUS)) {
; 1715 : 	/*
; 1716 : 	 * Do not pollute the target state by adding transitions from
; 1717 : 	 * it as it is likely to be the shared target of multiple branches.
; 1718 : 	 * So isolate with an epsilon transition.
; 1719 : 	 */
; 1720 :         xmlRegStatePtr tmp;
; 1721 : 
; 1722 : 	tmp = xmlRegNewState(ctxt);
; 1723 : 	if (tmp != NULL)
; 1724 : 	    xmlRegStatePush(ctxt, tmp);
; 1725 : 	else {
; 1726 : 	    return(-1);
; 1727 : 	}
; 1728 : 	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);
; 1729 : 	to = tmp;
; 1730 :     }
; 1731 :     if (xmlRegAtomPush(ctxt, atom) < 0) {
; 1732 : 	return(-1);
; 1733 :     }
; 1734 :     if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
; 1735 :         (atom->min == 0) && (atom->max > 0)) {
; 1736 : 	nullable = 1;
; 1737 : 	atom->min = 1;
; 1738 :         if (atom->max == 1)
; 1739 : 	    atom->quant = XML_REGEXP_QUANT_OPT;
; 1740 :     }
; 1741 :     xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);
; 1742 :     ctxt->state = end;
; 1743 :     switch (atom->quant) {
; 1744 : 	case XML_REGEXP_QUANT_OPT:
; 1745 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;
; 1746 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1747 : 	    break;
; 1748 : 	case XML_REGEXP_QUANT_MULT:
; 1749 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;
; 1750 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1751 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
; 1752 : 	    break;
; 1753 : 	case XML_REGEXP_QUANT_PLUS:
; 1754 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;
; 1755 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);
; 1756 : 	    break;
; 1757 : 	case XML_REGEXP_QUANT_RANGE:
; 1758 : 	    if (nullable)
; 1759 : 		xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1760 : 	    break;
; 1761 : 	default:
; 1762 : 	    break;
; 1763 :     }
; 1764 :     return(0);
; 1765 : }
; 1766 : 
; 1767 : /**
; 1768 :  * xmlFAReduceEpsilonTransitions:
; 1769 :  * @ctxt:  a regexp parser context
; 1770 :  * @fromnr:  the from state
; 1771 :  * @tonr:  the to state
; 1772 :  * @counter:  should that transition be associated to a counted
; 1773 :  *
; 1774 :  */
; 1775 : static void
; 1776 : xmlFAReduceEpsilonTransitions(xmlRegParserCtxtPtr ctxt, int fromnr,
; 1777 : 	                      int tonr, int counter) {
; 1778 :     int transnr;
; 1779 :     xmlRegStatePtr from;
; 1780 :     xmlRegStatePtr to;
; 1781 : 
; 1782 : #ifdef DEBUG_REGEXP_GRAPH
; 1783 :     printf("xmlFAReduceEpsilonTransitions(%d, %d)\n", fromnr, tonr);
; 1784 : #endif
; 1785 :     from = ctxt->states[fromnr];
; 1786 :     if (from == NULL)
; 1787 : 	return;
; 1788 :     to = ctxt->states[tonr];
; 1789 :     if (to == NULL)
; 1790 : 	return;
; 1791 :     if ((to->mark == XML_REGEXP_MARK_START) ||
; 1792 : 	(to->mark == XML_REGEXP_MARK_VISITED))
; 1793 : 	return;
; 1794 : 
; 1795 :     to->mark = XML_REGEXP_MARK_VISITED;
; 1796 :     if (to->type == XML_REGEXP_FINAL_STATE) {
; 1797 : #ifdef DEBUG_REGEXP_GRAPH
; 1798 : 	printf("State %d is final, so %d becomes final\n", tonr, fromnr);
; 1799 : #endif
; 1800 : 	from->type = XML_REGEXP_FINAL_STATE;
; 1801 :     }
; 1802 :     for (transnr = 0;transnr < to->nbTrans;transnr++) {
; 1803 :         if (to->trans[transnr].to < 0)
; 1804 : 	    continue;
; 1805 : 	if (to->trans[transnr].atom == NULL) {
; 1806 : 	    /*
; 1807 : 	     * Don't remove counted transitions
; 1808 : 	     * Don't loop either
; 1809 : 	     */
; 1810 : 	    if (to->trans[transnr].to != fromnr) {
; 1811 : 		if (to->trans[transnr].count >= 0) {
; 1812 : 		    int newto = to->trans[transnr].to;
; 1813 : 
; 1814 : 		    xmlRegStateAddTrans(ctxt, from, NULL,
; 1815 : 					ctxt->states[newto],
; 1816 : 					-1, to->trans[transnr].count);
; 1817 : 		} else {
; 1818 : #ifdef DEBUG_REGEXP_GRAPH
; 1819 : 		    printf("Found epsilon trans %d from %d to %d\n",
; 1820 : 			   transnr, tonr, to->trans[transnr].to);
; 1821 : #endif
; 1822 : 		    if (to->trans[transnr].counter >= 0) {
; 1823 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,
; 1824 : 					      to->trans[transnr].to,
; 1825 : 					      to->trans[transnr].counter);
; 1826 : 		    } else {
; 1827 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,
; 1828 : 					      to->trans[transnr].to,
; 1829 : 					      counter);
; 1830 : 		    }
; 1831 : 		}
; 1832 : 	    }
; 1833 : 	} else {
; 1834 : 	    int newto = to->trans[transnr].to;
; 1835 : 
; 1836 : 	    if (to->trans[transnr].counter >= 0) {
; 1837 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,
; 1838 : 				    ctxt->states[newto],
; 1839 : 				    to->trans[transnr].counter, -1);
; 1840 : 	    } else {
; 1841 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,
; 1842 : 				    ctxt->states[newto], counter, -1);
; 1843 : 	    }
; 1844 : 	}
; 1845 :     }
; 1846 :     to->mark = XML_REGEXP_MARK_NORMAL;
; 1847 : }
; 1848 : 
; 1849 : /**
; 1850 :  * xmlFAEliminateSimpleEpsilonTransitions:
; 1851 :  * @ctxt:  a regexp parser context
; 1852 :  *
; 1853 :  * Eliminating general epsilon transitions can get costly in the general
; 1854 :  * algorithm due to the large amount of generated new transitions and
; 1855 :  * associated comparisons. However for simple epsilon transition used just
; 1856 :  * to separate building blocks when generating the automata this can be
; 1857 :  * reduced to state elimination:
; 1858 :  *    - if there exists an epsilon from X to Y
; 1859 :  *    - if there is no other transition from X
; 1860 :  * then X and Y are semantically equivalent and X can be eliminated
; 1861 :  * If X is the start state then make Y the start state, else replace the
; 1862 :  * target of all transitions to X by transitions to Y.
; 1863 :  */
; 1864 : static void
; 1865 : xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {
; 1866 :     int statenr, i, j, newto;
; 1867 :     xmlRegStatePtr state, tmp;
; 1868 : 
; 1869 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	eax, DWORD PTR [edx+48]
	inc	ebx
	mov	DWORD PTR _statenr$1$[ebp], ebx
	cmp	ebx, eax
	jl	$LL55@xmlFAElimi
$LN54@xmlFAElimi:

; 1930 :     int statenr, transnr;
; 1931 :     xmlRegStatePtr state;
; 1932 :     int has_epsilon;
; 1933 : 
; 1934 :     if (ctxt->states == NULL) return;
; 1935 : 
; 1936 :     /*
; 1937 :      * Eliminate simple epsilon transition and the associated unreachable
; 1938 :      * states.
; 1939 :      */
; 1940 :     xmlFAEliminateSimpleEpsilonTransitions(ctxt);
; 1941 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN3@xmlFAElimi
	npad	6
$LL4@xmlFAElimi:

; 1942 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	esi, DWORD PTR [eax+edi*4]

; 1943 : 	if ((state != NULL) && (state->type == XML_REGEXP_UNREACH_STATE)) {

	test	esi, esi
	je	SHORT $LN2@xmlFAElimi
	cmp	DWORD PTR [esi], 5
	jne	SHORT $LN2@xmlFAElimi

; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN73@xmlFAElimi

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN73@xmlFAElimi:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN74@xmlFAElimi

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN74@xmlFAElimi:

; 905  :     xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree

; 1944 : #ifdef DEBUG_REGEXP_GRAPH
; 1945 : 	    printf("Removed unreachable state %d\n", statenr);
; 1946 : #endif
; 1947 : 	    xmlRegFreeState(state);
; 1948 : 	    ctxt->states[statenr] = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]

; 905  :     xmlFree(state);

	add	esp, 4

; 1944 : #ifdef DEBUG_REGEXP_GRAPH
; 1945 : 	    printf("Removed unreachable state %d\n", statenr);
; 1946 : #endif
; 1947 : 	    xmlRegFreeState(state);
; 1948 : 	    ctxt->states[statenr] = NULL;

	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [eax+edi*4], 0
$LN2@xmlFAElimi:

; 1930 :     int statenr, transnr;
; 1931 :     xmlRegStatePtr state;
; 1932 :     int has_epsilon;
; 1933 : 
; 1934 :     if (ctxt->states == NULL) return;
; 1935 : 
; 1936 :     /*
; 1937 :      * Eliminate simple epsilon transition and the associated unreachable
; 1938 :      * states.
; 1939 :      */
; 1940 :     xmlFAEliminateSimpleEpsilonTransitions(ctxt);
; 1941 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	eax, DWORD PTR [edx+48]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL4@xmlFAElimi
$LN3@xmlFAElimi:

; 1949 : 	}
; 1950 :     }
; 1951 : 
; 1952 :     has_epsilon = 0;
; 1953 : 
; 1954 :     /*
; 1955 :      * Build the completed transitions bypassing the epsilons
; 1956 :      * Use a marking algorithm to avoid loops
; 1957 :      * Mark sink states too.
; 1958 :      * Process from the latests states backward to the start when
; 1959 :      * there is long cascading epsilon chains this minimize the
; 1960 :      * recursions and transition compares when adding the new ones
; 1961 :      */
; 1962 :     for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {

	lea	ecx, DWORD PTR [eax-1]
	xor	ebx, ebx
	mov	DWORD PTR _has_epsilon$1$[ebp], ebx
	mov	DWORD PTR _statenr$2$[ebp], ecx
	test	ecx, ecx
	js	$LN6@xmlFAElimi
$LL7@xmlFAElimi:

; 1963 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	esi, DWORD PTR [eax+ecx*4]

; 1964 : 	if (state == NULL)

	test	esi, esi
	je	$LN5@xmlFAElimi

; 1965 : 	    continue;
; 1966 : 	if ((state->nbTrans == 0) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN34@xmlFAElimi
	cmp	DWORD PTR [esi], 2
	je	SHORT $LN34@xmlFAElimi

; 1967 : 	    (state->type != XML_REGEXP_FINAL_STATE)) {
; 1968 : 	    state->type = XML_REGEXP_SINK_STATE;

	mov	DWORD PTR [esi], 4
$LN34@xmlFAElimi:

; 1969 : 	}
; 1970 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@xmlFAElimi
	xor	edi, edi
	npad	5
$LL10@xmlFAElimi:

; 1971 : 	    if ((state->trans[transnr].atom == NULL) &&

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [edi+eax], 0
	jne	SHORT $LN8@xmlFAElimi
	mov	ecx, DWORD PTR [edi+eax+4]
	test	ecx, ecx
	js	SHORT $LN8@xmlFAElimi

; 1972 : 		(state->trans[transnr].to >= 0)) {
; 1973 : 		if (state->trans[transnr].to == statenr) {

	cmp	ecx, DWORD PTR _statenr$2$[ebp]
	jne	SHORT $LN36@xmlFAElimi

; 1974 : 		    state->trans[transnr].to = -1;

	mov	DWORD PTR [edi+eax+4], -1
	jmp	SHORT $LN8@xmlFAElimi
$LN36@xmlFAElimi:

; 1975 : #ifdef DEBUG_REGEXP_GRAPH
; 1976 : 		    printf("Removed loopback epsilon trans %d on %d\n",
; 1977 : 			   transnr, statenr);
; 1978 : #endif
; 1979 : 		} else if (state->trans[transnr].count < 0) {

	cmp	DWORD PTR [edi+eax+12], 0
	jge	SHORT $LN8@xmlFAElimi

; 1980 : 		    int newto = state->trans[transnr].to;
; 1981 : 
; 1982 : #ifdef DEBUG_REGEXP_GRAPH
; 1983 : 		    printf("Found epsilon trans %d from %d to %d\n",
; 1984 : 			   transnr, statenr, newto);
; 1985 : #endif
; 1986 : 		    has_epsilon = 1;
; 1987 : 		    state->trans[transnr].to = -2;

	mov	DWORD PTR [edi+eax+4], -2		; fffffffeH

; 1988 : 		    state->mark = XML_REGEXP_MARK_START;
; 1989 : 		    xmlFAReduceEpsilonTransitions(ctxt, statenr,

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR _has_epsilon$1$[ebp], 1
	push	DWORD PTR [edi+eax+8]
	push	ecx
	push	DWORD PTR _statenr$2$[ebp]
	push	edx
	call	_xmlFAReduceEpsilonTransitions
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	esp, 16					; 00000010H

; 1990 : 				      newto, state->trans[transnr].counter);
; 1991 : 		    state->mark = XML_REGEXP_MARK_NORMAL;

	mov	DWORD PTR [esi+4], 0
$LN8@xmlFAElimi:

; 1969 : 	}
; 1970 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	inc	ebx
	add	edi, 20					; 00000014H
	cmp	ebx, DWORD PTR [esi+24]
	jl	SHORT $LL10@xmlFAElimi
	mov	ecx, DWORD PTR _statenr$2$[ebp]
$LN5@xmlFAElimi:

; 1949 : 	}
; 1950 :     }
; 1951 : 
; 1952 :     has_epsilon = 0;
; 1953 : 
; 1954 :     /*
; 1955 :      * Build the completed transitions bypassing the epsilons
; 1956 :      * Use a marking algorithm to avoid loops
; 1957 :      * Mark sink states too.
; 1958 :      * Process from the latests states backward to the start when
; 1959 :      * there is long cascading epsilon chains this minimize the
; 1960 :      * recursions and transition compares when adding the new ones
; 1961 :      */
; 1962 :     for (statenr = ctxt->nbStates - 1;statenr >= 0;statenr--) {

	sub	ecx, 1
	mov	DWORD PTR _statenr$2$[ebp], ecx
	jns	$LL7@xmlFAElimi
	mov	eax, DWORD PTR [edx+48]
	mov	ebx, DWORD PTR _has_epsilon$1$[ebp]
$LN6@xmlFAElimi:

; 1992 : #ifdef DEBUG_REGEXP_GRAPH
; 1993 : 		} else {
; 1994 : 		    printf("Found counted transition %d on %d\n",
; 1995 : 			   transnr, statenr);
; 1996 : #endif
; 1997 : 	        }
; 1998 : 	    }
; 1999 : 	}
; 2000 :     }
; 2001 :     /*
; 2002 :      * Eliminate the epsilon transitions
; 2003 :      */
; 2004 :     if (has_epsilon) {

	mov	ecx, eax
	test	ebx, ebx
	je	SHORT $LN12@xmlFAElimi

; 2005 : 	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN12@xmlFAElimi
$LL13@xmlFAElimi:

; 2006 : 	    state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	edi, DWORD PTR [eax+ebx*4]

; 2007 : 	    if (state == NULL)

	test	edi, edi
	je	SHORT $LN11@xmlFAElimi

; 2008 : 		continue;
; 2009 : 	    for (transnr = 0;transnr < state->nbTrans;transnr++) {

	xor	ecx, ecx
	cmp	DWORD PTR [edi+24], ecx
	jle	SHORT $LN11@xmlFAElimi
	xor	esi, esi
$LL16@xmlFAElimi:

; 2010 : 		xmlRegTransPtr trans = &(state->trans[transnr]);

	mov	eax, DWORD PTR [edi+28]
	add	eax, esi

; 2011 : 		if ((trans->atom == NULL) &&
; 2012 : 		    (trans->count < 0) &&

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@xmlFAElimi
	cmp	DWORD PTR [eax+12], 0
	jge	SHORT $LN14@xmlFAElimi
	cmp	DWORD PTR [eax+4], 0
	jl	SHORT $LN14@xmlFAElimi

; 2013 : 		    (trans->to >= 0)) {
; 2014 : 		    trans->to = -1;

	mov	DWORD PTR [eax+4], -1
$LN14@xmlFAElimi:

; 2008 : 		continue;
; 2009 : 	    for (transnr = 0;transnr < state->nbTrans;transnr++) {

	inc	ecx
	add	esi, 20					; 00000014H
	cmp	ecx, DWORD PTR [edi+24]
	jl	SHORT $LL16@xmlFAElimi
$LN11@xmlFAElimi:

; 2005 : 	for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	ecx, DWORD PTR [edx+48]
	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LL13@xmlFAElimi
$LN12@xmlFAElimi:

; 2015 : 		}
; 2016 : 	    }
; 2017 : 	}
; 2018 :     }
; 2019 : 
; 2020 :     /*
; 2021 :      * Use this pass to detect unreachable states too
; 2022 :      */
; 2023 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN18@xmlFAElimi
	npad	4
$LL19@xmlFAElimi:

; 2024 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	eax, DWORD PTR [eax+esi*4]

; 2025 : 	if (state != NULL)

	test	eax, eax
	je	SHORT $LN17@xmlFAElimi

; 2026 : 	    state->reached = XML_REGEXP_MARK_NORMAL;

	mov	DWORD PTR [eax+12], 0
$LN17@xmlFAElimi:

; 2015 : 		}
; 2016 : 	    }
; 2017 : 	}
; 2018 :     }
; 2019 : 
; 2020 :     /*
; 2021 :      * Use this pass to detect unreachable states too
; 2022 :      */
; 2023 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	ecx, DWORD PTR [edx+48]
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL19@xmlFAElimi
$LN18@xmlFAElimi:

; 2027 :     }
; 2028 :     state = ctxt->states[0];

	mov	eax, DWORD PTR [edx+52]
	mov	edi, DWORD PTR [eax]

; 2029 :     if (state != NULL)

	test	edi, edi
	je	$LN21@xmlFAElimi

; 2030 : 	state->reached = XML_REGEXP_MARK_START;

	mov	DWORD PTR [edi+12], 1
	mov	ecx, DWORD PTR [edx+48]
$LL20@xmlFAElimi:

; 2031 :     while (state != NULL) {
; 2032 : 	xmlRegStatePtr target = NULL;

	xor	ebx, ebx

; 2033 : 	state->reached = XML_REGEXP_MARK_VISITED;

	mov	DWORD PTR [edi+12], 2

; 2034 : 	/*
; 2035 : 	 * Mark all states reachable from the current reachable state
; 2036 : 	 */
; 2037 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	xor	ecx, ecx
	mov	DWORD PTR _target$1$[ebp], ebx
	cmp	DWORD PTR [edi+24], ecx
	jle	SHORT $LN138@xmlFAElimi

; 2031 :     while (state != NULL) {
; 2032 : 	xmlRegStatePtr target = NULL;

	xor	esi, esi
$LL24@xmlFAElimi:

; 2038 : 	    if ((state->trans[transnr].to >= 0) &&

	mov	eax, DWORD PTR [edi+28]
	mov	ebx, DWORD PTR [esi+eax+4]
	test	ebx, ebx
	js	SHORT $LN143@xmlFAElimi
	cmp	DWORD PTR [esi+eax], 0
	jne	SHORT $LN45@xmlFAElimi
	cmp	DWORD PTR [esi+eax+12], 0
	jl	SHORT $LN143@xmlFAElimi
$LN45@xmlFAElimi:

; 2039 : 		((state->trans[transnr].atom != NULL) ||
; 2040 : 		 (state->trans[transnr].count >= 0))) {
; 2041 : 		int newto = state->trans[transnr].to;
; 2042 : 
; 2043 : 		if (ctxt->states[newto] == NULL)

	mov	eax, DWORD PTR [edx+52]
	mov	eax, DWORD PTR [eax+ebx*4]
	test	eax, eax
	je	SHORT $LN143@xmlFAElimi

; 2044 : 		    continue;
; 2045 : 		if (ctxt->states[newto]->reached == XML_REGEXP_MARK_NORMAL) {

	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN143@xmlFAElimi

; 2046 : 		    ctxt->states[newto]->reached = XML_REGEXP_MARK_START;

	mov	DWORD PTR [eax+12], 1

; 2047 : 		    target = ctxt->states[newto];

	mov	eax, DWORD PTR [edx+52]
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _target$1$[ebp], ebx
	jmp	SHORT $LN22@xmlFAElimi
$LN143@xmlFAElimi:

; 2034 : 	/*
; 2035 : 	 * Mark all states reachable from the current reachable state
; 2036 : 	 */
; 2037 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	mov	ebx, DWORD PTR _target$1$[ebp]
$LN22@xmlFAElimi:
	inc	ecx
	add	esi, 20					; 00000014H
	cmp	ecx, DWORD PTR [edi+24]
	jl	SHORT $LL24@xmlFAElimi

; 2048 : 		}
; 2049 : 	    }
; 2050 : 	}
; 2051 : 
; 2052 : 	/*
; 2053 : 	 * find the next accessible state not explored
; 2054 : 	 */
; 2055 : 	if (target == NULL) {

	test	ebx, ebx
	jne	SHORT $LN139@xmlFAElimi
$LN138@xmlFAElimi:

; 2056 : 	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {

	mov	edi, DWORD PTR [edx+48]
	mov	esi, 1
	cmp	edi, esi
	jle	SHORT $LN139@xmlFAElimi

; 2057 : 		state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	add	eax, 4
$LL27@xmlFAElimi:
	mov	ecx, DWORD PTR [eax]

; 2058 : 		if ((state != NULL) && (state->reached ==

	test	ecx, ecx
	je	SHORT $LN25@xmlFAElimi
	cmp	DWORD PTR [ecx+12], 1
	je	SHORT $LN94@xmlFAElimi
$LN25@xmlFAElimi:

; 2056 : 	    for (statenr = 1;statenr < ctxt->nbStates;statenr++) {

	inc	esi
	add	eax, 4
	cmp	esi, edi
	jl	SHORT $LL27@xmlFAElimi
	jmp	SHORT $LN139@xmlFAElimi
$LN94@xmlFAElimi:

; 2059 : 			XML_REGEXP_MARK_START)) {
; 2060 : 		    target = state;

	mov	ebx, ecx
$LN139@xmlFAElimi:

; 2061 : 		    break;
; 2062 : 		}
; 2063 : 	    }
; 2064 : 	}
; 2065 : 	state = target;

	mov	edi, ebx
	test	ebx, ebx
	jne	$LL20@xmlFAElimi
	mov	ecx, DWORD PTR [edx+48]
$LN21@xmlFAElimi:

; 2066 :     }
; 2067 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN144@xmlFAElimi
	npad	4
$LL30@xmlFAElimi:

; 2068 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [edx+52]
	mov	esi, DWORD PTR [eax+edi*4]

; 2069 : 	if ((state != NULL) && (state->reached == XML_REGEXP_MARK_NORMAL)) {

	test	esi, esi
	je	SHORT $LN28@xmlFAElimi
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN28@xmlFAElimi

; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN78@xmlFAElimi

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN78@xmlFAElimi:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN79@xmlFAElimi

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN79@xmlFAElimi:

; 905  :     xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree

; 2070 : #ifdef DEBUG_REGEXP_GRAPH
; 2071 : 	    printf("Removed unreachable state %d\n", statenr);
; 2072 : #endif
; 2073 : 	    xmlRegFreeState(state);
; 2074 : 	    ctxt->states[statenr] = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]

; 905  :     xmlFree(state);

	add	esp, 4

; 2070 : #ifdef DEBUG_REGEXP_GRAPH
; 2071 : 	    printf("Removed unreachable state %d\n", statenr);
; 2072 : #endif
; 2073 : 	    xmlRegFreeState(state);
; 2074 : 	    ctxt->states[statenr] = NULL;

	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [eax+edi*4], 0
$LN28@xmlFAElimi:

; 2066 :     }
; 2067 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	inc	edi
	cmp	edi, DWORD PTR [edx+48]
	jl	SHORT $LL30@xmlFAElimi
$LN144@xmlFAElimi:
	pop	edi
	pop	esi
	pop	ebx
$LN29@xmlFAElimi:

; 2075 : 	}
; 2076 :     }
; 2077 : 
; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAEliminateEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAEliminateSimpleEpsilonTransitions
_TEXT	SEGMENT
_state$1$ = -16						; size = 4
_statenr$1$ = -12					; size = 4
_newto$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAEliminateSimpleEpsilonTransitions PROC		; COMDAT

; 1865 : xmlFAEliminateSimpleEpsilonTransitions(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	mov	DWORD PTR _statenr$1$[ebp], edx
	cmp	DWORD PTR [esi+48], edx
	jle	$LN3@xmlFAElimi
	push	ebx
	push	edi
$LL4@xmlFAElimi:

; 1870 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _state$1$[ebp], ecx

; 1871 : 	if (state == NULL)

	test	ecx, ecx
	je	$LN2@xmlFAElimi

; 1872 : 	    continue;
; 1873 : 	if (state->nbTrans != 1)

	cmp	DWORD PTR [ecx+24], 1
	jne	$LN2@xmlFAElimi

; 1874 : 	    continue;
; 1875 : 	if (state->type == XML_REGEXP_UNREACH_STATE)

	mov	edi, DWORD PTR [ecx]
	cmp	edi, 5
	je	$LN2@xmlFAElimi

; 1876 : 	    continue;
; 1877 : 	/* is the only transition out a basic transition */
; 1878 : 	if ((state->trans[0].atom == NULL) &&
; 1879 : 	    (state->trans[0].to >= 0) &&
; 1880 : 	    (state->trans[0].to != statenr) &&
; 1881 : 	    (state->trans[0].counter < 0) &&

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@xmlFAElimi
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _newto$1$[ebp], ebx
	test	ebx, ebx
	js	$LN2@xmlFAElimi
	cmp	ebx, edx
	je	$LN2@xmlFAElimi
	cmp	DWORD PTR [eax+8], 0
	jge	$LN2@xmlFAElimi
	cmp	DWORD PTR [eax+12], 0
	jge	$LN2@xmlFAElimi

; 1882 : 	    (state->trans[0].count < 0)) {
; 1883 : 	    newto = state->trans[0].to;
; 1884 : 
; 1885 :             if (state->type == XML_REGEXP_START_STATE) {

	cmp	edi, 1
	je	$LN2@xmlFAElimi

; 1886 : #ifdef DEBUG_REGEXP_GRAPH
; 1887 : 		printf("Found simple epsilon trans from start %d to %d\n",
; 1888 : 		       statenr, newto);
; 1889 : #endif
; 1890 :             } else {
; 1891 : #ifdef DEBUG_REGEXP_GRAPH
; 1892 : 		printf("Found simple epsilon trans from %d to %d\n",
; 1893 : 		       statenr, newto);
; 1894 : #endif
; 1895 : 	        for (i = 0;i < state->nbTransTo;i++) {

	xor	ebx, ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	DWORD PTR [ecx+36], ebx
	jle	SHORT $LN6@xmlFAElimi
$LL7@xmlFAElimi:

; 1896 : 		    tmp = ctxt->states[state->transTo[i]];

	mov	eax, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 1897 : 		    for (j = 0;j < tmp->nbTrans;j++) {

	xor	ebx, ebx
	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edi+24], ebx
	jle	SHORT $LN5@xmlFAElimi

; 1896 : 		    tmp = ctxt->states[state->transTo[i]];

	xor	esi, esi
	npad	8
$LL10@xmlFAElimi:

; 1898 : 			if (tmp->trans[j].to == statenr) {

	mov	eax, DWORD PTR [edi+28]
	cmp	DWORD PTR [eax+esi+4], edx
	jne	SHORT $LN8@xmlFAElimi

; 1899 : #ifdef DEBUG_REGEXP_GRAPH
; 1900 : 			    printf("Changed transition %d on %d to go to %d\n",
; 1901 : 				   j, tmp->no, newto);
; 1902 : #endif
; 1903 : 			    tmp->trans[j].to = -1;
; 1904 : 			    xmlRegStateAddTrans(ctxt, tmp, tmp->trans[j].atom,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+esi+4], -1
	mov	ecx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edx+52]
	mov	edx, DWORD PTR _newto$1$[ebp]
	push	DWORD PTR [ecx+esi+12]
	push	DWORD PTR [ecx+esi+8]
	push	DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [ecx+esi]
	push	edi
	push	edx
	call	_xmlRegStateAddTrans
	mov	edx, DWORD PTR _statenr$1$[ebp]
	add	esp, 24					; 00000018H
$LN8@xmlFAElimi:

; 1897 : 		    for (j = 0;j < tmp->nbTrans;j++) {

	inc	ebx
	add	esi, 20					; 00000014H
	cmp	ebx, DWORD PTR [edi+24]
	jl	SHORT $LL10@xmlFAElimi
	mov	esi, DWORD PTR _ctxt$[ebp]
$LN5@xmlFAElimi:

; 1886 : #ifdef DEBUG_REGEXP_GRAPH
; 1887 : 		printf("Found simple epsilon trans from start %d to %d\n",
; 1888 : 		       statenr, newto);
; 1889 : #endif
; 1890 :             } else {
; 1891 : #ifdef DEBUG_REGEXP_GRAPH
; 1892 : 		printf("Found simple epsilon trans from %d to %d\n",
; 1893 : 		       statenr, newto);
; 1894 : #endif
; 1895 : 	        for (i = 0;i < state->nbTransTo;i++) {

	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR _state$1$[ebp]
	inc	ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, DWORD PTR [ecx+36]
	jl	SHORT $LL7@xmlFAElimi
	mov	edi, DWORD PTR [ecx]
$LN6@xmlFAElimi:

; 1905 : 						ctxt->states[newto],
; 1906 : 					        tmp->trans[j].counter,
; 1907 : 						tmp->trans[j].count);
; 1908 : 			}
; 1909 : 		    }
; 1910 : 		}
; 1911 : 		if (state->type == XML_REGEXP_FINAL_STATE)

	cmp	edi, 2
	jne	SHORT $LN18@xmlFAElimi

; 1912 : 		    ctxt->states[newto]->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR _newto$1$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax], edi
$LN18@xmlFAElimi:

; 1913 : 		/* eliminate the transition completely */
; 1914 : 		state->nbTrans = 0;

	mov	DWORD PTR [ecx+24], 0

; 1915 : 
; 1916 :                 state->type = XML_REGEXP_UNREACH_STATE;

	mov	DWORD PTR [ecx], 5
$LN2@xmlFAElimi:

; 1866 :     int statenr, i, j, newto;
; 1867 :     xmlRegStatePtr state, tmp;
; 1868 : 
; 1869 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	inc	edx
	mov	DWORD PTR _statenr$1$[ebp], edx
	cmp	edx, DWORD PTR [esi+48]
	jl	$LL4@xmlFAElimi
	pop	edi
	pop	ebx
$LN3@xmlFAElimi:
	pop	esi

; 1917 : 
; 1918 : 	    }
; 1919 : 
; 1920 : 	}
; 1921 :     }
; 1922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAEliminateSimpleEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAReduceEpsilonTransitions
_TEXT	SEGMENT
tv632 = -8						; size = 4
_transnr$1$ = -4					; size = 4
_from$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_fromnr$ = 12						; size = 4
_tonr$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAReduceEpsilonTransitions PROC			; COMDAT

; 1777 : 	                      int tonr, int counter) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _fromnr$[ebp]
	mov	edi, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _from$1$[ebp], ebx
	test	ebx, ebx
	je	$LN8@xmlFAReduc

; 1778 :     int transnr;
; 1779 :     xmlRegStatePtr from;
; 1780 :     xmlRegStatePtr to;
; 1781 : 
; 1782 : #ifdef DEBUG_REGEXP_GRAPH
; 1783 :     printf("xmlFAReduceEpsilonTransitions(%d, %d)\n", fromnr, tonr);
; 1784 : #endif
; 1785 :     from = ctxt->states[fromnr];
; 1786 :     if (from == NULL)
; 1787 : 	return;
; 1788 :     to = ctxt->states[tonr];

	mov	eax, DWORD PTR _tonr$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]

; 1789 :     if (to == NULL)

	test	edi, edi
	je	$LN8@xmlFAReduc

; 1790 : 	return;
; 1791 :     if ((to->mark == XML_REGEXP_MARK_START) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	$LN8@xmlFAReduc
	cmp	eax, 2
	je	$LN8@xmlFAReduc

; 1792 : 	(to->mark == XML_REGEXP_MARK_VISITED))
; 1793 : 	return;
; 1794 : 
; 1795 :     to->mark = XML_REGEXP_MARK_VISITED;
; 1796 :     if (to->type == XML_REGEXP_FINAL_STATE) {

	cmp	DWORD PTR [edi], 2
	mov	DWORD PTR [edi+4], 2
	jne	SHORT $LN9@xmlFAReduc

; 1797 : #ifdef DEBUG_REGEXP_GRAPH
; 1798 : 	printf("State %d is final, so %d becomes final\n", tonr, fromnr);
; 1799 : #endif
; 1800 : 	from->type = XML_REGEXP_FINAL_STATE;

	mov	DWORD PTR [ebx], 2
$LN9@xmlFAReduc:

; 1801 :     }
; 1802 :     for (transnr = 0;transnr < to->nbTrans;transnr++) {

	cmp	DWORD PTR [edi+24], 0
	mov	DWORD PTR _transnr$1$[ebp], 0
	jle	$LN3@xmlFAReduc
	xor	ecx, ecx
	mov	DWORD PTR tv632[ebp], ecx
$LL4@xmlFAReduc:

; 1803 :         if (to->trans[transnr].to < 0)

	mov	eax, DWORD PTR [edi+28]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	js	SHORT $LN2@xmlFAReduc

; 1804 : 	    continue;
; 1805 : 	if (to->trans[transnr].atom == NULL) {

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	jne	SHORT $LN11@xmlFAReduc

; 1806 : 	    /*
; 1807 : 	     * Don't remove counted transitions
; 1808 : 	     * Don't loop either
; 1809 : 	     */
; 1810 : 	    if (to->trans[transnr].to != fromnr) {

	cmp	ecx, DWORD PTR _fromnr$[ebp]
	je	SHORT $LN2@xmlFAReduc

; 1811 : 		if (to->trans[transnr].count >= 0) {

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	js	SHORT $LN14@xmlFAReduc

; 1812 : 		    int newto = to->trans[transnr].to;
; 1813 : 
; 1814 : 		    xmlRegStateAddTrans(ctxt, from, NULL,

	mov	eax, DWORD PTR [esi+52]
	push	edx
	push	-1
	push	DWORD PTR [eax+ecx*4]
	push	0

; 1815 : 					ctxt->states[newto],
; 1816 : 					-1, to->trans[transnr].count);
; 1817 : 		} else {

	jmp	SHORT $LN25@xmlFAReduc
$LN14@xmlFAReduc:

; 1818 : #ifdef DEBUG_REGEXP_GRAPH
; 1819 : 		    printf("Found epsilon trans %d from %d to %d\n",
; 1820 : 			   transnr, tonr, to->trans[transnr].to);
; 1821 : #endif
; 1822 : 		    if (to->trans[transnr].counter >= 0) {

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	js	SHORT $LN16@xmlFAReduc

; 1823 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,

	push	eax
	push	ecx
	push	DWORD PTR _fromnr$[ebp]
	push	esi
	call	_xmlFAReduceEpsilonTransitions
	add	esp, 16					; 00000010H

; 1824 : 					      to->trans[transnr].to,
; 1825 : 					      to->trans[transnr].counter);
; 1826 : 		    } else {

	jmp	SHORT $LN2@xmlFAReduc
$LN16@xmlFAReduc:

; 1827 : 			xmlFAReduceEpsilonTransitions(ctxt, fromnr,

	push	DWORD PTR _counter$[ebp]
	push	ecx
	push	DWORD PTR _fromnr$[ebp]
	push	esi
	call	_xmlFAReduceEpsilonTransitions
	add	esp, 16					; 00000010H

; 1828 : 					      to->trans[transnr].to,
; 1829 : 					      counter);
; 1830 : 		    }
; 1831 : 		}
; 1832 : 	    }
; 1833 : 	} else {

	jmp	SHORT $LN2@xmlFAReduc
$LN11@xmlFAReduc:

; 1834 : 	    int newto = to->trans[transnr].to;
; 1835 : 
; 1836 : 	    if (to->trans[transnr].counter >= 0) {

	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi+52]
	push	-1
	mov	eax, DWORD PTR [eax+ecx*4]
	test	ebx, ebx
	js	SHORT $LN18@xmlFAReduc

; 1837 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,

	push	ebx

; 1838 : 				    ctxt->states[newto],
; 1839 : 				    to->trans[transnr].counter, -1);
; 1840 : 	    } else {

	jmp	SHORT $LN26@xmlFAReduc
$LN18@xmlFAReduc:

; 1841 : 		xmlRegStateAddTrans(ctxt, from, to->trans[transnr].atom,

	push	DWORD PTR _counter$[ebp]
$LN26@xmlFAReduc:

; 1801 :     }
; 1802 :     for (transnr = 0;transnr < to->nbTrans;transnr++) {

	mov	ebx, DWORD PTR _from$1$[ebp]
	push	eax
	push	edx
$LN25@xmlFAReduc:
	push	ebx
	push	esi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
$LN2@xmlFAReduc:
	mov	eax, DWORD PTR _transnr$1$[ebp]
	mov	ecx, DWORD PTR tv632[ebp]
	inc	eax
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _transnr$1$[ebp], eax
	mov	DWORD PTR tv632[ebp], ecx
	cmp	eax, DWORD PTR [edi+24]
	jl	$LL4@xmlFAReduc
$LN3@xmlFAReduc:

; 1842 : 				    ctxt->states[newto], counter, -1);
; 1843 : 	    }
; 1844 : 	}
; 1845 :     }
; 1846 :     to->mark = XML_REGEXP_MARK_NORMAL;

	mov	DWORD PTR [edi+4], 0
$LN8@xmlFAReduc:
	pop	edi

; 1847 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFAReduceEpsilonTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateTransitions
_TEXT	SEGMENT
_end$1$ = -8						; size = 4
_nullable$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_tmp$1$ = 20						; size = 4
_newstate$1$ = 20					; size = 4
_atom$ = 20						; size = 4
_xmlFAGenerateTransitions PROC				; COMDAT

; 1545 : 	                 xmlRegStatePtr to, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _atom$[ebp]
	mov	DWORD PTR _nullable$1$[ebp], 0
	test	ebx, ebx
	jne	SHORT $LN6@xmlFAGener

; 1546 :     xmlRegStatePtr end;
; 1547 :     int nullable = 0;
; 1548 : 
; 1549 :     if (atom == NULL) {
; 1550 : 	ERROR("genrate transition: atom == NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0CB@LMLDANHN@genrate?5transition?3?5atom?5?$DN?$DN?5NUL@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1551 : 	return(-1);

	or	eax, -1
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlFAGener:

; 1552 :     }
; 1553 :     if (atom->type == XML_REGEXP_SUBREG) {

	cmp	DWORD PTR [ebx+4], 4
	push	esi
	push	edi
	jne	$LN7@xmlFAGener

; 1554 : 	/*
; 1555 : 	 * this is a subexpression handling one should not need to
; 1556 : 	 * create a new node except for XML_REGEXP_QUANT_RANGE.
; 1557 : 	 */
; 1558 : 	if (xmlRegAtomPush(ctxt, atom) < 0) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	edi
	call	_xmlRegAtomPush
	add	esp, 8
	test	eax, eax
	js	$LN33@xmlFAGener

; 1559 : 	    return(-1);
; 1560 : 	}
; 1561 : 	if ((to != NULL) && (atom->stop != to) &&

	mov	esi, DWORD PTR _to$[ebp]
	mov	DWORD PTR _newstate$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN9@xmlFAGener
	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, esi
	je	SHORT $LN9@xmlFAGener
	cmp	DWORD PTR [ebx+8], 8
	je	SHORT $LN9@xmlFAGener

; 1562 : 	    (atom->quant != XML_REGEXP_QUANT_RANGE)) {
; 1563 : 	    /*
; 1564 : 	     * Generate an epsilon transition to link to the target
; 1565 : 	     */
; 1566 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);

	push	esi
	push	eax
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN9@xmlFAGener:

; 1567 : #ifdef DV
; 1568 : 	} else if ((to == NULL) && (atom->quant != XML_REGEXP_QUANT_RANGE) &&
; 1569 : 		   (atom->quant != XML_REGEXP_QUANT_ONCE)) {
; 1570 : 	    to = xmlRegNewState(ctxt);
; 1571 : 	    xmlRegStatePush(ctxt, to);
; 1572 : 	    ctxt->state = to;
; 1573 : 	    xmlFAGenerateEpsilonTransition(ctxt, atom->stop, to);
; 1574 : #endif
; 1575 : 	}
; 1576 : 	switch (atom->quant) {

	mov	eax, DWORD PTR [ebx+8]
	add	eax, -3					; fffffffdH
	cmp	eax, 5
	ja	$LN23@xmlFAGener
	jmp	DWORD PTR $LN51@xmlFAGener[eax*4]
$LN10@xmlFAGener:

; 1577 : 	    case XML_REGEXP_QUANT_OPT:
; 1578 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [ebx+8], 2

; 1579 : 		/*
; 1580 : 		 * transition done to the state after end of atom.
; 1581 : 		 *      1. set transition from atom start to new state
; 1582 : 		 *      2. set transition from atom end to this state.
; 1583 : 		 */
; 1584 :                 if (to == NULL) {

	test	esi, esi
	jne	SHORT $LN11@xmlFAGener

; 1585 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, 0);

	push	esi
	push	eax
	push	edi
	call	_xmlFAGenerateEpsilonTransition

; 1586 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->stop,

	mov	eax, DWORD PTR [ebx+44]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR [edi+24]
$LN11@xmlFAGener:

; 1587 :                                                    ctxt->state);
; 1588 :                 } else {
; 1589 :                     xmlFAGenerateEpsilonTransition(ctxt, atom->start, to);
; 1590 :                 }
; 1591 : 		break;

	push	esi
	push	eax
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlFAGener:

; 1592 : 	    case XML_REGEXP_QUANT_MULT:
; 1593 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1594 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->start, atom->stop);

	push	DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+8], 2
	push	DWORD PTR [ebx+36]
	push	edi
	call	_xmlFAGenerateEpsilonTransition

; 1595 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);

	push	DWORD PTR [ebx+36]
	push	DWORD PTR [ebx+44]
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 24					; 00000018H

; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlFAGener:

; 1596 : 		break;
; 1597 : 	    case XML_REGEXP_QUANT_PLUS:
; 1598 : 		atom->quant = XML_REGEXP_QUANT_ONCE;
; 1599 : 		xmlFAGenerateEpsilonTransition(ctxt, atom->stop, atom->start);

	push	DWORD PTR [ebx+36]
	mov	DWORD PTR [ebx+8], 2
	push	DWORD PTR [ebx+44]
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlFAGener:

; 1600 : 		break;
; 1601 : 	    case XML_REGEXP_QUANT_RANGE: {
; 1602 : 		int counter;
; 1603 : 		xmlRegStatePtr inter, newstate;
; 1604 : 
; 1605 : 		/*
; 1606 : 		 * create the final state now if needed
; 1607 : 		 */
; 1608 : 		if (to != NULL) {

	test	esi, esi
	jne	SHORT $LN17@xmlFAGener

; 1609 : 		    newstate = to;
; 1610 : 		} else {
; 1611 : 		    newstate = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState

; 1612 : 		    xmlRegStatePush(ctxt, newstate);

	push	eax
	push	edi
	mov	DWORD PTR _newstate$1$[ebp], eax
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH
$LN17@xmlFAGener:

; 1613 : 		}
; 1614 : 
; 1615 : 		/*
; 1616 : 		 * The principle here is to use counted transition
; 1617 : 		 * to avoid explosion in the number of states in the
; 1618 : 		 * graph. This is clearly more complex but should not
; 1619 : 		 * be exploitable at runtime.
; 1620 : 		 */
; 1621 : 		if ((atom->min == 0) && (atom->start0 == NULL)) {

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN46@xmlFAGener
	cmp	DWORD PTR [ebx+40], 0
	jne	$LN46@xmlFAGener

; 1622 : 		    xmlRegAtomPtr copy;
; 1623 : 		    /*
; 1624 : 		     * duplicate a transition based on atom to count next
; 1625 : 		     * occurences after 1. We cannot loop to atom->start
; 1626 : 		     * directly because we need an epsilon transition to
; 1627 : 		     * newstate.
; 1628 : 		     */
; 1629 : 		     /* ???? For some reason it seems we never reach that
; 1630 : 		        case, I suppose this got optimized out before when
; 1631 : 			building the automata */
; 1632 : 		    copy = xmlRegCopyAtom(ctxt, atom);

	push	ebx
	push	edi
	call	_xmlRegCopyAtom
	add	esp, 8

; 1633 : 		    if (copy == NULL)

	test	eax, eax
	je	$LN33@xmlFAGener

; 1634 : 		        return(-1);
; 1635 : 		    copy->quant = XML_REGEXP_QUANT_ONCE;
; 1636 : 		    copy->min = 0;
; 1637 : 		    copy->max = 0;
; 1638 : 
; 1639 : 		    if (xmlFAGenerateTransitions(ctxt, atom->start, NULL, copy)
; 1640 : 		        < 0)

	push	eax
	push	0
	mov	DWORD PTR [eax+8], 2
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	push	DWORD PTR [ebx+36]
	push	edi
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	js	$LN33@xmlFAGener

; 1641 : 			return(-1);
; 1642 : 		    inter = ctxt->state;
; 1643 : 		    counter = xmlRegGetCounter(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR [edi+24]
	call	_xmlRegGetCounter

; 1644 : 		    ctxt->counters[counter].min = atom->min - 1;

	mov	edx, DWORD PTR [ebx+12]
	mov	esi, eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	dec	edx

; 1645 : 		    ctxt->counters[counter].max = atom->max - 1;
; 1646 : 		    /* count the number of times we see it again */
; 1647 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, inter,

	push	esi
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [ecx+esi*8], edx
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+64]
	dec	ecx
	mov	DWORD PTR [eax+esi*8+4], ecx
	push	DWORD PTR [ebx+44]
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlFAGenerateCountedEpsilonTransition

; 1648 : 						   atom->stop, counter);
; 1649 : 		    /* allow a way out based on the count */
; 1650 : 		    xmlFAGenerateCountedTransition(ctxt, inter,

	push	esi
	mov	esi, DWORD PTR _newstate$1$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	_xmlFAGenerateCountedTransition

; 1651 : 			                           newstate, counter);
; 1652 : 		    /* and also allow a direct exit for 0 */
; 1653 : 		    xmlFAGenerateEpsilonTransition(ctxt, atom->start,

	push	esi
	push	DWORD PTR [ebx+36]
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 48					; 00000030H

; 1654 : 		                                   newstate);
; 1655 : 		} else {

	jmp	SHORT $LN22@xmlFAGener
$LN46@xmlFAGener:

; 1656 : 		    /*
; 1657 : 		     * either we need the atom at least once or there
; 1658 : 		     * is an atom->start0 allowing to easilly plug the
; 1659 : 		     * epsilon transition.
; 1660 : 		     */
; 1661 : 		    counter = xmlRegGetCounter(ctxt);

	push	edi
	call	_xmlRegGetCounter

; 1662 : 		    ctxt->counters[counter].min = atom->min - 1;

	mov	ecx, DWORD PTR [edi+64]
	mov	esi, eax
	mov	edx, DWORD PTR [ebx+12]
	dec	edx

; 1663 : 		    ctxt->counters[counter].max = atom->max - 1;
; 1664 : 		    /* count the number of times we see it again */
; 1665 : 		    xmlFAGenerateCountedEpsilonTransition(ctxt, atom->stop,

	push	esi
	mov	DWORD PTR [ecx+esi*8], edx
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [edi+64]
	dec	ecx
	mov	DWORD PTR [eax+esi*8+4], ecx
	push	DWORD PTR [ebx+36]
	push	DWORD PTR [ebx+44]
	push	edi
	call	_xmlFAGenerateCountedEpsilonTransition

; 1666 : 						   atom->start, counter);
; 1667 : 		    /* allow a way out based on the count */
; 1668 : 		    xmlFAGenerateCountedTransition(ctxt, atom->stop,

	push	esi
	mov	esi, DWORD PTR _newstate$1$[ebp]
	push	esi
	push	DWORD PTR [ebx+44]
	push	edi
	call	_xmlFAGenerateCountedTransition
	add	esp, 36					; 00000024H

; 1669 : 			                           newstate, counter);
; 1670 : 		    /* and if needed allow a direct exit for 0 */
; 1671 : 		    if (atom->min == 0)

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN22@xmlFAGener

; 1672 : 			xmlFAGenerateEpsilonTransition(ctxt, atom->start0,

	push	esi
	push	DWORD PTR [ebx+40]
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN22@xmlFAGener:

; 1673 : 						       newstate);
; 1674 : 
; 1675 : 		}
; 1676 : 		atom->min = 0;

	mov	DWORD PTR [ebx+12], 0

; 1677 : 		atom->max = 0;

	mov	DWORD PTR [ebx+16], 0

; 1678 : 		atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	DWORD PTR [ebx+8], 2

; 1679 : 		ctxt->state = newstate;

	mov	DWORD PTR [edi+24], esi
$LN23@xmlFAGener:

; 1680 : 	    }
; 1681 : 	    default:
; 1682 : 		break;
; 1683 : 	}
; 1684 : 	return(0);

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlFAGener:

; 1685 :     }
; 1686 :     if ((atom->min == 0) && (atom->max == 0) &&

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN24@xmlFAGener
	cmp	DWORD PTR [ebx+16], 0
	jne	SHORT $LN24@xmlFAGener
	cmp	DWORD PTR [ebx+8], 8
	jne	SHORT $LN24@xmlFAGener

; 1687 :                (atom->quant == XML_REGEXP_QUANT_RANGE)) {
; 1688 :         /*
; 1689 : 	 * we can discard the atom and generate an epsilon transition instead
; 1690 : 	 */
; 1691 : 	if (to == NULL) {

	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN27@xmlFAGener

; 1692 : 	    to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax
	add	esp, 4

; 1693 : 	    if (to != NULL)

	test	esi, esi
	je	$LN33@xmlFAGener

; 1694 : 		xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 8
$LN27@xmlFAGener:

; 1695 : 	    else {
; 1696 : 		return(-1);
; 1697 : 	    }
; 1698 : 	}
; 1699 : 	xmlFAGenerateEpsilonTransition(ctxt, from, to);

	push	esi
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlFAGenerateEpsilonTransition

; 1700 : 	ctxt->state = to;
; 1701 : 	xmlRegFreeAtom(atom);

	push	ebx
	mov	DWORD PTR [edi+24], esi
	call	_xmlRegFreeAtom
	add	esp, 16					; 00000010H

; 1702 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlFAGener:

; 1703 :     }
; 1704 :     if (to == NULL) {

	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN30@xmlFAGener

; 1705 : 	to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax
	add	esp, 4

; 1706 : 	if (to != NULL)

	test	esi, esi
	je	$LN33@xmlFAGener

; 1707 : 	    xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 8
$LN30@xmlFAGener:

; 1708 : 	else {
; 1709 : 	    return(-1);
; 1710 : 	}
; 1711 :     }
; 1712 :     end = to;
; 1713 :     if ((atom->quant == XML_REGEXP_QUANT_MULT) ||

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _end$1$[ebp], esi
	cmp	eax, 4
	je	SHORT $LN32@xmlFAGener
	cmp	eax, 5
	jne	SHORT $LN31@xmlFAGener
$LN32@xmlFAGener:

; 1714 :         (atom->quant == XML_REGEXP_QUANT_PLUS)) {
; 1715 : 	/*
; 1716 : 	 * Do not pollute the target state by adding transitions from
; 1717 : 	 * it as it is likely to be the shared target of multiple branches.
; 1718 : 	 * So isolate with an epsilon transition.
; 1719 : 	 */
; 1720 :         xmlRegStatePtr tmp;
; 1721 : 
; 1722 : 	tmp = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR _tmp$1$[ebp], eax

; 1723 : 	if (tmp != NULL)

	test	eax, eax
	je	$LN33@xmlFAGener

; 1724 : 	    xmlRegStatePush(ctxt, tmp);

	push	eax
	push	edi
	call	_xmlRegStatePush

; 1727 : 	}
; 1728 : 	xmlFAGenerateEpsilonTransition(ctxt, tmp, to);

	push	esi
	mov	esi, DWORD PTR _tmp$1$[ebp]
	push	esi
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 20					; 00000014H
$LN31@xmlFAGener:

; 1729 : 	to = tmp;
; 1730 :     }
; 1731 :     if (xmlRegAtomPush(ctxt, atom) < 0) {

	push	ebx
	push	edi
	call	_xmlRegAtomPush
	add	esp, 8
	test	eax, eax
	js	$LN33@xmlFAGener

; 1732 : 	return(-1);
; 1733 :     }
; 1734 :     if ((atom->quant == XML_REGEXP_QUANT_RANGE) &&
; 1735 :         (atom->min == 0) && (atom->max > 0)) {

	cmp	DWORD PTR [ebx+8], 8
	jne	SHORT $LN37@xmlFAGener
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN37@xmlFAGener
	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	jle	SHORT $LN37@xmlFAGener

; 1736 : 	nullable = 1;

	mov	DWORD PTR _nullable$1$[ebp], 1

; 1737 : 	atom->min = 1;

	mov	DWORD PTR [ebx+12], 1

; 1738 :         if (atom->max == 1)

	cmp	eax, 1
	jne	SHORT $LN37@xmlFAGener

; 1739 : 	    atom->quant = XML_REGEXP_QUANT_OPT;

	mov	DWORD PTR [ebx+8], 3
$LN37@xmlFAGener:

; 1740 :     }
; 1741 :     xmlRegStateAddTrans(ctxt, from, atom, to, -1, -1);

	push	-1
	push	-1
	push	esi
	push	ebx
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlRegStateAddTrans

; 1742 :     ctxt->state = end;

	mov	eax, DWORD PTR _end$1$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+24], eax

; 1743 :     switch (atom->quant) {

	mov	eax, DWORD PTR [ebx+8]
	add	eax, -3					; fffffffdH
	cmp	eax, 5
	ja	SHORT $LN42@xmlFAGener
	jmp	DWORD PTR $LN52@xmlFAGener[eax*4]
$LN38@xmlFAGener:

; 1744 : 	case XML_REGEXP_QUANT_OPT:
; 1745 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;

	mov	DWORD PTR [ebx+8], 2

; 1746 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1747 : 	    break;

	jmp	SHORT $LN49@xmlFAGener
$LN39@xmlFAGener:

; 1748 : 	case XML_REGEXP_QUANT_MULT:
; 1749 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;
; 1750 : 	    xmlFAGenerateEpsilonTransition(ctxt, from, to);

	mov	eax, DWORD PTR _from$[ebp]
	push	esi
	push	eax
	push	edi
	mov	DWORD PTR [ebx+8], 2
	call	_xmlFAGenerateEpsilonTransition

; 1751 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);

	push	-1
	push	-1
	push	esi
	push	ebx
	push	esi
	push	edi
	call	_xmlRegStateAddTrans
	add	esp, 36					; 00000024H

; 1759 : 		xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1760 : 	    break;
; 1761 : 	default:
; 1762 : 	    break;
; 1763 :     }
; 1764 :     return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlFAGener:

; 1752 : 	    break;
; 1753 : 	case XML_REGEXP_QUANT_PLUS:
; 1754 : 	    atom->quant = XML_REGEXP_QUANT_ONCE;
; 1755 : 	    xmlRegStateAddTrans(ctxt, to, atom, to, -1, -1);

	push	-1
	push	-1
	push	esi
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebx+8], 2
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H

; 1759 : 		xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1760 : 	    break;
; 1761 : 	default:
; 1762 : 	    break;
; 1763 :     }
; 1764 :     return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlFAGener:

; 1756 : 	    break;
; 1757 : 	case XML_REGEXP_QUANT_RANGE:
; 1758 : 	    if (nullable)

	cmp	DWORD PTR _nullable$1$[ebp], 0
	je	SHORT $LN42@xmlFAGener
$LN49@xmlFAGener:

; 1759 : 		xmlFAGenerateEpsilonTransition(ctxt, from, to);
; 1760 : 	    break;
; 1761 : 	default:
; 1762 : 	    break;
; 1763 :     }
; 1764 :     return(0);

	mov	eax, DWORD PTR _from$[ebp]
	push	esi
	push	eax
	push	edi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN42@xmlFAGener:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlFAGener:
	pop	edi
	pop	esi

; 1725 : 	else {
; 1726 : 	    return(-1);

	or	eax, -1
	pop	ebx

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN51@xmlFAGener:
	DD	$LN10@xmlFAGener
	DD	$LN13@xmlFAGener
	DD	$LN14@xmlFAGener
	DD	$LN23@xmlFAGener
	DD	$LN23@xmlFAGener
	DD	$LN15@xmlFAGener
$LN52@xmlFAGener:
	DD	$LN38@xmlFAGener
	DD	$LN39@xmlFAGener
	DD	$LN40@xmlFAGener
	DD	$LN42@xmlFAGener
	DD	$LN42@xmlFAGener
	DD	$LN41@xmlFAGener
_xmlFAGenerateTransitions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateCountedTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAGenerateCountedTransition PROC			; COMDAT

; 1525 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlFAGener

; 1526 :     if (to == NULL) {
; 1527 : 	to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax

; 1528 : 	xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 1529 : 	ctxt->state = to;

	mov	DWORD PTR [edi+24], esi
$LN2@xmlFAGener:

; 1530 :     }
; 1531 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, counter);

	push	DWORD PTR _counter$[ebp]
	push	-1
	push	esi
	push	0
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1532 : }

	pop	ebp
	ret	0
_xmlFAGenerateCountedTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateCountedEpsilonTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlFAGenerateCountedEpsilonTransition PROC		; COMDAT

; 1506 : 	    xmlRegStatePtr from, xmlRegStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlFAGener

; 1507 :     if (to == NULL) {
; 1508 : 	to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax

; 1509 : 	xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 1510 : 	ctxt->state = to;

	mov	DWORD PTR [edi+24], esi
$LN2@xmlFAGener:

; 1511 :     }
; 1512 :     xmlRegStateAddTrans(ctxt, from, NULL, to, counter, -1);

	push	-1
	push	DWORD PTR _counter$[ebp]
	push	esi
	push	0
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1513 : }

	pop	ebp
	ret	0
_xmlFAGenerateCountedEpsilonTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateEpsilonTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_xmlFAGenerateEpsilonTransition PROC			; COMDAT

; 1487 : 			       xmlRegStatePtr from, xmlRegStatePtr to) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlFAGener

; 1488 :     if (to == NULL) {
; 1489 : 	to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax

; 1490 : 	xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 1491 : 	ctxt->state = to;

	mov	DWORD PTR [edi+24], esi
$LN2@xmlFAGener:

; 1492 :     }
; 1493 :     xmlRegStateAddTrans(ctxt, from, NULL, to, -1, -1);

	push	-1
	push	-1
	push	esi
	push	0
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1494 : }

	pop	ebp
	ret	0
_xmlFAGenerateEpsilonTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAGenerateAllTransition
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_lax$ = 20						; size = 4
_xmlFAGenerateAllTransition PROC			; COMDAT

; 1466 : 			   int lax) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _to$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlFAGener

; 1467 :     if (to == NULL) {
; 1468 : 	to = xmlRegNewState(ctxt);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax

; 1469 : 	xmlRegStatePush(ctxt, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 1470 : 	ctxt->state = to;

	mov	DWORD PTR [edi+24], esi
$LN2@xmlFAGener:

; 1471 :     }
; 1472 :     if (lax)
; 1473 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_LAX_COUNTER);
; 1474 :     else
; 1475 : 	xmlRegStateAddTrans(ctxt, from, NULL, to, -1, REGEXP_ALL_COUNTER);
; 1476 : }

	xor	ecx, ecx
	cmp	DWORD PTR _lax$[ebp], ecx
	setne	cl
	add	ecx, 1193046				; 00123456H
	push	ecx
	push	-1
	push	esi
	push	0
	push	DWORD PTR _from$[ebp]
	push	edi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlFAGenerateAllTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStatePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlRegStatePush PROC					; COMDAT

; 1427 : xmlRegStatePush(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlRegStat

; 1428 :     if (state == NULL) return(-1);

	or	eax, -1
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
$LN2@xmlRegStat:
	push	esi

; 1429 :     if (ctxt->maxStates == 0) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jne	SHORT $LN3@xmlRegStat

; 1430 : 	ctxt->maxStates = 4;
; 1431 : 	ctxt->states = (xmlRegStatePtr *) xmlMalloc(ctxt->maxStates *

	push	16					; 00000010H
	mov	DWORD PTR [esi+44], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+52], eax

; 1432 : 		                             sizeof(xmlRegStatePtr));
; 1433 : 	if (ctxt->states == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRegStat

; 1434 : 	    xmlRegexpErrMemory(ctxt, "adding state");

	push	OFFSET ??_C@_0N@NHLBLLB@adding?5state@
	push	esi
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1435 : 	    ctxt->maxStates = 0;

	mov	DWORD PTR [esi+44], 0

; 1436 : 	    return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
$LN3@xmlRegStat:

; 1437 : 	}
; 1438 :     } else if (ctxt->nbStates >= ctxt->maxStates) {

	cmp	DWORD PTR [esi+48], eax
	jl	SHORT $LN6@xmlRegStat

; 1439 : 	xmlRegStatePtr *tmp;
; 1440 : 	ctxt->maxStates *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+44], eax

; 1441 : 	tmp = (xmlRegStatePtr *) xmlRealloc(ctxt->states, ctxt->maxStates *

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+52]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1442 : 		                             sizeof(xmlRegStatePtr));
; 1443 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRegStat

; 1444 : 	    xmlRegexpErrMemory(ctxt, "adding state");

	push	OFFSET ??_C@_0N@NHLBLLB@adding?5state@
	push	esi
	call	_xmlRegexpErrMemory

; 1445 : 	    ctxt->maxStates /= 2;

	mov	eax, DWORD PTR [esi+44]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+44], eax

; 1446 : 	    return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
$LN7@xmlRegStat:

; 1447 : 	}
; 1448 : 	ctxt->states = tmp;

	mov	DWORD PTR [esi+52], eax
$LN6@xmlRegStat:

; 1449 :     }
; 1450 :     state->no = ctxt->nbStates;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+16], eax

; 1451 :     ctxt->states[ctxt->nbStates++] = state;

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi+48]

; 1452 :     return(0);

	xor	eax, eax
	pop	esi
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
_xmlRegStatePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStateAddTrans
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_state$ = 12						; size = 4
_atom$ = 16						; size = 4
_target$ = 20						; size = 4
_counter$ = 24						; size = 4
_count$ = 28						; size = 4
_xmlRegStateAddTrans PROC				; COMDAT

; 1350 : 		    int counter, int count) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _state$[ebp]
	test	edi, edi
	jne	SHORT $LN5@xmlRegStat

; 1351 : 
; 1352 :     int nrtrans;
; 1353 : 
; 1354 :     if (state == NULL) {
; 1355 : 	ERROR("add state: state is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BJ@KPILLGIF@add?5state?3?5state?5is?5NULL@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN5@xmlRegStat:
	push	esi

; 1356 : 	return;
; 1357 :     }
; 1358 :     if (target == NULL) {

	mov	esi, DWORD PTR _target$[ebp]
	test	esi, esi
	jne	SHORT $LN6@xmlRegStat

; 1359 : 	ERROR("add state: target is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BK@PPLNMJBI@add?5state?3?5target?5is?5NULL@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN6@xmlRegStat:

; 1360 : 	return;
; 1361 :     }
; 1362 :     /*
; 1363 :      * Other routines follow the philosophy 'When in doubt, add a transition'
; 1364 :      * so we check here whether such a transition is already present and, if
; 1365 :      * so, silently ignore this request.
; 1366 :      */
; 1367 : 
; 1368 :     for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {

	mov	ecx, DWORD PTR [edi+24]
	push	ebx
	mov	ebx, DWORD PTR _count$[ebp]
	lea	edx, DWORD PTR [ecx-1]
	test	edx, edx
	js	SHORT $LN3@xmlRegStat

; 1369 : 	xmlRegTransPtr trans = &(state->trans[nrtrans]);

	mov	eax, DWORD PTR [edi+28]
	lea	ecx, DWORD PTR [edx+edx*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _atom$[ebp]
	npad	2
$LL4@xmlRegStat:

; 1370 : 	if ((trans->atom == atom) &&
; 1371 : 	    (trans->to == target->no) &&
; 1372 : 	    (trans->counter == counter) &&

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN2@xmlRegStat
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+16]
	jne	SHORT $LN27@xmlRegStat
	mov	ecx, DWORD PTR _counter$[ebp]
	cmp	DWORD PTR [eax+8], ecx
	jne	SHORT $LN27@xmlRegStat
	cmp	DWORD PTR [eax+12], ebx
	je	$LN29@xmlRegStat
$LN27@xmlRegStat:

; 1360 : 	return;
; 1361 :     }
; 1362 :     /*
; 1363 :      * Other routines follow the philosophy 'When in doubt, add a transition'
; 1364 :      * so we check here whether such a transition is already present and, if
; 1365 :      * so, silently ignore this request.
; 1366 :      */
; 1367 : 
; 1368 :     for (nrtrans = state->nbTrans - 1; nrtrans >= 0; nrtrans--) {

	mov	ecx, DWORD PTR _atom$[ebp]
$LN2@xmlRegStat:
	sub	eax, 20					; 00000014H
	sub	edx, 1
	jns	SHORT $LL4@xmlRegStat
	mov	ecx, DWORD PTR [edi+24]
$LN3@xmlRegStat:

; 1373 : 	    (trans->count == count)) {
; 1374 : #ifdef DEBUG_REGEXP_GRAPH
; 1375 : 	    printf("Ignoring duplicate transition from %d to %d\n",
; 1376 : 		    state->no, target->no);
; 1377 : #endif
; 1378 : 	    return;
; 1379 : 	}
; 1380 :     }
; 1381 : 
; 1382 :     if (state->maxTrans == 0) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	jne	SHORT $LN8@xmlRegStat

; 1383 : 	state->maxTrans = 8;
; 1384 : 	state->trans = (xmlRegTrans *) xmlMalloc(state->maxTrans *

	push	160					; 000000a0H
	mov	DWORD PTR [edi+20], 8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+28], eax

; 1385 : 		                             sizeof(xmlRegTrans));
; 1386 : 	if (state->trans == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlRegStat

; 1387 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1388 : 	    state->maxTrans = 0;

	mov	DWORD PTR [edi+20], 0
	pop	ebx
	pop	esi
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN8@xmlRegStat:

; 1389 : 	    return;
; 1390 : 	}
; 1391 :     } else if (state->nbTrans >= state->maxTrans) {

	cmp	ecx, eax
	jl	SHORT $LN11@xmlRegStat

; 1392 : 	xmlRegTrans *tmp;
; 1393 : 	state->maxTrans *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+20], eax

; 1394 : 	tmp = (xmlRegTrans *) xmlRealloc(state->trans, state->maxTrans *

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1395 : 		                             sizeof(xmlRegTrans));
; 1396 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlRegStat

; 1397 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 1398 : 	    state->maxTrans /= 2;

	mov	eax, DWORD PTR [edi+20]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	pop	ebx
	pop	esi
	mov	DWORD PTR [edi+20], eax
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN12@xmlRegStat:

; 1399 : 	    return;
; 1400 : 	}
; 1401 : 	state->trans = tmp;

	mov	DWORD PTR [edi+28], eax
$LN11@xmlRegStat:

; 1402 :     }
; 1403 : #ifdef DEBUG_REGEXP_GRAPH
; 1404 :     printf("Add trans from %d to %d ", state->no, target->no);
; 1405 :     if (count == REGEXP_ALL_COUNTER)
; 1406 : 	printf("all transition\n");
; 1407 :     else if (count >= 0)
; 1408 : 	printf("count based %d\n", count);
; 1409 :     else if (counter >= 0)
; 1410 : 	printf("counted %d\n", counter);
; 1411 :     else if (atom == NULL)
; 1412 : 	printf("epsilon transition\n");
; 1413 :     else if (atom != NULL)
; 1414 :         xmlRegPrintAtom(stdout, atom);
; 1415 : #endif
; 1416 : 
; 1417 :     state->trans[state->nbTrans].atom = atom;

	mov	eax, DWORD PTR [edi+24]
	mov	edx, DWORD PTR _atom$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4], edx

; 1418 :     state->trans[state->nbTrans].to = target->no;

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+28]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 1419 :     state->trans[state->nbTrans].counter = counter;

	mov	eax, DWORD PTR [edi+24]
	mov	edx, DWORD PTR _counter$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 1420 :     state->trans[state->nbTrans].count = count;

	mov	eax, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4+12], ebx

; 1421 :     state->trans[state->nbTrans].nd = 0;

	mov	eax, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4+16], 0

; 1422 :     state->nbTrans++;

	inc	DWORD PTR [edi+24]

; 1322 :     if (target->maxTransTo == 0) {

	mov	eax, DWORD PTR [esi+32]

; 1423 :     xmlRegStateAddTransTo(ctxt, target, state->no);

	mov	edi, DWORD PTR [edi+16]

; 1322 :     if (target->maxTransTo == 0) {

	test	eax, eax
	jne	SHORT $LN15@xmlRegStat

; 1323 : 	target->maxTransTo = 8;
; 1324 : 	target->transTo = (int *) xmlMalloc(target->maxTransTo *

	push	32					; 00000020H
	mov	DWORD PTR [esi+32], 8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 1325 : 		                             sizeof(int));
; 1326 : 	if (target->transTo == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlRegStat

; 1327 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1328 : 	    target->maxTransTo = 0;

	mov	DWORD PTR [esi+32], 0
	pop	ebx
	pop	esi
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN15@xmlRegStat:

; 1331 :     } else if (target->nbTransTo >= target->maxTransTo) {

	cmp	DWORD PTR [esi+36], eax
	jl	SHORT $LN18@xmlRegStat

; 1332 : 	int *tmp;
; 1333 : 	target->maxTransTo *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+32], eax

; 1334 : 	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1335 : 		                             sizeof(int));
; 1336 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlRegStat

; 1337 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 1338 : 	    target->maxTransTo /= 2;

	mov	eax, DWORD PTR [esi+32]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	pop	ebx
	mov	DWORD PTR [esi+32], eax
	pop	esi
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
$LN19@xmlRegStat:

; 1341 : 	target->transTo = tmp;

	mov	DWORD PTR [esi+40], eax
$LN18@xmlRegStat:

; 1342 :     }
; 1343 :     target->transTo[target->nbTransTo] = from;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [eax+ecx*4], edi

; 1344 :     target->nbTransTo++;

	inc	DWORD PTR [esi+36]
$LN29@xmlRegStat:
	pop	ebx
	pop	esi
	pop	edi

; 1424 : }

	pop	ebp
	ret	0
_xmlRegStateAddTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStateAddTransTo
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_from$ = 16						; size = 4
_xmlRegStateAddTransTo PROC				; COMDAT

; 1321 :                       int from) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _target$[ebp]
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN2@xmlRegStat

; 1322 :     if (target->maxTransTo == 0) {
; 1323 : 	target->maxTransTo = 8;

	push	32					; 00000020H
	mov	DWORD PTR [esi+32], 8

; 1324 : 	target->transTo = (int *) xmlMalloc(target->maxTransTo *

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 1325 : 		                             sizeof(int));
; 1326 : 	if (target->transTo == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRegStat

; 1327 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1328 : 	    target->maxTransTo = 0;

	mov	DWORD PTR [esi+32], 0
	pop	esi

; 1345 : }

	pop	ebp
	ret	0
$LN2@xmlRegStat:

; 1329 : 	    return;
; 1330 : 	}
; 1331 :     } else if (target->nbTransTo >= target->maxTransTo) {

	cmp	DWORD PTR [esi+36], eax
	jl	SHORT $LN5@xmlRegStat

; 1332 : 	int *tmp;
; 1333 : 	target->maxTransTo *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+32], eax

; 1334 : 	tmp = (int *) xmlRealloc(target->transTo, target->maxTransTo *

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1335 : 		                             sizeof(int));
; 1336 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRegStat

; 1337 : 	    xmlRegexpErrMemory(ctxt, "adding transition");

	push	OFFSET ??_C@_0BC@FHJHIDDF@adding?5transition@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 1338 : 	    target->maxTransTo /= 2;

	mov	eax, DWORD PTR [esi+32]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 1345 : }

	pop	ebp
	ret	0
$LN6@xmlRegStat:

; 1339 : 	    return;
; 1340 : 	}
; 1341 : 	target->transTo = tmp;

	mov	DWORD PTR [esi+40], eax
$LN5@xmlRegStat:

; 1342 :     }
; 1343 :     target->transTo[target->nbTransTo] = from;

	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1344 :     target->nbTransTo++;

	inc	DWORD PTR [esi+36]
	pop	esi

; 1345 : }

	pop	ebp
	ret	0
_xmlRegStateAddTransTo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegAtomPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_xmlRegAtomPush PROC					; COMDAT

; 1288 : xmlRegAtomPush(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _atom$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlRegAtom

; 1289 :     if (atom == NULL) {
; 1290 : 	ERROR("atom push: atom is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BI@LIIKMBAE@atom?5push?3?5atom?5is?5NULL@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8

; 1291 : 	return(-1);

	or	eax, -1
	pop	edi

; 1317 : }

	pop	ebp
	ret	0
$LN2@xmlRegAtom:
	push	esi

; 1292 :     }
; 1293 :     if (ctxt->maxAtoms == 0) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN3@xmlRegAtom

; 1294 : 	ctxt->maxAtoms = 4;
; 1295 : 	ctxt->atoms = (xmlRegAtomPtr *) xmlMalloc(ctxt->maxAtoms *

	push	16					; 00000010H
	mov	DWORD PTR [esi+32], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 1296 : 		                             sizeof(xmlRegAtomPtr));
; 1297 : 	if (ctxt->atoms == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRegAtom

; 1298 : 	    xmlRegexpErrMemory(ctxt, "pushing atom");

	push	OFFSET ??_C@_0N@PMKNEBIB@pushing?5atom@
	push	esi
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1299 : 	    ctxt->maxAtoms = 0;

	mov	DWORD PTR [esi+32], 0

; 1300 : 	    return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1317 : }

	pop	ebp
	ret	0
$LN3@xmlRegAtom:

; 1301 : 	}
; 1302 :     } else if (ctxt->nbAtoms >= ctxt->maxAtoms) {

	cmp	DWORD PTR [esi+36], eax
	jl	SHORT $LN6@xmlRegAtom

; 1303 : 	xmlRegAtomPtr *tmp;
; 1304 : 	ctxt->maxAtoms *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+32], eax

; 1305 : 	tmp = (xmlRegAtomPtr *) xmlRealloc(ctxt->atoms, ctxt->maxAtoms *

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1306 : 		                             sizeof(xmlRegAtomPtr));
; 1307 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRegAtom

; 1308 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	push	esi
	call	_xmlRegexpErrMemory

; 1309 : 	    ctxt->maxAtoms /= 2;

	mov	eax, DWORD PTR [esi+32]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+32], eax

; 1310 : 	    return(-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1317 : }

	pop	ebp
	ret	0
$LN7@xmlRegAtom:

; 1311 : 	}
; 1312 : 	ctxt->atoms = tmp;

	mov	DWORD PTR [esi+40], eax
$LN6@xmlRegAtom:

; 1313 :     }
; 1314 :     atom->no = ctxt->nbAtoms;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi], eax

; 1315 :     ctxt->atoms[ctxt->nbAtoms++] = atom;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi+36]

; 1316 :     return(0);

	xor	eax, eax
	pop	esi
	pop	edi

; 1317 : }

	pop	ebp
	ret	0
_xmlRegAtomPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegGetCounter
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRegGetCounter PROC					; COMDAT

; 1260 : xmlRegGetCounter(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	jne	SHORT $LN2@xmlRegGetC

; 1261 :     if (ctxt->maxCounters == 0) {
; 1262 : 	ctxt->maxCounters = 4;

	push	32					; 00000020H
	mov	DWORD PTR [esi+56], 4

; 1263 : 	ctxt->counters = (xmlRegCounter *) xmlMalloc(ctxt->maxCounters *

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+64], eax

; 1264 : 		                             sizeof(xmlRegCounter));
; 1265 : 	if (ctxt->counters == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRegGetC

; 1266 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	push	esi
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1267 : 	    ctxt->maxCounters = 0;

	mov	DWORD PTR [esi+56], 0

; 1268 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1285 : }

	pop	ebp
	ret	0
$LN2@xmlRegGetC:

; 1269 : 	}
; 1270 :     } else if (ctxt->nbCounters >= ctxt->maxCounters) {

	cmp	DWORD PTR [esi+60], eax
	jl	SHORT $LN5@xmlRegGetC

; 1271 : 	xmlRegCounter *tmp;
; 1272 : 	ctxt->maxCounters *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+56], eax

; 1273 : 	tmp = (xmlRegCounter *) xmlRealloc(ctxt->counters, ctxt->maxCounters *

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+64]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1274 : 		                           sizeof(xmlRegCounter));
; 1275 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlRegGetC

; 1276 : 	    xmlRegexpErrMemory(ctxt, "allocating counter");

	push	OFFSET ??_C@_0BD@OEINICOI@allocating?5counter@
	push	esi
	call	_xmlRegexpErrMemory

; 1277 : 	    ctxt->maxCounters /= 2;

	mov	eax, DWORD PTR [esi+56]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+56], eax

; 1278 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1285 : }

	pop	ebp
	ret	0
$LN6@xmlRegGetC:

; 1279 : 	}
; 1280 : 	ctxt->counters = tmp;

	mov	DWORD PTR [esi+64], eax
$LN5@xmlRegGetC:

; 1281 :     }
; 1282 :     ctxt->counters[ctxt->nbCounters].min = -1;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [eax+ecx*8], -1

; 1283 :     ctxt->counters[ctxt->nbCounters].max = -1;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [eax+ecx*8+4], -1

; 1284 :     return(ctxt->nbCounters++);

	mov	eax, DWORD PTR [esi+60]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+60], ecx
	pop	esi

; 1285 : }

	pop	ebp
	ret	0
_xmlRegGetCounter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegAtomAddRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_neg$ = 16						; size = 4
_type$ = 20						; size = 4
_start$ = 24						; size = 4
_end$ = 28						; size = 4
_blockName$ = 32					; size = 4
_xmlRegAtomAddRange PROC				; COMDAT

; 1219 : 		   xmlChar *blockName) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _atom$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlRegAtom

; 1220 :     xmlRegRangePtr range;
; 1221 : 
; 1222 :     if (atom == NULL) {
; 1223 : 	ERROR("add range: atom is NULL");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BI@MEBKNK@add?5range?3?5atom?5is?5NULL@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi

; 1256 : 
; 1257 : }

	pop	ebp
	ret	0
$LN2@xmlRegAtom:

; 1224 : 	return;
; 1225 :     }
; 1226 :     if (atom->type != XML_REGEXP_RANGES) {

	cmp	DWORD PTR [esi+4], 3
	je	SHORT $LN3@xmlRegAtom

; 1227 : 	ERROR("add range: atom is not ranges");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0BO@PJJILLLG@add?5range?3?5atom?5is?5not?5ranges@
	push	eax
	mov	DWORD PTR [eax+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	esi

; 1256 : 
; 1257 : }

	pop	ebp
	ret	0
$LN3@xmlRegAtom:

; 1228 : 	return;
; 1229 :     }
; 1230 :     if (atom->maxRanges == 0) {

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	jne	SHORT $LN4@xmlRegAtom

; 1231 : 	atom->maxRanges = 4;
; 1232 : 	atom->ranges = (xmlRegRangePtr *) xmlMalloc(atom->maxRanges *

	push	16					; 00000010H
	mov	DWORD PTR [esi+48], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+56], eax

; 1233 : 		                             sizeof(xmlRegRangePtr));
; 1234 : 	if (atom->ranges == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRegAtom

; 1235 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");

	push	OFFSET ??_C@_0O@INOJCFAI@adding?5ranges@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8

; 1236 : 	    atom->maxRanges = 0;

	mov	DWORD PTR [esi+48], 0
	pop	esi

; 1256 : 
; 1257 : }

	pop	ebp
	ret	0
$LN4@xmlRegAtom:

; 1237 : 	    return;
; 1238 : 	}
; 1239 :     } else if (atom->nbRanges >= atom->maxRanges) {

	cmp	DWORD PTR [esi+52], eax
	jl	SHORT $LN7@xmlRegAtom

; 1240 : 	xmlRegRangePtr *tmp;
; 1241 : 	atom->maxRanges *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+48], eax

; 1242 : 	tmp = (xmlRegRangePtr *) xmlRealloc(atom->ranges, atom->maxRanges *

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+56]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1243 : 		                             sizeof(xmlRegRangePtr));
; 1244 : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlRegAtom

; 1245 : 	    xmlRegexpErrMemory(ctxt, "adding ranges");

	push	OFFSET ??_C@_0O@INOJCFAI@adding?5ranges@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 1246 : 	    atom->maxRanges /= 2;

	mov	eax, DWORD PTR [esi+48]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+48], eax
	pop	esi

; 1256 : 
; 1257 : }

	pop	ebp
	ret	0
$LN8@xmlRegAtom:

; 1247 : 	    return;
; 1248 : 	}
; 1249 : 	atom->ranges = tmp;

	mov	DWORD PTR [esi+56], eax
$LN7@xmlRegAtom:

; 1250 :     }
; 1251 :     range = xmlRegNewRange(ctxt, neg, type, start, end);

	push	DWORD PTR _end$[ebp]
	push	DWORD PTR _start$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR _neg$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegNewRange
	add	esp, 20					; 00000014H

; 1252 :     if (range == NULL)

	test	eax, eax
	je	SHORT $LN1@xmlRegAtom

; 1253 : 	return;
; 1254 :     range->blockName = blockName;

	mov	ecx, DWORD PTR _blockName$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1255 :     atom->ranges[atom->nbRanges++] = range;

	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+56]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi+52]
$LN1@xmlRegAtom:
	pop	esi

; 1256 : 
; 1257 : }

	pop	ebp
	ret	0
_xmlRegAtomAddRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintState
_TEXT	SEGMENT
tv408 = -4						; size = 4
_output$ = 8						; size = 4
_i$1$ = 12						; size = 4
_state$ = 12						; size = 4
_xmlRegPrintState PROC					; COMDAT

; 1149 : xmlRegPrintState(FILE *output, xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_08NOIFNCJM@?5state?3?5@
	push	esi
	call	_fprintf
	mov	ebx, DWORD PTR _state$[ebp]
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN5@xmlRegPrin

; 1150 :     int i;
; 1151 : 
; 1152 :     fprintf(output, " state: ");
; 1153 :     if (state == NULL) {
; 1154 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	esi

; 1165 :     }
; 1166 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRegPrin:

; 1155 : 	return;
; 1156 :     }
; 1157 :     if (state->type == XML_REGEXP_START_STATE)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	jne	SHORT $LN6@xmlRegPrin

; 1158 : 	fprintf(output, "START ");

	push	OFFSET ??_C@_06BNBHINFE@START?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [ebx]
	add	esp, 8
$LN6@xmlRegPrin:

; 1159 :     if (state->type == XML_REGEXP_FINAL_STATE)

	cmp	eax, 2
	jne	SHORT $LN7@xmlRegPrin

; 1160 : 	fprintf(output, "FINAL ");

	push	OFFSET ??_C@_06EFHALCBA@FINAL?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN7@xmlRegPrin:

; 1161 : 
; 1162 :     fprintf(output, "%d, %d transitions:\n", state->no, state->nbTrans);

	push	DWORD PTR [ebx+24]
	push	DWORD PTR [ebx+16]
	push	OFFSET ??_C@_0BF@NHMHHIIL@?$CFd?0?5?$CFd?5transitions?3?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H

; 1163 :     for (i = 0;i < state->nbTrans; i++) {

	mov	DWORD PTR _i$1$[ebp], 0
	cmp	DWORD PTR [ebx+24], 0
	jle	$LN3@xmlRegPrin

; 1161 : 
; 1162 :     fprintf(output, "%d, %d transitions:\n", state->no, state->nbTrans);

	xor	ecx, ecx
	mov	DWORD PTR tv408[ebp], ecx
	push	edi
$LL4@xmlRegPrin:

; 1164 : 	xmlRegPrintTrans(output, &(state->trans[i]));

	mov	edi, DWORD PTR [ebx+28]

; 1116 :     fprintf(output, "  trans: ");

	push	OFFSET ??_C@_09KCGMBGNH@?5?5trans?3?5@
	push	esi

; 1164 : 	xmlRegPrintTrans(output, &(state->trans[i]));

	add	edi, ecx

; 1116 :     fprintf(output, "  trans: ");

	call	_fprintf
	add	esp, 8

; 1117 :     if (trans == NULL) {

	test	edi, edi
	jne	SHORT $LN10@xmlRegPrin

; 1118 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	esi
	call	_fprintf
	add	esp, 8

; 1119 : 	return;

	jmp	$LN2@xmlRegPrin
$LN10@xmlRegPrin:

; 1120 :     }
; 1121 :     if (trans->to < 0) {

	cmp	DWORD PTR [edi+4], 0
	jge	SHORT $LN11@xmlRegPrin

; 1122 : 	fprintf(output, "removed\n");

	push	OFFSET ??_C@_08IDDAKHFP@removed?6@
	push	esi
	call	_fprintf
	add	esp, 8

; 1123 : 	return;

	jmp	$LN2@xmlRegPrin
$LN11@xmlRegPrin:

; 1124 :     }
; 1125 :     if (trans->nd != 0) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN14@xmlRegPrin

; 1126 : 	if (trans->nd == 2)

	cmp	eax, 2
	jne	SHORT $LN13@xmlRegPrin

; 1127 : 	    fprintf(output, "last not determinist, ");

	push	OFFSET ??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@
	jmp	SHORT $LN26@xmlRegPrin
$LN13@xmlRegPrin:

; 1128 : 	else
; 1129 : 	    fprintf(output, "not determinist, ");

	push	OFFSET ??_C@_0BC@EKCPHBCA@not?5determinist?0?5@
$LN26@xmlRegPrin:

; 1130 :     }
; 1131 :     if (trans->counter >= 0) {

	push	esi
	call	_fprintf
	add	esp, 8
$LN14@xmlRegPrin:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	js	SHORT $LN15@xmlRegPrin

; 1132 : 	fprintf(output, "counted %d, ", trans->counter);

	push	eax
	push	OFFSET ??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN15@xmlRegPrin:

; 1133 :     }
; 1134 :     if (trans->count == REGEXP_ALL_COUNTER) {

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, 1193046				; 00123456H
	jne	SHORT $LN16@xmlRegPrin

; 1135 : 	fprintf(output, "all transition, ");

	push	OFFSET ??_C@_0BB@CPMJDJHN@all?5transition?0?5@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN18@xmlRegPrin
$LN16@xmlRegPrin:

; 1136 :     } else if (trans->count >= 0) {

	test	eax, eax
	js	SHORT $LN18@xmlRegPrin

; 1137 : 	fprintf(output, "count based %d, ", trans->count);

	push	eax
	push	OFFSET ??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN18@xmlRegPrin:

; 1138 :     }
; 1139 :     if (trans->atom == NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN19@xmlRegPrin

; 1140 : 	fprintf(output, "epsilon to %d\n", trans->to);

	push	DWORD PTR [edi+4]
	push	OFFSET ??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1141 : 	return;

	jmp	SHORT $LN2@xmlRegPrin
$LN19@xmlRegPrin:

; 1142 :     }
; 1143 :     if (trans->atom->type == XML_REGEXP_CHARVAL)

	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN20@xmlRegPrin

; 1144 : 	fprintf(output, "char %c ", trans->atom->codepoint);

	push	DWORD PTR [eax+32]
	push	OFFSET ??_C@_08JNAFCHHG@char?5?$CFc?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
$LN20@xmlRegPrin:

; 1145 :     fprintf(output, "atom %d, to %d\n", trans->atom->no, trans->to);

	push	DWORD PTR [edi+4]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
$LN2@xmlRegPrin:

; 1163 :     for (i = 0;i < state->nbTrans; i++) {

	mov	eax, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR tv408[ebp]
	inc	eax
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _i$1$[ebp], eax
	mov	DWORD PTR tv408[ebp], ecx
	cmp	eax, DWORD PTR [ebx+24]
	jl	$LL4@xmlRegPrin
	pop	edi
$LN3@xmlRegPrin:
	pop	esi

; 1165 :     }
; 1166 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegPrintState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintTrans
_TEXT	SEGMENT
_output$ = 8						; size = 4
_trans$ = 12						; size = 4
_xmlRegPrintTrans PROC					; COMDAT

; 1115 : xmlRegPrintTrans(FILE *output, xmlRegTransPtr trans) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_09KCGMBGNH@?5?5trans?3?5@
	push	esi
	call	_fprintf
	mov	edi, DWORD PTR _trans$[ebp]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN2@xmlRegPrin

; 1116 :     fprintf(output, "  trans: ");
; 1117 :     if (trans == NULL) {
; 1118 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi

; 1146 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlRegPrin:

; 1119 : 	return;
; 1120 :     }
; 1121 :     if (trans->to < 0) {

	cmp	DWORD PTR [edi+4], 0
	jge	SHORT $LN3@xmlRegPrin

; 1122 : 	fprintf(output, "removed\n");

	push	OFFSET ??_C@_08IDDAKHFP@removed?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi

; 1146 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlRegPrin:

; 1123 : 	return;
; 1124 :     }
; 1125 :     if (trans->nd != 0) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN6@xmlRegPrin

; 1126 : 	if (trans->nd == 2)

	cmp	eax, 2
	jne	SHORT $LN5@xmlRegPrin

; 1127 : 	    fprintf(output, "last not determinist, ");

	push	OFFSET ??_C@_0BH@PJNPIGKD@last?5not?5determinist?0?5@
	jmp	SHORT $LN14@xmlRegPrin
$LN5@xmlRegPrin:

; 1128 : 	else
; 1129 : 	    fprintf(output, "not determinist, ");

	push	OFFSET ??_C@_0BC@EKCPHBCA@not?5determinist?0?5@
$LN14@xmlRegPrin:

; 1130 :     }
; 1131 :     if (trans->counter >= 0) {

	push	esi
	call	_fprintf
	add	esp, 8
$LN6@xmlRegPrin:
	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	js	SHORT $LN7@xmlRegPrin

; 1132 : 	fprintf(output, "counted %d, ", trans->counter);

	push	eax
	push	OFFSET ??_C@_0N@NIIDMCG@counted?5?$CFd?0?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN7@xmlRegPrin:

; 1133 :     }
; 1134 :     if (trans->count == REGEXP_ALL_COUNTER) {

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, 1193046				; 00123456H
	jne	SHORT $LN8@xmlRegPrin

; 1135 : 	fprintf(output, "all transition, ");

	push	OFFSET ??_C@_0BB@CPMJDJHN@all?5transition?0?5@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN10@xmlRegPrin
$LN8@xmlRegPrin:

; 1136 :     } else if (trans->count >= 0) {

	test	eax, eax
	js	SHORT $LN10@xmlRegPrin

; 1137 : 	fprintf(output, "count based %d, ", trans->count);

	push	eax
	push	OFFSET ??_C@_0BB@LHHOLMKP@count?5based?5?$CFd?0?5@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN10@xmlRegPrin:

; 1138 :     }
; 1139 :     if (trans->atom == NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN11@xmlRegPrin

; 1140 : 	fprintf(output, "epsilon to %d\n", trans->to);

	push	DWORD PTR [edi+4]
	push	OFFSET ??_C@_0P@BEFDCDEN@epsilon?5to?5?$CFd?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	edi

; 1146 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlRegPrin:

; 1141 : 	return;
; 1142 :     }
; 1143 :     if (trans->atom->type == XML_REGEXP_CHARVAL)

	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN12@xmlRegPrin

; 1144 : 	fprintf(output, "char %c ", trans->atom->codepoint);

	push	DWORD PTR [eax+32]
	push	OFFSET ??_C@_08JNAFCHHG@char?5?$CFc?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
$LN12@xmlRegPrin:

; 1145 :     fprintf(output, "atom %d, to %d\n", trans->atom->no, trans->to);

	push	DWORD PTR [edi+4]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BA@DDAHGLMD@atom?5?$CFd?0?5to?5?$CFd?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	edi

; 1146 : }

	pop	esi
	pop	ebp
	ret	0
_xmlRegPrintTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintAtom
_TEXT	SEGMENT
_output$ = 8						; size = 4
_i$1$ = 12						; size = 4
_atom$ = 12						; size = 4
_xmlRegPrintAtom PROC					; COMDAT

; 1086 : xmlRegPrintAtom(FILE *output, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_07LAIPMBOA@?5atom?3?5@
	push	esi
	call	_fprintf
	mov	edi, DWORD PTR _atom$[ebp]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN5@xmlRegPrin

; 1111 :     }
; 1112 : }

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlRegPrin:

; 1087 :     fprintf(output, " atom: ");
; 1088 :     if (atom == NULL) {
; 1089 : 	fprintf(output, "NULL\n");
; 1090 : 	return;
; 1091 :     }
; 1092 :     if (atom->neg)

	cmp	DWORD PTR [edi+28], 0
	je	SHORT $LN6@xmlRegPrin

; 1093 :         fprintf(output, "not ");

	push	OFFSET ??_C@_04LKOGMCLF@not?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN6@xmlRegPrin:

; 1094 :     xmlRegPrintAtomType(output, atom->type);

	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRegPrintAtomType

; 1057 :     switch (type) {

	mov	eax, DWORD PTR [edi+8]

; 1094 :     xmlRegPrintAtomType(output, atom->type);

	add	esp, 8

; 1057 :     switch (type) {

	dec	eax
	cmp	eax, 7
	ja	SHORT $LN17@xmlRegPrin
	jmp	DWORD PTR $LN38@xmlRegPrin[eax*4]
$LN19@xmlRegPrin:

; 1058 :         case XML_REGEXP_QUANT_EPSILON:
; 1059 : 	    fprintf(output, "epsilon "); break;

	push	OFFSET ??_C@_08LJGDJFJP@epsilon?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN20@xmlRegPrin:

; 1060 :         case XML_REGEXP_QUANT_ONCE:
; 1061 : 	    fprintf(output, "once "); break;

	push	OFFSET ??_C@_05GDJGFPHL@once?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN21@xmlRegPrin:

; 1062 :         case XML_REGEXP_QUANT_OPT:
; 1063 : 	    fprintf(output, "? "); break;

	push	OFFSET ??_C@_02LKANKAOC@?$DP?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN22@xmlRegPrin:

; 1064 :         case XML_REGEXP_QUANT_MULT:
; 1065 : 	    fprintf(output, "* "); break;

	push	OFFSET ??_C@_02KAOAMBHJ@?$CK?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN23@xmlRegPrin:

; 1066 :         case XML_REGEXP_QUANT_PLUS:
; 1067 : 	    fprintf(output, "+ "); break;

	push	OFFSET ??_C@_02KBCCKLEO@?$CL?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN24@xmlRegPrin:

; 1068 : 	case XML_REGEXP_QUANT_RANGE:
; 1069 : 	    fprintf(output, "range "); break;

	push	OFFSET ??_C@_06IBKHBGID@range?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN25@xmlRegPrin:

; 1070 : 	case XML_REGEXP_QUANT_ONCEONLY:
; 1071 : 	    fprintf(output, "onceonly "); break;

	push	OFFSET ??_C@_09EPCGBNDN@onceonly?5@
	jmp	SHORT $LN36@xmlRegPrin
$LN26@xmlRegPrin:

; 1072 : 	case XML_REGEXP_QUANT_ALL:
; 1073 : 	    fprintf(output, "all "); break;

	push	OFFSET ??_C@_04DIDGAIEC@all?5@
$LN36@xmlRegPrin:

; 1095 :     xmlRegPrintQuantType(output, atom->quant);
; 1096 :     if (atom->quant == XML_REGEXP_QUANT_RANGE)

	push	esi
	call	_fprintf
	add	esp, 8
$LN17@xmlRegPrin:
	cmp	DWORD PTR [edi+8], 8
	jne	SHORT $LN7@xmlRegPrin

; 1097 : 	fprintf(output, "%d-%d ", atom->min, atom->max);

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	OFFSET ??_C@_06BIJEIIBB@?$CFd?9?$CFd?5@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
$LN7@xmlRegPrin:

; 1098 :     if (atom->type == XML_REGEXP_STRING)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 5
	jne	SHORT $LN8@xmlRegPrin

; 1099 : 	fprintf(output, "'%s' ", (char *) atom->valuep);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_05IMLJLABD@?8?$CFs?8?5@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
$LN8@xmlRegPrin:

; 1100 :     if (atom->type == XML_REGEXP_CHARVAL)

	cmp	eax, 2
	jne	SHORT $LN9@xmlRegPrin

; 1101 : 	fprintf(output, "char %c\n", atom->codepoint);

	push	DWORD PTR [edi+32]
	push	OFFSET ??_C@_08PCGOOLFO@char?5?$CFc?6@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	edi

; 1111 :     }
; 1112 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlRegPrin:

; 1102 :     else if (atom->type == XML_REGEXP_RANGES) {

	cmp	eax, 3
	jne	SHORT $LN11@xmlRegPrin

; 1103 : 	int i;
; 1104 : 	fprintf(output, "%d entries\n", atom->nbRanges);

	push	DWORD PTR [edi+52]
	push	OFFSET ??_C@_0M@BCDCHBAM@?$CFd?5entries?6@
	push	esi
	call	_fprintf

; 1105 : 	for (i = 0; i < atom->nbRanges;i++)

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [edi+52], ecx
	jle	$LN14@xmlRegPrin
	push	ebx
	npad	3
$LL4@xmlRegPrin:

; 1106 : 	    xmlRegPrintRange(output, atom->ranges[i]);

	mov	eax, DWORD PTR [edi+56]

; 1078 :     fprintf(output, "  range: ");

	push	OFFSET ??_C@_09LLABEBOE@?5?5range?3?5@
	push	esi

; 1106 : 	    xmlRegPrintRange(output, atom->ranges[i]);

	mov	ebx, DWORD PTR [eax+ecx*4]

; 1078 :     fprintf(output, "  range: ");

	call	_fprintf
	add	esp, 8

; 1079 :     if (range->neg)

	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN29@xmlRegPrin

; 1080 : 	fprintf(output, "negative ");

	push	OFFSET ??_C@_09KDBNABJA@negative?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN29@xmlRegPrin:

; 1081 :     xmlRegPrintAtomType(output, range->type);

	push	DWORD PTR [ebx+4]
	push	esi
	call	_xmlRegPrintAtomType

; 1082 :     fprintf(output, "%c - %c\n", range->start, range->end);

	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@
	push	esi
	call	_fprintf

; 1105 : 	for (i = 0; i < atom->nbRanges;i++)

	mov	ecx, DWORD PTR _i$1$[ebp]

; 1082 :     fprintf(output, "%c - %c\n", range->start, range->end);

	add	esp, 24					; 00000018H

; 1105 : 	for (i = 0; i < atom->nbRanges;i++)

	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+52]
	jl	SHORT $LL4@xmlRegPrin

; 1107 :     } else if (atom->type == XML_REGEXP_SUBREG) {

	pop	ebx
	pop	edi

; 1111 :     }
; 1112 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlRegPrin:

; 1107 :     } else if (atom->type == XML_REGEXP_SUBREG) {

	cmp	eax, 4
	jne	SHORT $LN13@xmlRegPrin

; 1108 : 	fprintf(output, "start %d end %d\n", atom->start->no, atom->stop->no);

	mov	eax, DWORD PTR [edi+44]
	push	DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+16]
	push	OFFSET ??_C@_0BB@GBMGKEL@start?5?$CFd?5end?5?$CFd?6@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	edi

; 1111 :     }
; 1112 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlRegPrin:

; 1109 :     } else {
; 1110 : 	fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@

; 1111 :     }
; 1112 : }

	push	esi
	call	_fprintf
	add	esp, 8
$LN14@xmlRegPrin:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN38@xmlRegPrin:
	DD	$LN19@xmlRegPrin
	DD	$LN20@xmlRegPrin
	DD	$LN21@xmlRegPrin
	DD	$LN22@xmlRegPrin
	DD	$LN23@xmlRegPrin
	DD	$LN25@xmlRegPrin
	DD	$LN26@xmlRegPrin
	DD	$LN24@xmlRegPrin
_xmlRegPrintAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintRange
_TEXT	SEGMENT
_output$ = 8						; size = 4
_range$ = 12						; size = 4
_xmlRegPrintRange PROC					; COMDAT

; 1077 : xmlRegPrintRange(FILE *output, xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	push	OFFSET ??_C@_09LLABEBOE@?5?5range?3?5@
	push	esi
	call	_fprintf
	mov	edi, DWORD PTR _range$[ebp]
	add	esp, 8
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN2@xmlRegPrin

; 1078 :     fprintf(output, "  range: ");
; 1079 :     if (range->neg)
; 1080 : 	fprintf(output, "negative ");

	push	OFFSET ??_C@_09KDBNABJA@negative?5@
	push	esi
	call	_fprintf
	add	esp, 8
$LN2@xmlRegPrin:

; 1081 :     xmlRegPrintAtomType(output, range->type);

	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlRegPrintAtomType

; 1082 :     fprintf(output, "%c - %c\n", range->start, range->end);

	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_08BNCIEJGK@?$CFc?5?9?5?$CFc?6@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1083 : }

	pop	ebp
	ret	0
_xmlRegPrintRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintQuantType
_TEXT	SEGMENT
_output$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegPrintQuantType PROC				; COMDAT

; 1056 : xmlRegPrintQuantType(FILE *output, xmlRegQuantType type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 7
	ja	SHORT $LN2@xmlRegPrin

; 1057 :     switch (type) {

	jmp	DWORD PTR $LN16@xmlRegPrin[eax*4]
$LN4@xmlRegPrin:

; 1058 :         case XML_REGEXP_QUANT_EPSILON:
; 1059 : 	    fprintf(output, "epsilon "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08LJGDJFJP@epsilon?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1058 :         case XML_REGEXP_QUANT_EPSILON:
; 1059 : 	    fprintf(output, "epsilon "); break;

	jmp	_fprintf
$LN5@xmlRegPrin:

; 1060 :         case XML_REGEXP_QUANT_ONCE:
; 1061 : 	    fprintf(output, "once "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_05GDJGFPHL@once?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1060 :         case XML_REGEXP_QUANT_ONCE:
; 1061 : 	    fprintf(output, "once "); break;

	jmp	_fprintf
$LN6@xmlRegPrin:

; 1062 :         case XML_REGEXP_QUANT_OPT:
; 1063 : 	    fprintf(output, "? "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_02LKANKAOC@?$DP?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1062 :         case XML_REGEXP_QUANT_OPT:
; 1063 : 	    fprintf(output, "? "); break;

	jmp	_fprintf
$LN7@xmlRegPrin:

; 1064 :         case XML_REGEXP_QUANT_MULT:
; 1065 : 	    fprintf(output, "* "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_02KAOAMBHJ@?$CK?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1064 :         case XML_REGEXP_QUANT_MULT:
; 1065 : 	    fprintf(output, "* "); break;

	jmp	_fprintf
$LN8@xmlRegPrin:

; 1066 :         case XML_REGEXP_QUANT_PLUS:
; 1067 : 	    fprintf(output, "+ "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_02KBCCKLEO@?$CL?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1066 :         case XML_REGEXP_QUANT_PLUS:
; 1067 : 	    fprintf(output, "+ "); break;

	jmp	_fprintf
$LN9@xmlRegPrin:

; 1068 : 	case XML_REGEXP_QUANT_RANGE:
; 1069 : 	    fprintf(output, "range "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_06IBKHBGID@range?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1068 : 	case XML_REGEXP_QUANT_RANGE:
; 1069 : 	    fprintf(output, "range "); break;

	jmp	_fprintf
$LN10@xmlRegPrin:

; 1070 : 	case XML_REGEXP_QUANT_ONCEONLY:
; 1071 : 	    fprintf(output, "onceonly "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09EPCGBNDN@onceonly?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1070 : 	case XML_REGEXP_QUANT_ONCEONLY:
; 1071 : 	    fprintf(output, "onceonly "); break;

	jmp	_fprintf
$LN11@xmlRegPrin:

; 1072 : 	case XML_REGEXP_QUANT_ALL:
; 1073 : 	    fprintf(output, "all "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_04DIDGAIEC@all?5@

; 1074 :     }
; 1075 : }

	pop	ebp

; 1072 : 	case XML_REGEXP_QUANT_ALL:
; 1073 : 	    fprintf(output, "all "); break;

	jmp	_fprintf
$LN2@xmlRegPrin:

; 1074 :     }
; 1075 : }

	pop	ebp
	ret	0
	npad	1
$LN16@xmlRegPrin:
	DD	$LN4@xmlRegPrin
	DD	$LN5@xmlRegPrin
	DD	$LN6@xmlRegPrin
	DD	$LN7@xmlRegPrin
	DD	$LN8@xmlRegPrin
	DD	$LN10@xmlRegPrin
	DD	$LN11@xmlRegPrin
	DD	$LN9@xmlRegPrin
_xmlRegPrintQuantType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegPrintAtomType
_TEXT	SEGMENT
_output$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegPrintAtomType PROC				; COMDAT

; 944  : xmlRegPrintAtomType(FILE *output, xmlRegAtomType type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	cmp	eax, 135				; 00000087H
	ja	$LN2@xmlRegPrin

; 945  :     switch (type) {

	movzx	eax, BYTE PTR $LN58@xmlRegPrin[eax]
	jmp	DWORD PTR $LN62@xmlRegPrin[eax*4]
$LN4@xmlRegPrin:

; 946  :         case XML_REGEXP_EPSILON:
; 947  : 	    fprintf(output, "epsilon "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08LJGDJFJP@epsilon?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 946  :         case XML_REGEXP_EPSILON:
; 947  : 	    fprintf(output, "epsilon "); break;

	jmp	_fprintf
$LN5@xmlRegPrin:

; 948  :         case XML_REGEXP_CHARVAL:
; 949  : 	    fprintf(output, "charval "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08DFHMJFEK@charval?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 948  :         case XML_REGEXP_CHARVAL:
; 949  : 	    fprintf(output, "charval "); break;

	jmp	_fprintf
$LN6@xmlRegPrin:

; 950  :         case XML_REGEXP_RANGES:
; 951  : 	    fprintf(output, "ranges "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_07IPEOMBMH@ranges?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 950  :         case XML_REGEXP_RANGES:
; 951  : 	    fprintf(output, "ranges "); break;

	jmp	_fprintf
$LN7@xmlRegPrin:

; 952  :         case XML_REGEXP_SUBREG:
; 953  : 	    fprintf(output, "subexpr "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08BABENLJO@subexpr?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 952  :         case XML_REGEXP_SUBREG:
; 953  : 	    fprintf(output, "subexpr "); break;

	jmp	_fprintf
$LN8@xmlRegPrin:

; 954  :         case XML_REGEXP_STRING:
; 955  : 	    fprintf(output, "string "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_07HBAIICBM@string?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 954  :         case XML_REGEXP_STRING:
; 955  : 	    fprintf(output, "string "); break;

	jmp	_fprintf
$LN9@xmlRegPrin:

; 956  :         case XML_REGEXP_ANYCHAR:
; 957  : 	    fprintf(output, "anychar "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08IIDGBAEF@anychar?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 956  :         case XML_REGEXP_ANYCHAR:
; 957  : 	    fprintf(output, "anychar "); break;

	jmp	_fprintf
$LN10@xmlRegPrin:

; 958  :         case XML_REGEXP_ANYSPACE:
; 959  : 	    fprintf(output, "anyspace "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09IFBFMEEE@anyspace?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 958  :         case XML_REGEXP_ANYSPACE:
; 959  : 	    fprintf(output, "anyspace "); break;

	jmp	_fprintf
$LN11@xmlRegPrin:

; 960  :         case XML_REGEXP_NOTSPACE:
; 961  : 	    fprintf(output, "notspace "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09PIGAJOFL@notspace?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 960  :         case XML_REGEXP_NOTSPACE:
; 961  : 	    fprintf(output, "notspace "); break;

	jmp	_fprintf
$LN12@xmlRegPrin:

; 962  :         case XML_REGEXP_INITNAME:
; 963  : 	    fprintf(output, "initname "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09PGNNJPMN@initname?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 962  :         case XML_REGEXP_INITNAME:
; 963  : 	    fprintf(output, "initname "); break;

	jmp	_fprintf
$LN13@xmlRegPrin:

; 964  :         case XML_REGEXP_NOTINITNAME:
; 965  : 	    fprintf(output, "notinitname "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@PKALLFNP@notinitname?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 964  :         case XML_REGEXP_NOTINITNAME:
; 965  : 	    fprintf(output, "notinitname "); break;

	jmp	_fprintf
$LN14@xmlRegPrin:

; 966  :         case XML_REGEXP_NAMECHAR:
; 967  : 	    fprintf(output, "namechar "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09GMGKKJAH@namechar?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 966  :         case XML_REGEXP_NAMECHAR:
; 967  : 	    fprintf(output, "namechar "); break;

	jmp	_fprintf
$LN15@xmlRegPrin:

; 968  :         case XML_REGEXP_NOTNAMECHAR:
; 969  : 	    fprintf(output, "notnamechar "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@GALMIDBF@notnamechar?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 968  :         case XML_REGEXP_NOTNAMECHAR:
; 969  : 	    fprintf(output, "notnamechar "); break;

	jmp	_fprintf
$LN16@xmlRegPrin:

; 970  :         case XML_REGEXP_DECIMAL:
; 971  : 	    fprintf(output, "decimal "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_08CDKGKILA@decimal?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 970  :         case XML_REGEXP_DECIMAL:
; 971  : 	    fprintf(output, "decimal "); break;

	jmp	_fprintf
$LN17@xmlRegPrin:

; 972  :         case XML_REGEXP_NOTDECIMAL:
; 973  : 	    fprintf(output, "notdecimal "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0M@EDJHICHL@notdecimal?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 972  :         case XML_REGEXP_NOTDECIMAL:
; 973  : 	    fprintf(output, "notdecimal "); break;

	jmp	_fprintf
$LN18@xmlRegPrin:

; 974  :         case XML_REGEXP_REALCHAR:
; 975  : 	    fprintf(output, "realchar "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09MOCDMJPB@realchar?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 974  :         case XML_REGEXP_REALCHAR:
; 975  : 	    fprintf(output, "realchar "); break;

	jmp	_fprintf
$LN19@xmlRegPrin:

; 976  :         case XML_REGEXP_NOTREALCHAR:
; 977  : 	    fprintf(output, "notrealchar "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@MCPFODOD@notrealchar?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 976  :         case XML_REGEXP_NOTREALCHAR:
; 977  : 	    fprintf(output, "notrealchar "); break;

	jmp	_fprintf
$LN20@xmlRegPrin:

; 978  :         case XML_REGEXP_LETTER:
; 979  :             fprintf(output, "LETTER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_07POCGPIHD@LETTER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 978  :         case XML_REGEXP_LETTER:
; 979  :             fprintf(output, "LETTER "); break;

	jmp	_fprintf
$LN21@xmlRegPrin:

; 980  :         case XML_REGEXP_LETTER_UPPERCASE:
; 981  :             fprintf(output, "LETTER_UPPERCASE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BC@KMHMCLHI@LETTER_UPPERCASE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 980  :         case XML_REGEXP_LETTER_UPPERCASE:
; 981  :             fprintf(output, "LETTER_UPPERCASE "); break;

	jmp	_fprintf
$LN22@xmlRegPrin:

; 982  :         case XML_REGEXP_LETTER_LOWERCASE:
; 983  :             fprintf(output, "LETTER_LOWERCASE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BC@MLADGGJK@LETTER_LOWERCASE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 982  :         case XML_REGEXP_LETTER_LOWERCASE:
; 983  :             fprintf(output, "LETTER_LOWERCASE "); break;

	jmp	_fprintf
$LN23@xmlRegPrin:

; 984  :         case XML_REGEXP_LETTER_TITLECASE:
; 985  :             fprintf(output, "LETTER_TITLECASE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BC@FGJDLGPN@LETTER_TITLECASE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 984  :         case XML_REGEXP_LETTER_TITLECASE:
; 985  :             fprintf(output, "LETTER_TITLECASE "); break;

	jmp	_fprintf
$LN24@xmlRegPrin:

; 986  :         case XML_REGEXP_LETTER_MODIFIER:
; 987  :             fprintf(output, "LETTER_MODIFIER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@MHDADLFE@LETTER_MODIFIER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 986  :         case XML_REGEXP_LETTER_MODIFIER:
; 987  :             fprintf(output, "LETTER_MODIFIER "); break;

	jmp	_fprintf
$LN25@xmlRegPrin:

; 988  :         case XML_REGEXP_LETTER_OTHERS:
; 989  :             fprintf(output, "LETTER_OTHERS "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@ONCGNHEJ@LETTER_OTHERS?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 988  :         case XML_REGEXP_LETTER_OTHERS:
; 989  :             fprintf(output, "LETTER_OTHERS "); break;

	jmp	_fprintf
$LN26@xmlRegPrin:

; 990  :         case XML_REGEXP_MARK:
; 991  :             fprintf(output, "MARK "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_05BACHLHLN@MARK?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 990  :         case XML_REGEXP_MARK:
; 991  :             fprintf(output, "MARK "); break;

	jmp	_fprintf
$LN27@xmlRegPrin:

; 992  :         case XML_REGEXP_MARK_NONSPACING:
; 993  :             fprintf(output, "MARK_NONSPACING "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@FIDLEIEL@MARK_NONSPACING?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 992  :         case XML_REGEXP_MARK_NONSPACING:
; 993  :             fprintf(output, "MARK_NONSPACING "); break;

	jmp	_fprintf
$LN28@xmlRegPrin:

; 994  :         case XML_REGEXP_MARK_SPACECOMBINING:
; 995  :             fprintf(output, "MARK_SPACECOMBINING "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BF@GJKDPMF@MARK_SPACECOMBINING?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 994  :         case XML_REGEXP_MARK_SPACECOMBINING:
; 995  :             fprintf(output, "MARK_SPACECOMBINING "); break;

	jmp	_fprintf
$LN29@xmlRegPrin:

; 996  :         case XML_REGEXP_MARK_ENCLOSING:
; 997  :             fprintf(output, "MARK_ENCLOSING "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BA@NNNPPLBP@MARK_ENCLOSING?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 996  :         case XML_REGEXP_MARK_ENCLOSING:
; 997  :             fprintf(output, "MARK_ENCLOSING "); break;

	jmp	_fprintf
$LN30@xmlRegPrin:

; 998  :         case XML_REGEXP_NUMBER:
; 999  :             fprintf(output, "NUMBER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_07BAKEFCLB@NUMBER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 998  :         case XML_REGEXP_NUMBER:
; 999  :             fprintf(output, "NUMBER "); break;

	jmp	_fprintf
$LN31@xmlRegPrin:

; 1000 :         case XML_REGEXP_NUMBER_DECIMAL:
; 1001 :             fprintf(output, "NUMBER_DECIMAL "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BA@JLEBGNKM@NUMBER_DECIMAL?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1000 :         case XML_REGEXP_NUMBER_DECIMAL:
; 1001 :             fprintf(output, "NUMBER_DECIMAL "); break;

	jmp	_fprintf
$LN32@xmlRegPrin:

; 1002 :         case XML_REGEXP_NUMBER_LETTER:
; 1003 :             fprintf(output, "NUMBER_LETTER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@FJBLFHMA@NUMBER_LETTER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1002 :         case XML_REGEXP_NUMBER_LETTER:
; 1003 :             fprintf(output, "NUMBER_LETTER "); break;

	jmp	_fprintf
$LN33@xmlRegPrin:

; 1004 :         case XML_REGEXP_NUMBER_OTHERS:
; 1005 :             fprintf(output, "NUMBER_OTHERS "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@PDKFLOJK@NUMBER_OTHERS?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1004 :         case XML_REGEXP_NUMBER_OTHERS:
; 1005 :             fprintf(output, "NUMBER_OTHERS "); break;

	jmp	_fprintf
$LN34@xmlRegPrin:

; 1006 :         case XML_REGEXP_PUNCT:
; 1007 :             fprintf(output, "PUNCT "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_06INFGODEH@PUNCT?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1006 :         case XML_REGEXP_PUNCT:
; 1007 :             fprintf(output, "PUNCT "); break;

	jmp	_fprintf
$LN35@xmlRegPrin:

; 1008 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 1009 :             fprintf(output, "PUNCT_CONNECTOR "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@DCHADIII@PUNCT_CONNECTOR?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1008 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 1009 :             fprintf(output, "PUNCT_CONNECTOR "); break;

	jmp	_fprintf
$LN36@xmlRegPrin:

; 1010 :         case XML_REGEXP_PUNCT_DASH:
; 1011 :             fprintf(output, "PUNCT_DASH "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0M@BBMKBPFM@PUNCT_DASH?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1010 :         case XML_REGEXP_PUNCT_DASH:
; 1011 :             fprintf(output, "PUNCT_DASH "); break;

	jmp	_fprintf
$LN37@xmlRegPrin:

; 1012 :         case XML_REGEXP_PUNCT_OPEN:
; 1013 :             fprintf(output, "PUNCT_OPEN "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0M@FHHCCFFM@PUNCT_OPEN?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1012 :         case XML_REGEXP_PUNCT_OPEN:
; 1013 :             fprintf(output, "PUNCT_OPEN "); break;

	jmp	_fprintf
$LN38@xmlRegPrin:

; 1014 :         case XML_REGEXP_PUNCT_CLOSE:
; 1015 :             fprintf(output, "PUNCT_CLOSE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@OCGFHNOE@PUNCT_CLOSE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1014 :         case XML_REGEXP_PUNCT_CLOSE:
; 1015 :             fprintf(output, "PUNCT_CLOSE "); break;

	jmp	_fprintf
$LN39@xmlRegPrin:

; 1016 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 1017 :             fprintf(output, "PUNCT_INITQUOTE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@HJFINBLL@PUNCT_INITQUOTE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1016 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 1017 :             fprintf(output, "PUNCT_INITQUOTE "); break;

	jmp	_fprintf
$LN40@xmlRegPrin:

; 1018 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 1019 :             fprintf(output, "PUNCT_FINQUOTE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BA@EBCHGEDF@PUNCT_FINQUOTE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1018 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 1019 :             fprintf(output, "PUNCT_FINQUOTE "); break;

	jmp	_fprintf
$LN41@xmlRegPrin:

; 1020 :         case XML_REGEXP_PUNCT_OTHERS:
; 1021 :             fprintf(output, "PUNCT_OTHERS "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0O@FIEDELON@PUNCT_OTHERS?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1020 :         case XML_REGEXP_PUNCT_OTHERS:
; 1021 :             fprintf(output, "PUNCT_OTHERS "); break;

	jmp	_fprintf
$LN42@xmlRegPrin:

; 1022 :         case XML_REGEXP_SEPAR:
; 1023 :             fprintf(output, "SEPAR "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_06MODMGGJL@SEPAR?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1022 :         case XML_REGEXP_SEPAR:
; 1023 :             fprintf(output, "SEPAR "); break;

	jmp	_fprintf
$LN43@xmlRegPrin:

; 1024 :         case XML_REGEXP_SEPAR_SPACE:
; 1025 :             fprintf(output, "SEPAR_SPACE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@CEDLANHM@SEPAR_SPACE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1024 :         case XML_REGEXP_SEPAR_SPACE:
; 1025 :             fprintf(output, "SEPAR_SPACE "); break;

	jmp	_fprintf
$LN44@xmlRegPrin:

; 1026 :         case XML_REGEXP_SEPAR_LINE:
; 1027 :             fprintf(output, "SEPAR_LINE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0M@GPNEEMIA@SEPAR_LINE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1026 :         case XML_REGEXP_SEPAR_LINE:
; 1027 :             fprintf(output, "SEPAR_LINE "); break;

	jmp	_fprintf
$LN45@xmlRegPrin:

; 1028 :         case XML_REGEXP_SEPAR_PARA:
; 1029 :             fprintf(output, "SEPAR_PARA "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0M@DGHGIFFK@SEPAR_PARA?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1028 :         case XML_REGEXP_SEPAR_PARA:
; 1029 :             fprintf(output, "SEPAR_PARA "); break;

	jmp	_fprintf
$LN46@xmlRegPrin:

; 1030 :         case XML_REGEXP_SYMBOL:
; 1031 :             fprintf(output, "SYMBOL "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_07EJLPHCCB@SYMBOL?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1030 :         case XML_REGEXP_SYMBOL:
; 1031 :             fprintf(output, "SYMBOL "); break;

	jmp	_fprintf
$LN47@xmlRegPrin:

; 1032 :         case XML_REGEXP_SYMBOL_MATH:
; 1033 :             fprintf(output, "SYMBOL_MATH "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0N@LBDJILGE@SYMBOL_MATH?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1032 :         case XML_REGEXP_SYMBOL_MATH:
; 1033 :             fprintf(output, "SYMBOL_MATH "); break;

	jmp	_fprintf
$LN48@xmlRegPrin:

; 1034 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 1035 :             fprintf(output, "SYMBOL_CURRENCY "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@MBFAMNND@SYMBOL_CURRENCY?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1034 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 1035 :             fprintf(output, "SYMBOL_CURRENCY "); break;

	jmp	_fprintf
$LN49@xmlRegPrin:

; 1036 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 1037 :             fprintf(output, "SYMBOL_MODIFIER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0BB@CEPANLJE@SYMBOL_MODIFIER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1036 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 1037 :             fprintf(output, "SYMBOL_MODIFIER "); break;

	jmp	_fprintf
$LN50@xmlRegPrin:

; 1038 :         case XML_REGEXP_SYMBOL_OTHERS:
; 1039 :             fprintf(output, "SYMBOL_OTHERS "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@LKPECLCL@SYMBOL_OTHERS?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1038 :         case XML_REGEXP_SYMBOL_OTHERS:
; 1039 :             fprintf(output, "SYMBOL_OTHERS "); break;

	jmp	_fprintf
$LN51@xmlRegPrin:

; 1040 :         case XML_REGEXP_OTHER:
; 1041 :             fprintf(output, "OTHER "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_06HJDKAKAL@OTHER?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1040 :         case XML_REGEXP_OTHER:
; 1041 :             fprintf(output, "OTHER "); break;

	jmp	_fprintf
$LN52@xmlRegPrin:

; 1042 :         case XML_REGEXP_OTHER_CONTROL:
; 1043 :             fprintf(output, "OTHER_CONTROL "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@FGFCBEPI@OTHER_CONTROL?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1042 :         case XML_REGEXP_OTHER_CONTROL:
; 1043 :             fprintf(output, "OTHER_CONTROL "); break;

	jmp	_fprintf
$LN53@xmlRegPrin:

; 1044 :         case XML_REGEXP_OTHER_FORMAT:
; 1045 :             fprintf(output, "OTHER_FORMAT "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0O@BACNFCMB@OTHER_FORMAT?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1044 :         case XML_REGEXP_OTHER_FORMAT:
; 1045 :             fprintf(output, "OTHER_FORMAT "); break;

	jmp	_fprintf
$LN54@xmlRegPrin:

; 1046 :         case XML_REGEXP_OTHER_PRIVATE:
; 1047 :             fprintf(output, "OTHER_PRIVATE "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_0P@DEHNHHA@OTHER_PRIVATE?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1046 :         case XML_REGEXP_OTHER_PRIVATE:
; 1047 :             fprintf(output, "OTHER_PRIVATE "); break;

	jmp	_fprintf
$LN55@xmlRegPrin:

; 1048 :         case XML_REGEXP_OTHER_NA:
; 1049 :             fprintf(output, "OTHER_NA "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_09NECDEFOF@OTHER_NA?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1048 :         case XML_REGEXP_OTHER_NA:
; 1049 :             fprintf(output, "OTHER_NA "); break;

	jmp	_fprintf
$LN56@xmlRegPrin:

; 1050 :         case XML_REGEXP_BLOCK_NAME:
; 1051 : 	    fprintf(output, "BLOCK "); break;

	mov	DWORD PTR _type$[ebp], OFFSET ??_C@_06HDNEPAAO@BLOCK?5@

; 1052 :     }
; 1053 : }

	pop	ebp

; 1050 :         case XML_REGEXP_BLOCK_NAME:
; 1051 : 	    fprintf(output, "BLOCK "); break;

	jmp	_fprintf
$LN2@xmlRegPrin:

; 1052 :     }
; 1053 : }

	pop	ebp
	ret	0
	npad	3
$LN62@xmlRegPrin:
	DD	$LN4@xmlRegPrin
	DD	$LN5@xmlRegPrin
	DD	$LN6@xmlRegPrin
	DD	$LN7@xmlRegPrin
	DD	$LN8@xmlRegPrin
	DD	$LN9@xmlRegPrin
	DD	$LN10@xmlRegPrin
	DD	$LN11@xmlRegPrin
	DD	$LN12@xmlRegPrin
	DD	$LN13@xmlRegPrin
	DD	$LN14@xmlRegPrin
	DD	$LN15@xmlRegPrin
	DD	$LN16@xmlRegPrin
	DD	$LN17@xmlRegPrin
	DD	$LN18@xmlRegPrin
	DD	$LN19@xmlRegPrin
	DD	$LN20@xmlRegPrin
	DD	$LN21@xmlRegPrin
	DD	$LN22@xmlRegPrin
	DD	$LN23@xmlRegPrin
	DD	$LN24@xmlRegPrin
	DD	$LN25@xmlRegPrin
	DD	$LN26@xmlRegPrin
	DD	$LN27@xmlRegPrin
	DD	$LN28@xmlRegPrin
	DD	$LN29@xmlRegPrin
	DD	$LN30@xmlRegPrin
	DD	$LN31@xmlRegPrin
	DD	$LN32@xmlRegPrin
	DD	$LN33@xmlRegPrin
	DD	$LN34@xmlRegPrin
	DD	$LN35@xmlRegPrin
	DD	$LN36@xmlRegPrin
	DD	$LN37@xmlRegPrin
	DD	$LN38@xmlRegPrin
	DD	$LN39@xmlRegPrin
	DD	$LN40@xmlRegPrin
	DD	$LN41@xmlRegPrin
	DD	$LN42@xmlRegPrin
	DD	$LN43@xmlRegPrin
	DD	$LN44@xmlRegPrin
	DD	$LN45@xmlRegPrin
	DD	$LN46@xmlRegPrin
	DD	$LN47@xmlRegPrin
	DD	$LN48@xmlRegPrin
	DD	$LN49@xmlRegPrin
	DD	$LN50@xmlRegPrin
	DD	$LN51@xmlRegPrin
	DD	$LN52@xmlRegPrin
	DD	$LN53@xmlRegPrin
	DD	$LN54@xmlRegPrin
	DD	$LN55@xmlRegPrin
	DD	$LN56@xmlRegPrin
	DD	$LN2@xmlRegPrin
$LN58@xmlRegPrin:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	53					; 00000035H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
_xmlRegPrintAtomType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRegFreeParserCtxt PROC				; COMDAT

; 915  : xmlRegFreeParserCtxt(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlRegFree

; 916  :     int i;
; 917  :     if (ctxt == NULL)
; 918  : 	return;
; 919  : 
; 920  :     if (ctxt->string != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@xmlRegFree

; 921  : 	xmlFree(ctxt->string);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRegFree:

; 922  :     if (ctxt->states != NULL) {

	cmp	DWORD PTR [esi+52], 0
	push	edi
	je	SHORT $LN10@xmlRegFree

; 923  : 	for (i = 0;i < ctxt->nbStates;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+48], edi
	jle	SHORT $LN3@xmlRegFree
	push	ebx
$LL4@xmlRegFree:

; 924  : 	    xmlRegFreeState(ctxt->states[i]);

	mov	eax, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [eax+edi*4]

; 898  :     if (state == NULL)

	test	ebx, ebx
	je	SHORT $LN2@xmlRegFree

; 899  : 	return;
; 900  : 
; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN16@xmlRegFree

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlRegFree:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN17@xmlRegFree

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlRegFree:

; 905  :     xmlFree(state);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRegFree:

; 923  : 	for (i = 0;i < ctxt->nbStates;i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+48]
	jl	SHORT $LL4@xmlRegFree
	pop	ebx
$LN3@xmlRegFree:

; 925  : 	xmlFree(ctxt->states);

	push	DWORD PTR [esi+52]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlRegFree:

; 926  :     }
; 927  :     if (ctxt->atoms != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN11@xmlRegFree

; 928  : 	for (i = 0;i < ctxt->nbAtoms;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN6@xmlRegFree
	npad	1
$LL7@xmlRegFree:

; 929  : 	    xmlRegFreeAtom(ctxt->atoms[i]);

	mov	eax, DWORD PTR [esi+40]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRegFreeAtom
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL7@xmlRegFree
	mov	eax, DWORD PTR [esi+40]
$LN6@xmlRegFree:

; 930  : 	xmlFree(ctxt->atoms);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRegFree:

; 931  :     }
; 932  :     if (ctxt->counters != NULL)

	mov	eax, DWORD PTR [esi+64]
	pop	edi
	test	eax, eax
	je	SHORT $LN12@xmlRegFree

; 933  : 	xmlFree(ctxt->counters);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRegFree:

; 934  :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRegFree:
	pop	esi

; 935  : }

	pop	ebp
	ret	0
_xmlRegFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewState
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlRegNewState PROC					; COMDAT

; 876  : xmlRegNewState(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlRegNewS

; 381  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN5@xmlRegNewS

; 382  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax]

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+8], 2
$LN5@xmlRegNewS:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BB@CKELLPME@allocating?5state@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0BB@CKELLPME@allocating?5state@
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 877  :     xmlRegStatePtr ret;
; 878  : 
; 879  :     ret = (xmlRegStatePtr) xmlMalloc(sizeof(xmlRegState));
; 880  :     if (ret == NULL) {
; 881  : 	xmlRegexpErrMemory(ctxt, "allocating state");
; 882  : 	return(NULL);

	xor	eax, eax

; 887  :     return(ret);
; 888  : }

	pop	ebp
	ret	0
$LN2@xmlRegNewS:

; 883  :     }
; 884  :     memset(ret, 0, sizeof(xmlRegState));

	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0

; 885  :     ret->type = XML_REGEXP_TRANS_STATE;

	mov	DWORD PTR [eax], 3

; 886  :     ret->mark = XML_REGEXP_MARK_NORMAL;

	mov	DWORD PTR [eax+4], 0

; 887  :     return(ret);
; 888  : }

	pop	ebp
	ret	0
_xmlRegNewState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCopyAtom
_TEXT	SEGMENT
_range$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_atom$ = 12						; size = 4
_xmlRegCopyAtom PROC					; COMDAT

; 839  : xmlRegCopyAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN5@xmlRegCopy

; 381  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN11@xmlRegCopy

; 382  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax]

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+8], 2
$LN11@xmlRegCopy:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0N@ECMBACNP@copying?5atom@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0N@ECMBACNP@copying?5atom@
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 840  :     xmlRegAtomPtr ret;
; 841  : 
; 842  :     ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));
; 843  :     if (ret == NULL) {
; 844  : 	xmlRegexpErrMemory(ctxt, "copying atom");
; 845  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRegCopy:
	push	ebx
	push	esi

; 846  :     }
; 847  :     memset(ret, 0, sizeof(xmlRegAtom));

	push	64					; 00000040H
	push	0
	push	edi
	call	_memset

; 848  :     ret->type = atom->type;

	mov	esi, DWORD PTR _atom$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax

; 849  :     ret->quant = atom->quant;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax

; 850  :     ret->min = atom->min;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax

; 851  :     ret->max = atom->max;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 852  :     if (atom->nbRanges > 0) {

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	jle	$LN3@xmlRegCopy

; 853  :         int i;
; 854  : 
; 855  :         ret->ranges = (xmlRegRangePtr *) xmlMalloc(sizeof(xmlRegRangePtr) *

	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+56], eax

; 856  : 	                                           atom->nbRanges);
; 857  : 	if (ret->ranges == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRegCopy

; 858  : 	    xmlRegexpErrMemory(ctxt, "copying atom");

	push	OFFSET ??_C@_0N@ECMBACNP@copying?5atom@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8
$error$28:

; 869  : 
; 870  : error:
; 871  :     xmlRegFreeAtom(ret);

	push	edi
	call	_xmlRegFreeAtom
	add	esp, 4

; 872  :     return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRegCopy:

; 859  : 	    goto error;
; 860  : 	}
; 861  : 	for (i = 0;i < atom->nbRanges;i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [esi+52], ebx
	jle	SHORT $LN3@xmlRegCopy
	npad	3
$LL4@xmlRegCopy:

; 862  : 	    ret->ranges[i] = xmlRegCopyRange(ctxt, atom->ranges[i]);

	mov	eax, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _range$1$[ebp], eax

; 759  :     if (range == NULL)

	test	eax, eax
	je	SHORT $LN26@xmlRegCopy

; 760  : 	return(NULL);
; 761  : 
; 762  :     ret = xmlRegNewRange(ctxt, range->neg, range->type, range->start,

	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegNewRange
	mov	esi, eax
	add	esp, 20					; 00000014H

; 763  :                          range->end);
; 764  :     if (ret == NULL)

	test	esi, esi
	je	SHORT $LN26@xmlRegCopy

; 765  :         return(NULL);
; 766  :     if (range->blockName != NULL) {

	mov	eax, DWORD PTR _range$1$[ebp]
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN17@xmlRegCopy

; 767  : 	ret->blockName = xmlStrdup(range->blockName);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 768  : 	if (ret->blockName == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlRegCopy

; 769  : 	    xmlRegexpErrMemory(ctxt, "allocating range");

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 770  : 	    xmlRegFreeRange(ret);

	push	esi
	call	_xmlRegFreeRange
	add	esp, 12					; 0000000cH
$LN26@xmlRegCopy:

; 862  : 	    ret->ranges[i] = xmlRegCopyRange(ctxt, atom->ranges[i]);

	xor	esi, esi
$LN17@xmlRegCopy:
	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [eax+ebx*4], esi

; 863  : 	    if (ret->ranges[i] == NULL)

	mov	eax, DWORD PTR [edi+56]
	cmp	DWORD PTR [eax+ebx*4], 0
	je	$error$28

; 864  : 	        goto error;
; 865  : 	    ret->nbRanges = i + 1;

	mov	esi, DWORD PTR _atom$[ebp]
	inc	ebx
	mov	DWORD PTR [edi+52], ebx
	cmp	ebx, DWORD PTR [esi+52]
	jl	SHORT $LL4@xmlRegCopy
$LN3@xmlRegCopy:
	pop	esi
	pop	ebx

; 866  : 	}
; 867  :     }
; 868  :     return(ret);

	mov	eax, edi
	pop	edi

; 873  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegCopyAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewAtom
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_xmlRegNewAtom PROC					; COMDAT

; 787  : xmlRegNewAtom(xmlRegParserCtxtPtr ctxt, xmlRegAtomType type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlRegNewA

; 381  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN5@xmlRegNewA

; 382  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax]

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+8], 2
$LN5@xmlRegNewA:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BA@JCPCIFNM@allocating?5atom@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0BA@JCPCIFNM@allocating?5atom@
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 788  :     xmlRegAtomPtr ret;
; 789  : 
; 790  :     ret = (xmlRegAtomPtr) xmlMalloc(sizeof(xmlRegAtom));
; 791  :     if (ret == NULL) {
; 792  : 	xmlRegexpErrMemory(ctxt, "allocating atom");
; 793  : 	return(NULL);

	xor	eax, eax

; 800  :     return(ret);
; 801  : }

	pop	ebp
	ret	0
$LN2@xmlRegNewA:

; 794  :     }
; 795  :     memset(ret, 0, sizeof(xmlRegAtom));
; 796  :     ret->type = type;

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
	mov	DWORD PTR [eax+56], 0
	mov	DWORD PTR [eax+60], 0
	mov	DWORD PTR [eax+4], ecx

; 797  :     ret->quant = XML_REGEXP_QUANT_ONCE;

	mov	DWORD PTR [eax+8], 2

; 798  :     ret->min = 0;

	mov	DWORD PTR [eax+12], 0

; 799  :     ret->max = 0;

	mov	DWORD PTR [eax+16], 0

; 800  :     return(ret);
; 801  : }

	pop	ebp
	ret	0
_xmlRegNewAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCopyRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_range$ = 12						; size = 4
_xmlRegCopyRange PROC					; COMDAT

; 756  : xmlRegCopyRange(xmlRegParserCtxtPtr ctxt, xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _range$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlRegCopy

; 757  :     xmlRegRangePtr ret;
; 758  : 
; 759  :     if (range == NULL)
; 760  : 	return(NULL);
; 761  : 
; 762  :     ret = xmlRegNewRange(ctxt, range->neg, range->type, range->start,

	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegNewRange
	mov	edi, eax
	add	esp, 20					; 00000014H

; 763  :                          range->end);
; 764  :     if (ret == NULL)

	test	edi, edi
	je	SHORT $LN7@xmlRegCopy

; 765  :         return(NULL);
; 766  :     if (range->blockName != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlRegCopy

; 767  : 	ret->blockName = xmlStrdup(range->blockName);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+16], eax

; 768  : 	if (ret->blockName == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlRegCopy

; 769  : 	    xmlRegexpErrMemory(ctxt, "allocating range");

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 770  : 	    xmlRegFreeRange(ret);

	push	edi
	call	_xmlRegFreeRange
	add	esp, 12					; 0000000cH
$LN7@xmlRegCopy:

; 775  : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlRegCopy:

; 771  : 	    return(NULL);
; 772  : 	}
; 773  :     }
; 774  :     return(ret);

	mov	eax, edi
	pop	edi

; 775  : }

	pop	esi
	pop	ebp
	ret	0
_xmlRegCopyRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeRange
_TEXT	SEGMENT
_range$ = 8						; size = 4
_xmlRegFreeRange PROC					; COMDAT

; 738  : xmlRegFreeRange(xmlRegRangePtr range) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _range$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRegFree

; 739  :     if (range == NULL)
; 740  : 	return;
; 741  : 
; 742  :     if (range->blockName != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN3@xmlRegFree

; 743  : 	xmlFree(range->blockName);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRegFree:

; 744  :     xmlFree(range);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRegFree:
	pop	esi

; 745  : }

	pop	ebp
	ret	0
_xmlRegFreeRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_neg$ = 12						; size = 4
_type$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_xmlRegNewRange PROC					; COMDAT

; 716  : 	       int neg, xmlRegAtomType type, int start, int end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@xmlRegNewR

; 381  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlRegNewR

; 382  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax]

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+8], 2
$LN5@xmlRegNewR:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 717  :     xmlRegRangePtr ret;
; 718  : 
; 719  :     ret = (xmlRegRangePtr) xmlMalloc(sizeof(xmlRegRange));
; 720  :     if (ret == NULL) {
; 721  : 	xmlRegexpErrMemory(ctxt, "allocating range");
; 722  : 	return(NULL);

	xor	eax, eax

; 729  : }

	pop	ebp
	ret	0
$LN2@xmlRegNewR:

; 723  :     }
; 724  :     ret->neg = neg;

	mov	eax, DWORD PTR _neg$[ebp]
	mov	DWORD PTR [ecx], eax

; 725  :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 726  :     ret->start = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 727  :     ret->end = end;

	mov	eax, DWORD PTR _end$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 728  :     return(ret);

	mov	eax, ecx

; 729  : }

	pop	ebp
	ret	0
_xmlRegNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewParserCtxt
_TEXT	SEGMENT
_string$ = 8						; size = 4
_xmlRegNewParserCtxt PROC				; COMDAT

; 685  : xmlRegNewParserCtxt(const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlRegNewP
	pop	esi

; 700  : }

	pop	ebp
	ret	0
$LN2@xmlRegNewP:

; 686  :     xmlRegParserCtxtPtr ret;
; 687  : 
; 688  :     ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));
; 689  :     if (ret == NULL)
; 690  : 	return(NULL);
; 691  :     memset(ret, 0, sizeof(xmlRegParserCtxt));

	push	80					; 00000050H
	push	0
	push	esi
	call	_memset

; 692  :     if (string != NULL)

	mov	ecx, DWORD PTR _string$[ebp]
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN3@xmlRegNewP

; 693  : 	ret->string = xmlStrdup(string);

	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax
$LN3@xmlRegNewP:

; 694  :     ret->cur = ret->string;

	mov	DWORD PTR [esi+4], eax

; 695  :     ret->neg = 0;
; 696  :     ret->negs = 0;
; 697  :     ret->error = 0;
; 698  :     ret->determinist = -1;
; 699  :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+68], -1
	pop	esi

; 700  : }

	pop	ebp
	ret	0
_xmlRegNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegEpxFromParse
_TEXT	SEGMENT
_stateno$1$ = -60					; size = 4
tv1256 = -56						; size = 4
_j$2$ = -52						; size = 4
_atomno$1$ = -48					; size = 4
_trans$1$ = -44						; size = 4
tv1268 = -40						; size = 4
_i$5$ = -36						; size = 4
_i$2$ = -36						; size = 4
_state$1$ = -32						; size = 4
_transitions$1$ = -28					; size = 4
_value$1$ = -28						; size = 4
_ret$1$ = -24						; size = 4
_transdata$1$ = -20					; size = 4
tv1274 = -20						; size = 4
_nbstates$1$ = -16					; size = 4
_stringRemap$1$ = -12					; size = 4
_stringMap$1$ = -8					; size = 4
_stateRemap$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlRegEpxFromParse PROC				; COMDAT

; 430  : xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LN32@xmlRegEpxF

; 381  :     if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN61@xmlRegEpxF

; 382  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax]

; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+8], 2
$LN61@xmlRegEpxF:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 431  :     xmlRegexpPtr ret;
; 432  : 
; 433  :     ret = (xmlRegexpPtr) xmlMalloc(sizeof(xmlRegexp));
; 434  :     if (ret == NULL) {
; 435  : 	xmlRegexpErrMemory(ctxt, "compiling regexp");
; 436  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlRegEpxF:
	push	esi

; 437  :     }
; 438  :     memset(ret, 0, sizeof(xmlRegexp));

	push	56					; 00000038H
	push	0
	push	edi
	call	_memset

; 439  :     ret->string = ctxt->string;

	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 440  :     ret->nbStates = ctxt->nbStates;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+4], eax

; 441  :     ret->states = ctxt->states;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+8], eax

; 442  :     ret->nbAtoms = ctxt->nbAtoms;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+12], eax

; 443  :     ret->atoms = ctxt->atoms;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [edi+16], eax

; 444  :     ret->nbCounters = ctxt->nbCounters;

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [edi+20], eax

; 445  :     ret->counters = ctxt->counters;

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [edi+24], eax

; 446  :     ret->determinist = ctxt->determinist;

	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [edi+28], ecx

; 447  :     ret->flags = ctxt->flags;

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [edi+32], eax

; 448  :     if (ret->determinist == -1) {

	cmp	ecx, -1
	jne	SHORT $LN33@xmlRegEpxF

; 449  :         xmlRegexpIsDeterminist(ret);

	push	edi
	call	_xmlRegexpIsDeterminist
	mov	ecx, DWORD PTR [edi+28]
	add	esp, 4
$LN33@xmlRegEpxF:

; 450  :     }
; 451  : 
; 452  :     if ((ret->determinist != 0) &&
; 453  : 	(ret->nbCounters == 0) &&
; 454  : 	(ctxt->negs == 0) &&
; 455  : 	(ret->atoms != NULL) &&
; 456  : 	(ret->atoms[0] != NULL) &&

	push	ebx
	test	ecx, ecx
	je	$not_determ$118
	cmp	DWORD PTR [edi+20], 0
	jne	$not_determ$118
	cmp	DWORD PTR [esi+72], 0
	jne	$not_determ$118
	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	$not_determ$118
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$not_determ$118
	cmp	DWORD PTR [eax+4], 5
	jne	$not_determ$118

; 457  : 	(ret->atoms[0]->type == XML_REGEXP_STRING)) {
; 458  : 	int i, j, nbstates = 0, nbatoms = 0;
; 459  : 	int *stateRemap;
; 460  : 	int *stringRemap;
; 461  : 	int *transitions;
; 462  : 	void **transdata;
; 463  : 	xmlChar **stringMap;
; 464  :         xmlChar *value;
; 465  : 
; 466  : 	/*
; 467  : 	 * Switch to a compact representation
; 468  : 	 * 1/ counting the effective number of states left
; 469  : 	 * 2/ counting the unique number of atoms, and check that
; 470  : 	 *    they are all of the string type
; 471  : 	 * 3/ build a table state x atom for the transitions
; 472  : 	 */
; 473  : 
; 474  : 	stateRemap = xmlMalloc(ret->nbStates * sizeof(int));

	mov	eax, DWORD PTR [edi+4]
	xor	ebx, ebx
	shl	eax, 2
	push	eax
	mov	DWORD PTR _nbstates$1$[ebp], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _stateRemap$1$[ebp], eax

; 475  : 	if (stateRemap == NULL) {

	test	eax, eax
	jne	SHORT $LN35@xmlRegEpxF

; 476  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	esi
	call	_xmlRegexpErrMemory

; 477  : 	    xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 550  : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlRegEpxF:

; 478  : 	    return(NULL);
; 479  : 	}
; 480  : 	for (i = 0;i < ret->nbStates;i++) {

	xor	esi, esi
	cmp	DWORD PTR [edi+4], ebx
	jle	SHORT $LN3@xmlRegEpxF
	mov	ebx, DWORD PTR _stateRemap$1$[ebp]
	npad	6
$LL4@xmlRegEpxF:

; 481  : 	    if (ret->states[i] != NULL) {

	mov	eax, DWORD PTR [edi+8]
	or	edx, -1
	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	mov	eax, DWORD PTR _nbstates$1$[ebp]
	cmovne	edx, eax
	inc	eax
	test	ecx, ecx
	mov	DWORD PTR [ebx+esi*4], edx
	cmove	eax, DWORD PTR _nbstates$1$[ebp]
	inc	esi
	mov	DWORD PTR _nbstates$1$[ebp], eax
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL4@xmlRegEpxF

; 518  : 		    stringMap[nbatoms] = xmlStrdup(value);

	mov	DWORD PTR _nbstates$1$[ebp], eax
	xor	ebx, ebx
$LN3@xmlRegEpxF:

; 482  : 		stateRemap[i] = nbstates;
; 483  : 		nbstates++;
; 484  : 	    } else {
; 485  : 		stateRemap[i] = -1;
; 486  : 	    }
; 487  : 	}
; 488  : #ifdef DEBUG_COMPACTION
; 489  : 	printf("Final: %d states\n", nbstates);
; 490  : #endif
; 491  : 	stringMap = xmlMalloc(ret->nbAtoms * sizeof(char *));

	mov	eax, DWORD PTR [edi+12]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _stringMap$1$[ebp], esi

; 492  : 	if (stringMap == NULL) {

	test	esi, esi
	jne	SHORT $LN38@xmlRegEpxF

; 493  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 494  : 	    xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]

; 495  : 	    xmlFree(ret);
; 496  : 	    return(NULL);

	jmp	$LN115@xmlRegEpxF
$LN38@xmlRegEpxF:

; 497  : 	}
; 498  : 	stringRemap = xmlMalloc(ret->nbAtoms * sizeof(int));

	mov	eax, DWORD PTR [edi+12]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _stringRemap$1$[ebp], eax

; 499  : 	if (stringRemap == NULL) {

	test	eax, eax
	jne	SHORT $LN39@xmlRegEpxF

; 500  : 	    xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory

; 501  : 	    xmlFree(stringMap);

	push	esi
	call	DWORD PTR _xmlFree

; 502  : 	    xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 503  : 	    xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 550  : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlRegEpxF:

; 504  : 	    return(NULL);
; 505  : 	}
; 506  : 	for (i = 0;i < ret->nbAtoms;i++) {

	xor	eax, eax
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	DWORD PTR [edi+12], eax
	jle	$LN6@xmlRegEpxF
	npad	4
$LL7@xmlRegEpxF:

; 507  : 	    if ((ret->atoms[i]->type == XML_REGEXP_STRING) &&

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR tv1274[ebp], esi
	mov	eax, DWORD PTR [esi+eax]
	cmp	DWORD PTR [eax+4], 5
	jne	$LN40@xmlRegEpxF
	cmp	DWORD PTR [eax+8], 2
	jne	$LN40@xmlRegEpxF

; 508  : 		(ret->atoms[i]->quant == XML_REGEXP_QUANT_ONCE)) {
; 509  : 		value = ret->atoms[i]->valuep;

	mov	eax, DWORD PTR [eax+20]

; 510  :                 for (j = 0;j < nbatoms;j++) {

	xor	esi, esi
	mov	DWORD PTR _value$1$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN109@xmlRegEpxF
$LL10@xmlRegEpxF:

; 511  : 		    if (xmlStrEqual(stringMap[j], value)) {

	push	eax
	mov	eax, DWORD PTR _stringMap$1$[ebp]
	push	DWORD PTR [eax+esi*4]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN73@xmlRegEpxF

; 510  :                 for (j = 0;j < nbatoms;j++) {

	mov	eax, DWORD PTR _value$1$[ebp]
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL10@xmlRegEpxF
$LN109@xmlRegEpxF:

; 517  : 		    stringRemap[i] = nbatoms;

	mov	ecx, DWORD PTR tv1274[ebp]
$LN106@xmlRegEpxF:
	mov	edx, DWORD PTR _stringRemap$1$[ebp]

; 518  : 		    stringMap[nbatoms] = xmlStrdup(value);

	push	eax
	mov	DWORD PTR [ecx+edx], ebx
	call	_xmlStrdup
	mov	ecx, DWORD PTR _stringMap$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+ebx*4], eax

; 519  : 		    if (stringMap[nbatoms] == NULL) {

	test	eax, eax
	je	SHORT $LN74@xmlRegEpxF

; 527  : 		    }
; 528  : 		    nbatoms++;

	inc	ebx
$LN5@xmlRegEpxF:

; 504  : 	    return(NULL);
; 505  : 	}
; 506  : 	for (i = 0;i < ret->nbAtoms;i++) {

	mov	eax, DWORD PTR _i$2$[ebp]
	inc	eax
	mov	DWORD PTR _i$2$[ebp], eax
	cmp	eax, DWORD PTR [edi+12]
	jl	SHORT $LL7@xmlRegEpxF
$LN6@xmlRegEpxF:

; 538  : 	    }
; 539  : 	}
; 540  : #ifdef DEBUG_COMPACTION
; 541  : 	printf("Final: %d atoms\n", nbatoms);
; 542  : #endif
; 543  : 	transitions = (int *) xmlMalloc((nbstates + 1) *

	mov	eax, DWORD PTR _nbstates$1$[ebp]
	lea	esi, DWORD PTR [ebx+1]
	inc	eax
	imul	esi, eax
	shl	esi, 2
	push	esi
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _transitions$1$[ebp], eax

; 544  : 	                                (nbatoms + 1) * sizeof(int));
; 545  : 	if (transitions == NULL) {

	test	eax, eax
	jne	$LN45@xmlRegEpxF

; 546  : 	    xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 547  : 	    xmlFree(stringRemap);

	push	DWORD PTR _stringRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 548  : 	    xmlFree(stringMap);

	push	DWORD PTR _stringMap$1$[ebp]
$LN115@xmlRegEpxF:
	call	DWORD PTR _xmlFree

; 549  : 	    xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 550  : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlRegEpxF:

; 512  : 			stringRemap[i] = j;

	mov	ecx, DWORD PTR tv1274[ebp]
	mov	eax, DWORD PTR _stringRemap$1$[ebp]
	mov	DWORD PTR [ecx+eax], esi

; 513  : 			break;
; 514  : 		    }
; 515  : 		}
; 516  : 		if (j >= nbatoms) {

	cmp	esi, ebx
	jl	SHORT $LN5@xmlRegEpxF

; 510  :                 for (j = 0;j < nbatoms;j++) {

	mov	eax, DWORD PTR _value$1$[ebp]
	jmp	$LN106@xmlRegEpxF
$LN74@xmlRegEpxF:

; 520  : 			for (i = 0;i < nbatoms;i++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN12@xmlRegEpxF
$LL13@xmlRegEpxF:

; 521  : 			    xmlFree(stringMap[i]);

	push	DWORD PTR [ecx+esi*4]
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _stringMap$1$[ebp]
	inc	esi
	add	esp, 4
	cmp	esi, ebx
	jl	SHORT $LL13@xmlRegEpxF
$LN12@xmlRegEpxF:

; 522  : 			xmlFree(stringRemap);

	push	DWORD PTR _stringRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 523  : 			xmlFree(stringMap);

	push	DWORD PTR _stringMap$1$[ebp]
	call	DWORD PTR _xmlFree

; 524  : 			xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]

; 525  : 			xmlFree(ret);
; 526  : 			return(NULL);

	jmp	SHORT $LN115@xmlRegEpxF
$LN40@xmlRegEpxF:

; 529  : 		}
; 530  : 	    } else {
; 531  : 		xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 532  : 		xmlFree(stringRemap);

	push	DWORD PTR _stringRemap$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
	xor	esi, esi

; 533  : 		for (i = 0;i < nbatoms;i++)

	test	ebx, ebx
	jle	SHORT $LN15@xmlRegEpxF
	mov	edi, DWORD PTR _stringMap$1$[ebp]
	npad	4
$LL16@xmlRegEpxF:

; 534  : 		    xmlFree(stringMap[i]);

	push	DWORD PTR [edi+esi*4]
	call	DWORD PTR _xmlFree
	inc	esi
	add	esp, 4
	cmp	esi, ebx
	jl	SHORT $LL16@xmlRegEpxF
	mov	edi, DWORD PTR _ret$1$[ebp]
$LN15@xmlRegEpxF:

; 535  : 		xmlFree(stringMap);

	push	DWORD PTR _stringMap$1$[ebp]
	call	DWORD PTR _xmlFree

; 536  : 		xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 537  : 		return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlRegEpxF:

; 551  : 	}
; 552  : 	memset(transitions, 0, (nbstates + 1) * (nbatoms + 1) * sizeof(int));

	push	esi
	push	0
	push	eax
	call	_memset

; 553  : 
; 554  : 	/*
; 555  : 	 * Allocate the transition table. The first entry for each
; 556  : 	 * state corresponds to the state type.
; 557  : 	 */
; 558  : 	transdata = NULL;
; 559  : 
; 560  : 	for (i = 0;i < ret->nbStates;i++) {

	xor	ecx, ecx
	xor	esi, esi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _transdata$1$[ebp], esi
	mov	DWORD PTR _i$5$[ebp], ecx
	cmp	DWORD PTR [edi+4], ecx
	jle	$LN108@xmlRegEpxF
	mov	eax, DWORD PTR _stateRemap$1$[ebp]
$LL19@xmlRegEpxF:

; 561  : 	    int stateno, atomno, targetno, prev;
; 562  : 	    xmlRegStatePtr state;
; 563  : 	    xmlRegTransPtr trans;
; 564  : 
; 565  : 	    stateno = stateRemap[i];

	mov	ecx, DWORD PTR [eax+ecx*4]

; 566  : 	    if (stateno == -1)

	cmp	ecx, -1
	je	$LN17@xmlRegEpxF

; 567  : 		continue;
; 568  : 	    state = ret->states[i];

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _i$5$[ebp]

; 569  : 
; 570  : 	    transitions[stateno * (nbatoms + 1)] = state->type;

	mov	edi, DWORD PTR _transitions$1$[ebp]

; 571  : 
; 572  : 	    for (j = 0;j < state->nbTrans;j++) {

	mov	DWORD PTR _j$2$[ebp], 0
	mov	edx, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [ebx+1]
	imul	eax, ecx
	mov	DWORD PTR _state$1$[ebp], edx
	mov	DWORD PTR tv1268[ebp], eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR tv1268[ebp]
	mov	DWORD PTR [edi+edx*4], eax
	mov	eax, DWORD PTR _state$1$[ebp]
	mov	edi, DWORD PTR _ret$1$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jle	$LN111@xmlRegEpxF

; 621  : 			transdata[stateno * nbatoms + atomno] =

	imul	ecx, ebx
	mov	DWORD PTR _stateno$1$[ebp], ecx
	xor	ecx, ecx
	mov	DWORD PTR tv1256[ebp], ecx
$LL22@xmlRegEpxF:

; 573  : 		trans = &(state->trans[j]);

	mov	eax, DWORD PTR [eax+28]
	add	eax, ecx
	mov	DWORD PTR _trans$1$[ebp], eax

; 574  : 		if ((trans->to == -1) || (trans->atom == NULL))

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, -1
	je	$LN20@xmlRegEpxF
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN20@xmlRegEpxF

; 575  : 		    continue;
; 576  :                 atomno = stringRemap[trans->atom->no];
; 577  : 		if ((trans->atom->data != NULL) && (transdata == NULL)) {

	cmp	DWORD PTR [edx+60], 0
	mov	edi, DWORD PTR _stringRemap$1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR _atomno$1$[ebp], eax
	je	SHORT $LN51@xmlRegEpxF
	test	esi, esi
	jne	SHORT $LN51@xmlRegEpxF

; 578  : 		    transdata = (void **) xmlMalloc(nbstates * nbatoms *

	mov	esi, ebx
	imul	esi, DWORD PTR _nbstates$1$[ebp]
	shl	esi, 2
	push	esi
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _transdata$1$[ebp], eax

; 579  : 			                            sizeof(void *));
; 580  : 		    if (transdata != NULL)

	test	eax, eax
	je	SHORT $LN50@xmlRegEpxF

; 581  : 			memset(transdata, 0,

	push	esi
	push	0
	push	eax
	call	_memset
	mov	ecx, DWORD PTR _trans$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _atomno$1$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
$LN51@xmlRegEpxF:

; 585  : 			break;
; 586  : 		    }
; 587  : 		}
; 588  : 		targetno = stateRemap[trans->to];
; 589  : 		/*
; 590  : 		 * if the same atom can generate transitions to 2 different
; 591  : 		 * states then it means the automata is not determinist and
; 592  : 		 * the compact form can't be used !
; 593  : 		 */
; 594  : 		prev = transitions[stateno * (nbatoms + 1) + atomno + 1];

	add	eax, DWORD PTR tv1268[ebp]
	mov	edx, DWORD PTR _transitions$1$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _stateRemap$1$[ebp]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	eax

; 595  : 		if (prev != 0) {

	test	edx, edx
	je	SHORT $LN52@xmlRegEpxF

; 596  : 		    if (prev != targetno + 1) {

	cmp	edx, eax
	jne	SHORT $LN75@xmlRegEpxF

; 612  : 		    }
; 613  : 		} else {

	mov	esi, DWORD PTR _transdata$1$[ebp]
	jmp	SHORT $LN20@xmlRegEpxF
$LN52@xmlRegEpxF:

; 614  : #if 0
; 615  : 		    printf("State %d trans %d: atom %d to %d : %d to %d\n",
; 616  : 			   i, j, trans->atom->no, trans->to, atomno, targetno);
; 617  : #endif
; 618  : 		    transitions[stateno * (nbatoms + 1) + atomno + 1] =

	mov	DWORD PTR [esi+4], eax

; 619  : 			targetno + 1; /* to avoid 0 */
; 620  : 		    if (transdata != NULL)

	mov	esi, DWORD PTR _transdata$1$[ebp]
	test	esi, esi
	je	SHORT $LN20@xmlRegEpxF

; 621  : 			transdata[stateno * nbatoms + atomno] =

	mov	eax, DWORD PTR _trans$1$[ebp]
	mov	ecx, DWORD PTR _atomno$1$[ebp]
	add	ecx, DWORD PTR _stateno$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+60]
	mov	DWORD PTR [esi+ecx*4], eax
$LN20@xmlRegEpxF:

; 571  : 
; 572  : 	    for (j = 0;j < state->nbTrans;j++) {

	mov	eax, DWORD PTR _j$2$[ebp]
	mov	edx, DWORD PTR _state$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv1256[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _j$2$[ebp], eax
	mov	DWORD PTR tv1256[ebp], ecx
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN111@xmlRegEpxF
	mov	eax, edx
	jmp	$LL22@xmlRegEpxF
$LN50@xmlRegEpxF:

; 582  : 			       nbstates * nbatoms * sizeof(void *));
; 583  : 		    else {
; 584  : 			xmlRegexpErrMemory(ctxt, "compiling regexp");

	push	OFFSET ??_C@_0BB@FJPDMDM@compiling?5regexp@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlRegexpErrMemory
	add	esp, 8
$LN111@xmlRegEpxF:

; 553  : 
; 554  : 	/*
; 555  : 	 * Allocate the transition table. The first entry for each
; 556  : 	 * state corresponds to the state type.
; 557  : 	 */
; 558  : 	transdata = NULL;
; 559  : 
; 560  : 	for (i = 0;i < ret->nbStates;i++) {

	mov	eax, DWORD PTR _stateRemap$1$[ebp]
$LN17@xmlRegEpxF:
	mov	ecx, DWORD PTR _i$5$[ebp]
	inc	ecx
	mov	DWORD PTR _i$5$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+4]
	jge	SHORT $LN108@xmlRegEpxF
	mov	esi, DWORD PTR _transdata$1$[ebp]
	jmp	$LL19@xmlRegEpxF
$LN75@xmlRegEpxF:

; 597  : 			ret->determinist = 0;
; 598  : #ifdef DEBUG_COMPACTION
; 599  : 			printf("Indet: state %d trans %d, atom %d to %d : %d to %d\n",
; 600  : 			       i, j, trans->atom->no, trans->to, atomno, targetno);
; 601  : 			printf("       previous to is %d\n", prev);
; 602  : #endif
; 603  : 			if (transdata != NULL)

	mov	eax, DWORD PTR _transdata$1$[ebp]
	mov	DWORD PTR [edi+28], 0
	test	eax, eax
	je	SHORT $LN55@xmlRegEpxF

; 604  : 			    xmlFree(transdata);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN55@xmlRegEpxF:

; 605  : 			xmlFree(transitions);

	push	DWORD PTR _transitions$1$[ebp]
	call	DWORD PTR _xmlFree

; 606  : 			xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]
	call	DWORD PTR _xmlFree

; 607  : 			xmlFree(stringRemap);

	push	DWORD PTR _stringRemap$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	xor	esi, esi

; 608  : 			for (i = 0;i < nbatoms;i++)

	test	ebx, ebx
	jle	SHORT $LN24@xmlRegEpxF
	mov	edi, DWORD PTR _stringMap$1$[ebp]
$LL25@xmlRegEpxF:

; 609  : 			    xmlFree(stringMap[i]);

	push	DWORD PTR [edi+esi*4]
	call	DWORD PTR _xmlFree
	inc	esi
	add	esp, 4
	cmp	esi, ebx
	jl	SHORT $LL25@xmlRegEpxF
	mov	edi, DWORD PTR _ret$1$[ebp]
$LN24@xmlRegEpxF:

; 610  : 			xmlFree(stringMap);

	push	DWORD PTR _stringMap$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 611  : 			goto not_determ;

	jmp	$LN114@xmlRegEpxF
$LN108@xmlRegEpxF:

; 622  : 			    trans->atom->data;
; 623  : 		}
; 624  : 	    }
; 625  : 	}
; 626  : 	ret->determinist = 1;
; 627  : #ifdef DEBUG_COMPACTION
; 628  : 	/*
; 629  : 	 * Debug
; 630  : 	 */
; 631  : 	for (i = 0;i < nbstates;i++) {
; 632  : 	    for (j = 0;j < nbatoms + 1;j++) {
; 633  :                 printf("%02d ", transitions[i * (nbatoms + 1) + j]);
; 634  : 	    }
; 635  : 	    printf("\n");
; 636  : 	}
; 637  : 	printf("\n");
; 638  : #endif
; 639  : 	/*
; 640  : 	 * Cleanup of the old data
; 641  : 	 */
; 642  : 	if (ret->states != NULL) {

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+28], 1
	test	eax, eax
	je	SHORT $LN57@xmlRegEpxF

; 643  : 	    for (i = 0;i < ret->nbStates;i++)

	xor	esi, esi
	cmp	DWORD PTR [edi+4], esi
	jle	SHORT $LN27@xmlRegEpxF
	npad	1
$LL28@xmlRegEpxF:

; 644  : 		xmlRegFreeState(ret->states[i]);

	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [eax+esi*4]
	call	_xmlRegFreeState
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL28@xmlRegEpxF

; 518  : 		    stringMap[nbatoms] = xmlStrdup(value);

	mov	eax, DWORD PTR [edi+8]
$LN27@xmlRegEpxF:

; 645  : 	    xmlFree(ret->states);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN57@xmlRegEpxF:

; 646  : 	}
; 647  : 	ret->states = NULL;
; 648  : 	ret->nbStates = 0;
; 649  : 	if (ret->atoms != NULL) {

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+4], 0
	test	eax, eax
	je	SHORT $LN58@xmlRegEpxF

; 650  : 	    for (i = 0;i < ret->nbAtoms;i++)

	xor	esi, esi
	cmp	DWORD PTR [edi+12], esi
	jle	SHORT $LN30@xmlRegEpxF
	npad	3
$LL31@xmlRegEpxF:

; 651  : 		xmlRegFreeAtom(ret->atoms[i]);

	mov	eax, DWORD PTR [edi+16]
	push	DWORD PTR [eax+esi*4]
	call	_xmlRegFreeAtom
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [edi+12]
	jl	SHORT $LL31@xmlRegEpxF

; 518  : 		    stringMap[nbatoms] = xmlStrdup(value);

	mov	eax, DWORD PTR [edi+16]
$LN30@xmlRegEpxF:

; 652  : 	    xmlFree(ret->atoms);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN58@xmlRegEpxF:

; 653  : 	}
; 654  : 	ret->atoms = NULL;
; 655  : 	ret->nbAtoms = 0;
; 656  : 
; 657  : 	ret->compact = transitions;

	mov	eax, DWORD PTR _transitions$1$[ebp]

; 658  : 	ret->transdata = transdata;
; 659  : 	ret->stringMap = stringMap;
; 660  : 	ret->nbstrings = nbatoms;
; 661  : 	ret->nbstates = nbstates;
; 662  : 	xmlFree(stateRemap);

	push	DWORD PTR _stateRemap$1$[ebp]
	mov	DWORD PTR [edi+40], eax
	mov	eax, DWORD PTR _transdata$1$[ebp]
	mov	DWORD PTR [edi+44], eax
	mov	eax, DWORD PTR _stringMap$1$[ebp]
	mov	DWORD PTR [edi+52], eax
	mov	eax, DWORD PTR _nbstates$1$[ebp]
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+48], ebx
	mov	DWORD PTR [edi+36], eax
	call	DWORD PTR _xmlFree

; 663  : 	xmlFree(stringRemap);

	push	DWORD PTR _stringRemap$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN114@xmlRegEpxF:

; 664  :     }
; 665  : not_determ:
; 666  :     ctxt->string = NULL;

	mov	esi, DWORD PTR _ctxt$[ebp]
$not_determ$118:
	pop	ebx
	mov	DWORD PTR [esi], 0

; 667  :     ctxt->nbStates = 0;
; 668  :     ctxt->states = NULL;
; 669  :     ctxt->nbAtoms = 0;
; 670  :     ctxt->atoms = NULL;
; 671  :     ctxt->nbCounters = 0;
; 672  :     ctxt->counters = NULL;
; 673  :     return(ret);

	mov	eax, edi
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0
	pop	esi
	pop	edi

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegEpxFromParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAComputesDeterminism
_TEXT	SEGMENT
tv695 = -28						; size = 4
_statenr$2$ = -28					; size = 4
tv697 = -24						; size = 4
_statenr$1$ = -24					; size = 4
tv668 = -20						; size = 4
_state$2$ = -20						; size = 4
_transnr$2$ = -16					; size = 4
_transnr$1$ = -16					; size = 4
_ret$1$ = -12						; size = 4
tv696 = -8						; size = 4
_last$1$ = -8						; size = 4
tv666 = -4						; size = 4
_state$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFAComputesDeterminism PROC				; COMDAT

; 2647 : xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 1
	mov	eax, DWORD PTR [ebx+68]
	cmp	eax, -1
	jne	$LN1@xmlFACompu

; 2648 :     int statenr, transnr;
; 2649 :     xmlRegStatePtr state;
; 2650 :     xmlRegTransPtr t1, t2, last;
; 2651 :     int i;
; 2652 :     int ret = 1;
; 2653 :     int deep = 1;
; 2654 : 
; 2655 : #ifdef DEBUG_REGEXP_GRAPH
; 2656 :     printf("xmlFAComputesDeterminism\n");
; 2657 :     xmlRegPrintCtxt(stdout, ctxt);
; 2658 : #endif
; 2659 :     if (ctxt->determinist != -1)
; 2660 : 	return(ctxt->determinist);
; 2661 : 
; 2662 :     if (ctxt->flags & AM_AUTOMATA_RNG)
; 2663 :         deep = 0;
; 2664 : 
; 2665 :     /*
; 2666 :      * First cleanup the automata removing cancelled transitions
; 2667 :      */
; 2668 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	eax, DWORD PTR [ebx+76]
	xor	ecx, ecx
	and	eax, 1
	mov	DWORD PTR _statenr$1$[ebp], ecx
	mov	DWORD PTR tv695[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	push	esi
	push	edi
	test	eax, eax
	jle	$LN3@xmlFACompu
$LL4@xmlFACompu:

; 2669 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _state$1$[ebp], ecx

; 2670 : 	if (state == NULL)

	test	ecx, ecx
	je	$LN2@xmlFACompu

; 2671 : 	    continue;
; 2672 : 	if (state->nbTrans < 2)

	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, 2
	jl	$LN2@xmlFACompu

; 2673 : 	    continue;
; 2674 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	xor	edx, edx
	mov	DWORD PTR _transnr$1$[ebp], edx
	test	eax, eax
	jle	$LN2@xmlFACompu
	xor	eax, eax
	mov	DWORD PTR tv668[ebp], eax
$LL7@xmlFACompu:

; 2675 : 	    t1 = &(state->trans[transnr]);

	mov	edi, DWORD PTR [ecx+28]
	add	edi, eax

; 2676 : 	    /*
; 2677 : 	     * Determinism checks in case of counted or all transitions
; 2678 : 	     * will have to be handled separately
; 2679 : 	     */
; 2680 : 	    if (t1->atom == NULL) {

	cmp	DWORD PTR [edi], 0
	je	$LN5@xmlFACompu

; 2681 : 		/* t1->nd = 1; */
; 2682 : 		continue;
; 2683 : 	    }
; 2684 : 	    if (t1->to == -1) /* eliminated */

	cmp	DWORD PTR [edi+4], -1
	je	$LN5@xmlFACompu

; 2685 : 		continue;
; 2686 : 	    for (i = 0;i < transnr;i++) {

	test	edx, edx
	jle	$LN5@xmlFACompu
	xor	ebx, ebx
	mov	DWORD PTR tv696[ebp], edx
$LL10@xmlFACompu:

; 2687 : 		t2 = &(state->trans[i]);

	mov	esi, DWORD PTR [ecx+28]
	add	esi, ebx

; 2688 : 		if (t2->to == -1) /* eliminated */

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	$LN8@xmlFACompu

; 2689 : 		    continue;
; 2690 : 		if (t2->atom != NULL) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN93@xmlFACompu

; 2691 : 		    if (t1->to == t2->to) {

	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN93@xmlFACompu

; 2692 :                         /*
; 2693 :                          * Here we use deep because we want to keep the
; 2694 :                          * transitions which indicate a conflict
; 2695 :                          */
; 2696 : 			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
; 2697 :                             (t1->counter == t2->counter) &&

	mov	eax, DWORD PTR [edi]

; 2459 :     if (atom1 == atom2)

	cmp	eax, ecx
	je	SHORT $LN81@xmlFACompu

; 2460 : 	return(1);
; 2461 :     if ((atom1 == NULL) || (atom2 == NULL))

	test	eax, eax
	je	SHORT $LN93@xmlFACompu

; 2462 : 	return(0);
; 2463 : 
; 2464 :     if (atom1->type != atom2->type)

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN87@xmlFACompu

; 2465 :         return(0);
; 2466 :     switch (atom1->type) {

	dec	edx
	cmp	edx, 4
	ja	SHORT $LN87@xmlFACompu
	jmp	DWORD PTR $LN98@xmlFACompu[edx*4]
$LN50@xmlFACompu:

; 2467 :         case XML_REGEXP_EPSILON:
; 2468 : 	    ret = 0;
; 2469 : 	    break;
; 2470 :         case XML_REGEXP_STRING:
; 2471 :             if (!deep)

	cmp	DWORD PTR tv695[ebp], 0
	je	SHORT $LN51@xmlFACompu

; 2472 :                 ret = (atom1->valuep == atom2->valuep);

	mov	eax, DWORD PTR [eax+20]
	xor	edx, edx
	cmp	eax, DWORD PTR [ecx+20]
	jmp	SHORT $LN95@xmlFACompu
$LN51@xmlFACompu:

; 2473 :             else
; 2474 :                 ret = xmlStrEqual((xmlChar *)atom1->valuep,

	push	DWORD PTR [ecx+20]
	push	DWORD PTR [eax+20]
	call	_xmlStrEqual
	add	esp, 8
	mov	edx, eax

; 2475 :                                   (xmlChar *)atom2->valuep);
; 2476 : 	    break;

	jmp	SHORT $LN55@xmlFACompu
$LN53@xmlFACompu:

; 2477 :         case XML_REGEXP_CHARVAL:
; 2478 : 	    ret = (atom1->codepoint == atom2->codepoint);

	mov	eax, DWORD PTR [eax+32]
	xor	edx, edx
	cmp	eax, DWORD PTR [ecx+32]
$LN95@xmlFACompu:

; 2692 :                         /*
; 2693 :                          * Here we use deep because we want to keep the
; 2694 :                          * transitions which indicate a conflict
; 2695 :                          */
; 2696 : 			if (xmlFAEqualAtoms(t1->atom, t2->atom, deep) &&
; 2697 :                             (t1->counter == t2->counter) &&

	sete	dl
$LN55@xmlFACompu:
	test	edx, edx
	mov	edx, DWORD PTR tv696[ebp]
	je	SHORT $LN93@xmlFACompu
$LN81@xmlFACompu:
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN93@xmlFACompu
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR _state$1$[ebp]
	cmp	eax, DWORD PTR [esi+12]
	jne	SHORT $LN8@xmlFACompu

; 2698 :                             (t1->count == t2->count))
; 2699 : 			    t2->to = -1; /* eliminated */

	mov	DWORD PTR [esi+4], -1

; 2464 :     if (atom1->type != atom2->type)

	jmp	SHORT $LN8@xmlFACompu
$LN87@xmlFACompu:

; 2685 : 		continue;
; 2686 : 	    for (i = 0;i < transnr;i++) {

	mov	edx, DWORD PTR tv696[ebp]
$LN93@xmlFACompu:
	mov	ecx, DWORD PTR _state$1$[ebp]
$LN8@xmlFACompu:
	add	ebx, 20					; 00000014H
	sub	edx, 1
	mov	DWORD PTR tv696[ebp], edx
	jne	$LL10@xmlFACompu
	mov	edx, DWORD PTR _transnr$1$[ebp]
	mov	eax, DWORD PTR tv668[ebp]
$LN5@xmlFACompu:

; 2673 : 	    continue;
; 2674 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	inc	edx
	add	eax, 20					; 00000014H
	mov	DWORD PTR _transnr$1$[ebp], edx
	mov	DWORD PTR tv668[ebp], eax
	cmp	edx, DWORD PTR [ecx+24]
	jl	$LL7@xmlFACompu
	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN2@xmlFACompu:

; 2648 :     int statenr, transnr;
; 2649 :     xmlRegStatePtr state;
; 2650 :     xmlRegTransPtr t1, t2, last;
; 2651 :     int i;
; 2652 :     int ret = 1;
; 2653 :     int deep = 1;
; 2654 : 
; 2655 : #ifdef DEBUG_REGEXP_GRAPH
; 2656 :     printf("xmlFAComputesDeterminism\n");
; 2657 :     xmlRegPrintCtxt(stdout, ctxt);
; 2658 : #endif
; 2659 :     if (ctxt->determinist != -1)
; 2660 : 	return(ctxt->determinist);
; 2661 : 
; 2662 :     if (ctxt->flags & AM_AUTOMATA_RNG)
; 2663 :         deep = 0;
; 2664 : 
; 2665 :     /*
; 2666 :      * First cleanup the automata removing cancelled transitions
; 2667 :      */
; 2668 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	ecx, DWORD PTR _statenr$1$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	inc	ecx
	mov	DWORD PTR _statenr$1$[ebp], ecx
	cmp	ecx, eax
	jl	$LL4@xmlFACompu
$LN3@xmlFACompu:

; 2700 : 		    }
; 2701 : 		}
; 2702 : 	    }
; 2703 : 	}
; 2704 :     }
; 2705 : 
; 2706 :     /*
; 2707 :      * Check for all states that there aren't 2 transitions
; 2708 :      * with the same atom and a different target.
; 2709 :      */
; 2710 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	xor	edx, edx
	mov	DWORD PTR _statenr$2$[ebp], edx
	test	eax, eax
	jle	$LN12@xmlFACompu
$LL13@xmlFACompu:

; 2711 : 	state = ctxt->states[statenr];

	mov	eax, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _state$2$[ebp], edx

; 2712 : 	if (state == NULL)

	test	edx, edx
	je	$LN11@xmlFACompu

; 2713 : 	    continue;
; 2714 : 	if (state->nbTrans < 2)

	mov	ecx, DWORD PTR [edx+24]
	cmp	ecx, 2
	jl	$LN11@xmlFACompu

; 2715 : 	    continue;
; 2716 : 	last = NULL;

	xor	eax, eax

; 2717 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	xor	edi, edi
	mov	DWORD PTR _last$1$[ebp], eax
	mov	DWORD PTR _transnr$2$[ebp], edi
	test	ecx, ecx
	jle	$LN11@xmlFACompu
	xor	ecx, ecx
	mov	DWORD PTR tv666[ebp], ecx
	npad	7
$LL16@xmlFACompu:

; 2718 : 	    t1 = &(state->trans[transnr]);

	mov	esi, DWORD PTR [edx+28]
	add	esi, ecx

; 2719 : 	    /*
; 2720 : 	     * Determinism checks in case of counted or all transitions
; 2721 : 	     * will have to be handled separately
; 2722 : 	     */
; 2723 : 	    if (t1->atom == NULL) {

	cmp	DWORD PTR [esi], 0
	je	$LN14@xmlFACompu

; 2724 : 		continue;
; 2725 : 	    }
; 2726 : 	    if (t1->to == -1) /* eliminated */

	cmp	DWORD PTR [esi+4], -1
	je	$LN14@xmlFACompu

; 2727 : 		continue;
; 2728 : 	    for (i = 0;i < transnr;i++) {

	test	edi, edi
	jle	$LN14@xmlFACompu
	xor	ebx, ebx
	mov	DWORD PTR tv697[ebp], edi
$LL19@xmlFACompu:

; 2729 : 		t2 = &(state->trans[i]);

	mov	edi, DWORD PTR [edx+28]

; 2730 : 		if (t2->to == -1) /* eliminated */

	mov	edx, DWORD PTR [edi+ebx+4]
	cmp	edx, -1
	je	SHORT $LN17@xmlFACompu

; 2731 : 		    continue;
; 2732 : 		if (t2->atom != NULL) {

	mov	eax, DWORD PTR [edi+ebx]
	test	eax, eax
	je	SHORT $LN35@xmlFACompu

; 2733 :                     /*
; 2734 :                      * But here we don't use deep because we want to
; 2735 :                      * find transitions which indicate a conflict
; 2736 :                      */
; 2737 : 		    if (xmlFACompareAtoms(t1->atom, t2->atom, 1)) {

	push	1
	push	eax
	push	DWORD PTR [esi]
	call	_xmlFACompareAtoms
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN84@xmlFACompu

; 2738 : 			ret = 0;
; 2739 : 			/* mark the transitions as non-deterministic ones */
; 2740 : 			t1->nd = 1;
; 2741 : 			t2->nd = 1;
; 2742 : 			last = t1;

	mov	eax, esi
	mov	DWORD PTR [esi+16], 1
	mov	DWORD PTR _ret$1$[ebp], 0
	mov	DWORD PTR [edi+ebx+16], 1
	mov	DWORD PTR _last$1$[ebp], eax

; 2743 : 		    }

	jmp	SHORT $LN17@xmlFACompu
$LN35@xmlFACompu:

; 2744 : 		} else if (t1->to != -1) {

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, -1
	je	SHORT $LN84@xmlFACompu

; 2745 : 		    /*
; 2746 : 		     * do the closure in case of remaining specific
; 2747 : 		     * epsilon transitions like choices or all
; 2748 : 		     */
; 2749 : 		    ret = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],

	push	0
	push	edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlFARecurseDeterminism
	mov	ecx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$1$[ebp], ecx

; 2750 : 						   t2->to, t2->atom);
; 2751 : 		    /* don't shortcut the computation so all non deterministic
; 2752 : 		       transition get marked down
; 2753 : 		    if (ret == 0)
; 2754 : 			return(0);
; 2755 : 		     */
; 2756 : 		    if (ret == 0) {

	test	ecx, ecx
	jne	SHORT $LN84@xmlFACompu

; 2757 : 			t1->nd = 1;
; 2758 : 			/* t2->nd = 1; */
; 2759 : 			last = t1;

	mov	eax, esi
	mov	DWORD PTR [esi+16], 1
	mov	DWORD PTR _last$1$[ebp], eax
	jmp	SHORT $LN17@xmlFACompu
$LN84@xmlFACompu:

; 2727 : 		continue;
; 2728 : 	    for (i = 0;i < transnr;i++) {

	mov	eax, DWORD PTR _last$1$[ebp]
$LN17@xmlFACompu:
	mov	edx, DWORD PTR _state$2$[ebp]
	add	ebx, 20					; 00000014H
	sub	DWORD PTR tv697[ebp], 1
	jne	$LL19@xmlFACompu
	mov	edi, DWORD PTR _transnr$2$[ebp]
	mov	ecx, DWORD PTR tv666[ebp]
$LN14@xmlFACompu:

; 2717 : 	for (transnr = 0;transnr < state->nbTrans;transnr++) {

	inc	edi
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _transnr$2$[ebp], edi
	mov	DWORD PTR tv666[ebp], ecx
	cmp	edi, DWORD PTR [edx+24]
	jl	$LL16@xmlFACompu

; 2760 : 		    }
; 2761 : 		}
; 2762 : 	    }
; 2763 : 	    /* don't shortcut the computation so all non deterministic
; 2764 : 	       transition get marked down
; 2765 : 	    if (ret == 0)
; 2766 : 		break; */
; 2767 : 	}
; 2768 : 
; 2769 : 	/*
; 2770 : 	 * mark specifically the last non-deterministic transition
; 2771 : 	 * from a state since there is no need to set-up rollback
; 2772 : 	 * from it
; 2773 : 	 */
; 2774 : 	if (last != NULL) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlFACompu

; 2775 : 	    last->nd = 2;

	mov	DWORD PTR [eax+16], 2
$LN11@xmlFACompu:

; 2700 : 		    }
; 2701 : 		}
; 2702 : 	    }
; 2703 : 	}
; 2704 :     }
; 2705 : 
; 2706 :     /*
; 2707 :      * Check for all states that there aren't 2 transitions
; 2708 :      * with the same atom and a different target.
; 2709 :      */
; 2710 :     for (statenr = 0;statenr < ctxt->nbStates;statenr++) {

	mov	edx, DWORD PTR _statenr$2$[ebp]
	inc	edx
	mov	DWORD PTR _statenr$2$[ebp], edx
	cmp	edx, DWORD PTR [ebx+48]
	jl	$LL13@xmlFACompu
$LN12@xmlFACompu:

; 2776 : 	}
; 2777 : 
; 2778 : 	/* don't shortcut the computation so all non deterministic
; 2779 : 	   transition get marked down
; 2780 : 	if (ret == 0)
; 2781 : 	    break; */
; 2782 :     }
; 2783 : 
; 2784 :     ctxt->determinist = ret;

	mov	eax, DWORD PTR _ret$1$[ebp]

; 2785 :     return(ret);

	pop	edi
	mov	DWORD PTR [ebx+68], eax
	pop	esi
$LN1@xmlFACompu:
	pop	ebx

; 2786 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN98@xmlFACompu:
	DD	$LN87@xmlFACompu
	DD	$LN53@xmlFACompu
	DD	$LN87@xmlFACompu
	DD	$LN87@xmlFACompu
	DD	$LN50@xmlFACompu
_xmlFAComputesDeterminism ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpErrCompile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRegexpErrCompile PROC				; COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@xmlRegexpE

; 400  :     const char *regexp = NULL;
; 401  :     int idx = 0;
; 402  : 
; 403  :     if (ctxt != NULL) {
; 404  :         regexp = (const char *) ctxt->string;

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]

; 405  : 	idx = ctxt->cur - ctxt->string;

	sub	ecx, edx

; 406  : 	ctxt->error = XML_REGEXP_COMPILE_ERROR;

	mov	DWORD PTR [eax+8], 1450			; 000005aaH
$LN2@xmlRegexpE:

; 407  :     }
; 408  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@CFFLONMP@failed?5to?5compile?3?5?$CFs?6@
	push	0
	push	ecx
	push	0
	push	edx
	push	eax
	push	0
	push	0
	push	3
	push	1450					; 000005aaH
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 409  : 		    XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL, NULL, 0, extra,
; 410  : 		    regexp, NULL, idx, 0,
; 411  : 		    "failed to compile: %s\n", extra);
; 412  : }

	pop	ebp
	ret	0
_xmlRegexpErrCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlRegexpErrMemory PROC				; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@xmlRegexpE

; 380  :     const char *regexp = NULL;
; 381  :     if (ctxt != NULL) {
; 382  :         regexp = (const char *) ctxt->string;
; 383  : 	ctxt->error = XML_ERR_NO_MEMORY;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+8], 2
$LN2@xmlRegexpE:

; 384  :     }
; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	14					; 0000000eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 386  : 		    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 387  : 		    regexp, NULL, 0, 0,
; 388  : 		    "Memory allocation failed : %s\n", extra);
; 389  : }

	pop	ebp
	ret	0
_xmlRegexpErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataSetFlags
_TEXT	SEGMENT
_am$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlAutomataSetFlags PROC				; COMDAT

; 5661 : xmlAutomataSetFlags(xmlAutomataPtr am, int flags) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _am$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlAutomat

; 5662 :     if (am == NULL)
; 5663 : 	return;
; 5664 :     am->flags |= flags;

	mov	eax, DWORD PTR _flags$[ebp]
	or	DWORD PTR [ecx+76], eax
$LN1@xmlAutomat:

; 5665 : }

	pop	ebp
	ret	0
_xmlAutomataSetFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCheckCharacterRange
_TEXT	SEGMENT
_type$ = 8						; size = 4
_codepoint$ = 12					; size = 4
_neg$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_blockName$ = 28					; size = 4
_xmlRegCheckCharacterRange PROC				; COMDAT

; 2796 : 	                  int start, int end, const xmlChar *blockName) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _type$[ebp]
	xor	ecx, ecx
	dec	eax
	cmp	eax, 135				; 00000087H
	ja	$LN117@xmlRegChec

; 2797 :     int ret = 0;
; 2798 : 
; 2799 :     switch (type) {

	movzx	eax, BYTE PTR $LN111@xmlRegChec[eax]
	jmp	DWORD PTR $LN122@xmlRegChec[eax*4]
$LN4@xmlRegChec:

; 2800 :         case XML_REGEXP_STRING:
; 2801 :         case XML_REGEXP_SUBREG:
; 2802 :         case XML_REGEXP_RANGES:
; 2803 :         case XML_REGEXP_EPSILON:
; 2804 : 	    return(-1);

	or	eax, -1
	pop	esi

; 2967 : }

	pop	ebp
	ret	0
$LN5@xmlRegChec:

; 2805 :         case XML_REGEXP_ANYCHAR:
; 2806 : 	    ret = ((codepoint != '\n') && (codepoint != '\r'));

	mov	eax, DWORD PTR _codepoint$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN58@xmlRegChec
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN58@xmlRegChec
$LN62@xmlRegChec:

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	mov	ecx, 1
	jmp	$LN117@xmlRegChec
$LN6@xmlRegChec:

; 2807 : 	    break;
; 2808 :         case XML_REGEXP_CHARVAL:
; 2809 : 	    ret = ((codepoint >= start) && (codepoint <= end));

	mov	eax, DWORD PTR _codepoint$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jl	SHORT $LN58@xmlRegChec
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN58@xmlRegChec
	mov	ecx, 1
	jmp	$LN117@xmlRegChec
$LN7@xmlRegChec:

; 2810 : 	    break;
; 2811 :         case XML_REGEXP_NOTSPACE:
; 2812 : 	    neg = !neg;

	xor	eax, eax
	cmp	DWORD PTR _neg$[ebp], eax
	sete	al
	mov	DWORD PTR _neg$[ebp], eax
$LN112@xmlRegChec:

; 2813 :             /* Falls through. */
; 2814 :         case XML_REGEXP_ANYSPACE:
; 2815 : 	    ret = ((codepoint == '\n') || (codepoint == '\r') ||

	mov	eax, DWORD PTR _codepoint$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN62@xmlRegChec
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN62@xmlRegChec
	cmp	eax, 9
	je	SHORT $LN62@xmlRegChec
	cmp	eax, 32					; 00000020H
	je	SHORT $LN62@xmlRegChec
$LN58@xmlRegChec:

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	xor	ecx, ecx
	jmp	$LN117@xmlRegChec
$LN9@xmlRegChec:

; 2816 : 		   (codepoint == '\t') || (codepoint == ' '));
; 2817 : 	    break;
; 2818 :         case XML_REGEXP_NOTINITNAME:
; 2819 : 	    neg = !neg;

	xor	eax, eax
	cmp	DWORD PTR _neg$[ebp], eax
	sete	al
	mov	DWORD PTR _neg$[ebp], eax
$LN113@xmlRegChec:

; 2820 :             /* Falls through. */
; 2821 :         case XML_REGEXP_INITNAME:
; 2822 : 	    ret = (IS_LETTER(codepoint) ||

	mov	esi, DWORD PTR _codepoint$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN70@xmlRegChec
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN64@xmlRegChec
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN62@xmlRegChec
$LN64@xmlRegChec:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN65@xmlRegChec
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN62@xmlRegChec
$LN65@xmlRegChec:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN67@xmlRegChec
	cmp	esi, 214				; 000000d6H
	jle	$LN62@xmlRegChec
$LN67@xmlRegChec:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN68@xmlRegChec
	cmp	esi, 246				; 000000f6H
	jle	$LN62@xmlRegChec
$LN68@xmlRegChec:
	cmp	esi, 248				; 000000f8H
	jge	$LN62@xmlRegChec
	jmp	SHORT $LN104@xmlRegChec
$LN70@xmlRegChec:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN62@xmlRegChec
$LN104@xmlRegChec:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN108@xmlRegChec
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN72@xmlRegChec
	cmp	esi, 40869				; 00009fa5H
	jle	$LN62@xmlRegChec
$LN72@xmlRegChec:
	cmp	esi, 12295				; 00003007H
	je	$LN62@xmlRegChec
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN108@xmlRegChec
	cmp	esi, 12329				; 00003029H
	jle	$LN62@xmlRegChec
$LN108@xmlRegChec:
	cmp	esi, 95					; 0000005fH
	je	$LN62@xmlRegChec
	cmp	esi, 58					; 0000003aH
	je	$LN62@xmlRegChec
	xor	ecx, ecx
	jmp	$LN117@xmlRegChec
$LN11@xmlRegChec:

; 2823 : 		   (codepoint == '_') || (codepoint == ':'));
; 2824 : 	    break;
; 2825 :         case XML_REGEXP_NOTNAMECHAR:
; 2826 : 	    neg = !neg;

	xor	eax, eax
	cmp	DWORD PTR _neg$[ebp], eax
	sete	al
	mov	DWORD PTR _neg$[ebp], eax
$LN114@xmlRegChec:

; 2827 :             /* Falls through. */
; 2828 :         case XML_REGEXP_NAMECHAR:
; 2829 : 	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||

	mov	esi, DWORD PTR _codepoint$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN86@xmlRegChec
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN80@xmlRegChec
	cmp	esi, 90					; 0000005aH
	jle	$LN62@xmlRegChec
$LN80@xmlRegChec:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN81@xmlRegChec
	cmp	esi, 122				; 0000007aH
	jle	$LN62@xmlRegChec
$LN81@xmlRegChec:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN83@xmlRegChec
	cmp	esi, 214				; 000000d6H
	jle	$LN62@xmlRegChec
$LN83@xmlRegChec:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN84@xmlRegChec
	cmp	esi, 246				; 000000f6H
	jle	$LN62@xmlRegChec
$LN84@xmlRegChec:
	cmp	esi, 248				; 000000f8H
	jge	$LN62@xmlRegChec
	jmp	SHORT $LN105@xmlRegChec
$LN86@xmlRegChec:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN62@xmlRegChec
$LN105@xmlRegChec:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN119@xmlRegChec
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN88@xmlRegChec
	cmp	esi, 40869				; 00009fa5H
	jle	$LN62@xmlRegChec
$LN88@xmlRegChec:
	cmp	esi, 12295				; 00003007H
	je	$LN62@xmlRegChec
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN109@xmlRegChec
	cmp	esi, 12329				; 00003029H
	jle	$LN62@xmlRegChec
$LN109@xmlRegChec:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN97@xmlRegChec
$LN119@xmlRegChec:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN106@xmlRegChec

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	mov	ecx, 1
	jmp	$LN117@xmlRegChec
$LN97@xmlRegChec:

; 2827 :             /* Falls through. */
; 2828 :         case XML_REGEXP_NAMECHAR:
; 2829 : 	    ret = (IS_LETTER(codepoint) || IS_DIGIT(codepoint) ||

	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN62@xmlRegChec
$LN106@xmlRegChec:
	cmp	esi, 46					; 0000002eH
	je	$LN62@xmlRegChec
	cmp	esi, 45					; 0000002dH
	je	$LN62@xmlRegChec
	cmp	esi, 95					; 0000005fH
	je	$LN62@xmlRegChec
	cmp	esi, 58					; 0000003aH
	je	$LN62@xmlRegChec
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN110@xmlRegChec
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN62@xmlRegChec
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN102@xmlRegChec
$LN110@xmlRegChec:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN102@xmlRegChec:
	test	eax, eax
	jne	$LN62@xmlRegChec
	xor	ecx, ecx
	jmp	$LN117@xmlRegChec
$LN13@xmlRegChec:

; 2830 : 		   (codepoint == '.') || (codepoint == '-') ||
; 2831 : 		   (codepoint == '_') || (codepoint == ':') ||
; 2832 : 		   IS_COMBINING(codepoint) || IS_EXTENDER(codepoint));
; 2833 : 	    break;
; 2834 :         case XML_REGEXP_NOTDECIMAL:
; 2835 : 	    neg = !neg;

	xor	eax, eax
	cmp	DWORD PTR _neg$[ebp], eax
	sete	al
	mov	DWORD PTR _neg$[ebp], eax
$LN115@xmlRegChec:

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatNd
	add	esp, 4
	jmp	$LN120@xmlRegChec
$LN15@xmlRegChec:

; 2836 :             /* Falls through. */
; 2837 :         case XML_REGEXP_DECIMAL:
; 2838 : 	    ret = xmlUCSIsCatNd(codepoint);
; 2839 : 	    break;
; 2840 :         case XML_REGEXP_REALCHAR:
; 2841 : 	    neg = !neg;

	xor	eax, eax
	cmp	DWORD PTR _neg$[ebp], eax
	sete	al
	mov	DWORD PTR _neg$[ebp], eax
$LN116@xmlRegChec:

; 2842 :             /* Falls through. */
; 2843 :         case XML_REGEXP_NOTREALCHAR:
; 2844 : 	    ret = xmlUCSIsCatP(codepoint);

	mov	esi, DWORD PTR _codepoint$[ebp]
	push	esi
	call	_xmlUCSIsCatP
	mov	ecx, eax
	add	esp, 4

; 2845 : 	    if (ret == 0)

	test	ecx, ecx
	jne	$LN117@xmlRegChec

; 2846 : 		ret = xmlUCSIsCatZ(codepoint);

	push	esi
	call	_xmlUCSIsCatZ
	mov	ecx, eax
	add	esp, 4

; 2847 : 	    if (ret == 0)

	test	ecx, ecx
	jne	$LN117@xmlRegChec

; 2848 : 		ret = xmlUCSIsCatC(codepoint);

	push	esi
	call	_xmlUCSIsCatC
	add	esp, 4

; 2849 : 	    break;

	jmp	$LN120@xmlRegChec
$LN19@xmlRegChec:

; 2850 :         case XML_REGEXP_LETTER:
; 2851 : 	    ret = xmlUCSIsCatL(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatL
	add	esp, 4

; 2852 : 	    break;

	jmp	$LN120@xmlRegChec
$LN20@xmlRegChec:

; 2853 :         case XML_REGEXP_LETTER_UPPERCASE:
; 2854 : 	    ret = xmlUCSIsCatLu(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatLu
	add	esp, 4

; 2855 : 	    break;

	jmp	$LN120@xmlRegChec
$LN21@xmlRegChec:

; 2856 :         case XML_REGEXP_LETTER_LOWERCASE:
; 2857 : 	    ret = xmlUCSIsCatLl(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatLl
	add	esp, 4

; 2858 : 	    break;

	jmp	$LN120@xmlRegChec
$LN22@xmlRegChec:

; 2859 :         case XML_REGEXP_LETTER_TITLECASE:
; 2860 : 	    ret = xmlUCSIsCatLt(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatLt
	add	esp, 4

; 2861 : 	    break;

	jmp	$LN120@xmlRegChec
$LN23@xmlRegChec:

; 2862 :         case XML_REGEXP_LETTER_MODIFIER:
; 2863 : 	    ret = xmlUCSIsCatLm(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatLm
	add	esp, 4

; 2864 : 	    break;

	jmp	$LN120@xmlRegChec
$LN24@xmlRegChec:

; 2865 :         case XML_REGEXP_LETTER_OTHERS:
; 2866 : 	    ret = xmlUCSIsCatLo(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatLo
	add	esp, 4

; 2867 : 	    break;

	jmp	$LN120@xmlRegChec
$LN25@xmlRegChec:

; 2868 :         case XML_REGEXP_MARK:
; 2869 : 	    ret = xmlUCSIsCatM(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatM
	add	esp, 4

; 2870 : 	    break;

	jmp	$LN120@xmlRegChec
$LN26@xmlRegChec:

; 2871 :         case XML_REGEXP_MARK_NONSPACING:
; 2872 : 	    ret = xmlUCSIsCatMn(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatMn
	add	esp, 4

; 2873 : 	    break;

	jmp	$LN120@xmlRegChec
$LN27@xmlRegChec:

; 2874 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 2875 : 	    ret = xmlUCSIsCatMc(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatMc
	add	esp, 4

; 2876 : 	    break;

	jmp	$LN120@xmlRegChec
$LN28@xmlRegChec:

; 2877 :         case XML_REGEXP_MARK_ENCLOSING:
; 2878 : 	    ret = xmlUCSIsCatMe(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatMe
	add	esp, 4

; 2879 : 	    break;

	jmp	$LN120@xmlRegChec
$LN29@xmlRegChec:

; 2880 :         case XML_REGEXP_NUMBER:
; 2881 : 	    ret = xmlUCSIsCatN(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatN
	add	esp, 4

; 2882 : 	    break;

	jmp	$LN120@xmlRegChec
$LN31@xmlRegChec:

; 2883 :         case XML_REGEXP_NUMBER_DECIMAL:
; 2884 : 	    ret = xmlUCSIsCatNd(codepoint);
; 2885 : 	    break;
; 2886 :         case XML_REGEXP_NUMBER_LETTER:
; 2887 : 	    ret = xmlUCSIsCatNl(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatNl
	add	esp, 4

; 2888 : 	    break;

	jmp	$LN120@xmlRegChec
$LN32@xmlRegChec:

; 2889 :         case XML_REGEXP_NUMBER_OTHERS:
; 2890 : 	    ret = xmlUCSIsCatNo(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatNo
	add	esp, 4

; 2891 : 	    break;

	jmp	$LN120@xmlRegChec
$LN33@xmlRegChec:

; 2892 :         case XML_REGEXP_PUNCT:
; 2893 : 	    ret = xmlUCSIsCatP(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatP
	add	esp, 4

; 2894 : 	    break;

	jmp	$LN120@xmlRegChec
$LN34@xmlRegChec:

; 2895 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 2896 : 	    ret = xmlUCSIsCatPc(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPc
	add	esp, 4

; 2897 : 	    break;

	jmp	$LN120@xmlRegChec
$LN35@xmlRegChec:

; 2898 :         case XML_REGEXP_PUNCT_DASH:
; 2899 : 	    ret = xmlUCSIsCatPd(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPd
	add	esp, 4

; 2900 : 	    break;

	jmp	$LN120@xmlRegChec
$LN36@xmlRegChec:

; 2901 :         case XML_REGEXP_PUNCT_OPEN:
; 2902 : 	    ret = xmlUCSIsCatPs(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPs
	add	esp, 4

; 2903 : 	    break;

	jmp	$LN120@xmlRegChec
$LN37@xmlRegChec:

; 2904 :         case XML_REGEXP_PUNCT_CLOSE:
; 2905 : 	    ret = xmlUCSIsCatPe(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPe
	add	esp, 4

; 2906 : 	    break;

	jmp	$LN120@xmlRegChec
$LN38@xmlRegChec:

; 2907 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 2908 : 	    ret = xmlUCSIsCatPi(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPi
	add	esp, 4

; 2909 : 	    break;

	jmp	$LN120@xmlRegChec
$LN39@xmlRegChec:

; 2910 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 2911 : 	    ret = xmlUCSIsCatPf(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPf
	add	esp, 4

; 2912 : 	    break;

	jmp	$LN120@xmlRegChec
$LN40@xmlRegChec:

; 2913 :         case XML_REGEXP_PUNCT_OTHERS:
; 2914 : 	    ret = xmlUCSIsCatPo(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatPo
	add	esp, 4

; 2915 : 	    break;

	jmp	$LN120@xmlRegChec
$LN41@xmlRegChec:

; 2916 :         case XML_REGEXP_SEPAR:
; 2917 : 	    ret = xmlUCSIsCatZ(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatZ
	add	esp, 4

; 2918 : 	    break;

	jmp	$LN120@xmlRegChec
$LN42@xmlRegChec:

; 2919 :         case XML_REGEXP_SEPAR_SPACE:
; 2920 : 	    ret = xmlUCSIsCatZs(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatZs
	add	esp, 4

; 2921 : 	    break;

	jmp	$LN120@xmlRegChec
$LN43@xmlRegChec:

; 2922 :         case XML_REGEXP_SEPAR_LINE:
; 2923 : 	    ret = xmlUCSIsCatZl(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatZl
	add	esp, 4

; 2924 : 	    break;

	jmp	$LN120@xmlRegChec
$LN44@xmlRegChec:

; 2925 :         case XML_REGEXP_SEPAR_PARA:
; 2926 : 	    ret = xmlUCSIsCatZp(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatZp
	add	esp, 4

; 2927 : 	    break;

	jmp	$LN120@xmlRegChec
$LN45@xmlRegChec:

; 2928 :         case XML_REGEXP_SYMBOL:
; 2929 : 	    ret = xmlUCSIsCatS(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatS
	add	esp, 4

; 2930 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN46@xmlRegChec:

; 2931 :         case XML_REGEXP_SYMBOL_MATH:
; 2932 : 	    ret = xmlUCSIsCatSm(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatSm
	add	esp, 4

; 2933 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN47@xmlRegChec:

; 2934 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 2935 : 	    ret = xmlUCSIsCatSc(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatSc
	add	esp, 4

; 2936 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN48@xmlRegChec:

; 2937 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 2938 : 	    ret = xmlUCSIsCatSk(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatSk
	add	esp, 4

; 2939 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN49@xmlRegChec:

; 2940 :         case XML_REGEXP_SYMBOL_OTHERS:
; 2941 : 	    ret = xmlUCSIsCatSo(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatSo
	add	esp, 4

; 2942 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN50@xmlRegChec:

; 2943 :         case XML_REGEXP_OTHER:
; 2944 : 	    ret = xmlUCSIsCatC(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatC
	add	esp, 4

; 2945 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN51@xmlRegChec:

; 2946 :         case XML_REGEXP_OTHER_CONTROL:
; 2947 : 	    ret = xmlUCSIsCatCc(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatCc
	add	esp, 4

; 2948 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN52@xmlRegChec:

; 2949 :         case XML_REGEXP_OTHER_FORMAT:
; 2950 : 	    ret = xmlUCSIsCatCf(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatCf
	add	esp, 4

; 2951 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN53@xmlRegChec:

; 2952 :         case XML_REGEXP_OTHER_PRIVATE:
; 2953 : 	    ret = xmlUCSIsCatCo(codepoint);

	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsCatCo
	add	esp, 4

; 2954 : 	    break;

	jmp	SHORT $LN120@xmlRegChec
$LN55@xmlRegChec:

; 2955 :         case XML_REGEXP_OTHER_NA:
; 2956 : 	    /* ret = xmlUCSIsCatCn(codepoint); */
; 2957 : 	    /* Seems it doesn't exist anymore in recent Unicode releases */
; 2958 : 	    ret = 0;
; 2959 : 	    break;
; 2960 :         case XML_REGEXP_BLOCK_NAME:
; 2961 : 	    ret = xmlUCSIsBlock(codepoint, (const char *) blockName);

	push	DWORD PTR _blockName$[ebp]
	push	DWORD PTR _codepoint$[ebp]
	call	_xmlUCSIsBlock
	add	esp, 8
$LN120@xmlRegChec:

; 2962 : 	    break;
; 2963 :     }
; 2964 :     if (neg)

	mov	ecx, eax
$LN117@xmlRegChec:
	cmp	DWORD PTR _neg$[ebp], 0
	je	SHORT $LN56@xmlRegChec

; 2965 : 	return(!ret);

	xor	eax, eax
	test	ecx, ecx
	pop	esi
	sete	al

; 2967 : }

	pop	ebp
	ret	0
$LN56@xmlRegChec:

; 2966 :     return(ret);

	mov	eax, ecx
	pop	esi

; 2967 : }

	pop	ebp
	ret	0
	npad	2
$LN122@xmlRegChec:
	DD	$LN4@xmlRegChec
	DD	$LN6@xmlRegChec
	DD	$LN5@xmlRegChec
	DD	$LN112@xmlRegChec
	DD	$LN7@xmlRegChec
	DD	$LN113@xmlRegChec
	DD	$LN9@xmlRegChec
	DD	$LN114@xmlRegChec
	DD	$LN11@xmlRegChec
	DD	$LN115@xmlRegChec
	DD	$LN13@xmlRegChec
	DD	$LN15@xmlRegChec
	DD	$LN116@xmlRegChec
	DD	$LN19@xmlRegChec
	DD	$LN20@xmlRegChec
	DD	$LN21@xmlRegChec
	DD	$LN22@xmlRegChec
	DD	$LN23@xmlRegChec
	DD	$LN24@xmlRegChec
	DD	$LN25@xmlRegChec
	DD	$LN26@xmlRegChec
	DD	$LN27@xmlRegChec
	DD	$LN28@xmlRegChec
	DD	$LN29@xmlRegChec
	DD	$LN31@xmlRegChec
	DD	$LN32@xmlRegChec
	DD	$LN33@xmlRegChec
	DD	$LN34@xmlRegChec
	DD	$LN35@xmlRegChec
	DD	$LN36@xmlRegChec
	DD	$LN37@xmlRegChec
	DD	$LN38@xmlRegChec
	DD	$LN39@xmlRegChec
	DD	$LN40@xmlRegChec
	DD	$LN41@xmlRegChec
	DD	$LN42@xmlRegChec
	DD	$LN43@xmlRegChec
	DD	$LN44@xmlRegChec
	DD	$LN45@xmlRegChec
	DD	$LN46@xmlRegChec
	DD	$LN47@xmlRegChec
	DD	$LN48@xmlRegChec
	DD	$LN49@xmlRegChec
	DD	$LN50@xmlRegChec
	DD	$LN51@xmlRegChec
	DD	$LN52@xmlRegChec
	DD	$LN53@xmlRegChec
	DD	$LN58@xmlRegChec
	DD	$LN55@xmlRegChec
	DD	$LN117@xmlRegChec
$LN111@xmlRegChec:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	9
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
_xmlRegCheckCharacterRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegCheckCharacter
_TEXT	SEGMENT
tv485 = -4						; size = 4
_atom$ = 8						; size = 4
_codepoint$ = 12					; size = 4
_xmlRegCheckCharacter PROC				; COMDAT

; 2970 : xmlRegCheckCharacter(xmlRegAtomPtr atom, int codepoint) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _codepoint$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _atom$[ebp]
	xor	edx, edx
	test	ecx, ecx
	je	$LN8@xmlRegChec

; 2971 :     int i, ret = 0;
; 2972 :     xmlRegRangePtr range;
; 2973 : 
; 2974 :     if ((atom == NULL) || (!IS_CHAR(codepoint)))

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN32@xmlRegChec
	cmp	ebx, 9
	jl	SHORT $LN24@xmlRegChec
	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN39@xmlRegChec
$LN24@xmlRegChec:
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN39@xmlRegChec
	cmp	ebx, 32					; 00000020H
	jge	SHORT $LN39@xmlRegChec

; 3070 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlRegChec:

; 2971 :     int i, ret = 0;
; 2972 :     xmlRegRangePtr range;
; 2973 : 
; 2974 :     if ((atom == NULL) || (!IS_CHAR(codepoint)))

	cmp	ebx, 55295				; 0000d7ffH
	jle	SHORT $LN39@xmlRegChec
	cmp	ebx, 57344				; 0000e000H
	jl	SHORT $LN27@xmlRegChec
	cmp	ebx, 65533				; 0000fffdH
	jle	SHORT $LN39@xmlRegChec
$LN27@xmlRegChec:
	lea	eax, DWORD PTR [ebx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	$LN8@xmlRegChec
$LN39@xmlRegChec:

; 2975 : 	return(-1);
; 2976 : 
; 2977 :     switch (atom->type) {

	mov	esi, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 135				; 00000087H
	ja	$LN22@xmlRegChec
	movzx	eax, BYTE PTR $LN41@xmlRegChec[eax]
	jmp	DWORD PTR $LN44@xmlRegChec[eax*4]
$LN10@xmlRegChec:

; 2978 :         case XML_REGEXP_SUBREG:
; 2979 :         case XML_REGEXP_EPSILON:
; 2980 : 	    return(-1);
; 2981 :         case XML_REGEXP_CHARVAL:
; 2982 :             return(codepoint == atom->codepoint);

	xor	eax, eax
	cmp	ebx, DWORD PTR [ecx+32]
	pop	esi
	sete	al

; 3070 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlRegChec:
	push	edi

; 2983 :         case XML_REGEXP_RANGES: {
; 2984 : 	    int accept = 0;

	xor	esi, esi

; 2985 : 
; 2986 : 	    for (i = 0;i < atom->nbRanges;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ecx+52], edx
	jle	SHORT $LN40@xmlRegChec
$LL6@xmlRegChec:

; 2987 : 		range = atom->ranges[i];

	mov	eax, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax+edi*4]

; 2988 : 		if (range->neg == 2) {

	push	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+12]
	mov	DWORD PTR tv485[ebp], ecx
	push	DWORD PTR [eax+8]
	push	0
	push	ebx
	push	DWORD PTR [eax+4]
	call	_xmlRegCheckCharacterRange
	mov	ecx, DWORD PTR tv485[ebp]
	add	esp, 24					; 00000018H
	cmp	ecx, 2
	jne	SHORT $LN12@xmlRegChec

; 2989 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
; 2990 : 						0, range->start, range->end,
; 2991 : 						range->blockName);
; 2992 : 		    if (ret != 0)

	test	eax, eax
	je	SHORT $LN4@xmlRegChec
$LN17@xmlRegChec:
	pop	edi
	pop	esi

; 3000 : 		    else
; 3001 : 		        return(0);

	xor	eax, eax

; 3070 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlRegChec:

; 2993 : 			return(0); /* excluded char */
; 2994 : 		} else if (range->neg) {

	test	ecx, ecx
	je	SHORT $LN15@xmlRegChec

; 2995 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
; 2996 : 						0, range->start, range->end,
; 2997 : 						range->blockName);
; 2998 : 		    if (ret == 0)

	test	eax, eax
	jne	SHORT $LN17@xmlRegChec

; 2999 : 		        accept = 1;

	lea	esi, DWORD PTR [eax+1]

; 3002 : 		} else {

	jmp	SHORT $LN4@xmlRegChec
$LN15@xmlRegChec:

; 3003 : 		    ret = xmlRegCheckCharacterRange(range->type, codepoint,
; 3004 : 						0, range->start, range->end,
; 3005 : 						range->blockName);
; 3006 : 		    if (ret != 0)

	test	eax, eax
	mov	eax, 1
	cmovne	esi, eax
$LN4@xmlRegChec:

; 2985 : 
; 2986 : 	    for (i = 0;i < atom->nbRanges;i++) {

	mov	ecx, DWORD PTR _atom$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [ecx+52]
	jl	SHORT $LL6@xmlRegChec
$LN40@xmlRegChec:
	pop	edi

; 3007 : 			accept = 1; /* might still be excluded */
; 3008 : 		}
; 3009 : 	    }
; 3010 : 	    return(accept);

	mov	eax, esi
	pop	esi

; 3070 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlRegChec:

; 3011 : 	}
; 3012 :         case XML_REGEXP_STRING:
; 3013 : 	    printf("TODO: XML_REGEXP_STRING\n");

	push	OFFSET ??_C@_0BJ@POCEJEIB@TODO?3?5XML_REGEXP_STRING?6@
	call	_printf
	add	esp, 4
$LN8@xmlRegChec:

; 3070 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlRegChec:

; 3014 : 	    return(-1);
; 3015 :         case XML_REGEXP_ANYCHAR:
; 3016 :         case XML_REGEXP_ANYSPACE:
; 3017 :         case XML_REGEXP_NOTSPACE:
; 3018 :         case XML_REGEXP_INITNAME:
; 3019 :         case XML_REGEXP_NOTINITNAME:
; 3020 :         case XML_REGEXP_NAMECHAR:
; 3021 :         case XML_REGEXP_NOTNAMECHAR:
; 3022 :         case XML_REGEXP_DECIMAL:
; 3023 :         case XML_REGEXP_NOTDECIMAL:
; 3024 :         case XML_REGEXP_REALCHAR:
; 3025 :         case XML_REGEXP_NOTREALCHAR:
; 3026 :         case XML_REGEXP_LETTER:
; 3027 :         case XML_REGEXP_LETTER_UPPERCASE:
; 3028 :         case XML_REGEXP_LETTER_LOWERCASE:
; 3029 :         case XML_REGEXP_LETTER_TITLECASE:
; 3030 :         case XML_REGEXP_LETTER_MODIFIER:
; 3031 :         case XML_REGEXP_LETTER_OTHERS:
; 3032 :         case XML_REGEXP_MARK:
; 3033 :         case XML_REGEXP_MARK_NONSPACING:
; 3034 :         case XML_REGEXP_MARK_SPACECOMBINING:
; 3035 :         case XML_REGEXP_MARK_ENCLOSING:
; 3036 :         case XML_REGEXP_NUMBER:
; 3037 :         case XML_REGEXP_NUMBER_DECIMAL:
; 3038 :         case XML_REGEXP_NUMBER_LETTER:
; 3039 :         case XML_REGEXP_NUMBER_OTHERS:
; 3040 :         case XML_REGEXP_PUNCT:
; 3041 :         case XML_REGEXP_PUNCT_CONNECTOR:
; 3042 :         case XML_REGEXP_PUNCT_DASH:
; 3043 :         case XML_REGEXP_PUNCT_OPEN:
; 3044 :         case XML_REGEXP_PUNCT_CLOSE:
; 3045 :         case XML_REGEXP_PUNCT_INITQUOTE:
; 3046 :         case XML_REGEXP_PUNCT_FINQUOTE:
; 3047 :         case XML_REGEXP_PUNCT_OTHERS:
; 3048 :         case XML_REGEXP_SEPAR:
; 3049 :         case XML_REGEXP_SEPAR_SPACE:
; 3050 :         case XML_REGEXP_SEPAR_LINE:
; 3051 :         case XML_REGEXP_SEPAR_PARA:
; 3052 :         case XML_REGEXP_SYMBOL:
; 3053 :         case XML_REGEXP_SYMBOL_MATH:
; 3054 :         case XML_REGEXP_SYMBOL_CURRENCY:
; 3055 :         case XML_REGEXP_SYMBOL_MODIFIER:
; 3056 :         case XML_REGEXP_SYMBOL_OTHERS:
; 3057 :         case XML_REGEXP_OTHER:
; 3058 :         case XML_REGEXP_OTHER_CONTROL:
; 3059 :         case XML_REGEXP_OTHER_FORMAT:
; 3060 :         case XML_REGEXP_OTHER_PRIVATE:
; 3061 :         case XML_REGEXP_OTHER_NA:
; 3062 : 	case XML_REGEXP_BLOCK_NAME:
; 3063 : 	    ret = xmlRegCheckCharacterRange(atom->type, codepoint, 0, 0, 0,

	push	DWORD PTR [ecx+20]
	push	0
	push	0
	push	0
	push	ebx
	push	esi
	call	_xmlRegCheckCharacterRange

; 3064 : 		                            (const xmlChar *)atom->valuep);
; 3065 : 	    if (atom->neg)

	mov	ecx, DWORD PTR _atom$[ebp]
	add	esp, 24					; 00000018H
	mov	edx, eax
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN22@xmlRegChec

; 3066 : 		ret = !ret;

	xor	ecx, ecx
	test	edx, edx
	sete	cl
	mov	edx, ecx
$LN22@xmlRegChec:

; 3067 : 	    break;
; 3068 :     }
; 3069 :     return(ret);

	pop	esi
	mov	eax, edx

; 3070 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN44@xmlRegChec:
	DD	$LN8@xmlRegChec
	DD	$LN10@xmlRegChec
	DD	$LN11@xmlRegChec
	DD	$LN20@xmlRegChec
	DD	$LN21@xmlRegChec
	DD	$LN22@xmlRegChec
$LN41@xmlRegChec:
	DB	0
	DB	1
	DB	2
	DB	0
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
_xmlRegCheckCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegStrEqualWildcard
_TEXT	SEGMENT
_expStr$ = 8						; size = 4
_valStr$ = 12						; size = 4
_xmlRegStrEqualWildcard PROC				; COMDAT

; 3651 : xmlRegStrEqualWildcard(const xmlChar *expStr, const xmlChar *valStr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _expStr$[ebp]
	mov	eax, DWORD PTR _valStr$[ebp]
	cmp	esi, eax
	je	SHORT $LN16@xmlRegStrE

; 3652 :     if (expStr == valStr) return(1);
; 3653 :     if (expStr == NULL) return(0);

	test	esi, esi
	je	SHORT $LN31@xmlRegStrE

; 3654 :     if (valStr == NULL) return(0);

	test	eax, eax
	je	SHORT $LN31@xmlRegStrE
	mov	bl, BYTE PTR [eax]
$LL4@xmlRegStrE:

; 3655 :     do {
; 3656 : 	/*
; 3657 : 	* Eval if we have a wildcard for the current item.
; 3658 : 	*/
; 3659 :         if (*expStr != *valStr) {

	mov	cl, BYTE PTR [esi]
	cmp	cl, bl
	je	SHORT $LN14@xmlRegStrE

; 3660 : 	    /* if one of them starts with a wildcard make valStr be it */
; 3661 : 	    if (*valStr == '*') {
; 3662 : 	        const xmlChar *tmp;
; 3663 : 
; 3664 : 		tmp = valStr;
; 3665 : 		valStr = expStr;
; 3666 : 		expStr = tmp;
; 3667 : 	    }
; 3668 : 	    if ((*valStr != 0) && (*expStr != 0) && (*expStr++ == '*')) {

	cmp	bl, 42					; 0000002aH
	movzx	edx, cl
	movzx	ecx, bl
	mov	edi, eax
	cmovne	edx, ecx
	cmovne	edi, esi
	test	dl, dl
	je	SHORT $LN31@xmlRegStrE
	mov	cl, BYTE PTR [edi]
	test	cl, cl
	je	SHORT $LN31@xmlRegStrE
	cmp	cl, 42					; 0000002aH
	jne	SHORT $LN31@xmlRegStrE
	cmp	bl, cl
	cmovne	esi, eax
	mov	eax, esi
$LL7@xmlRegStrE:

; 3669 : 		do {
; 3670 : 		    if (*valStr == XML_REG_STRING_SEPARATOR)

	cmp	dl, 124					; 0000007cH
	je	SHORT $LN2@xmlRegStrE

; 3671 : 			break;
; 3672 : 		    valStr++;
; 3673 : 		} while (*valStr != 0);

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	mov	dl, cl
	test	cl, cl
	jne	SHORT $LL7@xmlRegStrE

; 3674 : 		continue;

	jmp	SHORT $LN2@xmlRegStrE
$LN14@xmlRegStrE:

; 3675 : 	    } else
; 3676 : 		return(0);
; 3677 : 	}
; 3678 : 	expStr++;
; 3679 : 	valStr++;

	inc	eax
	mov	edi, esi
$LN2@xmlRegStrE:

; 3680 :     } while (*valStr != 0);

	mov	bl, BYTE PTR [eax]
	lea	esi, DWORD PTR [edi+1]
	test	bl, bl
	jne	SHORT $LL4@xmlRegStrE

; 3681 :     if (*expStr != 0)

	cmp	BYTE PTR [esi], bl
	je	SHORT $LN16@xmlRegStrE
$LN31@xmlRegStrE:
	pop	edi

; 3682 : 	return (0);
; 3683 :     else
; 3684 : 	return (1);
; 3685 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlRegStrE:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlRegStrEqualWildcard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeAtom
_TEXT	SEGMENT
_atom$ = 8						; size = 4
_xmlRegFreeAtom PROC					; COMDAT

; 810  : xmlRegFreeAtom(xmlRegAtomPtr atom) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _atom$[ebp]
	test	esi, esi
	je	$LN1@xmlRegFree

; 811  :     int i;
; 812  : 
; 813  :     if (atom == NULL)
; 814  : 	return;
; 815  : 
; 816  :     for (i = 0;i < atom->nbRanges;i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+52], edi
	jle	SHORT $LN3@xmlRegFree
	push	ebx
$LL4@xmlRegFree:

; 817  : 	xmlRegFreeRange(atom->ranges[i]);

	mov	eax, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi*4]

; 739  :     if (range == NULL)

	test	ebx, ebx
	je	SHORT $LN2@xmlRegFree

; 740  : 	return;
; 741  : 
; 742  :     if (range->blockName != NULL)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN13@xmlRegFree

; 743  : 	xmlFree(range->blockName);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlRegFree:

; 744  :     xmlFree(range);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRegFree:

; 811  :     int i;
; 812  : 
; 813  :     if (atom == NULL)
; 814  : 	return;
; 815  : 
; 816  :     for (i = 0;i < atom->nbRanges;i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+52]
	jl	SHORT $LL4@xmlRegFree
	pop	ebx
$LN3@xmlRegFree:

; 818  :     if (atom->ranges != NULL)

	mov	eax, DWORD PTR [esi+56]
	pop	edi
	test	eax, eax
	je	SHORT $LN6@xmlRegFree

; 819  : 	xmlFree(atom->ranges);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlRegFree:

; 820  :     if ((atom->type == XML_REGEXP_STRING) && (atom->valuep != NULL))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 5
	jne	SHORT $LN8@xmlRegFree
	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN7@xmlRegFree

; 821  : 	xmlFree(atom->valuep);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN7@xmlRegFree:

; 822  :     if ((atom->type == XML_REGEXP_STRING) && (atom->valuep2 != NULL))

	cmp	eax, 5
	jne	SHORT $LN8@xmlRegFree
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN9@xmlRegFree

; 823  : 	xmlFree(atom->valuep2);

	push	eax
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN8@xmlRegFree:

; 824  :     if ((atom->type == XML_REGEXP_BLOCK_NAME) && (atom->valuep != NULL))

	cmp	eax, 136				; 00000088H
	jne	SHORT $LN9@xmlRegFree
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN9@xmlRegFree

; 825  : 	xmlFree(atom->valuep);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRegFree:

; 826  :     xmlFree(atom);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRegFree:
	pop	esi

; 827  : }

	pop	ebp
	ret	0
_xmlRegFreeAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_xmlRegFreeState PROC					; COMDAT

; 897  : xmlRegFreeState(xmlRegStatePtr state) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _state$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlRegFree

; 898  :     if (state == NULL)
; 899  : 	return;
; 900  : 
; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN3@xmlRegFree

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlRegFree:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN4@xmlRegFree

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlRegFree:

; 905  :     xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRegFree:
	pop	esi

; 906  : }

	pop	ebp
	ret	0
_xmlRegFreeState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFAParseRegExp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_top$ = 12						; size = 4
_xmlFAParseRegExp PROC					; COMDAT

; 5378 : xmlFAParseRegExp(xmlRegParserCtxtPtr ctxt, int top) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	0
	push	esi
	mov	ebx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+20], 0
	call	_xmlFAParseBranch
	add	esp, 8
	cmp	DWORD PTR _top$[ebp], 0
	je	SHORT $LN4@xmlFAParse

; 5379 :     xmlRegStatePtr start, end;
; 5380 : 
; 5381 :     /* if not top start should have been generated by an epsilon trans */
; 5382 :     start = ctxt->state;
; 5383 :     ctxt->end = NULL;
; 5384 :     xmlFAParseBranch(ctxt, NULL);
; 5385 :     if (top) {
; 5386 : #ifdef DEBUG_REGEXP_GRAPH
; 5387 : 	printf("State %d is final\n", ctxt->state->no);
; 5388 : #endif
; 5389 : 	ctxt->state->type = XML_REGEXP_FINAL_STATE;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax], 2
$LN4@xmlFAParse:

; 5390 :     }
; 5391 :     if (CUR != '|') {

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+24]
	cmp	BYTE PTR [eax], 124			; 0000007cH
	jne	SHORT $LN15@xmlFAParse
$LL2@xmlFAParse:

; 5392 : 	ctxt->end = ctxt->state;
; 5393 : 	return;
; 5394 :     }
; 5395 :     end = ctxt->state;
; 5396 :     while ((CUR == '|') && (ctxt->error == 0)) {

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN3@xmlFAParse

; 5397 : 	NEXT;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 5398 : 	if (CUR == 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN10@xmlFAParse

; 5400 : 	    return;
; 5401 : 	}
; 5402 : 	ctxt->state = start;
; 5403 : 	ctxt->end = NULL;
; 5404 : 	xmlFAParseBranch(ctxt, end);

	push	edi
	push	esi
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], 0
	call	_xmlFAParseBranch
	mov	eax, DWORD PTR [esi+4]
	add	esp, 8
	cmp	BYTE PTR [eax], 124			; 0000007cH
	je	SHORT $LL2@xmlFAParse
$LN3@xmlFAParse:

; 5405 :     }
; 5406 :     if (!top) {

	cmp	DWORD PTR _top$[ebp], 0
	jne	SHORT $LN7@xmlFAParse

; 5407 : 	ctxt->state = end;

	mov	DWORD PTR [esi+24], edi
$LN15@xmlFAParse:

; 5408 : 	ctxt->end = end;
; 5409 :     }
; 5410 : }

	mov	DWORD PTR [esi+20], edi
$LN7@xmlFAParse:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlFAParse:

; 5399 : 	    ERROR("expecting a branch after |")

	push	OFFSET ??_C@_0BL@KAIMKABF@expecting?5a?5branch?5after?5?$HM@
	push	esi
	mov	DWORD PTR [esi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
	pop	edi

; 5408 : 	ctxt->end = end;
; 5409 :     }
; 5410 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlFAParseRegExp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataIsDeterminist
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlAutomataIsDeterminist PROC				; COMDAT

; 6322 : xmlAutomataIsDeterminist(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _am$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlAutomat

; 6323 :     int ret;
; 6324 : 
; 6325 :     if (am == NULL)
; 6326 : 	return(-1);

	or	eax, -1

; 6329 :     return(ret);
; 6330 : }

	pop	ebp
	ret	0
$LN2@xmlAutomat:

; 6327 : 
; 6328 :     ret = xmlFAComputesDeterminism(am);

	mov	DWORD PTR _am$[ebp], eax

; 6329 :     return(ret);
; 6330 : }

	pop	ebp

; 6327 : 
; 6328 :     ret = xmlFAComputesDeterminism(am);

	jmp	_xmlFAComputesDeterminism
_xmlAutomataIsDeterminist ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataCompile
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlAutomataCompile PROC				; COMDAT

; 6302 : xmlAutomataCompile(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6303 :     xmlRegexpPtr ret;
; 6304 : 
; 6305 :     if ((am == NULL) || (am->error != 0)) return(NULL);

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN3@xmlAutomat

; 6306 :     xmlFAEliminateEpsilonTransitions(am);

	push	esi
	call	_xmlFAEliminateEpsilonTransitions

; 6307 :     /* xmlFAComputesDeterminism(am); */
; 6308 :     ret = xmlRegEpxFromParse(am);

	push	esi
	call	_xmlRegEpxFromParse
	add	esp, 8
	pop	esi

; 6309 : 
; 6310 :     return(ret);
; 6311 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 6303 :     xmlRegexpPtr ret;
; 6304 : 
; 6305 :     if ((am == NULL) || (am->error != 0)) return(NULL);

	xor	eax, eax
	pop	esi

; 6309 : 
; 6310 :     return(ret);
; 6311 : }

	pop	ebp
	ret	0
_xmlAutomataCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCounter
_TEXT	SEGMENT
_am$ = 8						; size = 4
_min$ = 12						; size = 4
_max$ = 16						; size = 4
_xmlAutomataNewCounter PROC				; COMDAT

; 6230 : xmlAutomataNewCounter(xmlAutomataPtr am, int min, int max) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlAutomat

; 6231 :     int ret;
; 6232 : 
; 6233 :     if (am == NULL)
; 6234 : 	return(-1);
; 6235 : 
; 6236 :     ret = xmlRegGetCounter(am);

	push	esi
	call	_xmlRegGetCounter
	mov	edi, eax
	add	esp, 4

; 6237 :     if (ret < 0)

	test	edi, edi
	js	SHORT $LN5@xmlAutomat

; 6239 :     am->counters[ret].min = min;

	mov	edx, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR _min$[ebp]

; 6240 :     am->counters[ret].max = max;

	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx+edi*8], ecx
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx+edi*8+4], eax

; 6241 :     return(ret);

	mov	eax, edi
	pop	edi

; 6242 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlAutomat:
	pop	edi

; 6238 : 	return(-1);

	or	eax, -1

; 6242 : }

	pop	esi
	pop	ebp
	ret	0
_xmlAutomataNewCounter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCounterTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlAutomataNewCounterTrans PROC			; COMDAT

; 6283 : 		xmlAutomataStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6284 :     if ((am == NULL) || (from == NULL) || (counter < 0))

	mov	eax, DWORD PTR _from$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlAutomat
	mov	ecx, DWORD PTR _counter$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@xmlAutomat

; 6286 :     xmlFAGenerateCountedTransition(am, from, to, counter);

	push	edi
	mov	edi, DWORD PTR _to$[ebp]
	push	ecx
	push	edi
	push	eax
	push	esi
	call	_xmlFAGenerateCountedTransition
	add	esp, 16					; 00000010H

; 6287 :     if (to == NULL)

	test	edi, edi
	jne	SHORT $LN4@xmlAutomat

; 6288 : 	return(am->state);

	mov	eax, DWORD PTR [esi+24]
	pop	edi
	pop	esi

; 6290 : }

	pop	ebp
	ret	0
$LN4@xmlAutomat:

; 6289 :     return(to);

	mov	eax, edi
	pop	edi
	pop	esi

; 6290 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 6285 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6290 : }

	pop	ebp
	ret	0
_xmlAutomataNewCounterTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountedTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_counter$ = 20						; size = 4
_xmlAutomataNewCountedTrans PROC			; COMDAT

; 6259 : 		xmlAutomataStatePtr to, int counter) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6260 :     if ((am == NULL) || (from == NULL) || (counter < 0))

	mov	eax, DWORD PTR _from$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlAutomat
	mov	ecx, DWORD PTR _counter$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@xmlAutomat

; 6262 :     xmlFAGenerateCountedEpsilonTransition(am, from, to, counter);

	push	edi
	mov	edi, DWORD PTR _to$[ebp]
	push	ecx
	push	edi
	push	eax
	push	esi
	call	_xmlFAGenerateCountedEpsilonTransition
	add	esp, 16					; 00000010H

; 6263 :     if (to == NULL)

	test	edi, edi
	jne	SHORT $LN4@xmlAutomat

; 6264 : 	return(am->state);

	mov	eax, DWORD PTR [esi+24]
	pop	edi
	pop	esi

; 6266 : }

	pop	ebp
	ret	0
$LN4@xmlAutomat:

; 6265 :     return(to);

	mov	eax, edi
	pop	edi
	pop	esi

; 6266 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 6261 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6266 : }

	pop	ebp
	ret	0
_xmlAutomataNewCountedTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewEpsilon
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_xmlAutomataNewEpsilon PROC				; COMDAT

; 6185 : 		      xmlAutomataStatePtr to) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6186 :     if ((am == NULL) || (from == NULL))

	mov	eax, DWORD PTR _from$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlAutomat

; 6188 :     xmlFAGenerateEpsilonTransition(am, from, to);

	push	edi
	mov	edi, DWORD PTR _to$[ebp]
	push	edi
	push	eax
	push	esi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH

; 6189 :     if (to == NULL)

	test	edi, edi
	jne	SHORT $LN4@xmlAutomat

; 6190 : 	return(am->state);

	mov	eax, DWORD PTR [esi+24]
	pop	edi
	pop	esi

; 6192 : }

	pop	ebp
	ret	0
$LN4@xmlAutomat:

; 6191 :     return(to);

	mov	eax, edi
	pop	edi
	pop	esi

; 6192 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 6187 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6192 : }

	pop	ebp
	ret	0
_xmlAutomataNewEpsilon ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewAllTrans
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_lax$ = 20						; size = 4
_xmlAutomataNewAllTrans PROC				; COMDAT

; 6210 : 		       xmlAutomataStatePtr to, int lax) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6211 :     if ((am == NULL) || (from == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat

; 6213 :     xmlFAGenerateAllTransition(am, from, to, lax);

	push	ebx
	push	edi
	mov	edi, DWORD PTR _to$[ebp]
	mov	ebx, edi

; 1467 :     if (to == NULL) {

	test	edi, edi
	jne	SHORT $LN12@xmlAutomat

; 1468 : 	to = xmlRegNewState(ctxt);

	push	esi
	call	_xmlRegNewState
	mov	ebx, eax

; 1469 : 	xmlRegStatePush(ctxt, to);

	push	ebx
	push	esi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 1470 : 	ctxt->state = to;

	mov	DWORD PTR [esi+24], ebx
$LN12@xmlAutomat:

; 6214 :     if (to == NULL)

	xor	eax, eax
	cmp	DWORD PTR _lax$[ebp], eax
	setne	al
	add	eax, 1193046				; 00123456H
	push	eax
	push	-1
	push	ebx
	push	0
	push	DWORD PTR _from$[ebp]
	push	esi
	call	_xmlRegStateAddTrans
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN4@xmlAutomat

; 6215 : 	return(am->state);

	mov	eax, DWORD PTR [esi+24]
	pop	edi
	pop	ebx
	pop	esi

; 6217 : }

	pop	ebp
	ret	0
$LN4@xmlAutomat:

; 6216 :     return(to);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 6217 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 6212 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6217 : }

	pop	ebp
	ret	0
_xmlAutomataNewAllTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewOnceTrans2
_TEXT	SEGMENT
$T1 = -4						; size = 4
_counter$1$ = 8						; size = 4
_atom$1$ = 8						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_data$ = 36						; size = 4
_xmlAutomataNewOnceTrans2 PROC				; COMDAT

; 6037 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _am$[ebp]
	test	ebx, ebx
	je	$LN3@xmlAutomat

; 6038 :     xmlRegAtomPtr atom;
; 6039 :     int counter;
; 6040 : 
; 6041 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	mov	esi, DWORD PTR _token$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 6042 : 	return(NULL);
; 6043 :     if (min < 1)

	mov	eax, DWORD PTR _min$[ebp]
	cmp	eax, 1
	jl	SHORT $LN3@xmlAutomat

; 6044 : 	return(NULL);
; 6045 :     if ((max < min) || (max < 1))

	mov	ecx, DWORD PTR _max$[ebp]
	cmp	ecx, eax
	jl	SHORT $LN3@xmlAutomat
	cmp	ecx, 1
	jl	SHORT $LN3@xmlAutomat

; 6046 : 	return(NULL);
; 6047 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	ebx
	call	_xmlRegNewAtom
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _atom$1$[ebp], edi

; 6048 :     if (atom == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlAutomat

; 6049 : 	return(NULL);
; 6050 :     if ((token2 == NULL) || (*token2 == 0)) {

	mov	eax, DWORD PTR _token2$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlAutomat
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN10@xmlAutomat

; 6052 :     } else {
; 6053 : 	int lenn, lenp;
; 6054 : 	xmlChar *str;
; 6055 : 
; 6056 : 	lenn = strlen((char *) token2);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+1]
$LL14@xmlAutomat:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL14@xmlAutomat
	sub	edi, ecx

; 6057 : 	lenp = strlen((char *) token);

	lea	ecx, DWORD PTR [esi+1]
	npad	2
$LL15@xmlAutomat:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL15@xmlAutomat
	sub	esi, ecx

; 6058 : 
; 6059 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax

; 6060 : 	if (str == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlAutomat

; 6061 : 	    xmlRegFreeAtom(atom);

	push	DWORD PTR _atom$1$[ebp]
	call	_xmlRegFreeAtom
	add	esp, 4
$LN3@xmlAutomat:

; 6091 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlAutomat:

; 6062 : 	    return(NULL);
; 6063 : 	}
; 6064 : 	memcpy(&str[0], token, lenp);

	push	esi
	push	DWORD PTR _token$[ebp]
	push	eax
	call	_memcpy

; 6065 : 	str[lenp] = '|';

	add	esi, DWORD PTR $T1[ebp]

; 6066 : 	memcpy(&str[lenp + 1], token2, lenn);

	push	edi
	push	DWORD PTR _token2$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 124			; 0000007cH
	push	eax
	call	_memcpy

; 6067 : 	str[lenn + lenp + 1] = 0;
; 6068 : 
; 6069 : 	atom->valuep = str;

	mov	eax, DWORD PTR $T1[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR [esi+edi+1], 0
	mov	edi, DWORD PTR _atom$1$[ebp]
	jmp	SHORT $LN9@xmlAutomat
$LN10@xmlAutomat:

; 6051 : 	atom->valuep = xmlStrdup(token);

	push	esi
	call	_xmlStrdup
	add	esp, 4
$LN9@xmlAutomat:

; 6070 :     }
; 6071 :     atom->data = data;

	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi+60], eax

; 6072 :     atom->quant = XML_REGEXP_QUANT_ONCEONLY;
; 6073 :     atom->min = min;

	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edi+12], eax

; 6074 :     atom->max = max;

	mov	eax, DWORD PTR _max$[ebp]

; 6075 :     /*
; 6076 :      * associate a counter to the transition.
; 6077 :      */
; 6078 :     counter = xmlRegGetCounter(am);

	push	ebx
	mov	DWORD PTR [edi+8], 6
	mov	DWORD PTR [edi+16], eax
	call	_xmlRegGetCounter

; 6079 :     am->counters[counter].min = 1;

	mov	ecx, DWORD PTR [ebx+64]
	add	esp, 4

; 6080 :     am->counters[counter].max = 1;
; 6081 : 
; 6082 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 6083 :     if (to == NULL) {

	mov	esi, DWORD PTR _to$[ebp]
	mov	DWORD PTR _counter$1$[ebp], eax
	mov	DWORD PTR [ecx+eax*8], 1
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [ecx+eax*8+4], 1
	test	esi, esi
	jne	SHORT $LN12@xmlAutomat

; 6084 : 	to = xmlRegNewState(am);

	push	ebx
	call	_xmlRegNewState
	mov	esi, eax

; 6085 : 	xmlRegStatePush(am, to);

	push	esi
	push	ebx
	call	_xmlRegStatePush
	mov	eax, DWORD PTR _counter$1$[ebp]
	add	esp, 12					; 0000000cH
$LN12@xmlAutomat:

; 6086 :     }
; 6087 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	push	eax
	push	esi
	push	edi
	push	DWORD PTR _from$[ebp]
	push	ebx
	call	_xmlRegStateAddTrans

; 6088 :     xmlRegAtomPush(am, atom);

	push	edi
	push	ebx
	call	_xmlRegAtomPush
	add	esp, 32					; 00000020H

; 6089 :     am->state = to;

	mov	DWORD PTR [ebx+24], esi

; 6090 :     return(to);

	mov	eax, esi
	pop	edi

; 6091 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewOnceTrans2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewOnceTrans
_TEXT	SEGMENT
_counter$1$ = 8						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_min$ = 24						; size = 4
_max$ = 28						; size = 4
_data$ = 32						; size = 4
_xmlAutomataNewOnceTrans PROC				; COMDAT

; 6116 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	$LN3@xmlAutomat

; 6117 :     xmlRegAtomPtr atom;
; 6118 :     int counter;
; 6119 : 
; 6120 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	$LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	je	$LN3@xmlAutomat

; 6121 : 	return(NULL);
; 6122 :     if (min < 1)

	mov	edi, DWORD PTR _min$[ebp]
	cmp	edi, 1
	jl	$LN3@xmlAutomat

; 6123 : 	return(NULL);
; 6124 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, edi
	jl	$LN3@xmlAutomat
	cmp	eax, 1
	jl	$LN3@xmlAutomat

; 6125 : 	return(NULL);
; 6126 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	esi
	call	_xmlRegNewAtom
	mov	ebx, eax
	add	esp, 8

; 6127 :     if (atom == NULL)

	test	ebx, ebx
	je	$LN3@xmlAutomat

; 6128 : 	return(NULL);
; 6129 :     atom->valuep = xmlStrdup(token);

	push	DWORD PTR _token$[ebp]
	call	_xmlStrdup

; 6130 :     atom->data = data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ebx+20], eax

; 6131 :     atom->quant = XML_REGEXP_QUANT_ONCEONLY;
; 6132 :     atom->min = min;
; 6133 :     atom->max = max;

	mov	eax, DWORD PTR _max$[ebp]

; 6134 :     /*
; 6135 :      * associate a counter to the transition.
; 6136 :      */
; 6137 :     counter = xmlRegGetCounter(am);

	push	esi
	mov	DWORD PTR [ebx+60], ecx
	mov	DWORD PTR [ebx+8], 6
	mov	DWORD PTR [ebx+12], edi
	mov	DWORD PTR [ebx+16], eax
	call	_xmlRegGetCounter

; 6138 :     am->counters[counter].min = 1;

	mov	ecx, DWORD PTR [esi+64]
	add	esp, 8

; 6139 :     am->counters[counter].max = 1;
; 6140 : 
; 6141 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 6142 :     if (to == NULL) {

	mov	edi, DWORD PTR _to$[ebp]
	mov	DWORD PTR _counter$1$[ebp], eax
	mov	DWORD PTR [ecx+eax*8], 1
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx+eax*8+4], 1
	test	edi, edi
	jne	SHORT $LN8@xmlAutomat

; 6143 : 	to = xmlRegNewState(am);

	push	esi
	call	_xmlRegNewState
	mov	edi, eax

; 6144 : 	xmlRegStatePush(am, to);

	push	edi
	push	esi
	call	_xmlRegStatePush
	mov	eax, DWORD PTR _counter$1$[ebp]
	add	esp, 12					; 0000000cH
$LN8@xmlAutomat:

; 6145 :     }
; 6146 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	push	eax
	push	edi
	push	ebx
	push	DWORD PTR _from$[ebp]
	push	esi
	call	_xmlRegStateAddTrans

; 6147 :     xmlRegAtomPush(am, atom);

	push	ebx
	push	esi
	call	_xmlRegAtomPush
	add	esp, 32					; 00000020H

; 6148 :     am->state = to;

	mov	DWORD PTR [esi+24], edi

; 6149 :     return(to);

	mov	eax, edi
	pop	edi

; 6150 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlAutomat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlAutomataNewOnceTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountTrans2
_TEXT	SEGMENT
$T1 = -4						; size = 4
_counter$1$ = 8						; size = 4
_atom$1$ = 8						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_min$ = 28						; size = 4
_max$ = 32						; size = 4
_data$ = 36						; size = 4
_xmlAutomataNewCountTrans2 PROC				; COMDAT

; 5882 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _min$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _am$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlAutomat

; 5883 :     xmlRegAtomPtr atom;
; 5884 :     int counter;
; 5885 : 
; 5886 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN3@xmlAutomat

; 5887 : 	return(NULL);
; 5888 :     if (min < 0)

	test	esi, esi
	js	SHORT $LN3@xmlAutomat

; 5889 : 	return(NULL);
; 5890 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, esi
	jl	SHORT $LN3@xmlAutomat
	cmp	eax, 1
	jl	SHORT $LN3@xmlAutomat

; 5891 : 	return(NULL);
; 5892 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	ebx
	call	_xmlRegNewAtom
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _atom$1$[ebp], edi

; 5893 :     if (atom == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlAutomat

; 5894 : 	return(NULL);
; 5895 :     if ((token2 == NULL) || (*token2 == 0)) {

	mov	eax, DWORD PTR _token2$[ebp]
	test	eax, eax
	je	$LN10@xmlAutomat
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN10@xmlAutomat

; 5897 :     } else {
; 5898 : 	int lenn, lenp;
; 5899 : 	xmlChar *str;
; 5900 : 
; 5901 : 	lenn = strlen((char *) token2);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+1]
$LL19@xmlAutomat:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL19@xmlAutomat

; 5902 : 	lenp = strlen((char *) token);

	mov	esi, DWORD PTR _token$[ebp]
	sub	edi, ecx
	lea	ecx, DWORD PTR [esi+1]
	npad	1
$LL20@xmlAutomat:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL20@xmlAutomat
	sub	esi, ecx

; 5903 : 
; 5904 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax

; 5905 : 	if (str == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlAutomat

; 5906 : 	    xmlRegFreeAtom(atom);

	push	DWORD PTR _atom$1$[ebp]
	call	_xmlRegFreeAtom
	add	esp, 4
$LN3@xmlAutomat:

; 5946 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlAutomat:

; 5907 : 	    return(NULL);
; 5908 : 	}
; 5909 : 	memcpy(&str[0], token, lenp);

	push	esi
	push	DWORD PTR _token$[ebp]
	push	eax
	call	_memcpy

; 5910 : 	str[lenp] = '|';

	add	esi, DWORD PTR $T1[ebp]

; 5911 : 	memcpy(&str[lenp + 1], token2, lenn);

	push	edi
	push	DWORD PTR _token2$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 124			; 0000007cH
	push	eax
	call	_memcpy

; 5912 : 	str[lenn + lenp + 1] = 0;
; 5913 : 
; 5914 : 	atom->valuep = str;

	mov	eax, DWORD PTR $T1[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR [esi+edi+1], 0
	mov	edi, DWORD PTR _atom$1$[ebp]
	mov	esi, DWORD PTR _min$[ebp]
	jmp	SHORT $LN9@xmlAutomat
$LN10@xmlAutomat:

; 5896 : 	atom->valuep = xmlStrdup(token);

	push	DWORD PTR _token$[ebp]
	call	_xmlStrdup
	add	esp, 4
$LN9@xmlAutomat:

; 5915 :     }
; 5916 :     atom->data = data;

	mov	DWORD PTR [edi+20], eax

; 5917 :     if (min == 0)
; 5918 : 	atom->min = 1;
; 5919 :     else
; 5920 : 	atom->min = min;
; 5921 :     atom->max = max;

	test	esi, esi
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi+60], eax
	mov	eax, 1
	cmovne	eax, esi
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR _max$[ebp]

; 5922 : 
; 5923 :     /*
; 5924 :      * associate a counter to the transition.
; 5925 :      */
; 5926 :     counter = xmlRegGetCounter(am);

	push	ebx
	mov	DWORD PTR [edi+16], eax
	call	_xmlRegGetCounter

; 5927 :     am->counters[counter].min = min;

	mov	ecx, DWORD PTR [ebx+64]
	mov	edx, eax

; 5928 :     am->counters[counter].max = max;

	mov	eax, DWORD PTR _max$[ebp]
	add	esp, 4
	mov	DWORD PTR _counter$1$[ebp], edx
	mov	DWORD PTR [ecx+edx*8], esi
	mov	ecx, DWORD PTR [ebx+64]

; 5929 : 
; 5930 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 5931 :     if (to == NULL) {

	mov	esi, DWORD PTR _to$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax
	test	esi, esi
	jne	SHORT $LN14@xmlAutomat

; 5932 :         to = xmlRegNewState(am);

	push	ebx
	call	_xmlRegNewState
	mov	esi, eax

; 5933 : 	xmlRegStatePush(am, to);

	push	esi
	push	ebx
	call	_xmlRegStatePush
	mov	edx, DWORD PTR _counter$1$[ebp]
	add	esp, 12					; 0000000cH
$LN14@xmlAutomat:

; 5934 :     }
; 5935 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	push	edx
	push	esi
	push	edi
	push	DWORD PTR _from$[ebp]
	push	ebx
	call	_xmlRegStateAddTrans

; 5936 :     xmlRegAtomPush(am, atom);

	push	edi
	push	ebx
	call	_xmlRegAtomPush
	add	esp, 32					; 00000020H

; 5937 :     am->state = to;

	mov	DWORD PTR [ebx+24], esi

; 5938 : 
; 5939 :     if (to == NULL)
; 5940 : 	to = am->state;
; 5941 :     if (to == NULL)

	test	esi, esi
	je	$LN3@xmlAutomat

; 5942 : 	return(NULL);
; 5943 :     if (min == 0)

	cmp	DWORD PTR _min$[ebp], 0
	jne	SHORT $LN17@xmlAutomat

; 5944 : 	xmlFAGenerateEpsilonTransition(am, from, to);

	push	esi
	push	DWORD PTR _from$[ebp]
	push	ebx
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN17@xmlAutomat:

; 5945 :     return(to);

	pop	edi
	mov	eax, esi

; 5946 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewCountTrans2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewCountTrans
_TEXT	SEGMENT
_counter$1$ = -4					; size = 4
_atom$1$ = 8						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_min$ = 24						; size = 4
_max$ = 28						; size = 4
_data$ = 32						; size = 4
_xmlAutomataNewCountTrans PROC				; COMDAT

; 5968 : 			 int min, int max, void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _min$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	$LN3@xmlAutomat

; 5969 :     xmlRegAtomPtr atom;
; 5970 :     int counter;
; 5971 : 
; 5972 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	$LN3@xmlAutomat
	cmp	DWORD PTR _token$[ebp], 0
	je	$LN3@xmlAutomat

; 5973 : 	return(NULL);
; 5974 :     if (min < 0)

	test	ebx, ebx
	js	$LN3@xmlAutomat

; 5975 : 	return(NULL);
; 5976 :     if ((max < min) || (max < 1))

	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, ebx
	jl	$LN3@xmlAutomat
	cmp	eax, 1
	jl	$LN3@xmlAutomat

; 5977 : 	return(NULL);
; 5978 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	esi
	call	_xmlRegNewAtom
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _atom$1$[ebp], edi

; 5979 :     if (atom == NULL)

	test	edi, edi
	je	$LN3@xmlAutomat

; 5980 : 	return(NULL);
; 5981 :     atom->valuep = xmlStrdup(token);

	push	DWORD PTR _token$[ebp]
	call	_xmlStrdup

; 5982 :     atom->data = data;

	mov	ecx, DWORD PTR _data$[ebp]

; 5983 :     if (min == 0)
; 5984 : 	atom->min = 1;
; 5985 :     else
; 5986 : 	atom->min = min;
; 5987 :     atom->max = max;

	test	ebx, ebx
	mov	DWORD PTR [edi+20], eax
	mov	eax, 1
	cmovne	eax, ebx
	mov	DWORD PTR [edi+60], ecx
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR _max$[ebp]

; 5988 : 
; 5989 :     /*
; 5990 :      * associate a counter to the transition.
; 5991 :      */
; 5992 :     counter = xmlRegGetCounter(am);

	push	esi
	mov	DWORD PTR [edi+16], eax
	call	_xmlRegGetCounter

; 5993 :     am->counters[counter].min = min;

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, eax

; 5994 :     am->counters[counter].max = max;
; 5995 : 
; 5996 :     /* xmlFAGenerateTransitions(am, from, to, atom); */
; 5997 :     if (to == NULL) {

	mov	edi, DWORD PTR _to$[ebp]
	add	esp, 8
	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR _counter$1$[ebp], edx
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx+edx*8+4], eax
	test	edi, edi
	jne	SHORT $LN10@xmlAutomat

; 5998 :         to = xmlRegNewState(am);

	push	esi
	call	_xmlRegNewState
	mov	edi, eax

; 5999 : 	xmlRegStatePush(am, to);

	push	edi
	push	esi
	call	_xmlRegStatePush
	mov	edx, DWORD PTR _counter$1$[ebp]
	add	esp, 12					; 0000000cH
$LN10@xmlAutomat:

; 6000 :     }
; 6001 :     xmlRegStateAddTrans(am, from, atom, to, counter, -1);

	push	-1
	push	edx
	push	edi
	push	DWORD PTR _atom$1$[ebp]
	push	DWORD PTR _from$[ebp]
	push	esi
	call	_xmlRegStateAddTrans

; 6002 :     xmlRegAtomPush(am, atom);

	push	DWORD PTR _atom$1$[ebp]
	push	esi
	call	_xmlRegAtomPush
	add	esp, 32					; 00000020H

; 6003 :     am->state = to;

	mov	DWORD PTR [esi+24], edi

; 6004 : 
; 6005 :     if (to == NULL)
; 6006 : 	to = am->state;
; 6007 :     if (to == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlAutomat

; 6008 : 	return(NULL);
; 6009 :     if (min == 0)

	test	ebx, ebx
	jne	SHORT $LN13@xmlAutomat

; 6010 : 	xmlFAGenerateEpsilonTransition(am, from, to);

	push	edi
	push	DWORD PTR _from$[ebp]
	push	esi
	call	_xmlFAGenerateEpsilonTransition
	add	esp, 12					; 0000000cH
$LN13@xmlAutomat:

; 6011 :     return(to);

	mov	eax, edi
	pop	edi

; 6012 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlAutomat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewCountTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewNegTrans
_TEXT	SEGMENT
_err_msg$ = -204					; size = 200
_atom$1$ = -4						; size = 4
$T1 = 8							; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlAutomataNewNegTrans PROC				; COMDAT

; 5814 : 		       const xmlChar *token2, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _am$[ebp]
	test	ebx, ebx
	je	$LN3@xmlAutomat

; 5815 :     xmlRegAtomPtr atom;
; 5816 :     xmlChar err_msg[200];
; 5817 : 
; 5818 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	$LN3@xmlAutomat
	mov	edi, DWORD PTR _token$[ebp]
	test	edi, edi
	je	$LN3@xmlAutomat

; 5819 : 	return(NULL);
; 5820 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	ebx
	call	_xmlRegNewAtom
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR _atom$1$[ebp], esi

; 5821 :     if (atom == NULL)

	test	esi, esi
	je	$LN3@xmlAutomat

; 5822 : 	return(NULL);
; 5823 :     atom->data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [esi+60], eax

; 5824 :     atom->neg = 1;
; 5825 :     if ((token2 == NULL) || (*token2 == 0)) {

	mov	eax, DWORD PTR _token2$[ebp]
	mov	DWORD PTR [esi+28], 1
	test	eax, eax
	je	SHORT $LN7@xmlAutomat
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN7@xmlAutomat

; 5827 :     } else {
; 5828 : 	int lenn, lenp;
; 5829 : 	xmlChar *str;
; 5830 : 
; 5831 : 	lenn = strlen((char *) token2);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+1]
	npad	4
$LL13@xmlAutomat:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL13@xmlAutomat

; 5832 : 	lenp = strlen((char *) token);

	mov	esi, DWORD PTR _token$[ebp]
	sub	edi, ecx
	lea	ecx, DWORD PTR [esi+1]
	npad	1
$LL14@xmlAutomat:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL14@xmlAutomat
	sub	esi, ecx

; 5833 : 
; 5834 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax

; 5835 : 	if (str == NULL) {

	test	eax, eax
	je	$LN15@xmlAutomat

; 5836 : 	    xmlRegFreeAtom(atom);
; 5837 : 	    return(NULL);
; 5838 : 	}
; 5839 : 	memcpy(&str[0], token, lenp);

	push	esi
	push	DWORD PTR _token$[ebp]
	push	eax
	call	_memcpy

; 5840 : 	str[lenp] = '|';

	add	esi, DWORD PTR $T1[ebp]

; 5841 : 	memcpy(&str[lenp + 1], token2, lenn);

	push	edi
	push	DWORD PTR _token2$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 124			; 0000007cH
	push	eax
	call	_memcpy

; 5842 : 	str[lenn + lenp + 1] = 0;
; 5843 : 
; 5844 : 	atom->valuep = str;

	mov	eax, DWORD PTR $T1[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR [esi+edi+1], 0
	mov	esi, DWORD PTR _atom$1$[ebp]
	jmp	SHORT $LN6@xmlAutomat
$LN7@xmlAutomat:

; 5826 : 	atom->valuep = xmlStrdup(token);

	push	edi
	call	_xmlStrdup
	add	esp, 4
$LN6@xmlAutomat:

; 5845 :     }
; 5846 :     snprintf((char *) err_msg, 199, "not %s", (const char *) atom->valuep);

	push	eax
	push	OFFSET ??_C@_06NGEMONLJ@not?5?$CFs@
	mov	DWORD PTR [esi+20], eax
	lea	eax, DWORD PTR _err_msg$[ebp]
	push	199					; 000000c7H
	push	eax
	call	_snprintf

; 5847 :     err_msg[199] = 0;
; 5848 :     atom->valuep2 = xmlStrdup(err_msg);

	lea	eax, DWORD PTR _err_msg$[ebp]
	mov	BYTE PTR _err_msg$[ebp+199], 0
	push	eax
	call	_xmlStrdup

; 5849 : 
; 5850 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	edi, DWORD PTR _to$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _from$[ebp]
	mov	DWORD PTR [esi+24], eax
	push	ebx
	call	_xmlFAGenerateTransitions
	add	esp, 36					; 00000024H
	test	eax, eax
	js	SHORT $LN12@xmlAutomat

; 5852 : 	return(NULL);
; 5853 :     }
; 5854 :     am->negs++;

	inc	DWORD PTR [ebx+72]

; 5855 :     if (to == NULL)

	test	edi, edi
	jne	SHORT $LN10@xmlAutomat

; 5856 : 	return(am->state);

	mov	eax, DWORD PTR [ebx+24]
	pop	edi

; 5858 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlAutomat:

; 5835 : 	if (str == NULL) {

	mov	esi, DWORD PTR _atom$1$[ebp]
$LN12@xmlAutomat:

; 5851 :         xmlRegFreeAtom(atom);

	push	esi
	call	_xmlRegFreeAtom
	add	esp, 4
$LN3@xmlAutomat:

; 5858 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlAutomat:

; 5857 :     return(to);

	mov	eax, edi
	pop	edi

; 5858 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewNegTrans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewTransition2
_TEXT	SEGMENT
$T1 = -4						; size = 4
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_token2$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlAutomataNewTransition2 PROC				; COMDAT

; 5754 : 			  const xmlChar *token2, void *data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _am$[ebp]
	test	edi, edi
	je	$LN3@xmlAutomat

; 5755 :     xmlRegAtomPtr atom;
; 5756 : 
; 5757 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	$LN3@xmlAutomat
	mov	esi, DWORD PTR _token$[ebp]
	test	esi, esi
	je	$LN3@xmlAutomat

; 5758 : 	return(NULL);
; 5759 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	edi
	call	_xmlRegNewAtom
	mov	ebx, eax
	add	esp, 8

; 5760 :     if (atom == NULL)

	test	ebx, ebx
	je	$LN3@xmlAutomat

; 5761 : 	return(NULL);
; 5762 :     atom->data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ebx+60], eax

; 5763 :     if ((token2 == NULL) || (*token2 == 0)) {

	mov	eax, DWORD PTR _token2$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlAutomat
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN7@xmlAutomat

; 5765 :     } else {
; 5766 : 	int lenn, lenp;
; 5767 : 	xmlChar *str;
; 5768 : 
; 5769 : 	lenn = strlen((char *) token2);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+1]
	npad	3
$LL13@xmlAutomat:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL13@xmlAutomat
	sub	edi, ecx

; 5770 : 	lenp = strlen((char *) token);

	lea	ecx, DWORD PTR [esi+1]
	npad	4
$LL14@xmlAutomat:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL14@xmlAutomat
	sub	esi, ecx

; 5771 : 
; 5772 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax

; 5773 : 	if (str == NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlAutomat

; 5774 : 	    xmlRegFreeAtom(atom);
; 5775 : 	    return(NULL);
; 5776 : 	}
; 5777 : 	memcpy(&str[0], token, lenp);

	push	esi
	push	DWORD PTR _token$[ebp]
	push	eax
	call	_memcpy

; 5778 : 	str[lenp] = '|';

	add	esi, DWORD PTR $T1[ebp]

; 5779 : 	memcpy(&str[lenp + 1], token2, lenn);

	push	edi
	push	DWORD PTR _token2$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 124			; 0000007cH
	push	eax
	call	_memcpy

; 5780 : 	str[lenn + lenp + 1] = 0;
; 5781 : 
; 5782 : 	atom->valuep = str;

	mov	eax, DWORD PTR $T1[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR [esi+edi+1], 0
	mov	edi, DWORD PTR _am$[ebp]
	jmp	SHORT $LN6@xmlAutomat
$LN7@xmlAutomat:

; 5764 : 	atom->valuep = xmlStrdup(token);

	push	esi
	call	_xmlStrdup
	add	esp, 4
$LN6@xmlAutomat:

; 5783 :     }
; 5784 : 
; 5785 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	esi, DWORD PTR _to$[ebp]
	push	ebx
	push	esi
	push	DWORD PTR _from$[ebp]
	mov	DWORD PTR [ebx+20], eax
	push	edi
	call	_xmlFAGenerateTransitions
	add	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN9@xmlAutomat
$LN12@xmlAutomat:

; 5786 :         xmlRegFreeAtom(atom);

	push	ebx
	call	_xmlRegFreeAtom
	add	esp, 4
$LN3@xmlAutomat:

; 5792 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlAutomat:

; 5787 : 	return(NULL);
; 5788 :     }
; 5789 :     if (to == NULL)

	test	esi, esi
	jne	SHORT $LN10@xmlAutomat

; 5790 : 	return(am->state);

	mov	eax, DWORD PTR [edi+24]
	pop	edi

; 5792 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlAutomat:
	pop	edi

; 5791 :     return(to);

	mov	eax, esi

; 5792 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAutomataNewTransition2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewTransition
_TEXT	SEGMENT
_am$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_token$ = 20						; size = 4
_data$ = 24						; size = 4
_xmlAutomataNewTransition PROC				; COMDAT

; 5716 : 			 void *data) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _am$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlAutomat

; 5717 :     xmlRegAtomPtr atom;
; 5718 : 
; 5719 :     if ((am == NULL) || (from == NULL) || (token == NULL))

	cmp	DWORD PTR _from$[ebp], 0
	je	SHORT $LN3@xmlAutomat
	mov	ebx, DWORD PTR _token$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlAutomat

; 5720 : 	return(NULL);
; 5721 :     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);

	push	5
	push	esi
	call	_xmlRegNewAtom
	mov	edi, eax
	add	esp, 8

; 5722 :     if (atom == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlAutomat

; 5723 :         return(NULL);
; 5724 :     atom->data = data;

	mov	eax, DWORD PTR _data$[ebp]

; 5725 :     atom->valuep = xmlStrdup(token);

	push	ebx
	mov	DWORD PTR [edi+60], eax
	call	_xmlStrdup

; 5726 : 
; 5727 :     if (xmlFAGenerateTransitions(am, from, to, atom) < 0) {

	mov	ebx, DWORD PTR _to$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _from$[ebp]
	mov	DWORD PTR [edi+20], eax
	push	esi
	call	_xmlFAGenerateTransitions
	add	esp, 20					; 00000014H
	test	eax, eax
	jns	SHORT $LN5@xmlAutomat

; 5728 :         xmlRegFreeAtom(atom);

	push	edi
	call	_xmlRegFreeAtom
	add	esp, 4
$LN3@xmlAutomat:

; 5733 :     return(to);
; 5734 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlAutomat:

; 5729 : 	return(NULL);
; 5730 :     }
; 5731 :     if (to == NULL)

	test	ebx, ebx
	jne	SHORT $LN6@xmlAutomat

; 5732 : 	return(am->state);

	mov	eax, DWORD PTR [esi+24]
	pop	edi

; 5733 :     return(to);
; 5734 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlAutomat:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
_xmlAutomataNewTransition ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataNewState
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlAutomataNewState PROC				; COMDAT

; 6161 : xmlAutomataNewState(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _am$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlAutomat

; 6162 :     xmlAutomataStatePtr to;
; 6163 : 
; 6164 :     if (am == NULL)
; 6165 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 6169 : }

	pop	ebp
	ret	0
$LN2@xmlAutomat:
	push	esi

; 6166 :     to = xmlRegNewState(am);

	push	edi
	call	_xmlRegNewState
	mov	esi, eax

; 6167 :     xmlRegStatePush(am, to);

	push	esi
	push	edi
	call	_xmlRegStatePush
	add	esp, 12					; 0000000cH

; 6168 :     return(to);

	mov	eax, esi
	pop	esi
	pop	edi

; 6169 : }

	pop	ebp
	ret	0
_xmlAutomataNewState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataSetFinalState
_TEXT	SEGMENT
_am$ = 8						; size = 4
_state$ = 12						; size = 4
_xmlAutomataSetFinalState PROC				; COMDAT

; 5692 : xmlAutomataSetFinalState(xmlAutomataPtr am, xmlAutomataStatePtr state) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _am$[ebp], 0
	je	SHORT $LN3@xmlAutomat

; 5693 :     if ((am == NULL) || (state == NULL))

	mov	eax, DWORD PTR _state$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlAutomat

; 5695 :     state->type = XML_REGEXP_FINAL_STATE;

	mov	DWORD PTR [eax], 2

; 5696 :     return(0);

	xor	eax, eax

; 5697 : }

	pop	ebp
	ret	0
$LN3@xmlAutomat:

; 5694 : 	return(-1);

	or	eax, -1

; 5697 : }

	pop	ebp
	ret	0
_xmlAutomataSetFinalState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlAutomataGetInitState
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlAutomataGetInitState PROC				; COMDAT

; 5676 : xmlAutomataGetInitState(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _am$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlAutomat

; 5680 : }

	pop	ebp
	ret	0
$LN2@xmlAutomat:

; 5677 :     if (am == NULL)
; 5678 : 	return(NULL);
; 5679 :     return(am->start);

	mov	eax, DWORD PTR [eax+16]

; 5680 : }

	pop	ebp
	ret	0
_xmlAutomataGetInitState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlFreeAutomata
_TEXT	SEGMENT
_am$ = 8						; size = 4
_xmlFreeAutomata PROC					; COMDAT

; 5647 : xmlFreeAutomata(xmlAutomataPtr am) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _am$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlFreeAut

; 5648 :     if (am == NULL)
; 5649 : 	return;
; 5650 :     xmlRegFreeParserCtxt(am);

	mov	DWORD PTR _am$[ebp], eax

; 5651 : }

	pop	ebp

; 5648 :     if (am == NULL)
; 5649 : 	return;
; 5650 :     xmlRegFreeParserCtxt(am);

	jmp	_xmlRegFreeParserCtxt
$LN1@xmlFreeAut:

; 5651 : }

	pop	ebp
	ret	0
_xmlFreeAutomata ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlNewAutomata
_TEXT	SEGMENT
_xmlNewAutomata PROC					; COMDAT

; 5615 : xmlNewAutomata(void) {

	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4

; 688  :     ret = (xmlRegParserCtxtPtr) xmlMalloc(sizeof(xmlRegParserCtxt));

	push	80					; 00000050H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 689  :     if (ret == NULL)

	test	esi, esi
	je	$LN16@xmlNewAuto

; 690  : 	return(NULL);
; 691  :     memset(ret, 0, sizeof(xmlRegParserCtxt));

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+76], 0

; 692  :     if (string != NULL)
; 693  : 	ret->string = xmlStrdup(string);
; 694  :     ret->cur = ret->string;

	mov	DWORD PTR [esi+4], 0

; 695  :     ret->neg = 0;

	mov	DWORD PTR [esi+12], 0

; 696  :     ret->negs = 0;

	mov	DWORD PTR [esi+72], 0

; 697  :     ret->error = 0;

	mov	DWORD PTR [esi+8], 0

; 698  :     ret->determinist = -1;

	mov	DWORD PTR [esi+68], -1

; 5616 :     xmlAutomataPtr ctxt;
; 5617 : 
; 5618 :     ctxt = xmlRegNewParserCtxt(NULL);
; 5619 :     if (ctxt == NULL)
; 5620 : 	return(NULL);
; 5621 : 
; 5622 :     /* initialize the parser */
; 5623 :     ctxt->end = NULL;
; 5624 :     ctxt->start = ctxt->state = xmlRegNewState(ctxt);

	push	esi
	mov	DWORD PTR [esi+20], 0
	call	_xmlRegNewState
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+16], eax

; 5625 :     if (ctxt->start == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlNewAuto

; 5650 :     xmlRegFreeParserCtxt(am);

	push	esi
	call	_xmlRegFreeParserCtxt
	add	esp, 4
$LN16@xmlNewAuto:

; 5638 : }

	xor	eax, eax
	pop	esi
	ret	0
$LN3@xmlNewAuto:

; 5626 : 	xmlFreeAutomata(ctxt);
; 5627 : 	return(NULL);
; 5628 :     }
; 5629 :     ctxt->start->type = XML_REGEXP_START_STATE;

	mov	DWORD PTR [eax], 1

; 5630 :     if (xmlRegStatePush(ctxt, ctxt->start) < 0) {

	push	DWORD PTR [esi+16]
	push	esi
	call	_xmlRegStatePush
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN4@xmlNewAuto

; 5631 :         xmlRegFreeState(ctxt->start);

	push	DWORD PTR [esi+16]
	call	_xmlRegFreeState

; 5650 :     xmlRegFreeParserCtxt(am);

	push	esi
	call	_xmlRegFreeParserCtxt
	add	esp, 8

; 5638 : }

	xor	eax, eax
	pop	esi
	ret	0
$LN4@xmlNewAuto:

; 5632 : 	xmlFreeAutomata(ctxt);
; 5633 : 	return(NULL);
; 5634 :     }
; 5635 :     ctxt->flags = 0;

	mov	DWORD PTR [esi+76], 0

; 5636 : 
; 5637 :     return(ctxt);

	mov	eax, esi
	pop	esi

; 5638 : }

	ret	0
_xmlNewAutomata ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpDump
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_expr$ = 12						; size = 4
_xmlExpDump PROC					; COMDAT

; 8126 : xmlExpDump(xmlBufferPtr buf, xmlExpNodePtr expr) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlExpDump

; 8127 :     if ((buf == NULL) || (expr == NULL))

	mov	eax, DWORD PTR _expr$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlExpDump

; 8128 :         return;
; 8129 :     xmlExpDumpInt(buf, expr, 0);

	push	0
	push	eax
	push	ecx
	call	_xmlExpDumpInt
	add	esp, 12					; 0000000cH
$LN3@xmlExpDump:

; 8130 : }

	pop	ebp
	ret	0
_xmlExpDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpSubsume
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_xmlExpSubsume PROC					; COMDAT

; 7814 : xmlExpSubsume(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _exp$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlExpSubs

; 7815 :     xmlExpNodePtr tmp;
; 7816 : 
; 7817 :     if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))

	test	ebx, ebx
	je	SHORT $LN3@xmlExpSubs
	mov	esi, DWORD PTR _sub$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlExpSubs

; 7818 :         return(-1);
; 7819 : 
; 7820 :     /*
; 7821 :      * TODO: speedup by checking the language of sub is a subset of the
; 7822 :      *       language of exp
; 7823 :      */
; 7824 :     /*
; 7825 :      * O(1) speedups
; 7826 :      */
; 7827 :     if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {

	test	BYTE PTR [esi+1], 1
	je	SHORT $LN4@xmlExpSubs
	test	BYTE PTR [edi+1], 1
	je	SHORT $LN12@xmlExpSubs
$LN4@xmlExpSubs:

; 7828 : #ifdef DEBUG_DERIV
; 7829 : 	printf("Sub nillable and not exp : can't subsume\n");
; 7830 : #endif
; 7831 :         return(0);
; 7832 :     }
; 7833 :     if (xmlExpCheckCard(exp, sub) == 0) {

	push	esi
	push	edi
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlExpSubs

; 7834 : #ifdef DEBUG_DERIV
; 7835 : 	printf("sub generate longuer sequances than exp : can't subsume\n");
; 7836 : #endif
; 7837 :         return(0);
; 7838 :     }
; 7839 :     tmp = xmlExpExpDeriveInt(ctxt, exp, sub);

	push	esi
	push	edi
	push	ebx
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH

; 7840 : #ifdef DEBUG_DERIV
; 7841 :     printf("Result derivation :\n");
; 7842 :     PRINT_EXP(tmp);
; 7843 : #endif
; 7844 :     if (tmp == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlExpSubs

; 7845 :         return(-1);
; 7846 :     if (tmp == forbiddenExp)

	cmp	eax, DWORD PTR _forbiddenExp
	je	SHORT $LN12@xmlExpSubs

; 7847 : 	return(0);
; 7848 :     if (tmp == emptyExp)

	cmp	eax, DWORD PTR _emptyExp
	je	SHORT $LN11@xmlExpSubs

; 7849 : 	return(1);
; 7850 :     if ((tmp != NULL) && (IS_NILLABLE(tmp))) {

	mov	bl, BYTE PTR [eax+1]
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpFree
	add	esp, 8
	test	bl, 1
	je	SHORT $LN12@xmlExpSubs
$LN11@xmlExpSubs:
	pop	edi

; 7851 :         xmlExpFree(ctxt, tmp);
; 7852 :         return(1);
; 7853 :     }
; 7854 :     xmlExpFree(ctxt, tmp);
; 7855 :     return(0);
; 7856 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlExpSubs:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlExpSubs:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlExpSubsume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpExpDerive
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_sub$ = 16						; size = 4
_xmlExpExpDerive PROC					; COMDAT

; 7780 : xmlExpExpDerive(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp, xmlExpNodePtr sub) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exp$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlExpExpD

; 7781 :     if ((exp == NULL) || (ctxt == NULL) || (sub == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlExpExpD
	mov	edi, DWORD PTR _sub$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlExpExpD

; 7783 : 
; 7784 :     /*
; 7785 :      * O(1) speedups
; 7786 :      */
; 7787 :     if (IS_NILLABLE(sub) && (!IS_NILLABLE(exp))) {

	test	BYTE PTR [edi+1], 1
	je	SHORT $LN4@xmlExpExpD
	test	BYTE PTR [esi+1], 1
	je	SHORT $LN7@xmlExpExpD
$LN4@xmlExpExpD:

; 7788 : #ifdef DEBUG_DERIV
; 7789 : 	printf("Sub nillable and not exp : can't subsume\n");
; 7790 : #endif
; 7791 :         return(forbiddenExp);
; 7792 :     }
; 7793 :     if (xmlExpCheckCard(exp, sub) == 0) {

	push	edi
	push	esi
	call	_xmlExpCheckCard
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlExpExpD
$LN7@xmlExpExpD:

; 7794 : #ifdef DEBUG_DERIV
; 7795 : 	printf("sub generate longuer sequances than exp : can't subsume\n");
; 7796 : #endif
; 7797 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	pop	edi

; 7800 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlExpExpD:

; 7798 :     }
; 7799 :     return(xmlExpExpDeriveInt(ctxt, exp, sub));

	push	edi
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlExpExpDeriveInt
	add	esp, 12					; 0000000cH
	pop	edi

; 7800 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlExpExpD:
	pop	edi

; 7782 :         return(NULL);

	xor	eax, eax

; 7800 : }

	pop	esi
	pop	ebp
	ret	0
_xmlExpExpDerive ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpStringDerive
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_str$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpStringDerive PROC				; COMDAT

; 7213 :                    const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _exp$[ebp], 0
	je	SHORT $LN3@xmlExpStri

; 7214 :     const xmlChar *input;
; 7215 : 
; 7216 :     if ((exp == NULL) || (ctxt == NULL) || (str == NULL)) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlExpStri
	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlExpStri

; 7218 :     }
; 7219 :     /*
; 7220 :      * check the string is in the dictionary, if yes use an interned
; 7221 :      * copy, otherwise we know it's not an acceptable input
; 7222 :      */
; 7223 :     input = xmlDictExists(ctxt->dict, str, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	push	DWORD PTR [esi]
	call	_xmlDictExists
	add	esp, 12					; 0000000cH

; 7224 :     if (input == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlExpStri

; 7225 :         return(forbiddenExp);

	mov	eax, DWORD PTR _forbiddenExp
	pop	esi

; 7228 : }

	pop	ebp
	ret	0
$LN4@xmlExpStri:

; 7226 :     }
; 7227 :     return(xmlExpStringDeriveInt(ctxt, exp, input));

	push	eax
	push	DWORD PTR _exp$[ebp]
	push	esi
	call	_xmlExpStringDeriveInt
	add	esp, 12					; 0000000cH
	pop	esi

; 7228 : }

	pop	ebp
	ret	0
$LN3@xmlExpStri:

; 7217 :         return(NULL);

	xor	eax, eax
	pop	esi

; 7228 : }

	pop	ebp
	ret	0
_xmlExpStringDerive ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetStart
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_tokList$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpGetStart PROC					; COMDAT

; 7068 :                const xmlChar**tokList, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlExpGetS

; 7069 :     if ((ctxt == NULL) || (exp == NULL) || (tokList == NULL) || (len <= 0))

	mov	eax, DWORD PTR _exp$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlExpGetS
	mov	edx, DWORD PTR _tokList$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlExpGetS
	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN3@xmlExpGetS

; 7071 :     return(xmlExpGetStartInt(ctxt, exp, tokList, len, 0));

	push	0
	push	DWORD PTR _len$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlExpGetStartInt
	add	esp, 20					; 00000014H

; 7072 : }

	pop	ebp
	ret	0
$LN3@xmlExpGetS:

; 7070 :         return(-1);

	or	eax, -1

; 7072 : }

	pop	ebp
	ret	0
_xmlExpGetStart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpGetLanguage
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_langList$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlExpGetLanguage PROC					; COMDAT

; 7000 :                   const xmlChar**langList, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlExpGetL

; 7001 :     if ((ctxt == NULL) || (exp == NULL) || (langList == NULL) || (len <= 0))

	mov	eax, DWORD PTR _exp$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlExpGetL
	mov	edx, DWORD PTR _langList$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlExpGetL
	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN3@xmlExpGetL

; 7003 :     return(xmlExpGetLanguageInt(ctxt, exp, langList, len, 0));

	push	0
	push	DWORD PTR _len$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlExpGetLanguageInt
	add	esp, 20					; 00000014H

; 7004 : }

	pop	ebp
	ret	0
$LN3@xmlExpGetL:

; 7002 :         return(-1);

	or	eax, -1

; 7004 : }

	pop	ebp
	ret	0
_xmlExpGetLanguage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpMaxToken
_TEXT	SEGMENT
_expr$ = 8						; size = 4
_xmlExpMaxToken PROC					; COMDAT

; 8141 : xmlExpMaxToken(xmlExpNodePtr expr) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _expr$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlExpMaxT

; 8142 :     if (expr == NULL)
; 8143 :         return(-1);

	or	eax, -1

; 8145 : }

	pop	ebp
	ret	0
$LN2@xmlExpMaxT:

; 8144 :     return(expr->c_max);

	mov	eax, DWORD PTR [eax+8]

; 8145 : }

	pop	ebp
	ret	0
_xmlExpMaxToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpIsNillable
_TEXT	SEGMENT
_exp$ = 8						; size = 4
_xmlExpIsNillable PROC					; COMDAT

; 7083 : xmlExpIsNillable(xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _exp$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlExpIsNi

; 7084 :     if (exp == NULL)
; 7085 :         return(-1);

	or	eax, -1

; 7087 : }

	pop	ebp
	ret	0
$LN2@xmlExpIsNi:

; 7086 :     return(IS_NILLABLE(exp) != 0);

	movzx	eax, BYTE PTR [eax+1]
	and	eax, 1

; 7087 : }

	pop	ebp
	ret	0
_xmlExpIsNillable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_subset$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_xmlExpNewRange PROC					; COMDAT

; 6935 : xmlExpNewRange(xmlExpCtxtPtr ctxt, xmlExpNodePtr subset, int min, int max) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	jne	SHORT $LN2@xmlExpNewR

; 6936 :     if (ctxt == NULL)
; 6937 :         return(NULL);

	xor	eax, eax

; 6944 :                               NULL, NULL, min, max));
; 6945 : }

	pop	ebp
	ret	0
$LN2@xmlExpNewR:

; 6938 :     if ((subset == NULL) || (min < 0) || (max < -1) ||

	mov	ecx, DWORD PTR _subset$[ebp]
	push	esi
	test	ecx, ecx
	je	SHORT $LN4@xmlExpNewR
	mov	esi, DWORD PTR _min$[ebp]
	test	esi, esi
	js	SHORT $LN4@xmlExpNewR
	mov	eax, DWORD PTR _max$[ebp]
	cmp	eax, -1
	jl	SHORT $LN4@xmlExpNewR
	test	eax, eax
	js	SHORT $LN3@xmlExpNewR
	cmp	esi, eax
	jg	SHORT $LN4@xmlExpNewR
$LN3@xmlExpNewR:

; 6942 :     }
; 6943 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_COUNT, subset,

	push	eax
	push	esi
	push	0
	push	0
	push	ecx
	push	5
	push	edx
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	esi

; 6944 :                               NULL, NULL, min, max));
; 6945 : }

	pop	ebp
	ret	0
$LN4@xmlExpNewR:

; 6939 :         ((max >= 0) && (min > max))) {
; 6940 : 	xmlExpFree(ctxt, subset);

	push	ecx
	push	edx
	call	_xmlExpFree
	add	esp, 8

; 6941 :         return(NULL);

	xor	eax, eax
	pop	esi

; 6944 :                               NULL, NULL, min, max));
; 6945 : }

	pop	ebp
	ret	0
_xmlExpNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewSeq
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpNewSeq PROC					; COMDAT

; 6909 : xmlExpNewSeq(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlExpNewS

; 6910 :     if (ctxt == NULL)
; 6911 :         return(NULL);

	xor	eax, eax
	pop	esi

; 6918 : }

	pop	ebp
	ret	0
$LN2@xmlExpNewS:

; 6912 :     if ((left == NULL) || (right == NULL)) {

	mov	eax, DWORD PTR _left$[ebp]
	push	edi
	mov	edi, DWORD PTR _right$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlExpNewS
	test	edi, edi
	je	SHORT $LN4@xmlExpNewS

; 6916 :     }
; 6917 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_SEQ, left, right, NULL, 0, 0));

	push	0
	push	0
	push	0
	push	edi
	push	eax
	push	3
	push	esi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 6918 : }

	pop	ebp
	ret	0
$LN4@xmlExpNewS:

; 6913 :         xmlExpFree(ctxt, left);

	push	eax
	push	esi
	call	_xmlExpFree

; 6914 :         xmlExpFree(ctxt, right);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 16					; 00000010H

; 6915 :         return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 6918 : }

	pop	ebp
	ret	0
_xmlExpNewSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewOr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_xmlExpNewOr PROC					; COMDAT

; 6884 : xmlExpNewOr(xmlExpCtxtPtr ctxt, xmlExpNodePtr left, xmlExpNodePtr right) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlExpNewO

; 6885 :     if (ctxt == NULL)
; 6886 :         return(NULL);

	xor	eax, eax
	pop	esi

; 6893 : }

	pop	ebp
	ret	0
$LN2@xmlExpNewO:

; 6887 :     if ((left == NULL) || (right == NULL)) {

	mov	eax, DWORD PTR _left$[ebp]
	push	edi
	mov	edi, DWORD PTR _right$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlExpNewO
	test	edi, edi
	je	SHORT $LN4@xmlExpNewO

; 6891 :     }
; 6892 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_OR, left, right, NULL, 0, 0));

	push	0
	push	0
	push	0
	push	edi
	push	eax
	push	4
	push	esi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 6893 : }

	pop	ebp
	ret	0
$LN4@xmlExpNewO:

; 6888 :         xmlExpFree(ctxt, left);

	push	eax
	push	esi
	call	_xmlExpFree

; 6889 :         xmlExpFree(ctxt, right);

	push	edi
	push	esi
	call	_xmlExpFree
	add	esp, 16					; 00000010H

; 6890 :         return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 6893 : }

	pop	ebp
	ret	0
_xmlExpNewOr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewAtom
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlExpNewAtom PROC					; COMDAT

; 6861 : xmlExpNewAtom(xmlExpCtxtPtr ctxt, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlExpNewA

; 6862 :     if ((ctxt == NULL) || (name == NULL))

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlExpNewA

; 6864 :     name = xmlDictLookup(ctxt->dict, name, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	push	DWORD PTR [esi]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 6865 :     if (name == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlExpNewA

; 6866 :         return(NULL);
; 6867 :     return(xmlExpHashGetEntry(ctxt, XML_EXP_ATOM, NULL, NULL, name, 0, 0));

	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	esi
	call	_xmlExpHashGetEntry
	add	esp, 28					; 0000001cH
	pop	esi

; 6868 : }

	pop	ebp
	ret	0
$LN3@xmlExpNewA:

; 6863 :         return(NULL);

	xor	eax, eax
	pop	esi

; 6868 : }

	pop	ebp
	ret	0
_xmlExpNewAtom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpParse
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_expr$ = 12						; size = 4
_xmlExpParse PROC					; COMDAT

; 8027 : xmlExpParse(xmlExpCtxtPtr ctxt, const char *expr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _expr$[ebp]
	push	esi
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	call	_xmlExpParseExpr
	mov	edx, DWORD PTR [esi+28]
	add	esp, 4
$LL2@xmlExpPars:

; 8028 :     xmlExpNodePtr ret;
; 8029 : 
; 8030 :     ctxt->expr = expr;
; 8031 :     ctxt->cur = expr;
; 8032 : 
; 8033 :     ret = xmlExpParseExpr(ctxt);
; 8034 :     SKIP_BLANKS

	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN4@xmlExpPars
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN4@xmlExpPars
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN4@xmlExpPars
	cmp	cl, 9
	jne	SHORT $LN3@xmlExpPars
$LN4@xmlExpPars:
	inc	edx
	mov	DWORD PTR [esi+28], edx
	jmp	SHORT $LL2@xmlExpPars
$LN3@xmlExpPars:

; 8035 :     if (*ctxt->cur != 0) {

	test	cl, cl
	je	SHORT $LN1@xmlExpPars

; 8036 :         xmlExpFree(ctxt, ret);

	push	eax
	push	esi
	call	_xmlExpFree
	add	esp, 8

; 8037 :         return(NULL);

	xor	eax, eax
$LN1@xmlExpPars:
	pop	esi

; 8038 :     }
; 8039 :     return(ret);
; 8040 : }

	pop	ebp
	ret	0
_xmlExpParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpRef
_TEXT	SEGMENT
_exp$ = 8						; size = 4
_xmlExpRef PROC						; COMDAT

; 6845 : xmlExpRef(xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _exp$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlExpRef

; 6846 :     if (exp != NULL)
; 6847 :         exp->ref++;

	inc	DWORD PTR [eax+4]
$LN2@xmlExpRef:

; 6848 : }

	pop	ebp
	ret	0
_xmlExpRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpFree
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_exp$ = 12						; size = 4
_xmlExpFree PROC					; COMDAT

; 6803 : xmlExpFree(xmlExpCtxtPtr ctxt, xmlExpNodePtr exp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exp$[ebp]
	test	esi, esi
	je	$LN5@xmlExpFree

; 6804 :     if ((exp == NULL) || (exp == forbiddenExp) || (exp == emptyExp))

	cmp	esi, DWORD PTR _forbiddenExp
	je	$LN5@xmlExpFree
	cmp	esi, DWORD PTR _emptyExp
	je	$LN5@xmlExpFree

; 6805 :         return;
; 6806 :     exp->ref--;

	add	DWORD PTR [esi+4], -1

; 6807 :     if (exp->ref == 0) {

	jne	$LN5@xmlExpFree

; 6808 :         unsigned short key;
; 6809 : 
; 6810 :         /* Unlink it first from the hash table */
; 6811 : 	key = exp->key % ctxt->size;

	movzx	eax, WORD PTR [esi+2]
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	cdq
	idiv	DWORD PTR [edi+8]

; 6812 : 	if (ctxt->table[key] == exp) {

	mov	eax, DWORD PTR [edi+4]
	movzx	ecx, dx
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, esi
	je	SHORT $LN16@xmlExpFree

; 6813 : 	    ctxt->table[key] = exp->next;
; 6814 : 	} else {
; 6815 : 	    xmlExpNodePtr tmp;
; 6816 : 
; 6817 : 	    tmp = ctxt->table[key];
; 6818 : 	    while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlExpFree
	npad	6
$LL2@xmlExpFree:

; 6819 : 	        if (tmp->next == exp) {

	lea	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, esi
	je	SHORT $LN16@xmlExpFree

; 6813 : 	    ctxt->table[key] = exp->next;
; 6814 : 	} else {
; 6815 : 	    xmlExpNodePtr tmp;
; 6816 : 
; 6817 : 	    tmp = ctxt->table[key];
; 6818 : 	    while (tmp != NULL) {

	test	eax, eax
	jne	SHORT $LL2@xmlExpFree

; 6819 : 	        if (tmp->next == exp) {

	jmp	SHORT $LN3@xmlExpFree
$LN16@xmlExpFree:

; 6820 : 		    tmp->next = exp->next;
; 6821 : 		    break;
; 6822 : 		}
; 6823 : 	        tmp = tmp->next;
; 6824 : 	    }
; 6825 : 	}
; 6826 : 
; 6827 :         if ((exp->type == XML_EXP_SEQ) || (exp->type == XML_EXP_OR)) {

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], eax
$LN3@xmlExpFree:
	mov	al, BYTE PTR [esi]
	cmp	al, 3
	je	SHORT $LN12@xmlExpFree
	cmp	al, 4
	je	SHORT $LN12@xmlExpFree

; 6830 : 	} else if (exp->type == XML_EXP_COUNT) {

	cmp	al, 5
	jne	SHORT $LN13@xmlExpFree

; 6831 : 	    xmlExpFree(ctxt, exp->exp_left);

	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlExpFree
	add	esp, 8

; 6832 : 	}
; 6833 :         xmlFree(exp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 6834 : 	ctxt->nb_nodes--;

	dec	DWORD PTR [edi+16]
	pop	edi
	pop	esi

; 6835 :     }
; 6836 : }

	pop	ebp
	ret	0
$LN12@xmlExpFree:

; 6828 : 	    xmlExpFree(ctxt, exp->exp_left);

	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlExpFree

; 6829 : 	    xmlExpFree(ctxt, exp->exp_right);

	push	DWORD PTR [esi+20]
	push	edi
	call	_xmlExpFree
	add	esp, 16					; 00000010H
$LN13@xmlExpFree:

; 6832 : 	}
; 6833 :         xmlFree(exp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 6834 : 	ctxt->nb_nodes--;

	dec	DWORD PTR [edi+16]
	pop	edi
$LN5@xmlExpFree:
	pop	esi

; 6835 :     }
; 6836 : }

	pop	ebp
	ret	0
_xmlExpFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCtxtNbCons
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpCtxtNbCons PROC					; COMDAT

; 8171 : xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlExpCtxt

; 8172 :     if (ctxt == NULL)
; 8173 :         return(-1);

	or	eax, -1

; 8175 : }

	pop	ebp
	ret	0
$LN2@xmlExpCtxt:

; 8174 :     return(ctxt->nb_cons);

	mov	eax, DWORD PTR [eax+32]

; 8175 : }

	pop	ebp
	ret	0
_xmlExpCtxtNbCons ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpCtxtNbNodes
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpCtxtNbNodes PROC					; COMDAT

; 8156 : xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlExpCtxt

; 8157 :     if (ctxt == NULL)
; 8158 :         return(-1);

	or	eax, -1

; 8160 : }

	pop	ebp
	ret	0
$LN2@xmlExpCtxt:

; 8159 :     return(ctxt->nb_nodes);

	mov	eax, DWORD PTR [eax+16]

; 8160 : }

	pop	ebp
	ret	0
_xmlExpCtxtNbNodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpNewCtxt
_TEXT	SEGMENT
_maxNodes$ = 8						; size = 4
_dict$ = 12						; size = 4
_xmlExpNewCtxt PROC					; COMDAT

; 6368 : xmlExpNewCtxt(int maxNodes, xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN9@xmlExpNewC

; 6369 :     xmlExpCtxtPtr ret;
; 6370 :     int size = 256;
; 6371 : 
; 6372 :     if (maxNodes <= 4096)
; 6373 :         maxNodes = 4096;
; 6374 : 
; 6375 :     ret = (xmlExpCtxtPtr) xmlMalloc(sizeof(xmlExpCtxt));

	mov	DWORD PTR [esi], 0
	mov	ecx, 4096				; 00001000H
	cmp	DWORD PTR _maxNodes$[ebp], ecx

; 6376 :     if (ret == NULL)
; 6377 :         return(NULL);
; 6378 :     memset(ret, 0, sizeof(xmlExpCtxt));

	mov	DWORD PTR [esi+4], 0
	cmovg	ecx, DWORD PTR _maxNodes$[ebp]
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0

; 6379 :     ret->size = size;
; 6380 :     ret->nbElems = 0;
; 6381 :     ret->maxNodes = maxNodes;
; 6382 :     ret->table = xmlMalloc(size * sizeof(xmlExpNodePtr));

	push	1024					; 00000400H
	mov	DWORD PTR [esi+8], 256			; 00000100H
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 6383 :     if (ret->table == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlExpNewC

; 6384 :         xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlExpNewC:

; 6400 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlExpNewC:

; 6385 : 	return(NULL);
; 6386 :     }
; 6387 :     memset(ret->table, 0, size * sizeof(xmlExpNodePtr));

	push	1024					; 00000400H
	push	0
	push	eax
	call	_memset

; 6388 :     if (dict == NULL) {

	mov	eax, DWORD PTR _dict$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@xmlExpNewC

; 6389 :         ret->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [esi], eax

; 6390 : 	if (ret->dict == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlExpNewC

; 6391 : 	    xmlFree(ret->table);

	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree

; 6392 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 6393 : 	    return(NULL);

	xor	eax, eax
	pop	esi

; 6400 : }

	pop	ebp
	ret	0
$LN5@xmlExpNewC:

; 6394 : 	}
; 6395 :     } else {
; 6396 :         ret->dict = dict;
; 6397 : 	xmlDictReference(ret->dict);

	push	eax
	mov	DWORD PTR [esi], eax
	call	_xmlDictReference
	add	esp, 4
$LN6@xmlExpNewC:

; 6398 :     }
; 6399 :     return(ret);

	mov	eax, esi
	pop	esi

; 6400 : }

	pop	ebp
	ret	0
_xmlExpNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlExpFreeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlExpFreeCtxt PROC					; COMDAT

; 6409 : xmlExpFreeCtxt(xmlExpCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlExpFree

; 6410 :     if (ctxt == NULL)
; 6411 :         return;
; 6412 :     xmlDictFree(ctxt->dict);

	push	DWORD PTR [esi]
	call	_xmlDictFree

; 6413 :     if (ctxt->table != NULL)

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlExpFree

; 6414 : 	xmlFree(ctxt->table);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlExpFree:

; 6415 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlExpFree:
	pop	esi

; 6416 : }

	pop	ebp
	ret	0
_xmlExpFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecErrInfo
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_string$ = 12						; size = 4
_nbval$ = 16						; size = 4
_nbneg$ = 20						; size = 4
_values$ = 24						; size = 4
_terminal$ = 28						; size = 4
_xmlRegExecErrInfo PROC					; COMDAT

; 4408 :                   int *nbval, int *nbneg, xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _exec$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlRegExec

; 4409 :     if (exec == NULL)
; 4410 :         return(-1);

	or	eax, -1

; 4418 : }

	pop	ebp
	ret	0
$LN2@xmlRegExec:

; 4411 :     if (string != NULL) {

	mov	edx, DWORD PTR _string$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlRegExec

; 4412 :         if (exec->status != 0)

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@xmlRegExec

; 4413 : 	    *string = exec->errString;

	mov	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR [edx], eax

; 4416 :     }
; 4417 :     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));

	mov	DWORD PTR _string$[ebp], 1
	mov	DWORD PTR _exec$[ebp], ecx

; 4418 : }

	pop	ebp

; 4416 :     }
; 4417 :     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));

	jmp	_xmlRegExecGetValues
$LN4@xmlRegExec:

; 4414 : 	else
; 4415 : 	    *string = NULL;

	mov	DWORD PTR [edx], 0
$LN5@xmlRegExec:

; 4416 :     }
; 4417 :     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));

	mov	DWORD PTR _string$[ebp], 1
	mov	DWORD PTR _exec$[ebp], ecx

; 4418 : }

	pop	ebp

; 4416 :     }
; 4417 :     return(xmlRegExecGetValues(exec, 1, nbval, nbneg, values, terminal));

	jmp	_xmlRegExecGetValues
_xmlRegExecErrInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecNextValues
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_nbval$ = 12						; size = 4
_nbneg$ = 16						; size = 4
_values$ = 20						; size = 4
_terminal$ = 24						; size = 4
_xmlRegExecNextValues PROC				; COMDAT

; 4383 :                      xmlChar **values, int *terminal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _terminal$[ebp]
	push	DWORD PTR _values$[ebp]
	push	DWORD PTR _nbneg$[ebp]
	push	DWORD PTR _nbval$[ebp]
	push	0
	push	DWORD PTR _exec$[ebp]
	call	_xmlRegExecGetValues
	add	esp, 24					; 00000018H

; 4384 :     return(xmlRegExecGetValues(exec, 0, nbval, nbneg, values, terminal));
; 4385 : }

	pop	ebp
	ret	0
_xmlRegExecNextValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushString2
_TEXT	SEGMENT
_buf$ = -152						; size = 150
_str$1$ = 8						; size = 4
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_value2$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlRegExecPushString2 PROC				; COMDAT

; 4162 :                       const xmlChar *value2, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _exec$[ebp]
	test	ebx, ebx
	je	$LN15@xmlRegExec

; 4163 :     xmlChar buf[150];
; 4164 :     int lenn, lenp, ret;
; 4165 :     xmlChar *str;
; 4166 : 
; 4167 :     if (exec == NULL)
; 4168 : 	return(-1);
; 4169 :     if (exec->comp == NULL)

	cmp	DWORD PTR [ebx+8], 0
	je	$LN15@xmlRegExec

; 4171 :     if (exec->status != 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jne	SHORT $LN1@xmlRegExec

; 4172 : 	return(exec->status);
; 4173 : 
; 4174 :     if (value2 == NULL)

	mov	eax, DWORD PTR _value2$[ebp]
	test	eax, eax
	jne	SHORT $LN5@xmlRegExec

; 4145 :     return(xmlRegExecPushStringInternal(exec, value, data, 0));

	push	eax
	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _value$[ebp]
	push	ebx
	call	_xmlRegExecPushStringInternal
	add	esp, 16					; 00000010H
	pop	ebx

; 4202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRegExec:
	push	edi

; 4175 :         return(xmlRegExecPushString(exec, value, data));
; 4176 : 
; 4177 :     lenn = strlen((char *) value2);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+1]
$LL16@xmlRegExec:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL16@xmlRegExec
	push	esi

; 4178 :     lenp = strlen((char *) value);

	mov	esi, DWORD PTR _value$[ebp]
	sub	edi, ecx
	lea	ecx, DWORD PTR [esi+1]
$LL17@xmlRegExec:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL17@xmlRegExec
	sub	esi, ecx

; 4179 : 
; 4180 :     if (150 < lenn + lenp + 2) {

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	cmp	eax, 150				; 00000096H
	jle	SHORT $LN6@xmlRegExec

; 4181 : 	str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _str$1$[ebp], eax

; 4182 : 	if (str == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlRegExec

; 4183 : 	    exec->status = -1;

	pop	esi
	mov	DWORD PTR [ebx], -1

; 4184 : 	    return(-1);

	or	eax, -1
	pop	edi
$LN1@xmlRegExec:
	pop	ebx

; 4202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRegExec:

; 4185 : 	}
; 4186 :     } else {
; 4187 : 	str = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _str$1$[ebp], eax
$LN7@xmlRegExec:

; 4188 :     }
; 4189 :     memcpy(&str[0], value, lenp);

	push	esi
	push	DWORD PTR _value$[ebp]
	push	eax
	call	_memcpy

; 4190 :     str[lenp] = XML_REG_STRING_SEPARATOR;

	add	esi, DWORD PTR _str$1$[ebp]

; 4191 :     memcpy(&str[lenp + 1], value2, lenn);

	push	edi
	push	DWORD PTR _value2$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 124			; 0000007cH
	push	eax
	call	_memcpy

; 4192 :     str[lenn + lenp + 1] = 0;

	mov	BYTE PTR [esi+edi+1], 0
	add	esp, 24					; 00000018H

; 4193 : 
; 4194 :     if (exec->comp->compact != NULL)

	mov	eax, DWORD PTR [ebx+8]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN9@xmlRegExec

; 4195 : 	ret = xmlRegCompactPushString(exec, exec->comp, str, data);

	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _str$1$[ebp]
	push	eax
	push	ebx
	call	_xmlRegCompactPushString
	jmp	SHORT $LN20@xmlRegExec
$LN9@xmlRegExec:

; 4196 :     else
; 4197 :         ret = xmlRegExecPushStringInternal(exec, str, data, 1);

	push	1
	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _str$1$[ebp]
	push	ebx
	call	_xmlRegExecPushStringInternal
$LN20@xmlRegExec:

; 4198 : 
; 4199 :     if (str != buf)

	mov	esi, eax
	lea	ecx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _str$1$[ebp]
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	je	SHORT $LN11@xmlRegExec

; 4200 :         xmlFree(str);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRegExec:

; 4201 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 4202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlRegExec:

; 4170 : 	return(-1);

	or	eax, -1
	pop	ebx

; 4202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlRegExecPushString2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegExecPushString
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_value$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlRegExecPushString PROC				; COMDAT

; 4144 : 	             void *data) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _exec$[ebp]
	call	_xmlRegExecPushStringInternal
	add	esp, 16					; 00000010H

; 4145 :     return(xmlRegExecPushStringInternal(exec, value, data, 0));
; 4146 : }

	pop	ebp
	ret	0
_xmlRegExecPushString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeExecCtxt
_TEXT	SEGMENT
_exec$ = 8						; size = 4
_xmlRegFreeExecCtxt PROC				; COMDAT

; 3572 : xmlRegFreeExecCtxt(xmlRegExecCtxtPtr exec) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _exec$[ebp]
	test	esi, esi
	je	$LN1@xmlRegFree

; 3573 :     if (exec == NULL)
; 3574 : 	return;
; 3575 : 
; 3576 :     if (exec->rollbacks != NULL) {

	mov	eax, DWORD PTR [esi+40]
	push	edi
	test	eax, eax
	je	SHORT $LN9@xmlRegFree

; 3577 : 	if (exec->counts != NULL) {

	cmp	DWORD PTR [esi+44], 0
	mov	edx, eax
	je	SHORT $LN3@xmlRegFree

; 3578 : 	    int i;
; 3579 : 
; 3580 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN3@xmlRegFree

; 3581 : 		if (exec->rollbacks[i].counts != NULL)

	push	ebx
	xor	ebx, ebx
$LL4@xmlRegFree:
	mov	ecx, DWORD PTR [ebx+eax+12]
	test	ecx, ecx
	je	SHORT $LN2@xmlRegFree

; 3582 : 		    xmlFree(exec->rollbacks[i].counts);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+40]
	add	esp, 4
	mov	edx, eax
$LN2@xmlRegFree:

; 3578 : 	    int i;
; 3579 : 
; 3580 : 	    for (i = 0;i < exec->maxRollbacks;i++)

	inc	edi
	add	ebx, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL4@xmlRegFree
	pop	ebx
$LN3@xmlRegFree:

; 3583 : 	}
; 3584 : 	xmlFree(exec->rollbacks);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlRegFree:

; 3585 :     }
; 3586 :     if (exec->counts != NULL)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN12@xmlRegFree

; 3587 : 	xmlFree(exec->counts);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRegFree:

; 3588 :     if (exec->inputStack != NULL) {

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN13@xmlRegFree

; 3589 : 	int i;
; 3590 : 
; 3591 : 	for (i = 0;i < exec->inputStackNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [esi+52], edi
	jle	SHORT $LN6@xmlRegFree

; 3592 : 	    if (exec->inputStack[i].value != NULL)

	mov	edx, eax
	npad	1
$LL7@xmlRegFree:
	mov	ecx, DWORD PTR [eax+edi*8]
	test	ecx, ecx
	je	SHORT $LN5@xmlRegFree

; 3593 : 		xmlFree(exec->inputStack[i].value);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+68]
	add	esp, 4
	mov	edx, eax
$LN5@xmlRegFree:

; 3589 : 	int i;
; 3590 : 
; 3591 : 	for (i = 0;i < exec->inputStackNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+52]
	jl	SHORT $LL7@xmlRegFree
	mov	eax, edx
$LN6@xmlRegFree:

; 3594 : 	}
; 3595 : 	xmlFree(exec->inputStack);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlRegFree:

; 3596 :     }
; 3597 :     if (exec->errString != NULL)

	mov	eax, DWORD PTR [esi+80]
	pop	edi
	test	eax, eax
	je	SHORT $LN15@xmlRegFree

; 3598 :         xmlFree(exec->errString);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlRegFree:

; 3599 :     xmlFree(exec);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlRegFree:
	pop	esi

; 3600 : }

	pop	ebp
	ret	0
_xmlRegFreeExecCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegNewExecCtxt
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_callback$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlRegNewExecCtxt PROC					; COMDAT

; 3511 : xmlRegNewExecCtxt(xmlRegexpPtr comp, xmlRegExecCallbacks callback, void *data) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _comp$[ebp]
	test	edi, edi
	je	$LN15@xmlRegNewE

; 3512 :     xmlRegExecCtxtPtr exec;
; 3513 : 
; 3514 :     if (comp == NULL)
; 3515 : 	return(NULL);
; 3516 :     if ((comp->compact == NULL) && (comp->states == NULL))

	cmp	DWORD PTR [edi+40], 0
	jne	SHORT $LN14@xmlRegNewE
	cmp	DWORD PTR [edi+8], 0
	je	$LN15@xmlRegNewE
$LN14@xmlRegNewE:
	push	esi

; 3518 :     exec = (xmlRegExecCtxtPtr) xmlMalloc(sizeof(xmlRegExecCtxt));

	push	92					; 0000005cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3519 :     if (exec == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlRegNewE

; 385  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,

	push	OFFSET ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
	push	eax
	push	eax
	push	3
	push	2
	push	14					; 0000000eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3520 : 	xmlRegexpErrMemory(NULL, "creating execution context");
; 3521 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 3563 : }

	pop	ebp
	ret	0
$LN4@xmlRegNewE:

; 3522 :     }
; 3523 :     memset(exec, 0, sizeof(xmlRegExecCtxt));

	push	92					; 0000005cH
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 3524 :     exec->inputString = NULL;
; 3525 :     exec->index = 0;
; 3526 :     exec->determinist = 1;

	mov	DWORD PTR [esi+4], 1

; 3527 :     exec->maxRollbacks = 0;
; 3528 :     exec->nbRollbacks = 0;
; 3529 :     exec->rollbacks = NULL;
; 3530 :     exec->status = 0;
; 3531 :     exec->comp = comp;

	mov	DWORD PTR [esi+8], edi

; 3532 :     if (comp->compact == NULL)

	cmp	DWORD PTR [edi+40], 0
	jne	SHORT $LN5@xmlRegNewE

; 3533 : 	exec->state = comp->states[0];

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+20], eax
$LN5@xmlRegNewE:

; 3534 :     exec->transno = 0;
; 3535 :     exec->transcount = 0;
; 3536 :     exec->callback = callback;

	mov	eax, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [esi+12], eax

; 3537 :     exec->data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+16], eax

; 3538 :     if (comp->nbCounters > 0) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	jle	SHORT $LN6@xmlRegNewE

; 3539 :         /*
; 3540 : 	 * For error handling, exec->counts is allocated twice the size
; 3541 : 	 * the second half is used to store the data in case of rollback
; 3542 : 	 */
; 3543 : 	exec->counts = (int *) xmlMalloc(comp->nbCounters * sizeof(int)

	shl	eax, 3
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+44], ecx

; 3544 : 	                                 * 2);
; 3545 : 	if (exec->counts == NULL) {

	test	ecx, ecx
	jne	SHORT $LN8@xmlRegNewE

; 3546 : 	    xmlRegexpErrMemory(NULL, "creating execution context");

	push	OFFSET ??_C@_0BL@LMPHHOAL@creating?5execution?5context@
	push	eax
	call	_xmlRegexpErrMemory

; 3547 : 	    xmlFree(exec);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	xor	eax, eax
	pop	esi
	pop	edi

; 3563 : }

	pop	ebp
	ret	0
$LN8@xmlRegNewE:

; 3548 : 	    return(NULL);
; 3549 : 	}
; 3550 :         memset(exec->counts, 0, comp->nbCounters * sizeof(int) * 2);

	mov	eax, DWORD PTR [edi+20]
	shl	eax, 3
	push	eax
	push	0
	push	ecx
	call	_memset

; 3551 : 	exec->errCounts = &exec->counts[comp->nbCounters];

	mov	ecx, DWORD PTR [edi+20]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [eax+ecx*4]

; 3552 :     } else {

	jmp	SHORT $LN7@xmlRegNewE
$LN6@xmlRegNewE:

; 3553 : 	exec->counts = NULL;

	mov	DWORD PTR [esi+44], 0

; 3554 : 	exec->errCounts = NULL;

	xor	eax, eax
$LN7@xmlRegNewE:

; 3555 :     }
; 3556 :     exec->inputStackMax = 0;

	mov	DWORD PTR [esi+84], eax

; 3557 :     exec->inputStackNr = 0;
; 3558 :     exec->inputStack = NULL;
; 3559 :     exec->errStateNo = -1;
; 3560 :     exec->errString = NULL;
; 3561 :     exec->nbPush = 0;
; 3562 :     return(exec);

	mov	eax, esi
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+72], -1
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+88], 0
	pop	esi
	pop	edi

; 3563 : }

	pop	ebp
	ret	0
$LN15@xmlRegNewE:

; 3517 :         return(NULL);

	xor	eax, eax
	pop	edi

; 3563 : }

	pop	ebp
	ret	0
_xmlRegNewExecCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpIsDeterminist
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_xmlRegexpIsDeterminist PROC				; COMDAT

; 5530 : xmlRegexpIsDeterminist(xmlRegexpPtr comp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlRegexpI

; 5531 :     xmlAutomataPtr am;
; 5532 :     int ret;
; 5533 : 
; 5534 :     if (comp == NULL)
; 5535 : 	return(-1);

	or	eax, -1
	pop	esi

; 5559 : }

	pop	ebp
	ret	0
$LN5@xmlRegexpI:

; 5536 :     if (comp->determinist != -1)

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, -1
	jne	$LN1@xmlRegexpI

; 5537 : 	return(comp->determinist);
; 5538 : 
; 5539 :     am = xmlNewAutomata();

	push	ebx
	call	_xmlNewAutomata
	mov	ebx, eax

; 5540 :     if (am->states != NULL) {

	cmp	DWORD PTR [ebx+52], 0
	je	SHORT $LN7@xmlRegexpI

; 5541 : 	int i;
; 5542 : 
; 5543 : 	for (i = 0;i < am->nbStates;i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [ebx+48], edi
	jle	SHORT $LN3@xmlRegexpI
	npad	3
$LL4@xmlRegexpI:

; 5544 : 	    xmlRegFreeState(am->states[i]);

	mov	eax, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [eax+edi*4]

; 898  :     if (state == NULL)

	test	esi, esi
	je	SHORT $LN2@xmlRegexpI

; 899  : 	return;
; 900  : 
; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN11@xmlRegexpI

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlRegexpI:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN12@xmlRegexpI

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRegexpI:

; 905  :     xmlFree(state);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRegexpI:

; 5541 : 	int i;
; 5542 : 
; 5543 : 	for (i = 0;i < am->nbStates;i++)

	inc	edi
	cmp	edi, DWORD PTR [ebx+48]
	jl	SHORT $LL4@xmlRegexpI
	mov	esi, DWORD PTR _comp$[ebp]
$LN3@xmlRegexpI:

; 5545 : 	xmlFree(am->states);

	push	DWORD PTR [ebx+52]
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN7@xmlRegexpI:

; 5546 :     }
; 5547 :     am->nbAtoms = comp->nbAtoms;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+36], eax

; 5548 :     am->atoms = comp->atoms;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ebx+40], eax

; 5549 :     am->nbStates = comp->nbStates;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+48], eax

; 5550 :     am->states = comp->states;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+52], eax

; 5551 :     am->determinist = -1;

	mov	DWORD PTR [ebx+68], -1

; 5552 :     am->flags = comp->flags;

	mov	eax, DWORD PTR [esi+32]

; 5553 :     ret = xmlFAComputesDeterminism(am);

	push	ebx
	mov	DWORD PTR [ebx+76], eax
	call	_xmlFAComputesDeterminism

; 5650 :     xmlRegFreeParserCtxt(am);

	push	ebx

; 5553 :     ret = xmlFAComputesDeterminism(am);

	mov	esi, eax

; 5554 :     am->atoms = NULL;

	mov	DWORD PTR [ebx+40], 0

; 5555 :     am->states = NULL;

	mov	DWORD PTR [ebx+52], 0

; 5650 :     xmlRegFreeParserCtxt(am);

	call	_xmlRegFreeParserCtxt

; 5556 :     xmlFreeAutomata(am);
; 5557 :     comp->determinist = ret;

	mov	eax, DWORD PTR _comp$[ebp]

; 5650 :     xmlRegFreeParserCtxt(am);

	add	esp, 8

; 5556 :     xmlFreeAutomata(am);
; 5557 :     comp->determinist = ret;

	mov	DWORD PTR [eax+28], esi

; 5558 :     return(ret);

	mov	eax, esi
	pop	ebx
$LN1@xmlRegexpI:
	pop	esi

; 5559 : }

	pop	ebp
	ret	0
_xmlRegexpIsDeterminist ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpPrint
_TEXT	SEGMENT
_output$ = 8						; size = 4
_regexp$ = 12						; size = 4
_xmlRegexpPrint PROC					; COMDAT

; 5426 : xmlRegexpPrint(FILE *output, xmlRegexpPtr regexp) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _output$[ebp]
	test	edi, edi
	je	$LN9@xmlRegexpP

; 5427 :     int i;
; 5428 : 
; 5429 :     if (output == NULL)
; 5430 :         return;
; 5431 :     fprintf(output, " regexp: ");

	push	esi
	push	OFFSET ??_C@_09BNLLHCCB@?5regexp?3?5@
	push	edi
	call	_fprintf

; 5432 :     if (regexp == NULL) {

	mov	esi, DWORD PTR _regexp$[ebp]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN12@xmlRegexpP

; 5433 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	edi

; 5451 : 		                                regexp->counters[i].max);
; 5452 :     }
; 5453 : }

	pop	ebp
	ret	0
$LN12@xmlRegexpP:
	push	ebx

; 5434 : 	return;
; 5435 :     }
; 5436 :     fprintf(output, "'%s' ", regexp->string);

	push	DWORD PTR [esi]
	push	OFFSET ??_C@_05IMLJLABD@?8?$CFs?8?5@
	push	edi
	call	_fprintf

; 5437 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf

; 5438 :     fprintf(output, "%d atoms:\n", regexp->nbAtoms);

	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_0L@PLBJGPP@?$CFd?5atoms?3?6@
	push	edi
	call	_fprintf

; 5439 :     for (i = 0;i < regexp->nbAtoms; i++) {

	xor	ebx, ebx
	add	esp, 32					; 00000020H
	cmp	DWORD PTR [esi+12], ebx
	jle	SHORT $LN3@xmlRegexpP
$LL4@xmlRegexpP:

; 5440 : 	fprintf(output, " %02d ", i);

	push	ebx
	push	OFFSET ??_C@_06NLBGECGK@?5?$CF02d?5@
	push	edi
	call	_fprintf

; 5441 : 	xmlRegPrintAtom(output, regexp->atoms[i]);

	mov	eax, DWORD PTR [esi+16]
	push	DWORD PTR [eax+ebx*4]
	push	edi
	call	_xmlRegPrintAtom
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, DWORD PTR [esi+12]
	jl	SHORT $LL4@xmlRegexpP
$LN3@xmlRegexpP:

; 5442 :     }
; 5443 :     fprintf(output, "%d states:", regexp->nbStates);

	push	DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@LDKKLMNF@?$CFd?5states?3@
	push	edi
	call	_fprintf

; 5444 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf

; 5445 :     for (i = 0;i < regexp->nbStates; i++) {

	xor	ebx, ebx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN6@xmlRegexpP
$LL7@xmlRegexpP:

; 5446 : 	xmlRegPrintState(output, regexp->states[i]);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+ebx*4]
	push	edi
	call	_xmlRegPrintState
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [esi+4]
	jl	SHORT $LL7@xmlRegexpP
$LN6@xmlRegexpP:

; 5447 :     }
; 5448 :     fprintf(output, "%d counters:\n", regexp->nbCounters);

	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_0O@EOOCDOKK@?$CFd?5counters?3?6@
	push	edi
	call	_fprintf

; 5449 :     for (i = 0;i < regexp->nbCounters; i++) {

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+20], ebx
	jle	SHORT $LN27@xmlRegexpP
$LL10@xmlRegexpP:

; 5450 : 	fprintf(output, " %d: min %d max %d\n", i, regexp->counters[i].min,

	mov	eax, DWORD PTR [esi+24]
	push	DWORD PTR [eax+ebx*8+4]
	push	DWORD PTR [eax+ebx*8]
	push	ebx
	push	OFFSET ??_C@_0BE@LNLBBGGH@?5?$CFd?3?5min?5?$CFd?5max?5?$CFd?6@
	push	edi
	call	_fprintf
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, DWORD PTR [esi+20]
	jl	SHORT $LL10@xmlRegexpP
$LN27@xmlRegexpP:
	pop	ebx
	pop	esi
$LN9@xmlRegexpP:
	pop	edi

; 5451 : 		                                regexp->counters[i].max);
; 5452 :     }
; 5453 : }

	pop	ebp
	ret	0
_xmlRegexpPrint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpExec
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlRegexpExec PROC					; COMDAT

; 5515 : xmlRegexpExec(xmlRegexpPtr comp, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _comp$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlRegexpE

; 5516 :     if ((comp == NULL) || (content == NULL))

	mov	eax, DWORD PTR _content$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlRegexpE

; 5518 :     return(xmlFARegExec(comp, content));

	mov	DWORD PTR _content$[ebp], eax
	mov	DWORD PTR _comp$[ebp], ecx

; 5519 : }

	pop	ebp

; 5518 :     return(xmlFARegExec(comp, content));

	jmp	_xmlFARegExec
$LN3@xmlRegexpE:

; 5517 : 	return(-1);

	or	eax, -1

; 5519 : }

	pop	ebp
	ret	0
_xmlRegexpExec ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegFreeRegexp
_TEXT	SEGMENT
_regexp$ = 8						; size = 4
_xmlRegFreeRegexp PROC					; COMDAT

; 5568 : xmlRegFreeRegexp(xmlRegexpPtr regexp) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _regexp$[ebp]
	test	esi, esi
	je	$LN1@xmlRegFree

; 5569 :     int i;
; 5570 :     if (regexp == NULL)
; 5571 : 	return;
; 5572 : 
; 5573 :     if (regexp->string != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@xmlRegFree

; 5574 : 	xmlFree(regexp->string);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlRegFree:

; 5575 :     if (regexp->states != NULL) {

	cmp	DWORD PTR [esi+8], 0
	push	edi
	je	SHORT $LN13@xmlRegFree

; 5576 : 	for (i = 0;i < regexp->nbStates;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN3@xmlRegFree
	push	ebx
$LL4@xmlRegFree:

; 5577 : 	    xmlRegFreeState(regexp->states[i]);

	mov	eax, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [eax+edi*4]

; 898  :     if (state == NULL)

	test	ebx, ebx
	je	SHORT $LN2@xmlRegFree

; 899  : 	return;
; 900  : 
; 901  :     if (state->trans != NULL)

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN22@xmlRegFree

; 902  : 	xmlFree(state->trans);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlRegFree:

; 903  :     if (state->transTo != NULL)

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN23@xmlRegFree

; 904  : 	xmlFree(state->transTo);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlRegFree:

; 905  :     xmlFree(state);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlRegFree:

; 5576 : 	for (i = 0;i < regexp->nbStates;i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL4@xmlRegFree
	pop	ebx
$LN3@xmlRegFree:

; 5578 : 	xmlFree(regexp->states);

	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlRegFree:

; 5579 :     }
; 5580 :     if (regexp->atoms != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN14@xmlRegFree

; 5581 : 	for (i = 0;i < regexp->nbAtoms;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN6@xmlRegFree
	npad	1
$LL7@xmlRegFree:

; 5582 : 	    xmlRegFreeAtom(regexp->atoms[i]);

	mov	eax, DWORD PTR [esi+16]
	push	DWORD PTR [eax+edi*4]
	call	_xmlRegFreeAtom
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LL7@xmlRegFree
	mov	eax, DWORD PTR [esi+16]
$LN6@xmlRegFree:

; 5583 : 	xmlFree(regexp->atoms);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlRegFree:

; 5584 :     }
; 5585 :     if (regexp->counters != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN15@xmlRegFree

; 5586 : 	xmlFree(regexp->counters);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlRegFree:

; 5587 :     if (regexp->compact != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN16@xmlRegFree

; 5588 : 	xmlFree(regexp->compact);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlRegFree:

; 5589 :     if (regexp->transdata != NULL)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN17@xmlRegFree

; 5590 : 	xmlFree(regexp->transdata);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlRegFree:

; 5591 :     if (regexp->stringMap != NULL) {

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN18@xmlRegFree

; 5592 : 	for (i = 0; i < regexp->nbstrings;i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+48], edi
	jle	SHORT $LN9@xmlRegFree
$LL10@xmlRegFree:

; 5593 : 	    xmlFree(regexp->stringMap[i]);

	mov	eax, DWORD PTR [esi+52]
	push	DWORD PTR [eax+edi*4]
	call	DWORD PTR _xmlFree
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+48]
	jl	SHORT $LL10@xmlRegFree
	mov	eax, DWORD PTR [esi+52]
$LN9@xmlRegFree:

; 5594 : 	xmlFree(regexp->stringMap);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlRegFree:

; 5595 :     }
; 5596 : 
; 5597 :     xmlFree(regexp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN1@xmlRegFree:
	pop	esi

; 5598 : }

	pop	ebp
	ret	0
_xmlRegFreeRegexp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlregexp.c
;	COMDAT _xmlRegexpCompile
_TEXT	SEGMENT
_regexp$ = 8						; size = 4
_xmlRegexpCompile PROC					; COMDAT

; 5466 : xmlRegexpCompile(const xmlChar *regexp) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __F6DD4902_xmlregexp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _regexp$[ebp]
	call	_xmlRegNewParserCtxt
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	$LN8@xmlRegexpC

; 5467 :     xmlRegexpPtr ret;
; 5468 :     xmlRegParserCtxtPtr ctxt;
; 5469 : 
; 5470 :     ctxt = xmlRegNewParserCtxt(regexp);
; 5471 :     if (ctxt == NULL)
; 5472 : 	return(NULL);
; 5473 : 
; 5474 :     /* initialize the parser */
; 5475 :     ctxt->end = NULL;

	push	edi
	mov	DWORD PTR [edi+20], 0

; 5476 :     ctxt->start = ctxt->state = xmlRegNewState(ctxt);

	call	_xmlRegNewState

; 5477 :     xmlRegStatePush(ctxt, ctxt->start);

	push	eax
	push	edi
	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+16], eax
	call	_xmlRegStatePush

; 5478 : 
; 5479 :     /* parse the expression building an automata */
; 5480 :     xmlFAParseRegExp(ctxt, 1);

	push	1
	push	edi
	call	_xmlFAParseRegExp

; 5481 :     if (CUR != 0) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 20					; 00000014H
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN3@xmlRegexpC

; 5482 : 	ERROR("xmlFAParseRegExp: extra characters");

	push	OFFSET ??_C@_0CD@GPPIOFAL@xmlFAParseRegExp?3?5extra?5charact@
	push	edi
	mov	DWORD PTR [edi+8], 1450			; 000005aaH
	call	_xmlRegexpErrCompile
	add	esp, 8
$LN3@xmlRegexpC:

; 5483 :     }
; 5484 :     if (ctxt->error != 0) {

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN7@xmlRegexpC

; 5485 : 	xmlRegFreeParserCtxt(ctxt);
; 5486 : 	return(NULL);
; 5487 :     }
; 5488 :     ctxt->end = ctxt->state;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+20], eax

; 5489 :     ctxt->start->type = XML_REGEXP_START_STATE;

	mov	eax, DWORD PTR [edi+16]

; 5490 :     ctxt->end->type = XML_REGEXP_FINAL_STATE;
; 5491 : 
; 5492 :     /* remove the Epsilon except for counted transitions */
; 5493 :     xmlFAEliminateEpsilonTransitions(ctxt);

	push	edi
	mov	DWORD PTR [eax], 1
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax], 2
	call	_xmlFAEliminateEpsilonTransitions
	add	esp, 4

; 5494 : 
; 5495 : 
; 5496 :     if (ctxt->error != 0) {

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN7@xmlRegexpC

; 5498 : 	return(NULL);
; 5499 :     }
; 5500 :     ret = xmlRegEpxFromParse(ctxt);

	push	esi
	push	edi
	call	_xmlRegEpxFromParse

; 5501 :     xmlRegFreeParserCtxt(ctxt);

	push	edi
	mov	esi, eax
	call	_xmlRegFreeParserCtxt
	add	esp, 8

; 5502 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5503 : }

	pop	ebp
	ret	0
$LN7@xmlRegexpC:

; 5497 : 	xmlRegFreeParserCtxt(ctxt);

	push	edi
	call	_xmlRegFreeParserCtxt
	add	esp, 4
$LN8@xmlRegexpC:

; 5503 : }

	xor	eax, eax
	pop	edi
	pop	ebp
	ret	0
_xmlRegexpCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	esi, eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	edi
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 28					; 0000001cH

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);
; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

	pop	edi
	pop	esi

; 961  :     }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
