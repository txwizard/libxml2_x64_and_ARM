; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\parserInternals.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__A40A425D_stat@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__3A8479ED_parserinternals@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlCheckVersion
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlParserInputRead
PUBLIC	_xmlParserInputGrow
PUBLIC	_xmlSubstituteEntitiesDefault
PUBLIC	_xmlKeepBlanksDefault
PUBLIC	_xmlPedanticParserDefault
PUBLIC	_xmlLineNumbersDefault
PUBLIC	_xmlNewParserCtxt
PUBLIC	_xmlInitParserCtxt
PUBLIC	_xmlClearParserCtxt
PUBLIC	_xmlFreeParserCtxt
PUBLIC	_xmlNewIOInputStream
PUBLIC	_xmlParserFindNodeInfo
PUBLIC	_xmlInitNodeInfoSeq
PUBLIC	_xmlClearNodeInfoSeq
PUBLIC	_xmlParserFindNodeInfoIndex
PUBLIC	_xmlParserAddNodeInfo
PUBLIC	_xmlIsLetter
PUBLIC	_xmlSwitchEncoding
PUBLIC	_xmlSwitchToEncoding
PUBLIC	_xmlSwitchInputEncoding
PUBLIC	___xmlErrEncoding
PUBLIC	_xmlNewStringInputStream
PUBLIC	_xmlNewEntityInputStream
PUBLIC	_xmlFreeInputStream
PUBLIC	_xmlNewInputFromFile
PUBLIC	_xmlNewInputStream
PUBLIC	_xmlStringCurrentChar
PUBLIC	_xmlCurrentChar
PUBLIC	_xmlCopyCharMultiByte
PUBLIC	_xmlCopyChar
PUBLIC	_xmlNextChar
PUBLIC	_xmlParserInputShrink
PUBLIC	_xmlErrMemory
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@ ; `string'
PUBLIC	??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@ ; `string'
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@ ; `string'
PUBLIC	??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@ ; `string'
PUBLIC	??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ ; `string'
PUBLIC	??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@ ; `string'
PUBLIC	??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@ ; `string'
PUBLIC	??_C@_0BC@NFNLFCFA@encoding?5unknown?6@		; `string'
PUBLIC	??_C@_0BD@IJIIAAMB@USC4?5little?5endian@	; `string'
PUBLIC	??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BA@ELDAKMNC@USC4?5big?5endian@		; `string'
PUBLIC	??_C@_06JJAKJGEC@EBCDIC@			; `string'
PUBLIC	??_C@_09GAABMJEL@UCS4?52143@			; `string'
PUBLIC	??_C@_09HFGPODGD@UCS4?53412@			; `string'
PUBLIC	??_C@_04MDAFHLBC@UCS2@				; `string'
PUBLIC	??_C@_0M@LMIFKILO@ISO?92022?9JP@		; `string'
PUBLIC	??_C@_09LOKLFMHN@Shift_JIS@			; `string'
PUBLIC	??_C@_06KCFOODCD@EUC?9JP@			; `string'
PUBLIC	??_C@_08NBDJLNFA@UTF?916LE@			; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_08NLKHJAFK@UTF?916BE@			; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@ ; `string'
PUBLIC	??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@ ; `string'
PUBLIC	??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@ ; `string'
PUBLIC	??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@ ; `string'
PUBLIC	??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@	; `string'
PUBLIC	??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@ ; `string'
PUBLIC	??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@ ; `string'
PUBLIC	??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@ ; `string'
PUBLIC	??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@ ; `string'
PUBLIC	??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@ ; `string'
PUBLIC	??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@ ; `string'
PUBLIC	??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@ ; `string'
PUBLIC	??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ ; `string'
PUBLIC	??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@ ; `string'
PUBLIC	??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@ ; `string'
PUBLIC	??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@ ; `string'
PUBLIC	??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___xmlLoaderErr:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufEnd:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictSetLimit:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashDefaultDeallocator:PROC
EXTRN	_xmlParserValidityError:PROC
EXTRN	_xmlParserValidityWarning:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlGetCharEncodingHandler:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlParserInputBufferRead:PROC
EXTRN	_xmlParserInputBufferGrow:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlCheckHTTPInput:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_xmlStopParser:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	_xmlCtxtReset:PROC
EXTRN	_xmlSAX2IgnorableWhitespace:PROC
EXTRN	_xmlSAXVersion:PROC
EXTRN	_xmlDefaultSAXHandlerInit:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlDoValidityCheckingDefaultValue:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlGetWarningsDefaultValue:PROC
EXTRN	___xmlIndentTreeOutput:PROC
EXTRN	___xmlKeepBlanksDefaultValue:PROC
EXTRN	___xmlLineNumbersDefaultValue:PROC
EXTRN	___xmlLoadExtDtdDefaultValue:PROC
EXTRN	___xmlParserDebugEntities:PROC
EXTRN	___xmlPedanticParserDefaultValue:PROC
EXTRN	___xmlSubstituteEntitiesDefaultValue:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_inputPop:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCatalogFreeLocal:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufIsEmpty:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_xmlCharEncFirstLineInput:PROC
EXTRN	_xmlCharEncInput:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@
CONST	SEGMENT
??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@ DB 'failed to allocate'
	DB	' buffer', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@
CONST	SEGMENT
??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@ DB 'cannot alloca'
	DB	'te parser context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
CONST	SEGMENT
??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@ DB 'cannot initial'
	DB	'ize parser context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@
CONST	SEGMENT
??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@ DB 'Got NULL parser cont'
	DB	'ext', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
CONST	SEGMENT
??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ DB 'failed to lo'
	DB	'ad external entity "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@
CONST	SEGMENT
??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@ DB 'failed to lo'
	DB	'ad external entity: NULL filename ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@ DB 'new input from '
	DB	'file: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@
CONST	SEGMENT
??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@ DB 'new fixed input:'
	DB	' %.30s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@
CONST	SEGMENT
??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@ DB 'xmlNewStringInp'
	DB	'utStream string = NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@
CONST	SEGMENT
??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@ DB 'Predefined'
	DB	' entity %s without content !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@
CONST	SEGMENT
??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@ DB 'Internal p'
	DB	'arameter entity %s without content !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@
CONST	SEGMENT
??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@ DB 'Internal e'
	DB	'ntity %s without content !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@ DB 'Cannot parse entit'
	DB	'y %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@ DB 'new input fro'
	DB	'm entity: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@
CONST	SEGMENT
??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@ DB 'xmlNewEntityInp'
	DB	'utStream entity = NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@
CONST	SEGMENT
??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@ DB 'new input from I/O', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
CONST	SEGMENT
??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@ DB 'couldn''t a'
	DB	'llocate a new input stream', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@
CONST	SEGMENT
??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@ DB 'xmlSwitchToE'
	DB	'ncoding : no input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@
CONST	SEGMENT
??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@ DB 'switching en'
	DB	'coding : no input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@
CONST	SEGMENT
??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@ DB 'switching enc'
	DB	'oding: encoder error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLKHJAFK@UTF?916BE@
CONST	SEGMENT
??_C@_08NLKHJAFK@UTF?916BE@ DB 'UTF-16BE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBDJLNFA@UTF?916LE@
CONST	SEGMENT
??_C@_08NBDJLNFA@UTF?916LE@ DB 'UTF-16LE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFOODCD@EUC?9JP@
CONST	SEGMENT
??_C@_06KCFOODCD@EUC?9JP@ DB 'EUC-JP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOKLFMHN@Shift_JIS@
CONST	SEGMENT
??_C@_09LOKLFMHN@Shift_JIS@ DB 'Shift_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMIFKILO@ISO?92022?9JP@
CONST	SEGMENT
??_C@_0M@LMIFKILO@ISO?92022?9JP@ DB 'ISO-2022-JP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDAFHLBC@UCS2@
CONST	SEGMENT
??_C@_04MDAFHLBC@UCS2@ DB 'UCS2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFGPODGD@UCS4?53412@
CONST	SEGMENT
??_C@_09HFGPODGD@UCS4?53412@ DB 'UCS4 3412', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAABMJEL@UCS4?52143@
CONST	SEGMENT
??_C@_09GAABMJEL@UCS4?52143@ DB 'UCS4 2143', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJAKJGEC@EBCDIC@
CONST	SEGMENT
??_C@_06JJAKJGEC@EBCDIC@ DB 'EBCDIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELDAKMNC@USC4?5big?5endian@
CONST	SEGMENT
??_C@_0BA@ELDAKMNC@USC4?5big?5endian@ DB 'USC4 big endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@ DB 'encoding not su'
	DB	'pported %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IJIIAAMB@USC4?5little?5endian@
CONST	SEGMENT
??_C@_0BD@IJIIAAMB@USC4?5little?5endian@ DB 'USC4 little endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFNLFCFA@encoding?5unknown?6@
CONST	SEGMENT
??_C@_0BC@NFNLFCFA@encoding?5unknown?6@ DB 'encoding unknown', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@
CONST	SEGMENT
??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@ DB 'Internal error'
	DB	', xmlCopyCharMultiByte 0x%X out of bound', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@
CONST	SEGMENT
??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@ DB 'Char 0x0 out'
	DB	' of allowed range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is no'
	DB	't proper UTF-8, indicate encoding !', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
CONST	SEGMENT
??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ DB 'B'
	DB	'ytes: 0x%02X 0x%02X 0x%02X 0x%02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is n'
	DB	'ot proper UTF-8, indicate encoding !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
CONST	SEGMENT
??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@ DB 'Char 0x%'
	DB	'X out of allowed range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@
CONST	SEGMENT
??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@ DB 'Parser input'
	DB	' data memory error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@
CONST	SEGMENT
??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@ DB 'Warning: prog'
	DB	'ram compiled against libxml %d using older %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
CONST	SEGMENT
??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@ DB 'Fatal: progra'
	DB	'm compiled against libxml %d using libxml %d', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchInputEncodingInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_handler$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlSwitchInputEncodingInt PROC				; COMDAT

; 1131 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _handler$[ebp]
	test	ebx, ebx
	je	$LN18@xmlSwitchI

; 1132 :     int nbchars;
; 1133 : 
; 1134 :     if (handler == NULL)
; 1135 :         return (-1);
; 1136 :     if (input == NULL)

	mov	edi, DWORD PTR _input$[ebp]
	test	edi, edi
	je	$LN18@xmlSwitchI

; 1137 :         return (-1);
; 1138 :     if (input->buf != NULL) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN4@xmlSwitchI

; 1139 :         if (input->buf->encoder != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	push	esi
	test	ecx, ecx
	je	SHORT $LN6@xmlSwitchI

; 1140 :             /*
; 1141 :              * Check in case the auto encoding detetection triggered
; 1142 :              * in already.
; 1143 :              */
; 1144 :             if (input->buf->encoder == handler)

	cmp	ecx, ebx
	je	SHORT $LN8@xmlSwitchI

; 1145 :                 return (0);
; 1146 : 
; 1147 :             /*
; 1148 :              * "UTF-16" can be used for both LE and BE
; 1149 :              if ((!xmlStrncmp(BAD_CAST input->buf->encoder->name,
; 1150 :              BAD_CAST "UTF-16", 6)) &&
; 1151 :              (!xmlStrncmp(BAD_CAST handler->name,
; 1152 :              BAD_CAST "UTF-16", 6))) {
; 1153 :              return(0);
; 1154 :              }
; 1155 :              */
; 1156 : 
; 1157 :             /*
; 1158 :              * Note: this is a bit dangerous, but that's what it
; 1159 :              * takes to use nearly compatible signature for different
; 1160 :              * encodings.
; 1161 :              */
; 1162 :             xmlCharEncCloseFunc(input->buf->encoder);

	push	ecx
	call	_xmlCharEncCloseFunc

; 1163 :             input->buf->encoder = handler;

	mov	eax, DWORD PTR [edi]
	add	esp, 4
	mov	DWORD PTR [eax+12], ebx
$LN8@xmlSwitchI:

; 1164 :             return (0);

	pop	esi
	pop	edi
	xor	eax, eax

; 1256 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlSwitchI:

; 1165 :         }
; 1166 :         input->buf->encoder = handler;

	mov	DWORD PTR [eax+12], ebx

; 1167 : 
; 1168 :         /*
; 1169 :          * Is there already some content down the pipe to convert ?
; 1170 :          */
; 1171 :         if (xmlBufIsEmpty(input->buf->buffer) == 0) {

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+16]
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@xmlSwitchI

; 1172 :             int processed;
; 1173 : 	    unsigned int use;
; 1174 : 
; 1175 :             /*
; 1176 :              * Specific handling of the Byte Order Mark for
; 1177 :              * UTF-16
; 1178 :              */
; 1179 :             if ((handler->name != NULL) &&
; 1180 :                 (!strcmp(handler->name, "UTF-16LE") ||
; 1181 :                  !strcmp(handler->name, "UTF-16")) &&
; 1182 :                 (input->cur[0] == 0xFF) && (input->cur[1] == 0xFE)) {

	mov	eax, DWORD PTR [ebx]
	mov	esi, eax
	test	eax, eax
	je	SHORT $LN9@xmlSwitchI
	mov	ecx, OFFSET ??_C@_08NBDJLNFA@UTF?916LE@
$LL19@xmlSwitchI:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN20@xmlSwitchI
	test	dl, dl
	je	SHORT $LN21@xmlSwitchI
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN20@xmlSwitchI
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL19@xmlSwitchI
$LN21@xmlSwitchI:
	xor	eax, eax
	jmp	SHORT $LN22@xmlSwitchI
$LN20@xmlSwitchI:
	sbb	eax, eax
	or	eax, 1
$LN22@xmlSwitchI:
	test	eax, eax
	mov	eax, DWORD PTR [ebx]
	je	SHORT $LN10@xmlSwitchI
	mov	ecx, OFFSET ??_C@_06KNDPGIKI@UTF?916@
$LL23@xmlSwitchI:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN24@xmlSwitchI
	test	dl, dl
	je	SHORT $LN25@xmlSwitchI
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN24@xmlSwitchI
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL23@xmlSwitchI
$LN25@xmlSwitchI:
	xor	ecx, ecx
	jmp	SHORT $LN26@xmlSwitchI
$LN24@xmlSwitchI:
	sbb	ecx, ecx
	or	ecx, 1
$LN26@xmlSwitchI:
	mov	eax, DWORD PTR [ebx]
	mov	esi, eax
	test	ecx, ecx
	jne	SHORT $LN9@xmlSwitchI
$LN10@xmlSwitchI:
	mov	ecx, DWORD PTR [edi+16]
	mov	esi, eax
	cmp	BYTE PTR [ecx], 255			; 000000ffH
	jne	SHORT $LN9@xmlSwitchI
	cmp	BYTE PTR [ecx+1], 254			; 000000feH
	jne	SHORT $LN9@xmlSwitchI

; 1183 :                 input->cur += 2;

	lea	eax, DWORD PTR [ecx+2]
	mov	DWORD PTR [edi+16], eax
	mov	esi, DWORD PTR [ebx]
$LN9@xmlSwitchI:

; 1184 :             }
; 1185 :             if ((handler->name != NULL) &&
; 1186 :                 (!strcmp(handler->name, "UTF-16BE")) &&
; 1187 :                 (input->cur[0] == 0xFE) && (input->cur[1] == 0xFF)) {

	test	esi, esi
	je	$LN12@xmlSwitchI
	mov	ecx, OFFSET ??_C@_08NLKHJAFK@UTF?916BE@
	mov	eax, esi
$LL27@xmlSwitchI:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN28@xmlSwitchI
	test	dl, dl
	je	SHORT $LN29@xmlSwitchI
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN28@xmlSwitchI
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@xmlSwitchI
$LN29@xmlSwitchI:
	xor	ecx, ecx
	jmp	SHORT $LN30@xmlSwitchI
$LN28@xmlSwitchI:
	sbb	ecx, ecx
	or	ecx, 1
$LN30@xmlSwitchI:
	mov	eax, esi
	test	ecx, ecx
	jne	SHORT $LN11@xmlSwitchI
	mov	ecx, DWORD PTR [edi+16]
	cmp	BYTE PTR [ecx], 254			; 000000feH
	jne	SHORT $LN11@xmlSwitchI
	cmp	BYTE PTR [ecx+1], 255			; 000000ffH
	jne	SHORT $LN11@xmlSwitchI

; 1188 :                 input->cur += 2;

	lea	eax, DWORD PTR [ecx+2]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [ebx]
$LN11@xmlSwitchI:

; 1189 :             }
; 1190 :             /*
; 1191 :              * Errata on XML-1.0 June 20 2001
; 1192 :              * Specific handling of the Byte Order Mark for
; 1193 :              * UTF-8
; 1194 :              */
; 1195 :             if ((handler->name != NULL) &&
; 1196 :                 (!strcmp(handler->name, "UTF-8")) &&
; 1197 :                 (input->cur[0] == 0xEF) &&
; 1198 :                 (input->cur[1] == 0xBB) && (input->cur[2] == 0xBF)) {

	test	eax, eax
	je	SHORT $LN12@xmlSwitchI
	mov	ecx, OFFSET ??_C@_05EGJIMALK@UTF?98@
	npad	1
$LL31@xmlSwitchI:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN32@xmlSwitchI
	test	dl, dl
	je	SHORT $LN33@xmlSwitchI
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN32@xmlSwitchI
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL31@xmlSwitchI
$LN33@xmlSwitchI:
	xor	eax, eax
	jmp	SHORT $LN34@xmlSwitchI
$LN32@xmlSwitchI:
	sbb	eax, eax
	or	eax, 1
$LN34@xmlSwitchI:
	test	eax, eax
	jne	SHORT $LN12@xmlSwitchI
	mov	eax, DWORD PTR [edi+16]
	cmp	BYTE PTR [eax], 239			; 000000efH
	jne	SHORT $LN12@xmlSwitchI
	cmp	BYTE PTR [eax+1], 187			; 000000bbH
	jne	SHORT $LN12@xmlSwitchI
	cmp	BYTE PTR [eax+2], 191			; 000000bfH
	jne	SHORT $LN12@xmlSwitchI

; 1199 :                 input->cur += 3;

	add	eax, 3
	mov	DWORD PTR [edi+16], eax
$LN12@xmlSwitchI:

; 1200 :             }
; 1201 : 
; 1202 :             /*
; 1203 :              * Shrink the current input buffer.
; 1204 :              * Move it as the raw buffer and create a new input buffer
; 1205 :              */
; 1206 :             processed = input->cur - input->base;

	mov	esi, DWORD PTR [edi+16]

; 1207 :             xmlBufShrink(input->buf->buffer, processed);

	mov	eax, DWORD PTR [edi]
	sub	esi, DWORD PTR [edi+12]
	push	esi
	push	DWORD PTR [eax+16]
	call	_xmlBufShrink

; 1208 :             input->buf->raw = input->buf->buffer;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+20], eax

; 1209 :             input->buf->buffer = xmlBufCreate();

	call	_xmlBufCreate
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+16], eax

; 1210 : 	    input->buf->rawconsumed = processed;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+32], esi

; 1211 : 	    use = xmlBufUse(input->buf->raw);

	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+20]
	call	_xmlBufUse

; 1212 : 
; 1213 :             if (ctxt->html) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, eax
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN13@xmlSwitchI

; 1214 :                 /*
; 1215 :                  * convert as much as possible of the buffer
; 1216 :                  */
; 1217 :                 nbchars = xmlCharEncInput(input->buf, 1);

	push	1
	push	eax
	call	_xmlCharEncInput

; 1218 :             } else {

	jmp	SHORT $LN37@xmlSwitchI
$LN13@xmlSwitchI:

; 1219 :                 /*
; 1220 :                  * convert just enough to get
; 1221 :                  * '<?xml version="1.0" encoding="xxx"?>'
; 1222 :                  * parsed with the autodetected encoding
; 1223 :                  * into the parser reading buffer.
; 1224 :                  */
; 1225 :                 nbchars = xmlCharEncFirstLineInput(input->buf, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlCharEncFirstLineInput
$LN37@xmlSwitchI:

; 1226 :             }
; 1227 :             xmlBufResetInput(input->buf->buffer, input);

	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR [edi]
	push	edi
	push	DWORD PTR [eax+16]
	call	_xmlBufResetInput
	add	esp, 8

; 1228 :             if (nbchars < 0) {

	test	esi, esi
	jns	SHORT $LN15@xmlSwitchI

; 1229 :                 xmlErrInternal(ctxt,

	push	0
	push	OFFSET ??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1230 :                                "switching encoding: encoder error\n",
; 1231 :                                NULL);
; 1232 :                 return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 1256 : }

	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlSwitchI:

; 1233 :             }
; 1234 : 	    input->buf->rawconsumed += use - xmlBufUse(input->buf->raw);

	mov	esi, DWORD PTR [edi]
	push	DWORD PTR [esi+20]
	call	_xmlBufUse
	add	esp, 4
	sub	ebx, eax
	add	DWORD PTR [esi+32], ebx
	xor	eax, eax
	pop	esi
	pop	edi

; 1256 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSwitchI:

; 1235 :         }
; 1236 :         return (0);
; 1237 :     } else if (input->length == 0) {

	cmp	DWORD PTR [edi+24], 0
	jne	SHORT $LN16@xmlSwitchI

; 1238 : 	/*
; 1239 : 	 * When parsing a static memory array one must know the
; 1240 : 	 * size to be able to convert the buffer.
; 1241 : 	 */
; 1242 : 	xmlErrInternal(ctxt, "switching encoding : no input\n", NULL);

	push	0
	push	OFFSET ??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal

; 1243 :         /*
; 1244 :          * Callers assume that the input buffer takes ownership of the
; 1245 :          * encoding handler. xmlCharEncCloseFunc frees unregistered
; 1246 :          * handlers and avoids a memory leak.
; 1247 :          */
; 1248 :         xmlCharEncCloseFunc(handler);

	push	ebx
	call	_xmlCharEncCloseFunc
	add	esp, 16					; 00000010H
$LN18@xmlSwitchI:

; 1256 : }

	pop	edi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlSwitchI:

; 1249 : 	return (-1);
; 1250 :     }
; 1251 :     /*
; 1252 :      * We should actually raise an error here, see issue #34.
; 1253 :      */
; 1254 :     xmlCharEncCloseFunc(handler);

	push	ebx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 1255 :     return (0);

	xor	eax, eax
	pop	edi

; 1256 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSwitchInputEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchToEncodingInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_handler$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSwitchToEncodingInt PROC				; COMDAT

; 1290 :                        xmlCharEncodingHandlerPtr handler, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _handler$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSwitchT

; 1291 :     int ret = 0;
; 1292 : 
; 1293 :     if (handler != NULL) {
; 1294 :         if (ctxt->input != NULL) {

	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN4@xmlSwitchT

; 1295 : 	    ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	push	ecx
	push	esi
	call	_xmlSwitchInputEncodingInt
	add	esp, 16					; 00000010H

; 1300 : 	}
; 1301 : 	/*
; 1302 : 	 * The parsing is now done in UTF8 natively
; 1303 : 	 */
; 1304 : 	ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	DWORD PTR [esi+256], 1
	pop	esi

; 1307 :     return(ret);
; 1308 : }

	pop	ebp
	ret	0
$LN4@xmlSwitchT:

; 1296 : 	} else {
; 1297 : 	    xmlErrInternal(ctxt, "xmlSwitchToEncoding : no input\n",

	push	0
	push	OFFSET ??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@
	push	esi
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1298 : 	                   NULL);
; 1299 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1307 :     return(ret);
; 1308 : }

	pop	ebp
	ret	0
$LN2@xmlSwitchT:

; 1305 :     } else
; 1306 : 	return(-1);

	or	eax, -1

; 1307 :     return(ret);
; 1308 : }

	pop	ebp
	ret	0
_xmlSwitchToEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrEncodingInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlErrEncodingInt PROC					; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlErrEnco

; 204  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlErrEnco
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlErrEnco
$LN2@xmlErrEnco:

; 205  :         (ctxt->instate == XML_PARSER_EOF))
; 206  : 	return;
; 207  :     if (ctxt != NULL)
; 208  :         ctxt->errNo = error;

	mov	DWORD PTR [esi+84], ecx
$LN3@xmlErrEnco:

; 209  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	ecx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 210  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 211  :                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
; 212  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlErrEnco

; 213  :         ctxt->wellFormed = 0;
; 214  :         if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlErrEnco

; 215  :             ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlErrEnco:
	pop	esi

; 216  :     }
; 217  : }

	pop	ebp
	ret	0
_xmlErrEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrInternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlErrInternal PROC					; COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlErrInte

; 175  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlErrInte
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlErrInte
$LN2@xmlErrInte:

; 176  :         (ctxt->instate == XML_PARSER_EOF))
; 177  : 	return;
; 178  :     if (ctxt != NULL)
; 179  :         ctxt->errNo = XML_ERR_INTERNAL_ERROR;

	mov	DWORD PTR [esi+84], 1
$LN3@xmlErrInte:

; 180  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	1
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 181  :                     ctxt, NULL, XML_FROM_PARSER, XML_ERR_INTERNAL_ERROR,
; 182  :                     XML_ERR_FATAL, NULL, 0, (const char *) str, NULL, NULL,
; 183  :                     0, 0, msg, str);
; 184  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlErrInte

; 185  :         ctxt->wellFormed = 0;
; 186  :         if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlErrInte

; 187  :             ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlErrInte:
	pop	esi

; 188  :     }
; 189  : }

	pop	ebp
	ret	0
_xmlErrInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlErrMemory PROC					; COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlErrMemo

; 115  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrMemo
	cmp	DWORD PTR [eax+172], -1
	je	SHORT $LN5@xmlErrMemo
$LN2@xmlErrMemo:

; 116  :         (ctxt->instate == XML_PARSER_EOF))
; 117  : 	return;
; 118  :     if (ctxt != NULL) {
; 119  :         ctxt->errNo = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+84], 2

; 120  :         ctxt->instate = XML_PARSER_EOF;

	mov	DWORD PTR [eax+172], -1

; 121  :         ctxt->disableSAX = 1;

	mov	DWORD PTR [eax+212], 1
$LN3@xmlErrMemo:

; 122  :     }
; 123  :     if (extra)

	mov	ecx, DWORD PTR _extra$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlErrMemo

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	ecx
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	ecx
	push	0
	push	0
	push	3
	push	2
	push	1
	push	0
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 130  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 131  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 132  : }

	pop	ebp
	ret	0
$LN4@xmlErrMemo:

; 125  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 126  :                         NULL, NULL, 0, 0,
; 127  :                         "Memory allocation failed : %s\n", extra);
; 128  :     else
; 129  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	1
	push	0
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
$LN5@xmlErrMemo:

; 130  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 131  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 132  : }

	pop	ebp
	ret	0
_xmlErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputShrink
_TEXT	SEGMENT
_in$ = 8						; size = 4
_xmlParserInputShrink PROC				; COMDAT

; 358  : xmlParserInputShrink(xmlParserInputPtr in) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	test	esi, esi
	je	$LN1@xmlParserI

; 359  :     size_t used;
; 360  :     size_t ret;
; 361  :     size_t indx;
; 362  :     const xmlChar *content;
; 363  : 
; 364  : #ifdef DEBUG_INPUT
; 365  :     xmlGenericError(xmlGenericErrorContext, "Shrink\n");
; 366  : #endif
; 367  :     if (in == NULL) return;
; 368  :     if (in->buf == NULL) return;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN1@xmlParserI

; 369  :     if (in->base == NULL) return;

	cmp	DWORD PTR [esi+12], 0
	je	$LN1@xmlParserI

; 370  :     if (in->cur == NULL) return;

	cmp	DWORD PTR [esi+16], 0
	je	$LN1@xmlParserI

; 371  :     if (in->buf->buffer == NULL) return;

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	$LN1@xmlParserI

; 372  : 
; 373  :     CHECK_BUFFER(in);
; 374  : 
; 375  :     used = in->cur - xmlBufContent(in->buf->buffer);

	push	eax
	call	_xmlBufContent
	mov	ecx, DWORD PTR [esi+16]
	add	esp, 4
	sub	ecx, eax

; 376  :     /*
; 377  :      * Do not shrink on large buffers whose only a tiny fraction
; 378  :      * was consumed
; 379  :      */
; 380  :     if (used > INPUT_CHUNK) {

	cmp	ecx, 250				; 000000faH
	jbe	SHORT $LN7@xmlParserI

; 381  : 	ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);

	lea	eax, DWORD PTR [ecx-80]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufShrink
	add	esp, 8

; 382  : 	if (ret > 0) {

	test	eax, eax
	je	SHORT $LN13@xmlParserI

; 383  : 	    in->cur -= ret;

	sub	DWORD PTR [esi+16], eax

; 384  : 	    in->consumed += ret;

	add	DWORD PTR [esi+36], eax
$LN13@xmlParserI:

; 385  : 	}
; 386  : 	in->end = xmlBufEnd(in->buf->buffer);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufEnd
	add	esp, 4
	mov	DWORD PTR [esi+20], eax
$LN7@xmlParserI:

; 387  :     }
; 388  : 
; 389  :     CHECK_BUFFER(in);
; 390  : 
; 391  :     if (xmlBufUse(in->buf->buffer) > INPUT_CHUNK) {

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 250				; 000000faH
	ja	SHORT $LN1@xmlParserI

; 392  :         return;
; 393  :     }
; 394  :     xmlParserInputBufferRead(in->buf, 2 * INPUT_CHUNK);

	push	500					; 000001f4H
	push	DWORD PTR [esi]
	call	_xmlParserInputBufferRead

; 395  :     content = xmlBufContent(in->buf->buffer);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufContent

; 396  :     if (in->base != content) {

	mov	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	ecx, eax
	je	SHORT $LN10@xmlParserI

; 397  :         /*
; 398  : 	 * the buffer has been reallocated
; 399  : 	 */
; 400  : 	indx = in->cur - in->base;
; 401  : 	in->base = content;

	mov	DWORD PTR [esi+12], eax

; 402  : 	in->cur = &content[indx];

	sub	eax, ecx
	add	DWORD PTR [esi+16], eax
$LN10@xmlParserI:

; 403  :     }
; 404  :     in->end = xmlBufEnd(in->buf->buffer);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufEnd
	add	esp, 4
	mov	DWORD PTR [esi+20], eax
$LN1@xmlParserI:
	pop	esi

; 405  : 
; 406  :     CHECK_BUFFER(in);
; 407  : }

	pop	ebp
	ret	0
_xmlParserInputShrink ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNextChar
_TEXT	SEGMENT
_buffer$1 = -152					; size = 150
_ctxt$ = 8						; size = 4
_xmlNextChar PROC					; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN30@xmlNextCha

; 425  :     if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||

	cmp	DWORD PTR [esi+172], -1
	je	$LN30@xmlNextCha
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	$LN30@xmlNextCha

; 426  :         (ctxt->input == NULL))
; 427  :         return;
; 428  : 
; 429  :     if (!(VALID_CTXT(ctxt))) {

	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	SHORT $LN4@xmlNextCha

; 430  :         xmlErrInternal(ctxt, "Parser input data memory error\n", NULL);

	push	0
	push	OFFSET ??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@
	push	esi
	call	_xmlErrInternal

; 431  : 	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
; 432  :         xmlStopParser(ctxt);

	push	esi
	mov	DWORD PTR [esi+84], 1
	call	_xmlStopParser
	add	esp, 16					; 00000010H
	pop	esi

; 566  :     return;
; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNextCha:

; 433  : 	return;
; 434  :     }
; 435  : 
; 436  :     if ((*ctxt->input->cur == 0) &&

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN5@xmlNextCha
	push	250					; 000000faH
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
	test	eax, eax
	jle	$LN30@xmlNextCha
$LN5@xmlNextCha:

; 437  :         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {
; 438  :         return;
; 439  :     }
; 440  : 
; 441  :     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR [esi+256], 1
	mov	ecx, DWORD PTR [esi+36]
	push	ebx
	push	edi
	mov	eax, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [eax]
	jne	$LN6@xmlNextCha

; 442  :         const unsigned char *cur;
; 443  :         unsigned char c;
; 444  : 
; 445  :         /*
; 446  :          *   2.11 End-of-Line Handling
; 447  :          *   the literal two-character sequence "#xD#xA" or a standalone
; 448  :          *   literal #xD, an XML processor must pass to the application
; 449  :          *   the single character #xA.
; 450  :          */
; 451  :         if (*(ctxt->input->cur) == '\n') {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN8@xmlNextCha

; 452  :             ctxt->input->line++; ctxt->input->col = 1;

	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1

; 453  :         } else

	jmp	SHORT $LN9@xmlNextCha
$LN8@xmlNextCha:

; 454  :             ctxt->input->col++;

	inc	DWORD PTR [ecx+32]
$LN9@xmlNextCha:

; 455  : 
; 456  :         /*
; 457  :          * We are supposed to handle UTF8, check it's valid
; 458  :          * From rfc2044: encoding of the Unicode values on UTF-8:
; 459  :          *
; 460  :          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 461  :          * 0000 0000-0000 007F   0xxxxxxx
; 462  :          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 463  :          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 464  :          *
; 465  :          * Check for the 0x110000 limit too
; 466  :          */
; 467  :         cur = ctxt->input->cur;

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+16]

; 468  : 
; 469  :         c = *cur;

	mov	bl, BYTE PTR [edx]

; 470  :         if (c & 0x80) {

	test	bl, bl
	jns	$LN10@xmlNextCha

; 471  :             if (c == 0xC0)

	cmp	bl, 192					; 000000c0H
	je	$encoding_error$39

; 472  : 	        goto encoding_error;
; 473  :             if (cur[1] == 0) {

	cmp	BYTE PTR [edx+1], 0
	mov	edi, ecx
	jne	SHORT $LN13@xmlNextCha

; 474  :                 xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 475  :                 cur = ctxt->input->cur;

	mov	edi, DWORD PTR [esi+36]
	add	esp, 8
	mov	edx, DWORD PTR [edi+16]
$LN13@xmlNextCha:

; 476  :             }
; 477  :             if ((cur[1] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+1]
	mov	ecx, edi
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$39

; 478  :                 goto encoding_error;
; 479  :             if ((c & 0xe0) == 0xe0) {

	mov	al, bl
	and	al, 224					; 000000e0H
	cmp	al, 224					; 000000e0H
	jne	$LN15@xmlNextCha

; 480  :                 unsigned int val;
; 481  : 
; 482  :                 if (cur[2] == 0) {

	cmp	BYTE PTR [edx+2], 0
	jne	SHORT $LN17@xmlNextCha

; 483  :                     xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	edi
	call	_xmlParserInputGrow

; 484  :                     cur = ctxt->input->cur;

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 8
	mov	edx, DWORD PTR [ecx+16]
$LN17@xmlNextCha:

; 485  :                 }
; 486  :                 if ((cur[2] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+2]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$39

; 487  :                     goto encoding_error;
; 488  :                 if ((c & 0xf0) == 0xf0) {

	mov	al, bl
	and	al, 240					; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN19@xmlNextCha

; 489  :                     if (cur[3] == 0) {

	cmp	BYTE PTR [edx+3], 0
	mov	edi, ecx
	jne	SHORT $LN21@xmlNextCha

; 490  :                         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow

; 491  :                         cur = ctxt->input->cur;

	mov	edi, DWORD PTR [esi+36]
	add	esp, 8
	mov	edx, DWORD PTR [edi+16]
$LN21@xmlNextCha:

; 492  :                     }
; 493  :                     if (((c & 0xf8) != 0xf0) ||

	and	bl, 248					; 000000f8H
	mov	ecx, edi
	cmp	bl, 240					; 000000f0H
	jne	$encoding_error$39
	mov	al, BYTE PTR [edx+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$39

; 494  :                         ((cur[3] & 0xc0) != 0x80))
; 495  :                         goto encoding_error;
; 496  :                     /* 4-byte code */
; 497  :                     ctxt->input->cur += 4;

	add	DWORD PTR [edi+16], 4

; 498  :                     val = (cur[0] & 0x7) << 18;
; 499  :                     val |= (cur[1] & 0x3f) << 12;
; 500  :                     val |= (cur[2] & 0x3f) << 6;
; 501  :                     val |= cur[3] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 7
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+3]

; 502  :                 } else {

	jmp	SHORT $LN37@xmlNextCha
$LN19@xmlNextCha:

; 503  :                     /* 3-byte code */
; 504  :                     ctxt->input->cur += 3;

	add	DWORD PTR [ecx+16], 3

; 505  :                     val = (cur[0] & 0xf) << 12;
; 506  :                     val |= (cur[1] & 0x3f) << 6;
; 507  :                     val |= cur[2] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
$LN37@xmlNextCha:

; 508  :                 }
; 509  :                 if (((val > 0xd7ff) && (val < 0xe000)) ||
; 510  :                     ((val > 0xfffd) && (val < 0x10000)) ||

	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN26@xmlNextCha
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN25@xmlNextCha
$LN26@xmlNextCha:
	cmp	ecx, 65533				; 0000fffdH
	jbe	SHORT $LN27@xmlNextCha
	cmp	ecx, 65536				; 00010000H
	jb	SHORT $LN25@xmlNextCha
$LN27@xmlNextCha:
	cmp	ecx, 1114112				; 00110000H
	jb	$LN11@xmlNextCha
$LN25@xmlNextCha:

; 511  :                     (val >= 0x110000)) {
; 512  : 		xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	push	ecx
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	push	esi
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H

; 513  : 				  "Char 0x%X out of allowed range\n",
; 514  : 				  val);
; 515  :                 }
; 516  :             } else

	jmp	$LN11@xmlNextCha
$LN15@xmlNextCha:

; 517  :                 /* 2-byte code */
; 518  :                 ctxt->input->cur += 2;

	add	DWORD PTR [edi+16], 2

; 519  :         } else

	jmp	$LN11@xmlNextCha
$encoding_error$39:

; 540  :     return;
; 541  : encoding_error:
; 542  :     /*
; 543  :      * If we detect an UTF8 error that probably mean that the
; 544  :      * input encoding didn't get properly advertised in the
; 545  :      * declaration header. Report the error and switch the encoding
; 546  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 547  :      * encoding !)
; 548  :      */
; 549  :     if ((ctxt == NULL) || (ctxt->input == NULL) ||

	test	ecx, ecx
	je	SHORT $LN33@xmlNextCha
	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN33@xmlNextCha

; 552  : 		     "Input is not proper UTF-8, indicate encoding !\n",
; 553  : 		     NULL, NULL);
; 554  :     } else {
; 555  :         char buffer[150];
; 556  : 
; 557  : 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	movzx	eax, BYTE PTR [edx+3]
	push	eax
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	movzx	eax, BYTE PTR [edx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	149					; 00000095H
	push	eax
	call	_snprintf

; 558  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 559  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 560  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	push	esi
	call	___xmlErrEncoding
	add	esp, 48					; 00000030H
	jmp	SHORT $LN32@xmlNextCha
$LN33@xmlNextCha:

; 550  :         (ctxt->input->end - ctxt->input->cur < 4)) {
; 551  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	push	0
	push	OFFSET ??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	push	esi
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H
$LN32@xmlNextCha:

; 561  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 562  : 		     BAD_CAST buffer, NULL);
; 563  :     }
; 564  :     ctxt->charset = XML_CHAR_ENCODING_8859_1;
; 565  :     ctxt->input->cur++;

	mov	eax, DWORD PTR [esi+36]
	pop	edi
	mov	DWORD PTR [esi+256], 10			; 0000000aH
	pop	ebx
	inc	DWORD PTR [eax+16]
	pop	esi

; 566  :     return;
; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlNextCha:

; 520  :             /* 1-byte code */
; 521  :             ctxt->input->cur++;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+16], eax

; 522  : 
; 523  :         ctxt->nbChars++;
; 524  :     } else {

	jmp	SHORT $LN11@xmlNextCha
$LN6@xmlNextCha:

; 525  :         /*
; 526  :          * Assume it's a fixed length encoding (1) with
; 527  :          * a compatible encoding for the ASCII set, since
; 528  :          * XML constructs only use < 128 chars
; 529  :          */
; 530  : 
; 531  :         if (*(ctxt->input->cur) == '\n') {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN28@xmlNextCha

; 532  :             ctxt->input->line++; ctxt->input->col = 1;

	inc	DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+32], 1

; 533  :         } else

	jmp	SHORT $LN29@xmlNextCha
$LN28@xmlNextCha:

; 534  :             ctxt->input->col++;

	inc	DWORD PTR [ecx+32]
$LN29@xmlNextCha:

; 535  :         ctxt->input->cur++;

	mov	eax, DWORD PTR [esi+36]
	inc	DWORD PTR [eax+16]
$LN11@xmlNextCha:

; 536  :         ctxt->nbChars++;
; 537  :     }
; 538  :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [esi+36]
	inc	DWORD PTR [esi+200]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN35@xmlNextCha

; 539  :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN35@xmlNextCha:
	pop	edi
	pop	ebx
$LN30@xmlNextCha:
	pop	esi

; 566  :     return;
; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNextChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCopyChar
_TEXT	SEGMENT
_len$ = 8						; size = 4
_out$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlCopyChar PROC					; COMDAT

; 900  : xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _out$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlCopyCha

; 901  :     if (out == NULL) return(0);

	xor	eax, eax

; 908  : }

	pop	ebp
	ret	0
$LN2@xmlCopyCha:

; 902  :     /* the len parameter is ignored */
; 903  :     if  (val >= 0x80) {

	mov	eax, DWORD PTR _val$[ebp]
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN3@xmlCopyCha

; 904  : 	return(xmlCopyCharMultiByte (out, val));

	push	eax
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8

; 908  : }

	pop	ebp
	ret	0
$LN3@xmlCopyCha:

; 905  :     }
; 906  :     *out = (xmlChar) val;

	mov	BYTE PTR [ecx], al

; 907  :     return 1;

	mov	eax, 1

; 908  : }

	pop	ebp
	ret	0
_xmlCopyChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCopyCharMultiByte
_TEXT	SEGMENT
_out$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlCopyCharMultiByte PROC				; COMDAT

; 857  : xmlCopyCharMultiByte(xmlChar *out, int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlCopyCha

; 858  :     if (out == NULL) return(0);

	xor	eax, eax
	pop	esi

; 886  : }

	pop	ebp
	ret	0
$LN5@xmlCopyCha:
	push	ebx

; 859  :     /*
; 860  :      * We are supposed to handle UTF8, check it's valid
; 861  :      * From rfc2044: encoding of the Unicode values on UTF-8:
; 862  :      *
; 863  :      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 864  :      * 0000 0000-0000 007F   0xxxxxxx
; 865  :      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 866  :      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 867  :      */
; 868  :     if  (val >= 0x80) {

	mov	ebx, DWORD PTR _val$[ebp]
	cmp	ebx, 128				; 00000080H
	jl	$LN6@xmlCopyCha

; 869  : 	xmlChar *savedout = out;
; 870  : 	int bits;
; 871  : 	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }

	cmp	ebx, 2048				; 00000800H
	jge	SHORT $LN7@xmlCopyCha
	mov	edx, ebx
	xor	ecx, ecx
	sar	edx, 6
	or	dl, 192					; 000000c0H
	jmp	SHORT $LN12@xmlCopyCha
$LN7@xmlCopyCha:

; 872  : 	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}

	cmp	ebx, 65536				; 00010000H
	jge	SHORT $LN9@xmlCopyCha
	mov	edx, ebx
	mov	ecx, 6
	sar	edx, 12					; 0000000cH
	or	dl, 224					; 000000e0H
	jmp	SHORT $LN12@xmlCopyCha
$LN9@xmlCopyCha:

; 873  : 	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }

	cmp	ebx, 1114112				; 00110000H
	jge	SHORT $LN11@xmlCopyCha
	mov	edx, ebx
	mov	ecx, 12					; 0000000cH
	sar	edx, 18					; 00000012H
	or	dl, 240					; 000000f0H
$LN12@xmlCopyCha:

; 879  : 	}
; 880  : 	for ( ; bits >= 0; bits-= 6)

	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], dl
	npad	1
$LL4@xmlCopyCha:

; 881  : 	    *out++= ((val >> bits) & 0x3F) | 0x80 ;

	mov	edx, ebx
	sar	edx, cl
	and	dl, 63					; 0000003fH
	or	dl, 128					; 00000080H
	mov	BYTE PTR [eax], dl
	inc	eax
	sub	ecx, 6
	jns	SHORT $LL4@xmlCopyCha

; 882  : 	return (out - savedout);

	pop	ebx
	sub	eax, esi
	pop	esi

; 886  : }

	pop	ebp
	ret	0
$LN11@xmlCopyCha:

; 209  :     __xmlRaiseError(NULL, NULL, NULL,

	push	ebx
	push	OFFSET ??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@
	push	0
	push	ebx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	9
	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 874  : 	else {
; 875  : 	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
; 876  : 		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
; 877  : 			      val);
; 878  : 	    return(0);

	xor	eax, eax
	pop	ebx
	pop	esi

; 886  : }

	pop	ebp
	ret	0
$LN6@xmlCopyCha:

; 883  :     }
; 884  :     *out = (xmlChar) val;

	mov	BYTE PTR [esi], bl

; 885  :     return 1;

	mov	eax, 1
	pop	ebx
	pop	esi

; 886  : }

	pop	ebp
	ret	0
_xmlCopyCharMultiByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCurrentChar
_TEXT	SEGMENT
_buffer$1 = -152					; size = 150
_ctxt$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCurrentChar PROC					; COMDAT

; 588  : xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN3@xmlCurrent

; 589  :     if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	je	$LN3@xmlCurrent
	mov	edx, DWORD PTR [edi+36]
	test	edx, edx
	je	$LN3@xmlCurrent

; 590  :     if (ctxt->instate == XML_PARSER_EOF)

	cmp	DWORD PTR [edi+172], -1
	je	$LN3@xmlCurrent

; 591  : 	return(0);
; 592  : 
; 593  :     if ((*ctxt->input->cur >= 0x20) && (*ctxt->input->cur <= 0x7F)) {

	mov	ecx, DWORD PTR [edx+16]
	push	ebx
	mov	bl, BYTE PTR [ecx]
	lea	eax, DWORD PTR [ebx-32]
	cmp	al, 95					; 0000005fH
	jbe	$LN51@xmlCurrent

; 594  : 	    *len = 1;
; 595  : 	    return((int) *ctxt->input->cur);
; 596  :     }
; 597  :     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {

	cmp	DWORD PTR [edi+256], 1
	jne	$LN8@xmlCurrent

; 598  : 	/*
; 599  : 	 * We are supposed to handle UTF8, check it's valid
; 600  : 	 * From rfc2044: encoding of the Unicode values on UTF-8:
; 601  : 	 *
; 602  : 	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 603  : 	 * 0000 0000-0000 007F   0xxxxxxx
; 604  : 	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 605  : 	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 606  : 	 *
; 607  : 	 * Check for the 0x110000 limit too
; 608  : 	 */
; 609  : 	const unsigned char *cur = ctxt->input->cur;
; 610  : 	unsigned char c;
; 611  : 	unsigned int val;
; 612  : 
; 613  : 	c = *cur;
; 614  : 	if (c & 0x80) {

	test	bl, bl
	jns	$LN7@xmlCurrent

; 615  : 	    if (((c & 0x40) == 0) || (c == 0xC0))

	test	bl, 64					; 00000040H
	je	$encoding_error$54
	cmp	bl, 192					; 000000c0H
	je	$encoding_error$54

; 616  : 		goto encoding_error;
; 617  : 	    if (cur[1] == 0) {

	cmp	BYTE PTR [ecx+1], 0
	jne	SHORT $LN11@xmlCurrent

; 618  : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow

; 619  :                 cur = ctxt->input->cur;

	mov	edx, DWORD PTR [edi+36]
	add	esp, 8
	mov	ecx, DWORD PTR [edx+16]
$LN11@xmlCurrent:

; 620  :             }
; 621  : 	    if ((cur[1] & 0xc0) != 0x80)

	mov	al, BYTE PTR [ecx+1]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$54

; 622  : 		goto encoding_error;
; 623  : 	    if ((c & 0xe0) == 0xe0) {

	mov	al, bl
	and	al, 224					; 000000e0H
	cmp	al, 224					; 000000e0H
	jne	$LN13@xmlCurrent

; 624  : 		if (cur[2] == 0) {

	cmp	BYTE PTR [ecx+2], 0
	jne	SHORT $LN15@xmlCurrent

; 625  : 		    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow

; 626  :                     cur = ctxt->input->cur;

	mov	edx, DWORD PTR [edi+36]
	add	esp, 8
	mov	ecx, DWORD PTR [edx+16]
$LN15@xmlCurrent:

; 627  :                 }
; 628  : 		if ((cur[2] & 0xc0) != 0x80)

	mov	al, BYTE PTR [ecx+2]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$54

; 629  : 		    goto encoding_error;
; 630  : 		if ((c & 0xf0) == 0xf0) {

	mov	al, bl
	and	al, 240					; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN17@xmlCurrent

; 631  : 		    if (cur[3] == 0) {

	cmp	BYTE PTR [ecx+3], 0
	jne	SHORT $LN19@xmlCurrent

; 632  : 			xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	edx
	call	_xmlParserInputGrow

; 633  :                         cur = ctxt->input->cur;

	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	mov	ecx, DWORD PTR [eax+16]
$LN19@xmlCurrent:

; 634  :                     }
; 635  : 		    if (((c & 0xf8) != 0xf0) ||

	and	bl, 248					; 000000f8H
	cmp	bl, 240					; 000000f0H
	jne	$encoding_error$54
	mov	al, BYTE PTR [ecx+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$54

; 636  : 			((cur[3] & 0xc0) != 0x80))
; 637  : 			goto encoding_error;
; 638  : 		    /* 4-byte code */
; 639  : 		    *len = 4;

	mov	DWORD PTR [esi], 4

; 640  : 		    val = (cur[0] & 0x7) << 18;
; 641  : 		    val |= (cur[1] & 0x3f) << 12;
; 642  : 		    val |= (cur[2] & 0x3f) << 6;
; 643  : 		    val |= cur[3] & 0x3f;

	movzx	esi, BYTE PTR [ecx]
	movzx	eax, BYTE PTR [ecx+1]
	and	esi, 7
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+2]
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+3]
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax

; 644  : 		    if (val < 0x10000)

	cmp	esi, 65536				; 00010000H

; 645  : 			goto encoding_error;
; 646  : 		} else {

	jmp	SHORT $LN52@xmlCurrent
$LN17@xmlCurrent:

; 647  : 		  /* 3-byte code */
; 648  : 		    *len = 3;

	mov	DWORD PTR [esi], 3

; 649  : 		    val = (cur[0] & 0xf) << 12;
; 650  : 		    val |= (cur[1] & 0x3f) << 6;
; 651  : 		    val |= cur[2] & 0x3f;

	movzx	esi, BYTE PTR [ecx]
	movzx	eax, BYTE PTR [ecx+1]
	and	esi, 15					; 0000000fH
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax
	movzx	eax, BYTE PTR [ecx+2]
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax

; 652  : 		    if (val < 0x800)

	cmp	esi, 2048				; 00000800H

; 653  : 			goto encoding_error;
; 654  : 		}
; 655  : 	    } else {

	jmp	SHORT $LN52@xmlCurrent
$LN13@xmlCurrent:

; 656  : 	      /* 2-byte code */
; 657  : 		*len = 2;

	mov	DWORD PTR [esi], 2

; 658  : 		val = (cur[0] & 0x1f) << 6;
; 659  : 		val |= cur[1] & 0x3f;

	movzx	esi, BYTE PTR [ecx]
	movzx	eax, BYTE PTR [ecx+1]
	and	esi, 31					; 0000001fH
	shl	esi, 6
	and	eax, 63					; 0000003fH
	or	esi, eax

; 660  : 		if (val < 0x80)

	cmp	esi, 128				; 00000080H
$LN52@xmlCurrent:

; 661  : 		    goto encoding_error;
; 662  : 	    }
; 663  : 	    if (!IS_CHAR(val)) {

	jb	SHORT $LN47@xmlCurrent
	cmp	esi, 256				; 00000100H
	jae	SHORT $LN42@xmlCurrent
	cmp	esi, 9
	jb	SHORT $LN34@xmlCurrent
	cmp	esi, 10					; 0000000aH
	jbe	SHORT $LN25@xmlCurrent
$LN34@xmlCurrent:
	cmp	esi, 13					; 0000000dH
	je	SHORT $LN25@xmlCurrent
	cmp	esi, 32					; 00000020H
	jae	SHORT $LN25@xmlCurrent
	jmp	SHORT $LN39@xmlCurrent
$LN42@xmlCurrent:
	cmp	esi, 55295				; 0000d7ffH
	jbe	SHORT $LN25@xmlCurrent
	cmp	esi, 57344				; 0000e000H
	jb	SHORT $LN37@xmlCurrent
	cmp	esi, 65533				; 0000fffdH
	jbe	SHORT $LN25@xmlCurrent
$LN37@xmlCurrent:
	lea	eax, DWORD PTR [esi-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN25@xmlCurrent
$LN39@xmlCurrent:

; 664  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	push	esi
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	push	edi
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN25@xmlCurrent:

; 665  : 				  "Char 0x%X out of allowed range\n", val);
; 666  : 	    }
; 667  : 	    return(val);

	pop	ebx
	pop	edi
	mov	eax, esi

; 733  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlCurrent:

; 700  :     }
; 701  :     return((int) *ctxt->input->cur);
; 702  : encoding_error:
; 703  :     /*
; 704  :      * An encoding problem may arise from a truncated input buffer
; 705  :      * splitting a character in the middle. In that case do not raise
; 706  :      * an error but return 0 to endicate an end of stream problem
; 707  :      */
; 708  :     if (ctxt->input->end - ctxt->input->cur < 4) {

	mov	esi, DWORD PTR _len$[ebp]
$encoding_error$54:
	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jge	SHORT $LN32@xmlCurrent

; 709  : 	*len = 0;

	pop	ebx
	pop	edi
	mov	DWORD PTR [esi], 0

; 710  : 	return(0);

	xor	eax, eax

; 733  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlCurrent:

; 711  :     }
; 712  : 
; 713  :     /*
; 714  :      * If we detect an UTF8 error that probably mean that the
; 715  :      * input encoding didn't get properly advertised in the
; 716  :      * declaration header. Report the error and switch the encoding
; 717  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 718  :      * encoding !)
; 719  :      */
; 720  :     {
; 721  :         char buffer[150];
; 722  : 
; 723  : 	snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	movzx	eax, BYTE PTR [ecx+3]
	push	eax
	movzx	eax, BYTE PTR [ecx+2]
	push	eax
	movzx	eax, BYTE PTR [ecx+1]
	push	eax
	movzx	eax, BYTE PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	149					; 00000095H
	push	eax
	call	_snprintf

; 724  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 725  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 726  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	push	edi
	call	___xmlErrEncoding
	add	esp, 48					; 00000030H

; 727  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 728  : 		     BAD_CAST buffer, NULL);
; 729  :     }
; 730  :     ctxt->charset = XML_CHAR_ENCODING_8859_1;

	mov	DWORD PTR [edi+256], 10			; 0000000aH
$LN51@xmlCurrent:

; 731  :     *len = 1;

	mov	DWORD PTR [esi], 1

; 732  :     return((int) *ctxt->input->cur);

	mov	eax, DWORD PTR [edi+36]
	pop	ebx
	pop	edi

; 733  : }

	pop	esi
	mov	eax, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlCurrent:

; 668  : 	} else {
; 669  : 	    /* 1-byte code */
; 670  : 	    *len = 1;

	mov	DWORD PTR [esi], 1

; 671  : 	    if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN26@xmlCurrent

; 672  : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	push	ecx
	call	_xmlParserInputGrow
	mov	ecx, DWORD PTR [edi+36]
	add	esp, 8
$LN26@xmlCurrent:

; 673  : 	    if ((*ctxt->input->cur == 0) &&

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, ecx
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN27@xmlCurrent
	cmp	DWORD PTR [ecx+20], edx
	jbe	SHORT $LN27@xmlCurrent

; 674  : 	        (ctxt->input->end > ctxt->input->cur)) {
; 675  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	push	OFFSET ??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@
	push	9
	push	edi
	call	_xmlErrEncodingInt
	mov	eax, DWORD PTR [edi+36]
	add	esp, 16					; 00000010H
$LN27@xmlCurrent:

; 676  : 				  "Char 0x0 out of allowed range\n", 0);
; 677  : 	    }
; 678  : 	    if (*ctxt->input->cur == 0xD) {

	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN50@xmlCurrent
$LN30@xmlCurrent:
	pop	ebx
	pop	edi

; 679  : 		if (ctxt->input->cur[1] == 0xA) {
; 680  : 		    ctxt->nbChars++;
; 681  : 		    ctxt->input->cur++;
; 682  : 		}
; 683  : 		return(0xA);
; 684  : 	    }
; 685  : 	    return((int) *ctxt->input->cur);

	movzx	eax, dl

; 733  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlCurrent:

; 686  : 	}
; 687  :     }
; 688  :     /*
; 689  :      * Assume it's a fixed length encoding (1) with
; 690  :      * a compatible encoding for the ASCII set, since
; 691  :      * XML constructs only use < 128 chars
; 692  :      */
; 693  :     *len = 1;

	mov	DWORD PTR [esi], 1

; 694  :     if (*ctxt->input->cur == 0xD) {

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN30@xmlCurrent
$LN50@xmlCurrent:

; 695  : 	if (ctxt->input->cur[1] == 0xA) {
; 696  : 	    ctxt->nbChars++;
; 697  : 	    ctxt->input->cur++;
; 698  : 	}
; 699  : 	return(0xA);

	cmp	BYTE PTR [ecx+1], 10			; 0000000aH
	jne	SHORT $LN31@xmlCurrent
	inc	DWORD PTR [edi+200]
	inc	DWORD PTR [eax+16]
$LN31@xmlCurrent:
	pop	ebx
	pop	edi
	mov	eax, 10					; 0000000aH

; 733  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlCurrent:
	pop	edi

; 589  :     if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);

	xor	eax, eax

; 733  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCurrentChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlStringCurrentChar
_TEXT	SEGMENT
_buffer$1 = -152					; size = 150
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStringCurrentChar PROC				; COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	je	$LN3@xmlStringC

; 750  :     if ((len == NULL) || (cur == NULL)) return(0);

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN3@xmlStringC

; 751  :     if ((ctxt == NULL) || (ctxt->charset == XML_CHAR_ENCODING_UTF8)) {

	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlStringC
	cmp	DWORD PTR [ebx+256], 1
	jne	$LN6@xmlStringC
$LN5@xmlStringC:

; 752  :         /*
; 753  :          * We are supposed to handle UTF8, check it's valid
; 754  :          * From rfc2044: encoding of the Unicode values on UTF-8:
; 755  :          *
; 756  :          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 757  :          * 0000 0000-0000 007F   0xxxxxxx
; 758  :          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 759  :          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 760  :          *
; 761  :          * Check for the 0x110000 limit too
; 762  :          */
; 763  :         unsigned char c;
; 764  :         unsigned int val;
; 765  : 
; 766  :         c = *cur;

	mov	cl, BYTE PTR [edi]

; 767  :         if (c & 0x80) {

	test	cl, cl
	jns	$LN6@xmlStringC

; 768  :             if ((cur[1] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edi+1]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$34

; 769  :                 goto encoding_error;
; 770  :             if ((c & 0xe0) == 0xe0) {

	mov	al, cl
	and	al, 224					; 000000e0H
	cmp	al, 224					; 000000e0H
	jne	SHORT $LN9@xmlStringC

; 771  : 
; 772  :                 if ((cur[2] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edi+2]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$34

; 773  :                     goto encoding_error;
; 774  :                 if ((c & 0xf0) == 0xf0) {

	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN12@xmlStringC

; 775  :                     if (((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))

	and	cl, 248					; 000000f8H
	cmp	cl, al
	jne	$encoding_error$34
	mov	al, BYTE PTR [edi+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$34

; 776  :                         goto encoding_error;
; 777  :                     /* 4-byte code */
; 778  :                     *len = 4;

	mov	DWORD PTR [esi], 4

; 779  :                     val = (cur[0] & 0x7) << 18;
; 780  :                     val |= (cur[1] & 0x3f) << 12;
; 781  :                     val |= (cur[2] & 0x3f) << 6;
; 782  :                     val |= cur[3] & 0x3f;

	movzx	esi, BYTE PTR [edi]
	movzx	eax, BYTE PTR [edi+1]
	and	esi, 7
	and	eax, 63					; 0000003fH
	shl	esi, 6
	or	esi, eax
	movzx	eax, BYTE PTR [edi+2]
	and	eax, 63					; 0000003fH
	shl	esi, 6
	or	esi, eax
	movzx	eax, BYTE PTR [edi+3]

; 783  :                 } else {

	jmp	SHORT $LN32@xmlStringC
$LN12@xmlStringC:

; 784  :                     /* 3-byte code */
; 785  :                     *len = 3;

	mov	DWORD PTR [esi], 3

; 786  :                     val = (cur[0] & 0xf) << 12;
; 787  :                     val |= (cur[1] & 0x3f) << 6;
; 788  :                     val |= cur[2] & 0x3f;

	movzx	esi, BYTE PTR [edi]
	movzx	eax, BYTE PTR [edi+1]
	and	esi, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	esi, 6
	or	esi, eax
	movzx	eax, BYTE PTR [edi+2]

; 789  :                 }
; 790  :             } else {

	jmp	SHORT $LN32@xmlStringC
$LN9@xmlStringC:

; 791  :                 /* 2-byte code */
; 792  :                 *len = 2;

	mov	DWORD PTR [esi], 2

; 793  :                 val = (cur[0] & 0x1f) << 6;
; 794  :                 val |= cur[1] & 0x3f;

	movzx	esi, BYTE PTR [edi]
	movzx	eax, BYTE PTR [edi+1]
	and	esi, 31					; 0000001fH
$LN32@xmlStringC:

; 795  :             }
; 796  :             if (!IS_CHAR(val)) {

	and	eax, 63					; 0000003fH
	shl	esi, 6
	or	esi, eax
	cmp	esi, 256				; 00000100H
	jae	SHORT $LN28@xmlStringC
	cmp	esi, 9
	jb	SHORT $LN20@xmlStringC
	cmp	esi, 10					; 0000000aH
	jbe	SHORT $LN16@xmlStringC
$LN20@xmlStringC:
	cmp	esi, 13					; 0000000dH
	je	SHORT $LN16@xmlStringC
	cmp	esi, 32					; 00000020H
	jae	SHORT $LN16@xmlStringC
	jmp	SHORT $LN25@xmlStringC
$LN28@xmlStringC:
	cmp	esi, 55295				; 0000d7ffH
	jbe	SHORT $LN16@xmlStringC
	cmp	esi, 57344				; 0000e000H
	jb	SHORT $LN23@xmlStringC
	cmp	esi, 65533				; 0000fffdH
	jbe	SHORT $LN16@xmlStringC
$LN23@xmlStringC:
	lea	eax, DWORD PTR [esi-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN16@xmlStringC
$LN25@xmlStringC:

; 797  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	push	esi
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	push	ebx
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN16@xmlStringC:

; 798  : 				  "Char 0x%X out of allowed range\n", val);
; 799  :             }
; 800  :             return (val);

	pop	ebx
	pop	edi
	mov	eax, esi

; 845  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$encoding_error$34:

; 801  :         } else {
; 802  :             /* 1-byte code */
; 803  :             *len = 1;
; 804  :             return ((int) *cur);
; 805  :         }
; 806  :     }
; 807  :     /*
; 808  :      * Assume it's a fixed length encoding (1) with
; 809  :      * a compatible encoding for the ASCII set, since
; 810  :      * XML constructs only use < 128 chars
; 811  :      */
; 812  :     *len = 1;
; 813  :     return ((int) *cur);
; 814  : encoding_error:
; 815  : 
; 816  :     /*
; 817  :      * An encoding problem may arise from a truncated input buffer
; 818  :      * splitting a character in the middle. In that case do not raise
; 819  :      * an error but return 0 to endicate an end of stream problem
; 820  :      */
; 821  :     if ((ctxt == NULL) || (ctxt->input == NULL) ||

	test	ebx, ebx
	je	SHORT $LN18@xmlStringC
	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN18@xmlStringC
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN18@xmlStringC

; 825  :     }
; 826  :     /*
; 827  :      * If we detect an UTF8 error that probably mean that the
; 828  :      * input encoding didn't get properly advertised in the
; 829  :      * declaration header. Report the error and switch the encoding
; 830  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 831  :      * encoding !)
; 832  :      */
; 833  :     {
; 834  :         char buffer[150];
; 835  : 
; 836  : 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	movzx	eax, BYTE PTR [ecx+3]
	push	eax
	movzx	eax, BYTE PTR [ecx+2]
	push	eax
	movzx	eax, BYTE PTR [ecx+1]
	push	eax
	movzx	eax, BYTE PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	149					; 00000095H
	push	eax
	call	_snprintf

; 837  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 838  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 839  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	push	ebx
	call	___xmlErrEncoding
	add	esp, 48					; 00000030H
$LN6@xmlStringC:

; 840  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 841  : 		     BAD_CAST buffer, NULL);
; 842  :     }
; 843  :     *len = 1;

	mov	DWORD PTR [esi], 1

; 844  :     return ((int) *cur);

	movzx	eax, BYTE PTR [edi]
	pop	ebx
	pop	edi

; 845  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlStringC:
	pop	ebx
	pop	edi

; 822  :         (ctxt->input->end - ctxt->input->cur < 4)) {
; 823  : 	*len = 0;

	mov	DWORD PTR [esi], 0

; 824  : 	return(0);

	xor	eax, eax

; 845  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlStringC:
	pop	edi

; 750  :     if ((len == NULL) || (cur == NULL)) return(0);

	xor	eax, eax

; 845  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStringCurrentChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewInputStream
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlNewInputStream PROC					; COMDAT

; 1362 : xmlNewInputStream(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlNewInpu

; 115  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlNewInpu
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN6@xmlNewInpu
	cmp	DWORD PTR [eax+172], -1
	je	SHORT $LN9@xmlNewInpu
$LN6@xmlNewInpu:

; 116  :         (ctxt->instate == XML_PARSER_EOF))
; 117  : 	return;
; 118  :     if (ctxt != NULL) {
; 119  :         ctxt->errNo = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+84], 2

; 120  :         ctxt->instate = XML_PARSER_EOF;

	mov	DWORD PTR [eax+172], -1

; 121  :         ctxt->disableSAX = 1;

	mov	DWORD PTR [eax+212], 1
$LN7@xmlNewInpu:

; 122  :     }
; 123  :     if (extra)
; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
	push	0
	push	0
	push	3
	push	2
	push	1
	push	0
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN9@xmlNewInpu:

; 1363 :     xmlParserInputPtr input;
; 1364 : 
; 1365 :     input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
; 1366 :     if (input == NULL) {
; 1367 :         xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
; 1368 : 	return(NULL);

	xor	eax, eax

; 1382 : 
; 1383 :     return(input);
; 1384 : }

	pop	ebp
	ret	0
$LN2@xmlNewInpu:

; 1369 :     }
; 1370 :     memset(input, 0, sizeof(xmlParserInput));
; 1371 :     input->line = 1;
; 1372 :     input->col = 1;
; 1373 :     input->standalone = -1;
; 1374 : 
; 1375 :     /*
; 1376 :      * If the context is NULL the id cannot be initialized, but that
; 1377 :      * should not happen while parsing which is the situation where
; 1378 :      * the id is actually needed.
; 1379 :      */
; 1380 :     if (ctxt != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+56], 0
	mov	DWORD PTR [eax+28], 1
	mov	DWORD PTR [eax+32], 1
	mov	DWORD PTR [eax+52], -1
	test	edx, edx
	je	SHORT $LN1@xmlNewInpu

; 1381 :         input->id = ctxt->input_id++;

	mov	ecx, DWORD PTR [edx+464]
	mov	DWORD PTR [eax+56], ecx
	inc	DWORD PTR [edx+464]
$LN1@xmlNewInpu:

; 1382 : 
; 1383 :     return(input);
; 1384 : }

	pop	ebp
	ret	0
_xmlNewInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewInputFromFile
_TEXT	SEGMENT
_directory$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlNewInputFromFile PROC				; COMDAT

; 1526 : xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlParserDebugEntities
	mov	ebx, DWORD PTR _filename$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@xmlNewInpu

; 1527 :     xmlParserInputBufferPtr buf;
; 1528 :     xmlParserInputPtr inputStream;
; 1529 :     char *directory = NULL;
; 1530 :     xmlChar *URI = NULL;
; 1531 : 
; 1532 :     if (xmlParserDebugEntities)
; 1533 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN2@xmlNewInpu:

; 1534 : 		"new input from file: %s\n", filename);
; 1535 :     if (ctxt == NULL) return(NULL);

	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN15@xmlNewInpu

; 1536 :     buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);

	push	0
	push	ebx
	call	_xmlParserInputBufferCreateFilename
	mov	esi, eax
	add	esp, 8

; 1537 :     if (buf == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlNewInpu

; 1538 : 	if (filename == NULL)
; 1539 : 	    __xmlLoaderErr(ctxt,
; 1540 : 	                   "failed to load external entity: NULL filename \n",
; 1541 : 			   NULL);
; 1542 : 	else
; 1543 : 	    __xmlLoaderErr(ctxt, "failed to load external entity \"%s\"\n",
; 1544 : 			   (const char *) filename);
; 1545 : 	return(NULL);

	mov	ecx, OFFSET ??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@
	test	ebx, ebx
	mov	eax, OFFSET ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
	push	ebx
	cmove	eax, ecx
	push	eax
	push	edi
	call	___xmlLoaderErr
	add	esp, 12					; 0000000cH
$LN15@xmlNewInpu:

; 1571 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlNewInpu:

; 1546 :     }
; 1547 : 
; 1548 :     inputStream = xmlNewInputStream(ctxt);

	push	edi
	call	_xmlNewInputStream
	add	esp, 4

; 1549 :     if (inputStream == NULL)

	test	eax, eax
	je	SHORT $LN15@xmlNewInpu

; 1550 : 	return(NULL);
; 1551 : 
; 1552 :     inputStream->buf = buf;
; 1553 :     inputStream = xmlCheckHTTPInput(ctxt, inputStream);

	push	eax
	push	edi
	mov	DWORD PTR [eax], esi
	call	_xmlCheckHTTPInput
	mov	esi, eax
	add	esp, 8

; 1554 :     if (inputStream == NULL)

	test	esi, esi
	je	SHORT $LN15@xmlNewInpu

; 1555 :         return(NULL);
; 1556 : 
; 1557 :     if (inputStream->filename == NULL)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	cmove	ecx, ebx

; 1558 : 	URI = xmlStrdup((xmlChar *) filename);
; 1559 :     else
; 1560 : 	URI = xmlStrdup((xmlChar *) inputStream->filename);
; 1561 :     directory = xmlParserGetDirectory((const char *) URI);

	push	ecx
	call	_xmlStrdup
	mov	ebx, eax
	push	ebx
	call	_xmlParserGetDirectory
	mov	DWORD PTR _directory$1$[ebp], eax
	add	esp, 8

; 1562 :     if (inputStream->filename != NULL) xmlFree((char *)inputStream->filename);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN11@xmlNewInpu
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlNewInpu:

; 1563 :     inputStream->filename = (char *) xmlCanonicPath((const xmlChar *) URI);

	push	ebx
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 1564 :     if (URI != NULL) xmlFree((char *) URI);

	test	ebx, ebx
	je	SHORT $LN12@xmlNewInpu
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlNewInpu:

; 1565 :     inputStream->directory = directory;
; 1566 : 
; 1567 :     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR _directory$1$[ebp]
	mov	DWORD PTR [esi+8], ebx
	push	esi
	push	DWORD PTR [eax+16]
	call	_xmlBufResetInput
	add	esp, 8

; 1568 :     if ((ctxt->directory == NULL) && (directory != NULL))

	cmp	DWORD PTR [edi+180], 0
	jne	SHORT $LN13@xmlNewInpu
	test	ebx, ebx
	je	SHORT $LN13@xmlNewInpu

; 1569 :         ctxt->directory = (char *) xmlStrdup((const xmlChar *) directory);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+180], eax
$LN13@xmlNewInpu:

; 1570 :     return(inputStream);

	pop	edi
	mov	eax, esi

; 1571 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlNewInputFromFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlFreeInputStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_xmlFreeInputStream PROC				; COMDAT

; 1339 : xmlFreeInputStream(xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _input$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeInp

; 1340 :     if (input == NULL) return;
; 1341 : 
; 1342 :     if (input->filename != NULL) xmlFree((char *) input->filename);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlFreeInp
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeInp:

; 1343 :     if (input->directory != NULL) xmlFree((char *) input->directory);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlFreeInp
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeInp:

; 1344 :     if (input->encoding != NULL) xmlFree((char *) input->encoding);

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN5@xmlFreeInp
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeInp:

; 1345 :     if (input->version != NULL) xmlFree((char *) input->version);

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN6@xmlFreeInp
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlFreeInp:

; 1346 :     if ((input->free != NULL) && (input->base != NULL))

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN7@xmlFreeInp
	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN7@xmlFreeInp

; 1347 :         input->free((xmlChar *) input->base);

	push	ecx
	call	eax
	add	esp, 4
$LN7@xmlFreeInp:

; 1348 :     if (input->buf != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@xmlFreeInp

; 1349 :         xmlFreeParserInputBuffer(input->buf);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN8@xmlFreeInp:

; 1350 :     xmlFree(input);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeInp:
	pop	esi

; 1351 : }

	pop	ebp
	ret	0
_xmlFreeInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewEntityInputStream
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_entity$ = 12						; size = 4
_xmlNewEntityInputStream PROC				; COMDAT

; 1430 : xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _entity$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlNewEnti

; 1431 :     xmlParserInputPtr input;
; 1432 : 
; 1433 :     if (entity == NULL) {
; 1434 :         xmlErrInternal(ctxt, "xmlNewEntityInputStream entity = NULL\n",

	push	ebx
	push	OFFSET ??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1435 : 	               NULL);
; 1436 : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN4@xmlNewEnti:
	push	esi

; 1437 :     }
; 1438 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlNewEnti

; 1439 : 	xmlGenericError(xmlGenericErrorContext,

	push	edi
	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+8]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
$LN5@xmlNewEnti:

; 1440 : 		"new input from entity: %s\n", entity->name);
; 1441 :     if (entity->content == NULL) {

	cmp	DWORD PTR [ebx+40], 0
	jne	$LN6@xmlNewEnti

; 1442 : 	switch (entity->etype) {

	mov	eax, DWORD PTR [ebx+48]
	dec	eax
	cmp	eax, 5
	ja	$LN16@xmlNewEnti
	jmp	DWORD PTR $LN19@xmlNewEnti[eax*4]
$LN7@xmlNewEnti:

; 1443 :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1444 : 	        xmlErrInternal(ctxt, "Cannot parse entity %s\n",

	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1471 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN8@xmlNewEnti:

; 1445 : 		               entity->name);
; 1446 :                 break;
; 1447 :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1448 :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 1449 : 		return(xmlLoadExternalEntity((char *) entity->URI,

	push	DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [ebx+52]
	push	DWORD PTR [ebx+64]
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN9@xmlNewEnti:

; 1450 : 		       (char *) entity->ExternalID, ctxt));
; 1451 :             case XML_INTERNAL_GENERAL_ENTITY:
; 1452 : 	        xmlErrInternal(ctxt,

	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1471 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN10@xmlNewEnti:

; 1453 : 		      "Internal entity %s without content !\n",
; 1454 : 		               entity->name);
; 1455 :                 break;
; 1456 :             case XML_INTERNAL_PARAMETER_ENTITY:
; 1457 : 	        xmlErrInternal(ctxt,

	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1471 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN11@xmlNewEnti:

; 1458 : 		      "Internal parameter entity %s without content !\n",
; 1459 : 		               entity->name);
; 1460 :                 break;
; 1461 :             case XML_INTERNAL_PREDEFINED_ENTITY:
; 1462 : 	        xmlErrInternal(ctxt,

	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1471 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN6@xmlNewEnti:

; 1463 : 		      "Predefined entity %s without content !\n",
; 1464 : 		               entity->name);
; 1465 :                 break;
; 1466 : 	}
; 1467 : 	return(NULL);
; 1468 :     }
; 1469 :     input = xmlNewInputStream(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlNewInputStream
	mov	esi, eax
	add	esp, 4

; 1470 :     if (input == NULL) {

	test	esi, esi
	jne	SHORT $LN12@xmlNewEnti
$LN16@xmlNewEnti:
	pop	esi

; 1471 : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN12@xmlNewEnti:

; 1472 :     }
; 1473 :     if (entity->URI != NULL)

	mov	eax, DWORD PTR [ebx+64]
	test	eax, eax
	je	SHORT $LN13@xmlNewEnti

; 1474 : 	input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN13@xmlNewEnti:

; 1475 :     input->base = entity->content;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+12], eax

; 1476 :     if (entity->length == 0)

	cmp	DWORD PTR [ebx+44], 0
	jne	SHORT $LN14@xmlNewEnti

; 1477 :         entity->length = xmlStrlen(entity->content);

	push	DWORD PTR [ebx+40]
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR [ebx+44], eax
$LN14@xmlNewEnti:

; 1478 :     input->cur = entity->content;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+16], eax

; 1479 :     input->length = entity->length;

	mov	ecx, DWORD PTR [ebx+44]
	mov	DWORD PTR [esi+24], ecx

; 1480 :     input->end = &entity->content[input->length];

	mov	eax, DWORD PTR [ebx+40]
	add	eax, ecx
	mov	DWORD PTR [esi+20], eax

; 1481 :     return(input);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
	npad	1
$LN19@xmlNewEnti:
	DD	$LN9@xmlNewEnti
	DD	$LN8@xmlNewEnti
	DD	$LN7@xmlNewEnti
	DD	$LN10@xmlNewEnti
	DD	$LN8@xmlNewEnti
	DD	$LN11@xmlNewEnti
_xmlNewEntityInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewStringInputStream
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_xmlNewStringInputStream PROC				; COMDAT

; 1493 : xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buffer$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlNewStri

; 1494 :     xmlParserInputPtr input;
; 1495 : 
; 1496 :     if (buffer == NULL) {
; 1497 :         xmlErrInternal(ctxt, "xmlNewStringInputStream string = NULL\n",

	push	edi
	push	OFFSET ??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1498 : 	               NULL);
; 1499 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 1514 : }

	pop	ebp
	ret	0
$LN2@xmlNewStri:
	push	esi

; 1500 :     }
; 1501 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlNewStri

; 1502 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN3@xmlNewStri:

; 1503 : 		"new fixed input: %.30s\n", buffer);
; 1504 :     input = xmlNewInputStream(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlNewInputStream
	mov	esi, eax
	add	esp, 4

; 1505 :     if (input == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlNewStri

; 1506 :         xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");

	push	OFFSET ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlErrMemory
	add	esp, 8

; 1507 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1514 : }

	pop	ebp
	ret	0
$LN4@xmlNewStri:

; 1508 :     }
; 1509 :     input->base = buffer;
; 1510 :     input->cur = buffer;
; 1511 :     input->length = xmlStrlen(buffer);

	push	edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR [esi+24], eax

; 1512 :     input->end = &buffer[input->length];

	add	eax, edi
	mov	DWORD PTR [esi+20], eax

; 1513 :     return(input);

	mov	eax, esi
	pop	esi
	pop	edi

; 1514 : }

	pop	ebp
	ret	0
_xmlNewStringInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT ___xmlErrEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlerr$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
___xmlErrEncoding PROC					; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _xmlerr$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlErrEnco

; 148  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [esi+212], 0
	je	SHORT $LN2@xmlErrEnco
	cmp	DWORD PTR [esi+172], -1
	je	SHORT $LN5@xmlErrEnco
$LN2@xmlErrEnco:

; 149  :         (ctxt->instate == XML_PARSER_EOF))
; 150  : 	return;
; 151  :     if (ctxt != NULL)
; 152  :         ctxt->errNo = xmlerr;

	mov	DWORD PTR [esi+84], edx
$LN3@xmlErrEnco:

; 153  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	3
	push	edx
	push	1
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 154  :                     ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
; 155  :                     NULL, 0, (const char *) str1, (const char *) str2,
; 156  :                     NULL, 0, 0, msg, str1, str2);
; 157  :     if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlErrEnco

; 158  :         ctxt->wellFormed = 0;
; 159  :         if (ctxt->recovery == 0)

	cmp	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+12], 0
	jne	SHORT $LN5@xmlErrEnco

; 160  :             ctxt->disableSAX = 1;

	mov	DWORD PTR [esi+212], 1
$LN5@xmlErrEnco:
	pop	esi

; 161  :     }
; 162  : }

	pop	ebp
	ret	0
___xmlErrEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchInputEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_handler$ = 16						; size = 4
_xmlSwitchInputEncoding PROC				; COMDAT

; 1271 :                           xmlCharEncodingHandlerPtr handler) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	push	-1
	push	DWORD PTR _handler$[ebp]
	push	DWORD PTR _input$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSwitchInputEncodingInt
	add	esp, 16					; 00000010H

; 1272 :     return(xmlSwitchInputEncodingInt(ctxt, input, handler, -1));
; 1273 : }

	pop	ebp
	ret	0
_xmlSwitchInputEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchToEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_handler$ = 12						; size = 4
_xmlSwitchToEncoding PROC				; COMDAT

; 1322 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1293 :     if (handler != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlSwitchT

; 1294 :         if (ctxt->input != NULL) {

	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN6@xmlSwitchT

; 1295 : 	    ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);

	push	-1
	push	eax
	push	ecx
	push	esi
	call	_xmlSwitchInputEncodingInt
	add	esp, 16					; 00000010H

; 1298 : 	                   NULL);
; 1299 : 	    return(-1);
; 1300 : 	}
; 1301 : 	/*
; 1302 : 	 * The parsing is now done in UTF8 natively
; 1303 : 	 */
; 1304 : 	ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	DWORD PTR [esi+256], 1
	pop	esi

; 1324 : }

	pop	ebp
	ret	0
$LN6@xmlSwitchT:

; 1297 : 	    xmlErrInternal(ctxt, "xmlSwitchToEncoding : no input\n",

	push	0
	push	OFFSET ??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@
	push	esi
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1323 :     return (xmlSwitchToEncodingInt(ctxt, handler, -1));

	or	eax, -1
	pop	esi

; 1324 : }

	pop	ebp
	ret	0
$LN4@xmlSwitchT:

; 1323 :     return (xmlSwitchToEncodingInt(ctxt, handler, -1));

	or	eax, -1

; 1324 : }

	pop	ebp
	ret	0
_xmlSwitchToEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_enc$ = 12						; size = 4
_xmlSwitchEncoding PROC					; COMDAT

; 934  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	or	edi, -1
	test	esi, esi
	jne	SHORT $LN6@xmlSwitchE

; 1114 : }

	or	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSwitchE:
	push	ebx

; 935  :     xmlCharEncodingHandlerPtr handler;
; 936  :     int len = -1;
; 937  :     int ret;
; 938  : 
; 939  :     if (ctxt == NULL) return(-1);
; 940  :     switch (enc) {

	mov	ebx, DWORD PTR _enc$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, 23					; 00000017H
	ja	$LN2@xmlSwitchE
	movzx	eax, BYTE PTR $LN37@xmlSwitchE[eax]
	jmp	DWORD PTR $LN42@xmlSwitchE[eax*4]
$LN7@xmlSwitchE:

; 941  : 	case XML_CHAR_ENCODING_ERROR:
; 942  : 	    __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,

	push	0
	push	0
	push	OFFSET ??_C@_0BC@NFNLFCFA@encoding?5unknown?6@
	push	31					; 0000001fH
	push	esi
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 943  : 	                   "encoding unknown\n", NULL, NULL);
; 944  : 	    return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlSwitchE:

; 945  : 	case XML_CHAR_ENCODING_NONE:
; 946  : 	    /* let's assume it's UTF-8 without the XML decl */
; 947  : 	    ctxt->charset = XML_CHAR_ENCODING_UTF8;
; 948  : 	    return(0);
; 949  : 	case XML_CHAR_ENCODING_UTF8:
; 950  : 	    /* default encoding, no conversion should be needed */
; 951  : 	    ctxt->charset = XML_CHAR_ENCODING_UTF8;
; 952  : 
; 953  : 	    /*
; 954  : 	     * Errata on XML-1.0 June 20 2001
; 955  : 	     * Specific handling of the Byte Order Mark for
; 956  : 	     * UTF-8
; 957  : 	     */
; 958  : 	    if ((ctxt->input != NULL) &&
; 959  : 		(ctxt->input->cur[0] == 0xEF) &&
; 960  : 		(ctxt->input->cur[1] == 0xBB) &&

	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+256], 1
	test	ecx, ecx
	je	SHORT $LN10@xmlSwitchE
	mov	eax, DWORD PTR [ecx+16]
	cmp	BYTE PTR [eax], 239			; 000000efH
	jne	SHORT $LN10@xmlSwitchE
	cmp	BYTE PTR [eax+1], 187			; 000000bbH
	jne	SHORT $LN10@xmlSwitchE
	cmp	BYTE PTR [eax+2], 191			; 000000bfH
	jne	SHORT $LN10@xmlSwitchE

; 961  : 		(ctxt->input->cur[2] == 0xBF)) {
; 962  : 		ctxt->input->cur += 3;

	add	eax, 3
	mov	DWORD PTR [ecx+16], eax
$LN10@xmlSwitchE:

; 963  : 	    }
; 964  : 	    return(0);

	pop	ebx
	pop	edi
	xor	eax, eax

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlSwitchE:

; 965  :     case XML_CHAR_ENCODING_UTF16LE:
; 966  :     case XML_CHAR_ENCODING_UTF16BE:
; 967  :         /*The raw input characters are encoded
; 968  :          *in UTF-16. As we expect this function
; 969  :          *to be called after xmlCharEncInFunc, we expect
; 970  :          *ctxt->input->cur to contain UTF-8 encoded characters.
; 971  :          *So the raw UTF16 Byte Order Mark
; 972  :          *has also been converted into
; 973  :          *an UTF-8 BOM. Let's skip that BOM.
; 974  :          */
; 975  :         if ((ctxt->input != NULL) && (ctxt->input->cur != NULL) &&
; 976  :             (ctxt->input->cur[0] == 0xEF) &&
; 977  :             (ctxt->input->cur[1] == 0xBB) &&

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN12@xmlSwitchE
	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN12@xmlSwitchE
	cmp	BYTE PTR [eax], 239			; 000000efH
	jne	SHORT $LN12@xmlSwitchE
	cmp	BYTE PTR [eax+1], 187			; 000000bbH
	jne	SHORT $LN12@xmlSwitchE
	cmp	BYTE PTR [eax+2], 191			; 000000bfH
	jne	SHORT $LN12@xmlSwitchE

; 978  :             (ctxt->input->cur[2] == 0xBF)) {
; 979  :             ctxt->input->cur += 3;

	add	eax, 3
	mov	DWORD PTR [ecx+16], eax
$LN12@xmlSwitchE:

; 1007 : 	break;
; 1008 :     }
; 1009 :     handler = xmlGetCharEncodingHandler(enc);

	mov	edi, 90					; 0000005aH
	jmp	SHORT $LN2@xmlSwitchE
$LN14@xmlSwitchE:

; 980  :         }
; 981  :         len = 90;
; 982  : 	break;
; 983  :     case XML_CHAR_ENCODING_UCS2:
; 984  :         len = 90;
; 985  : 	break;
; 986  :     case XML_CHAR_ENCODING_UCS4BE:
; 987  :     case XML_CHAR_ENCODING_UCS4LE:
; 988  :     case XML_CHAR_ENCODING_UCS4_2143:
; 989  :     case XML_CHAR_ENCODING_UCS4_3412:
; 990  :         len = 180;

	mov	edi, 180				; 000000b4H

; 991  : 	break;

	jmp	SHORT $LN2@xmlSwitchE
$LN15@xmlSwitchE:

; 992  :     case XML_CHAR_ENCODING_EBCDIC:
; 993  :     case XML_CHAR_ENCODING_8859_1:
; 994  :     case XML_CHAR_ENCODING_8859_2:
; 995  :     case XML_CHAR_ENCODING_8859_3:
; 996  :     case XML_CHAR_ENCODING_8859_4:
; 997  :     case XML_CHAR_ENCODING_8859_5:
; 998  :     case XML_CHAR_ENCODING_8859_6:
; 999  :     case XML_CHAR_ENCODING_8859_7:
; 1000 :     case XML_CHAR_ENCODING_8859_8:
; 1001 :     case XML_CHAR_ENCODING_8859_9:
; 1002 :     case XML_CHAR_ENCODING_ASCII:
; 1003 :     case XML_CHAR_ENCODING_2022_JP:
; 1004 :     case XML_CHAR_ENCODING_SHIFT_JIS:
; 1005 :     case XML_CHAR_ENCODING_EUC_JP:
; 1006 :         len = 45;

	mov	edi, 45					; 0000002dH
$LN2@xmlSwitchE:

; 1007 : 	break;
; 1008 :     }
; 1009 :     handler = xmlGetCharEncodingHandler(enc);

	push	ebx
	call	_xmlGetCharEncodingHandler
	add	esp, 4

; 1010 :     if (handler == NULL) {

	test	eax, eax
	jne	$LN32@xmlSwitchE

; 1011 : 	/*
; 1012 : 	 * Default handlers.
; 1013 : 	 */
; 1014 : 	switch (enc) {

	lea	eax, DWORD PTR [ebx-4]
	cmp	eax, 18					; 00000012H
	ja	$LN36@xmlSwitchE
	movzx	eax, BYTE PTR $LN38@xmlSwitchE[eax]
	jmp	DWORD PTR $LN43@xmlSwitchE[eax*4]
$LN17@xmlSwitchE:
	pop	ebx
	pop	edi

; 1015 : 	    case XML_CHAR_ENCODING_ASCII:
; 1016 : 		/* default encoding, no conversion should be needed */
; 1017 : 		ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	DWORD PTR [esi+256], 1

; 1018 : 		return(0);

	xor	eax, eax

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
$LN20@xmlSwitchE:

; 1019 : 	    case XML_CHAR_ENCODING_UTF16LE:
; 1020 : 		break;
; 1021 : 	    case XML_CHAR_ENCODING_UTF16BE:
; 1022 : 		break;
; 1023 : 	    case XML_CHAR_ENCODING_UCS4LE:
; 1024 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0BD@IJIIAAMB@USC4?5little?5endian@

; 1025 : 			       "encoding not supported %s\n",
; 1026 : 			       BAD_CAST "USC4 little endian", NULL);
; 1027 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN21@xmlSwitchE:

; 1028 : 	    case XML_CHAR_ENCODING_UCS4BE:
; 1029 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0BA@ELDAKMNC@USC4?5big?5endian@

; 1030 : 			       "encoding not supported %s\n",
; 1031 : 			       BAD_CAST "USC4 big endian", NULL);
; 1032 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN22@xmlSwitchE:

; 1033 : 	    case XML_CHAR_ENCODING_EBCDIC:
; 1034 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_06JJAKJGEC@EBCDIC@

; 1035 : 			       "encoding not supported %s\n",
; 1036 : 			       BAD_CAST "EBCDIC", NULL);
; 1037 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN23@xmlSwitchE:

; 1038 : 	    case XML_CHAR_ENCODING_UCS4_2143:
; 1039 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09GAABMJEL@UCS4?52143@

; 1040 : 			       "encoding not supported %s\n",
; 1041 : 			       BAD_CAST "UCS4 2143", NULL);
; 1042 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN24@xmlSwitchE:

; 1043 : 	    case XML_CHAR_ENCODING_UCS4_3412:
; 1044 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09HFGPODGD@UCS4?53412@

; 1045 : 			       "encoding not supported %s\n",
; 1046 : 			       BAD_CAST "UCS4 3412", NULL);
; 1047 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN25@xmlSwitchE:

; 1048 : 	    case XML_CHAR_ENCODING_UCS2:
; 1049 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_04MDAFHLBC@UCS2@

; 1050 : 			       "encoding not supported %s\n",
; 1051 : 			       BAD_CAST "UCS2", NULL);
; 1052 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN26@xmlSwitchE:

; 1053 : 	    case XML_CHAR_ENCODING_8859_1:
; 1054 : 	    case XML_CHAR_ENCODING_8859_2:
; 1055 : 	    case XML_CHAR_ENCODING_8859_3:
; 1056 : 	    case XML_CHAR_ENCODING_8859_4:
; 1057 : 	    case XML_CHAR_ENCODING_8859_5:
; 1058 : 	    case XML_CHAR_ENCODING_8859_6:
; 1059 : 	    case XML_CHAR_ENCODING_8859_7:
; 1060 : 	    case XML_CHAR_ENCODING_8859_8:
; 1061 : 	    case XML_CHAR_ENCODING_8859_9:
; 1062 : 		/*
; 1063 : 		 * We used to keep the internal content in the
; 1064 : 		 * document encoding however this turns being unmaintainable
; 1065 : 		 * So xmlGetCharEncodingHandler() will return non-null
; 1066 : 		 * values for this now.
; 1067 : 		 */
; 1068 : 		if ((ctxt->inputNr == 1) &&
; 1069 : 		    (ctxt->encoding == NULL) &&
; 1070 : 		    (ctxt->input != NULL) &&

	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN27@xmlSwitchE
	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN27@xmlSwitchE
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN27@xmlSwitchE
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN27@xmlSwitchE

; 1071 : 		    (ctxt->input->encoding != NULL)) {
; 1072 : 		    ctxt->encoding = xmlStrdup(ctxt->input->encoding);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
$LN27@xmlSwitchE:

; 1073 : 		}
; 1074 : 		ctxt->charset = enc;

	mov	DWORD PTR [esi+256], ebx

; 1075 : 		return(0);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
$LN28@xmlSwitchE:

; 1076 : 	    case XML_CHAR_ENCODING_2022_JP:
; 1077 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@

; 1078 : 			       "encoding not supported %s\n",
; 1079 : 			       BAD_CAST "ISO-2022-JP", NULL);
; 1080 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN29@xmlSwitchE:

; 1081 : 	    case XML_CHAR_ENCODING_SHIFT_JIS:
; 1082 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09LOKLFMHN@Shift_JIS@

; 1083 : 			       "encoding not supported %s\n",
; 1084 : 			       BAD_CAST "Shift_JIS", NULL);
; 1085 : 		break;

	jmp	SHORT $LN40@xmlSwitchE
$LN30@xmlSwitchE:

; 1086 : 	    case XML_CHAR_ENCODING_EUC_JP:
; 1087 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_06KCFOODCD@EUC?9JP@
$LN40@xmlSwitchE:

; 1088 : 			       "encoding not supported %s\n",
; 1089 : 			       BAD_CAST "EUC-JP", NULL);
; 1090 : 		break;
; 1091 : 	    default:
; 1092 : 	        break;
; 1093 : 	}
; 1094 :     }
; 1095 :     /*
; 1096 :      * TODO: We could recover from errors in external entites if we
; 1097 :      * didn't stop the parser. But most callers of this function don't
; 1098 :      * check the return value.
; 1099 :      */
; 1100 :     if (handler == NULL) {
; 1101 :         xmlStopParser(ctxt);

	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	push	esi
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H
$LN36@xmlSwitchE:
	push	esi
	call	_xmlStopParser
	add	esp, 4

; 1102 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
$LN32@xmlSwitchE:

; 1103 :     }
; 1104 :     ctxt->charset = XML_CHAR_ENCODING_UTF8;
; 1105 :     ret = xmlSwitchToEncodingInt(ctxt, handler, len);

	push	edi
	push	eax
	push	esi
	mov	DWORD PTR [esi+256], 1
	call	_xmlSwitchToEncodingInt
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1106 :     if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {

	test	edi, edi
	js	SHORT $LN34@xmlSwitchE
	cmp	DWORD PTR [esi+84], 6003		; 00001773H
	jne	SHORT $LN33@xmlSwitchE
$LN34@xmlSwitchE:

; 1107 :         /*
; 1108 : 	 * on encoding conversion errors, stop the parser
; 1109 : 	 */
; 1110 :         xmlStopParser(ctxt);

	push	esi
	call	_xmlStopParser
	add	esp, 4

; 1111 : 	ctxt->errNo = XML_I18N_CONV_FAILED;

	mov	DWORD PTR [esi+84], 6003		; 00001773H
$LN33@xmlSwitchE:

; 1112 :     }
; 1113 :     return(ret);

	pop	ebx
	mov	eax, edi
	pop	edi

; 1114 : }

	pop	esi
	pop	ebp
	ret	0
	npad	3
$LN42@xmlSwitchE:
	DD	$LN7@xmlSwitchE
	DD	$LN17@xmlSwitchE
	DD	$LN9@xmlSwitchE
	DD	$LN11@xmlSwitchE
	DD	$LN14@xmlSwitchE
	DD	$LN15@xmlSwitchE
	DD	$LN12@xmlSwitchE
$LN37@xmlSwitchE:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	5
	DB	4
	DB	4
	DB	6
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
$LN43@xmlSwitchE:
	DD	$LN20@xmlSwitchE
	DD	$LN21@xmlSwitchE
	DD	$LN22@xmlSwitchE
	DD	$LN23@xmlSwitchE
	DD	$LN24@xmlSwitchE
	DD	$LN25@xmlSwitchE
	DD	$LN26@xmlSwitchE
	DD	$LN28@xmlSwitchE
	DD	$LN29@xmlSwitchE
	DD	$LN30@xmlSwitchE
	DD	$LN17@xmlSwitchE
$LN38@xmlSwitchE:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
_xmlSwitchEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlIsLetter
_TEXT	SEGMENT
_c$ = 8							; size = 4
_xmlIsLetter PROC					; COMDAT

; 229  : xmlIsLetter(int c) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _c$[ebp]
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN9@xmlIsLette

; 230  :     return(IS_BASECHAR(c) || IS_IDEOGRAPHIC(c));

	cmp	esi, 65					; 00000041H
	jl	SHORT $LN3@xmlIsLette
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN17@xmlIsLette
$LN3@xmlIsLette:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN4@xmlIsLette
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN17@xmlIsLette
$LN4@xmlIsLette:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN6@xmlIsLette
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN17@xmlIsLette
$LN6@xmlIsLette:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN7@xmlIsLette
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN17@xmlIsLette
$LN7@xmlIsLette:
	cmp	esi, 248				; 000000f8H
	jl	SHORT $LN19@xmlIsLette
$LN17@xmlIsLette:
	mov	eax, 1
	pop	esi

; 231  : }

	pop	ebp
	ret	0
$LN9@xmlIsLette:

; 230  :     return(IS_BASECHAR(c) || IS_IDEOGRAPHIC(c));

	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlIsLette
$LN19@xmlIsLette:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN20@xmlIsLette
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN11@xmlIsLette
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN17@xmlIsLette
$LN11@xmlIsLette:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN17@xmlIsLette
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN20@xmlIsLette
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN17@xmlIsLette
$LN20@xmlIsLette:
	xor	eax, eax
	pop	esi

; 231  : }

	pop	ebp
	ret	0
_xmlIsLetter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserAddNodeInfo
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pos$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_info$ = 12						; size = 4
_xmlParserAddNodeInfo PROC				; COMDAT

; 2013 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	test	ebx, ebx
	je	$LN6@xmlParserA

; 2014 :     unsigned long pos;
; 2015 : 
; 2016 :     if ((ctxt == NULL) || (info == NULL)) return;

	push	edi
	mov	edi, DWORD PTR _info$[ebp]
	test	edi, edi
	je	$LN23@xmlParserA

; 2017 : 
; 2018 :     /* Find pos and check to see if node is already in the sequence */
; 2019 :     pos = xmlParserFindNodeInfoIndex(&ctxt->node_seq, (xmlNodePtr)

	push	esi
	push	DWORD PTR [edi]
	lea	esi, DWORD PTR [ebx+72]
	push	esi
	call	_xmlParserFindNodeInfoIndex

; 2020 :                                      info->node);
; 2021 : 
; 2022 :     if ((pos < ctxt->node_seq.length) &&
; 2023 :         (ctxt->node_seq.buffer != NULL) &&

	mov	edx, DWORD PTR [ebx+76]
	add	esp, 8
	mov	DWORD PTR _pos$1$[ebp], eax
	cmp	eax, edx
	jae	SHORT $LN7@xmlParserA
	mov	ecx, DWORD PTR [ebx+80]
	test	ecx, ecx
	je	SHORT $LN7@xmlParserA
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN7@xmlParserA

; 2024 :         (ctxt->node_seq.buffer[pos].node == info->node)) {
; 2025 :         ctxt->node_seq.buffer[pos] = *info;

	movups	xmm0, XMMWORD PTR [edi]
	pop	esi
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [edi+16]
	pop	edi
	mov	DWORD PTR [ecx+16], eax
	pop	ebx

; 2066 :     }
; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParserA:

; 2026 :     }
; 2027 : 
; 2028 :     /* Otherwise, we need to add new node to buffer */
; 2029 :     else {
; 2030 :         if ((ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) ||

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	eax, ecx
	ja	SHORT $LN22@xmlParserA
	mov	ecx, DWORD PTR [ebx+80]
	test	ecx, ecx
	jne	SHORT $LN9@xmlParserA
	mov	ecx, DWORD PTR $T1[ebp]
$LN22@xmlParserA:

; 2031 : 	    (ctxt->node_seq.buffer == NULL)) {
; 2032 :             xmlParserNodeInfo *tmp_buffer;
; 2033 :             unsigned int byte_size;
; 2034 : 
; 2035 :             if (ctxt->node_seq.maximum == 0)

	test	ecx, ecx
	jne	SHORT $LN11@xmlParserA

; 2036 :                 ctxt->node_seq.maximum = 2;

	mov	DWORD PTR [ebx+72], 2
	mov	ecx, 2
$LN11@xmlParserA:

; 2037 :             byte_size = (sizeof(*ctxt->node_seq.buffer) *

	lea	eax, DWORD PTR [ecx+ecx*4]

; 2038 : 			(2 * ctxt->node_seq.maximum));
; 2039 : 
; 2040 :             if (ctxt->node_seq.buffer == NULL)

	mov	ecx, DWORD PTR [ebx+80]
	shl	eax, 3
	push	eax
	test	ecx, ecx
	jne	SHORT $LN12@xmlParserA

; 2041 :                 tmp_buffer = (xmlParserNodeInfo *) xmlMalloc(byte_size);

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	jmp	SHORT $LN25@xmlParserA
$LN12@xmlParserA:

; 2042 :             else
; 2043 :                 tmp_buffer =

	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
$LN25@xmlParserA:

; 2044 :                     (xmlParserNodeInfo *) xmlRealloc(ctxt->node_seq.buffer,
; 2045 :                                                      byte_size);
; 2046 : 
; 2047 :             if (tmp_buffer == NULL) {

	mov	ecx, eax
	test	ecx, ecx
	jne	SHORT $LN14@xmlParserA

; 2048 : 		xmlErrMemory(ctxt, "failed to allocate buffer\n");

	push	OFFSET ??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@
	push	ebx
	call	_xmlErrMemory
	add	esp, 8
	pop	esi
	pop	edi
	pop	ebx

; 2066 :     }
; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlParserA:

; 2049 :                 return;
; 2050 :             }
; 2051 :             ctxt->node_seq.buffer = tmp_buffer;
; 2052 :             ctxt->node_seq.maximum *= 2;

	mov	eax, DWORD PTR [ebx+72]
	mov	edx, DWORD PTR [ebx+76]
	add	eax, eax
	mov	DWORD PTR [ebx+80], ecx
	mov	DWORD PTR [ebx+72], eax
$LN9@xmlParserA:

; 2053 :         }
; 2054 : 
; 2055 :         /* If position is not at end, move elements out of the way */
; 2056 :         if (pos != ctxt->node_seq.length) {

	mov	eax, DWORD PTR _pos$1$[ebp]
	cmp	eax, edx

; 2057 :             unsigned long i;
; 2058 : 
; 2059 :             for (i = ctxt->node_seq.length; i > pos; i--)

	jae	SHORT $LN3@xmlParserA
	lea	edi, DWORD PTR [edx+edx*4]
	shl	edi, 2
	sub	edx, eax
$LL4@xmlParserA:

; 2060 :                 ctxt->node_seq.buffer[i] = ctxt->node_seq.buffer[i - 1];

	mov	ecx, DWORD PTR [ebx+80]
	add	ecx, edi
	add	edi, -20				; ffffffecH
	movups	xmm0, XMMWORD PTR [ecx-20]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [ecx-4]
	mov	DWORD PTR [ecx+16], eax
	sub	edx, 1
	jne	SHORT $LL4@xmlParserA

; 2026 :     }
; 2027 : 
; 2028 :     /* Otherwise, we need to add new node to buffer */
; 2029 :     else {
; 2030 :         if ((ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) ||

	mov	ecx, DWORD PTR [ebx+80]
	mov	edi, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _pos$1$[ebp]
$LN3@xmlParserA:

; 2061 :         }
; 2062 : 
; 2063 :         /* Copy element and increase length */
; 2064 :         ctxt->node_seq.buffer[pos] = *info;

	movups	xmm0, XMMWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+16], eax

; 2065 :         ctxt->node_seq.length++;

	inc	DWORD PTR [ebx+76]
	pop	esi
$LN23@xmlParserA:
	pop	edi
$LN6@xmlParserA:
	pop	ebx

; 2066 :     }
; 2067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserAddNodeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserFindNodeInfoIndex
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlParserFindNodeInfoIndex PROC			; COMDAT

; 1974 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _seq$[ebp]
	xor	ebx, ebx
	test	ecx, ecx
	je	SHORT $LN5@xmlParserF

; 1975 :     unsigned long upper, lower, middle;
; 1976 :     int found = 0;
; 1977 : 
; 1978 :     if ((seq == NULL) || (node == NULL))

	cmp	DWORD PTR _node$[ebp], ebx
	je	SHORT $LN5@xmlParserF

; 1980 : 
; 1981 :     /* Do a binary search for the key */
; 1982 :     lower = 1;

	push	edi

; 1983 :     upper = seq->length;

	mov	edi, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ebx+1]

; 1984 :     middle = 0;

	xor	eax, eax

; 1985 :     while (lower <= upper && !found) {

	cmp	edi, esi
	jb	SHORT $LN18@xmlParserF
	npad	6
$LL2@xmlParserF:
	test	ebx, ebx
	jne	SHORT $LN17@xmlParserF

; 1986 :         middle = lower + (upper - lower) / 2;
; 1987 :         if (node == seq->buffer[middle - 1].node)

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, edi
	sub	eax, esi
	shr	eax, 1
	add	eax, esi
	lea	edx, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [ecx+edx*4-20]
	cmp	DWORD PTR _node$[ebp], ecx
	jne	SHORT $LN6@xmlParserF

; 1988 :             found = 1;

	mov	ebx, 1
	jmp	SHORT $LN9@xmlParserF
$LN6@xmlParserF:

; 1989 :         else if (node < seq->buffer[middle - 1].node)

	jae	SHORT $LN8@xmlParserF

; 1990 :             upper = middle - 1;

	lea	edi, DWORD PTR [eax-1]
	jmp	SHORT $LN9@xmlParserF
$LN8@xmlParserF:

; 1991 :         else
; 1992 :             lower = middle + 1;

	lea	esi, DWORD PTR [eax+1]
$LN9@xmlParserF:

; 1985 :     while (lower <= upper && !found) {

	mov	ecx, DWORD PTR _seq$[ebp]
	cmp	esi, edi
	jbe	SHORT $LL2@xmlParserF
$LN17@xmlParserF:

; 1993 :     }
; 1994 : 
; 1995 :     /* Return position */
; 1996 :     if (middle == 0 || seq->buffer[middle - 1].node < node)

	test	eax, eax
	je	SHORT $LN18@xmlParserF
	mov	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+edx*4-20], esi
	jb	SHORT $LN18@xmlParserF

; 1997 :         return middle;
; 1998 :     else
; 1999 :         return middle - 1;

	dec	eax
$LN18@xmlParserF:
	pop	edi
	pop	esi

; 2000 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlParserF:
	pop	esi

; 1979 :         return ((unsigned long) -1);

	or	eax, -1

; 2000 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlParserFindNodeInfoIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlClearNodeInfoSeq
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_xmlClearNodeInfoSeq PROC				; COMDAT

; 1952 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _seq$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlClearNo

; 1953 :     if (seq == NULL)
; 1954 :         return;
; 1955 :     if (seq->buffer != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlClearNo

; 1956 :         xmlFree(seq->buffer);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlClearNo:

; 1938 :     seq->length = 0;

	mov	DWORD PTR [esi+4], 0

; 1939 :     seq->maximum = 0;

	mov	DWORD PTR [esi], 0

; 1940 :     seq->buffer = NULL;

	mov	DWORD PTR [esi+8], 0
$LN5@xmlClearNo:
	pop	esi

; 1957 :     xmlInitNodeInfoSeq(seq);
; 1958 : }

	pop	ebp
	ret	0
_xmlClearNodeInfoSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlInitNodeInfoSeq
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_xmlInitNodeInfoSeq PROC				; COMDAT

; 1935 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _seq$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlInitNod

; 1936 :     if (seq == NULL)
; 1937 :         return;
; 1938 :     seq->length = 0;
; 1939 :     seq->maximum = 0;

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], 0

; 1940 :     seq->buffer = NULL;

	mov	DWORD PTR [eax+8], 0
$LN1@xmlInitNod:

; 1941 : }

	pop	ebp
	ret	0
_xmlInitNodeInfoSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserFindNodeInfo
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlParserFindNodeInfo PROC				; COMDAT

; 1912 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlParserF

; 1913 :     unsigned long pos;
; 1914 : 
; 1915 :     if ((ctx == NULL) || (node == NULL))

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlParserF

; 1917 :     /* Find position where node should be at */
; 1918 :     pos = xmlParserFindNodeInfoIndex(&ctx->node_seq, node);

	lea	eax, DWORD PTR [esi+72]
	push	edi
	push	eax
	call	_xmlParserFindNodeInfoIndex
	add	esp, 8

; 1919 :     if (pos < ctx->node_seq.length
; 1920 :         && ctx->node_seq.buffer[pos].node == node)

	cmp	eax, DWORD PTR [esi+76]
	jae	SHORT $LN3@xmlParserF
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+80]
	cmp	DWORD PTR [eax+ecx*4], edi
	lea	eax, DWORD PTR [eax+ecx*4]
	je	SHORT $LN5@xmlParserF
$LN3@xmlParserF:

; 1916 :         return (NULL);

	xor	eax, eax
$LN5@xmlParserF:
	pop	edi

; 1921 :         return &ctx->node_seq.buffer[pos];
; 1922 :     else
; 1923 :         return NULL;
; 1924 : }

	pop	esi
	pop	ebp
	ret	0
_xmlParserFindNodeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewIOInputStream
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlNewIOInputStream PROC				; COMDAT

; 1399 : 	            xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _input$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlNewIOIn

; 1400 :     xmlParserInputPtr inputStream;
; 1401 : 
; 1402 :     if (input == NULL) return(NULL);
; 1403 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlNewIOIn

; 1404 : 	xmlGenericError(xmlGenericErrorContext, "new input from I/O\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN3@xmlNewIOIn:

; 1405 :     inputStream = xmlNewInputStream(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlNewInputStream
	mov	esi, eax
	add	esp, 4

; 1406 :     if (inputStream == NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlNewIOIn

; 1408 :     }
; 1409 :     inputStream->filename = NULL;

	mov	DWORD PTR [esi+4], 0

; 1410 :     inputStream->buf = input;

	mov	DWORD PTR [esi], edi

; 1411 :     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	push	esi
	push	DWORD PTR [edi+16]
	call	_xmlBufResetInput

; 1412 : 
; 1413 :     if (enc != XML_CHAR_ENCODING_NONE) {

	mov	eax, DWORD PTR _enc$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlNewIOIn

; 1414 :         xmlSwitchEncoding(ctxt, enc);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSwitchEncoding
	add	esp, 8
$LN5@xmlNewIOIn:

; 1415 :     }
; 1416 : 
; 1417 :     return(inputStream);

	pop	edi
	mov	eax, esi

; 1418 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlNewIOIn:
	pop	edi

; 1407 : 	return(NULL);

	xor	eax, eax

; 1418 : }

	pop	esi
	pop	ebp
	ret	0
_xmlNewIOInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlFreeParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreeParserCtxt PROC					; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlFreePar

; 1777 :     xmlParserInputPtr input;
; 1778 : 
; 1779 :     if (ctxt == NULL) return;
; 1780 : 
; 1781 :     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	push	edi
	call	_inputPop
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlFreePar
$LL2@xmlFreePar:

; 1782 :         xmlFreeInputStream(input);

	push	eax
	call	_xmlFreeInputStream
	push	edi
	call	_inputPop
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlFreePar
$LN3@xmlFreePar:

; 1783 :     }
; 1784 :     if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);

	mov	eax, DWORD PTR [edi+244]
	test	eax, eax
	je	SHORT $LN9@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreePar:

; 1785 :     if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);

	mov	eax, DWORD PTR [edi+196]
	test	eax, eax
	je	SHORT $LN10@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlFreePar:

; 1786 :     if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN11@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlFreePar:

; 1787 :     if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);

	mov	eax, DWORD PTR [edi+460]
	test	eax, eax
	je	SHORT $LN12@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreePar:

; 1788 :     if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN13@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlFreePar:

; 1789 :     if (ctxt->version != NULL) xmlFree((char *) ctxt->version);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN14@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreePar:

; 1790 :     if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN15@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreePar:

; 1791 :     if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);

	mov	eax, DWORD PTR [edi+224]
	test	eax, eax
	je	SHORT $LN16@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlFreePar:

; 1792 :     if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);

	mov	eax, DWORD PTR [edi+228]
	test	eax, eax
	je	SHORT $LN17@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlFreePar:

; 1793 : #ifdef LIBXML_SAX1_ENABLED
; 1794 :     if ((ctxt->sax != NULL) &&

	cmp	DWORD PTR [edi], 0
	push	esi
	je	SHORT $LN18@xmlFreePar
	mov	esi, DWORD PTR [edi]
	call	___xmlDefaultSAXHandler
	cmp	esi, eax
	je	SHORT $LN18@xmlFreePar

; 1795 :         (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
; 1796 : #else
; 1797 :     if (ctxt->sax != NULL)
; 1798 : #endif /* LIBXML_SAX1_ENABLED */
; 1799 :         xmlFree(ctxt->sax);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlFreePar:

; 1800 :     if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);

	mov	eax, DWORD PTR [edi+180]
	test	eax, eax
	je	SHORT $LN19@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlFreePar:

; 1801 :     if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);

	mov	eax, DWORD PTR [edi+132]
	test	eax, eax
	je	SHORT $LN20@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlFreePar:

; 1802 :     if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);

	mov	eax, DWORD PTR [edi+300]
	test	eax, eax
	je	SHORT $LN21@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlFreePar:

; 1803 :     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	eax, DWORD PTR [edi+296]
	test	eax, eax
	je	SHORT $LN22@xmlFreePar
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN22@xmlFreePar:

; 1804 :     if (ctxt->nsTab != NULL) xmlFree((char *) ctxt->nsTab);

	mov	eax, DWORD PTR [edi+336]
	test	eax, eax
	je	SHORT $LN23@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlFreePar:

; 1805 :     if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);

	mov	eax, DWORD PTR [edi+344]
	test	eax, eax
	je	SHORT $LN24@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlFreePar:

; 1806 :     if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);

	mov	eax, DWORD PTR [edi+340]
	test	eax, eax
	je	SHORT $LN25@xmlFreePar
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlFreePar:

; 1807 :     if (ctxt->attsDefault != NULL)

	mov	eax, DWORD PTR [edi+348]
	test	eax, eax
	je	SHORT $LN26@xmlFreePar

; 1808 :         xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN26@xmlFreePar:

; 1809 :     if (ctxt->attsSpecial != NULL)

	mov	eax, DWORD PTR [edi+352]
	test	eax, eax
	je	SHORT $LN27@xmlFreePar

; 1810 :         xmlHashFree(ctxt->attsSpecial, NULL);

	push	0
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN27@xmlFreePar:

; 1811 :     if (ctxt->freeElems != NULL) {

	mov	eax, DWORD PTR [edi+372]
	test	eax, eax
	je	SHORT $LN5@xmlFreePar
	npad	2
$LL4@xmlFreePar:

; 1812 :         xmlNodePtr cur, next;
; 1813 : 
; 1814 : 	cur = ctxt->freeElems;
; 1815 : 	while (cur != NULL) {
; 1816 : 	    next = cur->next;

	mov	esi, DWORD PTR [eax+24]

; 1817 : 	    xmlFree(cur);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1818 : 	    cur = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL4@xmlFreePar
$LN5@xmlFreePar:

; 1819 : 	}
; 1820 :     }
; 1821 :     if (ctxt->freeAttrs != NULL) {

	mov	eax, DWORD PTR [edi+380]
	test	eax, eax
	je	SHORT $LN7@xmlFreePar
	npad	3
$LL6@xmlFreePar:

; 1822 :         xmlAttrPtr cur, next;
; 1823 : 
; 1824 : 	cur = ctxt->freeAttrs;
; 1825 : 	while (cur != NULL) {
; 1826 : 	    next = cur->next;

	mov	esi, DWORD PTR [eax+24]

; 1827 : 	    xmlFree(cur);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1828 : 	    cur = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL6@xmlFreePar
$LN7@xmlFreePar:

; 1829 : 	}
; 1830 :     }
; 1831 :     /*
; 1832 :      * cleanup the error strings
; 1833 :      */
; 1834 :     if (ctxt->lastError.message != NULL)

	mov	eax, DWORD PTR [edi+392]
	pop	esi
	test	eax, eax
	je	SHORT $LN30@xmlFreePar

; 1835 :         xmlFree(ctxt->lastError.message);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlFreePar:

; 1836 :     if (ctxt->lastError.file != NULL)

	mov	eax, DWORD PTR [edi+400]
	test	eax, eax
	je	SHORT $LN31@xmlFreePar

; 1837 :         xmlFree(ctxt->lastError.file);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN31@xmlFreePar:

; 1838 :     if (ctxt->lastError.str1 != NULL)

	mov	eax, DWORD PTR [edi+408]
	test	eax, eax
	je	SHORT $LN32@xmlFreePar

; 1839 :         xmlFree(ctxt->lastError.str1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlFreePar:

; 1840 :     if (ctxt->lastError.str2 != NULL)

	mov	eax, DWORD PTR [edi+412]
	test	eax, eax
	je	SHORT $LN33@xmlFreePar

; 1841 :         xmlFree(ctxt->lastError.str2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlFreePar:

; 1842 :     if (ctxt->lastError.str3 != NULL)

	mov	eax, DWORD PTR [edi+416]
	test	eax, eax
	je	SHORT $LN34@xmlFreePar

; 1843 :         xmlFree(ctxt->lastError.str3);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlFreePar:

; 1844 : 
; 1845 : #ifdef LIBXML_CATALOG_ENABLED
; 1846 :     if (ctxt->catalogs != NULL)

	mov	eax, DWORD PTR [edi+284]
	test	eax, eax
	je	SHORT $LN35@xmlFreePar

; 1847 : 	xmlCatalogFreeLocal(ctxt->catalogs);

	push	eax
	call	_xmlCatalogFreeLocal
	add	esp, 4
$LN35@xmlFreePar:

; 1848 : #endif
; 1849 :     xmlFree(ctxt);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreePar:
	pop	edi

; 1850 : }

	pop	ebp
	ret	0
_xmlFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlClearParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlClearParserCtxt PROC				; COMDAT

; 1893 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlClearPa

; 1894 :   if (ctxt==NULL)
; 1895 :     return;
; 1896 :   xmlClearNodeInfoSeq(&ctxt->node_seq);

	push	esi
	lea	esi, DWORD PTR [edi+72]

; 1953 :     if (seq == NULL)

	test	esi, esi
	je	SHORT $LN8@xmlClearPa

; 1954 :         return;
; 1955 :     if (seq->buffer != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@xmlClearPa

; 1956 :         xmlFree(seq->buffer);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlClearPa:

; 1938 :     seq->length = 0;

	mov	DWORD PTR [esi+4], 0

; 1939 :     seq->maximum = 0;

	mov	DWORD PTR [esi], 0

; 1940 :     seq->buffer = NULL;

	mov	DWORD PTR [esi+8], 0
$LN8@xmlClearPa:

; 1897 :   xmlCtxtReset(ctxt);

	push	edi
	call	_xmlCtxtReset
	add	esp, 4
	pop	esi
$LN1@xmlClearPa:
	pop	edi

; 1898 : }

	pop	ebp
	ret	0
_xmlClearParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlInitParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlInitParserCtxt PROC					; COMDAT

; 1590 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlInitPar

; 180  :     __xmlRaiseError(NULL, NULL, NULL,

	push	esi
	push	OFFSET ??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	push	3
	push	1

; 1591 :     xmlParserInputPtr input;
; 1592 : 
; 1593 :     if(ctxt==NULL) {
; 1594 :         xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
; 1595 :         return(-1);

	jmp	$LN81@xmlInitPar
$LN4@xmlInitPar:

; 1596 :     }
; 1597 : 
; 1598 :     xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 1599 : 
; 1600 :     if (ctxt->dict == NULL)

	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	jne	SHORT $LN83@xmlInitPar

; 1601 : 	ctxt->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [esi+296], eax

; 1602 :     if (ctxt->dict == NULL) {

	test	eax, eax
	je	$LN80@xmlInitPar
$LN83@xmlInitPar:

; 1603 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1604 : 	return(-1);
; 1605 :     }
; 1606 :     xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);

	push	10000000				; 00989680H
	push	eax
	call	_xmlDictSetLimit

; 1607 : 
; 1608 :     if (ctxt->sax == NULL)

	mov	eax, DWORD PTR [esi]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN85@xmlInitPar

; 1609 : 	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));

	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 1610 :     if (ctxt->sax == NULL) {

	test	eax, eax
	je	$LN80@xmlInitPar
$LN85@xmlInitPar:

; 1611 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1612 : 	return(-1);
; 1613 :     }
; 1614 :     else
; 1615 :         xmlSAXVersion(ctxt->sax, 2);

	push	2
	push	eax
	call	_xmlSAXVersion

; 1616 : 
; 1617 :     ctxt->maxatts = 0;
; 1618 :     ctxt->atts = NULL;
; 1619 :     /* Allocate the Input stack */
; 1620 :     if (ctxt->inputTab == NULL) {

	mov	eax, DWORD PTR [esi+48]
	add	esp, 8
	mov	DWORD PTR [esi+304], 0
	mov	DWORD PTR [esi+300], 0
	test	eax, eax
	jne	SHORT $LN68@xmlInitPar

; 1621 : 	ctxt->inputTab = (xmlParserInputPtr *)

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+48], eax

; 1622 : 		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
; 1623 : 	ctxt->inputMax = 5;

	mov	DWORD PTR [esi+44], 5

; 1624 :     }
; 1625 :     if (ctxt->inputTab == NULL) {

	test	eax, eax
	jne	SHORT $LN68@xmlInitPar

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	eax
	push	eax
	push	3
	push	2
	push	1
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
$LN91@xmlInitPar:

; 1764 : }

	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	or	eax, -1
	mov	DWORD PTR [esi+36], 0
	pop	esi
	pop	ebp
	ret	0
$LN68@xmlInitPar:

; 1626 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1627 : 	ctxt->inputNr = 0;
; 1628 : 	ctxt->inputMax = 0;
; 1629 : 	ctxt->input = NULL;
; 1630 : 	return(-1);
; 1631 :     }
; 1632 :     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	push	esi
	call	_inputPop
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlInitPar
$LL2@xmlInitPar:

; 1633 :         xmlFreeInputStream(input);

	push	eax
	call	_xmlFreeInputStream
	push	esi
	call	_inputPop
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlInitPar
$LN3@xmlInitPar:

; 1634 :     }
; 1635 :     ctxt->inputNr = 0;
; 1636 :     ctxt->input = NULL;
; 1637 : 
; 1638 :     ctxt->version = NULL;
; 1639 :     ctxt->encoding = NULL;
; 1640 :     ctxt->standalone = -1;
; 1641 :     ctxt->hasExternalSubset = 0;
; 1642 :     ctxt->hasPErefs = 0;
; 1643 :     ctxt->html = 0;
; 1644 :     ctxt->external = 0;
; 1645 :     ctxt->instate = XML_PARSER_START;
; 1646 :     ctxt->token = 0;
; 1647 :     ctxt->directory = NULL;
; 1648 : 
; 1649 :     /* Allocate the Node stack */
; 1650 :     if (ctxt->nodeTab == NULL) {

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], -1
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+176], 0
	mov	DWORD PTR [esi+180], 0
	test	eax, eax
	jne	SHORT $LN13@xmlInitPar

; 1651 : 	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+64], eax

; 1652 : 	ctxt->nodeMax = 10;

	mov	DWORD PTR [esi+60], 10			; 0000000aH

; 1653 :     }
; 1654 :     if (ctxt->nodeTab == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlInitPar

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	eax
	push	eax
	push	3
	push	2
	push	1
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 1655 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1656 : 	ctxt->nodeNr = 0;

	mov	DWORD PTR [esi+56], 0

; 1657 : 	ctxt->nodeMax = 0;

	mov	DWORD PTR [esi+60], 0

; 1658 : 	ctxt->node = NULL;

	mov	DWORD PTR [esi+52], 0

; 1659 : 	ctxt->inputNr = 0;
; 1660 : 	ctxt->inputMax = 0;
; 1661 : 	ctxt->input = NULL;
; 1662 : 	return(-1);

	jmp	$LN91@xmlInitPar
$LN13@xmlInitPar:

; 1663 :     }
; 1664 :     ctxt->nodeNr = 0;
; 1665 :     ctxt->node = NULL;
; 1666 : 
; 1667 :     /* Allocate the Name stack */
; 1668 :     if (ctxt->nameTab == NULL) {

	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+52], 0
	test	eax, eax
	jne	$LN15@xmlInitPar

; 1669 : 	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+196], eax

; 1670 : 	ctxt->nameMax = 10;

	mov	DWORD PTR [esi+192], 10			; 0000000aH

; 1671 :     }
; 1672 :     if (ctxt->nameTab == NULL) {

	test	eax, eax
	jne	SHORT $LN15@xmlInitPar

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	eax
	push	eax
	push	3
	push	2
	push	1
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 1764 : }

	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	or	eax, -1
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+192], 0
	mov	DWORD PTR [esi+184], 0
	pop	esi
	pop	ebp
	ret	0
$LN15@xmlInitPar:

; 1673 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1674 : 	ctxt->nodeNr = 0;
; 1675 : 	ctxt->nodeMax = 0;
; 1676 : 	ctxt->node = NULL;
; 1677 : 	ctxt->inputNr = 0;
; 1678 : 	ctxt->inputMax = 0;
; 1679 : 	ctxt->input = NULL;
; 1680 : 	ctxt->nameNr = 0;
; 1681 : 	ctxt->nameMax = 0;
; 1682 : 	ctxt->name = NULL;
; 1683 : 	return(-1);
; 1684 :     }
; 1685 :     ctxt->nameNr = 0;
; 1686 :     ctxt->name = NULL;
; 1687 : 
; 1688 :     /* Allocate the space stack */
; 1689 :     if (ctxt->spaceTab == NULL) {

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+184], 0
	test	eax, eax
	jne	$LN17@xmlInitPar

; 1690 : 	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+244], eax

; 1691 : 	ctxt->spaceMax = 10;

	mov	DWORD PTR [esi+240], 10			; 0000000aH

; 1692 :     }
; 1693 :     if (ctxt->spaceTab == NULL) {

	test	eax, eax
	jne	$LN17@xmlInitPar

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	eax
	push	eax
	push	3
	push	2
	push	1
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 1764 : }

	add	esp, 68					; 00000044H
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	or	eax, -1
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+192], 0
	mov	DWORD PTR [esi+184], 0
	mov	DWORD PTR [esi+236], 0
	mov	DWORD PTR [esi+240], 0
	mov	DWORD PTR [esi+232], 0
	pop	esi
	pop	ebp
	ret	0
$LN17@xmlInitPar:

; 1694 :         xmlErrMemory(NULL, "cannot initialize parser context\n");
; 1695 : 	ctxt->nodeNr = 0;
; 1696 : 	ctxt->nodeMax = 0;
; 1697 : 	ctxt->node = NULL;
; 1698 : 	ctxt->inputNr = 0;
; 1699 : 	ctxt->inputMax = 0;
; 1700 : 	ctxt->input = NULL;
; 1701 : 	ctxt->nameNr = 0;
; 1702 : 	ctxt->nameMax = 0;
; 1703 : 	ctxt->name = NULL;
; 1704 : 	ctxt->spaceNr = 0;
; 1705 : 	ctxt->spaceMax = 0;
; 1706 : 	ctxt->space = NULL;
; 1707 : 	return(-1);
; 1708 :     }
; 1709 :     ctxt->spaceNr = 1;

	mov	DWORD PTR [esi+236], 1

; 1710 :     ctxt->spaceMax = 10;

	mov	DWORD PTR [esi+240], 10			; 0000000aH

; 1711 :     ctxt->spaceTab[0] = -1;

	mov	DWORD PTR [eax], -1

; 1712 :     ctxt->space = &ctxt->spaceTab[0];

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [esi+232], eax

; 1713 :     ctxt->userData = ctxt;

	mov	DWORD PTR [esi+4], esi

; 1714 :     ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], 0

; 1715 :     ctxt->wellFormed = 1;

	mov	DWORD PTR [esi+12], 1

; 1716 :     ctxt->nsWellFormed = 1;

	mov	DWORD PTR [esi+356], 1

; 1717 :     ctxt->valid = 1;

	mov	DWORD PTR [esi+100], 1

; 1718 :     ctxt->loadsubset = xmlLoadExtDtdDefaultValue;

	call	___xmlLoadExtDtdDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+276], eax

; 1719 :     if (ctxt->loadsubset) {

	test	eax, eax
	je	SHORT $LN76@xmlInitPar

; 1720 :         ctxt->options |= XML_PARSE_DTDLOAD;

	or	DWORD PTR [esi+360], 4
$LN76@xmlInitPar:

; 1721 :     }
; 1722 :     ctxt->validate = xmlDoValidityCheckingDefaultValue;

	call	___xmlDoValidityCheckingDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+104], eax

; 1723 :     ctxt->pedantic = xmlPedanticParserDefaultValue;

	call	___xmlPedanticParserDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+268], eax

; 1724 :     if (ctxt->pedantic) {

	test	eax, eax
	je	SHORT $LN77@xmlInitPar

; 1725 :         ctxt->options |= XML_PARSE_PEDANTIC;

	or	DWORD PTR [esi+360], 128		; 00000080H
$LN77@xmlInitPar:

; 1726 :     }
; 1727 :     ctxt->linenumbers = xmlLineNumbersDefaultValue;

	call	___xmlLineNumbersDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+280], eax

; 1728 :     ctxt->keepBlanks = xmlKeepBlanksDefaultValue;

	call	___xmlKeepBlanksDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+208], eax

; 1729 :     if (ctxt->keepBlanks == 0) {

	test	eax, eax
	jne	SHORT $LN78@xmlInitPar

; 1730 : 	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+72], OFFSET _xmlSAX2IgnorableWhitespace

; 1731 : 	ctxt->options |= XML_PARSE_NOBLANKS;

	or	DWORD PTR [esi+360], 256		; 00000100H
$LN78@xmlInitPar:

; 1732 :     }
; 1733 : 
; 1734 :     ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;
; 1735 :     ctxt->vctxt.userData = ctxt;
; 1736 :     ctxt->vctxt.error = xmlParserValidityError;
; 1737 :     ctxt->vctxt.warning = xmlParserValidityWarning;
; 1738 :     if (ctxt->validate) {

	cmp	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+136], -1412623820	; abcd1234H
	mov	DWORD PTR [esi+108], esi
	mov	DWORD PTR [esi+112], OFFSET _xmlParserValidityError
	mov	DWORD PTR [esi+116], OFFSET _xmlParserValidityWarning
	je	SHORT $LN79@xmlInitPar

; 1739 : 	if (xmlGetWarningsDefaultValue == 0)

	call	___xmlGetWarningsDefaultValue

; 1740 : 	    ctxt->vctxt.warning = NULL;
; 1741 : 	else
; 1742 : 	    ctxt->vctxt.warning = xmlParserValidityWarning;
; 1743 : 	ctxt->vctxt.nodeMax = 0;

	xor	ecx, ecx
	mov	edx, OFFSET _xmlParserValidityWarning
	cmp	DWORD PTR [eax], ecx
	cmovne	ecx, edx
	mov	DWORD PTR [esi+116], ecx

; 1744 :         ctxt->options |= XML_PARSE_DTDVALID;

	or	DWORD PTR [esi+360], 16			; 00000010H
	mov	DWORD PTR [esi+128], 0
$LN79@xmlInitPar:

; 1745 :     }
; 1746 :     ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;

	call	___xmlSubstituteEntitiesDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+16], eax

; 1747 :     if (ctxt->replaceEntities) {

	test	eax, eax
	je	SHORT $LN24@xmlInitPar

; 1748 :         ctxt->options |= XML_PARSE_NOENT;

	or	DWORD PTR [esi+360], 2
$LN24@xmlInitPar:

; 1749 :     }
; 1750 :     ctxt->record_info = 0;

	mov	DWORD PTR [esi+68], 0

; 1751 :     ctxt->nbChars = 0;

	mov	DWORD PTR [esi+200], 0

; 1752 :     ctxt->checkIndex = 0;

	mov	DWORD PTR [esi+204], 0

; 1753 :     ctxt->inSubset = 0;

	mov	DWORD PTR [esi+216], 0

; 1754 :     ctxt->errNo = XML_ERR_OK;

	mov	DWORD PTR [esi+84], 0

; 1755 :     ctxt->depth = 0;

	mov	DWORD PTR [esi+248], 0

; 1756 :     ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	DWORD PTR [esi+256], 1

; 1757 :     ctxt->catalogs = NULL;

	mov	DWORD PTR [esi+284], 0

; 1758 :     ctxt->nbentities = 0;

	mov	DWORD PTR [esi+440], 0

; 1759 :     ctxt->sizeentities = 0;

	mov	DWORD PTR [esi+444], 0

; 1760 :     ctxt->sizeentcopy = 0;

	mov	DWORD PTR [esi+468], 0

; 1761 :     ctxt->input_id = 1;

	mov	DWORD PTR [esi+464], 1

; 1762 :     xmlInitNodeInfoSeq(&ctxt->node_seq);

	add	esi, 72					; 00000048H
	push	esi
	call	_xmlInitNodeInfoSeq
	add	esp, 4

; 1763 :     return(0);

	xor	eax, eax
	pop	esi

; 1764 : }

	pop	ebp
	ret	0
$LN80@xmlInitPar:

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	push	0
	push	3
	push	2
$LN81@xmlInitPar:

; 1764 : }

	push	1
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlInitParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewParserCtxt
_TEXT	SEGMENT
_xmlNewParserCtxt PROC					; COMDAT

; 1862 : {

	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	push	472					; 000001d8H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewPars

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@
	push	eax
	push	eax
	push	3
	push	2
	push	1
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1863 :     xmlParserCtxtPtr ctxt;
; 1864 : 
; 1865 :     ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
; 1866 :     if (ctxt == NULL) {
; 1867 : 	xmlErrMemory(NULL, "cannot allocate parser context\n");
; 1868 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1876 : }

	ret	0
$LN2@xmlNewPars:

; 1869 :     }
; 1870 :     memset(ctxt, 0, sizeof(xmlParserCtxt));

	push	472					; 000001d8H
	push	0
	push	esi
	call	_memset

; 1871 :     if (xmlInitParserCtxt(ctxt) < 0) {

	push	esi
	call	_xmlInitParserCtxt
	add	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN3@xmlNewPars

; 1872 :         xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 1873 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1876 : }

	ret	0
$LN3@xmlNewPars:

; 1874 :     }
; 1875 :     return(ctxt);

	mov	eax, esi
	pop	esi

; 1876 : }

	ret	0
_xmlNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlLineNumbersDefault
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlLineNumbersDefault PROC				; COMDAT

; 2102 : xmlLineNumbersDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlLineNumbersDefaultValue
	mov	esi, DWORD PTR [eax]
	call	___xmlLineNumbersDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, esi
	pop	esi

; 2103 :     int old = xmlLineNumbersDefaultValue;
; 2104 : 
; 2105 :     xmlLineNumbersDefaultValue = val;
; 2106 :     return(old);
; 2107 : }

	pop	ebp
	ret	0
_xmlLineNumbersDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlPedanticParserDefault
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlPedanticParserDefault PROC				; COMDAT

; 2084 : xmlPedanticParserDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlPedanticParserDefaultValue
	mov	esi, DWORD PTR [eax]
	call	___xmlPedanticParserDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, esi
	pop	esi

; 2085 :     int old = xmlPedanticParserDefaultValue;
; 2086 : 
; 2087 :     xmlPedanticParserDefaultValue = val;
; 2088 :     return(old);
; 2089 : }

	pop	ebp
	ret	0
_xmlPedanticParserDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlKeepBlanksDefault
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlKeepBlanksDefault PROC				; COMDAT

; 2156 : xmlKeepBlanksDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlKeepBlanksDefaultValue
	mov	esi, DWORD PTR [eax]
	call	___xmlKeepBlanksDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx
	test	ecx, ecx
	jne	SHORT $LN4@xmlKeepBla

; 2157 :     int old = xmlKeepBlanksDefaultValue;
; 2158 : 
; 2159 :     xmlKeepBlanksDefaultValue = val;
; 2160 :     if (!val) xmlIndentTreeOutput = 1;

	call	___xmlIndentTreeOutput
	mov	DWORD PTR [eax], 1
$LN4@xmlKeepBla:

; 2161 :     return(old);
; 2162 : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlKeepBlanksDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSubstituteEntitiesDefault
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSubstituteEntitiesDefault PROC			; COMDAT

; 2124 : xmlSubstituteEntitiesDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlSubstituteEntitiesDefaultValue
	mov	esi, DWORD PTR [eax]
	call	___xmlSubstituteEntitiesDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, esi
	pop	esi

; 2125 :     int old = xmlSubstituteEntitiesDefaultValue;
; 2126 : 
; 2127 :     xmlSubstituteEntitiesDefaultValue = val;
; 2128 :     return(old);
; 2129 : }

	pop	ebp
	ret	0
_xmlSubstituteEntitiesDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputGrow
_TEXT	SEGMENT
tv268 = 8						; size = 4
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputGrow PROC				; COMDAT

; 300  : xmlParserInputGrow(xmlParserInputPtr in, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	test	esi, esi
	je	$LN3@xmlParserI

; 301  :     int ret;
; 302  :     size_t indx;
; 303  :     const xmlChar *content;
; 304  : 
; 305  :     if ((in == NULL) || (len < 0)) return(-1);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN3@xmlParserI

; 306  : #ifdef DEBUG_INPUT
; 307  :     xmlGenericError(xmlGenericErrorContext, "Grow\n");
; 308  : #endif
; 309  :     if (in->buf == NULL) return(-1);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlParserI

; 310  :     if (in->base == NULL) return(-1);

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR tv268[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN3@xmlParserI

; 311  :     if (in->cur == NULL) return(-1);

	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	SHORT $LN3@xmlParserI

; 312  :     if (in->buf->buffer == NULL) return(-1);

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@xmlParserI

; 313  : 
; 314  :     CHECK_BUFFER(in);
; 315  : 
; 316  :     indx = in->cur - in->base;
; 317  :     if (xmlBufUse(in->buf->buffer) > (unsigned int) indx + INPUT_CHUNK) {

	push	eax
	call	_xmlBufUse
	sub	edi, DWORD PTR tv268[ebp]
	add	esp, 4
	add	edi, 250				; 000000faH
	cmp	eax, edi
	ja	SHORT $LN9@xmlParserI

; 318  : 
; 319  : 	CHECK_BUFFER(in);
; 320  : 
; 321  :         return(0);
; 322  :     }
; 323  :     if (in->buf->readcallback != NULL) {

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN9@xmlParserI

; 324  : 	ret = xmlParserInputBufferGrow(in->buf, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlParserInputBufferGrow

; 327  : 
; 328  :     /*
; 329  :      * NOTE : in->base may be a "dangling" i.e. freed pointer in this
; 330  :      *        block, but we use it really as an integer to do some
; 331  :      *        pointer arithmetic. Insure will raise it as a bug but in
; 332  :      *        that specific case, that's not !
; 333  :      */
; 334  : 
; 335  :     content = xmlBufContent(in->buf->buffer);

	mov	ecx, DWORD PTR [esi]
	mov	edi, eax
	push	DWORD PTR [ecx+16]
	call	_xmlBufContent

; 336  :     if (in->base != content) {

	mov	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	ecx, eax
	je	SHORT $LN11@xmlParserI

; 337  :         /*
; 338  : 	 * the buffer has been reallocated
; 339  : 	 */
; 340  : 	indx = in->cur - in->base;
; 341  : 	in->base = content;

	mov	DWORD PTR [esi+12], eax

; 342  : 	in->cur = &content[indx];

	sub	eax, ecx
	add	DWORD PTR [esi+16], eax
$LN11@xmlParserI:

; 343  :     }
; 344  :     in->end = xmlBufEnd(in->buf->buffer);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+16]
	call	_xmlBufEnd
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 345  : 
; 346  :     CHECK_BUFFER(in);
; 347  : 
; 348  :     return(ret);

	mov	eax, edi
	pop	edi

; 349  : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlParserI:
	pop	edi

; 325  :     } else
; 326  :         return(0);

	xor	eax, eax

; 349  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlParserI:
	pop	edi

; 301  :     int ret;
; 302  :     size_t indx;
; 303  :     const xmlChar *content;
; 304  : 
; 305  :     if ((in == NULL) || (len < 0)) return(-1);

	or	eax, -1

; 349  : }

	pop	esi
	pop	ebp
	ret	0
_xmlParserInputGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputRead
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputRead PROC				; COMDAT
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	or	eax, -1
	ret	0
_xmlParserInputRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCheckVersion
_TEXT	SEGMENT
_version$ = 8						; size = 4
_xmlCheckVersion PROC					; COMDAT

; 77   : xmlCheckVersion(int version) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	eax, 1759218605				; 68db8badH
	imul	DWORD PTR _version$[ebp]
	sar	edx, 12					; 0000000cH
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	cmp	edi, 2
	je	SHORT $LN2@xmlCheckVe

; 78   :     int myversion = (int) LIBXML_VERSION;
; 79   : 
; 80   :     xmlInitParser();
; 81   : 
; 82   :     if ((myversion / 10000) != (version / 10000)) {
; 83   : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2
	push	edi
	push	OFFSET ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 84   : 		"Fatal: program compiled against libxml %d using libxml %d\n",
; 85   : 		(version / 10000), (myversion / 10000));
; 86   : 	fprintf(stderr,

	push	2
	push	edi
	push	OFFSET ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN2@xmlCheckVe:

; 87   : 		"Fatal: program compiled against libxml %d using libxml %d\n",
; 88   : 		(version / 10000), (myversion / 10000));
; 89   :     }
; 90   :     if ((myversion / 100) < (version / 100)) {

	mov	eax, 1374389535				; 51eb851fH
	imul	DWORD PTR _version$[ebp]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	cmp	edi, 209				; 000000d1H
	jle	SHORT $LN3@xmlCheckVe

; 91   : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	209					; 000000d1H
	push	edi
	push	OFFSET ??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN3@xmlCheckVe:

; 92   : 		"Warning: program compiled against libxml %d using older %d\n",
; 93   : 		(version / 100), (myversion / 100));
; 94   :     }
; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlCheckVersion ENDP
_TEXT	ENDS
END
