; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\uri.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__0B912F28_uri@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlCreateURI
PUBLIC	_xmlBuildURI
PUBLIC	_xmlBuildRelativeURI
PUBLIC	_xmlParseURI
PUBLIC	_xmlParseURIRaw
PUBLIC	_xmlParseURIReference
PUBLIC	_xmlSaveUri
PUBLIC	_xmlPrintURI
PUBLIC	_xmlURIEscapeStr
PUBLIC	_xmlURIUnescapeString
PUBLIC	_xmlNormalizeURIPath
PUBLIC	_xmlURIEscape
PUBLIC	_xmlFreeURI
PUBLIC	_xmlCanonicPath
PUBLIC	_xmlPathToURI
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@	; `string'
PUBLIC	??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@ ; `string'
PUBLIC	??_C@_0M@NFLMPNMP@saving?5URI?6@		; `string'
PUBLIC	??_C@_03HODKBCIO@?3?$CFd@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@	; `string'
PUBLIC	??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@	; `string'
PUBLIC	??_C@_03JCBKNEED@?$CL?9?4@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@		; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1@				; `string'
PUBLIC	??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@		; `string'
PUBLIC	??_C@_01EOFPKCAF@?$EA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@ ; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01IPJKGB@?$CD@				; `string'
PUBLIC	??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_02CAHBHFGK@?4?1@				; `string'
PUBLIC	??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@		; `string'
PUBLIC	??_C@_0BH@KBJNOCC@building?5relative?5URI?6@	; `string'
PUBLIC	??_C@_03GACAABJG@?3?1?1@			; `string'
PUBLIC	??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@	; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@
CONST	SEGMENT
??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@ DB ':/?_.#&;=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GACAABJG@?3?1?1@
CONST	SEGMENT
??_C@_03GACAABJG@?3?1?1@ DB '://', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KBJNOCC@building?5relative?5URI?6@
CONST	SEGMENT
??_C@_0BH@KBJNOCC@building?5relative?5URI?6@ DB 'building relative URI', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
CONST	SEGMENT
??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@ DB '/;&=+$,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CAHBHFGK@?4?1@
CONST	SEGMENT
??_C@_02CAHBHFGK@?4?1@ DB './', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@
CONST	SEGMENT
??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@ DB 'resolving URI aga'
	DB	'inst base', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@
CONST	SEGMENT
??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@ DB ';/?:@&=+,$', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@
CONST	SEGMENT
??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@ DB ':@&=+$,/?;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EOFPKCAF@?$EA@
CONST	SEGMENT
??_C@_01EOFPKCAF@?$EA@ DB '@', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@
CONST	SEGMENT
??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@ DB ';:&=+$,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
CONST	SEGMENT
??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@ DB '/?;:@', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JCBKNEED@?$CL?9?4@
CONST	SEGMENT
??_C@_03JCBKNEED@?$CL?9?4@ DB '+-.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
CONST	SEGMENT
??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@ DB 'escaping URI value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@
CONST	SEGMENT
??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@ DB 'unescaping URI value', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file@
CONST	SEGMENT
??_C@_04DAMGJPCA@file@ DB 'file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HODKBCIO@?3?$CFd@
CONST	SEGMENT
??_C@_03HODKBCIO@?3?$CFd@ DB ':%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFLMPNMP@saving?5URI?6@
CONST	SEGMENT
??_C@_0M@NFLMPNMP@saving?5URI?6@ DB 'saving URI', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@
CONST	SEGMENT
??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@ DB 'reaching arbitr'
	DB	'ary MAX_URI_LENGTH limit', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@
CONST	SEGMENT
??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@ DB 'creating URI structure'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _is_hex
_TEXT	SEGMENT
_c$ = 8							; size = 1
_is_hex	PROC						; COMDAT

; 1589 : static int is_hex(char c) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	al, BYTE PTR _c$[ebp]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN4@is_hex

; 1590 :     if (((c >= '0') && (c <= '9')) ||
; 1591 :         ((c >= 'a') && (c <= 'f')) ||

	cmp	al, 57					; 00000039H
	jle	SHORT $LN3@is_hex
$LN4@is_hex:
	cmp	al, 97					; 00000061H
	jl	SHORT $LN5@is_hex
	cmp	al, 102					; 00000066H
	jle	SHORT $LN3@is_hex
$LN5@is_hex:
	sub	al, 65					; 00000041H
	cmp	al, 5
	ja	SHORT $LN2@is_hex
$LN3@is_hex:

; 1592 :         ((c >= 'A') && (c <= 'F')))
; 1593 : 	return(1);

	mov	eax, 1

; 1595 : }

	pop	ebp
	ret	0
$LN2@is_hex:

; 1594 :     return(0);

	xor	eax, eax

; 1595 : }

	pop	ebp
	ret	0
_is_hex	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlSaveUriRealloc
_TEXT	SEGMENT
_ret$ = 8						; size = 4
_max$ = 12						; size = 4
_xmlSaveUriRealloc PROC					; COMDAT

; 1031 : xmlSaveUriRealloc(xmlChar *ret, int *max) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _max$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	eax, 1048576				; 00100000H
	jle	SHORT $LN2@xmlSaveUri

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@
	push	0
	push	0
	push	3
	push	2
	push	30					; 0000001eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1032 :     xmlChar *temp;
; 1033 :     int tmp;
; 1034 : 
; 1035 :     if (*max > MAX_URI_LENGTH) {
; 1036 :         xmlURIErrMemory("reaching arbitrary MAX_URI_LENGTH limit\n");
; 1037 :         return(NULL);

	xor	eax, eax
	pop	esi

; 1046 :     return(temp);
; 1047 : }

	pop	ebp
	ret	0
$LN2@xmlSaveUri:
	push	edi

; 1038 :     }
; 1039 :     tmp = *max * 2;

	lea	edi, DWORD PTR [eax+eax]

; 1040 :     temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));

	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	DWORD PTR _ret$[ebp]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1041 :     if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSaveUri

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	push	eax
	push	eax
	push	3
	push	2
	push	30					; 0000001eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1042 :         xmlURIErrMemory("saving URI\n");
; 1043 :         return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1046 :     return(temp);
; 1047 : }

	pop	ebp
	ret	0
$LN3@xmlSaveUri:

; 1044 :     }
; 1045 :     *max = tmp;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 1046 :     return(temp);
; 1047 : }

	pop	ebp
	ret	0
_xmlSaveUriRealloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986URIReference
_TEXT	SEGMENT
_str$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986URIReference PROC				; COMDAT

; 898  : xmlParse3986URIReference(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	jne	SHORT $LN2@xmlParse39

; 899  :     int ret;
; 900  : 
; 901  :     if (str == NULL)
; 902  : 	return(-1);

	or	eax, -1
	pop	ebx

; 919  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlParse39:
	push	esi
	push	edi

; 903  :     xmlCleanURI(uri);

	mov	edi, DWORD PTR _uri$[ebp]
	push	edi
	call	_xmlCleanURI

; 215  :     if (!ISA_ALPHA(cur))

	mov	al, BYTE PTR [ebx]

; 903  :     xmlCleanURI(uri);

	add	esp, 4

; 215  :     if (!ISA_ALPHA(cur))

	cmp	al, 97					; 00000061H
	jl	SHORT $LN21@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN20@xmlParse39
$LN21@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	$LN6@xmlParse39
	cmp	al, 90					; 0000005aH
	jg	$LN6@xmlParse39
$LN20@xmlParse39:

; 216  : 	return(2);
; 217  :     cur++;

	lea	esi, DWORD PTR [ebx+1]
	npad	7
$LL17@xmlParse39:

; 218  :     while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
; 219  :            (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN24@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN23@xmlParse39
$LN24@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN25@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	SHORT $LN23@xmlParse39
$LN25@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN26@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN23@xmlParse39
$LN26@xmlParse39:
	cmp	al, 43					; 0000002bH
	je	SHORT $LN23@xmlParse39
	cmp	al, 45					; 0000002dH
	je	SHORT $LN23@xmlParse39
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN18@xmlParse39
$LN23@xmlParse39:
	inc	esi
	jmp	SHORT $LL17@xmlParse39
$LN18@xmlParse39:

; 220  :     if (uri != NULL) {

	test	edi, edi
	je	SHORT $LN7@xmlParse39

; 221  : 	if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN28@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN28@xmlParse39:

; 222  : 	uri->scheme = STRNDUP(*str, cur - *str);

	mov	eax, esi
	sub	eax, ebx
	push	eax
	push	ebx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN7@xmlParse39:

; 862  :     if (*str != ':') {

	cmp	BYTE PTR [esi], 58			; 0000003aH
	jne	SHORT $LN6@xmlParse39

; 863  : 	return(1);
; 864  :     }
; 865  :     str++;

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _str$[ebp], eax

; 866  :     ret = xmlParse3986HierPart(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986HierPart
	add	esp, 8

; 867  :     if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN6@xmlParse39

; 868  :     if (*str == '?') {

	mov	eax, DWORD PTR _str$[ebp]
	cmp	BYTE PTR [eax], 63			; 0000003fH
	jne	SHORT $LN11@xmlParse39

; 869  : 	str++;

	inc	eax
	mov	DWORD PTR _str$[ebp], eax

; 870  : 	ret = xmlParse3986Query(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986Query
	add	esp, 8

; 871  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN6@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
$LN11@xmlParse39:

; 872  :     }
; 873  :     if (*str == '#') {

	cmp	BYTE PTR [eax], 35			; 00000023H
	jne	SHORT $LN13@xmlParse39

; 874  : 	str++;

	inc	eax
	mov	DWORD PTR _str$[ebp], eax

; 875  : 	ret = xmlParse3986Fragment(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986Fragment
	add	esp, 8

; 876  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN6@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
$LN13@xmlParse39:

; 877  :     }
; 878  :     if (*str != 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN4@xmlParse39

; 879  : 	xmlCleanURI(uri);

	push	edi
	call	_xmlCleanURI
	add	esp, 4
$LN6@xmlParse39:

; 904  : 
; 905  :     /*
; 906  :      * Try first to parse absolute refs, then fallback to relative if
; 907  :      * it fails.
; 908  :      */
; 909  :     ret = xmlParse3986URI(uri, str);
; 910  :     if (ret != 0) {
; 911  : 	xmlCleanURI(uri);

	push	edi
	call	_xmlCleanURI

; 912  :         ret = xmlParse3986RelativeRef(uri, str);

	push	ebx
	push	edi
	call	_xmlParse3986RelativeRef
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 913  : 	if (ret != 0) {

	test	esi, esi
	je	SHORT $LN4@xmlParse39

; 914  : 	    xmlCleanURI(uri);

	push	edi
	call	_xmlCleanURI
	add	esp, 4

; 915  : 	    return(ret);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 919  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlParse39:
	pop	edi
	pop	esi

; 916  : 	}
; 917  :     }
; 918  :     return(0);

	xor	eax, eax
	pop	ebx

; 919  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986URIReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986URI
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986URI PROC					; COMDAT

; 857  : xmlParse3986URI(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 215  :     if (!ISA_ALPHA(cur))

	mov	ebx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [ebx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN16@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN15@xmlParse39
$LN16@xmlParse39:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	$LN17@xmlParse39
$LN15@xmlParse39:
	push	esi

; 216  : 	return(2);
; 217  :     cur++;

	lea	esi, DWORD PTR [ebx+1]
	npad	7
$LL12@xmlParse39:

; 218  :     while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
; 219  :            (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN19@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN18@xmlParse39
$LN19@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN20@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	SHORT $LN18@xmlParse39
$LN20@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN21@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN18@xmlParse39
$LN21@xmlParse39:
	cmp	al, 43					; 0000002bH
	je	SHORT $LN18@xmlParse39
	cmp	al, 45					; 0000002dH
	je	SHORT $LN18@xmlParse39
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN13@xmlParse39
$LN18@xmlParse39:
	inc	esi
	jmp	SHORT $LL12@xmlParse39
$LN13@xmlParse39:
	push	edi

; 220  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlParse39

; 221  : 	if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN23@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlParse39:

; 222  : 	uri->scheme = STRNDUP(*str, cur - *str);

	mov	eax, esi
	sub	eax, ebx
	push	eax
	push	ebx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN2@xmlParse39:

; 862  :     if (*str != ':') {

	cmp	BYTE PTR [esi], 58			; 0000003aH
	jne	SHORT $LN33@xmlParse39

; 863  : 	return(1);
; 864  :     }
; 865  :     str++;

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _str$[ebp], eax

; 866  :     ret = xmlParse3986HierPart(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986HierPart
	add	esp, 8

; 867  :     if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN32@xmlParse39

; 868  :     if (*str == '?') {

	mov	eax, DWORD PTR _str$[ebp]
	cmp	BYTE PTR [eax], 63			; 0000003fH
	jne	SHORT $LN6@xmlParse39

; 869  : 	str++;

	inc	eax
	mov	DWORD PTR _str$[ebp], eax

; 870  : 	ret = xmlParse3986Query(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986Query
	add	esp, 8

; 871  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN32@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
$LN6@xmlParse39:

; 872  :     }
; 873  :     if (*str == '#') {

	cmp	BYTE PTR [eax], 35			; 00000023H
	jne	SHORT $LN8@xmlParse39

; 874  : 	str++;

	inc	eax
	mov	DWORD PTR _str$[ebp], eax

; 875  : 	ret = xmlParse3986Fragment(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	edi
	call	_xmlParse3986Fragment
	add	esp, 8

; 876  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN32@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
$LN8@xmlParse39:

; 877  :     }
; 878  :     if (*str != 0) {

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN9@xmlParse39

; 879  : 	xmlCleanURI(uri);

	push	edi
	call	_xmlCleanURI
	add	esp, 4
$LN33@xmlParse39:

; 880  : 	return(1);

	mov	eax, 1
$LN32@xmlParse39:
	pop	edi
	pop	esi
	pop	ebx

; 883  : }

	pop	ebp
	ret	0
$LN9@xmlParse39:
	pop	edi
	pop	esi

; 881  :     }
; 882  :     return(0);

	xor	eax, eax
	pop	ebx

; 883  : }

	pop	ebp
	ret	0
$LN17@xmlParse39:

; 858  :     int ret;
; 859  : 
; 860  :     ret = xmlParse3986Scheme(uri, &str);
; 861  :     if (ret != 0) return(ret);

	mov	eax, 2
	pop	ebx

; 883  : }

	pop	ebp
	ret	0
_xmlParse3986URI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986RelativeRef
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$1 = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986RelativeRef PROC				; COMDAT

; 803  : xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [edi]
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN6@xmlParse39

; 804  :     int ret;
; 805  : 
; 806  :     if ((*str == '/') && (*(str + 1) == '/')) {

	cmp	BYTE PTR [edi+1], 47			; 0000002fH
	lea	eax, DWORD PTR _str$[ebp]
	mov	ebx, DWORD PTR _uri$[ebp]
	push	eax
	push	ebx
	jne	SHORT $LN2@xmlParse39

; 807  :         str += 2;

	add	edi, 2
	mov	DWORD PTR _str$[ebp], edi

; 808  : 	ret = xmlParse3986Authority(uri, &str);

	call	_xmlParse3986Authority
	add	esp, 8

; 809  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39

; 810  : 	ret = xmlParse3986PathAbEmpty(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	ebx
	call	_xmlParse3986PathAbEmpty
	add	esp, 8

; 811  : 	if (ret != 0) return(ret);

	test	eax, eax
	je	SHORT $LN47@xmlParse39

; 841  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlParse39:

; 812  :     } else if (*str == '/') {
; 813  : 	ret = xmlParse3986PathAbsolute(uri, &str);

	call	_xmlParse3986PathAbsolute
	add	esp, 8

; 814  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39
$LN47@xmlParse39:

; 811  : 	if (ret != 0) return(ret);

	mov	edi, DWORD PTR _str$[ebp]
	jmp	$LN22@xmlParse39
$LN6@xmlParse39:

; 815  :     } else if (ISA_PCHAR(str)) {

	cmp	al, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN11@xmlParse39
$LN12@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN13@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN11@xmlParse39
$LN13@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN14@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN11@xmlParse39
$LN14@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN11@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN11@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN11@xmlParse39
	cmp	al, 126					; 0000007eH
	je	$LN11@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN21@xmlParse39
	mov	cl, BYTE PTR [edi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN17@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN16@xmlParse39
$LN17@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN18@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN16@xmlParse39
$LN18@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN21@xmlParse39
	cmp	cl, 70					; 00000046H
	jg	SHORT $LN21@xmlParse39
$LN16@xmlParse39:
	mov	cl, BYTE PTR [edi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN11@xmlParse39
$LN19@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN20@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN11@xmlParse39
$LN20@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN21@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN11@xmlParse39
$LN21@xmlParse39:
	cmp	al, 33					; 00000021H
	je	SHORT $LN11@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN11@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN11@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN11@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN11@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN11@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN11@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN11@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN11@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN11@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN11@xmlParse39
	cmp	al, 58					; 0000003aH
	je	SHORT $LN11@xmlParse39
	cmp	al, 64					; 00000040H
	je	SHORT $LN11@xmlParse39

; 816  :         ret = xmlParse3986PathNoScheme(uri, &str);
; 817  : 	if (ret != 0) return(ret);
; 818  :     } else {
; 819  : 	/* path-empty is effectively empty */
; 820  : 	if (uri != NULL) {

	mov	ebx, DWORD PTR _uri$[ebp]
	test	ebx, ebx
	je	$LN22@xmlParse39

; 821  : 	    if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN24@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlParse39:

; 822  : 	    uri->path = NULL;

	mov	DWORD PTR [ebx+24], 0
	jmp	$LN22@xmlParse39
$LN11@xmlParse39:

; 714  :     ret = xmlParse3986Segment(&cur, ':', 0);

	push	0
	lea	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR _cur$1[ebp], edi
	push	58					; 0000003aH
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 715  :     if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39

; 716  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$1[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN33@xmlParse39
$LL32@xmlParse39:

; 717  :         cur++;
; 718  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$1[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$1[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 719  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39

; 716  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$1[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL32@xmlParse39
$LN33@xmlParse39:

; 720  :     }
; 721  :     if (uri != NULL) {

	mov	ebx, DWORD PTR _uri$[ebp]
	test	ebx, ebx
	je	SHORT $LN39@xmlParse39

; 722  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN37@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN37@xmlParse39:

; 723  :         if (cur != *str) {

	cmp	esi, edi
	je	SHORT $LN38@xmlParse39

; 724  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, edi
	test	BYTE PTR [ebx+36], 2
	je	SHORT $LN40@xmlParse39

; 725  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	edi
	call	_xmlStrndup
	add	esp, 8

; 728  :         } else {

	mov	DWORD PTR [ebx+24], eax
	jmp	SHORT $LN39@xmlParse39
$LN40@xmlParse39:

; 726  :             else
; 727  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	edi
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 728  :         } else {

	mov	DWORD PTR [ebx+24], eax
	jmp	SHORT $LN39@xmlParse39
$LN38@xmlParse39:

; 729  :             uri->path = NULL;

	mov	DWORD PTR [ebx+24], 0
$LN39@xmlParse39:

; 730  :         }
; 731  :     }
; 732  :     *str = cur;

	mov	edi, esi
$LN22@xmlParse39:

; 823  : 	}
; 824  :     }
; 825  : 
; 826  :     if (*str == '?') {

	cmp	BYTE PTR [edi], 63			; 0000003fH
	jne	SHORT $LN26@xmlParse39

; 827  : 	str++;
; 828  : 	ret = xmlParse3986Query(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	inc	edi
	push	eax
	push	ebx
	mov	DWORD PTR _str$[ebp], edi
	call	_xmlParse3986Query
	add	esp, 8

; 829  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlParse39
	mov	edi, DWORD PTR _str$[ebp]
$LN26@xmlParse39:

; 830  :     }
; 831  :     if (*str == '#') {

	cmp	BYTE PTR [edi], 35			; 00000023H
	jne	SHORT $LN28@xmlParse39

; 832  : 	str++;
; 833  : 	ret = xmlParse3986Fragment(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	inc	edi
	push	eax
	push	ebx
	mov	DWORD PTR _str$[ebp], edi
	call	_xmlParse3986Fragment
	add	esp, 8

; 834  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlParse39
	mov	edi, DWORD PTR _str$[ebp]
$LN28@xmlParse39:

; 835  :     }
; 836  :     if (*str != 0) {

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN29@xmlParse39

; 837  : 	xmlCleanURI(uri);

	push	ebx
	call	_xmlCleanURI
	add	esp, 4

; 838  : 	return(1);

	mov	eax, 1
	pop	edi

; 841  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN29@xmlParse39:

; 839  :     }
; 840  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:
	pop	edi

; 841  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParse3986RelativeRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986HierPart
_TEXT	SEGMENT
_cur$1 = -4						; size = 4
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986HierPart PROC				; COMDAT

; 753  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], edi
	mov	al, BYTE PTR [edi]
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN7@xmlParse39

; 754  :     const char *cur;
; 755  :     int ret;
; 756  : 
; 757  :     cur = *str;
; 758  : 
; 759  :     if ((*cur == '/') && (*(cur + 1) == '/')) {

	cmp	BYTE PTR [edi+1], al
	jne	SHORT $LN2@xmlParse39

; 760  :         cur += 2;
; 761  : 	ret = xmlParse3986Authority(uri, &cur);

	mov	esi, DWORD PTR _uri$[ebp]
	lea	eax, DWORD PTR [edi+2]
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	_xmlParse3986Authority
	add	esp, 8

; 762  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39

; 763  : 	if (uri->server == NULL)

	cmp	DWORD PTR [esi+12], eax
	jne	SHORT $LN5@xmlParse39

; 764  : 	    uri->port = -1;

	mov	DWORD PTR [esi+20], -1
$LN5@xmlParse39:

; 765  : 	ret = xmlParse3986PathAbEmpty(uri, &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	_xmlParse3986PathAbEmpty
	add	esp, 8

; 766  : 	if (ret != 0) return(ret);

	test	eax, eax
	je	SHORT $LN43@xmlParse39

; 784  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlParse39:

; 767  : 	*str = cur;
; 768  : 	return(0);
; 769  :     } else if (*cur == '/') {
; 770  :         ret = xmlParse3986PathAbsolute(uri, &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	DWORD PTR _uri$[ebp]
	call	_xmlParse3986PathAbsolute
	add	esp, 8

; 771  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39
$LN43@xmlParse39:

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	edi, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], edi

; 783  :     return (0);

	xor	eax, eax
	pop	edi

; 784  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlParse39:

; 772  :     } else if (ISA_PCHAR(cur)) {

	cmp	al, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN12@xmlParse39
$LN13@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN14@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN12@xmlParse39
$LN14@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN15@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN12@xmlParse39
$LN15@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN12@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN12@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN12@xmlParse39
	cmp	al, 126					; 0000007eH
	je	$LN12@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN22@xmlParse39
	mov	cl, BYTE PTR [edi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN18@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN17@xmlParse39
$LN18@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN19@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN17@xmlParse39
$LN19@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN22@xmlParse39
	cmp	cl, 70					; 00000046H
	jg	SHORT $LN22@xmlParse39
$LN17@xmlParse39:
	mov	cl, BYTE PTR [edi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN20@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN12@xmlParse39
$LN20@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN21@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN12@xmlParse39
$LN21@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN22@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN12@xmlParse39
$LN22@xmlParse39:
	cmp	al, 33					; 00000021H
	je	SHORT $LN12@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN12@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN12@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN12@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN12@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN12@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN12@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN12@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN12@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN12@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN12@xmlParse39
	cmp	al, 58					; 0000003aH
	je	SHORT $LN12@xmlParse39
	cmp	al, 64					; 00000040H
	je	SHORT $LN12@xmlParse39

; 773  :         ret = xmlParse3986PathRootless(uri, &cur);
; 774  : 	if (ret != 0) return(ret);
; 775  :     } else {
; 776  : 	/* path-empty is effectively empty */
; 777  : 	if (uri != NULL) {

	mov	esi, DWORD PTR _uri$[ebp]
	test	esi, esi
	je	$LN23@xmlParse39

; 778  : 	    if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN25@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlParse39:

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [eax], edi

; 783  :     return (0);

	xor	eax, eax
	pop	edi

; 784  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlParse39:

; 672  :     ret = xmlParse3986Segment(&cur, 0, 0);

	push	0
	lea	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR _cur$1[ebp], edi
	push	0
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 673  :     if (ret != 0) return(ret);

	test	eax, eax
	jne	$LN1@xmlParse39

; 674  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$1[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN29@xmlParse39
	npad	4
$LL28@xmlParse39:

; 675  :         cur++;
; 676  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$1[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$1[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 677  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlParse39

; 674  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$1[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL28@xmlParse39
$LN29@xmlParse39:
	push	ebx

; 678  :     }
; 679  :     if (uri != NULL) {

	mov	ebx, DWORD PTR _uri$[ebp]
	test	ebx, ebx
	je	SHORT $LN35@xmlParse39

; 680  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN33@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlParse39:

; 681  :         if (cur != *str) {

	cmp	esi, edi
	je	SHORT $LN34@xmlParse39

; 682  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, edi
	test	BYTE PTR [ebx+36], 2
	je	SHORT $LN36@xmlParse39

; 683  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	edi
	call	_xmlStrndup
	add	esp, 8

; 686  :         } else {

	mov	DWORD PTR [ebx+24], eax

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]

; 690  :     *str = cur;

	mov	edi, esi
	pop	ebx

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	DWORD PTR [eax], edi

; 783  :     return (0);

	xor	eax, eax
	pop	edi

; 784  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlParse39:

; 685  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	edi
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 686  :         } else {

	mov	DWORD PTR [ebx+24], eax

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]

; 690  :     *str = cur;

	mov	edi, esi
	pop	ebx

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	DWORD PTR [eax], edi

; 783  :     return (0);

	xor	eax, eax
	pop	edi

; 784  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlParse39:

; 687  :             uri->path = NULL;

	mov	DWORD PTR [ebx+24], 0
$LN35@xmlParse39:

; 688  :         }
; 689  :     }
; 690  :     *str = cur;

	mov	edi, esi
	pop	ebx
$LN23@xmlParse39:

; 779  : 	    uri->path = NULL;
; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [eax], edi

; 783  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 784  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986HierPart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathNoScheme
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathNoScheme PROC				; COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	push	0
	push	58					; 0000003aH
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN1@xmlParse39

; 709  :     const char *cur;
; 710  :     int ret;
; 711  : 
; 712  :     cur = *str;
; 713  : 
; 714  :     ret = xmlParse3986Segment(&cur, ':', 0);
; 715  :     if (ret != 0) return(ret);
; 716  :     while (*cur == '/') {

	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN3@xmlParse39
$LL2@xmlParse39:

; 717  :         cur++;
; 718  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 719  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN17@xmlParse39

; 709  :     const char *cur;
; 710  :     int ret;
; 711  : 
; 712  :     cur = *str;
; 713  : 
; 714  :     ret = xmlParse3986Segment(&cur, ':', 0);
; 715  :     if (ret != 0) return(ret);
; 716  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL2@xmlParse39
$LN3@xmlParse39:
	push	edi

; 720  :     }
; 721  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlParse39

; 722  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN7@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlParse39:

; 723  :         if (cur != *str) {

	mov	ecx, DWORD PTR [ebx]
	cmp	esi, ecx
	je	SHORT $LN8@xmlParse39

; 724  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN10@xmlParse39

; 725  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 728  :         } else {

	mov	DWORD PTR [edi+24], eax

; 730  :         }
; 731  :     }
; 732  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 733  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 734  : }

	pop	ebp
	ret	0
$LN10@xmlParse39:

; 726  :             else
; 727  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 728  :         } else {

	mov	DWORD PTR [edi+24], eax

; 730  :         }
; 731  :     }
; 732  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 733  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 734  : }

	pop	ebp
	ret	0
$LN8@xmlParse39:

; 729  :             uri->path = NULL;

	mov	DWORD PTR [edi+24], 0
$LN9@xmlParse39:

; 730  :         }
; 731  :     }
; 732  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 733  :     return (0);

	xor	eax, eax
	pop	edi
$LN17@xmlParse39:
	pop	esi
$LN1@xmlParse39:
	pop	ebx

; 734  : }

	pop	ebp
	ret	0
_xmlParse3986PathNoScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathRootless
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathRootless PROC				; COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN1@xmlParse39

; 667  :     const char *cur;
; 668  :     int ret;
; 669  : 
; 670  :     cur = *str;
; 671  : 
; 672  :     ret = xmlParse3986Segment(&cur, 0, 0);
; 673  :     if (ret != 0) return(ret);
; 674  :     while (*cur == '/') {

	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN3@xmlParse39
$LL2@xmlParse39:

; 675  :         cur++;
; 676  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 677  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN17@xmlParse39

; 667  :     const char *cur;
; 668  :     int ret;
; 669  : 
; 670  :     cur = *str;
; 671  : 
; 672  :     ret = xmlParse3986Segment(&cur, 0, 0);
; 673  :     if (ret != 0) return(ret);
; 674  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL2@xmlParse39
$LN3@xmlParse39:
	push	edi

; 678  :     }
; 679  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlParse39

; 680  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN7@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlParse39:

; 681  :         if (cur != *str) {

	mov	ecx, DWORD PTR [ebx]
	cmp	esi, ecx
	je	SHORT $LN8@xmlParse39

; 682  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN10@xmlParse39

; 683  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 686  :         } else {

	mov	DWORD PTR [edi+24], eax

; 688  :         }
; 689  :     }
; 690  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 691  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 692  : }

	pop	ebp
	ret	0
$LN10@xmlParse39:

; 684  :             else
; 685  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 686  :         } else {

	mov	DWORD PTR [edi+24], eax

; 688  :         }
; 689  :     }
; 690  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 691  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 692  : }

	pop	ebp
	ret	0
$LN8@xmlParse39:

; 687  :             uri->path = NULL;

	mov	DWORD PTR [edi+24], 0
$LN9@xmlParse39:

; 688  :         }
; 689  :     }
; 690  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 691  :     return (0);

	xor	eax, eax
	pop	edi
$LN17@xmlParse39:
	pop	esi
$LN1@xmlParse39:
	pop	ebx

; 692  : }

	pop	ebp
	ret	0
_xmlParse3986PathRootless ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathAbsolute
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathAbsolute PROC				; COMDAT

; 620  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $LN4@xmlParse39

; 621  :     const char *cur;
; 622  :     int ret;
; 623  : 
; 624  :     cur = *str;
; 625  : 
; 626  :     if (*cur != '/')
; 627  :         return(1);

	mov	eax, 1
	pop	ebx

; 650  : }

	pop	ebp
	ret	0
$LN4@xmlParse39:
	push	esi

; 628  :     cur++;

	inc	eax

; 629  :     ret = xmlParse3986Segment(&cur, 0, 0);

	push	0
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	0
	push	eax
	call	_xmlParse3986Segment

; 630  :     if (ret == 0) {

	mov	esi, DWORD PTR _cur$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@xmlParse39

; 631  : 	while (*cur == '/') {

	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN3@xmlParse39
$LL2@xmlParse39:

; 632  : 	    cur++;
; 633  : 	    ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 634  : 	    if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN19@xmlParse39

; 631  : 	while (*cur == '/') {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL2@xmlParse39
$LN3@xmlParse39:
	push	edi

; 635  : 	}
; 636  :     }
; 637  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlParse39

; 638  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN8@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlParse39:

; 639  :         if (cur != *str) {

	mov	ecx, DWORD PTR [ebx]
	cmp	esi, ecx
	je	SHORT $LN9@xmlParse39

; 640  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN11@xmlParse39

; 641  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 644  :         } else {

	mov	DWORD PTR [edi+24], eax

; 646  :         }
; 647  :     }
; 648  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 649  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 650  : }

	pop	ebp
	ret	0
$LN11@xmlParse39:

; 642  :             else
; 643  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 644  :         } else {

	mov	DWORD PTR [edi+24], eax

; 646  :         }
; 647  :     }
; 648  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 649  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 650  : }

	pop	ebp
	ret	0
$LN9@xmlParse39:

; 645  :             uri->path = NULL;

	mov	DWORD PTR [edi+24], 0
$LN10@xmlParse39:

; 646  :         }
; 647  :     }
; 648  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 649  :     return (0);

	xor	eax, eax
	pop	edi
$LN19@xmlParse39:
	pop	esi
	pop	ebx

; 650  : }

	pop	ebp
	ret	0
_xmlParse3986PathAbsolute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathAbEmpty
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathAbEmpty PROC				; COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	mov	esi, DWORD PTR [ebx]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	jne	SHORT $LN3@xmlParse39
	npad	7
$LL2@xmlParse39:

; 587  :         cur++;
; 588  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	lea	eax, DWORD PTR _cur$[ebp]
	inc	esi
	push	0
	push	eax
	mov	DWORD PTR _cur$[ebp], esi
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH

; 589  : 	if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlParse39

; 581  :     const char *cur;
; 582  :     int ret;
; 583  : 
; 584  :     cur = *str;
; 585  : 
; 586  :     while (*cur == '/') {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	je	SHORT $LL2@xmlParse39
$LN3@xmlParse39:
	push	edi

; 590  :     }
; 591  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlParse39

; 592  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN6@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlParse39:

; 593  :         if (*str != cur) {

	mov	ecx, DWORD PTR [ebx]
	cmp	ecx, esi
	je	SHORT $LN7@xmlParse39

; 594  :             if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN9@xmlParse39

; 595  :                 uri->path = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 598  :         } else {

	mov	DWORD PTR [edi+24], eax

; 600  :         }
; 601  :     }
; 602  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 603  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi

; 604  : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlParse39:

; 596  :             else
; 597  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 598  :         } else {

	mov	DWORD PTR [edi+24], eax

; 600  :         }
; 601  :     }
; 602  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 603  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi

; 604  : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlParse39:

; 599  :             uri->path = NULL;

	mov	DWORD PTR [edi+24], 0
$LN8@xmlParse39:

; 600  :         }
; 601  :     }
; 602  :     *str = cur;

	mov	DWORD PTR [ebx], esi

; 603  :     return (0);

	xor	eax, eax
	pop	edi
$LN1@xmlParse39:

; 604  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlParse3986PathAbEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Segment
_TEXT	SEGMENT
_str$ = 8						; size = 4
_forbid$ = 12						; size = 1
_empty$ = 16						; size = 4
_xmlParse3986Segment PROC				; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	al, BYTE PTR [edx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN5@xmlParse39

; 552  :     const char *cur;
; 553  : 
; 554  :     cur = *str;
; 555  :     if (!ISA_PCHAR(cur)) {

	cmp	al, 122					; 0000007aH
	jle	SHORT $LN66@xmlParse39
$LN5@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN6@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	SHORT $LN66@xmlParse39
$LN6@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN7@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN66@xmlParse39
$LN7@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN66@xmlParse39
	cmp	al, 46					; 0000002eH
	je	SHORT $LN66@xmlParse39
	cmp	al, 95					; 0000005fH
	je	SHORT $LN66@xmlParse39
	cmp	al, 126					; 0000007eH
	je	SHORT $LN66@xmlParse39
	cmp	al, 37					; 00000025H
	jne	$LN14@xmlParse39
	mov	al, BYTE PTR [edx+1]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	cmp	al, 97					; 00000061H
	jl	SHORT $LN11@xmlParse39
	cmp	al, 102					; 00000066H
	jle	SHORT $LN9@xmlParse39
$LN11@xmlParse39:
	sub	al, 65					; 00000041H
	cmp	al, 5
	ja	$LN48@xmlParse39
$LN9@xmlParse39:
	mov	al, BYTE PTR [edx+2]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN66@xmlParse39
$LN12@xmlParse39:
	cmp	al, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	cmp	al, 102					; 00000066H
	jle	SHORT $LN66@xmlParse39
$LN13@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	$LN48@xmlParse39
	cmp	al, 70					; 00000046H
	jg	$LN48@xmlParse39
$LN66@xmlParse39:
	push	ebx
	mov	bl, BYTE PTR _forbid$[ebp]
	npad	7
$LL2@xmlParse39:

; 557  : 	    return(0);
; 558  : 	return(1);
; 559  :     }
; 560  :     while (ISA_PCHAR(cur) && (*cur != forbid))

	mov	al, BYTE PTR [edx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN17@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN16@xmlParse39
$LN17@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN18@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN16@xmlParse39
$LN18@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN19@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN16@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN16@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN16@xmlParse39
	cmp	al, 126					; 0000007eH
	je	$LN16@xmlParse39
	cmp	al, 37					; 00000025H
	jne	$LN26@xmlParse39
	mov	cl, BYTE PTR [edx+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN22@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN21@xmlParse39
$LN22@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN23@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN21@xmlParse39
$LN23@xmlParse39:
	sub	cl, 65					; 00000041H
	cmp	cl, 5
	ja	SHORT $LN62@xmlParse39
$LN21@xmlParse39:
	mov	cl, BYTE PTR [edx+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN24@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN24@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN25@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	$LN16@xmlParse39
$LN25@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN62@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	$LN16@xmlParse39
$LN62@xmlParse39:

; 562  :     *str = cur;
; 563  :     return (0);

	pop	ebx
	mov	DWORD PTR [esi], edx
	xor	eax, eax
	pop	esi

; 564  : }

	pop	ebp
	ret	0
$LN14@xmlParse39:

; 552  :     const char *cur;
; 553  : 
; 554  :     cur = *str;
; 555  :     if (!ISA_PCHAR(cur)) {

	cmp	al, 33					; 00000021H
	je	$LN66@xmlParse39
	cmp	al, 36					; 00000024H
	je	$LN66@xmlParse39
	cmp	al, 38					; 00000026H
	je	$LN66@xmlParse39
	cmp	al, 40					; 00000028H
	je	$LN66@xmlParse39
	cmp	al, 41					; 00000029H
	je	$LN66@xmlParse39
	cmp	al, 42					; 0000002aH
	je	$LN66@xmlParse39
	cmp	al, 43					; 0000002bH
	je	$LN66@xmlParse39
	cmp	al, 44					; 0000002cH
	je	$LN66@xmlParse39
	cmp	al, 59					; 0000003bH
	je	$LN66@xmlParse39
	cmp	al, 61					; 0000003dH
	je	$LN66@xmlParse39
	cmp	al, 39					; 00000027H
	je	$LN66@xmlParse39
	cmp	al, 58					; 0000003aH
	je	$LN66@xmlParse39
	cmp	al, 64					; 00000040H
	je	$LN66@xmlParse39
$LN48@xmlParse39:

; 556  :         if (empty)

	xor	eax, eax
	cmp	DWORD PTR _empty$[ebp], eax
	pop	esi
	sete	al

; 564  : }

	pop	ebp
	ret	0
$LN26@xmlParse39:

; 557  : 	    return(0);
; 558  : 	return(1);
; 559  :     }
; 560  :     while (ISA_PCHAR(cur) && (*cur != forbid))

	cmp	al, 33					; 00000021H
	je	SHORT $LN16@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN16@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN16@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN16@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN16@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN16@xmlParse39
	cmp	al, 58					; 0000003aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 64					; 00000040H
	jne	$LN62@xmlParse39
$LN16@xmlParse39:
	cmp	al, bl
	je	$LN62@xmlParse39

; 561  :         NEXT(cur);

	xor	ecx, ecx
	cmp	al, 37					; 00000025H
	sete	cl
	lea	edx, DWORD PTR [edx+ecx*2]
	inc	edx
	lea	ecx, DWORD PTR [ecx*2+1]
	jmp	$LL2@xmlParse39
_xmlParse3986Segment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Authority
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_cur$ = 12						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Authority PROC				; COMDAT

; 509  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	mov	esi, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	_xmlParse3986Userinfo
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlParse39

; 510  :     const char *cur;
; 511  :     int ret;
; 512  : 
; 513  :     cur = *str;
; 514  :     /*
; 515  :      * try to parse an userinfo and check for the trailing @
; 516  :      */
; 517  :     ret = xmlParse3986Userinfo(uri, &cur);
; 518  :     if ((ret != 0) || (*cur != '@'))

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 64			; 00000040H
	jne	SHORT $LN4@xmlParse39

; 520  :     else
; 521  :         cur++;

	inc	eax
	jmp	SHORT $LN3@xmlParse39
$LN4@xmlParse39:

; 519  :         cur = *str;

	mov	eax, DWORD PTR [edi]
$LN3@xmlParse39:

; 522  :     ret = xmlParse3986Host(uri, &cur);

	mov	DWORD PTR _cur$[ebp], eax
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	esi
	call	_xmlParse3986Host
	add	esp, 8

; 523  :     if (ret != 0) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlParse39

; 524  :     if (*cur == ':') {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [edx], 58			; 0000003aH
	jne	SHORT $LN7@xmlParse39

; 330  :     if (ISA_DIGIT(cur)) {

	mov	al, BYTE PTR [edx+1]

; 525  :         cur++;

	inc	edx

; 328  :     unsigned port = 0; /* unsigned for defined overflow behavior */

	xor	ecx, ecx

; 329  : 
; 330  :     if (ISA_DIGIT(cur)) {

	cmp	al, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	cmp	al, 57					; 00000039H
	jg	SHORT $LN12@xmlParse39
$LL10@xmlParse39:

; 331  : 	while (ISA_DIGIT(cur)) {

	cmp	al, 57					; 00000039H
	jg	SHORT $LN11@xmlParse39

; 332  : 	    port = port * 10 + (*cur - '0');

	movsx	eax, al
	lea	ecx, DWORD PTR [ecx+ecx*4]

; 333  : 
; 334  : 	    cur++;

	inc	edx
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL10@xmlParse39
$LN11@xmlParse39:

; 335  : 	}
; 336  : 	if (uri != NULL)

	test	esi, esi
	je	SHORT $LN7@xmlParse39

; 337  : 	    uri->port = port & INT_MAX; /* port value modulo INT_MAX+1 */

	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [esi+20], ecx
$LN7@xmlParse39:

; 528  :     }
; 529  :     *str = cur;

	mov	DWORD PTR [edi], edx

; 530  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 531  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlParse39:
	pop	edi

; 526  :         ret = xmlParse3986Port(uri, &cur);
; 527  : 	if (ret != 0) return(ret);

	mov	eax, 1

; 531  : }

	pop	esi
	pop	ebp
	ret	0
_xmlParse3986Authority ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Host
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Host PROC					; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	mov	esi, DWORD PTR [edi]
	mov	ebx, esi
	mov	DWORD PTR _cur$[ebp], esi
	mov	al, BYTE PTR [esi]
	cmp	al, 91					; 0000005bH
	jne	$LN6@xmlParse39

; 434  :     const char *cur = *str;
; 435  :     const char *host;
; 436  : 
; 437  :     host = cur;
; 438  :     /*
; 439  :      * IPv6 and future adressing scheme are enclosed between brackets
; 440  :      */
; 441  :     if (*cur == '[') {
; 442  :         cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi

; 443  : 	while ((*cur != ']') && (*cur != 0))

	mov	edx, esi
	cmp	al, 93					; 0000005dH
	je	SHORT $LN7@xmlParse39
	mov	ecx, esi
$LL2@xmlParse39:
	mov	edx, ecx
	test	al, al
	je	SHORT $LN3@xmlParse39

; 444  : 	    cur++;

	mov	al, BYTE PTR [ecx+1]
	lea	esi, DWORD PTR [ecx+1]
	mov	ecx, esi
	mov	edx, esi
	cmp	al, 93					; 0000005dH
	jne	SHORT $LL2@xmlParse39
$LN7@xmlParse39:

; 446  : 	    return(1);
; 447  : 	cur++;

	lea	esi, DWORD PTR [edx+1]
$found$60:

; 478  : found:
; 479  :     if (uri != NULL) {

	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	$LN32@xmlParse39

; 480  : 	if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN29@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN29@xmlParse39:

; 481  : 	uri->authority = NULL;
; 482  : 	if (uri->server != NULL) xmlFree(uri->server);

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [edi+8], 0
	test	eax, eax
	je	SHORT $LN30@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlParse39:

; 483  : 	if (cur != host) {

	cmp	esi, ebx
	je	$LN31@xmlParse39

; 484  : 	    if (uri->cleanup & 2)

	mov	eax, esi
	sub	eax, ebx
	test	BYTE PTR [edi+36], 2
	je	$LN33@xmlParse39

; 485  : 		uri->server = STRNDUP(host, cur - host);

	push	eax
	push	ebx
	call	_xmlStrndup
	add	esp, 8

; 488  : 	} else

	mov	DWORD PTR [edi+12], eax

; 490  :     }
; 491  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi

; 492  :     return(0);

	xor	eax, eax

; 493  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlParse39:

; 445  : 	if (*cur != ']')

	cmp	BYTE PTR [esi], 93			; 0000005dH
	je	SHORT $LN7@xmlParse39

; 493  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlParse39:

; 448  : 	goto found;
; 449  :     }
; 450  :     /*
; 451  :      * try to parse an IPv4
; 452  :      */
; 453  :     if (ISA_DIGIT(cur)) {

	cmp	al, 48					; 00000030H
	jl	SHORT $LL4@xmlParse39
	cmp	al, 57					; 00000039H
	jg	SHORT $LL4@xmlParse39

; 454  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	jne	SHORT $not_ipv4$61

; 455  : 	    goto not_ipv4;
; 456  : 	if (*cur != '.')

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 46			; 0000002eH
	jne	SHORT $not_ipv4$61

; 457  : 	    goto not_ipv4;
; 458  : 	cur++;

	inc	eax
	mov	DWORD PTR _cur$[ebp], eax

; 459  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	jne	SHORT $not_ipv4$61

; 460  : 	    goto not_ipv4;
; 461  : 	if (*cur != '.')

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 46			; 0000002eH
	jne	SHORT $not_ipv4$61

; 462  : 	    goto not_ipv4;
; 463  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	jne	SHORT $not_ipv4$61

; 464  : 	    goto not_ipv4;
; 465  : 	if (*cur != '.')

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 46			; 0000002eH
	jne	SHORT $not_ipv4$61

; 466  : 	    goto not_ipv4;
; 467  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	jne	SHORT $not_ipv4$61
	mov	esi, DWORD PTR _cur$[ebp]
	jmp	$found$60
$not_ipv4$61:

; 468  : 	    goto not_ipv4;
; 469  : 	goto found;
; 470  : not_ipv4:
; 471  :         cur = *str;

	mov	esi, DWORD PTR [edi]
	npad	4
$LL4@xmlParse39:

; 472  :     }
; 473  :     /*
; 474  :      * then this should be a hostname which can be empty
; 475  :      */
; 476  :     while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN17@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN27@xmlParse39
$LN17@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN18@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN27@xmlParse39
$LN18@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN27@xmlParse39
$LN19@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN27@xmlParse39
	cmp	al, 46					; 0000002eH
	je	SHORT $LN27@xmlParse39
	cmp	al, 95					; 0000005fH
	je	SHORT $LN27@xmlParse39
	cmp	al, 126					; 0000007eH
	je	SHORT $LN27@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN26@xmlParse39
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN22@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN21@xmlParse39
$LN22@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN23@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN21@xmlParse39
$LN23@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN26@xmlParse39
	cmp	cl, 70					; 00000046H
	jg	SHORT $LN26@xmlParse39
$LN21@xmlParse39:
	mov	cl, BYTE PTR [esi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN24@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN27@xmlParse39
$LN24@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN25@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN27@xmlParse39
$LN25@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN26@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN27@xmlParse39
$LN26@xmlParse39:
	cmp	al, 33					; 00000021H
	je	SHORT $LN27@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN27@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN27@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN27@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN27@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN27@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN27@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN27@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN27@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN27@xmlParse39
	cmp	al, 39					; 00000027H
	jne	$found$60
$LN27@xmlParse39:

; 477  :         NEXT(cur);

	cmp	al, 37					; 00000025H
	jne	SHORT $LN36@xmlParse39
	add	esi, 3
	jmp	$LL4@xmlParse39
$LN36@xmlParse39:
	inc	esi
	jmp	$LL4@xmlParse39
$LN33@xmlParse39:

; 486  : 	    else
; 487  : 		uri->server = xmlURIUnescapeString(host, cur - host, NULL);

	push	0
	push	eax
	push	ebx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 488  : 	} else

	mov	DWORD PTR [edi+12], eax

; 490  :     }
; 491  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi

; 492  :     return(0);

	xor	eax, eax

; 493  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlParse39:

; 489  : 	    uri->server = NULL;

	mov	DWORD PTR [edi+12], 0
$LN32@xmlParse39:

; 490  :     }
; 491  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi

; 492  :     return(0);

	xor	eax, eax

; 493  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Host ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986DecOctet
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlParse3986DecOctet PROC				; COMDAT

; 394  : xmlParse3986DecOctet(const char **str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [edi]
	mov	dl, BYTE PTR [ecx]
	mov	al, dl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN3@xmlParse39

; 395  :     const char *cur = *str;
; 396  : 
; 397  :     if (!(ISA_DIGIT(cur)))
; 398  :         return(1);
; 399  :     if (!ISA_DIGIT(cur+1))

	mov	bl, BYTE PTR [ecx+1]
	mov	al, bl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN6@xmlParse39

; 401  :     else if ((*cur != '0') && (ISA_DIGIT(cur + 1)) && (!ISA_DIGIT(cur+2)))

	cmp	dl, 48					; 00000030H
	je	SHORT $LN17@xmlParse39
	mov	ah, BYTE PTR [ecx+2]
	cmp	ah, 48					; 00000030H
	jl	SHORT $LN9@xmlParse39
	cmp	ah, 57					; 00000039H
	jle	SHORT $LN17@xmlParse39
$LN9@xmlParse39:

; 402  : 	cur += 2;

	add	ecx, 2

; 414  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edi], ecx
	pop	edi

; 415  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlParse39:

; 403  :     else if ((*cur == '1') && (ISA_DIGIT(cur + 1)) && (ISA_DIGIT(cur + 2)))

	cmp	dl, 49					; 00000031H
	jne	SHORT $LN10@xmlParse39
	mov	al, BYTE PTR [ecx+2]
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN3@xmlParse39

; 404  : 	cur += 3;

	add	ecx, 3

; 414  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edi], ecx
	pop	edi

; 415  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlParse39:

; 405  :     else if ((*cur == '2') && (*(cur + 1) >= '0') &&
; 406  : 	     (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))

	cmp	dl, 50					; 00000032H
	jne	SHORT $LN3@xmlParse39
	cmp	al, 4
	ja	SHORT $LN18@xmlParse39
	mov	al, BYTE PTR [ecx+2]
	sub	al, 48					; 00000030H
	cmp	al, 9
	jbe	SHORT $LN19@xmlParse39
$LN18@xmlParse39:

; 407  : 	cur += 3;
; 408  :     else if ((*cur == '2') && (*(cur + 1) == '5') &&
; 409  : 	     (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))

	cmp	bl, 53					; 00000035H
	jne	SHORT $LN3@xmlParse39
	cmp	BYTE PTR [ecx+2], 48			; 00000030H
	jl	SHORT $LN3@xmlParse39
$LN19@xmlParse39:

; 410  : 	cur += 3;
; 411  :     else
; 412  :         return(1);
; 413  :     *str = cur;

	add	ecx, 3

; 414  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edi], ecx
	pop	edi

; 415  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlParse39:

; 400  : 	cur++;

	inc	ecx

; 414  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edi], ecx
	pop	edi

; 415  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlParse39:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlParse3986DecOctet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Userinfo
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Userinfo PROC				; COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	mov	esi, DWORD PTR [ebx]
$LL2@xmlParse39:

; 359  :     const char *cur;
; 360  : 
; 361  :     cur = *str;
; 362  :     while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
; 363  :            ISA_SUB_DELIM(cur) || (*cur == ':'))

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN5@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN4@xmlParse39
$LN5@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN6@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN4@xmlParse39
$LN6@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN7@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN4@xmlParse39
$LN7@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN4@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN4@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN4@xmlParse39
	cmp	al, 126					; 0000007eH
	je	SHORT $LN4@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN14@xmlParse39
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN11@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN9@xmlParse39
$LN11@xmlParse39:
	sub	cl, 65					; 00000041H
	cmp	cl, 5
	ja	SHORT $LN15@xmlParse39
$LN9@xmlParse39:
	mov	cl, BYTE PTR [esi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN4@xmlParse39
$LN12@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN4@xmlParse39
$LN13@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN15@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN4@xmlParse39
$LN15@xmlParse39:
	pop	esi

; 375  :     }
; 376  :     return(1);

	mov	eax, 1

; 377  : }

	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlParse39:

; 359  :     const char *cur;
; 360  : 
; 361  :     cur = *str;
; 362  :     while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
; 363  :            ISA_SUB_DELIM(cur) || (*cur == ':'))

	cmp	al, 33					; 00000021H
	je	SHORT $LN4@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN4@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN4@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN4@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN4@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN4@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN4@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN4@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN4@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN4@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN4@xmlParse39
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN3@xmlParse39
$LN4@xmlParse39:

; 364  : 	NEXT(cur);

	xor	ecx, ecx
	cmp	al, 37					; 00000025H
	sete	cl
	lea	esi, DWORD PTR [esi+ecx*2]
	inc	esi
	lea	ecx, DWORD PTR [ecx*2+1]
	jmp	$LL2@xmlParse39
$LN3@xmlParse39:

; 365  :     if (*cur == '@') {

	cmp	al, 64					; 00000040H
	jne	SHORT $LN15@xmlParse39

; 366  : 	if (uri != NULL) {

	push	edi
	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN19@xmlParse39

; 367  : 	    if (uri->user != NULL) xmlFree(uri->user);

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN17@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlParse39:

; 368  : 	    if (uri->cleanup & 2)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN18@xmlParse39

; 369  : 		uri->user = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 372  : 	}
; 373  : 	*str = cur;

	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [ebx], esi

; 374  : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi

; 377  : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlParse39:

; 370  : 	    else
; 371  : 		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 372  : 	}
; 373  : 	*str = cur;

	mov	DWORD PTR [edi+16], eax
$LN19@xmlParse39:

; 374  : 	return(0);

	pop	edi
	mov	DWORD PTR [ebx], esi
	xor	eax, eax
	pop	esi

; 377  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlParse3986Userinfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Port
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Port PROC					; COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	xor	ecx, ecx
	mov	esi, DWORD PTR [edi]
	mov	dl, BYTE PTR [esi]
	lea	eax, DWORD PTR [edx-48]
	cmp	al, 9
	ja	SHORT $LN4@xmlParse39
	npad	1
$LL2@xmlParse39:

; 327  :     const char *cur = *str;
; 328  :     unsigned port = 0; /* unsigned for defined overflow behavior */
; 329  : 
; 330  :     if (ISA_DIGIT(cur)) {
; 331  : 	while (ISA_DIGIT(cur)) {

	cmp	dl, 57					; 00000039H
	jg	SHORT $LN3@xmlParse39

; 332  : 	    port = port * 10 + (*cur - '0');
; 333  : 
; 334  : 	    cur++;

	inc	esi
	movsx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [ecx-24]
	mov	dl, BYTE PTR [esi]
	lea	ecx, DWORD PTR [eax+ecx*2]
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL2@xmlParse39
$LN3@xmlParse39:

; 335  : 	}
; 336  : 	if (uri != NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlParse39

; 337  : 	    uri->port = port & INT_MAX; /* port value modulo INT_MAX+1 */

	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [eax+20], ecx
$LN5@xmlParse39:

; 338  : 	*str = cur;

	mov	DWORD PTR [edi], esi

; 339  : 	return(0);

	xor	eax, eax
	pop	edi

; 342  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlParse39:
	pop	edi

; 340  :     }
; 341  :     return(1);

	mov	eax, 1

; 342  : }

	pop	esi
	pop	ebp
	ret	0
_xmlParse3986Port ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Query
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Query PROC					; COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlParse39

; 283  :     const char *cur;
; 284  : 
; 285  :     if (str == NULL)
; 286  :         return (-1);

	or	eax, -1
	pop	ebx

; 310  : }

	pop	ebp
	ret	0
$LN4@xmlParse39:
	push	esi

; 287  : 
; 288  :     cur = *str;

	mov	esi, DWORD PTR [ebx]
	push	edi

; 289  : 
; 290  :     while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||

	mov	edi, DWORD PTR _uri$[ebp]
$LL2@xmlParse39:
	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN16@xmlParse39
$LN6@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN7@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN16@xmlParse39
$LN7@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN8@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN8@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN16@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN16@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN16@xmlParse39
	cmp	al, 126					; 0000007eH
	je	$LN16@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN15@xmlParse39
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN10@xmlParse39
$LN11@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN10@xmlParse39
$LN12@xmlParse39:
	sub	cl, 65					; 00000041H
	cmp	cl, 5
	ja	SHORT $LN43@xmlParse39
$LN10@xmlParse39:
	mov	cl, BYTE PTR [esi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN13@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN13@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN14@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN16@xmlParse39
$LN14@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN43@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN16@xmlParse39
	jmp	SHORT $LN43@xmlParse39
$LN15@xmlParse39:
	cmp	al, 33					; 00000021H
	je	SHORT $LN16@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN16@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN16@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN16@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN16@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN16@xmlParse39
	cmp	al, 58					; 0000003aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 64					; 00000040H
	je	SHORT $LN16@xmlParse39
	cmp	al, 47					; 0000002fH
	je	SHORT $LN16@xmlParse39
	cmp	al, 63					; 0000003fH
	je	SHORT $LN16@xmlParse39
$LN43@xmlParse39:
	test	edi, edi
	je	$LN17@xmlParse39
	test	BYTE PTR [edi+36], 1
	je	SHORT $LN44@xmlParse39
	cmp	al, 123					; 0000007bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 125					; 0000007dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 124					; 0000007cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 92					; 0000005cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 94					; 0000005eH
	je	SHORT $LN16@xmlParse39
	cmp	al, 91					; 0000005bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 93					; 0000005dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 96					; 00000060H
	jne	SHORT $LN44@xmlParse39
$LN16@xmlParse39:

; 291  :            ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
; 292  :         NEXT(cur);

	xor	ecx, ecx
	cmp	al, 37					; 00000025H
	sete	cl
	lea	esi, DWORD PTR [esi+ecx*2]
	inc	esi
	lea	ecx, DWORD PTR [ecx*2+1]
	jmp	$LL2@xmlParse39
$LN44@xmlParse39:

; 293  :     if (uri != NULL) {
; 294  :         if (uri->query != NULL)

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN18@xmlParse39

; 295  :             xmlFree(uri->query);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlParse39:

; 296  : 	if (uri->cleanup & 2)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, esi
	sub	eax, ecx
	test	BYTE PTR [edi+36], 2
	je	SHORT $LN19@xmlParse39

; 297  : 	    uri->query = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	jmp	SHORT $LN20@xmlParse39
$LN19@xmlParse39:

; 298  : 	else
; 299  : 	    uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
$LN20@xmlParse39:

; 300  : 
; 301  : 	/* Save the raw bytes of the query as well.
; 302  : 	 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00114
; 303  : 	 */
; 304  : 	if (uri->query_raw != NULL)

	mov	DWORD PTR [edi+28], eax
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN21@xmlParse39

; 305  : 	    xmlFree (uri->query_raw);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlParse39:

; 306  : 	uri->query_raw = STRNDUP (*str, cur - *str);

	mov	ecx, DWORD PTR [ebx]
	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [edi+40], eax
$LN17@xmlParse39:

; 307  :     }
; 308  :     *str = cur;
; 309  :     return (0);

	pop	edi
	mov	DWORD PTR [ebx], esi
	xor	eax, eax
	pop	esi
	pop	ebx

; 310  : }

	pop	ebp
	ret	0
_xmlParse3986Query ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Fragment
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Fragment PROC				; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlParse39

; 246  :     const char *cur;
; 247  : 
; 248  :     if (str == NULL)
; 249  :         return (-1);

	or	eax, -1
	pop	ebx

; 267  : }

	pop	ebp
	ret	0
$LN4@xmlParse39:
	push	esi

; 250  : 
; 251  :     cur = *str;

	mov	esi, DWORD PTR [ebx]
	push	edi

; 252  : 
; 253  :     while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
; 254  :            (*cur == '[') || (*cur == ']') ||

	mov	edi, DWORD PTR _uri$[ebp]
$LL2@xmlParse39:
	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	$LN16@xmlParse39
$LN6@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN7@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	$LN16@xmlParse39
$LN7@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN8@xmlParse39
	cmp	al, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN8@xmlParse39:
	cmp	al, 45					; 0000002dH
	je	$LN16@xmlParse39
	cmp	al, 46					; 0000002eH
	je	$LN16@xmlParse39
	cmp	al, 95					; 0000005fH
	je	$LN16@xmlParse39
	cmp	al, 126					; 0000007eH
	je	$LN16@xmlParse39
	cmp	al, 37					; 00000025H
	jne	SHORT $LN15@xmlParse39
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN10@xmlParse39
$LN11@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN10@xmlParse39
$LN12@xmlParse39:
	sub	cl, 65					; 00000041H
	cmp	cl, 5
	ja	SHORT $LN44@xmlParse39
$LN10@xmlParse39:
	mov	cl, BYTE PTR [esi+2]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN13@xmlParse39
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN16@xmlParse39
$LN13@xmlParse39:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN14@xmlParse39
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN16@xmlParse39
$LN14@xmlParse39:
	cmp	cl, 65					; 00000041H
	jl	SHORT $LN44@xmlParse39
	cmp	cl, 70					; 00000046H
	jle	SHORT $LN16@xmlParse39
	jmp	SHORT $LN44@xmlParse39
$LN15@xmlParse39:
	cmp	al, 33					; 00000021H
	je	SHORT $LN16@xmlParse39
	cmp	al, 36					; 00000024H
	je	SHORT $LN16@xmlParse39
	cmp	al, 38					; 00000026H
	je	SHORT $LN16@xmlParse39
	cmp	al, 40					; 00000028H
	je	SHORT $LN16@xmlParse39
	cmp	al, 41					; 00000029H
	je	SHORT $LN16@xmlParse39
	cmp	al, 42					; 0000002aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 43					; 0000002bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 44					; 0000002cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 59					; 0000003bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 61					; 0000003dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 39					; 00000027H
	je	SHORT $LN16@xmlParse39
	cmp	al, 58					; 0000003aH
	je	SHORT $LN16@xmlParse39
	cmp	al, 64					; 00000040H
	je	SHORT $LN16@xmlParse39
	cmp	al, 47					; 0000002fH
	je	SHORT $LN16@xmlParse39
	cmp	al, 63					; 0000003fH
	je	SHORT $LN16@xmlParse39
	cmp	al, 91					; 0000005bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 93					; 0000005dH
	je	SHORT $LN16@xmlParse39
$LN44@xmlParse39:
	test	edi, edi
	je	SHORT $LN20@xmlParse39
	mov	edx, DWORD PTR [edi+36]
	test	dl, 1
	je	SHORT $LN3@xmlParse39
	cmp	al, 123					; 0000007bH
	je	SHORT $LN16@xmlParse39
	cmp	al, 125					; 0000007dH
	je	SHORT $LN16@xmlParse39
	cmp	al, 124					; 0000007cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 92					; 0000005cH
	je	SHORT $LN16@xmlParse39
	cmp	al, 94					; 0000005eH
	je	SHORT $LN16@xmlParse39
	cmp	al, 96					; 00000060H
	jne	SHORT $LN3@xmlParse39
$LN16@xmlParse39:

; 255  :            ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
; 256  :         NEXT(cur);

	xor	ecx, ecx
	cmp	al, 37					; 00000025H
	sete	cl
	lea	esi, DWORD PTR [esi+ecx*2]
	inc	esi
	lea	ecx, DWORD PTR [ecx*2+1]
	jmp	$LL2@xmlParse39
$LN3@xmlParse39:

; 257  :     if (uri != NULL) {
; 258  :         if (uri->fragment != NULL)

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN18@xmlParse39

; 259  :             xmlFree(uri->fragment);

	push	eax
	call	DWORD PTR _xmlFree
	mov	edx, DWORD PTR [edi+36]
	add	esp, 4
$LN18@xmlParse39:

; 260  : 	if (uri->cleanup & 2)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, esi
	sub	eax, ecx
	test	dl, 2
	je	SHORT $LN19@xmlParse39

; 261  : 	    uri->fragment = STRNDUP(*str, cur - *str);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 264  :     }
; 265  :     *str = cur;

	mov	DWORD PTR [edi+32], eax
	mov	DWORD PTR [ebx], esi

; 266  :     return (0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 267  : }

	pop	ebp
	ret	0
$LN19@xmlParse39:

; 262  : 	else
; 263  : 	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	push	eax
	push	ecx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH

; 264  :     }
; 265  :     *str = cur;

	mov	DWORD PTR [edi+32], eax
$LN20@xmlParse39:

; 266  :     return (0);

	pop	edi
	mov	DWORD PTR [ebx], esi
	xor	eax, eax
	pop	esi
	pop	ebx

; 267  : }

	pop	ebp
	ret	0
_xmlParse3986Fragment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Scheme
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Scheme PROC				; COMDAT

; 208  : xmlParse3986Scheme(xmlURIPtr uri, const char **str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlParse39

; 209  :     const char *cur;
; 210  : 
; 211  :     if (str == NULL)
; 212  : 	return(-1);

	or	eax, -1
	pop	ebx

; 226  : }

	pop	ebp
	ret	0
$LN4@xmlParse39:
	push	esi

; 213  : 
; 214  :     cur = *str;

	mov	esi, DWORD PTR [ebx]

; 215  :     if (!ISA_ALPHA(cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN5@xmlParse39
$LN6@xmlParse39:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN7@xmlParse39
$LN5@xmlParse39:

; 217  :     cur++;
; 218  :     while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
; 219  :            (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 97					; 00000061H
	jl	SHORT $LN9@xmlParse39
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN5@xmlParse39
$LN9@xmlParse39:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN10@xmlParse39
	cmp	al, 90					; 0000005aH
	jle	SHORT $LN5@xmlParse39
$LN10@xmlParse39:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	cmp	al, 57					; 00000039H
	jle	SHORT $LN5@xmlParse39
$LN11@xmlParse39:
	cmp	al, 43					; 0000002bH
	je	SHORT $LN5@xmlParse39
	cmp	al, 45					; 0000002dH
	je	SHORT $LN5@xmlParse39
	cmp	al, 46					; 0000002eH
	je	SHORT $LN5@xmlParse39

; 220  :     if (uri != NULL) {

	push	edi
	mov	edi, DWORD PTR _uri$[ebp]
	test	edi, edi
	je	SHORT $LN12@xmlParse39

; 221  : 	if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@xmlParse39
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParse39:

; 222  : 	uri->scheme = STRNDUP(*str, cur - *str);

	mov	ecx, DWORD PTR [ebx]
	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN12@xmlParse39:

; 223  :     }
; 224  :     *str = cur;
; 225  :     return(0);

	pop	edi
	mov	DWORD PTR [ebx], esi
	xor	eax, eax
	pop	esi
	pop	ebx

; 226  : }

	pop	ebp
	ret	0
$LN7@xmlParse39:
	pop	esi

; 216  : 	return(2);

	mov	eax, 2
	pop	ebx

; 226  : }

	pop	ebp
	ret	0
_xmlParse3986Scheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCleanURI
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_xmlCleanURI PROC					; COMDAT

; 1349 : xmlCleanURI(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _uri$[ebp]
	test	esi, esi
	je	$LN1@xmlCleanUR

; 1350 :     if (uri == NULL) return;
; 1351 : 
; 1352 :     if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlCleanUR:

; 1353 :     uri->scheme = NULL;
; 1354 :     if (uri->server != NULL) xmlFree(uri->server);

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], 0
	test	eax, eax
	je	SHORT $LN4@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlCleanUR:

; 1355 :     uri->server = NULL;
; 1356 :     if (uri->user != NULL) xmlFree(uri->user);

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], 0
	test	eax, eax
	je	SHORT $LN5@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlCleanUR:

; 1357 :     uri->user = NULL;
; 1358 :     if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN6@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlCleanUR:

; 1359 :     uri->path = NULL;
; 1360 :     if (uri->fragment != NULL) xmlFree(uri->fragment);

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+24], 0
	test	eax, eax
	je	SHORT $LN7@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCleanUR:

; 1361 :     uri->fragment = NULL;
; 1362 :     if (uri->opaque != NULL) xmlFree(uri->opaque);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+32], 0
	test	eax, eax
	je	SHORT $LN8@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlCleanUR:

; 1363 :     uri->opaque = NULL;
; 1364 :     if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], 0
	test	eax, eax
	je	SHORT $LN9@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlCleanUR:

; 1365 :     uri->authority = NULL;
; 1366 :     if (uri->query != NULL) xmlFree(uri->query);

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+8], 0
	test	eax, eax
	je	SHORT $LN10@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlCleanUR:

; 1367 :     uri->query = NULL;
; 1368 :     if (uri->query_raw != NULL) xmlFree(uri->query_raw);

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+28], 0
	test	eax, eax
	je	SHORT $LN11@xmlCleanUR
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlCleanUR:

; 1369 :     uri->query_raw = NULL;

	mov	DWORD PTR [esi+40], 0
$LN1@xmlCleanUR:
	pop	esi

; 1370 : }

	pop	ebp
	ret	0
_xmlCleanURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlURIErrMemory PROC					; COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlURIErrM

; 38   :     if (extra)
; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	30					; 0000001eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 46   :                         NULL, NULL, XML_FROM_URI,
; 47   :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 48   :                         NULL, NULL, NULL, 0, 0,
; 49   :                         "Memory allocation failed\n");
; 50   : }

	pop	ebp
	ret	0
$LN2@xmlURIErrM:

; 40   :                         NULL, NULL, XML_FROM_URI,
; 41   :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 42   :                         extra, NULL, NULL, 0, 0,
; 43   :                         "Memory allocation failed : %s\n", extra);
; 44   :     else
; 45   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	30					; 0000001eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H

; 46   :                         NULL, NULL, XML_FROM_URI,
; 47   :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 48   :                         NULL, NULL, NULL, 0, 0,
; 49   :                         "Memory allocation failed\n");
; 50   : }

	pop	ebp
	ret	0
_xmlURIErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlPathToURI
_TEXT	SEGMENT
_temp$ = -44						; size = 44
_path$ = 8						; size = 4
_xmlPathToURI PROC					; COMDAT

; 2512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	ecx, OFFSET __0B912F28_uri@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _path$[ebp]
	test	edi, edi
	je	$LN20@xmlPathToU

; 938  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	ebx, eax

; 939  :     if (uri != NULL) {

	test	ebx, ebx
	je	SHORT $LN5@xmlPathToU

; 940  : 	ret = xmlParse3986URIReference(uri, str);

	push	edi
	push	ebx
	call	_xmlParse3986URIReference
	push	ebx
	mov	esi, eax
	call	_xmlFreeURI
	add	esp, 12					; 0000000cH

; 941  :         if (ret) {

	test	esi, esi
	jne	SHORT $LN5@xmlPathToU

; 2513 :     xmlURIPtr uri;
; 2514 :     xmlURI temp;
; 2515 :     xmlChar *ret, *cal;
; 2516 : 
; 2517 :     if (path == NULL)
; 2518 :         return(NULL);
; 2519 : 
; 2520 :     if ((uri = xmlParseURI((const char *) path)) != NULL) {
; 2521 : 	xmlFreeURI(uri);
; 2522 : 	return xmlStrdup(path);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 2550 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlPathToU:

; 2523 :     }
; 2524 :     cal = xmlCanonicPath(path);

	push	edi
	call	_xmlCanonicPath
	mov	edi, eax
	add	esp, 4

; 2525 :     if (cal == NULL)

	test	edi, edi
	je	SHORT $LN20@xmlPathToU

; 2526 :         return(NULL);
; 2527 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2528 :     /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
; 2529 :        If 'cal' is a valid URI allready then we are done here, as continuing would make
; 2530 :        it invalid. */
; 2531 :     if ((uri = xmlParseURI((const char *) cal)) != NULL) {

	push	edi
	call	_xmlParseURI
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@xmlPathToU

; 2532 : 	xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI
	add	esp, 4

; 2533 : 	return cal;

	mov	eax, edi
	pop	edi

; 2550 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlPathToU:

; 2534 :     }
; 2535 :     /* 'cal' can contain a relative path with backslashes. If that is processed
; 2536 :        by xmlSaveURI, they will be escaped and the external entity loader machinery
; 2537 :        will fail. So convert them to slashes. Misuse 'ret' for walking. */
; 2538 :     ret = cal;
; 2539 :     while (*ret != '\0') {

	mov	cl, BYTE PTR [edi]
	mov	eax, edi
	test	cl, cl
	je	SHORT $LN3@xmlPathToU
$LL2@xmlPathToU:

; 2540 : 	if (*ret == '\\')

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN18@xmlPathToU

; 2541 : 	    *ret = '/';

	mov	BYTE PTR [eax], 47			; 0000002fH
$LN18@xmlPathToU:

; 2534 :     }
; 2535 :     /* 'cal' can contain a relative path with backslashes. If that is processed
; 2536 :        by xmlSaveURI, they will be escaped and the external entity loader machinery
; 2537 :        will fail. So convert them to slashes. Misuse 'ret' for walking. */
; 2538 :     ret = cal;
; 2539 :     while (*ret != '\0') {

	mov	cl, BYTE PTR [eax+1]

; 2542 : 	ret++;

	inc	eax
	test	cl, cl
	jne	SHORT $LL2@xmlPathToU
$LN3@xmlPathToU:
	xorps	xmm0, xmm0

; 2543 :     }
; 2544 : #endif
; 2545 :     memset(&temp, 0, sizeof(temp));
; 2546 :     temp.path = (char *) cal;

	mov	DWORD PTR _temp$[ebp+24], edi

; 2547 :     ret = xmlSaveUri(&temp);

	lea	eax, DWORD PTR _temp$[ebp]
	movlpd	QWORD PTR _temp$[ebp], xmm0
	push	eax
	movlpd	QWORD PTR _temp$[ebp+8], xmm0
	movlpd	QWORD PTR _temp$[ebp+16], xmm0
	movlpd	QWORD PTR _temp$[ebp+28], xmm0
	movlpd	QWORD PTR _temp$[ebp+36], xmm0
	call	_xmlSaveUri

; 2548 :     xmlFree(cal);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 8

; 2549 :     return(ret);

	mov	eax, esi
	pop	edi

; 2550 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlPathToU:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPathToURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCanonicPath
_TEXT	SEGMENT
_len$1$ = 8						; size = 4
_path$ = 8						; size = 4
_xmlCanonicPath PROC					; COMDAT

; 2371 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _path$[ebp]
	test	edi, edi
	je	$LN47@xmlCanonic

; 2372 : /*
; 2373 :  * For Windows implementations, additional work needs to be done to
; 2374 :  * replace backslashes in pathnames with "forward slashes"
; 2375 :  */
; 2376 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2377 :     int len = 0;
; 2378 :     char *p = NULL;
; 2379 : #endif
; 2380 :     xmlURIPtr uri;
; 2381 :     xmlChar *ret;
; 2382 :     const xmlChar *absuri;
; 2383 : 
; 2384 :     if (path == NULL)
; 2385 : 	return(NULL);
; 2386 : 
; 2387 : #if defined(_WIN32)
; 2388 :     /*
; 2389 :      * We must not change the backslashes to slashes if the the path
; 2390 :      * starts with \\?\
; 2391 :      * Those paths can be up to 32k characters long.
; 2392 :      * Was added specifically for OpenOffice, those paths can't be converted
; 2393 :      * to URIs anyway.
; 2394 :      */
; 2395 :     if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&

	mov	al, BYTE PTR [edi]
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN8@xmlCanonic
	cmp	BYTE PTR [edi+1], al
	jne	SHORT $LN9@xmlCanonic
	cmp	BYTE PTR [edi+2], 63			; 0000003fH
	jne	SHORT $LN9@xmlCanonic
	cmp	BYTE PTR [edi+3], al
	jne	SHORT $LN9@xmlCanonic
$LN49@xmlCanonic:

; 2497 : }

	push	edi
	call	_xmlStrdup
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlCanonic:

; 2396 :         (path[3] == '\\') )
; 2397 : 	return xmlStrdup((const xmlChar *) path);
; 2398 : #endif
; 2399 : 
; 2400 : 	/* sanitize filename starting with // so it can be used as URI */
; 2401 :     if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN9@xmlCanonic
	cmp	BYTE PTR [edi+1], 47			; 0000002fH
	lea	eax, DWORD PTR [edi+1]
	jne	SHORT $LN9@xmlCanonic
	cmp	BYTE PTR [edi+2], 47			; 0000002fH
	cmovne	edi, eax
$LN9@xmlCanonic:

; 936  :     if (str == NULL)

	test	edi, edi
	je	SHORT $LN10@xmlCanonic

; 937  : 	return(NULL);
; 938  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	ebx, eax

; 939  :     if (uri != NULL) {

	test	ebx, ebx
	je	SHORT $LN10@xmlCanonic

; 940  : 	ret = xmlParse3986URIReference(uri, str);

	push	edi
	push	ebx
	call	_xmlParse3986URIReference
	push	ebx
	mov	esi, eax
	call	_xmlFreeURI
	add	esp, 12					; 0000000cH

; 941  :         if (ret) {

	test	esi, esi
	je	SHORT $LN49@xmlCanonic
$LN10@xmlCanonic:

; 2402 :         path++;
; 2403 : 
; 2404 :     if ((uri = xmlParseURI((const char *) path)) != NULL) {
; 2405 : 	xmlFreeURI(uri);
; 2406 : 	return xmlStrdup(path);
; 2407 :     }
; 2408 : 
; 2409 :     /* Check if this is an "absolute uri" */
; 2410 :     absuri = xmlStrstr(path, BAD_CAST "://");

	push	OFFSET ??_C@_03GACAABJG@?3?1?1@
	push	edi
	call	_xmlStrstr
	mov	edx, eax
	add	esp, 8

; 2411 :     if (absuri != NULL) {

	test	edx, edx
	je	SHORT $path_processing$51

; 2412 :         int l, j;
; 2413 : 	unsigned char c;
; 2414 : 	xmlChar *escURI;
; 2415 : 
; 2416 :         /*
; 2417 : 	 * this looks like an URI where some parts have not been
; 2418 : 	 * escaped leading to a parsing problem.  Check that the first
; 2419 : 	 * part matches a protocol.
; 2420 : 	 */
; 2421 : 	l = absuri - path;

	sub	edx, edi

; 2422 : 	/* Bypass if first part (part before the '://') is > 20 chars */
; 2423 : 	if ((l <= 0) || (l > 20))

	lea	ecx, DWORD PTR [edx-1]
	cmp	ecx, 19					; 00000013H
	ja	SHORT $path_processing$51

; 2424 : 	    goto path_processing;
; 2425 : 	/* Bypass if any non-alpha characters are present in first part */
; 2426 : 	for (j = 0;j < l;j++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN3@xmlCanonic
	npad	4
$LL4@xmlCanonic:

; 2427 : 	    c = path[j];

	mov	al, BYTE PTR [ecx+edi]

; 2428 : 	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))

	cmp	al, 97					; 00000061H
	jb	SHORT $LN15@xmlCanonic
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN2@xmlCanonic
$LN15@xmlCanonic:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $path_processing$51
$LN2@xmlCanonic:

; 2424 : 	    goto path_processing;
; 2425 : 	/* Bypass if any non-alpha characters are present in first part */
; 2426 : 	for (j = 0;j < l;j++) {

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL4@xmlCanonic
$LN3@xmlCanonic:

; 2429 : 	        goto path_processing;
; 2430 : 	}
; 2431 : 
; 2432 : 	/* Escape all except the characters specified in the supplied path */
; 2433 :         escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");

	push	OFFSET ??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@
	push	edi
	call	_xmlURIEscapeStr
	mov	esi, eax
	add	esp, 8

; 2434 : 	if (escURI != NULL) {

	test	esi, esi
	je	SHORT $path_processing$51

; 2435 : 	    /* Try parsing the escaped path */
; 2436 : 	    uri = xmlParseURI((const char *) escURI);

	push	esi
	call	_xmlParseURI
	add	esp, 4

; 2437 : 	    /* If successful, return the escaped string */
; 2438 : 	    if (uri != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlCanonic

; 2439 : 	        xmlFreeURI(uri);

	push	eax
	call	_xmlFreeURI
	add	esp, 4

; 2440 : 		return escURI;

	mov	eax, esi
	pop	edi

; 2497 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlCanonic:

; 2441 : 	    }
; 2442 :             xmlFree(escURI);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$path_processing$51:

; 2443 : 	}
; 2444 :     }
; 2445 : 
; 2446 : path_processing:
; 2447 : /* For Windows implementations, replace backslashes with 'forward slashes' */
; 2448 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2449 :     /*
; 2450 :      * Create a URI structure
; 2451 :      */
; 2452 :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	ebx, eax

; 2453 :     if (uri == NULL) {		/* Guard against 'out of memory' */

	test	ebx, ebx
	je	$LN47@xmlCanonic

; 2454 :         return(NULL);
; 2455 :     }
; 2456 : 
; 2457 :     len = xmlStrlen(path);

	push	edi
	call	_xmlStrlen
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], esi

; 2458 :     if ((len > 2) && IS_WINDOWS_PATH(path)) {

	cmp	esi, 2
	jle	$LN20@xmlCanonic
	test	edi, edi
	je	$LN20@xmlCanonic
	mov	cl, BYTE PTR [edi]
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN23@xmlCanonic
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN22@xmlCanonic
$LN23@xmlCanonic:
	sub	cl, 65					; 00000041H
	cmp	cl, 25					; 00000019H
	ja	SHORT $LN20@xmlCanonic
$LN22@xmlCanonic:
	cmp	BYTE PTR [edi+1], 58			; 0000003aH
	jne	SHORT $LN20@xmlCanonic
	mov	al, BYTE PTR [edi+2]
	cmp	al, 47					; 0000002fH
	je	SHORT $LN24@xmlCanonic
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN20@xmlCanonic
$LN24@xmlCanonic:

; 2459 :         /* make the scheme 'file' */
; 2460 : 	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");

	push	OFFSET ??_C@_04DAMGJPCA@file@
	call	_xmlStrdup
	mov	DWORD PTR [ebx], eax

; 2461 : 	/* allocate space for leading '/' + path + string terminator */
; 2462 : 	uri->path = xmlMallocAtomic(len + 2);

	lea	eax, DWORD PTR [esi+2]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 8
	mov	DWORD PTR [ebx+24], eax

; 2463 : 	if (uri->path == NULL) {

	test	eax, eax
	je	SHORT $LN46@xmlCanonic

; 2464 : 	    xmlFreeURI(uri);	/* Guard agains 'out of memory' */
; 2465 : 	    return(NULL);
; 2466 : 	}
; 2467 : 	/* Put in leading '/' plus path */
; 2468 : 	uri->path[0] = '/';

	mov	BYTE PTR [eax], 47			; 0000002fH

; 2469 : 	p = uri->path + 1;
; 2470 : 	strncpy(p, (char *) path, len + 1);

	mov	eax, DWORD PTR _len$1$[ebp]
	mov	esi, DWORD PTR [ebx+24]
	inc	eax
	push	eax
	inc	esi
	push	edi
	push	esi
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
$LN26@xmlCanonic:

; 2475 : 	    return(NULL);
; 2476 : 	}
; 2477 : 	p = uri->path;
; 2478 :     }
; 2479 :     /* Now change all occurences of '\' to '/' */
; 2480 :     while (*p != '\0') {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN6@xmlCanonic
$LL5@xmlCanonic:

; 2481 : 	if (*p == '\\')

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN43@xmlCanonic

; 2482 : 	    *p = '/';

	mov	BYTE PTR [esi], 47			; 0000002fH
$LN43@xmlCanonic:

; 2475 : 	    return(NULL);
; 2476 : 	}
; 2477 : 	p = uri->path;
; 2478 :     }
; 2479 :     /* Now change all occurences of '\' to '/' */
; 2480 :     while (*p != '\0') {

	mov	al, BYTE PTR [esi+1]

; 2483 : 	p++;

	inc	esi
	test	al, al
	jne	SHORT $LL5@xmlCanonic
$LN6@xmlCanonic:

; 2484 :     }
; 2485 : 
; 2486 :     if (uri->scheme == NULL) {

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN28@xmlCanonic

; 2487 : 	ret = xmlStrdup((const xmlChar *) uri->path);

	push	DWORD PTR [ebx+24]
	call	_xmlStrdup

; 2488 :     } else {

	jmp	SHORT $LN48@xmlCanonic
$LN20@xmlCanonic:

; 2471 :     } else {
; 2472 : 	uri->path = (char *) xmlStrdup(path);

	push	edi
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR [ebx+24], esi

; 2473 : 	if (uri->path == NULL) {

	test	esi, esi
	jne	SHORT $LN26@xmlCanonic
$LN46@xmlCanonic:

; 2474 : 	    xmlFreeURI(uri);

	push	ebx
	call	_xmlFreeURI
	add	esp, 4
$LN47@xmlCanonic:

; 2497 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN28@xmlCanonic:

; 2489 : 	ret = xmlSaveUri(uri);

	push	ebx
	call	_xmlSaveUri
$LN48@xmlCanonic:

; 2490 :     }
; 2491 : 
; 2492 :     xmlFreeURI(uri);

	add	esp, 4
	mov	esi, eax
	push	ebx
	call	_xmlFreeURI
	add	esp, 4

; 2493 : #else
; 2494 :     ret = xmlStrdup((const xmlChar *) path);
; 2495 : #endif
; 2496 :     return(ret);

	mov	eax, esi
	pop	edi

; 2497 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlCanonicPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlFreeURI
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_xmlFreeURI PROC					; COMDAT

; 1379 : xmlFreeURI(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _uri$[ebp]
	test	esi, esi
	je	$LN1@xmlFreeURI

; 1380 :     if (uri == NULL) return;
; 1381 : 
; 1382 :     if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeURI:

; 1383 :     if (uri->server != NULL) xmlFree(uri->server);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeURI:

; 1384 :     if (uri->user != NULL) xmlFree(uri->user);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeURI:

; 1385 :     if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlFreeURI:

; 1386 :     if (uri->fragment != NULL) xmlFree(uri->fragment);

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN7@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlFreeURI:

; 1387 :     if (uri->opaque != NULL) xmlFree(uri->opaque);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN8@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlFreeURI:

; 1388 :     if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeURI:

; 1389 :     if (uri->query != NULL) xmlFree(uri->query);

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN10@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlFreeURI:

; 1390 :     if (uri->query_raw != NULL) xmlFree(uri->query_raw);

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN11@xmlFreeURI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlFreeURI:

; 1391 :     xmlFree(uri);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeURI:
	pop	esi

; 1392 : }

	pop	ebp
	ret	0
_xmlFreeURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIEscape
_TEXT	SEGMENT
_port$1 = -12						; size = 10
_str$ = 8						; size = 4
_xmlURIEscape PROC					; COMDAT

; 1744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __0B912F28_uri@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN29@xmlURIEsca

; 1745 :     xmlChar *ret, *segment = NULL;
; 1746 :     xmlURIPtr uri;
; 1747 :     int ret2;
; 1748 : 
; 1749 : #define NULLCHK(p) if(!p) { \
; 1750 :          xmlURIErrMemory("escaping URI value\n"); \
; 1751 :          xmlFreeURI(uri); \
; 1752 :          return NULL; } \
; 1753 : 
; 1754 :     if (str == NULL)
; 1755 :         return (NULL);
; 1756 : 
; 1757 :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	esi, eax

; 1758 :     if (uri != NULL) {

	test	esi, esi
	je	SHORT $LN29@xmlURIEsca

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	edi
	push	esi

; 1759 : 	/*
; 1760 : 	 * Allow escaping errors in the unescaped form
; 1761 : 	 */
; 1762 :         uri->cleanup = 1;

	mov	DWORD PTR [esi+36], 1

; 963  :     return(xmlParse3986URIReference(uri, str));

	call	_xmlParse3986URIReference
	add	esp, 8

; 1763 :         ret2 = xmlParseURIReference(uri, (const char *)str);
; 1764 :         if (ret2) {

	test	eax, eax
	je	SHORT $LN5@xmlURIEsca

; 1765 :             xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4
$LN29@xmlURIEsca:

; 1858 : }

	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlURIEsca:

; 1766 :             return (NULL);
; 1767 :         }
; 1768 :     }
; 1769 : 
; 1770 :     if (!uri)
; 1771 :         return NULL;
; 1772 : 
; 1773 :     ret = NULL;
; 1774 : 
; 1775 :     if (uri->scheme) {

	mov	eax, DWORD PTR [esi]
	xor	edi, edi
	push	ebx
	test	eax, eax
	je	SHORT $LN6@xmlURIEsca

; 1776 :         segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");

	push	OFFSET ??_C@_03JCBKNEED@?$CL?9?4@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1777 :         NULLCHK(segment)

	test	ebx, ebx
	je	$LN30@xmlURIEsca

; 1778 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	edi
	call	_xmlStrcat

; 1779 :         ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 1780 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN6@xmlURIEsca:

; 1781 :     }
; 1782 : 
; 1783 :     if (uri->authority) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN8@xmlURIEsca

; 1784 :         segment =

	push	OFFSET ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1785 :             xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
; 1786 :         NULLCHK(segment)

	test	ebx, ebx
	je	$LN30@xmlURIEsca

; 1787 :         ret = xmlStrcat(ret, BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	push	edi
	call	_xmlStrcat

; 1788 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	eax
	call	_xmlStrcat

; 1789 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN8@xmlURIEsca:

; 1790 :     }
; 1791 : 
; 1792 :     if (uri->user) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN10@xmlURIEsca

; 1793 :         segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");

	push	OFFSET ??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1794 :         NULLCHK(segment)

	test	ebx, ebx
	je	$LN30@xmlURIEsca

; 1795 : 		ret = xmlStrcat(ret,BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	push	edi
	call	_xmlStrcat

; 1796 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	eax
	call	_xmlStrcat

; 1797 :         ret = xmlStrcat(ret, BAD_CAST "@");

	push	OFFSET ??_C@_01EOFPKCAF@?$EA@
	push	eax
	call	_xmlStrcat

; 1798 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH
$LN10@xmlURIEsca:

; 1799 :     }
; 1800 : 
; 1801 :     if (uri->server) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@xmlURIEsca

; 1802 :         segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");

	push	OFFSET ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1803 :         NULLCHK(segment)

	test	ebx, ebx
	je	$LN30@xmlURIEsca

; 1804 : 		if (uri->user == NULL)

	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN14@xmlURIEsca

; 1805 : 		ret = xmlStrcat(ret, BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	push	edi
	call	_xmlStrcat
	add	esp, 8
	mov	edi, eax
$LN14@xmlURIEsca:

; 1806 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	edi
	call	_xmlStrcat

; 1807 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN12@xmlURIEsca:

; 1808 :     }
; 1809 : 
; 1810 :     if (uri->port) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@xmlURIEsca

; 1811 :         xmlChar port[10];
; 1812 : 
; 1813 :         snprintf((char *) port, 10, "%d", uri->port);

	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	lea	eax, DWORD PTR _port$1[ebp]
	push	10					; 0000000aH
	push	eax
	call	_snprintf

; 1814 :         ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	edi
	call	_xmlStrcat

; 1815 :         ret = xmlStrcat(ret, port);

	lea	ecx, DWORD PTR _port$1[ebp]
	push	ecx
	push	eax
	call	_xmlStrcat
	add	esp, 32					; 00000020H
	mov	edi, eax
$LN15@xmlURIEsca:

; 1816 :     }
; 1817 : 
; 1818 :     if (uri->path) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN16@xmlURIEsca

; 1819 :         segment =

	push	OFFSET ??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1820 :             xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
; 1821 :         NULLCHK(segment)

	test	ebx, ebx
	je	$LN30@xmlURIEsca

; 1822 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	edi
	call	_xmlStrcat

; 1823 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN16@xmlURIEsca:

; 1824 :     }
; 1825 : 
; 1826 :     if (uri->query_raw) {

	cmp	DWORD PTR [esi+40], 0
	je	SHORT $LN18@xmlURIEsca

; 1827 :         ret = xmlStrcat(ret, BAD_CAST "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	push	edi
	call	_xmlStrcat

; 1828 :         ret = xmlStrcat(ret, BAD_CAST uri->query_raw);

	push	DWORD PTR [esi+40]
	push	eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H
	mov	edi, eax

; 1829 :     }

	jmp	SHORT $LN20@xmlURIEsca
$LN18@xmlURIEsca:

; 1830 :     else if (uri->query) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN20@xmlURIEsca

; 1831 :         segment =

	push	OFFSET ??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1832 :             xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
; 1833 :         NULLCHK(segment)

	test	ebx, ebx
	je	SHORT $LN30@xmlURIEsca

; 1834 :         ret = xmlStrcat(ret, BAD_CAST "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	push	edi
	call	_xmlStrcat

; 1835 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	eax
	call	_xmlStrcat

; 1836 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN20@xmlURIEsca:

; 1837 :     }
; 1838 : 
; 1839 :     if (uri->opaque) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN22@xmlURIEsca

; 1840 :         segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1841 :         NULLCHK(segment)

	test	ebx, ebx
	je	SHORT $LN30@xmlURIEsca

; 1842 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	edi
	call	_xmlStrcat

; 1843 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN22@xmlURIEsca:

; 1844 :     }
; 1845 : 
; 1846 :     if (uri->fragment) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN24@xmlURIEsca

; 1847 :         segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");

	push	OFFSET ??_C@_01IPJKGB@?$CD@
	push	eax
	call	_xmlURIEscapeStr
	mov	ebx, eax
	add	esp, 8

; 1848 :         NULLCHK(segment)

	test	ebx, ebx
	jne	SHORT $LN25@xmlURIEsca
$LN30@xmlURIEsca:
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	push	esi
	call	_xmlFreeURI
	add	esp, 8
	xor	eax, eax
	pop	ebx
	pop	edi

; 1858 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlURIEsca:

; 1849 :         ret = xmlStrcat(ret, BAD_CAST "#");

	push	OFFSET ??_C@_01IPJKGB@?$CD@
	push	edi
	call	_xmlStrcat

; 1850 :         ret = xmlStrcat(ret, segment);

	push	ebx
	push	eax
	call	_xmlStrcat

; 1851 :         xmlFree(segment);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN24@xmlURIEsca:

; 1852 :     }
; 1853 : 
; 1854 :     xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4

; 1855 : #undef NULLCHK
; 1856 : 
; 1857 :     return (ret);

	mov	eax, edi
	pop	ebx
	pop	edi

; 1858 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlURIEscape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlNormalizeURIPath
_TEXT	SEGMENT
_path$ = 8						; size = 4
_xmlNormalizeURIPath PROC				; COMDAT

; 1412 : xmlNormalizeURIPath(char *path) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _path$[ebp]
	test	edx, edx
	jne	SHORT $LN28@xmlNormali

; 1413 :     char *cur, *out;
; 1414 : 
; 1415 :     if (path == NULL)
; 1416 : 	return(-1);

	or	eax, -1

; 1587 : }

	pop	ebp
	ret	0
$LN28@xmlNormali:

; 1417 : 
; 1418 :     /* Skip all initial "/" chars.  We want to get to the beginning of the
; 1419 :      * first non-empty segment.
; 1420 :      */
; 1421 :     cur = path;
; 1422 :     while (cur[0] == '/')

	mov	cl, BYTE PTR [edx]
	mov	eax, edx
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN3@xmlNormali
$LL2@xmlNormali:
	mov	cl, BYTE PTR [eax+1]

; 1423 :       ++cur;

	inc	eax
	cmp	cl, 47					; 0000002fH
	je	SHORT $LL2@xmlNormali
$LN3@xmlNormali:

; 1424 :     if (cur[0] == '\0')

	test	cl, cl
	je	$LN43@xmlNormali

; 1425 :       return(0);
; 1426 : 
; 1427 :     /* Keep everything we've seen so far.  */
; 1428 :     out = cur;

	push	ebx
	mov	ebx, eax
$LL4@xmlNormali:

; 1434 : 	/*
; 1435 : 	 * c) All occurrences of "./", where "." is a complete path segment,
; 1436 : 	 *    are removed from the buffer string.
; 1437 : 	 */
; 1438 : 	if ((cur[0] == '.') && (cur[1] == '/')) {

	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN110@xmlNormali
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LN133@xmlNormali

; 1439 : 	    cur += 2;

	add	eax, 2

; 1440 : 	    /* '//' normalization should be done at this point too */
; 1441 : 	    while (cur[0] == '/')

	cmp	BYTE PTR [eax], cl
	jne	SHORT $LN70@xmlNormali
	npad	6
$LL6@xmlNormali:

; 1442 : 		cur++;

	inc	eax
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $LL6@xmlNormali

; 1443 : 	    continue;

	jmp	SHORT $LN70@xmlNormali
$LN133@xmlNormali:

; 1444 : 	}
; 1445 : 
; 1446 : 	/*
; 1447 : 	 * d) If the buffer string ends with "." as a complete path segment,
; 1448 : 	 *    that "." is removed.
; 1449 : 	 */
; 1450 : 	if ((cur[0] == '.') && (cur[1] == '\0'))

	test	cl, cl
	je	SHORT $done_cd$193
	mov	cl, 46					; 0000002eH
$LN110@xmlNormali:

; 1451 : 	    break;
; 1452 : 
; 1453 : 	/* Otherwise keep the segment.  */
; 1454 : 	while (cur[0] != '/') {

	cmp	cl, 47					; 0000002fH
	je	SHORT $LL10@xmlNormali

; 1444 : 	}
; 1445 : 
; 1446 : 	/*
; 1447 : 	 * d) If the buffer string ends with "." as a complete path segment,
; 1448 : 	 *    that "." is removed.
; 1449 : 	 */
; 1450 : 	if ((cur[0] == '.') && (cur[1] == '\0'))

	mov	cl, BYTE PTR [eax]
$LL8@xmlNormali:

; 1455 :             if (cur[0] == '\0')

	test	cl, cl
	je	SHORT $done_cd$193

; 1456 :               goto done_cd;
; 1457 : 	    (out++)[0] = (cur++)[0];

	inc	eax
	mov	BYTE PTR [ebx], cl
	inc	ebx
	mov	cl, BYTE PTR [eax]
	cmp	cl, 47					; 0000002fH
	jne	SHORT $LL8@xmlNormali
$LL10@xmlNormali:

; 1458 : 	}
; 1459 : 	/* nomalize // */
; 1460 : 	while ((cur[0] == '/') && (cur[1] == '/'))

	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	lea	ecx, DWORD PTR [eax+1]
	jne	SHORT $LN11@xmlNormali

; 1461 : 	    cur++;

	mov	eax, ecx
	jmp	SHORT $LL10@xmlNormali
$LN11@xmlNormali:

; 1462 : 
; 1463 :         (out++)[0] = (cur++)[0];

	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [ebx], cl
	inc	ebx
	inc	eax
$LN70@xmlNormali:

; 1429 : 
; 1430 :     /*
; 1431 :      * Analyze each segment in sequence for cases (c) and (d).
; 1432 :      */
; 1433 :     while (cur[0] != '\0') {

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	jne	SHORT $LL4@xmlNormali
$done_cd$193:

; 1464 :     }
; 1465 :  done_cd:
; 1466 :     out[0] = '\0';

	mov	BYTE PTR [ebx], 0

; 1467 : 
; 1468 :     /* Reset to the beginning of the first segment for the next sequence.  */
; 1469 :     cur = path;

	mov	ecx, edx

; 1470 :     while (cur[0] == '/')

	mov	al, BYTE PTR [edx]
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN13@xmlNormali
$LL12@xmlNormali:
	mov	al, BYTE PTR [ecx+1]

; 1471 :       ++cur;

	inc	ecx
	cmp	al, 47					; 0000002fH
	je	SHORT $LL12@xmlNormali
$LN13@xmlNormali:

; 1472 :     if (cur[0] == '\0')

	test	al, al
	je	$LN189@xmlNormali
	push	esi
	push	edi
	npad	6
$LL14@xmlNormali:

; 1473 : 	return(0);
; 1474 : 
; 1475 :     /*
; 1476 :      * Analyze each segment in sequence for cases (e) and (f).
; 1477 :      *
; 1478 :      * e) All occurrences of "<segment>/../", where <segment> is a
; 1479 :      *    complete path segment not equal to "..", are removed from the
; 1480 :      *    buffer string.  Removal of these path segments is performed
; 1481 :      *    iteratively, removing the leftmost matching pattern on each
; 1482 :      *    iteration, until no matching pattern remains.
; 1483 :      *
; 1484 :      * f) If the buffer string ends with "<segment>/..", where <segment>
; 1485 :      *    is a complete path segment not equal to "..", that
; 1486 :      *    "<segment>/.." is removed.
; 1487 :      *
; 1488 :      * To satisfy the "iterative" clause in (e), we need to collapse the
; 1489 :      * string every time we find something that needs to be removed.  Thus,
; 1490 :      * we don't need to keep two pointers into the string: we only need a
; 1491 :      * "current position" pointer.
; 1492 :      */
; 1493 :     while (1) {
; 1494 :         char *segp, *tmp;
; 1495 : 
; 1496 :         /* At the beginning of each iteration of this loop, "cur" points to
; 1497 :          * the first character of the segment we want to examine.
; 1498 :          */
; 1499 : 
; 1500 :         /* Find the end of the current segment.  */
; 1501 :         segp = cur;
; 1502 :         while ((segp[0] != '/') && (segp[0] != '\0'))

	mov	ah, BYTE PTR [ecx]
	mov	esi, ecx
	mov	al, ah
	cmp	ah, 47					; 0000002fH
	je	SHORT $LN17@xmlNormali
	npad	5
$LL16@xmlNormali:
	test	al, al
	je	SHORT $LN15@xmlNormali
	mov	al, BYTE PTR [esi+1]

; 1503 :           ++segp;

	inc	esi
	cmp	al, 47					; 0000002fH
	jne	SHORT $LL16@xmlNormali
$LN17@xmlNormali:

; 1504 : 
; 1505 :         /* If this is the last segment, we're done (we need at least two
; 1506 :          * segments to meet the criteria for the (e) and (f) cases).
; 1507 :          */
; 1508 :         if (segp[0] == '\0')

	mov	edi, esi
	test	al, al
	je	SHORT $LN15@xmlNormali

; 1509 :           break;
; 1510 : 
; 1511 :         /* If the first segment is "..", or if the next segment _isn't_ "..",
; 1512 :          * keep this segment and try the next one.
; 1513 :          */
; 1514 :         ++segp;
; 1515 :         if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
; 1516 :             || ((segp[0] != '.') || (segp[1] != '.')

	cmp	ah, 46					; 0000002eH
	jne	SHORT $LN37@xmlNormali
	cmp	BYTE PTR [ecx+1], ah
	jne	SHORT $LN37@xmlNormali
	lea	eax, DWORD PTR [ecx+2]
	cmp	edi, eax
	je	SHORT $LN38@xmlNormali
$LN37@xmlNormali:
	cmp	BYTE PTR [esi+1], 46			; 0000002eH
	jne	SHORT $LN38@xmlNormali
	cmp	BYTE PTR [edi+2], 46			; 0000002eH
	jne	SHORT $LN38@xmlNormali
	mov	al, BYTE PTR [edi+3]
	cmp	al, 47					; 0000002fH
	je	SHORT $LN35@xmlNormali
	test	al, al
	je	SHORT $LN65@xmlNormali
$LN38@xmlNormali:

; 1517 :                 || ((segp[2] != '/') && (segp[2] != '\0')))) {
; 1518 :           cur = segp;

	lea	ecx, DWORD PTR [esi+1]

; 1519 :           continue;

	jmp	SHORT $LL14@xmlNormali
$LN35@xmlNormali:

; 1532 :           break;
; 1533 :         }
; 1534 :         /* Valgrind complained, strcpy(cur, segp + 3); */
; 1535 :         /* string will overlap, do not use strcpy */
; 1536 :         tmp = cur;

	mov	esi, ecx

; 1537 :         segp += 3;

	add	edi, 4
$LL18@xmlNormali:

; 1538 :         while ((*tmp++ = *segp++) != 0)

	mov	al, BYTE PTR [edi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [esi-1], al
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL18@xmlNormali

; 1539 :           ;
; 1540 : 
; 1541 :         /* If there are no previous segments, then keep going from here.  */
; 1542 :         segp = cur;

	mov	eax, ecx
$LL20@xmlNormali:

; 1543 :         while ((segp > path) && ((--segp)[0] == '/'))

	cmp	eax, edx
	jbe	SHORT $LN191@xmlNormali
	dec	eax
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $LL20@xmlNormali

; 1544 :           ;
; 1545 :         if (segp == path)

	cmp	eax, edx
$LN191@xmlNormali:
	je	SHORT $LL14@xmlNormali

; 1546 :           continue;
; 1547 : 
; 1548 :         /* "segp" is pointing to the end of a previous segment; find it's
; 1549 :          * start.  We need to back up to the previous segment and start
; 1550 :          * over with that to handle things like "foo/bar/../..".  If we
; 1551 :          * don't do this, then on the first pass we'll remove the "bar/..",
; 1552 :          * but be pointing at the second ".." so we won't realize we can also
; 1553 :          * remove the "foo/..".
; 1554 :          */
; 1555 :         cur = segp;

	mov	ecx, eax

; 1556 :         while ((cur > path) && (cur[-1] != '/'))

	jbe	SHORT $LL14@xmlNormali
$LL22@xmlNormali:
	cmp	BYTE PTR [ecx-1], 47			; 0000002fH
	lea	eax, DWORD PTR [ecx-1]
	je	SHORT $LL14@xmlNormali

; 1557 :           --cur;

	mov	ecx, eax
	cmp	ecx, edx
	ja	SHORT $LL22@xmlNormali

; 1558 :     }

	jmp	$LL14@xmlNormali
$LN65@xmlNormali:

; 1520 :         }
; 1521 : 
; 1522 :         /* If we get here, remove this segment and the next one and back up
; 1523 :          * to the previous segment (if there is one), to implement the
; 1524 :          * "iteratively" clause.  It's pretty much impossible to back up
; 1525 :          * while maintaining two pointers into the buffer, so just compact
; 1526 :          * the whole buffer now.
; 1527 :          */
; 1528 : 
; 1529 :         /* If this is the end of the buffer, we're done.  */
; 1530 :         if (segp[2] == '\0') {
; 1531 :           cur[0] = '\0';

	mov	BYTE PTR [ecx], 0
$LN15@xmlNormali:

; 1559 :     out[0] = '\0';

	mov	BYTE PTR [ebx], 0

; 1560 : 
; 1561 :     /*
; 1562 :      * g) If the resulting buffer string still begins with one or more
; 1563 :      *    complete path segments of "..", then the reference is
; 1564 :      *    considered to be in error. Implementations may handle this
; 1565 :      *    error by retaining these components in the resolved path (i.e.,
; 1566 :      *    treating them as part of the final URI), by removing them from
; 1567 :      *    the resolved path (i.e., discarding relative levels above the
; 1568 :      *    root), or by avoiding traversal of the reference.
; 1569 :      *
; 1570 :      * We discard them from the final path.
; 1571 :      */
; 1572 :     if (path[0] == '/') {

	cmp	BYTE PTR [edx], 47			; 0000002fH
	jne	SHORT $LN190@xmlNormali

; 1573 :       cur = path;

	mov	eax, edx
$LL24@xmlNormali:

; 1574 :       while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
; 1575 :              && ((cur[3] == '/') || (cur[3] == '\0')))

	cmp	BYTE PTR [eax+1], 46			; 0000002eH
	jne	SHORT $LN25@xmlNormali
	cmp	BYTE PTR [eax+2], 46			; 0000002eH
	jne	SHORT $LN25@xmlNormali
	mov	cl, BYTE PTR [eax+3]
	cmp	cl, 47					; 0000002fH
	je	SHORT $LN42@xmlNormali
	test	cl, cl
	jne	SHORT $LN25@xmlNormali
$LN42@xmlNormali:

; 1576 : 	cur += 3;

	add	eax, 3
	cmp	cl, 47					; 0000002fH
	je	SHORT $LL24@xmlNormali
$LN25@xmlNormali:

; 1577 : 
; 1578 :       if (cur != path) {

	cmp	eax, edx
	je	SHORT $LN190@xmlNormali

; 1579 : 	out = path;
; 1580 : 	while (cur[0] != '\0')

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN27@xmlNormali

; 1444 : 	}
; 1445 : 
; 1446 : 	/*
; 1447 : 	 * d) If the buffer string ends with "." as a complete path segment,
; 1448 : 	 *    that "." is removed.
; 1449 : 	 */
; 1450 : 	if ((cur[0] == '.') && (cur[1] == '\0'))

	sub	eax, edx
$LL26@xmlNormali:

; 1581 :           (out++)[0] = (cur++)[0];

	mov	BYTE PTR [edx], cl
	inc	edx
	mov	cl, BYTE PTR [eax+edx]
	test	cl, cl
	jne	SHORT $LL26@xmlNormali
$LN27@xmlNormali:

; 1582 : 	out[0] = 0;

	mov	BYTE PTR [edx], 0
$LN190@xmlNormali:
	pop	edi
	pop	esi
$LN189@xmlNormali:
	pop	ebx
$LN43@xmlNormali:

; 1583 :       }
; 1584 :     }
; 1585 : 
; 1586 :     return(0);

	xor	eax, eax

; 1587 : }

	pop	ebp
	ret	0
_xmlNormalizeURIPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIUnescapeString
_TEXT	SEGMENT
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_target$ = 16						; size = 4
_xmlURIUnescapeString PROC				; COMDAT

; 1612 : xmlURIUnescapeString(const char *str, int len, char *target) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN44@xmlURIUnes

; 1613 :     char *ret, *out;
; 1614 :     const char *in;
; 1615 : 
; 1616 :     if (str == NULL)
; 1617 : 	return(NULL);
; 1618 :     if (len <= 0) len = strlen(str);

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	jg	SHORT $LN46@xmlURIUnes
	mov	esi, edi
	lea	ecx, DWORD PTR [esi+1]
$LL45@xmlURIUnes:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL45@xmlURIUnes
	sub	esi, ecx

; 1619 :     if (len < 0) return(NULL);

	test	esi, esi
$LN46@xmlURIUnes:
	js	SHORT $LN44@xmlURIUnes

; 1620 : 
; 1621 :     if (target == NULL) {

	mov	eax, DWORD PTR _target$[ebp]
	test	eax, eax
	jne	SHORT $LN7@xmlURIUnes

; 1622 : 	ret = (char *) xmlMallocAtomic(len + 1);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _target$[ebp], eax

; 1623 : 	if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlURIUnes

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@
	push	eax
	push	eax
	push	3
	push	2
	push	30					; 0000001eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN44@xmlURIUnes:
	pop	edi

; 1656 :     return(ret);
; 1657 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlURIUnes:

; 1624 :             xmlURIErrMemory("unescaping URI value\n");
; 1625 : 	    return(NULL);
; 1626 : 	}
; 1627 :     } else
; 1628 : 	ret = target;
; 1629 :     in = str;
; 1630 :     out = ret;

	mov	edx, eax

; 1631 :     while(len > 0) {

	test	esi, esi
	jle	$LN3@xmlURIUnes
	push	ebx
$LL2@xmlURIUnes:

; 1632 : 	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {

	cmp	esi, 2
	jle	$LN10@xmlURIUnes
	cmp	BYTE PTR [edi], 37			; 00000025H
	jne	$LN10@xmlURIUnes
	mov	al, BYTE PTR [edi+1]

; 1591 :         ((c >= 'a') && (c <= 'f')) ||

	cmp	al, 48					; 00000030H
	jl	SHORT $LN30@xmlURIUnes
	cmp	al, 57					; 00000039H
	jle	SHORT $LN42@xmlURIUnes
$LN30@xmlURIUnes:
	cmp	al, 97					; 00000061H
	jl	SHORT $LN31@xmlURIUnes
	cmp	al, 102					; 00000066H
	jle	SHORT $LN42@xmlURIUnes
$LN31@xmlURIUnes:
	lea	ecx, DWORD PTR [eax-65]
	cmp	cl, 5
	ja	$LN10@xmlURIUnes
$LN42@xmlURIUnes:

; 1632 : 	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {

	mov	cl, BYTE PTR [edi+2]
	lea	ebx, DWORD PTR [edi+2]

; 1591 :         ((c >= 'a') && (c <= 'f')) ||

	cmp	cl, 48					; 00000030H
	jl	SHORT $LN36@xmlURIUnes
	cmp	cl, 57					; 00000039H
	jle	SHORT $LN43@xmlURIUnes
$LN36@xmlURIUnes:
	cmp	cl, 97					; 00000061H
	jl	SHORT $LN37@xmlURIUnes
	cmp	cl, 102					; 00000066H
	jle	SHORT $LN43@xmlURIUnes
$LN37@xmlURIUnes:
	sub	cl, 65					; 00000041H
	cmp	cl, 5
	ja	SHORT $LN10@xmlURIUnes
$LN43@xmlURIUnes:

; 1633 : 	    in++;
; 1634 : 	    if ((*in >= '0') && (*in <= '9'))

	lea	ecx, DWORD PTR [eax-48]
	cmp	cl, 9
	ja	SHORT $LN12@xmlURIUnes

; 1635 : 	        *out = (*in - '0');

	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN16@xmlURIUnes
$LN12@xmlURIUnes:

; 1636 : 	    else if ((*in >= 'a') && (*in <= 'f'))

	lea	ecx, DWORD PTR [eax-97]
	cmp	cl, 5
	ja	SHORT $LN14@xmlURIUnes

; 1637 : 	        *out = (*in - 'a') + 10;

	sub	al, 87					; 00000057H
	jmp	SHORT $LN47@xmlURIUnes
$LN14@xmlURIUnes:

; 1638 : 	    else if ((*in >= 'A') && (*in <= 'F'))

	lea	ecx, DWORD PTR [eax-65]
	cmp	cl, 5
	ja	SHORT $LN16@xmlURIUnes

; 1639 : 	        *out = (*in - 'A') + 10;

	sub	al, 55					; 00000037H
$LN47@xmlURIUnes:

; 1640 : 	    in++;
; 1641 : 	    if ((*in >= '0') && (*in <= '9'))

	mov	BYTE PTR [edx], al
$LN16@xmlURIUnes:
	mov	cl, BYTE PTR [ebx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	al, 9
	ja	SHORT $LN17@xmlURIUnes

; 1642 : 	        *out = *out * 16 + (*in - '0');

	mov	al, BYTE PTR [edx]
	sub	al, 3
	shl	al, 4

; 1647 : 	    in++;
; 1648 : 	    len -= 3;
; 1649 : 	    out++;

	add	al, cl
	mov	BYTE PTR [edx], al
	mov	eax, -3					; fffffffdH

; 1650 : 	} else {

	jmp	SHORT $LN11@xmlURIUnes
$LN17@xmlURIUnes:

; 1643 : 	    else if ((*in >= 'a') && (*in <= 'f'))

	lea	eax, DWORD PTR [ecx-97]
	cmp	al, 5
	ja	SHORT $LN19@xmlURIUnes

; 1644 : 	        *out = *out * 16 + (*in - 'a') + 10;

	mov	al, BYTE PTR [edx]
	shl	al, 4
	sub	al, 87					; 00000057H

; 1647 : 	    in++;
; 1648 : 	    len -= 3;
; 1649 : 	    out++;

	add	al, cl
	mov	BYTE PTR [edx], al
	mov	eax, -3					; fffffffdH

; 1650 : 	} else {

	jmp	SHORT $LN11@xmlURIUnes
$LN19@xmlURIUnes:

; 1645 : 	    else if ((*in >= 'A') && (*in <= 'F'))

	lea	eax, DWORD PTR [ecx-65]
	cmp	al, 5
	ja	SHORT $LN21@xmlURIUnes

; 1646 : 	        *out = *out * 16 + (*in - 'A') + 10;

	mov	al, BYTE PTR [edx]
	shl	al, 4
	sub	al, 55					; 00000037H

; 1647 : 	    in++;
; 1648 : 	    len -= 3;
; 1649 : 	    out++;

	add	al, cl
	mov	BYTE PTR [edx], al
$LN21@xmlURIUnes:
	mov	eax, -3					; fffffffdH

; 1650 : 	} else {

	jmp	SHORT $LN11@xmlURIUnes
$LN10@xmlURIUnes:

; 1651 : 	    *out++ = *in++;

	mov	al, BYTE PTR [edi]

; 1652 : 	    len--;

	mov	ebx, edi
	mov	BYTE PTR [edx], al
	mov	eax, -1
$LN11@xmlURIUnes:

; 1631 :     while(len > 0) {

	add	esi, eax
	lea	edi, DWORD PTR [ebx+1]
	inc	edx
	test	esi, esi
	jg	$LL2@xmlURIUnes
	mov	eax, DWORD PTR _target$[ebp]
	pop	ebx
$LN3@xmlURIUnes:
	pop	edi

; 1653 : 	}
; 1654 :     }
; 1655 :     *out = 0;

	mov	BYTE PTR [edx], 0

; 1656 :     return(ret);
; 1657 : }

	pop	esi
	pop	ebp
	ret	0
_xmlURIUnescapeString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIEscapeStr
_TEXT	SEGMENT
_ch$ = -12						; size = 1
_len$1$ = -8						; size = 4
_len$ = -4						; size = 4
_ret$1$ = 8						; size = 4
_str$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlURIEscapeStr PROC					; COMDAT

; 1670 : xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __0B912F28_uri@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN28@xmlURIEsca

; 1671 :     xmlChar *ret, ch;
; 1672 :     xmlChar *temp;
; 1673 :     const xmlChar *in;
; 1674 :     int len, out;
; 1675 : 
; 1676 :     if (str == NULL)
; 1677 : 	return(NULL);
; 1678 :     if (str[0] == 0)

	cmp	BYTE PTR [esi], 0
	push	esi
	jne	SHORT $LN5@xmlURIEsca

; 1679 : 	return(xmlStrdup(str));

	call	_xmlStrdup
	add	esp, 4
	pop	esi

; 1725 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlURIEsca:

; 1680 :     len = xmlStrlen(str);

	call	_xmlStrlen
	mov	ebx, eax
	add	esp, 4

; 1681 :     if (!(len > 0)) return(NULL);

	test	ebx, ebx
	jle	SHORT $LN28@xmlURIEsca

; 1682 : 
; 1683 :     len += 20;

	add	ebx, 20					; 00000014H

; 1684 :     ret = (xmlChar *) xmlMallocAtomic(len);

	push	ebx
	mov	DWORD PTR _len$1$[ebp], ebx
	mov	DWORD PTR _len$[ebp], ebx
	call	DWORD PTR _xmlMallocAtomic
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], ecx

; 1685 :     if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlURIEsca

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	push	eax
	push	eax
	push	3
	push	2
	push	30					; 0000001eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN28@xmlURIEsca:
	pop	esi

; 1725 : }

	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlURIEsca:
	push	edi

; 1686 :         xmlURIErrMemory("escaping URI value\n");
; 1687 : 	return(NULL);
; 1688 :     }
; 1689 :     in = (const xmlChar *) str;
; 1690 :     out = 0;

	xor	edi, edi

; 1691 :     while(*in != 0) {

	cmp	BYTE PTR [esi], 0
	je	$LN29@xmlURIEsca
$LN33@xmlURIEsca:

; 1692 : 	if (len - out <= 3) {

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, ebx
	sub	eax, edi
	cmp	eax, 3
	jg	SHORT $LN8@xmlURIEsca

; 1693 :             temp = xmlSaveUriRealloc(ret, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1694 : 	    if (temp == NULL) {

	test	eax, eax
	je	$LN25@xmlURIEsca

; 1698 : 	    }
; 1699 : 	    ret = temp;

	mov	edx, DWORD PTR _list$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _ret$1$[ebp], ecx
	mov	DWORD PTR _len$1$[ebp], eax
$LN8@xmlURIEsca:

; 1700 : 	}
; 1701 : 
; 1702 : 	ch = *in;

	mov	bl, BYTE PTR [esi]
	mov	BYTE PTR _ch$[ebp], bl

; 1703 : 
; 1704 : 	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {

	cmp	bl, 64					; 00000040H
	je	$LN10@xmlURIEsca
	cmp	bl, 97					; 00000061H
	jb	SHORT $LN12@xmlURIEsca
	cmp	bl, 122					; 0000007aH
	jbe	$LN10@xmlURIEsca
$LN12@xmlURIEsca:
	cmp	bl, 65					; 00000041H
	jb	SHORT $LN13@xmlURIEsca
	cmp	bl, 90					; 0000005aH
	jbe	$LN10@xmlURIEsca
$LN13@xmlURIEsca:
	cmp	bl, 48					; 00000030H
	jb	SHORT $LN14@xmlURIEsca
	cmp	bl, 57					; 00000039H
	jbe	SHORT $LN10@xmlURIEsca
$LN14@xmlURIEsca:
	cmp	bl, 45					; 0000002dH
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 95					; 0000005fH
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 46					; 0000002eH
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 33					; 00000021H
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 126					; 0000007eH
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 42					; 0000002aH
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 39					; 00000027H
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 40					; 00000028H
	je	SHORT $LN10@xmlURIEsca
	cmp	bl, 41					; 00000029H
	je	SHORT $LN10@xmlURIEsca
	push	DWORD PTR _ch$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlURIEsca

; 1705 : 	    unsigned char val;
; 1706 : 	    ret[out++] = '%';

	mov	eax, DWORD PTR _ret$1$[ebp]
	lea	edx, DWORD PTR [edi+1]

; 1707 : 	    val = ch >> 4;

	mov	cl, bl
	shr	cl, 4
	mov	BYTE PTR [edi+eax], 37			; 00000025H

; 1708 : 	    if (val <= 9)
; 1709 : 		ret[out++] = '0' + val;
; 1710 : 	    else
; 1711 : 		ret[out++] = 'A' + val - 0xA;
; 1712 : 	    val = ch & 0xF;

	mov	al, 9
	cmp	al, cl
	lea	edi, DWORD PTR [edx+1]
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	and	bl, 15					; 0000000fH
	add	al, cl
	mov	ecx, DWORD PTR _ret$1$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1713 : 	    if (val <= 9)
; 1714 : 		ret[out++] = '0' + val;
; 1715 : 	    else
; 1716 : 		ret[out++] = 'A' + val - 0xA;
; 1717 : 	    in++;

	mov	al, 9
	cmp	al, bl
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, bl

; 1718 : 	} else {

	jmp	SHORT $LN32@xmlURIEsca
$LN30@xmlURIEsca:

; 1703 : 
; 1704 : 	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
$LN10@xmlURIEsca:

; 1719 : 	    ret[out++] = *in++;

	mov	al, BYTE PTR [esi]
$LN32@xmlURIEsca:

; 1691 :     while(*in != 0) {

	inc	esi
	mov	BYTE PTR [edi+ecx], al
	inc	edi
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN29@xmlURIEsca
	mov	ebx, DWORD PTR _len$1$[ebp]
	jmp	$LN33@xmlURIEsca
$LN25@xmlURIEsca:

; 1695 :                 xmlURIErrMemory("escaping URI value\n");

	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory

; 1696 : 		xmlFree(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 8

; 1697 : 		return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1725 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlURIEsca:

; 1720 : 	}
; 1721 : 
; 1722 :     }
; 1723 :     ret[out] = 0;

	mov	BYTE PTR [edi+ecx], 0

; 1724 :     return(ret);

	mov	eax, ecx
	pop	edi
	pop	esi

; 1725 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlURIEscapeStr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlPrintURI
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_uri$ = 12						; size = 4
_xmlPrintURI PROC					; COMDAT

; 1332 : xmlPrintURI(FILE *stream, xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _uri$[ebp]
	call	_xmlSaveUri
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN2@xmlPrintUR

; 1333 :     xmlChar *out;
; 1334 : 
; 1335 :     out = xmlSaveUri(uri);
; 1336 :     if (out != NULL) {
; 1337 : 	fprintf(stream, "%s", (char *) out);

	push	esi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR _stream$[ebp]
	call	_fprintf

; 1338 : 	xmlFree(out);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN2@xmlPrintUR:
	pop	esi

; 1339 :     }
; 1340 : }

	pop	ebp
	ret	0
_xmlPrintURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlSaveUri
_TEXT	SEGMENT
tv2565 = -12						; size = 4
tv2559 = -12						; size = 4
_p$7$ = -12						; size = 4
tv2531 = -8						; size = 4
_p$8$ = -8						; size = 4
_p$6$ = -8						; size = 4
_p$5$ = -8						; size = 4
_p$4$ = -8						; size = 4
_p$3$ = -8						; size = 4
_p$2$ = -8						; size = 4
_p$1$ = -8						; size = 4
_max$ = -4						; size = 4
_p$9$ = 8						; size = 4
_uri$ = 8						; size = 4
_xmlSaveUri PROC					; COMDAT

; 1058 : xmlSaveUri(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN20@xmlSaveUri

; 1059 :     xmlChar *ret = NULL;
; 1060 :     xmlChar *temp;
; 1061 :     const char *p;
; 1062 :     int len;
; 1063 :     int max;
; 1064 : 
; 1065 :     if (uri == NULL) return(NULL);

	xor	eax, eax

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSaveUri:
	push	ebx
	push	edi

; 1066 : 
; 1067 : 
; 1068 :     max = 80;

	mov	ebx, 80					; 00000050H

; 1069 :     ret = (xmlChar *) xmlMallocAtomic((max + 1) * sizeof(xmlChar));

	push	81					; 00000051H
	mov	DWORD PTR _max$[ebp], ebx
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 1070 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN21@xmlSaveUri

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	push	eax
	push	eax
	push	3
	push	2
	push	30					; 0000001eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1071 :         xmlURIErrMemory("saving URI\n");
; 1072 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	ebx

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSaveUri:

; 1073 :     }
; 1074 :     len = 0;
; 1075 : 
; 1076 :     if (uri->scheme != NULL) {

	mov	edx, DWORD PTR _uri$[ebp]
	push	esi
	xor	esi, esi
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _p$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN22@xmlSaveUri

; 1077 : 	p = uri->scheme;
; 1078 : 	while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN25@xmlSaveUri
	npad	5
$LL2@xmlSaveUri:

; 1079 : 	    if (len >= max) {

	cmp	esi, ebx
	jl	SHORT $LN23@xmlSaveUri

; 1080 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1081 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1082 : 		ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$1$[ebp]
$LN23@xmlSaveUri:

; 1083 : 	    }
; 1084 : 	    ret[len++] = *p++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$1$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL2@xmlSaveUri

; 1085 : 	}
; 1086 : 	if (len >= max) {

	cmp	esi, ebx
	jl	SHORT $LN170@xmlSaveUri

; 1087 :             temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1088 :             if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1089 :             ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
$LN170@xmlSaveUri:

; 1090 : 	}
; 1091 : 	ret[len++] = ':';

	mov	edx, DWORD PTR _uri$[ebp]
$LN25@xmlSaveUri:
	mov	BYTE PTR [esi+edi], 58			; 0000003aH
	inc	esi
$LN22@xmlSaveUri:

; 1092 :     }
; 1093 :     if (uri->opaque != NULL) {

	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _p$2$[ebp], ecx
	test	ecx, ecx
	je	$LN27@xmlSaveUri

; 1094 : 	p = uri->opaque;
; 1095 : 	while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN17@xmlSaveUri
	npad	3
$LL4@xmlSaveUri:

; 1096 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN29@xmlSaveUri

; 1097 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1098 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1099 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$2$[ebp]
$LN29@xmlSaveUri:

; 1100 : 	    }
; 1101 : 	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))

	mov	al, BYTE PTR [ecx]
	cmp	al, 59					; 0000003bH
	je	$LN38@xmlSaveUri
	cmp	al, 47					; 0000002fH
	je	$LN38@xmlSaveUri
	cmp	al, 63					; 0000003fH
	je	$LN38@xmlSaveUri
	cmp	al, 58					; 0000003aH
	je	$LN38@xmlSaveUri
	cmp	al, 64					; 00000040H
	je	$LN38@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	$LN38@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	$LN38@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	$LN38@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	$LN38@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 91					; 0000005bH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 93					; 0000005dH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 97					; 00000061H
	jl	SHORT $LN35@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN38@xmlSaveUri
$LN35@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN36@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	SHORT $LN38@xmlSaveUri
$LN36@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN37@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	SHORT $LN38@xmlSaveUri
$LN37@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN38@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN38@xmlSaveUri

; 1102 : 		ret[len++] = *p++;
; 1103 : 	    else {
; 1104 : 		int val = *(unsigned char *)p++;

	movzx	edx, al

; 1105 : 		int hi = val / 0x10, lo = val % 0x10;
; 1106 : 		ret[len++] = '%';
; 1107 : 		ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1108 : 		ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$2$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN38@xmlSaveUri:

; 1094 : 	p = uri->opaque;
; 1095 : 	while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$2$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL4@xmlSaveUri

; 1297 :                 if (temp == NULL) goto mem_error;

	jmp	$LN174@xmlSaveUri
$LN27@xmlSaveUri:

; 1109 : 	    }
; 1110 : 	}
; 1111 :     } else {
; 1112 : 	if ((uri->server != NULL) || (uri->port == -1)) {

	cmp	DWORD PTR [edx+12], 0
	jne	$LN167@xmlSaveUri
	cmp	DWORD PTR [edx+20], -1
	je	$LN167@xmlSaveUri

; 1166 : 		}
; 1167 : 	    }
; 1168 : 	} else if (uri->authority != NULL) {

	cmp	DWORD PTR [edx+8], 0
	je	$LN61@xmlSaveUri

; 1169 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN63@xmlSaveUri

; 1170 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1171 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1172 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	edx, DWORD PTR _uri$[ebp]
$LN63@xmlSaveUri:

; 1173 : 	    }
; 1174 : 	    ret[len++] = '/';

	mov	WORD PTR [esi+edi], 12079		; 00002f2fH

; 1175 : 	    ret[len++] = '/';

	add	esi, 2

; 1176 : 	    p = uri->authority;

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _p$3$[ebp], ecx

; 1177 : 	    while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN58@xmlSaveUri
	npad	2
$LL10@xmlSaveUri:

; 1178 : 		if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN65@xmlSaveUri

; 1179 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1180 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1181 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$3$[ebp]
$LN65@xmlSaveUri:

; 1182 : 		}
; 1183 : 		if ((IS_UNRESERVED(*(p))) ||
; 1184 :                     ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
; 1185 :                     ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
; 1186 :                     ((*(p) == '=')) || ((*(p) == '+')))

	mov	al, BYTE PTR [ecx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN70@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	$LN69@xmlSaveUri
$LN70@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN71@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	$LN69@xmlSaveUri
$LN71@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN72@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	SHORT $LN69@xmlSaveUri
$LN72@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 59					; 0000003bH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 58					; 0000003aH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 64					; 00000040H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN69@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	SHORT $LN69@xmlSaveUri

; 1187 : 		    ret[len++] = *p++;
; 1188 : 		else {
; 1189 : 		    int val = *(unsigned char *)p++;

	movzx	edx, al

; 1190 : 		    int hi = val / 0x10, lo = val % 0x10;
; 1191 : 		    ret[len++] = '%';
; 1192 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1193 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$3$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN69@xmlSaveUri:

; 1177 : 	    while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$3$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL10@xmlSaveUri

; 1297 :                 if (temp == NULL) goto mem_error;

	jmp	$LN175@xmlSaveUri
$LN61@xmlSaveUri:

; 1194 : 		}
; 1195 : 	    }
; 1196 : 	} else if (uri->scheme != NULL) {

	cmp	DWORD PTR [edx], 0
	je	$LN58@xmlSaveUri

; 1197 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	$LN58@xmlSaveUri

; 1198 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1199 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1200 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	jmp	$LN175@xmlSaveUri
$LN167@xmlSaveUri:

; 1113 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN42@xmlSaveUri

; 1114 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1115 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1116 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	edx, DWORD PTR _uri$[ebp]
$LN42@xmlSaveUri:

; 1117 : 	    }
; 1118 : 	    ret[len++] = '/';

	mov	WORD PTR [esi+edi], 12079		; 00002f2fH

; 1119 : 	    ret[len++] = '/';

	add	esi, 2

; 1120 : 	    if (uri->user != NULL) {

	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR _p$4$[ebp], ecx
	test	ecx, ecx
	je	$LN44@xmlSaveUri

; 1121 : 		p = uri->user;
; 1122 : 		while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN7@xmlSaveUri
	npad	1
$LL6@xmlSaveUri:

; 1123 : 		    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN45@xmlSaveUri

; 1124 :                         temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1125 :                         if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1126 :                         ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$4$[ebp]
$LN45@xmlSaveUri:

; 1127 : 		    }
; 1128 : 		    if ((IS_UNRESERVED(*(p))) ||
; 1129 : 			((*(p) == ';')) || ((*(p) == ':')) ||
; 1130 : 			((*(p) == '&')) || ((*(p) == '=')) ||
; 1131 : 			((*(p) == '+')) || ((*(p) == '$')) ||

	mov	al, BYTE PTR [ecx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN50@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	$LN49@xmlSaveUri
$LN50@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN51@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	$LN49@xmlSaveUri
$LN51@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN52@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	SHORT $LN49@xmlSaveUri
$LN52@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 59					; 0000003bH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 58					; 0000003aH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	SHORT $LN49@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN49@xmlSaveUri

; 1132 : 			((*(p) == ',')))
; 1133 : 			ret[len++] = *p++;
; 1134 : 		    else {
; 1135 : 			int val = *(unsigned char *)p++;

	movzx	edx, al

; 1136 : 			int hi = val / 0x10, lo = val % 0x10;
; 1137 : 			ret[len++] = '%';
; 1138 : 			ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1139 : 			ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$4$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN49@xmlSaveUri:

; 1121 : 		p = uri->user;
; 1122 : 		while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$4$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL6@xmlSaveUri
$LN7@xmlSaveUri:

; 1140 : 		    }
; 1141 : 		}
; 1142 : 		if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN53@xmlSaveUri

; 1143 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1144 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1145 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
$LN53@xmlSaveUri:

; 1146 : 		}
; 1147 : 		ret[len++] = '@';

	mov	edx, DWORD PTR _uri$[ebp]
	mov	BYTE PTR [esi+edi], 64			; 00000040H
	inc	esi
$LN44@xmlSaveUri:

; 1148 : 	    }
; 1149 : 	    if (uri->server != NULL) {

	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _p$5$[ebp], ecx
	test	ecx, ecx
	je	$LN58@xmlSaveUri

; 1150 : 		p = uri->server;
; 1151 : 		while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN9@xmlSaveUri
	npad	5
$LL8@xmlSaveUri:

; 1152 : 		    if (len >= max) {

	cmp	esi, ebx
	jl	SHORT $LN56@xmlSaveUri

; 1153 : 			temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1154 : 			if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1155 : 			ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$5$[ebp]
$LN56@xmlSaveUri:

; 1156 : 		    }
; 1157 : 		    ret[len++] = *p++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$5$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL8@xmlSaveUri
	mov	edx, DWORD PTR _uri$[ebp]
$LN9@xmlSaveUri:

; 1158 : 		}
; 1159 : 		if (uri->port > 0) {

	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	jle	SHORT $LN58@xmlSaveUri

; 1160 : 		    if (len + 10 >= max) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, ebx
	jl	SHORT $LN59@xmlSaveUri

; 1161 : 			temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1162 : 			if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1163 : 			ret = temp;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edi, eax
	mov	ebx, DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
$LN59@xmlSaveUri:

; 1164 : 		    }
; 1165 : 		    len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);

	push	ecx
	mov	eax, ebx
	sub	eax, esi
	push	OFFSET ??_C@_03HODKBCIO@?3?$CFd@
	push	eax
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	add	esi, eax
$LN175@xmlSaveUri:

; 1201 : 	    }
; 1202 : 	}
; 1203 : 	if (uri->path != NULL) {

	mov	edx, DWORD PTR _uri$[ebp]
$LN58@xmlSaveUri:
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _p$6$[ebp], ecx
	test	ecx, ecx
	je	$LN13@xmlSaveUri

; 1204 : 	    p = uri->path;
; 1205 : 	    /*
; 1206 : 	     * the colon in file:///d: should not be escaped or
; 1207 : 	     * Windows accesses fail later.
; 1208 : 	     */
; 1209 : 	    if ((uri->scheme != NULL) &&
; 1210 : 		(p[0] == '/') &&
; 1211 : 		(((p[1] >= 'a') && (p[1] <= 'z')) ||
; 1212 : 		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
; 1213 : 		(p[2] == ':') &&

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN132@xmlSaveUri
	cmp	BYTE PTR [ecx], 47			; 0000002fH
	jne	SHORT $LN132@xmlSaveUri
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv2559[ebp], eax
	mov	al, BYTE PTR [eax]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN79@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN78@xmlSaveUri
$LN79@xmlSaveUri:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN132@xmlSaveUri
$LN78@xmlSaveUri:
	cmp	BYTE PTR [ecx+2], 58			; 0000003aH
	jne	SHORT $LN132@xmlSaveUri
	push	OFFSET ??_C@_04DAMGJPCA@file@
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN168@xmlSaveUri

; 1214 : 	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
; 1215 : 		if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN80@xmlSaveUri

; 1216 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1217 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1218 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
$LN80@xmlSaveUri:

; 1219 : 		}
; 1220 : 		ret[len++] = *p++;

	mov	eax, DWORD PTR _p$6$[ebp]
	mov	ecx, DWORD PTR tv2559[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [esi+edi], al

; 1221 : 		ret[len++] = *p++;

	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR [esi+edi+1], al

; 1222 : 		ret[len++] = *p++;

	movzx	eax, BYTE PTR [ecx+1]
	mov	BYTE PTR [esi+edi+2], al
	add	esi, 3
	add	ecx, 2
	mov	DWORD PTR _p$6$[ebp], ecx
	jmp	SHORT $LN132@xmlSaveUri
$LN168@xmlSaveUri:

; 1204 : 	    p = uri->path;
; 1205 : 	    /*
; 1206 : 	     * the colon in file:///d: should not be escaped or
; 1207 : 	     * Windows accesses fail later.
; 1208 : 	     */
; 1209 : 	    if ((uri->scheme != NULL) &&
; 1210 : 		(p[0] == '/') &&
; 1211 : 		(((p[1] >= 'a') && (p[1] <= 'z')) ||
; 1212 : 		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
; 1213 : 		(p[2] == ':') &&

	mov	ecx, DWORD PTR _p$6$[ebp]
$LN132@xmlSaveUri:

; 1223 : 	    }
; 1224 : 	    while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN169@xmlSaveUri
$LL12@xmlSaveUri:

; 1225 : 		if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN82@xmlSaveUri

; 1226 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1227 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1228 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$6$[ebp]
$LN82@xmlSaveUri:

; 1229 : 		}
; 1230 : 		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
; 1231 :                     ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
; 1232 : 	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||

	mov	al, BYTE PTR [ecx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN87@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	$LN86@xmlSaveUri
$LN87@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN88@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	$LN86@xmlSaveUri
$LN88@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN89@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	SHORT $LN86@xmlSaveUri
$LN89@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 47					; 0000002fH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 59					; 0000003bH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 64					; 00000040H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	SHORT $LN86@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN86@xmlSaveUri

; 1233 : 	            ((*(p) == ',')))
; 1234 : 		    ret[len++] = *p++;
; 1235 : 		else {
; 1236 : 		    int val = *(unsigned char *)p++;

	movzx	edx, al

; 1237 : 		    int hi = val / 0x10, lo = val % 0x10;
; 1238 : 		    ret[len++] = '%';
; 1239 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1240 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$6$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN86@xmlSaveUri:

; 1223 : 	    }
; 1224 : 	    while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$6$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL12@xmlSaveUri
$LN169@xmlSaveUri:

; 1241 : 		}
; 1242 : 	    }
; 1243 : 	}
; 1244 : 	if (uri->query_raw != NULL) {

	mov	edx, DWORD PTR _uri$[ebp]
$LN13@xmlSaveUri:
	cmp	DWORD PTR [edx+40], 0
	je	$LN90@xmlSaveUri

; 1245 : 	    if (len + 1 >= max) {

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv2565[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LN92@xmlSaveUri

; 1246 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1247 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1248 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR tv2565[ebp]
	mov	edx, DWORD PTR _uri$[ebp]
$LN92@xmlSaveUri:

; 1249 : 	    }
; 1250 : 	    ret[len++] = '?';

	mov	BYTE PTR [esi+edi], 63			; 0000003fH
	mov	esi, eax

; 1251 : 	    p = uri->query_raw;

	mov	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR _p$7$[ebp], ecx

; 1252 : 	    while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN17@xmlSaveUri

; 1249 : 	    }
; 1250 : 	    ret[len++] = '?';

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv2531[ebp], eax
	npad	4
$LL14@xmlSaveUri:

; 1253 : 		if (len + 1 >= max) {

	cmp	eax, ebx
	jl	SHORT $LN94@xmlSaveUri

; 1254 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1255 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1256 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$7$[ebp]
$LN94@xmlSaveUri:

; 1257 : 		}
; 1258 : 		ret[len++] = *p++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	eax, DWORD PTR tv2531[ebp]
	inc	eax
	mov	DWORD PTR _p$7$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	mov	DWORD PTR tv2531[ebp], eax
	jne	SHORT $LL14@xmlSaveUri

; 1297 :                 if (temp == NULL) goto mem_error;

	jmp	$LN174@xmlSaveUri
$LN90@xmlSaveUri:

; 1259 : 	    }
; 1260 : 	} else if (uri->query != NULL) {

	cmp	DWORD PTR [edx+28], 0
	je	$LN17@xmlSaveUri

; 1261 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN97@xmlSaveUri

; 1262 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1263 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1264 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	edx, DWORD PTR _uri$[ebp]
$LN97@xmlSaveUri:

; 1265 : 	    }
; 1266 : 	    ret[len++] = '?';

	mov	BYTE PTR [esi+edi], 63			; 0000003fH
	inc	esi

; 1267 : 	    p = uri->query;

	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _p$8$[ebp], ecx

; 1268 : 	    while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN17@xmlSaveUri
	npad	2
$LL16@xmlSaveUri:

; 1269 : 		if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN99@xmlSaveUri

; 1270 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1271 :                     if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1272 :                     ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$8$[ebp]
$LN99@xmlSaveUri:

; 1273 : 		}
; 1274 : 		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))

	mov	al, BYTE PTR [ecx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN104@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	$LN107@xmlSaveUri
$LN104@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN105@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	$LN107@xmlSaveUri
$LN105@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN106@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	$LN107@xmlSaveUri
$LN106@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	$LN107@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	$LN107@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	$LN107@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	$LN107@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 59					; 0000003bH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 47					; 0000002fH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 63					; 0000003fH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 58					; 0000003aH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 64					; 00000040H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 91					; 0000005bH
	je	SHORT $LN107@xmlSaveUri
	cmp	al, 93					; 0000005dH
	je	SHORT $LN107@xmlSaveUri

; 1275 : 		    ret[len++] = *p++;
; 1276 : 		else {
; 1277 : 		    int val = *(unsigned char *)p++;

	movzx	edx, al

; 1278 : 		    int hi = val / 0x10, lo = val % 0x10;
; 1279 : 		    ret[len++] = '%';
; 1280 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1281 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$8$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN107@xmlSaveUri:

; 1268 : 	    while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$8$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL16@xmlSaveUri
$LN174@xmlSaveUri:

; 1282 : 		}
; 1283 : 	    }
; 1284 : 	}
; 1285 :     }
; 1286 :     if (uri->fragment != NULL) {

	mov	edx, DWORD PTR _uri$[ebp]
$LN17@xmlSaveUri:
	cmp	DWORD PTR [edx+32], 0
	je	$LN19@xmlSaveUri

; 1287 : 	if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN109@xmlSaveUri

; 1288 :             temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1289 :             if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1290 :             ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	edx, DWORD PTR _uri$[ebp]
$LN109@xmlSaveUri:

; 1291 : 	}
; 1292 : 	ret[len++] = '#';

	mov	BYTE PTR [esi+edi], 35			; 00000023H
	inc	esi

; 1293 : 	p = uri->fragment;

	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _p$9$[ebp], ecx

; 1294 : 	while (*p != 0) {

	cmp	BYTE PTR [ecx], 0
	je	$LN19@xmlSaveUri
	npad	4
$LL18@xmlSaveUri:

; 1295 : 	    if (len + 3 >= max) {

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, ebx
	jl	SHORT $LN111@xmlSaveUri

; 1296 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1297 :                 if (temp == NULL) goto mem_error;

	test	eax, eax
	je	$mem_error$177

; 1298 :                 ret = temp;

	mov	ebx, DWORD PTR _max$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR _p$9$[ebp]
$LN111@xmlSaveUri:

; 1299 : 	    }
; 1300 : 	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))

	mov	al, BYTE PTR [ecx]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN116@xmlSaveUri
	cmp	al, 122					; 0000007aH
	jle	$LN119@xmlSaveUri
$LN116@xmlSaveUri:
	cmp	al, 65					; 00000041H
	jl	SHORT $LN117@xmlSaveUri
	cmp	al, 90					; 0000005aH
	jle	$LN119@xmlSaveUri
$LN117@xmlSaveUri:
	cmp	al, 48					; 00000030H
	jl	SHORT $LN118@xmlSaveUri
	cmp	al, 57					; 00000039H
	jle	$LN119@xmlSaveUri
$LN118@xmlSaveUri:
	cmp	al, 45					; 0000002dH
	je	$LN119@xmlSaveUri
	cmp	al, 95					; 0000005fH
	je	$LN119@xmlSaveUri
	cmp	al, 46					; 0000002eH
	je	$LN119@xmlSaveUri
	cmp	al, 33					; 00000021H
	je	$LN119@xmlSaveUri
	cmp	al, 126					; 0000007eH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 42					; 0000002aH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 39					; 00000027H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 40					; 00000028H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 41					; 00000029H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 59					; 0000003bH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 47					; 0000002fH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 63					; 0000003fH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 58					; 0000003aH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 64					; 00000040H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 38					; 00000026H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 43					; 0000002bH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 36					; 00000024H
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 44					; 0000002cH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 91					; 0000005bH
	je	SHORT $LN119@xmlSaveUri
	cmp	al, 93					; 0000005dH
	je	SHORT $LN119@xmlSaveUri

; 1301 : 		ret[len++] = *p++;
; 1302 : 	    else {
; 1303 : 		int val = *(unsigned char *)p++;

	movzx	edx, al

; 1304 : 		int hi = val / 0x10, lo = val % 0x10;
; 1305 : 		ret[len++] = '%';
; 1306 : 		ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	mov	eax, 9
	mov	ecx, edx
	mov	BYTE PTR [esi+edi], 37			; 00000025H
	shr	ecx, 4
	and	edx, 15					; 0000000fH
	cmp	eax, ecx
	sbb	al, al
	add	cl, 48					; 00000030H
	and	al, 7
	add	al, cl

; 1307 : 		ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	mov	ecx, DWORD PTR _p$9$[ebp]
	mov	BYTE PTR [esi+edi+1], al
	mov	eax, 9
	add	esi, 2
	cmp	eax, edx
	sbb	al, al
	and	al, 7
	add	al, 48					; 00000030H
	add	al, dl
$LN119@xmlSaveUri:

; 1294 : 	while (*p != 0) {

	inc	ecx
	mov	BYTE PTR [esi+edi], al
	inc	esi
	mov	DWORD PTR _p$9$[ebp], ecx
	cmp	BYTE PTR [ecx], 0
	jne	$LL18@xmlSaveUri
$LN19@xmlSaveUri:

; 1308 : 	    }
; 1309 : 	}
; 1310 :     }
; 1311 :     if (len >= max) {

	cmp	esi, ebx
	jl	SHORT $LN120@xmlSaveUri

; 1312 :         temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	push	edi
	call	_xmlSaveUriRealloc
	add	esp, 8

; 1313 :         if (temp == NULL) goto mem_error;

	test	eax, eax
	jne	SHORT $LN121@xmlSaveUri
$mem_error$177:

; 1318 : 
; 1319 : mem_error:
; 1320 :     xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1321 :     return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi
	pop	ebx

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@xmlSaveUri:

; 1314 :         ret = temp;

	mov	edi, eax
$LN120@xmlSaveUri:

; 1315 :     }
; 1316 :     ret[len] = 0;

	mov	BYTE PTR [esi+edi], 0

; 1317 :     return(ret);

	mov	eax, edi
	pop	esi
	pop	edi
	pop	ebx

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveUri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURIReference
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseURIReference PROC				; COMDAT

; 962  : xmlParseURIReference(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 964  : }

	pop	ebp

; 963  :     return(xmlParse3986URIReference(uri, str));

	jmp	_xmlParse3986URIReference
_xmlParseURIReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURIRaw
_TEXT	SEGMENT
_str$ = 8						; size = 4
_raw$ = 12						; size = 4
_xmlParseURIRaw PROC					; COMDAT

; 978  : xmlParseURIRaw(const char *str, int raw) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlParseUR

; 979  :     xmlURIPtr uri;
; 980  :     int ret;
; 981  : 
; 982  :     if (str == NULL)
; 983  : 	return(NULL);

	xor	eax, eax

; 996  : }

	pop	ebp
	ret	0
$LN2@xmlParseUR:
	push	esi

; 984  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	esi, eax

; 985  :     if (uri != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlParseUR

; 986  :         if (raw) {

	cmp	DWORD PTR _raw$[ebp], 0
	je	SHORT $LN4@xmlParseUR

; 987  : 	    uri->cleanup |= 2;

	or	DWORD PTR [esi+36], 2
$LN4@xmlParseUR:

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	DWORD PTR _str$[ebp]
	push	esi
	call	_xmlParse3986URIReference
	add	esp, 8

; 988  : 	}
; 989  : 	ret = xmlParseURIReference(uri, str);
; 990  :         if (ret) {

	test	eax, eax
	je	SHORT $LN5@xmlParseUR

; 991  : 	    xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4

; 992  : 	    return(NULL);

	xor	eax, eax
	pop	esi

; 996  : }

	pop	ebp
	ret	0
$LN5@xmlParseUR:

; 993  : 	}
; 994  :     }
; 995  :     return(uri);

	mov	eax, esi
	pop	esi

; 996  : }

	pop	ebp
	ret	0
_xmlParseURIRaw ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURI
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlParseURI PROC					; COMDAT

; 932  : xmlParseURI(const char *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlParseUR

; 933  :     xmlURIPtr uri;
; 934  :     int ret;
; 935  : 
; 936  :     if (str == NULL)
; 937  : 	return(NULL);

	xor	eax, eax

; 947  : }

	pop	ebp
	ret	0
$LN2@xmlParseUR:
	push	esi

; 938  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	esi, eax

; 939  :     if (uri != NULL) {

	test	esi, esi
	je	SHORT $LN4@xmlParseUR

; 940  : 	ret = xmlParse3986URIReference(uri, str);

	push	DWORD PTR _str$[ebp]
	push	esi
	call	_xmlParse3986URIReference
	add	esp, 8

; 941  :         if (ret) {

	test	eax, eax
	je	SHORT $LN4@xmlParseUR

; 942  : 	    xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4

; 943  : 	    return(NULL);

	xor	eax, eax
	pop	esi

; 947  : }

	pop	ebp
	ret	0
$LN4@xmlParseUR:

; 944  : 	}
; 945  :     }
; 946  :     return(uri);

	mov	eax, esi
	pop	esi

; 947  : }

	pop	ebp
	ret	0
_xmlParseURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlBuildRelativeURI
_TEXT	SEGMENT
_remove_path$1$ = -20					; size = 4
tv774 = -16						; size = 4
tv769 = -16						; size = 4
_uptr$1$ = -16						; size = 4
_len$1$ = -12						; size = 4
_bptr$1$ = -12						; size = 4
_rptr$1$ = -8						; size = 4
_bas$1$ = -4						; size = 4
_ref$1$ = 8						; size = 4
_URI$ = 8						; size = 4
_base$ = 12						; size = 4
_xmlBuildRelativeURI PROC				; COMDAT

; 2164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _URI$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	mov	DWORD PTR _bas$1$[ebp], ebx
	mov	DWORD PTR _remove_path$1$[ebp], ebx
	test	esi, esi
	je	$LN14@xmlBuildRe

; 2165 :     xmlChar *val = NULL;
; 2166 :     int ret;
; 2167 :     int ix;
; 2168 :     int nbslash = 0;
; 2169 :     int len;
; 2170 :     xmlURIPtr ref = NULL;
; 2171 :     xmlURIPtr bas = NULL;
; 2172 :     xmlChar *bptr, *uptr, *vptr;
; 2173 :     int remove_path = 0;
; 2174 : 
; 2175 :     if ((URI == NULL) || (*URI == 0))

	cmp	BYTE PTR [esi], bl
	je	$LN14@xmlBuildRe

; 2176 : 	return NULL;
; 2177 : 
; 2178 :     /*
; 2179 :      * First parse URI into a standard form
; 2180 :      */
; 2181 :     ref = xmlCreateURI ();

	call	_xmlCreateURI
	mov	DWORD PTR _ref$1$[ebp], eax

; 2182 :     if (ref == NULL)

	test	eax, eax
	je	$LN14@xmlBuildRe

; 2183 : 	return NULL;
; 2184 :     /* If URI not already in "relative" form */
; 2185 :     if (URI[0] != '.') {

	cmp	BYTE PTR [esi], 46			; 0000002eH
	push	esi
	je	SHORT $LN16@xmlBuildRe

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	eax
	call	_xmlParse3986URIReference
	add	esp, 8

; 2186 : 	ret = xmlParseURIReference (ref, (const char *) URI);
; 2187 : 	if (ret != 0)

	test	eax, eax
	jne	$LN80@xmlBuildRe

; 2188 : 	    goto done;		/* Error in URI, return NULL */
; 2189 :     } else

	jmp	SHORT $LN17@xmlBuildRe
$LN16@xmlBuildRe:

; 2190 : 	ref->path = (char *)xmlStrdup(URI);

	call	_xmlStrdup
	mov	ecx, DWORD PTR _ref$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+24], eax
$LN17@xmlBuildRe:

; 2191 : 
; 2192 :     /*
; 2193 :      * Next parse base into the same standard form
; 2194 :      */
; 2195 :     if ((base == NULL) || (*base == 0)) {

	mov	eax, DWORD PTR _base$[ebp]
	test	eax, eax
	je	$LN20@xmlBuildRe
	cmp	BYTE PTR [eax], bl
	je	$LN20@xmlBuildRe

; 2196 : 	val = xmlStrdup (URI);
; 2197 : 	goto done;
; 2198 :     }
; 2199 :     bas = xmlCreateURI ();

	call	_xmlCreateURI
	mov	ecx, eax
	mov	DWORD PTR _bas$1$[ebp], ecx

; 2200 :     if (bas == NULL)

	test	ecx, ecx
	je	$LN80@xmlBuildRe

; 2201 : 	goto done;
; 2202 :     if (base[0] != '.') {

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	cmp	BYTE PTR [eax], 46			; 0000002eH
	je	SHORT $LN22@xmlBuildRe

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	ecx
	call	_xmlParse3986URIReference
	add	esp, 8

; 2203 : 	ret = xmlParseURIReference (bas, (const char *) base);
; 2204 : 	if (ret != 0)

	test	eax, eax
	jne	$LN80@xmlBuildRe

; 2205 : 	    goto done;		/* Error in base, return NULL */
; 2206 :     } else

	mov	ecx, DWORD PTR _bas$1$[ebp]
	jmp	SHORT $LN23@xmlBuildRe
$LN22@xmlBuildRe:

; 2207 : 	bas->path = (char *)xmlStrdup(base);

	call	_xmlStrdup
	mov	ecx, DWORD PTR _bas$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+24], eax
$LN23@xmlBuildRe:

; 2208 : 
; 2209 :     /*
; 2210 :      * If the scheme / server on the URI differs from the base,
; 2211 :      * just return the URI
; 2212 :      */
; 2213 :     if ((ref->scheme != NULL) &&

	mov	eax, DWORD PTR _ref$1$[ebp]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN25@xmlBuildRe
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	$LN20@xmlBuildRe
	push	edx
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$LN20@xmlBuildRe
	mov	eax, DWORD PTR _ref$1$[ebp]
	push	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _bas$1$[ebp]
	push	DWORD PTR [eax+12]
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$LN20@xmlBuildRe
	mov	eax, DWORD PTR _ref$1$[ebp]
$LN25@xmlBuildRe:

; 2214 : 	((bas->scheme == NULL) ||
; 2215 : 	 (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
; 2216 : 	 (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)))) {
; 2217 : 	val = xmlStrdup (URI);
; 2218 : 	goto done;
; 2219 :     }
; 2220 :     if (xmlStrEqual((xmlChar *)bas->path, (xmlChar *)ref->path)) {

	push	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _bas$1$[ebp]
	push	DWORD PTR [eax+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlBuildRe

; 2221 : 	val = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@

; 2222 : 	goto done;

	jmp	$LN82@xmlBuildRe
$LN27@xmlBuildRe:

; 2223 :     }
; 2224 :     if (bas->path == NULL) {

	mov	edx, DWORD PTR _bas$1$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _bptr$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN28@xmlBuildRe

; 2225 : 	val = xmlStrdup((xmlChar *)ref->path);

	mov	eax, DWORD PTR _ref$1$[ebp]
	push	DWORD PTR [eax+24]

; 2226 : 	goto done;

	jmp	$LN82@xmlBuildRe
$LN28@xmlBuildRe:

; 2227 :     }
; 2228 :     if (ref->path == NULL) {

	mov	ecx, DWORD PTR _ref$1$[ebp]
	mov	esi, DWORD PTR [ecx+24]
	mov	DWORD PTR _rptr$1$[ebp], esi
	test	esi, esi
	jne	SHORT $LN29@xmlBuildRe

; 2229 :         ref->path = (char *) "/";

	mov	DWORD PTR [ecx+24], OFFSET ??_C@_01KMDKNFGN@?1@

; 2230 : 	remove_path = 1;

	mov	esi, OFFSET ??_C@_01KMDKNFGN@?1@
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _remove_path$1$[ebp], 1
	mov	DWORD PTR _bptr$1$[ebp], eax
	mov	DWORD PTR _rptr$1$[ebp], esi
$LN29@xmlBuildRe:

; 2231 :     }
; 2232 : 
; 2233 :     /*
; 2234 :      * At this point (at last!) we can compare the two paths
; 2235 :      *
; 2236 :      * First we take care of the special case where either of the
; 2237 :      * two path components may be missing (bug 316224)
; 2238 :      */
; 2239 :     bptr = (xmlChar *)bas->path;
; 2240 :     {
; 2241 :         xmlChar *rptr = (xmlChar *) ref->path;
; 2242 :         int pos = 0;

	xor	ecx, ecx

; 2243 : 
; 2244 :         /*
; 2245 :          * Next we compare the two strings and find where they first differ
; 2246 :          */
; 2247 : 	if ((*rptr == '.') && (rptr[1] == '/'))

	cmp	BYTE PTR [esi], 46			; 0000002eH
	jne	SHORT $LN30@xmlBuildRe
	cmp	BYTE PTR [esi+1], 47			; 0000002fH
	jne	SHORT $LN30@xmlBuildRe

; 2248 :             rptr += 2;

	add	esi, 2
	mov	DWORD PTR _rptr$1$[ebp], esi
$LN30@xmlBuildRe:

; 2249 : 	if ((*bptr == '.') && (bptr[1] == '/'))

	mov	dl, BYTE PTR [eax]
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR tv774[ebp], esi
	mov	esi, DWORD PTR _rptr$1$[ebp]
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN66@xmlBuildRe
	mov	esi, DWORD PTR tv774[ebp]
	cmp	BYTE PTR [esi], 47			; 0000002fH
	mov	esi, DWORD PTR _rptr$1$[ebp]
	jne	SHORT $LN53@xmlBuildRe

; 2250 :             bptr += 2;

	lea	edx, DWORD PTR [eax+2]
	mov	DWORD PTR _bptr$1$[ebp], edx
	mov	dl, BYTE PTR [eax+2]
	mov	eax, DWORD PTR _bptr$1$[ebp]
	jmp	SHORT $LN53@xmlBuildRe
$LN66@xmlBuildRe:

; 2251 : 	else if ((*bptr == '/') && (*rptr != '/'))

	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN53@xmlBuildRe
	cmp	BYTE PTR [esi], dl
	je	SHORT $LN53@xmlBuildRe

; 2252 : 	    bptr++;

	mov	edx, DWORD PTR tv774[ebp]
	mov	eax, edx
	mov	DWORD PTR _bptr$1$[ebp], eax
	mov	dl, BYTE PTR [edx]
$LN53@xmlBuildRe:

; 2253 : 	while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))

	cmp	dl, BYTE PTR [esi]
	jne	SHORT $LN3@xmlBuildRe
	mov	ebx, DWORD PTR _rptr$1$[ebp]
	mov	esi, eax
	sub	ebx, eax
	mov	DWORD PTR tv769[ebp], ebx
	xor	ebx, ebx
	mov	edi, DWORD PTR tv769[ebp]
	npad	1
$LL2@xmlBuildRe:
	test	dl, dl
	je	SHORT $LN74@xmlBuildRe
	mov	al, BYTE PTR [esi+1]

; 2254 : 	    pos++;

	inc	esi
	inc	ecx
	mov	dl, al
	cmp	al, BYTE PTR [edi+esi]
	je	SHORT $LL2@xmlBuildRe
$LN74@xmlBuildRe:
	mov	esi, DWORD PTR _rptr$1$[ebp]
	xor	edi, edi
	mov	eax, DWORD PTR _bptr$1$[ebp]
$LN3@xmlBuildRe:

; 2255 : 
; 2256 : 	if (bptr[pos] == rptr[pos]) {

	mov	al, BYTE PTR [ecx+eax]
	cmp	al, BYTE PTR [ecx+esi]
	jne	SHORT $LN34@xmlBuildRe

; 2257 : 	    val = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax

; 2258 : 	    goto done;		/* (I can't imagine why anyone would do this) */

	jmp	$done$84
$LN34@xmlBuildRe:

; 2259 : 	}
; 2260 : 
; 2261 : 	/*
; 2262 : 	 * In URI, "back up" to the last '/' encountered.  This will be the
; 2263 : 	 * beginning of the "unique" suffix of URI
; 2264 : 	 */
; 2265 : 	ix = pos;
; 2266 : 	for (; ix > 0; ix--) {

	test	ecx, ecx
	jle	SHORT $LN75@xmlBuildRe
$LL6@xmlBuildRe:

; 2267 : 	    if (rptr[ix - 1] == '/')

	cmp	BYTE PTR [esi+ecx-1], 47		; 0000002fH
	je	SHORT $LN75@xmlBuildRe

; 2259 : 	}
; 2260 : 
; 2261 : 	/*
; 2262 : 	 * In URI, "back up" to the last '/' encountered.  This will be the
; 2263 : 	 * beginning of the "unique" suffix of URI
; 2264 : 	 */
; 2265 : 	ix = pos;
; 2266 : 	for (; ix > 0; ix--) {

	dec	ecx
	test	ecx, ecx
	jg	SHORT $LL6@xmlBuildRe
$LN75@xmlBuildRe:

; 2268 : 		break;
; 2269 : 	}
; 2270 : 	uptr = (xmlChar *)&rptr[ix];
; 2271 : 
; 2272 : 	/*
; 2273 : 	 * In base, count the number of '/' from the differing point
; 2274 : 	 */
; 2275 : 	for (; bptr[ix] != 0; ix++) {

	mov	edx, DWORD PTR _bptr$1$[ebp]
	add	esi, ecx
	add	ecx, edx
	mov	DWORD PTR _uptr$1$[ebp], esi
	mov	dl, BYTE PTR [ecx]
	test	dl, dl
	je	SHORT $LN72@xmlBuildRe
$LL9@xmlBuildRe:
	cmp	dl, 47					; 0000002fH
	lea	eax, DWORD PTR [edi+1]
	mov	dl, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	cmovne	eax, edi
	mov	edi, eax
	test	dl, dl
	jne	SHORT $LL9@xmlBuildRe

; 2276 : 	    if (bptr[ix] == '/')
; 2277 : 		nbslash++;
; 2278 : 	}
; 2279 : 
; 2280 : 	/*
; 2281 : 	 * e.g: URI="foo/" base="foo/bar" -> "./"
; 2282 : 	 */
; 2283 : 	if (nbslash == 0 && !uptr[0]) {

	test	edi, edi
	jne	SHORT $LN73@xmlBuildRe
$LN72@xmlBuildRe:
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN73@xmlBuildRe

; 2284 : 	    val = xmlStrdup(BAD_CAST "./");

	push	OFFSET ??_C@_02CAHBHFGK@?4?1@
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax

; 2285 : 	    goto done;

	jmp	$done$84
$LN73@xmlBuildRe:

; 2286 : 	}
; 2287 : 
; 2288 : 	len = xmlStrlen (uptr) + 1;

	push	esi
	call	_xmlStrlen
	inc	eax
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], eax

; 2289 :     }
; 2290 : 
; 2291 :     if (nbslash == 0) {

	test	edi, edi
	jne	SHORT $LN38@xmlBuildRe

; 2292 : 	if (uptr != NULL)

	test	esi, esi
	je	$done$84

; 2293 : 	    /* exception characters from xmlSaveUri */
; 2294 : 	    val = xmlURIEscapeStr(uptr, BAD_CAST "/;&=+$,");

	push	OFFSET ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
	push	esi
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	ebx, eax

; 2295 : 	goto done;

	jmp	$done$84
$LN38@xmlBuildRe:

; 2296 :     }
; 2297 : 
; 2298 :     /*
; 2299 :      * Allocate just enough space for the returned string -
; 2300 :      * length of the remainder of the URI, plus enough space
; 2301 :      * for the "../" groups, plus one for the terminator
; 2302 :      */
; 2303 :     val = (xmlChar *) xmlMalloc (len + 3 * nbslash);

	lea	eax, DWORD PTR [eax+edi*2]
	add	eax, edi
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 2304 :     if (val == NULL) {

	test	ebx, ebx
	jne	SHORT $LN40@xmlBuildRe

; 2305 :         xmlURIErrMemory("building relative URI\n");

	push	OFFSET ??_C@_0BH@KBJNOCC@building?5relative?5URI?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 2306 : 	goto done;

	jmp	SHORT $done$84
$LN40@xmlBuildRe:

; 2307 :     }
; 2308 :     vptr = val;

	mov	esi, ebx

; 2309 :     /*
; 2310 :      * Put in as many "../" as needed
; 2311 :      */
; 2312 :     for (; nbslash>0; nbslash--) {

	test	edi, edi
	jle	SHORT $LN11@xmlBuildRe
	npad	2
$LL12@xmlBuildRe:

; 2313 : 	*vptr++ = '.';

	mov	WORD PTR [esi], 11822			; 00002e2eH
	dec	edi

; 2314 : 	*vptr++ = '.';
; 2315 : 	*vptr++ = '/';

	mov	BYTE PTR [esi+2], 47			; 0000002fH
	add	esi, 3
	test	edi, edi
	jg	SHORT $LL12@xmlBuildRe
$LN11@xmlBuildRe:

; 2316 :     }
; 2317 :     /*
; 2318 :      * Finish up with the end of the URI
; 2319 :      */
; 2320 :     if (uptr != NULL) {

	mov	ecx, DWORD PTR _uptr$1$[ebp]
	mov	edi, DWORD PTR _len$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN41@xmlBuildRe

; 2321 :         if ((vptr > val) && (len > 0) &&
; 2322 : 	    (uptr[0] == '/') && (vptr[-1] == '/')) {

	cmp	esi, ebx
	jbe	SHORT $LN43@xmlBuildRe
	test	edi, edi
	jle	SHORT $LN43@xmlBuildRe
	cmp	BYTE PTR [ecx], 47			; 0000002fH
	jne	SHORT $LN43@xmlBuildRe
	cmp	BYTE PTR [esi-1], 47			; 0000002fH
	jne	SHORT $LN43@xmlBuildRe

; 2323 : 	    memcpy (vptr, uptr + 1, len - 1);

	lea	eax, DWORD PTR [edi-1]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2324 : 	    vptr[len - 2] = 0;

	mov	BYTE PTR [esi+edi-2], 0

; 2325 : 	} else {

	jmp	SHORT $LN42@xmlBuildRe
$LN43@xmlBuildRe:

; 2326 : 	    memcpy (vptr, uptr, len);

	push	edi
	push	ecx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN41@xmlBuildRe:

; 2327 : 	    vptr[len - 1] = 0;
; 2328 : 	}
; 2329 :     } else {
; 2330 : 	vptr[len - 1] = 0;
; 2331 :     }
; 2332 : 
; 2333 :     /* escape the freshly-built path */
; 2334 :     vptr = val;

	mov	BYTE PTR [esi+edi-1], 0
$LN42@xmlBuildRe:

; 2335 : 	/* exception characters from xmlSaveUri */
; 2336 :     val = xmlURIEscapeStr(vptr, BAD_CAST "/;&=+$,");

	push	OFFSET ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
	push	ebx
	mov	esi, ebx
	call	_xmlURIEscapeStr

; 2337 :     xmlFree(vptr);

	push	esi
	mov	ebx, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$done$84:

; 2338 : 
; 2339 : done:
; 2340 :     /*
; 2341 :      * Free the working variables
; 2342 :      */
; 2343 :     if (remove_path != 0)

	cmp	DWORD PTR _remove_path$1$[ebp], 0
	je	SHORT $LN80@xmlBuildRe

; 2344 :         ref->path = NULL;

	mov	eax, DWORD PTR _ref$1$[ebp]
	mov	DWORD PTR [eax+24], 0
	jmp	SHORT $LN45@xmlBuildRe
$LN20@xmlBuildRe:

; 2345 :     if (ref != NULL)
; 2346 : 	xmlFreeURI (ref);

	push	esi
$LN82@xmlBuildRe:
	call	_xmlStrdup
	mov	ebx, eax
	add	esp, 4
$LN80@xmlBuildRe:
	mov	eax, DWORD PTR _ref$1$[ebp]
$LN45@xmlBuildRe:
	push	eax
	call	_xmlFreeURI

; 2347 :     if (bas != NULL)

	mov	eax, DWORD PTR _bas$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN47@xmlBuildRe

; 2348 : 	xmlFreeURI (bas);

	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN47@xmlBuildRe:

; 2349 : 
; 2350 :     return val;
; 2351 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlBuildRe:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBuildRelativeURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlBuildURI
_TEXT	SEGMENT
_bas$1$ = -12						; size = 4
_ref$1$ = -8						; size = 4
_val$1$ = -4						; size = 4
tv1027 = 8						; size = 4
_URI$ = 8						; size = 4
_base$ = 12						; size = 4
_xmlBuildURI PROC					; COMDAT

; 1882 : xmlBuildURI(const xmlChar *URI, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _URI$[ebp]
	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _val$1$[ebp], eax
	xor	edi, edi
	mov	DWORD PTR _ref$1$[ebp], esi
	xor	ebx, ebx
	test	ecx, ecx
	je	$LN70@xmlBuildUR

; 1883 :     xmlChar *val = NULL;
; 1884 :     int ret, len, indx, cur, out;
; 1885 :     xmlURIPtr ref = NULL;
; 1886 :     xmlURIPtr bas = NULL;
; 1887 :     xmlURIPtr res = NULL;
; 1888 : 
; 1889 :     /*
; 1890 :      * 1) The URI reference is parsed into the potential four components and
; 1891 :      *    fragment identifier, as described in Section 4.3.
; 1892 :      *
; 1893 :      *    NOTE that a completely empty URI is treated by modern browsers
; 1894 :      *    as a reference to "." rather than as a synonym for the current
; 1895 :      *    URI.  Should we do that here?
; 1896 :      */
; 1897 :     if (URI == NULL)
; 1898 : 	ret = -1;
; 1899 :     else {
; 1900 : 	if (*URI) {

	cmp	BYTE PTR [ecx], al
	je	SHORT $LN90@xmlBuildUR

; 1901 : 	    ref = xmlCreateURI();

	call	_xmlCreateURI
	mov	esi, eax
	mov	DWORD PTR _ref$1$[ebp], esi

; 1902 : 	    if (ref == NULL)

	test	esi, esi
	je	SHORT $LN109@xmlBuildUR

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	DWORD PTR _URI$[ebp]
	push	esi
	call	_xmlParse3986URIReference
	add	esp, 8

; 1903 : 		goto done;
; 1904 : 	    ret = xmlParseURIReference(ref, (const char *) URI);
; 1905 : 	}
; 1906 : 	else
; 1907 : 	    ret = 0;
; 1908 :     }
; 1909 :     if (ret != 0)

	test	eax, eax
	jne	$done$123

; 1910 : 	goto done;
; 1911 :     if ((ref != NULL) && (ref->scheme != NULL)) {

	cmp	DWORD PTR [esi], ebx
	je	SHORT $LN90@xmlBuildUR

; 1912 : 	/*
; 1913 : 	 * The URI is absolute don't modify.
; 1914 : 	 */
; 1915 : 	val = xmlStrdup(URI);

	push	DWORD PTR _URI$[ebp]
	call	_xmlStrdup

; 1916 : 	goto done;

	jmp	$LN113@xmlBuildUR
$LN109@xmlBuildUR:
	pop	edi

; 2127 :     return(val);
; 2128 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@xmlBuildUR:

; 1917 :     }
; 1918 :     if (base == NULL)

	cmp	DWORD PTR _base$[ebp], ebx
	je	$LN102@xmlBuildUR

; 1919 : 	ret = -1;
; 1920 :     else {
; 1921 : 	bas = xmlCreateURI();

	call	_xmlCreateURI
	mov	edi, eax
	mov	DWORD PTR _bas$1$[ebp], edi

; 1922 : 	if (bas == NULL)

	test	edi, edi
	je	$done$123

; 963  :     return(xmlParse3986URIReference(uri, str));

	push	DWORD PTR _base$[ebp]
	push	edi
	call	_xmlParse3986URIReference
	add	esp, 8

; 1923 : 	    goto done;
; 1924 : 	ret = xmlParseURIReference(bas, (const char *) base);
; 1925 :     }
; 1926 :     if (ret != 0) {

	test	eax, eax
	jne	$LN102@xmlBuildUR

; 1928 : 	    val = xmlSaveUri(ref);
; 1929 : 	goto done;
; 1930 :     }
; 1931 :     if (ref == NULL) {

	test	esi, esi
	jne	SHORT $LN22@xmlBuildUR

; 1932 : 	/*
; 1933 : 	 * the base fragment must be ignored
; 1934 : 	 */
; 1935 : 	if (bas->fragment != NULL) {

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN23@xmlBuildUR

; 1936 : 	    xmlFree(bas->fragment);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1937 : 	    bas->fragment = NULL;

	mov	DWORD PTR [edi+32], ebx
$LN23@xmlBuildUR:

; 1938 : 	}
; 1939 : 	val = xmlSaveUri(bas);

	push	edi
	call	_xmlSaveUri
	mov	DWORD PTR _val$1$[ebp], eax

; 1940 : 	goto done;

	jmp	$LN114@xmlBuildUR
$LN22@xmlBuildUR:

; 1941 :     }
; 1942 : 
; 1943 :     /*
; 1944 :      * 2) If the path component is empty and the scheme, authority, and
; 1945 :      *    query components are undefined, then it is a reference to the
; 1946 :      *    current document and we are done.  Otherwise, the reference URI's
; 1947 :      *    query and fragment components are defined as found (or not found)
; 1948 :      *    within the URI reference and not inherited from the base URI.
; 1949 :      *
; 1950 :      *    NOTE that in modern browsers, the parsing differs from the above
; 1951 :      *    in the following aspect:  the query component is allowed to be
; 1952 :      *    defined while still treating this as a reference to the current
; 1953 :      *    document.
; 1954 :      */
; 1955 :     res = xmlCreateURI();

	call	_xmlCreateURI
	mov	ebx, eax

; 1956 :     if (res == NULL)

	test	ebx, ebx
	je	$done$123

; 1957 : 	goto done;
; 1958 :     if ((ref->scheme == NULL) && (ref->path == NULL) &&

	cmp	DWORD PTR [esi], 0
	jne	$LN101@xmlBuildUR
	cmp	DWORD PTR [esi+24], 0
	jne	$LN42@xmlBuildUR
	cmp	DWORD PTR [esi+8], 0
	jne	$LN42@xmlBuildUR
	cmp	DWORD PTR [esi+12], 0
	jne	$LN42@xmlBuildUR

; 1959 : 	((ref->authority == NULL) && (ref->server == NULL))) {
; 1960 : 	if (bas->scheme != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN26@xmlBuildUR

; 1961 : 	    res->scheme = xmlMemStrdup(bas->scheme);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN26@xmlBuildUR:

; 1962 : 	if (bas->authority != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN27@xmlBuildUR

; 1963 : 	    res->authority = xmlMemStrdup(bas->authority);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax
	jmp	SHORT $LN29@xmlBuildUR
$LN27@xmlBuildUR:

; 1964 : 	else if ((bas->server != NULL) || (bas->port == -1)) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN100@xmlBuildUR
	cmp	DWORD PTR [edi+20], -1
	jne	SHORT $LN29@xmlBuildUR

; 1965 : 	    if (bas->server != NULL)

	jmp	SHORT $LN31@xmlBuildUR
$LN100@xmlBuildUR:

; 1966 : 		res->server = xmlMemStrdup(bas->server);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+12], eax
$LN31@xmlBuildUR:

; 1967 : 	    if (bas->user != NULL)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN32@xmlBuildUR

; 1968 : 		res->user = xmlMemStrdup(bas->user);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+16], eax
$LN32@xmlBuildUR:

; 1969 : 	    res->port = bas->port;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [ebx+20], eax
$LN29@xmlBuildUR:

; 1970 : 	}
; 1971 : 	if (bas->path != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN33@xmlBuildUR

; 1972 : 	    res->path = xmlMemStrdup(bas->path);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+24], eax
$LN33@xmlBuildUR:

; 1973 : 	if (ref->query_raw != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN34@xmlBuildUR

; 1974 : 	    res->query_raw = xmlMemStrdup (ref->query_raw);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+40], eax
	jmp	SHORT $LN115@xmlBuildUR
$LN34@xmlBuildUR:

; 1975 : 	else if (ref->query != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN116@xmlBuildUR

; 1976 : 	    res->query = xmlMemStrdup(ref->query);
; 1977 : 	else if (bas->query_raw != NULL)

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN38@xmlBuildUR

; 1978 : 	    res->query_raw = xmlMemStrdup(bas->query_raw);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+40], eax
	jmp	SHORT $LN115@xmlBuildUR
$LN38@xmlBuildUR:

; 1979 : 	else if (bas->query != NULL)

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN40@xmlBuildUR
$LN116@xmlBuildUR:

; 1980 : 	    res->query = xmlMemStrdup(bas->query);
; 1981 : 	if (ref->fragment != NULL)

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+28], eax
$LN115@xmlBuildUR:
	add	esp, 4
$LN40@xmlBuildUR:
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	$step_7$124

; 1982 : 	    res->fragment = xmlMemStrdup(ref->fragment);

	push	eax
	call	DWORD PTR _xmlMemStrdup

; 2110 : 
; 2111 : step_7:
; 2112 : 
; 2113 :     /*
; 2114 :      * 7) The resulting URI components, including any inherited from the
; 2115 :      *    base URI, are recombined to give the absolute form of the URI
; 2116 :      *    reference.
; 2117 :      */
; 2118 :     val = xmlSaveUri(res);

	add	esp, 4
	mov	DWORD PTR [ebx+32], eax
	push	ebx
	jmp	$LN121@xmlBuildUR
$LN42@xmlBuildUR:

; 1983 : 	goto step_7;
; 1984 :     }
; 1985 : 
; 1986 :     /*
; 1987 :      * 3) If the scheme component is defined, indicating that the reference
; 1988 :      *    starts with a scheme name, then the reference is interpreted as an
; 1989 :      *    absolute URI and we are done.  Otherwise, the reference URI's
; 1990 :      *    scheme is inherited from the base URI's scheme component.
; 1991 :      */
; 1992 :     if (ref->scheme != NULL) {
; 1993 : 	val = xmlSaveUri(ref);
; 1994 : 	goto done;
; 1995 :     }
; 1996 :     if (bas->scheme != NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN43@xmlBuildUR

; 1997 : 	res->scheme = xmlMemStrdup(bas->scheme);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN43@xmlBuildUR:

; 1998 : 
; 1999 :     if (ref->query_raw != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN44@xmlBuildUR

; 2000 : 	res->query_raw = xmlMemStrdup(ref->query_raw);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+40], eax
	jmp	SHORT $LN118@xmlBuildUR
$LN44@xmlBuildUR:

; 2001 :     else if (ref->query != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN46@xmlBuildUR

; 2002 : 	res->query = xmlMemStrdup(ref->query);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+28], eax
$LN118@xmlBuildUR:

; 2003 :     if (ref->fragment != NULL)

	add	esp, 4
$LN46@xmlBuildUR:
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN47@xmlBuildUR

; 2004 : 	res->fragment = xmlMemStrdup(ref->fragment);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+32], eax
$LN47@xmlBuildUR:

; 2005 : 
; 2006 :     /*
; 2007 :      * 4) If the authority component is defined, then the reference is a
; 2008 :      *    network-path and we skip to step 7.  Otherwise, the reference
; 2009 :      *    URI's authority is inherited from the base URI's authority
; 2010 :      *    component, which will also be undefined if the URI scheme does not
; 2011 :      *    use an authority component.
; 2012 :      */
; 2013 :     if ((ref->authority != NULL) || (ref->server != NULL)) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	$LN99@xmlBuildUR
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	$LN50@xmlBuildUR

; 2024 : 	goto step_7;
; 2025 :     }
; 2026 :     if (bas->authority != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN54@xmlBuildUR

; 2027 : 	res->authority = xmlMemStrdup(bas->authority);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax
	jmp	SHORT $LN56@xmlBuildUR
$LN54@xmlBuildUR:

; 2028 :     else if ((bas->server != NULL) || (bas->port == -1)) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN98@xmlBuildUR
	cmp	DWORD PTR [edi+20], -1
	jne	SHORT $LN56@xmlBuildUR

; 2029 : 	if (bas->server != NULL)

	jmp	SHORT $LN58@xmlBuildUR
$LN98@xmlBuildUR:

; 2030 : 	    res->server = xmlMemStrdup(bas->server);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+12], eax
$LN58@xmlBuildUR:

; 2031 : 	if (bas->user != NULL)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN59@xmlBuildUR

; 2032 : 	    res->user = xmlMemStrdup(bas->user);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+16], eax
$LN59@xmlBuildUR:

; 2033 : 	res->port = bas->port;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [ebx+20], eax
$LN56@xmlBuildUR:

; 2034 :     }
; 2035 : 
; 2036 :     /*
; 2037 :      * 5) If the path component begins with a slash character ("/"), then
; 2038 :      *    the reference is an absolute-path and we skip to step 7.
; 2039 :      */
; 2040 :     if ((ref->path != NULL) && (ref->path[0] == '/')) {

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN105@xmlBuildUR
	cmp	BYTE PTR [ecx], 47			; 0000002fH
	jne	SHORT $LN105@xmlBuildUR

; 2041 : 	res->path = xmlMemStrdup(ref->path);

	push	ecx

; 2110 : 
; 2111 : step_7:
; 2112 : 
; 2113 :     /*
; 2114 :      * 7) The resulting URI components, including any inherited from the
; 2115 :      *    base URI, are recombined to give the absolute form of the URI
; 2116 :      *    reference.
; 2117 :      */
; 2118 :     val = xmlSaveUri(res);

	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+24], eax
	push	ebx
	jmp	$LN121@xmlBuildUR
$LN105@xmlBuildUR:

; 2042 : 	goto step_7;
; 2043 :     }
; 2044 : 
; 2045 : 
; 2046 :     /*
; 2047 :      * 6) If this step is reached, then we are resolving a relative-path
; 2048 :      *    reference.  The relative path needs to be merged with the base
; 2049 :      *    URI's path.  Although there are many ways to do this, we will
; 2050 :      *    describe a simple method using a separate string buffer.
; 2051 :      *
; 2052 :      * Allocate a buffer large enough for the result string.
; 2053 :      */
; 2054 :     len = 2; /* extra / and 0 */

	mov	edx, 2

; 2055 :     if (ref->path != NULL)

	test	ecx, ecx
	je	SHORT $LN61@xmlBuildUR

; 2056 : 	len += strlen(ref->path);

	lea	edx, DWORD PTR [ecx+1]
$LL106@xmlBuildUR:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL106@xmlBuildUR
	sub	ecx, edx
	lea	edx, DWORD PTR [ecx+2]
$LN61@xmlBuildUR:

; 2057 :     if (bas->path != NULL)

	mov	ecx, DWORD PTR [edi+24]
	test	ecx, ecx
	je	SHORT $LN62@xmlBuildUR

; 2058 : 	len += strlen(bas->path);

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv1027[ebp], eax
	npad	5
$LL107@xmlBuildUR:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL107@xmlBuildUR
	sub	ecx, DWORD PTR tv1027[ebp]
	add	edx, ecx
$LN62@xmlBuildUR:

; 2059 :     res->path = (char *) xmlMallocAtomic(len);

	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR [ebx+24], eax

; 2060 :     if (res->path == NULL) {

	test	eax, eax
	jne	SHORT $LN63@xmlBuildUR

; 2061 :         xmlURIErrMemory("resolving URI against base\n");

	push	OFFSET ??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@
	call	_xmlURIErrMemory

; 2062 : 	goto done;

	jmp	$LN120@xmlBuildUR
$LN63@xmlBuildUR:

; 2063 :     }
; 2064 :     res->path[0] = 0;

	mov	BYTE PTR [eax], 0

; 2065 : 
; 2066 :     /*
; 2067 :      * a) All but the last segment of the base URI's path component is
; 2068 :      *    copied to the buffer.  In other words, any characters after the
; 2069 :      *    last (right-most) slash character, if any, are excluded.
; 2070 :      */
; 2071 :     cur = 0;

	xor	edx, edx

; 2072 :     out = 0;
; 2073 :     if (bas->path != NULL) {

	mov	ecx, DWORD PTR [edi+24]
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN112@xmlBuildUR

; 2074 : 	while (bas->path[cur] != 0) {

	cmp	BYTE PTR [ecx], dl
	je	SHORT $LN112@xmlBuildUR
	npad	2
$LL2@xmlBuildUR:

; 2075 : 	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))

	cmp	BYTE PTR [ecx+edx], 0
	mov	eax, ecx
	je	SHORT $LN111@xmlBuildUR
$LL4@xmlBuildUR:
	cmp	BYTE PTR [ecx+edx], 47			; 0000002fH
	je	SHORT $LN111@xmlBuildUR
	mov	eax, DWORD PTR [edi+24]

; 2076 : 		cur++;

	inc	edx
	cmp	BYTE PTR [eax+edx], 0
	jne	SHORT $LL4@xmlBuildUR
$LN111@xmlBuildUR:

; 2077 : 	    if (bas->path[cur] == 0)

	cmp	BYTE PTR [eax+edx], 0
	je	SHORT $LN112@xmlBuildUR

; 2078 : 		break;
; 2079 : 
; 2080 : 	    cur++;

	inc	edx
	mov	ecx, eax

; 2081 : 	    while (out < cur) {

	cmp	esi, edx
	jge	SHORT $LN104@xmlBuildUR
$LL84@xmlBuildUR:

; 2082 : 		res->path[out] = bas->path[out];

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [ebx+24]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [esi+ecx], al

; 2083 : 		out++;

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL84@xmlBuildUR

; 2028 :     else if ((bas->server != NULL) || (bas->port == -1)) {

	mov	ecx, DWORD PTR [edi+24]
$LN104@xmlBuildUR:

; 2074 : 	while (bas->path[cur] != 0) {

	cmp	BYTE PTR [ecx+edx], 0
	jne	SHORT $LL2@xmlBuildUR
$LN112@xmlBuildUR:

; 2084 : 	    }
; 2085 : 	}
; 2086 :     }
; 2087 :     res->path[out] = 0;

	mov	eax, DWORD PTR [ebx+24]

; 2088 : 
; 2089 :     /*
; 2090 :      * b) The reference's path component is appended to the buffer
; 2091 :      *    string.
; 2092 :      */
; 2093 :     if (ref->path != NULL && ref->path[0] != 0) {

	mov	ecx, DWORD PTR _ref$1$[ebp]
	mov	BYTE PTR [esi+eax], 0
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN9@xmlBuildUR
	mov	dl, BYTE PTR [eax]
	test	dl, dl
	je	SHORT $LN9@xmlBuildUR

; 2094 : 	indx = 0;
; 2095 : 	/*
; 2096 : 	 * Ensure the path includes a '/'
; 2097 : 	 */
; 2098 : 	if ((out == 0) && (bas->server != NULL))

	test	esi, esi
	jne	SHORT $LN79@xmlBuildUR
	cmp	DWORD PTR [edi+12], esi
	je	SHORT $LN79@xmlBuildUR

; 2099 : 	    res->path[out++] = '/';

	mov	eax, DWORD PTR [ebx+24]
	mov	esi, 1
	mov	BYTE PTR [eax], 47			; 0000002fH
	mov	eax, DWORD PTR [ecx+24]
	mov	dl, BYTE PTR [eax]
$LN79@xmlBuildUR:

; 2100 : 	while (ref->path[indx] != 0) {

	test	dl, dl
	je	SHORT $LN9@xmlBuildUR
	mov	dl, BYTE PTR [eax]
	xor	edi, edi
$LL8@xmlBuildUR:

; 2101 : 	    res->path[out++] = ref->path[indx++];

	mov	eax, DWORD PTR [ebx+24]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [esi+eax], dl
	inc	esi
	mov	eax, DWORD PTR [ecx+24]
	mov	dl, BYTE PTR [edi+eax]
	test	dl, dl
	jne	SHORT $LL8@xmlBuildUR
	mov	edi, DWORD PTR _bas$1$[ebp]
$LN9@xmlBuildUR:

; 2102 : 	}
; 2103 :     }
; 2104 :     res->path[out] = 0;

	mov	eax, DWORD PTR [ebx+24]
	mov	BYTE PTR [esi+eax], 0

; 2105 : 
; 2106 :     /*
; 2107 :      * Steps c) to h) are really path normalization steps
; 2108 :      */
; 2109 :     xmlNormalizeURIPath(res->path);

	push	DWORD PTR [ebx+24]
	call	_xmlNormalizeURIPath
	mov	esi, DWORD PTR _ref$1$[ebp]

; 2110 : 
; 2111 : step_7:
; 2112 : 
; 2113 :     /*
; 2114 :      * 7) The resulting URI components, including any inherited from the
; 2115 :      *    base URI, are recombined to give the absolute form of the URI
; 2116 :      *    reference.
; 2117 :      */
; 2118 :     val = xmlSaveUri(res);

	add	esp, 4
	push	ebx
	jmp	SHORT $LN121@xmlBuildUR
$LN50@xmlBuildUR:

; 2016 : 	else {
; 2017 : 	    res->server = xmlMemStrdup(ref->server);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+12], eax
	add	esp, 4

; 2018 : 	    if (ref->user != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN52@xmlBuildUR

; 2019 : 		res->user = xmlMemStrdup(ref->user);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+16], eax
$LN52@xmlBuildUR:

; 2020 :             res->port = ref->port;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ebx+20], eax
	jmp	SHORT $LN51@xmlBuildUR
$LN99@xmlBuildUR:

; 2014 : 	if (ref->authority != NULL)
; 2015 : 	    res->authority = xmlMemStrdup(ref->authority);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax
$LN51@xmlBuildUR:

; 2021 : 	}
; 2022 : 	if (ref->path != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $step_7$124

; 2023 : 	    res->path = xmlMemStrdup(ref->path);

	push	eax

; 2110 : 
; 2111 : step_7:
; 2112 : 
; 2113 :     /*
; 2114 :      * 7) The resulting URI components, including any inherited from the
; 2115 :      *    base URI, are recombined to give the absolute form of the URI
; 2116 :      *    reference.
; 2117 :      */
; 2118 :     val = xmlSaveUri(res);

	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+24], eax
	add	esp, 4
$step_7$124:
	push	ebx
	jmp	SHORT $LN121@xmlBuildUR
$LN102@xmlBuildUR:

; 1927 : 	if (ref)

	test	esi, esi
	je	SHORT $LN68@xmlBuildUR
$LN101@xmlBuildUR:

; 2119 : 
; 2120 : done:
; 2121 :     if (ref != NULL)

	push	esi
$LN121@xmlBuildUR:
	call	_xmlSaveUri
$LN113@xmlBuildUR:
	mov	DWORD PTR _val$1$[ebp], eax
$LN120@xmlBuildUR:
	add	esp, 4
$done$123:
	test	esi, esi
	je	SHORT $LN68@xmlBuildUR

; 2122 : 	xmlFreeURI(ref);

	push	esi
	call	_xmlFreeURI
$LN114@xmlBuildUR:

; 2123 :     if (bas != NULL)

	add	esp, 4
$LN68@xmlBuildUR:
	test	edi, edi
	je	SHORT $LN69@xmlBuildUR

; 2124 : 	xmlFreeURI(bas);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN69@xmlBuildUR:

; 2125 :     if (res != NULL)

	test	ebx, ebx
	je	SHORT $LN108@xmlBuildUR

; 2126 : 	xmlFreeURI(res);

	push	ebx
	call	_xmlFreeURI
	add	esp, 4
$LN108@xmlBuildUR:

; 2127 :     return(val);
; 2128 : }

	mov	eax, DWORD PTR _val$1$[ebp]
$LN70@xmlBuildUR:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBuildURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCreateURI
_TEXT	SEGMENT
_xmlCreateURI PROC					; COMDAT

; 1012 : xmlCreateURI(void) {

	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCreateU

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@
	push	eax
	push	eax
	push	3
	push	2
	push	30					; 0000001eH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1013 :     xmlURIPtr ret;
; 1014 : 
; 1015 :     ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
; 1016 :     if (ret == NULL) {
; 1017 :         xmlURIErrMemory("creating URI structure\n");
; 1018 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1022 : }

	ret	0
$LN2@xmlCreateU:

; 1019 :     }
; 1020 :     memset(ret, 0, sizeof(xmlURI));

	push	44					; 0000002cH
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1021 :     return(ret);

	mov	eax, esi
	pop	esi

; 1022 : }

	ret	0
_xmlCreateURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
