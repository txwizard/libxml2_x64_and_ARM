; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\catalog.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__A40A425D_stat@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__0FC738B4_catalog@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlNewCatalog
PUBLIC	_xmlLoadACatalog
PUBLIC	_xmlLoadSGMLSuperCatalog
PUBLIC	_xmlConvertSGMLCatalog
PUBLIC	_xmlACatalogAdd
PUBLIC	_xmlACatalogRemove
PUBLIC	_xmlACatalogResolve
PUBLIC	_xmlACatalogResolveSystem
PUBLIC	_xmlACatalogResolvePublic
PUBLIC	_xmlACatalogResolveURI
PUBLIC	_xmlACatalogDump
PUBLIC	_xmlFreeCatalog
PUBLIC	_xmlCatalogIsEmpty
PUBLIC	_xmlInitializeCatalog
PUBLIC	_xmlLoadCatalog
PUBLIC	_xmlLoadCatalogs
PUBLIC	_xmlCatalogCleanup
PUBLIC	_xmlCatalogDump
PUBLIC	_xmlCatalogResolve
PUBLIC	_xmlCatalogResolveSystem
PUBLIC	_xmlCatalogResolvePublic
PUBLIC	_xmlCatalogResolveURI
PUBLIC	_xmlCatalogAdd
PUBLIC	_xmlCatalogRemove
PUBLIC	_xmlParseCatalogFile
PUBLIC	_xmlCatalogConvert
PUBLIC	_xmlCatalogFreeLocal
PUBLIC	_xmlCatalogAddLocal
PUBLIC	_xmlCatalogLocalResolve
PUBLIC	_xmlCatalogLocalResolveURI
PUBLIC	_xmlCatalogSetDebug
PUBLIC	_xmlCatalogSetDefaultPrefer
PUBLIC	_xmlCatalogSetDefaults
PUBLIC	_xmlCatalogGetDefaults
PUBLIC	_xmlCatalogGetSystem
PUBLIC	_xmlCatalogGetPublic
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@	; `string'
PUBLIC	??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@	; `string'
PUBLIC	??_C@_0BD@FCDBKBHD@allocating?5catalog@		; `string'
PUBLIC	??_C@_07JPOODLIK@ENTITY?5@			; `string'
PUBLIC	??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@		; `string'
PUBLIC	??_C@_08JFBCIFIP@DOCTYPE?5@			; `string'
PUBLIC	??_C@_09BKBNLHNH@LINKTYPE?5@			; `string'
PUBLIC	??_C@_09EADGFDGH@NOTATION?5@			; `string'
PUBLIC	??_C@_07GAMBALOD@PUBLIC?5@			; `string'
PUBLIC	??_C@_07PBLMPJLL@SYSTEM?5@			; `string'
PUBLIC	??_C@_09KHFEEDDG@DELEGATE?5@			; `string'
PUBLIC	??_C@_05FDFDEPAH@BASE?5@			; `string'
PUBLIC	??_C@_08LGGFEAEJ@CATALOG?5@			; `string'
PUBLIC	??_C@_09PKNPLMNA@DOCUMENT?5@			; `string'
PUBLIC	??_C@_09KEOJDEKL@SGMLDECL?5@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_04OEDFLLKD@?$CC?$CFs?$CC@			; `string'
PUBLIC	??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0M@IKOOEBPK@nextCatalog@			; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_06EOMAMIIF@public@			; `string'
PUBLIC	??_C@_06NEJLBODN@prefer@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_08KNJBHAKA@publicId@			; `string'
PUBLIC	??_C@_03GBBABMJN@uri@				; `string'
PUBLIC	??_C@_08MILANEJE@systemId@			; `string'
PUBLIC	??_C@_0O@CCMDBGLO@rewriteSystem@		; `string'
PUBLIC	??_C@_0BE@DMCACPJB@systemIdStartString@		; `string'
PUBLIC	??_C@_0O@FCPDBOKG@rewritePrefix@		; `string'
PUBLIC	??_C@_0P@FNMIEEAK@delegatePublic@		; `string'
PUBLIC	??_C@_0BE@JKBIFJL@publicIdStartString@		; `string'
PUBLIC	??_C@_0P@EEFGILEE@delegateSystem@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0L@BCFABNDK@rewriteURI@			; `string'
PUBLIC	??_C@_0P@HNKDCBAK@uriStartString@		; `string'
PUBLIC	??_C@_0M@NHAMNMJD@delegateURI@			; `string'
PUBLIC	??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@ ; `string'
PUBLIC	??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@ ; `string'
PUBLIC	??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@ ; `string'
PUBLIC	??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@ ; `string'
PUBLIC	??_C@_0O@NOBDOKAH@urn?3publicid?3@		; `string'
PUBLIC	??_C@_0P@PCJPAHLM@out?5of?5memory?6@		; `string'
PUBLIC	??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@	; `string'
PUBLIC	??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@	; `string'
PUBLIC	??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@ ; `string'
PUBLIC	??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@ ; `string'
PUBLIC	??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@ ; `string'
PUBLIC	??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@ ; `string'
PUBLIC	??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@ ; `string'
PUBLIC	??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@ ; `string'
PUBLIC	??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@ ; `string'
PUBLIC	??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@ ; `string'
PUBLIC	??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@ ; `string'
PUBLIC	??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@ ; `string'
PUBLIC	??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@ ; `string'
PUBLIC	??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@DLNFLLPI@allocating?5public?5ID@	; `string'
PUBLIC	??_C@_06FDHFNJBJ@SYSTEM@			; `string'
PUBLIC	??_C@_06EKOLBGFH@PUBLIC@			; `string'
PUBLIC	??_C@_08IALHHCM@DELEGATE@			; `string'
PUBLIC	??_C@_06GKLBAPIO@ENTITY@			; `string'
PUBLIC	??_C@_07JGKBCNAA@DOCTYPE@			; `string'
PUBLIC	??_C@_08PMANIKNM@LINKTYPE@			; `string'
PUBLIC	??_C@_08NCDGCBCC@NOTATION@			; `string'
PUBLIC	??_C@_08DJOOGKO@SGMLDECL@			; `string'
PUBLIC	??_C@_08OLOPJDNG@DOCUMENT@			; `string'
PUBLIC	??_C@_07DIADFEPH@CATALOG@			; `string'
PUBLIC	??_C@_04NLLCBHDK@BASE@				; `string'
PUBLIC	??_C@_08ICLDDLKE@OVERRIDE@			; `string'
PUBLIC	??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@		; `string'
PUBLIC	??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@		; `string'
PUBLIC	??_C@_0M@BAPINHKH@libxml2?4dll@			; `string'
PUBLIC	??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@	; `string'
PUBLIC	??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@		; `string'
PUBLIC	??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@	; `string'
PUBLIC	??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@ ; `string'
PUBLIC	??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@ ; `string'
PUBLIC	??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@	; `string'
PUBLIC	??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@ ; `string'
PUBLIC	??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@ ; `string'
PUBLIC	??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@ ; `string'
PUBLIC	??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@ ; `string'
PUBLIC	??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	__imp__getenv:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	_xmlNewDtd:PROC
EXTRN	_xmlNewNs:PROC
EXTRN	_xmlFreeNs:PROC
EXTRN	_xmlNewDoc:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlSearchNsByHref:PROC
EXTRN	_xmlSetProp:PROC
EXTRN	_xmlSetNsProp:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlGetNsProp:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlSaveFormatFileTo:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashRemoveEntry:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashSize:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlParseDocument:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlNewRMutex:PROC
EXTRN	_xmlRMutexLock:PROC
EXTRN	_xmlRMutexUnlock:PROC
EXTRN	_xmlFreeRMutex:PROC
EXTRN	_xmlGetThreadId:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlNewInputStream:PROC
EXTRN	_inputPush:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_GetModuleHandleA@4:PROC
EXTRN	_GetModuleFileNameA@12:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlDebugCatalogs DD 01H DUP (?)
_xmlCatalogXMLFiles DD 01H DUP (?)
_xmlDefaultCatalog DD 01H DUP (?)
_xmlCatalogMutex DD 01H DUP (?)
_xmlCatalogInitialized DD 01H DUP (?)
?result@?1??xmlCatalogGetSystem@@9@9 DB 03e8H DUP (?)	; `xmlCatalogGetSystem'::`2'::result
?msg@?1??xmlCatalogGetSystem@@9@9 DD 01H DUP (?)	; `xmlCatalogGetSystem'::`2'::msg
?result@?1??xmlCatalogGetPublic@@9@9 DB 03e8H DUP (?)	; `xmlCatalogGetPublic'::`2'::result
?msg@?1??xmlCatalogGetPublic@@9@9 DD 01H DUP (?)	; `xmlCatalogGetPublic'::`2'::msg
_BSS	ENDS
;	COMDAT ??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@
CONST	SEGMENT
??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@ DB 'Use of depreca'
	DB	'ted xmlCatalogGetPublic() call', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@
CONST	SEGMENT
??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@ DB 'Use of depreca'
	DB	'ted xmlCatalogGetSystem() call', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@ DB 'Local Resolve: s'
	DB	'ysID %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@ DB 'Local Resolve: p'
	DB	'ubID %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@
CONST	SEGMENT
??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@ DB 'Local'
	DB	' Resolve: pubID %s sysID %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@ DB 'Adding documen'
	DB	't catalog %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@
CONST	SEGMENT
??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@ DB 'Setting catal'
	DB	'og preference to SYSTEM', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@
CONST	SEGMENT
??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@ DB 'Setting catal'
	DB	'og preference to PUBLIC', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@
CONST	SEGMENT
??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@ DB 'Allowing all catalogs', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@
CONST	SEGMENT
??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@ DB 'Allowing only'
	DB	' catalogs from the document', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@
CONST	SEGMENT
??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@ DB 'Allowing only '
	DB	'global catalogs', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@
CONST	SEGMENT
??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@ DB 'Disabling catalog usa'
	DB	'ge', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@
CONST	SEGMENT
??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@ DB 'Catalogs cleanup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@
CONST	SEGMENT
??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@ DB '\..\etc\catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BAPINHKH@libxml2?4dll@
CONST	SEGMENT
??_C@_0M@BAPINHKH@libxml2?4dll@ DB 'libxml2.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@
CONST	SEGMENT
??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@ DB 'XML_CATALOG_FILES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
CONST	SEGMENT
??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@ DB 'XML_DEBUG_CATALOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@ DB 'Resolve URI %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@ DB 'Resolve: sysID %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@ DB 'Resolve: pubID %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@ DB 'Resolve: '
	DB	'pubID %s sysID %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@ DB 'Resolve pubID %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@ DB 'Resolve sysID %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICLDDLKE@OVERRIDE@
CONST	SEGMENT
??_C@_08ICLDDLKE@OVERRIDE@ DB 'OVERRIDE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLLCBHDK@BASE@
CONST	SEGMENT
??_C@_04NLLCBHDK@BASE@ DB 'BASE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIADFEPH@CATALOG@
CONST	SEGMENT
??_C@_07DIADFEPH@CATALOG@ DB 'CATALOG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLOPJDNG@DOCUMENT@
CONST	SEGMENT
??_C@_08OLOPJDNG@DOCUMENT@ DB 'DOCUMENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJOOGKO@SGMLDECL@
CONST	SEGMENT
??_C@_08DJOOGKO@SGMLDECL@ DB 'SGMLDECL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCDGCBCC@NOTATION@
CONST	SEGMENT
??_C@_08NCDGCBCC@NOTATION@ DB 'NOTATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMANIKNM@LINKTYPE@
CONST	SEGMENT
??_C@_08PMANIKNM@LINKTYPE@ DB 'LINKTYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JGKBCNAA@DOCTYPE@
CONST	SEGMENT
??_C@_07JGKBCNAA@DOCTYPE@ DB 'DOCTYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKLBAPIO@ENTITY@
CONST	SEGMENT
??_C@_06GKLBAPIO@ENTITY@ DB 'ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IALHHCM@DELEGATE@
CONST	SEGMENT
??_C@_08IALHHCM@DELEGATE@ DB 'DELEGATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKOLBGFH@PUBLIC@
CONST	SEGMENT
??_C@_06EKOLBGFH@PUBLIC@ DB 'PUBLIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDHFNJBJ@SYSTEM@
CONST	SEGMENT
??_C@_06FDHFNJBJ@SYSTEM@ DB 'SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
CONST	SEGMENT
??_C@_0BF@DLNFLLPI@allocating?5public?5ID@ DB 'allocating public ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@ DB 'URN ID expanded to'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@
CONST	SEGMENT
??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@ DB 'URN ID %s ex'
	DB	'panded to NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@ DB 'System URN'
	DB	' ID expanded to %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@
CONST	SEGMENT
??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@ DB 'System U'
	DB	'RN ID %s expanded to NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@ DB 'Public URN'
	DB	' ID expanded to %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@
CONST	SEGMENT
??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@ DB 'Public U'
	DB	'RN ID %s expanded to NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@ DB 'Trying URI delegat'
	DB	'e %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@ DB 'Found URI match %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@ DB 'Trying public d'
	DB	'elegate %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@ DB 'Found public match '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@ DB 'Trying system d'
	DB	'elegate %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@ DB 'Using rewriting r'
	DB	'ule %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@
CONST	SEGMENT
??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@ DB 'Found'
	DB	' system match %s, using %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
CONST	SEGMENT
??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@ DB 'Detected r'
	DB	'ecursion in catalog %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
CONST	SEGMENT
??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@ DB 'Removing e'
	DB	'lement %s from catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@
CONST	SEGMENT
??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@ DB 'Adding elem'
	DB	'ent %s to catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@
CONST	SEGMENT
??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@ DB 'Updating '
	DB	'element %s to catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@
CONST	SEGMENT
??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@ DB 'Failed to'
	DB	' add unknown element %s to catalog', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@
CONST	SEGMENT
??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@ DB '%s added to file h'
	DB	'ash', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@
CONST	SEGMENT
??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@ DB '%s not found '
	DB	'in file hash', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@
CONST	SEGMENT
??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@ DB 'Found %s in file h'
	DB	'ash', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@
CONST	SEGMENT
??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@ DB 'File %s '
	DB	'is not an XML Catalog', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@ DB '%d Parsing catal'
	DB	'og %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@ DB 'Failed to par'
	DB	'se catalog %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@ DB 'Invali'
	DB	'd value for prefer: ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@ DB '%'
	DB	's entry ''%s'' broken ?: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@ DB 'Found %s: ''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@ DB 'Found %s: '
	DB	'''%s'' ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@ DB '%s entry lacks '''
	DB	'%s''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@
CONST	SEGMENT
??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@ DB 'allocating catalog data'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
CONST	SEGMENT
??_C@_0P@PCJPAHLM@out?5of?5memory?6@ DB 'out of memory', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOBDOKAH@urn?3publicid?3@
CONST	SEGMENT
??_C@_0O@NOBDOKAH@urn?3publicid?3@ DB 'urn:publicid:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@
CONST	SEGMENT
??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@ DB 'Converting S'
	DB	'GML catalog to XML', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
CONST	SEGMENT
??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@ DB 'urn:oasis:na'
	DB	'mes:tc:entity:xmlns:xml:catalog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@
CONST	SEGMENT
??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@ DB '-//OASIS//'
	DB	'DTD Entity Resolution XML Catalog V1.0//EN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@
CONST	SEGMENT
??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@ DB 'http://www'
	DB	'.oasis-open.org/committees/entity/release/1.0/catalog.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHAMNMJD@delegateURI@
CONST	SEGMENT
??_C@_0M@NHAMNMJD@delegateURI@ DB 'delegateURI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNKDCBAK@uriStartString@
CONST	SEGMENT
??_C@_0P@HNKDCBAK@uriStartString@ DB 'uriStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCFABNDK@rewriteURI@
CONST	SEGMENT
??_C@_0L@BCFABNDK@rewriteURI@ DB 'rewriteURI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEFGILEE@delegateSystem@
CONST	SEGMENT
??_C@_0P@EEFGILEE@delegateSystem@ DB 'delegateSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKBIFJL@publicIdStartString@
CONST	SEGMENT
??_C@_0BE@JKBIFJL@publicIdStartString@ DB 'publicIdStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNMIEEAK@delegatePublic@
CONST	SEGMENT
??_C@_0P@FNMIEEAK@delegatePublic@ DB 'delegatePublic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FCPDBOKG@rewritePrefix@
CONST	SEGMENT
??_C@_0O@FCPDBOKG@rewritePrefix@ DB 'rewritePrefix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DMCACPJB@systemIdStartString@
CONST	SEGMENT
??_C@_0BE@DMCACPJB@systemIdStartString@ DB 'systemIdStartString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CCMDBGLO@rewriteSystem@
CONST	SEGMENT
??_C@_0O@CCMDBGLO@rewriteSystem@ DB 'rewriteSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MILANEJE@systemId@
CONST	SEGMENT
??_C@_08MILANEJE@systemId@ DB 'systemId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GBBABMJN@uri@
CONST	SEGMENT
??_C@_03GBBABMJN@uri@ DB 'uri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNJBHAKA@publicId@
CONST	SEGMENT
??_C@_08KNJBHAKA@publicId@ DB 'publicId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NEJLBODN@prefer@
CONST	SEGMENT
??_C@_06NEJLBODN@prefer@ DB 'prefer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMAMIIF@public@
CONST	SEGMENT
??_C@_06EOMAMIIF@public@ DB 'public', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKOOEBPK@nextCatalog@
CONST	SEGMENT
??_C@_0M@IKOOEBPK@nextCatalog@ DB 'nextCatalog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@ DB ' "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEDFLLKD@?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_04OEDFLLKD@?$CC?$CFs?$CC@ DB '"%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KEOJDEKL@SGMLDECL?5@
CONST	SEGMENT
??_C@_09KEOJDEKL@SGMLDECL?5@ DB 'SGMLDECL ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKNPLMNA@DOCUMENT?5@
CONST	SEGMENT
??_C@_09PKNPLMNA@DOCUMENT?5@ DB 'DOCUMENT ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGGFEAEJ@CATALOG?5@
CONST	SEGMENT
??_C@_08LGGFEAEJ@CATALOG?5@ DB 'CATALOG ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDFDEPAH@BASE?5@
CONST	SEGMENT
??_C@_05FDFDEPAH@BASE?5@ DB 'BASE ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHFEEDDG@DELEGATE?5@
CONST	SEGMENT
??_C@_09KHFEEDDG@DELEGATE?5@ DB 'DELEGATE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBLMPJLL@SYSTEM?5@
CONST	SEGMENT
??_C@_07PBLMPJLL@SYSTEM?5@ DB 'SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GAMBALOD@PUBLIC?5@
CONST	SEGMENT
??_C@_07GAMBALOD@PUBLIC?5@ DB 'PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EADGFDGH@NOTATION?5@
CONST	SEGMENT
??_C@_09EADGFDGH@NOTATION?5@ DB 'NOTATION ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKBNLHNH@LINKTYPE?5@
CONST	SEGMENT
??_C@_09BKBNLHNH@LINKTYPE?5@ DB 'LINKTYPE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JFBCIFIP@DOCTYPE?5@
CONST	SEGMENT
??_C@_08JFBCIFIP@DOCTYPE?5@ DB 'DOCTYPE ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@
CONST	SEGMENT
??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@ DB 'ENTITY %%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPOODLIK@ENTITY?5@
CONST	SEGMENT
??_C@_07JPOODLIK@ENTITY?5@ DB 'ENTITY ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FCDBKBHD@allocating?5catalog@
CONST	SEGMENT
??_C@_0BD@FCDBKBHD@allocating?5catalog@ DB 'allocating catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
CONST	SEGMENT
??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@ DB 'Free catalog entry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@ DB 'Free catalog entry '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@
CONST	SEGMENT
??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@ DB 'allocating catalog ent'
	DB	'ry', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_XML_XML_DEFAULT_CATALOG DB 'file:///etc/xml/catalog', 00H
	ORG $+232
_xmlCatalogDefaultAllow DD 03H
_xmlCatalogDefaultPrefer DD 01H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlInitializeCatalogData
_TEXT	SEGMENT
_xmlInitializeCatalogData PROC				; COMDAT
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN1@xmlInitial

; 3091 :     if (xmlCatalogInitialized != 0)
; 3092 : 	return;
; 3093 : 
; 3094 :     if (getenv("XML_DEBUG_CATALOG"))

	push	OFFSET ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
	call	DWORD PTR __imp__getenv
	mov	ecx, DWORD PTR _xmlDebugCatalogs
	add	esp, 4
	test	eax, eax
	mov	edx, 1
	cmovne	ecx, edx
	mov	DWORD PTR _xmlDebugCatalogs, ecx

; 3095 : 	xmlDebugCatalogs = 1;
; 3096 :     xmlCatalogMutex = xmlNewRMutex();

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlCatalogMutex, eax

; 3097 : 
; 3098 :     xmlCatalogInitialized = 1;

	mov	DWORD PTR _xmlCatalogInitialized, 1
$LN1@xmlInitial:

; 3099 : }

	ret	0
_xmlInitializeCatalogData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSGMLResolve
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogSGMLResolve PROC				; COMDAT

; 2614 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	SHORT $LN6@xmlCatalog

; 2615 :     const xmlChar *ret = NULL;
; 2616 : 
; 2617 :     if (catal->sgml == NULL)
; 2618 : 	return(NULL);
; 2619 : 
; 2620 :     if (pubID != NULL)

	mov	eax, DWORD PTR _pubID$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlCatalog

; 2621 : 	ret = xmlCatalogGetSGMLPublic(catal->sgml, pubID);

	push	eax
	push	ecx
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8

; 2622 :     if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlCatalog
$LN8@xmlCatalog:

; 2623 : 	return(ret);
; 2624 :     if (sysID != NULL)

	mov	eax, DWORD PTR _sysID$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlCatalog

; 2625 : 	ret = xmlCatalogGetSGMLSystem(catal->sgml, sysID);

	push	eax
	push	DWORD PTR [esi+52]
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8

; 2626 :     if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 2627 : 	return(ret);
; 2628 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:
	pop	esi

; 2629 : }

	pop	ebp
	ret	0
_xmlCatalogSGMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSGMLSystem
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlCatalogGetSGMLSystem PROC				; COMDAT

; 2588 : xmlCatalogGetSGMLSystem(xmlHashTablePtr catal, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlCatalog

; 2589 :     xmlCatalogEntryPtr entry;
; 2590 : 
; 2591 :     if (catal == NULL)
; 2592 : 	return(NULL);
; 2593 : 
; 2594 :     entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, sysID);

	push	DWORD PTR _sysID$[ebp]
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 2595 :     if (entry == NULL)

	test	eax, eax
	je	SHORT $LN4@xmlCatalog

; 2596 : 	return(NULL);
; 2597 :     if (entry->type == SGML_CATA_SYSTEM)

	cmp	DWORD PTR [eax+12], 13			; 0000000dH
	jne	SHORT $LN4@xmlCatalog

; 2598 : 	return(entry->URL);

	mov	eax, DWORD PTR [eax+24]

; 2600 : }

	pop	ebp
	ret	0
$LN4@xmlCatalog:

; 2599 :     return(NULL);

	xor	eax, eax

; 2600 : }

	pop	ebp
	ret	0
_xmlCatalogGetSGMLSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSGMLPublic
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_xmlCatalogGetSGMLPublic PROC				; COMDAT

; 2551 : xmlCatalogGetSGMLPublic(xmlHashTablePtr catal, const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _catal$[ebp], 0
	je	SHORT $LN8@xmlCatalog

; 2552 :     xmlCatalogEntryPtr entry;
; 2553 :     xmlChar *normid;
; 2554 : 
; 2555 :     if (catal == NULL)
; 2556 : 	return(NULL);
; 2557 : 
; 2558 :     normid = xmlCatalogNormalizePublic(pubID);

	mov	edi, DWORD PTR _pubID$[ebp]
	push	edi
	call	_xmlCatalogNormalizePublic
	mov	esi, eax
	add	esp, 4

; 2559 :     if (normid != NULL)

	test	esi, esi
	je	SHORT $LN3@xmlCatalog

; 2560 :         pubID = (*normid != 0 ? normid : NULL);

	xor	edi, edi
	cmp	BYTE PTR [esi], 0
	cmovne	edi, esi
$LN3@xmlCatalog:

; 2561 : 
; 2562 :     entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, pubID);

	push	edi
	push	DWORD PTR _catal$[ebp]
	call	_xmlHashLookup
	mov	edi, eax
	add	esp, 8

; 2563 :     if (entry == NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlCatalog

; 2564 : 	if (normid != NULL)
; 2565 : 	    xmlFree(normid);
; 2566 : 	return(NULL);
; 2567 :     }
; 2568 :     if (entry->type == SGML_CATA_PUBLIC) {

	cmp	DWORD PTR [edi+12], 14			; 0000000eH
	jne	SHORT $LN6@xmlCatalog

; 2569 : 	if (normid != NULL)

	test	esi, esi
	je	SHORT $LN7@xmlCatalog

; 2570 : 	    xmlFree(normid);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCatalog:

; 2571 : 	return(entry->URL);

	mov	eax, DWORD PTR [edi+24]
	pop	edi

; 2576 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlCatalog:

; 2572 :     }
; 2573 :     if (normid != NULL)
; 2574 :         xmlFree(normid);
; 2575 :     return(NULL);

	test	esi, esi
	je	SHORT $LN8@xmlCatalog
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlCatalog:
	pop	edi
	xor	eax, eax

; 2576 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCatalogGetSGMLPublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalog
_TEXT	SEGMENT
_base$1$ = -8						; size = 4
_filename$1$ = -4					; size = 4
_normid$1$ = -4						; size = 4
_name$1 = -4						; size = 4
_catal$ = 8						; size = 4
_sysid$2 = 12						; size = 4
_value$ = 12						; size = 4
_file$ = 16						; size = 4
_super$ = 20						; size = 4
_xmlParseSGMLCatalog PROC				; COMDAT

; 2331 : 	            const char *file, int super) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __0FC738B4_catalog@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	test	esi, esi
	je	$LN15@xmlParseSG

; 2332 :     const xmlChar *cur = value;
; 2333 :     xmlChar *base = NULL;
; 2334 :     int res;
; 2335 : 
; 2336 :     if ((cur == NULL) || (file == NULL))

	mov	eax, DWORD PTR _file$[ebp]
	test	eax, eax
	je	$LN15@xmlParseSG

; 2338 :     base = xmlStrdup((const xmlChar *) file);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _base$1$[ebp], eax
	push	ebx
	push	edi
$LL2@xmlParseSG:

; 2339 : 
; 2340 :     while ((cur != NULL) && (cur[0] != 0)) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	$LN78@xmlParseSG
	npad	1
$LL4@xmlParseSG:

; 2341 : 	SKIP_BLANKS;

	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN17@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlParseSG
$LN17@xmlParseSG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlParseSG
$LN16@xmlParseSG:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL4@xmlParseSG
$LN5@xmlParseSG:

; 2342 : 	if (cur[0] == 0)

	test	al, al
	je	$LN78@xmlParseSG

; 2343 : 	    break;
; 2344 : 	if ((cur[0] == '-') && (cur[1] == '-')) {

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN19@xmlParseSG
	cmp	BYTE PTR [esi+1], al
	jne	SHORT $LN19@xmlParseSG

; 2165 :     while ((cur[0] != 0) && ((cur[0] != '-') || ((cur[1] != '-'))))

	mov	al, BYTE PTR [esi+2]
	add	esi, 2
	test	al, al
	je	SHORT $LN140@xmlParseSG
$LL98@xmlParseSG:
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN144@xmlParseSG
	cmp	BYTE PTR [esi+1], al
	je	SHORT $LN142@xmlParseSG
$LN144@xmlParseSG:
	mov	al, BYTE PTR [esi+1]

; 2166 : 	NEXT;

	inc	esi
	test	al, al
	jne	SHORT $LL98@xmlParseSG
$LN140@xmlParseSG:

; 2167 :     if (cur[0] == 0) {
; 2168 : 	return(NULL);

	xor	esi, esi
	jmp	$LN78@xmlParseSG
$LN142@xmlParseSG:

; 2169 :     }
; 2170 :     return(cur + 2);

	add	esi, 2

; 2345 : 	    cur = xmlParseSGMLCatalogComment(cur);
; 2346 : 	    if (cur == NULL) {

	jne	SHORT $LL2@xmlParseSG

; 2347 : 		/* error */
; 2348 : 		break;
; 2349 : 	    }
; 2350 : 	} else {

	jmp	$LN78@xmlParseSG
$LN19@xmlParseSG:

; 2351 : 	    xmlChar *sysid = NULL;
; 2352 : 	    xmlChar *name = NULL;
; 2353 : 	    xmlCatalogEntryType type = XML_CATA_NONE;
; 2354 : 
; 2355 : 	    cur = xmlParseSGMLCatalogName(cur, &name);

	lea	eax, DWORD PTR _name$1[ebp]
	mov	DWORD PTR _sysid$2[ebp], 0
	push	eax
	push	esi
	mov	DWORD PTR _name$1[ebp], 0
	xor	ebx, ebx
	call	_xmlParseSGMLCatalogName

; 2356 : 	    if (name == NULL) {

	mov	edi, DWORD PTR _name$1[ebp]
	add	esp, 8
	mov	esi, eax
	test	edi, edi
	je	$LN78@xmlParseSG

; 2357 : 		/* error */
; 2358 : 		break;
; 2359 : 	    }
; 2360 : 	    if (!IS_BLANK_CH(*cur)) {

	mov	cl, BYTE PTR [esi]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN25@xmlParseSG
	cmp	cl, 9
	jb	SHORT $LN24@xmlParseSG
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LL6@xmlParseSG
$LN24@xmlParseSG:
	cmp	cl, 13					; 0000000dH
	jne	$LN78@xmlParseSG
$LL6@xmlParseSG:

; 2361 : 		/* error */
; 2362 : 		break;
; 2363 : 	    }
; 2364 : 	    SKIP_BLANKS;

	cmp	cl, 32					; 00000020H
	je	SHORT $LN25@xmlParseSG
	cmp	cl, 9
	jb	SHORT $LN26@xmlParseSG
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN25@xmlParseSG
$LN26@xmlParseSG:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlParseSG
$LN25@xmlParseSG:
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL6@xmlParseSG
$LN7@xmlParseSG:

; 2365 : 	    if (xmlStrEqual(name, (const xmlChar *) "SYSTEM"))

	push	OFFSET ??_C@_06FDHFNJBJ@SYSTEM@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlParseSG

; 2366 :                 type = SGML_CATA_SYSTEM;

	mov	ebx, 13					; 0000000dH
$LN49@xmlParseSG:

; 2396 : 	    }
; 2397 : 	    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 2398 : 	    name = NULL;

	xor	edi, edi

; 2399 : 
; 2400 : 	    switch(type) {

	lea	eax, DWORD PTR [ebx-13]
	add	esp, 4
	mov	DWORD PTR _name$1[ebp], edi
	cmp	eax, 11					; 0000000bH
	ja	$LN73@xmlParseSG
	movzx	eax, BYTE PTR $LN146@xmlParseSG[eax]
	jmp	DWORD PTR $LN171@xmlParseSG[eax*4]
$LN27@xmlParseSG:

; 2367 : 	    else if (xmlStrEqual(name, (const xmlChar *) "PUBLIC"))

	push	OFFSET ??_C@_06EKOLBGFH@PUBLIC@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParseSG

; 2368 :                 type = SGML_CATA_PUBLIC;

	mov	ebx, 14					; 0000000eH
	jmp	SHORT $LN49@xmlParseSG
$LN29@xmlParseSG:

; 2369 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DELEGATE"))

	push	OFFSET ??_C@_08IALHHCM@DELEGATE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlParseSG

; 2370 :                 type = SGML_CATA_DELEGATE;

	mov	ebx, 20					; 00000014H
	jmp	SHORT $LN49@xmlParseSG
$LN31@xmlParseSG:

; 2371 : 	    else if (xmlStrEqual(name, (const xmlChar *) "ENTITY"))

	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlParseSG

; 2372 :                 type = SGML_CATA_ENTITY;

	mov	ebx, 15					; 0000000fH
	jmp	SHORT $LN49@xmlParseSG
$LN33@xmlParseSG:

; 2373 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DOCTYPE"))

	push	OFFSET ??_C@_07JGKBCNAA@DOCTYPE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlParseSG

; 2374 :                 type = SGML_CATA_DOCTYPE;

	mov	ebx, 17					; 00000011H
	jmp	$LN49@xmlParseSG
$LN35@xmlParseSG:

; 2375 : 	    else if (xmlStrEqual(name, (const xmlChar *) "LINKTYPE"))

	push	OFFSET ??_C@_08PMANIKNM@LINKTYPE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlParseSG

; 2376 :                 type = SGML_CATA_LINKTYPE;

	mov	ebx, 18					; 00000012H
	jmp	$LN49@xmlParseSG
$LN37@xmlParseSG:

; 2377 : 	    else if (xmlStrEqual(name, (const xmlChar *) "NOTATION"))

	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlParseSG

; 2378 :                 type = SGML_CATA_NOTATION;

	mov	ebx, 19					; 00000013H
	jmp	$LN49@xmlParseSG
$LN39@xmlParseSG:

; 2379 : 	    else if (xmlStrEqual(name, (const xmlChar *) "SGMLDECL"))

	push	OFFSET ??_C@_08DJOOGKO@SGMLDECL@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlParseSG

; 2380 :                 type = SGML_CATA_SGMLDECL;

	mov	ebx, 24					; 00000018H
	jmp	$LN49@xmlParseSG
$LN41@xmlParseSG:

; 2381 : 	    else if (xmlStrEqual(name, (const xmlChar *) "DOCUMENT"))

	push	OFFSET ??_C@_08OLOPJDNG@DOCUMENT@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xmlParseSG

; 2382 :                 type = SGML_CATA_DOCUMENT;

	mov	ebx, 23					; 00000017H
	jmp	$LN49@xmlParseSG
$LN43@xmlParseSG:

; 2383 : 	    else if (xmlStrEqual(name, (const xmlChar *) "CATALOG"))

	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlParseSG

; 2384 :                 type = SGML_CATA_CATALOG;

	mov	ebx, 22					; 00000016H
	jmp	$LN49@xmlParseSG
$LN45@xmlParseSG:

; 2385 : 	    else if (xmlStrEqual(name, (const xmlChar *) "BASE"))

	push	OFFSET ??_C@_04NLLCBHDK@BASE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlParseSG

; 2386 :                 type = SGML_CATA_BASE;

	mov	ebx, 21					; 00000015H
	jmp	$LN49@xmlParseSG
$LN47@xmlParseSG:

; 2387 : 	    else if (xmlStrEqual(name, (const xmlChar *) "OVERRIDE")) {

	push	OFFSET ??_C@_08ICLDDLKE@OVERRIDE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN49@xmlParseSG

; 2388 : 		xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree

; 2389 : 		cur = xmlParseSGMLCatalogName(cur, &name);

	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	push	esi
	call	_xmlParseSGMLCatalogName
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2390 : 		if (name == NULL) {

	mov	eax, DWORD PTR _name$1[ebp]
	test	eax, eax
	je	$LN78@xmlParseSG

; 2391 : 		    /* error */
; 2392 : 		    break;
; 2393 : 		}
; 2394 : 		xmlFree(name);

	push	eax

; 2395 : 		continue;

	jmp	$LN164@xmlParseSG
$LN51@xmlParseSG:

; 2401 : 		case SGML_CATA_ENTITY:
; 2402 : 		    if (*cur == '%')

	cmp	BYTE PTR [esi], 37			; 00000025H
	mov	eax, 16					; 00000010H
	cmove	ebx, eax
$LN52@xmlParseSG:

; 2403 : 			type = SGML_CATA_PENTITY;
; 2404 :                     /* Falls through. */
; 2405 : 		case SGML_CATA_PENTITY:
; 2406 : 		case SGML_CATA_DOCTYPE:
; 2407 : 		case SGML_CATA_LINKTYPE:
; 2408 : 		case SGML_CATA_NOTATION:
; 2409 : 		    cur = xmlParseSGMLCatalogName(cur, &name);

	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	push	esi
	call	_xmlParseSGMLCatalogName
	mov	esi, eax
	add	esp, 8

; 2410 : 		    if (cur == NULL) {

	test	esi, esi
	je	$LN150@xmlParseSG

; 2411 : 			/* error */
; 2412 : 			break;
; 2413 : 		    }
; 2414 : 		    if (!IS_BLANK_CH(*cur)) {

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN57@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN56@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LL10@xmlParseSG
$LN56@xmlParseSG:
	cmp	al, 13					; 0000000dH
	je	SHORT $LL10@xmlParseSG
	mov	edi, DWORD PTR _name$1[ebp]
	jmp	$LN73@xmlParseSG
	npad	7
$LL10@xmlParseSG:

; 2415 : 			/* error */
; 2416 : 			break;
; 2417 : 		    }
; 2418 : 		    SKIP_BLANKS;

	cmp	al, 32					; 00000020H
	je	SHORT $LN57@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN58@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN57@xmlParseSG
$LN58@xmlParseSG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN11@xmlParseSG
$LN57@xmlParseSG:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL10@xmlParseSG
$LN11@xmlParseSG:

; 2419 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);

	lea	eax, DWORD PTR _sysid$2[ebp]
	push	eax
	push	esi
	call	_xmlParseSGMLCatalogPubid

; 2420 : 		    if (cur == NULL) {

	mov	edi, DWORD PTR _name$1[ebp]

; 2421 : 			/* error */
; 2422 : 			break;
; 2423 : 		    }
; 2424 : 		    break;

	jmp	$LN169@xmlParseSG
$LN60@xmlParseSG:

; 2425 : 		case SGML_CATA_PUBLIC:
; 2426 : 		case SGML_CATA_SYSTEM:
; 2427 : 		case SGML_CATA_DELEGATE:
; 2428 : 		    cur = xmlParseSGMLCatalogPubid(cur, &name);

	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	push	esi
	call	_xmlParseSGMLCatalogPubid

; 2429 : 		    if (cur == NULL) {

	mov	edi, DWORD PTR _name$1[ebp]
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	$LN118@xmlParseSG

; 2430 : 			/* error */
; 2431 : 			break;
; 2432 : 		    }
; 2433 : 		    if (type != SGML_CATA_SYSTEM) {

	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN66@xmlParseSG

; 2434 : 		        xmlChar *normid;
; 2435 : 
; 2436 : 		        normid = xmlCatalogNormalizePublic(name);

	push	edi
	call	_xmlCatalogNormalizePublic
	add	esp, 4
	mov	DWORD PTR _normid$1$[ebp], eax

; 2437 : 		        if (normid != NULL) {

	test	eax, eax
	je	SHORT $LN66@xmlParseSG

; 2438 : 		            if (name != NULL)

	test	edi, edi
	je	SHORT $LN64@xmlParseSG

; 2439 : 		                xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _normid$1$[ebp]
	add	esp, 4
$LN64@xmlParseSG:

; 2440 : 		            if (*normid != 0)

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN65@xmlParseSG

; 2441 : 		                name = normid;

	mov	edi, eax
	jmp	SHORT $LN66@xmlParseSG
$LN65@xmlParseSG:

; 2442 : 		            else {
; 2443 : 		                xmlFree(normid);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2444 : 		                name = NULL;

	xor	edi, edi
$LN66@xmlParseSG:

; 2445 : 		            }
; 2446 : 		        }
; 2447 : 		    }
; 2448 : 		    if (!IS_BLANK_CH(*cur)) {

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN69@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN68@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LL12@xmlParseSG
$LN68@xmlParseSG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN73@xmlParseSG
	npad	1
$LL12@xmlParseSG:

; 2449 : 			/* error */
; 2450 : 			break;
; 2451 : 		    }
; 2452 : 		    SKIP_BLANKS;

	cmp	al, 32					; 00000020H
	je	SHORT $LN69@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN70@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN69@xmlParseSG
$LN70@xmlParseSG:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN72@xmlParseSG
$LN69@xmlParseSG:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL12@xmlParseSG
$LN72@xmlParseSG:

; 2477 : 		break;
; 2478 : 	    } else if (type == SGML_CATA_BASE) {

	lea	eax, DWORD PTR _sysid$2[ebp]
	push	eax
	push	esi
	call	_xmlParseSGMLCatalogPubid
$LN169@xmlParseSG:
	add	esp, 8
	mov	esi, eax
$LN73@xmlParseSG:
	test	esi, esi
	je	$LN118@xmlParseSG
	cmp	ebx, 21					; 00000015H
	jne	SHORT $LN79@xmlParseSG

; 2479 : 		if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	SHORT $LN81@xmlParseSG

; 2480 : 		    xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN81@xmlParseSG:

; 2481 : 		base = xmlStrdup(sysid);

	mov	ebx, DWORD PTR _sysid$2[ebp]
	push	ebx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _base$1$[ebp], eax
	jmp	$LN85@xmlParseSG
$LN79@xmlParseSG:

; 2482 : 	    } else if ((type == SGML_CATA_PUBLIC) ||

	cmp	ebx, 14					; 0000000eH
	je	SHORT $LN84@xmlParseSG
	cmp	ebx, 13					; 0000000dH
	je	SHORT $LN84@xmlParseSG

; 2497 : 		}
; 2498 : 
; 2499 : 	    } else if (type == SGML_CATA_CATALOG) {

	cmp	ebx, 22					; 00000016H
	jne	$LN158@xmlParseSG

; 2500 : 		if (super) {

	cmp	DWORD PTR _super$[ebp], 0
	je	SHORT $LN88@xmlParseSG

; 2501 : 		    xmlCatalogEntryPtr entry;
; 2502 : 
; 2503 : 		    entry = xmlNewCatalogEntry(type, sysid, NULL, NULL,

	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR _sysid$2[ebp]
	push	ebx
	call	_xmlNewCatalogEntry
	mov	ebx, eax

; 2504 : 			                       XML_CATA_PREFER_NONE, NULL);
; 2505 : 		    res = xmlHashAddEntry(catal->sgml, sysid, entry);

	mov	eax, DWORD PTR _catal$[ebp]
	push	ebx
	push	DWORD PTR _sysid$2[ebp]
	push	DWORD PTR [eax+52]
	call	_xmlHashAddEntry
	add	esp, 36					; 00000024H

; 2506 : 		    if (res < 0) {

	test	eax, eax
	jns	$LN158@xmlParseSG

; 2507 : 			xmlFreeCatalogEntry(entry, NULL);

	push	0
	push	ebx
	call	_xmlFreeCatalogEntry
	add	esp, 8

; 2508 : 		    }
; 2509 : 		} else {

	jmp	SHORT $LN158@xmlParseSG
$LN88@xmlParseSG:

; 2510 : 		    xmlChar *filename;
; 2511 : 
; 2512 : 		    filename = xmlBuildURI(sysid, base);

	push	DWORD PTR _base$1$[ebp]
	push	DWORD PTR _sysid$2[ebp]
	call	_xmlBuildURI
	mov	ebx, eax
	add	esp, 8

; 2513 : 		    if (filename != NULL) {

	test	ebx, ebx
	je	SHORT $LN158@xmlParseSG

; 2514 : 			xmlExpandCatalog(catal, (const char *)filename);

	push	ebx
	push	DWORD PTR _catal$[ebp]
	call	_xmlExpandCatalog

; 2515 : 			xmlFree(filename);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN158@xmlParseSG
$LN84@xmlParseSG:

; 2483 : 		       (type == SGML_CATA_SYSTEM)) {
; 2484 : 		xmlChar *filename;
; 2485 : 
; 2486 : 		filename = xmlBuildURI(sysid, base);

	push	DWORD PTR _base$1$[ebp]
	push	DWORD PTR _sysid$2[ebp]
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _filename$1$[ebp], eax

; 2487 : 		if (filename != NULL) {

	test	eax, eax
	je	SHORT $LN158@xmlParseSG

; 2488 : 		    xmlCatalogEntryPtr entry;
; 2489 : 
; 2490 : 		    entry = xmlNewCatalogEntry(type, name, filename,

	push	0
	push	0
	push	0
	push	eax
	push	edi
	push	ebx
	call	_xmlNewCatalogEntry
	mov	ebx, eax

; 2491 : 			                       NULL, XML_CATA_PREFER_NONE, NULL);
; 2492 : 		    res = xmlHashAddEntry(catal->sgml, name, entry);

	mov	eax, DWORD PTR _catal$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR [eax+52]
	call	_xmlHashAddEntry
	add	esp, 36					; 00000024H

; 2493 : 		    if (res < 0) {

	test	eax, eax
	jns	SHORT $LN86@xmlParseSG

; 2494 : 			xmlFreeCatalogEntry(entry, NULL);

	push	0
	push	ebx
	call	_xmlFreeCatalogEntry
	add	esp, 8
$LN86@xmlParseSG:

; 2495 : 		    }
; 2496 : 		    xmlFree(filename);

	push	DWORD PTR _filename$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN158@xmlParseSG:

; 2516 : 		    }
; 2517 : 		}
; 2518 : 	    }
; 2519 : 	    /*
; 2520 : 	     * drop anything else we won't handle it
; 2521 : 	     */
; 2522 : 	    if (name != NULL)

	mov	ebx, DWORD PTR _sysid$2[ebp]
$LN85@xmlParseSG:
	test	edi, edi
	je	SHORT $LN92@xmlParseSG

; 2523 : 		xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN92@xmlParseSG:

; 2524 : 	    if (sysid != NULL)

	test	ebx, ebx
	je	SHORT $LN93@xmlParseSG

; 2525 : 		xmlFree(sysid);

	push	ebx
$LN164@xmlParseSG:

; 2339 : 
; 2340 :     while ((cur != NULL) && (cur[0] != 0)) {

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN93@xmlParseSG:
	test	esi, esi
	jne	$LL2@xmlParseSG

; 2341 : 	SKIP_BLANKS;

	jmp	SHORT $LN78@xmlParseSG
$LN150@xmlParseSG:

; 2410 : 		    if (cur == NULL) {

	mov	edi, DWORD PTR _name$1[ebp]
$LN118@xmlParseSG:

; 2453 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);
; 2454 : 		    if (cur == NULL) {
; 2455 : 			/* error */
; 2456 : 			break;
; 2457 : 		    }
; 2458 : 		    break;
; 2459 : 		case SGML_CATA_BASE:
; 2460 : 		case SGML_CATA_CATALOG:
; 2461 : 		case SGML_CATA_DOCUMENT:
; 2462 : 		case SGML_CATA_SGMLDECL:
; 2463 : 		    cur = xmlParseSGMLCatalogPubid(cur, &sysid);
; 2464 : 		    if (cur == NULL) {
; 2465 : 			/* error */
; 2466 : 			break;
; 2467 : 		    }
; 2468 : 		    break;
; 2469 : 		default:
; 2470 : 		    break;
; 2471 : 	    }
; 2472 : 	    if (cur == NULL) {
; 2473 : 		if (name != NULL)

	test	edi, edi
	je	SHORT $LN77@xmlParseSG

; 2474 : 		    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN77@xmlParseSG:

; 2475 : 		if (sysid != NULL)

	mov	eax, DWORD PTR _sysid$2[ebp]
	test	eax, eax
	je	SHORT $LN78@xmlParseSG

; 2476 : 		    xmlFree(sysid);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN78@xmlParseSG:

; 2526 : 	}
; 2527 :     }
; 2528 :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN94@xmlParseSG

; 2529 : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN94@xmlParseSG:

; 2530 :     if (cur == NULL)

	test	esi, esi
	je	SHORT $LN15@xmlParseSG

; 2531 : 	return(-1);
; 2532 :     return(0);

	xor	eax, eax
	pop	esi

; 2533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlParseSG:

; 2337 :         return(-1);

	or	eax, -1
	pop	esi

; 2533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN171@xmlParseSG:
	DD	$LN60@xmlParseSG
	DD	$LN51@xmlParseSG
	DD	$LN52@xmlParseSG
	DD	$LN72@xmlParseSG
$LN146@xmlParseSG:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
_xmlParseSGMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlGetSGMLCatalogEntryType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_xmlGetSGMLCatalogEntryType PROC			; COMDAT

; 2289 : xmlGetSGMLCatalogEntryType(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	xor	esi, esi
	push	OFFSET ??_C@_06FDHFNJBJ@SYSTEM@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlGetSGML

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	mov	esi, 13					; 0000000dH
	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN2@xmlGetSGML:

; 2290 :     xmlCatalogEntryType type = XML_CATA_NONE;
; 2291 :     if (xmlStrEqual(name, (const xmlChar *) "SYSTEM"))
; 2292 : 	type = SGML_CATA_SYSTEM;
; 2293 :     else if (xmlStrEqual(name, (const xmlChar *) "PUBLIC"))

	push	OFFSET ??_C@_06EKOLBGFH@PUBLIC@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlGetSGML

; 2294 : 	type = SGML_CATA_PUBLIC;

	mov	esi, 14					; 0000000eH

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN4@xmlGetSGML:

; 2295 :     else if (xmlStrEqual(name, (const xmlChar *) "DELEGATE"))

	push	OFFSET ??_C@_08IALHHCM@DELEGATE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlGetSGML

; 2296 : 	type = SGML_CATA_DELEGATE;

	mov	esi, 20					; 00000014H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN6@xmlGetSGML:

; 2297 :     else if (xmlStrEqual(name, (const xmlChar *) "ENTITY"))

	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlGetSGML

; 2298 : 	type = SGML_CATA_ENTITY;

	mov	esi, 15					; 0000000fH

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN8@xmlGetSGML:

; 2299 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCTYPE"))

	push	OFFSET ??_C@_07JGKBCNAA@DOCTYPE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlGetSGML

; 2300 : 	type = SGML_CATA_DOCTYPE;

	mov	esi, 17					; 00000011H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN10@xmlGetSGML:

; 2301 :     else if (xmlStrEqual(name, (const xmlChar *) "LINKTYPE"))

	push	OFFSET ??_C@_08PMANIKNM@LINKTYPE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlGetSGML

; 2302 : 	type = SGML_CATA_LINKTYPE;

	mov	esi, 18					; 00000012H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN12@xmlGetSGML:

; 2303 :     else if (xmlStrEqual(name, (const xmlChar *) "NOTATION"))

	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlGetSGML

; 2304 : 	type = SGML_CATA_NOTATION;

	mov	esi, 19					; 00000013H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN14@xmlGetSGML:

; 2305 :     else if (xmlStrEqual(name, (const xmlChar *) "SGMLDECL"))

	push	OFFSET ??_C@_08DJOOGKO@SGMLDECL@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlGetSGML

; 2306 : 	type = SGML_CATA_SGMLDECL;

	mov	esi, 24					; 00000018H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN16@xmlGetSGML:

; 2307 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCUMENT"))

	push	OFFSET ??_C@_08OLOPJDNG@DOCUMENT@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlGetSGML

; 2308 : 	type = SGML_CATA_DOCUMENT;

	mov	esi, 23					; 00000017H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN18@xmlGetSGML:

; 2309 :     else if (xmlStrEqual(name, (const xmlChar *) "CATALOG"))

	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlGetSGML

; 2310 : 	type = SGML_CATA_CATALOG;

	mov	esi, 22					; 00000016H

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
$LN20@xmlGetSGML:

; 2311 :     else if (xmlStrEqual(name, (const xmlChar *) "BASE"))

	push	OFFSET ??_C@_04NLLCBHDK@BASE@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	mov	ecx, 21					; 00000015H
	test	eax, eax
	cmovne	esi, ecx

; 2312 : 	type = SGML_CATA_BASE;
; 2313 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 2314 : }

	pop	ebp
	ret	0
_xmlGetSGMLCatalogEntryType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogName
_TEXT	SEGMENT
_buf$ = -108						; size = 105
_cur$ = 8						; size = 4
tv585 = 11						; size = 1
_name$ = 12						; size = 4
_xmlParseSGMLCatalogName PROC				; COMDAT

; 2252 : xmlParseSGMLCatalogName(const xmlChar *cur, xmlChar **name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _name$[ebp]
	xor	esi, esi
	mov	edi, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], esi
	mov	al, BYTE PTR [edi]
	movzx	ebx, al
	mov	BYTE PTR tv585[ebp], al
	cmp	ebx, 256				; 00000100H
	jae	SHORT $LN14@xmlParseSG

; 2253 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 2254 :     int len = 0;
; 2255 :     int c;
; 2256 : 
; 2257 :     *name = NULL;
; 2258 : 
; 2259 :     /*
; 2260 :      * Handler for more complex cases
; 2261 :      */
; 2262 :     c = *cur;
; 2263 :     if ((!IS_LETTER(c) && (c != '_') && (c != ':'))) {

	cmp	ebx, 65					; 00000041H
	jb	SHORT $LN8@xmlParseSG
	cmp	ebx, 90					; 0000005aH
	jbe	SHORT $LL2@xmlParseSG
$LN8@xmlParseSG:
	cmp	ebx, 97					; 00000061H
	jb	SHORT $LN9@xmlParseSG
	cmp	ebx, 122				; 0000007aH
	jbe	SHORT $LL2@xmlParseSG
$LN9@xmlParseSG:
	cmp	ebx, 192				; 000000c0H
	jb	SHORT $LN11@xmlParseSG
	cmp	ebx, 214				; 000000d6H
	jbe	SHORT $LL2@xmlParseSG
$LN11@xmlParseSG:
	cmp	ebx, 216				; 000000d8H
	jb	SHORT $LN12@xmlParseSG
	cmp	ebx, 246				; 000000f6H
	jbe	SHORT $LL2@xmlParseSG
$LN12@xmlParseSG:
	cmp	ebx, 248				; 000000f8H
	jae	SHORT $LL2@xmlParseSG
	jmp	SHORT $LN48@xmlParseSG
$LN14@xmlParseSG:
	push	OFFSET _xmlIsBaseCharGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlParseSG
	mov	al, BYTE PTR tv585[ebp]
$LN48@xmlParseSG:
	cmp	al, 95					; 0000005fH
	je	SHORT $LL2@xmlParseSG
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN42@xmlParseSG
$LL2@xmlParseSG:

; 2264 : 	return(NULL);
; 2265 :     }
; 2266 : 
; 2267 :     while (((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 2268 :             (c == '.') || (c == '-') ||
; 2269 : 	    (c == '_') || (c == ':'))) {

	cmp	ebx, 65					; 00000041H
	jb	SHORT $LN22@xmlParseSG
	cmp	ebx, 90					; 0000005aH
	jbe	SHORT $LN5@xmlParseSG
$LN22@xmlParseSG:
	cmp	ebx, 97					; 00000061H
	jb	SHORT $LN23@xmlParseSG
	cmp	ebx, 122				; 0000007aH
	jbe	SHORT $LN5@xmlParseSG
$LN23@xmlParseSG:
	cmp	ebx, 192				; 000000c0H
	jb	SHORT $LN25@xmlParseSG
	cmp	ebx, 214				; 000000d6H
	jbe	SHORT $LN5@xmlParseSG
$LN25@xmlParseSG:
	cmp	ebx, 216				; 000000d8H
	jb	SHORT $LN26@xmlParseSG
	cmp	ebx, 246				; 000000f6H
	jbe	SHORT $LN5@xmlParseSG
$LN26@xmlParseSG:
	cmp	ebx, 248				; 000000f8H
	jae	SHORT $LN5@xmlParseSG
	lea	eax, DWORD PTR [ebx-48]
	cmp	eax, 9
	jbe	SHORT $LN5@xmlParseSG
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN5@xmlParseSG
	cmp	ebx, 45					; 0000002dH
	je	SHORT $LN5@xmlParseSG
	cmp	ebx, 95					; 0000005fH
	je	SHORT $LN5@xmlParseSG
	cmp	ebx, 58					; 0000003aH
	jne	SHORT $LN3@xmlParseSG
$LN5@xmlParseSG:

; 2270 : 	buf[len++] = c;
; 2271 : 	cur++;

	inc	edi
	mov	BYTE PTR _buf$[ebp+esi], bl
	inc	esi

; 2272 : 	c = *cur;

	movzx	ebx, BYTE PTR [edi]

; 2273 : 	if (len >= XML_MAX_NAMELEN)

	cmp	esi, 100				; 00000064H
	jl	SHORT $LL2@xmlParseSG
$LN42@xmlParseSG:
	pop	edi

; 2278 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlParseSG:

; 2274 : 	    return(NULL);
; 2275 :     }
; 2276 :     *name = xmlStrndup(buf, len);

	lea	eax, DWORD PTR _buf$[ebp]
	push	esi
	push	eax
	call	_xmlStrndup
	mov	ecx, DWORD PTR _name$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 2277 :     return(cur);

	mov	eax, edi
	pop	edi

; 2278 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseSGMLCatalogName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogPubid
_TEXT	SEGMENT
_len$1$ = -8						; size = 4
_size$1$ = -4						; size = 4
tv392 = 8						; size = 4
_cur$ = 8						; size = 4
_id$ = 12						; size = 4
_xmlParseSGMLCatalogPubid PROC				; COMDAT

; 2183 : xmlParseSGMLCatalogPubid(const xmlChar *cur, xmlChar **id) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _id$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _len$1$[ebp], 0
	mov	DWORD PTR _size$1$[ebp], 50		; 00000032H
	mov	DWORD PTR [eax], 0
	mov	al, BYTE PTR [esi]
	cmp	al, 34					; 00000022H
	jne	SHORT $LN4@xmlParseSG

; 2184 :     xmlChar *buf = NULL, *tmp;
; 2185 :     int len = 0;
; 2186 :     int size = 50;
; 2187 :     xmlChar stop;
; 2188 :     int count = 0;
; 2189 : 
; 2190 :     *id = NULL;
; 2191 : 
; 2192 :     if (RAW == '"') {
; 2193 :         NEXT;
; 2194 : 	stop = '"';

	inc	esi
	mov	bl, al
	jmp	SHORT $LN7@xmlParseSG
$LN4@xmlParseSG:

; 2195 :     } else if (RAW == '\'') {

	cmp	al, 39					; 00000027H
	jne	SHORT $LN6@xmlParseSG

; 2196 :         NEXT;

	inc	esi

; 2197 : 	stop = '\'';

	mov	bl, al

; 2198 :     } else {

	jmp	SHORT $LN7@xmlParseSG
$LN6@xmlParseSG:

; 2199 : 	stop = ' ';

	mov	bl, 32					; 00000020H
$LN7@xmlParseSG:

; 2200 :     }
; 2201 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	push	50					; 00000032H
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 2202 :     if (buf == NULL) {

	test	edi, edi
	jne	SHORT $LN42@xmlParseSG

; 226  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_CATALOG,

	push	OFFSET ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
	push	eax
	push	eax
	push	2
	push	2
	push	20					; 00000014H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2240 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseSG:
	xor	edx, edx
	npad	9
$LL2@xmlParseSG:

; 2203 :         xmlCatalogErrMemory("allocating public ID");
; 2204 : 	return(NULL);
; 2205 :     }
; 2206 :     while (IS_PUBIDCHAR_CH(*cur) || (*cur == '?')) {

	mov	cl, BYTE PTR [esi]
	movzx	eax, cl
	cmp	BYTE PTR _xmlIsPubidChar_tab[eax], 0
	jne	SHORT $LN9@xmlParseSG
	cmp	cl, 63					; 0000003fH
	jne	SHORT $LN26@xmlParseSG
$LN9@xmlParseSG:

; 2207 : 	if ((*cur == stop) && (stop != ' '))

	cmp	cl, bl
	jne	SHORT $LN10@xmlParseSG
	cmp	bl, 32					; 00000020H
	je	SHORT $LN32@xmlParseSG
$LN26@xmlParseSG:

; 2225 :     buf[len] = 0;

	mov	BYTE PTR [edx+edi], 0
	mov	al, BYTE PTR [esi]

; 2226 :     if (stop == ' ') {

	cmp	bl, 32					; 00000020H
	jne	SHORT $LN16@xmlParseSG

; 2227 : 	if (!IS_BLANK_CH(*cur)) {

	cmp	al, bl
	je	$LN17@xmlParseSG
	cmp	al, 9
	jb	SHORT $LN19@xmlParseSG
	cmp	al, 10					; 0000000aH
	jbe	$LN17@xmlParseSG
$LN19@xmlParseSG:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN17@xmlParseSG

; 2233 : 	    xmlFree(buf);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2240 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlParseSG:

; 2208 : 	    break;
; 2209 : 	if ((stop == ' ') && (IS_BLANK_CH(*cur)))

	cmp	bl, 32					; 00000020H
	jne	SHORT $LN11@xmlParseSG
$LN32@xmlParseSG:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN26@xmlParseSG
	cmp	cl, 9
	jb	SHORT $LN13@xmlParseSG
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN26@xmlParseSG
$LN13@xmlParseSG:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN26@xmlParseSG
$LN11@xmlParseSG:

; 2210 : 	    break;
; 2211 : 	if (len + 1 >= size) {

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR tv392[ebp], eax
	cmp	eax, DWORD PTR _size$1$[ebp]
	jl	SHORT $LN34@xmlParseSG

; 2212 : 	    size *= 2;

	mov	eax, DWORD PTR _size$1$[ebp]
	add	eax, eax

; 2213 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	push	eax
	push	edi
	mov	DWORD PTR _size$1$[ebp], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 2214 : 	    if (tmp == NULL) {

	test	eax, eax
	je	SHORT $LN27@xmlParseSG

; 2217 : 		return(NULL);
; 2218 : 	    }
; 2219 : 	    buf = tmp;

	mov	cl, BYTE PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR tv392[ebp]
	mov	edx, DWORD PTR _len$1$[ebp]
$LN34@xmlParseSG:

; 2220 : 	}
; 2221 : 	buf[len++] = *cur;

	mov	BYTE PTR [edx+edi], cl

; 2222 : 	count++;
; 2223 : 	NEXT;

	inc	esi
	mov	edx, eax
	mov	DWORD PTR _len$1$[ebp], edx

; 2224 :     }

	jmp	$LL2@xmlParseSG
$LN16@xmlParseSG:

; 2228 : 	    xmlFree(buf);
; 2229 : 	    return(NULL);
; 2230 : 	}
; 2231 :     } else {
; 2232 : 	if (*cur != stop) {

	cmp	al, bl
	je	SHORT $LN20@xmlParseSG

; 2233 : 	    xmlFree(buf);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2240 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlParseSG:

; 2234 : 	    return(NULL);
; 2235 : 	}
; 2236 : 	NEXT;

	inc	esi
$LN17@xmlParseSG:

; 2237 :     }
; 2238 :     *id = buf;

	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax], edi

; 2239 :     return(cur);

	mov	eax, esi
	pop	edi

; 2240 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlParseSG:

; 2215 : 		xmlCatalogErrMemory("allocating public ID");

	push	OFFSET ??_C@_0BF@DLNFLLPI@allocating?5public?5ID@
	call	_xmlCatalogErrMemory

; 2216 : 		xmlFree(buf);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 2240 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseSGMLCatalogPubid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseSGMLCatalogComment
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlParseSGMLCatalogComment PROC			; COMDAT

; 2161 : xmlParseSGMLCatalogComment(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	SHORT $LN1@xmlParseSG

; 2162 :     if ((cur[0] != '-') || (cur[1] != '-'))

	cmp	BYTE PTR [eax+1], 45			; 0000002dH
	jne	SHORT $LN1@xmlParseSG

; 2163 : 	return(cur);
; 2164 :     SKIP(2);
; 2165 :     while ((cur[0] != 0) && ((cur[0] != '-') || ((cur[1] != '-'))))

	mov	cl, BYTE PTR [eax+2]
	add	eax, 2
	test	cl, cl
	je	SHORT $LN16@xmlParseSG
$LL2@xmlParseSG:
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN14@xmlParseSG
	cmp	BYTE PTR [eax+1], cl
	je	SHORT $LN7@xmlParseSG
$LN14@xmlParseSG:
	mov	cl, BYTE PTR [eax+1]

; 2166 : 	NEXT;

	inc	eax
	test	cl, cl
	jne	SHORT $LL2@xmlParseSG
$LN16@xmlParseSG:

; 2167 :     if (cur[0] == 0) {
; 2168 : 	return(NULL);

	xor	eax, eax

; 2171 : }

	pop	ebp
	ret	0
$LN7@xmlParseSG:

; 2169 :     }
; 2170 :     return(cur + 2);

	add	eax, 2
$LN1@xmlParseSG:

; 2171 : }

	pop	ebp
	ret	0
_xmlParseSGMLCatalogComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogXMLResolveURI
_TEXT	SEGMENT
_delegates$1 = -216					; size = 200
_len$1$ = -16						; size = 4
_lenrewrite$1$ = -12					; size = 4
_haveNext$1$ = -8					; size = 4
_rewrite$1$ = -4					; size = 4
_nbList$1$ = 8						; size = 4
_haveDelegate$1$ = 8					; size = 4
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogXMLResolveURI PROC				; COMDAT

; 1865 : xmlCatalogXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	mov	DWORD PTR _rewrite$1$[ebp], ecx
	mov	DWORD PTR _haveNext$1$[ebp], edx
	mov	DWORD PTR _lenrewrite$1$[ebp], ecx
	test	esi, esi
	je	$LN133@xmlCatalog

; 1866 :     xmlChar *ret = NULL;
; 1867 :     xmlCatalogEntryPtr cur;
; 1868 :     int haveDelegate = 0;
; 1869 :     int haveNext = 0;
; 1870 :     xmlCatalogEntryPtr rewrite = NULL;
; 1871 :     int lenrewrite = 0, len;
; 1872 : 
; 1873 :     if (catal == NULL)
; 1874 : 	return(NULL);
; 1875 : 
; 1876 :     if (URI == NULL)

	mov	edi, DWORD PTR _URI$[ebp]
	test	edi, edi
	je	$LN133@xmlCatalog

; 1877 : 	return(NULL);
; 1878 : 
; 1879 :     if (catal->depth > MAX_CATAL_DEPTH) {

	cmp	DWORD PTR [esi+36], 50			; 00000032H
	jle	SHORT $LN15@xmlCatalog

; 1880 : 	xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,

	mov	eax, DWORD PTR [esi+16]

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	push	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
	push	ecx
	push	ecx
	push	ecx
	push	ecx
	push	eax
	push	ecx
	push	ecx
	push	2
	push	1654					; 00000676H
	push	20					; 00000014H
	push	ecx
	push	esi
	push	ecx
	push	ecx
	push	ecx
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 1987 : 	}
; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);
; 1991 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlCatalog:

; 1881 : 		      "Detected recursion in catalog %s\n",
; 1882 : 		      catal->name, NULL, NULL);
; 1883 : 	return(NULL);
; 1884 :     }
; 1885 : 
; 1886 :     /*
; 1887 :      * First tries steps 2/ 3/ 4/ if a system ID is provided.
; 1888 :      */
; 1889 :     cur = catal;

	mov	ebx, esi

; 1890 :     haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$1$[ebp], ecx
$LL2@xmlCatalog:

; 1891 :     while (cur != NULL) {
; 1892 : 	switch (cur->type) {

	mov	eax, DWORD PTR [ebx+12]
	add	eax, -3					; fffffffdH
	cmp	eax, 9
	ja	SHORT $LN139@xmlCatalog
	movzx	eax, BYTE PTR $LN134@xmlCatalog[eax]
	jmp	DWORD PTR $LN146@xmlCatalog[eax*4]
$LN16@xmlCatalog:

; 1893 : 	    case XML_CATA_URI:
; 1894 : 		if (xmlStrEqual(URI, cur->name)) {

	push	DWORD PTR [ebx+16]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN111@xmlCatalog
$LN137@xmlCatalog:

; 1915 : 		break;
; 1916 : 	    default:
; 1917 : 		break;
; 1918 : 	}
; 1919 : 	cur = cur->next;

	mov	edx, DWORD PTR _haveNext$1$[ebp]
$LN139@xmlCatalog:
	mov	ecx, DWORD PTR _rewrite$1$[ebp]
$LN140@xmlCatalog:
	mov	eax, DWORD PTR _haveDelegate$1$[ebp]
$LN24@xmlCatalog:
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	jne	SHORT $LL2@xmlCatalog

; 1920 :     }
; 1921 :     if (rewrite != NULL) {

	test	ecx, ecx
	je	$LN25@xmlCatalog

; 1922 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, ebx
	je	SHORT $LN26@xmlCatalog

; 1923 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR _rewrite$1$[ebp]
	mov	edi, eax
	mov	esi, DWORD PTR [esi+16]
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	edi, DWORD PTR _URI$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rewrite$1$[ebp]
$LN26@xmlCatalog:

; 1924 : 		    "Using rewriting rule %s\n", rewrite->name);
; 1925 : 	ret = xmlStrdup(rewrite->URL);

	push	DWORD PTR [ecx+24]
	call	_xmlStrdup
	add	esp, 4

; 1926 : 	if (ret != NULL)

	test	eax, eax
	je	$LN1@xmlCatalog

; 1927 : 	    ret = xmlStrcat(ret, &URI[lenrewrite]);

	mov	ecx, DWORD PTR _lenrewrite$1$[ebp]
	add	ecx, edi
	push	ecx
	push	eax
	call	_xmlStrcat
	add	esp, 8
	pop	edi

; 1987 : 	}
; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);
; 1991 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlCatalog:

; 1899 : 		}
; 1900 : 		break;
; 1901 : 	    case XML_CATA_REWRITE_URI:
; 1902 : 		len = xmlStrlen(cur->name);

	push	DWORD PTR [ebx+16]
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], eax

; 1903 : 		if ((len > lenrewrite) &&

	cmp	eax, DWORD PTR _lenrewrite$1$[ebp]
	jle	$LN137@xmlCatalog
	push	eax
	push	DWORD PTR [ebx+16]
	push	edi
	call	_xmlStrncmp
	mov	edx, DWORD PTR _haveNext$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN139@xmlCatalog

; 1904 : 		    (!xmlStrncmp(URI, cur->name, len))) {
; 1905 : 		    lenrewrite = len;

	mov	eax, DWORD PTR _len$1$[ebp]

; 1906 : 		    rewrite = cur;

	mov	ecx, ebx
	mov	DWORD PTR _lenrewrite$1$[ebp], eax
	mov	DWORD PTR _rewrite$1$[ebp], ecx

; 1907 : 		}
; 1908 : 		break;

	jmp	$LN140@xmlCatalog
$LN21@xmlCatalog:

; 1909 : 	    case XML_CATA_DELEGATE_URI:
; 1910 : 		if (!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))

	push	DWORD PTR [ebx+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [ebx+16]
	push	edi
	call	_xmlStrncmp
	mov	ecx, DWORD PTR _rewrite$1$[ebp]
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _haveNext$1$[ebp]
	test	eax, eax
	mov	eax, DWORD PTR _haveDelegate$1$[ebp]
	jne	$LN24@xmlCatalog

; 1911 : 		    haveDelegate++;

	inc	eax
	mov	DWORD PTR _haveDelegate$1$[ebp], eax

; 1912 : 		break;

	jmp	$LN24@xmlCatalog
$LN23@xmlCatalog:

; 1913 : 	    case XML_CATA_NEXT_CATALOG:
; 1914 : 		haveNext++;

	inc	edx
	mov	DWORD PTR _haveNext$1$[ebp], edx
	jmp	$LN139@xmlCatalog
$LN111@xmlCatalog:

; 1895 : 		    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN18@xmlCatalog

; 1896 : 			xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+16]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BE@BBLLMFBP@Found?5URI?5match?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
$LN18@xmlCatalog:

; 1897 : 				"Found URI match %s\n", cur->name);
; 1898 : 		    return(xmlStrdup(cur->URL));

	push	DWORD PTR [ebx+24]
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 1987 : 	}
; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);
; 1991 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlCatalog:

; 1928 : 	return(ret);
; 1929 :     }
; 1930 :     if (haveDelegate) {

	test	eax, eax
	je	$LN28@xmlCatalog

; 1931 : 	const xmlChar *delegates[MAX_DELEGATE];
; 1932 : 	int nbList = 0, i;

	xor	ebx, ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
	npad	2
$LL6@xmlCatalog:

; 1940 : 	    if (((cur->type == XML_CATA_DELEGATE_SYSTEM) ||
; 1941 : 	         (cur->type == XML_CATA_DELEGATE_URI)) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 9
	je	SHORT $LN123@xmlCatalog
	cmp	eax, 12					; 0000000cH
	jne	$LN37@xmlCatalog
$LN123@xmlCatalog:
	push	DWORD PTR [esi+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [esi+16]
	push	edi
	call	_xmlStrncmp
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN37@xmlCatalog

; 1942 : 		(!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))) {
; 1943 : 		for (i = 0;i < nbList;i++)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN32@xmlCatalog
	npad	12
$LL10@xmlCatalog:

; 1944 : 		    if (xmlStrEqual(cur->URL, delegates[i]))

	push	DWORD PTR _delegates$1[ebp+edi*4]
	push	DWORD PTR [esi+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN112@xmlCatalog

; 1942 : 		(!xmlStrncmp(URI, cur->name, xmlStrlen(cur->name)))) {
; 1943 : 		for (i = 0;i < nbList;i++)

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL10@xmlCatalog

; 1945 : 			break;
; 1946 : 		if (i < nbList) {

	jmp	SHORT $LN32@xmlCatalog
$LN112@xmlCatalog:
	cmp	edi, ebx
	jl	SHORT $LN37@xmlCatalog
$LN32@xmlCatalog:

; 1947 : 		    cur = cur->next;
; 1948 : 		    continue;
; 1949 : 		}
; 1950 : 		if (nbList < MAX_DELEGATE)

	cmp	ebx, 50					; 00000032H
	jge	SHORT $LN129@xmlCatalog

; 1951 : 		    delegates[nbList++] = cur->URL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _delegates$1[ebp+ebx*4], eax
	inc	ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
$LN129@xmlCatalog:

; 1952 : 
; 1953 : 		if (cur->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN142@xmlCatalog

; 1954 : 		    xmlFetchXMLCatalogFile(cur);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4

; 1955 : 		}
; 1956 : 		if (cur->children != NULL) {

	test	eax, eax
	je	SHORT $LN37@xmlCatalog
$LN142@xmlCatalog:

; 1957 : 		    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN36@xmlCatalog

; 1958 : 			xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [esi+24]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BI@FMDOMGLN@Trying?5URI?5delegate?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _nbList$1$[ebp]
$LN36@xmlCatalog:

; 1959 : 				"Trying URI delegate %s\n", cur->URL);
; 1960 : 		    ret = xmlCatalogListXMLResolveURI(

	push	DWORD PTR _URI$[ebp]
	push	eax
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8

; 1961 : 			    cur->children, URI);
; 1962 : 		    if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlCatalog
$LN37@xmlCatalog:

; 1933 : 
; 1934 : 	/*
; 1935 : 	 * Assume the entries have been sorted by decreasing substring
; 1936 : 	 * matches when the list was produced.
; 1937 : 	 */
; 1938 : 	cur = catal;
; 1939 : 	while (cur != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN132@xmlCatalog
	mov	edi, DWORD PTR _URI$[ebp]
	jmp	$LL6@xmlCatalog
$LN132@xmlCatalog:
	pop	edi

; 1987 : 	}
; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);
; 1991 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlCatalog:

; 1963 : 			return(ret);
; 1964 : 		}
; 1965 : 	    }
; 1966 : 	    cur = cur->next;
; 1967 : 	}
; 1968 : 	/*
; 1969 : 	 * Apply the cut algorithm explained in 4/
; 1970 : 	 */
; 1971 : 	return(XML_CATAL_BREAK);
; 1972 :     }
; 1973 :     if (haveNext) {

	test	edx, edx
	je	SHORT $LN133@xmlCatalog
$LL11@xmlCatalog:

; 1974 : 	cur = catal;
; 1975 : 	while (cur != NULL) {
; 1976 : 	    if (cur->type == XML_CATA_NEXT_CATALOG) {

	cmp	DWORD PTR [esi+12], 3
	jne	SHORT $LN42@xmlCatalog

; 1977 : 		if (cur->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN144@xmlCatalog

; 1978 : 		    xmlFetchXMLCatalogFile(cur);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4

; 1979 : 		}
; 1980 : 		if (cur->children != NULL) {

	test	eax, eax
	je	SHORT $LN42@xmlCatalog
$LN144@xmlCatalog:

; 1981 : 		    ret = xmlCatalogListXMLResolveURI(cur->children, URI);

	push	edi
	push	eax
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8

; 1982 : 		    if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlCatalog
$LN42@xmlCatalog:

; 1983 : 			return(ret);
; 1984 : 		}
; 1985 : 	    }
; 1986 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL11@xmlCatalog
$LN133@xmlCatalog:

; 1987 : 	}
; 1988 :     }
; 1989 : 
; 1990 :     return(NULL);
; 1991 : }

	xor	eax, eax
$LN1@xmlCatalog:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN146@xmlCatalog:
	DD	$LN23@xmlCatalog
	DD	$LN16@xmlCatalog
	DD	$LN19@xmlCatalog
	DD	$LN21@xmlCatalog
	DD	$LN139@xmlCatalog
$LN134@xmlCatalog:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
_xmlCatalogXMLResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogXMLResolve
_TEXT	SEGMENT
_delegates$1 = -220					; size = 200
_delegates$2 = -220					; size = 200
_haveDelegate$1$ = -20					; size = 4
_lenrewrite$1$ = -16					; size = 4
_len$1$ = -12						; size = 4
_cur$1$ = -12						; size = 4
tv807 = -8						; size = 4
_haveNext$1$ = -4					; size = 4
_nbList$1$ = 8						; size = 4
_nbList$1$ = 8						; size = 4
_rewrite$1$ = 8						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogXMLResolve PROC				; COMDAT

; 1633 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR [esi+36]
	lea	ebx, DWORD PTR [esi+36]
	mov	DWORD PTR _haveNext$1$[ebp], edx
	mov	DWORD PTR tv807[ebp], ebx
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN22@xmlCatalog

; 1634 :     xmlChar *ret = NULL;
; 1635 :     xmlCatalogEntryPtr cur;
; 1636 :     int haveDelegate = 0;
; 1637 :     int haveNext = 0;
; 1638 : 
; 1639 :     /*
; 1640 :      * protection against loops
; 1641 :      */
; 1642 :     if (catal->depth > MAX_CATAL_DEPTH) {
; 1643 : 	xmlCatalogErr(catal, NULL, XML_CATALOG_RECURSION,

	mov	eax, DWORD PTR [esi+16]

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	push	edx
	push	edx
	push	eax
	push	OFFSET ??_C@_0CC@DACKBEAO@Detected?5recursion?5in?5catalog?5?$CF@
	push	edx
	push	edx
	push	edx
	push	edx
	push	eax
	push	edx
	push	edx
	push	2
	push	1654					; 00000676H
	push	20					; 00000014H
	push	edx
	push	esi
	push	edx
	push	edx
	push	edx
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 1644 : 		      "Detected recursion in catalog %s\n",
; 1645 : 		      catal->name, NULL, NULL);
; 1646 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlCatalog:

; 1647 :     }
; 1648 :     catal->depth++;
; 1649 : 
; 1650 :     /*
; 1651 :      * First tries steps 2/ 3/ 4/ if a system ID is provided.
; 1652 :      */
; 1653 :     if (sysID != NULL) {

	mov	ecx, DWORD PTR _sysID$[ebp]
	inc	eax
	mov	DWORD PTR [ebx], eax
	push	edi
	test	ecx, ecx
	je	$LN268@xmlCatalog

; 1654 : 	xmlCatalogEntryPtr rewrite = NULL;

	xor	eax, eax

; 1655 : 	int lenrewrite = 0, len;
; 1656 : 	cur = catal;

	mov	edi, esi
	mov	DWORD PTR _rewrite$1$[ebp], eax
	mov	DWORD PTR _lenrewrite$1$[ebp], eax
	mov	DWORD PTR _cur$1$[ebp], edi

; 1657 : 	haveDelegate = 0;

	mov	DWORD PTR _haveDelegate$1$[ebp], eax
	npad	6
$LL2@xmlCatalog:

; 1658 : 	while (cur != NULL) {
; 1659 : 	    switch (cur->type) {

	mov	eax, DWORD PTR [edi+12]
	add	eax, -3					; fffffffdH
	cmp	eax, 6
	ja	SHORT $LN283@xmlCatalog
	jmp	DWORD PTR $LN292@xmlCatalog[eax*4]
$LN24@xmlCatalog:

; 1660 : 		case XML_CATA_SYSTEM:
; 1661 : 		    if (xmlStrEqual(sysID, cur->name)) {

	push	DWORD PTR [edi+16]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN235@xmlCatalog
$LN280@xmlCatalog:

; 1684 : 		    break;
; 1685 : 		default:
; 1686 : 		    break;
; 1687 : 	    }
; 1688 : 	    cur = cur->next;

	mov	ecx, DWORD PTR _sysID$[ebp]
	mov	edx, DWORD PTR _haveNext$1$[ebp]
$LN283@xmlCatalog:
	mov	eax, DWORD PTR _rewrite$1$[ebp]
$LN32@xmlCatalog:
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _cur$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LL2@xmlCatalog

; 1689 : 	}
; 1690 : 	if (rewrite != NULL) {

	test	eax, eax
	je	$LN33@xmlCatalog

; 1691 : 	    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, edi
	je	SHORT $LN34@xmlCatalog

; 1692 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	mov	eax, DWORD PTR _rewrite$1$[ebp]
	mov	esi, DWORD PTR [eax+16]
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BJ@CPNLKDBD@Using?5rewriting?5rule?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	eax, DWORD PTR _rewrite$1$[ebp]
	add	esp, 12					; 0000000cH
$LN34@xmlCatalog:

; 1693 : 			"Using rewriting rule %s\n", rewrite->name);
; 1694 : 	    ret = xmlStrdup(rewrite->URL);

	push	DWORD PTR [eax+24]
	call	_xmlStrdup
	add	esp, 4

; 1695 : 	    if (ret != NULL)

	test	eax, eax
	je	SHORT $LN35@xmlCatalog

; 1696 : 		ret = xmlStrcat(ret, &sysID[lenrewrite]);

	mov	ecx, DWORD PTR _sysID$[ebp]
	add	ecx, DWORD PTR _lenrewrite$1$[ebp]
	push	ecx
	push	eax
	call	_xmlStrcat
	add	esp, 8
$LN35@xmlCatalog:

; 1697 : 	    catal->depth--;

	dec	DWORD PTR [ebx]
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlCatalog:

; 1668 : 		    }
; 1669 : 		    break;
; 1670 : 		case XML_CATA_REWRITE_SYSTEM:
; 1671 : 		    len = xmlStrlen(cur->name);

	push	DWORD PTR [edi+16]
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], eax

; 1672 : 		    if ((len > lenrewrite) &&

	cmp	eax, DWORD PTR _lenrewrite$1$[ebp]
	jle	$LN280@xmlCatalog
	push	eax
	push	DWORD PTR [edi+16]
	push	DWORD PTR _sysID$[ebp]
	call	_xmlStrncmp
	mov	edx, DWORD PTR _haveNext$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _sysID$[ebp]
	test	eax, eax
	jne	$LN283@xmlCatalog

; 1673 : 			(!xmlStrncmp(sysID, cur->name, len))) {
; 1674 : 			lenrewrite = len;

	mov	eax, DWORD PTR _len$1$[ebp]
	mov	DWORD PTR _lenrewrite$1$[ebp], eax

; 1675 : 			rewrite = cur;

	mov	eax, edi
	mov	DWORD PTR _rewrite$1$[ebp], eax

; 1676 : 		    }
; 1677 : 		    break;

	jmp	$LN32@xmlCatalog
$LN29@xmlCatalog:

; 1678 : 		case XML_CATA_DELEGATE_SYSTEM:
; 1679 : 		    if (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))

	push	DWORD PTR [edi+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [edi+16]
	push	DWORD PTR _sysID$[ebp]
	call	_xmlStrncmp
	mov	edx, DWORD PTR _haveNext$1$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _sysID$[ebp]
	test	eax, eax
	mov	eax, DWORD PTR _rewrite$1$[ebp]
	jne	$LN32@xmlCatalog

; 1680 : 			haveDelegate++;

	inc	DWORD PTR _haveDelegate$1$[ebp]

; 1681 : 		    break;

	jmp	$LN32@xmlCatalog
$LN31@xmlCatalog:

; 1682 : 		case XML_CATA_NEXT_CATALOG:
; 1683 : 		    haveNext++;

	inc	edx
	mov	DWORD PTR _haveNext$1$[ebp], edx
	jmp	$LN283@xmlCatalog
$LN235@xmlCatalog:

; 1662 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN26@xmlCatalog

; 1663 : 			    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [edi+24]
	mov	ebx, eax
	mov	edi, DWORD PTR [edi+16]
	call	___xmlGenericErrorContext
	push	esi
	push	edi
	push	OFFSET ??_C@_0CB@ONCPCECG@Found?5system?5match?5?$CFs?0?5using?5?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	edi, DWORD PTR _cur$1$[ebp]
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR tv807[ebp]
$LN26@xmlCatalog:

; 1664 : 				    "Found system match %s, using %s\n",
; 1665 : 				            cur->name, cur->URL);
; 1666 : 			catal->depth--;

	dec	DWORD PTR [ebx]

; 1667 : 			return(xmlStrdup(cur->URL));

	push	DWORD PTR [edi+24]
	call	_xmlStrdup
	add	esp, 4
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlCatalog:

; 1698 : 	    return(ret);
; 1699 : 	}
; 1700 : 	if (haveDelegate) {

	cmp	DWORD PTR _haveDelegate$1$[ebp], 0
	je	$LN268@xmlCatalog

; 1701 : 	    const xmlChar *delegates[MAX_DELEGATE];
; 1702 : 	    int nbList = 0, i;

	xor	ebx, ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
$LL6@xmlCatalog:

; 1710 : 		if ((cur->type == XML_CATA_DELEGATE_SYSTEM) &&

	cmp	DWORD PTR [esi+12], 9
	jne	$LN44@xmlCatalog
	push	DWORD PTR [esi+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [esi+16]
	push	DWORD PTR _sysID$[ebp]
	call	_xmlStrncmp
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN44@xmlCatalog

; 1711 : 		    (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))) {
; 1712 : 		    for (i = 0;i < nbList;i++)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN39@xmlCatalog
	npad	12
$LL10@xmlCatalog:

; 1713 : 			if (xmlStrEqual(cur->URL, delegates[i]))

	push	DWORD PTR _delegates$2[ebp+edi*4]
	push	DWORD PTR [esi+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN236@xmlCatalog

; 1711 : 		    (!xmlStrncmp(sysID, cur->name, xmlStrlen(cur->name)))) {
; 1712 : 		    for (i = 0;i < nbList;i++)

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL10@xmlCatalog

; 1714 : 			    break;
; 1715 : 		    if (i < nbList) {

	jmp	SHORT $LN39@xmlCatalog
$LN236@xmlCatalog:
	cmp	edi, ebx
	jl	SHORT $LN44@xmlCatalog
$LN39@xmlCatalog:

; 1716 : 			cur = cur->next;
; 1717 : 			continue;
; 1718 : 		    }
; 1719 : 		    if (nbList < MAX_DELEGATE)

	cmp	ebx, 50					; 00000032H
	jge	SHORT $LN267@xmlCatalog

; 1720 : 			delegates[nbList++] = cur->URL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _delegates$2[ebp+ebx*4], eax
	inc	ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
$LN267@xmlCatalog:

; 1721 : 
; 1722 : 		    if (cur->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN286@xmlCatalog

; 1723 : 			xmlFetchXMLCatalogFile(cur);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4

; 1724 : 		    }
; 1725 : 		    if (cur->children != NULL) {

	test	eax, eax
	je	SHORT $LN44@xmlCatalog
$LN286@xmlCatalog:

; 1726 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN43@xmlCatalog

; 1727 : 			    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [esi+24]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BL@MIEFLOCA@Trying?5system?5delegate?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _nbList$1$[ebp]
$LN43@xmlCatalog:

; 1728 : 				    "Trying system delegate %s\n", cur->URL);
; 1729 : 			ret = xmlCatalogListXMLResolve(

	mov	ecx, DWORD PTR _sysID$[ebp]
	push	ecx
	push	0
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 1730 : 				cur->children, NULL, sysID);
; 1731 : 			if (ret != NULL) {

	test	eax, eax
	jne	$LN240@xmlCatalog
$LN44@xmlCatalog:

; 1703 : 
; 1704 : 	    /*
; 1705 : 	     * Assume the entries have been sorted by decreasing substring
; 1706 : 	     * matches when the list was produced.
; 1707 : 	     */
; 1708 : 	    cur = catal;
; 1709 : 	    while (cur != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL6@xmlCatalog

; 1812 : 			    return(ret);
; 1813 : 			}
; 1814 : 		    }
; 1815 : 		}
; 1816 : 		cur = cur->next;
; 1817 : 	    }
; 1818 : 	    /*
; 1819 : 	     * Apply the cut algorithm explained in 4/
; 1820 : 	     */
; 1821 : 	    catal->depth--;

	mov	ecx, DWORD PTR tv807[ebp]
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	dec	DWORD PTR [ecx]
	or	eax, -1
	mov	esp, ebp
	pop	ebp
	ret	0
$LN268@xmlCatalog:

; 1732 : 			    catal->depth--;
; 1733 : 			    return(ret);
; 1734 : 			}
; 1735 : 		    }
; 1736 : 		}
; 1737 : 		cur = cur->next;
; 1738 : 	    }
; 1739 : 	    /*
; 1740 : 	     * Apply the cut algorithm explained in 4/
; 1741 : 	     */
; 1742 : 	    catal->depth--;
; 1743 : 	    return(XML_CATAL_BREAK);
; 1744 : 	}
; 1745 :     }
; 1746 :     /*
; 1747 :      * Then tries 5/ 6/ if a public ID is provided
; 1748 :      */
; 1749 :     if (pubID != NULL) {

	mov	ecx, DWORD PTR _pubID$[ebp]
	test	ecx, ecx
	je	$LN54@xmlCatalog

; 1750 : 	cur = catal;

	mov	ebx, esi

; 1751 : 	haveDelegate = 0;

	xor	edi, edi
$LL11@xmlCatalog:

; 1753 : 	    switch (cur->type) {

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, 3
	je	SHORT $LN51@xmlCatalog
	sub	eax, 2
	je	SHORT $LN46@xmlCatalog
	sub	eax, 3
	jne	SHORT $LN52@xmlCatalog

; 1761 : 		    }
; 1762 : 		    break;
; 1763 : 		case XML_CATA_DELEGATE_PUBLIC:
; 1764 : 		    if (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)) &&

	push	DWORD PTR [ebx+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [ebx+16]
	push	DWORD PTR _pubID$[ebp]
	call	_xmlStrncmp
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN277@xmlCatalog
	cmp	DWORD PTR [ebx+28], 1
	mov	ecx, DWORD PTR _pubID$[ebp]
	jne	SHORT $LN52@xmlCatalog

; 1765 : 			(cur->prefer == XML_CATA_PREFER_PUBLIC))
; 1766 : 			haveDelegate++;

	inc	edi

; 1767 : 		    break;

	jmp	SHORT $LN52@xmlCatalog
$LN46@xmlCatalog:

; 1754 : 		case XML_CATA_PUBLIC:
; 1755 : 		    if (xmlStrEqual(pubID, cur->name)) {

	push	DWORD PTR [ebx+16]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN238@xmlCatalog
$LN277@xmlCatalog:

; 1771 : 		    break;
; 1772 : 		default:
; 1773 : 		    break;
; 1774 : 	    }
; 1775 : 	    cur = cur->next;

	mov	ecx, DWORD PTR _pubID$[ebp]
$LN52@xmlCatalog:
	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	je	SHORT $LN273@xmlCatalog

; 1752 : 	while (cur != NULL) {

	mov	edx, DWORD PTR _haveNext$1$[ebp]
	jmp	SHORT $LL11@xmlCatalog
$LN51@xmlCatalog:

; 1768 : 		case XML_CATA_NEXT_CATALOG:
; 1769 : 		    if (sysID == NULL)

	cmp	DWORD PTR _sysID$[ebp], 0
	jne	SHORT $LN52@xmlCatalog

; 1770 : 			haveNext++;

	inc	edx
	mov	DWORD PTR _haveNext$1$[ebp], edx
	jmp	SHORT $LN52@xmlCatalog
$LN238@xmlCatalog:

; 1756 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN48@xmlCatalog

; 1757 : 			    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+16]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BH@IJBOMLNL@Found?5public?5match?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
$LN48@xmlCatalog:

; 1758 : 				    "Found public match %s\n", cur->name);
; 1759 : 			catal->depth--;

	mov	ecx, DWORD PTR tv807[ebp]
	dec	DWORD PTR [ecx]

; 1760 : 			return(xmlStrdup(cur->URL));

	push	DWORD PTR [ebx+24]
	call	_xmlStrdup
	add	esp, 4
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN273@xmlCatalog:

; 1776 : 	}
; 1777 : 	if (haveDelegate) {

	test	edi, edi
	je	$LN281@xmlCatalog

; 1778 : 	    const xmlChar *delegates[MAX_DELEGATE];
; 1779 : 	    int nbList = 0, i;

	xor	ebx, ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
$LL15@xmlCatalog:

; 1787 : 		if ((cur->type == XML_CATA_DELEGATE_PUBLIC) &&
; 1788 : 		    (cur->prefer == XML_CATA_PREFER_PUBLIC) &&

	cmp	DWORD PTR [esi+12], 8
	jne	$LN62@xmlCatalog
	cmp	DWORD PTR [esi+28], 1
	jne	$LN62@xmlCatalog
	push	DWORD PTR [esi+16]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [esi+16]
	push	DWORD PTR _pubID$[ebp]
	call	_xmlStrncmp
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN62@xmlCatalog

; 1789 : 		    (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)))) {
; 1790 : 
; 1791 : 		    for (i = 0;i < nbList;i++)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN57@xmlCatalog
	npad	2
$LL19@xmlCatalog:

; 1792 : 			if (xmlStrEqual(cur->URL, delegates[i]))

	push	DWORD PTR _delegates$1[ebp+edi*4]
	push	DWORD PTR [esi+24]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN239@xmlCatalog

; 1789 : 		    (!xmlStrncmp(pubID, cur->name, xmlStrlen(cur->name)))) {
; 1790 : 
; 1791 : 		    for (i = 0;i < nbList;i++)

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL19@xmlCatalog

; 1793 : 			    break;
; 1794 : 		    if (i < nbList) {

	jmp	SHORT $LN57@xmlCatalog
$LN239@xmlCatalog:
	cmp	edi, ebx
	jl	SHORT $LN62@xmlCatalog
$LN57@xmlCatalog:

; 1795 : 			cur = cur->next;
; 1796 : 			continue;
; 1797 : 		    }
; 1798 : 		    if (nbList < MAX_DELEGATE)

	cmp	ebx, 50					; 00000032H
	jge	SHORT $LN269@xmlCatalog

; 1799 : 			delegates[nbList++] = cur->URL;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _delegates$1[ebp+ebx*4], eax
	inc	ebx
	mov	DWORD PTR _nbList$1$[ebp], ebx
$LN269@xmlCatalog:

; 1800 : 
; 1801 : 		    if (cur->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN288@xmlCatalog

; 1802 : 			xmlFetchXMLCatalogFile(cur);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4

; 1803 : 		    }
; 1804 : 		    if (cur->children != NULL) {

	test	eax, eax
	je	SHORT $LN62@xmlCatalog
$LN288@xmlCatalog:

; 1805 : 			if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN61@xmlCatalog

; 1806 : 			    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [esi+24]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BL@PNMEBECK@Trying?5public?5delegate?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _nbList$1$[ebp]
$LN61@xmlCatalog:

; 1807 : 				    "Trying public delegate %s\n", cur->URL);
; 1808 : 			ret = xmlCatalogListXMLResolve(

	mov	edi, DWORD PTR _pubID$[ebp]
	push	0
	push	edi
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 1809 : 				cur->children, pubID, NULL);
; 1810 : 			if (ret != NULL) {

	test	eax, eax
	jne	SHORT $LN240@xmlCatalog
$LN62@xmlCatalog:

; 1780 : 
; 1781 : 	    /*
; 1782 : 	     * Assume the entries have been sorted by decreasing substring
; 1783 : 	     * matches when the list was produced.
; 1784 : 	     */
; 1785 : 	    cur = catal;
; 1786 : 	    while (cur != NULL) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL15@xmlCatalog

; 1812 : 			    return(ret);
; 1813 : 			}
; 1814 : 		    }
; 1815 : 		}
; 1816 : 		cur = cur->next;
; 1817 : 	    }
; 1818 : 	    /*
; 1819 : 	     * Apply the cut algorithm explained in 4/
; 1820 : 	     */
; 1821 : 	    catal->depth--;

	mov	ecx, DWORD PTR tv807[ebp]
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	dec	DWORD PTR [ecx]
	or	eax, -1
	mov	esp, ebp
	pop	ebp
	ret	0
$LN240@xmlCatalog:

; 1811 : 			    catal->depth--;

	mov	ecx, DWORD PTR tv807[ebp]
	pop	edi
	pop	esi

; 1848 : }

	pop	ebx
	dec	DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN281@xmlCatalog:

; 1776 : 	}
; 1777 : 	if (haveDelegate) {

	mov	ebx, DWORD PTR tv807[ebp]
$LN54@xmlCatalog:

; 1822 : 	    return(XML_CATAL_BREAK);
; 1823 : 	}
; 1824 :     }
; 1825 :     if (haveNext) {

	cmp	DWORD PTR _haveNext$1$[ebp], 0
	je	SHORT $LN275@xmlCatalog

; 1826 : 	cur = catal;

	mov	edi, DWORD PTR _pubID$[ebp]
	npad	4
$LL20@xmlCatalog:

; 1827 : 	while (cur != NULL) {
; 1828 : 	    if (cur->type == XML_CATA_NEXT_CATALOG) {

	cmp	DWORD PTR [esi+12], 3
	jne	SHORT $LN69@xmlCatalog

; 1829 : 		if (cur->children == NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN290@xmlCatalog

; 1830 : 		    xmlFetchXMLCatalogFile(cur);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4

; 1831 : 		}
; 1832 : 		if (cur->children != NULL) {

	test	eax, eax
	je	SHORT $LN69@xmlCatalog
$LN290@xmlCatalog:

; 1833 : 		    ret = xmlCatalogListXMLResolve(cur->children, pubID, sysID);

	push	DWORD PTR _sysID$[ebp]
	push	edi
	push	eax
	call	_xmlCatalogListXMLResolve
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [ebx]

; 1834 : 		    if (ret != NULL) {

	test	ecx, ecx
	jne	SHORT $LN241@xmlCatalog

; 1837 : 		    } else if (catal->depth > MAX_CATAL_DEPTH) {

	cmp	eax, 50					; 00000032H
	jg	SHORT $LN242@xmlCatalog
$LN69@xmlCatalog:

; 1838 : 		        return(NULL);
; 1839 : 		    }
; 1840 : 		}
; 1841 : 	    }
; 1842 : 	    cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL20@xmlCatalog
$LN275@xmlCatalog:

; 1843 : 	}
; 1844 :     }
; 1845 : 
; 1846 :     catal->depth--;

	dec	DWORD PTR [ebx]
$LN242@xmlCatalog:
	pop	edi
	pop	esi

; 1847 :     return(NULL);

	xor	eax, eax

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN241@xmlCatalog:
	pop	edi

; 1835 : 			catal->depth--;

	dec	eax
	mov	DWORD PTR [ebx], eax

; 1836 : 			return(ret);

	mov	eax, ecx
	pop	esi

; 1848 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN292@xmlCatalog:
	DD	$LN31@xmlCatalog
	DD	$LN283@xmlCatalog
	DD	$LN283@xmlCatalog
	DD	$LN24@xmlCatalog
	DD	$LN27@xmlCatalog
	DD	$LN283@xmlCatalog
	DD	$LN29@xmlCatalog
_xmlCatalogXMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDelXMLCatalog
_TEXT	SEGMENT
tv285 = 8						; size = 4
_catal$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlDelXMLCatalog PROC					; COMDAT

; 1581 : xmlDelXMLCatalog(xmlCatalogEntryPtr catal, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _catal$[ebp]
	test	edi, edi
	je	$LN5@xmlDelXMLC

; 1582 :     xmlCatalogEntryPtr cur;
; 1583 :     int ret = 0;
; 1584 : 
; 1585 :     if ((catal == NULL) ||

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, 1
	je	SHORT $LN4@xmlDelXMLC
	cmp	eax, 2
	jne	$LN5@xmlDelXMLC
$LN4@xmlDelXMLC:

; 1589 :     if (value == NULL)

	mov	ebx, DWORD PTR _value$[ebp]
	test	ebx, ebx
	je	$LN5@xmlDelXMLC

; 1590 : 	return(-1);
; 1591 :     if (catal->children == NULL) {

	push	esi
	mov	esi, DWORD PTR [edi+8]
	test	esi, esi
	jne	SHORT $LL2@xmlDelXMLC

; 1592 : 	xmlFetchXMLCatalogFile(catal);

	push	edi
	call	_xmlFetchXMLCatalogFile
	mov	esi, DWORD PTR [edi+8]
	add	esp, 4

; 1593 :     }
; 1594 : 
; 1595 :     /*
; 1596 :      * Scan the children
; 1597 :      */
; 1598 :     cur = catal->children;
; 1599 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlDelXMLC
	npad	2
$LL2@xmlDelXMLC:

; 1600 : 	if (((cur->name != NULL) && (xmlStrEqual(value, cur->name))) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN10@xmlDelXMLC
	push	eax
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlDelXMLC
$LN10@xmlDelXMLC:
	push	DWORD PTR [esi+20]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlDelXMLC
$LN9@xmlDelXMLC:

; 1601 : 	    (xmlStrEqual(value, cur->value))) {
; 1602 : 	    if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN13@xmlDelXMLC

; 1603 : 		if (cur->name != NULL)

	mov	edi, DWORD PTR [esi+16]
	call	___xmlGenericError
	mov	DWORD PTR tv285[ebp], eax
	test	edi, edi
	je	SHORT $LN12@xmlDelXMLC

; 1604 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+16]
	jmp	SHORT $LN20@xmlDelXMLC
$LN12@xmlDelXMLC:

; 1605 : 			    "Removing element %s from catalog\n", cur->name);
; 1606 : 		else
; 1607 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+20]
$LN20@xmlDelXMLC:

; 1608 : 			    "Removing element %s from catalog\n", cur->value);
; 1609 : 	    }
; 1610 : 	    cur->type = XML_CATA_REMOVED;

	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv285[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
$LN13@xmlDelXMLC:
	mov	DWORD PTR [esi+12], -1
$LN8@xmlDelXMLC:

; 1611 : 	}
; 1612 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlDelXMLC
$LN3@xmlDelXMLC:

; 1613 :     }
; 1614 :     return(ret);

	pop	esi
	pop	edi
	xor	eax, eax

; 1615 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlDelXMLC:
	pop	edi

; 1586 : 	((catal->type != XML_CATA_CATALOG) &&
; 1587 : 	 (catal->type != XML_CATA_BROKEN_CATALOG)))
; 1588 : 	return(-1);

	or	eax, -1

; 1615 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlDelXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlAddXMLCatalog
_TEXT	SEGMENT
$T1 = -4						; size = 4
_catal$ = 8						; size = 4
_type$ = 12						; size = 4
_orig$ = 16						; size = 4
_replace$ = 20						; size = 4
_xmlAddXMLCatalog PROC					; COMDAT

; 1504 : 	      const xmlChar *orig, const xmlChar *replace) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	test	esi, esi
	je	$LN5@xmlAddXMLC

; 1505 :     xmlCatalogEntryPtr cur;
; 1506 :     xmlCatalogEntryType typ;
; 1507 :     int doregister = 0;
; 1508 : 
; 1509 :     if ((catal == NULL) ||

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 1
	je	SHORT $LN4@xmlAddXMLC
	cmp	eax, 2
	jne	$LN5@xmlAddXMLC
$LN4@xmlAddXMLC:

; 1510 : 	((catal->type != XML_CATA_CATALOG) &&
; 1511 : 	 (catal->type != XML_CATA_BROKEN_CATALOG)))
; 1512 : 	return(-1);
; 1513 :     if (catal->children == NULL) {

	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T1[ebp], edi
	test	edi, edi
	jne	SHORT $LN6@xmlAddXMLC

; 1514 : 	xmlFetchXMLCatalogFile(catal);

	push	esi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
$LN6@xmlAddXMLC:

; 1109 :     if (xmlStrEqual(name, (const xmlChar *) "system"))

	mov	ebx, DWORD PTR _type$[ebp]
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlAddXMLC

; 1110 : 	type = XML_CATA_SYSTEM;

	mov	ebx, 6
	jmp	$LN8@xmlAddXMLC
$LN23@xmlAddXMLC:

; 1111 :     else if (xmlStrEqual(name, (const xmlChar *) "public"))

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlAddXMLC

; 1112 : 	type = XML_CATA_PUBLIC;

	mov	ebx, 5
	jmp	$LN8@xmlAddXMLC
$LN25@xmlAddXMLC:

; 1113 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteSystem"))

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlAddXMLC

; 1114 : 	type = XML_CATA_REWRITE_SYSTEM;

	mov	ebx, 7
	jmp	$LN8@xmlAddXMLC
$LN27@xmlAddXMLC:

; 1115 :     else if (xmlStrEqual(name, (const xmlChar *) "delegatePublic"))

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlAddXMLC

; 1116 : 	type = XML_CATA_DELEGATE_PUBLIC;

	mov	ebx, 8
	jmp	$LN8@xmlAddXMLC
$LN29@xmlAddXMLC:

; 1117 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateSystem"))

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlAddXMLC

; 1118 : 	type = XML_CATA_DELEGATE_SYSTEM;

	mov	ebx, 9
	jmp	SHORT $LN8@xmlAddXMLC
$LN31@xmlAddXMLC:

; 1119 :     else if (xmlStrEqual(name, (const xmlChar *) "uri"))

	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlAddXMLC

; 1120 : 	type = XML_CATA_URI;

	mov	ebx, 10					; 0000000aH
	jmp	SHORT $LN8@xmlAddXMLC
$LN33@xmlAddXMLC:

; 1121 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteURI"))

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xmlAddXMLC

; 1122 : 	type = XML_CATA_REWRITE_URI;

	mov	ebx, 11					; 0000000bH
	jmp	SHORT $LN8@xmlAddXMLC
$LN35@xmlAddXMLC:

; 1123 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateURI"))

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@xmlAddXMLC

; 1124 : 	type = XML_CATA_DELEGATE_URI;

	mov	ebx, 12					; 0000000cH
	jmp	SHORT $LN8@xmlAddXMLC
$LN37@xmlAddXMLC:

; 1125 :     else if (xmlStrEqual(name, (const xmlChar *) "nextCatalog"))

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlAddXMLC

; 1126 : 	type = XML_CATA_NEXT_CATALOG;

	mov	ebx, 3
	jmp	SHORT $LN8@xmlAddXMLC
$LN39@xmlAddXMLC:

; 1127 :     else if (xmlStrEqual(name, (const xmlChar *) "catalog"))

	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN49@xmlAddXMLC

; 1128 : 	type = XML_CATA_CATALOG;

	mov	ebx, 1
$LN8@xmlAddXMLC:

; 1523 : 		    "Failed to add unknown element %s to catalog\n", type);
; 1524 : 	return(-1);
; 1525 :     }
; 1526 : 
; 1527 :     cur = catal->children;

	mov	edi, DWORD PTR [esi+8]

; 1528 :     /*
; 1529 :      * Might be a simple "update in place"
; 1530 :      */
; 1531 :     if (cur != NULL) {

	test	edi, edi
	je	SHORT $LN50@xmlAddXMLC
$LL2@xmlAddXMLC:

; 1532 : 	while (cur != NULL) {
; 1533 : 	    if ((orig != NULL) && (cur->type == typ) &&

	mov	eax, DWORD PTR _orig$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlAddXMLC
	cmp	DWORD PTR [edi+12], ebx
	jne	SHORT $LN11@xmlAddXMLC
	push	DWORD PTR [edi+16]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@xmlAddXMLC
$LN11@xmlAddXMLC:

; 1545 : 	    }
; 1546 : 	    if (cur->next == NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN50@xmlAddXMLC

; 1547 : 		break;
; 1548 : 	    cur = cur->next;

	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL2@xmlAddXMLC
$LN50@xmlAddXMLC:

; 1549 : 	}
; 1550 :     }
; 1551 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN16@xmlAddXMLC

; 1552 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@CBJLKDGJ@Adding?5element?5?$CFs?5to?5catalog?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _catal$[ebp]
	add	esp, 12					; 0000000cH
$LN16@xmlAddXMLC:

; 1553 : 		"Adding element %s to catalog\n", type);
; 1554 :     if (cur == NULL)

	push	0
	push	DWORD PTR [esi+28]
	push	0
	push	DWORD PTR _replace$[ebp]
	push	DWORD PTR _orig$[ebp]
	push	ebx
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	test	edi, edi
	jne	SHORT $LN17@xmlAddXMLC

; 1555 : 	catal->children = xmlNewCatalogEntry(typ, orig, replace,

	mov	DWORD PTR [esi+8], eax
	jmp	SHORT $LN18@xmlAddXMLC
$LN44@xmlAddXMLC:

; 1534 : 		(xmlStrEqual(orig, cur->name))) {
; 1535 : 		if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN12@xmlAddXMLC

; 1536 : 		    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@DFBONGAG@Updating?5element?5?$CFs?5to?5catalog?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN12@xmlAddXMLC:

; 1537 : 			    "Updating element %s to catalog\n", type);
; 1538 : 		if (cur->value != NULL)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN13@xmlAddXMLC

; 1539 : 		    xmlFree(cur->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlAddXMLC:

; 1540 : 		if (cur->URL != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN14@xmlAddXMLC

; 1541 : 		    xmlFree(cur->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlAddXMLC:

; 1542 : 		cur->value = xmlStrdup(replace);

	mov	ebx, DWORD PTR _replace$[ebp]
	push	ebx
	call	_xmlStrdup

; 1543 : 		cur->URL = xmlStrdup(replace);

	push	ebx
	mov	DWORD PTR [edi+20], eax
	call	_xmlStrdup
	add	esp, 8
	mov	DWORD PTR [edi+24], eax

; 1544 : 		return(0);

	xor	eax, eax
	pop	edi

; 1565 :     }
; 1566 : 
; 1567 :     return(0);
; 1568 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlAddXMLC:

; 1556 : 		                             NULL, catal->prefer, NULL);
; 1557 :     else
; 1558 : 	cur->next = xmlNewCatalogEntry(typ, orig, replace,

	mov	DWORD PTR [edi], eax
$LN18@xmlAddXMLC:

; 1559 : 		                       NULL, catal->prefer, NULL);
; 1560 :     if (doregister) {

	cmp	DWORD PTR $T1[ebp], 0
	jne	SHORT $LN20@xmlAddXMLC

; 1561 :         catal->type = XML_CATA_CATALOG;
; 1562 : 	cur = (xmlCatalogEntryPtr)xmlHashLookup(xmlCatalogXMLFiles, catal->URL);

	push	DWORD PTR [esi+24]
	mov	DWORD PTR [esi+12], 1
	push	DWORD PTR _xmlCatalogXMLFiles
	call	_xmlHashLookup
	add	esp, 8

; 1563 : 	if (cur != NULL)

	test	eax, eax
	je	SHORT $LN20@xmlAddXMLC

; 1564 : 	    cur->children = catal->children;

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
$LN20@xmlAddXMLC:

; 1565 :     }
; 1566 : 
; 1567 :     return(0);
; 1568 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlAddXMLC:

; 1515 :     }
; 1516 :     if (catal->children == NULL)
; 1517 : 	doregister = 1;
; 1518 : 
; 1519 :     typ = xmlGetXMLCatalogEntryType(type);
; 1520 :     if (typ == XML_CATA_NONE) {
; 1521 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN5@xmlAddXMLC

; 1522 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0CN@LDFDKPIL@Failed?5to?5add?5unknown?5element?5?$CF@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN5@xmlAddXMLC:

; 1565 :     }
; 1566 : 
; 1567 :     return(0);
; 1568 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFetchXMLCatalogFile
_TEXT	SEGMENT
$T1 = 8							; size = 4
_doc$2$ = 8						; size = 4
_catal$ = 8						; size = 4
_xmlFetchXMLCatalogFile PROC				; COMDAT

; 1414 : xmlFetchXMLCatalogFile(xmlCatalogEntryPtr catal) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _catal$[ebp]
	test	ebx, ebx
	je	$LN19@xmlFetchXM

; 1415 :     xmlCatalogEntryPtr doc;
; 1416 : 
; 1417 :     if (catal == NULL)
; 1418 : 	return(-1);
; 1419 :     if (catal->URL == NULL)

	cmp	DWORD PTR [ebx+24], 0
	je	$LN19@xmlFetchXM

; 1421 : 
; 1422 :     /*
; 1423 :      * lock the whole catalog for modification
; 1424 :      */
; 1425 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock
	add	esp, 4

; 1426 :     if (catal->children != NULL) {

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN4@xmlFetchXM

; 1427 : 	/* Okay someone else did it in the meantime */
; 1428 : 	xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexUnlock
	add	esp, 4

; 1429 : 	return(0);

	xor	eax, eax
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN4@xmlFetchXM:

; 1430 :     }
; 1431 : 
; 1432 :     if (xmlCatalogXMLFiles != NULL) {

	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN10@xmlFetchXM

; 1433 : 	doc = (xmlCatalogEntryPtr)

	push	DWORD PTR [ebx+24]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 1434 : 	    xmlHashLookup(xmlCatalogXMLFiles, catal->URL);
; 1435 : 	if (doc != NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlFetchXM

; 1436 : 	    if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN7@xmlFetchXM

; 1437 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+24]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BH@CAELNCCF@Found?5?$CFs?5in?5file?5hash?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	eax, DWORD PTR $T1[ebp]
	add	esp, 12					; 0000000cH
$LN7@xmlFetchXM:

; 1438 : 		    "Found %s in file hash\n", catal->URL);
; 1439 : 
; 1440 : 	    if (catal->type == XML_CATA_CATALOG)

	cmp	DWORD PTR [ebx+12], 1
	jne	SHORT $LN8@xmlFetchXM

; 1441 : 		catal->children = doc->children;

	mov	eax, DWORD PTR [eax+8]
$LN8@xmlFetchXM:

; 1442 : 	    else
; 1443 : 		catal->children = doc;
; 1444 : 	    catal->dealloc = 0;

	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+32], 0

; 1445 : 	    xmlRMutexUnlock(xmlCatalogMutex);
; 1446 : 	    return(0);

	jmp	$LN15@xmlFetchXM
$LN6@xmlFetchXM:

; 1447 : 	}
; 1448 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN10@xmlFetchXM

; 1449 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+24]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BL@NEIEMMME@?$CFs?5not?5found?5in?5file?5hash?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
$LN10@xmlFetchXM:

; 1450 : 		"%s not found in file hash\n", catal->URL);
; 1451 :     }
; 1452 : 
; 1453 :     /*
; 1454 :      * Fetch and parse. Note that xmlParseXMLCatalogFile does not
; 1455 :      * use the existing catalog, there is no recursion allowed at
; 1456 :      * that level.
; 1457 :      */
; 1458 :     doc = xmlParseXMLCatalogFile(catal->prefer, catal->URL);

	push	DWORD PTR [ebx+24]
	push	DWORD PTR [ebx+28]
	call	_xmlParseXMLCatalogFile
	add	esp, 8
	mov	DWORD PTR _doc$2$[ebp], eax

; 1459 :     if (doc == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlFetchXM

; 1460 : 	catal->type = XML_CATA_BROKEN_CATALOG;
; 1461 : 	xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	DWORD PTR [ebx+12], 2
	call	_xmlRMutexUnlock
	add	esp, 4

; 1462 : 	return(-1);

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN11@xmlFetchXM:

; 1463 :     }
; 1464 : 
; 1465 :     if (catal->type == XML_CATA_CATALOG)

	cmp	DWORD PTR [ebx+12], 1
	jne	SHORT $LN12@xmlFetchXM

; 1466 : 	catal->children = doc->children;

	mov	ecx, DWORD PTR [eax+8]
	jmp	SHORT $LN13@xmlFetchXM
$LN12@xmlFetchXM:

; 1467 :     else
; 1468 : 	catal->children = doc;

	mov	ecx, eax
$LN13@xmlFetchXM:

; 1469 : 
; 1470 :     doc->dealloc = 1;

	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [eax+32], 1

; 1471 : 
; 1472 :     if (xmlCatalogXMLFiles == NULL)

	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	test	eax, eax
	jne	SHORT $LN18@xmlFetchXM

; 1473 : 	xmlCatalogXMLFiles = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _xmlCatalogXMLFiles, eax

; 1474 :     if (xmlCatalogXMLFiles != NULL) {

	test	eax, eax
	je	SHORT $LN15@xmlFetchXM
$LN18@xmlFetchXM:

; 1475 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN16@xmlFetchXM

; 1476 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+24]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BH@KIEODICD@?$CFs?5added?5to?5file?5hash?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	add	esp, 12					; 0000000cH
$LN16@xmlFetchXM:

; 1477 : 		"%s added to file hash\n", catal->URL);
; 1478 : 	xmlHashAddEntry(xmlCatalogXMLFiles, catal->URL, doc);

	push	DWORD PTR _doc$2$[ebp]
	push	DWORD PTR [ebx+24]
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
$LN15@xmlFetchXM:

; 1479 :     }
; 1480 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexUnlock
	add	esp, 4

; 1481 :     return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
$LN19@xmlFetchXM:

; 1420 : 	return(-1);

	or	eax, -1
	pop	ebx

; 1482 : }

	pop	ebp
	ret	0
_xmlFetchXMLCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogNode
_TEXT	SEGMENT
_base$1$ = -4						; size = 4
_pref$1$ = 8						; size = 4
_entry$1$ = 8						; size = 4
_cur$ = 8						; size = 4
_prefer$ = 12						; size = 4
_parent$ = 16						; size = 4
_cgroup$ = 20						; size = 4
_xmlParseXMLCatalogNode PROC				; COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _base$1$[ebp], 0
	test	ebx, ebx
	je	$LN34@xmlParseXM

; 1223 :     xmlChar *base = NULL;
; 1224 :     xmlCatalogEntryPtr entry = NULL;
; 1225 : 
; 1226 :     if (cur == NULL)
; 1227 :         return;
; 1228 :     if (xmlStrEqual(cur->name, BAD_CAST "group")) {

	push	esi
	push	edi
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlParseXM

; 1229 :         xmlChar *prop;
; 1230 : 	xmlCatalogPrefer pref = XML_CATA_PREFER_NONE;
; 1231 : 
; 1232 :         prop = xmlGetProp(cur, BAD_CAST "prefer");

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	push	ebx
	mov	DWORD PTR _pref$1$[ebp], 0
	call	_xmlGetProp
	mov	esi, eax
	add	esp, 8

; 1233 :         if (prop != NULL) {

	test	esi, esi
	je	SHORT $LN49@xmlParseXM

; 1234 :             if (xmlStrEqual(prop, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlParseXM

; 1240 :                               "Invalid value for prefer: '%s'\n",
; 1241 : 			      prop, NULL, NULL);
; 1242 :             }
; 1243 :             xmlFree(prop);

	push	esi
	mov	edi, 2
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1244 : 	    pref = prefer;

	mov	DWORD PTR _pref$1$[ebp], edi
	jmp	SHORT $LN7@xmlParseXM
$LN8@xmlParseXM:

; 1235 :                 prefer = XML_CATA_PREFER_SYSTEM;
; 1236 :             } else if (xmlStrEqual(prop, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseXM

; 1240 :                               "Invalid value for prefer: '%s'\n",
; 1241 : 			      prop, NULL, NULL);
; 1242 :             }
; 1243 :             xmlFree(prop);

	push	esi
	mov	edi, 1
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1244 : 	    pref = prefer;

	mov	DWORD PTR _pref$1$[ebp], edi
	jmp	SHORT $LN7@xmlParseXM
$LN10@xmlParseXM:

; 1237 :                 prefer = XML_CATA_PREFER_PUBLIC;
; 1238 :             } else {
; 1239 : 		xmlCatalogErr(parent, cur, XML_CATALOG_PREFER_VALUE,

	push	0
	push	0
	push	esi
	push	OFFSET ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
	push	1652					; 00000674H
	push	ebx
	push	DWORD PTR _parent$[ebp]
	call	_xmlCatalogErr
	mov	edi, DWORD PTR _prefer$[ebp]
	add	esp, 28					; 0000001cH

; 1240 :                               "Invalid value for prefer: '%s'\n",
; 1241 : 			      prop, NULL, NULL);
; 1242 :             }
; 1243 :             xmlFree(prop);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1244 : 	    pref = prefer;

	mov	DWORD PTR _pref$1$[ebp], edi
	jmp	SHORT $LN7@xmlParseXM
$LN49@xmlParseXM:

; 1233 :         if (prop != NULL) {

	mov	edi, DWORD PTR _prefer$[ebp]
$LN7@xmlParseXM:

; 1245 :         }
; 1246 : 	prop = xmlGetProp(cur, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	call	_xmlGetProp

; 1247 : 	base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	ebx
	mov	esi, eax
	call	_xmlGetNsProp

; 1248 : 	entry = xmlNewCatalogEntry(XML_CATA_GROUP, prop, base, NULL, pref, cgroup);

	push	DWORD PTR _cgroup$[ebp]
	mov	DWORD PTR _base$1$[ebp], eax
	push	DWORD PTR _pref$1$[ebp]
	push	0
	push	eax
	push	esi
	push	4
	call	_xmlNewCatalogEntry

; 1249 : 	xmlFree(prop);

	push	esi
	mov	DWORD PTR _entry$1$[ebp], eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _entry$1$[ebp]
	add	esp, 48					; 00000030H
	jmp	$LN28@xmlParseXM
$LN5@xmlParseXM:

; 1250 :     } else if (xmlStrEqual(cur->name, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseXM

; 1251 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_PUBLIC,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08KNJBHAKA@publicId@
	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	5
	jmp	$LN52@xmlParseXM
$LN12@xmlParseXM:

; 1252 : 		BAD_CAST "public", BAD_CAST "publicId", BAD_CAST "uri", prefer, cgroup);
; 1253 :     } else if (xmlStrEqual(cur->name, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlParseXM

; 1254 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_SYSTEM,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08MILANEJE@systemId@
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	6
	jmp	$LN52@xmlParseXM
$LN14@xmlParseXM:

; 1255 : 		BAD_CAST "system", BAD_CAST "systemId", BAD_CAST "uri", prefer, cgroup);
; 1256 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteSystem")) {

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlParseXM

; 1257 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_SYSTEM,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	7
	jmp	$LN52@xmlParseXM
$LN16@xmlParseXM:

; 1258 : 		BAD_CAST "rewriteSystem", BAD_CAST "systemIdStartString",
; 1259 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1260 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegatePublic")) {

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlParseXM

; 1261 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_PUBLIC,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@JKBIFJL@publicIdStartString@
	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	8
	jmp	$LN52@xmlParseXM
$LN18@xmlParseXM:

; 1262 : 		BAD_CAST "delegatePublic", BAD_CAST "publicIdStartString",
; 1263 : 		BAD_CAST "catalog", prefer, cgroup);
; 1264 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateSystem")) {

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlParseXM

; 1265 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_SYSTEM,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	9
	jmp	$LN52@xmlParseXM
$LN20@xmlParseXM:

; 1266 : 		BAD_CAST "delegateSystem", BAD_CAST "systemIdStartString",
; 1267 : 		BAD_CAST "catalog", prefer, cgroup);
; 1268 :     } else if (xmlStrEqual(cur->name, BAD_CAST "uri")) {

	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlParseXM

; 1269 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_URI,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	10					; 0000000aH
	jmp	$LN52@xmlParseXM
$LN22@xmlParseXM:

; 1270 : 		BAD_CAST "uri", BAD_CAST "name",
; 1271 : 		BAD_CAST "uri", prefer, cgroup);
; 1272 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteURI")) {

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlParseXM

; 1273 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_URI,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	11					; 0000000bH
	jmp	SHORT $LN52@xmlParseXM
$LN24@xmlParseXM:

; 1274 : 		BAD_CAST "rewriteURI", BAD_CAST "uriStartString",
; 1275 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1276 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateURI")) {

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlParseXM

; 1277 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_URI,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	12					; 0000000cH
	jmp	SHORT $LN52@xmlParseXM
$LN26@xmlParseXM:

; 1278 : 		BAD_CAST "delegateURI", BAD_CAST "uriStartString",
; 1279 : 		BAD_CAST "catalog", prefer, cgroup);
; 1280 :     } else if (xmlStrEqual(cur->name, BAD_CAST "nextCatalog")) {

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN50@xmlParseXM

; 1281 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_NEXT_CATALOG,

	push	DWORD PTR _cgroup$[ebp]
	mov	edi, DWORD PTR _prefer$[ebp]
	push	edi
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	0
	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	3
$LN52@xmlParseXM:

; 1282 : 		BAD_CAST "nextCatalog", NULL,
; 1283 : 		BAD_CAST "catalog", prefer, cgroup);
; 1284 :     }
; 1285 :     if (entry != NULL) {

	push	ebx
	call	_xmlParseXMLCatalogOneNode
	mov	ecx, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _entry$1$[ebp], ecx
$LN28@xmlParseXM:
	test	ecx, ecx
	je	SHORT $LN38@xmlParseXM

; 1286 :         if (parent != NULL) {

	mov	eax, DWORD PTR _parent$[ebp]
	test	eax, eax
	je	SHORT $LN32@xmlParseXM

; 1287 : 	    entry->parent = parent;

	mov	DWORD PTR [ecx+4], eax

; 1288 : 	    if (parent->children == NULL)

	mov	esi, DWORD PTR [eax+8]
	test	esi, esi
	jne	SHORT $LN31@xmlParseXM

; 1289 : 		parent->children = entry;

	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN32@xmlParseXM
$LN31@xmlParseXM:

; 1290 : 	    else {
; 1291 : 		xmlCatalogEntryPtr prev;
; 1292 : 
; 1293 : 		prev = parent->children;
; 1294 : 		while (prev->next != NULL)

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN3@xmlParseXM
$LL2@xmlParseXM:
	mov	eax, DWORD PTR [edx]

; 1295 : 		    prev = prev->next;

	mov	esi, edx
	mov	edx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlParseXM
$LN3@xmlParseXM:

; 1296 : 		prev->next = entry;

	mov	DWORD PTR [esi], ecx
$LN32@xmlParseXM:

; 1297 : 	    }
; 1298 : 	}
; 1299 : 	if (entry->type == XML_CATA_GROUP) {

	cmp	DWORD PTR [ecx+12], 4
	jne	SHORT $LN38@xmlParseXM

; 1300 : 	    /*
; 1301 : 	     * Recurse to propagate prefer to the subtree
; 1302 : 	     * (xml:base handling is automated)
; 1303 : 	     */
; 1304 :             xmlParseXMLCatalogNodeList(cur->children, prefer, parent, entry);

	mov	esi, DWORD PTR [ebx+12]

; 1325 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN38@xmlParseXM
	mov	ebx, DWORD PTR _entry$1$[ebp]
$LL37@xmlParseXM:

; 1326 : 	if ((cur->ns != NULL) && (cur->ns->href != NULL) &&

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN39@xmlParseXM
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN39@xmlParseXM
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlParseXM

; 1327 : 	    (xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {
; 1328 : 	    xmlParseXMLCatalogNode(cur, prefer, parent, cgroup);

	push	ebx
	push	DWORD PTR _parent$[ebp]
	push	edi
	push	esi
	call	_xmlParseXMLCatalogNode
	add	esp, 16					; 00000010H
$LN39@xmlParseXM:

; 1329 : 	}
; 1330 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL37@xmlParseXM
$LN38@xmlParseXM:

; 1305 : 	}
; 1306 :     }
; 1307 :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	SHORT $LN50@xmlParseXM

; 1308 : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlParseXM:
	pop	edi
	pop	esi
$LN34@xmlParseXM:
	pop	ebx

; 1309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogOneNode
_TEXT	SEGMENT
_base$1$ = -4						; size = 4
_ok$1$ = -4						; size = 4
_cur$ = 8						; size = 4
_type$ = 12						; size = 4
_name$ = 16						; size = 4
_URL$1$ = 20						; size = 4
_attrName$ = 20						; size = 4
_uriAttrName$ = 24					; size = 4
_prefer$ = 28						; size = 4
_cgroup$ = 32						; size = 4
_xmlParseXMLCatalogOneNode PROC				; COMDAT

; 1151 : 			  xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _attrName$[ebp]
	xor	edi, edi
	mov	esi, DWORD PTR _name$[ebp]
	mov	ebx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ok$1$[ebp], 1
	test	eax, eax
	je	SHORT $LN3@xmlParseXM

; 1152 :     int ok = 1;
; 1153 :     xmlChar *uriValue;
; 1154 :     xmlChar *nameValue = NULL;
; 1155 :     xmlChar *base = NULL;
; 1156 :     xmlChar *URL = NULL;
; 1157 :     xmlCatalogEntryPtr ret = NULL;
; 1158 : 
; 1159 :     if (attrName != NULL) {
; 1160 : 	nameValue = xmlGetProp(cur, attrName);

	push	eax
	push	ebx
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 1161 : 	if (nameValue == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlParseXM

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	push	eax
	mov	eax, DWORD PTR _attrName$[ebp]
	push	eax
	push	esi
	push	OFFSET ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
	push	edi
	push	edi
	push	edi
	push	eax
	push	esi
	push	edi
	push	edi
	push	2
	push	1650					; 00000672H
	push	20					; 00000014H
	push	ebx
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 1162 : 	    xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,
; 1163 : 			  "%s entry lacks '%s'\n", name, attrName, NULL);
; 1164 : 	    ok = 0;

	mov	DWORD PTR _ok$1$[ebp], edi
$LN3@xmlParseXM:

; 1165 : 	}
; 1166 :     }
; 1167 :     uriValue = xmlGetProp(cur, uriAttrName);

	push	DWORD PTR _uriAttrName$[ebp]
	push	ebx
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8

; 1168 :     if (uriValue == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlParseXM

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	push	eax
	mov	eax, DWORD PTR _uriAttrName$[ebp]
	push	eax
	push	esi
	push	OFFSET ??_C@_0BF@JJKMCIOA@?$CFs?5entry?5lacks?5?8?$CFs?8?6@
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	esi
	push	ebx
	push	ebx
	push	2
	push	1650					; 00000672H
	push	20					; 00000014H
	push	DWORD PTR _cur$[ebp]
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 1169 : 	xmlCatalogErr(ret, cur, XML_CATALOG_MISSING_ATTR,
; 1170 : 		"%s entry lacks '%s'\n", name, uriAttrName, NULL);
; 1171 : 	ok = 0;
; 1172 :     }
; 1173 :     if (!ok) {

	jmp	SHORT $LN24@xmlParseXM
$LN4@xmlParseXM:
	cmp	DWORD PTR _ok$1$[ebp], 0
	jne	SHORT $LN5@xmlParseXM
$LN24@xmlParseXM:

; 1174 : 	if (nameValue != NULL)

	test	edi, edi
	je	SHORT $LN6@xmlParseXM

; 1175 : 	    xmlFree(nameValue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlParseXM:

; 1176 : 	if (uriValue != NULL)

	test	ebx, ebx
	je	SHORT $LN7@xmlParseXM

; 1177 : 	    xmlFree(uriValue);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlParseXM:

; 1206 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParseXM:

; 1178 : 	return(NULL);
; 1179 :     }
; 1180 : 
; 1181 :     base = xmlNodeGetBase(cur->doc, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlNodeGetBase

; 1182 :     URL = xmlBuildURI(uriValue, base);

	push	eax
	push	ebx
	mov	DWORD PTR _base$1$[ebp], eax
	call	_xmlBuildURI
	add	esp, 16					; 00000010H
	mov	DWORD PTR _URL$1$[ebp], eax

; 1183 :     if (URL != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlParseXM

; 1184 : 	if (xmlDebugCatalogs > 1) {

	cmp	DWORD PTR _xmlDebugCatalogs, 1
	jle	SHORT $LN12@xmlParseXM

; 1185 : 	    if (nameValue != NULL)

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [esi]
	push	DWORD PTR _URL$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN11@xmlParseXM

; 1186 : 		xmlGenericError(xmlGenericErrorContext,

	push	edi
	push	eax
	push	OFFSET ??_C@_0BF@BGILJEII@Found?5?$CFs?3?5?8?$CFs?8?5?8?$CFs?8?6@
	push	ecx
	call	edx
	add	esp, 20					; 00000014H
	jmp	SHORT $LN26@xmlParseXM
$LN11@xmlParseXM:

; 1187 : 			"Found %s: '%s' '%s'\n", name, nameValue, URL);
; 1188 : 	    else
; 1189 : 		xmlGenericError(xmlGenericErrorContext,

	push	eax
	push	OFFSET ??_C@_0BA@FJAJBNGG@Found?5?$CFs?3?5?8?$CFs?8?6@
	push	ecx
	call	edx
	add	esp, 16					; 00000010H
$LN26@xmlParseXM:

; 1190 : 			"Found %s: '%s'\n", name, URL);
; 1191 : 	}
; 1192 : 	ret = xmlNewCatalogEntry(type, nameValue, uriValue, URL, prefer, cgroup);

	mov	eax, DWORD PTR _URL$1$[ebp]
$LN12@xmlParseXM:
	push	DWORD PTR _cgroup$[ebp]
	push	DWORD PTR _prefer$[ebp]
	push	eax
	push	ebx
	push	edi
	push	DWORD PTR _type$[ebp]
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	esi, eax

; 1193 :     } else {

	jmp	SHORT $LN22@xmlParseXM
$LN8@xmlParseXM:

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	mov	eax, DWORD PTR _uriAttrName$[ebp]
	push	ebx
	push	eax
	push	esi
	push	OFFSET ??_C@_0BM@NDOJAICK@?$CFs?5entry?5?8?$CFs?8?5broken?5?$DP?3?5?$CFs?6@
	push	0
	push	0
	push	ebx
	push	eax
	push	esi
	push	0
	push	0
	push	2
	push	1651					; 00000673H
	push	20					; 00000014H
	push	DWORD PTR _cur$[ebp]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
	xor	esi, esi
$LN22@xmlParseXM:

; 1194 : 	xmlCatalogErr(ret, cur, XML_CATALOG_ENTRY_BROKEN,
; 1195 : 		"%s entry '%s' broken ?: %s\n", name, uriAttrName, uriValue);
; 1196 :     }
; 1197 :     if (nameValue != NULL)

	test	edi, edi
	je	SHORT $LN13@xmlParseXM

; 1198 : 	xmlFree(nameValue);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParseXM:

; 1199 :     if (uriValue != NULL)

	test	ebx, ebx
	je	SHORT $LN14@xmlParseXM

; 1200 : 	xmlFree(uriValue);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlParseXM:

; 1201 :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlParseXM

; 1202 : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlParseXM:

; 1203 :     if (URL != NULL)

	mov	eax, DWORD PTR _URL$1$[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlParseXM

; 1204 : 	xmlFree(URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlParseXM:

; 1205 :     return(ret);

	pop	edi
	mov	eax, esi

; 1206 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlGetXMLCatalogEntryType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_xmlGetXMLCatalogEntryType PROC				; COMDAT

; 1107 : xmlGetXMLCatalogEntryType(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	xor	esi, esi
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlGetXMLC

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	mov	esi, 6
	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN2@xmlGetXMLC:

; 1108 :     xmlCatalogEntryType type = XML_CATA_NONE;
; 1109 :     if (xmlStrEqual(name, (const xmlChar *) "system"))
; 1110 : 	type = XML_CATA_SYSTEM;
; 1111 :     else if (xmlStrEqual(name, (const xmlChar *) "public"))

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlGetXMLC

; 1112 : 	type = XML_CATA_PUBLIC;

	mov	esi, 5

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN4@xmlGetXMLC:

; 1113 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteSystem"))

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlGetXMLC

; 1114 : 	type = XML_CATA_REWRITE_SYSTEM;

	mov	esi, 7

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN6@xmlGetXMLC:

; 1115 :     else if (xmlStrEqual(name, (const xmlChar *) "delegatePublic"))

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlGetXMLC

; 1116 : 	type = XML_CATA_DELEGATE_PUBLIC;

	mov	esi, 8

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN8@xmlGetXMLC:

; 1117 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateSystem"))

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlGetXMLC

; 1118 : 	type = XML_CATA_DELEGATE_SYSTEM;

	mov	esi, 9

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN10@xmlGetXMLC:

; 1119 :     else if (xmlStrEqual(name, (const xmlChar *) "uri"))

	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlGetXMLC

; 1120 : 	type = XML_CATA_URI;

	mov	esi, 10					; 0000000aH

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN12@xmlGetXMLC:

; 1121 :     else if (xmlStrEqual(name, (const xmlChar *) "rewriteURI"))

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlGetXMLC

; 1122 : 	type = XML_CATA_REWRITE_URI;

	mov	esi, 11					; 0000000bH

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN14@xmlGetXMLC:

; 1123 :     else if (xmlStrEqual(name, (const xmlChar *) "delegateURI"))

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlGetXMLC

; 1124 : 	type = XML_CATA_DELEGATE_URI;

	mov	esi, 12					; 0000000cH

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN16@xmlGetXMLC:

; 1125 :     else if (xmlStrEqual(name, (const xmlChar *) "nextCatalog"))

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlGetXMLC

; 1126 : 	type = XML_CATA_NEXT_CATALOG;

	mov	esi, 3

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
$LN18@xmlGetXMLC:

; 1127 :     else if (xmlStrEqual(name, (const xmlChar *) "catalog"))

	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	mov	ecx, 1
	test	eax, eax
	cmovne	esi, ecx

; 1128 : 	type = XML_CATA_CATALOG;
; 1129 :     return(type);

	pop	edi
	mov	eax, esi
	pop	esi

; 1130 : }

	pop	ebp
	ret	0
_xmlGetXMLCatalogEntryType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogListXMLResolveURI
_TEXT	SEGMENT
_urnID$1$ = 8						; size = 4
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogListXMLResolveURI PROC			; COMDAT

; 2099 : xmlCatalogListXMLResolveURI(xmlCatalogEntryPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _catal$[ebp]
	xor	esi, esi
	test	edi, edi
	je	$LN23@xmlCatalog

; 2100 :     xmlChar *ret = NULL;
; 2101 :     xmlChar *urnID = NULL;
; 2102 : 
; 2103 :     if (catal == NULL)
; 2104 :         return(NULL);
; 2105 :     if (URI == NULL)

	mov	ebx, DWORD PTR _URI$[ebp]
	test	ebx, ebx
	je	$LN23@xmlCatalog

; 2106 : 	return(NULL);
; 2107 : 
; 2108 :     if (!xmlStrncmp(URI, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	push	ebx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL2@xmlCatalog

; 2109 : 	urnID = xmlCatalogUnWrapURN(URI);

	push	ebx
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	esi, eax

; 2110 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	mov	DWORD PTR _urnID$1$[ebp], esi
	je	SHORT $LN9@xmlCatalog

; 2111 : 	    if (urnID == NULL)

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR _urnID$1$[ebp]
	mov	eax, DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN8@xmlCatalog

; 2112 : 		xmlGenericError(xmlGenericErrorContext,

	push	ebx
	push	OFFSET ??_C@_0BM@FKFGGIIN@URN?5ID?5?$CFs?5expanded?5to?5NULL?6@
	jmp	SHORT $LN31@xmlCatalog
$LN8@xmlCatalog:

; 2113 : 			"URN ID %s expanded to NULL\n", URI);
; 2114 : 	    else
; 2115 : 		xmlGenericError(xmlGenericErrorContext,

	push	esi
	push	OFFSET ??_C@_0BH@CIFAIMNL@URN?5ID?5expanded?5to?5?$CFs?6@
$LN31@xmlCatalog:

; 2116 : 			"URN ID expanded to %s\n", urnID);
; 2117 : 	}
; 2118 : 	ret = xmlCatalogListXMLResolve(catal, urnID, NULL);

	push	eax
	call	ecx
	add	esp, 12					; 0000000cH
$LN9@xmlCatalog:
	push	0
	push	esi
	push	edi
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	edi, eax

; 2119 : 	if (urnID != NULL)

	test	esi, esi
	je	SHORT $LN10@xmlCatalog

; 2120 : 	    xmlFree(urnID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlCatalog:

; 2121 : 	return(ret);

	mov	eax, edi
	pop	edi

; 2135 :     }
; 2136 :     return(ret);
; 2137 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LL2@xmlCatalog:

; 2122 :     }
; 2123 :     while (catal != NULL) {
; 2124 : 	if (catal->type == XML_CATA_CATALOG) {

	cmp	DWORD PTR [edi+12], 1
	jne	SHORT $LN14@xmlCatalog

; 2125 : 	    if (catal->children == NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN33@xmlCatalog

; 2126 : 		xmlFetchXMLCatalogFile(catal);

	push	edi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [edi+8]
	add	esp, 4

; 2127 : 	    }
; 2128 : 	    if (catal->children != NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlCatalog
$LN33@xmlCatalog:

; 2129 : 		ret = xmlCatalogXMLResolveURI(catal->children, URI);

	push	ebx
	push	eax
	call	_xmlCatalogXMLResolveURI
	mov	esi, eax
	add	esp, 8

; 2130 : 		if (ret != NULL)

	test	esi, esi
	jne	SHORT $LN17@xmlCatalog
$LN14@xmlCatalog:

; 2131 : 		    return(ret);
; 2132 : 	    }
; 2133 : 	}
; 2134 : 	catal = catal->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL2@xmlCatalog
$LN17@xmlCatalog:
	pop	edi

; 2135 :     }
; 2136 :     return(ret);
; 2137 : }

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlCatalog:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlCatalogListXMLResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogListXMLResolve
_TEXT	SEGMENT
_normid$1$ = -8						; size = 4
_ret$2$ = -4						; size = 4
_urnID$2$ = 8						; size = 4
_urnID$1$ = 8						; size = 4
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogListXMLResolve PROC				; COMDAT

; 2009 : 	              const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _catal$[ebp]
	mov	DWORD PTR _ret$2$[ebp], 0
	test	edi, edi
	je	$LN39@xmlCatalog

; 2010 :     xmlChar *ret = NULL;
; 2011 :     xmlChar *urnID = NULL;
; 2012 :     xmlChar *normid;
; 2013 : 
; 2014 :     if (catal == NULL)
; 2015 :         return(NULL);
; 2016 :     if ((pubID == NULL) && (sysID == NULL))

	mov	ebx, DWORD PTR _pubID$[ebp]
	test	ebx, ebx
	jne	SHORT $LN5@xmlCatalog
	cmp	DWORD PTR _sysID$[ebp], ebx
	je	$LN39@xmlCatalog
$LN5@xmlCatalog:
	push	esi

; 2018 : 
; 2019 :     normid = xmlCatalogNormalizePublic(pubID);

	push	ebx
	call	_xmlCatalogNormalizePublic
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _normid$1$[ebp], esi

; 2020 :     if (normid != NULL)

	test	esi, esi
	je	SHORT $LN6@xmlCatalog

; 2021 :         pubID = (*normid != 0 ? normid : NULL);

	xor	ebx, ebx
	cmp	BYTE PTR [esi], bl
	cmovne	ebx, esi
$LN6@xmlCatalog:

; 2022 : 
; 2023 :     if (!xmlStrncmp(pubID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	push	ebx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@xmlCatalog

; 2024 : 	urnID = xmlCatalogUnWrapURN(pubID);

	push	ebx
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	DWORD PTR _urnID$1$[ebp], eax

; 2025 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN10@xmlCatalog

; 2026 : 	    if (urnID == NULL)

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _urnID$1$[ebp]
	test	eax, eax
	jne	SHORT $LN9@xmlCatalog

; 2027 : 		xmlGenericError(xmlGenericErrorContext,

	push	ebx
	push	OFFSET ??_C@_0CD@CFKEBFJH@Public?5URN?5ID?5?$CFs?5expanded?5to?5NU@
	jmp	SHORT $LN50@xmlCatalog
$LN9@xmlCatalog:

; 2028 : 			"Public URN ID %s expanded to NULL\n", pubID);
; 2029 : 	    else
; 2030 : 		xmlGenericError(xmlGenericErrorContext,

	push	eax
	push	OFFSET ??_C@_0BO@PMAINHBC@Public?5URN?5ID?5expanded?5to?5?$CFs?6@
$LN50@xmlCatalog:

; 2031 : 			"Public URN ID expanded to %s\n", urnID);
; 2032 : 	}
; 2033 : 	ret = xmlCatalogListXMLResolve(catal, urnID, sysID);

	push	ecx
	call	edx
	mov	eax, DWORD PTR _urnID$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _normid$1$[ebp]
$LN10@xmlCatalog:
	push	DWORD PTR _sysID$[ebp]
	push	eax
	push	edi
	call	_xmlCatalogListXMLResolve
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2034 : 	if (urnID != NULL)

	mov	eax, DWORD PTR _urnID$1$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlCatalog

; 2035 : 	    xmlFree(urnID);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlCatalog:

; 2036 : 	if (normid != NULL)

	test	esi, esi
	je	SHORT $LN22@xmlCatalog

; 2037 : 	    xmlFree(normid);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlCatalog:

; 2038 : 	return(ret);

	mov	eax, edi
$LN49@xmlCatalog:
	pop	esi
	pop	edi

; 2083 :     return(ret);
; 2084 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlCatalog:

; 2039 :     }
; 2040 :     if (!xmlStrncmp(sysID, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	push	DWORD PTR _sysID$[ebp]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL2@xmlCatalog

; 2041 : 	urnID = xmlCatalogUnWrapURN(sysID);

	push	DWORD PTR _sysID$[ebp]
	call	_xmlCatalogUnWrapURN
	add	esp, 4
	mov	esi, eax

; 2042 : 	if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	mov	DWORD PTR _urnID$2$[ebp], esi
	je	SHORT $LN16@xmlCatalog

; 2043 : 	    if (urnID == NULL)

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR _urnID$2$[ebp]
	mov	eax, DWORD PTR [eax]
	test	esi, esi
	jne	SHORT $LN15@xmlCatalog

; 2044 : 		xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR _sysID$[ebp]
	push	OFFSET ??_C@_0CD@CPPNJIKG@System?5URN?5ID?5?$CFs?5expanded?5to?5NU@
	jmp	SHORT $LN51@xmlCatalog
$LN15@xmlCatalog:

; 2045 : 			"System URN ID %s expanded to NULL\n", sysID);
; 2046 : 	    else
; 2047 : 		xmlGenericError(xmlGenericErrorContext,

	push	esi
	push	OFFSET ??_C@_0BO@PPGKEABI@System?5URN?5ID?5expanded?5to?5?$CFs?6@
$LN51@xmlCatalog:

; 2048 : 			"System URN ID expanded to %s\n", urnID);
; 2049 : 	}
; 2050 : 	if (pubID == NULL)

	push	eax
	call	ecx
	add	esp, 12					; 0000000cH
$LN16@xmlCatalog:
	test	ebx, ebx
	jne	SHORT $LN17@xmlCatalog

; 2051 : 	    ret = xmlCatalogListXMLResolve(catal, urnID, NULL);

	mov	ebx, esi
	xor	eax, eax
	jmp	SHORT $LN20@xmlCatalog
$LN17@xmlCatalog:

; 2052 : 	else if (xmlStrEqual(pubID, urnID))

	push	esi
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlCatalog

; 2053 : 	    ret = xmlCatalogListXMLResolve(catal, pubID, NULL);

	xor	eax, eax
	jmp	SHORT $LN20@xmlCatalog
$LN19@xmlCatalog:

; 2054 : 	else {
; 2055 : 	    ret = xmlCatalogListXMLResolve(catal, pubID, urnID);

	mov	eax, esi
$LN20@xmlCatalog:

; 2056 : 	}
; 2057 : 	if (urnID != NULL)

	push	eax
	push	ebx
	push	edi
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH
	mov	edi, eax
	test	esi, esi
	je	SHORT $LN21@xmlCatalog

; 2058 : 	    xmlFree(urnID);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlCatalog:

; 2059 : 	if (normid != NULL)

	mov	eax, DWORD PTR _normid$1$[ebp]
	test	eax, eax
	je	$LN22@xmlCatalog

; 2060 : 	    xmlFree(normid);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	eax, edi
	pop	esi
	pop	edi

; 2083 :     return(ret);
; 2084 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL2@xmlCatalog:

; 2064 : 	if (catal->type == XML_CATA_CATALOG) {

	cmp	DWORD PTR [edi+12], 1
	jne	SHORT $LN47@xmlCatalog

; 2065 : 	    if (catal->children == NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN53@xmlCatalog

; 2066 : 		xmlFetchXMLCatalogFile(catal);

	push	edi
	call	_xmlFetchXMLCatalogFile
	mov	eax, DWORD PTR [edi+8]
	add	esp, 4

; 2067 : 	    }
; 2068 : 	    if (catal->children != NULL) {

	test	eax, eax
	je	SHORT $LN47@xmlCatalog
$LN53@xmlCatalog:

; 2069 : 		ret = xmlCatalogXMLResolve(catal->children, pubID, sysID);

	push	DWORD PTR _sysID$[ebp]
	push	ebx
	push	eax
	call	_xmlCatalogXMLResolve
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], eax

; 2070 : 		if (ret != NULL) {

	test	eax, eax
	jne	SHORT $LN42@xmlCatalog

; 2071 : 		    break;
; 2072 :                 } else if ((catal->children != NULL) &&

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN28@xmlCatalog
	cmp	DWORD PTR [ecx+36], 50			; 00000032H
	jle	SHORT $LN28@xmlCatalog

; 2073 : 		           (catal->children->depth > MAX_CATAL_DEPTH)) {
; 2074 : 	            ret = NULL;

	mov	DWORD PTR _ret$2$[ebp], eax
$LN42@xmlCatalog:

; 2080 :     }
; 2081 :     if (normid != NULL)

	test	esi, esi
	je	$LN49@xmlCatalog

; 2082 : 	xmlFree(normid);

	push	esi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _ret$2$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 2083 :     return(ret);
; 2084 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlCatalog:

; 2075 : 		    break;
; 2076 : 	        }
; 2077 : 	    }
; 2078 : 	}
; 2079 : 	catal = catal->next;

	mov	eax, DWORD PTR _ret$2$[ebp]
$LN28@xmlCatalog:
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL2@xmlCatalog

; 2061 : 	return(ret);
; 2062 :     }
; 2063 :     while (catal != NULL) {

	jmp	SHORT $LN42@xmlCatalog
$LN39@xmlCatalog:
	pop	edi

; 2017 : 	return(NULL);

	xor	eax, eax

; 2083 :     return(ret);
; 2084 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogListXMLResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogNodeList
_TEXT	SEGMENT
_base$1$ = -4						; size = 4
_prefer$1$ = 8						; size = 4
_cur$ = 8						; size = 4
_prefer$ = 12						; size = 4
_parent$ = 16						; size = 4
_cgroup$ = 20						; size = 4
_xmlParseXMLCatalogNodeList PROC			; COMDAT

; 1324 : 	                   xmlCatalogEntryPtr parent, xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlParseXM
	push	ebx
	mov	ebx, DWORD PTR _prefer$[ebp]
	push	edi
	mov	edi, DWORD PTR _cgroup$[ebp]
$LL2@xmlParseXM:

; 1325 :     while (cur != NULL) {
; 1326 : 	if ((cur->ns != NULL) && (cur->ns->href != NULL) &&

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	$LN39@xmlParseXM
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	$LN39@xmlParseXM
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN39@xmlParseXM

; 1228 :     if (xmlStrEqual(cur->name, BAD_CAST "group")) {

	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	DWORD PTR [esi+8]

; 1327 : 	    (xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {
; 1328 : 	    xmlParseXMLCatalogNode(cur, prefer, parent, cgroup);

	mov	DWORD PTR _prefer$1$[ebp], ebx

; 1223 :     xmlChar *base = NULL;

	mov	DWORD PTR _base$1$[ebp], 0

; 1224 :     xmlCatalogEntryPtr entry = NULL;
; 1225 : 
; 1226 :     if (cur == NULL)
; 1227 :         return;
; 1228 :     if (xmlStrEqual(cur->name, BAD_CAST "group")) {

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN10@xmlParseXM

; 1229 :         xmlChar *prop;
; 1230 : 	xmlCatalogPrefer pref = XML_CATA_PREFER_NONE;
; 1231 : 
; 1232 :         prop = xmlGetProp(cur, BAD_CAST "prefer");

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	push	esi
	xor	ebx, ebx
	call	_xmlGetProp
	mov	edi, eax
	add	esp, 8

; 1233 :         if (prop != NULL) {

	test	edi, edi
	je	SHORT $LN12@xmlParseXM

; 1234 :             if (xmlStrEqual(prop, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlParseXM

; 1235 :                 prefer = XML_CATA_PREFER_SYSTEM;

	mov	DWORD PTR _prefer$1$[ebp], 2
	jmp	SHORT $LN16@xmlParseXM
$LN13@xmlParseXM:

; 1236 :             } else if (xmlStrEqual(prop, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlParseXM

; 1237 :                 prefer = XML_CATA_PREFER_PUBLIC;

	mov	DWORD PTR _prefer$1$[ebp], 1

; 1238 :             } else {

	jmp	SHORT $LN16@xmlParseXM
$LN15@xmlParseXM:

; 1239 : 		xmlCatalogErr(parent, cur, XML_CATALOG_PREFER_VALUE,

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
	push	1652					; 00000674H
	push	esi
	push	DWORD PTR _parent$[ebp]
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH
$LN16@xmlParseXM:

; 1240 :                               "Invalid value for prefer: '%s'\n",
; 1241 : 			      prop, NULL, NULL);
; 1242 :             }
; 1243 :             xmlFree(prop);

	push	edi
	call	DWORD PTR _xmlFree

; 1244 : 	    pref = prefer;

	mov	ebx, DWORD PTR _prefer$1$[ebp]
	add	esp, 4
$LN12@xmlParseXM:

; 1245 :         }
; 1246 : 	prop = xmlGetProp(cur, BAD_CAST "id");

	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	call	_xmlGetProp

; 1247 : 	base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	esi
	mov	edi, eax
	call	_xmlGetNsProp

; 1248 : 	entry = xmlNewCatalogEntry(XML_CATA_GROUP, prop, base, NULL, pref, cgroup);

	push	DWORD PTR _cgroup$[ebp]
	mov	DWORD PTR _base$1$[ebp], eax
	push	ebx
	push	0
	push	eax
	push	edi
	push	4
	call	_xmlNewCatalogEntry

; 1249 : 	xmlFree(prop);

	push	edi
	mov	ebx, eax
	call	DWORD PTR _xmlFree
	mov	edi, DWORD PTR _cgroup$[ebp]
	add	esp, 48					; 00000030H
	jmp	$LN33@xmlParseXM
$LN10@xmlParseXM:

; 1250 :     } else if (xmlStrEqual(cur->name, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlParseXM

; 1251 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_PUBLIC,

	push	edi
	push	ebx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08KNJBHAKA@publicId@
	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	5
	jmp	$LN50@xmlParseXM
$LN17@xmlParseXM:

; 1252 : 		BAD_CAST "public", BAD_CAST "publicId", BAD_CAST "uri", prefer, cgroup);
; 1253 :     } else if (xmlStrEqual(cur->name, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlParseXM

; 1254 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_SYSTEM,

	push	edi
	push	ebx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_08MILANEJE@systemId@
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	6
	jmp	$LN50@xmlParseXM
$LN19@xmlParseXM:

; 1255 : 		BAD_CAST "system", BAD_CAST "systemId", BAD_CAST "uri", prefer, cgroup);
; 1256 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteSystem")) {

	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlParseXM

; 1257 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_SYSTEM,

	push	edi
	push	ebx
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	7
	jmp	$LN50@xmlParseXM
$LN21@xmlParseXM:

; 1258 : 		BAD_CAST "rewriteSystem", BAD_CAST "systemIdStartString",
; 1259 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1260 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegatePublic")) {

	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlParseXM

; 1261 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_PUBLIC,

	push	edi
	push	ebx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@JKBIFJL@publicIdStartString@
	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	8
	jmp	$LN50@xmlParseXM
$LN23@xmlParseXM:

; 1262 : 		BAD_CAST "delegatePublic", BAD_CAST "publicIdStartString",
; 1263 : 		BAD_CAST "catalog", prefer, cgroup);
; 1264 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateSystem")) {

	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlParseXM

; 1265 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_SYSTEM,

	push	edi
	push	ebx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	9
	jmp	$LN50@xmlParseXM
$LN25@xmlParseXM:

; 1266 : 		BAD_CAST "delegateSystem", BAD_CAST "systemIdStartString",
; 1267 : 		BAD_CAST "catalog", prefer, cgroup);
; 1268 :     } else if (xmlStrEqual(cur->name, BAD_CAST "uri")) {

	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlParseXM

; 1269 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_URI,

	push	edi
	push	ebx
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	10					; 0000000aH
	jmp	SHORT $LN50@xmlParseXM
$LN27@xmlParseXM:

; 1270 : 		BAD_CAST "uri", BAD_CAST "name",
; 1271 : 		BAD_CAST "uri", prefer, cgroup);
; 1272 :     } else if (xmlStrEqual(cur->name, BAD_CAST "rewriteURI")) {

	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParseXM

; 1273 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_REWRITE_URI,

	push	edi
	push	ebx
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	11					; 0000000bH
	jmp	SHORT $LN50@xmlParseXM
$LN29@xmlParseXM:

; 1274 : 		BAD_CAST "rewriteURI", BAD_CAST "uriStartString",
; 1275 : 		BAD_CAST "rewritePrefix", prefer, cgroup);
; 1276 :     } else if (xmlStrEqual(cur->name, BAD_CAST "delegateURI")) {

	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlParseXM

; 1277 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_DELEGATE_URI,

	push	edi
	push	ebx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	12					; 0000000cH
	jmp	SHORT $LN50@xmlParseXM
$LN31@xmlParseXM:

; 1278 : 		BAD_CAST "delegateURI", BAD_CAST "uriStartString",
; 1279 : 		BAD_CAST "catalog", prefer, cgroup);
; 1280 :     } else if (xmlStrEqual(cur->name, BAD_CAST "nextCatalog")) {

	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlParseXM

; 1281 : 	entry = xmlParseXMLCatalogOneNode(cur, XML_CATA_NEXT_CATALOG,

	push	edi
	push	ebx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	0
	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	3
$LN50@xmlParseXM:

; 1282 : 		BAD_CAST "nextCatalog", NULL,
; 1283 : 		BAD_CAST "catalog", prefer, cgroup);
; 1284 :     }
; 1285 :     if (entry != NULL) {

	push	esi
	call	_xmlParseXMLCatalogOneNode
	add	esp, 28					; 0000001cH
	mov	ebx, eax
$LN33@xmlParseXM:
	test	ebx, ebx
	je	SHORT $LN38@xmlParseXM

; 1286 :         if (parent != NULL) {

	mov	eax, DWORD PTR _parent$[ebp]
	test	eax, eax
	je	SHORT $LN37@xmlParseXM

; 1287 : 	    entry->parent = parent;

	mov	DWORD PTR [ebx+4], eax

; 1288 : 	    if (parent->children == NULL)

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	jne	SHORT $LN36@xmlParseXM

; 1289 : 		parent->children = entry;

	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN37@xmlParseXM
$LN36@xmlParseXM:

; 1290 : 	    else {
; 1291 : 		xmlCatalogEntryPtr prev;
; 1292 : 
; 1293 : 		prev = parent->children;
; 1294 : 		while (prev->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN8@xmlParseXM
	npad	3
$LL7@xmlParseXM:
	mov	eax, DWORD PTR [ecx]

; 1295 : 		    prev = prev->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL7@xmlParseXM
	mov	eax, DWORD PTR _parent$[ebp]
$LN8@xmlParseXM:

; 1296 : 		prev->next = entry;

	mov	DWORD PTR [edx], ebx
$LN37@xmlParseXM:

; 1297 : 	    }
; 1298 : 	}
; 1299 : 	if (entry->type == XML_CATA_GROUP) {

	cmp	DWORD PTR [ebx+12], 4
	jne	SHORT $LN38@xmlParseXM

; 1300 : 	    /*
; 1301 : 	     * Recurse to propagate prefer to the subtree
; 1302 : 	     * (xml:base handling is automated)
; 1303 : 	     */
; 1304 :             xmlParseXMLCatalogNodeList(cur->children, prefer, parent, entry);

	push	ebx
	push	eax
	push	DWORD PTR _prefer$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlParseXMLCatalogNodeList
	add	esp, 16					; 00000010H
$LN38@xmlParseXM:

; 1305 : 	}
; 1306 :     }
; 1307 :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	SHORT $LN49@xmlParseXM

; 1308 : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN49@xmlParseXM:

; 1329 : 	}
; 1330 : 	cur = cur->next;

	mov	ebx, DWORD PTR _prefer$[ebp]
$LN39@xmlParseXM:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlParseXM
	pop	edi
	pop	ebx
$LN3@xmlParseXM:
	pop	esi

; 1331 :     }
; 1332 :     /* TODO: sort the list according to REWRITE lengths and prefer value */
; 1333 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLCatalogNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseXMLCatalogFile
_TEXT	SEGMENT
_prefer$ = 8						; size = 4
_doc$1$ = 12						; size = 4
_parent$1$ = 12						; size = 4
_filename$ = 12						; size = 4
_xmlParseXMLCatalogFile PROC				; COMDAT

; 1346 : xmlParseXMLCatalogFile(xmlCatalogPrefer prefer, const xmlChar *filename) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _filename$[ebp]
	test	ebx, ebx
	je	SHORT $LN4@xmlParseXM

; 1347 :     xmlDocPtr doc;
; 1348 :     xmlNodePtr cur;
; 1349 :     xmlChar *prop;
; 1350 :     xmlCatalogEntryPtr parent = NULL;
; 1351 : 
; 1352 :     if (filename == NULL)
; 1353 :         return(NULL);
; 1354 : 
; 1355 :     doc = xmlParseCatalogFile((const char *) filename);

	push	ebx
	call	_xmlParseCatalogFile
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _doc$1$[ebp], esi

; 1356 :     if (doc == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlParseXM

; 1357 : 	if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, eax
	je	SHORT $LN4@xmlParseXM

; 1358 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0BM@BEDEBNKA@Failed?5to?5parse?5catalog?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN4@xmlParseXM:

; 1359 : 		    "Failed to parse catalog %s\n", filename);
; 1360 : 	return(NULL);

	pop	esi
	xor	eax, eax

; 1403 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlParseXM:

; 1361 :     }
; 1362 : 
; 1363 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	push	edi
	je	SHORT $LN5@xmlParseXM

; 1364 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	ebx
	mov	esi, eax
	call	_xmlGetThreadId
	push	eax
	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BH@HBOEOPJE@?$CFd?5Parsing?5catalog?5?$CFs?6@
	push	DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _doc$1$[ebp]
	add	esp, 16					; 00000010H
$LN5@xmlParseXM:

; 1365 : 		"%d Parsing catalog %s\n", xmlGetThreadId(), filename);
; 1366 : 
; 1367 :     cur = xmlDocGetRootElement(doc);

	push	esi
	call	_xmlDocGetRootElement
	mov	edi, eax
	add	esp, 4

; 1368 :     if ((cur != NULL) && (xmlStrEqual(cur->name, BAD_CAST "catalog")) &&
; 1369 : 	(cur->ns != NULL) && (cur->ns->href != NULL) &&

	test	edi, edi
	je	$LN6@xmlParseXM
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlParseXM
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	$LN6@xmlParseXM
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	$LN6@xmlParseXM
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlParseXM

; 1370 : 	(xmlStrEqual(cur->ns->href, XML_CATALOGS_NAMESPACE))) {
; 1371 : 
; 1372 : 	parent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	push	DWORD PTR _prefer$[ebp]
	push	0
	push	ebx
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR _parent$1$[ebp], eax

; 1373 : 				    (const xmlChar *)filename, NULL, prefer, NULL);
; 1374 :         if (parent == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlParseXM

; 1375 : 	    xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 4

; 1376 : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1403 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlParseXM:

; 1377 : 	}
; 1378 : 
; 1379 : 	prop = xmlGetProp(cur, BAD_CAST "prefer");

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	push	edi
	call	_xmlGetProp
	mov	ebx, eax
	add	esp, 8

; 1380 : 	if (prop != NULL) {

	test	ebx, ebx
	je	SHORT $LN9@xmlParseXM

; 1381 : 	    if (xmlStrEqual(prop, BAD_CAST "system")) {

	push	OFFSET ??_C@_06FHFOAHML@system@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseXM

; 1382 : 		prefer = XML_CATA_PREFER_SYSTEM;

	mov	DWORD PTR _prefer$[ebp], 2
	jmp	SHORT $LN13@xmlParseXM
$LN10@xmlParseXM:

; 1383 : 	    } else if (xmlStrEqual(prop, BAD_CAST "public")) {

	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseXM

; 1384 : 		prefer = XML_CATA_PREFER_PUBLIC;

	mov	DWORD PTR _prefer$[ebp], 1

; 1385 : 	    } else {

	jmp	SHORT $LN13@xmlParseXM
$LN12@xmlParseXM:

; 1386 : 		xmlCatalogErr(NULL, cur, XML_CATALOG_PREFER_VALUE,

	push	0
	push	0
	push	ebx
	push	OFFSET ??_C@_0CA@KIJKHIJM@Invalid?5value?5for?5prefer?3?5?8?$CFs?8?6@
	push	1652					; 00000674H
	push	edi
	push	0
	call	_xmlCatalogErr
	add	esp, 28					; 0000001cH
$LN13@xmlParseXM:

; 1387 : 			      "Invalid value for prefer: '%s'\n",
; 1388 : 			      prop, NULL, NULL);
; 1389 : 	    }
; 1390 : 	    xmlFree(prop);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlParseXM:

; 1391 : 	}
; 1392 : 	cur = cur->children;
; 1393 : 	xmlParseXMLCatalogNodeList(cur, prefer, parent, NULL);

	mov	ebx, DWORD PTR _parent$1$[ebp]
	push	0
	push	ebx
	push	DWORD PTR _prefer$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlParseXMLCatalogNodeList

; 1399 : 	return(NULL);
; 1400 :     }
; 1401 :     xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 20					; 00000014H

; 1402 :     return(parent);

	mov	eax, ebx
	pop	edi
	pop	esi

; 1403 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlParseXM:

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,

	push	0
	push	0
	push	ebx
	push	OFFSET ??_C@_0BP@DJPOHLHG@File?5?$CFs?5is?5not?5an?5XML?5Catalog?6@
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	0
	push	0
	push	2
	push	1653					; 00000675H
	push	20					; 00000014H
	push	esi
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1394 :     } else {
; 1395 : 	xmlCatalogErr(NULL, (xmlNodePtr) doc, XML_CATALOG_NOT_CATALOG,
; 1396 : 		      "File %s is not an XML Catalog\n",
; 1397 : 		      filename, NULL, NULL);
; 1398 : 	xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 80					; 00000050H
	xor	eax, eax
	pop	edi
	pop	esi

; 1403 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlParseXMLCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadFileContent
_TEXT	SEGMENT
_info$ = -48						; size = 48
_filename$ = 8						; size = 4
_xmlLoadFileContent PROC				; COMDAT

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	ecx, OFFSET __0FC738B4_catalog@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	test	esi, esi
	je	$LN10@xmlLoadFil
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	push	esi
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c

; 979  :     if (stat(filename, &info) < 0)

	test	eax, eax
	js	SHORT $LN10@xmlLoadFil

; 980  :         return (NULL);
; 981  : #endif
; 982  : 
; 983  : #ifdef HAVE_STAT
; 984  :     if ((fd = open(filename, O_RDONLY)) < 0)

	push	0
	push	esi
	call	DWORD PTR __imp__open
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	js	SHORT $LN10@xmlLoadFil

; 990  :     }
; 991  : #ifdef HAVE_STAT
; 992  :     size = info.st_size;

	push	ebx
	mov	ebx, DWORD PTR _info$[ebp+20]

; 993  : #else
; 994  :     if (fseek(fd, 0, SEEK_END) || (size = ftell(fd)) == EOF || fseek(fd, 0, SEEK_SET)) {        /* File operations denied? ok, just close and return failure */
; 995  :         fclose(fd);
; 996  :         return (NULL);
; 997  :     }
; 998  : #endif
; 999  :     content = (xmlChar*)xmlMallocAtomic(size + 10);

	lea	ecx, DWORD PTR [ebx+10]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	mov	esi, eax
	add	esp, 4

; 1000 :     if (content == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlLoadFil

; 1001 :         xmlCatalogErrMemory("allocating catalog data");

	push	OFFSET ??_C@_0BI@CBBLIKLJ@allocating?5catalog?5data@
	call	_xmlCatalogErrMemory

; 1002 : #ifdef HAVE_STAT
; 1003 : 	close(fd);

	push	edi
	call	DWORD PTR __imp__close
	add	esp, 8

; 1004 : #else
; 1005 : 	fclose(fd);
; 1006 : #endif
; 1007 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1023 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlLoadFil:

; 1008 :     }
; 1009 : #ifdef HAVE_STAT
; 1010 :     len = read(fd, content, size);

	push	ebx
	push	esi
	push	edi
	call	DWORD PTR __imp__read

; 1011 :     close(fd);

	push	edi
	mov	ebx, eax
	call	DWORD PTR __imp__close
	add	esp, 16					; 00000010H

; 1012 : #else
; 1013 :     len = fread(content, 1, size, fd);
; 1014 :     fclose(fd);
; 1015 : #endif
; 1016 :     if (len < 0) {

	test	ebx, ebx
	jns	SHORT $LN6@xmlLoadFil

; 1017 :         xmlFree(content);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	ebx
	pop	edi

; 1023 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlLoadFil:

; 1018 :         return (NULL);
; 1019 :     }
; 1020 :     content[len] = 0;

	mov	BYTE PTR [ebx+esi], 0

; 1021 : 
; 1022 :     return(content);

	mov	eax, esi
	pop	ebx
	pop	edi

; 1023 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlLoadFil:
	pop	edi

; 985  : #else
; 986  :     if ((fd = fopen(filename, "rb")) == NULL)
; 987  : #endif
; 988  :     {
; 989  :         return (NULL);

	xor	eax, eax

; 1023 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLoadFileContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogUnWrapURN
_TEXT	SEGMENT
_result$ = -2000					; size = 2000
_urn$ = 8						; size = 4
_xmlCatalogUnWrapURN PROC				; COMDAT

; 827  : xmlCatalogUnWrapURN(const xmlChar *urn) {

	push	ebp
	mov	ebp, esp
	sub	esp, 2000				; 000007d0H
	mov	ecx, OFFSET __0FC738B4_catalog@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _urn$[ebp]
	xor	esi, esi
	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@NOBDOKAH@urn?3publicid?3@
	push	edi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@xmlCatalog

; 828  :     xmlChar result[2000];
; 829  :     unsigned int i = 0;
; 830  : 
; 831  :     if (xmlStrncmp(urn, BAD_CAST XML_URN_PUBID, sizeof(XML_URN_PUBID) - 1))
; 832  : 	return(NULL);

	pop	edi
	xor	eax, eax

; 880  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCatalog:

; 833  :     urn += sizeof(XML_URN_PUBID) - 1;
; 834  : 
; 835  :     while (*urn != 0) {

	mov	cl, BYTE PTR [edi+13]
	add	edi, 13					; 0000000dH
	test	cl, cl
	je	$LN49@xmlCatalog
$LL2@xmlCatalog:

; 836  : 	if (i > sizeof(result) - 4)

	cmp	esi, 1996				; 000007ccH
	ja	$LN49@xmlCatalog

; 837  : 	    break;
; 838  : 	if (*urn == '+') {

	cmp	cl, 43					; 0000002bH
	jne	SHORT $LN6@xmlCatalog

; 839  : 	    result[i++] = ' ';

	mov	BYTE PTR _result$[ebp+esi], 32		; 00000020H

; 840  : 	    urn++;

	jmp	$LN50@xmlCatalog
$LN6@xmlCatalog:

; 841  : 	} else if (*urn == ':') {

	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN8@xmlCatalog

; 842  : 	    result[i++] = '/';

	mov	WORD PTR _result$[ebp+esi], 12079	; 00002f2fH

; 843  : 	    result[i++] = '/';
; 844  : 	    urn++;

	mov	eax, 2
	jmp	$LN51@xmlCatalog
$LN8@xmlCatalog:

; 845  : 	} else if (*urn == ';') {

	cmp	cl, 59					; 0000003bH
	jne	SHORT $LN10@xmlCatalog

; 846  : 	    result[i++] = ':';

	mov	WORD PTR _result$[ebp+esi], 14906	; 00003a3aH

; 847  : 	    result[i++] = ':';
; 848  : 	    urn++;

	mov	eax, 2
	jmp	$LN51@xmlCatalog
$LN10@xmlCatalog:

; 849  : 	} else if (*urn == '%') {

	cmp	cl, 37					; 00000025H
	jne	$LN12@xmlCatalog

; 850  : 	    if ((urn[1] == '2') && (urn[2] == 'B'))

	mov	al, BYTE PTR [edi+1]
	cmp	al, 50					; 00000032H
	jne	SHORT $LN35@xmlCatalog
	cmp	BYTE PTR [edi+2], 66			; 00000042H
	jne	SHORT $LN43@xmlCatalog

; 851  : 		result[i++] = '+';

	mov	BYTE PTR _result$[ebp+esi], 43		; 0000002bH

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	$LN13@xmlCatalog
$LN35@xmlCatalog:

; 852  : 	    else if ((urn[1] == '3') && (urn[2] == 'A'))

	cmp	al, 51					; 00000033H
	jne	SHORT $LN36@xmlCatalog
	cmp	BYTE PTR [edi+2], 65			; 00000041H
	jne	SHORT $LN44@xmlCatalog

; 853  : 		result[i++] = ':';

	mov	BYTE PTR _result$[ebp+esi], 58		; 0000003aH

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	$LN13@xmlCatalog
$LN36@xmlCatalog:

; 854  : 	    else if ((urn[1] == '2') && (urn[2] == 'F'))

	cmp	al, 50					; 00000032H
	jne	SHORT $LN37@xmlCatalog
$LN43@xmlCatalog:
	cmp	BYTE PTR [edi+2], 70			; 00000046H
	jne	SHORT $LN45@xmlCatalog

; 855  : 		result[i++] = '/';

	mov	BYTE PTR _result$[ebp+esi], 47		; 0000002fH

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	$LN13@xmlCatalog
$LN37@xmlCatalog:

; 856  : 	    else if ((urn[1] == '3') && (urn[2] == 'B'))

	cmp	al, 51					; 00000033H
	jne	SHORT $LN38@xmlCatalog
$LN44@xmlCatalog:
	cmp	BYTE PTR [edi+2], 66			; 00000042H
	jne	SHORT $LN46@xmlCatalog

; 857  : 		result[i++] = ';';

	mov	BYTE PTR _result$[ebp+esi], 59		; 0000003bH

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	$LN13@xmlCatalog
$LN38@xmlCatalog:

; 858  : 	    else if ((urn[1] == '2') && (urn[2] == '7'))

	cmp	al, 50					; 00000032H
	jne	SHORT $LN39@xmlCatalog
$LN45@xmlCatalog:
	cmp	BYTE PTR [edi+2], 55			; 00000037H
	jne	SHORT $LN47@xmlCatalog

; 859  : 		result[i++] = '\'';

	mov	BYTE PTR _result$[ebp+esi], 39		; 00000027H

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	SHORT $LN13@xmlCatalog
$LN39@xmlCatalog:

; 860  : 	    else if ((urn[1] == '3') && (urn[2] == 'F'))

	cmp	al, 51					; 00000033H
	jne	SHORT $LN40@xmlCatalog
$LN46@xmlCatalog:
	cmp	BYTE PTR [edi+2], 70			; 00000046H
	jne	SHORT $LN28@xmlCatalog

; 861  : 		result[i++] = '?';

	mov	BYTE PTR _result$[ebp+esi], 63		; 0000003fH

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	SHORT $LN13@xmlCatalog
$LN40@xmlCatalog:

; 862  : 	    else if ((urn[1] == '2') && (urn[2] == '3'))

	cmp	al, 50					; 00000032H
	jne	SHORT $LN28@xmlCatalog
$LN47@xmlCatalog:
	mov	al, BYTE PTR [edi+2]
	cmp	al, 51					; 00000033H
	jne	SHORT $LN48@xmlCatalog

; 863  : 		result[i++] = '#';

	mov	BYTE PTR _result$[ebp+esi], 35		; 00000023H

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	SHORT $LN13@xmlCatalog
$LN48@xmlCatalog:

; 864  : 	    else if ((urn[1] == '2') && (urn[2] == '5'))

	cmp	al, 53					; 00000035H
	jne	SHORT $LN28@xmlCatalog

; 865  : 		result[i++] = '%';

	mov	BYTE PTR _result$[ebp+esi], 37		; 00000025H

; 870  : 	    }
; 871  : 	    urn += 3;

	add	edi, 3
	mov	eax, 1

; 872  : 	} else {

	jmp	SHORT $LN13@xmlCatalog
$LN28@xmlCatalog:

; 866  : 	    else {
; 867  : 		result[i++] = *urn;

	mov	BYTE PTR _result$[ebp+esi], 37		; 00000025H

; 868  : 		urn++;
; 869  : 		continue;

	jmp	SHORT $LN50@xmlCatalog
$LN12@xmlCatalog:

; 873  : 	    result[i++] = *urn;

	mov	BYTE PTR _result$[ebp+esi], cl
$LN50@xmlCatalog:

; 833  :     urn += sizeof(XML_URN_PUBID) - 1;
; 834  : 
; 835  :     while (*urn != 0) {

	mov	eax, 1
$LN51@xmlCatalog:
	inc	edi
$LN13@xmlCatalog:
	mov	cl, BYTE PTR [edi]
	add	esi, eax
	test	cl, cl
	jne	$LL2@xmlCatalog
$LN49@xmlCatalog:

; 874  : 	    urn++;
; 875  : 	}
; 876  :     }
; 877  :     result[i] = 0;
; 878  : 
; 879  :     return(xmlStrdup(result));

	lea	eax, DWORD PTR _result$[ebp]
	mov	BYTE PTR _result$[ebp+esi], 0
	push	eax
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 880  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCatalogUnWrapURN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogConvertEntry
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCatalogConvertEntry PROC				; COMDAT

; 732  :                        const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	test	esi, esi
	je	$LN7@xmlCatalog

; 733  :     xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;
; 734  :     xmlCatalogPtr catal = (xmlCatalogPtr) data;
; 735  :     if ((entry == NULL) || (catal == NULL) || (catal->sgml == NULL) ||

	push	edi
	mov	edi, DWORD PTR _data$[ebp]
	test	edi, edi
	je	$LN26@xmlCatalog
	mov	ecx, DWORD PTR [edi+52]
	test	ecx, ecx
	je	$LN26@xmlCatalog
	cmp	DWORD PTR [edi+60], 0
	je	$LN26@xmlCatalog

; 736  : 	(catal->xml == NULL))
; 737  : 	return;
; 738  :     switch (entry->type) {

	mov	eax, DWORD PTR [esi+12]
	add	eax, -13				; fffffff3H
	cmp	eax, 9
	ja	SHORT $LN17@xmlCatalog
	movzx	eax, BYTE PTR $LN25@xmlCatalog[eax]
	jmp	DWORD PTR $LN28@xmlCatalog[eax*4]
$LN13@xmlCatalog:

; 739  : 	case SGML_CATA_ENTITY:
; 740  : 	    entry->type = XML_CATA_PUBLIC;
; 741  : 	    break;
; 742  : 	case SGML_CATA_PENTITY:
; 743  : 	    entry->type = XML_CATA_PUBLIC;
; 744  : 	    break;
; 745  : 	case SGML_CATA_DOCTYPE:
; 746  : 	    entry->type = XML_CATA_PUBLIC;
; 747  : 	    break;
; 748  : 	case SGML_CATA_LINKTYPE:
; 749  : 	    entry->type = XML_CATA_PUBLIC;
; 750  : 	    break;
; 751  : 	case SGML_CATA_NOTATION:
; 752  : 	    entry->type = XML_CATA_PUBLIC;
; 753  : 	    break;
; 754  : 	case SGML_CATA_PUBLIC:
; 755  : 	    entry->type = XML_CATA_PUBLIC;

	mov	DWORD PTR [esi+12], 5

; 756  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN14@xmlCatalog:

; 757  : 	case SGML_CATA_SYSTEM:
; 758  : 	    entry->type = XML_CATA_SYSTEM;

	mov	DWORD PTR [esi+12], 6

; 759  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN15@xmlCatalog:

; 760  : 	case SGML_CATA_DELEGATE:
; 761  : 	    entry->type = XML_CATA_DELEGATE_PUBLIC;

	mov	DWORD PTR [esi+12], 8

; 762  : 	    break;

	jmp	SHORT $LN2@xmlCatalog
$LN16@xmlCatalog:

; 763  : 	case SGML_CATA_CATALOG:
; 764  : 	    entry->type = XML_CATA_CATALOG;

	mov	DWORD PTR [esi+12], 1
$LN2@xmlCatalog:

; 768  : 	    return;
; 769  :     }
; 770  :     /*
; 771  :      * Conversion successful, remove from the SGML catalog
; 772  :      * and add it to the default XML one
; 773  :      */
; 774  :     xmlHashRemoveEntry(catal->sgml, entry->name, NULL);

	push	0
	push	DWORD PTR [esi+16]
	push	DWORD PTR [edi+52]
	call	_xmlHashRemoveEntry

; 775  :     entry->parent = catal->xml;

	mov	eax, DWORD PTR [edi+60]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax

; 776  :     entry->next = NULL;

	mov	DWORD PTR [esi], 0

; 777  :     if (catal->xml->children == NULL)

	mov	eax, DWORD PTR [edi+60]
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	jne	SHORT $LN18@xmlCatalog

; 778  : 	catal->xml->children = entry;

	pop	edi
	mov	DWORD PTR [eax+8], esi
	pop	esi

; 786  :     }
; 787  : }

	pop	ebp
	ret	0
$LN18@xmlCatalog:

; 779  :     else {
; 780  : 	xmlCatalogEntryPtr prev;
; 781  : 
; 782  : 	prev = catal->xml->children;
; 783  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN5@xmlCatalog
$LL4@xmlCatalog:
	mov	eax, DWORD PTR [ecx]

; 784  : 	    prev = prev->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL4@xmlCatalog
$LN5@xmlCatalog:
	pop	edi

; 785  : 	prev->next = entry;

	mov	DWORD PTR [edx], esi
	pop	esi

; 786  :     }
; 787  : }

	pop	ebp
	ret	0
$LN17@xmlCatalog:

; 765  : 	    break;
; 766  : 	default:
; 767  : 	    xmlHashRemoveEntry(catal->sgml, entry->name, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	push	DWORD PTR [esi+16]
	push	ecx
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
$LN26@xmlCatalog:
	pop	edi
$LN7@xmlCatalog:
	pop	esi

; 786  :     }
; 787  : }

	pop	ebp
	ret	0
	npad	3
$LN28@xmlCatalog:
	DD	$LN14@xmlCatalog
	DD	$LN13@xmlCatalog
	DD	$LN15@xmlCatalog
	DD	$LN16@xmlCatalog
	DD	$LN17@xmlCatalog
$LN25@xmlCatalog:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	4
	DB	3
_xmlCatalogConvertEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDumpXMLCatalog
_TEXT	SEGMENT
_out$ = 8						; size = 4
_catal$ = 12						; size = 4
_xmlDumpXMLCatalog PROC					; COMDAT

; 662  : xmlDumpXMLCatalog(FILE *out, xmlCatalogEntryPtr catal) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	call	_xmlNewDoc
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlDumpXML

; 663  :     int ret;
; 664  :     xmlDocPtr doc;
; 665  :     xmlNsPtr ns;
; 666  :     xmlDtdPtr dtd;
; 667  :     xmlNodePtr catalog;
; 668  :     xmlOutputBufferPtr buf;
; 669  : 
; 670  :     /*
; 671  :      * Rebuild a catalog
; 672  :      */
; 673  :     doc = xmlNewDoc(NULL);
; 674  :     if (doc == NULL)
; 675  : 	return(-1);

	or	eax, -1
	pop	edi

; 714  : }

	pop	ebp
	ret	0
$LN2@xmlDumpXML:
	push	ebx
	push	esi

; 676  :     dtd = xmlNewDtd(doc, BAD_CAST "catalog",

	push	OFFSET ??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@
	push	OFFSET ??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	edi
	call	_xmlNewDtd

; 677  : 	       BAD_CAST "-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN",
; 678  : BAD_CAST "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
; 679  : 
; 680  :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	push	eax
	push	edi
	call	_xmlAddChild

; 681  : 
; 682  :     ns = xmlNewNs(NULL, XML_CATALOGS_NAMESPACE, NULL);

	push	0
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	0
	call	_xmlNewNs
	mov	esi, eax
	add	esp, 36					; 00000024H

; 683  :     if (ns == NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlDumpXML

; 684  : 	xmlFreeDoc(doc);
; 685  : 	return(-1);
; 686  :     }
; 687  :     catalog = xmlNewDocNode(doc, ns, BAD_CAST "catalog", NULL);

	push	0
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	esi
	push	edi
	call	_xmlNewDocNode
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 688  :     if (catalog == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlDumpXML

; 689  : 	xmlFreeNs(ns);

	push	esi
	call	_xmlFreeNs

; 690  : 	xmlFreeDoc(doc);

	push	edi
	call	_xmlFreeDoc
	add	esp, 8

; 704  : 	return(-1);

	or	eax, -1
	pop	esi
	pop	ebx
	pop	edi

; 714  : }

	pop	ebp
	ret	0
$LN4@xmlDumpXML:

; 691  : 	return(-1);
; 692  :     }
; 693  :     catalog->nsDef = ns;
; 694  :     xmlAddChild((xmlNodePtr) doc, catalog);

	push	ebx
	push	edi
	mov	DWORD PTR [ebx+48], esi
	call	_xmlAddChild

; 695  : 
; 696  :     xmlDumpXMLCatalogNode(catal, catalog, doc, ns, NULL);

	push	0
	push	esi
	push	edi
	push	ebx
	push	DWORD PTR _catal$[ebp]
	call	_xmlDumpXMLCatalogNode

; 697  : 
; 698  :     /*
; 699  :      * reserialize it
; 700  :      */
; 701  :     buf = xmlOutputBufferCreateFile(out, NULL);

	push	0
	push	DWORD PTR _out$[ebp]
	call	_xmlOutputBufferCreateFile
	add	esp, 36					; 00000024H

; 702  :     if (buf == NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlDumpXML

; 705  :     }
; 706  :     ret = xmlSaveFormatFileTo(buf, doc, NULL, 1);

	push	1
	push	0
	push	edi
	push	eax
	call	_xmlSaveFormatFileTo

; 707  : 
; 708  :     /*
; 709  :      * Free it
; 710  :      */
; 711  :     xmlFreeDoc(doc);

	push	edi
	mov	esi, eax
	call	_xmlFreeDoc
	add	esp, 20					; 00000014H

; 712  : 
; 713  :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 714  : }

	pop	ebp
	ret	0
$LN7@xmlDumpXML:

; 703  : 	xmlFreeDoc(doc);

	push	edi
	call	_xmlFreeDoc
	add	esp, 4

; 704  : 	return(-1);

	or	eax, -1
	pop	esi
	pop	ebx
	pop	edi

; 714  : }

	pop	ebp
	ret	0
_xmlDumpXMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlDumpXMLCatalogNode
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_catalog$ = 12						; size = 4
_doc$ = 16						; size = 4
_ns$ = 20						; size = 4
_cgroup$ = 24						; size = 4
_xmlDumpXMLCatalogNode PROC				; COMDAT

; 545  : 		    xmlDocPtr doc, xmlNsPtr ns, xmlCatalogEntryPtr cgroup) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _catal$[ebp]
	mov	edi, edx
	test	edx, edx
	je	$LN3@xmlDumpXML
	mov	ecx, DWORD PTR _ns$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _doc$[ebp]
	push	esi
$LL2@xmlDumpXML:

; 553  :         if (cur->group == cgroup) {

	mov	eax, DWORD PTR _cgroup$[ebp]
	cmp	DWORD PTR [edi+40], eax
	jne	$LN28@xmlDumpXML

; 554  : 	    switch (cur->type) {

	mov	eax, DWORD PTR [edi+12]
	dec	eax
	cmp	eax, 11					; 0000000bH
	ja	$LN28@xmlDumpXML
	jmp	DWORD PTR $LN40@xmlDumpXML[eax*4]
$LN10@xmlDumpXML:

; 555  : 	        case XML_CATA_REMOVED:
; 556  : 		    break;
; 557  : 	        case XML_CATA_BROKEN_CATALOG:
; 558  : 	        case XML_CATA_CATALOG:
; 559  : 		    if (cur == catal) {

	cmp	edi, edx
	jne	$LN28@xmlDumpXML

; 560  : 			cur = cur->children;

	mov	edi, DWORD PTR [edi+8]

; 561  : 		        continue;

	jmp	$LN32@xmlDumpXML
$LN12@xmlDumpXML:

; 562  : 		    }
; 563  : 		    break;
; 564  : 		case XML_CATA_NEXT_CATALOG:
; 565  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "nextCatalog", NULL);

	push	0
	push	OFFSET ??_C@_0M@IKOOEBPK@nextCatalog@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 566  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);

	push	DWORD PTR [edi+20]
	mov	esi, eax
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	esi
	call	_xmlSetProp

; 567  : 		    xmlAddChild(catalog, node);

	push	esi
	push	DWORD PTR _catalog$[ebp]
	call	_xmlAddChild
	add	esp, 36					; 00000024H

; 568  :                     break;

	jmp	$LN35@xmlDumpXML
$LN14@xmlDumpXML:

; 569  : 		case XML_CATA_NONE:
; 570  : 		    break;
; 571  : 		case XML_CATA_GROUP:
; 572  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "group", NULL);

	push	0
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 573  : 		    xmlSetProp(node, BAD_CAST "id", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	esi
	call	_xmlSetProp
	add	esp, 28					; 0000001cH

; 574  : 		    if (cur->value != NULL) {

	cmp	DWORD PTR [edi+20], 0
	je	SHORT $LN16@xmlDumpXML

; 575  : 		        xmlNsPtr xns;
; 576  : 			xns = xmlSearchNsByHref(doc, node, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	push	ebx
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 577  : 			if (xns != NULL)

	test	eax, eax
	je	SHORT $LN16@xmlDumpXML

; 578  : 			    xmlSetNsProp(node, xns, BAD_CAST "base",

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	eax
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
$LN16@xmlDumpXML:

; 579  : 					 cur->value);
; 580  : 		    }
; 581  : 		    switch (cur->prefer) {

	mov	eax, DWORD PTR [edi+28]
	sub	eax, 1
	je	SHORT $LN18@xmlDumpXML
	sub	eax, 1
	jne	SHORT $LN6@xmlDumpXML

; 586  : 			    break;
; 587  : 			case XML_CATA_PREFER_SYSTEM:
; 588  : 		            xmlSetProp(node, BAD_CAST "prefer", BAD_CAST "system");

	push	OFFSET ??_C@_06FHFOAHML@system@
	jmp	SHORT $LN36@xmlDumpXML
$LN18@xmlDumpXML:

; 582  : 			case XML_CATA_PREFER_NONE:
; 583  : 		            break;
; 584  : 			case XML_CATA_PREFER_PUBLIC:
; 585  : 		            xmlSetProp(node, BAD_CAST "prefer", BAD_CAST "public");

	push	OFFSET ??_C@_06EOMAMIIF@public@
$LN36@xmlDumpXML:

; 589  : 			    break;
; 590  : 		    }
; 591  : 		    xmlDumpXMLCatalogNode(cur->next, node, doc, ns, cur);

	push	OFFSET ??_C@_06NEJLBODN@prefer@
	push	esi
	call	_xmlSetProp
	add	esp, 12					; 0000000cH
$LN6@xmlDumpXML:
	push	edi
	push	DWORD PTR _ns$[ebp]
	push	ebx
	push	esi
	push	DWORD PTR [edi]
	call	_xmlDumpXMLCatalogNode

; 592  : 		    xmlAddChild(catalog, node);

	push	esi
	push	DWORD PTR _catalog$[ebp]
	call	_xmlAddChild
	add	esp, 28					; 0000001cH

; 593  : 	            break;

	jmp	$LN35@xmlDumpXML
$LN20@xmlDumpXML:

; 594  : 		case XML_CATA_PUBLIC:
; 595  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "public", NULL);

	push	0
	push	OFFSET ??_C@_06EOMAMIIF@public@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 596  : 		    xmlSetProp(node, BAD_CAST "publicId", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_08KNJBHAKA@publicId@
	push	esi
	call	_xmlSetProp

; 597  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_03GBBABMJN@uri@

; 598  : 		    xmlAddChild(catalog, node);
; 599  : 		    break;

	jmp	$LN37@xmlDumpXML
$LN21@xmlDumpXML:

; 600  : 		case XML_CATA_SYSTEM:
; 601  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "system", NULL);

	push	0
	push	OFFSET ??_C@_06FHFOAHML@system@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 602  : 		    xmlSetProp(node, BAD_CAST "systemId", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_08MILANEJE@systemId@
	push	esi
	call	_xmlSetProp

; 603  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_03GBBABMJN@uri@

; 604  : 		    xmlAddChild(catalog, node);
; 605  : 		    break;

	jmp	$LN37@xmlDumpXML
$LN22@xmlDumpXML:

; 606  : 		case XML_CATA_REWRITE_SYSTEM:
; 607  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "rewriteSystem", NULL);

	push	0
	push	OFFSET ??_C@_0O@CCMDBGLO@rewriteSystem@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 608  : 		    xmlSetProp(node, BAD_CAST "systemIdStartString", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@
	push	esi
	call	_xmlSetProp

; 609  : 		    xmlSetProp(node, BAD_CAST "rewritePrefix", cur->value);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@

; 610  : 		    xmlAddChild(catalog, node);
; 611  : 		    break;

	jmp	$LN37@xmlDumpXML
$LN23@xmlDumpXML:

; 612  : 		case XML_CATA_DELEGATE_PUBLIC:
; 613  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegatePublic", NULL);

	push	0
	push	OFFSET ??_C@_0P@FNMIEEAK@delegatePublic@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 614  : 		    xmlSetProp(node, BAD_CAST "publicIdStartString", cur->name);

	push	DWORD PTR [edi+16]
	push	OFFSET ??_C@_0BE@JKBIFJL@publicIdStartString@

; 615  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);
; 616  : 		    xmlAddChild(catalog, node);
; 617  : 		    break;

	jmp	SHORT $LN38@xmlDumpXML
$LN24@xmlDumpXML:

; 618  : 		case XML_CATA_DELEGATE_SYSTEM:
; 619  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegateSystem", NULL);

	push	0
	push	OFFSET ??_C@_0P@EEFGILEE@delegateSystem@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 620  : 		    xmlSetProp(node, BAD_CAST "systemIdStartString", cur->name);

	push	DWORD PTR [edi+16]
	push	OFFSET ??_C@_0BE@DMCACPJB@systemIdStartString@

; 621  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);
; 622  : 		    xmlAddChild(catalog, node);
; 623  : 		    break;

	jmp	SHORT $LN38@xmlDumpXML
$LN25@xmlDumpXML:

; 624  : 		case XML_CATA_URI:
; 625  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "uri", NULL);

	push	0
	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 626  : 		    xmlSetProp(node, BAD_CAST "name", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	esi
	call	_xmlSetProp

; 627  : 		    xmlSetProp(node, BAD_CAST "uri", cur->value);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_03GBBABMJN@uri@

; 628  : 		    xmlAddChild(catalog, node);
; 629  : 		    break;

	jmp	SHORT $LN37@xmlDumpXML
$LN26@xmlDumpXML:

; 630  : 		case XML_CATA_REWRITE_URI:
; 631  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "rewriteURI", NULL);

	push	0
	push	OFFSET ??_C@_0L@BCFABNDK@rewriteURI@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 632  : 		    xmlSetProp(node, BAD_CAST "uriStartString", cur->name);

	push	DWORD PTR [edi+16]
	mov	esi, eax
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
	push	esi
	call	_xmlSetProp

; 633  : 		    xmlSetProp(node, BAD_CAST "rewritePrefix", cur->value);

	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_0O@FCPDBOKG@rewritePrefix@

; 634  : 		    xmlAddChild(catalog, node);
; 635  : 		    break;

	jmp	SHORT $LN37@xmlDumpXML
$LN27@xmlDumpXML:

; 636  : 		case XML_CATA_DELEGATE_URI:
; 637  : 		    node = xmlNewDocNode(doc, ns, BAD_CAST "delegateURI", NULL);

	push	0
	push	OFFSET ??_C@_0M@NHAMNMJD@delegateURI@
	push	ecx
	push	ebx
	call	_xmlNewDocNode

; 638  : 		    xmlSetProp(node, BAD_CAST "uriStartString", cur->name);

	push	DWORD PTR [edi+16]
	push	OFFSET ??_C@_0P@HNKDCBAK@uriStartString@
$LN38@xmlDumpXML:

; 639  : 		    xmlSetProp(node, BAD_CAST "catalog", cur->value);
; 640  : 		    xmlAddChild(catalog, node);
; 641  : 		    break;
; 642  : 		case SGML_CATA_SYSTEM:
; 643  : 		case SGML_CATA_PUBLIC:
; 644  : 		case SGML_CATA_ENTITY:
; 645  : 		case SGML_CATA_PENTITY:
; 646  : 		case SGML_CATA_DOCTYPE:
; 647  : 		case SGML_CATA_LINKTYPE:
; 648  : 		case SGML_CATA_NOTATION:
; 649  : 		case SGML_CATA_DELEGATE:
; 650  : 		case SGML_CATA_BASE:
; 651  : 		case SGML_CATA_CATALOG:
; 652  : 		case SGML_CATA_DOCUMENT:
; 653  : 		case SGML_CATA_SGMLDECL:
; 654  : 		    break;
; 655  : 	    }
; 656  :         }
; 657  : 	cur = cur->next;

	mov	esi, eax
	push	esi
	call	_xmlSetProp
	push	DWORD PTR [edi+20]
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
$LN37@xmlDumpXML:
	push	esi
	call	_xmlSetProp
	push	esi
	push	DWORD PTR _catalog$[ebp]
	call	_xmlAddChild
	add	esp, 48					; 00000030H
$LN35@xmlDumpXML:
	mov	edx, DWORD PTR _catal$[ebp]
	mov	ecx, DWORD PTR _ns$[ebp]
$LN28@xmlDumpXML:
	mov	edi, DWORD PTR [edi]
$LN32@xmlDumpXML:

; 546  :     xmlNodePtr node;
; 547  :     xmlCatalogEntryPtr cur;
; 548  :     /*
; 549  :      * add all the catalog entries
; 550  :      */
; 551  :     cur = catal;
; 552  :     while (cur != NULL) {

	test	edi, edi
	jne	$LL2@xmlDumpXML
	pop	esi
	pop	ebx
$LN3@xmlDumpXML:
	pop	edi

; 658  :     }
; 659  : }

	pop	ebp
	ret	0
	npad	3
$LN40@xmlDumpXML:
	DD	$LN10@xmlDumpXML
	DD	$LN10@xmlDumpXML
	DD	$LN12@xmlDumpXML
	DD	$LN14@xmlDumpXML
	DD	$LN20@xmlDumpXML
	DD	$LN21@xmlDumpXML
	DD	$LN22@xmlDumpXML
	DD	$LN23@xmlDumpXML
	DD	$LN24@xmlDumpXML
	DD	$LN25@xmlDumpXML
	DD	$LN26@xmlDumpXML
	DD	$LN27@xmlDumpXML
_xmlDumpXMLCatalogNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogDumpEntry
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCatalogDumpEntry PROC				; COMDAT

; 466  :                     const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	test	esi, esi
	je	$LN22@xmlCatalog

; 467  :     xmlCatalogEntryPtr entry = (xmlCatalogEntryPtr) payload;
; 468  :     FILE *out = (FILE *) data;
; 469  :     if ((entry == NULL) || (out == NULL))

	push	edi
	mov	edi, DWORD PTR _data$[ebp]
	test	edi, edi
	je	$LN30@xmlCatalog

; 470  : 	return;
; 471  :     switch (entry->type) {

	mov	eax, DWORD PTR [esi+12]
	add	eax, -13				; fffffff3H
	cmp	eax, 11					; 0000000bH
	ja	$LN30@xmlCatalog
	jmp	DWORD PTR $LN33@xmlCatalog[eax*4]
$LN10@xmlCatalog:

; 472  : 	case SGML_CATA_ENTITY:
; 473  : 	    fprintf(out, "ENTITY "); break;

	mov	eax, OFFSET ??_C@_07JPOODLIK@ENTITY?5@
	jmp	SHORT $LN2@xmlCatalog
$LN11@xmlCatalog:

; 474  : 	case SGML_CATA_PENTITY:
; 475  : 	    fprintf(out, "ENTITY %%"); break;

	mov	eax, OFFSET ??_C@_09KGBCFCOH@ENTITY?5?$CF?$CF@
	jmp	SHORT $LN2@xmlCatalog
$LN12@xmlCatalog:

; 476  : 	case SGML_CATA_DOCTYPE:
; 477  : 	    fprintf(out, "DOCTYPE "); break;

	mov	eax, OFFSET ??_C@_08JFBCIFIP@DOCTYPE?5@
	jmp	SHORT $LN2@xmlCatalog
$LN13@xmlCatalog:

; 478  : 	case SGML_CATA_LINKTYPE:
; 479  : 	    fprintf(out, "LINKTYPE "); break;

	mov	eax, OFFSET ??_C@_09BKBNLHNH@LINKTYPE?5@
	jmp	SHORT $LN2@xmlCatalog
$LN14@xmlCatalog:

; 480  : 	case SGML_CATA_NOTATION:
; 481  : 	    fprintf(out, "NOTATION "); break;

	mov	eax, OFFSET ??_C@_09EADGFDGH@NOTATION?5@
	jmp	SHORT $LN2@xmlCatalog
$LN15@xmlCatalog:

; 482  : 	case SGML_CATA_PUBLIC:
; 483  : 	    fprintf(out, "PUBLIC "); break;

	mov	eax, OFFSET ??_C@_07GAMBALOD@PUBLIC?5@
	jmp	SHORT $LN2@xmlCatalog
$LN16@xmlCatalog:

; 484  : 	case SGML_CATA_SYSTEM:
; 485  : 	    fprintf(out, "SYSTEM "); break;

	mov	eax, OFFSET ??_C@_07PBLMPJLL@SYSTEM?5@
	jmp	SHORT $LN2@xmlCatalog
$LN17@xmlCatalog:

; 486  : 	case SGML_CATA_DELEGATE:
; 487  : 	    fprintf(out, "DELEGATE "); break;

	mov	eax, OFFSET ??_C@_09KHFEEDDG@DELEGATE?5@
	jmp	SHORT $LN2@xmlCatalog
$LN18@xmlCatalog:

; 488  : 	case SGML_CATA_BASE:
; 489  : 	    fprintf(out, "BASE "); break;

	mov	eax, OFFSET ??_C@_05FDFDEPAH@BASE?5@
	jmp	SHORT $LN2@xmlCatalog
$LN19@xmlCatalog:

; 490  : 	case SGML_CATA_CATALOG:
; 491  : 	    fprintf(out, "CATALOG "); break;

	mov	eax, OFFSET ??_C@_08LGGFEAEJ@CATALOG?5@
	jmp	SHORT $LN2@xmlCatalog
$LN20@xmlCatalog:

; 492  : 	case SGML_CATA_DOCUMENT:
; 493  : 	    fprintf(out, "DOCUMENT "); break;

	mov	eax, OFFSET ??_C@_09PKNPLMNA@DOCUMENT?5@
	jmp	SHORT $LN2@xmlCatalog
$LN21@xmlCatalog:

; 494  : 	case SGML_CATA_SGMLDECL:
; 495  : 	    fprintf(out, "SGMLDECL "); break;

	mov	eax, OFFSET ??_C@_09KEOJDEKL@SGMLDECL?5@
$LN2@xmlCatalog:

; 496  : 	default:
; 497  : 	    return;
; 498  :     }
; 499  :     switch (entry->type) {

	push	eax
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	add	eax, -13				; fffffff3H
	cmp	eax, 11					; 0000000bH
	ja	SHORT $LN25@xmlCatalog
	movzx	eax, BYTE PTR $LN29@xmlCatalog[eax]
	jmp	DWORD PTR $LN34@xmlCatalog[eax*4]
$LN23@xmlCatalog:

; 500  : 	case SGML_CATA_ENTITY:
; 501  : 	case SGML_CATA_PENTITY:
; 502  : 	case SGML_CATA_DOCTYPE:
; 503  : 	case SGML_CATA_LINKTYPE:
; 504  : 	case SGML_CATA_NOTATION:
; 505  : 	    fprintf(out, "%s", (const char *) entry->name); break;

	push	DWORD PTR [esi+16]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	jmp	SHORT $LN31@xmlCatalog
$LN24@xmlCatalog:

; 506  : 	case SGML_CATA_PUBLIC:
; 507  : 	case SGML_CATA_SYSTEM:
; 508  : 	case SGML_CATA_SGMLDECL:
; 509  : 	case SGML_CATA_DOCUMENT:
; 510  : 	case SGML_CATA_CATALOG:
; 511  : 	case SGML_CATA_BASE:
; 512  : 	case SGML_CATA_DELEGATE:
; 513  : 	    fprintf(out, "\"%s\"", entry->name); break;

	push	DWORD PTR [esi+16]
	push	OFFSET ??_C@_04OEDFLLKD@?$CC?$CFs?$CC@
$LN31@xmlCatalog:

; 514  : 	default:
; 515  : 	    break;
; 516  :     }
; 517  :     switch (entry->type) {

	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN25@xmlCatalog:
	mov	eax, DWORD PTR [esi+12]
	add	eax, -13				; fffffff3H
	cmp	eax, 7
	ja	SHORT $LN27@xmlCatalog

; 518  : 	case SGML_CATA_ENTITY:
; 519  : 	case SGML_CATA_PENTITY:
; 520  : 	case SGML_CATA_DOCTYPE:
; 521  : 	case SGML_CATA_LINKTYPE:
; 522  : 	case SGML_CATA_NOTATION:
; 523  : 	case SGML_CATA_PUBLIC:
; 524  : 	case SGML_CATA_SYSTEM:
; 525  : 	case SGML_CATA_DELEGATE:
; 526  : 	    fprintf(out, " \"%s\"", entry->value); break;

	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_05JEHJOICL@?5?$CC?$CFs?$CC@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN27@xmlCatalog:

; 527  : 	default:
; 528  : 	    break;
; 529  :     }
; 530  :     fprintf(out, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
$LN30@xmlCatalog:
	pop	edi
$LN22@xmlCatalog:
	pop	esi

; 531  : }

	pop	ebp
	ret	0
	npad	3
$LN33@xmlCatalog:
	DD	$LN16@xmlCatalog
	DD	$LN15@xmlCatalog
	DD	$LN10@xmlCatalog
	DD	$LN11@xmlCatalog
	DD	$LN12@xmlCatalog
	DD	$LN13@xmlCatalog
	DD	$LN14@xmlCatalog
	DD	$LN17@xmlCatalog
	DD	$LN18@xmlCatalog
	DD	$LN19@xmlCatalog
	DD	$LN20@xmlCatalog
	DD	$LN21@xmlCatalog
$LN34@xmlCatalog:
	DD	$LN24@xmlCatalog
	DD	$LN23@xmlCatalog
$LN29@xmlCatalog:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_xmlCatalogDumpEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCreateNewCatalog
_TEXT	SEGMENT
_type$ = 8						; size = 4
_prefer$ = 12						; size = 4
_xmlCreateNewCatalog PROC				; COMDAT

; 415  : xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlCreateN

; 226  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_CATALOG,

	push	OFFSET ??_C@_0BD@FCDBKBHD@allocating?5catalog@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BD@FCDBKBHD@allocating?5catalog@
	push	eax
	push	eax
	push	2
	push	2
	push	20					; 00000014H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 416  :     xmlCatalogPtr ret;
; 417  : 
; 418  :     ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
; 419  :     if (ret == NULL) {
; 420  :         xmlCatalogErrMemory("allocating catalog");
; 421  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 431  : }

	pop	ebp
	ret	0
$LN2@xmlCreateN:

; 422  :     }
; 423  :     memset(ret, 0, sizeof(xmlCatalog));
; 424  :     ret->type = type;

	mov	ecx, DWORD PTR _type$[ebp]

; 425  :     ret->catalNr = 0;
; 426  :     ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
; 427  :     ret->prefer = prefer;

	mov	eax, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 10			; 0000000aH
	mov	DWORD PTR [esi+56], eax

; 428  :     if (ret->type == XML_SGML_CATALOG_TYPE)

	cmp	ecx, 2
	jne	SHORT $LN3@xmlCreateN

; 429  : 	ret->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+52], eax
$LN3@xmlCreateN:

; 430  :     return(ret);

	mov	eax, esi
	pop	esi

; 431  : }

	pop	ebp
	ret	0
_xmlCreateNewCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogHashEntryList
_TEXT	SEGMENT
tv304 = -4						; size = 4
_next$1$ = -4						; size = 4
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeCatalogHashEntryList PROC			; COMDAT

; 385  :                             const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _payload$[ebp]
	test	eax, eax
	je	$LN1@xmlFreeCat

; 386  :     xmlCatalogEntryPtr catal = (xmlCatalogEntryPtr) payload;
; 387  :     xmlCatalogEntryPtr children, next;
; 388  : 
; 389  :     if (catal == NULL)
; 390  : 	return;
; 391  : 
; 392  :     children = catal->children;

	push	esi
	mov	esi, DWORD PTR [eax+8]

; 393  :     while (children != NULL) {

	test	esi, esi
	je	$LN3@xmlFreeCat
	push	ebx
	push	edi
	npad	9
$LL2@xmlFreeCat:

; 338  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0

; 394  : 	next = children->next;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _next$1$[ebp], ebx

; 395  : 	children->dealloc = 0;

	mov	DWORD PTR [esi+32], 0

; 396  : 	children->children = NULL;

	mov	DWORD PTR [esi+8], 0

; 338  :     if (xmlDebugCatalogs) {

	je	SHORT $LN13@xmlFreeCat

; 339  : 	if (ret->name != NULL)

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN10@xmlFreeCat

; 340  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	ebx, DWORD PTR _next$1$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@xmlFreeCat
$LN10@xmlFreeCat:

; 341  : 		    "Free catalog entry %s\n", ret->name);
; 342  : 	else if (ret->value != NULL)

	mov	edi, DWORD PTR [esi+20]
	call	___xmlGenericError
	mov	DWORD PTR tv304[ebp], eax
	test	edi, edi
	je	SHORT $LN12@xmlFreeCat

; 343  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+20]
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv304[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@xmlFreeCat
$LN12@xmlFreeCat:

; 344  : 		    "Free catalog entry %s\n", ret->value);
; 345  : 	else
; 346  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv304[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
$LN13@xmlFreeCat:

; 347  : 		    "Free catalog entry\n");
; 348  :     }
; 349  : 
; 350  :     if (ret->name != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN14@xmlFreeCat

; 351  : 	xmlFree(ret->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreeCat:

; 352  :     if (ret->value != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@xmlFreeCat

; 353  : 	xmlFree(ret->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreeCat:

; 354  :     if (ret->URL != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN16@xmlFreeCat

; 355  : 	xmlFree(ret->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlFreeCat:

; 356  :     xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 397  : 	xmlFreeCatalogEntry(children, NULL);
; 398  : 	children = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlFreeCat
	mov	eax, DWORD PTR _payload$[ebp]
	pop	edi
	pop	ebx
$LN3@xmlFreeCat:

; 399  :     }
; 400  :     catal->dealloc = 0;
; 401  :     xmlFreeCatalogEntry(catal, NULL);

	push	0
	push	eax
	mov	DWORD PTR [eax+32], 0
	call	_xmlFreeCatalogEntry
	add	esp, 8
	pop	esi
$LN1@xmlFreeCat:

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeCatalogHashEntryList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogEntry
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeCatalogEntry PROC				; COMDAT

; 327  : xmlFreeCatalogEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _payload$[ebp]
	test	ebx, ebx
	je	$LN1@xmlFreeCat

; 328  :     xmlCatalogEntryPtr ret = (xmlCatalogEntryPtr) payload;
; 329  :     if (ret == NULL)
; 330  : 	return;
; 331  :     /*
; 332  :      * Entries stored in the file hash must be deallocated
; 333  :      * only by the file hash cleaner !
; 334  :      */
; 335  :     if (ret->dealloc == 1)

	cmp	DWORD PTR [ebx+32], 1
	je	$LN1@xmlFreeCat

; 336  : 	return;
; 337  : 
; 338  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN8@xmlFreeCat

; 339  : 	if (ret->name != NULL)

	cmp	DWORD PTR [ebx+16], 0
	push	esi
	push	edi
	je	SHORT $LN5@xmlFreeCat

; 340  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+16]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@xmlFreeCat
$LN5@xmlFreeCat:

; 341  : 		    "Free catalog entry %s\n", ret->name);
; 342  : 	else if (ret->value != NULL)

	mov	esi, DWORD PTR [ebx+20]
	call	___xmlGenericError
	mov	edi, eax
	test	esi, esi
	je	SHORT $LN7@xmlFreeCat

; 343  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, DWORD PTR [ebx+20]
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@xmlFreeCat
$LN7@xmlFreeCat:

; 344  : 		    "Free catalog entry %s\n", ret->value);
; 345  : 	else
; 346  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8
$LN13@xmlFreeCat:
	pop	edi
	pop	esi
$LN8@xmlFreeCat:

; 347  : 		    "Free catalog entry\n");
; 348  :     }
; 349  : 
; 350  :     if (ret->name != NULL)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN9@xmlFreeCat

; 351  : 	xmlFree(ret->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeCat:

; 352  :     if (ret->value != NULL)

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN10@xmlFreeCat

; 353  : 	xmlFree(ret->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlFreeCat:

; 354  :     if (ret->URL != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN11@xmlFreeCat

; 355  : 	xmlFree(ret->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlFreeCat:

; 356  :     xmlFree(ret);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeCat:
	pop	ebx

; 357  : }

	pop	ebp
	ret	0
_xmlFreeCatalogEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalogEntryList
_TEXT	SEGMENT
tv288 = 8						; size = 4
_next$1$ = 8						; size = 4
_ret$ = 8						; size = 4
_xmlFreeCatalogEntryList PROC				; COMDAT

; 366  : xmlFreeCatalogEntryList(xmlCatalogEntryPtr ret) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ret$[ebp]
	test	esi, esi
	je	$LN3@xmlFreeCat
	push	ebx
	push	edi
	npad	5
$LL2@xmlFreeCat:

; 335  :     if (ret->dealloc == 1)

	cmp	DWORD PTR [esi+32], 1

; 367  :     xmlCatalogEntryPtr next;
; 368  : 
; 369  :     while (ret != NULL) {
; 370  : 	next = ret->next;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _next$1$[ebp], ebx

; 335  :     if (ret->dealloc == 1)

	je	$LN5@xmlFreeCat

; 336  : 	return;
; 337  : 
; 338  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN12@xmlFreeCat

; 339  : 	if (ret->name != NULL)

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN9@xmlFreeCat

; 340  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, DWORD PTR [esi+16]
	mov	ebx, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	mov	ebx, DWORD PTR _next$1$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@xmlFreeCat
$LN9@xmlFreeCat:

; 341  : 		    "Free catalog entry %s\n", ret->name);
; 342  : 	else if (ret->value != NULL)

	mov	edi, DWORD PTR [esi+20]
	call	___xmlGenericError
	mov	DWORD PTR tv288[ebp], eax
	test	edi, edi
	je	SHORT $LN11@xmlFreeCat

; 343  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+20]
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BH@BGJCBBBD@Free?5catalog?5entry?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv288[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@xmlFreeCat
$LN11@xmlFreeCat:

; 344  : 		    "Free catalog entry %s\n", ret->value);
; 345  : 	else
; 346  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@GJGIKNJC@Free?5catalog?5entry?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv288[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
$LN12@xmlFreeCat:

; 347  : 		    "Free catalog entry\n");
; 348  :     }
; 349  : 
; 350  :     if (ret->name != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN13@xmlFreeCat

; 351  : 	xmlFree(ret->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlFreeCat:

; 352  :     if (ret->value != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN14@xmlFreeCat

; 353  : 	xmlFree(ret->value);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreeCat:

; 354  :     if (ret->URL != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN15@xmlFreeCat

; 355  : 	xmlFree(ret->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreeCat:

; 356  :     xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeCat:

; 371  : 	xmlFreeCatalogEntry(ret, NULL);
; 372  : 	ret = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlFreeCat
	pop	edi
	pop	ebx
$LN3@xmlFreeCat:
	pop	esi

; 373  :     }
; 374  : }

	pop	ebp
	ret	0
_xmlFreeCatalogEntryList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlNewCatalogEntry
_TEXT	SEGMENT
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_URL$ = 20						; size = 4
_prefer$ = 24						; size = 4
_group$ = 28						; size = 4
_xmlNewCatalogEntry PROC				; COMDAT

; 276  : 	   xmlCatalogEntryPtr group) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	push	44					; 0000002cH
	xor	ebx, ebx
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewCata

; 226  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_CATALOG,

	push	OFFSET ??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@BLANILEA@allocating?5catalog?5entry@
	push	eax
	push	eax
	push	2
	push	2
	push	20					; 00000014H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 277  :     xmlCatalogEntryPtr ret;
; 278  :     xmlChar *normid = NULL;
; 279  : 
; 280  :     ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
; 281  :     if (ret == NULL) {
; 282  :         xmlCatalogErrMemory("allocating catalog entry");
; 283  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 315  : }

	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlNewCata:

; 284  :     }
; 285  :     ret->next = NULL;
; 286  :     ret->parent = NULL;
; 287  :     ret->children = NULL;
; 288  :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], eax
	push	edi

; 289  :     if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {

	cmp	eax, 5
	je	SHORT $LN4@xmlNewCata
	cmp	eax, 8
	je	SHORT $LN4@xmlNewCata
	mov	edi, DWORD PTR _name$[ebp]
	jmp	SHORT $LN5@xmlNewCata
$LN4@xmlNewCata:

; 290  :         normid = xmlCatalogNormalizePublic(name);

	mov	edi, DWORD PTR _name$[ebp]
	push	edi
	call	_xmlCatalogNormalizePublic
	mov	ebx, eax
	add	esp, 4

; 291  :         if (normid != NULL)

	test	ebx, ebx
	je	SHORT $LN5@xmlNewCata

; 292  :             name = (*normid != 0 ? normid : NULL);

	xor	edi, edi
	cmp	BYTE PTR [ebx], 0
	cmovne	edi, ebx
$LN5@xmlNewCata:

; 293  :     }
; 294  :     if (name != NULL)

	test	edi, edi
	je	SHORT $LN6@xmlNewCata

; 295  : 	ret->name = xmlStrdup(name);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN7@xmlNewCata
$LN6@xmlNewCata:

; 296  :     else
; 297  : 	ret->name = NULL;

	xor	eax, eax
$LN7@xmlNewCata:

; 298  :     if (normid != NULL)

	mov	DWORD PTR [esi+16], eax
	test	ebx, ebx
	je	SHORT $LN8@xmlNewCata

; 299  :         xmlFree(normid);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlNewCata:

; 300  :     if (value != NULL)

	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlNewCata

; 301  : 	ret->value = xmlStrdup(value);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN10@xmlNewCata
$LN9@xmlNewCata:

; 302  :     else
; 303  : 	ret->value = NULL;

	xor	eax, eax
$LN10@xmlNewCata:

; 304  :     if (URL == NULL)

	mov	DWORD PTR [esi+20], eax

; 305  : 	URL = value;
; 306  :     if (URL != NULL)

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	cmovne	edi, eax
	test	edi, edi
	je	SHORT $LN12@xmlNewCata

; 307  : 	ret->URL = xmlStrdup(URL);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN13@xmlNewCata
$LN12@xmlNewCata:

; 308  :     else
; 309  : 	ret->URL = NULL;

	xor	eax, eax
$LN13@xmlNewCata:

; 310  :     ret->prefer = prefer;

	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR _prefer$[ebp]
	mov	DWORD PTR [esi+28], eax

; 311  :     ret->dealloc = 0;
; 312  :     ret->depth = 0;
; 313  :     ret->group = group;

	mov	eax, DWORD PTR _group$[ebp]
	mov	DWORD PTR [esi+40], eax

; 314  :     return(ret);

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi

; 315  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlNewCatalogEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogErr
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_str3$ = 32						; size = 4
_xmlCatalogErr PROC					; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _str3$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	edx
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	20					; 00000014H
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _catal$[ebp]
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 246  :     __xmlRaiseError(NULL, NULL, NULL, catal, node, XML_FROM_CATALOG,
; 247  :                     error, XML_ERR_ERROR, NULL, 0,
; 248  : 		    (const char *) str1, (const char *) str2,
; 249  : 		    (const char *) str3, 0, 0,
; 250  : 		    msg, str1, str2, str3);
; 251  : }

	pop	ebp
	ret	0
_xmlCatalogErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlCatalogErrMemory PROC				; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	2
	push	20					; 00000014H
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 226  :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_CATALOG,
; 227  :                     XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0,
; 228  : 		    extra, NULL, NULL, 0, 0,
; 229  : 		    "Memory allocation failed : %s\n", extra);
; 230  : }

	pop	ebp
	ret	0
_xmlCatalogErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlExpandCatalog
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlExpandCatalog PROC					; COMDAT

; 2741 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlExpandC

; 2742 :     int ret;
; 2743 : 
; 2744 :     if ((catal == NULL) || (filename == NULL))

	mov	ebx, DWORD PTR _filename$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlExpandC

; 2745 : 	return(-1);
; 2746 : 
; 2747 : 
; 2748 :     if (catal->type == XML_SGML_CATALOG_TYPE) {

	cmp	DWORD PTR [esi], 2
	jne	SHORT $LN6@xmlExpandC

; 2749 : 	xmlChar *content;
; 2750 : 
; 2751 : 	content = xmlLoadFileContent(filename);

	push	ebx
	call	_xmlLoadFileContent
	mov	edi, eax
	add	esp, 4

; 2752 : 	if (content == NULL)

	test	edi, edi
	je	SHORT $LN5@xmlExpandC

; 2753 : 	    return(-1);
; 2754 : 
; 2755 :         ret = xmlParseSGMLCatalog(catal, content, filename, 0);

	push	0
	push	ebx
	push	edi
	push	esi
	call	_xmlParseSGMLCatalog
	add	esp, 16					; 00000010H

; 2756 : 	if (ret < 0) {

	push	edi
	test	eax, eax
	jns	SHORT $LN9@xmlExpandC

; 2757 : 	    xmlFree(content);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlExpandC:

; 2775 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlExpandC:

; 2758 : 	    return(-1);
; 2759 : 	}
; 2760 : 	xmlFree(content);

	call	DWORD PTR _xmlFree
	add	esp, 4

; 2772 : 	}
; 2773 :     }
; 2774 :     return (0);

	xor	eax, eax
	pop	edi

; 2775 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlExpandC:

; 2761 :     } else {
; 2762 : 	xmlCatalogEntryPtr tmp, cur;
; 2763 : 	tmp = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	ebx
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry

; 2764 : 		       NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);
; 2765 : 
; 2766 : 	cur = catal->xml;

	mov	edx, DWORD PTR [esi+60]
	add	esp, 24					; 00000018H
	mov	edi, eax

; 2767 : 	if (cur == NULL) {

	test	edx, edx
	jne	SHORT $LN117@xmlExpandC

; 2768 : 	    catal->xml = tmp;

	mov	DWORD PTR [esi+60], edi

; 2772 : 	}
; 2773 :     }
; 2774 :     return (0);

	xor	eax, eax
	pop	edi

; 2775 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN117@xmlExpandC:

; 2769 : 	} else {
; 2770 : 	    while (cur->next != NULL) cur = cur->next;

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN3@xmlExpandC
$LL2@xmlExpandC:
	mov	eax, DWORD PTR [ecx]
	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlExpandC
$LN3@xmlExpandC:

; 2771 : 	    cur->next = tmp;

	mov	DWORD PTR [edx], edi

; 2772 : 	}
; 2773 :     }
; 2774 :     return (0);

	xor	eax, eax
	pop	edi

; 2775 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlExpandCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogNormalizePublic
_TEXT	SEGMENT
_pubID$ = 8						; size = 4
_xmlCatalogNormalizePublic PROC				; COMDAT

; 1039 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pubID$[ebp]
	mov	esi, 1
	test	edi, edi
	je	$LN33@xmlCatalog

; 1040 :     int ok = 1;
; 1041 :     int white;
; 1042 :     const xmlChar *p;
; 1043 :     xmlChar *ret;
; 1044 :     xmlChar *q;
; 1045 : 
; 1046 :     if (pubID == NULL)
; 1047 :         return(NULL);
; 1048 : 
; 1049 :     white = 1;

	cmp	BYTE PTR [edi], 0
	mov	edx, esi

; 1050 :     for (p = pubID;*p != 0 && ok;p++) {

	mov	ecx, edi
	je	SHORT $LN14@xmlCatalog
$LL4@xmlCatalog:
	test	esi, esi
	je	SHORT $LN14@xmlCatalog

; 1051 :         if (!xmlIsBlank_ch(*p))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN31@xmlCatalog
	cmp	al, 9
	jb	SHORT $LN11@xmlCatalog
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlCatalog
$LN11@xmlCatalog:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN12@xmlCatalog

; 1052 :             white = 0;

	xor	edx, edx
	jmp	SHORT $LN2@xmlCatalog
$LN31@xmlCatalog:

; 1053 :         else if (*p == 0x20 && !white)

	test	edx, edx
	jne	SHORT $LN12@xmlCatalog

; 1054 :             white = 1;

	mov	edx, 1
	jmp	SHORT $LN2@xmlCatalog
$LN12@xmlCatalog:

; 1055 :         else
; 1056 :             ok = 0;

	xor	esi, esi
$LN2@xmlCatalog:

; 1050 :     for (p = pubID;*p != 0 && ok;p++) {

	inc	ecx
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL4@xmlCatalog

; 1057 :     }
; 1058 :     if (ok && !white)	/* is normalized */

	test	esi, esi
	je	SHORT $LN14@xmlCatalog
	test	edx, edx
	je	SHORT $LN33@xmlCatalog
$LN14@xmlCatalog:
	push	ebx

; 1060 : 
; 1061 :     ret = xmlStrdup(pubID);

	push	edi
	call	_xmlStrdup

; 1062 :     q = ret;
; 1063 :     white = 0;
; 1064 :     for (p = pubID;*p != 0;p++) {

	mov	dl, BYTE PTR [edi]
	add	esp, 4
	mov	ebx, eax
	xor	esi, esi
	mov	ecx, ebx
	test	dl, dl
	je	SHORT $LN6@xmlCatalog
	lea	eax, DWORD PTR [esi+1]
$LL7@xmlCatalog:

; 1065 :         if (xmlIsBlank_ch(*p)) {

	cmp	dl, 32					; 00000020H
	je	SHORT $LN17@xmlCatalog
	cmp	dl, 9
	jb	SHORT $LN18@xmlCatalog
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN17@xmlCatalog
$LN18@xmlCatalog:
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN17@xmlCatalog

; 1067 :                 white = 1;
; 1068 :         } else {
; 1069 :             if (white) {

	test	esi, esi
	je	SHORT $LN32@xmlCatalog

; 1070 :                 *(q++) = 0x20;

	mov	BYTE PTR [ecx], 32			; 00000020H
	inc	ecx

; 1071 :                 white = 0;

	xor	esi, esi
$LN32@xmlCatalog:

; 1072 :             }
; 1073 :             *(q++) = *p;

	mov	al, BYTE PTR [edi]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	eax, 1
	jmp	SHORT $LN5@xmlCatalog
$LN17@xmlCatalog:

; 1066 :             if (q != ret)

	cmp	ecx, ebx
	cmovne	esi, eax
$LN5@xmlCatalog:

; 1062 :     q = ret;
; 1063 :     white = 0;
; 1064 :     for (p = pubID;*p != 0;p++) {

	mov	dl, BYTE PTR [edi+1]
	inc	edi
	test	dl, dl
	jne	SHORT $LL7@xmlCatalog
$LN6@xmlCatalog:

; 1074 :         }
; 1075 :     }
; 1076 :     *q = 0;
; 1077 :     return(ret);

	mov	eax, ebx
	mov	BYTE PTR [ecx], 0
	pop	ebx
	pop	edi

; 1078 : }

	pop	esi
	pop	ebp
	ret	0
$LN33@xmlCatalog:
	pop	edi

; 1059 :         return(NULL);

	xor	eax, eax

; 1078 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCatalogNormalizePublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetPublic
_TEXT	SEGMENT
_pubID$ = 8						; size = 4
_xmlCatalogGetPublic PROC				; COMDAT

; 3792 : xmlCatalogGetPublic(const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3793 :     xmlChar *ret;
; 3794 :     static xmlChar result[1000];
; 3795 :     static int msg = 0;
; 3796 : 
; 3797 :     if (!xmlCatalogInitialized)
; 3798 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3799 : 
; 3800 :     if (msg == 0) {

	cmp	DWORD PTR ?msg@?1??xmlCatalogGetPublic@@9@9, 0
	push	esi
	jne	SHORT $LN3@xmlCatalog

; 3801 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CO@NCFNFNHN@Use?5of?5deprecated?5xmlCatalogGet@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3802 : 		"Use of deprecated xmlCatalogGetPublic() call\n");
; 3803 : 	msg++;

	inc	DWORD PTR ?msg@?1??xmlCatalogGetPublic@@9@9
$LN3@xmlCatalog:

; 3804 :     }
; 3805 : 
; 3806 :     if (pubID == NULL)

	mov	esi, DWORD PTR _pubID$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlCatalog

; 3807 : 	return(NULL);
; 3808 : 
; 3809 :     /*
; 3810 :      * Check first the XML catalogs
; 3811 :      */
; 3812 :     if (xmlDefaultCatalog != NULL) {

	mov	eax, DWORD PTR _xmlDefaultCatalog
	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 3813 : 	ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, pubID, NULL);

	push	0
	push	esi
	push	DWORD PTR [eax+60]
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 3814 : 	if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {

	test	eax, eax
	je	SHORT $LN6@xmlCatalog
	cmp	eax, -1
	je	SHORT $LN6@xmlCatalog

; 3815 : 	    snprintf((char *) result, sizeof(result) - 1, "%s", (char *) ret);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	999					; 000003e7H
	push	OFFSET ?result@?1??xmlCatalogGetPublic@@9@9
	call	_snprintf
	add	esp, 16					; 00000010H

; 3816 : 	    result[sizeof(result) - 1] = 0;

	mov	BYTE PTR ?result@?1??xmlCatalogGetPublic@@9@9+999, 0

; 3817 : 	    return(result);

	mov	eax, OFFSET ?result@?1??xmlCatalogGetPublic@@9@9
	pop	esi

; 3824 : }

	pop	ebp
	ret	0
$LN6@xmlCatalog:

; 3818 : 	}
; 3819 :     }
; 3820 : 
; 3821 :     if (xmlDefaultCatalog != NULL)

	mov	eax, DWORD PTR _xmlDefaultCatalog
	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 3822 : 	return(xmlCatalogGetSGMLPublic(xmlDefaultCatalog->sgml, pubID));

	push	esi
	push	DWORD PTR [eax+52]
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8
	pop	esi

; 3824 : }

	pop	ebp
	ret	0
$LN7@xmlCatalog:

; 3823 :     return(NULL);

	xor	eax, eax
	pop	esi

; 3824 : }

	pop	ebp
	ret	0
_xmlCatalogGetPublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetSystem
_TEXT	SEGMENT
_sysID$ = 8						; size = 4
_xmlCatalogGetSystem PROC				; COMDAT

; 3748 : xmlCatalogGetSystem(const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3749 :     xmlChar *ret;
; 3750 :     static xmlChar result[1000];
; 3751 :     static int msg = 0;
; 3752 : 
; 3753 :     if (!xmlCatalogInitialized)
; 3754 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3755 : 
; 3756 :     if (msg == 0) {

	cmp	DWORD PTR ?msg@?1??xmlCatalogGetSystem@@9@9, 0
	push	esi
	jne	SHORT $LN3@xmlCatalog

; 3757 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CO@JOIDOAAA@Use?5of?5deprecated?5xmlCatalogGet@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3758 : 		"Use of deprecated xmlCatalogGetSystem() call\n");
; 3759 : 	msg++;

	inc	DWORD PTR ?msg@?1??xmlCatalogGetSystem@@9@9
$LN3@xmlCatalog:

; 3760 :     }
; 3761 : 
; 3762 :     if (sysID == NULL)

	mov	esi, DWORD PTR _sysID$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlCatalog

; 3763 : 	return(NULL);
; 3764 : 
; 3765 :     /*
; 3766 :      * Check first the XML catalogs
; 3767 :      */
; 3768 :     if (xmlDefaultCatalog != NULL) {

	mov	eax, DWORD PTR _xmlDefaultCatalog
	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 3769 : 	ret = xmlCatalogListXMLResolve(xmlDefaultCatalog->xml, NULL, sysID);

	push	esi
	push	0
	push	DWORD PTR [eax+60]
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 3770 : 	if ((ret != NULL) && (ret != XML_CATAL_BREAK)) {

	test	eax, eax
	je	SHORT $LN6@xmlCatalog
	cmp	eax, -1
	je	SHORT $LN6@xmlCatalog

; 3771 : 	    snprintf((char *) result, sizeof(result) - 1, "%s", (char *) ret);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	999					; 000003e7H
	push	OFFSET ?result@?1??xmlCatalogGetSystem@@9@9
	call	_snprintf
	add	esp, 16					; 00000010H

; 3772 : 	    result[sizeof(result) - 1] = 0;

	mov	BYTE PTR ?result@?1??xmlCatalogGetSystem@@9@9+999, 0

; 3773 : 	    return(result);

	mov	eax, OFFSET ?result@?1??xmlCatalogGetSystem@@9@9
	pop	esi

; 3779 :     return(NULL);
; 3780 : }

	pop	ebp
	ret	0
$LN6@xmlCatalog:

; 3774 : 	}
; 3775 :     }
; 3776 : 
; 3777 :     if (xmlDefaultCatalog != NULL)

	mov	eax, DWORD PTR _xmlDefaultCatalog
	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 3778 : 	return(xmlCatalogGetSGMLSystem(xmlDefaultCatalog->sgml, sysID));

	mov	eax, DWORD PTR [eax+52]

; 2591 :     if (catal == NULL)

	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 2592 : 	return(NULL);
; 2593 : 
; 2594 :     entry = (xmlCatalogEntryPtr) xmlHashLookup(catal, sysID);

	push	esi
	push	eax
	call	_xmlHashLookup
	add	esp, 8

; 2595 :     if (entry == NULL)

	test	eax, eax
	je	SHORT $LN7@xmlCatalog

; 2596 : 	return(NULL);
; 2597 :     if (entry->type == SGML_CATA_SYSTEM)

	cmp	DWORD PTR [eax+12], 13			; 0000000dH
	jne	SHORT $LN7@xmlCatalog

; 2598 : 	return(entry->URL);

	mov	eax, DWORD PTR [eax+24]
	pop	esi

; 3779 :     return(NULL);
; 3780 : }

	pop	ebp
	ret	0
$LN7@xmlCatalog:
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlCatalogGetSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogGetDefaults
_TEXT	SEGMENT
_xmlCatalogGetDefaults PROC				; COMDAT
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlCatalogDefaultAllow
	ret	0
_xmlCatalogGetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDefaults
_TEXT	SEGMENT
_allow$ = 8						; size = 4
_xmlCatalogSetDefaults PROC				; COMDAT

; 3510 : xmlCatalogSetDefaults(xmlCatalogAllow allow) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlDebugCatalogs, 0
	mov	edi, DWORD PTR _allow$[ebp]
	je	$LN2@xmlCatalog

; 3511 :     if (xmlDebugCatalogs) {
; 3512 : 	switch (allow) {

	cmp	edi, 3
	ja	$LN2@xmlCatalog
	push	esi
	jmp	DWORD PTR $LN13@xmlCatalog[edi*4]
$LN5@xmlCatalog:

; 3513 : 	    case XML_CATA_ALLOW_NONE:
; 3514 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BJ@DJLGHJPH@Disabling?5catalog?5usage?6@

; 3523 : 			"Allowing only catalogs from the document\n");
; 3524 : 		break;
; 3525 : 	    case XML_CATA_ALLOW_ALL:
; 3526 : 		xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3527 : 			"Allowing all catalogs\n");
; 3528 : 		break;
; 3529 : 	}
; 3530 :     }
; 3531 :     xmlCatalogDefaultAllow = allow;

	mov	DWORD PTR _xmlCatalogDefaultAllow, edi
	pop	esi
	pop	edi

; 3532 : }

	pop	ebp
	ret	0
$LN6@xmlCatalog:

; 3515 : 			"Disabling catalog usage\n");
; 3516 : 		break;
; 3517 : 	    case XML_CATA_ALLOW_GLOBAL:
; 3518 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BP@JNJOABOL@Allowing?5only?5global?5catalogs?6@

; 3523 : 			"Allowing only catalogs from the document\n");
; 3524 : 		break;
; 3525 : 	    case XML_CATA_ALLOW_ALL:
; 3526 : 		xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3527 : 			"Allowing all catalogs\n");
; 3528 : 		break;
; 3529 : 	}
; 3530 :     }
; 3531 :     xmlCatalogDefaultAllow = allow;

	mov	DWORD PTR _xmlCatalogDefaultAllow, edi
	pop	esi
	pop	edi

; 3532 : }

	pop	ebp
	ret	0
$LN7@xmlCatalog:

; 3519 : 			"Allowing only global catalogs\n");
; 3520 : 		break;
; 3521 : 	    case XML_CATA_ALLOW_DOCUMENT:
; 3522 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CK@GBNCHLDL@Allowing?5only?5catalogs?5from?5the@

; 3523 : 			"Allowing only catalogs from the document\n");
; 3524 : 		break;
; 3525 : 	    case XML_CATA_ALLOW_ALL:
; 3526 : 		xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3527 : 			"Allowing all catalogs\n");
; 3528 : 		break;
; 3529 : 	}
; 3530 :     }
; 3531 :     xmlCatalogDefaultAllow = allow;

	mov	DWORD PTR _xmlCatalogDefaultAllow, edi
	pop	esi
	pop	edi

; 3532 : }

	pop	ebp
	ret	0
$LN8@xmlCatalog:

; 3523 : 			"Allowing only catalogs from the document\n");
; 3524 : 		break;
; 3525 : 	    case XML_CATA_ALLOW_ALL:
; 3526 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BH@NEFJFIDI@Allowing?5all?5catalogs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN10@xmlCatalog:
	pop	esi
$LN2@xmlCatalog:

; 3527 : 			"Allowing all catalogs\n");
; 3528 : 		break;
; 3529 : 	}
; 3530 :     }
; 3531 :     xmlCatalogDefaultAllow = allow;

	mov	DWORD PTR _xmlCatalogDefaultAllow, edi
	pop	edi

; 3532 : }

	pop	ebp
	ret	0
	npad	1
$LN13@xmlCatalog:
	DD	$LN5@xmlCatalog
	DD	$LN6@xmlCatalog
	DD	$LN7@xmlCatalog
	DD	$LN8@xmlCatalog
_xmlCatalogSetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDefaultPrefer
_TEXT	SEGMENT
_prefer$ = 8						; size = 4
_xmlCatalogSetDefaultPrefer PROC			; COMDAT

; 3545 : xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _prefer$[ebp]
	mov	ebx, DWORD PTR _xmlCatalogDefaultPrefer
	test	edi, edi
	je	SHORT $LN8@xmlCatalog

; 3546 :     xmlCatalogPrefer ret = xmlCatalogDefaultPrefer;
; 3547 : 
; 3548 :     if (prefer == XML_CATA_PREFER_NONE)
; 3549 : 	return(ret);
; 3550 : 
; 3551 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN2@xmlCatalog

; 3552 : 	switch (prefer) {

	mov	eax, edi
	sub	eax, 1
	je	SHORT $LN6@xmlCatalog
	sub	eax, 1
	jne	SHORT $LN8@xmlCatalog

; 3555 : 			"Setting catalog preference to PUBLIC\n");
; 3556 : 		break;
; 3557 : 	    case XML_CATA_PREFER_SYSTEM:
; 3558 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CG@GAPDIOJL@Setting?5catalog?5preference?5to?5S@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 3559 : 			"Setting catalog preference to SYSTEM\n");
; 3560 : 		break;
; 3561 : 	    default:
; 3562 : 		return(ret);
; 3563 : 	}
; 3564 :     }
; 3565 :     xmlCatalogDefaultPrefer = prefer;

	add	esp, 8
	mov	DWORD PTR _xmlCatalogDefaultPrefer, edi

; 3566 :     return(ret);
; 3567 : }

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlCatalog:

; 3553 : 	    case XML_CATA_PREFER_PUBLIC:
; 3554 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_0CG@PBIOHMMD@Setting?5catalog?5preference?5to?5P@
	push	DWORD PTR [eax]
	call	ecx

; 3559 : 			"Setting catalog preference to SYSTEM\n");
; 3560 : 		break;
; 3561 : 	    default:
; 3562 : 		return(ret);
; 3563 : 	}
; 3564 :     }
; 3565 :     xmlCatalogDefaultPrefer = prefer;

	add	esp, 8
$LN2@xmlCatalog:
	mov	DWORD PTR _xmlCatalogDefaultPrefer, edi
$LN8@xmlCatalog:
	pop	edi

; 3566 :     return(ret);
; 3567 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
_xmlCatalogSetDefaultPrefer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogSetDebug
_TEXT	SEGMENT
_level$ = 8						; size = 4
_xmlCatalogSetDebug PROC				; COMDAT

; 3579 : xmlCatalogSetDebug(int level) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _level$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _xmlDebugCatalogs
	test	ecx, ecx
	cmovg	edx, ecx
	mov	DWORD PTR _xmlDebugCatalogs, edx

; 3580 :     int ret = xmlDebugCatalogs;
; 3581 : 
; 3582 :     if (level <= 0)
; 3583 :         xmlDebugCatalogs = 0;
; 3584 :     else
; 3585 : 	xmlDebugCatalogs = level;
; 3586 :     return(ret);
; 3587 : }

	pop	ebp
	ret	0
_xmlCatalogSetDebug ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogLocalResolveURI
_TEXT	SEGMENT
_catalogs$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlCatalogLocalResolveURI PROC				; COMDAT

; 3710 : xmlCatalogLocalResolveURI(void *catalogs, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3711 :     xmlCatalogEntryPtr catal;
; 3712 :     xmlChar *ret;
; 3713 : 
; 3714 :     if (!xmlCatalogInitialized)
; 3715 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:
	push	edi

; 3716 : 
; 3717 :     if (URI == NULL)

	mov	edi, DWORD PTR _URI$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlCatalog

; 3718 : 	return(NULL);
; 3719 : 
; 3720 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlCatalog

; 3721 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
$LN4@xmlCatalog:

; 3722 : 		"Resolve URI %s\n", URI);
; 3723 : 
; 3724 :     catal = (xmlCatalogEntryPtr) catalogs;
; 3725 :     if (catal == NULL)

	mov	eax, DWORD PTR _catalogs$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlCatalog

; 3726 : 	return(NULL);
; 3727 :     ret = xmlCatalogListXMLResolveURI(catal, URI);

	push	edi
	push	eax
	call	_xmlCatalogListXMLResolveURI
	add	esp, 8

; 3728 :     if ((ret != NULL) && (ret != XML_CATAL_BREAK))

	test	eax, eax
	je	SHORT $LN6@xmlCatalog
	cmp	eax, -1
	jne	SHORT $LN1@xmlCatalog
$LN6@xmlCatalog:

; 3729 : 	return(ret);
; 3730 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:
	pop	edi

; 3731 : }

	pop	ebp
	ret	0
_xmlCatalogLocalResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogLocalResolve
_TEXT	SEGMENT
_catalogs$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlCatalogLocalResolve PROC				; COMDAT

; 3666 : 	               const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3667 :     xmlCatalogEntryPtr catal;
; 3668 :     xmlChar *ret;
; 3669 : 
; 3670 :     if (!xmlCatalogInitialized)
; 3671 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:
	push	ebx

; 3672 : 
; 3673 :     if ((pubID == NULL) && (sysID == NULL))

	mov	ebx, DWORD PTR _sysID$[ebp]
	push	edi
	mov	edi, DWORD PTR _pubID$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlCatalog
	test	ebx, ebx
	je	SHORT $LN10@xmlCatalog
$LN3@xmlCatalog:

; 3674 : 	return(NULL);
; 3675 : 
; 3676 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN8@xmlCatalog

; 3677 :         if ((pubID != NULL) && (sysID != NULL)) {

	push	esi
	test	edi, edi
	je	SHORT $LN5@xmlCatalog
	test	ebx, ebx
	je	SHORT $LN5@xmlCatalog

; 3678 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	edi
	push	OFFSET ??_C@_0CC@EFNIHKEA@Local?5Resolve?3?5pubID?5?$CFs?5sysID?5?$CF@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN12@xmlCatalog
$LN5@xmlCatalog:

; 3679 :                             "Local Resolve: pubID %s sysID %s\n", pubID, sysID);
; 3680 :         } else if (pubID != NULL) {

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN7@xmlCatalog

; 3681 :             xmlGenericError(xmlGenericErrorContext,

	push	edi
	push	OFFSET ??_C@_0BJ@JNLHMJMH@Local?5Resolve?3?5pubID?5?$CFs?6@

; 3682 :                             "Local Resolve: pubID %s\n", pubID);
; 3683 :         } else {

	jmp	SHORT $LN13@xmlCatalog
$LN7@xmlCatalog:

; 3684 :             xmlGenericError(xmlGenericErrorContext,

	push	ebx
	push	OFFSET ??_C@_0BJ@CAKFLAGF@Local?5Resolve?3?5sysID?5?$CFs?6@
$LN13@xmlCatalog:
	push	eax
	call	ecx
	add	esp, 12					; 0000000cH
$LN12@xmlCatalog:
	pop	esi
$LN8@xmlCatalog:

; 3685 :                             "Local Resolve: sysID %s\n", sysID);
; 3686 :         }
; 3687 :     }
; 3688 : 
; 3689 :     catal = (xmlCatalogEntryPtr) catalogs;
; 3690 :     if (catal == NULL)

	mov	eax, DWORD PTR _catalogs$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlCatalog

; 3691 : 	return(NULL);
; 3692 :     ret = xmlCatalogListXMLResolve(catal, pubID, sysID);

	push	ebx
	push	edi
	push	eax
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 3693 :     if ((ret != NULL) && (ret != XML_CATAL_BREAK))

	test	eax, eax
	je	SHORT $LN10@xmlCatalog
	cmp	eax, -1
	jne	SHORT $LN1@xmlCatalog
$LN10@xmlCatalog:

; 3694 : 	return(ret);
; 3695 :     return(NULL);

	xor	eax, eax
$LN1@xmlCatalog:
	pop	edi

; 3696 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlCatalogLocalResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogAddLocal
_TEXT	SEGMENT
_catalogs$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlCatalogAddLocal PROC				; COMDAT

; 3624 : xmlCatalogAddLocal(void *catalogs, const xmlChar *URL) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN4@xmlCatalog

; 3625 :     xmlCatalogEntryPtr catal, add;
; 3626 : 
; 3627 :     if (!xmlCatalogInitialized)
; 3628 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN4@xmlCatalog:
	push	esi
	push	edi

; 3629 : 
; 3630 :     if (URL == NULL)

	mov	edi, DWORD PTR _URL$[ebp]
	test	edi, edi
	je	SHORT $LN14@xmlCatalog

; 3631 : 	return(catalogs);
; 3632 : 
; 3633 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN6@xmlCatalog

; 3634 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BM@KJMHHCDF@Adding?5document?5catalog?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN6@xmlCatalog:

; 3635 : 		"Adding document catalog %s\n", URL);
; 3636 : 
; 3637 :     add = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL, URL, NULL,

	push	0
	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	0
	push	edi
	push	0
	push	1
	call	_xmlNewCatalogEntry
	mov	edi, eax
	add	esp, 24					; 00000018H

; 3638 : 	                     xmlCatalogDefaultPrefer, NULL);
; 3639 :     if (add == NULL)

	test	edi, edi
	je	SHORT $LN14@xmlCatalog

; 3641 : 
; 3642 :     catal = (xmlCatalogEntryPtr) catalogs;

	mov	eax, DWORD PTR _catalogs$[ebp]
	mov	esi, eax

; 3643 :     if (catal == NULL)

	test	eax, eax
	jne	SHORT $LN10@xmlCatalog

; 3644 : 	return((void *) add);

	mov	eax, edi
	pop	edi

; 3649 :     return(catalogs);
; 3650 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlCatalog:

; 3645 : 
; 3646 :     while (catal->next != NULL)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN3@xmlCatalog
	npad	6
$LL2@xmlCatalog:
	mov	ecx, DWORD PTR [edx]

; 3647 : 	catal = catal->next;

	mov	esi, edx
	mov	edx, ecx
	test	ecx, ecx
	jne	SHORT $LL2@xmlCatalog
$LN3@xmlCatalog:

; 3648 :     catal->next = add;

	mov	DWORD PTR [esi], edi
	pop	edi

; 3649 :     return(catalogs);
; 3650 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlCatalog:

; 3640 : 	return(catalogs);

	mov	eax, DWORD PTR _catalogs$[ebp]
	pop	edi

; 3649 :     return(catalogs);
; 3650 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCatalogAddLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogFreeLocal
_TEXT	SEGMENT
_catalogs$ = 8						; size = 4
_xmlCatalogFreeLocal PROC				; COMDAT

; 3602 : xmlCatalogFreeLocal(void *catalogs) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3603 :     xmlCatalogEntryPtr catal;
; 3604 : 
; 3605 :     if (!xmlCatalogInitialized)
; 3606 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3607 : 
; 3608 :     catal = (xmlCatalogEntryPtr) catalogs;
; 3609 :     if (catal != NULL)

	mov	eax, DWORD PTR _catalogs$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlCatalog

; 3610 : 	xmlFreeCatalogEntryList(catal);

	mov	DWORD PTR _catalogs$[ebp], eax

; 3611 : }

	pop	ebp

; 3610 : 	xmlFreeCatalogEntryList(catal);

	jmp	_xmlFreeCatalogEntryList
$LN3@xmlCatalog:

; 3611 : }

	pop	ebp
	ret	0
_xmlCatalogFreeLocal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogConvert
_TEXT	SEGMENT
_xmlCatalogConvert PROC					; COMDAT
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3472 :     int res = -1;
; 3473 : 
; 3474 :     if (!xmlCatalogInitialized)
; 3475 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:
	push	esi

; 3476 : 
; 3477 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock

; 3478 :     res = xmlConvertSGMLCatalog(xmlDefaultCatalog);

	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlConvertSGMLCatalog

; 3479 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	esi, eax
	call	_xmlRMutexUnlock
	add	esp, 12					; 0000000cH

; 3480 :     return(res);

	mov	eax, esi
	pop	esi

; 3481 : }

	ret	0
_xmlCatalogConvert ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlParseCatalogFile
_TEXT	SEGMENT
_buf$1$ = -4						; size = 4
_filename$ = 8						; size = 4
_xmlParseCatalogFile PROC				; COMDAT

; 893  : xmlParseCatalogFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edi, edi
	call	_xmlNewParserCtxt
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN2@xmlParseCa

; 894  :     xmlDocPtr ret;
; 895  :     xmlParserCtxtPtr ctxt;
; 896  :     char *directory = NULL;
; 897  :     xmlParserInputPtr inputStream;
; 898  :     xmlParserInputBufferPtr buf;
; 899  : 
; 900  :     ctxt = xmlNewParserCtxt();
; 901  :     if (ctxt == NULL) {
; 902  : #ifdef LIBXML_SAX1_ENABLED
; 903  : 	if (xmlDefaultSAXHandler.error != NULL) {

	call	___xmlDefaultSAXHandler
	cmp	DWORD PTR [eax+88], edi
	je	SHORT $LN3@xmlParseCa

; 904  : 	    xmlDefaultSAXHandler.error(NULL, "out of memory\n");

	call	___xmlDefaultSAXHandler
	push	OFFSET ??_C@_0P@PCJPAHLM@out?5of?5memory?6@
	push	esi
	mov	eax, DWORD PTR [eax+88]
	call	eax
	add	esp, 8
$LN3@xmlParseCa:

; 905  : 	}
; 906  : #endif
; 907  : 	return(NULL);

	pop	edi
	xor	eax, eax

; 949  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlParseCa:
	push	ebx

; 908  :     }
; 909  : 
; 910  :     buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);

	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlParserInputBufferCreateFilename
	add	esp, 8
	mov	DWORD PTR _buf$1$[ebp], eax

; 911  :     if (buf == NULL) {

	test	eax, eax
	je	$LN11@xmlParseCa

; 912  : 	xmlFreeParserCtxt(ctxt);
; 913  : 	return(NULL);
; 914  :     }
; 915  : 
; 916  :     inputStream = xmlNewInputStream(ctxt);

	push	esi
	call	_xmlNewInputStream
	mov	ebx, eax
	add	esp, 4

; 917  :     if (inputStream == NULL) {

	test	ebx, ebx
	je	$LN11@xmlParseCa

; 920  :     }
; 921  : 
; 922  :     inputStream->filename = (char *) xmlCanonicPath((const xmlChar *)filename);

	push	DWORD PTR _filename$[ebp]
	call	_xmlCanonicPath
	mov	DWORD PTR [ebx+4], eax

; 923  :     inputStream->buf = buf;

	mov	eax, DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR [ebx], eax

; 924  :     xmlBufResetInput(buf->buffer, inputStream);

	push	ebx
	push	DWORD PTR [eax+16]
	call	_xmlBufResetInput

; 925  : 
; 926  :     inputPush(ctxt, inputStream);

	push	ebx
	push	esi
	call	_inputPush

; 927  :     if ((ctxt->directory == NULL) && (directory == NULL))

	mov	eax, DWORD PTR [esi+180]
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN7@xmlParseCa

; 928  :         directory = xmlParserGetDirectory(filename);

	push	DWORD PTR _filename$[ebp]
	call	_xmlParserGetDirectory
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi+180]

; 929  :     if ((ctxt->directory == NULL) && (directory != NULL))

	test	eax, eax
	jne	SHORT $LN7@xmlParseCa
	test	edi, edi
	je	SHORT $LN7@xmlParseCa

; 930  :         ctxt->directory = directory;

	mov	DWORD PTR [esi+180], edi
$LN7@xmlParseCa:

; 931  :     ctxt->valid = 0;
; 932  :     ctxt->validate = 0;
; 933  :     ctxt->loadsubset = 0;
; 934  :     ctxt->pedantic = 0;
; 935  :     ctxt->dictNames = 1;
; 936  : 
; 937  :     xmlParseDocument(ctxt);

	push	esi
	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+276], 0
	mov	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+364], 1
	call	_xmlParseDocument

; 938  : 
; 939  :     if (ctxt->wellFormed)

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN8@xmlParseCa

; 945  :     }
; 946  :     xmlFreeParserCtxt(ctxt);

	push	esi
	mov	edi, eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 947  : 
; 948  :     return(ret);

	mov	eax, edi
	pop	ebx
	pop	edi

; 949  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlParseCa:

; 940  : 	ret = ctxt->myDoc;
; 941  :     else {
; 942  :         ret = NULL;
; 943  :         xmlFreeDoc(ctxt->myDoc);

	push	eax
	xor	edi, edi
	call	_xmlFreeDoc
	add	esp, 4

; 944  :         ctxt->myDoc = NULL;

	mov	DWORD PTR [esi+8], edi

; 945  :     }
; 946  :     xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 947  : 
; 948  :     return(ret);

	mov	eax, edi
	pop	ebx
	pop	edi

; 949  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlParseCa:

; 918  : 	xmlFreeParserCtxt(ctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 919  : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 949  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCatalogFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogRemove
_TEXT	SEGMENT
_value$ = 8						; size = 4
_xmlCatalogRemove PROC					; COMDAT

; 3451 : xmlCatalogRemove(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3452 :     int res;
; 3453 : 
; 3454 :     if (!xmlCatalogInitialized)
; 3455 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:
	push	esi

; 3456 : 
; 3457 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock

; 3458 :     res = xmlACatalogRemove(xmlDefaultCatalog, value);

	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogRemove

; 3459 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	esi, eax
	call	_xmlRMutexUnlock
	add	esp, 16					; 00000010H

; 3460 :     return(res);

	mov	eax, esi
	pop	esi

; 3461 : }

	pop	ebp
	ret	0
_xmlCatalogRemove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogAdd
_TEXT	SEGMENT
_type$ = 8						; size = 4
_orig$ = 12						; size = 4
_replace$ = 16						; size = 4
_xmlCatalogAdd PROC					; COMDAT

; 3415 : xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3416 :     int res = -1;
; 3417 : 
; 3418 :     if (!xmlCatalogInitialized)
; 3419 : 	xmlInitializeCatalogData();

	call	_xmlInitializeCatalogData
$LN2@xmlCatalog:
	push	esi

; 3420 : 
; 3421 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock

; 3422 :     /*
; 3423 :      * Specific case where one want to override the default catalog
; 3424 :      * put in place by xmlInitializeCatalog();
; 3425 :      */
; 3426 :     if ((xmlDefaultCatalog == NULL) &&

	mov	eax, DWORD PTR _xmlDefaultCatalog
	add	esp, 4
	mov	esi, DWORD PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlCatalog
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlCatalog

; 3427 : 	(xmlStrEqual(type, BAD_CAST "catalog"))) {
; 3428 : 	xmlDefaultCatalog = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	1
	call	_xmlCreateNewCatalog

; 3429 : 		                          xmlCatalogDefaultPrefer);
; 3430 : 	xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	push	DWORD PTR _xmlCatalogDefaultPrefer
	mov	DWORD PTR _xmlDefaultCatalog, eax
	push	0
	push	DWORD PTR _orig$[ebp]
	push	0
	push	1
	call	_xmlNewCatalogEntry
	mov	ecx, DWORD PTR _xmlDefaultCatalog

; 3431 : 				    orig, NULL,  xmlCatalogDefaultPrefer, NULL);
; 3432 : 
; 3433 : 	xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	DWORD PTR [ecx+60], eax
	call	_xmlRMutexUnlock
	add	esp, 36					; 00000024H

; 3434 : 	return(0);

	xor	eax, eax
	pop	esi

; 3440 : }

	pop	ebp
	ret	0
$LN5@xmlCatalog:

; 3422 :     /*
; 3423 :      * Specific case where one want to override the default catalog
; 3424 :      * put in place by xmlInitializeCatalog();
; 3425 :      */
; 3426 :     if ((xmlDefaultCatalog == NULL) &&

	mov	eax, DWORD PTR _xmlDefaultCatalog
$LN3@xmlCatalog:

; 3435 :     }
; 3436 : 
; 3437 :     res = xmlACatalogAdd(xmlDefaultCatalog, type, orig, replace);

	push	DWORD PTR _replace$[ebp]
	push	DWORD PTR _orig$[ebp]
	push	esi
	push	eax
	call	_xmlACatalogAdd

; 3438 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	esi, eax
	call	_xmlRMutexUnlock
	add	esp, 20					; 00000014H

; 3439 :     return(res);

	mov	eax, esi
	pop	esi

; 3440 : }

	pop	ebp
	ret	0
_xmlCatalogAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolveURI
_TEXT	SEGMENT
_URI$ = 8						; size = 4
_xmlCatalogResolveURI PROC				; COMDAT

; 3372 : xmlCatalogResolveURI(const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3373 :     xmlChar *ret;
; 3374 : 
; 3375 :     if (!xmlCatalogInitialized)
; 3376 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3377 : 
; 3378 :     ret = xmlACatalogResolveURI(xmlDefaultCatalog, URI);

	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogResolveURI
	add	esp, 8

; 3379 :     return(ret);
; 3380 : }

	pop	ebp
	ret	0
_xmlCatalogResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolvePublic
_TEXT	SEGMENT
_pubID$ = 8						; size = 4
_xmlCatalogResolvePublic PROC				; COMDAT

; 3331 : xmlCatalogResolvePublic(const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3332 :     xmlChar *ret;
; 3333 : 
; 3334 :     if (!xmlCatalogInitialized)
; 3335 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3336 : 
; 3337 :     ret = xmlACatalogResolvePublic(xmlDefaultCatalog, pubID);

	push	DWORD PTR _pubID$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogResolvePublic
	add	esp, 8

; 3338 :     return(ret);
; 3339 : }

	pop	ebp
	ret	0
_xmlCatalogResolvePublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolveSystem
_TEXT	SEGMENT
_sysID$ = 8						; size = 4
_xmlCatalogResolveSystem PROC				; COMDAT

; 3311 : xmlCatalogResolveSystem(const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3312 :     xmlChar *ret;
; 3313 : 
; 3314 :     if (!xmlCatalogInitialized)
; 3315 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3316 : 
; 3317 :     ret = xmlACatalogResolveSystem(xmlDefaultCatalog, sysID);

	push	DWORD PTR _sysID$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogResolveSystem
	add	esp, 8

; 3318 :     return(ret);
; 3319 : }

	pop	ebp
	ret	0
_xmlCatalogResolveSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogResolve
_TEXT	SEGMENT
_pubID$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlCatalogResolve PROC					; COMDAT

; 3352 : xmlCatalogResolve(const xmlChar *pubID, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlCatalog

; 3353 :     xmlChar *ret;
; 3354 : 
; 3355 :     if (!xmlCatalogInitialized)
; 3356 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN2@xmlCatalog:

; 3357 : 
; 3358 :     ret = xmlACatalogResolve(xmlDefaultCatalog, pubID, sysID);

	push	DWORD PTR _sysID$[ebp]
	push	DWORD PTR _pubID$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogResolve
	add	esp, 12					; 0000000cH

; 3359 :     return(ret);
; 3360 : }

	pop	ebp
	ret	0
_xmlCatalogResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogDump
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlCatalogDump PROC					; COMDAT

; 3390 : xmlCatalogDump(FILE *out) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN1@xmlCatalog

; 3391 :     if (out == NULL)
; 3392 : 	return;
; 3393 : 
; 3394 :     if (!xmlCatalogInitialized)

	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN3@xmlCatalog

; 3395 : 	xmlInitializeCatalog();

	call	_xmlInitializeCatalog
$LN3@xmlCatalog:

; 3396 : 
; 3397 :     xmlACatalogDump(xmlDefaultCatalog, out);

	push	DWORD PTR _out$[ebp]
	push	DWORD PTR _xmlDefaultCatalog
	call	_xmlACatalogDump
	add	esp, 8
$LN1@xmlCatalog:

; 3398 : }

	pop	ebp
	ret	0
_xmlCatalogDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogCleanup
_TEXT	SEGMENT
_xmlCatalogCleanup PROC					; COMDAT
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	je	$LN1@xmlCatalog

; 3282 :     if (xmlCatalogInitialized == 0)
; 3283 :         return;
; 3284 : 
; 3285 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock
	add	esp, 4

; 3286 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN3@xmlCatalog

; 3287 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BC@BLLDGNNC@Catalogs?5cleanup?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
	pop	esi
$LN3@xmlCatalog:

; 3288 : 		"Catalogs cleanup\n");
; 3289 :     if (xmlCatalogXMLFiles != NULL)

	mov	eax, DWORD PTR _xmlCatalogXMLFiles
	test	eax, eax
	je	SHORT $LN4@xmlCatalog

; 3290 : 	xmlHashFree(xmlCatalogXMLFiles, xmlFreeCatalogHashEntryList);

	push	OFFSET _xmlFreeCatalogHashEntryList
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN4@xmlCatalog:

; 3291 :     xmlCatalogXMLFiles = NULL;
; 3292 :     if (xmlDefaultCatalog != NULL)

	mov	eax, DWORD PTR _xmlDefaultCatalog
	mov	DWORD PTR _xmlCatalogXMLFiles, 0
	test	eax, eax
	je	SHORT $LN5@xmlCatalog

; 3293 : 	xmlFreeCatalog(xmlDefaultCatalog);

	push	eax
	call	_xmlFreeCatalog
	add	esp, 4
$LN5@xmlCatalog:

; 3294 :     xmlDefaultCatalog = NULL;
; 3295 :     xmlDebugCatalogs = 0;
; 3296 :     xmlCatalogInitialized = 0;
; 3297 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	DWORD PTR _xmlDefaultCatalog, 0
	mov	DWORD PTR _xmlDebugCatalogs, 0
	mov	DWORD PTR _xmlCatalogInitialized, 0
	call	_xmlRMutexUnlock

; 3298 :     xmlFreeRMutex(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlFreeRMutex
	add	esp, 8
$LN1@xmlCatalog:

; 3299 : }

	ret	0
_xmlCatalogCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadCatalogs
_TEXT	SEGMENT
_pathss$ = 8						; size = 4
_xmlLoadCatalogs PROC					; COMDAT

; 3238 : xmlLoadCatalogs(const char *pathss) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _pathss$[ebp]
	test	esi, esi
	je	$LN51@xmlLoadCat

; 3239 :     const char *cur;
; 3240 :     const char *paths;
; 3241 :     xmlChar *path;
; 3242 : #ifdef _WIN32
; 3243 :     int i, iLen;
; 3244 : #endif
; 3245 : 
; 3246 :     if (pathss == NULL)
; 3247 : 	return;
; 3248 : 
; 3249 :     cur = pathss;
; 3250 :     while (*cur != 0) {

	cmp	BYTE PTR [esi], 0
	je	$LN51@xmlLoadCat
	push	edi
$LL4@xmlLoadCat:

; 3251 : 	while (xmlIsBlank_ch(*cur)) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN14@xmlLoadCat
	cmp	al, 9
	jl	SHORT $LN15@xmlLoadCat
	cmp	al, 10					; 0000000aH
	jle	SHORT $LN14@xmlLoadCat
$LN15@xmlLoadCat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlLoadCat
$LN14@xmlLoadCat:
	inc	esi
	jmp	SHORT $LL4@xmlLoadCat
$LN5@xmlLoadCat:

; 3252 : 	if (*cur != 0) {

	test	al, al
	je	SHORT $LN25@xmlLoadCat

; 3253 : 	    paths = cur;

	mov	ecx, esi
	npad	2
$LL6@xmlLoadCat:

; 3254 : 	    while ((*cur != 0) && (*cur != PATH_SEPARATOR) && (!xmlIsBlank_ch(*cur)))

	cmp	al, 59					; 0000003bH
	je	SHORT $LN7@xmlLoadCat
	cmp	al, 32					; 00000020H
	je	SHORT $LN7@xmlLoadCat
	cmp	al, 9
	jl	SHORT $LN17@xmlLoadCat
	cmp	al, 10					; 0000000aH
	jle	SHORT $LN7@xmlLoadCat
$LN17@xmlLoadCat:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN7@xmlLoadCat
	mov	al, BYTE PTR [esi+1]

; 3255 : 		cur++;

	inc	esi
	test	al, al
	jne	SHORT $LL6@xmlLoadCat
$LN7@xmlLoadCat:

; 3256 : 	    path = xmlStrndup((const xmlChar *)paths, cur - paths);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax
	add	esp, 8

; 3257 : #ifdef _WIN32
; 3258 :         iLen = strlen((const char*)path);

	mov	edx, edi
	lea	eax, DWORD PTR [edx+1]
$LL47@xmlLoadCat:
	mov	cl, BYTE PTR [edx]
	inc	edx
	test	cl, cl
	jne	SHORT $LL47@xmlLoadCat
	sub	edx, eax
	xor	eax, eax

; 3259 :         for(i = 0; i < iLen; i++) {

	test	edx, edx
	jle	SHORT $LN9@xmlLoadCat
$LL30@xmlLoadCat:

; 3260 :             if(path[i] == '\\') {

	cmp	BYTE PTR [eax+edi], 92			; 0000005cH
	jne	SHORT $LN44@xmlLoadCat

; 3261 :                 path[i] = '/';

	mov	BYTE PTR [eax+edi], 47			; 0000002fH
$LN44@xmlLoadCat:

; 3259 :         for(i = 0; i < iLen; i++) {

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL30@xmlLoadCat
$LN9@xmlLoadCat:

; 3262 :             }
; 3263 :         }
; 3264 : #endif
; 3265 : 	    if (path != NULL) {

	test	edi, edi
	je	SHORT $LN25@xmlLoadCat

; 3266 : 		xmlLoadCatalog((const char *) path);

	push	edi
	call	_xmlLoadCatalog

; 3267 : 		xmlFree(path);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN25@xmlLoadCat:

; 3268 : 	    }
; 3269 : 	}
; 3270 : 	while (*cur == PATH_SEPARATOR)

	mov	al, BYTE PTR [esi]
	cmp	al, 59					; 0000003bH
	jne	SHORT $LN12@xmlLoadCat
	npad	7
$LL11@xmlLoadCat:
	mov	al, BYTE PTR [esi+1]

; 3271 : 	    cur++;

	inc	esi
	cmp	al, 59					; 0000003bH
	je	SHORT $LL11@xmlLoadCat
$LN12@xmlLoadCat:

; 3239 :     const char *cur;
; 3240 :     const char *paths;
; 3241 :     xmlChar *path;
; 3242 : #ifdef _WIN32
; 3243 :     int i, iLen;
; 3244 : #endif
; 3245 : 
; 3246 :     if (pathss == NULL)
; 3247 : 	return;
; 3248 : 
; 3249 :     cur = pathss;
; 3250 :     while (*cur != 0) {

	test	al, al
	jne	$LL4@xmlLoadCat
	pop	edi
$LN51@xmlLoadCat:
	pop	esi

; 3272 :     }
; 3273 : }

	pop	ebp
	ret	0
_xmlLoadCatalogs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadCatalog
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlLoadCatalog PROC					; COMDAT

; 3202 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	SHORT $LN2@xmlLoadCat

; 3203 :     int ret;
; 3204 :     xmlCatalogPtr catal;
; 3205 : 
; 3206 :     if (!xmlCatalogInitialized)
; 3207 : 	xmlInitializeCatalogData();

	call	_xmlInitializeCatalogData
$LN2@xmlLoadCat:

; 3208 : 
; 3209 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock

; 3210 : 
; 3211 :     if (xmlDefaultCatalog == NULL) {

	mov	eax, DWORD PTR _xmlDefaultCatalog
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@xmlLoadCat

; 3212 : 	catal = xmlLoadACatalog(filename);

	push	DWORD PTR _filename$[ebp]
	call	_xmlLoadACatalog
	add	esp, 4

; 3213 : 	if (catal == NULL) {

	push	DWORD PTR _xmlCatalogMutex
	test	eax, eax
	jne	SHORT $LN4@xmlLoadCat

; 3214 : 	    xmlRMutexUnlock(xmlCatalogMutex);

	call	_xmlRMutexUnlock
	add	esp, 4

; 3215 : 	    return(-1);

	or	eax, -1

; 3226 : }

	pop	ebp
	ret	0
$LN4@xmlLoadCat:

; 3216 : 	}
; 3217 : 
; 3218 : 	xmlDefaultCatalog = catal;

	mov	DWORD PTR _xmlDefaultCatalog, eax

; 3219 : 	xmlRMutexUnlock(xmlCatalogMutex);

	call	_xmlRMutexUnlock
	add	esp, 4

; 3220 : 	return(0);

	xor	eax, eax

; 3226 : }

	pop	ebp
	ret	0
$LN3@xmlLoadCat:
	push	esi

; 3221 :     }
; 3222 : 
; 3223 :     ret = xmlExpandCatalog(xmlDefaultCatalog, filename);

	push	DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlExpandCatalog

; 3224 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	mov	esi, eax
	call	_xmlRMutexUnlock
	add	esp, 12					; 0000000cH

; 3225 :     return(ret);

	mov	eax, esi
	pop	esi

; 3226 : }

	pop	ebp
	ret	0
_xmlLoadCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlInitializeCatalog
_TEXT	SEGMENT
_buf$1 = -260						; size = 256
_catal$1$ = -4						; size = 4
_xmlInitializeCatalog PROC				; COMDAT

; 3108 : xmlInitializeCatalog(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlCatalogInitialized, 0
	jne	$LN1@xmlInitial

; 3109 :     if (xmlCatalogInitialized != 0)
; 3110 : 	return;
; 3111 : 
; 3112 :     xmlInitializeCatalogData();

	push	esi
	call	_xmlInitializeCatalogData

; 3113 :     xmlRMutexLock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexLock

; 3114 : 
; 3115 :     if (getenv("XML_DEBUG_CATALOG"))

	mov	esi, DWORD PTR __imp__getenv
	push	OFFSET ??_C@_0BC@FJHLJCPJ@XML_DEBUG_CATALOG@
	call	esi
	mov	ecx, DWORD PTR _xmlDebugCatalogs
	add	esp, 8
	test	eax, eax
	mov	edx, 1
	cmovne	ecx, edx

; 3116 : 	xmlDebugCatalogs = 1;
; 3117 : 
; 3118 :     if (xmlDefaultCatalog == NULL) {

	cmp	DWORD PTR _xmlDefaultCatalog, 0
	mov	DWORD PTR _xmlDebugCatalogs, ecx
	jne	$LN19@xmlInitial

; 3119 : 	const char *catalogs;
; 3120 : 	char *path;
; 3121 : 	const char *cur, *paths;
; 3122 : 	xmlCatalogPtr catal;
; 3123 : 	xmlCatalogEntryPtr *nextent;
; 3124 : 
; 3125 : 	catalogs = (const char *) getenv("XML_CATALOG_FILES");

	push	edi
	push	OFFSET ??_C@_0BC@LLNJEHMH@XML_CATALOG_FILES@
	call	esi
	mov	esi, eax
	add	esp, 4

; 3126 : 	if (catalogs == NULL)

	test	esi, esi
	jne	$LN13@xmlInitial

; 3127 : #if defined(_WIN32) && defined(_MSC_VER)
; 3128 :     {
; 3129 : 		void* hmodule;
; 3130 : 		hmodule = GetModuleHandleA("libxml2.dll");

	push	OFFSET ??_C@_0M@BAPINHKH@libxml2?4dll@
	call	_GetModuleHandleA@4

; 3131 : 		if (hmodule == NULL)

	test	eax, eax
	jne	SHORT $LN42@xmlInitial

; 3132 : 			hmodule = GetModuleHandleA(NULL);

	push	eax
	call	_GetModuleHandleA@4

; 3133 : 		if (hmodule != NULL) {

	test	eax, eax
	je	$LN18@xmlInitial
$LN42@xmlInitial:

; 3134 : 			char buf[256];
; 3135 : 			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	call	_GetModuleFileNameA@12

; 3136 : 			if (len != 0) {

	test	eax, eax
	je	SHORT $LN18@xmlInitial

; 3137 : 				char* p = &(buf[len]);

	lea	ecx, DWORD PTR _buf$1[ebp]
	add	ecx, eax

; 3138 : 				while (*p != '\\' && p > buf)

	cmp	BYTE PTR [ecx], 92			; 0000005cH
	je	SHORT $LN50@xmlInitial
	npad	8
$LL2@xmlInitial:
	lea	eax, DWORD PTR _buf$1[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN50@xmlInitial

; 3139 : 					p--;

	dec	ecx
	cmp	BYTE PTR [ecx], 92			; 0000005cH
	jne	SHORT $LL2@xmlInitial
$LN50@xmlInitial:

; 3140 : 				if (p != buf) {

	lea	eax, DWORD PTR _buf$1[ebp]
	cmp	ecx, eax
	je	SHORT $LN18@xmlInitial

; 3141 : 					xmlChar* uri;
; 3142 : 					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));

	mov	edi, DWORD PTR __imp__strncpy
	lea	eax, DWORD PTR _buf$1[ebp+255]
	sub	eax, ecx
	push	eax
	push	OFFSET ??_C@_0BA@IDHJNFKC@?2?4?4?2etc?2catalog@
	push	ecx
	call	edi

; 3143 : 					uri = xmlCanonicPath((const xmlChar*)buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	_xmlCanonicPath
	mov	esi, eax
	add	esp, 16					; 00000010H

; 3144 : 					if (uri != NULL) {

	test	esi, esi
	je	SHORT $LN18@xmlInitial

; 3145 : 						strncpy(XML_XML_DEFAULT_CATALOG, uri, 255);

	push	255					; 000000ffH
	push	esi
	push	OFFSET _XML_XML_DEFAULT_CATALOG
	call	edi

; 3146 : 						xmlFree(uri);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN18@xmlInitial:

; 3147 : 					}
; 3148 : 				}
; 3149 : 			}
; 3150 : 		}
; 3151 : 		catalogs = XML_XML_DEFAULT_CATALOG;

	mov	esi, OFFSET _XML_XML_DEFAULT_CATALOG
$LN13@xmlInitial:

; 3152 :     }
; 3153 : #else
; 3154 : 	    catalogs = XML_XML_DEFAULT_CATALOG;
; 3155 : #endif
; 3156 : 
; 3157 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	1
	call	_xmlCreateNewCatalog
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _catal$1$[ebp], ecx

; 3158 : 		xmlCatalogDefaultPrefer);
; 3159 : 	if (catal != NULL) {

	test	ecx, ecx
	je	$LN52@xmlInitial

; 3160 : 	    /* the XML_CATALOG_FILES envvar is allowed to contain a
; 3161 : 	       space-separated list of entries. */
; 3162 : 	    cur = catalogs;
; 3163 : 	    nextent = &catal->xml;
; 3164 : 	    while (*cur != '\0') {

	cmp	BYTE PTR [esi], 0
	push	ebx
	lea	ebx, DWORD PTR [ecx+60]
	je	SHORT $LN49@xmlInitial
$LL6@xmlInitial:

; 3165 : 		while (xmlIsBlank_ch(*cur))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN20@xmlInitial
	cmp	al, 9
	jl	SHORT $LN21@xmlInitial
	cmp	al, 10					; 0000000aH
	jle	SHORT $LN20@xmlInitial
$LN21@xmlInitial:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlInitial
$LN20@xmlInitial:

; 3166 : 		    cur++;

	inc	esi
	jmp	SHORT $LL6@xmlInitial
$LN7@xmlInitial:

; 3167 : 		if (*cur != 0) {

	test	al, al
	je	SHORT $LN51@xmlInitial

; 3168 : 		    paths = cur;

	mov	ecx, esi
$LL8@xmlInitial:

; 3169 : 		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))

	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlInitial
	cmp	al, 9
	jl	SHORT $LN23@xmlInitial
	cmp	al, 10					; 0000000aH
	jle	SHORT $LN9@xmlInitial
$LN23@xmlInitial:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN9@xmlInitial
	mov	al, BYTE PTR [esi+1]

; 3170 : 			cur++;

	inc	esi
	test	al, al
	jne	SHORT $LL8@xmlInitial
$LN9@xmlInitial:

; 3171 : 		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	edi, eax
	add	esp, 8

; 3172 : 		    if (path != NULL) {

	test	edi, edi
	je	SHORT $LN24@xmlInitial

; 3173 : 			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	edi
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry

; 3174 : 				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
; 3175 : 			if (*nextent != NULL)

	test	eax, eax
	mov	DWORD PTR [ebx], eax

; 3176 : 			    nextent = &((*nextent)->next);
; 3177 : 			xmlFree(path);

	push	edi
	cmovne	ebx, eax
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH
$LN24@xmlInitial:

; 3160 : 	    /* the XML_CATALOG_FILES envvar is allowed to contain a
; 3161 : 	       space-separated list of entries. */
; 3162 : 	    cur = catalogs;
; 3163 : 	    nextent = &catal->xml;
; 3164 : 	    while (*cur != '\0') {

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL6@xmlInitial
$LN51@xmlInitial:
	mov	ecx, DWORD PTR _catal$1$[ebp]
$LN49@xmlInitial:

; 3178 : 		    }
; 3179 : 		}
; 3180 : 	    }
; 3181 : 	    xmlDefaultCatalog = catal;

	mov	DWORD PTR _xmlDefaultCatalog, ecx
	pop	ebx
$LN52@xmlInitial:
	pop	edi
$LN19@xmlInitial:

; 3182 : 	}
; 3183 :     }
; 3184 : 
; 3185 :     xmlRMutexUnlock(xmlCatalogMutex);

	push	DWORD PTR _xmlCatalogMutex
	call	_xmlRMutexUnlock
	add	esp, 4
	pop	esi
$LN1@xmlInitial:

; 3186 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlInitializeCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlCatalogIsEmpty
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_xmlCatalogIsEmpty PROC					; COMDAT

; 3048 : xmlCatalogIsEmpty(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlCatalog

; 3049 :     if (catal == NULL)
; 3050 : 	return(-1);
; 3051 : 
; 3052 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@xmlCatalog

; 3053 : 	if (catal->xml == NULL)

	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN12@xmlCatalog

; 3054 : 	    return(1);
; 3055 : 	if ((catal->xml->type != XML_CATA_CATALOG) &&

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, 1
	je	SHORT $LN6@xmlCatalog
	cmp	ecx, 2
	jne	SHORT $LN13@xmlCatalog
$LN6@xmlCatalog:

; 3056 : 	    (catal->xml->type != XML_CATA_BROKEN_CATALOG))
; 3057 : 	    return(-1);
; 3058 : 	if (catal->xml->children == NULL)

	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN10@xmlCatalog
$LN12@xmlCatalog:

; 3068 : 	    return(1);

	mov	eax, 1

; 3073 : }

	pop	ebp
	ret	0
$LN3@xmlCatalog:

; 3059 : 	    return(1);
; 3060 :         return(0);
; 3061 :     } else {
; 3062 : 	int res;
; 3063 : 
; 3064 : 	if (catal->sgml == NULL)

	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN12@xmlCatalog

; 3065 : 	    return(1);
; 3066 : 	res = xmlHashSize(catal->sgml);

	push	eax
	call	_xmlHashSize
	add	esp, 4

; 3067 : 	if (res == 0)

	test	eax, eax
	je	SHORT $LN12@xmlCatalog

; 3069 : 	if (res < 0)

	js	SHORT $LN13@xmlCatalog
$LN10@xmlCatalog:

; 3071 :     }
; 3072 :     return(0);

	xor	eax, eax

; 3073 : }

	pop	ebp
	ret	0
$LN13@xmlCatalog:

; 3070 : 	    return(-1);

	or	eax, -1

; 3073 : }

	pop	ebp
	ret	0
_xmlCatalogIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlFreeCatalog
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_xmlFreeCatalog PROC					; COMDAT

; 440  : xmlFreeCatalog(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _catal$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeCat

; 441  :     if (catal == NULL)
; 442  : 	return;
; 443  :     if (catal->xml != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN3@xmlFreeCat

; 444  : 	xmlFreeCatalogEntryList(catal->xml);

	push	eax
	call	_xmlFreeCatalogEntryList
	add	esp, 4
$LN3@xmlFreeCat:

; 445  :     if (catal->sgml != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN4@xmlFreeCat

; 446  : 	xmlHashFree(catal->sgml, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN4@xmlFreeCat:

; 447  :     xmlFree(catal);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeCat:
	pop	esi

; 448  : }

	pop	ebp
	ret	0
_xmlFreeCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogDump
_TEXT	SEGMENT
_catal$1$ = -4						; size = 4
_catal$ = 8						; size = 4
_catalog$1$ = 12					; size = 4
_out$ = 12						; size = 4
_xmlACatalogDump PROC					; COMDAT

; 2938 : xmlACatalogDump(xmlCatalogPtr catal, FILE *out) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _out$[ebp]
	test	ebx, ebx
	je	$LN3@xmlACatalo

; 2939 :     if ((out == NULL) || (catal == NULL))

	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlACatalo

; 2940 : 	return;
; 2941 : 
; 2942 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [eax], 1
	jne	$LN4@xmlACatalo

; 2943 : 	xmlDumpXMLCatalog(out, catal->xml);

	mov	eax, DWORD PTR [eax+60]
	push	esi

; 673  :     doc = xmlNewDoc(NULL);

	push	0

; 2943 : 	xmlDumpXMLCatalog(out, catal->xml);

	mov	DWORD PTR _catal$1$[ebp], eax

; 673  :     doc = xmlNewDoc(NULL);

	call	_xmlNewDoc
	mov	esi, eax
	add	esp, 4

; 674  :     if (doc == NULL)

	test	esi, esi
	je	SHORT $LN14@xmlACatalo

; 675  : 	return(-1);
; 676  :     dtd = xmlNewDtd(doc, BAD_CAST "catalog",

	push	edi
	push	OFFSET ??_C@_0EE@FEMHHJKG@http?3?1?1www?4oasis?9open?4org?1commi@
	push	OFFSET ??_C@_0DF@EBMIELJJ@?9?1?1OASIS?1?1DTD?5Entity?5Resolution@
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	esi
	call	_xmlNewDtd

; 677  : 	       BAD_CAST "-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN",
; 678  : BAD_CAST "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd");
; 679  : 
; 680  :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	push	eax
	push	esi
	call	_xmlAddChild

; 681  : 
; 682  :     ns = xmlNewNs(NULL, XML_CATALOGS_NAMESPACE, NULL);

	push	0
	push	OFFSET ??_C@_0CM@FMEFCNGF@urn?3oasis?3names?3tc?3entity?3xmlns@
	push	0
	call	_xmlNewNs
	mov	edi, eax
	add	esp, 36					; 00000024H

; 683  :     if (ns == NULL) {

	test	edi, edi
	je	SHORT $LN13@xmlACatalo

; 684  : 	xmlFreeDoc(doc);
; 685  : 	return(-1);
; 686  :     }
; 687  :     catalog = xmlNewDocNode(doc, ns, BAD_CAST "catalog", NULL);

	push	0
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	push	edi
	push	esi
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _catalog$1$[ebp], eax

; 688  :     if (catalog == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlACatalo

; 689  : 	xmlFreeNs(ns);

	push	edi
	call	_xmlFreeNs

; 690  : 	xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 8
	pop	edi
$LN14@xmlACatalo:
	pop	esi
$LN3@xmlACatalo:
	pop	ebx

; 2946 :     }
; 2947 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlACatalo:

; 694  :     xmlAddChild((xmlNodePtr) doc, catalog);

	push	eax
	push	esi
	mov	DWORD PTR [eax+48], edi
	call	_xmlAddChild

; 695  : 
; 696  :     xmlDumpXMLCatalogNode(catal, catalog, doc, ns, NULL);

	push	0
	push	edi
	push	esi
	push	DWORD PTR _catalog$1$[ebp]
	push	DWORD PTR _catal$1$[ebp]
	call	_xmlDumpXMLCatalogNode

; 697  : 
; 698  :     /*
; 699  :      * reserialize it
; 700  :      */
; 701  :     buf = xmlOutputBufferCreateFile(out, NULL);

	push	0
	push	ebx
	call	_xmlOutputBufferCreateFile
	add	esp, 36					; 00000024H

; 702  :     if (buf == NULL) {

	test	eax, eax
	je	SHORT $LN13@xmlACatalo

; 704  : 	return(-1);
; 705  :     }
; 706  :     ret = xmlSaveFormatFileTo(buf, doc, NULL, 1);

	push	1
	push	0
	push	esi
	push	eax
	call	_xmlSaveFormatFileTo

; 707  : 
; 708  :     /*
; 709  :      * Free it
; 710  :      */
; 711  :     xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2946 :     }
; 2947 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlACatalo:

; 703  : 	xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2946 :     }
; 2947 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlACatalo:

; 2944 :     } else {
; 2945 : 	xmlHashScan(catal->sgml, xmlCatalogDumpEntry, out);

	push	ebx
	push	OFFSET _xmlCatalogDumpEntry
	push	DWORD PTR [eax+52]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
	pop	ebx

; 2946 :     }
; 2947 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlACatalogDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolveURI
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlACatalogResolveURI PROC				; COMDAT

; 2905 : xmlACatalogResolveURI(xmlCatalogPtr catal, const xmlChar *URI) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _URI$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN3@xmlACatalo

; 2906 :     xmlChar *ret = NULL;
; 2907 : 
; 2908 :     if ((URI == NULL) || (catal == NULL))

	mov	ebx, DWORD PTR _catal$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlACatalo

; 2910 : 
; 2911 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, edi
	je	SHORT $LN4@xmlACatalo

; 2912 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _URI$[ebp]
	push	OFFSET ??_C@_0BA@GHNHNPIN@Resolve?5URI?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	eax, DWORD PTR _URI$[ebp]
	add	esp, 12					; 0000000cH
	pop	esi
$LN4@xmlACatalo:

; 2913 : 		"Resolve URI %s\n", URI);
; 2914 : 
; 2915 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN5@xmlACatalo

; 2916 : 	ret = xmlCatalogListXMLResolveURI(catal->xml, URI);

	push	eax
	push	DWORD PTR [ebx+60]
	call	_xmlCatalogListXMLResolveURI
	mov	edi, eax
	add	esp, 8

; 2917 : 	if (ret == XML_CATAL_BREAK)

	cmp	edi, -1
	jne	SHORT $LN8@xmlACatalo

; 2918 : 	    ret = NULL;

	xor	edi, edi

; 2925 :     }
; 2926 :     return(ret);

	mov	eax, edi
	pop	edi

; 2927 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlACatalo:

; 2617 :     if (catal->sgml == NULL)

	mov	ecx, DWORD PTR [ebx+52]
	test	ecx, ecx
	je	SHORT $LN8@xmlACatalo

; 2618 : 	return(NULL);
; 2619 : 
; 2620 :     if (pubID != NULL)
; 2621 : 	ret = xmlCatalogGetSGMLPublic(catal->sgml, pubID);
; 2622 :     if (ret != NULL)
; 2623 : 	return(ret);
; 2624 :     if (sysID != NULL)
; 2625 : 	ret = xmlCatalogGetSGMLSystem(catal->sgml, sysID);

	push	eax
	push	ecx
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8

; 2626 :     if (ret != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlACatalo

; 2919 :     } else {
; 2920 : 	const xmlChar *sgml;
; 2921 : 
; 2922 : 	sgml = xmlCatalogSGMLResolve(catal, NULL, URI);
; 2923 : 	if (sgml != NULL)
; 2924 :             ret = xmlStrdup(sgml);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN8@xmlACatalo:

; 2925 :     }
; 2926 :     return(ret);

	mov	eax, edi
	pop	edi

; 2927 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlACatalo:
	pop	edi

; 2909 : 	return(NULL);

	xor	eax, eax

; 2927 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlACatalogResolveURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolvePublic
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_xmlACatalogResolvePublic PROC				; COMDAT

; 2823 : xmlACatalogResolvePublic(xmlCatalogPtr catal, const xmlChar *pubID) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pubID$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN3@xmlACatalo

; 2824 :     xmlChar *ret = NULL;
; 2825 : 
; 2826 :     if ((pubID == NULL) || (catal == NULL))

	mov	ebx, DWORD PTR _catal$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlACatalo

; 2828 : 
; 2829 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, edi
	je	SHORT $LN4@xmlACatalo

; 2830 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _pubID$[ebp]
	push	OFFSET ??_C@_0BC@IFIFPGFD@Resolve?5pubID?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	eax, DWORD PTR _pubID$[ebp]
	add	esp, 12					; 0000000cH
	pop	esi
$LN4@xmlACatalo:

; 2831 : 		"Resolve pubID %s\n", pubID);
; 2832 : 
; 2833 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN5@xmlACatalo

; 2834 : 	ret = xmlCatalogListXMLResolve(catal->xml, pubID, NULL);

	push	0
	push	eax
	push	DWORD PTR [ebx+60]
	call	_xmlCatalogListXMLResolve
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2835 : 	if (ret == XML_CATAL_BREAK)

	cmp	edi, -1
	jne	SHORT $LN8@xmlACatalo

; 2836 : 	    ret = NULL;

	xor	edi, edi

; 2843 :     }
; 2844 :     return(ret);

	mov	eax, edi
	pop	edi

; 2845 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlACatalo:

; 2837 :     } else {
; 2838 : 	const xmlChar *sgml;
; 2839 : 
; 2840 : 	sgml = xmlCatalogGetSGMLPublic(catal->sgml, pubID);

	push	eax
	push	DWORD PTR [ebx+52]
	call	_xmlCatalogGetSGMLPublic
	add	esp, 8

; 2841 : 	if (sgml != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlACatalo

; 2842 : 	    ret = xmlStrdup(sgml);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN8@xmlACatalo:

; 2843 :     }
; 2844 :     return(ret);

	mov	eax, edi
	pop	edi

; 2845 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlACatalo:
	pop	edi

; 2827 : 	return(NULL);

	xor	eax, eax

; 2845 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlACatalogResolvePublic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolveSystem
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_sysID$ = 12						; size = 4
_xmlACatalogResolveSystem PROC				; COMDAT

; 2788 : xmlACatalogResolveSystem(xmlCatalogPtr catal, const xmlChar *sysID) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _sysID$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN3@xmlACatalo

; 2789 :     xmlChar *ret = NULL;
; 2790 : 
; 2791 :     if ((sysID == NULL) || (catal == NULL))

	mov	ebx, DWORD PTR _catal$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlACatalo

; 2793 : 
; 2794 :     if (xmlDebugCatalogs)

	cmp	DWORD PTR _xmlDebugCatalogs, edi
	je	SHORT $LN4@xmlACatalo

; 2795 : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _sysID$[ebp]
	push	OFFSET ??_C@_0BC@DIJHIPPB@Resolve?5sysID?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	eax, DWORD PTR _sysID$[ebp]
	add	esp, 12					; 0000000cH
	pop	esi
$LN4@xmlACatalo:

; 2796 : 		"Resolve sysID %s\n", sysID);
; 2797 : 
; 2798 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [ebx], 1
	push	eax
	jne	SHORT $LN5@xmlACatalo

; 2799 : 	ret = xmlCatalogListXMLResolve(catal->xml, NULL, sysID);

	push	0
	push	DWORD PTR [ebx+60]
	call	_xmlCatalogListXMLResolve
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2800 : 	if (ret == XML_CATAL_BREAK)

	cmp	edi, -1
	jne	SHORT $LN8@xmlACatalo

; 2801 : 	    ret = NULL;

	xor	edi, edi

; 2808 :     }
; 2809 :     return(ret);

	mov	eax, edi
	pop	edi

; 2810 : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlACatalo:

; 2802 :     } else {
; 2803 : 	const xmlChar *sgml;
; 2804 : 
; 2805 : 	sgml = xmlCatalogGetSGMLSystem(catal->sgml, sysID);

	push	DWORD PTR [ebx+52]
	call	_xmlCatalogGetSGMLSystem
	add	esp, 8

; 2806 : 	if (sgml != NULL)

	test	eax, eax
	je	SHORT $LN8@xmlACatalo

; 2807 : 	    ret = xmlStrdup(sgml);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN8@xmlACatalo:

; 2808 :     }
; 2809 :     return(ret);

	mov	eax, edi
	pop	edi

; 2810 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlACatalo:
	pop	edi

; 2792 : 	return(NULL);

	xor	eax, eax

; 2810 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlACatalogResolveSystem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogResolve
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_pubID$ = 12						; size = 4
_sysID$ = 16						; size = 4
_xmlACatalogResolve PROC				; COMDAT

; 2861 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pubID$[ebp]
	mov	ebx, DWORD PTR _sysID$[ebp]
	test	edi, edi
	jne	SHORT $LN4@xmlACatalo

; 2862 :     xmlChar *ret = NULL;
; 2863 : 
; 2864 :     if (((pubID == NULL) && (sysID == NULL)) || (catal == NULL))

	test	ebx, ebx
	je	SHORT $LN15@xmlACatalo
$LN4@xmlACatalo:
	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlACatalo

; 2865 :         return (NULL);
; 2866 : 
; 2867 :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN9@xmlACatalo

; 2868 :          if ((pubID != NULL) && (sysID != NULL)) {

	push	esi
	test	edi, edi
	je	SHORT $LN6@xmlACatalo
	test	ebx, ebx
	je	SHORT $LN6@xmlACatalo

; 2869 :              xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	edi
	push	OFFSET ??_C@_0BM@EMMNBONF@Resolve?3?5pubID?5?$CFs?5sysID?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN17@xmlACatalo
$LN6@xmlACatalo:

; 2870 :                              "Resolve: pubID %s sysID %s\n", pubID, sysID);
; 2871 :          } else if (pubID != NULL) {

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN8@xmlACatalo

; 2872 :              xmlGenericError(xmlGenericErrorContext,

	push	edi
	push	OFFSET ??_C@_0BD@JDBJIPCK@Resolve?3?5pubID?5?$CFs?6@

; 2873 :                              "Resolve: pubID %s\n", pubID);
; 2874 :          } else {

	jmp	SHORT $LN18@xmlACatalo
$LN8@xmlACatalo:

; 2875 :              xmlGenericError(xmlGenericErrorContext,

	push	ebx
	push	OFFSET ??_C@_0BD@COALPGII@Resolve?3?5sysID?5?$CFs?6@
$LN18@xmlACatalo:
	push	eax
	call	ecx
	add	esp, 12					; 0000000cH
$LN17@xmlACatalo:
	mov	eax, DWORD PTR _catal$[ebp]
	pop	esi
$LN9@xmlACatalo:

; 2876 :                              "Resolve: sysID %s\n", sysID);
; 2877 :          }
; 2878 :     }
; 2879 : 
; 2880 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [eax], 1
	push	ebx
	push	edi
	jne	SHORT $LN10@xmlACatalo

; 2881 :         ret = xmlCatalogListXMLResolve(catal->xml, pubID, sysID);

	push	DWORD PTR [eax+60]
	call	_xmlCatalogListXMLResolve
	add	esp, 12					; 0000000cH

; 2882 : 	if (ret == XML_CATAL_BREAK)

	cmp	eax, -1
	jne	SHORT $LN1@xmlACatalo
$LN15@xmlACatalo:

; 2890 :     }
; 2891 :     return (ret);
; 2892 : }

	xor	eax, eax
$LN1@xmlACatalo:
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlACatalo:

; 2883 : 	    ret = NULL;
; 2884 :     } else {
; 2885 :         const xmlChar *sgml;
; 2886 : 
; 2887 :         sgml = xmlCatalogSGMLResolve(catal, pubID, sysID);

	push	eax
	call	_xmlCatalogSGMLResolve
	add	esp, 12					; 0000000cH

; 2888 :         if (sgml != NULL)

	test	eax, eax
	je	SHORT $LN15@xmlACatalo

; 2889 :             ret = xmlStrdup(sgml);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 2890 :     }
; 2891 :     return (ret);
; 2892 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlACatalogResolve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogRemove
_TEXT	SEGMENT
tv299 = 8						; size = 4
_catal$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlACatalogRemove PROC					; COMDAT

; 3000 : xmlACatalogRemove(xmlCatalogPtr catal, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	$LN3@xmlACatalo

; 3001 :     int res = -1;
; 3002 : 
; 3003 :     if ((catal == NULL) || (value == NULL))

	mov	ebx, DWORD PTR _value$[ebp]
	test	ebx, ebx
	je	$LN3@xmlACatalo

; 3005 : 
; 3006 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [eax], 1
	push	edi
	jne	$LN4@xmlACatalo

; 3007 : 	res = xmlDelXMLCatalog(catal->xml, value);

	mov	edi, DWORD PTR [eax+60]

; 1585 :     if ((catal == NULL) ||

	test	edi, edi
	je	$LN12@xmlACatalo
	mov	eax, DWORD PTR [edi+12]
	cmp	eax, 1
	je	SHORT $LN11@xmlACatalo
	cmp	eax, 2
	jne	$LN12@xmlACatalo
$LN11@xmlACatalo:
	push	esi

; 1589 :     if (value == NULL)
; 1590 : 	return(-1);
; 1591 :     if (catal->children == NULL) {

	mov	esi, DWORD PTR [edi+8]
	test	esi, esi
	jne	SHORT $LL9@xmlACatalo

; 1592 : 	xmlFetchXMLCatalogFile(catal);

	push	edi
	call	_xmlFetchXMLCatalogFile
	mov	esi, DWORD PTR [edi+8]
	add	esp, 4

; 1593 :     }
; 1594 : 
; 1595 :     /*
; 1596 :      * Scan the children
; 1597 :      */
; 1598 :     cur = catal->children;
; 1599 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN10@xmlACatalo
$LL9@xmlACatalo:

; 1600 : 	if (((cur->name != NULL) && (xmlStrEqual(value, cur->name))) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN17@xmlACatalo
	push	eax
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlACatalo
$LN17@xmlACatalo:
	push	DWORD PTR [esi+20]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlACatalo
$LN16@xmlACatalo:

; 1601 : 	    (xmlStrEqual(value, cur->value))) {
; 1602 : 	    if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN20@xmlACatalo

; 1603 : 		if (cur->name != NULL)

	mov	edi, DWORD PTR [esi+16]
	call	___xmlGenericError
	mov	DWORD PTR tv299[ebp], eax
	test	edi, edi
	je	SHORT $LN19@xmlACatalo

; 1604 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+16]
	jmp	SHORT $LN27@xmlACatalo
$LN19@xmlACatalo:

; 1605 : 			    "Removing element %s from catalog\n", cur->name);
; 1606 : 		else
; 1607 : 		    xmlGenericError(xmlGenericErrorContext,

	mov	edi, DWORD PTR [esi+20]
$LN27@xmlACatalo:

; 1608 : 			    "Removing element %s from catalog\n", cur->value);
; 1609 : 	    }
; 1610 : 	    cur->type = XML_CATA_REMOVED;

	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0CC@LGDNIPOE@Removing?5element?5?$CFs?5from?5catalo@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR tv299[ebp]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
$LN20@xmlACatalo:
	mov	DWORD PTR [esi+12], -1
$LN15@xmlACatalo:

; 1611 : 	}
; 1612 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL9@xmlACatalo
$LN10@xmlACatalo:

; 1613 :     }
; 1614 :     return(ret);

	pop	esi

; 3011 : 	    res = 1;
; 3012 :     }
; 3013 :     return(res);

	pop	edi

; 1614 :     return(ret);

	xor	eax, eax
	pop	ebx

; 3014 : }

	pop	ebp
	ret	0
$LN12@xmlACatalo:

; 3011 : 	    res = 1;
; 3012 :     }
; 3013 :     return(res);

	pop	edi

; 1588 : 	return(-1);

	or	eax, -1
	pop	ebx

; 3014 : }

	pop	ebp
	ret	0
$LN4@xmlACatalo:

; 3008 :     } else {
; 3009 : 	res = xmlHashRemoveEntry(catal->sgml, value, xmlFreeCatalogEntry);

	push	OFFSET _xmlFreeCatalogEntry
	push	ebx
	push	DWORD PTR [eax+52]
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH

; 3010 : 	if (res == 0)

	mov	ecx, 1
	test	eax, eax
	cmove	eax, ecx

; 3011 : 	    res = 1;
; 3012 :     }
; 3013 :     return(res);

	pop	edi
	pop	ebx

; 3014 : }

	pop	ebp
	ret	0
$LN3@xmlACatalo:

; 3004 : 	return(-1);

	or	eax, -1
	pop	ebx

; 3014 : }

	pop	ebp
	ret	0
_xmlACatalogRemove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlACatalogAdd
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_type$ = 12						; size = 4
_orig$ = 16						; size = 4
_replace$ = 20						; size = 4
_xmlACatalogAdd PROC					; COMDAT

; 2965 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _catal$[ebp]
	or	ebx, -1
	test	edi, edi
	jne	SHORT $LN2@xmlACatalo

; 2966 :     int res = -1;
; 2967 : 
; 2968 :     if (catal == NULL)
; 2969 : 	return(-1);

	pop	edi
	or	eax, ebx

; 2988 : }

	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlACatalo:

; 2970 : 
; 2971 :     if (catal->type == XML_XML_CATALOG_TYPE) {

	cmp	DWORD PTR [edi], 1
	jne	SHORT $LN3@xmlACatalo

; 2972 :         res = xmlAddXMLCatalog(catal->xml, type, orig, replace);

	push	DWORD PTR _replace$[ebp]
	push	DWORD PTR _orig$[ebp]
	push	DWORD PTR _type$[ebp]
	push	DWORD PTR [edi+60]
	call	_xmlAddXMLCatalog
	add	esp, 16					; 00000010H
	mov	ebx, eax
	pop	edi

; 2988 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlACatalo:
	push	esi

; 2291 :     if (xmlStrEqual(name, (const xmlChar *) "SYSTEM"))

	mov	esi, DWORD PTR _type$[ebp]
	push	OFFSET ??_C@_06FDHFNJBJ@SYSTEM@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlACatalo

; 2292 : 	type = SGML_CATA_SYSTEM;

	mov	eax, 13					; 0000000dH
	jmp	$LN31@xmlACatalo
$LN9@xmlACatalo:

; 2293 :     else if (xmlStrEqual(name, (const xmlChar *) "PUBLIC"))

	push	OFFSET ??_C@_06EKOLBGFH@PUBLIC@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlACatalo

; 2294 : 	type = SGML_CATA_PUBLIC;

	mov	eax, 14					; 0000000eH
	jmp	$LN31@xmlACatalo
$LN11@xmlACatalo:

; 2295 :     else if (xmlStrEqual(name, (const xmlChar *) "DELEGATE"))

	push	OFFSET ??_C@_08IALHHCM@DELEGATE@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlACatalo

; 2296 : 	type = SGML_CATA_DELEGATE;

	mov	eax, 20					; 00000014H
	jmp	$LN31@xmlACatalo
$LN13@xmlACatalo:

; 2297 :     else if (xmlStrEqual(name, (const xmlChar *) "ENTITY"))

	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlACatalo

; 2298 : 	type = SGML_CATA_ENTITY;

	mov	eax, 15					; 0000000fH
	jmp	$LN31@xmlACatalo
$LN15@xmlACatalo:

; 2299 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCTYPE"))

	push	OFFSET ??_C@_07JGKBCNAA@DOCTYPE@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlACatalo

; 2300 : 	type = SGML_CATA_DOCTYPE;

	mov	eax, 17					; 00000011H
	jmp	$LN31@xmlACatalo
$LN17@xmlACatalo:

; 2301 :     else if (xmlStrEqual(name, (const xmlChar *) "LINKTYPE"))

	push	OFFSET ??_C@_08PMANIKNM@LINKTYPE@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlACatalo

; 2302 : 	type = SGML_CATA_LINKTYPE;

	mov	eax, 18					; 00000012H
	jmp	SHORT $LN31@xmlACatalo
$LN19@xmlACatalo:

; 2303 :     else if (xmlStrEqual(name, (const xmlChar *) "NOTATION"))

	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlACatalo

; 2304 : 	type = SGML_CATA_NOTATION;

	mov	eax, 19					; 00000013H
	jmp	SHORT $LN31@xmlACatalo
$LN21@xmlACatalo:

; 2305 :     else if (xmlStrEqual(name, (const xmlChar *) "SGMLDECL"))

	push	OFFSET ??_C@_08DJOOGKO@SGMLDECL@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlACatalo

; 2306 : 	type = SGML_CATA_SGMLDECL;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN31@xmlACatalo
$LN23@xmlACatalo:

; 2307 :     else if (xmlStrEqual(name, (const xmlChar *) "DOCUMENT"))

	push	OFFSET ??_C@_08OLOPJDNG@DOCUMENT@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlACatalo

; 2308 : 	type = SGML_CATA_DOCUMENT;

	mov	eax, 23					; 00000017H
	jmp	SHORT $LN31@xmlACatalo
$LN25@xmlACatalo:

; 2309 :     else if (xmlStrEqual(name, (const xmlChar *) "CATALOG"))

	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlACatalo

; 2310 : 	type = SGML_CATA_CATALOG;

	mov	eax, 22					; 00000016H
	jmp	SHORT $LN31@xmlACatalo
$LN27@xmlACatalo:

; 2311 :     else if (xmlStrEqual(name, (const xmlChar *) "BASE"))

	push	OFFSET ??_C@_04NLLCBHDK@BASE@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlACatalo

; 2312 : 	type = SGML_CATA_BASE;

	mov	eax, 21					; 00000015H
$LN31@xmlACatalo:

; 2973 :     } else {
; 2974 :         xmlCatalogEntryType cattype;
; 2975 : 
; 2976 :         cattype = xmlGetSGMLCatalogEntryType(type);
; 2977 :         if (cattype != XML_CATA_NONE) {
; 2978 :             xmlCatalogEntryPtr entry;
; 2979 : 
; 2980 :             entry = xmlNewCatalogEntry(cattype, orig, replace, NULL,

	mov	esi, DWORD PTR _orig$[ebp]
	push	0
	push	0
	push	0
	push	DWORD PTR _replace$[ebp]
	push	esi
	push	eax
	call	_xmlNewCatalogEntry
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 2981 :                                        XML_CATA_PREFER_NONE, NULL);
; 2982 : 	    if (catal->sgml == NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	jne	SHORT $LN6@xmlACatalo

; 2983 : 		catal->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [edi+52], eax
$LN6@xmlACatalo:

; 2984 :             res = xmlHashAddEntry(catal->sgml, orig, entry);

	push	ebx
	push	esi
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	mov	ebx, eax
$LN32@xmlACatalo:

; 2985 :         }
; 2986 :     }
; 2987 :     return (res);

	pop	esi
	pop	edi
	mov	eax, ebx

; 2988 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlACatalogAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlConvertSGMLCatalog
_TEXT	SEGMENT
_catal$ = 8						; size = 4
_xmlConvertSGMLCatalog PROC				; COMDAT

; 798  : xmlConvertSGMLCatalog(xmlCatalogPtr catal) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _catal$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlConvert

; 799  : 
; 800  :     if ((catal == NULL) || (catal->type != XML_SGML_CATALOG_TYPE))

	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN3@xmlConvert

; 802  : 
; 803  :     if (xmlDebugCatalogs) {

	cmp	DWORD PTR _xmlDebugCatalogs, 0
	je	SHORT $LN4@xmlConvert

; 804  : 	xmlGenericError(xmlGenericErrorContext,

	push	esi
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CA@PPIGJEMK@Converting?5SGML?5catalog?5to?5XML?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	eax, DWORD PTR _catal$[ebp]
	add	esp, 8
	pop	esi
$LN4@xmlConvert:

; 805  : 		"Converting SGML catalog to XML\n");
; 806  :     }
; 807  :     xmlHashScan(catal->sgml, xmlCatalogConvertEntry, &catal);

	lea	ecx, DWORD PTR _catal$[ebp]
	push	ecx
	push	OFFSET _xmlCatalogConvertEntry
	push	DWORD PTR [eax+52]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 808  :     return(0);

	xor	eax, eax

; 809  : }

	pop	ebp
	ret	0
$LN3@xmlConvert:

; 801  : 	return(-1);

	or	eax, -1

; 809  : }

	pop	ebp
	ret	0
_xmlConvertSGMLCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadSGMLSuperCatalog
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlLoadSGMLSuperCatalog PROC				; COMDAT

; 2649 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	push	esi
	call	_xmlLoadFileContent
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LN2@xmlLoadSGM

; 2671 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlLoadSGM:
	push	edi

; 2650 :     xmlChar *content;
; 2651 :     xmlCatalogPtr catal;
; 2652 :     int ret;
; 2653 : 
; 2654 :     content = xmlLoadFileContent(filename);
; 2655 :     if (content == NULL)
; 2656 :         return(NULL);
; 2657 : 
; 2658 :     catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	2
	call	_xmlCreateNewCatalog
	mov	edi, eax
	add	esp, 8

; 2659 :     if (catal == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlLoadSGM

; 2660 : 	xmlFree(content);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2661 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2671 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlLoadSGM:

; 2662 :     }
; 2663 : 
; 2664 :     ret = xmlParseSGMLCatalog(catal, content, filename, 1);

	push	1
	push	esi
	push	ebx
	push	edi
	call	_xmlParseSGMLCatalog

; 2665 :     xmlFree(content);

	push	ebx
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2666 :     if (ret < 0) {

	test	esi, esi
	jns	SHORT $LN4@xmlLoadSGM

; 2667 : 	xmlFreeCatalog(catal);

	push	edi
	call	_xmlFreeCatalog
	add	esp, 4

; 2668 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2671 : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlLoadSGM:

; 2669 :     }
; 2670 :     return (catal);

	mov	eax, edi
	pop	edi
	pop	esi

; 2671 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlLoadSGMLSuperCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlLoadACatalog
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlLoadACatalog PROC					; COMDAT

; 2686 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _filename$[ebp]
	push	ebx
	call	_xmlLoadFileContent
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN4@xmlLoadACa

; 2727 : }

	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlLoadACa:

; 2687 :     xmlChar *content;
; 2688 :     xmlChar *first;
; 2689 :     xmlCatalogPtr catal;
; 2690 :     int ret;
; 2691 : 
; 2692 :     content = xmlLoadFileContent(filename);
; 2693 :     if (content == NULL)
; 2694 :         return(NULL);
; 2695 : 
; 2696 : 
; 2697 :     first = content;
; 2698 : 
; 2699 :     while ((*first != 0) && (*first != '-') && (*first != '<') &&

	mov	cl, BYTE PTR [edi]
	mov	edx, edi
	push	esi
	test	cl, cl
	je	SHORT $LN3@xmlLoadACa
	mov	al, cl
$LL2@xmlLoadACa:
	mov	cl, al
	cmp	al, 45					; 0000002dH
	je	SHORT $LN3@xmlLoadACa
	cmp	al, 60					; 0000003cH
	je	SHORT $LN7@xmlLoadACa
	cmp	al, 65					; 00000041H
	jb	SHORT $LN5@xmlLoadACa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN3@xmlLoadACa
$LN5@xmlLoadACa:
	cmp	al, 97					; 00000061H
	jb	SHORT $LN6@xmlLoadACa
	mov	cl, al
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN3@xmlLoadACa
$LN6@xmlLoadACa:
	mov	cl, BYTE PTR [edx+1]

; 2700 : 	   (!(((*first >= 'A') && (*first <= 'Z')) ||
; 2701 : 	      ((*first >= 'a') && (*first <= 'z')))))
; 2702 : 	first++;

	inc	edx
	mov	al, cl
	test	cl, cl
	jne	SHORT $LL2@xmlLoadACa
$LN3@xmlLoadACa:

; 2703 : 
; 2704 :     if (*first != '<') {

	cmp	cl, 60					; 0000003cH
	je	SHORT $LN7@xmlLoadACa

; 2705 : 	catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	2
	call	_xmlCreateNewCatalog
	mov	esi, eax
	add	esp, 8

; 2706 : 	if (catal == NULL) {

	test	esi, esi
	je	SHORT $LN17@xmlLoadACa

; 2707 : 	    xmlFree(content);
; 2708 : 	    return(NULL);
; 2709 : 	}
; 2710 :         ret = xmlParseSGMLCatalog(catal, content, filename, 0);

	push	0
	push	ebx
	push	edi
	push	esi
	call	_xmlParseSGMLCatalog
	add	esp, 16					; 00000010H

; 2711 : 	if (ret < 0) {

	test	eax, eax
	jns	SHORT $LN8@xmlLoadACa

; 2712 : 	    xmlFreeCatalog(catal);

	push	esi
	call	_xmlFreeCatalog

; 2713 : 	    xmlFree(content);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 2714 : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2727 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlLoadACa:

; 2715 : 	}
; 2716 :     } else {
; 2717 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE, xmlCatalogDefaultPrefer);

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	1
	call	_xmlCreateNewCatalog
	mov	esi, eax
	add	esp, 8

; 2718 : 	if (catal == NULL) {

	test	esi, esi
	jne	SHORT $LN11@xmlLoadACa
$LN17@xmlLoadACa:

; 2719 : 	    xmlFree(content);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2720 : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2727 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlLoadACa:

; 2721 : 	}
; 2722 :         catal->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,

	push	0
	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	ebx
	push	0
	push	0
	push	1
	call	_xmlNewCatalogEntry
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+60], eax
$LN8@xmlLoadACa:

; 2723 : 		       NULL, BAD_CAST filename, xmlCatalogDefaultPrefer, NULL);
; 2724 :     }
; 2725 :     xmlFree(content);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2726 :     return (catal);

	mov	eax, esi
	pop	esi
	pop	edi

; 2727 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlLoadACatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\catalog.c
;	COMDAT _xmlNewCatalog
_TEXT	SEGMENT
_sgml$ = 8						; size = 4
_xmlNewCatalog PROC					; COMDAT

; 3025 : xmlNewCatalog(int sgml) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0FC738B4_catalog@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _sgml$[ebp], 0
	je	SHORT $LN2@xmlNewCata

; 3026 :     xmlCatalogPtr catal = NULL;
; 3027 : 
; 3028 :     if (sgml) {
; 3029 : 	catal = xmlCreateNewCatalog(XML_SGML_CATALOG_TYPE,

	push	esi
	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	2
	call	_xmlCreateNewCatalog
	mov	esi, eax
	add	esp, 8

; 3030 : 		                    xmlCatalogDefaultPrefer);
; 3031 :         if ((catal != NULL) && (catal->sgml == NULL))

	test	esi, esi
	je	SHORT $LN8@xmlNewCata
	cmp	DWORD PTR [esi+52], 0
	jne	SHORT $LN8@xmlNewCata

; 3032 : 	    catal->sgml = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	mov	DWORD PTR [esi+52], eax
	add	esp, 4

; 3035 : 		                    xmlCatalogDefaultPrefer);
; 3036 :     return(catal);

	mov	eax, esi
$LN8@xmlNewCata:
	pop	esi

; 3037 : }

	pop	ebp
	ret	0
$LN2@xmlNewCata:

; 3033 :     } else
; 3034 : 	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,

	push	DWORD PTR _xmlCatalogDefaultPrefer
	push	1
	call	_xmlCreateNewCatalog
	add	esp, 8

; 3037 : }

	pop	ebp
	ret	0
_xmlNewCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\sys\stat.h
;	COMDAT _stat
_TEXT	SEGMENT
__FileName$ = 8						; size = 4
__Stat$ = 12						; size = 4
_stat	PROC						; COMDAT

; 240  :         {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A40A425D_stat@h
	call	@__CheckForDebuggerJustMyCode@4

; 243  :         }

	pop	ebp

; 241  :             _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	jmp	DWORD PTR __imp___stat64i32
_stat	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
