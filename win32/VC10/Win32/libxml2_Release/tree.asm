; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\tree.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___xmlRegisterCallbacks
PUBLIC	_xmlStringText
PUBLIC	_xmlStringTextNoenc
PUBLIC	_xmlStringComment
_BSS	SEGMENT
___xmlRegisterCallbacks DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
CONST	SEGMENT
_xmlStringText DB 074H
	DB	065H
	DB	078H
	DB	074H
	DB	00H
	ORG $+3
_xmlStringTextNoenc DB 074H
	DB	065H
	DB	078H
	DB	074H
	DB	06eH
	DB	06fH
	DB	065H
	DB	06eH
	DB	063H
	DB	00H
	ORG $+2
_xmlStringComment DB 063H
	DB	06fH
	DB	06dH
	DB	06dH
	DB	065H
	DB	06eH
	DB	074H
	DB	00H
CONST	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__59973643_tree@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlValidateNCName
PUBLIC	_xmlValidateQName
PUBLIC	_xmlValidateName
PUBLIC	_xmlValidateNMToken
PUBLIC	_xmlBuildQName
PUBLIC	_xmlSplitQName2
PUBLIC	_xmlSplitQName3
PUBLIC	_xmlSetBufferAllocationScheme
PUBLIC	_xmlGetBufferAllocationScheme
PUBLIC	_xmlBufferCreate
PUBLIC	_xmlBufferCreateSize
PUBLIC	_xmlBufferCreateStatic
PUBLIC	_xmlBufferResize
PUBLIC	_xmlBufferFree
PUBLIC	_xmlBufferDump
PUBLIC	_xmlBufferAdd
PUBLIC	_xmlBufferAddHead
PUBLIC	_xmlBufferCat
PUBLIC	_xmlBufferCCat
PUBLIC	_xmlBufferShrink
PUBLIC	_xmlBufferGrow
PUBLIC	_xmlBufferEmpty
PUBLIC	_xmlBufferContent
PUBLIC	_xmlBufferDetach
PUBLIC	_xmlBufferSetAllocationScheme
PUBLIC	_xmlBufferLength
PUBLIC	_xmlCreateIntSubset
PUBLIC	_xmlNewDtd
PUBLIC	_xmlGetIntSubset
PUBLIC	_xmlFreeDtd
PUBLIC	_xmlNewNs
PUBLIC	_xmlFreeNs
PUBLIC	_xmlFreeNsList
PUBLIC	_xmlNewDoc
PUBLIC	_xmlFreeDoc
PUBLIC	_xmlNewDocProp
PUBLIC	_xmlNewProp
PUBLIC	_xmlNewNsProp
PUBLIC	_xmlNewNsPropEatName
PUBLIC	_xmlFreePropList
PUBLIC	_xmlFreeProp
PUBLIC	_xmlCopyProp
PUBLIC	_xmlCopyPropList
PUBLIC	_xmlCopyDtd
PUBLIC	_xmlCopyDoc
PUBLIC	_xmlNewDocNode
PUBLIC	_xmlNewDocNodeEatName
PUBLIC	_xmlNewNode
PUBLIC	_xmlNewNodeEatName
PUBLIC	_xmlNewChild
PUBLIC	_xmlNewDocText
PUBLIC	_xmlNewText
PUBLIC	_xmlNewDocPI
PUBLIC	_xmlNewPI
PUBLIC	_xmlNewDocTextLen
PUBLIC	_xmlNewTextLen
PUBLIC	_xmlNewDocComment
PUBLIC	_xmlNewComment
PUBLIC	_xmlNewCDataBlock
PUBLIC	_xmlNewCharRef
PUBLIC	_xmlNewReference
PUBLIC	_xmlCopyNode
PUBLIC	_xmlDocCopyNode
PUBLIC	_xmlDocCopyNodeList
PUBLIC	_xmlCopyNodeList
PUBLIC	_xmlNewTextChild
PUBLIC	_xmlNewDocRawNode
PUBLIC	_xmlNewDocFragment
PUBLIC	_xmlGetLineNo
PUBLIC	_xmlGetNodePath
PUBLIC	_xmlDocGetRootElement
PUBLIC	_xmlGetLastChild
PUBLIC	_xmlNodeIsText
PUBLIC	_xmlIsBlankNode
PUBLIC	_xmlDocSetRootElement
PUBLIC	_xmlNodeSetName
PUBLIC	_xmlAddChild
PUBLIC	_xmlAddChildList
PUBLIC	_xmlReplaceNode
PUBLIC	_xmlAddPrevSibling
PUBLIC	_xmlAddSibling
PUBLIC	_xmlAddNextSibling
PUBLIC	_xmlUnlinkNode
PUBLIC	_xmlTextMerge
PUBLIC	_xmlTextConcat
PUBLIC	_xmlFreeNodeList
PUBLIC	_xmlFreeNode
PUBLIC	_xmlSetTreeDoc
PUBLIC	_xmlSetListDoc
PUBLIC	_xmlSearchNs
PUBLIC	_xmlSearchNsByHref
PUBLIC	_xmlGetNsList
PUBLIC	_xmlSetNs
PUBLIC	_xmlCopyNamespace
PUBLIC	_xmlCopyNamespaceList
PUBLIC	_xmlSetProp
PUBLIC	_xmlSetNsProp
PUBLIC	_xmlGetNoNsProp
PUBLIC	_xmlGetProp
PUBLIC	_xmlHasProp
PUBLIC	_xmlHasNsProp
PUBLIC	_xmlGetNsProp
PUBLIC	_xmlStringGetNodeList
PUBLIC	_xmlStringLenGetNodeList
PUBLIC	_xmlNodeListGetString
PUBLIC	_xmlNodeListGetRawString
PUBLIC	_xmlNodeSetContent
PUBLIC	_xmlNodeSetContentLen
PUBLIC	_xmlNodeAddContent
PUBLIC	_xmlNodeAddContentLen
PUBLIC	_xmlNodeGetContent
PUBLIC	_xmlNodeBufGetContent
PUBLIC	_xmlBufGetNodeContent
PUBLIC	_xmlNodeGetLang
PUBLIC	_xmlNodeGetSpacePreserve
PUBLIC	_xmlNodeSetLang
PUBLIC	_xmlNodeSetSpacePreserve
PUBLIC	_xmlNodeGetBase
PUBLIC	_xmlNodeSetBase
PUBLIC	_xmlRemoveProp
PUBLIC	_xmlUnsetNsProp
PUBLIC	_xmlUnsetProp
PUBLIC	_xmlBufferWriteCHAR
PUBLIC	_xmlBufferWriteChar
PUBLIC	_xmlBufferWriteQuotedString
PUBLIC	_xmlReconciliateNs
PUBLIC	_xmlGetDocCompressMode
PUBLIC	_xmlSetDocCompressMode
PUBLIC	_xmlGetCompressMode
PUBLIC	_xmlSetCompressMode
PUBLIC	_xmlDOMWrapNewCtxt
PUBLIC	_xmlDOMWrapFreeCtxt
PUBLIC	_xmlDOMWrapReconcileNamespaces
PUBLIC	_xmlDOMWrapAdoptNode
PUBLIC	_xmlDOMWrapRemoveNode
PUBLIC	_xmlDOMWrapCloneNode
PUBLIC	_xmlChildElementCount
PUBLIC	_xmlNextElementSibling
PUBLIC	_xmlFirstElementChild
PUBLIC	_xmlLastElementChild
PUBLIC	_xmlPreviousElementSibling
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CF@MFCHFOON@invalid?5hexadecimal?5character?5v@ ; `string'
PUBLIC	??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@ ; `string'
PUBLIC	??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@ ; `string'
PUBLIC	??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ ; `string'
PUBLIC	??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@	; `string'
PUBLIC	??_C@_0P@LPKFEOPI@building?5QName@		; `string'
PUBLIC	??_C@_0M@GKLEBIKC@QName?5split@			; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_0BD@OMFEMMGI@building?5namespace@		; `string'
PUBLIC	??_C@_0N@OIMLODKO@building?5DTD@		; `string'
PUBLIC	??_C@_0BJ@INPJKJEA@building?5internal?5subset@	; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40@				; `string'
PUBLIC	??_C@_0N@LKACPEIE@building?5doc@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BD@EEPKIILJ@building?5attribute@		; `string'
PUBLIC	??_C@_0L@GJIJNDEK@ISO?98859?91@			; `string'
PUBLIC	??_C@_0M@OGMFHPHO@building?5PI@			; `string'
PUBLIC	??_C@_0O@LNBKNEAL@building?5node@		; `string'
PUBLIC	??_C@_0BC@HPKKMJFM@building?5fragment@		; `string'
PUBLIC	??_C@_0O@LOBCMCEI@building?5text@		; `string'
PUBLIC	??_C@_0BN@PHGPAPBE@building?5character?5reference@ ; `string'
PUBLIC	??_C@_0BD@OKHPDLFF@building?5reference@		; `string'
PUBLIC	??_C@_0BB@JNPLEEAM@building?5comment@		; `string'
PUBLIC	??_C@_0P@MBGLGFEO@building?5CDATA@		; `string'
PUBLIC	??_C@_0N@IDAFCAHJ@copying?5node@		; `string'
PUBLIC	??_C@_0BC@NABGEGIL@getting?5node?5path@		; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs@			; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_09OMIOBGHN@comment?$CI?$CJ@		; `string'
PUBLIC	??_C@_06HNGKFOCG@text?$CI?$CJ@			; `string'
PUBLIC	??_C@_0BN@BBPFEMPE@processing?9instruction?$CI?8?$CFs?8?$CJ@ ; `string'
PUBLIC	??_C@_02MDNGGIDF@?1?$EA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs@		; `string'
PUBLIC	??_C@_0L@INIGIDIG@?$CFs?$CFs?$FL?$CFd?$FN?$CFs@	; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_07DLHCIBDH@default@			; `string'
PUBLIC	??_C@_05OLNILLAB@space@				; `string'
PUBLIC	??_C@_08ILAKLJGO@preserve@			; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1@			; `string'
PUBLIC	??_C@_06FNAPNHDD@ftp?3?1?1@			; `string'
PUBLIC	??_C@_04KODJDHBJ@urn?3@				; `string'
PUBLIC	??_C@_0BH@FLIFGMAI@getting?5namespace?5list@	; `string'
PUBLIC	??_C@_0BN@LLCMIJBD@allocating?5the?5XML?5namespace@ ; `string'
PUBLIC	??_C@_0BE@FPBDMLJE@searching?5namespace@	; `string'
PUBLIC	??_C@_05BNPGKEDD@?$CF?420s@			; `string'
PUBLIC	??_C@_09DFKPACFI@default?$CFd@			; `string'
PUBLIC	??_C@_07BKMHDFJP@?$CF?420s?$CFd@		; `string'
PUBLIC	??_C@_0BC@MPADMMPM@fixing?5namespaces@		; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_0P@LKGMENGP@growing?5buffer@		; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@	; `string'
PUBLIC	??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@ ; `string'
PUBLIC	??_C@_0BP@IBBGEDIA@allocating?5DOM?9wrapper?5context@ ; `string'
PUBLIC	??_C@_0BC@OAPAONED@alloc?5ns?5map?5item@	; `string'
PUBLIC	??_C@_0BE@NIDEIDLB@realloc?5ns?5map?5item@	; `string'
PUBLIC	??_C@_05GOMIJPDF@ns_?$CFd@			; `string'
PUBLIC	??_C@_08LCJGELPI@?$CF?430s_?$CFd@		; `string'
PUBLIC	??_C@_0CJ@IBBFFAIA@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ ; `string'
PUBLIC	??_C@_0CP@CMDBBNPE@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ ; `string'
PUBLIC	??_C@_0CM@EDBMOGPG@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlStrncat:PROC
EXTRN	_xmlStrncatNew:PROC
EXTRN	_xmlCheckUTF8:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlHashRemoveEntry:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlCopyNotationTable:PROC
EXTRN	_xmlFreeNotationTable:PROC
EXTRN	_xmlCopyElementTable:PROC
EXTRN	_xmlFreeElementTable:PROC
EXTRN	_xmlCopyAttributeTable:PROC
EXTRN	_xmlFreeAttributeTable:PROC
EXTRN	_xmlAddID:PROC
EXTRN	_xmlFreeIDTable:PROC
EXTRN	_xmlIsID:PROC
EXTRN	_xmlRemoveID:PROC
EXTRN	_xmlFreeRefTable:PROC
EXTRN	_xmlGetDtdAttrDesc:PROC
EXTRN	_xmlGetDtdQAttrDesc:PROC
EXTRN	_xmlGetDtdQElementDesc:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlEncodeEntitiesReentrant:PROC
EXTRN	_xmlEncodeSpecialChars:PROC
EXTRN	_xmlCopyEntitiesTable:PROC
EXTRN	_xmlFreeEntitiesTable:PROC
EXTRN	___xmlBufferAllocScheme:PROC
EXTRN	___xmlDefaultBufferSize:PROC
EXTRN	___xmlRegisterNodeDefaultValue:PROC
EXTRN	___xmlDeregisterNodeDefaultValue:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlPathToURI:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlCopyCharMultiByte:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufCreateSize:PROC
EXTRN	_xmlBufSetAllocationScheme:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufAdd:PROC
EXTRN	_xmlBufCat:PROC
EXTRN	_xmlBufIsEmpty:PROC
EXTRN	_xmlBufDetach:PROC
EXTRN	_xmlBufFromBuffer:PROC
EXTRN	_xmlBufBackToBuffer:PROC
EXTRN	_xmlEncodeAttributeEntities:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlCompressMode DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CM@EDBMOGPG@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@
CONST	SEGMENT
??_C@_0CM@EDBMOGPG@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ DB 'xmlDOMWra'
	DB	'pCloneNode(): allocating namespace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CMDBBNPE@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@
CONST	SEGMENT
??_C@_0CP@CMDBBNPE@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ DB 'xmlDOMWra'
	DB	'pCloneNode(): allocating an attr-node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IBBFFAIA@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@
CONST	SEGMENT
??_C@_0CJ@IBBFFAIA@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@ DB 'xmlDOMWra'
	DB	'pCloneNode(): allocating a node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCJGELPI@?$CF?430s_?$CFd@
CONST	SEGMENT
??_C@_08LCJGELPI@?$CF?430s_?$CFd@ DB '%.30s_%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOMIJPDF@ns_?$CFd@
CONST	SEGMENT
??_C@_05GOMIJPDF@ns_?$CFd@ DB 'ns_%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NIDEIDLB@realloc?5ns?5map?5item@
CONST	SEGMENT
??_C@_0BE@NIDEIDLB@realloc?5ns?5map?5item@ DB 'realloc ns map item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OAPAONED@alloc?5ns?5map?5item@
CONST	SEGMENT
??_C@_0BC@OAPAONED@alloc?5ns?5map?5item@ DB 'alloc ns map item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IBBGEDIA@allocating?5DOM?9wrapper?5context@
CONST	SEGMENT
??_C@_0BP@IBBGEDIA@allocating?5DOM?9wrapper?5context@ DB 'allocating DOM-'
	DB	'wrapper context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@
CONST	SEGMENT
??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@ DB 'allocating names'
	DB	'pace map item', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@
CONST	SEGMENT
??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@ DB 'allocating namespace m'
	DB	'ap', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKGMENGP@growing?5buffer@
CONST	SEGMENT
??_C@_0P@LKGMENGP@growing?5buffer@ DB 'growing buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MPADMMPM@fixing?5namespaces@
CONST	SEGMENT
??_C@_0BC@MPADMMPM@fixing?5namespaces@ DB 'fixing namespaces', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BKMHDFJP@?$CF?420s?$CFd@
CONST	SEGMENT
??_C@_07BKMHDFJP@?$CF?420s?$CFd@ DB '%.20s%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFKPACFI@default?$CFd@
CONST	SEGMENT
??_C@_09DFKPACFI@default?$CFd@ DB 'default%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNPGKEDD@?$CF?420s@
CONST	SEGMENT
??_C@_05BNPGKEDD@?$CF?420s@ DB '%.20s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FPBDMLJE@searching?5namespace@
CONST	SEGMENT
??_C@_0BE@FPBDMLJE@searching?5namespace@ DB 'searching namespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LLCMIJBD@allocating?5the?5XML?5namespace@
CONST	SEGMENT
??_C@_0BN@LLCMIJBD@allocating?5the?5XML?5namespace@ DB 'allocating the XM'
	DB	'L namespace', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLIFGMAI@getting?5namespace?5list@
CONST	SEGMENT
??_C@_0BH@FLIFGMAI@getting?5namespace?5list@ DB 'getting namespace list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KODJDHBJ@urn?3@
CONST	SEGMENT
??_C@_04KODJDHBJ@urn?3@ DB 'urn:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNAPNHDD@ftp?3?1?1@
CONST	SEGMENT
??_C@_06FNAPNHDD@ftp?3?1?1@ DB 'ftp://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1@ DB 'http://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILAKLJGO@preserve@
CONST	SEGMENT
??_C@_08ILAKLJGO@preserve@ DB 'preserve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLNILLAB@space@
CONST	SEGMENT
??_C@_05OLNILLAB@space@ DB 'space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default@
CONST	SEGMENT
??_C@_07DLHCIBDH@default@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INIGIDIG@?$CFs?$CFs?$FL?$CFd?$FN?$CFs@
CONST	SEGMENT
??_C@_0L@INIGIDIG@?$CFs?$CFs?$FL?$CFd?$FN?$CFs@ DB '%s%s[%d]%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDNGGIDF@?1?$EA@
CONST	SEGMENT
??_C@_02MDNGGIDF@?1?$EA@ DB '/@', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BBPFEMPE@processing?9instruction?$CI?8?$CFs?8?$CJ@
CONST	SEGMENT
??_C@_0BN@BBPFEMPE@processing?9instruction?$CI?8?$CFs?8?$CJ@ DB 'processi'
	DB	'ng-instruction(''%s'')', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HNGKFOCG@text?$CI?$CJ@
CONST	SEGMENT
??_C@_06HNGKFOCG@text?$CI?$CJ@ DB 'text()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMIOBGHN@comment?$CI?$CJ@
CONST	SEGMENT
??_C@_09OMIOBGHN@comment?$CI?$CJ@ DB 'comment()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs@ DB '%s:%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NABGEGIL@getting?5node?5path@
CONST	SEGMENT
??_C@_0BC@NABGEGIL@getting?5node?5path@ DB 'getting node path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDAFCAHJ@copying?5node@
CONST	SEGMENT
??_C@_0N@IDAFCAHJ@copying?5node@ DB 'copying node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBGLGFEO@building?5CDATA@
CONST	SEGMENT
??_C@_0P@MBGLGFEO@building?5CDATA@ DB 'building CDATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNPLEEAM@building?5comment@
CONST	SEGMENT
??_C@_0BB@JNPLEEAM@building?5comment@ DB 'building comment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OKHPDLFF@building?5reference@
CONST	SEGMENT
??_C@_0BD@OKHPDLFF@building?5reference@ DB 'building reference', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PHGPAPBE@building?5character?5reference@
CONST	SEGMENT
??_C@_0BN@PHGPAPBE@building?5character?5reference@ DB 'building character'
	DB	' reference', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LOBCMCEI@building?5text@
CONST	SEGMENT
??_C@_0O@LOBCMCEI@building?5text@ DB 'building text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HPKKMJFM@building?5fragment@
CONST	SEGMENT
??_C@_0BC@HPKKMJFM@building?5fragment@ DB 'building fragment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNBKNEAL@building?5node@
CONST	SEGMENT
??_C@_0O@LNBKNEAL@building?5node@ DB 'building node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OGMFHPHO@building?5PI@
CONST	SEGMENT
??_C@_0M@OGMFHPHO@building?5PI@ DB 'building PI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91@
CONST	SEGMENT
??_C@_0L@GJIJNDEK@ISO?98859?91@ DB 'ISO-8859-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEPKIILJ@building?5attribute@
CONST	SEGMENT
??_C@_0BD@EEPKIILJ@building?5attribute@ DB 'building attribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKACPEIE@building?5doc@
CONST	SEGMENT
??_C@_0N@LKACPEIE@building?5doc@ DB 'building doc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40@ DB '1.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@INPJKJEA@building?5internal?5subset@
CONST	SEGMENT
??_C@_0BJ@INPJKJEA@building?5internal?5subset@ DB 'building internal subs'
	DB	'et', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIMLODKO@building?5DTD@
CONST	SEGMENT
??_C@_0N@OIMLODKO@building?5DTD@ DB 'building DTD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMFEMMGI@building?5namespace@
CONST	SEGMENT
??_C@_0BD@OMFEMMGI@building?5namespace@ DB 'building namespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GKLEBIKC@QName?5split@
CONST	SEGMENT
??_C@_0M@GKLEBIKC@QName?5split@ DB 'QName split', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPKFEOPI@building?5QName@
CONST	SEGMENT
??_C@_0P@LPKFEOPI@building?5QName@ DB 'building QName', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlCheckDTD DD	01H
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
CONST	SEGMENT
??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@ DB 'unexpected error numb'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
CONST	SEGMENT
??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ DB 'string is not in UT'
	DB	'F-8', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@
CONST	SEGMENT
??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@ DB 'unterminate'
	DB	'd entity reference %15s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@
CONST	SEGMENT
??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@ DB 'invalid decima'
	DB	'l character value', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MFCHFOON@invalid?5hexadecimal?5character?5v@
CONST	SEGMENT
??_C@_0CF@MFCHFOON@invalid?5hexadecimal?5character?5v@ DB 'invalid hexade'
	DB	'cimal character value', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapAdoptAttr
_TEXT	SEGMENT
_cur$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
_nsName$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_sourceDoc$ = 12					; size = 4
_attr$ = 16						; size = 4
_destDoc$ = 20						; size = 4
_destParent$ = 24					; size = 4
_options$ = 28						; size = 4
_xmlDOMWrapAdoptAttr PROC				; COMDAT

; 9903 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __59973643_tree@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _attr$[ebp]
	test	edx, edx
	je	$LN7@xmlDOMWrap

; 9904 :     xmlNodePtr cur;
; 9905 :     int adoptStr = 1;
; 9906 : 
; 9907 :     if ((attr == NULL) || (destDoc == NULL))

	mov	ebx, DWORD PTR _destDoc$[ebp]
	test	ebx, ebx
	je	$LN7@xmlDOMWrap

; 9908 : 	return (-1);
; 9909 : 
; 9910 :     attr->doc = destDoc;
; 9911 :     if (attr->ns != NULL) {

	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [edx+32], ebx
	test	ecx, ecx
	je	$LN8@xmlDOMWrap

; 9912 : 	xmlNsPtr ns = NULL;
; 9913 : 
; 9914 : 	if (ctxt != NULL) {
; 9915 : 	    /* TODO: User defined. */
; 9916 : 	}
; 9917 : 	/* XML Namespace. */
; 9918 : 	if (IS_STR_XML(attr->ns->prefix)) {

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax], 120			; 00000078H
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+1], 109			; 0000006dH
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+2], 108			; 0000006cH
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN10@xmlDOMWrap

; 9919 : 	    ns = xmlTreeEnsureXMLDecl(destDoc);

	push	ebx
	call	_xmlTreeEnsureXMLDecl
	add	esp, 4
	jmp	$LN124@xmlDOMWrap
$LN10@xmlDOMWrap:

; 9920 : 	} else if (destParent == NULL) {

	mov	edi, DWORD PTR _destParent$[ebp]
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR _nsName$1$[ebp], esi
	test	edi, edi
	jne	SHORT $LN12@xmlDOMWrap

; 9921 : 	    /*
; 9922 : 	    * Store in @destDoc->oldNs.
; 9923 : 	    */
; 9924 : 	    ns = xmlDOMWrapStoreNs(destDoc, attr->ns->href, attr->ns->prefix);

	push	eax
	push	esi
	push	ebx
	call	_xmlDOMWrapStoreNs
	add	esp, 12					; 0000000cH

; 9925 : 	} else {

	jmp	$LN124@xmlDOMWrap
$LN12@xmlDOMWrap:

; 8355 :     xmlNodePtr cur, prev = NULL, out = NULL;

	xor	ebx, ebx
	mov	DWORD PTR _out$1$[ebp], ebx

; 8356 :     xmlNsPtr ns, prevns;
; 8357 : 
; 8358 :     if ((doc == NULL) || (nsName == NULL) || (retNs == NULL))

	test	esi, esi
	je	SHORT $LN7@xmlDOMWrap

; 8359 : 	return (-1);
; 8360 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN7@xmlDOMWrap

; 8361 :         return(-1);
; 8362 : 
; 8363 :     *retNs = NULL;
; 8364 :     if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlDOMWrap

; 8365 : 	*retNs = xmlTreeEnsureXMLDecl(doc);

	mov	ebx, DWORD PTR _destDoc$[ebp]
	push	ebx
	call	_xmlTreeEnsureXMLDecl
	mov	edi, eax
	add	esp, 4

; 8366 : 	if (*retNs == NULL)

	test	edi, edi
	jne	$LN98@xmlDOMWrap
$LN7@xmlDOMWrap:
$internal_error$127:
	pop	edi

; 9995 : 	}
; 9996 :     }
; 9997 :     return (0);
; 9998 : internal_error:
; 9999 :     return (-1);
; 10000: }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlDOMWrap:

; 8370 :     cur = node;

	mov	ecx, edi
	mov	DWORD PTR _cur$1$[ebp], edi
	npad	10
$LL42@xmlDOMWrap:

; 8371 :     do {
; 8372 : 	if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	$LN55@xmlDOMWrap

; 8373 : 	    if (cur->nsDef != NULL) {

	mov	edi, DWORD PTR [ecx+48]
	test	edi, edi
	je	$LN68@xmlDOMWrap
	npad	9
$LL45@xmlDOMWrap:

; 8375 : 		    if (prefixed && (ns->prefix == NULL))

	cmp	DWORD PTR [edi+12], 0
	je	$LN43@xmlDOMWrap

; 8376 : 			continue;
; 8377 : 		    if (prev != NULL) {

	test	ebx, ebx
	je	SHORT $LN62@xmlDOMWrap

; 8378 : 			/*
; 8379 : 			* Check the last level of ns-decls for a
; 8380 : 			* shadowing prefix.
; 8381 : 			*/
; 8382 : 			prevns = prev->nsDef;

	mov	esi, DWORD PTR [ebx+48]
$LL48@xmlDOMWrap:

; 8383 : 			do {
; 8384 : 			    if ((prevns->prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	je	$LN122@xmlDOMWrap
	test	eax, eax
	je	SHORT $LN60@xmlDOMWrap
	test	ecx, ecx
	je	SHORT $LN60@xmlDOMWrap
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN122@xmlDOMWrap
$LN60@xmlDOMWrap:

; 8385 : 				((prevns->prefix != NULL) &&
; 8386 : 				(ns->prefix != NULL) &&
; 8387 : 				xmlStrEqual(prevns->prefix, ns->prefix))) {
; 8388 : 				/*
; 8389 : 				* Shadowed.
; 8390 : 				*/
; 8391 : 				break;
; 8392 : 			    }
; 8393 : 			    prevns = prevns->next;

	mov	esi, DWORD PTR [esi]

; 8394 : 			} while (prevns != NULL);

	test	esi, esi
	jne	SHORT $LL48@xmlDOMWrap
	mov	esi, DWORD PTR _nsName$1$[ebp]
$LN62@xmlDOMWrap:

; 8395 : 			if (prevns != NULL)
; 8396 : 			    continue;
; 8397 : 		    }
; 8398 : 		    /*
; 8399 : 		    * Ns-name comparison.
; 8400 : 		    */
; 8401 : 		    if ((nsName == ns->href) ||

	mov	eax, DWORD PTR [edi+8]
	cmp	esi, eax
	je	SHORT $LN64@xmlDOMWrap
	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xmlDOMWrap
$LN64@xmlDOMWrap:

; 8402 : 			xmlStrEqual(nsName, ns->href)) {
; 8403 : 			/*
; 8404 : 			* At this point the prefix can only be shadowed,
; 8405 : 			* if we are the the (at least) 3rd level of
; 8406 : 			* ns-decls.
; 8407 : 			*/
; 8408 : 			if (out) {

	cmp	DWORD PTR _out$1$[ebp], 0
	je	SHORT $LN67@xmlDOMWrap

; 8409 : 			    int ret;
; 8410 : 
; 8411 : 			    ret = xmlNsInScope(doc, node, prev, ns->prefix);

	push	DWORD PTR [edi+12]
	push	ebx
	push	DWORD PTR _destParent$[ebp]
	push	DWORD PTR _destDoc$[ebp]
	call	_xmlNsInScope
	add	esp, 16					; 00000010H

; 8412 : 			    if (ret < 0)

	test	eax, eax
	js	$LN7@xmlDOMWrap

; 8413 : 				return (-1);
; 8414 : 			    /*
; 8415 : 			    * TODO: Should we try to find a matching ns-name
; 8416 : 			    * only once? This here keeps on searching.
; 8417 : 			    * I think we should try further since, there might
; 8418 : 			    * be an other matching ns-decl with an unshadowed
; 8419 : 			    * prefix.
; 8420 : 			    */
; 8421 : 			    if (! ret)

	je	SHORT $LN43@xmlDOMWrap
$LN67@xmlDOMWrap:

; 9926 : 	    /*
; 9927 : 	    * Declare on @destParent.
; 9928 : 	    */
; 9929 : 	    if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,
; 9930 : 		&ns, 1) == -1)
; 9931 : 		goto internal_error;
; 9932 : 	    if (ns == NULL) {

	test	edi, edi
	jne	SHORT $LN116@xmlDOMWrap
$LN102@xmlDOMWrap:

; 9933 : 		ns = xmlDOMWrapNSNormDeclareNsForced(destDoc, destParent,

	mov	ecx, DWORD PTR _attr$[ebp]
	mov	ebx, DWORD PTR _destDoc$[ebp]
	push	1
	mov	eax, DWORD PTR [ecx+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	DWORD PTR _destParent$[ebp]
	push	ebx
	call	_xmlDOMWrapNSNormDeclareNsForced
	add	esp, 20					; 00000014H
$LN124@xmlDOMWrap:

; 9934 : 		    attr->ns->href, attr->ns->prefix, 1);
; 9935 : 	    }
; 9936 : 	}
; 9937 : 	if (ns == NULL)

	mov	edi, eax
	test	edi, edi
	je	$LN7@xmlDOMWrap

; 9926 : 	    /*
; 9927 : 	    * Declare on @destParent.
; 9928 : 	    */
; 9929 : 	    if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,
; 9930 : 		&ns, 1) == -1)
; 9931 : 		goto internal_error;
; 9932 : 	    if (ns == NULL) {

	jmp	SHORT $LN98@xmlDOMWrap
$LN122@xmlDOMWrap:

; 8374 : 		for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	esi, DWORD PTR _nsName$1$[ebp]
$LN43@xmlDOMWrap:
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	$LL45@xmlDOMWrap

; 8422 : 				continue;
; 8423 : 			}
; 8424 : 			*retNs = ns;
; 8425 : 			return (1);
; 8426 : 		    }
; 8427 : 		}
; 8428 : 		out = prev;
; 8429 : 		prev = cur;

	mov	ecx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR _out$1$[ebp], ebx
	mov	ebx, ecx

; 8430 : 	    }
; 8431 : 	} else if ((cur->type == XML_ENTITY_NODE) ||

	jmp	SHORT $LN68@xmlDOMWrap
$LN55@xmlDOMWrap:
	cmp	eax, 6
	je	SHORT $LN102@xmlDOMWrap
	cmp	eax, 17					; 00000011H
	je	SHORT $LN102@xmlDOMWrap
$LN68@xmlDOMWrap:

; 8432 :             (cur->type == XML_ENTITY_DECL))
; 8433 : 	    return (0);
; 8434 : 	cur = cur->parent;

	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cur$1$[ebp], ecx

; 8435 :     } while ((cur != NULL) && (cur->doc != (xmlDocPtr) cur));

	test	ecx, ecx
	je	SHORT $LN102@xmlDOMWrap
	cmp	DWORD PTR [ecx+32], ecx
	jne	$LL42@xmlDOMWrap
	jmp	SHORT $LN102@xmlDOMWrap
$LN116@xmlDOMWrap:

; 9926 : 	    /*
; 9927 : 	    * Declare on @destParent.
; 9928 : 	    */
; 9929 : 	    if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,
; 9930 : 		&ns, 1) == -1)
; 9931 : 		goto internal_error;
; 9932 : 	    if (ns == NULL) {

	mov	ebx, DWORD PTR _destDoc$[ebp]
$LN98@xmlDOMWrap:

; 9938 : 	    goto internal_error;
; 9939 : 	attr->ns = ns;

	mov	edx, DWORD PTR _attr$[ebp]
	mov	DWORD PTR [edx+36], edi
$LN8@xmlDOMWrap:

; 9940 :     }
; 9941 : 
; 9942 :     XML_TREE_ADOPT_STR(attr->name);

	mov	esi, DWORD PTR [edx+8]
	mov	edi, DWORD PTR _sourceDoc$[ebp]
	test	esi, esi
	je	SHORT $LN22@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+80]
	test	eax, eax
	je	$LN18@xmlDOMWrap
	push	-1
	push	esi
	push	eax
	call	_xmlDictLookup
	mov	ecx, DWORD PTR _attr$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	test	edi, edi
	je	SHORT $LN21@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN21@xmlDOMWrap
	push	esi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN120@xmlDOMWrap
$LN21@xmlDOMWrap:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN120@xmlDOMWrap:

; 9943 :     attr->atype = 0;

	mov	edx, DWORD PTR _attr$[ebp]
$LN22@xmlDOMWrap:

; 9944 :     attr->psvi = NULL;
; 9945 :     /*
; 9946 :     * Walk content.
; 9947 :     */
; 9948 :     if (attr->children == NULL)

	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0
	test	esi, esi
	je	$LN115@xmlDOMWrap

; 9949 : 	return (0);
; 9950 :     cur = attr->children;
; 9951 :     if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	$LN7@xmlDOMWrap
$LL2@xmlDOMWrap:

; 9954 : 	cur->doc = destDoc;
; 9955 : 	switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+32], ebx
	cmp	eax, 3
	jl	$LN28@xmlDOMWrap
	cmp	eax, 4
	jle	$LN25@xmlDOMWrap
	cmp	eax, 5
	jne	$LN28@xmlDOMWrap

; 9959 : 		break;
; 9960 : 	    case XML_ENTITY_REF_NODE:
; 9961 : 		/*
; 9962 : 		* Remove reference to the entitity-node.
; 9963 : 		*/
; 9964 : 		cur->content = NULL;

	mov	DWORD PTR [esi+40], 0

; 9965 : 		cur->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 9966 : 		cur->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 9967 : 		if ((destDoc->intSubset) || (destDoc->extSubset)) {

	cmp	DWORD PTR [ebx+44], 0
	jne	SHORT $LN31@xmlDOMWrap
	cmp	DWORD PTR [ebx+48], 0
	je	$LN28@xmlDOMWrap
$LN31@xmlDOMWrap:

; 9968 : 		    xmlEntityPtr ent;
; 9969 : 		    /*
; 9970 : 		    * Assign new entity-node if available.
; 9971 : 		    */
; 9972 : 		    ent = xmlGetDocEntity(destDoc, cur->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlGetDocEntity

; 9973 : 		    if (ent != NULL) {

	mov	edx, DWORD PTR _attr$[ebp]
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlDOMWrap

; 9974 : 			cur->content = ent->content;

	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [esi+40], ecx

; 9975 : 			cur->children = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+12], eax

; 9976 : 			cur->last = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+16], eax

; 9977 : 		    }
; 9978 : 		}
; 9979 : 		break;

	jmp	$LN28@xmlDOMWrap
$LN18@xmlDOMWrap:

; 9940 :     }
; 9941 : 
; 9942 :     XML_TREE_ADOPT_STR(attr->name);

	test	edi, edi
	je	$LN22@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	$LN22@xmlDOMWrap
	push	esi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	$LN120@xmlDOMWrap
	mov	ecx, DWORD PTR _attr$[ebp]
	push	DWORD PTR [ecx+8]
	call	_xmlStrdup
	mov	edx, DWORD PTR _attr$[ebp]
	add	esp, 4
	mov	DWORD PTR [edx+8], eax
	jmp	$LN22@xmlDOMWrap
$LN25@xmlDOMWrap:

; 9956 : 	    case XML_TEXT_NODE:
; 9957 : 	    case XML_CDATA_SECTION_NODE:
; 9958 : 		XML_TREE_ADOPT_STR_2(cur->content)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN28@xmlDOMWrap
	test	edi, edi
	je	SHORT $LN28@xmlDOMWrap
	mov	ecx, DWORD PTR [edi+80]
	test	ecx, ecx
	je	SHORT $LN28@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN118@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN27@xmlDOMWrap
	push	-1
	push	ecx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN125@xmlDOMWrap
$LN27@xmlDOMWrap:
	push	ecx
	call	_xmlStrdup
	add	esp, 4
$LN125@xmlDOMWrap:

; 9980 : 	    default:
; 9981 : 		break;
; 9982 : 	}
; 9983 : 	if (cur->children != NULL) {

	mov	DWORD PTR [esi+40], eax
$LN118@xmlDOMWrap:
	mov	edx, DWORD PTR _attr$[ebp]
$LN28@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN84@xmlDOMWrap
	npad	5
$next_sibling$128:

; 9984 : 	    cur = cur->children;
; 9985 : 	    continue;
; 9986 : 	}
; 9987 : next_sibling:
; 9988 : 	if (cur == (xmlNodePtr) attr)

	cmp	esi, edx
	je	SHORT $LN115@xmlDOMWrap

; 9989 : 	    break;
; 9990 : 	if (cur->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN84@xmlDOMWrap

; 9991 : 	    cur = cur->next;
; 9992 : 	else {
; 9993 : 	    cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 9994 : 	    goto next_sibling;

	jmp	SHORT $next_sibling$128
$LN84@xmlDOMWrap:

; 9952 :         goto internal_error;
; 9953 :     while (cur != NULL) {

	mov	esi, eax
	test	esi, esi
	jne	$LL2@xmlDOMWrap
$LN115@xmlDOMWrap:
	pop	edi

; 9995 : 	}
; 9996 :     }
; 9997 :     return (0);
; 9998 : internal_error:
; 9999 :     return (-1);
; 10000: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDOMWrapAdoptAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapAdoptBranch
_TEXT	SEGMENT
_curElem$1$ = -24					; size = 4
_adoptStr$1$ = -20					; size = 4
_ns$ = -16						; size = 4
_parnsdone$1$ = -12					; size = 4
_nsMap$ = -8						; size = 4
_depth$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_sourceDoc$ = 12					; size = 4
_node$ = 16						; size = 4
_destDoc$ = 20						; size = 4
_destParent$ = 24					; size = 4
_options$ = 28						; size = 4
_xmlDOMWrapAdoptBranch PROC				; COMDAT

; 9008 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _sourceDoc$[ebp]
	xor	esi, esi
	or	edx, -1
	mov	DWORD PTR _curElem$1$[ebp], 0
	mov	DWORD PTR _nsMap$[ebp], esi
	mov	DWORD PTR _ns$[ebp], esi
	mov	DWORD PTR _depth$1$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN23@xmlDOMWrap

; 9009 :     int ret = 0;
; 9010 :     xmlNodePtr cur, curElem = NULL;
; 9011 :     xmlNsMapPtr nsMap = NULL;
; 9012 :     xmlNsMapItemPtr mi;
; 9013 :     xmlNsPtr ns = NULL;
; 9014 :     int depth = -1, adoptStr = 1;
; 9015 :     /* gather @parent's ns-decls. */
; 9016 :     int parnsdone;
; 9017 :     /* @ancestorsOnly should be set per option. */
; 9018 :     int ancestorsOnly = 0;
; 9019 : 
; 9020 :     /*
; 9021 :     * Optimize string adoption for equal or none dicts.
; 9022 :     */
; 9023 :     if ((sourceDoc != NULL) &&

	mov	edi, DWORD PTR _destDoc$[ebp]
	mov	eax, DWORD PTR [ecx+80]

; 9024 : 	(sourceDoc->dict == destDoc->dict))
; 9025 : 	adoptStr = 0;

	mov	DWORD PTR _adoptStr$1$[ebp], esi
	cmp	eax, DWORD PTR [edi+80]
	je	SHORT $LN24@xmlDOMWrap
$LN23@xmlDOMWrap:

; 9026 :     else
; 9027 : 	adoptStr = 1;

	mov	DWORD PTR _adoptStr$1$[ebp], 1
$LN24@xmlDOMWrap:

; 9028 : 
; 9029 :     /*
; 9030 :     * Get the ns-map from the context if available.
; 9031 :     */
; 9032 :     if (ctxt)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN166@xmlDOMWrap

; 9033 : 	nsMap = (xmlNsMapPtr) ctxt->namespaceMap;

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _nsMap$[ebp], esi
$LN166@xmlDOMWrap:

; 9034 :     /*
; 9035 :     * Disable search for ns-decls in the parent-axis of the
; 9036 :     * desination element, if:
; 9037 :     * 1) there's no destination parent
; 9038 :     * 2) custom ns-reference handling is used
; 9039 :     */
; 9040 :     if ((destParent == NULL) ||

	cmp	DWORD PTR _destParent$[ebp], 0
	je	SHORT $LN28@xmlDOMWrap
	test	eax, eax
	je	SHORT $LN26@xmlDOMWrap
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN28@xmlDOMWrap
$LN26@xmlDOMWrap:

; 9044 :     } else
; 9045 : 	parnsdone = 0;

	mov	DWORD PTR _parnsdone$1$[ebp], 0
	jmp	SHORT $LN27@xmlDOMWrap
$LN28@xmlDOMWrap:

; 9041 : 	(ctxt && ctxt->getNsForNodeFunc))
; 9042 :     {
; 9043 : 	parnsdone = 1;

	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN27@xmlDOMWrap:

; 9046 : 
; 9047 :     cur = node;

	mov	edi, DWORD PTR _node$[ebp]
	mov	ebx, edi

; 9048 :     if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))

	test	edi, edi
	je	$LN247@xmlDOMWrap
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$internal_error$261
$LL2@xmlDOMWrap:

; 9052 : 	/*
; 9053 : 	* Paranoid source-doc sanity check.
; 9054 : 	*/
; 9055 : 	if (cur->doc != sourceDoc) {

	cmp	DWORD PTR [ebx+32], ecx
	je	SHORT $LN34@xmlDOMWrap

; 9056 : 	    /*
; 9057 : 	    * We'll assume XIncluded nodes if the doc differs.
; 9058 : 	    * TODO: Do we need to reconciliate XIncluded nodes?
; 9059 : 	    * This here skips XIncluded nodes and tries to handle
; 9060 : 	    * broken sequences.
; 9061 : 	    */
; 9062 : 	    if (cur->next == NULL)

	mov	ecx, DWORD PTR [ebx+24]
	test	ecx, ecx
	je	$leave_node$262
	mov	eax, DWORD PTR [edi+32]
	npad	5
$LL6@xmlDOMWrap:

; 9063 : 		goto leave_node;
; 9064 : 	    do {
; 9065 : 		cur = cur->next;

	mov	ebx, ecx

; 9066 : 		if ((cur->type == XML_XINCLUDE_END) ||

	cmp	DWORD PTR [ebx+4], 20			; 00000014H
	je	SHORT $LN5@xmlDOMWrap
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [ebx+32], eax
	je	SHORT $LN254@xmlDOMWrap

; 9067 : 		    (cur->doc == node->doc))
; 9068 : 		    break;
; 9069 : 	    } while (cur->next != NULL);

	mov	ecx, DWORD PTR [ebx+24]
	test	ecx, ecx
	jne	SHORT $LL6@xmlDOMWrap
$LN5@xmlDOMWrap:

; 9070 : 
; 9071 : 	    if (cur->doc != node->doc)

	cmp	DWORD PTR [ebx+32], eax
	jne	$leave_node$262
$LN254@xmlDOMWrap:
	mov	ecx, DWORD PTR _sourceDoc$[ebp]
$LN34@xmlDOMWrap:

; 9072 : 		goto leave_node;
; 9073 : 	}
; 9074 : 	cur->doc = destDoc;

	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	DWORD PTR [ebx+32], eax

; 9075 : 	switch (cur->type) {

	mov	eax, DWORD PTR [ebx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	$internal_error$261
	movzx	eax, BYTE PTR $LN206@xmlDOMWrap[eax]
	jmp	DWORD PTR $LN260@xmlDOMWrap[eax*4]
$LN36@xmlDOMWrap:

; 9076 : 	    case XML_XINCLUDE_START:
; 9077 : 	    case XML_XINCLUDE_END:
; 9078 : 		/*
; 9079 : 		* TODO
; 9080 : 		*/
; 9081 : 		return (-1);
; 9082 : 	    case XML_ELEMENT_NODE:
; 9083 : 		curElem = cur;
; 9084 : 		depth++;
; 9085 : 		/*
; 9086 : 		* Namespace declarations.
; 9087 : 		* - ns->href and ns->prefix are never in the dict, so
; 9088 : 		*   we need not move the values over to the destination dict.
; 9089 : 		* - Note that for custom handling of ns-references,
; 9090 : 		*   the ns-decls need not be stored in the ns-map,
; 9091 : 		*   since they won't be referenced by node->ns.
; 9092 : 		*/
; 9093 : 		if ((cur->nsDef) &&

	mov	edi, DWORD PTR [ebx+48]
	inc	edx
	mov	DWORD PTR _curElem$1$[ebp], ebx
	mov	DWORD PTR _depth$1$[ebp], edx
	test	edi, edi
	je	$LN10@xmlDOMWrap
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN192@xmlDOMWrap
	cmp	DWORD PTR [eax+12], 0
	jne	$LN10@xmlDOMWrap
$LN192@xmlDOMWrap:

; 9094 : 		    ((ctxt == NULL) || (ctxt->getNsForNodeFunc == NULL)))
; 9095 : 		{
; 9096 : 		    if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	jne	SHORT $LN39@xmlDOMWrap

; 9097 : 			/*
; 9098 : 			* Gather @parent's in-scope ns-decls.
; 9099 : 			*/
; 9100 : 			if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 9101 : 			    destParent) == -1)

	push	DWORD PTR _destParent$[ebp]
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	add	esp, 8
	cmp	eax, -1
	je	$LN218@xmlDOMWrap

; 9102 : 			    goto internal_error;
; 9103 : 			parnsdone = 1;

	mov	edi, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	edx, DWORD PTR _depth$1$[ebp]
	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN39@xmlDOMWrap:

; 9104 : 		    }
; 9105 : 		    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	DWORD PTR _ns$[ebp], edi
	test	edi, edi
	je	SHORT $LN10@xmlDOMWrap
	npad	4
$LL11@xmlDOMWrap:

; 9106 : 			/*
; 9107 : 			* NOTE: ns->prefix and ns->href are never in the dict.
; 9108 : 			* XML_TREE_ADOPT_STR(ns->prefix)
; 9109 : 			* XML_TREE_ADOPT_STR(ns->href)
; 9110 : 			*/
; 9111 : 			/*
; 9112 : 			* Does it shadow any ns-decl?
; 9113 : 			*/
; 9114 : 			if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN13@xmlDOMWrap
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN13@xmlDOMWrap
	npad	6
$LL14@xmlDOMWrap:

; 9116 : 				if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&
; 9117 : 				    (mi->shadowDepth == -1) &&

	cmp	DWORD PTR [esi+20], -1
	jl	SHORT $LN12@xmlDOMWrap
	cmp	DWORD PTR [esi+16], -1
	jne	SHORT $LN12@xmlDOMWrap
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN43@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	mov	edx, DWORD PTR _depth$1$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlDOMWrap
$LN43@xmlDOMWrap:

; 9118 : 				    ((ns->prefix == mi->newNs->prefix) ||
; 9119 : 				    xmlStrEqual(ns->prefix,
; 9120 : 				    mi->newNs->prefix))) {
; 9121 : 
; 9122 : 				    mi->shadowDepth = depth;

	mov	DWORD PTR [esi+16], edx
$LN12@xmlDOMWrap:

; 9115 : 			    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL14@xmlDOMWrap
$LN13@xmlDOMWrap:

; 9123 : 				}
; 9124 : 			    }
; 9125 : 			}
; 9126 : 			/*
; 9127 : 			* Push mapping.
; 9128 : 			*/
; 9129 : 			if (xmlDOMWrapNsMapAddItem(&nsMap, -1,
; 9130 : 			    ns, ns, depth) == NULL)

	push	edx
	push	edi
	push	edi
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	-1
	push	eax
	call	_xmlDOMWrapNsMapAddItem
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN218@xmlDOMWrap

; 9104 : 		    }
; 9105 : 		    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	DWORD PTR _ns$[ebp], edi
	test	edi, edi
	je	SHORT $LN10@xmlDOMWrap
	mov	edx, DWORD PTR _depth$1$[ebp]
	jmp	SHORT $LL11@xmlDOMWrap
$LN10@xmlDOMWrap:

; 9131 : 			    goto internal_error;
; 9132 : 		    }
; 9133 : 		}
; 9134 :                 /* Falls through. */
; 9135 : 	    case XML_ATTRIBUTE_NODE:
; 9136 : 		/* No namespace, no fun. */
; 9137 : 		if (cur->ns == NULL)

	cmp	DWORD PTR [ebx+36], 0
	je	$ns_end$263

; 9138 : 		    goto ns_end;
; 9139 : 
; 9140 : 		if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	mov	edi, DWORD PTR _destParent$[ebp]
	jne	SHORT $LN47@xmlDOMWrap

; 9141 : 		    if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 9142 : 			destParent) == -1)

	lea	eax, DWORD PTR _nsMap$[ebp]
	push	edi
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	add	esp, 8
	cmp	eax, -1
	je	$LN218@xmlDOMWrap

; 9143 : 			goto internal_error;
; 9144 : 		    parnsdone = 1;

	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN47@xmlDOMWrap:

; 9145 : 		}
; 9146 : 		/*
; 9147 : 		* Adopt ns-references.
; 9148 : 		*/
; 9149 : 		if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN205@xmlDOMWrap
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN205@xmlDOMWrap
	npad	6
$LL17@xmlDOMWrap:

; 9154 : 			if ((mi->shadowDepth == -1) &&

	cmp	DWORD PTR [ecx+16], -1
	jne	SHORT $LN15@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+36]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN128@xmlDOMWrap
$LN15@xmlDOMWrap:

; 9150 : 		    /*
; 9151 : 		    * Search for a mapping.
; 9152 : 		    */
; 9153 : 		    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL17@xmlDOMWrap
$LN205@xmlDOMWrap:

; 9159 : 			}
; 9160 : 		    }
; 9161 : 		}
; 9162 : 		/*
; 9163 : 		* No matching namespace in scope. We need a new one.
; 9164 : 		*/
; 9165 : 		if ((ctxt) && (ctxt->getNsForNodeFunc)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN51@xmlDOMWrap
	mov	ecx, DWORD PTR [edx+12]
	test	ecx, ecx
	je	SHORT $LN51@xmlDOMWrap

; 9166 : 		    /*
; 9167 : 		    * User-defined behaviour.
; 9168 : 		    */
; 9169 : 		    ns = ctxt->getNsForNodeFunc(ctxt, cur,

	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	ebx
	push	edx
	call	ecx
	mov	esi, eax

; 9170 : 			cur->ns->href, cur->ns->prefix);
; 9171 : 		    /*
; 9172 : 		    * Insert mapping if ns is available; it's the users fault
; 9173 : 		    * if not.
; 9174 : 		    */
; 9175 : 		    if (xmlDOMWrapNsMapAddItem(&nsMap, -1,
; 9176 : 			    cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)

	lea	eax, DWORD PTR _nsMap$[ebp]
	push	-4					; fffffffcH
	push	esi
	push	DWORD PTR [ebx+36]
	mov	DWORD PTR _ns$[ebp], esi
	push	-1
	push	eax
	call	_xmlDOMWrapNsMapAddItem
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN218@xmlDOMWrap

; 9177 : 			goto internal_error;
; 9178 : 		    cur->ns = ns;

	mov	DWORD PTR [ebx+36], esi

; 9179 : 		} else {

	mov	esi, DWORD PTR _nsMap$[ebp]
	jmp	SHORT $ns_end$263
$LN128@xmlDOMWrap:

; 9155 : 			    (cur->ns == mi->oldNs)) {
; 9156 : 
; 9157 : 			    cur->ns = mi->newNs;

	mov	eax, DWORD PTR [ecx+12]

; 9158 : 			    goto ns_end;

	jmp	SHORT $LN255@xmlDOMWrap
$LN51@xmlDOMWrap:

; 9180 : 		    /*
; 9181 : 		    * Aquire a normalized ns-decl and add it to the map.
; 9182 : 		    */
; 9183 : 		    if (xmlDOMWrapNSNormAquireNormalizedNs(destDoc,
; 9184 : 			/* ns-decls on curElem or on destDoc->oldNs */
; 9185 : 			destParent ? curElem : NULL,
; 9186 : 			cur->ns, &ns,
; 9187 : 			&nsMap, depth,
; 9188 : 			ancestorsOnly,
; 9189 : 			/* ns-decls must be prefixed for attributes. */
; 9190 : 			(cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)

	xor	eax, eax
	cmp	DWORD PTR [ebx+4], 2
	sete	al
	push	eax
	push	0
	push	DWORD PTR _depth$1$[ebp]
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	lea	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	DWORD PTR [ebx+36]
	xor	eax, eax
	test	edi, edi
	cmovne	eax, DWORD PTR _curElem$1$[ebp]
	push	eax
	push	DWORD PTR _destDoc$[ebp]
	call	_xmlDOMWrapNSNormAquireNormalizedNs
	add	esp, 32					; 00000020H
	cmp	eax, -1
	je	$LN218@xmlDOMWrap

; 9191 : 			goto internal_error;
; 9192 : 		    cur->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	esi, DWORD PTR _nsMap$[ebp]
$LN255@xmlDOMWrap:

; 9193 : 		}
; 9194 : ns_end:
; 9195 : 		/*
; 9196 : 		* Further node properties.
; 9197 : 		* TODO: Is this all?
; 9198 : 		*/
; 9199 : 		XML_TREE_ADOPT_STR(cur->name)

	mov	DWORD PTR [ebx+36], eax
$ns_end$263:
	cmp	DWORD PTR _adoptStr$1$[ebp], 0
	je	SHORT $LN244@xmlDOMWrap
	mov	edi, DWORD PTR [ebx+8]
	test	edi, edi
	je	SHORT $LN244@xmlDOMWrap
	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN56@xmlDOMWrap
	push	-1
	push	edi
	push	eax
	call	_xmlDictLookup
	mov	DWORD PTR [ebx+8], eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	SHORT $LN59@xmlDOMWrap
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN59@xmlDOMWrap
	push	edi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN244@xmlDOMWrap
$LN59@xmlDOMWrap:
	push	edi
	call	DWORD PTR _xmlFree
	jmp	SHORT $LN257@xmlDOMWrap
$LN56@xmlDOMWrap:
	mov	eax, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	SHORT $LN60@xmlDOMWrap
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN244@xmlDOMWrap
	push	edi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN244@xmlDOMWrap
	push	DWORD PTR [ebx+8]
	call	_xmlStrdup
	mov	DWORD PTR [ebx+8], eax
$LN257@xmlDOMWrap:

; 9200 : 		if (cur->type == XML_ELEMENT_NODE) {

	add	esp, 4
$LN244@xmlDOMWrap:
	mov	eax, DWORD PTR _sourceDoc$[ebp]
$LN60@xmlDOMWrap:
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN61@xmlDOMWrap

; 9201 : 		    cur->psvi = NULL;
; 9202 : 		    cur->line = 0;

	xor	eax, eax
	mov	DWORD PTR [ebx+52], 0
	mov	DWORD PTR [ebx+56], eax

; 9203 : 		    cur->extra = 0;
; 9204 : 		    /*
; 9205 : 		    * Walk attributes.
; 9206 : 		    */
; 9207 : 		    if (cur->properties != NULL) {

	mov	eax, DWORD PTR [ebx+44]
	test	eax, eax
	je	$LN239@xmlDOMWrap
$LN130@xmlDOMWrap:

; 9049 : 	goto internal_error;
; 9050 : 
; 9051 :     while (cur != NULL) {

	mov	ebx, eax
	test	ebx, ebx
	je	$LN247@xmlDOMWrap
	mov	edx, DWORD PTR _depth$1$[ebp]
	mov	edi, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _sourceDoc$[ebp]
	jmp	$LL2@xmlDOMWrap
$LN61@xmlDOMWrap:

; 9208 : 			/*
; 9209 : 			* Process first attribute node.
; 9210 : 			*/
; 9211 : 			cur = (xmlNodePtr) cur->properties;
; 9212 : 			continue;
; 9213 : 		    }
; 9214 : 		} else {
; 9215 : 		    /*
; 9216 : 		    * Attributes.
; 9217 : 		    */
; 9218 : 		    if ((sourceDoc != NULL) &&

	test	eax, eax
	je	SHORT $LN64@xmlDOMWrap
	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN64@xmlDOMWrap

; 9219 : 			(((xmlAttrPtr) cur)->atype == XML_ATTRIBUTE_ID))
; 9220 : 		    {
; 9221 : 			xmlRemoveID(sourceDoc, (xmlAttrPtr) cur);

	push	ebx
	push	eax
	call	_xmlRemoveID
	add	esp, 8
$LN64@xmlDOMWrap:

; 9222 : 		    }
; 9223 : 		    ((xmlAttrPtr) cur)->atype = 0;

	mov	DWORD PTR [ebx+40], 0

; 9224 : 		    ((xmlAttrPtr) cur)->psvi = NULL;

	mov	DWORD PTR [ebx+44], 0

; 9225 : 		}
; 9226 : 		break;

	jmp	$LN239@xmlDOMWrap
$LN65@xmlDOMWrap:

; 9227 : 	    case XML_TEXT_NODE:
; 9228 : 	    case XML_CDATA_SECTION_NODE:
; 9229 : 		/*
; 9230 : 		* This puts the content in the dest dict, only if
; 9231 : 		* it was previously in the source dict.
; 9232 : 		*/
; 9233 : 		XML_TREE_ADOPT_STR_2(cur->content)

	cmp	DWORD PTR _adoptStr$1$[ebp], 0
	je	$leave_node$262
	mov	ecx, DWORD PTR [ebx+40]
	test	ecx, ecx
	je	$leave_node$262
	mov	eax, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	$leave_node$262
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	$leave_node$262
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	$LN233@xmlDOMWrap
	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN67@xmlDOMWrap
	push	-1
	push	ecx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+40], eax
	jmp	$LN233@xmlDOMWrap
$LN67@xmlDOMWrap:
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+40], eax

; 9234 : 		goto leave_node;

	jmp	$LN233@xmlDOMWrap
$LN69@xmlDOMWrap:

; 9235 : 	    case XML_ENTITY_REF_NODE:
; 9236 : 		/*
; 9237 : 		* Remove reference to the entitity-node.
; 9238 : 		*/
; 9239 : 		cur->content = NULL;
; 9240 : 		cur->children = NULL;
; 9241 : 		cur->last = NULL;
; 9242 : 		if ((destDoc->intSubset) || (destDoc->extSubset)) {

	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	DWORD PTR [ebx+40], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN71@xmlDOMWrap
	cmp	DWORD PTR [eax+48], 0
	je	$leave_node$262
$LN71@xmlDOMWrap:

; 9243 : 		    xmlEntityPtr ent;
; 9244 : 		    /*
; 9245 : 		    * Assign new entity-node if available.
; 9246 : 		    */
; 9247 : 		    ent = xmlGetDocEntity(destDoc, cur->name);

	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDocEntity
	mov	ecx, eax
	add	esp, 8

; 9248 : 		    if (ent != NULL) {

	test	ecx, ecx
	je	$LN233@xmlDOMWrap

; 9249 : 			cur->content = ent->content;

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [ebx+40], eax

; 9250 : 			cur->children = (xmlNodePtr) ent;

	mov	DWORD PTR [ebx+12], ecx

; 9251 : 			cur->last = (xmlNodePtr) ent;

	mov	DWORD PTR [ebx+16], ecx

; 9252 : 		    }
; 9253 : 		}
; 9254 : 		goto leave_node;

	jmp	$LN233@xmlDOMWrap
$LN73@xmlDOMWrap:

; 9255 : 	    case XML_PI_NODE:
; 9256 : 		XML_TREE_ADOPT_STR(cur->name)

	cmp	DWORD PTR _adoptStr$1$[ebp], 0
	je	$LN82@xmlDOMWrap
	mov	edi, DWORD PTR [ebx+8]
	test	edi, edi
	je	SHORT $LN79@xmlDOMWrap
	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN75@xmlDOMWrap
	push	-1
	push	edi
	push	eax
	call	_xmlDictLookup
	mov	DWORD PTR [ebx+8], eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	SHORT $LN78@xmlDOMWrap
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN78@xmlDOMWrap
	push	edi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN79@xmlDOMWrap
$LN78@xmlDOMWrap:
	push	edi
	call	DWORD PTR _xmlFree
	jmp	SHORT $LN256@xmlDOMWrap
$LN75@xmlDOMWrap:
	test	ecx, ecx
	je	SHORT $LN79@xmlDOMWrap
	mov	eax, DWORD PTR [ecx+80]
	test	eax, eax
	je	SHORT $LN79@xmlDOMWrap
	push	edi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN79@xmlDOMWrap
	push	DWORD PTR [ebx+8]
	call	_xmlStrdup
	mov	DWORD PTR [ebx+8], eax
$LN256@xmlDOMWrap:

; 9257 : 		XML_TREE_ADOPT_STR_2(cur->content)

	add	esp, 4
$LN79@xmlDOMWrap:
	mov	ecx, DWORD PTR [ebx+40]
	test	ecx, ecx
	je	SHORT $LN239@xmlDOMWrap
	mov	eax, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	SHORT $LN239@xmlDOMWrap
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN239@xmlDOMWrap
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN239@xmlDOMWrap
	mov	eax, DWORD PTR _destDoc$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN81@xmlDOMWrap
	push	-1
	push	ecx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN258@xmlDOMWrap
$LN81@xmlDOMWrap:
	push	ecx
	call	_xmlStrdup
	add	esp, 4
$LN258@xmlDOMWrap:

; 9258 : 		break;
; 9259 : 	    case XML_COMMENT_NODE:
; 9260 : 		break;
; 9261 : 	    default:
; 9262 : 		goto internal_error;
; 9263 : 	}
; 9264 : 	/*
; 9265 : 	* Walk the tree.
; 9266 : 	*/
; 9267 : 	if (cur->children != NULL) {

	mov	DWORD PTR [ebx+40], eax
$LN239@xmlDOMWrap:
	mov	edi, DWORD PTR _node$[ebp]
$LN82@xmlDOMWrap:
	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	jne	$LN130@xmlDOMWrap
$LN233@xmlDOMWrap:

; 9268 : 	    cur = cur->children;
; 9269 : 	    continue;
; 9270 : 	}
; 9271 : 
; 9272 : leave_node:
; 9273 : 	if (cur == node)

	mov	edx, DWORD PTR _depth$1$[ebp]
$leave_node$262:
	cmp	ebx, edi
	je	$LN247@xmlDOMWrap

; 9274 : 	    break;
; 9275 : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 9276 : 	    (cur->type == XML_XINCLUDE_START) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	je	SHORT $LN88@xmlDOMWrap
	cmp	eax, 19					; 00000013H
	je	SHORT $LN88@xmlDOMWrap
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN87@xmlDOMWrap
$LN88@xmlDOMWrap:

; 9277 : 	    (cur->type == XML_XINCLUDE_END))
; 9278 : 	{
; 9279 : 	    /*
; 9280 : 	    * TODO: Do we expect nsDefs on XML_XINCLUDE_START?
; 9281 : 	    */
; 9282 : 	    if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN21@xmlDOMWrap
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN21@xmlDOMWrap

; 9283 : 		/*
; 9284 : 		* Pop mappings.
; 9285 : 		*/
; 9286 : 		while ((nsMap->last != NULL) &&

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN230@xmlDOMWrap
	npad	6
$LL18@xmlDOMWrap:
	cmp	DWORD PTR [ecx+20], edx
	jl	SHORT $LN230@xmlDOMWrap

; 9287 : 		    (nsMap->last->depth >= depth))
; 9288 : 		{
; 9289 : 		    XML_NSMAP_POP(nsMap, mi)

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN90@xmlDOMWrap
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN91@xmlDOMWrap
$LN90@xmlDOMWrap:
	mov	DWORD PTR [eax], 0
$LN91@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LL18@xmlDOMWrap
$LN230@xmlDOMWrap:

; 9290 : 		}
; 9291 : 		/*
; 9292 : 		* Unshadow.
; 9293 : 		*/
; 9294 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN21@xmlDOMWrap
	npad	2
$LL22@xmlDOMWrap:

; 9295 : 		    if (mi->shadowDepth >= depth)

	cmp	DWORD PTR [eax+16], edx
	jl	SHORT $LN20@xmlDOMWrap

; 9296 : 			mi->shadowDepth = -1;

	mov	DWORD PTR [eax+16], -1
$LN20@xmlDOMWrap:

; 9290 : 		}
; 9291 : 		/*
; 9292 : 		* Unshadow.
; 9293 : 		*/
; 9294 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL22@xmlDOMWrap
$LN21@xmlDOMWrap:

; 9297 : 		}
; 9298 : 	    }
; 9299 : 	    depth--;

	dec	edx
	mov	DWORD PTR _depth$1$[ebp], edx
$LN87@xmlDOMWrap:

; 9300 : 	}
; 9301 : 	if (cur->next != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	jne	$LN130@xmlDOMWrap

; 9302 : 	    cur = cur->next;
; 9303 : 	else if ((cur->type == XML_ATTRIBUTE_NODE) &&

	cmp	DWORD PTR [ebx+4], 2
	jne	SHORT $LN194@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	$LN130@xmlDOMWrap
$LN194@xmlDOMWrap:

; 9304 : 	    (cur->parent->children != NULL))
; 9305 : 	{
; 9306 : 	    cur = cur->parent->children;
; 9307 : 	} else {
; 9308 : 	    cur = cur->parent;

	mov	ebx, DWORD PTR [ebx+20]

; 9309 : 	    goto leave_node;

	jmp	$leave_node$262
$LN218@xmlDOMWrap:

; 9097 : 			/*
; 9098 : 			* Gather @parent's in-scope ns-decls.
; 9099 : 			*/
; 9100 : 			if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 9101 : 			    destParent) == -1)

	mov	esi, DWORD PTR _nsMap$[ebp]
$internal_error$261:

; 9310 : 	}
; 9311 :     }
; 9312 : 
; 9313 :     goto exit;
; 9314 : 
; 9315 : internal_error:
; 9316 :     ret = -1;

	or	ebx, -1
	jmp	SHORT $exit$264
$LN35@xmlDOMWrap:
	pop	edi

; 9337 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN247@xmlDOMWrap:

; 9317 : 
; 9318 : exit:
; 9319 :     /*
; 9320 :     * Cleanup.
; 9321 :     */
; 9322 :     if (nsMap != NULL) {

	xor	ebx, ebx
$exit$264:
	test	esi, esi
	je	SHORT $LN105@xmlDOMWrap

; 9323 : 	if ((ctxt) && (ctxt->namespaceMap == nsMap)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN98@xmlDOMWrap
	cmp	DWORD PTR [eax+8], esi
	jne	SHORT $LN98@xmlDOMWrap

; 9324 : 	    /*
; 9325 : 	    * Just cleanup the map but don't free.
; 9326 : 	    */
; 9327 : 	    if (nsMap->first) {

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN105@xmlDOMWrap

; 9328 : 		if (nsMap->pool)

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN101@xmlDOMWrap

; 9329 : 		    nsMap->last->next = nsMap->pool;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
$LN101@xmlDOMWrap:

; 9330 : 		nsMap->pool = nsMap->first;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax

; 9331 : 		nsMap->first = NULL;
; 9332 : 	    }
; 9333 : 	} else
; 9334 : 	    xmlDOMWrapNsMapFree(nsMap);
; 9335 :     }
; 9336 :     return(ret);

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [esi], 0

; 9337 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@xmlDOMWrap:

; 7857 :     cur = nsmap->pool;

	mov	edi, DWORD PTR [esi+8]

; 7858 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN107@xmlDOMWrap
	npad	3
$LL106@xmlDOMWrap:

; 7859 : 	tmp = cur;
; 7860 : 	cur = cur->next;
; 7861 : 	xmlFree(tmp);

	push	edi
	mov	edi, DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	edi, edi
	jne	SHORT $LL106@xmlDOMWrap
$LN107@xmlDOMWrap:

; 7862 :     }
; 7863 :     cur = nsmap->first;

	mov	edi, DWORD PTR [esi]

; 7864 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN109@xmlDOMWrap
$LL108@xmlDOMWrap:

; 7865 : 	tmp = cur;
; 7866 : 	cur = cur->next;
; 7867 : 	xmlFree(tmp);

	push	edi
	mov	edi, DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	edi, edi
	jne	SHORT $LL108@xmlDOMWrap
$LN109@xmlDOMWrap:

; 7868 :     }
; 7869 :     xmlFree(nsmap);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN105@xmlDOMWrap:
	pop	edi

; 9337 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN260@xmlDOMWrap:
	DD	$LN36@xmlDOMWrap
	DD	$LN10@xmlDOMWrap
	DD	$LN65@xmlDOMWrap
	DD	$LN69@xmlDOMWrap
	DD	$LN73@xmlDOMWrap
	DD	$LN82@xmlDOMWrap
	DD	$LN35@xmlDOMWrap
	DD	$internal_error$261
$LN206@xmlDOMWrap:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	7
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
	DB	6
_xmlDOMWrapAdoptBranch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNSNormAquireNormalizedNs
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_elem$ = 12						; size = 4
_ns$ = 16						; size = 4
_retNs$ = 20						; size = 4
_nsMap$ = 24						; size = 4
_depth$ = 28						; size = 4
_ancestorsOnly$ = 32					; size = 4
_prefixed$ = 36						; size = 4
_xmlDOMWrapNSNormAquireNormalizedNs PROC		; COMDAT

; 8606 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN9@xmlDOMWrap

; 8607 :     xmlNsMapItemPtr mi;
; 8608 : 
; 8609 :     if ((doc == NULL) || (ns == NULL) || (retNs == NULL) ||

	mov	ebx, DWORD PTR _ns$[ebp]
	test	ebx, ebx
	je	$LN9@xmlDOMWrap
	mov	esi, DWORD PTR _retNs$[ebp]
	test	esi, esi
	je	$LN9@xmlDOMWrap
	mov	ecx, DWORD PTR _nsMap$[ebp]
	test	ecx, ecx
	je	$LN9@xmlDOMWrap

; 8610 : 	(nsMap == NULL))
; 8611 : 	return (-1);
; 8612 : 
; 8613 :     *retNs = NULL;

	mov	DWORD PTR [esi], 0

; 8614 :     /*
; 8615 :     * Handle XML namespace.
; 8616 :     */
; 8617 :     if (IS_STR_XML(ns->prefix)) {

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax], 120			; 00000078H
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+1], 109			; 0000006dH
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+2], 108			; 0000006cH
	jne	SHORT $LN10@xmlDOMWrap
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN10@xmlDOMWrap

; 8618 : 	/*
; 8619 : 	* Insert XML namespace mapping.
; 8620 : 	*/
; 8621 : 	*retNs = xmlTreeEnsureXMLDecl(doc);

	push	edi
	call	_xmlTreeEnsureXMLDecl
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 8622 : 	if (*retNs == NULL)

	test	eax, eax
	je	$LN9@xmlDOMWrap

; 8715 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlDOMWrap:

; 8623 : 	    return (-1);
; 8624 : 	return (0);
; 8625 :     }
; 8626 :     /*
; 8627 :     * If the search should be done in ancestors only and no
; 8628 :     * @elem (the first ancestor) was specified, then skip the search.
; 8629 :     */
; 8630 :     if ((XML_NSMAP_NOTEMPTY(*nsMap)) &&

	mov	esi, DWORD PTR [ecx]
	mov	ecx, eax
	mov	edx, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlDOMWrap
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN3@xmlDOMWrap
	mov	ecx, DWORD PTR _ancestorsOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LL13@xmlDOMWrap
	mov	ecx, eax
	test	edx, edx
	je	SHORT $LN3@xmlDOMWrap
$LN43@xmlDOMWrap:

; 8637 : 	    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&
; 8638 : 		/*
; 8639 : 		* ancestorsOnly: This should be turned on to gain speed,
; 8640 : 		* if one knows that the branch itself was already
; 8641 : 		* ns-wellformed and no stale references existed.
; 8642 : 		* I.e. it searches in the ancestor axis only.
; 8643 : 		*/
; 8644 : 		((! ancestorsOnly) || (mi->depth == XML_TREE_NSMAP_PARENT)) &&
; 8645 : 		/* Skip shadowed prefixes. */
; 8646 : 		(mi->shadowDepth == -1) &&
; 8647 : 		/* Skip xmlns="" or xmlns:foo="". */
; 8648 : 		((mi->newNs->href != NULL) &&
; 8649 : 		(mi->newNs->href[0] != 0)) &&
; 8650 : 		/* Ensure a prefix if wanted. */
; 8651 : 		((! prefixed) || (mi->newNs->prefix != NULL)) &&

	mov	ecx, DWORD PTR _ancestorsOnly$[ebp]
	npad	5
$LL13@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, -1
	jl	SHORT $LN2@xmlDOMWrap
	test	ecx, ecx
	je	SHORT $LN34@xmlDOMWrap
	cmp	eax, -1
	jne	SHORT $LN2@xmlDOMWrap
$LN34@xmlDOMWrap:
	cmp	DWORD PTR [esi+16], -1
	jne	SHORT $LN2@xmlDOMWrap
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@xmlDOMWrap
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN2@xmlDOMWrap
	cmp	DWORD PTR _prefixed$[ebp], 0
	je	SHORT $LN16@xmlDOMWrap
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN2@xmlDOMWrap
$LN16@xmlDOMWrap:
	mov	ecx, DWORD PTR [ebx+8]
	cmp	eax, ecx
	je	SHORT $LN38@xmlDOMWrap
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@xmlDOMWrap
$LN2@xmlDOMWrap:

; 8631 : 	(! (ancestorsOnly && (elem == NULL))))
; 8632 :     {
; 8633 : 	/*
; 8634 : 	* Try to find an equal ns-name in in-scope ns-decls.
; 8635 : 	*/
; 8636 : 	XML_NSMAP_FOREACH(*nsMap, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LN43@xmlDOMWrap

; 8696 : 		if ((mi->depth < depth) &&
; 8697 : 		    (mi->shadowDepth == -1) &&

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR _elem$[ebp]
$LN3@xmlDOMWrap:

; 8658 : 		return (0);
; 8659 : 	    }
; 8660 : 	}
; 8661 :     }
; 8662 :     /*
; 8663 :     * No luck, the namespace is out of scope or shadowed.
; 8664 :     */
; 8665 :     if (elem == NULL) {

	mov	eax, DWORD PTR [ebx+8]
	test	edx, edx
	jne	SHORT $LN18@xmlDOMWrap

; 8666 : 	xmlNsPtr tmpns;
; 8667 : 
; 8668 : 	/*
; 8669 : 	* Store ns-decls in "oldNs" of the document-node.
; 8670 : 	*/
; 8671 : 	tmpns = xmlDOMWrapStoreNs(doc, ns->href, ns->prefix);

	push	ecx
	push	eax
	push	edi
	call	_xmlDOMWrapStoreNs
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 8672 : 	if (tmpns == NULL)

	test	edi, edi
	je	SHORT $LN9@xmlDOMWrap

; 8673 : 	    return (-1);
; 8674 : 	/*
; 8675 : 	* Insert mapping.
; 8676 : 	*/
; 8677 : 	if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns,
; 8678 : 		tmpns, XML_TREE_NSMAP_DOC) == NULL) {

	push	-3					; fffffffdH
	push	edi
	push	ebx
$LN44@xmlDOMWrap:

; 8715 : }

	push	-1
	push	DWORD PTR _nsMap$[ebp]
	call	_xmlDOMWrapNsMapAddItem
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN26@xmlDOMWrap
	push	edi
	call	_xmlFreeNs
	add	esp, 4
$LN9@xmlDOMWrap:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN38@xmlDOMWrap:

; 8652 : 		/* Equal ns name */
; 8653 : 		((mi->newNs->href == ns->href) ||
; 8654 : 		xmlStrEqual(mi->newNs->href, ns->href))) {
; 8655 : 		/* Set the mapping. */
; 8656 : 		mi->oldNs = ns;
; 8657 : 		*retNs = mi->newNs;

	mov	ecx, DWORD PTR _retNs$[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ebx
	pop	edi

; 8715 : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlDOMWrap:

; 8679 : 	    xmlFreeNs(tmpns);
; 8680 : 	    return (-1);
; 8681 : 	}
; 8682 : 	*retNs = tmpns;
; 8683 :     } else {
; 8684 : 	xmlNsPtr tmpns;
; 8685 : 
; 8686 : 	tmpns = xmlDOMWrapNSNormDeclareNsForced(doc, elem, ns->href,

	push	0
	push	ecx
	push	eax
	push	edx
	push	edi
	call	_xmlDOMWrapNSNormDeclareNsForced
	mov	edi, eax
	add	esp, 20					; 00000014H

; 8687 : 	    ns->prefix, 0);
; 8688 : 	if (tmpns == NULL)

	test	edi, edi
	je	SHORT $LN9@xmlDOMWrap

; 8689 : 	    return (-1);
; 8690 : 
; 8691 : 	if (*nsMap != NULL) {

	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	ebx, DWORD PTR _depth$[ebp]
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN40@xmlDOMWrap

; 8692 : 	    /*
; 8693 : 	    * Does it shadow ancestor ns-decls?
; 8694 : 	    */
; 8695 : 	    XML_NSMAP_FOREACH(*nsMap, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN40@xmlDOMWrap
	npad	3
$LL7@xmlDOMWrap:

; 8696 : 		if ((mi->depth < depth) &&
; 8697 : 		    (mi->shadowDepth == -1) &&

	cmp	DWORD PTR [esi+20], ebx
	jge	SHORT $LN5@xmlDOMWrap
	cmp	DWORD PTR [esi+16], -1
	jne	SHORT $LN5@xmlDOMWrap
	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN25@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlDOMWrap
$LN5@xmlDOMWrap:

; 8692 : 	    /*
; 8693 : 	    * Does it shadow ancestor ns-decls?
; 8694 : 	    */
; 8695 : 	    XML_NSMAP_FOREACH(*nsMap, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL7@xmlDOMWrap

; 8704 : 		    break;
; 8705 : 		}
; 8706 : 	    }
; 8707 : 	}
; 8708 : 	if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {

	push	ebx
	push	edi
	push	DWORD PTR _ns$[ebp]

; 8709 : 	    xmlFreeNs(tmpns);
; 8710 : 	    return (-1);

	jmp	$LN44@xmlDOMWrap
$LN25@xmlDOMWrap:

; 8698 : 		    ((ns->prefix == mi->newNs->prefix) ||
; 8699 : 		    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {
; 8700 : 		    /*
; 8701 : 		    * Shadows.
; 8702 : 		    */
; 8703 : 		    mi->shadowDepth = depth;

	mov	DWORD PTR [esi+16], ebx
$LN40@xmlDOMWrap:

; 8704 : 		    break;
; 8705 : 		}
; 8706 : 	    }
; 8707 : 	}
; 8708 : 	if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {

	push	ebx
	push	edi
	push	DWORD PTR _ns$[ebp]

; 8709 : 	    xmlFreeNs(tmpns);
; 8710 : 	    return (-1);

	jmp	$LN44@xmlDOMWrap
$LN26@xmlDOMWrap:

; 8711 : 	}
; 8712 : 	*retNs = tmpns;
; 8713 :     }
; 8714 :     return (0);

	mov	ecx, DWORD PTR _retNs$[ebp]
	xor	eax, eax
	mov	DWORD PTR [ecx], edi
	pop	edi

; 8715 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlDOMWrapNSNormAquireNormalizedNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNSNormDeclareNsForced
_TEXT	SEGMENT
_buf$ = -56						; size = 50
_counter$1$ = -4					; size = 4
_doc$ = 8						; size = 4
_elem$ = 12						; size = 4
_nsName$ = 16						; size = 4
_prefix$ = 20						; size = 4
_checkShadow$ = 24					; size = 4
_xmlDOMWrapNSNormDeclareNsForced PROC			; COMDAT

; 8523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _doc$[ebp], 0
	mov	DWORD PTR _counter$1$[ebp], 0
	je	$LN7@xmlDOMWrap

; 8524 : 
; 8525 :     xmlNsPtr ret;
; 8526 :     char buf[50];
; 8527 :     const xmlChar *pref;
; 8528 :     int counter = 0;
; 8529 : 
; 8530 :     if ((doc == NULL) || (elem == NULL) || (elem->type != XML_ELEMENT_NODE))

	mov	ebx, DWORD PTR _elem$[ebp]
	test	ebx, ebx
	je	$LN7@xmlDOMWrap
	cmp	DWORD PTR [ebx+4], 1
	jne	$LN7@xmlDOMWrap

; 8531 :         return(NULL);
; 8532 :     /*
; 8533 :     * Create a ns-decl on @anchor.
; 8534 :     */
; 8535 :     pref = prefix;

	mov	edi, DWORD PTR _prefix$[ebp]
	npad	4
$LL2@xmlDOMWrap:

; 8536 :     while (1) {
; 8537 : 	/*
; 8538 : 	* Lookup whether the prefix is unused in elem's ns-decls.
; 8539 : 	*/
; 8540 : 	if ((elem->nsDef != NULL) &&

	mov	esi, DWORD PTR [ebx+48]
	test	esi, esi
	je	SHORT $LN8@xmlDOMWrap
	npad	9
$LL21@xmlDOMWrap:

; 8060 : 	    if ((prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	cmp	edi, eax
	je	$ns_next_prefix$89
	push	eax
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$ns_next_prefix$89

; 8061 : 		xmlStrEqual(prefix, ns->prefix)) {
; 8062 : 		return (ns);
; 8063 : 	    }
; 8064 : 	    ns = ns->next;

	mov	esi, DWORD PTR [esi]

; 8065 : 	} while (ns != NULL);

	test	esi, esi
	jne	SHORT $LL21@xmlDOMWrap
$LN8@xmlDOMWrap:

; 8541 : 	    (xmlTreeNSListLookupByPrefix(elem->nsDef, pref) != NULL))
; 8542 : 	    goto ns_next_prefix;
; 8543 : 	if (checkShadow && elem->parent &&

	cmp	DWORD PTR _checkShadow$[ebp], 0
	je	SHORT $LN10@xmlDOMWrap
	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	je	SHORT $LN83@xmlDOMWrap
	cmp	DWORD PTR [ebx+32], ebx
	je	SHORT $LN83@xmlDOMWrap

; 8460 :     if ((doc == NULL) || (node == NULL) || (node->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	SHORT $LN83@xmlDOMWrap

; 8461 :         return(-1);
; 8462 : 
; 8463 :     if (retNs)
; 8464 : 	*retNs = NULL;
; 8465 :     if (IS_STR_XML(prefix)) {

	test	edi, edi
	je	SHORT $LL29@xmlDOMWrap
	cmp	BYTE PTR [edi], 120			; 00000078H
	jne	SHORT $LL29@xmlDOMWrap
	cmp	BYTE PTR [edi+1], 109			; 0000006dH
	jne	SHORT $LL29@xmlDOMWrap
	cmp	BYTE PTR [edi+2], 108			; 0000006cH
	jne	SHORT $LL29@xmlDOMWrap
	cmp	BYTE PTR [edi+3], 0
	je	SHORT $LN84@xmlDOMWrap
$LL29@xmlDOMWrap:

; 8466 : 	if (retNs) {
; 8467 : 	    *retNs = xmlTreeEnsureXMLDecl(doc);
; 8468 : 	    if (*retNs == NULL)
; 8469 : 		return (-1);
; 8470 : 	}
; 8471 : 	return (1);
; 8472 :     }
; 8473 :     cur = node;
; 8474 :     do {
; 8475 : 	if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	jne	SHORT $LN39@xmlDOMWrap

; 8476 : 	    if (cur->nsDef != NULL) {

	mov	esi, DWORD PTR [ebx+48]
	test	esi, esi
	je	SHORT $LN46@xmlDOMWrap
$LL32@xmlDOMWrap:

; 8477 : 		ns = cur->nsDef;
; 8478 : 		do {
; 8479 : 		    if ((prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	cmp	edi, eax
	je	SHORT $LN57@xmlDOMWrap
	push	eax
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@xmlDOMWrap

; 8486 : 			    return(0);
; 8487 : 			if (retNs)
; 8488 : 			    *retNs = ns;
; 8489 : 			return (1);
; 8490 : 		    }
; 8491 : 		    ns = ns->next;

	mov	esi, DWORD PTR [esi]

; 8492 : 		} while (ns != NULL);

	test	esi, esi
	jne	SHORT $LL32@xmlDOMWrap

; 8493 : 	    }
; 8494 : 	} else if ((cur->type == XML_ENTITY_NODE) ||

	jmp	SHORT $LN46@xmlDOMWrap
$LN39@xmlDOMWrap:
	cmp	eax, 6
	je	SHORT $LN83@xmlDOMWrap
	cmp	eax, 17					; 00000011H
	je	SHORT $LN83@xmlDOMWrap
$LN46@xmlDOMWrap:

; 8495 :             (cur->type == XML_ENTITY_DECL))
; 8496 : 	    return (0);
; 8497 : 	cur = cur->parent;

	mov	ebx, DWORD PTR [ebx+20]

; 8498 :     } while ((cur != NULL) && (cur->doc != (xmlDocPtr) cur));

	test	ebx, ebx
	je	SHORT $LN83@xmlDOMWrap
	cmp	DWORD PTR [ebx+32], ebx
	jne	SHORT $LL29@xmlDOMWrap
$LN83@xmlDOMWrap:

; 8544 : 	    ((xmlNodePtr) elem->parent->doc != elem->parent)) {
; 8545 : 	    /*
; 8546 : 	    * Does it shadow ancestor ns-decls?
; 8547 : 	    */
; 8548 : 	    if (xmlSearchNsByPrefixStrict(doc, elem->parent, pref, NULL) == 1)
; 8549 : 		goto ns_next_prefix;
; 8550 : 	}
; 8551 : 	ret = xmlNewNs(NULL, nsName, pref);

	mov	ebx, DWORD PTR _elem$[ebp]
$LN10@xmlDOMWrap:
	push	edi
	push	DWORD PTR _nsName$[ebp]
	push	0
	call	_xmlNewNs
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 8552 : 	if (ret == NULL)

	test	esi, esi
	je	$LN7@xmlDOMWrap

; 8553 : 	    return (NULL);
; 8554 : 	if (elem->nsDef == NULL)

	mov	edx, DWORD PTR [ebx+48]
	test	edx, edx
	jne	SHORT $LN12@xmlDOMWrap

; 8555 : 	    elem->nsDef = ret;

	pop	edi
	mov	DWORD PTR [ebx+48], esi

; 8574 :     }
; 8575 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlDOMWrap:

; 8485 : 			if (ns->href == NULL)

	cmp	DWORD PTR [esi+8], 0
	mov	ebx, DWORD PTR _elem$[ebp]
	je	SHORT $LN10@xmlDOMWrap

; 8461 :         return(-1);
; 8462 : 
; 8463 :     if (retNs)
; 8464 : 	*retNs = NULL;
; 8465 :     if (IS_STR_XML(prefix)) {

	jmp	SHORT $ns_next_prefix$89
$LN84@xmlDOMWrap:
	mov	ebx, DWORD PTR _elem$[ebp]
$ns_next_prefix$89:

; 8563 : ns_next_prefix:
; 8564 : 	counter++;

	mov	eax, DWORD PTR _counter$1$[ebp]
	inc	eax
	mov	DWORD PTR _counter$1$[ebp], eax

; 8565 : 	if (counter > 1000)

	cmp	eax, 1000				; 000003e8H
	jg	SHORT $LN7@xmlDOMWrap

; 8566 : 	    return (NULL);
; 8567 : 	if (prefix == NULL) {

	mov	ecx, DWORD PTR _prefix$[ebp]
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@xmlDOMWrap

; 8568 : 	    snprintf((char *) buf, sizeof(buf),

	push	OFFSET ??_C@_05GOMIJPDF@ns_?$CFd@
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 8572 : 	    "%.30s_%d", (char *)prefix, counter);
; 8573 : 	pref = BAD_CAST buf;

	lea	edi, DWORD PTR _buf$[ebp]
	jmp	$LL2@xmlDOMWrap
$LN15@xmlDOMWrap:

; 8569 : 		"ns_%d", counter);
; 8570 : 	} else
; 8571 : 	    snprintf((char *) buf, sizeof(buf),

	push	ecx
	push	OFFSET ??_C@_08LCJGELPI@?$CF?430s_?$CFd@
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 8572 : 	    "%.30s_%d", (char *)prefix, counter);
; 8573 : 	pref = BAD_CAST buf;

	lea	edi, DWORD PTR _buf$[ebp]
	jmp	$LL2@xmlDOMWrap
$LN12@xmlDOMWrap:

; 8556 : 	else {
; 8557 : 	    xmlNsPtr ns2 = elem->nsDef;
; 8558 : 	    while (ns2->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN5@xmlDOMWrap
$LL4@xmlDOMWrap:
	mov	eax, DWORD PTR [ecx]

; 8559 : 		ns2 = ns2->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL4@xmlDOMWrap
$LN5@xmlDOMWrap:
	pop	edi

; 8560 : 	    ns2->next = ret;

	mov	DWORD PTR [edx], esi

; 8561 : 	}
; 8562 : 	return (ret);

	mov	eax, esi

; 8574 :     }
; 8575 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlDOMWrap:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDOMWrapNSNormDeclareNsForced ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSearchNsByPrefixStrict
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_node$ = 12						; size = 4
_prefix$ = 16						; size = 4
_retNs$ = 20						; size = 4
_xmlSearchNsByPrefixStrict PROC				; COMDAT

; 8456 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlSearchN

; 8457 :     xmlNodePtr cur;
; 8458 :     xmlNsPtr ns;
; 8459 : 
; 8460 :     if ((doc == NULL) || (node == NULL) || (node->type == XML_NAMESPACE_DECL))

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlSearchN
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN9@xmlSearchN

; 8461 :         return(-1);
; 8462 : 
; 8463 :     if (retNs)

	mov	ecx, DWORD PTR _retNs$[ebp]
	test	ecx, ecx
	je	SHORT $LN32@xmlSearchN

; 8464 : 	*retNs = NULL;

	mov	DWORD PTR [ecx], 0
$LN32@xmlSearchN:

; 8465 :     if (IS_STR_XML(prefix)) {

	mov	ebx, DWORD PTR _prefix$[ebp]
	test	ebx, ebx
	je	SHORT $LL4@xmlSearchN
	cmp	BYTE PTR [ebx], 120			; 00000078H
	jne	SHORT $LL4@xmlSearchN
	cmp	BYTE PTR [ebx+1], 109			; 0000006dH
	jne	SHORT $LL4@xmlSearchN
	cmp	BYTE PTR [ebx+2], 108			; 0000006cH
	jne	SHORT $LL4@xmlSearchN
	cmp	BYTE PTR [ebx+3], 0
	jne	SHORT $LL4@xmlSearchN

; 8466 : 	if (retNs) {

	test	ecx, ecx
	je	SHORT $LN20@xmlSearchN

; 8467 : 	    *retNs = xmlTreeEnsureXMLDecl(doc);

	push	eax
	call	_xmlTreeEnsureXMLDecl
	mov	ecx, DWORD PTR _retNs$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 8468 : 	    if (*retNs == NULL)

	test	eax, eax
	jne	SHORT $LN20@xmlSearchN
$LN9@xmlSearchN:
	pop	edi

; 8499 :     return (0);
; 8500 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LL4@xmlSearchN:

; 8469 : 		return (-1);
; 8470 : 	}
; 8471 : 	return (1);
; 8472 :     }
; 8473 :     cur = node;
; 8474 :     do {
; 8475 : 	if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	jne	SHORT $LN14@xmlSearchN

; 8476 : 	    if (cur->nsDef != NULL) {

	mov	esi, DWORD PTR [edi+48]
	test	esi, esi
	je	SHORT $LN21@xmlSearchN
	npad	1
$LL7@xmlSearchN:

; 8477 : 		ns = cur->nsDef;
; 8478 : 		do {
; 8479 : 		    if ((prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	cmp	ebx, eax
	je	SHORT $LN27@xmlSearchN
	push	eax
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlSearchN

; 8489 : 			return (1);
; 8490 : 		    }
; 8491 : 		    ns = ns->next;

	mov	esi, DWORD PTR [esi]

; 8492 : 		} while (ns != NULL);

	test	esi, esi
	jne	SHORT $LL7@xmlSearchN

; 8493 : 	    }

	jmp	SHORT $LN21@xmlSearchN
$LN14@xmlSearchN:

; 8494 : 	} else if ((cur->type == XML_ENTITY_NODE) ||

	cmp	eax, 6
	je	SHORT $LN22@xmlSearchN
	cmp	eax, 17					; 00000011H
	je	SHORT $LN22@xmlSearchN
$LN21@xmlSearchN:

; 8495 :             (cur->type == XML_ENTITY_DECL))
; 8496 : 	    return (0);
; 8497 : 	cur = cur->parent;

	mov	edi, DWORD PTR [edi+20]

; 8498 :     } while ((cur != NULL) && (cur->doc != (xmlDocPtr) cur));

	test	edi, edi
	je	SHORT $LN22@xmlSearchN
	cmp	DWORD PTR [edi+32], edi
	jne	SHORT $LL4@xmlSearchN
$LN22@xmlSearchN:
	pop	edi

; 8499 :     return (0);
; 8500 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN27@xmlSearchN:

; 8480 : 			xmlStrEqual(prefix, ns->prefix))
; 8481 : 		    {
; 8482 : 			/*
; 8483 : 			* Disabled namespaces, e.g. xmlns:abc="".
; 8484 : 			*/
; 8485 : 			if (ns->href == NULL)

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN22@xmlSearchN

; 8486 : 			    return(0);
; 8487 : 			if (retNs)

	mov	ecx, DWORD PTR _retNs$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@xmlSearchN

; 8488 : 			    *retNs = ns;

	mov	DWORD PTR [ecx], esi
$LN20@xmlSearchN:
	pop	edi

; 8499 :     return (0);
; 8500 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlSearchNsByPrefixStrict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSearchNsByNamespaceStrict
_TEXT	SEGMENT
_cur$1$ = -8						; size = 4
_out$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_node$ = 12						; size = 4
_nsName$ = 16						; size = 4
_retNs$ = 20						; size = 4
_prefixed$ = 24						; size = 4
_xmlSearchNsByNamespaceStrict PROC			; COMDAT

; 8354 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	ebx, ebx
	mov	DWORD PTR _out$1$[ebp], ebx
	cmp	DWORD PTR _doc$[ebp], ebx
	je	$LN12@xmlSearchN

; 8355 :     xmlNodePtr cur, prev = NULL, out = NULL;
; 8356 :     xmlNsPtr ns, prevns;
; 8357 : 
; 8358 :     if ((doc == NULL) || (nsName == NULL) || (retNs == NULL))

	mov	esi, DWORD PTR _nsName$[ebp]
	test	esi, esi
	je	$LN12@xmlSearchN
	mov	eax, DWORD PTR _retNs$[ebp]
	test	eax, eax
	je	$LN12@xmlSearchN

; 8359 : 	return (-1);
; 8360 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$LN12@xmlSearchN
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN12@xmlSearchN

; 8361 :         return(-1);
; 8362 : 
; 8363 :     *retNs = NULL;
; 8364 :     if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	mov	DWORD PTR [eax], ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSearchN

; 8365 : 	*retNs = xmlTreeEnsureXMLDecl(doc);

	push	DWORD PTR _doc$[ebp]
	call	_xmlTreeEnsureXMLDecl
	mov	ecx, DWORD PTR _retNs$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 8366 : 	if (*retNs == NULL)

	test	eax, eax
	je	$LN12@xmlSearchN

; 8436 :     return (0);
; 8437 : }

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ebx+1]
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSearchN:

; 8367 : 	    return (-1);
; 8368 : 	return (1);
; 8369 :     }
; 8370 :     cur = node;

	mov	ecx, edi
	mov	DWORD PTR _cur$1$[ebp], edi
	npad	9
$LL4@xmlSearchN:

; 8371 :     do {
; 8372 : 	if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	$LN17@xmlSearchN

; 8373 : 	    if (cur->nsDef != NULL) {

	mov	edi, DWORD PTR [ecx+48]
	test	edi, edi
	je	$LN30@xmlSearchN
$LL7@xmlSearchN:

; 8375 : 		    if (prefixed && (ns->prefix == NULL))

	cmp	DWORD PTR _prefixed$[ebp], 0
	je	SHORT $LN50@xmlSearchN
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN5@xmlSearchN
$LN50@xmlSearchN:

; 8376 : 			continue;
; 8377 : 		    if (prev != NULL) {

	test	ebx, ebx
	je	SHORT $LN24@xmlSearchN

; 8378 : 			/*
; 8379 : 			* Check the last level of ns-decls for a
; 8380 : 			* shadowing prefix.
; 8381 : 			*/
; 8382 : 			prevns = prev->nsDef;

	mov	esi, DWORD PTR [ebx+48]
	npad	6
$LL10@xmlSearchN:

; 8383 : 			do {
; 8384 : 			    if ((prevns->prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	je	SHORT $LN52@xmlSearchN
	test	eax, eax
	je	SHORT $LN22@xmlSearchN
	test	ecx, ecx
	je	SHORT $LN22@xmlSearchN
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@xmlSearchN
$LN22@xmlSearchN:

; 8385 : 				((prevns->prefix != NULL) &&
; 8386 : 				(ns->prefix != NULL) &&
; 8387 : 				xmlStrEqual(prevns->prefix, ns->prefix))) {
; 8388 : 				/*
; 8389 : 				* Shadowed.
; 8390 : 				*/
; 8391 : 				break;
; 8392 : 			    }
; 8393 : 			    prevns = prevns->next;

	mov	esi, DWORD PTR [esi]

; 8394 : 			} while (prevns != NULL);

	test	esi, esi
	jne	SHORT $LL10@xmlSearchN
	mov	esi, DWORD PTR _nsName$[ebp]
$LN24@xmlSearchN:

; 8395 : 			if (prevns != NULL)
; 8396 : 			    continue;
; 8397 : 		    }
; 8398 : 		    /*
; 8399 : 		    * Ns-name comparison.
; 8400 : 		    */
; 8401 : 		    if ((nsName == ns->href) ||

	mov	eax, DWORD PTR [edi+8]
	cmp	esi, eax
	je	SHORT $LN26@xmlSearchN
	push	eax
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@xmlSearchN
$LN26@xmlSearchN:

; 8402 : 			xmlStrEqual(nsName, ns->href)) {
; 8403 : 			/*
; 8404 : 			* At this point the prefix can only be shadowed,
; 8405 : 			* if we are the the (at least) 3rd level of
; 8406 : 			* ns-decls.
; 8407 : 			*/
; 8408 : 			if (out) {

	cmp	DWORD PTR _out$1$[ebp], 0
	je	SHORT $LN29@xmlSearchN

; 8409 : 			    int ret;
; 8410 : 
; 8411 : 			    ret = xmlNsInScope(doc, node, prev, ns->prefix);

	push	DWORD PTR [edi+12]
	push	ebx
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNsInScope
	add	esp, 16					; 00000010H

; 8412 : 			    if (ret < 0)

	test	eax, eax
	js	SHORT $LN12@xmlSearchN

; 8413 : 				return (-1);
; 8414 : 			    /*
; 8415 : 			    * TODO: Should we try to find a matching ns-name
; 8416 : 			    * only once? This here keeps on searching.
; 8417 : 			    * I think we should try further since, there might
; 8418 : 			    * be an other matching ns-decl with an unshadowed
; 8419 : 			    * prefix.
; 8420 : 			    */
; 8421 : 			    if (! ret)

	je	SHORT $LN5@xmlSearchN
$LN29@xmlSearchN:

; 8422 : 				continue;
; 8423 : 			}
; 8424 : 			*retNs = ns;

	mov	ecx, DWORD PTR _retNs$[ebp]

; 8425 : 			return (1);

	mov	eax, 1
	mov	DWORD PTR [ecx], edi
	pop	edi

; 8436 :     return (0);
; 8437 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlSearchN:

; 8374 : 		for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	esi, DWORD PTR _nsName$[ebp]
$LN5@xmlSearchN:
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	$LL7@xmlSearchN

; 8426 : 		    }
; 8427 : 		}
; 8428 : 		out = prev;
; 8429 : 		prev = cur;

	mov	ecx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR _out$1$[ebp], ebx
	mov	ebx, ecx

; 8430 : 	    }

	jmp	SHORT $LN30@xmlSearchN
$LN17@xmlSearchN:

; 8431 : 	} else if ((cur->type == XML_ENTITY_NODE) ||

	cmp	eax, 6
	je	SHORT $LN31@xmlSearchN
	cmp	eax, 17					; 00000011H
	je	SHORT $LN31@xmlSearchN
$LN30@xmlSearchN:

; 8432 :             (cur->type == XML_ENTITY_DECL))
; 8433 : 	    return (0);
; 8434 : 	cur = cur->parent;

	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cur$1$[ebp], ecx

; 8435 :     } while ((cur != NULL) && (cur->doc != (xmlDocPtr) cur));

	test	ecx, ecx
	je	SHORT $LN31@xmlSearchN
	cmp	DWORD PTR [ecx+32], ecx
	jne	$LL4@xmlSearchN
$LN31@xmlSearchN:
	pop	edi

; 8436 :     return (0);
; 8437 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSearchN:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSearchNsByNamespaceStrict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNSNormAddNsMapItem2
_TEXT	SEGMENT
_list$ = 8						; size = 4
_size$ = 12						; size = 4
_number$ = 16						; size = 4
_oldNs$ = 20						; size = 4
_newNs$ = 24						; size = 4
_xmlDOMWrapNSNormAddNsMapItem2 PROC			; COMDAT

; 8176 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [edi]
	test	edx, edx
	jne	SHORT $LN2@xmlDOMWrap

; 8177 :     if (*list == NULL) {
; 8178 : 	*list = (xmlNsPtr *) xmlMalloc(6 * sizeof(xmlNsPtr));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 8179 : 	if (*list == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlDOMWrap

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@OAPAONED@alloc?5ns?5map?5item@
$LN12@xmlDOMWrap:

; 8198 : }

	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlDOMWrap:

; 8180 : 	    xmlTreeErrMemory("alloc ns map item");
; 8181 : 	    return(-1);
; 8182 : 	}
; 8183 : 	*size = 3;

	mov	eax, DWORD PTR _size$[ebp]

; 8184 : 	*number = 0;

	mov	esi, DWORD PTR _number$[ebp]
	mov	DWORD PTR [eax], 3
	mov	DWORD PTR [esi], 0
	mov	edx, DWORD PTR [edi]
$LN6@xmlDOMWrap:

; 8192 : 	}
; 8193 :     }
; 8194 :     (*list)[2 * (*number)] = oldNs;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _oldNs$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 8195 :     (*list)[2 * (*number) +1] = newNs;

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _newNs$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+edx*8+4], eax

; 8196 :     (*number)++;

	inc	DWORD PTR [esi]

; 8197 :     return (0);

	xor	eax, eax

; 8198 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlDOMWrap:

; 8185 :     } else if ((*number) >= (*size)) {

	mov	ecx, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _number$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [esi], eax
	jl	SHORT $LN6@xmlDOMWrap

; 8186 : 	*size *= 2;

	add	eax, eax
	mov	DWORD PTR [ecx], eax

; 8187 : 	*list = (xmlNsPtr *) xmlRealloc(*list,

	shl	eax, 3
	push	eax
	push	DWORD PTR [edi]
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [edi], edx

; 8188 : 	    (*size) * 2 * sizeof(xmlNsPtr));
; 8189 : 	if (*list == NULL) {

	test	edx, edx
	jne	SHORT $LN6@xmlDOMWrap

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BE@NIDEIDLB@realloc?5ns?5map?5item@

; 8190 : 	    xmlTreeErrMemory("realloc ns map item");
; 8191 : 	    return(-1);

	jmp	SHORT $LN12@xmlDOMWrap
_xmlDOMWrapNSNormAddNsMapItem2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNSNormGatherInScopeNs
_TEXT	SEGMENT
_cur$1$ = -4						; size = 4
_shadowed$1$ = 8					; size = 4
_map$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlDOMWrapNSNormGatherInScopeNs PROC			; COMDAT

; 8083 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _map$[ebp]
	test	ebx, ebx
	je	$LN11@xmlDOMWrap

; 8084 :     xmlNodePtr cur;
; 8085 :     xmlNsPtr ns;
; 8086 :     xmlNsMapItemPtr mi;
; 8087 :     int shadowed;
; 8088 : 
; 8089 :     if ((map == NULL) || (*map != NULL))

	cmp	DWORD PTR [ebx], 0
	jne	$LN11@xmlDOMWrap

; 8091 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _cur$1$[ebp], eax
	test	eax, eax
	je	$LN11@xmlDOMWrap
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	$LN11@xmlDOMWrap
	push	esi
	push	edi
	npad	3
$LL2@xmlDOMWrap:

; 8092 :         return (-1);
; 8093 :     /*
; 8094 :     * Get in-scope ns-decls of @parent.
; 8095 :     */
; 8096 :     cur = node;
; 8097 :     while ((cur != NULL) && (cur != (xmlNodePtr) cur->doc)) {

	cmp	eax, DWORD PTR [eax+32]
	je	$LN3@xmlDOMWrap

; 8098 : 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	$LN5@xmlDOMWrap

; 8099 : 	    if (cur->nsDef != NULL) {

	mov	edi, DWORD PTR [eax+48]
	test	edi, edi
	je	$LN5@xmlDOMWrap
	npad	2
$LL6@xmlDOMWrap:

; 8100 : 		ns = cur->nsDef;
; 8101 : 		do {
; 8102 : 		    shadowed = 0;
; 8103 : 		    if (XML_NSMAP_NOTEMPTY(*map)) {

	mov	esi, DWORD PTR [ebx]
	mov	DWORD PTR _shadowed$1$[ebp], 0
	test	esi, esi
	je	SHORT $LN8@xmlDOMWrap
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN8@xmlDOMWrap
$LL9@xmlDOMWrap:

; 8108 : 			    if ((ns->prefix == mi->newNs->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN43@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@xmlDOMWrap

; 8104 : 			/*
; 8105 : 			* Skip shadowed prefixes.
; 8106 : 			*/
; 8107 : 			XML_NSMAP_FOREACH(*map, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL9@xmlDOMWrap

; 8125 : 		} while (ns != NULL);

	jmp	SHORT $LN8@xmlDOMWrap
$LN43@xmlDOMWrap:

; 8109 : 				xmlStrEqual(ns->prefix, mi->newNs->prefix)) {
; 8110 : 				shadowed = 1;

	mov	DWORD PTR _shadowed$1$[ebp], 1
$LN8@xmlDOMWrap:

; 7892 :     map = *nsmap;

	mov	esi, DWORD PTR [ebx]

; 7893 : 
; 7894 :     if (map == NULL) {

	test	esi, esi
	jne	SHORT $LN25@xmlDOMWrap

; 7895 : 	/*
; 7896 : 	* Create the ns-map.
; 7897 : 	*/
; 7898 : 	map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 7899 : 	if (map == NULL) {

	test	esi, esi
	je	$LN53@xmlDOMWrap
	xorps	xmm0, xmm0

; 7902 : 	}
; 7903 : 	memset(map, 0, sizeof(struct xmlNsMap));

	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 7904 : 	*nsmap = map;

	mov	DWORD PTR [ebx], esi
$LN25@xmlDOMWrap:

; 7905 :     }
; 7906 : 
; 7907 :     if (map->pool != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN27@xmlDOMWrap

; 7908 : 	/*
; 7909 : 	* Reuse an item from the pool.
; 7910 : 	*/
; 7911 : 	ret = map->pool;
; 7912 : 	map->pool = ret->next;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 7913 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7914 :     } else {

	jmp	SHORT $LN61@xmlDOMWrap
$LN27@xmlDOMWrap:

; 7915 : 	/*
; 7916 : 	* Create a new item.
; 7917 : 	*/
; 7918 : 	ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 7919 : 	if (ret == NULL) {

	test	ecx, ecx
	je	SHORT $LN54@xmlDOMWrap
$LN61@xmlDOMWrap:

; 7920 : 	    xmlTreeErrMemory("allocating namespace map item");
; 7921 : 	    return (NULL);
; 7922 : 	}
; 7923 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7924 :     }
; 7925 : 
; 7926 :     if (map->first == NULL) {

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN30@xmlDOMWrap

; 7927 : 	/*
; 7928 : 	* First ever.
; 7929 : 	*/
; 7930 : 	map->first = ret;
; 7931 : 	map->last = ret;

	mov	DWORD PTR [esi+4], ecx
	jmp	SHORT $LN34@xmlDOMWrap
$LN30@xmlDOMWrap:

; 7932 :     } else if (position == -1) {
; 7933 : 	/*
; 7934 : 	* Append.
; 7935 : 	*/
; 7936 : 	ret->prev = map->last;
; 7937 : 	map->last->next = ret;
; 7938 : 	map->last = ret;
; 7939 :     } else if (position == 0) {
; 7940 : 	/*
; 7941 : 	* Set on first position.
; 7942 : 	*/
; 7943 : 	map->first->prev = ret;

	mov	DWORD PTR [eax+4], ecx

; 7944 : 	ret->next = map->first;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN34@xmlDOMWrap:

; 7950 :     ret->shadowDepth = -1;

	or	eax, -1
	mov	DWORD PTR [esi], ecx

; 8122 : 		    if (shadowed)

	xor	edx, edx

; 7951 :     ret->depth = depth;

	mov	DWORD PTR [ecx+20], eax

; 8122 : 		    if (shadowed)

	cmp	DWORD PTR _shadowed$1$[ebp], edx

; 7948 :     ret->oldNs = oldNs;

	mov	DWORD PTR [ecx+8], 0

; 8122 : 		    if (shadowed)

	cmovne	eax, edx

; 7949 :     ret->newNs = newNs;

	mov	DWORD PTR [ecx+12], edi

; 8122 : 		    if (shadowed)

	mov	DWORD PTR [ecx+16], eax

; 8123 : 			mi->shadowDepth = 0;
; 8124 : 		    ns = ns->next;

	mov	edi, DWORD PTR [edi]

; 8125 : 		} while (ns != NULL);

	test	edi, edi
	jne	$LL6@xmlDOMWrap
	mov	eax, DWORD PTR _cur$1$[ebp]
$LN5@xmlDOMWrap:

; 8126 : 	    }
; 8127 : 	}
; 8128 : 	cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _cur$1$[ebp], eax
	test	eax, eax
	jne	$LL2@xmlDOMWrap
$LN3@xmlDOMWrap:
	pop	edi
	pop	esi

; 8129 :     }
; 8130 :     return (0);

	xor	eax, eax
	pop	ebx

; 8131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlDOMWrap:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, OFFSET ??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@

; 7901 : 	    return (NULL);

	jmp	SHORT $LN44@xmlDOMWrap
$LN54@xmlDOMWrap:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, OFFSET ??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@
$LN44@xmlDOMWrap:

; 8111 : 				break;
; 8112 : 			    }
; 8113 : 			}
; 8114 : 		    }
; 8115 : 		    /*
; 8116 : 		    * Insert mapping.
; 8117 : 		    */
; 8118 : 		    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,
; 8119 : 			ns, XML_TREE_NSMAP_PARENT);
; 8120 : 		    if (mi == NULL)
; 8121 : 			return (-1);

	push	eax
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx

; 8131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlDOMWrap:

; 8090 : 	return (-1);

	or	eax, -1
	pop	ebx

; 8131 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDOMWrapNSNormGatherInScopeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTreeNSListLookupByPrefix
_TEXT	SEGMENT
_nsList$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlTreeNSListLookupByPrefix PROC			; COMDAT

; 8053 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nsList$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlTreeNSL

; 8054 :     if (nsList == NULL)
; 8055 : 	return (NULL);

	xor	eax, eax
	pop	esi

; 8066 :     }
; 8067 :     return (NULL);
; 8068 : }

	pop	ebp
	ret	0
$LN5@xmlTreeNSL:
	push	edi

; 8056 :     {
; 8057 : 	xmlNsPtr ns;
; 8058 : 	ns = nsList;

	mov	edi, DWORD PTR _prefix$[ebp]
	npad	2
$LL4@xmlTreeNSL:

; 8059 : 	do {
; 8060 : 	    if ((prefix == ns->prefix) ||

	mov	eax, DWORD PTR [esi+12]
	cmp	edi, eax
	je	SHORT $LN7@xmlTreeNSL
	push	eax
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlTreeNSL

; 8063 : 	    }
; 8064 : 	    ns = ns->next;

	mov	esi, DWORD PTR [esi]

; 8065 : 	} while (ns != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlTreeNSL
	pop	edi
	pop	esi

; 8066 :     }
; 8067 :     return (NULL);
; 8068 : }

	pop	ebp
	ret	0
$LN7@xmlTreeNSL:
	pop	edi

; 8061 : 		xmlStrEqual(prefix, ns->prefix)) {
; 8062 : 		return (ns);

	mov	eax, esi
	pop	esi

; 8066 :     }
; 8067 :     return (NULL);
; 8068 : }

	pop	ebp
	ret	0
_xmlTreeNSListLookupByPrefix ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapStoreNs
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_nsName$ = 12						; size = 4
_prefix$ = 16						; size = 4
_xmlDOMWrapStoreNs PROC					; COMDAT

; 7971 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlDOMWrap

; 7972 :     xmlNsPtr ns;
; 7973 : 
; 7974 :     if (doc == NULL)
; 7975 : 	return (NULL);
; 7976 :     ns = xmlTreeEnsureXMLDecl(doc);

	push	eax
	call	_xmlTreeEnsureXMLDecl
	mov	esi, eax
	add	esp, 4

; 7977 :     if (ns == NULL)

	test	esi, esi
	je	SHORT $LN10@xmlDOMWrap

; 7978 : 	return (NULL);
; 7979 :     if (ns->next != NULL) {

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR _prefix$[ebp]
	mov	ebx, DWORD PTR _nsName$[ebp]
	test	eax, eax
	je	SHORT $LN14@xmlDOMWrap

; 7980 : 	/* Reuse. */
; 7981 : 	ns = ns->next;

	mov	esi, eax

; 7982 : 	while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN10@xmlDOMWrap
$LL2@xmlDOMWrap:

; 7983 : 	    if (((ns->prefix == prefix) ||
; 7984 : 		xmlStrEqual(ns->prefix, prefix)) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN8@xmlDOMWrap
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlDOMWrap
$LN8@xmlDOMWrap:
	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlDOMWrap
$LN7@xmlDOMWrap:

; 7987 : 	    }
; 7988 : 	    if (ns->next == NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@xmlDOMWrap

; 7989 : 		break;
; 7990 : 	    ns = ns->next;

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL2@xmlDOMWrap
$LN10@xmlDOMWrap:
	pop	edi

; 7996 :         return (ns->next);
; 7997 :     }
; 7998 :     return(NULL);
; 7999 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlDOMWrap:
	pop	edi

; 7985 : 		xmlStrEqual(ns->href, nsName)) {
; 7986 : 		return (ns);

	mov	eax, esi

; 7996 :         return (ns->next);
; 7997 :     }
; 7998 :     return(NULL);
; 7999 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlDOMWrap:

; 7991 : 	}
; 7992 :     }
; 7993 :     /* Create. */
; 7994 :     if (ns != NULL) {
; 7995 :         ns->next = xmlNewNs(NULL, nsName, prefix);

	push	edi
	push	ebx
	push	0
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	pop	edi

; 7996 :         return (ns->next);
; 7997 :     }
; 7998 :     return(NULL);
; 7999 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlDOMWrapStoreNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNsMapAddItem
_TEXT	SEGMENT
_nsmap$ = 8						; size = 4
_position$ = 12						; size = 4
_oldNs$ = 16						; size = 4
_newNs$ = 20						; size = 4
_depth$ = 24						; size = 4
_xmlDOMWrapNsMapAddItem PROC				; COMDAT

; 7884 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _nsmap$[ebp]
	test	ebx, ebx
	je	$LN19@xmlDOMWrap

; 7885 :     xmlNsMapItemPtr ret;
; 7886 :     xmlNsMapPtr map;
; 7887 : 
; 7888 :     if (nsmap == NULL)
; 7889 : 	return(NULL);
; 7890 :     if ((position != -1) && (position != 0))

	mov	edi, DWORD PTR _position$[ebp]
	cmp	edi, -1
	je	SHORT $LN3@xmlDOMWrap
	test	edi, edi
	jne	$LN19@xmlDOMWrap
$LN3@xmlDOMWrap:
	push	esi

; 7892 :     map = *nsmap;

	mov	esi, DWORD PTR [ebx]

; 7893 : 
; 7894 :     if (map == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlDOMWrap

; 7895 : 	/*
; 7896 : 	* Create the ns-map.
; 7897 : 	*/
; 7898 : 	map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 7899 : 	if (map == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlDOMWrap

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@

; 7900 : 	    xmlTreeErrMemory("allocating namespace map");
; 7901 : 	    return (NULL);

	jmp	SHORT $LN22@xmlDOMWrap
$LN5@xmlDOMWrap:
	xorps	xmm0, xmm0

; 7902 : 	}
; 7903 : 	memset(map, 0, sizeof(struct xmlNsMap));

	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0

; 7904 : 	*nsmap = map;

	mov	DWORD PTR [ebx], esi
$LN4@xmlDOMWrap:

; 7905 :     }
; 7906 : 
; 7907 :     if (map->pool != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN6@xmlDOMWrap

; 7908 : 	/*
; 7909 : 	* Reuse an item from the pool.
; 7910 : 	*/
; 7911 : 	ret = map->pool;
; 7912 : 	map->pool = ret->next;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax
$LN8@xmlDOMWrap:

; 7922 : 	}
; 7923 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7924 :     }
; 7925 : 
; 7926 :     if (map->first == NULL) {

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN9@xmlDOMWrap

; 7927 : 	/*
; 7928 : 	* First ever.
; 7929 : 	*/
; 7930 : 	map->first = ret;
; 7931 : 	map->last = ret;

	mov	DWORD PTR [esi+4], ecx
	jmp	SHORT $LN21@xmlDOMWrap
$LN6@xmlDOMWrap:

; 7913 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7914 :     } else {
; 7915 : 	/*
; 7916 : 	* Create a new item.
; 7917 : 	*/
; 7918 : 	ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 7919 : 	if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN8@xmlDOMWrap

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@
$LN22@xmlDOMWrap:
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7920 : 	    xmlTreeErrMemory("allocating namespace map item");
; 7921 : 	    return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 7953 : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlDOMWrap:

; 7932 :     } else if (position == -1) {

	cmp	edi, -1
	jne	SHORT $LN11@xmlDOMWrap

; 7933 : 	/*
; 7934 : 	* Append.
; 7935 : 	*/
; 7936 : 	ret->prev = map->last;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 7937 : 	map->last->next = ret;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx

; 7938 : 	map->last = ret;

	mov	DWORD PTR [esi+4], ecx
	jmp	SHORT $LN13@xmlDOMWrap
$LN11@xmlDOMWrap:

; 7939 :     } else if (position == 0) {

	test	edi, edi
	jne	SHORT $LN13@xmlDOMWrap

; 7940 : 	/*
; 7941 : 	* Set on first position.
; 7942 : 	*/
; 7943 : 	map->first->prev = ret;

	mov	DWORD PTR [eax+4], ecx

; 7944 : 	ret->next = map->first;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN21@xmlDOMWrap:

; 7945 : 	map->first = ret;
; 7946 :     }
; 7947 : 
; 7948 :     ret->oldNs = oldNs;

	mov	DWORD PTR [esi], ecx
$LN13@xmlDOMWrap:
	mov	eax, DWORD PTR _oldNs$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 7949 :     ret->newNs = newNs;

	mov	eax, DWORD PTR _newNs$[ebp]
	pop	esi
	mov	DWORD PTR [ecx+12], eax

; 7950 :     ret->shadowDepth = -1;
; 7951 :     ret->depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+20], eax

; 7952 :     return (ret);

	mov	eax, ecx
	mov	DWORD PTR [ecx+16], -1

; 7953 : }

	pop	ebx
	pop	ebp
	ret	0
$LN19@xmlDOMWrap:
	pop	edi

; 7891 : 	return(NULL);

	xor	eax, eax

; 7953 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlDOMWrapNsMapAddItem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNsMapFree
_TEXT	SEGMENT
_nsmap$ = 8						; size = 4
_xmlDOMWrapNsMapFree PROC				; COMDAT

; 7852 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _nsmap$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlDOMWrap

; 7853 :     xmlNsMapItemPtr cur, tmp;
; 7854 : 
; 7855 :     if (nsmap == NULL)
; 7856 : 	return;
; 7857 :     cur = nsmap->pool;

	push	esi
	mov	esi, DWORD PTR [edi+8]

; 7858 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlDOMWrap
	npad	3
$LL2@xmlDOMWrap:

; 7859 : 	tmp = cur;
; 7860 : 	cur = cur->next;
; 7861 : 	xmlFree(tmp);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL2@xmlDOMWrap
$LN3@xmlDOMWrap:

; 7862 :     }
; 7863 :     cur = nsmap->first;

	mov	esi, DWORD PTR [edi]

; 7864 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlDOMWrap
$LL4@xmlDOMWrap:

; 7865 : 	tmp = cur;
; 7866 : 	cur = cur->next;
; 7867 : 	xmlFree(tmp);

	push	esi
	mov	esi, DWORD PTR [esi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL4@xmlDOMWrap
$LN5@xmlDOMWrap:

; 7868 :     }
; 7869 :     xmlFree(nsmap);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN1@xmlDOMWrap:
	pop	edi

; 7870 : }

	pop	ebp
	ret	0
_xmlDOMWrapNsMapFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetPropNodeInternal
_TEXT	SEGMENT
_tmpstr$3$ = -12					; size = 4
_elemQName$1$ = -8					; size = 4
_doc$1$ = -4						; size = 4
_nsList$1$ = 8						; size = 4
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_nsName$ = 16						; size = 4
_useDTD$ = 20						; size = 4
_xmlGetPropNodeInternal PROC				; COMDAT

; 6483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __59973643_tree@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	$LN11@xmlGetProp

; 6484 :     xmlAttrPtr prop;
; 6485 : 
; 6486 :     if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))

	cmp	DWORD PTR [ecx+4], 1
	jne	$LN11@xmlGetProp
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	$LN11@xmlGetProp

; 6487 : 	return(NULL);
; 6488 : 
; 6489 :     if (node->properties != NULL) {

	mov	esi, DWORD PTR [ecx+44]
	mov	ebx, DWORD PTR _nsName$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlGetProp

; 6490 : 	prop = node->properties;
; 6491 : 	if (nsName == NULL) {

	test	ebx, ebx
	jne	SHORT $LL7@xmlGetProp
$LL4@xmlGetProp:

; 6492 : 	    /*
; 6493 : 	    * We want the attr to be in no namespace.
; 6494 : 	    */
; 6495 : 	    do {
; 6496 : 		if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN15@xmlGetProp
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@xmlGetProp
$LN15@xmlGetProp:

; 6497 : 		    return(prop);
; 6498 : 		}
; 6499 : 		prop = prop->next;

	mov	esi, DWORD PTR [esi+24]

; 6500 : 	    } while (prop != NULL);

	test	esi, esi
	jne	SHORT $LL4@xmlGetProp
	jmp	SHORT $LN65@xmlGetProp
$LN38@xmlGetProp:
	pop	edi

; 6588 : 	    return((xmlAttrPtr) attrDecl);
; 6589 :     }
; 6590 : #endif /* LIBXML_TREE_ENABLED */
; 6591 :     return(NULL);
; 6592 : }

	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	7
$LL7@xmlGetProp:

; 6501 : 	} else {
; 6502 : 	    /*
; 6503 : 	    * We want the attr to be in the specified namespace.
; 6504 : 	    */
; 6505 : 	    do {
; 6506 : 		if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN16@xmlGetProp
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@xmlGetProp
	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, ebx
	je	SHORT $LN38@xmlGetProp
	push	ebx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@xmlGetProp
$LN16@xmlGetProp:

; 6507 : 		    ((prop->ns->href == nsName) ||
; 6508 : 		     xmlStrEqual(prop->ns->href, nsName)))
; 6509 : 		{
; 6510 : 		    return(prop);
; 6511 : 		}
; 6512 : 		prop = prop->next;

	mov	esi, DWORD PTR [esi+24]

; 6513 : 	    } while (prop != NULL);

	test	esi, esi
	jne	SHORT $LL7@xmlGetProp
$LN65@xmlGetProp:

; 6514 : 	}
; 6515 :     }
; 6516 : 
; 6517 : #ifdef LIBXML_TREE_ENABLED
; 6518 :     if (! useDTD)

	mov	ecx, DWORD PTR _node$[ebp]
$LN6@xmlGetProp:
	cmp	DWORD PTR _useDTD$[ebp], 0
	je	$LN11@xmlGetProp

; 6519 : 	return(NULL);
; 6520 :     /*
; 6521 :      * Check if there is a default/fixed attribute declaration in
; 6522 :      * the internal or external subset.
; 6523 :      */
; 6524 :     if ((node->doc != NULL) && (node->doc->intSubset != NULL)) {

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _doc$1$[ebp], eax
	test	eax, eax
	je	$LN11@xmlGetProp
	cmp	DWORD PTR [eax+44], 0
	je	$LN11@xmlGetProp

; 6525 : 	xmlDocPtr doc = node->doc;
; 6526 : 	xmlAttributePtr attrDecl = NULL;
; 6527 : 	xmlChar *elemQName, *tmpstr = NULL;
; 6528 : 
; 6529 : 	/*
; 6530 : 	* We need the QName of the element for the DTD-lookup.
; 6531 : 	*/
; 6532 : 	if ((node->ns != NULL) && (node->ns->prefix != NULL)) {

	mov	edx, DWORD PTR [ecx+36]
	xor	esi, esi
	mov	DWORD PTR _tmpstr$3$[ebp], esi
	test	edx, edx
	je	SHORT $LN20@xmlGetProp
	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	je	SHORT $LN20@xmlGetProp

; 6533 : 	    tmpstr = xmlStrdup(node->ns->prefix);

	push	edx
	call	_xmlStrdup

; 6534 : 	    tmpstr = xmlStrcat(tmpstr, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 6535 : 	    tmpstr = xmlStrcat(tmpstr, node->name);

	mov	ecx, DWORD PTR _node$[ebp]
	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmpstr$3$[ebp], eax

; 6536 : 	    if (tmpstr == NULL)

	test	eax, eax
	je	$LN11@xmlGetProp

; 6537 : 		return(NULL);
; 6538 : 	    elemQName = tmpstr;
; 6539 : 	} else

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, eax
	mov	DWORD PTR _elemQName$1$[ebp], eax
	mov	eax, DWORD PTR _doc$1$[ebp]
	jmp	SHORT $LN21@xmlGetProp
$LN20@xmlGetProp:

; 6540 : 	    elemQName = (xmlChar *) node->name;

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _elemQName$1$[ebp], edx
$LN21@xmlGetProp:

; 6541 : 	if (nsName == NULL) {

	test	ebx, ebx
	jne	SHORT $LN23@xmlGetProp

; 6542 : 	    /*
; 6543 : 	    * The common and nice case: Attr in no namespace.
; 6544 : 	    */
; 6545 : 	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,

	push	ebx
	push	edi
	push	edx
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQAttrDesc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6546 : 		elemQName, name, NULL);
; 6547 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {

	test	esi, esi
	jne	$LN24@xmlGetProp
	mov	eax, DWORD PTR _doc$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	$LN24@xmlGetProp

; 6548 : 		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,

	push	esi
	push	edi
	push	DWORD PTR _elemQName$1$[ebp]
	push	eax
	call	_xmlGetDtdQAttrDesc
	add	esp, 16					; 00000010H
	mov	esi, eax

; 6549 : 		    elemQName, name, NULL);
; 6550 : 	    }
; 6551 : 	} else {

	jmp	$LN24@xmlGetProp
$LN23@xmlGetProp:

; 6552 : 	    xmlNsPtr *nsList, *cur;
; 6553 : 
; 6554 : 	    /*
; 6555 : 	    * The ugly case: Search using the prefixes of in-scope
; 6556 : 	    * ns-decls corresponding to @nsName.
; 6557 : 	    */
; 6558 : 	    nsList = xmlGetNsList(node->doc, node);

	push	ecx
	push	DWORD PTR [ecx+32]
	call	_xmlGetNsList
	add	esp, 8
	mov	DWORD PTR _nsList$1$[ebp], eax

; 6559 : 	    if (nsList == NULL) {

	test	eax, eax
	jne	SHORT $LN26@xmlGetProp

; 6560 : 		if (tmpstr != NULL)

	mov	eax, DWORD PTR _tmpstr$3$[ebp]
	test	eax, eax
	je	$LN11@xmlGetProp

; 6561 : 		    xmlFree(tmpstr);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi

; 6588 : 	    return((xmlAttrPtr) attrDecl);
; 6589 :     }
; 6590 : #endif /* LIBXML_TREE_ENABLED */
; 6591 :     return(NULL);
; 6592 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlGetProp:

; 6562 : 		return(NULL);
; 6563 : 	    }
; 6564 : 	    cur = nsList;

	mov	ebx, eax

; 6565 : 	    while (*cur != NULL) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN63@xmlGetProp
$LL8@xmlGetProp:

; 6566 : 		if (xmlStrEqual((*cur)->href, nsName)) {

	push	DWORD PTR _nsName$[ebp]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@xmlGetProp

; 6567 : 		    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _doc$1$[ebp]
	push	edi
	push	DWORD PTR _elemQName$1$[ebp]
	push	DWORD PTR [eax+44]
	call	_xmlGetDtdQAttrDesc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6568 : 			name, (*cur)->prefix);
; 6569 : 		    if (attrDecl)

	test	esi, esi
	jne	SHORT $LN63@xmlGetProp

; 6570 : 			break;
; 6571 : 		    if (doc->extSubset != NULL) {

	mov	eax, DWORD PTR _doc$1$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	je	SHORT $LN31@xmlGetProp

; 6572 : 			attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+12]
	push	edi
	push	DWORD PTR _elemQName$1$[ebp]
	push	ecx
	call	_xmlGetDtdQAttrDesc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6573 : 			    name, (*cur)->prefix);
; 6574 : 			if (attrDecl)

	test	esi, esi
	jne	SHORT $LN63@xmlGetProp
$LN31@xmlGetProp:

; 6565 : 	    while (*cur != NULL) {

	mov	eax, DWORD PTR [ebx+4]

; 6575 : 			    break;
; 6576 : 		    }
; 6577 : 		}
; 6578 : 		cur++;

	add	ebx, 4
	test	eax, eax
	jne	SHORT $LL8@xmlGetProp
$LN63@xmlGetProp:

; 6579 : 	    }
; 6580 : 	    xmlFree(nsList);

	push	DWORD PTR _nsList$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlGetProp:

; 6581 : 	}
; 6582 : 	if (tmpstr != NULL)

	mov	eax, DWORD PTR _tmpstr$3$[ebp]
	test	eax, eax
	je	SHORT $LN32@xmlGetProp

; 6583 : 	    xmlFree(tmpstr);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN32@xmlGetProp:

; 6584 : 	/*
; 6585 : 	* Only default/fixed attrs are relevant.
; 6586 : 	*/
; 6587 : 	if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))

	test	esi, esi
	je	SHORT $LN11@xmlGetProp
	cmp	DWORD PTR [esi+48], 0
	jne	$LN38@xmlGetProp
$LN11@xmlGetProp:
	pop	edi

; 6588 : 	    return((xmlAttrPtr) attrDecl);
; 6589 :     }
; 6590 : #endif /* LIBXML_TREE_ENABLED */
; 6591 :     return(NULL);
; 6592 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetPropNodeInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNsInScope
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_node$ = 12						; size = 4
_ancestor$ = 16						; size = 4
_prefix$ = 20						; size = 4
_xmlNsInScope PROC					; COMDAT

; 6099 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _ancestor$[ebp]
	test	ebx, ebx
	je	SHORT $LN25@xmlNsInSco
	mov	edi, DWORD PTR _prefix$[ebp]
	npad	3
$LL2@xmlNsInSco:

; 6100 :     xmlNsPtr tst;
; 6101 : 
; 6102 :     while ((node != NULL) && (node != ancestor)) {

	cmp	ebx, ecx
	je	SHORT $LN11@xmlNsInSco

; 6103 :         if ((node->type == XML_ENTITY_REF_NODE) ||
; 6104 :             (node->type == XML_ENTITY_NODE) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 5
	je	SHORT $LN24@xmlNsInSco
	cmp	eax, 6
	je	SHORT $LN24@xmlNsInSco
	cmp	eax, 17					; 00000011H
	je	SHORT $LN24@xmlNsInSco

; 6105 :             (node->type == XML_ENTITY_DECL))
; 6106 :             return (-1);
; 6107 :         if (node->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	SHORT $LN5@xmlNsInSco

; 6108 :             tst = node->nsDef;

	mov	esi, DWORD PTR [ebx+48]

; 6109 :             while (tst != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlNsInSco
$LL4@xmlNsInSco:

; 6110 :                 if ((tst->prefix == NULL)
; 6111 :                     && (prefix == NULL))

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN27@xmlNsInSco
	test	edi, edi
	je	SHORT $LN16@xmlNsInSco

; 6112 :                     return (0);
; 6113 :                 if ((tst->prefix != NULL)
; 6114 :                     && (prefix != NULL)
; 6115 :                     && (xmlStrEqual(tst->prefix, prefix)))

	test	eax, eax
	je	SHORT $LN10@xmlNsInSco
$LN27@xmlNsInSco:
	test	edi, edi
	je	SHORT $LN10@xmlNsInSco
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlNsInSco
$LN10@xmlNsInSco:

; 6116 :                     return (0);
; 6117 :                 tst = tst->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlNsInSco
	mov	ecx, DWORD PTR _ancestor$[ebp]
$LN5@xmlNsInSco:

; 6118 :             }
; 6119 :         }
; 6120 :         node = node->parent;

	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	SHORT $LL2@xmlNsInSco
$LN25@xmlNsInSco:

; 6121 :     }
; 6122 :     if (node != ancestor)

	cmp	ebx, ecx
	je	SHORT $LN11@xmlNsInSco
$LN24@xmlNsInSco:
	pop	edi

; 6123 :         return (-1);
; 6124 :     return (1);
; 6125 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlNsInSco:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlNsInSco:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlNsInScope ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTreeEnsureXMLDecl
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlTreeEnsureXMLDecl PROC				; COMDAT

; 5970 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlTreeEns

; 5971 :     if (doc == NULL)
; 5972 : 	return (NULL);

	xor	eax, eax
	pop	edi

; 5989 :     }
; 5990 : }

	pop	ebp
	ret	0
$LN2@xmlTreeEns:

; 5973 :     if (doc->oldNs != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	jne	SHORT $LN1@xmlTreeEns

; 5974 : 	return (doc->oldNs);
; 5975 :     {
; 5976 : 	xmlNsPtr ns;
; 5977 : 	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	esi
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5978 : 	if (ns == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlTreeEns

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BN@LLCMIJBD@allocating?5the?5XML?5namespace@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 5979 : 	    xmlTreeErrMemory(
; 5980 : 		"allocating the XML namespace");
; 5981 : 	    return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5989 :     }
; 5990 : }

	pop	ebp
	ret	0
$LN4@xmlTreeEns:
	xorps	xmm0, xmm0

; 5982 : 	}
; 5983 : 	memset(ns, 0, sizeof(xmlNs));

	movups	XMMWORD PTR [esi], xmm0

; 5984 : 	ns->type = XML_LOCAL_NAMESPACE;
; 5985 : 	ns->href = xmlStrdup(XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+4], 18			; 00000012H
	call	_xmlStrdup

; 5986 : 	ns->prefix = xmlStrdup((const xmlChar *)"xml");

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	DWORD PTR [esi+8], eax
	call	_xmlStrdup
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 5987 : 	doc->oldNs = ns;

	mov	DWORD PTR [edi+52], esi

; 5988 : 	return (ns);

	mov	eax, esi
	pop	esi
$LN1@xmlTreeEns:
	pop	edi

; 5989 :     }
; 5990 : }

	pop	ebp
	ret	0
_xmlTreeEnsureXMLDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetLineNoInternal
_TEXT	SEGMENT
_node$ = 8						; size = 4
_depth$ = 12						; size = 4
_xmlGetLineNoInternal PROC				; COMDAT

; 4595 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _depth$[ebp]
	or	eax, -1
	cmp	edx, 5
	jge	$LN22@xmlGetLine

; 4596 :     long result = -1;
; 4597 : 
; 4598 :     if (depth >= 5)
; 4599 :         return(-1);
; 4600 : 
; 4601 :     if (!node)

	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN22@xmlGetLine

; 4603 :     if ((node->type == XML_ELEMENT_NODE) ||
; 4604 :         (node->type == XML_TEXT_NODE) ||
; 4605 : 	(node->type == XML_COMMENT_NODE) ||

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	cmp	ecx, 1
	je	SHORT $LN6@xmlGetLine
	cmp	ecx, 3
	je	SHORT $LN6@xmlGetLine
	cmp	ecx, 8
	je	SHORT $LN6@xmlGetLine
	cmp	ecx, 7
	je	SHORT $LN6@xmlGetLine

; 4620 :     } else if ((node->prev != NULL) &&

	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	je	SHORT $LN17@xmlGetLine
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, 1
	je	SHORT $LN19@xmlGetLine
	cmp	ecx, 3
	je	SHORT $LN19@xmlGetLine
	cmp	ecx, 8
	je	SHORT $LN19@xmlGetLine
	cmp	ecx, 7
	jne	SHORT $LN17@xmlGetLine
$LN19@xmlGetLine:

; 4621 :              ((node->prev->type == XML_ELEMENT_NODE) ||
; 4622 : 	      (node->prev->type == XML_TEXT_NODE) ||
; 4623 : 	      (node->prev->type == XML_COMMENT_NODE) ||
; 4624 : 	      (node->prev->type == XML_PI_NODE)))
; 4625 :         result = xmlGetLineNoInternal(node->prev, depth + 1);

	lea	eax, DWORD PTR [edx+1]
	push	eax
	push	edi
	call	_xmlGetLineNoInternal
	add	esp, 8

; 4629 : 
; 4630 :     return result;

	pop	edi
	pop	esi

; 4631 : }

	pop	ebp
	ret	0
$LN17@xmlGetLine:

; 4626 :     else if ((node->parent != NULL) &&

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN15@xmlGetLine
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN15@xmlGetLine

; 4629 : 
; 4630 :     return result;

	pop	edi
	lea	eax, DWORD PTR [edx+1]
	pop	esi

; 4627 :              (node->parent->type == XML_ELEMENT_NODE))
; 4628 :         result = xmlGetLineNoInternal(node->parent, depth + 1);

	mov	DWORD PTR _depth$[ebp], eax
	mov	DWORD PTR _node$[ebp], ecx

; 4631 : }

	pop	ebp

; 4627 :              (node->parent->type == XML_ELEMENT_NODE))
; 4628 :         result = xmlGetLineNoInternal(node->parent, depth + 1);

	jmp	_xmlGetLineNoInternal
$LN6@xmlGetLine:

; 4606 : 	(node->type == XML_PI_NODE)) {
; 4607 : 	if (node->line == 65535) {

	mov	eax, 65535				; 0000ffffH
	cmp	WORD PTR [esi+56], ax
	jne	SHORT $LN16@xmlGetLine

; 4608 : 	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))

	cmp	ecx, 3
	jne	SHORT $LN8@xmlGetLine
	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN10@xmlGetLine

; 4609 : 	        result = (long) (ptrdiff_t) node->psvi;

	jmp	SHORT $LN14@xmlGetLine
$LN8@xmlGetLine:

; 4610 : 	    else if ((node->type == XML_ELEMENT_NODE) &&

	cmp	ecx, 1
	jne	SHORT $LN10@xmlGetLine
	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	jne	SHORT $LN25@xmlGetLine
$LN10@xmlGetLine:

; 4611 : 	             (node->children != NULL))
; 4612 : 	        result = xmlGetLineNoInternal(node->children, depth + 1);
; 4613 : 	    else if (node->next != NULL)

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	jne	SHORT $LN25@xmlGetLine

; 4614 : 	        result = xmlGetLineNoInternal(node->next, depth + 1);
; 4615 : 	    else if (node->prev != NULL)

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN16@xmlGetLine
$LN25@xmlGetLine:

; 4616 : 	        result = xmlGetLineNoInternal(node->prev, depth + 1);
; 4617 : 	}
; 4618 : 	if ((result == -1) || (result == 65535))

	lea	eax, DWORD PTR [edx+1]
	push	eax
	push	ecx
	call	_xmlGetLineNoInternal
	add	esp, 8
$LN14@xmlGetLine:
	cmp	eax, -1
	je	SHORT $LN16@xmlGetLine
	cmp	eax, 65535				; 0000ffffH
	jne	SHORT $LN15@xmlGetLine
$LN16@xmlGetLine:

; 4619 : 	    result = (long) node->line;

	movzx	eax, WORD PTR [esi+56]
$LN15@xmlGetLine:

; 4629 : 
; 4630 :     return result;

	pop	edi
	pop	esi

; 4631 : }

	pop	ebp
	ret	0
$LN22@xmlGetLine:

; 4602 :         return result;

	or	eax, -1
	pop	esi

; 4631 : }

	pop	ebp
	ret	0
_xmlGetLineNoInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlStaticCopyNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_doc$ = 12						; size = 4
_parent$ = 16						; size = 4
_extended$ = 20						; size = 4
_xmlStaticCopyNode PROC					; COMDAT

; 4170 :                   int extended) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$LN13@xmlStaticC

; 4171 :     xmlNodePtr ret;
; 4172 : 
; 4173 :     if (node == NULL) return(NULL);
; 4174 :     switch (node->type) {

	mov	eax, DWORD PTR [edi+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN2@xmlStaticC
	movzx	eax, BYTE PTR $LN121@xmlStaticC[eax]
	jmp	DWORD PTR $LN129@xmlStaticC[eax*4]
$LN10@xmlStaticC:

; 4175 :         case XML_TEXT_NODE:
; 4176 :         case XML_CDATA_SECTION_NODE:
; 4177 :         case XML_ELEMENT_NODE:
; 4178 :         case XML_DOCUMENT_FRAG_NODE:
; 4179 :         case XML_ENTITY_REF_NODE:
; 4180 :         case XML_ENTITY_NODE:
; 4181 :         case XML_PI_NODE:
; 4182 :         case XML_COMMENT_NODE:
; 4183 :         case XML_XINCLUDE_START:
; 4184 :         case XML_XINCLUDE_END:
; 4185 : 	    break;
; 4186 :         case XML_ATTRIBUTE_NODE:
; 4187 : 		return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));

	push	edi
	push	DWORD PTR _parent$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlCopyPropInternal
	add	esp, 12					; 0000000cH
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN11@xmlStaticC:

; 4188 :         case XML_NAMESPACE_DECL:
; 4189 : 	    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));

	push	edi
	call	_xmlCopyNamespaceList
	add	esp, 4
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN12@xmlStaticC:

; 4190 : 
; 4191 :         case XML_DOCUMENT_NODE:
; 4192 :         case XML_HTML_DOCUMENT_NODE:
; 4193 : #ifdef LIBXML_DOCB_ENABLED
; 4194 :         case XML_DOCB_DOCUMENT_NODE:
; 4195 : #endif
; 4196 : #ifdef LIBXML_TREE_ENABLED
; 4197 : 	    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));

	push	DWORD PTR _extended$[ebp]
	push	edi
	call	_xmlCopyDoc
	add	esp, 8
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN2@xmlStaticC:
	push	esi

; 4206 :     }
; 4207 : 
; 4208 :     /*
; 4209 :      * Allocate a new node and fill the fields.
; 4210 :      */
; 4211 :     ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 4212 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN14@xmlStaticC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0N@IDAFCAHJ@copying?5node@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 4213 : 	xmlTreeErrMemory("copying node");
; 4214 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN14@xmlStaticC:
	push	ebx

; 4215 :     }
; 4216 :     memset(ret, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	esi
	call	_memset

; 4217 :     ret->type = node->type;

	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH

; 4218 : 
; 4219 :     ret->doc = doc;

	mov	ebx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi+4], eax

; 4220 :     ret->parent = parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+20], eax

; 4221 :     if (node->name == xmlStringText)

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, OFFSET _xmlStringText
	jne	SHORT $LN15@xmlStaticC

; 4222 : 	ret->name = xmlStringText;

	mov	DWORD PTR [esi+8], OFFSET _xmlStringText
	jmp	SHORT $LN23@xmlStaticC
$LN15@xmlStaticC:

; 4223 :     else if (node->name == xmlStringTextNoenc)

	cmp	eax, OFFSET _xmlStringTextNoenc
	jne	SHORT $LN17@xmlStaticC

; 4224 : 	ret->name = xmlStringTextNoenc;

	mov	DWORD PTR [esi+8], OFFSET _xmlStringTextNoenc
	jmp	SHORT $LN23@xmlStaticC
$LN17@xmlStaticC:

; 4225 :     else if (node->name == xmlStringComment)

	cmp	eax, OFFSET _xmlStringComment
	jne	SHORT $LN19@xmlStaticC

; 4226 : 	ret->name = xmlStringComment;

	mov	DWORD PTR [esi+8], OFFSET _xmlStringComment
	jmp	SHORT $LN23@xmlStaticC
$LN19@xmlStaticC:

; 4227 :     else if (node->name != NULL) {

	test	eax, eax
	je	SHORT $LN23@xmlStaticC

; 4228 :         if ((doc != NULL) && (doc->dict != NULL))

	test	ebx, ebx
	je	SHORT $LN22@xmlStaticC
	mov	ecx, DWORD PTR [ebx+80]
	test	ecx, ecx
	je	SHORT $LN22@xmlStaticC

; 4229 : 	    ret->name = xmlDictLookup(doc->dict, node->name, -1);

	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN125@xmlStaticC
$LN22@xmlStaticC:

; 4230 : 	else
; 4231 : 	    ret->name = xmlStrdup(node->name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN125@xmlStaticC:

; 4232 :     }
; 4233 :     if ((node->type != XML_ELEMENT_NODE) &&
; 4234 : 	(node->content != NULL) &&
; 4235 : 	(node->type != XML_ENTITY_REF_NODE) &&
; 4236 : 	(node->type != XML_XINCLUDE_END) &&

	mov	DWORD PTR [esi+8], eax
$LN23@xmlStaticC:
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN120@xmlStaticC
	mov	ecx, DWORD PTR [edi+40]
	test	ecx, ecx
	je	SHORT $LN26@xmlStaticC
	cmp	eax, 5
	je	SHORT $LN26@xmlStaticC
	cmp	eax, 20					; 00000014H
	je	SHORT $LN26@xmlStaticC
	cmp	eax, 19					; 00000013H
	je	SHORT $LN26@xmlStaticC

; 4237 : 	(node->type != XML_XINCLUDE_START)) {
; 4238 : 	ret->content = xmlStrdup(node->content);

	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4239 :     }else{

	jmp	SHORT $LN26@xmlStaticC
$LN120@xmlStaticC:

; 4240 :       if (node->type == XML_ELEMENT_NODE)
; 4241 :         ret->line = node->line;

	mov	ax, WORD PTR [edi+56]
	mov	WORD PTR [esi+56], ax
$LN26@xmlStaticC:

; 4242 :     }
; 4243 :     if (parent != NULL) {

	mov	eax, DWORD PTR _parent$[ebp]
	test	eax, eax
	je	SHORT $LN29@xmlStaticC

; 4244 : 	xmlNodePtr tmp;
; 4245 : 
; 4246 : 	/*
; 4247 : 	 * this is a tricky part for the node register thing:
; 4248 : 	 * in case ret does get coalesced in xmlAddChild
; 4249 : 	 * the deregister-node callback is called; so we register ret now already
; 4250 : 	 */
; 4251 : 	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN28@xmlStaticC
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN122@xmlStaticC

; 4252 : 	    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN122@xmlStaticC:

; 4253 : 
; 4254 :         tmp = xmlAddChild(parent, ret);

	mov	eax, DWORD PTR _parent$[ebp]
$LN28@xmlStaticC:
	push	esi
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 4255 : 	/* node could have coalesced */
; 4256 : 	if (tmp != ret)

	cmp	eax, esi
	jne	$LN124@xmlStaticC
$LN29@xmlStaticC:

; 4257 : 	    return(tmp);
; 4258 :     }
; 4259 : 
; 4260 :     if (!extended)

	cmp	DWORD PTR _extended$[ebp], 0
	je	$out$130

; 4261 : 	goto out;
; 4262 :     if (((node->type == XML_ELEMENT_NODE) ||
; 4263 :          (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN32@xmlStaticC
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN31@xmlStaticC
$LN32@xmlStaticC:
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN31@xmlStaticC

; 4264 :         ret->nsDef = xmlCopyNamespaceList(node->nsDef);

	push	eax
	call	_xmlCopyNamespaceList
	add	esp, 4
	mov	DWORD PTR [esi+48], eax
$LN31@xmlStaticC:

; 4265 : 
; 4266 :     if (node->ns != NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN35@xmlStaticC

; 4267 :         xmlNsPtr ns;
; 4268 : 
; 4269 : 	ns = xmlSearchNs(doc, ret, node->ns->prefix);

	push	DWORD PTR [eax+12]
	push	esi
	push	ebx
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 4270 : 	if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN34@xmlStaticC

; 4271 : 	    /*
; 4272 : 	     * Humm, we are copying an element whose namespace is defined
; 4273 : 	     * out of the new tree scope. Search it in the original tree
; 4274 : 	     * and add it at the top of the new tree
; 4275 : 	     */
; 4276 : 	    ns = xmlSearchNs(node->doc, node, node->ns->prefix);

	mov	eax, DWORD PTR [edi+36]
	push	DWORD PTR [eax+12]
	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 4277 : 	    if (ns != NULL) {

	test	eax, eax
	je	SHORT $LN36@xmlStaticC

; 4278 : 	        xmlNodePtr root = ret;
; 4279 : 
; 4280 : 		while (root->parent != NULL) root = root->parent;

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, esi
	test	ecx, ecx
	je	SHORT $LN5@xmlStaticC
$LL4@xmlStaticC:
	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	jne	SHORT $LL4@xmlStaticC
$LN5@xmlStaticC:

; 4281 : 		ret->ns = xmlNewNs(root, ns->href, ns->prefix);

	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	edx
	call	_xmlNewNs

; 4282 : 		} else {

	jmp	SHORT $LN126@xmlStaticC
$LN36@xmlStaticC:

; 4283 : 			ret->ns = xmlNewReconciliedNs(doc, ret, node->ns);

	push	DWORD PTR [edi+36]
	push	esi
	push	ebx
	call	_xmlNewReconciliedNs
$LN126@xmlStaticC:

; 4284 : 	    }
; 4285 : 	} else {

	add	esp, 12					; 0000000cH
$LN34@xmlStaticC:

; 4286 : 	    /*
; 4287 : 	     * reference the existing namespace definition in our own tree.
; 4288 : 	     */
; 4289 : 	    ret->ns = ns;
; 4290 : 	}
; 4291 :     }
; 4292 :     if (((node->type == XML_ELEMENT_NODE) ||
; 4293 :          (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))

	mov	DWORD PTR [esi+36], eax
$LN35@xmlStaticC:
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN39@xmlStaticC
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN38@xmlStaticC
$LN39@xmlStaticC:
	mov	ecx, DWORD PTR [edi+44]
	test	ecx, ecx
	je	SHORT $LN38@xmlStaticC

; 4294 :         ret->properties = xmlCopyPropList(ret, node->properties);

	push	ecx
	push	esi
	call	_xmlCopyPropList
	mov	DWORD PTR [esi+44], eax
	add	esp, 8
	mov	eax, DWORD PTR [edi+4]
$LN38@xmlStaticC:

; 4295 :     if (node->type == XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	SHORT $LN40@xmlStaticC

; 4296 : 	if ((doc == NULL) || (node->doc != doc)) {

	test	ebx, ebx
	je	SHORT $LN44@xmlStaticC
	cmp	DWORD PTR [edi+32], ebx
	jne	SHORT $LN44@xmlStaticC

; 4304 : 	} else {
; 4305 :             ret->children = node->children;

	mov	eax, DWORD PTR [edi+12]

; 4306 : 	}
; 4307 : 	ret->last = ret->children;

	mov	DWORD PTR [esi+12], eax
	jmp	SHORT $LN127@xmlStaticC
$LN44@xmlStaticC:

; 4297 : 	    /*
; 4298 : 	     * The copied node will go into a separate document, so
; 4299 : 	     * to avoid dangling references to the ENTITY_DECL node
; 4300 : 	     * we cannot keep the reference. Try to find it in the
; 4301 : 	     * target document.
; 4302 : 	     */
; 4303 : 	    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlGetDocEntity
	add	esp, 8

; 4306 : 	}
; 4307 : 	ret->last = ret->children;

	mov	DWORD PTR [esi+12], eax
	jmp	SHORT $LN127@xmlStaticC
$LN40@xmlStaticC:

; 4308 :     } else if ((node->children != NULL) && (extended != 2)) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $out$130
	cmp	DWORD PTR _extended$[ebp], 2
	je	SHORT $out$130

; 4309 :         ret->children = xmlStaticCopyNodeList(node->children, doc, ret);

	push	esi
	push	ebx
	push	eax
	call	_xmlStaticCopyNodeList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+12], eax

; 4310 : 	UPDATE_LAST_CHILD_AND_PARENT(ret)

	test	eax, eax
	jne	SHORT $LN113@xmlStaticC
	mov	DWORD PTR [esi+16], eax
	jmp	SHORT $out$130
$LN113@xmlStaticC:
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN7@xmlStaticC
$LL6@xmlStaticC:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL6@xmlStaticC
$LN7@xmlStaticC:
	mov	DWORD PTR [eax+20], esi
$LN127@xmlStaticC:

; 4311 :     }
; 4312 : 
; 4313 : out:
; 4314 :     /* if parent != NULL we already registered the node above */
; 4315 :     if ((parent == NULL) &&

	mov	DWORD PTR [esi+16], eax
$out$130:
	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN49@xmlStaticC
	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN49@xmlStaticC
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN49@xmlStaticC

; 4316 :         ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))
; 4317 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)ret);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN49@xmlStaticC:

; 4318 :     return(ret);

	mov	eax, esi
$LN124@xmlStaticC:
	pop	ebx
	pop	esi
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN13@xmlStaticC:

; 4198 : #endif /* LIBXML_TREE_ENABLED */
; 4199 :         case XML_DOCUMENT_TYPE_NODE:
; 4200 :         case XML_NOTATION_NODE:
; 4201 :         case XML_DTD_NODE:
; 4202 :         case XML_ELEMENT_DECL:
; 4203 :         case XML_ATTRIBUTE_DECL:
; 4204 :         case XML_ENTITY_DECL:
; 4205 :             return(NULL);

	xor	eax, eax
	pop	edi

; 4319 : }

	pop	ebp
	ret	0
$LN129@xmlStaticC:
	DD	$LN10@xmlStaticC
	DD	$LN12@xmlStaticC
	DD	$LN13@xmlStaticC
	DD	$LN11@xmlStaticC
	DD	$LN2@xmlStaticC
$LN121@xmlStaticC:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
	DB	4
	DB	1
_xmlStaticCopyNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyPropInternal
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_target$ = 12						; size = 4
_ns$2$ = 16						; size = 4
_ns$1$ = 16						; size = 4
_cur$ = 16						; size = 4
_xmlCopyPropInternal PROC				; COMDAT

; 4006 : xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN88@xmlCopyPro

; 4007 :     xmlAttrPtr ret;
; 4008 : 
; 4009 :     if (cur == NULL) return(NULL);
; 4010 :     if ((target != NULL) && (target->type != XML_ELEMENT_NODE))

	mov	esi, DWORD PTR _target$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlCopyPro
	cmp	DWORD PTR [esi+4], 1
	jne	$LN88@xmlCopyPro

; 4011 :         return(NULL);
; 4012 :     if (target != NULL)

	test	esi, esi
	je	SHORT $LN8@xmlCopyPro

; 4013 : 	ret = xmlNewDocProp(target->doc, cur->name, NULL);

	mov	ecx, DWORD PTR [esi+32]
	jmp	SHORT $LN15@xmlCopyPro
$LN8@xmlCopyPro:

; 4014 :     else if (doc != NULL)

	mov	ecx, DWORD PTR _doc$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@xmlCopyPro

; 4015 : 	ret = xmlNewDocProp(doc, cur->name, NULL);
; 4016 :     else if (cur->parent != NULL)

	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	je	SHORT $LN12@xmlCopyPro

; 4017 : 	ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);

	mov	ecx, DWORD PTR [ecx+32]
	jmp	SHORT $LN15@xmlCopyPro
$LN12@xmlCopyPro:

; 4018 :     else if (cur->children != NULL)

	mov	ecx, DWORD PTR [ebx+12]
	test	ecx, ecx
	je	SHORT $LN14@xmlCopyPro

; 4019 : 	ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);

	mov	ecx, DWORD PTR [ecx+32]
	jmp	SHORT $LN15@xmlCopyPro
$LN14@xmlCopyPro:

; 4020 :     else
; 4021 : 	ret = xmlNewDocProp(NULL, cur->name, NULL);

	xor	ecx, ecx
$LN15@xmlCopyPro:

; 4022 :     if (ret == NULL) return(NULL);

	mov	eax, DWORD PTR [ebx+8]
	push	0
	push	eax
	push	ecx
	call	_xmlNewDocProp
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	$LN88@xmlCopyPro

; 4023 :     ret->parent = target;

	mov	DWORD PTR [edi+20], esi

; 4024 : 
; 4025 :     if ((cur->ns != NULL) && (target != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	$LN17@xmlCopyPro
	test	esi, esi
	je	$LN17@xmlCopyPro

; 4026 :       xmlNsPtr ns;
; 4027 : 
; 4028 :       ns = xmlSearchNs(target->doc, target, cur->ns->prefix);

	push	DWORD PTR [eax+12]
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlSearchNs
	mov	ecx, DWORD PTR [ebx+36]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ns$2$[ebp], eax

; 4029 :       if (ns == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlCopyPro

; 4030 :         /*
; 4031 :          * Humm, we are copying an element whose namespace is defined
; 4032 :          * out of the new tree scope. Search it in the original tree
; 4033 :          * and add it at the top of the new tree
; 4034 :          */
; 4035 :         ns = xmlSearchNs(cur->doc, cur->parent, cur->ns->prefix);

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ebx+20]
	push	DWORD PTR [ebx+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ns$1$[ebp], eax

; 4036 :         if (ns != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlCopyPro

; 4037 :           xmlNodePtr root = target;
; 4038 :           xmlNodePtr pred = NULL;
; 4039 : 
; 4040 :           while (root->parent != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	xor	eax, eax
	mov	edx, esi
	test	ecx, ecx
	je	SHORT $LN3@xmlCopyPro
$LL2@xmlCopyPro:

; 4041 :             pred = root;

	mov	eax, edx

; 4042 :             root = root->parent;

	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	jne	SHORT $LL2@xmlCopyPro
$LN3@xmlCopyPro:

; 4043 :           }
; 4044 :           if (root == (xmlNodePtr) target->doc) {
; 4045 :             /* correct possibly cycling above the document elt */
; 4046 :             root = pred;
; 4047 :           }
; 4048 :           ret->ns = xmlNewNs(root, ns->href, ns->prefix);

	mov	ecx, DWORD PTR _ns$1$[ebp]
	cmp	edx, DWORD PTR [esi+32]
	cmovne	eax, edx
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [ecx+8]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+36], eax

; 4049 :         }
; 4050 :       } else {

	jmp	SHORT $LN18@xmlCopyPro
$LN19@xmlCopyPro:

; 4051 :         /*
; 4052 :          * we have to find something appropriate here since
; 4053 :          * we cant be sure, that the namespce we found is identified
; 4054 :          * by the prefix
; 4055 :          */
; 4056 :         if (xmlStrEqual(ns->href, cur->ns->href)) {

	push	DWORD PTR [ecx+8]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlCopyPro

; 4057 :           /* this is the nice case */
; 4058 :           ret->ns = ns;

	mov	eax, DWORD PTR _ns$2$[ebp]
	mov	DWORD PTR [edi+36], eax

; 4059 :         } else {

	jmp	SHORT $LN18@xmlCopyPro
$LN23@xmlCopyPro:

; 4060 :           /*
; 4061 :            * we are in trouble: we need a new reconcilied namespace.
; 4062 :            * This is expensive
; 4063 :            */
; 4064 :           ret->ns = xmlNewReconciliedNs(target->doc, target, cur->ns);

	push	DWORD PTR [ebx+36]
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlNewReconciliedNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+36], eax

; 4065 :         }
; 4066 :       }
; 4067 : 
; 4068 :     } else

	jmp	SHORT $LN18@xmlCopyPro
$LN17@xmlCopyPro:

; 4069 :         ret->ns = NULL;

	mov	DWORD PTR [edi+36], 0
$LN18@xmlCopyPro:

; 4070 : 
; 4071 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN5@xmlCopyPro

; 4072 : 	xmlNodePtr tmp;
; 4073 : 
; 4074 : 	ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);

	push	edi
	push	DWORD PTR [edi+32]
	push	eax
	call	_xmlStaticCopyNodeList
	mov	ecx, eax

; 4075 : 	ret->last = NULL;

	mov	DWORD PTR [edi+16], 0
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+12], ecx

; 4076 : 	tmp = ret->children;
; 4077 : 	while (tmp != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlCopyPro
$LL4@xmlCopyPro:

; 4078 : 	    /* tmp->parent = (xmlNodePtr)ret; */
; 4079 : 	    if (tmp->next == NULL)

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN87@xmlCopyPro

; 4080 : 	        ret->last = tmp;

	mov	DWORD PTR [edi+16], ecx
	mov	eax, DWORD PTR [ecx+24]
$LN87@xmlCopyPro:

; 4081 : 	    tmp = tmp->next;

	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL4@xmlCopyPro
$LN5@xmlCopyPro:

; 4082 : 	}
; 4083 :     }
; 4084 :     /*
; 4085 :      * Try to handle IDs
; 4086 :      */
; 4087 :     if ((target!= NULL) && (cur!= NULL) &&
; 4088 : 	(target->doc != NULL) && (cur->doc != NULL) &&
; 4089 : 	(cur->doc->ids != NULL) && (cur->parent != NULL)) {

	test	esi, esi
	je	SHORT $LN29@xmlCopyPro
	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN29@xmlCopyPro
	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN29@xmlCopyPro
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN29@xmlCopyPro
	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	je	SHORT $LN29@xmlCopyPro

; 4090 : 	if (xmlIsID(cur->doc, cur->parent, cur)) {

	push	ebx
	push	ecx
	push	eax
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@xmlCopyPro

; 4091 : 	    xmlChar *id;
; 4092 : 
; 4093 : 	    id = xmlNodeListGetString(cur->doc, cur->children, 1);

	push	1
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+32]
	call	_xmlNodeListGetString
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 4094 : 	    if (id != NULL) {

	test	ebx, ebx
	je	SHORT $LN29@xmlCopyPro

; 4095 : 		xmlAddID(NULL, target->doc, id, ret);

	push	edi
	push	ebx
	push	DWORD PTR [esi+32]
	push	0
	call	_xmlAddID

; 4096 : 		xmlFree(id);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
$LN29@xmlCopyPro:

; 4097 : 	    }
; 4098 : 	}
; 4099 :     }
; 4100 :     return(ret);

	mov	eax, edi
	pop	edi

; 4101 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN88@xmlCopyPro:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlCopyPropInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlStaticCopyNodeList
_TEXT	SEGMENT
_p$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_node$ = 8						; size = 4
_doc$ = 12						; size = 4
_parent$ = 16						; size = 4
_xmlStaticCopyNodeList PROC				; COMDAT

; 4322 : xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	xor	ecx, ecx
	xor	eax, eax
	mov	DWORD PTR _ret$1$[ebp], ecx
	mov	DWORD PTR _p$1$[ebp], eax
	test	edi, edi
	je	$LN3@xmlStaticC
	mov	ebx, DWORD PTR _doc$[ebp]
	npad	5
$LL2@xmlStaticC:

; 4327 : #ifdef LIBXML_TREE_ENABLED
; 4328 : 	if (node->type == XML_DTD_NODE ) {

	cmp	DWORD PTR [edi+4], 14			; 0000000eH
	jne	SHORT $LN4@xmlStaticC

; 4329 : 	    if (doc == NULL) {

	test	ebx, ebx
	je	SHORT $LN23@xmlStaticC

; 4330 : 		node = node->next;
; 4331 : 		continue;
; 4332 : 	    }
; 4333 : 	    if (doc->intSubset == NULL) {

	mov	esi, DWORD PTR [ebx+44]
	test	esi, esi
	jne	SHORT $LN7@xmlStaticC

; 4334 : 		q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );

	push	edi
	call	_xmlCopyDtd
	mov	esi, eax
	add	esp, 4

; 4335 : 		if (q == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN18@xmlStaticC

; 4336 : 		q->doc = doc;
; 4337 : 		q->parent = parent;

	mov	eax, DWORD PTR _parent$[ebp]

; 4338 : 		doc->intSubset = (xmlDtdPtr) q;
; 4339 : 		xmlAddChild(parent, q);
; 4340 : 	    } else {
; 4341 : 		q = (xmlNodePtr) doc->intSubset;
; 4342 : 		xmlAddChild(parent, q);
; 4343 : 	    }
; 4344 : 	} else

	push	esi
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+20], eax
	push	eax
	mov	DWORD PTR [ebx+44], esi
	call	_xmlAddChild
	add	esp, 8
	jmp	SHORT $LN5@xmlStaticC
$LN7@xmlStaticC:
	mov	eax, DWORD PTR _parent$[ebp]
	push	esi
	push	eax
	call	_xmlAddChild
	add	esp, 8
	jmp	SHORT $LN5@xmlStaticC
$LN4@xmlStaticC:

; 4345 : #endif /* LIBXML_TREE_ENABLED */
; 4346 : 	    q = xmlStaticCopyNode(node, doc, parent, 1);

	push	1
	push	DWORD PTR _parent$[ebp]
	push	ebx
	push	edi
	call	_xmlStaticCopyNode
	add	esp, 16					; 00000010H
	mov	esi, eax
$LN5@xmlStaticC:

; 4347 : 	if (q == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN18@xmlStaticC

; 4348 : 	if (ret == NULL) {

	cmp	DWORD PTR _ret$1$[ebp], 0
	jne	SHORT $LN11@xmlStaticC

; 4349 : 	    q->prev = NULL;
; 4350 : 	    ret = p = q;

	mov	ecx, esi
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR _p$1$[ebp], esi
	mov	DWORD PTR _ret$1$[ebp], ecx
	jmp	SHORT $LN13@xmlStaticC
$LN11@xmlStaticC:

; 4351 : 	} else if (p != q) {

	mov	ecx, DWORD PTR _p$1$[ebp]
	cmp	ecx, esi
	je	SHORT $LN23@xmlStaticC

; 4352 : 	/* the test is required if xmlStaticCopyNode coalesced 2 text nodes */
; 4353 : 	    p->next = q;

	mov	DWORD PTR [ecx+24], esi

; 4354 : 	    q->prev = p;

	mov	DWORD PTR [esi+28], ecx

; 4355 : 	    p = q;

	mov	DWORD PTR _p$1$[ebp], esi
$LN23@xmlStaticC:

; 4323 :     xmlNodePtr ret = NULL;
; 4324 :     xmlNodePtr p = NULL,q;
; 4325 : 
; 4326 :     while (node != NULL) {

	mov	ecx, DWORD PTR _ret$1$[ebp]
$LN13@xmlStaticC:
	mov	eax, DWORD PTR [edi+24]
	mov	edi, eax
	test	eax, eax
	jne	$LL2@xmlStaticC
$LN3@xmlStaticC:
	pop	edi

; 4356 : 	}
; 4357 : 	node = node->next;
; 4358 :     }
; 4359 :     return(ret);
; 4360 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlStaticC:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStaticCopyNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddPropSibling
_TEXT	SEGMENT
_prev$ = 8						; size = 4
tv400 = 12						; size = 4
_cur$ = 12						; size = 4
_prop$ = 16						; size = 4
_xmlAddPropSibling PROC					; COMDAT

; 2958 : xmlAddPropSibling(xmlNodePtr prev, xmlNodePtr cur, xmlNodePtr prop) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN3@xmlAddProp

; 2959 : 	xmlAttrPtr attr;
; 2960 : 
; 2961 : 	if ((cur == NULL) || (cur->type != XML_ATTRIBUTE_NODE) ||
; 2962 : 	    (prop == NULL) || (prop->type != XML_ATTRIBUTE_NODE) ||

	cmp	DWORD PTR [edi+4], 2
	jne	$LN3@xmlAddProp
	mov	esi, DWORD PTR _prop$[ebp]
	test	esi, esi
	je	$LN3@xmlAddProp
	cmp	DWORD PTR [esi+4], 2
	jne	$LN3@xmlAddProp
	mov	ebx, DWORD PTR _prev$[ebp]
	test	ebx, ebx
	je	SHORT $LN2@xmlAddProp
	cmp	DWORD PTR [ebx+4], 2
	jne	$LN3@xmlAddProp
$LN2@xmlAddProp:

; 2963 : 	    ((prev != NULL) && (prev->type != XML_ATTRIBUTE_NODE)))
; 2964 : 		return(NULL);
; 2965 : 
; 2966 : 	/* check if an attribute with the same name exists */
; 2967 : 	if (prop->ns == NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jne	SHORT $LN4@xmlAddProp

; 2968 : 		attr = xmlHasNsProp(cur->parent, prop->name, NULL);

	xor	ecx, ecx
	jmp	SHORT $LN5@xmlAddProp
$LN4@xmlAddProp:

; 2969 : 	else
; 2970 : 		attr = xmlHasNsProp(cur->parent, prop->name, prop->ns->href);

	mov	ecx, DWORD PTR [eax+8]
$LN5@xmlAddProp:

; 2971 : 
; 2972 : 	if (prop->doc != cur->doc) {

	mov	eax, DWORD PTR [esi+8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edi+20]
	push	eax
	call	_xmlHasNsProp
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR tv400[ebp], ecx
	cmp	DWORD PTR [esi+32], eax
	je	SHORT $LN6@xmlAddProp

; 2973 : 		xmlSetTreeDoc(prop, cur->doc);

	push	eax
	push	esi
	call	_xmlSetTreeDoc
	mov	ecx, DWORD PTR tv400[ebp]
	add	esp, 8
$LN6@xmlAddProp:

; 2974 : 	}
; 2975 : 	prop->parent = cur->parent;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], eax

; 2976 : 	prop->prev = prev;

	mov	DWORD PTR [esi+28], ebx

; 2977 : 	if (prev != NULL) {

	test	ebx, ebx
	je	SHORT $LN7@xmlAddProp

; 2978 : 		prop->next = prev->next;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [esi+24], eax

; 2979 : 		prev->next = prop;

	mov	DWORD PTR [ebx+24], esi

; 2980 : 		if (prop->next)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN8@xmlAddProp

; 2981 : 			prop->next->prev = prop;

	mov	DWORD PTR [eax+28], esi

; 2982 : 	} else {

	jmp	SHORT $LN8@xmlAddProp
$LN7@xmlAddProp:

; 2983 : 		prop->next = cur;

	mov	DWORD PTR [esi+24], edi

; 2984 : 		cur->prev = prop;

	mov	DWORD PTR [edi+28], esi
$LN8@xmlAddProp:

; 2985 : 	}
; 2986 : 	if (prop->prev == NULL && prop->parent != NULL)

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN10@xmlAddProp
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN10@xmlAddProp

; 2987 : 		prop->parent->properties = (xmlAttrPtr) prop;

	mov	DWORD PTR [eax+44], esi
$LN10@xmlAddProp:

; 2988 : 	if ((attr != NULL) && (attr->type != XML_ATTRIBUTE_DECL)) {

	test	ecx, ecx
	je	SHORT $LN11@xmlAddProp
	cmp	DWORD PTR [ecx+4], 16			; 00000010H
	je	SHORT $LN11@xmlAddProp

; 2989 : 		/* different instance, destroy it (attributes must be unique) */
; 2990 : 		xmlRemoveProp((xmlAttrPtr) attr);

	push	ecx
	call	_xmlRemoveProp
	add	esp, 4
$LN11@xmlAddProp:

; 2991 : 	}
; 2992 : 	return prop;

	pop	edi
	mov	eax, esi

; 2993 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlAddProp:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlAddPropSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewPropInternal
_TEXT	SEGMENT
_doc$1$ = -4						; size = 4
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_value$ = 20						; size = 4
_eatname$ = 24						; size = 4
_xmlNewPropInternal PROC				; COMDAT

; 1840 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _name$[ebp]
	mov	ecx, OFFSET __59973643_tree@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _doc$1$[ebp], 0
	test	edi, edi
	je	SHORT $LN6@xmlNewProp

; 1841 :     xmlAttrPtr cur;
; 1842 :     xmlDocPtr doc = NULL;
; 1843 : 
; 1844 :     if ((node != NULL) && (node->type != XML_ELEMENT_NODE)) {

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN6@xmlNewProp

; 1845 :         if ((eatname == 1) &&

	cmp	DWORD PTR _eatname$[ebp], 1
	jne	SHORT $LN7@xmlNewProp
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN8@xmlNewProp
	push	ebx
	push	DWORD PTR [eax+80]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlNewProp
$LN8@xmlNewProp:

; 1846 : 	    ((node->doc == NULL) ||
; 1847 : 	     (!(xmlDictOwns(node->doc->dict, name)))))
; 1848 :             xmlFree((xmlChar *) name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlNewProp:

; 1849 :         return (NULL);

	pop	edi
	xor	eax, eax

; 1925 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlNewProp:
	push	esi

; 1850 :     }
; 1851 : 
; 1852 :     /*
; 1853 :      * Allocate a new property and fill the fields.
; 1854 :      */
; 1855 :     cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1856 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN9@xmlNewProp

; 1857 :         if ((eatname == 1) &&

	cmp	DWORD PTR _eatname$[ebp], 1
	jne	SHORT $LN10@xmlNewProp
	test	edi, edi
	je	SHORT $LN11@xmlNewProp
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN11@xmlNewProp
	push	ebx
	push	DWORD PTR [eax+80]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlNewProp
$LN11@xmlNewProp:

; 1858 : 	    ((node == NULL) || (node->doc == NULL) ||
; 1859 : 	     (!(xmlDictOwns(node->doc->dict, name)))))
; 1860 :             xmlFree((xmlChar *) name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlNewProp:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BD@EEPKIILJ@building?5attribute@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1861 :         xmlTreeErrMemory("building attribute");
; 1862 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1925 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlNewProp:

; 1863 :     }
; 1864 :     memset(cur, 0, sizeof(xmlAttr));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1865 :     cur->type = XML_ATTRIBUTE_NODE;

	mov	DWORD PTR [esi+4], 2

; 1866 : 
; 1867 :     cur->parent = node;

	mov	DWORD PTR [esi+20], edi

; 1868 :     if (node != NULL) {

	test	edi, edi
	je	SHORT $LN51@xmlNewProp

; 1869 :         doc = node->doc;

	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR _doc$1$[ebp], ecx

; 1870 :         cur->doc = doc;

	mov	DWORD PTR [esi+32], ecx
	jmp	SHORT $LN12@xmlNewProp
$LN51@xmlNewProp:

; 1868 :     if (node != NULL) {

	xor	ecx, ecx
$LN12@xmlNewProp:

; 1871 :     }
; 1872 :     cur->ns = ns;
; 1873 : 
; 1874 :     if (eatname == 0) {

	cmp	DWORD PTR _eatname$[ebp], 0
	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [esi+36], eax
	jne	SHORT $LN13@xmlNewProp

; 1875 :         if ((doc != NULL) && (doc->dict != NULL))

	test	ecx, ecx
	je	SHORT $LN15@xmlNewProp
	mov	eax, DWORD PTR [ecx+80]
	test	eax, eax
	je	SHORT $LN15@xmlNewProp

; 1876 :             cur->name = (xmlChar *) xmlDictLookup(doc->dict, name, -1);

	push	-1
	push	ebx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN54@xmlNewProp
$LN15@xmlNewProp:

; 1877 :         else
; 1878 :             cur->name = xmlStrdup(name);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
$LN54@xmlNewProp:

; 1879 :     } else

	mov	ebx, eax
$LN13@xmlNewProp:

; 1880 :         cur->name = name;
; 1881 : 
; 1882 :     if (value != NULL) {

	mov	eax, esi
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR _value$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlNewProp

; 1883 :         xmlNodePtr tmp;
; 1884 : 
; 1885 :         if(!xmlCheckUTF8(value)) {

	push	ebx
	call	_xmlCheckUTF8
	mov	ebx, DWORD PTR _doc$1$[ebp]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@xmlNewProp

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	eax
	push	OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
	push	ebx
	push	1303					; 00000517H
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1886 :             xmlTreeErr(XML_TREE_NOT_UTF8, (xmlNodePtr) doc,
; 1887 :                        NULL);
; 1888 :             if (doc != NULL)

	test	ebx, ebx
	je	SHORT $LN19@xmlNewProp

; 1889 :                 doc->encoding = xmlStrdup(BAD_CAST "ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+60], eax
$LN19@xmlNewProp:

; 2656 :     cur = xmlNewText(content);

	push	DWORD PTR _value$[ebp]
	call	_xmlNewText
	add	esp, 4

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	test	eax, eax
	je	SHORT $LN39@xmlNewProp
	mov	DWORD PTR [eax+32], ebx
$LN39@xmlNewProp:

; 1890 :         }
; 1891 :         cur->children = xmlNewDocText(doc, value);

	mov	DWORD PTR [esi+12], eax

; 1892 :         cur->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 1893 :         tmp = cur->children;
; 1894 :         while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN52@xmlNewProp
	npad	1
$LL2@xmlNewProp:

; 1895 :             tmp->parent = (xmlNodePtr) cur;
; 1896 :             if (tmp->next == NULL)

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], esi
	test	ecx, ecx
	jne	SHORT $LN49@xmlNewProp

; 1897 :                 cur->last = tmp;

	mov	DWORD PTR [esi+16], eax
	mov	ecx, DWORD PTR [eax+24]
$LN49@xmlNewProp:

; 1898 :             tmp = tmp->next;

	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LL2@xmlNewProp
$LN52@xmlNewProp:

; 1899 :         }
; 1900 :     }
; 1901 : 
; 1902 :     /*
; 1903 :      * Add it at the end to preserve parsing order ...
; 1904 :      */
; 1905 :     if (node != NULL) {

	mov	ebx, DWORD PTR _value$[ebp]
$LN3@xmlNewProp:
	test	edi, edi
	je	SHORT $LN23@xmlNewProp

; 1906 :         if (node->properties == NULL) {

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	jne	SHORT $LN22@xmlNewProp

; 1907 :             node->properties = cur;

	mov	DWORD PTR [edi+44], esi

; 1908 :         } else {

	jmp	SHORT $LN23@xmlNewProp
$LN22@xmlNewProp:

; 1909 :             xmlAttrPtr prev = node->properties;
; 1910 : 
; 1911 :             while (prev->next != NULL)

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN5@xmlNewProp
$LL4@xmlNewProp:

; 1912 :                 prev = prev->next;

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LL4@xmlNewProp
$LN5@xmlNewProp:

; 1913 :             prev->next = cur;

	mov	DWORD PTR [eax+24], esi

; 1914 :             cur->prev = prev;

	mov	DWORD PTR [esi+28], eax
$LN23@xmlNewProp:

; 1915 :         }
; 1916 :     }
; 1917 : 
; 1918 :     if ((value != NULL) && (node != NULL) &&

	test	ebx, ebx
	je	SHORT $LN24@xmlNewProp
	test	edi, edi
	je	SHORT $LN24@xmlNewProp
	push	esi
	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN24@xmlNewProp

; 1919 :         (xmlIsID(node->doc, node, cur) == 1))
; 1920 :         xmlAddID(NULL, node->doc, value, cur);

	push	esi
	push	ebx
	push	DWORD PTR [edi+32]
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
$LN24@xmlNewProp:

; 1921 : 
; 1922 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN25@xmlNewProp
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN25@xmlNewProp

; 1923 :         xmlRegisterNodeDefaultValue((xmlNodePtr) cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN25@xmlNewProp:

; 1924 :     return (cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 1925 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewPropInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetParameterEntityFromDtd
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetParameterEntityFromDtd PROC			; COMDAT

; 190  : xmlGetParameterEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlGetPara

; 191  :     xmlEntitiesTablePtr table;
; 192  : 
; 193  :     if ((dtd != NULL) && (dtd->pentities != NULL)) {

	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN2@xmlGetPara

; 194  : 	table = (xmlEntitiesTablePtr) dtd->pentities;
; 195  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	mov	DWORD PTR _dtd$[ebp], eax

; 199  : }

	pop	ebp

; 194  : 	table = (xmlEntitiesTablePtr) dtd->pentities;
; 195  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	jmp	_xmlHashLookup
$LN2@xmlGetPara:

; 196  : 	/* return(xmlGetEntityFromTable(table, name)); */
; 197  :     }
; 198  :     return(NULL);

	xor	eax, eax

; 199  : }

	pop	ebp
	ret	0
_xmlGetParameterEntityFromDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetEntityFromDtd
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetEntityFromDtd PROC				; COMDAT

; 169  : xmlGetEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dtd$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlGetEnti

; 170  :     xmlEntitiesTablePtr table;
; 171  : 
; 172  :     if((dtd != NULL) && (dtd->entities != NULL)) {

	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN2@xmlGetEnti

; 173  : 	table = (xmlEntitiesTablePtr) dtd->entities;
; 174  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	mov	DWORD PTR _dtd$[ebp], eax

; 178  : }

	pop	ebp

; 173  : 	table = (xmlEntitiesTablePtr) dtd->entities;
; 174  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	jmp	_xmlHashLookup
$LN2@xmlGetEnti:

; 175  : 	/* return(xmlGetEntityFromTable(table, name)); */
; 176  :     }
; 177  :     return(NULL);

	xor	eax, eax

; 178  : }

	pop	ebp
	ret	0
_xmlGetEntityFromDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTreeErr
_TEXT	SEGMENT
_code$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_xmlTreeErr PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _code$[ebp]
	lea	eax, DWORD PTR [ecx-1300]
	cmp	eax, 3
	ja	SHORT $LN8@xmlTreeErr

; 93   :     const char *msg = NULL;
; 94   : 
; 95   :     switch(code) {

	jmp	DWORD PTR $LN11@xmlTreeErr[eax*4]
$LN4@xmlTreeErr:

; 96   :         case XML_TREE_INVALID_HEX:
; 97   : 	    msg = "invalid hexadecimal character value\n";
; 98   : 	    break;
; 99   : 	case XML_TREE_INVALID_DEC:
; 100  : 	    msg = "invalid decimal character value\n";
; 101  : 	    break;
; 102  : 	case XML_TREE_UNTERMINATED_ENTITY:
; 103  : 	    msg = "unterminated entity reference %15s\n";
; 104  : 	    break;
; 105  : 	case XML_TREE_NOT_UTF8:
; 106  : 	    msg = "string is not in UTF-8\n";
; 107  : 	    break;
; 108  : 	default:
; 109  : 	    msg = "unexpected error number\n";
; 110  :     }
; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0CF@MFCHFOON@invalid?5hexadecimal?5character?5v@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	pop	ebp
	ret	0
$LN5@xmlTreeErr:

; 96   :         case XML_TREE_INVALID_HEX:
; 97   : 	    msg = "invalid hexadecimal character value\n";
; 98   : 	    break;
; 99   : 	case XML_TREE_INVALID_DEC:
; 100  : 	    msg = "invalid decimal character value\n";
; 101  : 	    break;
; 102  : 	case XML_TREE_UNTERMINATED_ENTITY:
; 103  : 	    msg = "unterminated entity reference %15s\n";
; 104  : 	    break;
; 105  : 	case XML_TREE_NOT_UTF8:
; 106  : 	    msg = "string is not in UTF-8\n";
; 107  : 	    break;
; 108  : 	default:
; 109  : 	    msg = "unexpected error number\n";
; 110  :     }
; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	pop	ebp
	ret	0
$LN6@xmlTreeErr:

; 96   :         case XML_TREE_INVALID_HEX:
; 97   : 	    msg = "invalid hexadecimal character value\n";
; 98   : 	    break;
; 99   : 	case XML_TREE_INVALID_DEC:
; 100  : 	    msg = "invalid decimal character value\n";
; 101  : 	    break;
; 102  : 	case XML_TREE_UNTERMINATED_ENTITY:
; 103  : 	    msg = "unterminated entity reference %15s\n";
; 104  : 	    break;
; 105  : 	case XML_TREE_NOT_UTF8:
; 106  : 	    msg = "string is not in UTF-8\n";
; 107  : 	    break;
; 108  : 	default:
; 109  : 	    msg = "unexpected error number\n";
; 110  :     }
; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	pop	ebp
	ret	0
$LN7@xmlTreeErr:

; 96   :         case XML_TREE_INVALID_HEX:
; 97   : 	    msg = "invalid hexadecimal character value\n";
; 98   : 	    break;
; 99   : 	case XML_TREE_INVALID_DEC:
; 100  : 	    msg = "invalid decimal character value\n";
; 101  : 	    break;
; 102  : 	case XML_TREE_UNTERMINATED_ENTITY:
; 103  : 	    msg = "unterminated entity reference %15s\n";
; 104  : 	    break;
; 105  : 	case XML_TREE_NOT_UTF8:
; 106  : 	    msg = "string is not in UTF-8\n";
; 107  : 	    break;
; 108  : 	default:
; 109  : 	    msg = "unexpected error number\n";
; 110  :     }
; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	pop	ebp
	ret	0
$LN8@xmlTreeErr:

; 96   :         case XML_TREE_INVALID_HEX:
; 97   : 	    msg = "invalid hexadecimal character value\n";
; 98   : 	    break;
; 99   : 	case XML_TREE_INVALID_DEC:
; 100  : 	    msg = "invalid decimal character value\n";
; 101  : 	    break;
; 102  : 	case XML_TREE_UNTERMINATED_ENTITY:
; 103  : 	    msg = "unterminated entity reference %15s\n";
; 104  : 	    break;
; 105  : 	case XML_TREE_NOT_UTF8:
; 106  : 	    msg = "string is not in UTF-8\n";
; 107  : 	    break;
; 108  : 	default:
; 109  : 	    msg = "unexpected error number\n";
; 110  :     }
; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 112  : }

	pop	ebp
	ret	0
	npad	1
$LN11@xmlTreeErr:
	DD	$LN4@xmlTreeErr
	DD	$LN5@xmlTreeErr
	DD	$LN6@xmlTreeErr
	DD	$LN7@xmlTreeErr
_xmlTreeErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTreeErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlTreeErrMemory PROC					; COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 81   : }

	pop	ebp
	ret	0
_xmlTreeErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetPropNodeValueInternal
_TEXT	SEGMENT
_prop$ = 8						; size = 4
_xmlGetPropNodeValueInternal PROC			; COMDAT

; 6596 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _prop$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlGetProp

; 6597 :     if (prop == NULL)
; 6598 : 	return(NULL);
; 6599 :     if (prop->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	jne	SHORT $LN3@xmlGetProp

; 6600 : 	/*
; 6601 : 	* Note that we return at least the empty string.
; 6602 : 	*   TODO: Do we really always want that?
; 6603 : 	*/
; 6604 : 	if (prop->children != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN9@xmlGetProp

; 6605 : 	    if ((prop->children->next == NULL) &&

	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN6@xmlGetProp
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, 3
	je	SHORT $LN8@xmlGetProp
	cmp	edx, 4
	jne	SHORT $LN6@xmlGetProp
$LN8@xmlGetProp:

; 6606 : 		((prop->children->type == XML_TEXT_NODE) ||
; 6607 : 		(prop->children->type == XML_CDATA_SECTION_NODE)))
; 6608 : 	    {
; 6609 : 		/*
; 6610 : 		* Optimization for the common case: only 1 text node.
; 6611 : 		*/
; 6612 : 		return(xmlStrdup(prop->children->content));

	push	DWORD PTR [ecx+40]
	call	_xmlStrdup
	add	esp, 4

; 6626 : }

	pop	ebp
	ret	0
$LN6@xmlGetProp:

; 6613 : 	    } else {
; 6614 : 		xmlChar *ret;
; 6615 : 
; 6616 : 		ret = xmlNodeListGetString(prop->doc, prop->children, 1);

	push	1
	push	ecx
	push	DWORD PTR [eax+32]
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH

; 6617 : 		if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlGetProp
$LN9@xmlGetProp:

; 6618 : 		    return(ret);
; 6619 : 	    }
; 6620 : 	}
; 6621 : 	return(xmlStrdup((xmlChar *)""));

	mov	DWORD PTR _prop$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 6626 : }

	pop	ebp

; 6618 : 		    return(ret);
; 6619 : 	    }
; 6620 : 	}
; 6621 : 	return(xmlStrdup((xmlChar *)""));

	jmp	_xmlStrdup
$LN3@xmlGetProp:

; 6622 :     } else if (prop->type == XML_ATTRIBUTE_DECL) {

	cmp	ecx, 16					; 00000010H
	jne	SHORT $LN10@xmlGetProp

; 6623 : 	return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));

	push	DWORD PTR [eax+48]
	call	_xmlStrdup
	add	esp, 4

; 6626 : }

	pop	ebp
	ret	0
$LN10@xmlGetProp:

; 6624 :     }
; 6625 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetProp:

; 6626 : }

	pop	ebp
	ret	0
_xmlGetPropNodeValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewReconciliedNs
_TEXT	SEGMENT
_prefix$ = -52						; size = 50
_doc$ = 8						; size = 4
tv221 = 12						; size = 4
_tree$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlNewReconciliedNs PROC				; COMDAT

; 6230 : xmlNewReconciliedNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	ecx, OFFSET __59973643_tree@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _tree$[ebp]
	mov	esi, 1
	test	ebx, ebx
	je	$LN5@xmlNewReco

; 6231 :     xmlNsPtr def;
; 6232 :     xmlChar prefix[50];
; 6233 :     int counter = 1;
; 6234 : 
; 6235 :     if ((tree == NULL) || (tree->type != XML_ELEMENT_NODE)) {

	cmp	DWORD PTR [ebx+4], esi
	jne	$LN5@xmlNewReco

; 6241 :     }
; 6242 :     if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL)) {

	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	$LN5@xmlNewReco
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	$LN5@xmlNewReco

; 6243 : #ifdef DEBUG_TREE
; 6244 :         xmlGenericError(xmlGenericErrorContext,
; 6245 : 		"xmlNewReconciliedNs : ns == NULL\n");
; 6246 : #endif
; 6247 : 	return(NULL);
; 6248 :     }
; 6249 :     /*
; 6250 :      * Search an existing namespace definition inherited.
; 6251 :      */
; 6252 :     def = xmlSearchNsByHref(doc, tree, ns->href);

	push	DWORD PTR [edi+8]
	push	ebx
	push	DWORD PTR _doc$[ebp]
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 6253 :     if (def != NULL)

	test	eax, eax
	jne	$LN1@xmlNewReco

; 6254 :         return(def);
; 6255 : 
; 6256 :     /*
; 6257 :      * Find a close prefix which is not already in use.
; 6258 :      * Let's strip namespace prefixes longer than 20 chars !
; 6259 :      */
; 6260 :     if (ns->prefix == NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN9@xmlNewReco

; 6261 : 	snprintf((char *) prefix, sizeof(prefix), "default");

	push	OFFSET ??_C@_07DLHCIBDH@default@
	lea	eax, DWORD PTR _prefix$[ebp]
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@xmlNewReco
$LN9@xmlNewReco:

; 6262 :     else
; 6263 : 	snprintf((char *) prefix, sizeof(prefix), "%.20s", (char *)ns->prefix);

	push	eax
	push	OFFSET ??_C@_05BNPGKEDD@?$CF?420s@
	lea	eax, DWORD PTR _prefix$[ebp]
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN10@xmlNewReco:

; 6264 : 
; 6265 :     def = xmlSearchNs(doc, tree, prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _doc$[ebp]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 6266 :     while (def != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlNewReco
	npad	4
$LL2@xmlNewReco:

; 6267 :         if (counter > 1000) return(NULL);

	cmp	esi, 1000				; 000003e8H
	jg	SHORT $LN5@xmlNewReco

; 6268 : 	if (ns->prefix == NULL)

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR tv221[ebp], ecx
	push	esi
	test	eax, eax
	jne	SHORT $LN12@xmlNewReco

; 6269 : 	    snprintf((char *) prefix, sizeof(prefix), "default%d", counter++);

	push	OFFSET ??_C@_09DFKPACFI@default?$CFd@
	lea	eax, DWORD PTR _prefix$[ebp]
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN13@xmlNewReco
$LN12@xmlNewReco:

; 6270 : 	else
; 6271 : 	    snprintf((char *) prefix, sizeof(prefix), "%.20s%d",

	push	eax
	push	OFFSET ??_C@_07BKMHDFJP@?$CF?420s?$CFd@
	lea	eax, DWORD PTR _prefix$[ebp]
	push	50					; 00000032H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
$LN13@xmlNewReco:

; 6272 : 		(char *)ns->prefix, counter++);
; 6273 : 	def = xmlSearchNs(doc, tree, prefix);

	mov	esi, DWORD PTR tv221[ebp]
	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _doc$[ebp]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL2@xmlNewReco
$LN3@xmlNewReco:

; 6274 :     }
; 6275 : 
; 6276 :     /*
; 6277 :      * OK, now we are ready to create a new one.
; 6278 :      */
; 6279 :     def = xmlNewNs(tree, ns->href, prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	DWORD PTR [edi+8]
	push	ebx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	pop	edi

; 6280 :     return(def);
; 6281 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlNewReco:

; 6236 : #ifdef DEBUG_TREE
; 6237 :         xmlGenericError(xmlGenericErrorContext,
; 6238 : 		"xmlNewReconciliedNs : tree == NULL\n");
; 6239 : #endif
; 6240 : 	return(NULL);

	xor	eax, eax
$LN1@xmlNewReco:
	pop	edi

; 6280 :     return(def);
; 6281 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewReconciliedNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlPreviousElementSibling
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlPreviousElementSibling PROC				; COMDAT

; 3589 : xmlPreviousElementSibling(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlPreviou

; 3590 :     if (node == NULL)
; 3591 :         return(NULL);
; 3592 :     switch (node->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN8@xmlPreviou
	movzx	eax, BYTE PTR $LN16@xmlPreviou[eax]
	jmp	DWORD PTR $LN18@xmlPreviou[eax*4]
$LN7@xmlPreviou:

; 3593 :         case XML_ELEMENT_NODE:
; 3594 :         case XML_TEXT_NODE:
; 3595 :         case XML_CDATA_SECTION_NODE:
; 3596 :         case XML_ENTITY_REF_NODE:
; 3597 :         case XML_ENTITY_NODE:
; 3598 :         case XML_PI_NODE:
; 3599 :         case XML_COMMENT_NODE:
; 3600 :         case XML_XINCLUDE_START:
; 3601 :         case XML_XINCLUDE_END:
; 3602 :             node = node->prev;

	mov	eax, DWORD PTR [ecx+28]

; 3606 :     }
; 3607 :     while (node != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlPreviou
$LL4@xmlPreviou:

; 3608 :         if (node->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlPreviou

; 3609 :             return(node);
; 3610 :         node = node->prev;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL4@xmlPreviou
$LN8@xmlPreviou:

; 3603 :             break;
; 3604 :         default:
; 3605 :             return(NULL);

	xor	eax, eax
$LN1@xmlPreviou:

; 3611 :     }
; 3612 :     return(NULL);
; 3613 : }

	pop	ebp
	ret	0
	npad	1
$LN18@xmlPreviou:
	DD	$LN7@xmlPreviou
	DD	$LN8@xmlPreviou
$LN16@xmlPreviou:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
_xmlPreviousElementSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlLastElementChild
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_xmlLastElementChild PROC				; COMDAT

; 3552 : xmlLastElementChild(xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _parent$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlLastEle

; 3553 :     xmlNodePtr cur = NULL;
; 3554 : 
; 3555 :     if (parent == NULL)
; 3556 :         return(NULL);
; 3557 :     switch (parent->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN8@xmlLastEle
	movzx	eax, BYTE PTR $LN16@xmlLastEle[eax]
	jmp	DWORD PTR $LN18@xmlLastEle[eax*4]
$LN7@xmlLastEle:

; 3558 :         case XML_ELEMENT_NODE:
; 3559 :         case XML_ENTITY_NODE:
; 3560 :         case XML_DOCUMENT_NODE:
; 3561 :         case XML_DOCUMENT_FRAG_NODE:
; 3562 :         case XML_HTML_DOCUMENT_NODE:
; 3563 :             cur = parent->last;

	mov	eax, DWORD PTR [ecx+16]

; 3567 :     }
; 3568 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlLastEle
$LL4@xmlLastEle:

; 3569 :         if (cur->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlLastEle

; 3570 :             return(cur);
; 3571 :         cur = cur->prev;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL4@xmlLastEle
$LN8@xmlLastEle:

; 3564 :             break;
; 3565 :         default:
; 3566 :             return(NULL);

	xor	eax, eax
$LN1@xmlLastEle:

; 3572 :     }
; 3573 :     return(NULL);
; 3574 : }

	pop	ebp
	ret	0
	npad	1
$LN18@xmlLastEle:
	DD	$LN7@xmlLastEle
	DD	$LN8@xmlLastEle
$LN16@xmlLastEle:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
_xmlLastElementChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFirstElementChild
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_xmlFirstElementChild PROC				; COMDAT

; 3516 : xmlFirstElementChild(xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _parent$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlFirstEl

; 3517 :     xmlNodePtr cur = NULL;
; 3518 : 
; 3519 :     if (parent == NULL)
; 3520 :         return(NULL);
; 3521 :     switch (parent->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN8@xmlFirstEl
	movzx	eax, BYTE PTR $LN16@xmlFirstEl[eax]
	jmp	DWORD PTR $LN18@xmlFirstEl[eax*4]
$LN7@xmlFirstEl:

; 3522 :         case XML_ELEMENT_NODE:
; 3523 :         case XML_ENTITY_NODE:
; 3524 :         case XML_DOCUMENT_NODE:
; 3525 :         case XML_DOCUMENT_FRAG_NODE:
; 3526 :         case XML_HTML_DOCUMENT_NODE:
; 3527 :             cur = parent->children;

	mov	eax, DWORD PTR [ecx+12]

; 3531 :     }
; 3532 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlFirstEl
$LL4@xmlFirstEl:

; 3533 :         if (cur->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlFirstEl

; 3534 :             return(cur);
; 3535 :         cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL4@xmlFirstEl
$LN8@xmlFirstEl:

; 3528 :             break;
; 3529 :         default:
; 3530 :             return(NULL);

	xor	eax, eax
$LN1@xmlFirstEl:

; 3536 :     }
; 3537 :     return(NULL);
; 3538 : }

	pop	ebp
	ret	0
	npad	1
$LN18@xmlFirstEl:
	DD	$LN7@xmlFirstEl
	DD	$LN8@xmlFirstEl
$LN16@xmlFirstEl:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
_xmlFirstElementChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNextElementSibling
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlNextElementSibling PROC				; COMDAT

; 3628 : xmlNextElementSibling(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlNextEle

; 3629 :     if (node == NULL)
; 3630 :         return(NULL);
; 3631 :     switch (node->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN8@xmlNextEle
	movzx	eax, BYTE PTR $LN16@xmlNextEle[eax]
	jmp	DWORD PTR $LN18@xmlNextEle[eax*4]
$LN7@xmlNextEle:

; 3632 :         case XML_ELEMENT_NODE:
; 3633 :         case XML_TEXT_NODE:
; 3634 :         case XML_CDATA_SECTION_NODE:
; 3635 :         case XML_ENTITY_REF_NODE:
; 3636 :         case XML_ENTITY_NODE:
; 3637 :         case XML_PI_NODE:
; 3638 :         case XML_COMMENT_NODE:
; 3639 :         case XML_DTD_NODE:
; 3640 :         case XML_XINCLUDE_START:
; 3641 :         case XML_XINCLUDE_END:
; 3642 :             node = node->next;

	mov	eax, DWORD PTR [ecx+24]

; 3646 :     }
; 3647 :     while (node != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlNextEle
$LL4@xmlNextEle:

; 3648 :         if (node->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlNextEle

; 3649 :             return(node);
; 3650 :         node = node->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL4@xmlNextEle
$LN8@xmlNextEle:

; 3643 :             break;
; 3644 :         default:
; 3645 :             return(NULL);

	xor	eax, eax
$LN1@xmlNextEle:

; 3651 :     }
; 3652 :     return(NULL);
; 3653 : }

	pop	ebp
	ret	0
	npad	1
$LN18@xmlNextEle:
	DD	$LN7@xmlNextEle
	DD	$LN8@xmlNextEle
$LN16@xmlNextEle:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
_xmlNextElementSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlChildElementCount
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_xmlChildElementCount PROC				; COMDAT

; 3479 : xmlChildElementCount(xmlNodePtr parent) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _parent$[ebp]
	xor	edx, edx
	test	ecx, ecx
	je	SHORT $LN8@xmlChildEl

; 3480 :     unsigned long ret = 0;
; 3481 :     xmlNodePtr cur = NULL;
; 3482 : 
; 3483 :     if (parent == NULL)
; 3484 :         return(0);
; 3485 :     switch (parent->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN8@xmlChildEl
	movzx	eax, BYTE PTR $LN15@xmlChildEl[eax]
	jmp	DWORD PTR $LN17@xmlChildEl[eax*4]
$LN7@xmlChildEl:

; 3486 :         case XML_ELEMENT_NODE:
; 3487 :         case XML_ENTITY_NODE:
; 3488 :         case XML_DOCUMENT_NODE:
; 3489 :         case XML_DOCUMENT_FRAG_NODE:
; 3490 :         case XML_HTML_DOCUMENT_NODE:
; 3491 :             cur = parent->children;

	mov	ecx, DWORD PTR [ecx+12]

; 3495 :     }
; 3496 :     while (cur != NULL) {

	test	ecx, ecx
	je	SHORT $LN5@xmlChildEl
$LL4@xmlChildEl:

; 3497 :         if (cur->type == XML_ELEMENT_NODE)
; 3498 :             ret++;
; 3499 :         cur = cur->next;

	cmp	DWORD PTR [ecx+4], 1
	lea	eax, DWORD PTR [edx+1]
	mov	ecx, DWORD PTR [ecx+24]
	cmovne	eax, edx
	mov	edx, eax
	test	ecx, ecx
	jne	SHORT $LL4@xmlChildEl
$LN5@xmlChildEl:

; 3500 :     }
; 3501 :     return(ret);

	mov	eax, edx

; 3502 : }

	pop	ebp
	ret	0
$LN8@xmlChildEl:

; 3492 :             break;
; 3493 :         default:
; 3494 :             return(0);

	xor	eax, eax

; 3502 : }

	pop	ebp
	ret	0
	npad	1
$LN17@xmlChildEl:
	DD	$LN7@xmlChildEl
	DD	$LN8@xmlChildEl
$LN15@xmlChildEl:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
_xmlChildElementCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapCloneNode
_TEXT	SEGMENT
_curElem$1$ = -48					; size = 4
_cloneNsDefSlot$1$ = -44				; size = 4
_cur$1$ = -40						; size = 4
_cloneNs$1$ = -36					; size = 4
_ns$ = -36						; size = 4
_parnsdone$1$ = -32					; size = 4
_resultClone$1$ = -28					; size = 4
_sourceDoc$1$ = -24					; size = 4
_parentClone$1$ = -20					; size = 4
_dict$1$ = -16						; size = 4
_depth$1$ = -12						; size = 4
_nsMap$ = -8						; size = 4
_clone$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_sourceDoc$ = 12					; size = 4
_node$ = 16						; size = 4
_resNode$ = 20						; size = 4
_destDoc$ = 24						; size = 4
_destParent$ = 28					; size = 4
_deep$ = 32						; size = 4
_options$ = 36						; size = 4
_xmlDOMWrapCloneNode PROC				; COMDAT

; 9378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR _curElem$1$[ebp], 0
	mov	DWORD PTR _nsMap$[ebp], esi
	mov	DWORD PTR _depth$1$[ebp], -1
	mov	DWORD PTR _parnsdone$1$[ebp], esi
	mov	DWORD PTR _resultClone$1$[ebp], esi
	mov	DWORD PTR _parentClone$1$[ebp], esi
	test	ecx, ecx
	je	$LN23@xmlDOMWrap

; 9379 :     int ret = 0;
; 9380 :     xmlNodePtr cur, curElem = NULL;
; 9381 :     xmlNsMapPtr nsMap = NULL;
; 9382 :     xmlNsMapItemPtr mi;
; 9383 :     xmlNsPtr ns;
; 9384 :     int depth = -1;
; 9385 :     /* int adoptStr = 1; */
; 9386 :     /* gather @parent's ns-decls. */
; 9387 :     int parnsdone = 0;
; 9388 :     /*
; 9389 :     * @ancestorsOnly:
; 9390 :     * TODO: @ancestorsOnly should be set per option.
; 9391 :     *
; 9392 :     */
; 9393 :     int ancestorsOnly = 0;
; 9394 :     xmlNodePtr resultClone = NULL, clone = NULL, parentClone = NULL, prevClone = NULL;
; 9395 :     xmlNsPtr cloneNs = NULL, *cloneNsDefSlot = NULL;
; 9396 :     xmlDictPtr dict; /* The destination dict */
; 9397 : 
; 9398 :     if ((node == NULL) || (resNode == NULL) || (destDoc == NULL))

	cmp	DWORD PTR _resNode$[ebp], esi
	je	$LN23@xmlDOMWrap
	mov	ebx, DWORD PTR _destDoc$[ebp]
	test	ebx, ebx
	je	$LN23@xmlDOMWrap

; 9399 : 	return(-1);
; 9400 :     /*
; 9401 :     * TODO: Initially we support only element-nodes.
; 9402 :     */
; 9403 :     if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN24@xmlDOMWrap

; 9404 : 	return(1);

	pop	edi
	lea	eax, DWORD PTR [esi+1]

; 9878 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlDOMWrap:

; 9405 :     /*
; 9406 :     * Check node->doc sanity.
; 9407 :     */
; 9408 :     if ((node->doc != NULL) && (sourceDoc != NULL) &&

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _sourceDoc$[ebp]
	mov	DWORD PTR _sourceDoc$1$[ebp], edx
	test	eax, eax
	je	SHORT $LN25@xmlDOMWrap
	test	edx, edx
	je	SHORT $LN190@xmlDOMWrap
	cmp	eax, edx
	jne	$LN23@xmlDOMWrap
$LN25@xmlDOMWrap:

; 9409 : 	(node->doc != sourceDoc)) {
; 9410 : 	/*
; 9411 : 	* Might be an XIncluded node.
; 9412 : 	*/
; 9413 : 	return (-1);
; 9414 :     }
; 9415 :     if (sourceDoc == NULL)

	test	edx, edx
	jne	SHORT $LN27@xmlDOMWrap
$LN190@xmlDOMWrap:

; 9416 : 	sourceDoc = node->doc;

	mov	edx, eax
	mov	DWORD PTR _sourceDoc$1$[ebp], edx

; 9417 :     if (sourceDoc == NULL)

	test	edx, edx
	je	$LN23@xmlDOMWrap
$LN27@xmlDOMWrap:

; 9418 :         return (-1);
; 9419 : 
; 9420 :     dict = destDoc->dict;

	mov	eax, DWORD PTR [ebx+80]
	mov	DWORD PTR _dict$1$[ebp], eax

; 9421 :     /*
; 9422 :     * Reuse the namespace map of the context.
; 9423 :     */
; 9424 :     if (ctxt)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN183@xmlDOMWrap

; 9425 : 	nsMap = (xmlNsMapPtr) ctxt->namespaceMap;

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _nsMap$[ebp], esi
$LN183@xmlDOMWrap:

; 9426 : 
; 9427 :     *resNode = NULL;

	mov	eax, DWORD PTR _resNode$[ebp]

; 9428 : 
; 9429 :     cur = node;

	mov	ebx, ecx
	mov	DWORD PTR _cur$1$[ebp], ebx
	mov	DWORD PTR [eax], edi

; 9430 :     if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	$LN23@xmlDOMWrap
$LL2@xmlDOMWrap:

; 9431 :         return(-1);
; 9432 : 
; 9433 :     while (cur != NULL) {

	test	ebx, ebx
	je	$LN221@xmlDOMWrap

; 9434 : 	if (cur->doc != sourceDoc) {

	cmp	DWORD PTR [ebx+32], edx
	jne	$internal_error$230

; 9435 : 	    /*
; 9436 : 	    * We'll assume XIncluded nodes if the doc differs.
; 9437 : 	    * TODO: Do we need to reconciliate XIncluded nodes?
; 9438 : 	    * TODO: This here returns -1 in this case.
; 9439 : 	    */
; 9440 : 	    goto internal_error;
; 9441 : 	}
; 9442 : 	/*
; 9443 : 	* Create a new node.
; 9444 : 	*/
; 9445 : 	switch (cur->type) {

	mov	eax, DWORD PTR [ebx+4]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	$internal_error$230
	movzx	eax, BYTE PTR $LN212@xmlDOMWrap[eax]
	jmp	DWORD PTR $LN228@xmlDOMWrap[eax*4]
$LN32@xmlDOMWrap:

; 9446 : 	    case XML_XINCLUDE_START:
; 9447 : 	    case XML_XINCLUDE_END:
; 9448 : 		/*
; 9449 : 		* TODO: What to do with XInclude?
; 9450 : 		*/
; 9451 : 		goto internal_error;
; 9452 : 		break;
; 9453 : 	    case XML_ELEMENT_NODE:
; 9454 : 	    case XML_TEXT_NODE:
; 9455 : 	    case XML_CDATA_SECTION_NODE:
; 9456 : 	    case XML_COMMENT_NODE:
; 9457 : 	    case XML_PI_NODE:
; 9458 : 	    case XML_DOCUMENT_FRAG_NODE:
; 9459 : 	    case XML_ENTITY_REF_NODE:
; 9460 : 	    case XML_ENTITY_NODE:
; 9461 : 		/*
; 9462 : 		* Nodes of xmlNode structure.
; 9463 : 		*/
; 9464 : 		clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _clone$1$[ebp], eax

; 9465 : 		if (clone == NULL) {

	test	eax, eax
	je	$LN152@xmlDOMWrap

; 9467 : 		    goto internal_error;
; 9468 : 		}
; 9469 : 		memset(clone, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 9470 : 		/*
; 9471 : 		* Set hierachical links.
; 9472 : 		*/
; 9473 : 		if (resultClone != NULL) {

	cmp	DWORD PTR _resultClone$1$[ebp], 0
	je	SHORT $LN40@xmlDOMWrap

; 9474 : 		    clone->parent = parentClone;

	mov	ecx, DWORD PTR _clone$1$[ebp]
	mov	eax, DWORD PTR _parentClone$1$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 9475 : 		    if (prevClone) {

	test	edi, edi
	je	SHORT $LN36@xmlDOMWrap

; 9476 : 			prevClone->next = clone;

	mov	DWORD PTR [edi+24], ecx

; 9477 : 			clone->prev = prevClone;

	mov	DWORD PTR [ecx+28], edi

; 9478 : 		    } else

	mov	edi, ecx
	jmp	SHORT $LN41@xmlDOMWrap
$LN36@xmlDOMWrap:

; 9479 : 			parentClone->children = clone;

	mov	edi, DWORD PTR _clone$1$[ebp]
	mov	DWORD PTR [eax+12], edi

; 9480 : 		} else
; 9481 : 		    resultClone = clone;
; 9482 : 
; 9483 : 		break;

	jmp	SHORT $LN41@xmlDOMWrap
$LN38@xmlDOMWrap:

; 9484 : 	    case XML_ATTRIBUTE_NODE:
; 9485 : 		/*
; 9486 : 		* Attributes (xmlAttr).
; 9487 : 		*/
; 9488 : 		clone = (xmlNodePtr) xmlMalloc(sizeof(xmlAttr));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _clone$1$[ebp], eax

; 9489 : 		if (clone == NULL) {

	test	eax, eax
	je	$LN153@xmlDOMWrap

; 9491 : 		    goto internal_error;
; 9492 : 		}
; 9493 : 		memset(clone, 0, sizeof(xmlAttr));

	push	48					; 00000030H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 9494 : 		/*
; 9495 : 		* Set hierachical links.
; 9496 : 		* TODO: Change this to add to the end of attributes.
; 9497 : 		*/
; 9498 : 		if (resultClone != NULL) {

	cmp	DWORD PTR _resultClone$1$[ebp], 0
	je	SHORT $LN40@xmlDOMWrap

; 9499 : 		    clone->parent = parentClone;

	mov	ecx, DWORD PTR _clone$1$[ebp]
	mov	eax, DWORD PTR _parentClone$1$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 9500 : 		    if (prevClone) {

	test	edi, edi
	je	SHORT $LN42@xmlDOMWrap

; 9501 : 			prevClone->next = clone;

	mov	DWORD PTR [edi+24], ecx

; 9502 : 			clone->prev = prevClone;

	mov	DWORD PTR [ecx+28], edi

; 9503 : 		    } else

	mov	edi, ecx
	jmp	SHORT $LN41@xmlDOMWrap
$LN42@xmlDOMWrap:

; 9504 : 			parentClone->properties = (xmlAttrPtr) clone;

	mov	edi, DWORD PTR _clone$1$[ebp]
	mov	DWORD PTR [eax+44], edi

; 9505 : 		} else
; 9506 : 		    resultClone = clone;
; 9507 : 		break;
; 9508 : 	    default:
; 9509 : 		/*
; 9510 : 		* TODO QUESTION: Any other nodes expected?
; 9511 : 		*/
; 9512 : 		goto internal_error;
; 9513 : 	}
; 9514 : 
; 9515 : 	clone->type = cur->type;

	jmp	SHORT $LN41@xmlDOMWrap
$LN40@xmlDOMWrap:
	mov	edi, DWORD PTR _clone$1$[ebp]
	mov	DWORD PTR _resultClone$1$[ebp], edi
$LN41@xmlDOMWrap:
	mov	eax, DWORD PTR [ebx+4]

; 9516 : 	clone->doc = destDoc;

	mov	ecx, DWORD PTR _destDoc$[ebp]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+32], ecx

; 9517 : 
; 9518 : 	/*
; 9519 : 	* Clone the name of the node if any.
; 9520 : 	*/
; 9521 : 	if (cur->name == xmlStringText)

	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, OFFSET _xmlStringText
	jne	SHORT $LN45@xmlDOMWrap

; 9522 : 	    clone->name = xmlStringText;

	mov	DWORD PTR [edi+8], OFFSET _xmlStringText
	jmp	SHORT $LN54@xmlDOMWrap
$LN45@xmlDOMWrap:

; 9523 : 	else if (cur->name == xmlStringTextNoenc)

	cmp	eax, OFFSET _xmlStringTextNoenc
	jne	SHORT $LN47@xmlDOMWrap

; 9524 : 	    /*
; 9525 : 	    * NOTE: Although xmlStringTextNoenc is never assigned to a node
; 9526 : 	    *   in tree.c, it might be set in Libxslt via
; 9527 : 	    *   "xsl:disable-output-escaping".
; 9528 : 	    */
; 9529 : 	    clone->name = xmlStringTextNoenc;

	mov	DWORD PTR [edi+8], OFFSET _xmlStringTextNoenc
	jmp	SHORT $LN54@xmlDOMWrap
$LN47@xmlDOMWrap:

; 9530 : 	else if (cur->name == xmlStringComment)

	cmp	eax, OFFSET _xmlStringComment
	jne	SHORT $LN49@xmlDOMWrap

; 9531 : 	    clone->name = xmlStringComment;

	mov	DWORD PTR [edi+8], OFFSET _xmlStringComment
	jmp	SHORT $LN54@xmlDOMWrap
$LN49@xmlDOMWrap:

; 9532 : 	else if (cur->name != NULL) {

	test	eax, eax
	je	SHORT $LN54@xmlDOMWrap

; 9533 : 	    DICT_CONST_COPY(cur->name, clone->name);

	mov	ecx, DWORD PTR _dict$1$[ebp]
	push	eax
	test	ecx, ecx
	je	SHORT $LN53@xmlDOMWrap
	push	ecx
	call	_xmlDictOwns
	mov	ecx, DWORD PTR [ebx+8]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN56@xmlDOMWrap
	push	-1
	push	ecx
	push	DWORD PTR _dict$1$[ebp]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, eax
$LN56@xmlDOMWrap:
	mov	DWORD PTR [edi+8], ecx
	jmp	SHORT $LN223@xmlDOMWrap
$LN53@xmlDOMWrap:
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+8], eax
$LN223@xmlDOMWrap:

; 9534 : 	}
; 9535 : 
; 9536 : 	switch (cur->type) {

	mov	ecx, DWORD PTR _destDoc$[ebp]
$LN54@xmlDOMWrap:
	mov	eax, DWORD PTR [ebx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	$internal_error$230
	movzx	eax, BYTE PTR $LN213@xmlDOMWrap[eax]
	jmp	DWORD PTR $LN229@xmlDOMWrap[eax*4]
$LN58@xmlDOMWrap:

; 9537 : 	    case XML_XINCLUDE_START:
; 9538 : 	    case XML_XINCLUDE_END:
; 9539 : 		/*
; 9540 : 		* TODO
; 9541 : 		*/
; 9542 : 		return (-1);
; 9543 : 	    case XML_ELEMENT_NODE:
; 9544 : 		curElem = cur;
; 9545 : 		depth++;

	inc	DWORD PTR _depth$1$[ebp]

; 9546 : 		/*
; 9547 : 		* Namespace declarations.
; 9548 : 		*/
; 9549 : 		if (cur->nsDef != NULL) {

	mov	edi, DWORD PTR [ebx+48]
	mov	DWORD PTR _curElem$1$[ebp], ebx
	test	edi, edi
	je	$LN219@xmlDOMWrap

; 9550 : 		    if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	jne	SHORT $LN60@xmlDOMWrap

; 9551 : 			if (destParent && (ctxt == NULL)) {

	mov	eax, DWORD PTR _destParent$[ebp]
	test	eax, eax
	je	SHORT $LN62@xmlDOMWrap
	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN62@xmlDOMWrap

; 9552 : 			    /*
; 9553 : 			    * Gather @parent's in-scope ns-decls.
; 9554 : 			    */
; 9555 : 			    if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 9556 : 				destParent) == -1)

	push	eax
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	add	esp, 8
	cmp	eax, -1
	je	$LN214@xmlDOMWrap
	mov	esi, DWORD PTR _nsMap$[ebp]
$LN62@xmlDOMWrap:

; 9557 : 				goto internal_error;
; 9558 : 			}
; 9559 : 			parnsdone = 1;

	mov	edi, DWORD PTR [ebx+48]
	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN60@xmlDOMWrap:

; 9560 : 		    }
; 9561 : 		    /*
; 9562 : 		    * Clone namespace declarations.
; 9563 : 		    */
; 9564 : 		    cloneNsDefSlot = &(clone->nsDef);

	mov	eax, DWORD PTR _clone$1$[ebp]
	add	eax, 48					; 00000030H

; 9565 : 		    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	DWORD PTR _ns$[ebp], edi
	mov	DWORD PTR _cloneNsDefSlot$1$[ebp], eax
	test	edi, edi
	je	$LN219@xmlDOMWrap
$LL10@xmlDOMWrap:

; 9566 : 			/*
; 9567 : 			* Create a new xmlNs.
; 9568 : 			*/
; 9569 : 			cloneNs = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _cloneNs$1$[ebp], ebx

; 9570 : 			if (cloneNs == NULL) {

	test	ebx, ebx
	je	$LN146@xmlDOMWrap

; 9572 : 				"allocating namespace");
; 9573 : 			    return(-1);
; 9574 : 			}
; 9575 : 			memset(cloneNs, 0, sizeof(xmlNs));

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ebx], xmm0
	movq	QWORD PTR [ebx+16], xmm0

; 9576 : 			cloneNs->type = XML_LOCAL_NAMESPACE;

	mov	DWORD PTR [ebx+4], 18			; 00000012H

; 9577 : 
; 9578 : 			if (ns->href != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN64@xmlDOMWrap

; 9579 : 			    cloneNs->href = xmlStrdup(ns->href);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax
$LN64@xmlDOMWrap:

; 9580 : 			if (ns->prefix != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN65@xmlDOMWrap

; 9581 : 			    cloneNs->prefix = xmlStrdup(ns->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+12], eax
$LN65@xmlDOMWrap:

; 9582 : 
; 9583 : 			*cloneNsDefSlot = cloneNs;

	mov	eax, DWORD PTR _cloneNsDefSlot$1$[ebp]

; 9584 : 			cloneNsDefSlot = &(cloneNs->next);

	mov	DWORD PTR _cloneNsDefSlot$1$[ebp], ebx
	mov	DWORD PTR [eax], ebx

; 9585 : 
; 9586 : 			/*
; 9587 : 			* Note that for custom handling of ns-references,
; 9588 : 			* the ns-decls need not be stored in the ns-map,
; 9589 : 			* since they won't be referenced by node->ns.
; 9590 : 			*/
; 9591 : 			if ((ctxt == NULL) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN67@xmlDOMWrap
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN8@xmlDOMWrap
$LN67@xmlDOMWrap:

; 9592 : 			    (ctxt->getNsForNodeFunc == NULL))
; 9593 : 			{
; 9594 : 			    /*
; 9595 : 			    * Does it shadow any ns-decl?
; 9596 : 			    */
; 9597 : 			    if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN12@xmlDOMWrap
	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN12@xmlDOMWrap
	mov	ebx, DWORD PTR _depth$1$[ebp]
	npad	7
$LL13@xmlDOMWrap:

; 9599 : 				    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&
; 9600 : 					(mi->shadowDepth == -1) &&

	cmp	DWORD PTR [esi+20], -1
	jl	SHORT $LN11@xmlDOMWrap
	cmp	DWORD PTR [esi+16], -1
	jne	SHORT $LN11@xmlDOMWrap
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN70@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlDOMWrap
$LN70@xmlDOMWrap:

; 9601 : 					((ns->prefix == mi->newNs->prefix) ||
; 9602 : 					xmlStrEqual(ns->prefix,
; 9603 : 					mi->newNs->prefix))) {
; 9604 : 					/*
; 9605 : 					* Mark as shadowed at the current
; 9606 : 					* depth.
; 9607 : 					*/
; 9608 : 					mi->shadowDepth = depth;

	mov	DWORD PTR [esi+16], ebx
$LN11@xmlDOMWrap:

; 9598 : 				XML_NSMAP_FOREACH(nsMap, mi) {

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL13@xmlDOMWrap
	mov	ebx, DWORD PTR _cloneNs$1$[ebp]
$LN12@xmlDOMWrap:

; 9609 : 				    }
; 9610 : 				}
; 9611 : 			    }
; 9612 : 			    /*
; 9613 : 			    * Push mapping.
; 9614 : 			    */
; 9615 : 			    if (xmlDOMWrapNsMapAddItem(&nsMap, -1,
; 9616 : 				ns, cloneNs, depth) == NULL)

	push	DWORD PTR _depth$1$[ebp]
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	ebx
	push	edi
	push	-1
	push	eax
	call	_xmlDOMWrapNsMapAddItem
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN214@xmlDOMWrap
	mov	esi, DWORD PTR _nsMap$[ebp]
$LN8@xmlDOMWrap:

; 9565 : 		    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _ns$[ebp], edi
	test	edi, edi
	jne	$LL10@xmlDOMWrap
	mov	ebx, DWORD PTR _cur$1$[ebp]
$LN219@xmlDOMWrap:

; 9661 : 	    case XML_PI_NODE:
; 9662 : 		DICT_COPY(cur->content, clone->content);
; 9663 : 		goto leave_node;
; 9664 : 	    case XML_COMMENT_NODE:
; 9665 : 		DICT_COPY(cur->content, clone->content);
; 9666 : 		goto leave_node;
; 9667 : 	    default:
; 9668 : 		goto internal_error;
; 9669 : 	}
; 9670 : 
; 9671 : 	if (cur->ns == NULL)

	mov	edi, DWORD PTR _clone$1$[ebp]
$LN9@xmlDOMWrap:
	cmp	DWORD PTR [ebx+36], 0
	je	$end_ns_reference$231

; 9672 : 	    goto end_ns_reference;
; 9673 : 
; 9674 : /* handle_ns_reference: */
; 9675 : 	/*
; 9676 : 	** The following will take care of references to ns-decls ********
; 9677 : 	** and is intended only for element- and attribute-nodes.
; 9678 : 	**
; 9679 : 	*/
; 9680 : 	if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	jne	SHORT $LN100@xmlDOMWrap

; 9681 : 	    if (destParent && (ctxt == NULL)) {

	mov	eax, DWORD PTR _destParent$[ebp]
	test	eax, eax
	je	SHORT $LN102@xmlDOMWrap
	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN102@xmlDOMWrap

; 9682 : 		if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap, destParent) == -1)

	push	eax
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	add	esp, 8
	cmp	eax, -1
	je	$LN214@xmlDOMWrap
	mov	esi, DWORD PTR _nsMap$[ebp]
$LN102@xmlDOMWrap:

; 9683 : 		    goto internal_error;
; 9684 : 	    }
; 9685 : 	    parnsdone = 1;

	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN100@xmlDOMWrap:

; 9686 : 	}
; 9687 : 	/*
; 9688 : 	* Adopt ns-references.
; 9689 : 	*/
; 9690 : 	if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN211@xmlDOMWrap
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN211@xmlDOMWrap
	npad	5
$LL16@xmlDOMWrap:

; 9695 : 		if ((mi->shadowDepth == -1) &&

	cmp	DWORD PTR [ecx+16], -1
	jne	SHORT $LN14@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+36]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN148@xmlDOMWrap
$LN14@xmlDOMWrap:

; 9691 : 	    /*
; 9692 : 	    * Search for a mapping.
; 9693 : 	    */
; 9694 : 	    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL16@xmlDOMWrap
$LN211@xmlDOMWrap:

; 9702 : 		}
; 9703 : 	    }
; 9704 : 	}
; 9705 : 	/*
; 9706 : 	* No matching namespace in scope. We need a new one.
; 9707 : 	*/
; 9708 : 	if ((ctxt != NULL) && (ctxt->getNsForNodeFunc != NULL)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN105@xmlDOMWrap
	mov	ecx, DWORD PTR [edx+12]
	test	ecx, ecx
	je	SHORT $LN105@xmlDOMWrap

; 9709 : 	    /*
; 9710 : 	    * User-defined behaviour.
; 9711 : 	    */
; 9712 : 	    ns = ctxt->getNsForNodeFunc(ctxt, cur,

	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	ebx
	push	edx
	call	ecx
	mov	esi, eax

; 9713 : 		cur->ns->href, cur->ns->prefix);
; 9714 : 	    /*
; 9715 : 	    * Add user's mapping.
; 9716 : 	    */
; 9717 : 	    if (xmlDOMWrapNsMapAddItem(&nsMap, -1,
; 9718 : 		cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)

	lea	eax, DWORD PTR _nsMap$[ebp]
	push	-4					; fffffffcH
	push	esi
	push	DWORD PTR [ebx+36]
	mov	DWORD PTR _ns$[ebp], esi
	push	-1
	push	eax
	call	_xmlDOMWrapNsMapAddItem
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN214@xmlDOMWrap

; 9719 : 		goto internal_error;
; 9720 : 	    clone->ns = ns;

	mov	DWORD PTR [edi+36], esi

; 9721 : 	} else {

	mov	esi, DWORD PTR _nsMap$[ebp]
	jmp	SHORT $end_ns_reference$231
$LN148@xmlDOMWrap:

; 9696 : 		    (cur->ns == mi->oldNs)) {
; 9697 : 		    /*
; 9698 : 		    * This is the nice case: a mapping was found.
; 9699 : 		    */
; 9700 : 		    clone->ns = mi->newNs;

	mov	eax, DWORD PTR [ecx+12]

; 9701 : 		    goto end_ns_reference;

	jmp	SHORT $LN224@xmlDOMWrap
$LN105@xmlDOMWrap:

; 9722 : 	    /*
; 9723 : 	    * Aquire a normalized ns-decl and add it to the map.
; 9724 : 	    */
; 9725 : 	    if (xmlDOMWrapNSNormAquireNormalizedNs(destDoc,
; 9726 : 		/* ns-decls on curElem or on destDoc->oldNs */
; 9727 : 		destParent ? curElem : NULL,
; 9728 : 		cur->ns, &ns,
; 9729 : 		&nsMap, depth,
; 9730 : 		/* if we need to search only in the ancestor-axis */
; 9731 : 		ancestorsOnly,
; 9732 : 		/* ns-decls must be prefixed for attributes. */
; 9733 : 		(cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)

	xor	eax, eax
	cmp	DWORD PTR [ebx+4], 2
	sete	al
	push	eax
	push	0
	push	DWORD PTR _depth$1$[ebp]
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	lea	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	DWORD PTR [ebx+36]
	xor	eax, eax
	cmp	DWORD PTR _destParent$[ebp], eax
	cmovne	eax, DWORD PTR _curElem$1$[ebp]
	push	eax
	push	DWORD PTR _destDoc$[ebp]
	call	_xmlDOMWrapNSNormAquireNormalizedNs
	add	esp, 32					; 00000020H
	cmp	eax, -1
	je	$LN214@xmlDOMWrap

; 9734 : 		goto internal_error;
; 9735 : 	    clone->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	esi, DWORD PTR _nsMap$[ebp]
$LN224@xmlDOMWrap:

; 9736 : 	}
; 9737 : 
; 9738 : end_ns_reference:
; 9739 : 
; 9740 : 	/*
; 9741 : 	* Some post-processing.
; 9742 : 	*
; 9743 : 	* Handle ID attributes.
; 9744 : 	*/
; 9745 : 	if ((clone->type == XML_ATTRIBUTE_NODE) &&

	mov	DWORD PTR [edi+36], eax
$end_ns_reference$231:
	cmp	DWORD PTR [edi+4], 2
	jne	SHORT $LN111@xmlDOMWrap
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN111@xmlDOMWrap

; 9746 : 	    (clone->parent != NULL))
; 9747 : 	{
; 9748 : 	    if (xmlIsID(destDoc, clone->parent, (xmlAttrPtr) clone)) {

	push	edi
	push	eax
	push	DWORD PTR _destDoc$[ebp]
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN111@xmlDOMWrap

; 9749 : 
; 9750 : 		xmlChar *idVal;
; 9751 : 
; 9752 : 		idVal = xmlNodeListGetString(cur->doc, cur->children, 1);

	push	1
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+32]
	call	_xmlNodeListGetString
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 9753 : 		if (idVal != NULL) {

	test	edi, edi
	je	SHORT $LN217@xmlDOMWrap

; 9754 : 		    if (xmlAddID(NULL, destDoc, idVal, (xmlAttrPtr) cur) == NULL) {

	push	ebx
	push	edi
	push	DWORD PTR _destDoc$[ebp]
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
	push	edi
	test	eax, eax
	je	$LN158@xmlDOMWrap

; 9757 : 			goto internal_error;
; 9758 : 		    }
; 9759 : 		    xmlFree(idVal);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN217@xmlDOMWrap:

; 9760 : 		}
; 9761 : 	    }
; 9762 : 	}
; 9763 : 	/*
; 9764 : 	**
; 9765 : 	** The following will traverse the tree **************************
; 9766 : 	**
; 9767 : 	*
; 9768 : 	* Walk the element's attributes before descending into child-nodes.
; 9769 : 	*/
; 9770 : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->properties != NULL)) {

	mov	edi, DWORD PTR _clone$1$[ebp]
$LN111@xmlDOMWrap:
	cmp	DWORD PTR [ebx+4], 1
	jne	$into_content$232
	mov	eax, DWORD PTR [ebx+44]
	test	eax, eax
	je	$into_content$232
$LN116@xmlDOMWrap:

; 9431 :         return(-1);
; 9432 : 
; 9433 :     while (cur != NULL) {

	mov	ecx, DWORD PTR _clone$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR _parentClone$1$[ebp], ecx
$LN150@xmlDOMWrap:
	mov	edx, DWORD PTR _sourceDoc$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR _cur$1$[ebp], ebx
	jmp	$LL2@xmlDOMWrap
$LN73@xmlDOMWrap:

; 9786 : 	    }
; 9787 : 	}
; 9788 : 
; 9789 : leave_node:
; 9790 : 	/*
; 9791 : 	* At this point we are done with the node, its content
; 9792 : 	* and an element-nodes's attribute-nodes.
; 9793 : 	*/
; 9794 : 	if (cur == node)

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	$leave_node$233
	mov	ecx, DWORD PTR _dict$1$[ebp]
	push	eax
	test	ecx, ecx
	je	SHORT $LN75@xmlDOMWrap
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	SHORT $LN77@xmlDOMWrap
	mov	eax, DWORD PTR [ebx+40]
	jmp	SHORT $LN78@xmlDOMWrap
$LN77@xmlDOMWrap:
	push	-1
	push	DWORD PTR [ebx+40]
	push	DWORD PTR _dict$1$[ebp]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN78@xmlDOMWrap
$LN80@xmlDOMWrap:

; 9617 : 				goto internal_error;
; 9618 : 			}
; 9619 : 		    }
; 9620 : 		}
; 9621 : 		/* cur->ns will be processed further down. */
; 9622 : 		break;
; 9623 : 	    case XML_ATTRIBUTE_NODE:
; 9624 : 		/* IDs will be processed further down. */
; 9625 : 		/* cur->ns will be processed further down. */
; 9626 : 		break;
; 9627 : 	    case XML_TEXT_NODE:
; 9628 : 	    case XML_CDATA_SECTION_NODE:
; 9629 : 		/*
; 9630 : 		* Note that this will also cover the values of attributes.
; 9631 : 		*/
; 9632 : 		DICT_COPY(cur->content, clone->content);
; 9633 : 		goto leave_node;
; 9634 : 	    case XML_ENTITY_NODE:
; 9635 : 		/* TODO: What to do here? */
; 9636 : 		goto leave_node;
; 9637 : 	    case XML_ENTITY_REF_NODE:
; 9638 : 		if (sourceDoc != destDoc) {

	cmp	DWORD PTR _sourceDoc$1$[ebp], ecx
	je	SHORT $LN81@xmlDOMWrap

; 9639 : 		    if ((destDoc->intSubset) || (destDoc->extSubset)) {

	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN84@xmlDOMWrap
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $leave_node$233
$LN84@xmlDOMWrap:

; 9640 : 			xmlEntityPtr ent;
; 9641 : 			/*
; 9642 : 			* Different doc: Assign new entity-node if available.
; 9643 : 			*/
; 9644 : 			ent = xmlGetDocEntity(destDoc, cur->name);

	push	DWORD PTR [ebx+8]
	push	ecx
	call	_xmlGetDocEntity
	mov	ecx, eax
	add	esp, 8

; 9645 : 			if (ent != NULL) {

	test	ecx, ecx
	je	SHORT $leave_node$233

; 9646 : 			    clone->content = ent->content;

	mov	eax, DWORD PTR [ecx+40]

; 9647 : 			    clone->children = (xmlNodePtr) ent;

	mov	DWORD PTR [edi+12], ecx

; 9648 : 			    clone->last = (xmlNodePtr) ent;

	mov	DWORD PTR [edi+16], ecx

; 9649 : 			}
; 9650 : 		    }
; 9651 : 		} else {

	jmp	SHORT $LN78@xmlDOMWrap
$LN81@xmlDOMWrap:

; 9652 : 		    /*
; 9653 : 		    * Same doc: Use the current node's entity declaration
; 9654 : 		    * and value.
; 9655 : 		    */
; 9656 : 		    clone->content = cur->content;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [edi+40], eax

; 9657 : 		    clone->children = cur->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], eax

; 9658 : 		    clone->last = cur->last;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+16], eax

; 9659 : 		}
; 9660 : 		goto leave_node;

	jmp	SHORT $leave_node$233
$LN75@xmlDOMWrap:

; 9786 : 	    }
; 9787 : 	}
; 9788 : 
; 9789 : leave_node:
; 9790 : 	/*
; 9791 : 	* At this point we are done with the node, its content
; 9792 : 	* and an element-nodes's attribute-nodes.
; 9793 : 	*/
; 9794 : 	if (cur == node)

	call	_xmlStrdup
	add	esp, 4
$LN78@xmlDOMWrap:
	mov	DWORD PTR [edi+40], eax
$leave_node$233:
	cmp	ebx, DWORD PTR _node$[ebp]
	je	$LN221@xmlDOMWrap

; 9795 : 	    break;
; 9796 : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 9797 : 	    (cur->type == XML_XINCLUDE_START) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	je	SHORT $LN119@xmlDOMWrap
	cmp	eax, 19					; 00000013H
	je	SHORT $LN119@xmlDOMWrap
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN118@xmlDOMWrap
$LN119@xmlDOMWrap:

; 9798 : 	    (cur->type == XML_XINCLUDE_END)) {
; 9799 : 	    /*
; 9800 : 	    * TODO: Do we expect nsDefs on XML_XINCLUDE_START?
; 9801 : 	    */
; 9802 : 	    if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN20@xmlDOMWrap
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN20@xmlDOMWrap

; 9803 : 		/*
; 9804 : 		* Pop mappings.
; 9805 : 		*/
; 9806 : 		while ((nsMap->last != NULL) &&

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _depth$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@xmlDOMWrap
$LL17@xmlDOMWrap:
	cmp	DWORD PTR [ecx+20], edx
	jl	SHORT $LN18@xmlDOMWrap

; 9807 : 		    (nsMap->last->depth >= depth))
; 9808 : 		{
; 9809 : 		    XML_NSMAP_POP(nsMap, mi)

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN121@xmlDOMWrap
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN122@xmlDOMWrap
$LN121@xmlDOMWrap:
	mov	DWORD PTR [eax], 0
$LN122@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LL17@xmlDOMWrap
$LN18@xmlDOMWrap:

; 9810 : 		}
; 9811 : 		/*
; 9812 : 		* Unshadow.
; 9813 : 		*/
; 9814 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@xmlDOMWrap
$LL21@xmlDOMWrap:

; 9815 : 		    if (mi->shadowDepth >= depth)

	cmp	DWORD PTR [eax+16], edx
	jl	SHORT $LN19@xmlDOMWrap

; 9816 : 			mi->shadowDepth = -1;

	mov	DWORD PTR [eax+16], -1
$LN19@xmlDOMWrap:

; 9810 : 		}
; 9811 : 		/*
; 9812 : 		* Unshadow.
; 9813 : 		*/
; 9814 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL21@xmlDOMWrap
$LN20@xmlDOMWrap:

; 9817 : 		}
; 9818 : 	    }
; 9819 : 	    depth--;

	dec	DWORD PTR _depth$1$[ebp]
$LN118@xmlDOMWrap:

; 9820 : 	}
; 9821 : 	if (cur->next != NULL) {

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	jne	$LN150@xmlDOMWrap

; 9822 : 	    prevClone = clone;
; 9823 : 	    cur = cur->next;
; 9824 : 	} else if (cur->type != XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [ebx+4], 2
	je	SHORT $LN126@xmlDOMWrap

; 9825 : 	    /*
; 9826 : 	    * Set clone->last.
; 9827 : 	    */
; 9828 : 	    if (clone->parent != NULL)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN204@xmlDOMWrap

; 9829 : 		clone->parent->last = clone;

	mov	DWORD PTR [eax+16], edi
	mov	eax, DWORD PTR [edi+20]
$LN204@xmlDOMWrap:

; 9830 : 	    clone = clone->parent;

	mov	edi, eax

; 9831 : 	    if (clone != NULL)

	test	eax, eax
	je	SHORT $LN129@xmlDOMWrap

; 9832 : 		parentClone = clone->parent;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _parentClone$1$[ebp], eax
$LN129@xmlDOMWrap:

; 9833 : 	    /*
; 9834 : 	    * Process parent --> next;
; 9835 : 	    */
; 9836 : 	    cur = cur->parent;

	mov	ebx, DWORD PTR [ebx+20]

; 9837 : 	    goto leave_node;

	jmp	$leave_node$233
$LN126@xmlDOMWrap:

; 9838 : 	} else {
; 9839 : 	    /* This is for attributes only. */
; 9840 : 	    clone = clone->parent;

	mov	edi, DWORD PTR [edi+20]

; 9841 : 	    parentClone = clone->parent;
; 9842 : 	    /*
; 9843 : 	    * Process parent-element --> children.
; 9844 : 	    */
; 9845 : 	    cur = cur->parent;

	mov	ebx, DWORD PTR [ebx+20]
	mov	DWORD PTR _clone$1$[ebp], edi
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _parentClone$1$[ebp], eax
$into_content$232:

; 9771 : 	    prevClone = NULL;
; 9772 : 	    parentClone = clone;
; 9773 : 	    cur = (xmlNodePtr) cur->properties;
; 9774 : 	    continue;
; 9775 : 	}
; 9776 : into_content:
; 9777 : 	/*
; 9778 : 	* Descend into child-nodes.
; 9779 : 	*/
; 9780 : 	if (cur->children != NULL) {

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	$leave_node$233

; 9781 : 	    if (deep || (cur->type == XML_ATTRIBUTE_NODE)) {

	cmp	DWORD PTR _deep$[ebp], 0
	jne	$LN116@xmlDOMWrap
	cmp	DWORD PTR [ebx+4], 2
	jne	$leave_node$233

; 9782 : 		prevClone = NULL;
; 9783 : 		parentClone = clone;
; 9784 : 		cur = cur->children;
; 9785 : 		continue;

	jmp	$LN116@xmlDOMWrap
$LN152@xmlDOMWrap:

; 9466 : 		    xmlTreeErrMemory("xmlDOMWrapCloneNode(): allocating a node");

	push	OFFSET ??_C@_0CJ@IBBFFAIA@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@

; 9846 : 	    goto into_content;
; 9847 : 	}
; 9848 :     }
; 9849 :     goto exit;
; 9850 : 
; 9851 : internal_error:
; 9852 :     ret = -1;

	call	_xmlTreeErrMemory
	add	esp, 4
	or	ebx, -1
	jmp	SHORT $exit$234
$LN146@xmlDOMWrap:

; 9571 : 			    xmlTreeErrMemory("xmlDOMWrapCloneNode(): "

	push	OFFSET ??_C@_0CM@EDBMOGPG@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@
	call	_xmlTreeErrMemory
	add	esp, 4
$LN23@xmlDOMWrap:

; 9878 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN214@xmlDOMWrap:

; 9552 : 			    /*
; 9553 : 			    * Gather @parent's in-scope ns-decls.
; 9554 : 			    */
; 9555 : 			    if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 9556 : 				destParent) == -1)

	mov	esi, DWORD PTR _nsMap$[ebp]

; 9846 : 	    goto into_content;
; 9847 : 	}
; 9848 :     }
; 9849 :     goto exit;
; 9850 : 
; 9851 : internal_error:
; 9852 :     ret = -1;

	or	ebx, -1
	jmp	SHORT $exit$234
$LN158@xmlDOMWrap:

; 9755 : 			/* TODO: error message. */
; 9756 : 			xmlFree(idVal);

	call	DWORD PTR _xmlFree

; 9846 : 	    goto into_content;
; 9847 : 	}
; 9848 :     }
; 9849 :     goto exit;
; 9850 : 
; 9851 : internal_error:
; 9852 :     ret = -1;

	add	esp, 4
	or	ebx, -1
	jmp	SHORT $exit$234
$LN153@xmlDOMWrap:

; 9490 : 		    xmlTreeErrMemory("xmlDOMWrapCloneNode(): allocating an attr-node");

	push	OFFSET ??_C@_0CP@CMDBBNPE@xmlDOMWrapCloneNode?$CI?$CJ?3?5allocati@

; 9846 : 	    goto into_content;
; 9847 : 	}
; 9848 :     }
; 9849 :     goto exit;
; 9850 : 
; 9851 : internal_error:
; 9852 :     ret = -1;

	call	_xmlTreeErrMemory
	add	esp, 4
$internal_error$230:
	or	ebx, -1
	jmp	SHORT $exit$234
$LN221@xmlDOMWrap:

; 9853 : 
; 9854 : exit:
; 9855 :     /*
; 9856 :     * Cleanup.
; 9857 :     */
; 9858 :     if (nsMap != NULL) {

	xor	ebx, ebx
$exit$234:
	test	esi, esi
	je	SHORT $LN132@xmlDOMWrap

; 9859 : 	if ((ctxt) && (ctxt->namespaceMap == nsMap)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN131@xmlDOMWrap
	cmp	DWORD PTR [eax+8], esi
	jne	SHORT $LN131@xmlDOMWrap

; 9860 : 	    /*
; 9861 : 	    * Just cleanup the map but don't free.
; 9862 : 	    */
; 9863 : 	    if (nsMap->first) {

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN132@xmlDOMWrap

; 9864 : 		if (nsMap->pool)

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN134@xmlDOMWrap

; 9865 : 		    nsMap->last->next = nsMap->pool;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
$LN134@xmlDOMWrap:

; 9866 : 		nsMap->pool = nsMap->first;

	mov	eax, DWORD PTR [esi]

; 9871 :     }
; 9872 :     /*
; 9873 :     * TODO: Should we try a cleanup of the cloned node in case of a
; 9874 :     * fatal error?
; 9875 :     */
; 9876 :     *resNode = resultClone;

	mov	ecx, DWORD PTR _resNode$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _resultClone$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [ecx], eax

; 9877 :     return (ret);

	mov	eax, ebx

; 9878 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN131@xmlDOMWrap:

; 9867 : 		nsMap->first = NULL;
; 9868 : 	    }
; 9869 : 	} else
; 9870 : 	    xmlDOMWrapNsMapFree(nsMap);

	push	esi
	call	_xmlDOMWrapNsMapFree
	add	esp, 4
$LN132@xmlDOMWrap:

; 9871 :     }
; 9872 :     /*
; 9873 :     * TODO: Should we try a cleanup of the cloned node in case of a
; 9874 :     * fatal error?
; 9875 :     */
; 9876 :     *resNode = resultClone;

	mov	ecx, DWORD PTR _resNode$[ebp]
	mov	eax, DWORD PTR _resultClone$1$[ebp]
	pop	edi

; 9878 : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN228@xmlDOMWrap:
	DD	$LN32@xmlDOMWrap
	DD	$LN38@xmlDOMWrap
	DD	$internal_error$230
$LN212@xmlDOMWrap:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	npad	1
$LN229@xmlDOMWrap:
	DD	$LN58@xmlDOMWrap
	DD	$LN9@xmlDOMWrap
	DD	$LN73@xmlDOMWrap
	DD	$LN80@xmlDOMWrap
	DD	$leave_node$233
	DD	$LN23@xmlDOMWrap
	DD	$internal_error$230
$LN213@xmlDOMWrap:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	2
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	5
_xmlDOMWrapCloneNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapRemoveNode
_TEXT	SEGMENT
_sizeList$ = -8						; size = 4
_list$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_nbList$ = 16						; size = 4
_node$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlDOMWrapRemoveNode PROC				; COMDAT

; 8220 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _list$[ebp], ebx
	test	esi, esi
	je	$LN16@xmlDOMWrap

; 8221 :     xmlNsPtr *list = NULL;
; 8222 :     int sizeList, nbList, i, j;
; 8223 :     xmlNsPtr ns;
; 8224 : 
; 8225 :     if ((node == NULL) || (doc == NULL) || (node->doc != doc))

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	$LN16@xmlDOMWrap
	cmp	DWORD PTR [esi+32], eax
	jne	$LN16@xmlDOMWrap

; 8226 : 	return (-1);
; 8227 : 
; 8228 :     /* TODO: 0 or -1 ? */
; 8229 :     if (node->parent == NULL)

	cmp	DWORD PTR [esi+20], ebx
	je	SHORT $LN39@xmlDOMWrap

; 8230 : 	return (0);
; 8231 : 
; 8232 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 7
	ja	$LN20@xmlDOMWrap
	movzx	eax, BYTE PTR $LN75@xmlDOMWrap[eax]
	jmp	DWORD PTR $LN84@xmlDOMWrap[eax*4]
$LN18@xmlDOMWrap:

; 8233 : 	case XML_TEXT_NODE:
; 8234 : 	case XML_CDATA_SECTION_NODE:
; 8235 : 	case XML_ENTITY_REF_NODE:
; 8236 : 	case XML_PI_NODE:
; 8237 : 	case XML_COMMENT_NODE:
; 8238 : 	    xmlUnlinkNode(node);

	push	esi
	call	_xmlUnlinkNode

; 8333 :     return (-1);
; 8334 : }

	add	esp, 4
$LN39@xmlDOMWrap:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlDOMWrap:

; 8239 : 	    return (0);
; 8240 : 	case XML_ELEMENT_NODE:
; 8241 : 	case XML_ATTRIBUTE_NODE:
; 8242 : 	    break;
; 8243 : 	default:
; 8244 : 	    return (1);
; 8245 :     }
; 8246 :     xmlUnlinkNode(node);

	push	esi
	call	_xmlUnlinkNode
	add	esp, 4
$LL6@xmlDOMWrap:

; 8247 :     /*
; 8248 :     * Save out-of-scope ns-references in doc->oldNs.
; 8249 :     */
; 8250 :     do {
; 8251 : 	switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	sub	eax, 1
	je	SHORT $LN21@xmlDOMWrap
	sub	eax, 1
	je	SHORT $LN10@xmlDOMWrap
	jmp	$next_sibling$85
$LN21@xmlDOMWrap:

; 8252 : 	    case XML_ELEMENT_NODE:
; 8253 : 		if ((ctxt == NULL) && (node->nsDef != NULL)) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN10@xmlDOMWrap
	mov	edi, DWORD PTR [esi+48]
	test	edi, edi
	je	SHORT $LN10@xmlDOMWrap
$LL11@xmlDOMWrap:

; 8254 : 		    ns = node->nsDef;
; 8255 : 		    do {
; 8256 : 			if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,
; 8257 : 			    &nbList, ns, ns) == -1)

	push	edi
	push	edi
	lea	eax, DWORD PTR _nbList$[ebp]
	push	eax
	lea	eax, DWORD PTR _sizeList$[ebp]
	push	eax
	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormAddNsMapItem2
	add	esp, 20					; 00000014H
	cmp	eax, -1
	je	$LN78@xmlDOMWrap

; 8258 : 			    goto internal_error;
; 8259 : 			ns = ns->next;

	mov	edi, DWORD PTR [edi]

; 8260 : 		    } while (ns != NULL);

	test	edi, edi
	jne	SHORT $LL11@xmlDOMWrap
	mov	ebx, DWORD PTR _list$[ebp]
$LN10@xmlDOMWrap:

; 8261 : 		}
; 8262 :                 /* Falls through. */
; 8263 : 	    case XML_ATTRIBUTE_NODE:
; 8264 : 		if (node->ns != NULL) {

	mov	edx, DWORD PTR [esi+36]
	test	edx, edx
	je	SHORT $LN71@xmlDOMWrap

; 8265 : 		    /*
; 8266 : 		    * Find a mapping.
; 8267 : 		    */
; 8268 : 		    if (list != NULL) {

	test	ebx, ebx
	je	SHORT $LN13@xmlDOMWrap

; 8269 : 			for (i = 0, j = 0; i < nbList; i++, j += 2) {

	mov	edi, DWORD PTR _nbList$[ebp]
	xor	ecx, ecx
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN13@xmlDOMWrap
	npad	1
$LL14@xmlDOMWrap:

; 8270 : 			    if (node->ns == list[j]) {

	cmp	edx, DWORD PTR [ebx+eax*4]
	je	$LN49@xmlDOMWrap

; 8269 : 			for (i = 0, j = 0; i < nbList; i++, j += 2) {

	inc	ecx
	add	eax, 2
	cmp	ecx, edi
	jl	SHORT $LL14@xmlDOMWrap
$LN13@xmlDOMWrap:

; 8272 : 				goto next_node;
; 8273 : 			    }
; 8274 : 			}
; 8275 : 		    }
; 8276 : 		    ns = NULL;

	xor	edi, edi

; 8277 : 		    if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], edi
	jne	SHORT $LN32@xmlDOMWrap

; 8278 : 			/*
; 8279 : 			* User defined.
; 8280 : 			*/
; 8281 : 		    } else {
; 8282 : 			/*
; 8283 : 			* Add to doc's oldNs.
; 8284 : 			*/
; 8285 : 			ns = xmlDOMWrapStoreNs(doc, node->ns->href,

	push	DWORD PTR [edx+12]
	push	DWORD PTR [edx+8]
	push	DWORD PTR _doc$[ebp]
	call	_xmlDOMWrapStoreNs
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 8286 : 			    node->ns->prefix);
; 8287 : 			if (ns == NULL)

	test	edi, edi
	je	$internal_error$86

; 8288 : 			    goto internal_error;
; 8289 : 		    }
; 8290 : 		    if (ns != NULL) {
; 8291 : 			/*
; 8292 : 			* Add mapping.
; 8293 : 			*/
; 8294 : 			if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,
; 8295 : 			    &nbList, node->ns, ns) == -1)

	push	edi
	push	DWORD PTR [esi+36]
	lea	eax, DWORD PTR _nbList$[ebp]
	push	eax
	lea	eax, DWORD PTR _sizeList$[ebp]
	push	eax
	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormAddNsMapItem2
	add	esp, 20					; 00000014H
	cmp	eax, -1
	je	SHORT $LN78@xmlDOMWrap
	mov	ebx, DWORD PTR _list$[ebp]
$LN32@xmlDOMWrap:

; 8296 : 			    goto internal_error;
; 8297 : 		    }
; 8298 : 		    node->ns = ns;

	mov	DWORD PTR [esi+36], edi
$LN71@xmlDOMWrap:

; 8299 : 		}
; 8300 : 		if ((node->type == XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $next_sibling$85
	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN69@xmlDOMWrap
$LN51@xmlDOMWrap:

; 8323 : 	}
; 8324 :     } while (node != NULL);

	mov	esi, eax
	test	esi, esi
	jne	$LL6@xmlDOMWrap
$LN5@xmlDOMWrap:

; 8325 : 
; 8326 :     if (list != NULL)

	test	ebx, ebx
	je	$LN39@xmlDOMWrap

; 8327 : 	xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree

; 8333 :     return (-1);
; 8334 : }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlDOMWrap:

; 8271 : 				node->ns = list[++j];

	mov	eax, DWORD PTR [ebx+eax*4+4]
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [esi+4]
$next_node$87:

; 8301 : 		    (node->properties != NULL)) {
; 8302 : 		    node = (xmlNodePtr) node->properties;
; 8303 : 		    continue;
; 8304 : 		}
; 8305 : 		break;
; 8306 : 	    default:
; 8307 : 		goto next_sibling;
; 8308 : 	}
; 8309 : next_node:
; 8310 : 	if ((node->type == XML_ELEMENT_NODE) &&

	cmp	eax, 1
	jne	SHORT $next_sibling$85
$LN69@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN51@xmlDOMWrap
$next_sibling$85:

; 8311 : 	    (node->children != NULL)) {
; 8312 : 	    node = node->children;
; 8313 : 	    continue;
; 8314 : 	}
; 8315 : next_sibling:
; 8316 : 	if (node == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlDOMWrap

; 8317 : 	    break;
; 8318 : 	if (node->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN51@xmlDOMWrap

; 8319 : 	    node = node->next;
; 8320 : 	else {
; 8321 : 	    node = node->parent;

	mov	esi, DWORD PTR [esi+20]

; 8322 : 	    goto next_sibling;

	jmp	SHORT $next_sibling$85
$LN78@xmlDOMWrap:

; 8288 : 			    goto internal_error;
; 8289 : 		    }
; 8290 : 		    if (ns != NULL) {
; 8291 : 			/*
; 8292 : 			* Add mapping.
; 8293 : 			*/
; 8294 : 			if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,
; 8295 : 			    &nbList, node->ns, ns) == -1)

	mov	ebx, DWORD PTR _list$[ebp]
$internal_error$86:

; 8328 :     return (0);
; 8329 : 
; 8330 : internal_error:
; 8331 :     if (list != NULL)

	test	ebx, ebx
	je	SHORT $LN16@xmlDOMWrap

; 8332 : 	xmlFree(list);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlDOMWrap:

; 8333 :     return (-1);
; 8334 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlDOMWrap:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN84@xmlDOMWrap:
	DD	$LN19@xmlDOMWrap
	DD	$LN18@xmlDOMWrap
	DD	$LN20@xmlDOMWrap
$LN75@xmlDOMWrap:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
_xmlDOMWrapRemoveNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapAdoptNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_sourceDoc$ = 12					; size = 4
tv691 = 16						; size = 4
_old$1$ = 16						; size = 4
_old$1$ = 16						; size = 4
_adoptStr$1$ = 16					; size = 4
_node$ = 16						; size = 4
_destDoc$ = 20						; size = 4
_destParent$ = 24					; size = 4
_options$ = 28						; size = 4
_xmlDOMWrapAdoptNode PROC				; COMDAT

; 10036: {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN7@xmlDOMWrap

; 10037:     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||
; 10038:         (destDoc == NULL) ||

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 18					; 00000012H
	je	$LN7@xmlDOMWrap
	mov	ebx, DWORD PTR _destDoc$[ebp]
	test	ebx, ebx
	je	$LN7@xmlDOMWrap
	mov	edx, DWORD PTR _destParent$[ebp]
	test	edx, edx
	je	SHORT $LN6@xmlDOMWrap
	cmp	DWORD PTR [edx+32], ebx
	jne	$LN7@xmlDOMWrap
$LN6@xmlDOMWrap:

; 10039: 	((destParent != NULL) && (destParent->doc != destDoc)))
; 10040: 	return(-1);
; 10041:     /*
; 10042:     * Check node->doc sanity.
; 10043:     */
; 10044:     if ((node->doc != NULL) && (sourceDoc != NULL) &&

	mov	eax, DWORD PTR [esi+32]
	mov	edi, DWORD PTR _sourceDoc$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlDOMWrap
	test	edi, edi
	je	SHORT $LN46@xmlDOMWrap
	cmp	eax, edi
	jne	$LN7@xmlDOMWrap
$LN8@xmlDOMWrap:

; 10045: 	(node->doc != sourceDoc)) {
; 10046: 	/*
; 10047: 	* Might be an XIncluded node.
; 10048: 	*/
; 10049: 	return (-1);
; 10050:     }
; 10051:     if (sourceDoc == NULL)

	test	edi, edi
	jne	SHORT $LN9@xmlDOMWrap
$LN46@xmlDOMWrap:

; 10052: 	sourceDoc = node->doc;

	mov	edi, eax
$LN9@xmlDOMWrap:

; 10053:     if (sourceDoc == destDoc)

	cmp	edi, ebx
	je	$LN7@xmlDOMWrap

; 10054: 	return (-1);
; 10055:     switch (node->type) {

	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 10					; 0000000aH
	ja	$LN13@xmlDOMWrap
	movzx	eax, BYTE PTR $LN47@xmlDOMWrap[eax]
	jmp	DWORD PTR $LN54@xmlDOMWrap[eax*4]
$LN11@xmlDOMWrap:

; 10056: 	case XML_ELEMENT_NODE:
; 10057: 	case XML_ATTRIBUTE_NODE:
; 10058: 	case XML_TEXT_NODE:
; 10059: 	case XML_CDATA_SECTION_NODE:
; 10060: 	case XML_ENTITY_REF_NODE:
; 10061: 	case XML_PI_NODE:
; 10062: 	case XML_COMMENT_NODE:
; 10063: 	    break;
; 10064: 	case XML_DOCUMENT_FRAG_NODE:
; 10065: 	    /* TODO: Support document-fragment-nodes. */
; 10066: 	    return (2);
; 10067: 	default:
; 10068: 	    return (1);
; 10069:     }
; 10070:     /*
; 10071:     * Unlink only if @node was not already added to @destParent.
; 10072:     */
; 10073:     if ((node->parent != NULL) && (destParent != node->parent))

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN14@xmlDOMWrap
	cmp	edx, eax
	je	SHORT $LN14@xmlDOMWrap

; 10074: 	xmlUnlinkNode(node);

	push	esi
	call	_xmlUnlinkNode
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 4
	mov	edx, DWORD PTR _destParent$[ebp]
$LN14@xmlDOMWrap:

; 10075: 
; 10076:     if (node->type == XML_ELEMENT_NODE) {

	cmp	ecx, 1
	jne	SHORT $LN15@xmlDOMWrap

; 10077: 	    return (xmlDOMWrapAdoptBranch(ctxt, sourceDoc, node,

	push	DWORD PTR _options$[ebp]
	push	edx
	push	ebx
	push	esi
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlDOMWrapAdoptBranch
	add	esp, 24					; 00000018H
	pop	edi

; 10129: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlDOMWrap:

; 10078: 		    destDoc, destParent, options));
; 10079:     } else if (node->type == XML_ATTRIBUTE_NODE) {

	cmp	ecx, 2
	jne	SHORT $LN17@xmlDOMWrap

; 10080: 	    return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,

	push	DWORD PTR _options$[ebp]
	push	edx
	push	ebx
	push	esi
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlDOMWrapAdoptAttr
	add	esp, 24					; 00000018H
	pop	edi

; 10129: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlDOMWrap:

; 10081: 		(xmlAttrPtr) node, destDoc, destParent, options));
; 10082:     } else {
; 10083: 	xmlNodePtr cur = node;
; 10084: 	int adoptStr = 1;
; 10085: 
; 10086: 	cur->doc = destDoc;

	mov	DWORD PTR [esi+32], ebx
	mov	edx, 1
	mov	DWORD PTR _adoptStr$1$[ebp], edx

; 10087: 	/*
; 10088: 	* Optimize string adoption.
; 10089: 	*/
; 10090: 	if ((sourceDoc != NULL) &&

	test	edi, edi
	je	SHORT $LN19@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	cmp	eax, DWORD PTR [ebx+80]
	mov	DWORD PTR tv691[ebp], 0
	cmove	edx, DWORD PTR tv691[ebp]
	mov	DWORD PTR _adoptStr$1$[ebp], edx
$LN19@xmlDOMWrap:

; 10091: 	    (sourceDoc->dict == destDoc->dict))
; 10092: 		adoptStr = 0;
; 10093: 	switch (node->type) {

	add	ecx, -3					; fffffffdH
	cmp	ecx, 4
	ja	$LN43@xmlDOMWrap
	jmp	DWORD PTR $LN55@xmlDOMWrap[ecx*4]
$LN20@xmlDOMWrap:

; 10094: 	    case XML_TEXT_NODE:
; 10095: 	    case XML_CDATA_SECTION_NODE:
; 10096: 		XML_TREE_ADOPT_STR_2(node->content)

	test	edx, edx
	je	$LN43@xmlDOMWrap
$LN40@xmlDOMWrap:

; 10122: 		break;
; 10123: 	    }
; 10124: 	    default:
; 10125: 		break;
; 10126: 	}
; 10127:     }
; 10128:     return (0);

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	$LN43@xmlDOMWrap
	test	edi, edi
	je	$LN43@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	$LN43@xmlDOMWrap
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	$LN43@xmlDOMWrap
	mov	ecx, DWORD PTR [ebx+80]
	mov	eax, DWORD PTR [esi+40]
	test	ecx, ecx
	je	$LN42@xmlDOMWrap
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+40], eax
	xor	eax, eax
	pop	edi

; 10129: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlDOMWrap:

; 10097: 		    break;
; 10098: 	    case XML_ENTITY_REF_NODE:
; 10099: 		/*
; 10100: 		* Remove reference to the entitity-node.
; 10101: 		*/
; 10102: 		node->content = NULL;

	mov	DWORD PTR [esi+40], 0

; 10103: 		node->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 10104: 		node->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 10105: 		if ((destDoc->intSubset) || (destDoc->extSubset)) {

	cmp	DWORD PTR [ebx+44], 0
	jne	SHORT $LN26@xmlDOMWrap
	cmp	DWORD PTR [ebx+48], 0
	je	SHORT $LN27@xmlDOMWrap
$LN26@xmlDOMWrap:

; 10106: 		    xmlEntityPtr ent;
; 10107: 		    /*
; 10108: 		    * Assign new entity-node if available.
; 10109: 		    */
; 10110: 		    ent = xmlGetDocEntity(destDoc, node->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlGetDocEntity

; 10111: 		    if (ent != NULL) {

	mov	edx, DWORD PTR _adoptStr$1$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlDOMWrap

; 10112: 			node->content = ent->content;

	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [esi+40], ecx

; 10113: 			node->children = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+12], eax

; 10114: 			node->last = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+16], eax
$LN27@xmlDOMWrap:

; 10115: 		    }
; 10116: 		}
; 10117: 		XML_TREE_ADOPT_STR(node->name)

	test	edx, edx
	je	$LN43@xmlDOMWrap
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _old$1$[ebp], eax
	test	eax, eax
	je	$LN43@xmlDOMWrap
	mov	ecx, DWORD PTR [ebx+80]
	test	ecx, ecx
	je	SHORT $LN29@xmlDOMWrap
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR _old$1$[ebp]
	test	edi, edi
	je	SHORT $LN32@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN32@xmlDOMWrap
	push	esi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	$LN43@xmlDOMWrap
$LN32@xmlDOMWrap:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 10122: 		break;
; 10123: 	    }
; 10124: 	    default:
; 10125: 		break;
; 10126: 	}
; 10127:     }
; 10128:     return (0);

	xor	eax, eax
	pop	edi

; 10129: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN29@xmlDOMWrap:

; 10115: 		    }
; 10116: 		}
; 10117: 		XML_TREE_ADOPT_STR(node->name)

	test	edi, edi
	je	$LN43@xmlDOMWrap
	mov	ecx, DWORD PTR [edi+80]
	test	ecx, ecx
	je	$LN43@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	$LN43@xmlDOMWrap
	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 10122: 		break;
; 10123: 	    }
; 10124: 	    default:
; 10125: 		break;
; 10126: 	}
; 10127:     }
; 10128:     return (0);

	xor	eax, eax
	pop	edi

; 10129: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN34@xmlDOMWrap:

; 10118: 		break;
; 10119: 	    case XML_PI_NODE: {
; 10120: 		XML_TREE_ADOPT_STR(node->name)

	test	edx, edx
	je	$LN43@xmlDOMWrap
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _old$1$[ebp], eax
	test	eax, eax
	je	$LN40@xmlDOMWrap
	mov	ecx, DWORD PTR [ebx+80]
	test	ecx, ecx
	je	SHORT $LN36@xmlDOMWrap
	push	-1
	push	eax
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax
	test	edi, edi
	je	SHORT $LN39@xmlDOMWrap
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN39@xmlDOMWrap
	push	DWORD PTR _old$1$[ebp]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	$LN40@xmlDOMWrap
$LN39@xmlDOMWrap:
	push	DWORD PTR _old$1$[ebp]
	call	DWORD PTR _xmlFree

; 10121: 		XML_TREE_ADOPT_STR_2(node->content)

	add	esp, 4
	jmp	$LN40@xmlDOMWrap
$LN36@xmlDOMWrap:

; 10118: 		break;
; 10119: 	    case XML_PI_NODE: {
; 10120: 		XML_TREE_ADOPT_STR(node->name)

	test	edi, edi
	je	$LN40@xmlDOMWrap
	mov	ecx, DWORD PTR [edi+80]
	test	ecx, ecx
	je	$LN40@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	je	$LN40@xmlDOMWrap
	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	mov	DWORD PTR [esi+8], eax

; 10121: 		XML_TREE_ADOPT_STR_2(node->content)

	add	esp, 4
	jmp	$LN40@xmlDOMWrap
$LN42@xmlDOMWrap:

; 10122: 		break;
; 10123: 	    }
; 10124: 	    default:
; 10125: 		break;
; 10126: 	}
; 10127:     }
; 10128:     return (0);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+40], eax
$LN43@xmlDOMWrap:

; 10129: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlDOMWrap:
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlDOMWrap:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlDOMWrap:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN54@xmlDOMWrap:
	DD	$LN11@xmlDOMWrap
	DD	$LN12@xmlDOMWrap
	DD	$LN13@xmlDOMWrap
$LN47@xmlDOMWrap:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	0
	DB	2
	DB	2
	DB	1
	npad	1
$LN55@xmlDOMWrap:
	DD	$LN20@xmlDOMWrap
	DD	$LN20@xmlDOMWrap
	DD	$LN24@xmlDOMWrap
	DD	$LN43@xmlDOMWrap
	DD	$LN34@xmlDOMWrap
_xmlDOMWrapAdoptNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapReconcileNamespaces
_TEXT	SEGMENT
_doc$1$ = -52						; size = 4
_sizeRedund$ = -48					; size = 4
tv1141 = -44						; size = 4
_ns$ = -40						; size = 4
_curElem$1$ = -36					; size = 4
_parnsdone$1$ = -32					; size = 4
_adoptns$1$ = -28					; size = 4
_listRedund$ = -24					; size = 4
_nsMap$1$ = -20						; size = 4
_nbRedund$ = -16					; size = 4
_nsMap$ = -12						; size = 4
_newNs$1$ = -8						; size = 4
_cur$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_elem$ = 12						; size = 4
_prevns$1$ = 16						; size = 4
_nbRedund$1$ = 16					; size = 4
_options$ = 16						; size = 4
_xmlDOMWrapReconcileNamespaces PROC			; COMDAT

; 8742 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _elem$[ebp]
	xor	eax, eax
	mov	DWORD PTR _parnsdone$1$[ebp], eax
	xor	esi, esi
	mov	DWORD PTR _curElem$1$[ebp], eax
	xor	edi, edi
	mov	eax, DWORD PTR _options$[ebp]
	or	ebx, -1
	and	eax, 1
	mov	DWORD PTR _nsMap$1$[ebp], esi
	mov	DWORD PTR _nsMap$[ebp], esi
	mov	DWORD PTR tv1141[ebp], eax
	mov	DWORD PTR _listRedund$[ebp], esi
	mov	DWORD PTR _sizeRedund$[ebp], esi
	mov	DWORD PTR _nbRedund$1$[ebp], edi
	mov	DWORD PTR _nbRedund$[ebp], edi
	test	ecx, ecx
	je	$LN30@xmlDOMWrap

; 8743 :     int depth = -1, adoptns = 0, parnsdone = 0;
; 8744 :     xmlNsPtr ns, prevns;
; 8745 :     xmlDocPtr doc;
; 8746 :     xmlNodePtr cur, curElem = NULL;
; 8747 :     xmlNsMapPtr nsMap = NULL;
; 8748 :     xmlNsMapItemPtr /* topmi = NULL, */ mi;
; 8749 :     /* @ancestorsOnly should be set by an option flag. */
; 8750 :     int ancestorsOnly = 0;
; 8751 :     int optRemoveRedundantNS =
; 8752 : 	((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;
; 8753 :     xmlNsPtr *listRedund = NULL;
; 8754 :     int sizeRedund = 0, nbRedund = 0, ret, i, j;
; 8755 : 
; 8756 :     if ((elem == NULL) || (elem->doc == NULL) ||

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _doc$1$[ebp], eax
	test	eax, eax
	je	$LN30@xmlDOMWrap
	cmp	DWORD PTR [ecx+4], 1
	jne	$LN30@xmlDOMWrap

; 8757 : 	(elem->type != XML_ELEMENT_NODE))
; 8758 : 	return (-1);
; 8759 : 
; 8760 :     doc = elem->doc;
; 8761 :     cur = elem;

	mov	edx, ecx
	mov	DWORD PTR _cur$1$[ebp], edx
$LL4@xmlDOMWrap:

; 8762 :     do {
; 8763 : 	switch (cur->type) {

	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	je	SHORT $LN31@xmlDOMWrap
	sub	eax, 1
	je	$LN48@xmlDOMWrap
	jmp	$next_sibling$254
$LN31@xmlDOMWrap:

; 8764 : 	    case XML_ELEMENT_NODE:
; 8765 : 		adoptns = 1;
; 8766 : 		curElem = cur;
; 8767 : 		depth++;
; 8768 : 		/*
; 8769 : 		* Namespace declarations.
; 8770 : 		*/
; 8771 : 		if (cur->nsDef != NULL) {

	mov	eax, DWORD PTR [edx+48]
	mov	edi, 1
	inc	ebx
	mov	DWORD PTR _adoptns$1$[ebp], edi
	mov	DWORD PTR _curElem$1$[ebp], edx
	mov	DWORD PTR _newNs$1$[ebp], eax
	test	eax, eax
	je	$LN238@xmlDOMWrap

; 8772 : 		    prevns = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _prevns$1$[ebp], ecx
	npad	6
$LL7@xmlDOMWrap:

; 8773 : 		    ns = cur->nsDef;
; 8774 : 		    while (ns != NULL) {
; 8775 : 			if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	jne	SHORT $LN33@xmlDOMWrap

; 8776 : 			    if ((elem->parent) &&

	mov	ecx, DWORD PTR _elem$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	je	SHORT $LN35@xmlDOMWrap
	cmp	DWORD PTR [ecx+32], ecx
	je	SHORT $LN35@xmlDOMWrap

; 8777 : 				((xmlNodePtr) elem->parent->doc != elem->parent)) {
; 8778 : 				/*
; 8779 : 				* Gather ancestor in-scope ns-decls.
; 8780 : 				*/
; 8781 : 				if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 8782 : 				    elem->parent) == -1)

	push	ecx
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	mov	esi, DWORD PTR _nsMap$[ebp]
	add	esp, 8
	cmp	eax, -1
	je	$LN226@xmlDOMWrap
	mov	eax, DWORD PTR _newNs$1$[ebp]
	mov	DWORD PTR _nsMap$1$[ebp], esi
$LN35@xmlDOMWrap:

; 8783 : 				    goto internal_error;
; 8784 : 			    }
; 8785 : 			    parnsdone = 1;

	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN33@xmlDOMWrap:

; 8786 : 			}
; 8787 : 
; 8788 : 			/*
; 8789 : 			* Lookup the ns ancestor-axis for equal ns-decls in scope.
; 8790 : 			*/
; 8791 : 			if (optRemoveRedundantNS && XML_NSMAP_NOTEMPTY(nsMap)) {

	cmp	DWORD PTR tv1141[ebp], 0
	je	$LN208@xmlDOMWrap
	test	esi, esi
	je	$LN208@xmlDOMWrap
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	$LN237@xmlDOMWrap
$LL11@xmlDOMWrap:

; 8793 : 				if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&
; 8794 : 				    (mi->shadowDepth == -1) &&
; 8795 : 				    ((ns->prefix == mi->newNs->prefix) ||
; 8796 : 				      xmlStrEqual(ns->prefix, mi->newNs->prefix)) &&

	cmp	DWORD PTR [edi+20], -1
	jl	SHORT $LN9@xmlDOMWrap
	cmp	DWORD PTR [edi+16], -1
	jne	SHORT $LN9@xmlDOMWrap
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN38@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlDOMWrap
$LN38@xmlDOMWrap:
	mov	ecx, DWORD PTR _newNs$1$[ebp]
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+8]
	cmp	ecx, eax
	je	SHORT $LN194@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN194@xmlDOMWrap
$LN9@xmlDOMWrap:

; 8792 : 			    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN237@xmlDOMWrap
	mov	eax, DWORD PTR _newNs$1$[ebp]
	jmp	SHORT $LL11@xmlDOMWrap
$LN194@xmlDOMWrap:

; 8797 : 				    ((ns->href == mi->newNs->href) ||
; 8798 : 				      xmlStrEqual(ns->href, mi->newNs->href)))
; 8799 : 				{
; 8800 : 				    /*
; 8801 : 				    * A redundant ns-decl was found.
; 8802 : 				    * Add it to the list of redundant ns-decls.
; 8803 : 				    */
; 8804 : 				    if (xmlDOMWrapNSNormAddNsMapItem2(&listRedund,
; 8805 : 					&sizeRedund, &nbRedund, ns, mi->newNs) == -1)

	push	DWORD PTR [edi+12]
	mov	edi, DWORD PTR _newNs$1$[ebp]
	lea	eax, DWORD PTR _nbRedund$[ebp]
	push	edi
	push	eax
	lea	eax, DWORD PTR _sizeRedund$[ebp]
	push	eax
	lea	eax, DWORD PTR _listRedund$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormAddNsMapItem2
	add	esp, 20					; 00000014H
	cmp	eax, -1
	je	$LN226@xmlDOMWrap

; 8806 : 					goto internal_error;
; 8807 : 				    /*
; 8808 : 				    * Remove the ns-decl from the element-node.
; 8809 : 				    */
; 8810 : 				    if (prevns)

	mov	ecx, DWORD PTR _prevns$1$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _cur$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN41@xmlDOMWrap

; 8811 : 					prevns->next = ns->next;

	mov	DWORD PTR [ecx], eax
	mov	eax, edi
	jmp	$next_ns_decl$255
$LN41@xmlDOMWrap:

; 8812 : 				    else
; 8813 : 					cur->nsDef = ns->next;

	mov	DWORD PTR [edx+48], eax

; 8814 : 				    goto next_ns_decl;

	mov	eax, DWORD PTR _newNs$1$[ebp]
	jmp	$next_ns_decl$255
$LN237@xmlDOMWrap:

; 8815 : 				}
; 8816 : 			    }
; 8817 : 			}
; 8818 : 
; 8819 : 			/*
; 8820 : 			* Skip ns-references handling if the referenced
; 8821 : 			* ns-decl is declared on the same element.
; 8822 : 			*/
; 8823 : 			if ((cur->ns != NULL) && adoptns && (cur->ns == ns))

	mov	edi, DWORD PTR _adoptns$1$[ebp]
$LN208@xmlDOMWrap:
	mov	eax, DWORD PTR _cur$1$[ebp]
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN43@xmlDOMWrap
	test	edi, edi
	je	SHORT $LN43@xmlDOMWrap
	xor	ecx, ecx
	cmp	eax, DWORD PTR _newNs$1$[ebp]
	cmove	edi, ecx
	mov	DWORD PTR _adoptns$1$[ebp], edi
$LN43@xmlDOMWrap:

; 8824 : 			    adoptns = 0;
; 8825 : 			/*
; 8826 : 			* Does it shadow any ns-decl?
; 8827 : 			*/
; 8828 : 			if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN13@xmlDOMWrap
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN13@xmlDOMWrap
	mov	esi, DWORD PTR _newNs$1$[ebp]
$LL14@xmlDOMWrap:

; 8830 : 				if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&
; 8831 : 				    (mi->shadowDepth == -1) &&

	cmp	DWORD PTR [edi+20], -1
	jl	SHORT $LN12@xmlDOMWrap
	cmp	DWORD PTR [edi+16], -1
	jne	SHORT $LN12@xmlDOMWrap
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN46@xmlDOMWrap
	push	eax
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlDOMWrap
$LN46@xmlDOMWrap:

; 8832 : 				    ((ns->prefix == mi->newNs->prefix) ||
; 8833 : 				    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {
; 8834 : 
; 8835 : 				    mi->shadowDepth = depth;

	mov	DWORD PTR [edi+16], ebx
$LN12@xmlDOMWrap:

; 8829 : 			    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	SHORT $LL14@xmlDOMWrap
	mov	esi, DWORD PTR _nsMap$1$[ebp]
$LN13@xmlDOMWrap:

; 7892 :     map = *nsmap;

	mov	edi, esi
	test	edi, edi

; 7893 : 
; 7894 :     if (map == NULL) {

	jne	SHORT $LN79@xmlDOMWrap

; 7895 : 	/*
; 7896 : 	* Create the ns-map.
; 7897 : 	*/
; 7898 : 	map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 7899 : 	if (map == NULL) {

	test	edi, edi
	je	$LN185@xmlDOMWrap
	xorps	xmm0, xmm0

; 7900 : 	    xmlTreeErrMemory("allocating namespace map");
; 7901 : 	    return (NULL);
; 7902 : 	}
; 7903 : 	memset(map, 0, sizeof(struct xmlNsMap));

	movq	QWORD PTR [edi], xmm0
	mov	DWORD PTR [edi+8], esi

; 7904 : 	*nsmap = map;

	mov	esi, edi
	mov	DWORD PTR _nsMap$1$[ebp], esi
	mov	DWORD PTR _nsMap$[ebp], esi
$LN79@xmlDOMWrap:

; 7905 :     }
; 7906 : 
; 7907 :     if (map->pool != NULL) {

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN81@xmlDOMWrap

; 7908 : 	/*
; 7909 : 	* Reuse an item from the pool.
; 7910 : 	*/
; 7911 : 	ret = map->pool;
; 7912 : 	map->pool = ret->next;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+8], eax

; 7913 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7914 :     } else {

	jmp	SHORT $LN248@xmlDOMWrap
$LN81@xmlDOMWrap:

; 7915 : 	/*
; 7916 : 	* Create a new item.
; 7917 : 	*/
; 7918 : 	ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 7919 : 	if (ret == NULL) {

	test	ecx, ecx
	je	$LN187@xmlDOMWrap
$LN248@xmlDOMWrap:

; 7920 : 	    xmlTreeErrMemory("allocating namespace map item");
; 7921 : 	    return (NULL);
; 7922 : 	}
; 7923 : 	memset(ret, 0, sizeof(struct xmlNsMapItem));
; 7924 :     }
; 7925 : 
; 7926 :     if (map->first == NULL) {

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN84@xmlDOMWrap

; 7927 : 	/*
; 7928 : 	* First ever.
; 7929 : 	*/
; 7930 : 	map->first = ret;

	mov	DWORD PTR [edi], ecx

; 7931 : 	map->last = ret;

	jmp	SHORT $LN88@xmlDOMWrap
$LN84@xmlDOMWrap:

; 7932 :     } else if (position == -1) {
; 7933 : 	/*
; 7934 : 	* Append.
; 7935 : 	*/
; 7936 : 	ret->prev = map->last;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax

; 7937 : 	map->last->next = ret;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ecx
$LN88@xmlDOMWrap:

; 7938 : 	map->last = ret;
; 7939 :     } else if (position == 0) {
; 7940 : 	/*
; 7941 : 	* Set on first position.
; 7942 : 	*/
; 7943 : 	map->first->prev = ret;
; 7944 : 	ret->next = map->first;
; 7945 : 	map->first = ret;
; 7946 :     }
; 7947 : 
; 7948 :     ret->oldNs = oldNs;

	mov	eax, DWORD PTR _newNs$1$[ebp]
	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [ecx+8], eax

; 7949 :     ret->newNs = newNs;

	mov	DWORD PTR [ecx+12], eax

; 7950 :     ret->shadowDepth = -1;

	mov	DWORD PTR [ecx+16], -1

; 7951 :     ret->depth = depth;

	mov	DWORD PTR [ecx+20], ebx

; 8836 : 				}
; 8837 : 			    }
; 8838 : 			}
; 8839 : 			/*
; 8840 : 			* Push mapping.
; 8841 : 			*/
; 8842 : 			if (xmlDOMWrapNsMapAddItem(&nsMap, -1, ns, ns,
; 8843 : 			    depth) == NULL)
; 8844 : 			    goto internal_error;
; 8845 : 
; 8846 : 			prevns = ns;

	mov	DWORD PTR _prevns$1$[ebp], eax
$next_ns_decl$255:

; 8847 : next_ns_decl:
; 8848 : 			ns = ns->next;

	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR _adoptns$1$[ebp]
	mov	DWORD PTR _newNs$1$[ebp], eax
	mov	DWORD PTR _ns$[ebp], eax
	test	eax, eax
	jne	$LL7@xmlDOMWrap

; 8849 : 		    }
; 8850 : 		}
; 8851 : 		if (! adoptns)

	cmp	DWORD PTR _adoptns$1$[ebp], 0
	mov	edi, DWORD PTR _nbRedund$[ebp]
	mov	DWORD PTR _nbRedund$1$[ebp], edi
	je	$ns_end$256
	mov	ecx, DWORD PTR _elem$[ebp]
	jmp	SHORT $LN48@xmlDOMWrap
$LN238@xmlDOMWrap:

; 8764 : 	    case XML_ELEMENT_NODE:
; 8765 : 		adoptns = 1;
; 8766 : 		curElem = cur;
; 8767 : 		depth++;
; 8768 : 		/*
; 8769 : 		* Namespace declarations.
; 8770 : 		*/
; 8771 : 		if (cur->nsDef != NULL) {

	mov	edi, DWORD PTR _nbRedund$1$[ebp]
$LN48@xmlDOMWrap:

; 8852 : 		    goto ns_end;
; 8853 :                 /* Falls through. */
; 8854 : 	    case XML_ATTRIBUTE_NODE:
; 8855 : 		/* No ns, no fun. */
; 8856 : 		if (cur->ns == NULL)

	cmp	DWORD PTR [edx+36], 0
	je	$ns_end$256

; 8857 : 		    goto ns_end;
; 8858 : 
; 8859 : 		if (! parnsdone) {

	cmp	DWORD PTR _parnsdone$1$[ebp], 0
	jne	SHORT $LN51@xmlDOMWrap

; 8860 : 		    if ((elem->parent) &&

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN53@xmlDOMWrap
	cmp	DWORD PTR [eax+32], eax
	je	SHORT $LN53@xmlDOMWrap

; 8861 : 			((xmlNodePtr) elem->parent->doc != elem->parent)) {
; 8862 : 			if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,
; 8863 : 				elem->parent) == -1)

	push	eax
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	call	_xmlDOMWrapNSNormGatherInScopeNs
	add	esp, 8
	cmp	eax, -1
	je	$LN225@xmlDOMWrap
	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR _nsMap$1$[ebp], esi
$LN53@xmlDOMWrap:

; 8864 : 			    goto internal_error;
; 8865 : 		    }
; 8866 : 		    parnsdone = 1;

	mov	DWORD PTR _parnsdone$1$[ebp], 1
$LN51@xmlDOMWrap:

; 8867 : 		}
; 8868 : 		/*
; 8869 : 		* Adjust the reference if this was a redundant ns-decl.
; 8870 : 		*/
; 8871 : 		if (listRedund) {

	cmp	DWORD PTR _listRedund$[ebp], 0
	je	SHORT $LN16@xmlDOMWrap

; 8872 : 		   for (i = 0, j = 0; i < nbRedund; i++, j += 2) {

	xor	ecx, ecx
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN16@xmlDOMWrap

; 8873 : 		       if (cur->ns == listRedund[j]) {

	mov	edx, DWORD PTR [edx+36]
$LL17@xmlDOMWrap:
	mov	esi, DWORD PTR _listRedund$[ebp]
	cmp	edx, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _nsMap$1$[ebp]
	je	SHORT $LN123@xmlDOMWrap

; 8872 : 		   for (i = 0, j = 0; i < nbRedund; i++, j += 2) {

	inc	ecx
	add	eax, 2
	cmp	ecx, edi
	jl	SHORT $LL17@xmlDOMWrap

; 8955 : 		cur = cur->parent;
; 8956 : 		goto into_content;
; 8957 : 	    }
; 8958 : 	    cur = cur->parent;
; 8959 : 	    goto next_sibling;
; 8960 : 	}
; 8961 :     } while (cur != NULL);

	mov	edx, DWORD PTR _cur$1$[ebp]
	jmp	SHORT $LN16@xmlDOMWrap
$LN123@xmlDOMWrap:

; 8874 : 			   cur->ns = listRedund[++j];

	mov	ecx, DWORD PTR _listRedund$[ebp]
	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR [edx+36], eax
$LN16@xmlDOMWrap:

; 8875 : 			   break;
; 8876 : 		       }
; 8877 : 		   }
; 8878 : 		}
; 8879 : 		/*
; 8880 : 		* Adopt ns-references.
; 8881 : 		*/
; 8882 : 		if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN210@xmlDOMWrap
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN210@xmlDOMWrap
	npad	1
$LL20@xmlDOMWrap:

; 8887 : 			if ((mi->shadowDepth == -1) &&

	cmp	DWORD PTR [ecx+16], -1
	jne	SHORT $LN18@xmlDOMWrap
	mov	eax, DWORD PTR [edx+36]
	cmp	eax, DWORD PTR [ecx+8]
	je	$LN124@xmlDOMWrap
$LN18@xmlDOMWrap:

; 8883 : 		    /*
; 8884 : 		    * Search for a mapping.
; 8885 : 		    */
; 8886 : 		    XML_NSMAP_FOREACH(nsMap, mi) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL20@xmlDOMWrap
$LN210@xmlDOMWrap:

; 8892 : 			}
; 8893 : 		    }
; 8894 : 		}
; 8895 : 		/*
; 8896 : 		* Aquire a normalized ns-decl and add it to the map.
; 8897 : 		*/
; 8898 : 		if (xmlDOMWrapNSNormAquireNormalizedNs(doc, curElem,
; 8899 : 			cur->ns, &ns,
; 8900 : 			&nsMap, depth,
; 8901 : 			ancestorsOnly,
; 8902 : 			(cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)

	xor	eax, eax
	cmp	DWORD PTR [edx+4], 2
	sete	al
	push	eax
	push	0
	push	ebx
	lea	eax, DWORD PTR _nsMap$[ebp]
	push	eax
	lea	eax, DWORD PTR _ns$[ebp]
	push	eax
	push	DWORD PTR [edx+36]
	push	DWORD PTR _curElem$1$[ebp]
	push	DWORD PTR _doc$1$[ebp]
	call	_xmlDOMWrapNSNormAquireNormalizedNs
	add	esp, 32					; 00000020H
	cmp	eax, -1
	je	$LN225@xmlDOMWrap

; 8903 : 		    goto internal_error;
; 8904 : 		cur->ns = ns;

	mov	esi, DWORD PTR _nsMap$[ebp]
	mov	eax, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR _nsMap$1$[ebp], esi
$LN249@xmlDOMWrap:

; 8905 : 
; 8906 : ns_end:
; 8907 : 		if ((cur->type == XML_ELEMENT_NODE) &&

	mov	DWORD PTR [edx+36], eax
$ns_end$256:
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN241@xmlDOMWrap
	mov	eax, DWORD PTR [edx+44]
	test	eax, eax
	jne	$LN251@xmlDOMWrap
$into_content$257:

; 8908 : 		    (cur->properties != NULL)) {
; 8909 : 		    /*
; 8910 : 		    * Process attributes.
; 8911 : 		    */
; 8912 : 		    cur = (xmlNodePtr) cur->properties;
; 8913 : 		    continue;
; 8914 : 		}
; 8915 : 		break;
; 8916 : 	    default:
; 8917 : 		goto next_sibling;
; 8918 : 	}
; 8919 : into_content:
; 8920 : 	if ((cur->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN241@xmlDOMWrap
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	jne	$LN126@xmlDOMWrap
$LN241@xmlDOMWrap:

; 8921 : 	    (cur->children != NULL)) {
; 8922 : 	    /*
; 8923 : 	    * Process content of element-nodes only.
; 8924 : 	    */
; 8925 : 	    cur = cur->children;
; 8926 : 	    continue;
; 8927 : 	}
; 8928 : next_sibling:
; 8929 : 	if (cur == elem)

	mov	ecx, DWORD PTR _elem$[ebp]
	npad	5
$next_sibling$254:
	cmp	edx, ecx
	je	$LN3@xmlDOMWrap

; 8930 : 	    break;
; 8931 : 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edx+4], 1
	lea	edi, DWORD PTR [edx+4]
	jne	SHORT $LN63@xmlDOMWrap

; 8932 : 	    if (XML_NSMAP_NOTEMPTY(nsMap)) {

	test	esi, esi
	je	SHORT $LN24@xmlDOMWrap
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN24@xmlDOMWrap

; 8933 : 		/*
; 8934 : 		* Pop mappings.
; 8935 : 		*/
; 8936 : 		while ((nsMap->last != NULL) &&

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN235@xmlDOMWrap
$LL21@xmlDOMWrap:
	cmp	DWORD PTR [ecx+20], ebx
	jl	SHORT $LN235@xmlDOMWrap

; 8937 : 		    (nsMap->last->depth >= depth))
; 8938 : 		{
; 8939 : 		    XML_NSMAP_POP(nsMap, mi)

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LN65@xmlDOMWrap
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN66@xmlDOMWrap
$LN124@xmlDOMWrap:

; 8888 : 			    (cur->ns == mi->oldNs)) {
; 8889 : 
; 8890 : 			    cur->ns = mi->newNs;

	mov	eax, DWORD PTR [ecx+12]

; 8891 : 			    goto ns_end;

	jmp	SHORT $LN249@xmlDOMWrap
$LN65@xmlDOMWrap:

; 8937 : 		    (nsMap->last->depth >= depth))
; 8938 : 		{
; 8939 : 		    XML_NSMAP_POP(nsMap, mi)

	mov	DWORD PTR [eax], 0
$LN66@xmlDOMWrap:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LL21@xmlDOMWrap
$LN235@xmlDOMWrap:

; 8940 : 		}
; 8941 : 		/*
; 8942 : 		* Unshadow.
; 8943 : 		*/
; 8944 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN239@xmlDOMWrap
$LL25@xmlDOMWrap:

; 8945 : 		    if (mi->shadowDepth >= depth)

	cmp	DWORD PTR [eax+16], ebx
	jl	SHORT $LN23@xmlDOMWrap

; 8946 : 			mi->shadowDepth = -1;

	mov	DWORD PTR [eax+16], -1
$LN23@xmlDOMWrap:

; 8940 : 		}
; 8941 : 		/*
; 8942 : 		* Unshadow.
; 8943 : 		*/
; 8944 : 		XML_NSMAP_FOREACH(nsMap, mi) {

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL25@xmlDOMWrap
$LN239@xmlDOMWrap:

; 8947 : 		}
; 8948 : 	    }
; 8949 : 	    depth--;

	mov	ecx, DWORD PTR _elem$[ebp]
$LN24@xmlDOMWrap:
	dec	ebx
$LN63@xmlDOMWrap:

; 8950 : 	}
; 8951 : 	if (cur->next != NULL)

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	jne	SHORT $LN126@xmlDOMWrap

; 8952 : 	    cur = cur->next;
; 8953 : 	else {
; 8954 : 	    if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [edi], 2
	mov	edx, DWORD PTR [edx+20]
	jne	SHORT $next_sibling$254

; 8743 :     int depth = -1, adoptns = 0, parnsdone = 0;
; 8744 :     xmlNsPtr ns, prevns;
; 8745 :     xmlDocPtr doc;
; 8746 :     xmlNodePtr cur, curElem = NULL;
; 8747 :     xmlNsMapPtr nsMap = NULL;
; 8748 :     xmlNsMapItemPtr /* topmi = NULL, */ mi;
; 8749 :     /* @ancestorsOnly should be set by an option flag. */
; 8750 :     int ancestorsOnly = 0;
; 8751 :     int optRemoveRedundantNS =
; 8752 : 	((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;
; 8753 :     xmlNsPtr *listRedund = NULL;
; 8754 :     int sizeRedund = 0, nbRedund = 0, ret, i, j;
; 8755 : 
; 8756 :     if ((elem == NULL) || (elem->doc == NULL) ||

	jmp	$into_content$257
$LN126@xmlDOMWrap:

; 8955 : 		cur = cur->parent;
; 8956 : 		goto into_content;
; 8957 : 	    }
; 8958 : 	    cur = cur->parent;
; 8959 : 	    goto next_sibling;
; 8960 : 	}
; 8961 :     } while (cur != NULL);

	mov	edi, DWORD PTR _nbRedund$1$[ebp]
$LN251@xmlDOMWrap:
	mov	edx, eax
	mov	DWORD PTR _cur$1$[ebp], edx
	test	edx, edx
	je	SHORT $LN3@xmlDOMWrap

; 8743 :     int depth = -1, adoptns = 0, parnsdone = 0;
; 8744 :     xmlNsPtr ns, prevns;
; 8745 :     xmlDocPtr doc;
; 8746 :     xmlNodePtr cur, curElem = NULL;
; 8747 :     xmlNsMapPtr nsMap = NULL;
; 8748 :     xmlNsMapItemPtr /* topmi = NULL, */ mi;
; 8749 :     /* @ancestorsOnly should be set by an option flag. */
; 8750 :     int ancestorsOnly = 0;
; 8751 :     int optRemoveRedundantNS =
; 8752 : 	((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;
; 8753 :     xmlNsPtr *listRedund = NULL;
; 8754 :     int sizeRedund = 0, nbRedund = 0, ret, i, j;
; 8755 : 
; 8756 :     if ((elem == NULL) || (elem->doc == NULL) ||

	mov	ecx, DWORD PTR _elem$[ebp]
	jmp	$LL4@xmlDOMWrap
$LN185@xmlDOMWrap:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@JOLPDGAP@allocating?5namespace?5map@
$LN252@xmlDOMWrap:

; 8964 :     goto exit;
; 8965 : internal_error:
; 8966 :     ret = -1;

	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN226@xmlDOMWrap:
	mov	eax, DWORD PTR _nbRedund$[ebp]
	mov	DWORD PTR _nbRedund$1$[ebp], eax
	mov	DWORD PTR _ret$1$[ebp], -1
	jmp	SHORT $exit$258
$LN187@xmlDOMWrap:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BO@JPEMBFPF@allocating?5namespace?5map?5item@

; 8892 : 			}
; 8893 : 		    }
; 8894 : 		}
; 8895 : 		/*
; 8896 : 		* Aquire a normalized ns-decl and add it to the map.
; 8897 : 		*/
; 8898 : 		if (xmlDOMWrapNSNormAquireNormalizedNs(doc, curElem,
; 8899 : 			cur->ns, &ns,
; 8900 : 			&nsMap, depth,
; 8901 : 			ancestorsOnly,
; 8902 : 			(cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)

	jmp	SHORT $LN252@xmlDOMWrap
$LN225@xmlDOMWrap:
	mov	esi, DWORD PTR _nsMap$[ebp]
$internal_error$259:

; 8964 :     goto exit;
; 8965 : internal_error:
; 8966 :     ret = -1;

	mov	DWORD PTR _ret$1$[ebp], -1
	jmp	SHORT $exit$258
$LN3@xmlDOMWrap:

; 8962 : 
; 8963 :     ret = 0;

	mov	DWORD PTR _ret$1$[ebp], 0
$exit$258:

; 8967 : exit:
; 8968 :     if (listRedund) {

	mov	ecx, DWORD PTR _listRedund$[ebp]
	test	ecx, ecx
	je	SHORT $LN71@xmlDOMWrap

; 8969 : 	for (i = 0, j = 0; i < nbRedund; i++, j += 2) {

	mov	eax, DWORD PTR _nbRedund$1$[ebp]
	test	eax, eax
	jle	SHORT $LN27@xmlDOMWrap
	mov	ebx, ecx
$LL28@xmlDOMWrap:

; 8970 : 	    xmlFreeNs(listRedund[j]);

	mov	edi, DWORD PTR [ebx]

; 828  :     if (cur == NULL) {

	test	edi, edi
	je	SHORT $LN26@xmlDOMWrap

; 829  : #ifdef DEBUG_TREE
; 830  :         xmlGenericError(xmlGenericErrorContext,
; 831  : 		"xmlFreeNs : ns == NULL\n");
; 832  : #endif
; 833  : 	return;
; 834  :     }
; 835  :     if (cur->href != NULL) xmlFree((char *) cur->href);

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN96@xmlDOMWrap
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN96@xmlDOMWrap:

; 836  :     if (cur->prefix != NULL) xmlFree((char *) cur->prefix);

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN97@xmlDOMWrap
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN97@xmlDOMWrap:

; 837  :     xmlFree(cur);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _nbRedund$1$[ebp]
	add	esp, 4
$LN26@xmlDOMWrap:

; 8969 : 	for (i = 0, j = 0; i < nbRedund; i++, j += 2) {

	add	ebx, 8
	sub	eax, 1
	mov	DWORD PTR _nbRedund$1$[ebp], eax
	jne	SHORT $LL28@xmlDOMWrap
	mov	ecx, DWORD PTR _listRedund$[ebp]
$LN27@xmlDOMWrap:

; 8971 : 	}
; 8972 : 	xmlFree(listRedund);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN71@xmlDOMWrap:

; 8973 :     }
; 8974 :     if (nsMap != NULL)

	test	esi, esi
	je	SHORT $LN99@xmlDOMWrap

; 7857 :     cur = nsmap->pool;

	mov	edi, DWORD PTR [esi+8]

; 7858 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN101@xmlDOMWrap
	npad	8
$LL100@xmlDOMWrap:

; 7859 : 	tmp = cur;
; 7860 : 	cur = cur->next;
; 7861 : 	xmlFree(tmp);

	push	edi
	mov	edi, DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	edi, edi
	jne	SHORT $LL100@xmlDOMWrap
$LN101@xmlDOMWrap:

; 7862 :     }
; 7863 :     cur = nsmap->first;

	mov	edi, DWORD PTR [esi]

; 7864 :     while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN103@xmlDOMWrap
$LL102@xmlDOMWrap:

; 7865 : 	tmp = cur;
; 7866 : 	cur = cur->next;
; 7867 : 	xmlFree(tmp);

	push	edi
	mov	edi, DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4
	test	edi, edi
	jne	SHORT $LL102@xmlDOMWrap
$LN103@xmlDOMWrap:

; 7868 :     }
; 7869 :     xmlFree(nsmap);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN99@xmlDOMWrap:

; 8975 : 	xmlDOMWrapNsMapFree(nsMap);
; 8976 :     return (ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 8977 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlDOMWrap:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDOMWrapReconcileNamespaces ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapFreeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlDOMWrapFreeCtxt PROC				; COMDAT

; 8030 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlDOMWrap

; 8031 :     if (ctxt == NULL)
; 8032 : 	return;
; 8033 :     if (ctxt->namespaceMap != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlDOMWrap

; 8034 : 	xmlDOMWrapNsMapFree((xmlNsMapPtr) ctxt->namespaceMap);

	push	eax
	call	_xmlDOMWrapNsMapFree
	add	esp, 4
$LN3@xmlDOMWrap:

; 8035 :     /*
; 8036 :     * TODO: Store the namespace map in the context.
; 8037 :     */
; 8038 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlDOMWrap:
	pop	esi

; 8039 : }

	pop	ebp
	ret	0
_xmlDOMWrapFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDOMWrapNewCtxt
_TEXT	SEGMENT
_xmlDOMWrapNewCtxt PROC					; COMDAT
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlDOMWrap

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BP@IBBGEDIA@allocating?5DOM?9wrapper?5context@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 8011 :     xmlDOMWrapCtxtPtr ret;
; 8012 : 
; 8013 :     ret = xmlMalloc(sizeof(xmlDOMWrapCtxt));
; 8014 :     if (ret == NULL) {
; 8015 : 	xmlTreeErrMemory("allocating DOM-wrapper context");
; 8016 : 	return (NULL);

	xor	eax, eax

; 8019 :     return (ret);
; 8020 : }

	ret	0
$LN2@xmlDOMWrap:
	xorps	xmm0, xmm0

; 8017 :     }
; 8018 :     memset(ret, 0, sizeof(xmlDOMWrapCtxt));

	movups	XMMWORD PTR [eax], xmm0

; 8019 :     return (ret);
; 8020 : }

	ret	0
_xmlDOMWrapNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetCompressMode
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_xmlSetCompressMode PROC				; COMDAT

; 7796 : xmlSetCompressMode(int mode) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _mode$[ebp]
	test	eax, eax
	jns	SHORT $LN2@xmlSetComp

; 7799 :     else xmlCompressMode = mode;
; 7800 : }

	mov	DWORD PTR _xmlCompressMode, 0
	pop	ebp
	ret	0
$LN2@xmlSetComp:

; 7797 :     if (mode < 0) xmlCompressMode = 0;
; 7798 :     else if (mode > 9) xmlCompressMode = 9;

	mov	ecx, 9
	cmp	eax, ecx
	cmovg	eax, ecx

; 7799 :     else xmlCompressMode = mode;
; 7800 : }

	mov	DWORD PTR _xmlCompressMode, eax
	pop	ebp
	ret	0
_xmlSetCompressMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetCompressMode
_TEXT	SEGMENT
_xmlGetCompressMode PROC				; COMDAT
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlCompressMode
	ret	0
_xmlGetCompressMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetDocCompressMode
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_mode$ = 12						; size = 4
_xmlSetDocCompressMode PROC				; COMDAT

; 7769 : xmlSetDocCompressMode (xmlDocPtr doc, int mode) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlSetDocC

; 7770 :     if (doc == NULL) return;
; 7771 :     if (mode < 0) doc->compression = 0;

	mov	eax, DWORD PTR _mode$[ebp]
	test	eax, eax
	jns	SHORT $LN3@xmlSetDocC
	mov	DWORD PTR [ecx+36], 0

; 7773 :     else doc->compression = mode;
; 7774 : }

	pop	ebp
	ret	0
$LN3@xmlSetDocC:

; 7772 :     else if (mode > 9) doc->compression = 9;

	mov	edx, 9
	cmp	eax, edx
	cmovg	eax, edx
	mov	DWORD PTR [ecx+36], eax
$LN5@xmlSetDocC:

; 7773 :     else doc->compression = mode;
; 7774 : }

	pop	ebp
	ret	0
_xmlSetDocCompressMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetDocCompressMode
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlGetDocCompressMode PROC				; COMDAT

; 7755 : xmlGetDocCompressMode (const xmlDoc *doc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlGetDocC

; 7756 :     if (doc == NULL) return(-1);

	or	eax, -1

; 7758 : }

	pop	ebp
	ret	0
$LN2@xmlGetDocC:

; 7757 :     return(doc->compression);

	mov	eax, DWORD PTR [eax+36]

; 7758 : }

	pop	ebp
	ret	0
_xmlGetDocCompressMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlReconciliateNs
_TEXT	SEGMENT
tv545 = -16						; size = 4
_n$2$ = -16						; size = 4
_attr$1$ = -12						; size = 4
_n$1$ = -12						; size = 4
_newNs$1$ = -8						; size = 4
_sizeCache$1$ = -4					; size = 4
_doc$ = 8						; size = 4
_tree$ = 12						; size = 4
_xmlReconciliateNs PROC					; COMDAT

; 6299 : xmlReconciliateNs(xmlDocPtr doc, xmlNodePtr tree) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _tree$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _newNs$1$[ebp], eax
	xor	ebx, ebx
	mov	DWORD PTR _sizeCache$1$[ebp], ecx
	xor	edi, edi
	mov	esi, edx
	test	edx, edx
	je	$LN15@xmlReconci

; 6300 :     xmlNsPtr *oldNs = NULL;
; 6301 :     xmlNsPtr *newNs = NULL;
; 6302 :     int sizeCache = 0;
; 6303 :     int nbCache = 0;
; 6304 : 
; 6305 :     xmlNsPtr n;
; 6306 :     xmlNodePtr node = tree;
; 6307 :     xmlAttrPtr attr;
; 6308 :     int ret = 0, i;
; 6309 : 
; 6310 :     if ((node == NULL) || (node->type != XML_ELEMENT_NODE)) return(-1);

	cmp	DWORD PTR [edx+4], 1
	jne	$LN15@xmlReconci

; 6311 :     if ((doc == NULL) || (doc->type != XML_DOCUMENT_NODE)) return(-1);

	cmp	DWORD PTR _doc$[ebp], eax
	je	$LN15@xmlReconci
	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	mov	ecx, eax
	jne	$LN15@xmlReconci

; 6312 :     if (node->doc != doc) return(-1);

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+32], eax
	mov	eax, ecx
	jne	$LN15@xmlReconci
	npad	2
$LL2@xmlReconci:

; 6314 :         /*
; 6315 : 	 * Reconciliate the node namespace
; 6316 : 	 */
; 6317 : 	if (node->ns != NULL) {

	cmp	DWORD PTR [esi+36], 0
	je	$LN25@xmlReconci

; 6318 : 	    /*
; 6319 : 	     * initialize the cache if needed
; 6320 : 	     */
; 6321 : 	    if (sizeCache == 0) {

	test	ecx, ecx
	jne	SHORT $LN22@xmlReconci

; 6322 : 		sizeCache = 10;
; 6323 : 		oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *

	push	40					; 00000028H
	mov	DWORD PTR _sizeCache$1$[ebp], 10	; 0000000aH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 6324 : 					       sizeof(xmlNsPtr));
; 6325 : 		if (oldNs == NULL) {

	test	ebx, ebx
	je	$LN74@xmlReconci

; 6327 : 		    return(-1);
; 6328 : 		}
; 6329 : 		newNs = (xmlNsPtr *) xmlMalloc(sizeCache *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _newNs$1$[ebp], eax

; 6330 : 					       sizeof(xmlNsPtr));
; 6331 : 		if (newNs == NULL) {

	test	eax, eax
	je	$LN75@xmlReconci
$LN22@xmlReconci:

; 6332 : 		    xmlTreeErrMemory("fixing namespaces");
; 6333 : 		    xmlFree(oldNs);
; 6334 : 		    return(-1);
; 6335 : 		}
; 6336 : 	    }
; 6337 : 	    for (i = 0;i < nbCache;i++) {

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN5@xmlReconci

; 6338 : 	        if (oldNs[i] == node->ns) {

	mov	edx, DWORD PTR [esi+36]
	npad	7
$LL6@xmlReconci:
	cmp	DWORD PTR [ebx+ecx*4], edx
	je	SHORT $LN66@xmlReconci

; 6332 : 		    xmlTreeErrMemory("fixing namespaces");
; 6333 : 		    xmlFree(oldNs);
; 6334 : 		    return(-1);
; 6335 : 		}
; 6336 : 	    }
; 6337 : 	    for (i = 0;i < nbCache;i++) {

	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL6@xmlReconci

; 6362 : 			                               sizeof(xmlNsPtr));
; 6363 : 		        if (newNs == NULL) {

	jmp	SHORT $LN5@xmlReconci
$LN66@xmlReconci:

; 6339 : 		    node->ns = newNs[i];

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+36], eax
$LN5@xmlReconci:

; 6340 : 		    break;
; 6341 : 		}
; 6342 : 	    }
; 6343 : 	    if (i == nbCache) {

	cmp	ecx, edi
	jne	SHORT $LN116@xmlReconci

; 6344 : 	        /*
; 6345 : 		 * OK we need to recreate a new namespace definition
; 6346 : 		 */
; 6347 : 		n = xmlNewReconciliedNs(doc, tree, node->ns);

	push	DWORD PTR [esi+36]
	push	DWORD PTR _tree$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewReconciliedNs
	mov	edx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$1$[ebp], edx

; 6348 : 		if (n != NULL) { /* :-( what if else ??? */

	test	edx, edx
	je	SHORT $LN116@xmlReconci

; 6349 : 		    /*
; 6350 : 		     * check if we need to grow the cache buffers.
; 6351 : 		     */
; 6352 : 		    if (sizeCache <= nbCache) {

	mov	eax, DWORD PTR _sizeCache$1$[ebp]
	cmp	eax, edi
	jg	$LN113@xmlReconci

; 6353 : 		        sizeCache *= 2;

	add	eax, eax
	mov	DWORD PTR _sizeCache$1$[ebp], eax

; 6354 : 			oldNs = (xmlNsPtr *) xmlRealloc(oldNs, sizeCache *

	shl	eax, 2
	push	eax
	push	ebx
	mov	DWORD PTR tv545[ebp], eax
	call	DWORD PTR _xmlRealloc
	mov	ebx, eax
	add	esp, 8

; 6355 : 			                               sizeof(xmlNsPtr));
; 6356 : 		        if (oldNs == NULL) {

	test	ebx, ebx
	je	$LN76@xmlReconci

; 6359 : 			    return(-1);
; 6360 : 			}
; 6361 : 			newNs = (xmlNsPtr *) xmlRealloc(newNs, sizeCache *

	push	DWORD PTR tv545[ebp]
	push	DWORD PTR _newNs$1$[ebp]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _newNs$1$[ebp], ecx

; 6362 : 			                               sizeof(xmlNsPtr));
; 6363 : 		        if (newNs == NULL) {

	test	ecx, ecx
	je	$LN75@xmlReconci

; 6349 : 		    /*
; 6350 : 		     * check if we need to grow the cache buffers.
; 6351 : 		     */
; 6352 : 		    if (sizeCache <= nbCache) {

	mov	edx, DWORD PTR _n$1$[ebp]
$LN28@xmlReconci:

; 6364 : 			    xmlTreeErrMemory("fixing namespaces");
; 6365 : 			    xmlFree(oldNs);
; 6366 : 			    return(-1);
; 6367 : 			}
; 6368 : 		    }
; 6369 : 		    newNs[nbCache] = n;

	mov	DWORD PTR [ecx+edi*4], edx

; 6370 : 		    oldNs[nbCache++] = node->ns;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx+edi*4], eax
	inc	edi

; 6371 : 		    node->ns = n;

	mov	DWORD PTR [esi+36], edx
$LN116@xmlReconci:

; 6372 :                 }
; 6373 : 	    }
; 6374 : 	}
; 6375 : 	/*
; 6376 : 	 * now check for namespace hold by attributes on the node.
; 6377 : 	 */
; 6378 : 	if (node->type == XML_ELEMENT_NODE) {

	mov	ecx, DWORD PTR _sizeCache$1$[ebp]
$LN25@xmlReconci:
	cmp	DWORD PTR [esi+4], 1
	jne	$LN8@xmlReconci

; 6379 : 	    attr = node->properties;

	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR _attr$1$[ebp], edx

; 6380 : 	    while (attr != NULL) {

	test	edx, edx
	je	$LN8@xmlReconci
$LL7@xmlReconci:

; 6381 : 		if (attr->ns != NULL) {

	cmp	DWORD PTR [edx+36], 0
	je	$LN36@xmlReconci

; 6382 : 		    /*
; 6383 : 		     * initialize the cache if needed
; 6384 : 		     */
; 6385 : 		    if (sizeCache == 0) {

	test	ecx, ecx
	jne	SHORT $LN33@xmlReconci

; 6386 : 			sizeCache = 10;
; 6387 : 			oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *

	push	40					; 00000028H
	mov	DWORD PTR _sizeCache$1$[ebp], 10	; 0000000aH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 6388 : 						       sizeof(xmlNsPtr));
; 6389 : 			if (oldNs == NULL) {

	test	ebx, ebx
	je	$LN68@xmlReconci

; 6390 : 			    xmlTreeErrMemory("fixing namespaces");
; 6391 : 			    return(-1);
; 6392 : 			}
; 6393 : 			newNs = (xmlNsPtr *) xmlMalloc(sizeCache *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _newNs$1$[ebp], ecx

; 6394 : 						       sizeof(xmlNsPtr));
; 6395 : 			if (newNs == NULL) {

	test	ecx, ecx
	je	$LN69@xmlReconci
	mov	edx, DWORD PTR _attr$1$[ebp]
$LN33@xmlReconci:

; 6396 : 			    xmlTreeErrMemory("fixing namespaces");
; 6397 : 			    xmlFree(oldNs);
; 6398 : 			    return(-1);
; 6399 : 			}
; 6400 : 		    }
; 6401 : 		    for (i = 0;i < nbCache;i++) {

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN10@xmlReconci

; 6402 : 			if (oldNs[i] == attr->ns) {

	mov	ecx, DWORD PTR [edx+36]
$LL11@xmlReconci:
	cmp	DWORD PTR [ebx+eax*4], ecx
	je	SHORT $LN67@xmlReconci

; 6396 : 			    xmlTreeErrMemory("fixing namespaces");
; 6397 : 			    xmlFree(oldNs);
; 6398 : 			    return(-1);
; 6399 : 			}
; 6400 : 		    }
; 6401 : 		    for (i = 0;i < nbCache;i++) {

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL11@xmlReconci

; 6362 : 			                               sizeof(xmlNsPtr));
; 6363 : 		        if (newNs == NULL) {

	jmp	SHORT $LN10@xmlReconci
$LN113@xmlReconci:

; 6349 : 		    /*
; 6350 : 		     * check if we need to grow the cache buffers.
; 6351 : 		     */
; 6352 : 		    if (sizeCache <= nbCache) {

	mov	ecx, DWORD PTR _newNs$1$[ebp]
	jmp	$LN28@xmlReconci
$LN67@xmlReconci:

; 6403 : 			    attr->ns = newNs[i];

	mov	ecx, DWORD PTR _newNs$1$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+36], ecx
$LN10@xmlReconci:

; 6404 : 			    break;
; 6405 : 			}
; 6406 : 		    }
; 6407 : 		    if (i == nbCache) {

	cmp	eax, edi
	jne	$LN36@xmlReconci

; 6408 : 			/*
; 6409 : 			 * OK we need to recreate a new namespace definition
; 6410 : 			 */
; 6411 : 			n = xmlNewReconciliedNs(doc, tree, attr->ns);

	push	DWORD PTR [edx+36]
	push	DWORD PTR _tree$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewReconciliedNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$2$[ebp], eax

; 6412 : 			if (n != NULL) { /* :-( what if else ??? */

	test	eax, eax
	je	SHORT $LN111@xmlReconci

; 6413 : 			    /*
; 6414 : 			     * check if we need to grow the cache buffers.
; 6415 : 			     */
; 6416 : 			    if (sizeCache <= nbCache) {

	mov	ecx, DWORD PTR _sizeCache$1$[ebp]
	cmp	ecx, edi
	jg	SHORT $LN112@xmlReconci

; 6417 : 				sizeCache *= 2;

	add	ecx, ecx
	mov	DWORD PTR _sizeCache$1$[ebp], ecx

; 6418 : 				oldNs = (xmlNsPtr *) xmlRealloc(oldNs,

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	ebx
	call	DWORD PTR _xmlRealloc
	mov	ebx, eax
	add	esp, 8

; 6419 : 				           sizeCache * sizeof(xmlNsPtr));
; 6420 : 				if (oldNs == NULL) {

	test	ebx, ebx
	je	$LN70@xmlReconci

; 6423 : 				    return(-1);
; 6424 : 				}
; 6425 : 				newNs = (xmlNsPtr *) xmlRealloc(newNs,

	mov	ecx, DWORD PTR _sizeCache$1$[ebp]
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	DWORD PTR _newNs$1$[ebp]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _newNs$1$[ebp], ecx

; 6426 : 				           sizeCache * sizeof(xmlNsPtr));
; 6427 : 				if (newNs == NULL) {

	test	ecx, ecx
	je	$LN69@xmlReconci

; 6413 : 			    /*
; 6414 : 			     * check if we need to grow the cache buffers.
; 6415 : 			     */
; 6416 : 			    if (sizeCache <= nbCache) {

	mov	eax, DWORD PTR _n$2$[ebp]
$LN39@xmlReconci:

; 6428 : 				    xmlTreeErrMemory("fixing namespaces");
; 6429 : 				    xmlFree(oldNs);
; 6430 : 				    return(-1);
; 6431 : 				}
; 6432 : 			    }
; 6433 : 			    newNs[nbCache] = n;
; 6434 : 			    oldNs[nbCache++] = attr->ns;

	mov	edx, DWORD PTR _attr$1$[ebp]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ebx+edi*4], eax
	inc	edi

; 6435 : 			    attr->ns = n;

	mov	eax, DWORD PTR _n$2$[ebp]
	mov	DWORD PTR [edx+36], eax
	jmp	SHORT $LN36@xmlReconci
$LN112@xmlReconci:

; 6413 : 			    /*
; 6414 : 			     * check if we need to grow the cache buffers.
; 6415 : 			     */
; 6416 : 			    if (sizeCache <= nbCache) {

	mov	ecx, DWORD PTR _newNs$1$[ebp]
	jmp	SHORT $LN39@xmlReconci
$LN111@xmlReconci:

; 6412 : 			if (n != NULL) { /* :-( what if else ??? */

	mov	edx, DWORD PTR _attr$1$[ebp]
$LN36@xmlReconci:

; 6436 : 			}
; 6437 : 		    }
; 6438 : 		}
; 6439 : 		attr = attr->next;

	mov	edx, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _sizeCache$1$[ebp]
	mov	DWORD PTR _attr$1$[ebp], edx
	test	edx, edx
	jne	$LL7@xmlReconci
$LN8@xmlReconci:

; 6440 : 	    }
; 6441 : 	}
; 6442 : 
; 6443 : 	/*
; 6444 : 	 * Browse the full subtree, deep first
; 6445 : 	 */
; 6446 :         if ((node->children != NULL) && (node->type != XML_ENTITY_REF_NODE)) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN40@xmlReconci
	cmp	DWORD PTR [esi+4], 5
	je	SHORT $LN40@xmlReconci

; 6447 : 	    /* deep first */
; 6448 : 	    node = node->children;

	mov	esi, eax
	jmp	SHORT $LN49@xmlReconci
$LN40@xmlReconci:

; 6449 : 	} else if ((node != tree) && (node->next != NULL)) {

	mov	edx, DWORD PTR _tree$[ebp]
	cmp	esi, edx
	je	SHORT $LN44@xmlReconci
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL12@xmlReconci

; 6450 : 	    /* then siblings */
; 6451 : 	    node = node->next;

	mov	esi, eax
	jmp	SHORT $LN49@xmlReconci
	npad	3
$LL12@xmlReconci:

; 6455 : 	        if (node->parent != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	cmovne	esi, eax

; 6456 : 		    node = node->parent;
; 6457 : 		if ((node != tree) && (node->next != NULL)) {

	cmp	esi, edx
	je	SHORT $LN47@xmlReconci
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN72@xmlReconci
$LN47@xmlReconci:

; 6460 : 		}
; 6461 : 		if (node->parent == NULL) {

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN73@xmlReconci

; 6452 : 	} else if (node != tree) {
; 6453 : 	    /* go up to parents->next if needed */
; 6454 : 	    while (node != tree) {

	cmp	esi, edx
	jne	SHORT $LL12@xmlReconci
$LN44@xmlReconci:

; 6468 : 	        node = NULL;
; 6469 : 	} else
; 6470 : 	    break;
; 6471 :     }
; 6472 :     if (oldNs != NULL)

	test	ebx, ebx
	je	SHORT $LN50@xmlReconci

; 6473 : 	xmlFree(oldNs);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlReconci:

; 6474 :     if (newNs != NULL)

	mov	eax, DWORD PTR _newNs$1$[ebp]
	test	eax, eax
	je	SHORT $LN51@xmlReconci

; 6475 : 	xmlFree(newNs);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN51@xmlReconci:

; 6476 :     return(ret);
; 6477 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlReconci:

; 6458 : 		    node = node->next;

	mov	esi, eax

; 6459 : 		    break;

	jmp	SHORT $LN13@xmlReconci
$LN73@xmlReconci:

; 6462 : 		    node = NULL;

	xor	esi, esi
$LN13@xmlReconci:

; 6463 : 		    break;
; 6464 : 		}
; 6465 : 	    }
; 6466 : 	    /* exit condition */
; 6467 : 	    if (node == tree)

	cmp	esi, edx
	je	SHORT $LN44@xmlReconci
$LN49@xmlReconci:

; 6313 :     while (node != NULL) {

	test	esi, esi
	je	SHORT $LN44@xmlReconci
	mov	eax, DWORD PTR _newNs$1$[ebp]
	mov	ecx, DWORD PTR _sizeCache$1$[ebp]
	jmp	$LL2@xmlReconci
$LN75@xmlReconci:

; 6476 :     return(ret);
; 6477 : }

	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	call	_xmlTreeErrMemory
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN15@xmlReconci:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlReconci:

; 6326 : 		    xmlTreeErrMemory("fixing namespaces");

	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	call	_xmlTreeErrMemory
	add	esp, 4

; 6476 :     return(ret);
; 6477 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlReconci:

; 6357 : 			    xmlTreeErrMemory("fixing namespaces");

	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	call	_xmlTreeErrMemory

; 6358 : 			    xmlFree(newNs);

	push	DWORD PTR _newNs$1$[ebp]

; 6476 :     return(ret);
; 6477 : }

	call	DWORD PTR _xmlFree
	add	esp, 8
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@xmlReconci:
	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@xmlReconci:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 6476 :     return(ret);
; 6477 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlReconci:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@MPADMMPM@fixing?5namespaces@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError

; 6421 : 				    xmlTreeErrMemory("fixing namespaces");
; 6422 : 				    xmlFree(newNs);

	push	DWORD PTR _newNs$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 6476 :     return(ret);
; 6477 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReconciliateNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferWriteQuotedString
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufferWriteQuotedString PROC			; COMDAT

; 7705 : xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN7@xmlBufferW

; 7706 :     const xmlChar *cur, *base;
; 7707 :     if (buf == NULL)
; 7708 :         return;
; 7709 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;

	cmp	DWORD PTR [esi+12], 2
	je	$LN7@xmlBufferW

; 7710 :     if (xmlStrchr(string, '\"')) {

	push	edi
	mov	edi, DWORD PTR _string$[ebp]
	push	34					; 00000022H
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlBufferW

; 7711 :         if (xmlStrchr(string, '\'')) {

	push	39					; 00000027H
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN8@xmlBufferW

; 7712 : #ifdef DEBUG_BUFFER
; 7713 : 	    xmlGenericError(xmlGenericErrorContext,
; 7714 :  "xmlBufferWriteQuotedString: string contains quote and double-quotes !\n");
; 7715 : #endif
; 7716 : 	    xmlBufferCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	esi
	call	_xmlBufferCCat

; 7717 :             base = cur = string;
; 7718 :             while(*cur != 0){

	mov	al, BYTE PTR [edi]
	add	esp, 8
	mov	ecx, edi
	test	al, al
	je	$LN13@xmlBufferW
$LL2@xmlBufferW:

; 7719 :                 if(*cur == '"'){

	cmp	al, 34					; 00000022H
	jne	SHORT $LN10@xmlBufferW

; 7720 :                     if (base != cur)

	cmp	ecx, edi
	je	SHORT $LN12@xmlBufferW

; 7721 :                         xmlBufferAdd(buf, base, cur - base);

	mov	eax, edi
	sub	eax, ecx
	push	eax
	push	ecx
	push	esi
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN12@xmlBufferW:

; 7507 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	SHORT $LN17@xmlBufferW

; 7508 :     if (len < -1) {
; 7509 : #ifdef DEBUG_BUFFER
; 7510 :         xmlGenericError(xmlGenericErrorContext,
; 7511 : 		"xmlBufferAdd: len < 0\n");
; 7512 : #endif
; 7513 : 	return -1;
; 7514 :     }
; 7515 :     if (len == 0) return 0;
; 7516 : 
; 7517 :     if (len < 0)
; 7518 :         len = xmlStrlen(str);
; 7519 : 
; 7520 :     if (len < 0) return -1;
; 7521 :     if (len == 0) return 0;
; 7522 : 
; 7523 :     needSize = buf->use + len + 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, 8

; 7524 :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [esi+8]
	jbe	SHORT $LN34@xmlBufferW

; 7525 :         if (!xmlBufferResize(buf, needSize)){

	push	eax
	push	esi
	call	_xmlBufferResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@xmlBufferW

; 7526 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7527 :             return XML_ERR_NO_MEMORY;

	jmp	SHORT $LN17@xmlBufferW
$LN34@xmlBufferW:

; 7528 :         }
; 7529 :     }
; 7530 : 
; 7531 :     memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));

	mov	eax, DWORD PTR [esi]
	add	eax, DWORD PTR [esi+4]
	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	push	eax
	call	_memmove

; 7532 :     buf->use += len;
; 7533 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [esi+4], 6
	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR [ecx+eax], 0
$LN17@xmlBufferW:

; 7722 :                     xmlBufferAdd(buf, BAD_CAST "&quot;", 6);
; 7723 :                     cur++;

	lea	ecx, DWORD PTR [edi+1]
$LN10@xmlBufferW:

; 7717 :             base = cur = string;
; 7718 :             while(*cur != 0){

	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL2@xmlBufferW

; 7724 :                     base = cur;
; 7725 :                 }
; 7726 :                 else {
; 7727 :                     cur++;
; 7728 :                 }
; 7729 :             }
; 7730 :             if (base != cur)

	cmp	ecx, edi
	je	SHORT $LN13@xmlBufferW

; 7731 :                 xmlBufferAdd(buf, base, cur - base);

	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN13@xmlBufferW:

; 7732 : 	    xmlBufferCCat(buf, "\"");

	mov	eax, OFFSET ??_C@_01BJJEKLCA@?$CC@

; 7738 :         }
; 7739 :     } else {

	push	eax
	push	esi
	call	_xmlBufferCCat
	add	esp, 8
	pop	edi
	pop	esi

; 7743 :     }
; 7744 : }

	pop	ebp
	ret	0
$LN8@xmlBufferW:

; 7733 : 	}
; 7734 :         else{
; 7735 : 	    xmlBufferCCat(buf, "\'");

	push	OFFSET ??_C@_01GEODFPGF@?8@
	push	esi
	call	_xmlBufferCCat

; 7736 :             xmlBufferCat(buf, string);

	push	edi
	push	esi
	call	_xmlBufferCat
	add	esp, 16					; 00000010H

; 7737 : 	    xmlBufferCCat(buf, "\'");

	mov	eax, OFFSET ??_C@_01GEODFPGF@?8@

; 7738 :         }
; 7739 :     } else {

	push	eax
	push	esi
	call	_xmlBufferCCat
	add	esp, 8
	pop	edi
	pop	esi

; 7743 :     }
; 7744 : }

	pop	ebp
	ret	0
$LN6@xmlBufferW:

; 7740 :         xmlBufferCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	esi
	call	_xmlBufferCCat

; 7741 :         xmlBufferCat(buf, string);

	push	edi
	push	esi
	call	_xmlBufferCat

; 7742 :         xmlBufferCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	esi
	call	_xmlBufferCCat
	add	esp, 24					; 00000018H
	pop	edi
$LN7@xmlBufferW:
	pop	esi

; 7743 :     }
; 7744 : }

	pop	ebp
	ret	0
_xmlBufferWriteQuotedString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferWriteChar
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufferWriteChar PROC				; COMDAT

; 7687 : xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlBufferW

; 7688 :     if (buf == NULL)
; 7689 :         return;
; 7690 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;

	cmp	DWORD PTR [eax+12], 2
	je	SHORT $LN1@xmlBufferW

; 7691 :     xmlBufferCCat(buf, string);

	mov	DWORD PTR _buf$[ebp], eax

; 7692 : }

	pop	ebp

; 7691 :     xmlBufferCCat(buf, string);

	jmp	_xmlBufferCCat
$LN1@xmlBufferW:

; 7692 : }

	pop	ebp
	ret	0
_xmlBufferWriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferWriteCHAR
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_string$ = 12						; size = 4
_xmlBufferWriteCHAR PROC				; COMDAT

; 7671 : xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlBufferW

; 7672 :     if (buf == NULL)
; 7673 :         return;
; 7674 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;

	cmp	DWORD PTR [eax+12], 2
	je	SHORT $LN1@xmlBufferW

; 7675 :     xmlBufferCat(buf, string);

	mov	DWORD PTR _buf$[ebp], eax

; 7676 : }

	pop	ebp

; 7675 :     xmlBufferCat(buf, string);

	jmp	_xmlBufferCat
$LN1@xmlBufferW:

; 7676 : }

	pop	ebp
	ret	0
_xmlBufferWriteCHAR ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlUnsetProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlUnsetProp PROC					; COMDAT

; 6788 : xmlUnsetProp(xmlNodePtr node, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4

; 6486 :     if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))

	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN43@xmlUnsetPr
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN43@xmlUnsetPr
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN43@xmlUnsetPr

; 6487 : 	return(NULL);
; 6488 : 
; 6489 :     if (node->properties != NULL) {

	mov	esi, DWORD PTR [esi+44]
	test	esi, esi
	je	SHORT $LN43@xmlUnsetPr
	npad	6
$LL7@xmlUnsetPr:

; 6490 : 	prop = node->properties;
; 6491 : 	if (nsName == NULL) {
; 6492 : 	    /*
; 6493 : 	    * We want the attr to be in no namespace.
; 6494 : 	    */
; 6495 : 	    do {
; 6496 : 		if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN18@xmlUnsetPr
	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlUnsetPr
$LN18@xmlUnsetPr:

; 6497 : 		    return(prop);
; 6498 : 		}
; 6499 : 		prop = prop->next;

	mov	esi, DWORD PTR [esi+24]

; 6500 : 	    } while (prop != NULL);

	test	esi, esi
	jne	SHORT $LL7@xmlUnsetPr
$LN43@xmlUnsetPr:
	pop	edi

; 6789 :     xmlAttrPtr prop;
; 6790 : 
; 6791 :     prop = xmlGetPropNodeInternal(node, name, NULL, 0);
; 6792 :     if (prop == NULL)
; 6793 : 	return(-1);

	or	eax, -1

; 6797 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlUnsetPr:

; 6794 :     xmlUnlinkNode((xmlNodePtr) prop);

	push	esi
	call	_xmlUnlinkNode

; 6795 :     xmlFreeProp(prop);

	push	esi
	call	_xmlFreeProp
	add	esp, 8

; 6796 :     return(0);

	xor	eax, eax
	pop	edi

; 6797 : }

	pop	esi
	pop	ebp
	ret	0
_xmlUnsetProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlUnsetNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlUnsetNsProp PROC					; COMDAT

; 6809 : xmlUnsetNsProp(xmlNodePtr node, xmlNsPtr ns, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlUnsetNs

; 6810 :     xmlAttrPtr prop;
; 6811 : 
; 6812 :     prop = xmlGetPropNodeInternal(node, name, (ns != NULL) ? ns->href : NULL, 0);

	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN5@xmlUnsetNs
$LN4@xmlUnsetNs:
	xor	eax, eax
$LN5@xmlUnsetNs:
	push	esi
	push	0
	push	eax
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetPropNodeInternal
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6813 :     if (prop == NULL)

	test	esi, esi
	jne	SHORT $LN2@xmlUnsetNs

; 6814 : 	return(-1);

	or	eax, -1
	pop	esi

; 6818 : }

	pop	ebp
	ret	0
$LN2@xmlUnsetNs:

; 6815 :     xmlUnlinkNode((xmlNodePtr) prop);

	push	esi
	call	_xmlUnlinkNode

; 6816 :     xmlFreeProp(prop);

	push	esi
	call	_xmlFreeProp
	add	esp, 8

; 6817 :     return(0);

	xor	eax, eax
	pop	esi

; 6818 : }

	pop	ebp
	ret	0
_xmlUnsetNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlRemoveProp
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlRemoveProp PROC					; COMDAT

; 2112 : xmlRemoveProp(xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _cur$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlRemoveP

; 2113 :     xmlAttrPtr tmp;
; 2114 :     if (cur == NULL) {
; 2115 : #ifdef DEBUG_TREE
; 2116 :         xmlGenericError(xmlGenericErrorContext,
; 2117 : 		"xmlRemoveProp : cur == NULL\n");
; 2118 : #endif
; 2119 : 	return(-1);
; 2120 :     }
; 2121 :     if (cur->parent == NULL) {

	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	je	SHORT $LN3@xmlRemoveP

; 2122 : #ifdef DEBUG_TREE
; 2123 :         xmlGenericError(xmlGenericErrorContext,
; 2124 : 		"xmlRemoveProp : cur->parent == NULL\n");
; 2125 : #endif
; 2126 : 	return(-1);
; 2127 :     }
; 2128 :     tmp = cur->parent->properties;

	mov	eax, DWORD PTR [ecx+44]

; 2129 :     if (tmp == cur) {

	cmp	eax, edx
	jne	SHORT $LN11@xmlRemoveP

; 2130 :         cur->parent->properties = cur->next;

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+44], eax

; 2131 : 		if (cur->next != NULL)

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN9@xmlRemoveP

; 2141 : 	    xmlFreeProp(cur);

	push	edx
	mov	DWORD PTR [eax+28], 0
	call	_xmlFreeProp
	add	esp, 4

; 2142 : 	    return(0);

	xor	eax, eax

; 2151 : }

	pop	ebp
	ret	0
$LN11@xmlRemoveP:

; 2132 : 			cur->next->prev = NULL;
; 2133 : 	xmlFreeProp(cur);
; 2134 : 	return(0);
; 2135 :     }
; 2136 :     while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlRemoveP
$LL2@xmlRemoveP:

; 2137 : 	if (tmp->next == cur) {

	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, edx
	je	SHORT $LN12@xmlRemoveP

; 2143 : 	}
; 2144 :         tmp = tmp->next;

	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL2@xmlRemoveP
$LN3@xmlRemoveP:

; 2145 :     }
; 2146 : #ifdef DEBUG_TREE
; 2147 :     xmlGenericError(xmlGenericErrorContext,
; 2148 : 	    "xmlRemoveProp : attribute not owned by its node\n");
; 2149 : #endif
; 2150 :     return(-1);

	or	eax, -1

; 2151 : }

	pop	ebp
	ret	0
$LN12@xmlRemoveP:

; 2138 : 	    tmp->next = cur->next;

	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR [eax+24], ecx

; 2139 : 	    if (tmp->next != NULL)

	test	ecx, ecx
	je	SHORT $LN9@xmlRemoveP

; 2140 : 		tmp->next->prev = tmp;

	mov	DWORD PTR [ecx+28], eax
$LN9@xmlRemoveP:

; 2141 : 	    xmlFreeProp(cur);

	push	edx
	call	_xmlFreeProp
	add	esp, 4

; 2142 : 	    return(0);

	xor	eax, eax

; 2151 : }

	pop	ebp
	ret	0
_xmlRemoveProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetBase
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_uri$ = 12						; size = 4
_xmlNodeSetBase PROC					; COMDAT

; 5197 : xmlNodeSetBase(xmlNodePtr cur, const xmlChar* uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN13@xmlNodeSet

; 5198 :     xmlNsPtr ns;
; 5199 :     xmlChar* fixed;
; 5200 : 
; 5201 :     if (cur == NULL) return;
; 5202 :     switch(cur->type) {

	mov	eax, DWORD PTR [esi+4]
	add	eax, -3					; fffffffdH
	cmp	eax, 18					; 00000012H
	ja	SHORT $LN2@xmlNodeSet
	movzx	eax, BYTE PTR $LN15@xmlNodeSet[eax]
	jmp	DWORD PTR $LN19@xmlNodeSet[eax*4]
$LN7@xmlNodeSet:

; 5203 :         case XML_TEXT_NODE:
; 5204 :         case XML_CDATA_SECTION_NODE:
; 5205 :         case XML_COMMENT_NODE:
; 5206 :         case XML_DOCUMENT_TYPE_NODE:
; 5207 :         case XML_DOCUMENT_FRAG_NODE:
; 5208 :         case XML_NOTATION_NODE:
; 5209 :         case XML_DTD_NODE:
; 5210 :         case XML_ELEMENT_DECL:
; 5211 :         case XML_ATTRIBUTE_DECL:
; 5212 :         case XML_ENTITY_DECL:
; 5213 :         case XML_PI_NODE:
; 5214 :         case XML_ENTITY_REF_NODE:
; 5215 :         case XML_ENTITY_NODE:
; 5216 : 	case XML_NAMESPACE_DECL:
; 5217 : 	case XML_XINCLUDE_START:
; 5218 : 	case XML_XINCLUDE_END:
; 5219 : 	    return;
; 5220 :         case XML_ELEMENT_NODE:
; 5221 :         case XML_ATTRIBUTE_NODE:
; 5222 : 	    break;
; 5223 :         case XML_DOCUMENT_NODE:
; 5224 : #ifdef LIBXML_DOCB_ENABLED
; 5225 : 	case XML_DOCB_DOCUMENT_NODE:
; 5226 : #endif
; 5227 :         case XML_HTML_DOCUMENT_NODE: {
; 5228 : 	    xmlDocPtr doc = (xmlDocPtr) cur;
; 5229 : 
; 5230 : 	    if (doc->URL != NULL)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN8@xmlNodeSet

; 5231 : 		xmlFree((xmlChar *) doc->URL);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlNodeSet:

; 5232 : 	    if (uri == NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	test	eax, eax
	jne	SHORT $LN9@xmlNodeSet

; 5236 : 	    return;

	mov	DWORD PTR [esi+72], eax
	pop	esi

; 5249 :     }
; 5250 : }

	pop	ebp
	ret	0
$LN9@xmlNodeSet:

; 5233 : 		doc->URL = NULL;
; 5234 : 	    else
; 5235 : 		doc->URL = xmlPathToURI(uri);

	push	eax
	call	_xmlPathToURI
	add	esp, 4

; 5236 : 	    return;

	mov	DWORD PTR [esi+72], eax
	pop	esi

; 5249 :     }
; 5250 : }

	pop	ebp
	ret	0
$LN2@xmlNodeSet:
	push	edi

; 5237 : 	}
; 5238 :     }
; 5239 : 
; 5240 :     ns = xmlSearchNsByHref(cur->doc, cur, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlSearchNsByHref
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 5241 :     if (ns == NULL)

	test	edi, edi
	je	SHORT $LN16@xmlNodeSet

; 5242 : 	return;
; 5243 :     fixed = xmlPathToURI(uri);

	push	ebx
	push	DWORD PTR _uri$[ebp]
	call	_xmlPathToURI
	mov	ebx, eax
	add	esp, 4

; 5244 :     if (fixed != NULL) {

	test	ebx, ebx
	je	SHORT $LN12@xmlNodeSet

; 5245 : 	xmlSetNsProp(cur, ns, BAD_CAST "base", fixed);

	push	ebx
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	edi
	push	esi
	call	_xmlSetNsProp

; 5246 : 	xmlFree(fixed);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi
	pop	esi

; 5249 :     }
; 5250 : }

	pop	ebp
	ret	0
$LN12@xmlNodeSet:

; 5247 :     } else {
; 5248 : 	xmlSetNsProp(cur, ns, BAD_CAST "base", uri);

	push	DWORD PTR _uri$[ebp]
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	edi
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
	pop	ebx
$LN16@xmlNodeSet:
	pop	edi
$LN13@xmlNodeSet:
	pop	esi

; 5249 :     }
; 5250 : }

	pop	ebp
	ret	0
$LN19@xmlNodeSet:
	DD	$LN13@xmlNodeSet
	DD	$LN7@xmlNodeSet
$LN15@xmlNodeSet:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
_xmlNodeSetBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeGetBase
_TEXT	SEGMENT
_newbase$1$ = -4					; size = 4
_doc$ = 8						; size = 4
_doc$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xmlNodeGetBase PROC					; COMDAT

; 5271 : xmlNodeGetBase(const xmlDoc *doc, const xmlNode *cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LN43@xmlNodeGet

; 5272 :     xmlChar *oldbase = NULL;
; 5273 :     xmlChar *base, *newbase;
; 5274 : 
; 5275 :     if ((cur == NULL) && (doc == NULL))

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _doc$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN42@xmlNodeGet
$LN3@xmlNodeGet:
	pop	edi

; 5297 : 	    }
; 5298 : 	    cur = cur->next;
; 5299 : 	}
; 5300 : 	return(NULL);

	xor	eax, eax

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlNodeGet:

; 5276 :         return(NULL);
; 5277 :     if ((cur != NULL) && (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN3@xmlNodeGet

; 5278 :         return(NULL);
; 5279 :     if (doc == NULL) doc = cur->doc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _doc$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN42@xmlNodeGet
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _doc$1$[ebp], eax

; 5280 :     if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {

	test	eax, eax
	je	$LN33@xmlNodeGet
$LN42@xmlNodeGet:
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN33@xmlNodeGet

; 5281 :         cur = doc->children;

	mov	esi, DWORD PTR [eax+12]

; 5282 : 	while ((cur != NULL) && (cur->name != NULL)) {

	test	esi, esi
	je	SHORT $LN3@xmlNodeGet
$LL2@xmlNodeGet:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlNodeGet

; 5283 : 	    if (cur->type != XML_ELEMENT_NODE) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN46@xmlNodeGet

; 5284 : 	        cur = cur->next;
; 5285 : 		continue;
; 5286 : 	    }
; 5287 : 	    if (!xmlStrcasecmp(cur->name, BAD_CAST "html")) {

	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlNodeGet

; 5288 : 	        cur = cur->children;

	mov	esi, DWORD PTR [esi+12]

; 5289 : 		continue;

	jmp	SHORT $LN36@xmlNodeGet
$LN11@xmlNodeGet:

; 5290 : 	    }
; 5291 : 	    if (!xmlStrcasecmp(cur->name, BAD_CAST "head")) {

	push	OFFSET ??_C@_04NEODDMOL@head@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlNodeGet

; 5292 : 	        cur = cur->children;

	mov	esi, DWORD PTR [esi+12]

; 5293 : 		continue;

	jmp	SHORT $LN36@xmlNodeGet
$LN12@xmlNodeGet:

; 5294 : 	    }
; 5295 : 	    if (!xmlStrcasecmp(cur->name, BAD_CAST "base")) {

	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlNodeGet
$LN46@xmlNodeGet:

; 5282 : 	while ((cur != NULL) && (cur->name != NULL)) {

	mov	esi, DWORD PTR [esi+24]
$LN36@xmlNodeGet:
	test	esi, esi
	jne	SHORT $LL2@xmlNodeGet

; 5297 : 	    }
; 5298 : 	    cur = cur->next;
; 5299 : 	}
; 5300 : 	return(NULL);

	pop	edi
	xor	eax, eax

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlNodeGet:

; 5296 :                 return(xmlGetProp(cur, BAD_CAST "href"));

	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	esi
	call	_xmlGetProp
	add	esp, 8
	pop	edi

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlNodeGet:
	push	ebx

; 5301 :     }
; 5302 :     while (cur != NULL) {

	test	esi, esi
	je	$LN5@xmlNodeGet
$LL4@xmlNodeGet:

; 5303 : 	if (cur->type == XML_ENTITY_DECL) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 17					; 00000011H
	je	$LN35@xmlNodeGet

; 5306 : 	}
; 5307 : 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	$LN21@xmlNodeGet

; 6771 :     prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);

	push	DWORD PTR _xmlCheckDTD
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	esi
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H

; 6772 :     if (prop == NULL)

	test	eax, eax
	je	$LN21@xmlNodeGet

; 6773 : 	return(NULL);
; 6774 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	mov	ebx, eax
	add	esp, 4

; 5308 : 	    base = xmlGetNsProp(cur, BAD_CAST "base", XML_XML_NAMESPACE);
; 5309 : 	    if (base != NULL) {

	test	ebx, ebx
	je	SHORT $LN21@xmlNodeGet

; 5310 : 		if (oldbase != NULL) {

	test	edi, edi
	je	SHORT $LN17@xmlNodeGet

; 5311 : 		    newbase = xmlBuildURI(oldbase, base);

	push	ebx
	push	edi
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _newbase$1$[ebp], eax

; 5312 : 		    if (newbase != NULL) {

	push	edi
	test	eax, eax
	je	$LN19@xmlNodeGet

; 5313 : 			xmlFree(oldbase);

	call	DWORD PTR _xmlFree

; 5314 : 			xmlFree(base);

	push	ebx
	call	DWORD PTR _xmlFree

; 5315 : 			oldbase = newbase;

	mov	edi, DWORD PTR _newbase$1$[ebp]
	add	esp, 8

; 5320 : 		    }
; 5321 : 		} else {

	jmp	SHORT $LN18@xmlNodeGet
$LN17@xmlNodeGet:

; 5322 : 		    oldbase = base;

	mov	edi, ebx
$LN18@xmlNodeGet:

; 5323 : 		}
; 5324 : 		if ((!xmlStrncmp(oldbase, BAD_CAST "http://", 7)) ||
; 5325 : 		    (!xmlStrncmp(oldbase, BAD_CAST "ftp://", 6)) ||

	push	7
	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	push	edi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN23@xmlNodeGet
	push	6
	push	OFFSET ??_C@_06FNAPNHDD@ftp?3?1?1@
	push	edi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@xmlNodeGet
	push	4
	push	OFFSET ??_C@_04KODJDHBJ@urn?3@
	push	edi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@xmlNodeGet
$LN21@xmlNodeGet:

; 5326 : 		    (!xmlStrncmp(oldbase, BAD_CAST "urn:", 4)))
; 5327 : 		    return(oldbase);
; 5328 : 	    }
; 5329 : 	}
; 5330 : 	cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	$LL4@xmlNodeGet

; 5323 : 		}
; 5324 : 		if ((!xmlStrncmp(oldbase, BAD_CAST "http://", 7)) ||
; 5325 : 		    (!xmlStrncmp(oldbase, BAD_CAST "ftp://", 6)) ||

	mov	eax, DWORD PTR _doc$1$[ebp]
$LN5@xmlNodeGet:

; 5331 :     }
; 5332 :     if ((doc != NULL) && (doc->URL != NULL)) {

	test	eax, eax
	je	SHORT $LN23@xmlNodeGet
	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN23@xmlNodeGet

; 5333 : 	if (oldbase == NULL)

	push	eax
	test	edi, edi
	je	SHORT $LN47@xmlNodeGet

; 5334 : 	    return(xmlStrdup(doc->URL));
; 5335 : 	newbase = xmlBuildURI(oldbase, doc->URL);

	push	edi
	call	_xmlBuildURI

; 5336 : 	xmlFree(oldbase);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 5337 : 	return(newbase);

	mov	eax, esi
	pop	ebx
	pop	edi

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlNodeGet:

; 5316 : 		    } else {
; 5317 : 			xmlFree(oldbase);

	call	DWORD PTR _xmlFree

; 5318 : 			xmlFree(base);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8

; 5319 : 			return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlNodeGet:

; 5304 : 	    xmlEntityPtr ent = (xmlEntityPtr) cur;
; 5305 : 	    return(xmlStrdup(ent->URI));

	push	DWORD PTR [esi+64]
$LN47@xmlNodeGet:
	call	_xmlStrdup
	add	esp, 4
	pop	ebx
	pop	edi

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlNodeGet:
	pop	ebx

; 5338 :     }
; 5339 :     return(oldbase);

	mov	eax, edi
	pop	edi

; 5340 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeGetBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetSpacePreserve
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlNodeSetSpacePreserve PROC				; COMDAT

; 5045 : xmlNodeSetSpacePreserve(xmlNodePtr cur, int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlNodeSet

; 5046 :     xmlNsPtr ns;
; 5047 : 
; 5048 :     if (cur == NULL) return;
; 5049 :     switch(cur->type) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jl	SHORT $LN8@xmlNodeSet
	cmp	eax, 21					; 00000015H
	jle	SHORT $LN4@xmlNodeSet
$LN8@xmlNodeSet:

; 5050 :         case XML_TEXT_NODE:
; 5051 :         case XML_CDATA_SECTION_NODE:
; 5052 :         case XML_COMMENT_NODE:
; 5053 :         case XML_DOCUMENT_NODE:
; 5054 :         case XML_DOCUMENT_TYPE_NODE:
; 5055 :         case XML_DOCUMENT_FRAG_NODE:
; 5056 :         case XML_NOTATION_NODE:
; 5057 :         case XML_HTML_DOCUMENT_NODE:
; 5058 :         case XML_DTD_NODE:
; 5059 :         case XML_ELEMENT_DECL:
; 5060 :         case XML_ATTRIBUTE_DECL:
; 5061 :         case XML_ENTITY_DECL:
; 5062 :         case XML_PI_NODE:
; 5063 :         case XML_ENTITY_REF_NODE:
; 5064 :         case XML_ENTITY_NODE:
; 5065 : 	case XML_NAMESPACE_DECL:
; 5066 : 	case XML_XINCLUDE_START:
; 5067 : 	case XML_XINCLUDE_END:
; 5068 : #ifdef LIBXML_DOCB_ENABLED
; 5069 : 	case XML_DOCB_DOCUMENT_NODE:
; 5070 : #endif
; 5071 : 	    return;
; 5072 :         case XML_ELEMENT_NODE:
; 5073 :         case XML_ATTRIBUTE_NODE:
; 5074 : 	    break;
; 5075 :     }
; 5076 :     ns = xmlSearchNsByHref(cur->doc, cur, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 5077 :     if (ns == NULL)

	test	eax, eax
	je	SHORT $LN4@xmlNodeSet

; 5078 : 	return;
; 5079 :     switch (val) {

	mov	ecx, DWORD PTR _val$[ebp]
	sub	ecx, 0
	je	SHORT $LN10@xmlNodeSet
	sub	ecx, 1
	jne	SHORT $LN4@xmlNodeSet

; 5082 : 	break;
; 5083 :     case 1:
; 5084 : 	xmlSetNsProp(cur, ns, BAD_CAST "space", BAD_CAST "preserve");

	push	OFFSET ??_C@_08ILAKLJGO@preserve@

; 5085 : 	break;
; 5086 :     }
; 5087 : }

	push	OFFSET ??_C@_05OLNILLAB@space@
	push	eax
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlNodeSet:

; 5080 :     case 0:
; 5081 : 	xmlSetNsProp(cur, ns, BAD_CAST "space", BAD_CAST "default");

	push	OFFSET ??_C@_07DLHCIBDH@default@

; 5085 : 	break;
; 5086 :     }
; 5087 : }

	push	OFFSET ??_C@_05OLNILLAB@space@
	push	eax
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
$LN4@xmlNodeSet:
	pop	esi
	pop	ebp
	ret	0
_xmlNodeSetSpacePreserve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetLang
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_lang$ = 12						; size = 4
_xmlNodeSetLang PROC					; COMDAT

; 4971 : xmlNodeSetLang(xmlNodePtr cur, const xmlChar *lang) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlNodeSet

; 4972 :     xmlNsPtr ns;
; 4973 : 
; 4974 :     if (cur == NULL) return;
; 4975 :     switch(cur->type) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jl	SHORT $LN6@xmlNodeSet
	cmp	eax, 21					; 00000015H
	jle	SHORT $LN1@xmlNodeSet
$LN6@xmlNodeSet:

; 4976 :         case XML_TEXT_NODE:
; 4977 :         case XML_CDATA_SECTION_NODE:
; 4978 :         case XML_COMMENT_NODE:
; 4979 :         case XML_DOCUMENT_NODE:
; 4980 :         case XML_DOCUMENT_TYPE_NODE:
; 4981 :         case XML_DOCUMENT_FRAG_NODE:
; 4982 :         case XML_NOTATION_NODE:
; 4983 :         case XML_HTML_DOCUMENT_NODE:
; 4984 :         case XML_DTD_NODE:
; 4985 :         case XML_ELEMENT_DECL:
; 4986 :         case XML_ATTRIBUTE_DECL:
; 4987 :         case XML_ENTITY_DECL:
; 4988 :         case XML_PI_NODE:
; 4989 :         case XML_ENTITY_REF_NODE:
; 4990 :         case XML_ENTITY_NODE:
; 4991 : 	case XML_NAMESPACE_DECL:
; 4992 : #ifdef LIBXML_DOCB_ENABLED
; 4993 : 	case XML_DOCB_DOCUMENT_NODE:
; 4994 : #endif
; 4995 : 	case XML_XINCLUDE_START:
; 4996 : 	case XML_XINCLUDE_END:
; 4997 : 	    return;
; 4998 :         case XML_ELEMENT_NODE:
; 4999 :         case XML_ATTRIBUTE_NODE:
; 5000 : 	    break;
; 5001 :     }
; 5002 :     ns = xmlSearchNsByHref(cur->doc, cur, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 5003 :     if (ns == NULL)

	test	eax, eax
	je	SHORT $LN1@xmlNodeSet

; 5004 : 	return;
; 5005 :     xmlSetNsProp(cur, ns, BAD_CAST "lang", lang);

	push	DWORD PTR _lang$[ebp]
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	eax
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
$LN1@xmlNodeSet:
	pop	esi

; 5006 : }

	pop	ebp
	ret	0
_xmlNodeSetLang ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeGetSpacePreserve
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlNodeGetSpacePreserve PROC				; COMDAT

; 5101 : xmlNodeGetSpacePreserve(const xmlNode *cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN19@xmlNodeGet

; 5102 :     xmlChar *space;
; 5103 : 
; 5104 :     if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN19@xmlNodeGet
	npad	4
$LL2@xmlNodeGet:

; 6771 :     prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);

	push	DWORD PTR _xmlCheckDTD
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_05OLNILLAB@space@
	push	esi
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H

; 6772 :     if (prop == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlNodeGet

; 6773 : 	return(NULL);
; 6774 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	mov	edi, eax
	add	esp, 4

; 5106 :     while (cur != NULL) {
; 5107 : 	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
; 5108 : 	if (space != NULL) {

	test	edi, edi
	je	SHORT $LN6@xmlNodeGet

; 5109 : 	    if (xmlStrEqual(space, BAD_CAST "preserve")) {

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlNodeGet

; 5112 : 	    }
; 5113 : 	    if (xmlStrEqual(space, BAD_CAST "default")) {

	push	OFFSET ??_C@_07DLHCIBDH@default@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	push	edi
	test	eax, eax
	jne	SHORT $LN15@xmlNodeGet

; 5116 : 	    }
; 5117 : 	    xmlFree(space);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNodeGet:

; 5118 : 	}
; 5119 : 	cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL2@xmlNodeGet
$LN19@xmlNodeGet:
	pop	edi

; 5105 :         return(-1);

	or	eax, -1

; 5120 :     }
; 5121 :     return(-1);
; 5122 : }

	pop	esi
	pop	ebp
	ret	0
$LN15@xmlNodeGet:

; 5114 : 		xmlFree(space);

	call	DWORD PTR _xmlFree
	add	esp, 4

; 5115 : 		return(0);

	xor	eax, eax
	pop	edi

; 5120 :     }
; 5121 :     return(-1);
; 5122 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlNodeGet:

; 5110 : 		xmlFree(space);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 5111 : 		return(1);

	mov	eax, 1
	pop	edi

; 5120 :     }
; 5121 :     return(-1);
; 5122 : }

	pop	esi
	pop	ebp
	ret	0
_xmlNodeGetSpacePreserve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeGetLang
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlNodeGetLang PROC					; COMDAT

; 5020 : xmlNodeGetLang(const xmlNode *cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN17@xmlNodeGet

; 5021 :     xmlChar *lang;
; 5022 : 
; 5023 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN17@xmlNodeGet
	npad	5
$LL2@xmlNodeGet:

; 6771 :     prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);

	push	DWORD PTR _xmlCheckDTD
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	esi
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H

; 6772 :     if (prop == NULL)

	test	eax, eax
	je	SHORT $LN16@xmlNodeGet

; 6773 : 	return(NULL);
; 6774 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	add	esp, 4

; 5025 :     while (cur != NULL) {
; 5026 :         lang = xmlGetNsProp(cur, BAD_CAST "lang", XML_XML_NAMESPACE);
; 5027 : 	if (lang != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlNodeGet
$LN16@xmlNodeGet:

; 5028 : 	    return(lang);
; 5029 : 	cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL2@xmlNodeGet
$LN17@xmlNodeGet:

; 5024 :         return(NULL);

	xor	eax, eax
$LN1@xmlNodeGet:
	pop	esi

; 5030 :     }
; 5031 :     return(NULL);
; 5032 : }

	pop	ebp
	ret	0
_xmlNodeGetLang ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufGetNodeContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlBufGetNodeContent PROC				; COMDAT

; 5385 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN18@xmlBufGetN

; 5386 :     if ((cur == NULL) || (buf == NULL)) return(-1);

	mov	ebx, DWORD PTR _buf$[ebp]
	test	ebx, ebx
	je	$LN18@xmlBufGetN

; 5387 :     switch (cur->type) {

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN43@xmlBufGetN
	movzx	eax, BYTE PTR $LN93@xmlBufGetN[eax]
	jmp	DWORD PTR $LN117@xmlBufGetN[eax*4]
$LN19@xmlBufGetN:

; 5504 : 	    break;
; 5505 :         case XML_ELEMENT_DECL:
; 5506 :         case XML_ATTRIBUTE_DECL:
; 5507 :         case XML_ENTITY_DECL:
; 5508 :             break;
; 5509 :     }
; 5510 :     return(0);

	push	DWORD PTR [edi+40]
	push	ebx
	call	_xmlBufCat
	add	esp, 8
	xor	eax, eax
	pop	edi

; 5511 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN20@xmlBufGetN:

; 5388 :         case XML_CDATA_SECTION_NODE:
; 5389 :         case XML_TEXT_NODE:
; 5390 : 	    xmlBufCat(buf, cur->content);
; 5391 :             break;
; 5392 :         case XML_DOCUMENT_FRAG_NODE:
; 5393 :         case XML_ELEMENT_NODE:{
; 5394 :                 const xmlNode *tmp = cur;

	mov	esi, edi
$LL4@xmlBufGetN:

; 5397 :                     switch (tmp->type) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jl	SHORT $LN22@xmlBufGetN
	cmp	eax, 4
	jle	SHORT $LN21@xmlBufGetN
	cmp	eax, 5
	jne	SHORT $LN22@xmlBufGetN

; 5402 :                             break;
; 5403 :                         case XML_ENTITY_REF_NODE:
; 5404 :                             xmlBufGetNodeContent(buf, tmp);

	push	esi
	push	ebx
	call	_xmlBufGetNodeContent

; 5405 :                             break;

	jmp	SHORT $LN111@xmlBufGetN
$LN21@xmlBufGetN:

; 5398 :                         case XML_CDATA_SECTION_NODE:
; 5399 :                         case XML_TEXT_NODE:
; 5400 :                             if (tmp->content != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN22@xmlBufGetN

; 5401 :                                 xmlBufCat(buf, tmp->content);

	push	eax
	push	ebx
	call	_xmlBufCat
$LN111@xmlBufGetN:

; 5406 :                         default:
; 5407 :                             break;
; 5408 :                     }
; 5409 :                     /*
; 5410 :                      * Skip to next node
; 5411 :                      */
; 5412 :                     if (tmp->children != NULL) {

	add	esp, 8
$LN22@xmlBufGetN:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN26@xmlBufGetN

; 5413 :                         if (tmp->children->type != XML_ENTITY_DECL) {

	cmp	DWORD PTR [eax+4], 17			; 00000011H
	jne	SHORT $LN112@xmlBufGetN

; 5414 :                             tmp = tmp->children;
; 5415 :                             continue;
; 5416 :                         }
; 5417 :                     }
; 5418 :                     if (tmp == cur)
; 5419 :                         break;
; 5420 : 
; 5421 :                     if (tmp->next != NULL) {
; 5422 :                         tmp = tmp->next;
; 5423 :                         continue;

	jmp	SHORT $LN26@xmlBufGetN
$LL10@xmlBufGetN:

; 5424 :                     }
; 5425 : 
; 5426 :                     do {
; 5427 :                         tmp = tmp->parent;

	mov	esi, DWORD PTR [esi+20]

; 5428 :                         if (tmp == NULL)

	test	esi, esi
	je	$LN43@xmlBufGetN
$LN26@xmlBufGetN:

; 5395 : 
; 5396 :                 while (tmp != NULL) {

	cmp	esi, edi
	je	$LN43@xmlBufGetN
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL10@xmlBufGetN
$LN112@xmlBufGetN:
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@xmlBufGetN

; 5511 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN32@xmlBufGetN:

; 5429 :                             break;
; 5430 :                         if (tmp == cur) {
; 5431 :                             tmp = NULL;
; 5432 :                             break;
; 5433 :                         }
; 5434 :                         if (tmp->next != NULL) {
; 5435 :                             tmp = tmp->next;
; 5436 :                             break;
; 5437 :                         }
; 5438 :                     } while (tmp != NULL);
; 5439 :                 }
; 5440 : 		break;
; 5441 :             }
; 5442 :         case XML_ATTRIBUTE_NODE:{
; 5443 :                 xmlAttrPtr attr = (xmlAttrPtr) cur;
; 5444 : 		xmlNodePtr tmp = attr->children;

	mov	esi, DWORD PTR [edi+12]

; 5445 : 
; 5446 : 		while (tmp != NULL) {

	test	esi, esi
	je	$LN43@xmlBufGetN
$LL11@xmlBufGetN:

; 5447 : 		    if (tmp->type == XML_TEXT_NODE)

	cmp	DWORD PTR [esi+4], 3
	jne	SHORT $LN33@xmlBufGetN

; 5448 : 		        xmlBufCat(buf, tmp->content);

	push	DWORD PTR [esi+40]
	push	ebx
	call	_xmlBufCat
	jmp	SHORT $LN115@xmlBufGetN
$LN33@xmlBufGetN:

; 5449 : 		    else
; 5450 : 		        xmlBufGetNodeContent(buf, tmp);

	push	esi
	push	ebx
	call	_xmlBufGetNodeContent
$LN115@xmlBufGetN:

; 5451 : 		    tmp = tmp->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL11@xmlBufGetN

; 5511 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN36@xmlBufGetN:

; 5452 : 		}
; 5453 :                 break;
; 5454 :             }
; 5455 :         case XML_COMMENT_NODE:
; 5456 :         case XML_PI_NODE:
; 5457 : 	    xmlBufCat(buf, cur->content);
; 5458 :             break;
; 5459 :         case XML_ENTITY_REF_NODE:{
; 5460 :                 xmlEntityPtr ent;
; 5461 :                 xmlNodePtr tmp;
; 5462 : 
; 5463 :                 /* lookup entity declaration */
; 5464 :                 ent = xmlGetDocEntity(cur->doc, cur->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+32]
	call	_xmlGetDocEntity
	add	esp, 8

; 5465 :                 if (ent == NULL)

	test	eax, eax
	je	SHORT $LN18@xmlBufGetN

; 5466 :                     return(-1);
; 5467 : 
; 5468 :                 /* an entity content can be any "well balanced chunk",
; 5469 :                  * i.e. the result of the content [43] production:
; 5470 :                  * http://www.w3.org/TR/REC-xml#NT-content
; 5471 :                  * -> we iterate through child nodes and recursive call
; 5472 :                  * xmlNodeGetContent() which handles all possible node types */
; 5473 :                 tmp = ent->children;

	mov	esi, DWORD PTR [eax+12]

; 5474 :                 while (tmp) {

	test	esi, esi
	je	SHORT $LN43@xmlBufGetN
$LL13@xmlBufGetN:

; 5475 : 		    xmlBufGetNodeContent(buf, tmp);

	push	esi
	push	ebx
	call	_xmlBufGetNodeContent

; 5476 :                     tmp = tmp->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL13@xmlBufGetN

; 5511 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN39@xmlBufGetN:

; 5477 :                 }
; 5478 : 		break;
; 5479 :             }
; 5480 :         case XML_ENTITY_NODE:
; 5481 :         case XML_DOCUMENT_TYPE_NODE:
; 5482 :         case XML_NOTATION_NODE:
; 5483 :         case XML_DTD_NODE:
; 5484 :         case XML_XINCLUDE_START:
; 5485 :         case XML_XINCLUDE_END:
; 5486 :             break;
; 5487 :         case XML_DOCUMENT_NODE:
; 5488 : #ifdef LIBXML_DOCB_ENABLED
; 5489 :         case XML_DOCB_DOCUMENT_NODE:
; 5490 : #endif
; 5491 :         case XML_HTML_DOCUMENT_NODE:
; 5492 : 	    cur = cur->children;

	mov	esi, DWORD PTR [edi+12]

; 5493 : 	    while (cur!= NULL) {

	test	esi, esi
	je	SHORT $LN43@xmlBufGetN
$LL15@xmlBufGetN:

; 5494 : 		if ((cur->type == XML_ELEMENT_NODE) ||
; 5495 : 		    (cur->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN41@xmlBufGetN
	cmp	eax, 3
	je	SHORT $LN41@xmlBufGetN
	cmp	eax, 4
	jne	SHORT $LN40@xmlBufGetN
$LN41@xmlBufGetN:

; 5496 : 		    (cur->type == XML_CDATA_SECTION_NODE)) {
; 5497 : 		    xmlBufGetNodeContent(buf, cur);

	push	esi
	push	ebx
	call	_xmlBufGetNodeContent
	add	esp, 8
$LN40@xmlBufGetN:

; 5498 : 		}
; 5499 : 		cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL15@xmlBufGetN

; 5511 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN42@xmlBufGetN:

; 5500 : 	    }
; 5501 : 	    break;
; 5502 :         case XML_NAMESPACE_DECL:
; 5503 : 	    xmlBufCat(buf, ((xmlNsPtr) cur)->href);

	push	DWORD PTR [edi+8]

; 5504 : 	    break;
; 5505 :         case XML_ELEMENT_DECL:
; 5506 :         case XML_ATTRIBUTE_DECL:
; 5507 :         case XML_ENTITY_DECL:
; 5508 :             break;
; 5509 :     }
; 5510 :     return(0);

	push	ebx
	call	_xmlBufCat
	add	esp, 8
$LN43@xmlBufGetN:

; 5511 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlBufGetN:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LN117@xmlBufGetN:
	DD	$LN20@xmlBufGetN
	DD	$LN32@xmlBufGetN
	DD	$LN19@xmlBufGetN
	DD	$LN36@xmlBufGetN
	DD	$LN39@xmlBufGetN
	DD	$LN42@xmlBufGetN
	DD	$LN43@xmlBufGetN
$LN93@xmlBufGetN:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	6
	DB	2
	DB	2
	DB	4
	DB	6
	DB	0
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	4
_xmlBufGetNodeContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeBufGetContent
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNodeBufGetContent PROC				; COMDAT

; 5357 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlNodeBuf

; 5358 :     xmlBufPtr buf;
; 5359 :     int ret;
; 5360 : 
; 5361 :     if ((cur == NULL) || (buffer == NULL)) return(-1);

	mov	eax, DWORD PTR _buffer$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlNodeBuf

; 5362 :     buf = xmlBufFromBuffer(buffer);

	push	edi
	push	eax
	call	_xmlBufFromBuffer
	mov	edi, eax

; 5363 :     ret = xmlBufGetNodeContent(buf, cur);

	push	esi
	push	edi
	call	_xmlBufGetNodeContent

; 5364 :     buffer = xmlBufBackToBuffer(buf);

	push	edi
	mov	esi, eax
	call	_xmlBufBackToBuffer
	add	esp, 16					; 00000010H

; 5365 :     if ((ret < 0) || (buffer == NULL))

	pop	edi
	test	esi, esi
	js	SHORT $LN3@xmlNodeBuf
	test	eax, eax
	je	SHORT $LN3@xmlNodeBuf

; 5366 :         return(-1);
; 5367 :     return(0);

	xor	eax, eax
	pop	esi

; 5368 : }

	pop	ebp
	ret	0
$LN3@xmlNodeBuf:

; 5358 :     xmlBufPtr buf;
; 5359 :     int ret;
; 5360 : 
; 5361 :     if ((cur == NULL) || (buffer == NULL)) return(-1);

	or	eax, -1
	pop	esi

; 5368 : }

	pop	ebp
	ret	0
_xmlNodeBufGetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeGetContent
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlNodeGetContent PROC					; COMDAT

; 5526 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN2@xmlNodeGet

; 5527 :     if (cur == NULL)
; 5528 :         return (NULL);
; 5529 :     switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN2@xmlNodeGet
	movzx	eax, BYTE PTR $LN23@xmlNodeGet[eax]
	jmp	DWORD PTR $LN28@xmlNodeGet[eax*4]
$LN5@xmlNodeGet:

; 5530 :         case XML_DOCUMENT_FRAG_NODE:
; 5531 :         case XML_ELEMENT_NODE:{
; 5532 :                 xmlBufPtr buf;
; 5533 :                 xmlChar *ret;
; 5534 : 
; 5535 :                 buf = xmlBufCreateSize(64);

	push	64					; 00000040H
	call	_xmlBufCreateSize
	add	esp, 4
$LN26@xmlNodeGet:

; 5617 : }

	mov	edi, eax
	test	edi, edi
	je	SHORT $LN2@xmlNodeGet
	push	esi
	push	edi
	call	_xmlBufGetNodeContent
	push	edi
	call	_xmlBufDetach
	push	edi
	mov	esi, eax
	call	_xmlBufFree
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlNodeGet:

; 5536 :                 if (buf == NULL)
; 5537 :                     return (NULL);
; 5538 : 		xmlBufGetNodeContent(buf, cur);
; 5539 :                 ret = xmlBufDetach(buf);
; 5540 :                 xmlBufFree(buf);
; 5541 :                 return (ret);
; 5542 :             }
; 5543 :         case XML_ATTRIBUTE_NODE:
; 5544 : 	    return(xmlGetPropNodeValueInternal((xmlAttrPtr) cur));

	push	esi
	call	_xmlGetPropNodeValueInternal
	add	esp, 4
	pop	edi

; 5617 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlNodeGet:
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN2@xmlNodeGet
	pop	edi
	pop	esi
	mov	DWORD PTR _cur$[ebp], eax
	pop	ebp
	jmp	_xmlStrdup
$LN10@xmlNodeGet:

; 5545 :         case XML_COMMENT_NODE:
; 5546 :         case XML_PI_NODE:
; 5547 :             if (cur->content != NULL)
; 5548 :                 return (xmlStrdup(cur->content));
; 5549 :             return (NULL);
; 5550 :         case XML_ENTITY_REF_NODE:{
; 5551 :                 xmlEntityPtr ent;
; 5552 :                 xmlBufPtr buf;
; 5553 :                 xmlChar *ret;
; 5554 : 
; 5555 :                 /* lookup entity declaration */
; 5556 :                 ent = xmlGetDocEntity(cur->doc, cur->name);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+32]
	call	_xmlGetDocEntity
	add	esp, 8

; 5557 :                 if (ent == NULL)

	test	eax, eax
	je	SHORT $LN2@xmlNodeGet
$LN14@xmlNodeGet:

; 5617 : }

	call	_xmlBufCreate
	jmp	SHORT $LN26@xmlNodeGet
$LN16@xmlNodeGet:

; 5558 :                     return (NULL);
; 5559 : 
; 5560 :                 buf = xmlBufCreate();
; 5561 :                 if (buf == NULL)
; 5562 :                     return (NULL);
; 5563 : 
; 5564 :                 xmlBufGetNodeContent(buf, cur);
; 5565 : 
; 5566 :                 ret = xmlBufDetach(buf);
; 5567 :                 xmlBufFree(buf);
; 5568 :                 return (ret);
; 5569 :             }
; 5570 :         case XML_ENTITY_NODE:
; 5571 :         case XML_DOCUMENT_TYPE_NODE:
; 5572 :         case XML_NOTATION_NODE:
; 5573 :         case XML_DTD_NODE:
; 5574 :         case XML_XINCLUDE_START:
; 5575 :         case XML_XINCLUDE_END:
; 5576 :             return (NULL);
; 5577 :         case XML_DOCUMENT_NODE:
; 5578 : #ifdef LIBXML_DOCB_ENABLED
; 5579 :         case XML_DOCB_DOCUMENT_NODE:
; 5580 : #endif
; 5581 :         case XML_HTML_DOCUMENT_NODE: {
; 5582 : 	    xmlBufPtr buf;
; 5583 : 	    xmlChar *ret;
; 5584 : 
; 5585 : 	    buf = xmlBufCreate();
; 5586 : 	    if (buf == NULL)
; 5587 : 		return (NULL);
; 5588 : 
; 5589 : 	    xmlBufGetNodeContent(buf, (xmlNodePtr) cur);
; 5590 : 
; 5591 : 	    ret = xmlBufDetach(buf);
; 5592 : 	    xmlBufFree(buf);
; 5593 : 	    return (ret);
; 5594 : 	}
; 5595 :         case XML_NAMESPACE_DECL: {
; 5596 : 	    xmlChar *tmp;
; 5597 : 
; 5598 : 	    tmp = xmlStrdup(((xmlNsPtr) cur)->href);

	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 5617 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlNodeGet:
	pop	edi

; 5599 :             return (tmp);
; 5600 : 	}
; 5601 :         case XML_ELEMENT_DECL:
; 5602 :             /* TODO !!! */
; 5603 :             return (NULL);
; 5604 :         case XML_ATTRIBUTE_DECL:
; 5605 :             /* TODO !!! */
; 5606 :             return (NULL);
; 5607 :         case XML_ENTITY_DECL:
; 5608 :             /* TODO !!! */
; 5609 :             return (NULL);
; 5610 :         case XML_CDATA_SECTION_NODE:
; 5611 :         case XML_TEXT_NODE:
; 5612 :             if (cur->content != NULL)
; 5613 :                 return (xmlStrdup(cur->content));
; 5614 :             return (NULL);
; 5615 :     }
; 5616 :     return (NULL);

	xor	eax, eax

; 5617 : }

	pop	esi
	pop	ebp
	ret	0
$LN28@xmlNodeGet:
	DD	$LN5@xmlNodeGet
	DD	$LN7@xmlNodeGet
	DD	$LN8@xmlNodeGet
	DD	$LN10@xmlNodeGet
	DD	$LN2@xmlNodeGet
	DD	$LN14@xmlNodeGet
	DD	$LN16@xmlNodeGet
$LN23@xmlNodeGet:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	4
	DB	2
	DB	2
	DB	5
	DB	4
	DB	0
	DB	4
	DB	5
	DB	4
	DB	4
	DB	4
	DB	4
	DB	6
	DB	4
	DB	4
	DB	5
_xmlNodeGetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeAddContentLen
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_content$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNodeAddContentLen PROC				; COMDAT

; 5781 : xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN12@xmlNodeAdd

; 5782 :     if (cur == NULL) {
; 5783 : #ifdef DEBUG_TREE
; 5784 :         xmlGenericError(xmlGenericErrorContext,
; 5785 : 		"xmlNodeAddContentLen : node == NULL\n");
; 5786 : #endif
; 5787 : 	return;
; 5788 :     }
; 5789 :     if (len <= 0) return;

	push	edi
	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jle	$LN21@xmlNodeAdd

; 5790 :     switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 11					; 0000000bH
	ja	$LN21@xmlNodeAdd
	movzx	eax, BYTE PTR $LN20@xmlNodeAdd[eax]
	push	ebx
	jmp	DWORD PTR $LN25@xmlNodeAdd[eax*4]
$LN6@xmlNodeAdd:

; 5791 :         case XML_DOCUMENT_FRAG_NODE:
; 5792 :         case XML_ELEMENT_NODE: {
; 5793 : 	    xmlNodePtr last, newNode, tmp;
; 5794 : 
; 5795 : 	    last = cur->last;

	mov	ebx, DWORD PTR [esi+16]

; 5796 : 	    newNode = xmlNewTextLen(content, len);

	push	edi
	push	DWORD PTR _content$[ebp]
	call	_xmlNewTextLen
	mov	edi, eax
	add	esp, 8

; 5797 : 	    if (newNode != NULL) {

	test	edi, edi
	je	$LN22@xmlNodeAdd

; 5798 : 		tmp = xmlAddChild(cur, newNode);

	push	edi
	push	esi
	call	_xmlAddChild
	add	esp, 8

; 5799 : 		if (tmp != newNode)

	cmp	eax, edi
	jne	SHORT $LN22@xmlNodeAdd

; 5800 : 		    return;
; 5801 : 	        if ((last != NULL) && (last->next == newNode)) {

	test	ebx, ebx
	je	SHORT $LN22@xmlNodeAdd
	cmp	DWORD PTR [ebx+24], edi
	jne	SHORT $LN22@xmlNodeAdd

; 5802 : 		    xmlTextMerge(last, newNode);

	push	edi
	push	ebx
	call	_xmlTextMerge
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 5826 :             }
; 5827 :         case XML_DOCUMENT_NODE:
; 5828 :         case XML_DTD_NODE:
; 5829 :         case XML_HTML_DOCUMENT_NODE:
; 5830 :         case XML_DOCUMENT_TYPE_NODE:
; 5831 : 	case XML_NAMESPACE_DECL:
; 5832 : 	case XML_XINCLUDE_START:
; 5833 : 	case XML_XINCLUDE_END:
; 5834 : #ifdef LIBXML_DOCB_ENABLED
; 5835 : 	case XML_DOCB_DOCUMENT_NODE:
; 5836 : #endif
; 5837 : 	    break;
; 5838 :         case XML_ELEMENT_DECL:
; 5839 :         case XML_ATTRIBUTE_DECL:
; 5840 :         case XML_ENTITY_DECL:
; 5841 : 	    break;
; 5842 :     }
; 5843 : }

	pop	ebp
	ret	0
$LN11@xmlNodeAdd:

; 5803 : 		}
; 5804 : 	    }
; 5805 : 	    break;
; 5806 : 	}
; 5807 :         case XML_ATTRIBUTE_NODE:
; 5808 : 	    break;
; 5809 :         case XML_TEXT_NODE:
; 5810 :         case XML_CDATA_SECTION_NODE:
; 5811 :         case XML_ENTITY_REF_NODE:
; 5812 :         case XML_ENTITY_NODE:
; 5813 :         case XML_PI_NODE:
; 5814 :         case XML_COMMENT_NODE:
; 5815 :         case XML_NOTATION_NODE:
; 5816 : 	    if (content != NULL) {

	mov	ebx, DWORD PTR _content$[ebp]
	test	ebx, ebx
	je	SHORT $LN22@xmlNodeAdd

; 5817 : 	        if ((cur->content == (xmlChar *) &(cur->properties)) ||

	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR [esi+44]
	cmp	ecx, eax
	je	SHORT $LN19@xmlNodeAdd
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN13@xmlNodeAdd
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN13@xmlNodeAdd
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xmlNodeAdd
$LN13@xmlNodeAdd:

; 5823 : 		    break;
; 5824 : 		}
; 5825 : 		cur->content = xmlStrncat(cur->content, content, len);

	push	edi
	push	ebx
	push	DWORD PTR [esi+40]
	call	_xmlStrncat
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+40], eax
	pop	ebx
	pop	edi
	pop	esi

; 5826 :             }
; 5827 :         case XML_DOCUMENT_NODE:
; 5828 :         case XML_DTD_NODE:
; 5829 :         case XML_HTML_DOCUMENT_NODE:
; 5830 :         case XML_DOCUMENT_TYPE_NODE:
; 5831 : 	case XML_NAMESPACE_DECL:
; 5832 : 	case XML_XINCLUDE_START:
; 5833 : 	case XML_XINCLUDE_END:
; 5834 : #ifdef LIBXML_DOCB_ENABLED
; 5835 : 	case XML_DOCB_DOCUMENT_NODE:
; 5836 : #endif
; 5837 : 	    break;
; 5838 :         case XML_ELEMENT_DECL:
; 5839 :         case XML_ATTRIBUTE_DECL:
; 5840 :         case XML_ENTITY_DECL:
; 5841 : 	    break;
; 5842 :     }
; 5843 : }

	pop	ebp
	ret	0
$LN19@xmlNodeAdd:

; 5818 : 		    ((cur->doc != NULL) && (cur->doc->dict != NULL) &&
; 5819 : 			    xmlDictOwns(cur->doc->dict, cur->content))) {
; 5820 : 		    cur->content = xmlStrncatNew(cur->content, content, len);

	push	edi
	push	ebx
	push	DWORD PTR [esi+40]
	call	_xmlStrncatNew

; 5821 : 		    cur->properties = NULL;

	mov	DWORD PTR [esi+44], 0
	add	esp, 12					; 0000000cH

; 5822 : 		    cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+40], eax
$LN22@xmlNodeAdd:
	pop	ebx
$LN21@xmlNodeAdd:
	pop	edi
$LN12@xmlNodeAdd:
	pop	esi

; 5826 :             }
; 5827 :         case XML_DOCUMENT_NODE:
; 5828 :         case XML_DTD_NODE:
; 5829 :         case XML_HTML_DOCUMENT_NODE:
; 5830 :         case XML_DOCUMENT_TYPE_NODE:
; 5831 : 	case XML_NAMESPACE_DECL:
; 5832 : 	case XML_XINCLUDE_START:
; 5833 : 	case XML_XINCLUDE_END:
; 5834 : #ifdef LIBXML_DOCB_ENABLED
; 5835 : 	case XML_DOCB_DOCUMENT_NODE:
; 5836 : #endif
; 5837 : 	    break;
; 5838 :         case XML_ELEMENT_DECL:
; 5839 :         case XML_ATTRIBUTE_DECL:
; 5840 :         case XML_ENTITY_DECL:
; 5841 : 	    break;
; 5842 :     }
; 5843 : }

	pop	ebp
	ret	0
	npad	3
$LN25@xmlNodeAdd:
	DD	$LN6@xmlNodeAdd
	DD	$LN11@xmlNodeAdd
	DD	$LN22@xmlNodeAdd
$LN20@xmlNodeAdd:
	DB	0
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	0
	DB	1
_xmlNodeAddContentLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeAddContent
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlNodeAddContent PROC					; COMDAT

; 5856 : xmlNodeAddContent(xmlNodePtr cur, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@xmlNodeAdd

; 5857 :     int len;
; 5858 : 
; 5859 :     if (cur == NULL) {
; 5860 : #ifdef DEBUG_TREE
; 5861 :         xmlGenericError(xmlGenericErrorContext,
; 5862 : 		"xmlNodeAddContent : node == NULL\n");
; 5863 : #endif
; 5864 : 	return;
; 5865 :     }
; 5866 :     if (content == NULL) return;

	push	esi
	mov	esi, DWORD PTR _content$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlNodeAdd

; 5867 :     len = xmlStrlen(content);

	push	esi
	call	_xmlStrlen

; 5868 :     xmlNodeAddContentLen(cur, content, len);

	push	eax
	push	esi
	push	DWORD PTR _cur$[ebp]
	call	_xmlNodeAddContentLen
	add	esp, 16					; 00000010H
$LN5@xmlNodeAdd:
	pop	esi
$LN1@xmlNodeAdd:

; 5869 : }

	pop	ebp
	ret	0
_xmlNodeAddContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetContentLen
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_content$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNodeSetContentLen PROC				; COMDAT

; 5707 : xmlNodeSetContentLen(xmlNodePtr cur, const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN22@xmlNodeSet

; 5708 :     if (cur == NULL) {
; 5709 : #ifdef DEBUG_TREE
; 5710 :         xmlGenericError(xmlGenericErrorContext,
; 5711 : 		"xmlNodeSetContentLen : node == NULL\n");
; 5712 : #endif
; 5713 : 	return;
; 5714 :     }
; 5715 :     switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 11					; 0000000bH
	ja	$LN22@xmlNodeSet
	movzx	eax, BYTE PTR $LN28@xmlNodeSet[eax]
	jmp	DWORD PTR $LN30@xmlNodeSet[eax*4]
$LN7@xmlNodeSet:

; 5716 :         case XML_DOCUMENT_FRAG_NODE:
; 5717 :         case XML_ELEMENT_NODE:
; 5718 :         case XML_ATTRIBUTE_NODE:
; 5719 : 	    if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@xmlNodeSet
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN8@xmlNodeSet:

; 5720 : 	    cur->children = xmlStringLenGetNodeList(cur->doc, content, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _content$[ebp]
	push	DWORD PTR [esi+32]
	call	_xmlStringLenGetNodeList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+12], eax

; 5721 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	test	eax, eax
	jne	SHORT $LN24@xmlNodeSet

; 5722 : 	    break;

	mov	DWORD PTR [esi+16], eax
	pop	esi

; 5744 : 	    break;
; 5745 :         case XML_DOCUMENT_NODE:
; 5746 :         case XML_DTD_NODE:
; 5747 :         case XML_HTML_DOCUMENT_NODE:
; 5748 :         case XML_DOCUMENT_TYPE_NODE:
; 5749 : 	case XML_NAMESPACE_DECL:
; 5750 : 	case XML_XINCLUDE_START:
; 5751 : 	case XML_XINCLUDE_END:
; 5752 : #ifdef LIBXML_DOCB_ENABLED
; 5753 : 	case XML_DOCB_DOCUMENT_NODE:
; 5754 : #endif
; 5755 : 	    break;
; 5756 :         case XML_ELEMENT_DECL:
; 5757 : 	    /* TODO !!! */
; 5758 : 	    break;
; 5759 :         case XML_ATTRIBUTE_DECL:
; 5760 : 	    /* TODO !!! */
; 5761 : 	    break;
; 5762 :         case XML_ENTITY_DECL:
; 5763 : 	    /* TODO !!! */
; 5764 : 	    break;
; 5765 :     }
; 5766 : }

	pop	ebp
	ret	0
$LN24@xmlNodeSet:

; 5721 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN5@xmlNodeSet
	npad	5
$LL4@xmlNodeSet:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL4@xmlNodeSet
$LN5@xmlNodeSet:
	mov	DWORD PTR [eax+20], esi

; 5722 : 	    break;

	mov	DWORD PTR [esi+16], eax
	pop	esi

; 5744 : 	    break;
; 5745 :         case XML_DOCUMENT_NODE:
; 5746 :         case XML_DTD_NODE:
; 5747 :         case XML_HTML_DOCUMENT_NODE:
; 5748 :         case XML_DOCUMENT_TYPE_NODE:
; 5749 : 	case XML_NAMESPACE_DECL:
; 5750 : 	case XML_XINCLUDE_START:
; 5751 : 	case XML_XINCLUDE_END:
; 5752 : #ifdef LIBXML_DOCB_ENABLED
; 5753 : 	case XML_DOCB_DOCUMENT_NODE:
; 5754 : #endif
; 5755 : 	    break;
; 5756 :         case XML_ELEMENT_DECL:
; 5757 : 	    /* TODO !!! */
; 5758 : 	    break;
; 5759 :         case XML_ATTRIBUTE_DECL:
; 5760 : 	    /* TODO !!! */
; 5761 : 	    break;
; 5762 :         case XML_ENTITY_DECL:
; 5763 : 	    /* TODO !!! */
; 5764 : 	    break;
; 5765 :     }
; 5766 : }

	pop	ebp
	ret	0
$LN12@xmlNodeSet:

; 5723 :         case XML_TEXT_NODE:
; 5724 :         case XML_CDATA_SECTION_NODE:
; 5725 :         case XML_ENTITY_REF_NODE:
; 5726 :         case XML_ENTITY_NODE:
; 5727 :         case XML_PI_NODE:
; 5728 :         case XML_COMMENT_NODE:
; 5729 :         case XML_NOTATION_NODE:
; 5730 : 	    if ((cur->content != NULL) &&

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN14@xmlNodeSet
	lea	eax, DWORD PTR [esi+44]
	cmp	ecx, eax
	je	SHORT $LN14@xmlNodeSet

; 5731 : 	        (cur->content != (xmlChar *) &(cur->properties))) {
; 5732 : 	        if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@xmlNodeSet
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN15@xmlNodeSet
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlNodeSet
$LN15@xmlNodeSet:

; 5733 : 		    (xmlDictOwns(cur->doc->dict, cur->content))))
; 5734 : 		    xmlFree(cur->content);

	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlNodeSet:

; 5735 : 	    }
; 5736 : 	    if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xmlNodeSet
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN16@xmlNodeSet:

; 5737 : 	    cur->children = cur->last = NULL;
; 5738 : 	    if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+12], 0
	test	eax, eax
	je	SHORT $LN17@xmlNodeSet

; 5739 : 		cur->content = xmlStrndup(content, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8

; 5742 : 	    cur->properties = NULL;

	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], 0

; 5743 : 	    cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], 0
	pop	esi

; 5744 : 	    break;
; 5745 :         case XML_DOCUMENT_NODE:
; 5746 :         case XML_DTD_NODE:
; 5747 :         case XML_HTML_DOCUMENT_NODE:
; 5748 :         case XML_DOCUMENT_TYPE_NODE:
; 5749 : 	case XML_NAMESPACE_DECL:
; 5750 : 	case XML_XINCLUDE_START:
; 5751 : 	case XML_XINCLUDE_END:
; 5752 : #ifdef LIBXML_DOCB_ENABLED
; 5753 : 	case XML_DOCB_DOCUMENT_NODE:
; 5754 : #endif
; 5755 : 	    break;
; 5756 :         case XML_ELEMENT_DECL:
; 5757 : 	    /* TODO !!! */
; 5758 : 	    break;
; 5759 :         case XML_ATTRIBUTE_DECL:
; 5760 : 	    /* TODO !!! */
; 5761 : 	    break;
; 5762 :         case XML_ENTITY_DECL:
; 5763 : 	    /* TODO !!! */
; 5764 : 	    break;
; 5765 :     }
; 5766 : }

	pop	ebp
	ret	0
$LN17@xmlNodeSet:

; 5740 : 	    } else
; 5741 : 		cur->content = NULL;

	xor	eax, eax

; 5742 : 	    cur->properties = NULL;

	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax

; 5743 : 	    cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], eax
$LN22@xmlNodeSet:
	pop	esi

; 5744 : 	    break;
; 5745 :         case XML_DOCUMENT_NODE:
; 5746 :         case XML_DTD_NODE:
; 5747 :         case XML_HTML_DOCUMENT_NODE:
; 5748 :         case XML_DOCUMENT_TYPE_NODE:
; 5749 : 	case XML_NAMESPACE_DECL:
; 5750 : 	case XML_XINCLUDE_START:
; 5751 : 	case XML_XINCLUDE_END:
; 5752 : #ifdef LIBXML_DOCB_ENABLED
; 5753 : 	case XML_DOCB_DOCUMENT_NODE:
; 5754 : #endif
; 5755 : 	    break;
; 5756 :         case XML_ELEMENT_DECL:
; 5757 : 	    /* TODO !!! */
; 5758 : 	    break;
; 5759 :         case XML_ATTRIBUTE_DECL:
; 5760 : 	    /* TODO !!! */
; 5761 : 	    break;
; 5762 :         case XML_ENTITY_DECL:
; 5763 : 	    /* TODO !!! */
; 5764 : 	    break;
; 5765 :     }
; 5766 : }

	pop	ebp
	ret	0
$LN30@xmlNodeSet:
	DD	$LN7@xmlNodeSet
	DD	$LN12@xmlNodeSet
	DD	$LN22@xmlNodeSet
$LN28@xmlNodeSet:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	0
	DB	1
_xmlNodeSetContentLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetContent
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlNodeSetContent PROC					; COMDAT

; 5630 : xmlNodeSetContent(xmlNodePtr cur, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN25@xmlNodeSet

; 5631 :     if (cur == NULL) {
; 5632 : #ifdef DEBUG_TREE
; 5633 :         xmlGenericError(xmlGenericErrorContext,
; 5634 : 		"xmlNodeSetContent : node == NULL\n");
; 5635 : #endif
; 5636 : 	return;
; 5637 :     }
; 5638 :     switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	$LN25@xmlNodeSet
	movzx	eax, BYTE PTR $LN117@xmlNodeSet[eax]
	jmp	DWORD PTR $LN119@xmlNodeSet[eax*4]
$LN7@xmlNodeSet:

; 5639 :         case XML_DOCUMENT_FRAG_NODE:
; 5640 :         case XML_ELEMENT_NODE:
; 5641 :         case XML_ATTRIBUTE_NODE:
; 5642 : 	    if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@xmlNodeSet
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN8@xmlNodeSet:

; 5643 : 	    cur->children = xmlStringGetNodeList(cur->doc, content);

	push	DWORD PTR _content$[ebp]
	push	DWORD PTR [esi+32]
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 5644 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	test	eax, eax
	jne	SHORT $LN113@xmlNodeSet

; 5645 : 	    break;

	mov	DWORD PTR [esi+16], eax
	pop	esi

; 5666 : 	    break;
; 5667 :         case XML_DOCUMENT_NODE:
; 5668 :         case XML_HTML_DOCUMENT_NODE:
; 5669 :         case XML_DOCUMENT_TYPE_NODE:
; 5670 : 	case XML_XINCLUDE_START:
; 5671 : 	case XML_XINCLUDE_END:
; 5672 : #ifdef LIBXML_DOCB_ENABLED
; 5673 : 	case XML_DOCB_DOCUMENT_NODE:
; 5674 : #endif
; 5675 : 	    break;
; 5676 :         case XML_NOTATION_NODE:
; 5677 : 	    break;
; 5678 :         case XML_DTD_NODE:
; 5679 : 	    break;
; 5680 : 	case XML_NAMESPACE_DECL:
; 5681 : 	    break;
; 5682 :         case XML_ELEMENT_DECL:
; 5683 : 	    /* TODO !!! */
; 5684 : 	    break;
; 5685 :         case XML_ATTRIBUTE_DECL:
; 5686 : 	    /* TODO !!! */
; 5687 : 	    break;
; 5688 :         case XML_ENTITY_DECL:
; 5689 : 	    /* TODO !!! */
; 5690 : 	    break;
; 5691 :     }
; 5692 : }

	pop	ebp
	ret	0
$LN113@xmlNodeSet:

; 5644 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN5@xmlNodeSet
	npad	8
$LL4@xmlNodeSet:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL4@xmlNodeSet
$LN5@xmlNodeSet:
	mov	DWORD PTR [eax+20], esi

; 5645 : 	    break;

	mov	DWORD PTR [esi+16], eax
	pop	esi

; 5666 : 	    break;
; 5667 :         case XML_DOCUMENT_NODE:
; 5668 :         case XML_HTML_DOCUMENT_NODE:
; 5669 :         case XML_DOCUMENT_TYPE_NODE:
; 5670 : 	case XML_XINCLUDE_START:
; 5671 : 	case XML_XINCLUDE_END:
; 5672 : #ifdef LIBXML_DOCB_ENABLED
; 5673 : 	case XML_DOCB_DOCUMENT_NODE:
; 5674 : #endif
; 5675 : 	    break;
; 5676 :         case XML_NOTATION_NODE:
; 5677 : 	    break;
; 5678 :         case XML_DTD_NODE:
; 5679 : 	    break;
; 5680 : 	case XML_NAMESPACE_DECL:
; 5681 : 	    break;
; 5682 :         case XML_ELEMENT_DECL:
; 5683 : 	    /* TODO !!! */
; 5684 : 	    break;
; 5685 :         case XML_ATTRIBUTE_DECL:
; 5686 : 	    /* TODO !!! */
; 5687 : 	    break;
; 5688 :         case XML_ENTITY_DECL:
; 5689 : 	    /* TODO !!! */
; 5690 : 	    break;
; 5691 :     }
; 5692 : }

	pop	ebp
	ret	0
$LN12@xmlNodeSet:

; 5646 :         case XML_TEXT_NODE:
; 5647 :         case XML_CDATA_SECTION_NODE:
; 5648 :         case XML_ENTITY_REF_NODE:
; 5649 :         case XML_ENTITY_NODE:
; 5650 :         case XML_PI_NODE:
; 5651 :         case XML_COMMENT_NODE:
; 5652 : 	    if ((cur->content != NULL) &&

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN14@xmlNodeSet
	lea	eax, DWORD PTR [esi+44]
	cmp	ecx, eax
	je	SHORT $LN14@xmlNodeSet

; 5653 : 	        (cur->content != (xmlChar *) &(cur->properties))) {
; 5654 : 	        if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@xmlNodeSet
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $LN15@xmlNodeSet
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlNodeSet
$LN15@xmlNodeSet:

; 5655 : 		    (xmlDictOwns(cur->doc->dict, cur->content))))
; 5656 : 		    xmlFree(cur->content);

	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlNodeSet:

; 5657 : 	    }
; 5658 : 	    if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xmlNodeSet
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN16@xmlNodeSet:

; 5659 : 	    cur->last = cur->children = NULL;
; 5660 : 	    if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	je	SHORT $LN17@xmlNodeSet

; 5661 : 		cur->content = xmlStrdup(content);

	push	eax
	call	_xmlStrdup
	add	esp, 4

; 5664 : 	    cur->properties = NULL;

	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], 0

; 5665 : 	    cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], 0
	pop	esi

; 5666 : 	    break;
; 5667 :         case XML_DOCUMENT_NODE:
; 5668 :         case XML_HTML_DOCUMENT_NODE:
; 5669 :         case XML_DOCUMENT_TYPE_NODE:
; 5670 : 	case XML_XINCLUDE_START:
; 5671 : 	case XML_XINCLUDE_END:
; 5672 : #ifdef LIBXML_DOCB_ENABLED
; 5673 : 	case XML_DOCB_DOCUMENT_NODE:
; 5674 : #endif
; 5675 : 	    break;
; 5676 :         case XML_NOTATION_NODE:
; 5677 : 	    break;
; 5678 :         case XML_DTD_NODE:
; 5679 : 	    break;
; 5680 : 	case XML_NAMESPACE_DECL:
; 5681 : 	    break;
; 5682 :         case XML_ELEMENT_DECL:
; 5683 : 	    /* TODO !!! */
; 5684 : 	    break;
; 5685 :         case XML_ATTRIBUTE_DECL:
; 5686 : 	    /* TODO !!! */
; 5687 : 	    break;
; 5688 :         case XML_ENTITY_DECL:
; 5689 : 	    /* TODO !!! */
; 5690 : 	    break;
; 5691 :     }
; 5692 : }

	pop	ebp
	ret	0
$LN17@xmlNodeSet:

; 5662 : 	    } else
; 5663 : 		cur->content = NULL;

	xor	eax, eax

; 5664 : 	    cur->properties = NULL;

	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax

; 5665 : 	    cur->nsDef = NULL;

	mov	DWORD PTR [esi+48], eax
$LN25@xmlNodeSet:
	pop	esi

; 5666 : 	    break;
; 5667 :         case XML_DOCUMENT_NODE:
; 5668 :         case XML_HTML_DOCUMENT_NODE:
; 5669 :         case XML_DOCUMENT_TYPE_NODE:
; 5670 : 	case XML_XINCLUDE_START:
; 5671 : 	case XML_XINCLUDE_END:
; 5672 : #ifdef LIBXML_DOCB_ENABLED
; 5673 : 	case XML_DOCB_DOCUMENT_NODE:
; 5674 : #endif
; 5675 : 	    break;
; 5676 :         case XML_NOTATION_NODE:
; 5677 : 	    break;
; 5678 :         case XML_DTD_NODE:
; 5679 : 	    break;
; 5680 : 	case XML_NAMESPACE_DECL:
; 5681 : 	    break;
; 5682 :         case XML_ELEMENT_DECL:
; 5683 : 	    /* TODO !!! */
; 5684 : 	    break;
; 5685 :         case XML_ATTRIBUTE_DECL:
; 5686 : 	    /* TODO !!! */
; 5687 : 	    break;
; 5688 :         case XML_ENTITY_DECL:
; 5689 : 	    /* TODO !!! */
; 5690 : 	    break;
; 5691 :     }
; 5692 : }

	pop	ebp
	ret	0
	npad	3
$LN119@xmlNodeSet:
	DD	$LN7@xmlNodeSet
	DD	$LN12@xmlNodeSet
	DD	$LN25@xmlNodeSet
$LN117@xmlNodeSet:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	0
_xmlNodeSetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeListGetRawString
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_buf$1 = 12						; size = 2
_list$ = 12						; size = 4
_inLine$ = 16						; size = 4
_xmlNodeListGetRawString PROC				; COMDAT

; 1767 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LN28@xmlNodeLis

; 1768 :     const xmlNode *node = list;
; 1769 :     xmlChar *ret = NULL;
; 1770 :     xmlEntityPtr ent;
; 1771 : 
; 1772 :     if (list == NULL)
; 1773 :         return (NULL);

	pop	edi
	xor	eax, eax

; 1833 : }

	pop	esi
	pop	ebp
	ret	0
$LN28@xmlNodeLis:
	mov	ecx, DWORD PTR _inLine$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _doc$[ebp]
$LL2@xmlNodeLis:

; 1774 : 
; 1775 :     while (node != NULL) {
; 1776 :         if ((node->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	je	SHORT $LN21@xmlNodeLis
	cmp	eax, 4
	je	SHORT $LN21@xmlNodeLis

; 1784 :                 if (buffer != NULL) {
; 1785 :                     ret = xmlStrcat(ret, buffer);
; 1786 :                     xmlFree(buffer);
; 1787 :                 }
; 1788 :             }
; 1789 :         } else if (node->type == XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	$LN10@xmlNodeLis

; 1790 :             if (inLine) {

	test	ecx, ecx
	je	SHORT $LN12@xmlNodeLis

; 1791 :                 ent = xmlGetDocEntity(doc, node->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlGetDocEntity
	add	esp, 8

; 1792 :                 if (ent != NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlNodeLis

; 1793 :                     xmlChar *buffer;
; 1794 : 
; 1795 :                     /* an entity content can be any "well balanced chunk",
; 1796 :                      * i.e. the result of the content [43] production:
; 1797 :                      * http://www.w3.org/TR/REC-xml#NT-content.
; 1798 :                      * So it can contain text, CDATA section or nested
; 1799 :                      * entity reference nodes (among others).
; 1800 :                      * -> we recursive  call xmlNodeListGetRawString()
; 1801 :                      * which handles these types */
; 1802 :                     buffer =

	push	1
	push	DWORD PTR [eax+12]
	push	ebx
	call	_xmlNodeListGetRawString
	add	esp, 12					; 0000000cH

; 1803 :                         xmlNodeListGetRawString(doc, ent->children, 1);
; 1804 :                     if (buffer != NULL) {
; 1805 :                         ret = xmlStrcat(ret, buffer);
; 1806 :                         xmlFree(buffer);
; 1807 :                     }
; 1808 :                 } else {

	jmp	SHORT $LN33@xmlNodeLis
$LN14@xmlNodeLis:

; 1809 :                     ret = xmlStrcat(ret, node->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlStrcat
	add	esp, 8
	mov	edi, eax

; 1810 :                 }
; 1811 :             } else {

	jmp	SHORT $LN31@xmlNodeLis
$LN12@xmlNodeLis:

; 1812 :                 xmlChar buf[2];
; 1813 : 
; 1814 :                 buf[0] = '&';
; 1815 :                 buf[1] = 0;
; 1816 :                 ret = xmlStrncat(ret, buf, 1);

	push	1
	lea	eax, DWORD PTR _buf$1[ebp]
	mov	WORD PTR _buf$1[ebp], 38		; 00000026H
	push	eax
	push	edi
	call	_xmlStrncat

; 1817 :                 ret = xmlStrcat(ret, node->name);

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlStrcat

; 1818 :                 buf[0] = ';';
; 1819 :                 buf[1] = 0;
; 1820 :                 ret = xmlStrncat(ret, buf, 1);

	push	1
	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	WORD PTR _buf$1[ebp], 59		; 0000003bH
	push	ecx
	push	eax
	call	_xmlStrncat
	add	esp, 32					; 00000020H
	mov	edi, eax
	jmp	SHORT $LN31@xmlNodeLis
$LN21@xmlNodeLis:

; 1777 :             (node->type == XML_CDATA_SECTION_NODE)) {
; 1778 :             if (inLine) {

	mov	eax, DWORD PTR [esi+40]
	push	eax
	test	ecx, ecx
	je	SHORT $LN8@xmlNodeLis

; 1779 :                 ret = xmlStrcat(ret, node->content);

	push	edi
	call	_xmlStrcat
	add	esp, 8
	mov	edi, eax

; 1780 :             } else {

	jmp	SHORT $LN31@xmlNodeLis
$LN8@xmlNodeLis:

; 1781 :                 xmlChar *buffer;
; 1782 : 
; 1783 :                 buffer = xmlEncodeSpecialChars(doc, node->content);

	push	ebx
	call	_xmlEncodeSpecialChars
	add	esp, 8
$LN33@xmlNodeLis:

; 1821 :             }
; 1822 :         }
; 1823 : #if 0
; 1824 :         else {
; 1825 :             xmlGenericError(xmlGenericErrorContext,
; 1826 :                             "xmlGetNodeListString : invalid node type %d\n",
; 1827 :                             node->type);
; 1828 :         }
; 1829 : #endif
; 1830 :         node = node->next;

	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN30@xmlNodeLis
	push	ebx
	push	edi
	call	_xmlStrcat
	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN30@xmlNodeLis:
	mov	ebx, DWORD PTR _doc$[ebp]
$LN31@xmlNodeLis:
	mov	ecx, DWORD PTR _inLine$[ebp]
$LN10@xmlNodeLis:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlNodeLis

; 1831 :     }
; 1832 :     return (ret);

	pop	ebx
	mov	eax, edi
	pop	edi

; 1833 : }

	pop	esi
	pop	ebp
	ret	0
_xmlNodeListGetRawString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeListGetString
_TEXT	SEGMENT
_attr$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_buf$1 = 12						; size = 2
_list$ = 12						; size = 4
_inLine$ = 16						; size = 4
_xmlNodeListGetString PROC				; COMDAT

; 1677 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LN4@xmlNodeLis

; 1678 :     const xmlNode *node = list;
; 1679 :     xmlChar *ret = NULL;
; 1680 :     xmlEntityPtr ent;
; 1681 :     int attr;
; 1682 : 
; 1683 :     if (list == NULL)
; 1684 :         return (NULL);

	pop	edi
	xor	eax, eax

; 1750 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNodeLis:

; 1685 :     if ((list->parent != NULL) && (list->parent->type == XML_ATTRIBUTE_NODE))

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN5@xmlNodeLis
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN5@xmlNodeLis

; 1686 :         attr = 1;

	mov	edx, 1
	jmp	SHORT $LN34@xmlNodeLis
$LN5@xmlNodeLis:

; 1687 :     else
; 1688 :         attr = 0;

	xor	edx, edx
$LN34@xmlNodeLis:
	mov	ecx, DWORD PTR _inLine$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _attr$1$[ebp], edx
$LL2@xmlNodeLis:

; 1689 : 
; 1690 :     while (node != NULL) {
; 1691 :         if ((node->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	je	SHORT $LN25@xmlNodeLis
	cmp	eax, 4
	je	SHORT $LN25@xmlNodeLis

; 1703 :                     ret = xmlStrcat(ret, buffer);
; 1704 :                     xmlFree(buffer);
; 1705 :                 }
; 1706 :             }
; 1707 :         } else if (node->type == XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	$LN14@xmlNodeLis

; 1708 :             if (inLine) {

	test	ecx, ecx
	je	SHORT $LN16@xmlNodeLis

; 1709 :                 ent = xmlGetDocEntity(doc, node->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlGetDocEntity
	add	esp, 8

; 1710 :                 if (ent != NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlNodeLis

; 1711 :                     xmlChar *buffer;
; 1712 : 
; 1713 :                     /* an entity content can be any "well balanced chunk",
; 1714 :                      * i.e. the result of the content [43] production:
; 1715 :                      * http://www.w3.org/TR/REC-xml#NT-content.
; 1716 :                      * So it can contain text, CDATA section or nested
; 1717 :                      * entity reference nodes (among others).
; 1718 :                      * -> we recursive  call xmlNodeListGetString()
; 1719 :                      * which handles these types */
; 1720 :                     buffer = xmlNodeListGetString(doc, ent->children, 1);

	push	1
	push	DWORD PTR [eax+12]
	push	ebx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH

; 1721 :                     if (buffer != NULL) {
; 1722 :                         ret = xmlStrcat(ret, buffer);
; 1723 :                         xmlFree(buffer);
; 1724 :                     }
; 1725 :                 } else {

	jmp	SHORT $LN38@xmlNodeLis
$LN18@xmlNodeLis:

; 1726 :                     ret = xmlStrcat(ret, node->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlStrcat
	add	esp, 8
	mov	edi, eax

; 1727 :                 }
; 1728 :             } else {

	jmp	SHORT $LN35@xmlNodeLis
$LN16@xmlNodeLis:

; 1729 :                 xmlChar buf[2];
; 1730 : 
; 1731 :                 buf[0] = '&';
; 1732 :                 buf[1] = 0;
; 1733 :                 ret = xmlStrncat(ret, buf, 1);

	push	1
	lea	eax, DWORD PTR _buf$1[ebp]
	mov	WORD PTR _buf$1[ebp], 38		; 00000026H
	push	eax
	push	edi
	call	_xmlStrncat

; 1734 :                 ret = xmlStrcat(ret, node->name);

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlStrcat

; 1735 :                 buf[0] = ';';
; 1736 :                 buf[1] = 0;
; 1737 :                 ret = xmlStrncat(ret, buf, 1);

	push	1
	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	WORD PTR _buf$1[ebp], 59		; 0000003bH
	push	ecx
	push	eax
	call	_xmlStrncat
	add	esp, 32					; 00000020H
	mov	edi, eax
	jmp	SHORT $LN35@xmlNodeLis
$LN25@xmlNodeLis:

; 1692 :             (node->type == XML_CDATA_SECTION_NODE)) {
; 1693 :             if (inLine) {

	mov	eax, DWORD PTR [esi+40]
	push	eax
	test	ecx, ecx
	je	SHORT $LN10@xmlNodeLis

; 1694 :                 ret = xmlStrcat(ret, node->content);

	push	edi
	call	_xmlStrcat
	add	esp, 8
	mov	edi, eax

; 1695 :             } else {

	jmp	SHORT $LN35@xmlNodeLis
$LN10@xmlNodeLis:

; 1696 :                 xmlChar *buffer;
; 1697 : 
; 1698 : 		if (attr)

	push	ebx
	test	edx, edx
	je	SHORT $LN12@xmlNodeLis

; 1699 : 		    buffer = xmlEncodeAttributeEntities(doc, node->content);

	call	_xmlEncodeAttributeEntities
	jmp	SHORT $LN36@xmlNodeLis
$LN12@xmlNodeLis:

; 1700 : 		else
; 1701 : 		    buffer = xmlEncodeEntitiesReentrant(doc, node->content);

	call	_xmlEncodeEntitiesReentrant
$LN36@xmlNodeLis:

; 1702 :                 if (buffer != NULL) {

	add	esp, 8
$LN38@xmlNodeLis:

; 1738 :             }
; 1739 :         }
; 1740 : #if 0
; 1741 :         else {
; 1742 :             xmlGenericError(xmlGenericErrorContext,
; 1743 :                             "xmlGetNodeListString : invalid node type %d\n",
; 1744 :                             node->type);
; 1745 :         }
; 1746 : #endif
; 1747 :         node = node->next;

	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN33@xmlNodeLis
	push	ebx
	push	edi
	call	_xmlStrcat
	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN33@xmlNodeLis:
	mov	ebx, DWORD PTR _doc$[ebp]
$LN35@xmlNodeLis:
	mov	ecx, DWORD PTR _inLine$[ebp]
$LN14@xmlNodeLis:
	mov	esi, DWORD PTR [esi+24]
	mov	edx, DWORD PTR _attr$1$[ebp]
	test	esi, esi
	jne	$LL2@xmlNodeLis

; 1748 :     }
; 1749 :     return (ret);

	pop	ebx
	mov	eax, edi
	pop	edi

; 1750 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeListGetString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlStringLenGetNodeList
_TEXT	SEGMENT
_buffer$1 = -24						; size = 10
_end$1$ = -12						; size = 4
_last$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_buf$1$ = 12						; size = 4
_value$ = 12						; size = 4
_val$1$ = 16						; size = 4
_cur$1$ = 16						; size = 4
_len$ = 16						; size = 4
_xmlStringLenGetNodeList PROC				; COMDAT

; 1275 : xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _value$[ebp]
	xor	edi, edi
	mov	ebx, DWORD PTR _len$[ebp]
	add	ebx, esi
	mov	DWORD PTR _ret$1$[ebp], 0
	mov	DWORD PTR _last$1$[ebp], edi
	mov	DWORD PTR _end$1$[ebp], ebx
	test	esi, esi
	je	$LN124@xmlStringL

; 1276 :     xmlNodePtr ret = NULL, last = NULL;
; 1277 :     xmlNodePtr node;
; 1278 :     xmlChar *val;
; 1279 :     const xmlChar *cur = value, *end = cur + len;
; 1280 :     const xmlChar *q;
; 1281 :     xmlEntityPtr ent;
; 1282 :     xmlBufPtr buf;
; 1283 : 
; 1284 :     if (value == NULL) return(NULL);
; 1285 : 
; 1286 :     buf = xmlBufCreateSize(0);

	push	edi
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], eax

; 1287 :     if (buf == NULL) return(NULL);

	test	eax, eax
	je	$LN124@xmlStringL

; 1288 :     xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_HYBRID);

	push	4
	push	eax
	call	_xmlBufSetAllocationScheme
	add	esp, 8

; 1289 : 
; 1290 :     q = cur;

	mov	ecx, esi

; 1291 :     while ((cur < end) && (*cur != 0)) {

	cmp	esi, ebx
	jae	$LN60@xmlStringL
	npad	5
$LL2@xmlStringL:
	mov	al, BYTE PTR [esi]
	test	al, al
	je	$LN3@xmlStringL

; 1292 : 	if (cur[0] == '&') {

	cmp	al, 38					; 00000026H
	jne	$LN14@xmlStringL

; 1293 : 	    int charval = 0;
; 1294 : 	    xmlChar tmp;
; 1295 : 
; 1296 : 	    /*
; 1297 : 	     * Save the current text.
; 1298 : 	     */
; 1299 :             if (cur != q) {

	mov	ebx, DWORD PTR _buf$1$[ebp]
	xor	edi, edi
	cmp	esi, ecx
	je	SHORT $LN17@xmlStringL

; 1300 : 		if (xmlBufAdd(buf, q, cur - q))

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	ebx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN155@xmlStringL
$LN17@xmlStringL:

; 1301 : 		    goto out;
; 1302 : 	    }
; 1303 : 	    q = cur;
; 1304 : 	    if ((cur + 2 < end) && (cur[1] == '#') && (cur[2] == 'x')) {

	mov	ecx, DWORD PTR _end$1$[ebp]
	lea	edx, DWORD PTR [esi+2]
	mov	DWORD PTR _cur$1$[ebp], edx
	cmp	edx, ecx
	jae	$LN18@xmlStringL
	cmp	BYTE PTR [esi+1], 35			; 00000023H
	jne	$LN18@xmlStringL
	cmp	BYTE PTR [edx], 120			; 00000078H
	jne	SHORT $LN18@xmlStringL

; 1305 : 		cur += 3;

	add	esi, 3

; 1306 : 		if (cur < end)

	cmp	esi, ecx
	jae	SHORT $LN20@xmlStringL

; 1307 : 		    tmp = *cur;

	mov	bl, BYTE PTR [esi]

; 1308 : 		else
; 1309 : 		    tmp = 0;
; 1310 : 		while (tmp != ';') { /* Non input consuming loop */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN5@xmlStringL
	jmp	SHORT $LL4@xmlStringL
$LN20@xmlStringL:

; 1311 : 		    if ((tmp >= '0') && (tmp <= '9'))

	xor	bl, bl
$LL4@xmlStringL:
	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN22@xmlStringL

; 1312 : 			charval = charval * 16 + (tmp - '0');

	add	edi, -3					; fffffffdH
	shl	edi, 4
	jmp	SHORT $LN160@xmlStringL
$LN22@xmlStringL:

; 1313 : 		    else if ((tmp >= 'a') && (tmp <= 'f'))

	lea	eax, DWORD PTR [ebx-97]
	cmp	al, 5
	ja	SHORT $LN24@xmlStringL

; 1314 : 			charval = charval * 16 + (tmp - 'a') + 10;

	shl	edi, 4
	add	edi, -87				; ffffffa9H
	jmp	SHORT $LN160@xmlStringL
$LN24@xmlStringL:

; 1315 : 		    else if ((tmp >= 'A') && (tmp <= 'F'))

	lea	eax, DWORD PTR [ebx-65]
	cmp	al, 5
	ja	SHORT $LN26@xmlStringL

; 1316 : 			charval = charval * 16 + (tmp - 'A') + 10;

	shl	edi, 4
	add	edi, -55				; ffffffc9H
$LN160@xmlStringL:

; 1321 : 			break;
; 1322 : 		    }
; 1323 : 		    cur++;

	movzx	eax, bl
	inc	esi
	add	edi, eax

; 1324 : 		    if (cur < end)

	cmp	esi, ecx
	jae	SHORT $LN20@xmlStringL

; 1325 : 			tmp = *cur;

	mov	bl, BYTE PTR [esi]
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL4@xmlStringL

; 1326 : 		    else
; 1327 : 			tmp = 0;
; 1328 : 		}
; 1329 : 		if (tmp == ';')
; 1330 : 		    cur++;
; 1331 : 		q = cur;

	lea	eax, DWORD PTR [esi+1]
	cmp	bl, bl
	cmovne	eax, esi
	mov	esi, eax
	jmp	$LN32@xmlStringL
$LN26@xmlStringL:

; 1317 : 		    else {
; 1318 : 			xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,

	push	0
	push	DWORD PTR _doc$[ebp]
	push	1300					; 00000514H
	call	_xmlTreeErr
	add	esp, 12					; 0000000cH

; 1319 : 			           NULL);
; 1320 : 			charval = 0;

	xor	edi, edi
$LN5@xmlStringL:

; 1326 : 		    else
; 1327 : 			tmp = 0;
; 1328 : 		}
; 1329 : 		if (tmp == ';')
; 1330 : 		    cur++;
; 1331 : 		q = cur;

	lea	eax, DWORD PTR [esi+1]
	cmp	bl, 59					; 0000003bH
	cmovne	eax, esi
	mov	esi, eax
	jmp	SHORT $LN32@xmlStringL
$LN18@xmlStringL:

; 1332 : 	    } else if ((cur + 1 < end) && (cur[1] == '#')) {

	inc	esi
	cmp	esi, ecx
	jae	$LN31@xmlStringL
	cmp	BYTE PTR [esi], 35			; 00000023H
	jne	$LN31@xmlStringL

; 1333 : 		cur += 2;
; 1334 : 		if (cur < end)

	cmp	edx, ecx
	jae	SHORT $LN33@xmlStringL

; 1335 : 		    tmp = *cur;

	mov	bl, BYTE PTR [edx]

; 1338 : 		while (tmp != ';') { /* Non input consuming loops */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN7@xmlStringL
	jmp	SHORT $LN144@xmlStringL
$LN33@xmlStringL:

; 1336 : 		else
; 1337 : 		    tmp = 0;

	xor	bl, bl
$LN144@xmlStringL:
	mov	esi, ecx
$LL6@xmlStringL:

; 1339 : 		    if ((tmp >= '0') && (tmp <= '9'))

	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN35@xmlStringL

; 1340 : 			charval = charval * 10 + (tmp - '0');

	lea	edi, DWORD PTR [edi+edi*4]
	movzx	eax, bl

; 1345 : 			break;
; 1346 : 		    }
; 1347 : 		    cur++;

	inc	edx
	lea	edi, DWORD PTR [edi-24]
	mov	DWORD PTR _cur$1$[ebp], edx
	lea	edi, DWORD PTR [eax+edi*2]

; 1348 : 		    if (cur < end)

	cmp	edx, esi
	jae	SHORT $LN37@xmlStringL

; 1349 : 			tmp = *cur;

	mov	bl, BYTE PTR [edx]
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL6@xmlStringL

; 1338 : 		while (tmp != ';') { /* Non input consuming loops */

	jmp	SHORT $LN7@xmlStringL
$LN37@xmlStringL:

; 1350 : 		    else
; 1351 : 			tmp = 0;

	xor	bl, bl
	jmp	SHORT $LL6@xmlStringL
$LN35@xmlStringL:

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	0
	push	OFFSET ??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@
	push	DWORD PTR _doc$[ebp]
	push	1301					; 00000515H
	push	2
	call	___xmlSimpleError
	mov	edx, DWORD PTR _cur$1$[ebp]
	add	esp, 20					; 00000014H

; 1341 : 		    else {
; 1342 : 			xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,
; 1343 : 			           NULL);
; 1344 : 			charval = 0;

	xor	edi, edi
$LN7@xmlStringL:

; 1352 : 		}
; 1353 : 		if (tmp == ';')
; 1354 : 		    cur++;
; 1355 : 		q = cur;

	cmp	bl, 59					; 0000003bH
	lea	esi, DWORD PTR [edx+1]
	cmovne	esi, edx
$LN32@xmlStringL:

; 1431 : 		q = cur;
; 1432 : 	    }
; 1433 : 	    if (charval != 0) {

	test	edi, edi
	je	$LN57@xmlStringL

; 1434 : 		xmlChar buffer[10];
; 1435 : 		int l;
; 1436 : 
; 1437 : 		l = xmlCopyCharMultiByte(buffer, charval);

	lea	eax, DWORD PTR _buffer$1[ebp]
	push	edi
	push	eax
	call	_xmlCopyCharMultiByte

; 1438 : 		buffer[l] = 0;

	mov	BYTE PTR _buffer$1[ebp+eax], 0

; 1439 : 
; 1440 : 		if (xmlBufCat(buf, buffer))

	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufCat
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN155@xmlStringL

; 1441 : 		    goto out;
; 1442 : 		charval = 0;
; 1443 : 	    }
; 1444 : 	} else

	mov	ebx, DWORD PTR _end$1$[ebp]
	mov	ecx, esi
	jmp	$LN15@xmlStringL
$LN31@xmlStringL:

; 1356 : 	    } else {
; 1357 : 		/*
; 1358 : 		 * Read the entity string
; 1359 : 		 */
; 1360 : 		cur++;
; 1361 : 		q = cur;

	mov	edx, esi

; 1362 : 		while ((cur < end) && (*cur != 0) && (*cur != ';')) cur++;

	cmp	esi, ecx
	jae	SHORT $LN41@xmlStringL
$LL8@xmlStringL:
	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN41@xmlStringL
	cmp	al, 59					; 0000003bH
	je	SHORT $LN9@xmlStringL
	inc	esi
	cmp	esi, ecx
	jb	SHORT $LL8@xmlStringL
$LN41@xmlStringL:

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	edx
	push	OFFSET ??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@
	push	DWORD PTR _doc$[ebp]
	push	1302					; 00000516H
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1364 : 		    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY, (xmlNodePtr) doc,
; 1365 : 		               (const char *) q);
; 1366 : 		    goto out;

	jmp	$LN155@xmlStringL
$LN9@xmlStringL:

; 1363 : 		if ((cur >= end) || (*cur == 0)) {

	test	al, al
	je	SHORT $LN41@xmlStringL

; 1367 : 		}
; 1368 : 		if (cur != q) {

	cmp	esi, edx
	je	$LN42@xmlStringL

; 1369 : 		    /*
; 1370 : 		     * Predefined entities don't generate nodes
; 1371 : 		     */
; 1372 : 		    val = xmlStrndup(q, cur - q);

	mov	eax, esi
	sub	eax, edx
	push	eax
	push	edx
	call	_xmlStrndup

; 1373 : 		    ent = xmlGetDocEntity(doc, val);

	push	eax
	push	DWORD PTR _doc$[ebp]
	mov	DWORD PTR _val$1$[ebp], eax
	call	_xmlGetDocEntity
	mov	edi, eax
	add	esp, 16					; 00000010H

; 1374 : 		    if ((ent != NULL) &&

	test	edi, edi
	je	SHORT $LN43@xmlStringL
	cmp	DWORD PTR [edi+48], 6
	jne	SHORT $LN43@xmlStringL

; 1375 : 			(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 1376 : 
; 1377 : 			if (xmlBufCat(buf, ent->content))

	push	DWORD PTR [edi+40]
	push	ebx
	call	_xmlBufCat
	add	esp, 8
	test	eax, eax
	jne	$LN155@xmlStringL

; 1378 : 			    goto out;
; 1379 : 
; 1380 : 		    } else {

	jmp	$LN56@xmlStringL
$LN43@xmlStringL:

; 1381 : 			/*
; 1382 : 			 * Flush buffer so far
; 1383 : 			 */
; 1384 : 			if (!xmlBufIsEmpty(buf)) {

	push	ebx
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN50@xmlStringL

; 2656 :     cur = xmlNewText(content);

	push	eax
	call	_xmlNewText
	mov	ebx, eax
	add	esp, 4

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	test	ebx, ebx
	je	$LN97@xmlStringL
	mov	eax, DWORD PTR _doc$[ebp]

; 1385 : 			    node = xmlNewDocText(doc, NULL);
; 1386 : 			    if (node == NULL) {
; 1387 : 				if (val != NULL) xmlFree(val);
; 1388 : 				goto out;
; 1389 : 			    }
; 1390 : 			    node->content = xmlBufDetach(buf);

	push	DWORD PTR _buf$1$[ebp]

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	mov	DWORD PTR [ebx+32], eax

; 1385 : 			    node = xmlNewDocText(doc, NULL);
; 1386 : 			    if (node == NULL) {
; 1387 : 				if (val != NULL) xmlFree(val);
; 1388 : 				goto out;
; 1389 : 			    }
; 1390 : 			    node->content = xmlBufDetach(buf);

	call	_xmlBufDetach
	mov	DWORD PTR [ebx+40], eax
	add	esp, 4

; 1391 : 
; 1392 : 			    if (last == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN49@xmlStringL

; 1393 : 				last = ret = node;

	mov	DWORD PTR _ret$1$[ebp], ebx
	mov	DWORD PTR _last$1$[ebp], ebx

; 1394 : 			    } else {

	jmp	SHORT $LN50@xmlStringL
$LN49@xmlStringL:

; 1395 : 				last = xmlAddNextSibling(last, node);

	push	ebx
	push	eax
	call	_xmlAddNextSibling
	add	esp, 8
	mov	DWORD PTR _last$1$[ebp], eax
$LN50@xmlStringL:

; 1396 : 			    }
; 1397 : 			}
; 1398 : 
; 1399 : 			/*
; 1400 : 			 * Create a new REFERENCE_REF node
; 1401 : 			 */
; 1402 : 			node = xmlNewReference(doc, val);

	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewReference
	mov	ebx, eax
	add	esp, 8

; 1403 : 			if (node == NULL) {

	test	ebx, ebx
	je	$LN97@xmlStringL

; 1404 : 			    if (val != NULL) xmlFree(val);
; 1405 : 			    goto out;
; 1406 : 			}
; 1407 : 			else if ((ent != NULL) && (ent->children == NULL)) {

	test	edi, edi
	je	SHORT $LN11@xmlStringL
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN11@xmlStringL

; 1408 : 			    xmlNodePtr temp;
; 1409 : 
; 1410 :                             /* Set to non-NULL value to avoid recursion. */
; 1411 : 			    ent->children = (xmlNodePtr) -1;

	mov	DWORD PTR [edi+12], -1

; 1412 : 			    ent->children = xmlStringGetNodeList(doc,

	push	DWORD PTR [ebx+40]
	push	DWORD PTR _doc$[ebp]
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [edi+12], eax

; 1413 : 				    (const xmlChar*)node->content);
; 1414 : 			    ent->owner = 1;

	mov	DWORD PTR [edi+68], 1

; 1415 : 			    temp = ent->children;
; 1416 : 			    while (temp) {

	test	eax, eax
	je	SHORT $LN11@xmlStringL
	npad	4
$LL10@xmlStringL:

; 1417 : 				temp->parent = (xmlNodePtr)ent;

	mov	DWORD PTR [eax+20], edi

; 1418 : 				ent->last = temp;

	mov	DWORD PTR [edi+16], eax

; 1419 : 				temp = temp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL10@xmlStringL
$LN11@xmlStringL:

; 1420 : 			    }
; 1421 : 			}
; 1422 : 			if (last == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN55@xmlStringL

; 1423 : 			    last = ret = node;

	mov	DWORD PTR _ret$1$[ebp], ebx
	mov	DWORD PTR _last$1$[ebp], ebx

; 1424 : 			} else {

	jmp	SHORT $LN56@xmlStringL
$LN55@xmlStringL:

; 1425 : 			    last = xmlAddNextSibling(last, node);

	push	ebx
	push	eax
	call	_xmlAddNextSibling
	add	esp, 8
	mov	DWORD PTR _last$1$[ebp], eax
$LN56@xmlStringL:

; 1426 : 			}
; 1427 : 		    }
; 1428 : 		    xmlFree(val);

	push	DWORD PTR _val$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN42@xmlStringL:

; 1429 : 		}
; 1430 : 		cur++;

	inc	esi
$LN57@xmlStringL:

; 1441 : 		    goto out;
; 1442 : 		charval = 0;
; 1443 : 	    }
; 1444 : 	} else

	mov	ebx, DWORD PTR _end$1$[ebp]
	mov	ecx, esi
	jmp	SHORT $LN15@xmlStringL
$LN14@xmlStringL:

; 1445 : 	    cur++;

	inc	esi
$LN15@xmlStringL:

; 1291 :     while ((cur < end) && (*cur != 0)) {

	cmp	esi, ebx
	jb	$LL2@xmlStringL
$LN3@xmlStringL:

; 1446 :     }
; 1447 : 
; 1448 :     if (cur != q) {

	cmp	esi, ecx
	je	SHORT $LN147@xmlStringL

; 1449 :         /*
; 1450 : 	 * Handle the last piece of text.
; 1451 : 	 */
; 1452 : 	if (xmlBufAdd(buf, q, cur - q))

	sub	esi, ecx
	push	esi
	push	ecx
	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN155@xmlStringL
$LN147@xmlStringL:

; 1453 : 	    goto out;
; 1454 :     }
; 1455 : 
; 1456 :     if (!xmlBufIsEmpty(buf)) {

	mov	edi, DWORD PTR _last$1$[ebp]
$LN60@xmlStringL:
	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN61@xmlStringL

; 1457 : 	node = xmlNewDocText(doc, NULL);

	push	eax
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewDocText
	mov	esi, eax
	add	esp, 8

; 1458 : 	if (node == NULL) goto out;

	test	esi, esi
	je	SHORT $LN155@xmlStringL

; 1459 : 	node->content = xmlBufDetach(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufDetach
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 1460 : 
; 1461 : 	if (last == NULL) {

	test	edi, edi
	jne	SHORT $LN64@xmlStringL

; 1462 : 	    ret = node;

	mov	DWORD PTR _ret$1$[ebp], esi

; 1463 : 	} else {

	jmp	SHORT $LN155@xmlStringL
$LN97@xmlStringL:

; 1468 :     }
; 1469 : 
; 1470 : out:
; 1471 :     xmlBufFree(buf);

	mov	eax, DWORD PTR _val$1$[ebp]
	test	eax, eax
	je	SHORT $LN155@xmlStringL
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN155@xmlStringL
$LN64@xmlStringL:

; 1464 : 	    xmlAddNextSibling(last, node);

	push	esi
	push	edi
	call	_xmlAddNextSibling

; 1465 : 	}

	jmp	SHORT $LN161@xmlStringL
$LN61@xmlStringL:

; 1466 :     } else if (ret == NULL) {

	mov	esi, DWORD PTR _ret$1$[ebp]
	test	esi, esi
	jne	SHORT $out$163

; 1467 :         ret = xmlNewDocText(doc, BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewDocText
	mov	DWORD PTR _ret$1$[ebp], eax
$LN161@xmlStringL:

; 1468 :     }
; 1469 : 
; 1470 : out:
; 1471 :     xmlBufFree(buf);

	add	esp, 8
$LN155@xmlStringL:
	mov	esi, DWORD PTR _ret$1$[ebp]
$out$163:
	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufFree
	add	esp, 4

; 1472 :     return(ret);

	mov	eax, esi
	pop	edi

; 1473 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN124@xmlStringL:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStringLenGetNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlStringGetNodeList
_TEXT	SEGMENT
_buffer$1 = -24						; size = 10
_val$1$ = -12						; size = 4
_cur$1$ = -12						; size = 4
_ret$1$ = -8						; size = 4
_last$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_buf$1$ = 12						; size = 4
_value$ = 12						; size = 4
_xmlStringGetNodeList PROC				; COMDAT

; 1485 : xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _ret$1$[ebp], 0
	mov	DWORD PTR _last$1$[ebp], ebx
	test	edi, edi
	je	$LN102@xmlStringG

; 1486 :     xmlNodePtr ret = NULL, last = NULL;
; 1487 :     xmlNodePtr node;
; 1488 :     xmlChar *val;
; 1489 :     const xmlChar *cur = value;
; 1490 :     const xmlChar *q;
; 1491 :     xmlEntityPtr ent;
; 1492 :     xmlBufPtr buf;
; 1493 : 
; 1494 :     if (value == NULL) return(NULL);
; 1495 : 
; 1496 :     buf = xmlBufCreateSize(0);

	push	ebx
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], eax

; 1497 :     if (buf == NULL) return(NULL);

	test	eax, eax
	je	$LN102@xmlStringG

; 1498 :     xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_HYBRID);

	push	esi
	push	4
	push	eax
	call	_xmlBufSetAllocationScheme

; 1499 : 
; 1500 :     q = cur;
; 1501 :     while (*cur != 0) {

	mov	al, BYTE PTR [edi]
	add	esp, 8
	mov	ecx, edi
	test	al, al
	je	$LN49@xmlStringG
$LL2@xmlStringG:

; 1502 : 	if (cur[0] == '&') {

	cmp	al, 38					; 00000026H
	jne	$LN14@xmlStringG

; 1503 : 	    int charval = 0;
; 1504 : 	    xmlChar tmp;
; 1505 : 
; 1506 : 	    /*
; 1507 : 	     * Save the current text.
; 1508 : 	     */
; 1509 :             if (cur != q) {

	mov	ebx, DWORD PTR _buf$1$[ebp]
	xor	esi, esi
	cmp	edi, ecx
	je	SHORT $LN17@xmlStringG

; 1510 : 		if (xmlBufAdd(buf, q, cur - q))

	mov	eax, edi
	sub	eax, ecx
	push	eax
	push	ecx
	push	ebx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$out$109
$LN17@xmlStringG:

; 1511 : 		    goto out;
; 1512 : 	    }
; 1513 : 	    q = cur;
; 1514 : 	    if ((cur[1] == '#') && (cur[2] == 'x')) {

	mov	al, BYTE PTR [edi+1]
	lea	ecx, DWORD PTR [edi+1]
	cmp	al, 35					; 00000023H
	jne	$LN27@xmlStringG
	mov	bl, BYTE PTR [edi+2]
	lea	edx, DWORD PTR [edi+2]
	mov	DWORD PTR _cur$1$[ebp], edx
	cmp	bl, 120					; 00000078H
	jne	SHORT $LN101@xmlStringG

; 1515 : 		cur += 3;
; 1516 : 		tmp = *cur;

	mov	bl, BYTE PTR [edi+3]
	add	edi, 3

; 1517 : 		while (tmp != ';') { /* Non input consuming loop */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN5@xmlStringG
$LL4@xmlStringG:

; 1518 : 		    if ((tmp >= '0') && (tmp <= '9'))

	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN20@xmlStringG

; 1519 : 			charval = charval * 16 + (tmp - '0');

	add	esi, -3					; fffffffdH
	shl	esi, 4
	jmp	SHORT $LN107@xmlStringG
$LN20@xmlStringG:

; 1520 : 		    else if ((tmp >= 'a') && (tmp <= 'f'))

	lea	eax, DWORD PTR [ebx-97]
	cmp	al, 5
	ja	SHORT $LN22@xmlStringG

; 1521 : 			charval = charval * 16 + (tmp - 'a') + 10;

	shl	esi, 4
	add	esi, -87				; ffffffa9H
	jmp	SHORT $LN107@xmlStringG
$LN22@xmlStringG:

; 1522 : 		    else if ((tmp >= 'A') && (tmp <= 'F'))

	lea	eax, DWORD PTR [ebx-65]
	cmp	al, 5
	ja	SHORT $LN24@xmlStringG

; 1523 : 			charval = charval * 16 + (tmp - 'A') + 10;

	shl	esi, 4
	add	esi, -55				; ffffffc9H
$LN107@xmlStringG:

; 1528 : 			break;
; 1529 : 		    }
; 1530 : 		    cur++;

	inc	edi
	movzx	eax, bl
	add	esi, eax

; 1531 : 		    tmp = *cur;

	mov	bl, BYTE PTR [edi]
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL4@xmlStringG

; 1532 : 		}
; 1533 : 		if (tmp == ';')
; 1534 : 		    cur++;
; 1535 : 		q = cur;

	lea	eax, DWORD PTR [edi+1]
	cmp	bl, bl
	cmovne	eax, edi
	mov	edi, eax
	jmp	SHORT $LN28@xmlStringG
$LN24@xmlStringG:

; 1524 : 		    else {
; 1525 : 			xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,

	push	0
	push	DWORD PTR _doc$[ebp]
	push	1300					; 00000514H
	call	_xmlTreeErr
	add	esp, 12					; 0000000cH

; 1526 : 			           NULL);
; 1527 : 			charval = 0;

	xor	esi, esi
$LN5@xmlStringG:

; 1532 : 		}
; 1533 : 		if (tmp == ';')
; 1534 : 		    cur++;
; 1535 : 		q = cur;

	lea	eax, DWORD PTR [edi+1]
	cmp	bl, 59					; 0000003bH
	cmovne	eax, edi
	mov	edi, eax
	jmp	SHORT $LN28@xmlStringG
$LN101@xmlStringG:

; 1536 : 	    } else if  (cur[1] == '#') {
; 1537 : 		cur += 2;
; 1538 : 		tmp = *cur;
; 1539 : 		while (tmp != ';') { /* Non input consuming loops */

	cmp	bl, 59					; 0000003bH
	je	SHORT $LN7@xmlStringG
	npad	2
$LL6@xmlStringG:

; 1540 : 		    if ((tmp >= '0') && (tmp <= '9'))

	lea	eax, DWORD PTR [ebx-48]
	cmp	al, 9
	ja	SHORT $LN29@xmlStringG

; 1546 : 			break;
; 1547 : 		    }
; 1548 : 		    cur++;

	inc	edx
	movzx	eax, bl
	lea	esi, DWORD PTR [esi+esi*4]
	mov	DWORD PTR _cur$1$[ebp], edx
	lea	esi, DWORD PTR [esi-24]

; 1549 : 		    tmp = *cur;

	mov	bl, BYTE PTR [edx]
	lea	esi, DWORD PTR [eax+esi*2]
	cmp	bl, 59					; 0000003bH
	jne	SHORT $LL6@xmlStringG

; 1633 : 
; 1634 : 		if (xmlBufCat(buf, buffer))

	jmp	SHORT $LN7@xmlStringG
$LN29@xmlStringG:

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	0
	push	OFFSET ??_C@_0CB@MCPMOJHG@invalid?5decimal?5character?5value@
	push	DWORD PTR _doc$[ebp]
	push	1301					; 00000515H
	push	2
	call	___xmlSimpleError
	mov	edx, DWORD PTR _cur$1$[ebp]
	add	esp, 20					; 00000014H

; 1541 : 			charval = charval * 10 + (tmp - '0');
; 1542 : 		    else {
; 1543 : 			xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,
; 1544 : 			           NULL);
; 1545 : 			charval = 0;

	xor	esi, esi
$LN7@xmlStringG:

; 1550 : 		}
; 1551 : 		if (tmp == ';')
; 1552 : 		    cur++;
; 1553 : 		q = cur;

	cmp	bl, 59					; 0000003bH
	lea	edi, DWORD PTR [edx+1]
	cmovne	edi, edx
$LN28@xmlStringG:

; 1625 : 		q = cur;
; 1626 : 	    }
; 1627 : 	    if (charval != 0) {

	test	esi, esi
	je	$LN46@xmlStringG

; 1628 : 		xmlChar buffer[10];
; 1629 : 		int len;
; 1630 : 
; 1631 : 		len = xmlCopyCharMultiByte(buffer, charval);

	lea	eax, DWORD PTR _buffer$1[ebp]
	push	esi
	push	eax
	call	_xmlCopyCharMultiByte

; 1632 : 		buffer[len] = 0;

	mov	BYTE PTR _buffer$1[ebp+eax], 0

; 1633 : 
; 1634 : 		if (xmlBufCat(buf, buffer))

	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufCat
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$out$109

; 1635 : 		    goto out;
; 1636 : 		charval = 0;
; 1637 : 	    }
; 1638 : 	} else

	mov	ecx, edi
	jmp	$LN15@xmlStringG
$LN27@xmlStringG:

; 1554 : 	    } else {
; 1555 : 		/*
; 1556 : 		 * Read the entity string
; 1557 : 		 */
; 1558 : 		cur++;

	mov	edi, ecx

; 1559 : 		q = cur;

	mov	edx, edi

; 1560 : 		while ((*cur != 0) && (*cur != ';')) cur++;

	test	al, al
	je	$LN81@xmlStringG
$LL8@xmlStringG:
	mov	cl, al
	cmp	al, 59					; 0000003bH
	je	SHORT $LN9@xmlStringG
	mov	al, BYTE PTR [edi+1]
	inc	edi
	mov	cl, al
	test	al, al
	jne	SHORT $LL8@xmlStringG
$LN9@xmlStringG:

; 1561 : 		if (*cur == 0) {

	test	cl, cl
	je	$LN81@xmlStringG

; 1562 : 		    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,
; 1563 : 		               (xmlNodePtr) doc, (const char *) q);
; 1564 : 		    goto out;
; 1565 : 		}
; 1566 : 		if (cur != q) {

	cmp	edi, edx
	je	$LN33@xmlStringG

; 1567 : 		    /*
; 1568 : 		     * Predefined entities don't generate nodes
; 1569 : 		     */
; 1570 : 		    val = xmlStrndup(q, cur - q);

	mov	eax, edi
	sub	eax, edx
	push	eax
	push	edx
	call	_xmlStrndup

; 1571 : 		    ent = xmlGetDocEntity(doc, val);

	push	eax
	push	DWORD PTR _doc$[ebp]
	mov	DWORD PTR _val$1$[ebp], eax
	call	_xmlGetDocEntity
	mov	esi, eax
	add	esp, 16					; 00000010H

; 1572 : 		    if ((ent != NULL) &&

	test	esi, esi
	je	SHORT $LN34@xmlStringG
	cmp	DWORD PTR [esi+48], 6
	jne	SHORT $LN34@xmlStringG

; 1573 : 			(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 1574 : 
; 1575 : 			if (xmlBufCat(buf, ent->content))

	push	DWORD PTR [esi+40]
	push	ebx
	call	_xmlBufCat
	add	esp, 8
	test	eax, eax
	jne	$out$109

; 1620 : 			}
; 1621 : 		    }
; 1622 : 		    xmlFree(val);

	push	DWORD PTR _val$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1623 : 		}
; 1624 : 		cur++;

	inc	edi

; 1635 : 		    goto out;
; 1636 : 		charval = 0;
; 1637 : 	    }
; 1638 : 	} else

	mov	ecx, edi
	jmp	$LN15@xmlStringG
$LN34@xmlStringG:

; 1576 : 			    goto out;
; 1577 : 
; 1578 : 		    } else {
; 1579 : 			/*
; 1580 : 			 * Flush buffer so far
; 1581 : 			 */
; 1582 : 			if (!xmlBufIsEmpty(buf)) {

	push	ebx
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN39@xmlStringG

; 2656 :     cur = xmlNewText(content);

	push	eax
	call	_xmlNewText
	mov	ebx, eax
	add	esp, 4

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	test	ebx, ebx
	je	SHORT $LN73@xmlStringG
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ebx+32], eax
$LN73@xmlStringG:

; 1583 : 			    node = xmlNewDocText(doc, NULL);
; 1584 : 			    node->content = xmlBufDetach(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufDetach
	mov	DWORD PTR [ebx+40], eax
	add	esp, 4

; 1585 : 
; 1586 : 			    if (last == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN38@xmlStringG

; 1587 : 				last = ret = node;

	mov	DWORD PTR _ret$1$[ebp], ebx
	mov	DWORD PTR _last$1$[ebp], ebx

; 1588 : 			    } else {

	jmp	SHORT $LN39@xmlStringG
$LN38@xmlStringG:

; 1589 : 				last = xmlAddNextSibling(last, node);

	push	ebx
	push	eax
	call	_xmlAddNextSibling
	add	esp, 8
	mov	DWORD PTR _last$1$[ebp], eax
$LN39@xmlStringG:

; 1590 : 			    }
; 1591 : 			}
; 1592 : 
; 1593 : 			/*
; 1594 : 			 * Create a new REFERENCE_REF node
; 1595 : 			 */
; 1596 : 			node = xmlNewReference(doc, val);

	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewReference
	mov	ebx, eax
	add	esp, 8

; 1597 : 			if (node == NULL) {

	test	ebx, ebx
	je	$LN83@xmlStringG

; 1599 : 			    goto out;
; 1600 : 			}
; 1601 : 			else if ((ent != NULL) && (ent->children == NULL)) {

	test	esi, esi
	je	SHORT $LN11@xmlStringG
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN11@xmlStringG

; 1602 : 			    xmlNodePtr temp;
; 1603 : 
; 1604 :                             /* Set to non-NULL value to avoid recursion. */
; 1605 : 			    ent->children = (xmlNodePtr) -1;

	mov	DWORD PTR [esi+12], -1

; 1606 : 			    ent->children = xmlStringGetNodeList(doc,

	push	DWORD PTR [ebx+40]
	push	DWORD PTR _doc$[ebp]
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 1607 : 				    (const xmlChar*)node->content);
; 1608 : 			    ent->owner = 1;

	mov	DWORD PTR [esi+68], 1

; 1609 : 			    temp = ent->children;
; 1610 : 			    while (temp) {

	test	eax, eax
	je	SHORT $LN11@xmlStringG
$LL10@xmlStringG:

; 1611 : 				temp->parent = (xmlNodePtr)ent;

	mov	DWORD PTR [eax+20], esi

; 1612 : 				ent->last = temp;

	mov	DWORD PTR [esi+16], eax

; 1613 : 				temp = temp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL10@xmlStringG
$LN11@xmlStringG:

; 1614 : 			    }
; 1615 : 			}
; 1616 : 			if (last == NULL) {

	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	jne	SHORT $LN44@xmlStringG

; 1620 : 			}
; 1621 : 		    }
; 1622 : 		    xmlFree(val);

	push	DWORD PTR _val$1$[ebp]
	mov	DWORD PTR _ret$1$[ebp], ebx
	mov	DWORD PTR _last$1$[ebp], ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1623 : 		}
; 1624 : 		cur++;

	inc	edi

; 1635 : 		    goto out;
; 1636 : 		charval = 0;
; 1637 : 	    }
; 1638 : 	} else

	mov	ecx, edi
	jmp	SHORT $LN15@xmlStringG
$LN44@xmlStringG:

; 1617 : 			    last = ret = node;
; 1618 : 			} else {
; 1619 : 			    last = xmlAddNextSibling(last, node);

	push	ebx
	push	eax
	call	_xmlAddNextSibling
	add	esp, 8
	mov	DWORD PTR _last$1$[ebp], eax

; 1620 : 			}
; 1621 : 		    }
; 1622 : 		    xmlFree(val);

	push	DWORD PTR _val$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlStringG:

; 1623 : 		}
; 1624 : 		cur++;

	inc	edi
$LN46@xmlStringG:

; 1635 : 		    goto out;
; 1636 : 		charval = 0;
; 1637 : 	    }
; 1638 : 	} else

	mov	ecx, edi
	jmp	SHORT $LN15@xmlStringG
$LN14@xmlStringG:

; 1639 : 	    cur++;

	inc	edi
$LN15@xmlStringG:

; 1499 : 
; 1500 :     q = cur;
; 1501 :     while (*cur != 0) {

	mov	al, BYTE PTR [edi]
	test	al, al
	jne	$LL2@xmlStringG

; 1640 :     }
; 1641 :     if ((cur != q) || (ret == NULL)) {

	mov	ebx, DWORD PTR _last$1$[ebp]
	cmp	edi, ecx
	jne	SHORT $LN49@xmlStringG
	cmp	DWORD PTR _ret$1$[ebp], 0
	jne	SHORT $LN104@xmlStringG
$LN49@xmlStringG:

; 1642 :         /*
; 1643 : 	 * Handle the last piece of text.
; 1644 : 	 */
; 1645 : 	xmlBufAdd(buf, q, cur - q);

	sub	edi, ecx
	push	edi
	mov	edi, DWORD PTR _buf$1$[ebp]
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN48@xmlStringG
$LN83@xmlStringG:

; 1598 : 			    if (val != NULL) xmlFree(val);

	mov	eax, DWORD PTR _val$1$[ebp]
	test	eax, eax
	je	$out$109
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1656 : 	}
; 1657 :     }
; 1658 : 
; 1659 : out:
; 1660 :     xmlBufFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufFree

; 1661 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 1662 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@xmlStringG:

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	edx
	push	OFFSET ??_C@_0CE@INHDJIAN@unterminated?5entity?5reference?5?$CF@
	push	DWORD PTR _doc$[ebp]
	push	1302					; 00000516H
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1656 : 	}
; 1657 :     }
; 1658 : 
; 1659 : out:
; 1660 :     xmlBufFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufFree

; 1661 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 1662 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN104@xmlStringG:

; 1640 :     }
; 1641 :     if ((cur != q) || (ret == NULL)) {

	mov	edi, DWORD PTR _buf$1$[ebp]
$LN48@xmlStringG:

; 1646 :     }
; 1647 : 
; 1648 :     if (!xmlBufIsEmpty(buf)) {

	push	edi
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $out$109

; 1649 : 	node = xmlNewDocText(doc, NULL);

	push	eax
	push	DWORD PTR _doc$[ebp]
	call	_xmlNewDocText

; 1650 : 	node->content = xmlBufDetach(buf);

	push	edi
	mov	esi, eax
	call	_xmlBufDetach
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+40], eax

; 1651 : 
; 1652 : 	if (last == NULL) {

	test	ebx, ebx
	jne	SHORT $LN51@xmlStringG

; 1656 : 	}
; 1657 :     }
; 1658 : 
; 1659 : out:
; 1660 :     xmlBufFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _ret$1$[ebp], esi
	call	_xmlBufFree
	add	esp, 4

; 1661 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 1662 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlStringG:

; 1653 : 	    ret = node;
; 1654 : 	} else {
; 1655 : 	    xmlAddNextSibling(last, node);

	push	esi
	push	ebx
	call	_xmlAddNextSibling
	add	esp, 8
$out$109:

; 1656 : 	}
; 1657 :     }
; 1658 : 
; 1659 : out:
; 1660 :     xmlBufFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlBufFree

; 1661 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	esi
	pop	edi

; 1662 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@xmlStringG:
	pop	edi

; 1497 :     if (buf == NULL) return(NULL);

	xor	eax, eax

; 1662 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStringGetNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_nameSpace$ = 16					; size = 4
_xmlGetNsProp PROC					; COMDAT

; 6768 : xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _xmlCheckDTD
	push	DWORD PTR _nameSpace$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@xmlGetNsPr

; 6775 : }

	pop	ebp
	ret	0
$LN2@xmlGetNsPr:

; 6769 :     xmlAttrPtr prop;
; 6770 : 
; 6771 :     prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);
; 6772 :     if (prop == NULL)
; 6773 : 	return(NULL);
; 6774 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	add	esp, 4

; 6775 : }

	pop	ebp
	ret	0
_xmlGetNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlHasNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_nameSpace$ = 16					; size = 4
_xmlHasNsProp PROC					; COMDAT

; 6696 : xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _xmlCheckDTD
	push	DWORD PTR _nameSpace$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H

; 6697 : 
; 6698 :     return(xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD));
; 6699 : }

	pop	ebp
	ret	0
_xmlHasNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlHasProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlHasProp PROC					; COMDAT

; 6641 : xmlHasProp(const xmlNode *node, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlHasProp

; 6642 :     xmlAttrPtr prop;
; 6643 :     xmlDocPtr doc;
; 6644 : 
; 6645 :     if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))

	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN5@xmlHasProp
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlHasProp

; 6647 :     /*
; 6648 :      * Check on the properties attached to the node
; 6649 :      */
; 6650 :     prop = node->properties;

	mov	esi, DWORD PTR [ebx+44]

; 6651 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlHasProp
	npad	5
$LL2@xmlHasProp:

; 6652 :         if (xmlStrEqual(prop->name, name))  {

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlHasProp

; 6654 :         }
; 6655 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlHasProp
$LN3@xmlHasProp:

; 6656 :     }
; 6657 :     if (!xmlCheckDTD) return(NULL);

	cmp	DWORD PTR _xmlCheckDTD, 0
	je	SHORT $LN5@xmlHasProp

; 6658 : 
; 6659 :     /*
; 6660 :      * Check if there is a default declaration in the internal
; 6661 :      * or external subsets
; 6662 :      */
; 6663 :     doc =  node->doc;

	mov	esi, DWORD PTR [ebx+32]

; 6664 :     if (doc != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlHasProp

; 6665 :         xmlAttributePtr attrDecl;
; 6666 :         if (doc->intSubset != NULL) {

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN5@xmlHasProp

; 6667 : 	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);

	push	edi
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 6668 : 	    if ((attrDecl == NULL) && (doc->extSubset != NULL))

	test	eax, eax
	jne	SHORT $LN18@xmlHasProp
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN5@xmlHasProp

; 6669 : 		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);

	push	edi
	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlGetDtdAttrDesc
	add	esp, 12					; 0000000cH

; 6670 :             if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))

	test	eax, eax
	je	SHORT $LN5@xmlHasProp
$LN18@xmlHasProp:
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN1@xmlHasProp
$LN5@xmlHasProp:

; 6646 :         return(NULL);

	xor	eax, eax
$LN1@xmlHasProp:
	pop	edi

; 6671 :               /* return attribute declaration only if a default value is given
; 6672 :                  (that includes #FIXED declarations) */
; 6673 : 		return((xmlAttrPtr) attrDecl);
; 6674 : 	}
; 6675 :     }
; 6676 :     return(NULL);
; 6677 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlHasProp:
	pop	edi

; 6653 : 	    return(prop);

	mov	eax, esi

; 6671 :               /* return attribute declaration only if a default value is given
; 6672 :                  (that includes #FIXED declarations) */
; 6673 : 		return((xmlAttrPtr) attrDecl);
; 6674 : 	}
; 6675 :     }
; 6676 :     return(NULL);
; 6677 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlHasProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetProp PROC					; COMDAT

; 6718 : xmlGetProp(const xmlNode *node, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlHasProp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlGetProp

; 6725 : }

	pop	ebp
	ret	0
$LN2@xmlGetProp:

; 6719 :     xmlAttrPtr prop;
; 6720 : 
; 6721 :     prop = xmlHasProp(node, name);
; 6722 :     if (prop == NULL)
; 6723 : 	return(NULL);
; 6724 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	add	esp, 4

; 6725 : }

	pop	ebp
	ret	0
_xmlGetProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetNoNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetNoNsProp PROC					; COMDAT

; 6743 : xmlGetNoNsProp(const xmlNode *node, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _xmlCheckDTD
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlGetPropNodeInternal
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@xmlGetNoNs

; 6750 : }

	pop	ebp
	ret	0
$LN2@xmlGetNoNs:

; 6744 :     xmlAttrPtr prop;
; 6745 : 
; 6746 :     prop = xmlGetPropNodeInternal(node, name, NULL, xmlCheckDTD);
; 6747 :     if (prop == NULL)
; 6748 : 	return(NULL);
; 6749 :     return(xmlGetPropNodeValueInternal(prop));

	push	eax
	call	_xmlGetPropNodeValueInternal
	add	esp, 4

; 6750 : }

	pop	ebp
	ret	0
_xmlGetNoNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_doc$1$ = 12						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlSetNsProp PROC					; COMDAT

; 6875 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	SHORT $LN14@xmlSetNsPr

; 6876 :     xmlAttrPtr prop;
; 6877 : 
; 6878 :     if (ns && (ns->href == NULL))

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN15@xmlSetNsPr
	pop	edi

; 6921 : }

	pop	ebp
	ret	0
$LN14@xmlSetNsPr:

; 6879 : 	return(NULL);
; 6880 :     prop = xmlGetPropNodeInternal(node, name, (ns != NULL) ? ns->href : NULL, 0);

	xor	eax, eax
$LN15@xmlSetNsPr:
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	push	esi
	push	0
	push	eax
	push	DWORD PTR _name$[ebp]
	push	ebx
	call	_xmlGetPropNodeInternal
	mov	esi, eax
	add	esp, 16					; 00000010H

; 6881 :     if (prop != NULL) {

	test	esi, esi
	je	$LN5@xmlSetNsPr

; 6882 : 	/*
; 6883 : 	* Modify the attribute's value.
; 6884 : 	*/
; 6885 : 	if (prop->atype == XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN6@xmlSetNsPr

; 6886 : 	    xmlRemoveID(node->doc, prop);

	push	esi
	push	DWORD PTR [ebx+32]
	call	_xmlRemoveID
	add	esp, 8

; 6887 : 	    prop->atype = XML_ATTRIBUTE_ID;

	mov	DWORD PTR [esi+40], 2
$LN6@xmlSetNsPr:

; 6888 : 	}
; 6889 : 	if (prop->children != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN7@xmlSetNsPr

; 6890 : 	    xmlFreeNodeList(prop->children);

	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN7@xmlSetNsPr:

; 6891 : 	prop->children = NULL;
; 6892 : 	prop->last = NULL;
; 6893 : 	prop->ns = ns;

	mov	DWORD PTR [esi+36], edi

; 6894 : 	if (value != NULL) {

	mov	edi, DWORD PTR _value$[ebp]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	test	edi, edi
	je	SHORT $LN3@xmlSetNsPr

; 6895 : 	    xmlNodePtr tmp;
; 6896 : 
; 6897 : 	    if(!xmlCheckUTF8(value)) {

	push	edi
	call	_xmlCheckUTF8
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@xmlSetNsPr

; 111  :     __xmlSimpleError(XML_FROM_TREE, code, node, msg, extra);

	push	eax
	push	OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
	push	DWORD PTR [ebx+32]
	push	1303					; 00000517H
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 6898 : 	        xmlTreeErr(XML_TREE_NOT_UTF8, (xmlNodePtr) node->doc,
; 6899 : 	                   NULL);
; 6900 :                 if (node->doc != NULL)

	cmp	DWORD PTR [ebx+32], 0
	je	SHORT $LN10@xmlSetNsPr

; 6901 :                     node->doc->encoding = xmlStrdup(BAD_CAST "ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlStrdup
	mov	ecx, DWORD PTR [ebx+32]
	add	esp, 4
	mov	DWORD PTR [ecx+60], eax
$LN10@xmlSetNsPr:

; 6902 : 	    }
; 6903 : 	    prop->children = xmlNewDocText(node->doc, value);

	mov	eax, DWORD PTR [ebx+32]

; 2656 :     cur = xmlNewText(content);

	push	edi

; 6902 : 	    }
; 6903 : 	    prop->children = xmlNewDocText(node->doc, value);

	mov	DWORD PTR _doc$1$[ebp], eax

; 2656 :     cur = xmlNewText(content);

	call	_xmlNewText
	add	esp, 4

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	test	eax, eax
	je	SHORT $LN26@xmlSetNsPr
	mov	ecx, DWORD PTR _doc$1$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN26@xmlSetNsPr:

; 6902 : 	    }
; 6903 : 	    prop->children = xmlNewDocText(node->doc, value);

	mov	DWORD PTR [esi+12], eax

; 6904 : 	    prop->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 6905 : 	    tmp = prop->children;
; 6906 : 	    while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlSetNsPr
$LL2@xmlSetNsPr:

; 6907 : 		tmp->parent = (xmlNodePtr) prop;
; 6908 : 		if (tmp->next == NULL)

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], esi
	test	ecx, ecx
	jne	SHORT $LN33@xmlSetNsPr

; 6909 : 		    prop->last = tmp;

	mov	DWORD PTR [esi+16], eax
	mov	ecx, DWORD PTR [eax+24]
$LN33@xmlSetNsPr:

; 6910 : 		tmp = tmp->next;

	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LL2@xmlSetNsPr
$LN3@xmlSetNsPr:

; 6911 : 	    }
; 6912 : 	}
; 6913 : 	if (prop->atype == XML_ATTRIBUTE_ID)

	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN12@xmlSetNsPr

; 6914 : 	    xmlAddID(NULL, node->doc, value, prop);

	push	esi
	push	edi
	push	DWORD PTR [ebx+32]
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
$LN12@xmlSetNsPr:

; 6915 : 	return(prop);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 6921 : }

	pop	ebp
	ret	0
$LN5@xmlSetNsPr:

; 6916 :     }
; 6917 :     /*
; 6918 :     * No equal attr found; create a new one.
; 6919 :     */
; 6920 :     return(xmlNewPropInternal(node, ns, name, value, 0));

	push	0
	push	DWORD PTR _value$[ebp]
	push	DWORD PTR _name$[ebp]
	push	edi
	push	ebx
	call	_xmlNewPropInternal
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 6921 : }

	pop	ebp
	ret	0
_xmlSetNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetProp
_TEXT	SEGMENT
_ns$1$ = -4						; size = 4
_prefix$1$ = 8						; size = 4
_len$ = 8						; size = 4
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlSetProp PROC					; COMDAT

; 6837 : xmlSetProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN3@xmlSetProp

; 6838 :     int len;
; 6839 :     const xmlChar *nqname;
; 6840 : 
; 6841 :     if ((node == NULL) || (name == NULL) || (node->type != XML_ELEMENT_NODE))

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSetProp
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN3@xmlSetProp

; 6843 : 
; 6844 :     /*
; 6845 :      * handle QNames
; 6846 :      */
; 6847 :     nqname = xmlSplitQName3(name, &len);

	push	ebx
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	push	edi
	call	_xmlSplitQName3
	mov	ebx, eax
	add	esp, 8

; 6848 :     if (nqname != NULL) {

	test	ebx, ebx
	je	SHORT $LN6@xmlSetProp

; 6849 :         xmlNsPtr ns;
; 6850 : 	xmlChar *prefix = xmlStrndup(name, len);

	push	DWORD PTR _len$[ebp]
	push	edi
	call	_xmlStrndup

; 6851 : 	ns = xmlSearchNs(node->doc, node, prefix);

	push	eax
	push	esi
	push	DWORD PTR [esi+32]
	mov	DWORD PTR _prefix$1$[ebp], eax
	call	_xmlSearchNs
	mov	ecx, eax
	add	esp, 20					; 00000014H

; 6852 : 	if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$1$[ebp]
	mov	DWORD PTR _ns$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN5@xmlSetProp

; 6853 : 	    xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _ns$1$[ebp]
	add	esp, 4
$LN5@xmlSetProp:

; 6854 : 	if (ns != NULL)

	test	ecx, ecx
	je	SHORT $LN6@xmlSetProp

; 6855 : 	    return(xmlSetNsProp(node, ns, nqname, value));

	push	DWORD PTR _value$[ebp]
	push	ebx
	push	ecx
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
	pop	ebx
	pop	edi

; 6858 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSetProp:

; 6856 :     }
; 6857 :     return(xmlSetNsProp(node, NULL, name, value));

	push	DWORD PTR _value$[ebp]
	push	edi
	push	0
	push	esi
	call	_xmlSetNsProp
	add	esp, 16					; 00000010H
	pop	ebx
	pop	edi

; 6858 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSetProp:
	pop	edi

; 6842 : 	return(NULL);

	xor	eax, eax

; 6858 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSetProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyNamespaceList
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCopyNamespaceList PROC				; COMDAT

; 3985 : xmlCopyNamespaceList(xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN18@xmlCopyNam
$LN10@xmlCopyNam:

; 3962 :     switch (cur->type) {

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN11@xmlCopyNam

; 3965 : 	    break;
; 3966 : 	default:
; 3967 : #ifdef DEBUG_TREE
; 3968 : 	    xmlGenericError(xmlGenericErrorContext,
; 3969 : 		    "xmlCopyNamespace: invalid type %d\n", cur->type);
; 3970 : #endif
; 3971 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN7@xmlCopyNam
$LN11@xmlCopyNam:

; 3963 : 	case XML_LOCAL_NAMESPACE:
; 3964 : 	    ret = xmlNewNs(NULL, cur->href, cur->prefix);

	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	0
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
$LN7@xmlCopyNam:

; 3986 :     xmlNsPtr ret = NULL;
; 3987 :     xmlNsPtr p = NULL,q;
; 3988 : 
; 3989 :     while (cur != NULL) {
; 3990 :         q = xmlCopyNamespace(cur);
; 3991 : 	if (p == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlCopyNam

; 3992 : 	    ret = p = q;

	mov	ebx, eax

; 3993 : 	} else {

	jmp	SHORT $LN5@xmlCopyNam
$LN4@xmlCopyNam:

; 3994 : 	    p->next = q;

	mov	DWORD PTR [edi], eax
$LN5@xmlCopyNam:

; 3995 : 	    p = q;
; 3996 : 	}
; 3997 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	mov	edi, eax
	test	esi, esi
	jne	SHORT $LN10@xmlCopyNam
$LN18@xmlCopyNam:
	pop	edi

; 3998 :     }
; 3999 :     return(ret);
; 4000 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
_xmlCopyNamespaceList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyNamespace
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCopyNamespace PROC					; COMDAT

; 3958 : xmlCopyNamespace(xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlCopyNam

; 3959 :     xmlNsPtr ret;
; 3960 : 
; 3961 :     if (cur == NULL) return(NULL);
; 3962 :     switch (cur->type) {

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN8@xmlCopyNam

; 3963 : 	case XML_LOCAL_NAMESPACE:
; 3964 : 	    ret = xmlNewNs(NULL, cur->href, cur->prefix);

	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	push	0
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 3972 :     }
; 3973 :     return(ret);
; 3974 : }

	pop	ebp
	ret	0
$LN8@xmlCopyNam:

; 3965 : 	    break;
; 3966 : 	default:
; 3967 : #ifdef DEBUG_TREE
; 3968 : 	    xmlGenericError(xmlGenericErrorContext,
; 3969 : 		    "xmlCopyNamespace: invalid type %d\n", cur->type);
; 3970 : #endif
; 3971 : 	    return(NULL);

	xor	eax, eax

; 3972 :     }
; 3973 :     return(ret);
; 3974 : }

	pop	ebp
	ret	0
_xmlCopyNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetNs
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSetNs PROC						; COMDAT

; 807  : xmlSetNs(xmlNodePtr node, xmlNsPtr ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSetNs

; 808  :     if (node == NULL) {
; 809  : #ifdef DEBUG_TREE
; 810  :         xmlGenericError(xmlGenericErrorContext,
; 811  : 		"xmlSetNs: node == NULL\n");
; 812  : #endif
; 813  : 	return;
; 814  :     }
; 815  :     if ((node->type == XML_ELEMENT_NODE) ||

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	je	SHORT $LN4@xmlSetNs
	cmp	eax, 2
	jne	SHORT $LN3@xmlSetNs
$LN4@xmlSetNs:

; 816  :         (node->type == XML_ATTRIBUTE_NODE))
; 817  : 	node->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN3@xmlSetNs:

; 818  : }

	pop	ebp
	ret	0
_xmlSetNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetNsList
_TEXT	SEGMENT
_maxns$1$ = -8						; size = 4
_cur$1$ = -4						; size = 4
_doc$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlGetNsList PROC					; COMDAT

; 5906 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	mov	esi, 10					; 0000000aH
	mov	DWORD PTR _maxns$1$[ebp], esi
	test	eax, eax
	je	$LN10@xmlGetNsLi

; 5907 :     xmlNsPtr cur;
; 5908 :     xmlNsPtr *ret = NULL;
; 5909 :     int nbns = 0;
; 5910 :     int maxns = 10;
; 5911 :     int i;
; 5912 : 
; 5913 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	$LN10@xmlGetNsLi
$LL2@xmlGetNsLi:

; 5914 :         return(NULL);
; 5915 : 
; 5916 :     while (node != NULL) {
; 5917 :         if (node->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	$LN5@xmlGetNsLi

; 5918 :             cur = node->nsDef;

	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR _cur$1$[ebp], edx

; 5919 :             while (cur != NULL) {

	test	edx, edx
	je	$LN5@xmlGetNsLi
	npad	4
$LL4@xmlGetNsLi:

; 5920 :                 if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN12@xmlGetNsLi

; 5921 :                     ret =

	lea	eax, DWORD PTR [esi*4+4]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5922 :                         (xmlNsPtr *) xmlMalloc((maxns + 1) *
; 5923 :                                                sizeof(xmlNsPtr));
; 5924 :                     if (ret == NULL) {

	test	ebx, ebx
	je	$LN29@xmlGetNsLi

; 5925 : 			xmlTreeErrMemory("getting namespace list");
; 5926 :                         return (NULL);
; 5927 :                     }
; 5928 :                     ret[nbns] = NULL;

	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR [ebx+edi*4], 0
$LN12@xmlGetNsLi:

; 5929 :                 }
; 5930 :                 for (i = 0; i < nbns; i++) {

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN39@xmlGetNsLi
	npad	1
$LL8@xmlGetNsLi:

; 5931 :                     if ((cur->prefix == ret[i]->prefix) ||

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [eax+12]
	cmp	ecx, eax
	je	SHORT $LN27@xmlGetNsLi
	push	eax
	push	ecx
	call	_xmlStrEqual
	mov	edx, DWORD PTR _cur$1$[ebp]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlGetNsLi

; 5929 :                 }
; 5930 :                 for (i = 0; i < nbns; i++) {

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL8@xmlGetNsLi

; 5932 :                         (xmlStrEqual(cur->prefix, ret[i]->prefix)))
; 5933 :                         break;
; 5934 :                 }
; 5935 :                 if (i >= nbns) {

	jmp	SHORT $LN39@xmlGetNsLi
$LN27@xmlGetNsLi:
	cmp	esi, edi
	jl	SHORT $LN42@xmlGetNsLi
$LN39@xmlGetNsLi:

; 5936 :                     if (nbns >= maxns) {

	mov	esi, DWORD PTR _maxns$1$[ebp]
	cmp	edi, esi
	jl	SHORT $LN18@xmlGetNsLi

; 5937 :                         maxns *= 2;

	add	esi, esi
	mov	DWORD PTR _maxns$1$[ebp], esi

; 5938 :                         ret = (xmlNsPtr *) xmlRealloc(ret,

	lea	eax, DWORD PTR [esi*4+4]
	push	eax
	push	ebx
	call	DWORD PTR _xmlRealloc
	mov	ebx, eax
	add	esp, 8

; 5939 :                                                       (maxns +
; 5940 :                                                        1) *
; 5941 :                                                       sizeof(xmlNsPtr));
; 5942 :                         if (ret == NULL) {

	test	ebx, ebx
	je	SHORT $LN29@xmlGetNsLi
$LN18@xmlGetNsLi:

; 5943 : 			    xmlTreeErrMemory("getting namespace list");
; 5944 :                             return (NULL);
; 5945 :                         }
; 5946 :                     }
; 5947 :                     ret[nbns++] = cur;

	mov	edx, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR [ebx+edi*4], edx
	inc	edi

; 5948 :                     ret[nbns] = NULL;

	mov	DWORD PTR [ebx+edi*4], 0
	jmp	SHORT $LN16@xmlGetNsLi
$LN42@xmlGetNsLi:

; 5932 :                         (xmlStrEqual(cur->prefix, ret[i]->prefix)))
; 5933 :                         break;
; 5934 :                 }
; 5935 :                 if (i >= nbns) {

	mov	esi, DWORD PTR _maxns$1$[ebp]
$LN16@xmlGetNsLi:

; 5949 :                 }
; 5950 : 
; 5951 :                 cur = cur->next;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _cur$1$[ebp], edx
	test	edx, edx
	jne	$LL4@xmlGetNsLi
	mov	eax, DWORD PTR _node$[ebp]
$LN5@xmlGetNsLi:

; 5952 :             }
; 5953 :         }
; 5954 :         node = node->parent;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _node$[ebp], eax
	test	eax, eax
	jne	$LL2@xmlGetNsLi

; 5955 :     }
; 5956 :     return (ret);
; 5957 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlGetNsLi:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BH@FLIFGMAI@getting?5namespace?5list@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN10@xmlGetNsLi:
	pop	edi

; 5955 :     }
; 5956 :     return (ret);
; 5957 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetNsList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSearchNsByHref
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_orig$1$ = 12						; size = 4
_node$ = 12						; size = 4
_href$ = 16						; size = 4
_xmlSearchNsByHref PROC					; COMDAT

; 6139 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _orig$1$[ebp], edi
	test	edi, edi
	je	$LN43@xmlSearchN

; 6140 :     xmlNsPtr cur;
; 6141 :     xmlNodePtr orig = node;
; 6142 :     int is_attr;
; 6143 : 
; 6144 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) || (href == NULL))

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN43@xmlSearchN
	mov	eax, DWORD PTR _href$[ebp]
	test	eax, eax
	je	$LN43@xmlSearchN

; 6145 :         return (NULL);
; 6146 :     if (xmlStrEqual(href, XML_XML_NAMESPACE)) {

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN14@xmlSearchN

; 6147 :         /*
; 6148 :          * Only the document can hold the XML spec namespace.
; 6149 :          */
; 6150 :         if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN12@xmlSearchN
	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN40@xmlSearchN

; 6151 :             /*
; 6152 :              * The XML-1.0 namespace is normally held on the root
; 6153 :              * element. In this case exceptionally create it on the
; 6154 :              * node element.
; 6155 :              */
; 6156 :             cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 6157 :             if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlSearchN

; 6158 : 		xmlTreeErrMemory("searching namespace");

	push	OFFSET ??_C@_0BE@FPBDMLJE@searching?5namespace@
	call	_xmlTreeErrMemory
	add	esp, 4

; 6212 :     }
; 6213 :     return (NULL);
; 6214 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlSearchN:
	xorps	xmm0, xmm0

; 6159 :                 return (NULL);
; 6160 :             }
; 6161 :             memset(cur, 0, sizeof(xmlNs));

	movups	XMMWORD PTR [esi], xmm0

; 6162 :             cur->type = XML_LOCAL_NAMESPACE;
; 6163 :             cur->href = xmlStrdup(XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+4], 18			; 00000012H
	call	_xmlStrdup

; 6164 :             cur->prefix = xmlStrdup((const xmlChar *) "xml");

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	DWORD PTR [esi+8], eax
	call	_xmlStrdup
	mov	DWORD PTR [esi+12], eax
	add	esp, 8

; 6165 :             cur->next = node->nsDef;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi], eax

; 6166 :             node->nsDef = cur;

	mov	DWORD PTR [edi+48], esi
$LN29@xmlSearchN:

; 6212 :     }
; 6213 :     return (NULL);
; 6214 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN40@xmlSearchN:

; 6167 :             return (cur);
; 6168 :         }
; 6169 : 	if (doc == NULL) {
; 6170 : 	    doc = node->doc;

	mov	eax, DWORD PTR [edi+32]

; 6171 : 	    if (doc == NULL)

	test	eax, eax
	je	$LN43@xmlSearchN
$LN12@xmlSearchN:

; 6172 : 		return(NULL);
; 6173 : 	}
; 6174 : 	/*
; 6175 : 	* Return the XML namespace declaration held by the doc.
; 6176 : 	*/
; 6177 : 	if (doc->oldNs == NULL)

	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	jne	SHORT $LN13@xmlSearchN

; 6178 : 	    return(xmlTreeEnsureXMLDecl(doc));

	push	eax
	call	_xmlTreeEnsureXMLDecl
	add	esp, 4
	pop	edi

; 6212 :     }
; 6213 :     return (NULL);
; 6214 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlSearchN:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlSearchN:

; 6179 : 	else
; 6180 : 	    return(doc->oldNs);
; 6181 :     }
; 6182 :     is_attr = (node->type == XML_ATTRIBUTE_NODE);

	mov	ebx, DWORD PTR [edi+4]
$LL2@xmlSearchN:

; 6183 :     while (node != NULL) {
; 6184 :         if ((node->type == XML_ENTITY_REF_NODE) ||
; 6185 :             (node->type == XML_ENTITY_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 5
	je	$LN43@xmlSearchN
	cmp	eax, 6
	je	$LN43@xmlSearchN
	cmp	eax, 17					; 00000011H
	je	$LN43@xmlSearchN

; 6186 :             (node->type == XML_ENTITY_DECL))
; 6187 :             return (NULL);
; 6188 :         if (node->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	$LN24@xmlSearchN

; 6189 :             cur = node->nsDef;

	mov	esi, DWORD PTR [edi+48]

; 6190 :             while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSearchN
$LL4@xmlSearchN:

; 6191 :                 if ((cur->href != NULL) && (href != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN19@xmlSearchN
	push	DWORD PTR _href$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlSearchN

; 6192 :                     (xmlStrEqual(cur->href, href))) {
; 6193 : 		    if (((!is_attr) || (cur->prefix != NULL)) &&

	cmp	ebx, 2
	jne	SHORT $LN41@xmlSearchN
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN19@xmlSearchN
$LN41@xmlSearchN:
	push	DWORD PTR [esi+12]
	push	edi
	push	DWORD PTR _orig$1$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNsInScope
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	$LN29@xmlSearchN
$LN19@xmlSearchN:

; 6194 : 		        (xmlNsInScope(doc, orig, node, cur->prefix) == 1))
; 6195 : 			return (cur);
; 6196 :                 }
; 6197 :                 cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlSearchN
$LN5@xmlSearchN:

; 6198 :             }
; 6199 :             if (orig != node) {

	cmp	DWORD PTR _orig$1$[ebp], edi
	je	SHORT $LN24@xmlSearchN

; 6200 :                 cur = node->ns;

	mov	esi, DWORD PTR [edi+36]

; 6201 :                 if (cur != NULL) {

	test	esi, esi
	je	SHORT $LN24@xmlSearchN

; 6202 :                     if ((cur->href != NULL) && (href != NULL) &&

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN24@xmlSearchN
	push	DWORD PTR _href$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlSearchN

; 6203 :                         (xmlStrEqual(cur->href, href))) {
; 6204 : 			if (((!is_attr) || (cur->prefix != NULL)) &&

	cmp	ebx, 2
	jne	SHORT $LN42@xmlSearchN
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN24@xmlSearchN
$LN42@xmlSearchN:
	push	DWORD PTR [esi+12]
	push	edi
	push	DWORD PTR _orig$1$[ebp]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNsInScope
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	$LN29@xmlSearchN
$LN24@xmlSearchN:

; 6205 : 		            (xmlNsInScope(doc, orig, node, cur->prefix) == 1))
; 6206 : 			    return (cur);
; 6207 :                     }
; 6208 :                 }
; 6209 :             }
; 6210 :         }
; 6211 :         node = node->parent;

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	jne	$LL2@xmlSearchN
$LN43@xmlSearchN:
	pop	edi

; 6212 :     }
; 6213 :     return (NULL);
; 6214 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSearchNsByHref ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSearchNs
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_orig$1$ = 12						; size = 4
_node$ = 12						; size = 4
_nameSpace$ = 16					; size = 4
_xmlSearchNs PROC					; COMDAT

; 6009 : xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _orig$1$[ebp], ebx
	test	ebx, ebx
	je	$LN46@xmlSearchN

; 6010 : 
; 6011 :     xmlNsPtr cur;
; 6012 :     const xmlNode *orig = node;
; 6013 : 
; 6014 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);

	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN46@xmlSearchN

; 6015 :     if ((nameSpace != NULL) &&

	mov	edi, DWORD PTR _nameSpace$[ebp]
	test	edi, edi
	je	$LL2@xmlSearchN
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LL2@xmlSearchN

; 6016 : 	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
; 6017 : 	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN12@xmlSearchN
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN39@xmlSearchN

; 6018 : 	    /*
; 6019 : 	     * The XML-1.0 namespace is normally held on the root
; 6020 : 	     * element. In this case exceptionally create it on the
; 6021 : 	     * node element.
; 6022 : 	     */
; 6023 : 	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 6024 : 	    if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlSearchN

; 6025 : 		xmlTreeErrMemory("searching namespace");

	push	OFFSET ??_C@_0BE@FPBDMLJE@searching?5namespace@
	call	_xmlTreeErrMemory
	add	esp, 4

; 6080 :     }
; 6081 :     return(NULL);
; 6082 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlSearchN:
	xorps	xmm0, xmm0

; 6026 : 		return(NULL);
; 6027 : 	    }
; 6028 : 	    memset(cur, 0, sizeof(xmlNs));

	movups	XMMWORD PTR [esi], xmm0

; 6029 : 	    cur->type = XML_LOCAL_NAMESPACE;
; 6030 : 	    cur->href = xmlStrdup(XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+4], 18			; 00000012H
	call	_xmlStrdup

; 6031 : 	    cur->prefix = xmlStrdup((const xmlChar *)"xml");

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	DWORD PTR [esi+8], eax
	call	_xmlStrdup
	mov	DWORD PTR [esi+12], eax
	add	esp, 8

; 6032 : 	    cur->next = node->nsDef;

	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [esi], eax

; 6033 : 	    node->nsDef = cur;

	mov	DWORD PTR [ebx+48], esi
$LN28@xmlSearchN:

; 6080 :     }
; 6081 :     return(NULL);
; 6082 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN39@xmlSearchN:

; 6034 : 	    return(cur);
; 6035 : 	}
; 6036 : 	if (doc == NULL) {
; 6037 : 	    doc = node->doc;

	mov	eax, DWORD PTR [ebx+32]

; 6038 : 	    if (doc == NULL)

	test	eax, eax
	je	$LN46@xmlSearchN
$LN12@xmlSearchN:

; 6039 : 		return(NULL);
; 6040 : 	}
; 6041 : 	/*
; 6042 : 	* Return the XML namespace declaration held by the doc.
; 6043 : 	*/
; 6044 : 	if (doc->oldNs == NULL)

	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	jne	SHORT $LN13@xmlSearchN

; 6045 : 	    return(xmlTreeEnsureXMLDecl(doc));

	push	eax
	call	_xmlTreeEnsureXMLDecl
	add	esp, 4
	pop	edi

; 6080 :     }
; 6081 :     return(NULL);
; 6082 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlSearchN:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
$LL2@xmlSearchN:

; 6046 : 	else
; 6047 : 	    return(doc->oldNs);
; 6048 :     }
; 6049 :     while (node != NULL) {
; 6050 : 	if ((node->type == XML_ENTITY_REF_NODE) ||
; 6051 : 	    (node->type == XML_ENTITY_NODE) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 5
	je	$LN46@xmlSearchN
	cmp	eax, 6
	je	$LN46@xmlSearchN
	cmp	eax, 17					; 00000011H
	je	$LN46@xmlSearchN

; 6052 : 	    (node->type == XML_ENTITY_DECL))
; 6053 : 	    return(NULL);
; 6054 : 	if (node->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	SHORT $LN23@xmlSearchN

; 6055 : 	    cur = node->nsDef;

	mov	esi, DWORD PTR [ebx+48]

; 6056 : 	    while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSearchN
	npad	6
$LL4@xmlSearchN:

; 6057 : 		if ((cur->prefix == NULL) && (nameSpace == NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN56@xmlSearchN
	test	edi, edi
	jne	SHORT $LN18@xmlSearchN
	cmp	DWORD PTR [esi+8], edi
	jne	SHORT $LN28@xmlSearchN
$LN18@xmlSearchN:

; 6058 : 		    (cur->href != NULL))
; 6059 : 		    return(cur);
; 6060 : 		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
; 6061 : 		    (cur->href != NULL) &&

	test	eax, eax
	je	SHORT $LN19@xmlSearchN
$LN56@xmlSearchN:
	test	edi, edi
	je	SHORT $LN19@xmlSearchN
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN19@xmlSearchN
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlSearchN
$LN19@xmlSearchN:

; 6062 : 		    (xmlStrEqual(cur->prefix, nameSpace)))
; 6063 : 		    return(cur);
; 6064 : 		cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlSearchN
$LN5@xmlSearchN:

; 6065 : 	    }
; 6066 : 	    if (orig != node) {

	cmp	DWORD PTR _orig$1$[ebp], ebx
	je	SHORT $LN23@xmlSearchN

; 6067 : 	        cur = node->ns;

	mov	esi, DWORD PTR [ebx+36]

; 6068 : 	        if (cur != NULL) {

	test	esi, esi
	je	SHORT $LN23@xmlSearchN

; 6069 : 		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN38@xmlSearchN
	test	edi, edi
	jne	SHORT $LN23@xmlSearchN
	cmp	DWORD PTR [esi+8], edi

; 6070 : 		        (cur->href != NULL))
; 6071 : 		        return(cur);
; 6072 : 		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
; 6073 : 		        (cur->href != NULL) &&

	jmp	SHORT $LN57@xmlSearchN
$LN38@xmlSearchN:
	test	edi, edi
	je	SHORT $LN23@xmlSearchN
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN23@xmlSearchN
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
$LN57@xmlSearchN:

; 6074 : 		        (xmlStrEqual(cur->prefix, nameSpace)))
; 6075 : 		        return(cur);
; 6076 : 	        }
; 6077 : 	    }
; 6078 : 	}
; 6079 : 	node = node->parent;

	jne	$LN28@xmlSearchN
$LN23@xmlSearchN:
	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	$LL2@xmlSearchN
$LN46@xmlSearchN:
	pop	edi

; 6080 :     }
; 6081 :     return(NULL);
; 6082 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSearchNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetListDoc
_TEXT	SEGMENT
_list$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlSetListDoc PROC					; COMDAT

; 2851 : xmlSetListDoc(xmlNodePtr list, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSetList

; 2852 :     xmlNodePtr cur;
; 2853 : 
; 2854 :     if ((list == NULL) || (list->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN5@xmlSetList

; 2855 : 	return;
; 2856 :     cur = list;

	push	edi
	mov	edi, DWORD PTR _doc$[ebp]
	npad	1
$LL2@xmlSetList:

; 2857 :     while (cur != NULL) {
; 2858 : 	if (cur->doc != doc)

	cmp	DWORD PTR [esi+32], edi
	je	SHORT $LN6@xmlSetList

; 2859 : 	    xmlSetTreeDoc(cur, doc);

	push	edi
	push	esi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN6@xmlSetList:

; 2860 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSetList
	pop	edi
$LN5@xmlSetList:
	pop	esi

; 2861 :     }
; 2862 : }

	pop	ebp
	ret	0
_xmlSetListDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetTreeDoc
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlSetTreeDoc PROC					; COMDAT

; 2804 : xmlSetTreeDoc(xmlNodePtr tree, xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _tree$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSetTree

; 2805 :     xmlAttrPtr prop;
; 2806 : 
; 2807 :     if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	je	SHORT $LN5@xmlSetTree

; 2808 : 	return;
; 2809 :     if (tree->doc != doc) {

	push	ebx
	mov	ebx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edi+32], ebx
	je	SHORT $LN15@xmlSetTree

; 2810 : 	if(tree->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	SHORT $LN3@xmlSetTree

; 2811 : 	    prop = tree->properties;

	push	esi
	mov	esi, DWORD PTR [edi+44]

; 2812 : 	    while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN16@xmlSetTree
$LL2@xmlSetTree:

; 2813 :                 if (prop->atype == XML_ATTRIBUTE_ID) {

	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN8@xmlSetTree

; 2814 :                     xmlRemoveID(tree->doc, prop);

	push	esi
	push	DWORD PTR [edi+32]
	call	_xmlRemoveID
	add	esp, 8
$LN8@xmlSetTree:

; 2815 :                 }
; 2816 : 
; 2817 : 		prop->doc = doc;
; 2818 : 		xmlSetListDoc(prop->children, doc);

	push	ebx
	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+32], ebx
	call	_xmlSetListDoc

; 2819 : 
; 2820 :                 /*
; 2821 :                  * TODO: ID attributes should be also added to the new
; 2822 :                  * document, but this breaks things like xmlReplaceNode.
; 2823 :                  * The underlying problem is that xmlRemoveID is only called
; 2824 :                  * if a node is destroyed, not if it's unlinked.
; 2825 :                  */
; 2826 : #if 0
; 2827 :                 if (xmlIsID(doc, tree, prop)) {
; 2828 :                     xmlChar *idVal = xmlNodeListGetString(doc, prop->children,
; 2829 :                                                           1);
; 2830 :                     xmlAddID(NULL, doc, idVal, prop);
; 2831 :                 }
; 2832 : #endif
; 2833 : 
; 2834 : 		prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@xmlSetTree
$LN16@xmlSetTree:
	pop	esi
$LN3@xmlSetTree:

; 2835 : 	    }
; 2836 : 	}
; 2837 : 	if (tree->children != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN9@xmlSetTree

; 2838 : 	    xmlSetListDoc(tree->children, doc);

	push	ebx
	push	eax
	call	_xmlSetListDoc
	add	esp, 8
$LN9@xmlSetTree:

; 2839 : 	tree->doc = doc;

	mov	DWORD PTR [edi+32], ebx
$LN15@xmlSetTree:
	pop	ebx
$LN5@xmlSetTree:
	pop	edi

; 2840 :     }
; 2841 : }

	pop	ebp
	ret	0
_xmlSetTreeDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeNode
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeNode PROC					; COMDAT

; 3735 : xmlFreeNode(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN1@xmlFreeNod

; 3736 :     xmlDictPtr dict = NULL;
; 3737 : 
; 3738 :     if (cur == NULL) return;
; 3739 : 
; 3740 :     /* use xmlFreeDtd for DTD nodes */
; 3741 :     if (cur->type == XML_DTD_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN3@xmlFreeNod

; 3742 : 	xmlFreeDtd((xmlDtdPtr) cur);

	push	esi
	call	_xmlFreeDtd

; 3797 : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlFreeNod:

; 3743 : 	return;
; 3744 :     }
; 3745 :     if (cur->type == XML_NAMESPACE_DECL) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN4@xmlFreeNod

; 3746 : 	xmlFreeNs((xmlNsPtr) cur);

	push	esi
	call	_xmlFreeNs

; 3797 : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlFreeNod:

; 3747 :         return;
; 3748 :     }
; 3749 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN5@xmlFreeNod

; 3750 : 	xmlFreeProp((xmlAttrPtr) cur);

	push	esi
	call	_xmlFreeProp

; 3797 : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlFreeNod:

; 3751 : 	return;
; 3752 :     }
; 3753 : 
; 3754 :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, edi
	je	SHORT $LN6@xmlFreeNod
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN6@xmlFreeNod

; 3755 : 	xmlDeregisterNodeDefaultValue(cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN6@xmlFreeNod:

; 3756 : 
; 3757 :     if (cur->doc != NULL) dict = cur->doc->dict;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN7@xmlFreeNod
	mov	edi, DWORD PTR [eax+80]
$LN7@xmlFreeNod:

; 3758 : 
; 3759 :     if (cur->type == XML_ENTITY_DECL) {

	cmp	DWORD PTR [esi+4], 17			; 00000011H
	jne	SHORT $LN11@xmlFreeNod

; 3760 :         xmlEntityPtr ent = (xmlEntityPtr) cur;
; 3761 : 	DICT_FREE(ent->SystemID);

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN9@xmlFreeNod
	test	edi, edi
	je	SHORT $LN10@xmlFreeNod
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlFreeNod
$LN10@xmlFreeNod:
	push	DWORD PTR [esi+56]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeNod:

; 3762 : 	DICT_FREE(ent->ExternalID);

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN11@xmlFreeNod
	test	edi, edi
	je	SHORT $LN12@xmlFreeNod
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlFreeNod
$LN12@xmlFreeNod:
	push	DWORD PTR [esi+52]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlFreeNod:

; 3763 :     }
; 3764 :     if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN13@xmlFreeNod
	cmp	DWORD PTR [esi+4], 5
	je	SHORT $LN13@xmlFreeNod

; 3765 : 	(cur->type != XML_ENTITY_REF_NODE))
; 3766 : 	xmlFreeNodeList(cur->children);

	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN13@xmlFreeNod:

; 3767 :     if (((cur->type == XML_ELEMENT_NODE) ||
; 3768 : 	 (cur->type == XML_XINCLUDE_START) ||
; 3769 : 	 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN15@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN15@xmlFreeNod
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN14@xmlFreeNod
$LN15@xmlFreeNod:
	mov	ecx, DWORD PTR [esi+44]
	test	ecx, ecx
	je	SHORT $LN14@xmlFreeNod

; 3770 : 	(cur->properties != NULL))
; 3771 : 	xmlFreePropList(cur->properties);

	push	ecx
	call	_xmlFreePropList
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN14@xmlFreeNod:

; 3772 :     if ((cur->type != XML_ELEMENT_NODE) &&
; 3773 : 	(cur->content != NULL) &&
; 3774 : 	(cur->type != XML_ENTITY_REF_NODE) &&
; 3775 : 	(cur->type != XML_XINCLUDE_END) &&
; 3776 : 	(cur->type != XML_XINCLUDE_START) &&

	cmp	eax, 1
	je	SHORT $LN17@xmlFreeNod
	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN17@xmlFreeNod
	cmp	eax, 5
	je	SHORT $LN17@xmlFreeNod
	cmp	eax, 20					; 00000014H
	je	SHORT $LN17@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN17@xmlFreeNod
	lea	eax, DWORD PTR [esi+44]
	cmp	ecx, eax
	je	SHORT $LN17@xmlFreeNod

; 3777 : 	(cur->content != (xmlChar *) &(cur->properties))) {
; 3778 : 	DICT_FREE(cur->content)

	test	edi, edi
	je	SHORT $LN18@xmlFreeNod
	push	ecx
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlFreeNod
$LN18@xmlFreeNod:
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlFreeNod:

; 3779 :     }
; 3780 : 
; 3781 :     /*
; 3782 :      * When a node is a text node or a comment, it uses a global static
; 3783 :      * variable for the name of the node.
; 3784 :      * Otherwise the node name might come from the document's dictionary
; 3785 :      */
; 3786 :     if ((cur->name != NULL) &&
; 3787 :         (cur->type != XML_TEXT_NODE) &&

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN20@xmlFreeNod
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	je	SHORT $LN20@xmlFreeNod
	cmp	eax, 8
	je	SHORT $LN20@xmlFreeNod

; 3788 :         (cur->type != XML_COMMENT_NODE))
; 3789 : 	DICT_FREE(cur->name)

	test	edi, edi
	je	SHORT $LN21@xmlFreeNod
	push	ecx
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlFreeNod
$LN21@xmlFreeNod:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlFreeNod:

; 3790 : 
; 3791 :     if (((cur->type == XML_ELEMENT_NODE) ||
; 3792 : 	 (cur->type == XML_XINCLUDE_START) ||
; 3793 : 	 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN23@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN23@xmlFreeNod
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN22@xmlFreeNod
$LN23@xmlFreeNod:
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN22@xmlFreeNod

; 3794 : 	(cur->nsDef != NULL))
; 3795 : 	xmlFreeNsList(cur->nsDef);

	push	eax
	call	_xmlFreeNsList
	add	esp, 4
$LN22@xmlFreeNod:

; 3796 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree

; 3797 : }

	add	esp, 4
$LN1@xmlFreeNod:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlFreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeNodeList
_TEXT	SEGMENT
_next$1$ = 8						; size = 4
_cur$ = 8						; size = 4
_xmlFreeNodeList PROC					; COMDAT

; 3665 : xmlFreeNodeList(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	test	edi, edi
	je	$LN3@xmlFreeNod

; 3666 :     xmlNodePtr next;
; 3667 :     xmlDictPtr dict = NULL;
; 3668 : 
; 3669 :     if (cur == NULL) return;
; 3670 :     if (cur->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN5@xmlFreeNod

; 3671 : 	xmlFreeNsList((xmlNsPtr) cur);

	push	edi
	call	_xmlFreeNsList

; 3724 :     }
; 3725 : }

	add	esp, 4
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlFreeNod:

; 3672 : 	return;
; 3673 :     }
; 3674 :     if ((cur->type == XML_DOCUMENT_NODE) ||
; 3675 : #ifdef LIBXML_DOCB_ENABLED
; 3676 : 	(cur->type == XML_DOCB_DOCUMENT_NODE) ||

	cmp	eax, 9
	je	$LN7@xmlFreeNod
	cmp	eax, 21					; 00000015H
	je	$LN7@xmlFreeNod
	cmp	eax, 13					; 0000000dH
	je	$LN7@xmlFreeNod

; 3680 : 	return;
; 3681 :     }
; 3682 :     if (cur->doc != NULL) dict = cur->doc->dict;

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN57@xmlFreeNod
	mov	ebx, DWORD PTR [eax+80]
$LN57@xmlFreeNod:
	push	esi
	npad	9
$LL2@xmlFreeNod:

; 3683 :     while (cur != NULL) {
; 3684 :         next = cur->next;
; 3685 : 	if (cur->type != XML_DTD_NODE) {

	cmp	DWORD PTR [edi+4], 14			; 0000000eH
	mov	esi, DWORD PTR [edi+24]
	mov	DWORD PTR _next$1$[ebp], esi
	je	$LN9@xmlFreeNod

; 3686 : 
; 3687 : 	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN10@xmlFreeNod
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@xmlFreeNod

; 3688 : 		xmlDeregisterNodeDefaultValue(cur);

	call	___xmlDeregisterNodeDefaultValue
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN10@xmlFreeNod:

; 3689 : 
; 3690 : 	    if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN11@xmlFreeNod
	cmp	DWORD PTR [edi+4], 5
	je	SHORT $LN11@xmlFreeNod

; 3691 : 		(cur->type != XML_ENTITY_REF_NODE))
; 3692 : 		xmlFreeNodeList(cur->children);

	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN11@xmlFreeNod:

; 3693 : 	    if (((cur->type == XML_ELEMENT_NODE) ||
; 3694 : 		 (cur->type == XML_XINCLUDE_START) ||
; 3695 : 		 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN13@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN13@xmlFreeNod
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN25@xmlFreeNod
$LN13@xmlFreeNod:
	mov	ecx, DWORD PTR [edi+44]
	test	ecx, ecx
	je	SHORT $LN25@xmlFreeNod
	npad	1
$LL24@xmlFreeNod:

; 2071 :         next = cur->next;

	mov	esi, DWORD PTR [ecx+24]

; 2072 :         xmlFreeProp(cur);

	push	ecx
	call	_xmlFreeProp
	add	esp, 4

; 2073 : 	cur = next;

	mov	ecx, esi
	test	esi, esi
	jne	SHORT $LL24@xmlFreeNod
	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _next$1$[ebp]
$LN25@xmlFreeNod:

; 3696 : 		(cur->properties != NULL))
; 3697 : 		xmlFreePropList(cur->properties);
; 3698 : 	    if ((cur->type != XML_ELEMENT_NODE) &&
; 3699 : 		(cur->type != XML_XINCLUDE_START) &&
; 3700 : 		(cur->type != XML_XINCLUDE_END) &&
; 3701 : 		(cur->type != XML_ENTITY_REF_NODE) &&

	cmp	eax, 1
	je	SHORT $LN15@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN15@xmlFreeNod
	cmp	eax, 20					; 00000014H
	je	SHORT $LN15@xmlFreeNod
	cmp	eax, 5
	je	SHORT $LN15@xmlFreeNod
	mov	ecx, DWORD PTR [edi+40]
	lea	eax, DWORD PTR [edi+44]
	cmp	ecx, eax
	je	SHORT $LN15@xmlFreeNod

; 3702 : 		(cur->content != (xmlChar *) &(cur->properties))) {
; 3703 : 		DICT_FREE(cur->content)

	test	ecx, ecx
	je	SHORT $LN15@xmlFreeNod
	test	ebx, ebx
	je	SHORT $LN16@xmlFreeNod
	push	ecx
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlFreeNod
$LN16@xmlFreeNod:
	push	DWORD PTR [edi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlFreeNod:

; 3704 : 	    }
; 3705 : 	    if (((cur->type == XML_ELEMENT_NODE) ||
; 3706 : 	         (cur->type == XML_XINCLUDE_START) ||
; 3707 : 		 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN18@xmlFreeNod
	cmp	eax, 19					; 00000013H
	je	SHORT $LN18@xmlFreeNod
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN17@xmlFreeNod
$LN18@xmlFreeNod:
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN17@xmlFreeNod

; 3708 : 		(cur->nsDef != NULL))
; 3709 : 		xmlFreeNsList(cur->nsDef);

	push	eax
	call	_xmlFreeNsList
	add	esp, 4
$LN17@xmlFreeNod:

; 3710 : 
; 3711 : 	    /*
; 3712 : 	     * When a node is a text node or a comment, it uses a global static
; 3713 : 	     * variable for the name of the node.
; 3714 : 	     * Otherwise the node name might come from the document's
; 3715 : 	     * dictionary
; 3716 : 	     */
; 3717 : 	    if ((cur->name != NULL) &&
; 3718 : 		(cur->type != XML_TEXT_NODE) &&

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN20@xmlFreeNod
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 3
	je	SHORT $LN20@xmlFreeNod
	cmp	eax, 8
	je	SHORT $LN20@xmlFreeNod

; 3719 : 		(cur->type != XML_COMMENT_NODE))
; 3720 : 		DICT_FREE(cur->name)

	test	ebx, ebx
	je	SHORT $LN21@xmlFreeNod
	push	ecx
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlFreeNod
$LN21@xmlFreeNod:
	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN20@xmlFreeNod:

; 3721 : 	    xmlFree(cur);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeNod:

; 3722 : 	}
; 3723 : 	cur = next;

	mov	edi, esi
	test	esi, esi
	jne	$LL2@xmlFreeNod

; 3724 :     }
; 3725 : }

	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlFreeNod:

; 3677 : #endif
; 3678 : 	(cur->type == XML_HTML_DOCUMENT_NODE)) {
; 3679 : 	xmlFreeDoc((xmlDocPtr) cur);

	push	edi
	call	_xmlFreeDoc

; 3724 :     }
; 3725 : }

	add	esp, 4
$LN3@xmlFreeNod:
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
_xmlFreeNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTextConcat
_TEXT	SEGMENT
_node$ = 8						; size = 4
_content$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlTextConcat PROC					; COMDAT

; 6979 : xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN11@xmlTextCon

; 6980 :     if (node == NULL) return(-1);
; 6981 : 
; 6982 :     if ((node->type != XML_TEXT_NODE) &&
; 6983 :         (node->type != XML_CDATA_SECTION_NODE) &&
; 6984 : 	(node->type != XML_COMMENT_NODE) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	je	SHORT $LN3@xmlTextCon
	cmp	eax, 4
	je	SHORT $LN3@xmlTextCon
	cmp	eax, 8
	je	SHORT $LN3@xmlTextCon
	cmp	eax, 7
	jne	SHORT $LN11@xmlTextCon
$LN3@xmlTextCon:

; 6985 : 	(node->type != XML_PI_NODE)) {
; 6986 : #ifdef DEBUG_TREE
; 6987 : 	xmlGenericError(xmlGenericErrorContext,
; 6988 : 		"xmlTextConcat: node is not text nor CDATA\n");
; 6989 : #endif
; 6990 :         return(-1);
; 6991 :     }
; 6992 :     /* need to check if content is currently in the dictionary */
; 6993 :     if ((node->content == (xmlChar *) &(node->properties)) ||

	mov	eax, DWORD PTR [esi+40]
	push	edi
	lea	edi, DWORD PTR [esi+44]
	cmp	eax, edi
	je	SHORT $LN10@xmlTextCon
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN4@xmlTextCon
	mov	ecx, DWORD PTR [ecx+80]
	test	ecx, ecx
	je	SHORT $LN4@xmlTextCon
	push	eax
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlTextCon
$LN4@xmlTextCon:

; 6997 :     } else {
; 6998 :         node->content = xmlStrncat(node->content, content, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _content$[ebp]
	push	DWORD PTR [esi+40]
	call	_xmlStrncat
	jmp	SHORT $LN12@xmlTextCon
$LN10@xmlTextCon:

; 6994 :         ((node->doc != NULL) && (node->doc->dict != NULL) &&
; 6995 : 		xmlDictOwns(node->doc->dict, node->content))) {
; 6996 : 	node->content = xmlStrncatNew(node->content, content, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _content$[ebp]
	push	DWORD PTR [esi+40]
	call	_xmlStrncatNew
$LN12@xmlTextCon:

; 6999 :     }
; 7000 :     node->properties = NULL;

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+40], eax

; 7001 :     if (node->content == NULL)

	cmp	DWORD PTR [esi+40], 0
	mov	DWORD PTR [edi], 0
	pop	edi
	je	SHORT $LN11@xmlTextCon

; 7003 :     return(0);

	xor	eax, eax
	pop	esi

; 7004 : }

	pop	ebp
	ret	0
$LN11@xmlTextCon:

; 7002 :         return(-1);

	or	eax, -1
	pop	esi

; 7004 : }

	pop	ebp
	ret	0
_xmlTextConcat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlTextMerge
_TEXT	SEGMENT
_first$ = 8						; size = 4
_second$ = 12						; size = 4
_xmlTextMerge PROC					; COMDAT

; 5880 : xmlTextMerge(xmlNodePtr first, xmlNodePtr second) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _first$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlTextMer

; 5881 :     if (first == NULL) return(second);

	mov	eax, DWORD PTR _second$[ebp]
	pop	edi

; 5891 : }

	pop	ebp
	ret	0
$LN2@xmlTextMer:
	push	esi

; 5882 :     if (second == NULL) return(first);

	mov	esi, DWORD PTR _second$[ebp]
	test	esi, esi
	je	SHORT $LN36@xmlTextMer

; 5883 :     if (first->type != XML_TEXT_NODE) return(first);

	cmp	DWORD PTR [edi+4], 3
	jne	SHORT $LN36@xmlTextMer

; 5884 :     if (second->type != XML_TEXT_NODE) return(first);

	cmp	DWORD PTR [esi+4], 3
	jne	SHORT $LN36@xmlTextMer

; 5885 :     if (second->name != first->name)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN36@xmlTextMer

; 5887 :     xmlNodeAddContent(first, second->content);

	push	ebx
	mov	ebx, DWORD PTR [esi+40]

; 5866 :     if (content == NULL) return;

	test	ebx, ebx
	je	SHORT $LN8@xmlTextMer

; 5867 :     len = xmlStrlen(content);

	push	ebx
	call	_xmlStrlen

; 5868 :     xmlNodeAddContentLen(cur, content, len);

	push	eax
	push	ebx
	push	edi
	call	_xmlNodeAddContentLen
	add	esp, 16					; 00000010H
$LN8@xmlTextMer:

; 5888 :     xmlUnlinkNode(second);

	push	esi
	call	_xmlUnlinkNode

; 5889 :     xmlFreeNode(second);

	push	esi
	call	_xmlFreeNode
	add	esp, 8

; 5890 :     return(first);

	pop	ebx
$LN36@xmlTextMer:

; 5886 : 	return(first);

	pop	esi
	mov	eax, edi
	pop	edi

; 5891 : }

	pop	ebp
	ret	0
_xmlTextMerge ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlUnlinkNode
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlUnlinkNode PROC					; COMDAT

; 3810 : xmlUnlinkNode(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN1@xmlUnlinkN

; 3811 :     if (cur == NULL) {
; 3812 : #ifdef DEBUG_TREE
; 3813 :         xmlGenericError(xmlGenericErrorContext,
; 3814 : 		"xmlUnlinkNode : node == NULL\n");
; 3815 : #endif
; 3816 : 	return;
; 3817 :     }
; 3818 :     if (cur->type == XML_NAMESPACE_DECL)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 18					; 00000012H
	je	$LN1@xmlUnlinkN

; 3819 :         return;
; 3820 :     if (cur->type == XML_DTD_NODE) {

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN7@xmlUnlinkN

; 3821 : 	xmlDocPtr doc;
; 3822 : 	doc = cur->doc;

	mov	eax, DWORD PTR [esi+32]

; 3823 : 	if (doc != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlUnlinkN

; 3824 : 	    if (doc->intSubset == (xmlDtdPtr) cur)

	cmp	DWORD PTR [eax+44], esi
	jne	SHORT $LN6@xmlUnlinkN

; 3825 : 		doc->intSubset = NULL;

	mov	DWORD PTR [eax+44], 0
$LN6@xmlUnlinkN:

; 3826 : 	    if (doc->extSubset == (xmlDtdPtr) cur)

	cmp	DWORD PTR [eax+48], esi
	jne	SHORT $LN7@xmlUnlinkN

; 3827 : 		doc->extSubset = NULL;

	mov	DWORD PTR [eax+48], 0
$LN7@xmlUnlinkN:

; 3828 : 	}
; 3829 :     }
; 3830 :     if (cur->type == XML_ENTITY_DECL) {

	cmp	DWORD PTR [esi+4], 17			; 00000011H
	jne	$LN15@xmlUnlinkN

; 3831 :         xmlDocPtr doc;
; 3832 : 	doc = cur->doc;

	push	edi
	mov	edi, DWORD PTR [esi+32]

; 3833 : 	if (doc != NULL) {

	test	edi, edi
	je	$LN25@xmlUnlinkN

; 3834 : 	    if (doc->intSubset != NULL) {

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN12@xmlUnlinkN

; 3835 : 	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)

	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlHashLookup
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN11@xmlUnlinkN

; 3836 : 		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,

	mov	eax, DWORD PTR [edi+44]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
$LN11@xmlUnlinkN:

; 3837 : 		                       NULL);
; 3838 : 	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)

	mov	eax, DWORD PTR [edi+44]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+60]
	call	_xmlHashLookup
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN12@xmlUnlinkN

; 3839 : 		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,

	mov	eax, DWORD PTR [edi+44]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+60]
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
$LN12@xmlUnlinkN:

; 3840 : 		                       NULL);
; 3841 : 	    }
; 3842 : 	    if (doc->extSubset != NULL) {

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN25@xmlUnlinkN

; 3843 : 	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)

	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlHashLookup
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN14@xmlUnlinkN

; 3844 : 		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,

	mov	eax, DWORD PTR [edi+48]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+48]
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
$LN14@xmlUnlinkN:

; 3845 : 		                       NULL);
; 3846 : 	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)

	mov	eax, DWORD PTR [edi+48]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+60]
	call	_xmlHashLookup
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN25@xmlUnlinkN

; 3847 : 		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,

	mov	eax, DWORD PTR [edi+48]
	push	0
	push	DWORD PTR [esi+8]
	push	DWORD PTR [eax+60]
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
$LN25@xmlUnlinkN:
	pop	edi
$LN15@xmlUnlinkN:

; 3848 : 		                       NULL);
; 3849 : 	    }
; 3850 : 	}
; 3851 :     }
; 3852 :     if (cur->parent != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN16@xmlUnlinkN

; 3853 : 	xmlNodePtr parent;
; 3854 : 	parent = cur->parent;
; 3855 : 	if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [esi+4], 2
	jne	SHORT $LN17@xmlUnlinkN

; 3856 : 	    if (parent->properties == (xmlAttrPtr) cur)

	cmp	DWORD PTR [ecx+44], esi
	jne	SHORT $LN21@xmlUnlinkN

; 3857 : 		parent->properties = ((xmlAttrPtr) cur)->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+44], eax

; 3858 : 	} else {

	jmp	SHORT $LN21@xmlUnlinkN
$LN17@xmlUnlinkN:

; 3859 : 	    if (parent->children == cur)

	cmp	DWORD PTR [ecx+12], esi
	jne	SHORT $LN20@xmlUnlinkN

; 3860 : 		parent->children = cur->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+12], eax
$LN20@xmlUnlinkN:

; 3861 : 	    if (parent->last == cur)

	cmp	DWORD PTR [ecx+16], esi
	jne	SHORT $LN21@xmlUnlinkN

; 3862 : 		parent->last = cur->prev;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+16], eax
$LN21@xmlUnlinkN:

; 3863 : 	}
; 3864 : 	cur->parent = NULL;

	mov	DWORD PTR [esi+20], 0
$LN16@xmlUnlinkN:

; 3865 :     }
; 3866 :     if (cur->next != NULL)

	mov	ecx, DWORD PTR [esi+24]
	test	ecx, ecx
	je	SHORT $LN22@xmlUnlinkN

; 3867 :         cur->next->prev = cur->prev;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+28], eax
$LN22@xmlUnlinkN:

; 3868 :     if (cur->prev != NULL)

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN23@xmlUnlinkN

; 3869 :         cur->prev->next = cur->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+24], eax
$LN23@xmlUnlinkN:

; 3870 :     cur->next = cur->prev = NULL;

	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], 0
$LN1@xmlUnlinkN:
	pop	esi

; 3871 : }

	pop	ebp
	ret	0
_xmlUnlinkNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddNextSibling
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlAddNextSibling PROC					; COMDAT

; 3010 : xmlAddNextSibling(xmlNodePtr cur, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN3@xmlAddNext

; 3011 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN3@xmlAddNext

; 3017 :     }
; 3018 :     if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN3@xmlAddNext
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN3@xmlAddNext

; 3019 : #ifdef DEBUG_TREE
; 3020 :         xmlGenericError(xmlGenericErrorContext,
; 3021 : 		"xmlAddNextSibling : elem == NULL\n");
; 3022 : #endif
; 3023 : 	return(NULL);
; 3024 :     }
; 3025 : 
; 3026 :     if (cur == elem) {

	cmp	ebx, edi
	je	$LN3@xmlAddNext

; 3027 : #ifdef DEBUG_TREE
; 3028 :         xmlGenericError(xmlGenericErrorContext,
; 3029 : 		"xmlAddNextSibling : cur == elem\n");
; 3030 : #endif
; 3031 : 	return(NULL);
; 3032 :     }
; 3033 : 
; 3034 :     xmlUnlinkNode(elem);

	push	edi
	call	_xmlUnlinkNode

; 3035 : 
; 3036 :     if (elem->type == XML_TEXT_NODE) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	cmp	eax, 3
	jne	SHORT $LN7@xmlAddNext

; 3037 : 	if (cur->type == XML_TEXT_NODE) {

	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN9@xmlAddNext

; 3038 : 	    xmlNodeAddContent(cur, elem->content);

	push	DWORD PTR [edi+40]
	push	ebx
	call	_xmlNodeAddContent

; 3039 : 	    xmlFreeNode(elem);

	push	edi
	call	_xmlFreeNode
	add	esp, 12					; 0000000cH

; 3040 : 	    return(cur);

	mov	eax, ebx
	pop	edi

; 3069 : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlAddNext:

; 3041 : 	}
; 3042 : 	if ((cur->next != NULL) && (cur->next->type == XML_TEXT_NODE) &&

	mov	ecx, DWORD PTR [ebx+24]
	test	ecx, ecx
	je	SHORT $LN17@xmlAddNext
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN17@xmlAddNext
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN17@xmlAddNext

; 3043 :             (cur->name == cur->next->name)) {
; 3044 : 	    xmlChar *tmp;
; 3045 : 
; 3046 : 	    tmp = xmlStrdup(elem->content);

	push	esi
	push	DWORD PTR [edi+40]
	call	_xmlStrdup

; 3047 : 	    tmp = xmlStrcat(tmp, cur->next->content);

	mov	ecx, DWORD PTR [ebx+24]
	push	DWORD PTR [ecx+40]
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 3048 : 	    xmlNodeSetContent(cur->next, tmp);

	push	esi
	push	DWORD PTR [ebx+24]
	call	_xmlNodeSetContent

; 3049 : 	    xmlFree(tmp);

	push	esi
	call	DWORD PTR _xmlFree

; 3050 : 	    xmlFreeNode(elem);

	push	edi
	call	_xmlFreeNode

; 3051 : 	    return(cur->next);

	mov	eax, DWORD PTR [ebx+24]
	add	esp, 28					; 0000001cH
	pop	esi
	pop	edi

; 3069 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlAddNext:

; 3052 : 	}
; 3053 :     } else if (elem->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN17@xmlAddNext

; 3054 : 		return xmlAddPropSibling(cur, cur, elem);

	push	edi
	push	ebx
	push	ebx
	call	_xmlAddPropSibling
	add	esp, 12					; 0000000cH
	pop	edi

; 3069 : }

	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlAddNext:

; 3055 :     }
; 3056 : 
; 3057 :     if (elem->doc != cur->doc) {

	mov	eax, DWORD PTR [ebx+32]
	cmp	DWORD PTR [edi+32], eax
	je	SHORT $LN12@xmlAddNext

; 3058 : 	xmlSetTreeDoc(elem, cur->doc);

	push	eax
	push	edi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN12@xmlAddNext:

; 3059 :     }
; 3060 :     elem->parent = cur->parent;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+20], eax

; 3061 :     elem->prev = cur;

	mov	DWORD PTR [edi+28], ebx

; 3062 :     elem->next = cur->next;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [edi+24], eax

; 3063 :     cur->next = elem;

	mov	DWORD PTR [ebx+24], edi

; 3064 :     if (elem->next != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN13@xmlAddNext

; 3065 : 	elem->next->prev = elem;

	mov	DWORD PTR [eax+28], edi
$LN13@xmlAddNext:

; 3066 :     if ((elem->parent != NULL) && (elem->parent->last == cur))

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN14@xmlAddNext
	cmp	DWORD PTR [eax+16], ebx
	jne	SHORT $LN14@xmlAddNext

; 3067 : 	elem->parent->last = elem;

	mov	DWORD PTR [eax+16], edi
$LN14@xmlAddNext:

; 3068 :     return(elem);

	mov	eax, edi
	pop	edi

; 3069 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlAddNext:
	pop	edi

; 3012 : #ifdef DEBUG_TREE
; 3013 :         xmlGenericError(xmlGenericErrorContext,
; 3014 : 		"xmlAddNextSibling : cur == NULL\n");
; 3015 : #endif
; 3016 : 	return(NULL);

	xor	eax, eax

; 3069 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlAddNextSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddSibling
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlAddSibling PROC					; COMDAT

; 3164 : xmlAddSibling(xmlNodePtr cur, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN5@xmlAddSibl

; 3165 :     xmlNodePtr parent;
; 3166 : 
; 3167 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 18					; 00000012H
	je	$LN5@xmlAddSibl

; 3173 :     }
; 3174 : 
; 3175 :     if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN5@xmlAddSibl
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN5@xmlAddSibl

; 3176 : #ifdef DEBUG_TREE
; 3177 :         xmlGenericError(xmlGenericErrorContext,
; 3178 : 		"xmlAddSibling : elem == NULL\n");
; 3179 : #endif
; 3180 : 	return(NULL);
; 3181 :     }
; 3182 : 
; 3183 :     if (cur == elem) {

	cmp	esi, edi
	je	$LN5@xmlAddSibl

; 3184 : #ifdef DEBUG_TREE
; 3185 :         xmlGenericError(xmlGenericErrorContext,
; 3186 : 		"xmlAddSibling : cur == elem\n");
; 3187 : #endif
; 3188 : 	return(NULL);
; 3189 :     }
; 3190 : 
; 3191 :     /*
; 3192 :      * Constant time is we can rely on the ->parent->last to find
; 3193 :      * the last sibling.
; 3194 :      */
; 3195 :     if ((cur->type != XML_ATTRIBUTE_NODE) && (cur->parent != NULL) &&
; 3196 : 	(cur->parent->children != NULL) &&
; 3197 : 	(cur->parent->last != NULL) &&

	cmp	eax, 2
	je	SHORT $LN17@xmlAddSibl
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN17@xmlAddSibl
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN17@xmlAddSibl
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN17@xmlAddSibl
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN17@xmlAddSibl

; 3198 : 	(cur->parent->last->next == NULL)) {
; 3199 : 	cur = cur->parent->last;

	mov	esi, eax

; 3200 :     } else {

	jmp	SHORT $LN3@xmlAddSibl
$LN17@xmlAddSibl:

; 3201 : 	while (cur->next != NULL) cur = cur->next;

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlAddSibl
	npad	3
$LL2@xmlAddSibl:
	mov	esi, eax
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LL2@xmlAddSibl
$LN3@xmlAddSibl:

; 3202 :     }
; 3203 : 
; 3204 :     xmlUnlinkNode(elem);

	push	edi
	call	_xmlUnlinkNode
	add	esp, 4

; 3205 : 
; 3206 :     if ((cur->type == XML_TEXT_NODE) && (elem->type == XML_TEXT_NODE) &&

	cmp	DWORD PTR [esi+4], 3
	jne	SHORT $LN11@xmlAddSibl
	cmp	DWORD PTR [edi+4], 3
	jne	SHORT $LN11@xmlAddSibl
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN11@xmlAddSibl

; 3207 :         (cur->name == elem->name)) {
; 3208 : 	xmlNodeAddContent(cur, elem->content);

	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlNodeAddContent

; 3209 : 	xmlFreeNode(elem);

	push	edi
	call	_xmlFreeNode
	add	esp, 12					; 0000000cH

; 3210 : 	return(cur);

	mov	eax, esi
	pop	edi

; 3227 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@xmlAddSibl:

; 3211 :     } else if (elem->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [edi+4], 2
	jne	SHORT $LN13@xmlAddSibl

; 3212 : 		return xmlAddPropSibling(cur, cur, elem);

	push	edi
	push	esi
	push	esi
	call	_xmlAddPropSibling
	add	esp, 12					; 0000000cH
	pop	edi

; 3227 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlAddSibl:

; 3213 :     }
; 3214 : 
; 3215 :     if (elem->doc != cur->doc) {

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [edi+32], eax
	je	SHORT $LN14@xmlAddSibl

; 3216 : 	xmlSetTreeDoc(elem, cur->doc);

	push	eax
	push	edi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN14@xmlAddSibl:

; 3217 :     }
; 3218 :     parent = cur->parent;

	mov	eax, DWORD PTR [esi+20]

; 3219 :     elem->prev = cur;

	mov	DWORD PTR [edi+28], esi

; 3220 :     elem->next = NULL;

	mov	DWORD PTR [edi+24], 0

; 3221 :     elem->parent = parent;

	mov	DWORD PTR [edi+20], eax

; 3222 :     cur->next = elem;

	mov	DWORD PTR [esi+24], edi

; 3223 :     if (parent != NULL)

	test	eax, eax
	je	SHORT $LN15@xmlAddSibl

; 3224 : 	parent->last = elem;

	mov	DWORD PTR [eax+16], edi
$LN15@xmlAddSibl:

; 3225 : 
; 3226 :     return(elem);

	mov	eax, edi
	pop	edi

; 3227 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlAddSibl:
	pop	edi

; 3168 : #ifdef DEBUG_TREE
; 3169 :         xmlGenericError(xmlGenericErrorContext,
; 3170 : 		"xmlAddSibling : cur == NULL\n");
; 3171 : #endif
; 3172 : 	return(NULL);

	xor	eax, eax

; 3227 : }

	pop	esi
	pop	ebp
	ret	0
_xmlAddSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddPrevSibling
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlAddPrevSibling PROC					; COMDAT

; 3088 : xmlAddPrevSibling(xmlNodePtr cur, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN3@xmlAddPrev

; 3089 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN3@xmlAddPrev

; 3095 :     }
; 3096 :     if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {

	mov	edi, DWORD PTR _elem$[ebp]
	test	edi, edi
	je	$LN3@xmlAddPrev
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN3@xmlAddPrev

; 3097 : #ifdef DEBUG_TREE
; 3098 :         xmlGenericError(xmlGenericErrorContext,
; 3099 : 		"xmlAddPrevSibling : elem == NULL\n");
; 3100 : #endif
; 3101 : 	return(NULL);
; 3102 :     }
; 3103 : 
; 3104 :     if (cur == elem) {

	cmp	ebx, edi
	je	$LN3@xmlAddPrev

; 3105 : #ifdef DEBUG_TREE
; 3106 :         xmlGenericError(xmlGenericErrorContext,
; 3107 : 		"xmlAddPrevSibling : cur == elem\n");
; 3108 : #endif
; 3109 : 	return(NULL);
; 3110 :     }
; 3111 : 
; 3112 :     xmlUnlinkNode(elem);

	push	edi
	call	_xmlUnlinkNode

; 3113 : 
; 3114 :     if (elem->type == XML_TEXT_NODE) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	cmp	eax, 3
	jne	SHORT $LN7@xmlAddPrev

; 3115 : 	if (cur->type == XML_TEXT_NODE) {

	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN9@xmlAddPrev

; 3116 : 	    xmlChar *tmp;
; 3117 : 
; 3118 : 	    tmp = xmlStrdup(elem->content);

	push	esi
	push	DWORD PTR [edi+40]
	call	_xmlStrdup

; 3119 : 	    tmp = xmlStrcat(tmp, cur->content);

	push	DWORD PTR [ebx+40]
	push	eax
	call	_xmlStrcat
	mov	esi, eax

; 3120 : 	    xmlNodeSetContent(cur, tmp);

	push	esi
	push	ebx
	call	_xmlNodeSetContent

; 3121 : 	    xmlFree(tmp);

	push	esi
	call	DWORD PTR _xmlFree

; 3122 : 	    xmlFreeNode(elem);

	push	edi
	call	_xmlFreeNode
	add	esp, 28					; 0000001cH

; 3123 : 	    return(cur);

	mov	eax, ebx
	pop	esi
	pop	edi

; 3148 : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlAddPrev:

; 3124 : 	}
; 3125 : 	if ((cur->prev != NULL) && (cur->prev->type == XML_TEXT_NODE) &&

	mov	ecx, DWORD PTR [ebx+28]
	test	ecx, ecx
	je	SHORT $LN17@xmlAddPrev
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN17@xmlAddPrev
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN17@xmlAddPrev

; 3126 :             (cur->name == cur->prev->name)) {
; 3127 : 	    xmlNodeAddContent(cur->prev, elem->content);

	push	DWORD PTR [edi+40]
	push	ecx
	call	_xmlNodeAddContent

; 3128 : 	    xmlFreeNode(elem);

	push	edi
	call	_xmlFreeNode

; 3129 : 	    return(cur->prev);

	mov	eax, DWORD PTR [ebx+28]
	add	esp, 12					; 0000000cH
	pop	edi

; 3148 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlAddPrev:

; 3130 : 	}
; 3131 :     } else if (elem->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN17@xmlAddPrev

; 3132 : 		return xmlAddPropSibling(cur->prev, cur, elem);

	push	edi
	push	ebx
	push	DWORD PTR [ebx+28]
	call	_xmlAddPropSibling
	add	esp, 12					; 0000000cH
	pop	edi

; 3148 : }

	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlAddPrev:

; 3133 :     }
; 3134 : 
; 3135 :     if (elem->doc != cur->doc) {

	mov	eax, DWORD PTR [ebx+32]
	cmp	DWORD PTR [edi+32], eax
	je	SHORT $LN12@xmlAddPrev

; 3136 : 	xmlSetTreeDoc(elem, cur->doc);

	push	eax
	push	edi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN12@xmlAddPrev:

; 3137 :     }
; 3138 :     elem->parent = cur->parent;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [edi+20], eax

; 3139 :     elem->next = cur;

	mov	DWORD PTR [edi+24], ebx

; 3140 :     elem->prev = cur->prev;

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [edi+28], eax

; 3141 :     cur->prev = elem;

	mov	DWORD PTR [ebx+28], edi

; 3142 :     if (elem->prev != NULL)

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN13@xmlAddPrev

; 3143 : 	elem->prev->next = elem;

	mov	DWORD PTR [eax+24], edi
$LN13@xmlAddPrev:

; 3144 :     if ((elem->parent != NULL) && (elem->parent->children == cur)) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN14@xmlAddPrev
	cmp	DWORD PTR [eax+12], ebx
	jne	SHORT $LN14@xmlAddPrev

; 3145 : 		elem->parent->children = elem;

	mov	DWORD PTR [eax+12], edi
$LN14@xmlAddPrev:

; 3146 :     }
; 3147 :     return(elem);

	mov	eax, edi
	pop	edi

; 3148 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlAddPrev:
	pop	edi

; 3090 : #ifdef DEBUG_TREE
; 3091 :         xmlGenericError(xmlGenericErrorContext,
; 3092 : 		"xmlAddPrevSibling : cur == NULL\n");
; 3093 : #endif
; 3094 : 	return(NULL);

	xor	eax, eax

; 3148 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlAddPrevSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlReplaceNode
_TEXT	SEGMENT
_old$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlReplaceNode PROC					; COMDAT

; 3886 : xmlReplaceNode(xmlNodePtr old, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _old$[ebp]
	mov	edi, DWORD PTR _cur$[ebp]
	cmp	esi, edi
	je	$LN4@xmlReplace

; 3887 :     if (old == cur) return(NULL);
; 3888 :     if ((old == NULL) || (old->type == XML_NAMESPACE_DECL) ||

	test	esi, esi
	je	$LN4@xmlReplace
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 18					; 00000012H
	je	$LN4@xmlReplace
	cmp	DWORD PTR [esi+20], 0
	je	$LN4@xmlReplace

; 3895 :     }
; 3896 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	test	edi, edi
	je	$LN6@xmlReplace
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	je	$LN6@xmlReplace

; 3898 : 	return(old);
; 3899 :     }
; 3900 :     if (cur == old) {
; 3901 : 	return(old);
; 3902 :     }
; 3903 :     if ((old->type==XML_ATTRIBUTE_NODE) && (cur->type!=XML_ATTRIBUTE_NODE)) {

	cmp	ecx, 2
	jne	SHORT $LN8@xmlReplace
	cmp	eax, ecx
	je	SHORT $LN9@xmlReplace

; 3940 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlReplace:

; 3904 : #ifdef DEBUG_TREE
; 3905 :         xmlGenericError(xmlGenericErrorContext,
; 3906 : 		"xmlReplaceNode : Trying to replace attribute node with other node type\n");
; 3907 : #endif
; 3908 : 	return(old);
; 3909 :     }
; 3910 :     if ((cur->type==XML_ATTRIBUTE_NODE) && (old->type!=XML_ATTRIBUTE_NODE)) {

	cmp	eax, 2
	je	$LN20@xmlReplace
$LN9@xmlReplace:

; 3911 : #ifdef DEBUG_TREE
; 3912 :         xmlGenericError(xmlGenericErrorContext,
; 3913 : 		"xmlReplaceNode : Trying to replace a non-attribute node with attribute node\n");
; 3914 : #endif
; 3915 : 	return(old);
; 3916 :     }
; 3917 :     xmlUnlinkNode(cur);

	push	edi
	call	_xmlUnlinkNode

; 3918 :     xmlSetTreeDoc(cur, old->doc);

	push	DWORD PTR [esi+32]
	push	edi
	call	_xmlSetTreeDoc

; 3919 :     cur->parent = old->parent;

	mov	eax, DWORD PTR [esi+20]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+20], eax

; 3920 :     cur->next = old->next;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax

; 3921 :     if (cur->next != NULL)

	test	eax, eax
	je	SHORT $LN10@xmlReplace

; 3922 : 	cur->next->prev = cur;

	mov	DWORD PTR [eax+28], edi
$LN10@xmlReplace:

; 3923 :     cur->prev = old->prev;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+28], eax

; 3924 :     if (cur->prev != NULL)

	test	eax, eax
	je	SHORT $LN11@xmlReplace

; 3925 : 	cur->prev->next = cur;

	mov	DWORD PTR [eax+24], edi
$LN11@xmlReplace:

; 3926 :     if (cur->parent != NULL) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN17@xmlReplace

; 3927 : 	if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [edi+4], 2
	jne	SHORT $LN13@xmlReplace

; 3928 : 	    if (cur->parent->properties == (xmlAttrPtr)old)

	cmp	DWORD PTR [eax+44], esi
	jne	SHORT $LN17@xmlReplace

; 3929 : 		cur->parent->properties = ((xmlAttrPtr) cur);

	mov	DWORD PTR [eax+44], edi

; 3930 : 	} else {

	jmp	SHORT $LN17@xmlReplace
$LN13@xmlReplace:

; 3931 : 	    if (cur->parent->children == old)

	cmp	DWORD PTR [eax+12], esi
	jne	SHORT $LN16@xmlReplace

; 3932 : 		cur->parent->children = cur;

	mov	DWORD PTR [eax+12], edi
	mov	eax, DWORD PTR [edi+20]
$LN16@xmlReplace:

; 3933 : 	    if (cur->parent->last == old)

	cmp	DWORD PTR [eax+16], esi
	jne	SHORT $LN17@xmlReplace

; 3934 : 		cur->parent->last = cur;

	mov	DWORD PTR [eax+16], edi
$LN17@xmlReplace:
	pop	edi

; 3935 : 	}
; 3936 :     }
; 3937 :     old->next = old->prev = NULL;

	mov	DWORD PTR [esi+28], 0

; 3938 :     old->parent = NULL;
; 3939 :     return(old);

	mov	eax, esi
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+20], 0

; 3940 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlReplace:

; 3897 : 	xmlUnlinkNode(old);

	push	esi
	call	_xmlUnlinkNode
	add	esp, 4
$LN20@xmlReplace:

; 3940 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlReplace:
	pop	edi

; 3889 :         (old->parent == NULL)) {
; 3890 : #ifdef DEBUG_TREE
; 3891 :         xmlGenericError(xmlGenericErrorContext,
; 3892 : 		"xmlReplaceNode : old == NULL or without parent\n");
; 3893 : #endif
; 3894 : 	return(NULL);

	xor	eax, eax

; 3940 : }

	pop	esi
	pop	ebp
	ret	0
_xmlReplaceNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddChildList
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAddChildList PROC					; COMDAT

; 3240 : xmlAddChildList(xmlNodePtr parent, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _parent$[ebp]
	test	edi, edi
	je	$LN5@xmlAddChil

; 3241 :     xmlNodePtr prev;
; 3242 : 
; 3243 :     if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN5@xmlAddChil

; 3249 :     }
; 3250 : 
; 3251 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN5@xmlAddChil
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 18					; 00000012H
	je	$LN5@xmlAddChil

; 3252 : #ifdef DEBUG_TREE
; 3253 :         xmlGenericError(xmlGenericErrorContext,
; 3254 : 		"xmlAddChildList : child == NULL\n");
; 3255 : #endif
; 3256 : 	return(NULL);
; 3257 :     }
; 3258 : 
; 3259 :     if ((cur->doc != NULL) && (parent->doc != NULL) &&
; 3260 :         (cur->doc != parent->doc)) {
; 3261 : #ifdef DEBUG_TREE
; 3262 : 	xmlGenericError(xmlGenericErrorContext,
; 3263 : 		"Elements moved to a different document\n");
; 3264 : #endif
; 3265 :     }
; 3266 : 
; 3267 :     /*
; 3268 :      * add the first element at the end of the children list.
; 3269 :      */
; 3270 : 
; 3271 :     if (parent->children == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN9@xmlAddChil

; 3272 :         parent->children = cur;

	mov	DWORD PTR [edi+12], esi

; 3273 :     } else {

	jmp	SHORT $LN16@xmlAddChil
$LN9@xmlAddChil:

; 3274 : 	/*
; 3275 : 	 * If cur and parent->last both are TEXT nodes, then merge them.
; 3276 : 	 */
; 3277 : 	if ((cur->type == XML_TEXT_NODE) &&
; 3278 : 	    (parent->last->type == XML_TEXT_NODE) &&

	cmp	eax, 3
	jne	SHORT $LN11@xmlAddChil
	mov	ecx, DWORD PTR [edi+16]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN11@xmlAddChil
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@xmlAddChil

; 3279 : 	    (cur->name == parent->last->name)) {
; 3280 : 	    xmlNodeAddContent(parent->last, cur->content);

	push	DWORD PTR [esi+40]
	push	ecx
	call	_xmlNodeAddContent

; 3281 : 	    /*
; 3282 : 	     * if it's the only child, nothing more to be done.
; 3283 : 	     */
; 3284 : 	    if (cur->next == NULL) {

	mov	ecx, DWORD PTR [esi+24]
	add	esp, 8
	push	esi
	test	ecx, ecx
	jne	SHORT $LN12@xmlAddChil

; 3285 : 		xmlFreeNode(cur);

	call	_xmlFreeNode

; 3286 : 		return(parent->last);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 4
	pop	edi

; 3311 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlAddChil:

; 3287 : 	    }
; 3288 : 	    prev = cur;
; 3289 : 	    cur = cur->next;

	mov	esi, ecx

; 3290 : 	    xmlFreeNode(prev);

	call	_xmlFreeNode
	add	esp, 4
$LN11@xmlAddChil:

; 3291 : 	}
; 3292 :         prev = parent->last;

	mov	eax, DWORD PTR [edi+16]

; 3293 : 	prev->next = cur;

	mov	DWORD PTR [eax+24], esi

; 3294 : 	cur->prev = prev;

	mov	DWORD PTR [esi+28], eax
$LN16@xmlAddChil:

; 3295 :     }
; 3296 :     while (cur->next != NULL) {

	cmp	DWORD PTR [esi+24], 0
	push	ebx
	lea	ebx, DWORD PTR [esi+24]
	je	SHORT $LN3@xmlAddChil
	npad	5
$LL2@xmlAddChil:

; 3297 : 	cur->parent = parent;

	mov	DWORD PTR [esi+20], edi

; 3298 : 	if (cur->doc != parent->doc) {

	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [esi+32], eax
	je	SHORT $LN13@xmlAddChil

; 3299 : 	    xmlSetTreeDoc(cur, parent->doc);

	push	eax
	push	esi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN13@xmlAddChil:

; 3300 : 	}
; 3301 :         cur = cur->next;

	mov	esi, DWORD PTR [ebx]
	cmp	DWORD PTR [esi+24], 0
	lea	ebx, DWORD PTR [esi+24]
	jne	SHORT $LL2@xmlAddChil
$LN3@xmlAddChil:

; 3302 :     }
; 3303 :     cur->parent = parent;

	mov	DWORD PTR [esi+20], edi

; 3304 :     /* the parent may not be linked to a doc ! */
; 3305 :     if (cur->doc != parent->doc) {

	mov	eax, DWORD PTR [edi+32]
	pop	ebx
	cmp	DWORD PTR [esi+32], eax
	je	SHORT $LN14@xmlAddChil

; 3306 :         xmlSetTreeDoc(cur, parent->doc);

	push	eax
	push	esi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN14@xmlAddChil:

; 3307 :     }
; 3308 :     parent->last = cur;

	mov	DWORD PTR [edi+16], esi

; 3309 : 
; 3310 :     return(cur);

	mov	eax, esi
	pop	edi

; 3311 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlAddChil:
	pop	edi

; 3244 : #ifdef DEBUG_TREE
; 3245 :         xmlGenericError(xmlGenericErrorContext,
; 3246 : 		"xmlAddChildList : parent == NULL\n");
; 3247 : #endif
; 3248 : 	return(NULL);

	xor	eax, eax

; 3311 : }

	pop	esi
	pop	ebp
	ret	0
_xmlAddChildList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlAddChild
_TEXT	SEGMENT
_content$1$ = 8						; size = 4
_parent$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAddChild PROC					; COMDAT

; 3326 : xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _parent$[ebp]
	test	edi, edi
	je	$LN5@xmlAddChil

; 3327 :     xmlNodePtr prev;
; 3328 : 
; 3329 :     if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	je	$LN5@xmlAddChil

; 3330 : #ifdef DEBUG_TREE
; 3331 :         xmlGenericError(xmlGenericErrorContext,
; 3332 : 		"xmlAddChild : parent == NULL\n");
; 3333 : #endif
; 3334 : 	return(NULL);
; 3335 :     }
; 3336 : 
; 3337 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN5@xmlAddChil
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 18					; 00000012H
	je	$LN5@xmlAddChil

; 3338 : #ifdef DEBUG_TREE
; 3339 :         xmlGenericError(xmlGenericErrorContext,
; 3340 : 		"xmlAddChild : child == NULL\n");
; 3341 : #endif
; 3342 : 	return(NULL);
; 3343 :     }
; 3344 : 
; 3345 :     if (parent == cur) {

	cmp	edi, esi
	je	$LN5@xmlAddChil

; 3346 : #ifdef DEBUG_TREE
; 3347 :         xmlGenericError(xmlGenericErrorContext,
; 3348 : 		"xmlAddChild : parent == cur\n");
; 3349 : #endif
; 3350 : 	return(NULL);
; 3351 :     }
; 3352 :     /*
; 3353 :      * If cur is a TEXT node, merge its content with adjacent TEXT nodes
; 3354 :      * cur is then freed.
; 3355 :      */
; 3356 :     if (cur->type == XML_TEXT_NODE) {

	cmp	ecx, 3
	jne	SHORT $LN11@xmlAddChil

; 3357 : 	if ((parent->type == XML_TEXT_NODE) &&
; 3358 : 	    (parent->content != NULL) &&

	cmp	eax, ecx
	jne	SHORT $LN10@xmlAddChil
	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN10@xmlAddChil
	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN48@xmlAddChil
$LN10@xmlAddChil:

; 3359 : 	    (parent->name == cur->name)) {
; 3360 : 	    xmlNodeAddContent(parent, cur->content);
; 3361 : 	    xmlFreeNode(cur);
; 3362 : 	    return(parent);
; 3363 : 	}
; 3364 : 	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
; 3365 : 	    (parent->last->name == cur->name) &&

	mov	ebx, DWORD PTR [edi+16]
	test	ebx, ebx
	je	SHORT $LN11@xmlAddChil
	cmp	DWORD PTR [ebx+4], 3
	jne	SHORT $LN11@xmlAddChil
	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN11@xmlAddChil
	cmp	ebx, esi
	je	SHORT $LN11@xmlAddChil

; 3366 : 	    (parent->last != cur)) {
; 3367 : 	    xmlNodeAddContent(parent->last, cur->content);

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _content$1$[ebp], eax

; 5866 :     if (content == NULL) return;

	test	eax, eax
	je	SHORT $LN32@xmlAddChil

; 5867 :     len = xmlStrlen(content);

	push	eax
	call	_xmlStrlen

; 5868 :     xmlNodeAddContentLen(cur, content, len);

	push	eax
	push	DWORD PTR _content$1$[ebp]
	push	ebx
	call	_xmlNodeAddContentLen
	add	esp, 16					; 00000010H
$LN32@xmlAddChil:

; 3368 : 	    xmlFreeNode(cur);

	push	esi
	call	_xmlFreeNode

; 3369 : 	    return(parent->last);

	mov	eax, DWORD PTR [edi+16]
	add	esp, 4
	pop	edi

; 3440 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlAddChil:

; 3370 : 	}
; 3371 :     }
; 3372 : 
; 3373 :     /*
; 3374 :      * add the new element at the end of the children list.
; 3375 :      */
; 3376 :     prev = cur->parent;

	mov	ebx, DWORD PTR [esi+20]

; 3377 :     cur->parent = parent;

	mov	DWORD PTR [esi+20], edi

; 3378 :     if (cur->doc != parent->doc) {

	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [esi+32], eax
	je	SHORT $LN12@xmlAddChil

; 3379 : 	xmlSetTreeDoc(cur, parent->doc);

	push	eax
	push	esi
	call	_xmlSetTreeDoc
	add	esp, 8
$LN12@xmlAddChil:

; 3380 :     }
; 3381 :     /* this check prevents a loop on tree-traversions if a developer
; 3382 :      * tries to add a node to its parent multiple times
; 3383 :      */
; 3384 :     if (prev == parent)

	cmp	ebx, edi
	je	$LN26@xmlAddChil

; 3385 : 	return(cur);
; 3386 : 
; 3387 :     /*
; 3388 :      * Coalescing
; 3389 :      */
; 3390 :     if ((parent->type == XML_TEXT_NODE) &&
; 3391 : 	(parent->content != NULL) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 3
	jne	SHORT $LN14@xmlAddChil
	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN14@xmlAddChil
$LN48@xmlAddChil:

; 3392 : 	(parent != cur)) {
; 3393 : 	xmlNodeAddContent(parent, cur->content);
; 3394 : 	xmlFreeNode(cur);

	mov	ebx, DWORD PTR [esi+40]
	test	ebx, ebx
	je	SHORT $LN36@xmlAddChil
	push	ebx
	call	_xmlStrlen
	push	eax
	push	ebx
	push	edi
	call	_xmlNodeAddContentLen
	add	esp, 16					; 00000010H
$LN36@xmlAddChil:
	push	esi
	call	_xmlFreeNode
	add	esp, 4

; 3395 : 	return(parent);

	mov	eax, edi
	pop	edi

; 3440 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlAddChil:

; 3396 :     }
; 3397 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [esi+4], 2
	jne	SHORT $LN15@xmlAddChil

; 3398 : 		if (parent->type != XML_ELEMENT_NODE)

	cmp	eax, 1
	jne	$LN5@xmlAddChil

; 3399 : 			return(NULL);
; 3400 : 	if (parent->properties != NULL) {

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN46@xmlAddChil

; 3401 : 	    /* check if an attribute with the same name exists */
; 3402 : 	    xmlAttrPtr lastattr;
; 3403 : 
; 3404 : 	    if (cur->ns == NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN20@xmlAddChil
$LN19@xmlAddChil:

; 3405 : 		lastattr = xmlHasNsProp(parent, cur->name, NULL);
; 3406 : 	    else
; 3407 : 		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);

	mov	eax, DWORD PTR [eax+8]
$LN20@xmlAddChil:

; 3408 : 	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {

	push	eax
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	edi
	call	_xmlHasNsProp
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	SHORT $LN21@xmlAddChil
	cmp	ebx, esi
	je	SHORT $LN26@xmlAddChil
	cmp	DWORD PTR [ebx+4], 16			; 00000010H
	je	SHORT $LN21@xmlAddChil

; 3409 : 		/* different instance, destroy it (attributes must be unique) */
; 3410 : 			xmlUnlinkNode((xmlNodePtr) lastattr);

	push	ebx
	call	_xmlUnlinkNode

; 3411 : 		xmlFreeProp(lastattr);

	push	ebx
	call	_xmlFreeProp
	add	esp, 8
$LN21@xmlAddChil:

; 3412 : 	    }
; 3413 : 		if (lastattr == (xmlAttrPtr) cur)

	cmp	ebx, esi
	je	SHORT $LN26@xmlAddChil
$LN46@xmlAddChil:

; 3414 : 			return(cur);
; 3415 : 
; 3416 : 	}
; 3417 : 	if (parent->properties == NULL) {

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	jne	SHORT $LN23@xmlAddChil

; 3418 : 	    parent->properties = (xmlAttrPtr) cur;

	mov	DWORD PTR [edi+44], esi

; 3440 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlAddChil:

; 3419 : 	} else {
; 3420 : 	    /* find the end */
; 3421 : 	    xmlAttrPtr lastattr = parent->properties;
; 3422 : 	    while (lastattr->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN3@xmlAddChil
$LL2@xmlAddChil:

; 3423 : 		lastattr = lastattr->next;

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LL2@xmlAddChil
$LN3@xmlAddChil:

; 3424 : 	    }
; 3425 : 	    lastattr->next = (xmlAttrPtr) cur;

	mov	DWORD PTR [eax+24], esi

; 3426 : 	    ((xmlAttrPtr) cur)->prev = lastattr;

	mov	DWORD PTR [esi+28], eax

; 3440 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlAddChil:

; 3427 : 	}
; 3428 :     } else {
; 3429 : 	if (parent->children == NULL) {

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN25@xmlAddChil

; 3430 : 	    parent->children = cur;

	mov	DWORD PTR [edi+12], esi

; 3440 : }

	mov	eax, esi
	mov	DWORD PTR [edi+16], esi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN25@xmlAddChil:

; 3431 : 	    parent->last = cur;
; 3432 : 	} else {
; 3433 : 	    prev = parent->last;

	mov	ecx, DWORD PTR [edi+16]

; 3434 : 	    prev->next = cur;

	mov	DWORD PTR [ecx+24], esi

; 3435 : 	    cur->prev = prev;

	mov	DWORD PTR [esi+28], ecx

; 3436 : 	    parent->last = cur;
; 3437 : 	}
; 3438 :     }
; 3439 :     return(cur);

	mov	DWORD PTR [edi+16], esi
$LN26@xmlAddChil:

; 3440 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlAddChil:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlAddChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeSetName
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlNodeSetName PROC					; COMDAT

; 5133 : xmlNodeSetName(xmlNodePtr cur, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN14@xmlNodeSet

; 5134 :     xmlDocPtr doc;
; 5135 :     xmlDictPtr dict;
; 5136 :     const xmlChar *freeme = NULL;
; 5137 : 
; 5138 :     if (cur == NULL) return;
; 5139 :     if (name == NULL) return;

	cmp	DWORD PTR _name$[ebp], edi
	je	SHORT $LN14@xmlNodeSet

; 5140 :     switch(cur->type) {

	mov	eax, DWORD PTR [esi+4]
	add	eax, -3					; fffffffdH
	cmp	eax, 18					; 00000012H
	ja	SHORT $LN7@xmlNodeSet
	movzx	eax, BYTE PTR $LN16@xmlNodeSet[eax]
	jmp	DWORD PTR $LN18@xmlNodeSet[eax*4]
$LN7@xmlNodeSet:
	push	ebx

; 5141 :         case XML_TEXT_NODE:
; 5142 :         case XML_CDATA_SECTION_NODE:
; 5143 :         case XML_COMMENT_NODE:
; 5144 :         case XML_DOCUMENT_TYPE_NODE:
; 5145 :         case XML_DOCUMENT_FRAG_NODE:
; 5146 :         case XML_NOTATION_NODE:
; 5147 :         case XML_HTML_DOCUMENT_NODE:
; 5148 : 	case XML_NAMESPACE_DECL:
; 5149 : 	case XML_XINCLUDE_START:
; 5150 : 	case XML_XINCLUDE_END:
; 5151 : #ifdef LIBXML_DOCB_ENABLED
; 5152 : 	case XML_DOCB_DOCUMENT_NODE:
; 5153 : #endif
; 5154 : 	    return;
; 5155 :         case XML_ELEMENT_NODE:
; 5156 :         case XML_ATTRIBUTE_NODE:
; 5157 :         case XML_PI_NODE:
; 5158 :         case XML_ENTITY_REF_NODE:
; 5159 :         case XML_ENTITY_NODE:
; 5160 :         case XML_DTD_NODE:
; 5161 :         case XML_DOCUMENT_NODE:
; 5162 :         case XML_ELEMENT_DECL:
; 5163 :         case XML_ATTRIBUTE_DECL:
; 5164 :         case XML_ENTITY_DECL:
; 5165 : 	    break;
; 5166 :     }
; 5167 :     doc = cur->doc;

	mov	ebx, DWORD PTR [esi+32]

; 5168 :     if (doc != NULL)

	test	ebx, ebx
	je	SHORT $LN8@xmlNodeSet

; 5169 : 	dict = doc->dict;

	mov	ebx, DWORD PTR [ebx+80]
	jmp	SHORT $LN9@xmlNodeSet
$LN8@xmlNodeSet:

; 5170 :     else
; 5171 :         dict = NULL;

	xor	ebx, ebx
$LN9@xmlNodeSet:

; 5172 :     if (dict != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	ebx, ebx
	je	SHORT $LN10@xmlNodeSet

; 5173 :         if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))

	test	eax, eax
	je	SHORT $LN12@xmlNodeSet
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlNodeSet

; 5174 : 	    freeme = cur->name;

	mov	edi, DWORD PTR [esi+8]
$LN12@xmlNodeSet:

; 5175 : 	cur->name = xmlDictLookup(dict, name, -1);

	mov	eax, DWORD PTR _name$[ebp]
	push	-1
	push	eax
	push	ebx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 5176 :     } else {

	jmp	SHORT $LN11@xmlNodeSet
$LN10@xmlNodeSet:

; 5177 : 	if (cur->name != NULL)

	test	eax, eax
	cmovne	edi, eax

; 5178 : 	    freeme = cur->name;
; 5179 : 	cur->name = xmlStrdup(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN11@xmlNodeSet:

; 5180 :     }
; 5181 : 
; 5182 :     if (freeme)

	mov	DWORD PTR [esi+8], eax
	pop	ebx
	test	edi, edi
	je	SHORT $LN14@xmlNodeSet

; 5183 :         xmlFree((xmlChar *) freeme);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlNodeSet:

; 5184 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
	npad	3
$LN18@xmlNodeSet:
	DD	$LN14@xmlNodeSet
	DD	$LN7@xmlNodeSet
$LN16@xmlNodeSet:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
_xmlNodeSetName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDocSetRootElement
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_root$ = 12						; size = 4
_xmlDocSetRootElement PROC				; COMDAT

; 4932 : xmlDocSetRootElement(xmlDocPtr doc, xmlNodePtr root) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _doc$[ebp]
	test	ebx, ebx
	je	SHORT $LN6@xmlDocSetR

; 4933 :     xmlNodePtr old = NULL;
; 4934 : 
; 4935 :     if (doc == NULL) return(NULL);
; 4936 :     if ((root == NULL) || (root->type == XML_NAMESPACE_DECL))

	mov	edi, DWORD PTR _root$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlDocSetR
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN6@xmlDocSetR

; 4938 :     xmlUnlinkNode(root);

	push	esi
	push	edi
	call	_xmlUnlinkNode

; 4939 :     xmlSetTreeDoc(root, doc);

	push	ebx
	push	edi
	call	_xmlSetTreeDoc

; 4940 :     root->parent = (xmlNodePtr) doc;

	mov	DWORD PTR [edi+20], ebx
	add	esp, 12					; 0000000cH

; 4941 :     old = doc->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, eax

; 4942 :     while (old != NULL) {

	test	esi, esi
	je	SHORT $LN18@xmlDocSetR
$LL2@xmlDocSetR:

; 4943 : 	if (old->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN8@xmlDocSetR

; 4944 : 	    break;
; 4945 :         old = old->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlDocSetR
$LN18@xmlDocSetR:

; 4946 :     }
; 4947 :     if (old == NULL) {
; 4948 : 	if (doc->children == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlDocSetR

; 4956 :     }
; 4957 :     return(old);

	mov	eax, esi
	mov	DWORD PTR [ebx+12], edi
	pop	esi
	mov	DWORD PTR [ebx+16], edi
	pop	edi

; 4958 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlDocSetR:

; 4953 : 	}
; 4954 :     } else {
; 4955 : 	xmlReplaceNode(old, root);

	push	edi
	push	esi
	call	_xmlReplaceNode

; 4956 :     }
; 4957 :     return(old);

	add	esp, 8
	mov	eax, esi
	pop	esi
	pop	edi

; 4958 : }

	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlDocSetR:

; 4949 : 	    doc->children = root;
; 4950 : 	    doc->last = root;
; 4951 : 	} else {
; 4952 : 	    xmlAddSibling(doc->children, root);

	push	edi
	push	eax
	call	_xmlAddSibling

; 4956 :     }
; 4957 :     return(old);

	add	esp, 8
	mov	eax, esi
	pop	esi
	pop	edi

; 4958 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlDocSetR:
	pop	edi

; 4937 : 	return(NULL);

	xor	eax, eax

; 4958 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlDocSetRootElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlIsBlankNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlIsBlankNode PROC					; COMDAT

; 6950 : xmlIsBlankNode(const xmlNode *node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@xmlIsBlank

; 6951 :     const xmlChar *cur;
; 6952 :     if (node == NULL) return(0);
; 6953 : 
; 6954 :     if ((node->type != XML_TEXT_NODE) &&

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 3
	je	SHORT $LN5@xmlIsBlank
	cmp	eax, 4
	jne	SHORT $LN11@xmlIsBlank
$LN5@xmlIsBlank:

; 6955 :         (node->type != XML_CDATA_SECTION_NODE))
; 6956 : 	return(0);
; 6957 :     if (node->content == NULL) return(1);

	mov	ecx, DWORD PTR [ecx+40]
	test	ecx, ecx
	je	SHORT $LN3@xmlIsBlank

; 6958 :     cur = node->content;
; 6959 :     while (*cur != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN3@xmlIsBlank
	npad	2
$LL2@xmlIsBlank:

; 6960 : 	if (!IS_BLANK_CH(*cur)) return(0);

	cmp	al, 32					; 00000020H
	je	SHORT $LN7@xmlIsBlank
	cmp	al, 9
	jb	SHORT $LN8@xmlIsBlank
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN7@xmlIsBlank
$LN8@xmlIsBlank:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN11@xmlIsBlank
$LN7@xmlIsBlank:

; 6958 :     cur = node->content;
; 6959 :     while (*cur != 0) {

	mov	al, BYTE PTR [ecx+1]

; 6961 : 	cur++;

	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlIsBlank
$LN3@xmlIsBlank:

; 6962 :     }
; 6963 : 
; 6964 :     return(1);

	mov	eax, 1

; 6965 : }

	pop	ebp
	ret	0
$LN11@xmlIsBlank:

; 6960 : 	if (!IS_BLANK_CH(*cur)) return(0);

	xor	eax, eax

; 6965 : }

	pop	ebp
	ret	0
_xmlIsBlankNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNodeIsText
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlNodeIsText PROC					; COMDAT

; 6933 : xmlNodeIsText(const xmlNode *node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlNodeIsT

; 6934 :     if (node == NULL) return(0);
; 6935 : 
; 6936 :     if (node->type == XML_TEXT_NODE) return(1);

	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN3@xmlNodeIsT
	mov	eax, 1

; 6938 : }

	pop	ebp
	ret	0
$LN3@xmlNodeIsT:

; 6937 :     return(0);

	xor	eax, eax

; 6938 : }

	pop	ebp
	ret	0
_xmlNodeIsText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetLastChild
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_xmlGetLastChild PROC					; COMDAT

; 3450 : xmlGetLastChild(const xmlNode *parent) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _parent$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlGetLast

; 3451 :     if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN3@xmlGetLast

; 3457 :     }
; 3458 :     return(parent->last);

	mov	eax, DWORD PTR [eax+16]

; 3459 : }

	pop	ebp
	ret	0
$LN3@xmlGetLast:

; 3452 : #ifdef DEBUG_TREE
; 3453 :         xmlGenericError(xmlGenericErrorContext,
; 3454 : 		"xmlGetLastChild : parent == NULL\n");
; 3455 : #endif
; 3456 : 	return(NULL);

	xor	eax, eax

; 3459 : }

	pop	ebp
	ret	0
_xmlGetLastChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDocGetRootElement
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlDocGetRootElement PROC				; COMDAT

; 4906 : xmlDocGetRootElement(const xmlDoc *doc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlDocGetR

; 4915 :     }
; 4916 :     return(ret);
; 4917 : }

	pop	ebp
	ret	0
$LN4@xmlDocGetR:

; 4907 :     xmlNodePtr ret;
; 4908 : 
; 4909 :     if (doc == NULL) return(NULL);
; 4910 :     ret = doc->children;

	mov	eax, DWORD PTR [eax+12]

; 4911 :     while (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlDocGetR
	npad	3
$LL2@xmlDocGetR:

; 4912 : 	if (ret->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlDocGetR

; 4913 : 	    return(ret);
; 4914 :         ret = ret->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlDocGetR
$LN1@xmlDocGetR:

; 4915 :     }
; 4916 :     return(ret);
; 4917 : }

	pop	ebp
	ret	0
_xmlDocGetRootElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetNodePath
_TEXT	SEGMENT
_nametemp$ = -124					; size = 100
_generic$1$ = -24					; size = 4
_buf_len$1$ = -20					; size = 4
_buf$1$ = -16						; size = 4
_sep$1$ = -12						; size = 4
_name$1$ = -8						; size = 4
_buffer$1$ = -4						; size = 4
_next$1$ = 8						; size = 4
_node$ = 8						; size = 4
_xmlGetNodePath PROC					; COMDAT

; 4661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __59973643_tree@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$LN22@xmlGetNode

; 4662 :     const xmlNode *cur, *tmp, *next;
; 4663 :     xmlChar *buffer = NULL, *temp;
; 4664 :     size_t buf_len;
; 4665 :     xmlChar *buf;
; 4666 :     const char *sep;
; 4667 :     const char *name;
; 4668 :     char nametemp[100];
; 4669 :     int occur = 0, generic;
; 4670 : 
; 4671 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN22@xmlGetNode

; 4673 : 
; 4674 :     buf_len = 500;

	mov	eax, 500				; 000001f4H
	push	ebx

; 4675 :     buffer = (xmlChar *) xmlMallocAtomic(buf_len * sizeof(xmlChar));

	push	eax
	mov	DWORD PTR _buf_len$1$[ebp], eax
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _buffer$1$[ebp], ebx

; 4676 :     if (buffer == NULL) {

	test	ebx, ebx
	jne	SHORT $LN23@xmlGetNode

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@NABGEGIL@getting?5node?5path@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 4677 : 	xmlTreeErrMemory("getting node path");
; 4678 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 4893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlGetNode:

; 4679 :     }
; 4680 :     buf = (xmlChar *) xmlMallocAtomic(buf_len * sizeof(xmlChar));

	push	500					; 000001f4H
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buf$1$[ebp], eax

; 4681 :     if (buf == NULL) {

	test	eax, eax
	jne	SHORT $LN24@xmlGetNode

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@NABGEGIL@getting?5node?5path@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 4682 : 	xmlTreeErrMemory("getting node path");
; 4683 :         xmlFree(buffer);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 4684 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 4893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlGetNode:

; 4685 :     }
; 4686 : 
; 4687 :     buffer[0] = 0;

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [ecx], 0
	npad	6
$LL4@xmlGetNode:

; 4688 :     cur = node;
; 4689 :     do {
; 4690 :         name = "";
; 4691 :         sep = "?";
; 4692 :         occur = 0;
; 4693 :         if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	xor	ebx, ebx
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01OGPIMHDM@?$DP@
	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	eax, 9
	je	$LN27@xmlGetNode
	cmp	eax, 13					; 0000000dH
	je	$LN27@xmlGetNode

; 4699 :         } else if (cur->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	$LN29@xmlGetNode

; 4700 : 	    generic = 0;
; 4701 :             sep = "/";
; 4702 :             name = (const char *) cur->name;
; 4703 :             if (cur->ns) {

	mov	eax, DWORD PTR [edi+36]
	xor	ecx, ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR _generic$1$[ebp], ecx
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01KMDKNFGN@?1@
	mov	DWORD PTR _name$1$[ebp], edx
	test	eax, eax
	je	SHORT $LN33@xmlGetNode

; 4704 : 		if (cur->ns->prefix != NULL) {

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN32@xmlGetNode

; 4705 :                     snprintf(nametemp, sizeof(nametemp) - 1, "%s:%s",

	push	edx
	push	eax
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs@
	lea	eax, DWORD PTR _nametemp$[ebp]
	push	99					; 00000063H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 4706 : 			(char *)cur->ns->prefix, (char *)cur->name);
; 4707 : 		    nametemp[sizeof(nametemp) - 1] = 0;

	mov	BYTE PTR _nametemp$[ebp+99], bl

; 4708 : 		    name = nametemp;

	lea	edx, DWORD PTR _nametemp$[ebp]

; 4709 : 		} else {

	mov	ecx, ebx
	jmp	SHORT $LN138@xmlGetNode
$LN32@xmlGetNode:

; 4710 : 		    /*
; 4711 : 		    * We cannot express named elements in the default
; 4712 : 		    * namespace, so use "*".
; 4713 : 		    */
; 4714 : 		    generic = 1;

	mov	ecx, 1

; 4715 : 		    name = "*";

	mov	edx, OFFSET ??_C@_01NBENCBCI@?$CK@
	mov	DWORD PTR _generic$1$[ebp], ecx
$LN138@xmlGetNode:

; 4716 : 		}
; 4717 :             }
; 4718 :             next = cur->parent;

	mov	DWORD PTR _name$1$[ebp], edx
$LN33@xmlGetNode:

; 4719 : 
; 4720 :             /*
; 4721 :              * Thumbler index computation
; 4722 : 	     * TODO: the ocurence test seems bogus for namespaced names
; 4723 :              */
; 4724 :             tmp = cur->prev;

	mov	esi, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _next$1$[ebp], eax

; 4725 :             while (tmp != NULL) {

	test	esi, esi
	je	SHORT $LN124@xmlGetNode
$LL5@xmlGetNode:

; 4726 :                 if ((tmp->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN34@xmlGetNode
	test	ecx, ecx
	jne	SHORT $LN36@xmlGetNode
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlGetNode
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [edi+36]
	cmp	eax, ecx
	je	SHORT $LN36@xmlGetNode
	test	eax, eax
	je	SHORT $LN34@xmlGetNode
	test	ecx, ecx
	je	SHORT $LN34@xmlGetNode
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ecx+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xmlGetNode
$LN36@xmlGetNode:

; 4727 : 		    (generic ||
; 4728 : 		     (xmlStrEqual(cur->name, tmp->name) &&
; 4729 : 		     ((tmp->ns == cur->ns) ||
; 4730 : 		      ((tmp->ns != NULL) && (cur->ns != NULL) &&
; 4731 : 		       (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))
; 4732 :                     occur++;

	inc	ebx
$LN34@xmlGetNode:

; 4733 :                 tmp = tmp->prev;

	mov	esi, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR _generic$1$[ebp]
	test	esi, esi
	jne	SHORT $LL5@xmlGetNode

; 4734 :             }
; 4735 :             if (occur == 0) {

	test	ebx, ebx
	jne	$LN140@xmlGetNode
$LN124@xmlGetNode:

; 4736 :                 tmp = cur->next;

	mov	esi, DWORD PTR [edi+24]

; 4737 :                 while (tmp != NULL && occur == 0) {

	test	esi, esi
	je	$LN131@xmlGetNode
$LL7@xmlGetNode:
	test	ebx, ebx
	jne	SHORT $LN123@xmlGetNode

; 4738 :                     if ((tmp->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN39@xmlGetNode
	cmp	DWORD PTR _generic$1$[ebp], ebx
	jne	SHORT $LN41@xmlGetNode
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlGetNode
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [edi+36]
	cmp	eax, ecx
	je	SHORT $LN41@xmlGetNode
	test	eax, eax
	je	SHORT $LN39@xmlGetNode
	test	ecx, ecx
	je	SHORT $LN39@xmlGetNode
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ecx+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@xmlGetNode
$LN41@xmlGetNode:

; 4739 : 			(generic ||
; 4740 : 			 (xmlStrEqual(cur->name, tmp->name) &&
; 4741 : 			 ((tmp->ns == cur->ns) ||
; 4742 : 			  ((tmp->ns != NULL) && (cur->ns != NULL) &&
; 4743 : 			   (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))
; 4744 :                         occur++;

	mov	ebx, 1
$LN39@xmlGetNode:

; 4745 :                     tmp = tmp->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL7@xmlGetNode
$LN139@xmlGetNode:

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	test	ebx, ebx
	je	$LN131@xmlGetNode
$LN123@xmlGetNode:
	mov	ebx, 1
	jmp	$LN131@xmlGetNode
$LN29@xmlGetNode:

; 4746 :                 }
; 4747 :                 if (occur != 0)
; 4748 :                     occur = 1;
; 4749 :             } else
; 4750 :                 occur++;
; 4751 :         } else if (cur->type == XML_COMMENT_NODE) {

	cmp	eax, 8
	jne	SHORT $LN43@xmlGetNode

; 4752 :             sep = "/";
; 4753 : 	    name = "comment()";
; 4754 :             next = cur->parent;
; 4755 : 
; 4756 :             /*
; 4757 :              * Thumbler index computation
; 4758 :              */
; 4759 :             tmp = cur->prev;

	mov	ecx, DWORD PTR [edi+28]
	mov	esi, OFFSET ??_C@_09OMIOBGHN@comment?$CI?$CJ@
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01KMDKNFGN@?1@
	mov	DWORD PTR _next$1$[ebp], eax

; 4760 :             while (tmp != NULL) {

	test	ecx, ecx
	je	SHORT $LN125@xmlGetNode
	npad	9
$LL9@xmlGetNode:

; 4761 :                 if (tmp->type == XML_COMMENT_NODE)
; 4762 : 		    occur++;
; 4763 :                 tmp = tmp->prev;

	cmp	DWORD PTR [ecx+4], 8
	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, DWORD PTR [ecx+28]
	cmovne	eax, ebx
	mov	ebx, eax
	test	ecx, ecx
	jne	SHORT $LL9@xmlGetNode

; 4764 :             }
; 4765 :             if (occur == 0) {

	test	ebx, ebx
	je	SHORT $LN125@xmlGetNode

; 4773 :                     occur = 1;
; 4774 :             } else
; 4775 :                 occur++;

	inc	ebx

; 4776 :         } else if ((cur->type == XML_TEXT_NODE) ||

	jmp	$LN134@xmlGetNode
$LN125@xmlGetNode:

; 4766 :                 tmp = cur->next;

	mov	eax, DWORD PTR [edi+24]

; 4767 :                 while (tmp != NULL && occur == 0) {

	test	eax, eax
	je	$LN134@xmlGetNode
$LL11@xmlGetNode:
	test	ebx, ebx
	jne	SHORT $LN122@xmlGetNode

; 4768 : 		    if (tmp->type == XML_COMMENT_NODE)

	mov	ecx, DWORD PTR [eax+4]

; 4769 : 		        occur++;
; 4770 :                     tmp = tmp->next;

	cmp	ecx, 8
	mov	eax, DWORD PTR [eax+24]
	sete	bl
	test	eax, eax
	jne	SHORT $LL11@xmlGetNode

; 4771 :                 }
; 4772 :                 if (occur != 0)

	cmp	ecx, 8
	jne	$LN134@xmlGetNode
$LN122@xmlGetNode:

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	mov	ebx, 1
	jmp	$LN134@xmlGetNode
$LN43@xmlGetNode:

; 4776 :         } else if ((cur->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	$LN52@xmlGetNode
	cmp	eax, 4
	je	$LN52@xmlGetNode

; 4809 :         } else if (cur->type == XML_PI_NODE) {

	cmp	eax, 7
	jne	$LN59@xmlGetNode

; 4810 :             sep = "/";
; 4811 : 	    snprintf(nametemp, sizeof(nametemp) - 1,

	push	DWORD PTR [edi+8]
	lea	eax, DWORD PTR _nametemp$[ebp]
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01KMDKNFGN@?1@
	push	OFFSET ??_C@_0BN@BBPFEMPE@processing?9instruction?$CI?8?$CFs?8?$CJ@
	push	99					; 00000063H
	push	eax
	call	_snprintf

; 4812 : 		     "processing-instruction('%s')", (char *)cur->name);
; 4813 :             nametemp[sizeof(nametemp) - 1] = 0;

	mov	BYTE PTR _nametemp$[ebp+99], bl

; 4814 :             name = nametemp;

	lea	edx, DWORD PTR _nametemp$[ebp]

; 4815 : 
; 4816 : 	    next = cur->parent;
; 4817 : 
; 4818 :             /*
; 4819 :              * Thumbler index computation
; 4820 :              */
; 4821 :             tmp = cur->prev;

	mov	esi, DWORD PTR [edi+28]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _name$1$[ebp], edx
	mov	DWORD PTR _next$1$[ebp], eax

; 4822 :             while (tmp != NULL) {

	test	esi, esi
	je	SHORT $LN126@xmlGetNode
	npad	3
$LL17@xmlGetNode:

; 4823 :                 if ((tmp->type == XML_PI_NODE) &&

	cmp	DWORD PTR [esi+4], 7
	jne	SHORT $LN61@xmlGetNode
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN61@xmlGetNode

; 4824 : 		    (xmlStrEqual(cur->name, tmp->name)))
; 4825 :                     occur++;

	inc	ebx
$LN61@xmlGetNode:

; 4826 :                 tmp = tmp->prev;

	mov	esi, DWORD PTR [esi+28]
	test	esi, esi
	jne	SHORT $LL17@xmlGetNode

; 4827 :             }
; 4828 :             if (occur == 0) {

	test	ebx, ebx
	jne	$LN140@xmlGetNode
$LN126@xmlGetNode:

; 4829 :                 tmp = cur->next;

	mov	esi, DWORD PTR [edi+24]

; 4830 :                 while (tmp != NULL && occur == 0) {

	test	esi, esi
	je	$LN131@xmlGetNode
$LL19@xmlGetNode:
	test	ebx, ebx
	jne	$LN123@xmlGetNode

; 4831 :                     if ((tmp->type == XML_PI_NODE) &&

	cmp	DWORD PTR [esi+4], 7
	jne	SHORT $LN64@xmlGetNode
	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	mov	eax, 1
	cmovne	ebx, eax
$LN64@xmlGetNode:

; 4832 : 			(xmlStrEqual(cur->name, tmp->name)))
; 4833 :                         occur++;
; 4834 :                     tmp = tmp->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL19@xmlGetNode

; 4837 :                     occur = 1;
; 4838 :             } else

	jmp	$LN139@xmlGetNode
$LN59@xmlGetNode:

; 4839 :                 occur++;
; 4840 : 
; 4841 :         } else if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN68@xmlGetNode

; 4842 :             sep = "/@";
; 4843 :             name = (const char *) (((xmlAttrPtr) cur)->name);
; 4844 :             if (cur->ns) {

	mov	eax, DWORD PTR [edi+36]
	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_02MDNGGIDF@?1?$EA@
	test	eax, eax
	je	SHORT $LN68@xmlGetNode

; 4845 : 	        if (cur->ns->prefix != NULL)

	mov	eax, DWORD PTR [eax+12]
	push	esi
	test	eax, eax
	je	SHORT $LN69@xmlGetNode

; 4846 :                     snprintf(nametemp, sizeof(nametemp) - 1, "%s:%s",

	push	eax
	push	OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs@
	lea	eax, DWORD PTR _nametemp$[ebp]
	push	99					; 00000063H
	push	eax
	call	_snprintf

; 4850 : 			(char *)cur->name);
; 4851 :                 nametemp[sizeof(nametemp) - 1] = 0;

	mov	BYTE PTR _nametemp$[ebp+99], bl

; 4852 :                 name = nametemp;

	lea	esi, DWORD PTR _nametemp$[ebp]

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	mov	edi, DWORD PTR [edi+20]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _next$1$[ebp], edi
	jmp	$LN67@xmlGetNode
$LN69@xmlGetNode:

; 4847 : 			(char *)cur->ns->prefix, (char *)cur->name);
; 4848 : 		else
; 4849 : 		    snprintf(nametemp, sizeof(nametemp) - 1, "%s",

	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	lea	eax, DWORD PTR _nametemp$[ebp]
	push	99					; 00000063H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 4850 : 			(char *)cur->name);
; 4851 :                 nametemp[sizeof(nametemp) - 1] = 0;

	mov	BYTE PTR _nametemp$[ebp+99], bl

; 4852 :                 name = nametemp;

	lea	esi, DWORD PTR _nametemp$[ebp]
$LN68@xmlGetNode:

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	mov	edi, DWORD PTR [edi+20]
	mov	DWORD PTR _next$1$[ebp], edi
	jmp	$LN67@xmlGetNode
$LN52@xmlGetNode:

; 4777 :                    (cur->type == XML_CDATA_SECTION_NODE)) {
; 4778 :             sep = "/";
; 4779 : 	    name = "text()";
; 4780 :             next = cur->parent;

	mov	eax, DWORD PTR [edi+20]
	mov	esi, OFFSET ??_C@_06HNGKFOCG@text?$CI?$CJ@
	mov	DWORD PTR _next$1$[ebp], eax

; 4781 : 
; 4782 :             /*
; 4783 :              * Thumbler index computation
; 4784 :              */
; 4785 :             tmp = cur->prev;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01KMDKNFGN@?1@

; 4786 :             while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN127@xmlGetNode
$LL13@xmlGetNode:

; 4787 :                 if ((tmp->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	SHORT $LN111@xmlGetNode
	cmp	ecx, 4
	jne	SHORT $LN53@xmlGetNode
$LN111@xmlGetNode:

; 4788 : 		    (tmp->type == XML_CDATA_SECTION_NODE))
; 4789 : 		    occur++;

	inc	ebx
$LN53@xmlGetNode:

; 4790 :                 tmp = tmp->prev;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL13@xmlGetNode

; 4791 :             }
; 4792 : 	    /*
; 4793 : 	    * Evaluate if this is the only text- or CDATA-section-node;
; 4794 : 	    * if yes, then we'll get "text()", otherwise "text()[1]".
; 4795 : 	    */
; 4796 :             if (occur == 0) {

	test	ebx, ebx
	je	SHORT $LN127@xmlGetNode

; 4806 : 		}
; 4807 :             } else
; 4808 :                 occur++;

	inc	ebx

; 4809 :         } else if (cur->type == XML_PI_NODE) {

	jmp	SHORT $LN134@xmlGetNode
$LN127@xmlGetNode:

; 4797 :                 tmp = cur->next;

	mov	eax, DWORD PTR [edi+24]

; 4798 :                 while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN134@xmlGetNode
	npad	8
$LL15@xmlGetNode:

; 4799 : 		    if ((tmp->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	$LN122@xmlGetNode
	cmp	ecx, 4
	je	$LN122@xmlGetNode

; 4800 : 			(tmp->type == XML_CDATA_SECTION_NODE))
; 4801 : 		    {
; 4802 : 			occur = 1;
; 4803 : 			break;
; 4804 : 		    }
; 4805 : 		    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL15@xmlGetNode

; 4874 :             if (temp == NULL) {

	jmp	SHORT $LN134@xmlGetNode
$LN27@xmlGetNode:

; 4694 :             (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 4695 :             if (buffer[0] == '/')

	cmp	BYTE PTR [ecx], 47			; 0000002fH
	je	$LN3@xmlGetNode

; 4696 :                 break;
; 4697 :             sep = "/";
; 4698 :             next = NULL;

	xor	edi, edi
	mov	DWORD PTR _sep$1$[ebp], OFFSET ??_C@_01KMDKNFGN@?1@
	mov	DWORD PTR _next$1$[ebp], edi

; 4835 :                 }
; 4836 :                 if (occur != 0)

	jmp	SHORT $LN67@xmlGetNode
$LN140@xmlGetNode:

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	inc	ebx
$LN131@xmlGetNode:
	mov	esi, DWORD PTR _name$1$[ebp]
$LN134@xmlGetNode:
	mov	edi, DWORD PTR _next$1$[ebp]
$LN67@xmlGetNode:
	push	DWORD PTR _buffer$1$[ebp]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _buf_len$1$[ebp]
	add	eax, 120				; 00000078H
	add	esp, 4
	cmp	eax, ecx
	jbe	SHORT $LN135@xmlGetNode

; 4863 :             buf_len =

	push	DWORD PTR _buffer$1$[ebp]
	call	_xmlStrlen
	mov	ecx, DWORD PTR _buf_len$1$[ebp]
	add	ecx, 60					; 0000003cH
	lea	ecx, DWORD PTR [eax+ecx*2]

; 4864 :                 2 * buf_len + xmlStrlen(buffer) + sizeof(nametemp) + 20;
; 4865 :             temp = (xmlChar *) xmlRealloc(buffer, buf_len);

	push	ecx
	push	DWORD PTR _buffer$1$[ebp]
	mov	DWORD PTR _buf_len$1$[ebp], ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 12					; 0000000cH

; 4866 :             if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN92@xmlGetNode

; 4871 :             }
; 4872 :             buffer = temp;

	mov	DWORD PTR _buffer$1$[ebp], eax

; 4873 :             temp = (xmlChar *) xmlRealloc(buf, buf_len);

	mov	eax, DWORD PTR _buf_len$1$[ebp]
	push	eax
	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4874 :             if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN92@xmlGetNode

; 4875 : 		xmlTreeErrMemory("getting node path");
; 4876 :                 xmlFree(buf);
; 4877 :                 xmlFree(buffer);
; 4878 :                 return (NULL);
; 4879 :             }
; 4880 :             buf = temp;

	mov	ecx, DWORD PTR _buf_len$1$[ebp]
	mov	DWORD PTR _buf$1$[ebp], eax
	jmp	SHORT $LN71@xmlGetNode
$LN135@xmlGetNode:

; 4853 :             }
; 4854 :             next = ((xmlAttrPtr) cur)->parent;
; 4855 :         } else {
; 4856 :             next = cur->parent;
; 4857 :         }
; 4858 : 
; 4859 :         /*
; 4860 :          * Make sure there is enough room
; 4861 :          */
; 4862 :         if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {

	mov	eax, DWORD PTR _buf$1$[ebp]
$LN71@xmlGetNode:

; 4881 :         }
; 4882 :         if (occur == 0)

	push	DWORD PTR _buffer$1$[ebp]
	test	ebx, ebx
	jne	SHORT $LN74@xmlGetNode

; 4883 :             snprintf((char *) buf, buf_len, "%s%s%s",

	push	esi
	push	DWORD PTR _sep$1$[ebp]
	push	OFFSET ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
	push	ecx
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN75@xmlGetNode
$LN74@xmlGetNode:

; 4884 :                      sep, name, (char *) buffer);
; 4885 :         else
; 4886 :             snprintf((char *) buf, buf_len, "%s%s[%d]%s",

	push	ebx
	push	esi
	push	DWORD PTR _sep$1$[ebp]
	push	OFFSET ??_C@_0L@INIGIDIG@?$CFs?$CFs?$FL?$CFd?$FN?$CFs@
	push	ecx
	push	eax
	call	_snprintf
	add	esp, 28					; 0000001cH
$LN75@xmlGetNode:

; 4887 :                      sep, name, occur, (char *) buffer);
; 4888 :         snprintf((char *) buffer, buf_len, "%s", (char *)buf);

	push	DWORD PTR _buf$1$[ebp]
	mov	eax, DWORD PTR _buf_len$1$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	push	DWORD PTR _buffer$1$[ebp]
	call	_snprintf
	add	esp, 16					; 00000010H

; 4889 :         cur = next;
; 4890 :     } while (cur != NULL);

	cmp	DWORD PTR _next$1$[ebp], 0
	je	SHORT $LN3@xmlGetNode
	mov	ecx, DWORD PTR _buffer$1$[ebp]
	jmp	$LL4@xmlGetNode
$LN92@xmlGetNode:

; 4867 : 		xmlTreeErrMemory("getting node path");

	push	OFFSET ??_C@_0BC@NABGEGIL@getting?5node?5path@
	call	_xmlTreeErrMemory

; 4868 :                 xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 4869 :                 xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 4870 :                 return (NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 4893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlGetNode:

; 4891 :     xmlFree(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	DWORD PTR _xmlFree

; 4892 :     return (buffer);

	mov	eax, DWORD PTR _buffer$1$[ebp]
	add	esp, 4
	pop	esi
	pop	ebx
	pop	edi

; 4893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlGetNode:

; 4672 :         return (NULL);

	xor	eax, eax
	pop	edi

; 4893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetNodePath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetLineNo
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlGetLineNo PROC					; COMDAT

; 4645 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _node$[ebp]
	call	_xmlGetLineNoInternal
	add	esp, 8

; 4646 :     return(xmlGetLineNoInternal(node, 0));
; 4647 : }

	pop	ebp
	ret	0
_xmlGetLineNo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocFragment
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlNewDocFragment PROC					; COMDAT

; 2409 : xmlNewDocFragment(xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewDocF

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BC@HPKKMJFM@building?5fragment@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2410 :     xmlNodePtr cur;
; 2411 : 
; 2412 :     /*
; 2413 :      * Allocate a new DocumentFragment node and fill the fields.
; 2414 :      */
; 2415 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 2416 :     if (cur == NULL) {
; 2417 : 	xmlTreeErrMemory("building fragment");
; 2418 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2428 : }

	pop	ebp
	ret	0
$LN2@xmlNewDocF:

; 2419 :     }
; 2420 :     memset(cur, 0, sizeof(xmlNode));
; 2421 :     cur->type = XML_DOCUMENT_FRAG_NODE;
; 2422 : 
; 2423 :     cur->doc = doc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 11			; 0000000bH
	mov	DWORD PTR [esi+32], eax

; 2424 : 
; 2425 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN3@xmlNewDocF
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlNewDocF

; 2426 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN3@xmlNewDocF:

; 2427 :     return(cur);

	mov	eax, esi
	pop	esi

; 2428 : }

	pop	ebp
	ret	0
_xmlNewDocFragment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocRawNode
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlNewDocRawNode PROC					; COMDAT

; 2387 :                  const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4

; 2319 :     if ((doc != NULL) && (doc->dict != NULL))

	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN13@xmlNewDocR
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN13@xmlNewDocR

; 2320 :         cur = xmlNewNodeEatName(ns, (xmlChar *)

	push	-1
	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictLookup
	push	eax
	push	DWORD PTR _ns$[ebp]
	call	_xmlNewNodeEatName
	add	esp, 20					; 00000014H
	jmp	SHORT $LN30@xmlNewDocR
$LN13@xmlNewDocR:

; 2321 : 	                        xmlDictLookup(doc->dict, name, -1));
; 2322 :     else
; 2323 : 	cur = xmlNewNode(ns, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ns$[ebp]
	call	_xmlNewNode
	add	esp, 8
$LN30@xmlNewDocR:

; 2324 :     if (cur != NULL) {

	mov	esi, eax
	test	esi, esi
	je	SHORT $LN29@xmlNewDocR

; 2388 :     xmlNodePtr cur;
; 2389 : 
; 2390 :     cur = xmlNewDocNode(doc, ns, name, NULL);
; 2391 :     if (cur != NULL) {
; 2392 :         cur->doc = doc;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+32], edi

; 2393 : 	if (content != NULL) {

	test	eax, eax
	je	SHORT $LN29@xmlNewDocR

; 2656 :     cur = xmlNewText(content);

	push	eax
	call	_xmlNewText
	add	esp, 4

; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	test	eax, eax
	je	SHORT $LN22@xmlNewDocR
	mov	DWORD PTR [eax+32], edi
$LN22@xmlNewDocR:

; 2394 : 	    cur->children = xmlNewDocText(doc, content);

	mov	DWORD PTR [esi+12], eax

; 2395 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	test	eax, eax
	jne	SHORT $LN24@xmlNewDocR
	mov	DWORD PTR [esi+16], eax

; 2396 : 	}
; 2397 :     }
; 2398 :     return(cur);
; 2399 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN24@xmlNewDocR:

; 2395 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN3@xmlNewDocR
	npad	3
$LL2@xmlNewDocR:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL2@xmlNewDocR
$LN3@xmlNewDocR:
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [esi+16], eax
$LN29@xmlNewDocR:

; 2396 : 	}
; 2397 :     }
; 2398 :     return(cur);
; 2399 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlNewDocRawNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewTextChild
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlNewTextChild PROC					; COMDAT

; 2485 :             const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _parent$[ebp]
	test	esi, esi
	je	$LN19@xmlNewText

; 2486 :     xmlNodePtr cur, prev;
; 2487 : 
; 2488 :     if (parent == NULL) {
; 2489 : #ifdef DEBUG_TREE
; 2490 :         xmlGenericError(xmlGenericErrorContext,
; 2491 : 		"xmlNewTextChild : parent == NULL\n");
; 2492 : #endif
; 2493 : 	return(NULL);
; 2494 :     }
; 2495 : 
; 2496 :     if (name == NULL) {

	mov	edx, DWORD PTR _name$[ebp]
	test	edx, edx
	je	SHORT $LN19@xmlNewText

; 2497 : #ifdef DEBUG_TREE
; 2498 :         xmlGenericError(xmlGenericErrorContext,
; 2499 : 		"xmlNewTextChild : name == NULL\n");
; 2500 : #endif
; 2501 : 	return(NULL);
; 2502 :     }
; 2503 : 
; 2504 :     /*
; 2505 :      * Allocate a new node
; 2506 :      */
; 2507 :     if (parent->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN4@xmlNewText

; 2508 : 	if (ns == NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN12@xmlNewText

; 2509 : 	    cur = xmlNewDocRawNode(parent->doc, parent->ns, name, content);

	mov	eax, DWORD PTR [esi+36]

; 2510 : 	else
; 2511 : 	    cur = xmlNewDocRawNode(parent->doc, ns, name, content);
; 2512 :     } else if ((parent->type == XML_DOCUMENT_NODE) ||

	jmp	SHORT $LN12@xmlNewText
$LN4@xmlNewText:
	cmp	eax, 9
	je	SHORT $LN10@xmlNewText
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN10@xmlNewText

; 2515 : 	    cur = xmlNewDocRawNode((xmlDocPtr) parent, NULL, name, content);
; 2516 : 	else
; 2517 : 	    cur = xmlNewDocRawNode((xmlDocPtr) parent, ns, name, content);
; 2518 :     } else if (parent->type == XML_DOCUMENT_FRAG_NODE) {

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN19@xmlNewText

; 2519 : 	    cur = xmlNewDocRawNode( parent->doc, ns, name, content);

	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _ns$[ebp]

; 2520 :     } else {

	jmp	SHORT $LN12@xmlNewText
$LN10@xmlNewText:

; 2513 : 	       (parent->type == XML_HTML_DOCUMENT_NODE)) {
; 2514 : 	if (ns == NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, esi
	test	eax, eax
	jne	SHORT $LN12@xmlNewText
$LN12@xmlNewText:

; 2521 : 	return(NULL);
; 2522 :     }
; 2523 :     if (cur == NULL) return(NULL);

	push	DWORD PTR _content$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlNewDocRawNode
	mov	edx, eax
	add	esp, 16					; 00000010H
	test	edx, edx
	je	SHORT $LN19@xmlNewText

; 2524 : 
; 2525 :     /*
; 2526 :      * add the new element at the end of the children list.
; 2527 :      */
; 2528 :     cur->type = XML_ELEMENT_NODE;

	mov	DWORD PTR [edx+4], 1

; 2529 :     cur->parent = parent;

	mov	DWORD PTR [edx+20], esi

; 2530 :     cur->doc = parent->doc;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [edx+32], eax

; 2531 :     if (parent->children == NULL) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN16@xmlNewText

; 2532 :         parent->children = cur;

	mov	DWORD PTR [esi+12], edx

; 2536 : 	prev->next = cur;
; 2537 : 	cur->prev = prev;
; 2538 : 	parent->last = cur;
; 2539 :     }
; 2540 : 
; 2541 :     return(cur);

	mov	eax, edx
	mov	DWORD PTR [esi+16], edx
	pop	esi

; 2542 : }

	pop	ebp
	ret	0
$LN16@xmlNewText:

; 2533 : 	parent->last = cur;
; 2534 :     } else {
; 2535 :         prev = parent->last;

	mov	ecx, DWORD PTR [esi+16]

; 2536 : 	prev->next = cur;
; 2537 : 	cur->prev = prev;
; 2538 : 	parent->last = cur;
; 2539 :     }
; 2540 : 
; 2541 :     return(cur);

	mov	eax, edx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [edx+28], ecx
	mov	DWORD PTR [esi+16], edx
	pop	esi

; 2542 : }

	pop	ebp
	ret	0
$LN19@xmlNewText:

; 2521 : 	return(NULL);
; 2522 :     }
; 2523 :     if (cur == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 2542 : }

	pop	ebp
	ret	0
_xmlNewTextChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyNodeList
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlCopyNodeList PROC					; COMDAT

; 4424 : xmlNodePtr xmlCopyNodeList(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _node$[ebp]
	call	_xmlStaticCopyNodeList
	add	esp, 12					; 0000000cH

; 4425 :     xmlNodePtr ret = xmlStaticCopyNodeList(node, NULL, NULL);
; 4426 :     return(ret);
; 4427 : }

	pop	ebp
	ret	0
_xmlCopyNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDocCopyNodeList
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlDocCopyNodeList PROC				; COMDAT

; 4410 : xmlNodePtr xmlDocCopyNodeList(xmlDocPtr doc, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlStaticCopyNodeList
	add	esp, 12					; 0000000cH

; 4411 :     xmlNodePtr ret = xmlStaticCopyNodeList(node, doc, NULL);
; 4412 :     return(ret);
; 4413 : }

	pop	ebp
	ret	0
_xmlDocCopyNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlDocCopyNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_doc$ = 12						; size = 4
_extended$ = 16						; size = 4
_xmlDocCopyNode PROC					; COMDAT

; 4394 : xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extended$[ebp]
	push	0
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlStaticCopyNode
	add	esp, 16					; 00000010H

; 4395 :     xmlNodePtr ret;
; 4396 : 
; 4397 :     ret = xmlStaticCopyNode(node, doc, NULL, extended);
; 4398 :     return(ret);
; 4399 : }

	pop	ebp
	ret	0
_xmlDocCopyNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_extended$ = 12						; size = 4
_xmlCopyNode PROC					; COMDAT

; 4374 : xmlCopyNode(xmlNodePtr node, int extended) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extended$[ebp]
	push	0
	push	0
	push	DWORD PTR _node$[ebp]
	call	_xmlStaticCopyNode
	add	esp, 16					; 00000010H

; 4375 :     xmlNodePtr ret;
; 4376 : 
; 4377 :     ret = xmlStaticCopyNode(node, NULL, NULL, extended);
; 4378 :     return(ret);
; 4379 : }

	pop	ebp
	ret	0
_xmlCopyNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewReference
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlNewReference PROC					; COMDAT

; 2597 : xmlNewReference(const xmlDoc *doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlNewRefe

; 2598 :     xmlNodePtr cur;
; 2599 :     xmlEntityPtr ent;
; 2600 : 
; 2601 :     if (name == NULL)
; 2602 :         return(NULL);

	xor	eax, eax
	pop	edi

; 2642 : }

	pop	ebp
	ret	0
$LN2@xmlNewRefe:
	push	esi

; 2603 : 
; 2604 :     /*
; 2605 :      * Allocate a new node and fill the fields.
; 2606 :      */
; 2607 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2608 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewRefe

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BD@OKHPDLFF@building?5reference@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2609 : 	xmlTreeErrMemory("building reference");
; 2610 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2642 : }

	pop	ebp
	ret	0
$LN3@xmlNewRefe:

; 2611 :     }
; 2612 :     memset(cur, 0, sizeof(xmlNode));

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	push	ebx

; 2613 :     cur->type = XML_ENTITY_REF_NODE;
; 2614 : 
; 2615 :     cur->doc = (xmlDoc *)doc;

	mov	ebx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi+4], 5
	mov	DWORD PTR [esi+32], ebx

; 2616 :     if (name[0] == '&') {

	cmp	BYTE PTR [edi], 38			; 00000026H
	jne	SHORT $LN4@xmlNewRefe

; 2617 :         int len;
; 2618 :         name++;

	inc	edi

; 2619 : 	len = xmlStrlen(name);

	push	edi
	call	_xmlStrlen
	add	esp, 4

; 2620 : 	if (name[len - 1] == ';')

	cmp	BYTE PTR [eax+edi-1], 59		; 0000003bH
	jne	SHORT $LN6@xmlNewRefe

; 2621 : 	    cur->name = xmlStrndup(name, len - 1);

	dec	eax
$LN6@xmlNewRefe:

; 2622 : 	else
; 2623 : 	    cur->name = xmlStrndup(name, len);
; 2624 :     } else

	push	eax
	push	edi
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [esi+8], eax
	jmp	SHORT $LN5@xmlNewRefe
$LN4@xmlNewRefe:

; 2625 : 	cur->name = xmlStrdup(name);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN5@xmlNewRefe:

; 2626 : 
; 2627 :     ent = xmlGetDocEntity(doc, cur->name);

	push	eax
	push	ebx
	call	_xmlGetDocEntity
	add	esp, 8
	mov	ecx, eax
	pop	ebx

; 2628 :     if (ent != NULL) {

	test	ecx, ecx
	je	SHORT $LN8@xmlNewRefe

; 2629 : 	cur->content = ent->content;

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+40], eax

; 2630 : 	/*
; 2631 : 	 * The parent pointer in entity is a DTD pointer and thus is NOT
; 2632 : 	 * updated.  Not sure if this is 100% correct.
; 2633 : 	 *  -George
; 2634 : 	 */
; 2635 : 	cur->children = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+12], ecx

; 2636 : 	cur->last = (xmlNodePtr) ent;

	mov	DWORD PTR [esi+16], ecx
$LN8@xmlNewRefe:

; 2637 :     }
; 2638 : 
; 2639 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN9@xmlNewRefe
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlNewRefe

; 2640 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN9@xmlNewRefe:

; 2641 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 2642 : }

	pop	ebp
	ret	0
_xmlNewReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewCharRef
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlNewCharRef PROC					; COMDAT

; 2554 : xmlNewCharRef(xmlDocPtr doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlNewChar

; 2555 :     xmlNodePtr cur;
; 2556 : 
; 2557 :     if (name == NULL)
; 2558 :         return(NULL);

	xor	eax, eax
	pop	edi

; 2586 : }

	pop	ebp
	ret	0
$LN2@xmlNewChar:
	push	esi

; 2559 : 
; 2560 :     /*
; 2561 :      * Allocate a new node and fill the fields.
; 2562 :      */
; 2563 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2564 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewChar

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BN@PHGPAPBE@building?5character?5reference@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2565 : 	xmlTreeErrMemory("building character reference");
; 2566 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2586 : }

	pop	ebp
	ret	0
$LN3@xmlNewChar:

; 2567 :     }
; 2568 :     memset(cur, 0, sizeof(xmlNode));
; 2569 :     cur->type = XML_ENTITY_REF_NODE;
; 2570 : 
; 2571 :     cur->doc = doc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 5
	mov	DWORD PTR [esi+32], eax

; 2572 :     if (name[0] == '&') {

	cmp	BYTE PTR [edi], 38			; 00000026H
	jne	SHORT $LN4@xmlNewChar

; 2573 :         int len;
; 2574 :         name++;

	inc	edi

; 2575 : 	len = xmlStrlen(name);

	push	edi
	call	_xmlStrlen
	add	esp, 4

; 2576 : 	if (name[len - 1] == ';')

	cmp	BYTE PTR [eax+edi-1], 59		; 0000003bH
	jne	SHORT $LN6@xmlNewChar

; 2577 : 	    cur->name = xmlStrndup(name, len - 1);

	dec	eax
$LN6@xmlNewChar:

; 2578 : 	else
; 2579 : 	    cur->name = xmlStrndup(name, len);
; 2580 :     } else

	push	eax
	push	edi
	call	_xmlStrndup
	add	esp, 8
	jmp	SHORT $LN5@xmlNewChar
$LN4@xmlNewChar:

; 2581 : 	cur->name = xmlStrdup(name);

	push	edi
	call	_xmlStrdup
	add	esp, 4
$LN5@xmlNewChar:

; 2582 : 
; 2583 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN8@xmlNewChar
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@xmlNewChar

; 2584 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN8@xmlNewChar:

; 2585 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 2586 : }

	pop	ebp
	ret	0
_xmlNewCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewCDataBlock
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_content$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNewCDataBlock PROC					; COMDAT

; 2755 : xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewCDat

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0P@MBGLGFEO@building?5CDATA@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2756 :     xmlNodePtr cur;
; 2757 : 
; 2758 :     /*
; 2759 :      * Allocate a new node and fill the fields.
; 2760 :      */
; 2761 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 2762 :     if (cur == NULL) {
; 2763 : 	xmlTreeErrMemory("building CDATA");
; 2764 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2777 : }

	pop	ebp
	ret	0
$LN2@xmlNewCDat:

; 2765 :     }
; 2766 :     memset(cur, 0, sizeof(xmlNode));
; 2767 :     cur->type = XML_CDATA_SECTION_NODE;
; 2768 :     cur->doc = doc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+32], eax

; 2769 : 
; 2770 :     if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+4], 4
	test	eax, eax
	je	SHORT $LN3@xmlNewCDat

; 2771 : 	cur->content = xmlStrndup(content, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [esi+40], eax
$LN3@xmlNewCDat:

; 2772 :     }
; 2773 : 
; 2774 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewCDat
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewCDat

; 2775 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN4@xmlNewCDat:

; 2776 :     return(cur);

	mov	eax, esi
	pop	esi

; 2777 : }

	pop	ebp
	ret	0
_xmlNewCDataBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewComment
_TEXT	SEGMENT
_content$ = 8						; size = 4
_xmlNewComment PROC					; COMDAT

; 2721 : xmlNewComment(const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewComm

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BB@JNPLEEAM@building?5comment@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2722 :     xmlNodePtr cur;
; 2723 : 
; 2724 :     /*
; 2725 :      * Allocate a new node and fill the fields.
; 2726 :      */
; 2727 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 2728 :     if (cur == NULL) {
; 2729 : 	xmlTreeErrMemory("building comment");
; 2730 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2743 : }

	pop	ebp
	ret	0
$LN2@xmlNewComm:

; 2731 :     }
; 2732 :     memset(cur, 0, sizeof(xmlNode));
; 2733 :     cur->type = XML_COMMENT_NODE;
; 2734 : 
; 2735 :     cur->name = xmlStringComment;
; 2736 :     if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 8
	mov	DWORD PTR [esi+8], OFFSET _xmlStringComment
	test	eax, eax
	je	SHORT $LN3@xmlNewComm

; 2737 : 	cur->content = xmlStrdup(content);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+40], eax
$LN3@xmlNewComm:

; 2738 :     }
; 2739 : 
; 2740 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewComm
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewComm

; 2741 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN4@xmlNewComm:

; 2742 :     return(cur);

	mov	eax, esi
	pop	esi

; 2743 : }

	pop	ebp
	ret	0
_xmlNewComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocComment
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlNewDocComment PROC					; COMDAT

; 2788 : xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _content$[ebp]
	call	_xmlNewComment
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@xmlNewDocC

; 2789 :     xmlNodePtr cur;
; 2790 : 
; 2791 :     cur = xmlNewComment(content);
; 2792 :     if (cur != NULL) cur->doc = doc;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN2@xmlNewDocC:

; 2793 :     return(cur);
; 2794 : }

	pop	ebp
	ret	0
_xmlNewDocComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewTextLen
_TEXT	SEGMENT
_content$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlNewTextLen PROC					; COMDAT

; 2670 : xmlNewTextLen(const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewText

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0O@LOBCMCEI@building?5text@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2671 :     xmlNodePtr cur;
; 2672 : 
; 2673 :     /*
; 2674 :      * Allocate a new node and fill the fields.
; 2675 :      */
; 2676 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 2677 :     if (cur == NULL) {
; 2678 : 	xmlTreeErrMemory("building text");
; 2679 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2692 : }

	pop	ebp
	ret	0
$LN2@xmlNewText:

; 2680 :     }
; 2681 :     memset(cur, 0, sizeof(xmlNode));
; 2682 :     cur->type = XML_TEXT_NODE;
; 2683 : 
; 2684 :     cur->name = xmlStringText;
; 2685 :     if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 3
	mov	DWORD PTR [esi+8], OFFSET _xmlStringText
	test	eax, eax
	je	SHORT $LN3@xmlNewText

; 2686 : 	cur->content = xmlStrndup(content, len);

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [esi+40], eax
$LN3@xmlNewText:

; 2687 :     }
; 2688 : 
; 2689 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewText
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewText

; 2690 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN4@xmlNewText:

; 2691 :     return(cur);

	mov	eax, esi
	pop	esi

; 2692 : }

	pop	ebp
	ret	0
_xmlNewTextLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocTextLen
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_content$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNewDocTextLen PROC					; COMDAT

; 2705 : xmlNewDocTextLen(xmlDocPtr doc, const xmlChar *content, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _content$[ebp]
	call	_xmlNewTextLen
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlNewDocT

; 2706 :     xmlNodePtr cur;
; 2707 : 
; 2708 :     cur = xmlNewTextLen(content, len);
; 2709 :     if (cur != NULL) cur->doc = doc;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN2@xmlNewDocT:

; 2710 :     return(cur);
; 2711 : }

	pop	ebp
	ret	0
_xmlNewDocTextLen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewPI
_TEXT	SEGMENT
_name$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlNewPI PROC						; COMDAT

; 2210 : xmlNewPI(const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _content$[ebp]
	push	DWORD PTR _name$[ebp]
	push	0
	call	_xmlNewDocPI
	add	esp, 12					; 0000000cH

; 2211 :     return(xmlNewDocPI(NULL, name, content));
; 2212 : }

	pop	ebp
	ret	0
_xmlNewPI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocPI
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_content$ = 16						; size = 4
_xmlNewDocPI PROC					; COMDAT

; 2163 : xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	jne	SHORT $LN2@xmlNewDocP

; 2164 :     xmlNodePtr cur;
; 2165 : 
; 2166 :     if (name == NULL) {
; 2167 : #ifdef DEBUG_TREE
; 2168 :         xmlGenericError(xmlGenericErrorContext,
; 2169 : 		"xmlNewPI : name == NULL\n");
; 2170 : #endif
; 2171 : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 2197 : }

	pop	ebp
	ret	0
$LN2@xmlNewDocP:
	push	esi

; 2172 :     }
; 2173 : 
; 2174 :     /*
; 2175 :      * Allocate a new node and fill the fields.
; 2176 :      */
; 2177 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2178 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewDocP

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0M@OGMFHPHO@building?5PI@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2179 : 	xmlTreeErrMemory("building PI");
; 2180 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 2197 : }

	pop	ebp
	ret	0
$LN3@xmlNewDocP:
	push	edi

; 2181 :     }
; 2182 :     memset(cur, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	esi
	call	_memset

; 2183 :     cur->type = XML_PI_NODE;
; 2184 : 
; 2185 :     if ((doc != NULL) && (doc->dict != NULL))

	mov	edi, DWORD PTR _doc$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 7
	test	edi, edi
	je	SHORT $LN4@xmlNewDocP
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN4@xmlNewDocP

; 2186 :         cur->name = xmlDictLookup(doc->dict, name, -1);

	push	-1
	push	ebx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlNewDocP
$LN4@xmlNewDocP:

; 2187 :     else
; 2188 : 	cur->name = xmlStrdup(name);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
$LN5@xmlNewDocP:

; 2189 :     if (content != NULL) {

	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _content$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlNewDocP

; 2190 : 	cur->content = xmlStrdup(content);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+40], eax
$LN6@xmlNewDocP:

; 2191 :     }
; 2192 :     cur->doc = doc;

	mov	DWORD PTR [esi+32], edi

; 2193 : 
; 2194 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	pop	edi
	je	SHORT $LN7@xmlNewDocP
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@xmlNewDocP

; 2195 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN7@xmlNewDocP:

; 2196 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2197 : }

	pop	ebp
	ret	0
_xmlNewDocPI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewText
_TEXT	SEGMENT
_content$ = 8						; size = 4
_xmlNewText PROC					; COMDAT

; 2439 : xmlNewText(const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewText

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0O@LOBCMCEI@building?5text@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2440 :     xmlNodePtr cur;
; 2441 : 
; 2442 :     /*
; 2443 :      * Allocate a new node and fill the fields.
; 2444 :      */
; 2445 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
; 2446 :     if (cur == NULL) {
; 2447 : 	xmlTreeErrMemory("building text");
; 2448 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2461 : }

	pop	ebp
	ret	0
$LN2@xmlNewText:

; 2449 :     }
; 2450 :     memset(cur, 0, sizeof(xmlNode));
; 2451 :     cur->type = XML_TEXT_NODE;
; 2452 : 
; 2453 :     cur->name = xmlStringText;
; 2454 :     if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 3
	mov	DWORD PTR [esi+8], OFFSET _xmlStringText
	test	eax, eax
	je	SHORT $LN3@xmlNewText

; 2455 : 	cur->content = xmlStrdup(content);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+40], eax
$LN3@xmlNewText:

; 2456 :     }
; 2457 : 
; 2458 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewText
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewText

; 2459 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN4@xmlNewText:

; 2460 :     return(cur);

	mov	eax, esi
	pop	esi

; 2461 : }

	pop	ebp
	ret	0
_xmlNewText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocText
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlNewDocText PROC					; COMDAT

; 2653 : xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _content$[ebp]
	call	_xmlNewText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@xmlNewDocT

; 2654 :     xmlNodePtr cur;
; 2655 : 
; 2656 :     cur = xmlNewText(content);
; 2657 :     if (cur != NULL) cur->doc = (xmlDoc *)doc;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN2@xmlNewDocT:

; 2658 :     return(cur);
; 2659 : }

	pop	ebp
	ret	0
_xmlNewDocText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewChild
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlNewChild PROC					; COMDAT

; 2884 :             const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _parent$[ebp]
	test	esi, esi
	je	$LN19@xmlNewChil

; 2885 :     xmlNodePtr cur, prev;
; 2886 : 
; 2887 :     if (parent == NULL) {
; 2888 : #ifdef DEBUG_TREE
; 2889 :         xmlGenericError(xmlGenericErrorContext,
; 2890 : 		"xmlNewChild : parent == NULL\n");
; 2891 : #endif
; 2892 : 	return(NULL);
; 2893 :     }
; 2894 : 
; 2895 :     if (name == NULL) {

	mov	edx, DWORD PTR _name$[ebp]
	test	edx, edx
	je	SHORT $LN19@xmlNewChil

; 2896 : #ifdef DEBUG_TREE
; 2897 :         xmlGenericError(xmlGenericErrorContext,
; 2898 : 		"xmlNewChild : name == NULL\n");
; 2899 : #endif
; 2900 : 	return(NULL);
; 2901 :     }
; 2902 : 
; 2903 :     /*
; 2904 :      * Allocate a new node
; 2905 :      */
; 2906 :     if (parent->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN4@xmlNewChil

; 2907 : 	if (ns == NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN12@xmlNewChil

; 2908 : 	    cur = xmlNewDocNode(parent->doc, parent->ns, name, content);

	mov	eax, DWORD PTR [esi+36]

; 2909 : 	else
; 2910 : 	    cur = xmlNewDocNode(parent->doc, ns, name, content);
; 2911 :     } else if ((parent->type == XML_DOCUMENT_NODE) ||

	jmp	SHORT $LN12@xmlNewChil
$LN4@xmlNewChil:
	cmp	eax, 9
	je	SHORT $LN10@xmlNewChil
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN10@xmlNewChil

; 2914 : 	    cur = xmlNewDocNode((xmlDocPtr) parent, NULL, name, content);
; 2915 : 	else
; 2916 : 	    cur = xmlNewDocNode((xmlDocPtr) parent, ns, name, content);
; 2917 :     } else if (parent->type == XML_DOCUMENT_FRAG_NODE) {

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN19@xmlNewChil

; 2918 : 	    cur = xmlNewDocNode( parent->doc, ns, name, content);

	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _ns$[ebp]

; 2919 :     } else {

	jmp	SHORT $LN12@xmlNewChil
$LN10@xmlNewChil:

; 2912 : 	       (parent->type == XML_HTML_DOCUMENT_NODE)) {
; 2913 : 	if (ns == NULL)

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, esi
	test	eax, eax
	jne	SHORT $LN12@xmlNewChil
$LN12@xmlNewChil:

; 2920 : 	return(NULL);
; 2921 :     }
; 2922 :     if (cur == NULL) return(NULL);

	push	DWORD PTR _content$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_xmlNewDocNode
	mov	edx, eax
	add	esp, 16					; 00000010H
	test	edx, edx
	je	SHORT $LN19@xmlNewChil

; 2923 : 
; 2924 :     /*
; 2925 :      * add the new element at the end of the children list.
; 2926 :      */
; 2927 :     cur->type = XML_ELEMENT_NODE;

	mov	DWORD PTR [edx+4], 1

; 2928 :     cur->parent = parent;

	mov	DWORD PTR [edx+20], esi

; 2929 :     cur->doc = parent->doc;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [edx+32], eax

; 2930 :     if (parent->children == NULL) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN16@xmlNewChil

; 2931 :         parent->children = cur;

	mov	DWORD PTR [esi+12], edx

; 2935 : 	prev->next = cur;
; 2936 : 	cur->prev = prev;
; 2937 : 	parent->last = cur;
; 2938 :     }
; 2939 : 
; 2940 :     return(cur);

	mov	eax, edx
	mov	DWORD PTR [esi+16], edx
	pop	esi

; 2941 : }

	pop	ebp
	ret	0
$LN16@xmlNewChil:

; 2932 : 	parent->last = cur;
; 2933 :     } else {
; 2934 :         prev = parent->last;

	mov	ecx, DWORD PTR [esi+16]

; 2935 : 	prev->next = cur;
; 2936 : 	cur->prev = prev;
; 2937 : 	parent->last = cur;
; 2938 :     }
; 2939 : 
; 2940 :     return(cur);

	mov	eax, edx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [edx+28], ecx
	mov	DWORD PTR [esi+16], edx
	pop	esi

; 2941 : }

	pop	ebp
	ret	0
$LN19@xmlNewChil:

; 2920 : 	return(NULL);
; 2921 :     }
; 2922 :     if (cur == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 2941 : }

	pop	ebp
	ret	0
_xmlNewChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewNodeEatName
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlNewNodeEatName PROC					; COMDAT

; 2267 : xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlNewNode

; 2268 :     xmlNodePtr cur;
; 2269 : 
; 2270 :     if (name == NULL) {
; 2271 : #ifdef DEBUG_TREE
; 2272 :         xmlGenericError(xmlGenericErrorContext,
; 2273 : 		"xmlNewNode : name == NULL\n");
; 2274 : #endif
; 2275 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 2296 : }

	pop	ebp
	ret	0
$LN2@xmlNewNode:
	push	esi

; 2276 :     }
; 2277 : 
; 2278 :     /*
; 2279 :      * Allocate a new node and fill the fields.
; 2280 :      */
; 2281 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2282 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewNode

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0O@LNBKNEAL@building?5node@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2283 : 	xmlTreeErrMemory("building node");
; 2284 : 	/* we can't check here that name comes from the doc dictionary */
; 2285 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2296 : }

	pop	ebp
	ret	0
$LN3@xmlNewNode:

; 2286 :     }
; 2287 :     memset(cur, 0, sizeof(xmlNode));
; 2288 :     cur->type = XML_ELEMENT_NODE;
; 2289 : 
; 2290 :     cur->name = name;
; 2291 :     cur->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+36], eax

; 2292 : 
; 2293 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewNode
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewNode

; 2294 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN4@xmlNewNode:

; 2295 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 2296 : }

	pop	ebp
	ret	0
_xmlNewNodeEatName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewNode
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlNewNode PROC					; COMDAT

; 2225 : xmlNewNode(xmlNsPtr ns, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN2@xmlNewNode

; 2226 :     xmlNodePtr cur;
; 2227 : 
; 2228 :     if (name == NULL) {
; 2229 : #ifdef DEBUG_TREE
; 2230 :         xmlGenericError(xmlGenericErrorContext,
; 2231 : 		"xmlNewNode : name == NULL\n");
; 2232 : #endif
; 2233 : 	return(NULL);

	xor	eax, eax

; 2253 : }

	pop	ebp
	ret	0
$LN2@xmlNewNode:
	push	esi

; 2234 :     }
; 2235 : 
; 2236 :     /*
; 2237 :      * Allocate a new node and fill the fields.
; 2238 :      */
; 2239 :     cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));

	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2240 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewNode

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0O@LNBKNEAL@building?5node@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2241 : 	xmlTreeErrMemory("building node");
; 2242 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2253 : }

	pop	ebp
	ret	0
$LN3@xmlNewNode:

; 2243 :     }
; 2244 :     memset(cur, 0, sizeof(xmlNode));

	push	60					; 0000003cH
	push	0
	push	esi
	call	_memset

; 2245 :     cur->type = XML_ELEMENT_NODE;
; 2246 : 
; 2247 :     cur->name = xmlStrdup(name);

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+4], 1
	call	_xmlStrdup
	mov	DWORD PTR [esi+8], eax
	add	esp, 16					; 00000010H

; 2248 :     cur->ns = ns;

	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [esi+36], eax

; 2249 : 
; 2250 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlNewNode
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlNewNode

; 2251 : 	xmlRegisterNodeDefaultValue(cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN4@xmlNewNode:

; 2252 :     return(cur);

	mov	eax, esi
	pop	esi

; 2253 : }

	pop	ebp
	ret	0
_xmlNewNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocNodeEatName
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlNewDocNodeEatName PROC				; COMDAT

; 2353 :               xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	push	edi
	push	DWORD PTR _ns$[ebp]
	call	_xmlNewNodeEatName
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN4@xmlNewDocN

; 2354 :     xmlNodePtr cur;
; 2355 : 
; 2356 :     cur = xmlNewNodeEatName(ns, name);
; 2357 :     if (cur != NULL) {
; 2358 :         cur->doc = doc;

	mov	ecx, DWORD PTR _content$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [esi+32], eax

; 2359 : 	if (content != NULL) {

	test	ecx, ecx
	je	SHORT $LN17@xmlNewDocN

; 2360 : 	    cur->children = xmlStringGetNodeList(doc, content);

	push	ecx
	push	eax
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 2361 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	test	eax, eax
	jne	SHORT $LN12@xmlNewDocN
	mov	DWORD PTR [esi+16], eax

; 2368 :     }
; 2369 :     return(cur);
; 2370 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlNewDocN:

; 2361 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN3@xmlNewDocN
$LL2@xmlNewDocN:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL2@xmlNewDocN
$LN3@xmlNewDocN:
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [esi+16], eax

; 2368 :     }
; 2369 :     return(cur);
; 2370 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlNewDocN:

; 2362 : 	}
; 2363 :     } else {
; 2364 :         /* if name don't come from the doc dictionary free it here */
; 2365 :         if ((name != NULL) && (doc != NULL) &&

	test	edi, edi
	je	SHORT $LN10@xmlNewDocN
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN17@xmlNewDocN
	push	edi
	push	DWORD PTR [eax+80]
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlNewDocN

; 2366 : 	    (!(xmlDictOwns(doc->dict, name))))
; 2367 : 	    xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlNewDocN:

; 2368 :     }
; 2369 :     return(cur);
; 2370 : }

	mov	eax, esi
$LN10@xmlNewDocN:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlNewDocNodeEatName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocNode
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_content$ = 20						; size = 4
_xmlNewDocNode PROC					; COMDAT

; 2316 :               const xmlChar *name, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlNewDocN

; 2317 :     xmlNodePtr cur;
; 2318 : 
; 2319 :     if ((doc != NULL) && (doc->dict != NULL))

	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN4@xmlNewDocN

; 2320 :         cur = xmlNewNodeEatName(ns, (xmlChar *)

	push	-1
	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictLookup
	push	eax
	push	DWORD PTR _ns$[ebp]
	call	_xmlNewNodeEatName
	add	esp, 20					; 00000014H
	jmp	SHORT $LN18@xmlNewDocN
$LN4@xmlNewDocN:

; 2321 : 	                        xmlDictLookup(doc->dict, name, -1));
; 2322 :     else
; 2323 : 	cur = xmlNewNode(ns, name);

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ns$[ebp]
	call	_xmlNewNode
	add	esp, 8
$LN18@xmlNewDocN:

; 2324 :     if (cur != NULL) {

	mov	esi, eax
	test	esi, esi
	je	SHORT $LN17@xmlNewDocN

; 2325 :         cur->doc = doc;
; 2326 : 	if (content != NULL) {

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [esi+32], edi
	test	eax, eax
	je	SHORT $LN17@xmlNewDocN

; 2327 : 	    cur->children = xmlStringGetNodeList(doc, content);

	push	eax
	push	edi
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 2328 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	test	eax, eax
	jne	SHORT $LN12@xmlNewDocN
	mov	DWORD PTR [esi+16], eax

; 2329 : 	}
; 2330 :     }
; 2331 : 
; 2332 :     return(cur);
; 2333 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlNewDocN:

; 2328 : 	    UPDATE_LAST_CHILD_AND_PARENT(cur)

	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	je	SHORT $LN3@xmlNewDocN
$LL2@xmlNewDocN:
	mov	DWORD PTR [eax+20], esi
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	lea	ecx, DWORD PTR [eax+24]
	jne	SHORT $LL2@xmlNewDocN
$LN3@xmlNewDocN:
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [esi+16], eax
$LN17@xmlNewDocN:

; 2329 : 	}
; 2330 :     }
; 2331 : 
; 2332 :     return(cur);
; 2333 : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlNewDocNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyDoc
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_recursive$ = 12					; size = 4
_xmlCopyDoc PROC					; COMDAT

; 4528 : xmlCopyDoc(xmlDocPtr doc, int recursive) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN114@xmlCopyDoc

; 4529 :     xmlDocPtr ret;
; 4530 : 
; 4531 :     if (doc == NULL) return(NULL);
; 4532 :     ret = xmlNewDoc(doc->version);

	push	DWORD PTR [edi+56]
	call	_xmlNewDoc
	mov	esi, eax
	add	esp, 4

; 4533 :     if (ret == NULL) return(NULL);

	test	esi, esi
	je	$LN114@xmlCopyDoc

; 4534 :     if (doc->name != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlCopyDoc

; 4535 :         ret->name = xmlMemStrdup(doc->name);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN6@xmlCopyDoc:

; 4536 :     if (doc->encoding != NULL)

	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN7@xmlCopyDoc

; 4537 :         ret->encoding = xmlStrdup(doc->encoding);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+60], eax
$LN7@xmlCopyDoc:

; 4538 :     if (doc->URL != NULL)

	mov	eax, DWORD PTR [edi+72]
	test	eax, eax
	je	SHORT $LN8@xmlCopyDoc

; 4539 :         ret->URL = xmlStrdup(doc->URL);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+72], eax
$LN8@xmlCopyDoc:

; 4540 :     ret->charset = doc->charset;
; 4541 :     ret->compression = doc->compression;
; 4542 :     ret->standalone = doc->standalone;
; 4543 :     if (!recursive) return(ret);

	cmp	DWORD PTR _recursive$[ebp], 0
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
	je	$LN3@xmlCopyDoc

; 4544 : 
; 4545 :     ret->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 4546 :     ret->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 4547 : #ifdef LIBXML_TREE_ENABLED
; 4548 :     if (doc->intSubset != NULL) {

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN10@xmlCopyDoc

; 4549 :         ret->intSubset = xmlCopyDtd(doc->intSubset);

	push	eax
	call	_xmlCopyDtd
	add	esp, 4
	mov	DWORD PTR [esi+44], eax

; 4550 : 	if (ret->intSubset == NULL) {

	push	esi
	test	eax, eax
	jne	SHORT $LN11@xmlCopyDoc

; 4551 : 	    xmlFreeDoc(ret);

	call	_xmlFreeDoc
	add	esp, 4
$LN114@xmlCopyDoc:

; 4574 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN11@xmlCopyDoc:

; 4552 : 	    return(NULL);
; 4553 : 	}
; 4554 : 	xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);

	push	eax
	call	_xmlSetTreeDoc

; 4555 : 	ret->intSubset->parent = ret;

	mov	eax, DWORD PTR [esi+44]
	add	esp, 8
	mov	DWORD PTR [eax+20], esi
$LN10@xmlCopyDoc:

; 4556 :     }
; 4557 : #endif
; 4558 :     if (doc->oldNs != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN12@xmlCopyDoc

; 4559 :         ret->oldNs = xmlCopyNamespaceList(doc->oldNs);

	push	eax
	call	_xmlCopyNamespaceList
	add	esp, 4
	mov	DWORD PTR [esi+52], eax
$LN12@xmlCopyDoc:

; 4560 :     if (doc->children != NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN3@xmlCopyDoc

; 4561 : 	xmlNodePtr tmp;
; 4562 : 
; 4563 : 	ret->children = xmlStaticCopyNodeList(doc->children, ret,

	push	esi
	push	esi
	push	eax
	call	_xmlStaticCopyNodeList
	mov	ecx, eax

; 4564 : 		                               (xmlNodePtr)ret);
; 4565 : 	ret->last = NULL;

	mov	DWORD PTR [esi+16], 0
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+12], ecx

; 4566 : 	tmp = ret->children;
; 4567 : 	while (tmp != NULL) {

	test	ecx, ecx
	je	SHORT $LN3@xmlCopyDoc
	npad	3
$LL2@xmlCopyDoc:

; 4568 : 	    if (tmp->next == NULL)

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN113@xmlCopyDoc

; 4569 : 	        ret->last = tmp;

	mov	DWORD PTR [esi+16], ecx
	mov	eax, DWORD PTR [ecx+24]
$LN113@xmlCopyDoc:

; 4570 : 	    tmp = tmp->next;

	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlCopyDoc
$LN3@xmlCopyDoc:
	pop	edi

; 4571 : 	}
; 4572 :     }
; 4573 :     return(ret);

	mov	eax, esi

; 4574 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCopyDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyDtd
_TEXT	SEGMENT
_dtd$ = 8						; size = 4
_xmlCopyDtd PROC					; COMDAT

; 4439 : xmlCopyDtd(xmlDtdPtr dtd) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _dtd$[ebp]
	xor	ebx, ebx
	test	esi, esi
	je	$LN40@xmlCopyDtd

; 4440 :     xmlDtdPtr ret;
; 4441 :     xmlNodePtr cur, p = NULL, q;
; 4442 : 
; 4443 :     if (dtd == NULL) return(NULL);
; 4444 :     ret = xmlNewDtd(NULL, dtd->name, dtd->ExternalID, dtd->SystemID);

	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlNewDtd
	mov	edi, eax
	add	esp, 16					; 00000010H

; 4445 :     if (ret == NULL) return(NULL);

	test	edi, edi
	je	$LN40@xmlCopyDtd

; 4446 :     if (dtd->entities != NULL)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN8@xmlCopyDtd

; 4447 :         ret->entities = (void *) xmlCopyEntitiesTable(

	push	eax
	call	_xmlCopyEntitiesTable
	add	esp, 4
	mov	DWORD PTR [edi+48], eax
$LN8@xmlCopyDtd:

; 4448 : 	                    (xmlEntitiesTablePtr) dtd->entities);
; 4449 :     if (dtd->notations != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN9@xmlCopyDtd

; 4450 :         ret->notations = (void *) xmlCopyNotationTable(

	push	eax
	call	_xmlCopyNotationTable
	add	esp, 4
	mov	DWORD PTR [edi+36], eax
$LN9@xmlCopyDtd:

; 4451 : 	                    (xmlNotationTablePtr) dtd->notations);
; 4452 :     if (dtd->elements != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN10@xmlCopyDtd

; 4453 :         ret->elements = (void *) xmlCopyElementTable(

	push	eax
	call	_xmlCopyElementTable
	add	esp, 4
	mov	DWORD PTR [edi+40], eax
$LN10@xmlCopyDtd:

; 4454 : 	                    (xmlElementTablePtr) dtd->elements);
; 4455 :     if (dtd->attributes != NULL)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN11@xmlCopyDtd

; 4456 :         ret->attributes = (void *) xmlCopyAttributeTable(

	push	eax
	call	_xmlCopyAttributeTable
	add	esp, 4
	mov	DWORD PTR [edi+44], eax
$LN11@xmlCopyDtd:

; 4457 : 	                    (xmlAttributeTablePtr) dtd->attributes);
; 4458 :     if (dtd->pentities != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN12@xmlCopyDtd

; 4459 : 	ret->pentities = (void *) xmlCopyEntitiesTable(

	push	eax
	call	_xmlCopyEntitiesTable
	add	esp, 4
	mov	DWORD PTR [edi+60], eax
$LN12@xmlCopyDtd:

; 4460 : 			    (xmlEntitiesTablePtr) dtd->pentities);
; 4461 : 
; 4462 :     cur = dtd->children;

	mov	esi, DWORD PTR [esi+12]

; 4463 :     while (cur != NULL) {

	test	esi, esi
	je	$LN3@xmlCopyDtd
$LL2@xmlCopyDtd:

; 4464 : 	q = NULL;
; 4465 : 
; 4466 : 	if (cur->type == XML_ENTITY_DECL) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN13@xmlCopyDtd

; 4467 : 	    xmlEntityPtr tmp = (xmlEntityPtr) cur;
; 4468 : 	    switch (tmp->etype) {

	mov	eax, DWORD PTR [esi+48]
	dec	eax
	cmp	eax, 4
	ja	$LN37@xmlCopyDtd
	jmp	DWORD PTR $LN43@xmlCopyDtd[eax*4]
$LN15@xmlCopyDtd:

; 172  :     if((dtd != NULL) && (dtd->entities != NULL)) {

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	$LN37@xmlCopyDtd

; 173  : 	table = (xmlEntitiesTablePtr) dtd->entities;
; 174  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	jmp	SHORT $LN22@xmlCopyDtd
$LN16@xmlCopyDtd:

; 193  :     if ((dtd != NULL) && (dtd->pentities != NULL)) {

	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN37@xmlCopyDtd

; 194  : 	table = (xmlEntitiesTablePtr) dtd->pentities;
; 195  : 	return((xmlEntityPtr) xmlHashLookup(table, name));

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlHashLookup
	add	esp, 8
	jmp	SHORT $LN22@xmlCopyDtd
$LN13@xmlCopyDtd:

; 4469 : 		case XML_INTERNAL_GENERAL_ENTITY:
; 4470 : 		case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 4471 : 		case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 4472 : 		    q = (xmlNodePtr) xmlGetEntityFromDtd(ret, tmp->name);
; 4473 : 		    break;
; 4474 : 		case XML_INTERNAL_PARAMETER_ENTITY:
; 4475 : 		case XML_EXTERNAL_PARAMETER_ENTITY:
; 4476 : 		    q = (xmlNodePtr)
; 4477 : 			xmlGetParameterEntityFromDtd(ret, tmp->name);
; 4478 : 		    break;
; 4479 : 		case XML_INTERNAL_PREDEFINED_ENTITY:
; 4480 : 		    break;
; 4481 : 	    }
; 4482 : 	} else if (cur->type == XML_ELEMENT_DECL) {

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN18@xmlCopyDtd

; 4483 : 	    xmlElementPtr tmp = (xmlElementPtr) cur;
; 4484 : 	    q = (xmlNodePtr)

	push	DWORD PTR [esi+48]
	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlGetDtdQElementDesc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@xmlCopyDtd
$LN18@xmlCopyDtd:

; 4485 : 		xmlGetDtdQElementDesc(ret, tmp->name, tmp->prefix);
; 4486 : 	} else if (cur->type == XML_ATTRIBUTE_DECL) {

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN20@xmlCopyDtd

; 4487 : 	    xmlAttributePtr tmp = (xmlAttributePtr) cur;
; 4488 : 	    q = (xmlNodePtr)

	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+60]
	push	edi
	call	_xmlGetDtdQAttrDesc
	jmp	SHORT $LN41@xmlCopyDtd
$LN20@xmlCopyDtd:

; 4489 : 		xmlGetDtdQAttrDesc(ret, tmp->elem, tmp->name, tmp->prefix);
; 4490 : 	} else if (cur->type == XML_COMMENT_NODE) {

	cmp	eax, 8
	jne	SHORT $LN37@xmlCopyDtd

; 4377 :     ret = xmlStaticCopyNode(node, NULL, NULL, extended);

	push	0
	push	0
	push	0
	push	esi
	call	_xmlStaticCopyNode
$LN41@xmlCopyDtd:

; 4491 : 	    q = xmlCopyNode(cur, 0);
; 4492 : 	}
; 4493 : 
; 4494 : 	if (q == NULL) {

	add	esp, 16					; 00000010H
$LN22@xmlCopyDtd:
	test	eax, eax
	je	SHORT $LN37@xmlCopyDtd

; 4495 : 	    cur = cur->next;
; 4496 : 	    continue;
; 4497 : 	}
; 4498 : 
; 4499 : 	if (p == NULL)

	test	ebx, ebx
	jne	SHORT $LN24@xmlCopyDtd

; 4500 : 	    ret->children = q;

	mov	DWORD PTR [edi+12], eax
	jmp	SHORT $LN25@xmlCopyDtd
$LN24@xmlCopyDtd:

; 4501 : 	else
; 4502 : 	    p->next = q;

	mov	DWORD PTR [ebx+24], eax
$LN25@xmlCopyDtd:

; 4503 : 
; 4504 : 	q->prev = p;

	mov	DWORD PTR [eax+28], ebx

; 4505 : 	q->parent = (xmlNodePtr) ret;
; 4506 : 	q->next = NULL;
; 4507 : 	ret->last = q;
; 4508 : 	p = q;

	mov	ebx, eax
	mov	DWORD PTR [eax+20], edi
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [edi+16], eax
$LN37@xmlCopyDtd:

; 4463 :     while (cur != NULL) {

	mov	eax, DWORD PTR [esi+24]
	mov	esi, eax
	test	eax, eax
	jne	$LL2@xmlCopyDtd
$LN3@xmlCopyDtd:

; 4509 : 	cur = cur->next;
; 4510 :     }
; 4511 : 
; 4512 :     return(ret);

	mov	eax, edi
	pop	edi

; 4513 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN40@xmlCopyDtd:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN43@xmlCopyDtd:
	DD	$LN15@xmlCopyDtd
	DD	$LN15@xmlCopyDtd
	DD	$LN15@xmlCopyDtd
	DD	$LN16@xmlCopyDtd
	DD	$LN16@xmlCopyDtd
_xmlCopyDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyPropList
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_target$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlCopyPropList PROC					; COMDAT

; 4127 : xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _target$[ebp]
	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _ret$1$[ebp], eax
	test	ebx, ebx
	je	SHORT $LN11@xmlCopyPro

; 4128 :     xmlAttrPtr ret = NULL;
; 4129 :     xmlAttrPtr p = NULL,q;
; 4130 : 
; 4131 :     if ((target != NULL) && (target->type != XML_ELEMENT_NODE))

	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN12@xmlCopyPro
$LN11@xmlCopyPro:

; 4132 :         return(NULL);
; 4133 :     while (cur != NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlCopyPro
	npad	4
$LL2@xmlCopyPro:

; 4114 : 	return xmlCopyPropInternal(NULL, target, cur);

	push	esi
	push	ebx
	push	0
	call	_xmlCopyPropInternal
	add	esp, 12					; 0000000cH

; 4134 :         q = xmlCopyProp(target, cur);
; 4135 : 	if (q == NULL)

	test	eax, eax
	je	SHORT $LN12@xmlCopyPro

; 4137 : 	if (p == NULL) {

	test	edi, edi
	jne	SHORT $LN6@xmlCopyPro

; 4138 : 	    ret = p = q;

	mov	edi, eax
	mov	DWORD PTR _ret$1$[ebp], eax

; 4139 : 	} else {

	jmp	SHORT $LN7@xmlCopyPro
$LN6@xmlCopyPro:

; 4140 : 	    p->next = q;

	mov	DWORD PTR [edi+24], eax

; 4141 : 	    q->prev = p;

	mov	DWORD PTR [eax+28], edi

; 4142 : 	    p = q;

	mov	edi, eax
	mov	eax, DWORD PTR _ret$1$[ebp]
$LN7@xmlCopyPro:

; 4143 : 	}
; 4144 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlCopyPro

; 4145 :     }
; 4146 :     return(ret);
; 4147 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlCopyPro:

; 4136 : 	    return(NULL);

	xor	eax, eax
$LN1@xmlCopyPro:
	pop	edi

; 4145 :     }
; 4146 :     return(ret);
; 4147 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCopyPropList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCopyProp
_TEXT	SEGMENT
_target$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlCopyProp PROC					; COMDAT

; 4113 : xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _target$[ebp]
	push	0
	call	_xmlCopyPropInternal
	add	esp, 12					; 0000000cH

; 4114 : 	return xmlCopyPropInternal(NULL, target, cur);
; 4115 : }

	pop	ebp
	ret	0
_xmlCopyProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeProp
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeProp PROC					; COMDAT

; 2084 : xmlFreeProp(xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN1@xmlFreePro

; 2085 :     xmlDictPtr dict = NULL;
; 2086 :     if (cur == NULL) return;
; 2087 : 
; 2088 :     if (cur->doc != NULL) dict = cur->doc->dict;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN3@xmlFreePro
	mov	edi, DWORD PTR [eax+80]
$LN3@xmlFreePro:

; 2089 : 
; 2090 :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN4@xmlFreePro
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlFreePro

; 2091 : 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN4@xmlFreePro:

; 2092 : 
; 2093 :     /* Check for ID removal -> leading to invalid references ! */
; 2094 :     if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN5@xmlFreePro
	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN5@xmlFreePro

; 2095 : 	    xmlRemoveID(cur->doc, cur);

	push	esi
	push	eax
	call	_xmlRemoveID
	add	esp, 8
$LN5@xmlFreePro:

; 2096 :     }
; 2097 :     if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@xmlFreePro
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN6@xmlFreePro:

; 2098 :     DICT_FREE(cur->name)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@xmlFreePro
	test	edi, edi
	je	SHORT $LN8@xmlFreePro
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlFreePro
$LN8@xmlFreePro:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlFreePro:

; 2099 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreePro:

; 2100 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlFreeProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreePropList
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreePropList PROC					; COMDAT

; 2067 : xmlFreePropList(xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlFreePro
	push	ebx
	push	edi
	npad	5
$LL2@xmlFreePro:

; 2088 :     if (cur->doc != NULL) dict = cur->doc->dict;

	mov	eax, DWORD PTR [esi+32]
	xor	edi, edi

; 2068 :     xmlAttrPtr next;
; 2069 :     if (cur == NULL) return;
; 2070 :     while (cur != NULL) {
; 2071 :         next = cur->next;

	mov	ebx, DWORD PTR [esi+24]

; 2088 :     if (cur->doc != NULL) dict = cur->doc->dict;

	test	eax, eax
	je	SHORT $LN8@xmlFreePro
	mov	edi, DWORD PTR [eax+80]
$LN8@xmlFreePro:

; 2089 : 
; 2090 :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN9@xmlFreePro
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlFreePro

; 2091 : 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN9@xmlFreePro:

; 2092 : 
; 2093 :     /* Check for ID removal -> leading to invalid references ! */
; 2094 :     if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN10@xmlFreePro
	cmp	DWORD PTR [esi+40], 2
	jne	SHORT $LN10@xmlFreePro

; 2095 : 	    xmlRemoveID(cur->doc, cur);

	push	esi
	push	eax
	call	_xmlRemoveID
	add	esp, 8
$LN10@xmlFreePro:

; 2096 :     }
; 2097 :     if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN11@xmlFreePro
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN11@xmlFreePro:

; 2098 :     DICT_FREE(cur->name)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN12@xmlFreePro
	test	edi, edi
	je	SHORT $LN13@xmlFreePro
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlFreePro
$LN13@xmlFreePro:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreePro:

; 2099 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2072 :         xmlFreeProp(cur);
; 2073 : 	cur = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlFreePro
	pop	edi
	pop	ebx
$LN3@xmlFreePro:
	pop	esi

; 2074 :     }
; 2075 : }

	pop	ebp
	ret	0
_xmlFreePropList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewNsPropEatName
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlNewNsPropEatName PROC				; COMDAT

; 1990 :            const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlNewNsPr

; 2001 : }

	pop	ebp
	ret	0
$LN2@xmlNewNsPr:

; 1991 : 
; 1992 :     if (name == NULL) {
; 1993 : #ifdef DEBUG_TREE
; 1994 :         xmlGenericError(xmlGenericErrorContext,
; 1995 : 		"xmlNewNsPropEatName : name == NULL\n");
; 1996 : #endif
; 1997 : 	return(NULL);
; 1998 :     }
; 1999 : 
; 2000 :     return xmlNewPropInternal(node, ns, name, value, 1);

	push	1
	push	DWORD PTR _value$[ebp]
	push	eax
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlNewPropInternal
	add	esp, 20					; 00000014H

; 2001 : }

	pop	ebp
	ret	0
_xmlNewNsPropEatName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewNsProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_name$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlNewNsProp PROC					; COMDAT

; 1965 :            const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlNewNsPr

; 1976 : }

	pop	ebp
	ret	0
$LN2@xmlNewNsPr:

; 1966 : 
; 1967 :     if (name == NULL) {
; 1968 : #ifdef DEBUG_TREE
; 1969 :         xmlGenericError(xmlGenericErrorContext,
; 1970 : 		"xmlNewNsProp : name == NULL\n");
; 1971 : #endif
; 1972 : 	return(NULL);
; 1973 :     }
; 1974 : 
; 1975 :     return xmlNewPropInternal(node, ns, name, value, 0);

	push	0
	push	DWORD PTR _value$[ebp]
	push	eax
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlNewPropInternal
	add	esp, 20					; 00000014H

; 1976 : }

	pop	ebp
	ret	0
_xmlNewNsProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewProp
_TEXT	SEGMENT
_node$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlNewProp PROC					; COMDAT

; 1939 : xmlNewProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlNewProp

; 1950 : }

	pop	ebp
	ret	0
$LN2@xmlNewProp:

; 1940 : 
; 1941 :     if (name == NULL) {
; 1942 : #ifdef DEBUG_TREE
; 1943 :         xmlGenericError(xmlGenericErrorContext,
; 1944 : 		"xmlNewProp : name == NULL\n");
; 1945 : #endif
; 1946 : 	return(NULL);
; 1947 :     }
; 1948 : 
; 1949 : 	return xmlNewPropInternal(node, NULL, name, value, 0);

	push	0
	push	DWORD PTR _value$[ebp]
	push	eax
	push	0
	push	DWORD PTR _node$[ebp]
	call	_xmlNewPropInternal
	add	esp, 20					; 00000014H

; 1950 : }

	pop	ebp
	ret	0
_xmlNewProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDocProp
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlNewDocProp PROC					; COMDAT

; 2013 : xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	jne	SHORT $LN4@xmlNewDocP

; 2014 :     xmlAttrPtr cur;
; 2015 : 
; 2016 :     if (name == NULL) {
; 2017 : #ifdef DEBUG_TREE
; 2018 :         xmlGenericError(xmlGenericErrorContext,
; 2019 : 		"xmlNewDocProp : name == NULL\n");
; 2020 : #endif
; 2021 : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 2058 : }

	pop	ebp
	ret	0
$LN4@xmlNewDocP:
	push	esi

; 2022 :     }
; 2023 : 
; 2024 :     /*
; 2025 :      * Allocate a new property and fill the fields.
; 2026 :      */
; 2027 :     cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2028 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlNewDocP

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BD@EEPKIILJ@building?5attribute@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2029 : 	xmlTreeErrMemory("building attribute");
; 2030 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx

; 2058 : }

	pop	ebp
	ret	0
$LN5@xmlNewDocP:
	push	edi

; 2031 :     }
; 2032 :     memset(cur, 0, sizeof(xmlAttr));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 2033 :     cur->type = XML_ATTRIBUTE_NODE;
; 2034 : 
; 2035 :     if ((doc != NULL) && (doc->dict != NULL))

	mov	edi, DWORD PTR _doc$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 2
	test	edi, edi
	je	SHORT $LN6@xmlNewDocP
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN6@xmlNewDocP

; 2036 : 	cur->name = xmlDictLookup(doc->dict, name, -1);

	push	-1
	push	ebx
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@xmlNewDocP
$LN6@xmlNewDocP:

; 2037 :     else
; 2038 : 	cur->name = xmlStrdup(name);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
$LN7@xmlNewDocP:

; 2039 :     cur->doc = doc;

	mov	DWORD PTR [esi+8], eax

; 2040 :     if (value != NULL) {

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [esi+32], edi
	test	eax, eax
	je	SHORT $LN3@xmlNewDocP

; 2041 : 	xmlNodePtr tmp;
; 2042 : 
; 2043 : 	cur->children = xmlStringGetNodeList(doc, value);

	push	eax
	push	edi
	call	_xmlStringGetNodeList
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 2044 : 	cur->last = NULL;

	mov	DWORD PTR [esi+16], 0

; 2045 : 
; 2046 : 	tmp = cur->children;
; 2047 : 	while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlNewDocP
$LL2@xmlNewDocP:

; 2048 : 	    tmp->parent = (xmlNodePtr) cur;
; 2049 : 	    if (tmp->next == NULL)

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], esi
	test	ecx, ecx
	jne	SHORT $LN18@xmlNewDocP

; 2050 : 		cur->last = tmp;

	mov	DWORD PTR [esi+16], eax
	mov	ecx, DWORD PTR [eax+24]
$LN18@xmlNewDocP:

; 2051 : 	    tmp = tmp->next;

	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LL2@xmlNewDocP
$LN3@xmlNewDocP:

; 2052 : 	}
; 2053 :     }
; 2054 : 
; 2055 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	pop	edi
	je	SHORT $LN10@xmlNewDocP
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@xmlNewDocP

; 2056 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
$LN10@xmlNewDocP:

; 2057 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2058 : }

	pop	ebp
	ret	0
_xmlNewDocProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeDoc
_TEXT	SEGMENT
tv433 = 8						; size = 4
_cur$ = 8						; size = 4
_xmlFreeDoc PROC					; COMDAT

; 1209 : xmlFreeDoc(xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN20@xmlFreeDoc

; 1210 :     xmlDtdPtr extSubset, intSubset;
; 1211 :     xmlDictPtr dict = NULL;
; 1212 : 
; 1213 :     if (cur == NULL) {
; 1214 : #ifdef DEBUG_TREE
; 1215 :         xmlGenericError(xmlGenericErrorContext,
; 1216 : 		"xmlFreeDoc : document == NULL\n");
; 1217 : #endif
; 1218 : 	return;
; 1219 :     }
; 1220 : #ifdef LIBXML_DEBUG_RUNTIME
; 1221 : #ifdef LIBXML_DEBUG_ENABLED
; 1222 :     xmlDebugCheckDocument(stderr, cur);
; 1223 : #endif
; 1224 : #endif
; 1225 : 
; 1226 :     if (cur != NULL) dict = cur->dict;

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	push	edi
	mov	edi, DWORD PTR [esi+80]

; 1227 : 
; 1228 :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	je	SHORT $LN4@xmlFreeDoc
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlFreeDoc

; 1229 : 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN4@xmlFreeDoc:

; 1230 : 
; 1231 :     /*
; 1232 :      * Do this before freeing the children list to avoid ID lookups
; 1233 :      */
; 1234 :     if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN5@xmlFreeDoc
	push	eax
	call	_xmlFreeIDTable
	add	esp, 4
$LN5@xmlFreeDoc:

; 1235 :     cur->ids = NULL;
; 1236 :     if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [esi+64], 0
	test	eax, eax
	je	SHORT $LN6@xmlFreeDoc
	push	eax
	call	_xmlFreeRefTable
	add	esp, 4
$LN6@xmlFreeDoc:

; 1237 :     cur->refs = NULL;
; 1238 :     extSubset = cur->extSubset;

	mov	ecx, DWORD PTR [esi+48]

; 1239 :     intSubset = cur->intSubset;
; 1240 :     if (intSubset == extSubset)
; 1241 : 	extSubset = NULL;
; 1242 :     if (extSubset != NULL) {

	xor	eax, eax
	push	ebx
	mov	ebx, DWORD PTR [esi+44]
	cmp	ebx, ecx
	mov	DWORD PTR [esi+68], 0
	cmovne	eax, ecx
	mov	DWORD PTR tv433[ebp], eax
	test	eax, eax
	je	SHORT $LN8@xmlFreeDoc

; 1243 : 	xmlUnlinkNode((xmlNodePtr) cur->extSubset);

	push	ecx
	call	_xmlUnlinkNode

; 1244 : 	cur->extSubset = NULL;
; 1245 : 	xmlFreeDtd(extSubset);

	push	DWORD PTR tv433[ebp]
	mov	DWORD PTR [esi+48], 0
	call	_xmlFreeDtd
	add	esp, 8
$LN8@xmlFreeDoc:

; 1246 :     }
; 1247 :     if (intSubset != NULL) {

	test	ebx, ebx
	je	SHORT $LN9@xmlFreeDoc

; 1248 : 	xmlUnlinkNode((xmlNodePtr) cur->intSubset);

	push	DWORD PTR [esi+44]
	call	_xmlUnlinkNode

; 1249 : 	cur->intSubset = NULL;
; 1250 : 	xmlFreeDtd(intSubset);

	push	ebx
	mov	DWORD PTR [esi+44], 0
	call	_xmlFreeDtd
	add	esp, 8
$LN9@xmlFreeDoc:

; 1251 :     }
; 1252 : 
; 1253 :     if (cur->children != NULL) xmlFreeNodeList(cur->children);

	mov	eax, DWORD PTR [esi+12]
	pop	ebx
	test	eax, eax
	je	SHORT $LN10@xmlFreeDoc
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4
$LN10@xmlFreeDoc:

; 1254 :     if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN11@xmlFreeDoc
	push	eax
	call	_xmlFreeNsList
	add	esp, 4
$LN11@xmlFreeDoc:

; 1255 : 
; 1256 :     DICT_FREE(cur->version)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN12@xmlFreeDoc
	test	edi, edi
	je	SHORT $LN13@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlFreeDoc
$LN13@xmlFreeDoc:
	push	DWORD PTR [esi+56]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlFreeDoc:

; 1257 :     DICT_FREE(cur->name)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN14@xmlFreeDoc
	test	edi, edi
	je	SHORT $LN15@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlFreeDoc
$LN15@xmlFreeDoc:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlFreeDoc:

; 1258 :     DICT_FREE(cur->encoding)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN16@xmlFreeDoc
	test	edi, edi
	je	SHORT $LN17@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlFreeDoc
$LN17@xmlFreeDoc:
	push	DWORD PTR [esi+60]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlFreeDoc:

; 1259 :     DICT_FREE(cur->URL)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN18@xmlFreeDoc
	test	edi, edi
	je	SHORT $LN19@xmlFreeDoc
	push	eax
	push	edi
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlFreeDoc
$LN19@xmlFreeDoc:
	push	DWORD PTR [esi+72]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlFreeDoc:

; 1260 :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1261 :     if (dict) xmlDictFree(dict);

	test	edi, edi
	je	SHORT $LN58@xmlFreeDoc
	push	edi
	call	_xmlDictFree
	add	esp, 4
$LN58@xmlFreeDoc:
	pop	edi
$LN20@xmlFreeDoc:
	pop	esi

; 1262 : }

	pop	ebp
	ret	0
_xmlFreeDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDoc
_TEXT	SEGMENT
_version$ = 8						; size = 4
_xmlNewDoc PROC						; COMDAT

; 1162 : xmlNewDoc(const xmlChar *version) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	96					; 00000060H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN3@xmlNewDoc

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0N@LKACPEIE@building?5doc@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1163 :     xmlDocPtr cur;
; 1164 : 
; 1165 :     if (version == NULL)
; 1166 : 	version = (const xmlChar *) "1.0";
; 1167 : 
; 1168 :     /*
; 1169 :      * Allocate a new document and fill the fields.
; 1170 :      */
; 1171 :     cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
; 1172 :     if (cur == NULL) {
; 1173 : 	xmlTreeErrMemory("building doc");
; 1174 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1200 : }

	pop	ebp
	ret	0
$LN3@xmlNewDoc:

; 1175 :     }
; 1176 :     memset(cur, 0, sizeof(xmlDoc));

	push	96					; 00000060H
	push	0
	push	esi
	call	_memset
	mov	eax, DWORD PTR _version$[ebp]
	mov	ecx, OFFSET ??_C@_03HLLJOCDO@1?40@
	test	eax, eax

; 1177 :     cur->type = XML_DOCUMENT_NODE;

	mov	DWORD PTR [esi+4], 9
	cmovne	ecx, eax

; 1178 : 
; 1179 :     cur->version = xmlStrdup(version);

	push	ecx
	call	_xmlStrdup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+56], eax

; 1180 :     if (cur->version == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlNewDoc

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0N@LKACPEIE@building?5doc@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 1181 : 	xmlTreeErrMemory("building doc");
; 1182 : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 1183 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1200 : }

	pop	ebp
	ret	0
$LN4@xmlNewDoc:

; 1184 :     }
; 1185 :     cur->standalone = -1;

	mov	DWORD PTR [esi+40], -1

; 1186 :     cur->compression = -1; /* not initialized */

	mov	DWORD PTR [esi+36], -1

; 1187 :     cur->doc = cur;

	mov	DWORD PTR [esi+32], esi

; 1188 :     cur->parseFlags = 0;

	mov	DWORD PTR [esi+88], 0

; 1189 :     cur->properties = XML_DOC_USERBUILT;

	mov	DWORD PTR [esi+92], 32			; 00000020H

; 1190 :     /*
; 1191 :      * The in memory encoding is always UTF8
; 1192 :      * This field will never change and would
; 1193 :      * be obsolete if not for binary compatibility.
; 1194 :      */
; 1195 :     cur->charset = XML_CHAR_ENCODING_UTF8;

	mov	DWORD PTR [esi+76], 1

; 1196 : 
; 1197 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN5@xmlNewDoc
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlNewDoc

; 1198 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN5@xmlNewDoc:

; 1199 :     return(cur);

	mov	eax, esi
	pop	esi

; 1200 : }

	pop	ebp
	ret	0
_xmlNewDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeNsList
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeNsList PROC					; COMDAT

; 847  : xmlFreeNsList(xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFreeNsL
	push	edi
$LL2@xmlFreeNsL:

; 835  :     if (cur->href != NULL) xmlFree((char *) cur->href);

	mov	eax, DWORD PTR [esi+8]

; 848  :     xmlNsPtr next;
; 849  :     if (cur == NULL) {
; 850  : #ifdef DEBUG_TREE
; 851  :         xmlGenericError(xmlGenericErrorContext,
; 852  : 		"xmlFreeNsList : ns == NULL\n");
; 853  : #endif
; 854  : 	return;
; 855  :     }
; 856  :     while (cur != NULL) {
; 857  :         next = cur->next;

	mov	edi, DWORD PTR [esi]

; 835  :     if (cur->href != NULL) xmlFree((char *) cur->href);

	test	eax, eax
	je	SHORT $LN8@xmlFreeNsL
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlFreeNsL:

; 836  :     if (cur->prefix != NULL) xmlFree((char *) cur->prefix);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@xmlFreeNsL
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeNsL:

; 837  :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 858  :         xmlFreeNs(cur);
; 859  : 	cur = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlFreeNsL
	pop	edi
$LN3@xmlFreeNsL:
	pop	esi

; 860  :     }
; 861  : }

	pop	ebp
	ret	0
_xmlFreeNsList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeNs
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlFreeNs PROC						; COMDAT

; 827  : xmlFreeNs(xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeNs

; 828  :     if (cur == NULL) {
; 829  : #ifdef DEBUG_TREE
; 830  :         xmlGenericError(xmlGenericErrorContext,
; 831  : 		"xmlFreeNs : ns == NULL\n");
; 832  : #endif
; 833  : 	return;
; 834  :     }
; 835  :     if (cur->href != NULL) xmlFree((char *) cur->href);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlFreeNs
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeNs:

; 836  :     if (cur->prefix != NULL) xmlFree((char *) cur->prefix);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlFreeNs
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlFreeNs:

; 837  :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeNs:
	pop	esi

; 838  : }

	pop	ebp
	ret	0
_xmlFreeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewNs
_TEXT	SEGMENT
_node$ = 8						; size = 4
_href$ = 12						; size = 4
_prefix$ = 16						; size = 4
_xmlNewNs PROC						; COMDAT

; 734  : xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlNewNs

; 735  :     xmlNsPtr cur;
; 736  : 
; 737  :     if ((node != NULL) && (node->type != XML_ELEMENT_NODE))

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN29@xmlNewNs
$LN4@xmlNewNs:

; 738  : 	return(NULL);
; 739  : 
; 740  :     if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {

	mov	ebx, DWORD PTR _prefix$[ebp]
	test	ebx, ebx
	je	SHORT $LN6@xmlNewNs
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlNewNs

; 741  :         /* xml namespace is predefined, no need to add it */
; 742  :         if (xmlStrEqual(href, XML_XML_NAMESPACE))

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	DWORD PTR _href$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlNewNs
$LN29@xmlNewNs:
	pop	edi

; 743  :             return(NULL);

	xor	eax, eax

; 797  : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlNewNs:
	push	esi

; 744  : 
; 745  :         /*
; 746  :          * Problem, this is an attempt to bind xml prefix to a wrong
; 747  :          * namespace, which breaks
; 748  :          * Namespace constraint: Reserved Prefixes and Namespace Names
; 749  :          * from XML namespace. But documents authors may not care in
; 750  :          * their context so let's proceed.
; 751  :          */
; 752  :     }
; 753  : 
; 754  :     /*
; 755  :      * Allocate a new Namespace and fill the fields.
; 756  :      */
; 757  :     cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 758  :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN7@xmlNewNs

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BD@OMFEMMGI@building?5namespace@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 759  : 	xmlTreeErrMemory("building namespace");
; 760  : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 797  : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlNewNs:

; 761  :     }
; 762  :     memset(cur, 0, sizeof(xmlNs));
; 763  :     cur->type = XML_LOCAL_NAMESPACE;
; 764  : 
; 765  :     if (href != NULL)

	mov	eax, DWORD PTR _href$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0
	movq	QWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+4], 18			; 00000012H
	test	eax, eax
	je	SHORT $LN8@xmlNewNs

; 766  : 	cur->href = xmlStrdup(href);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN8@xmlNewNs:

; 767  :     if (prefix != NULL)

	test	ebx, ebx
	je	SHORT $LN9@xmlNewNs

; 768  : 	cur->prefix = xmlStrdup(prefix);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
$LN9@xmlNewNs:

; 769  : 
; 770  :     /*
; 771  :      * Add it at the end to preserve parsing order ...
; 772  :      * and checks for existing use of the prefix
; 773  :      */
; 774  :     if (node != NULL) {

	test	edi, edi
	je	SHORT $LN12@xmlNewNs

; 775  : 	if (node->nsDef == NULL) {

	mov	ebx, DWORD PTR [edi+48]
	test	ebx, ebx
	jne	SHORT $LN11@xmlNewNs

; 776  : 	    node->nsDef = cur;

	mov	DWORD PTR [edi+48], esi
$LN12@xmlNewNs:

; 794  : 	}
; 795  :     }
; 796  :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 797  : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlNewNs:

; 777  : 	} else {
; 778  : 	    xmlNsPtr prev = node->nsDef;
; 779  : 
; 780  : 	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	jne	SHORT $LN27@xmlNewNs
	cmp	DWORD PTR [esi+12], eax
	je	SHORT $LN17@xmlNewNs
$LN27@xmlNewNs:
	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlNewNs

; 781  : 		(xmlStrEqual(prev->prefix, cur->prefix))) {
; 782  : 		xmlFreeNs(cur);
; 783  : 		return(NULL);
; 784  : 	    }
; 785  : 	    while (prev->next != NULL) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN3@xmlNewNs
$LL2@xmlNewNs:

; 786  : 	        prev = prev->next;
; 787  : 		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||

	mov	eax, DWORD PTR [edi+12]
	mov	ebx, edi
	test	eax, eax
	jne	SHORT $LN28@xmlNewNs
	cmp	DWORD PTR [esi+12], eax
	je	SHORT $LN17@xmlNewNs
$LN28@xmlNewNs:
	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlNewNs

; 781  : 		(xmlStrEqual(prev->prefix, cur->prefix))) {
; 782  : 		xmlFreeNs(cur);
; 783  : 		return(NULL);
; 784  : 	    }
; 785  : 	    while (prev->next != NULL) {

	mov	eax, DWORD PTR [edi]
	mov	edi, eax
	test	eax, eax
	jne	SHORT $LL2@xmlNewNs
$LN3@xmlNewNs:

; 791  : 		}
; 792  : 	    }
; 793  : 	    prev->next = cur;

	mov	DWORD PTR [ebx], esi

; 794  : 	}
; 795  :     }
; 796  :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 797  : }

	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlNewNs:

; 788  : 		    (xmlStrEqual(prev->prefix, cur->prefix))) {
; 789  : 		    xmlFreeNs(cur);

	push	esi
	call	_xmlFreeNs
	add	esp, 4

; 790  : 		    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 797  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlNewNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlFreeDtd
_TEXT	SEGMENT
_dict$1$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlFreeDtd PROC					; COMDAT

; 1104 : xmlFreeDtd(xmlDtdPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	xor	eax, eax
	mov	DWORD PTR _dict$1$[ebp], eax
	test	edi, edi
	je	$LN1@xmlFreeDtd

; 1105 :     xmlDictPtr dict = NULL;
; 1106 : 
; 1107 :     if (cur == NULL) {
; 1108 : 	return;
; 1109 :     }
; 1110 :     if (cur->doc != NULL) dict = cur->doc->dict;

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN5@xmlFreeDtd
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR _dict$1$[ebp], eax
$LN5@xmlFreeDtd:

; 1111 : 
; 1112 :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN6@xmlFreeDtd
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@xmlFreeDtd

; 1113 : 	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlDeregisterNodeDefaultValue
	push	edi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN6@xmlFreeDtd:

; 1114 : 
; 1115 :     if (cur->children != NULL) {

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edi+12]
	test	esi, esi
	je	SHORT $LN3@xmlFreeDtd
$LL2@xmlFreeDtd:

; 1116 : 	xmlNodePtr next, c = cur->children;
; 1117 : 
; 1118 : 	/*
; 1119 : 	 * Cleanup all nodes which are not part of the specific lists
; 1120 : 	 * of notations, elements, attributes and entities.
; 1121 : 	 */
; 1122 :         while (c != NULL) {
; 1123 : 	    next = c->next;
; 1124 : 	    if ((c->type != XML_NOTATION_NODE) &&
; 1125 : 	        (c->type != XML_ELEMENT_DECL) &&
; 1126 : 		(c->type != XML_ATTRIBUTE_DECL) &&

	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+24]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN8@xmlFreeDtd
	cmp	eax, 15					; 0000000fH
	je	SHORT $LN8@xmlFreeDtd
	cmp	eax, 16					; 00000010H
	je	SHORT $LN8@xmlFreeDtd
	cmp	eax, 17					; 00000011H
	je	SHORT $LN8@xmlFreeDtd

; 1127 : 		(c->type != XML_ENTITY_DECL)) {
; 1128 : 		xmlUnlinkNode(c);

	push	esi
	call	_xmlUnlinkNode

; 1129 : 		xmlFreeNode(c);

	push	esi
	call	_xmlFreeNode
	add	esp, 8
$LN8@xmlFreeDtd:

; 1130 : 	    }
; 1131 : 	    c = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	SHORT $LL2@xmlFreeDtd
$LN3@xmlFreeDtd:

; 1132 : 	}
; 1133 :     }
; 1134 :     DICT_FREE(cur->name)

	mov	eax, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR _dict$1$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlFreeDtd
	test	ebx, ebx
	je	SHORT $LN10@xmlFreeDtd
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlFreeDtd
$LN10@xmlFreeDtd:
	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlFreeDtd:

; 1135 :     DICT_FREE(cur->SystemID)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN11@xmlFreeDtd
	test	ebx, ebx
	je	SHORT $LN12@xmlFreeDtd
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlFreeDtd
$LN12@xmlFreeDtd:
	push	DWORD PTR [edi+56]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlFreeDtd:

; 1136 :     DICT_FREE(cur->ExternalID)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN13@xmlFreeDtd
	test	ebx, ebx
	je	SHORT $LN14@xmlFreeDtd
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlFreeDtd
$LN14@xmlFreeDtd:
	push	DWORD PTR [edi+52]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlFreeDtd:

; 1137 :     /* TODO !!! */
; 1138 :     if (cur->notations != NULL)

	mov	eax, DWORD PTR [edi+36]
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN15@xmlFreeDtd

; 1139 :         xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);

	push	eax
	call	_xmlFreeNotationTable
	add	esp, 4
$LN15@xmlFreeDtd:

; 1140 : 
; 1141 :     if (cur->elements != NULL)

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN16@xmlFreeDtd

; 1142 :         xmlFreeElementTable((xmlElementTablePtr) cur->elements);

	push	eax
	call	_xmlFreeElementTable
	add	esp, 4
$LN16@xmlFreeDtd:

; 1143 :     if (cur->attributes != NULL)

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN17@xmlFreeDtd

; 1144 :         xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);

	push	eax
	call	_xmlFreeAttributeTable
	add	esp, 4
$LN17@xmlFreeDtd:

; 1145 :     if (cur->entities != NULL)

	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	je	SHORT $LN18@xmlFreeDtd

; 1146 :         xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);

	push	eax
	call	_xmlFreeEntitiesTable
	add	esp, 4
$LN18@xmlFreeDtd:

; 1147 :     if (cur->pentities != NULL)

	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN19@xmlFreeDtd

; 1148 :         xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);

	push	eax
	call	_xmlFreeEntitiesTable
	add	esp, 4
$LN19@xmlFreeDtd:

; 1149 : 
; 1150 :     xmlFree(cur);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeDtd:
	pop	edi

; 1151 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetIntSubset
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlGetIntSubset PROC					; COMDAT

; 925  : xmlGetIntSubset(const xmlDoc *doc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlGetIntS

; 926  :     xmlNodePtr cur;
; 927  : 
; 928  :     if (doc == NULL)
; 929  : 	return(NULL);

	xor	eax, eax

; 937  : }

	pop	ebp
	ret	0
$LN4@xmlGetIntS:

; 930  :     cur = doc->children;

	mov	eax, DWORD PTR [ecx+12]

; 931  :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlGetIntS
	npad	1
$LL2@xmlGetIntS:

; 932  : 	if (cur->type == XML_DTD_NODE)

	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	je	SHORT $LN1@xmlGetIntS

; 933  : 	    return((xmlDtdPtr) cur);
; 934  : 	cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlGetIntS
$LN3@xmlGetIntS:

; 935  :     }
; 936  :     return((xmlDtdPtr) doc->intSubset);

	mov	eax, DWORD PTR [ecx+44]
$LN1@xmlGetIntS:

; 937  : }

	pop	ebp
	ret	0
_xmlGetIntSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlNewDtd
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_xmlNewDtd PROC						; COMDAT

; 877  :                     const xmlChar *ExternalID, const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlNewDtd

; 878  :     xmlDtdPtr cur;
; 879  : 
; 880  :     if ((doc != NULL) && (doc->extSubset != NULL)) {

	cmp	DWORD PTR [edi+48], 0
	je	SHORT $LN2@xmlNewDtd

; 881  : #ifdef DEBUG_TREE
; 882  :         xmlGenericError(xmlGenericErrorContext,
; 883  : 		"xmlNewDtd(%s): document %s already have a DTD %s\n",
; 884  : 	    /* !!! */ (char *) name, doc->name,
; 885  : 	    /* !!! */ (char *)doc->extSubset->name);
; 886  : #endif
; 887  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 914  : }

	pop	ebp
	ret	0
$LN2@xmlNewDtd:
	push	esi

; 888  :     }
; 889  : 
; 890  :     /*
; 891  :      * Allocate a new DTD and fill the fields.
; 892  :      */
; 893  :     cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));

	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 894  :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlNewDtd

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0N@OIMLODKO@building?5DTD@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 895  : 	xmlTreeErrMemory("building DTD");
; 896  : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 914  : }

	pop	ebp
	ret	0
$LN3@xmlNewDtd:

; 897  :     }
; 898  :     memset(cur, 0 , sizeof(xmlDtd));

	push	64					; 00000040H
	push	0
	push	esi
	call	_memset

; 899  :     cur->type = XML_DTD_NODE;
; 900  : 
; 901  :     if (name != NULL)

	mov	eax, DWORD PTR _name$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 14			; 0000000eH
	test	eax, eax
	je	SHORT $LN4@xmlNewDtd

; 902  : 	cur->name = xmlStrdup(name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN4@xmlNewDtd:

; 903  :     if (ExternalID != NULL)

	mov	eax, DWORD PTR _ExternalID$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlNewDtd

; 904  : 	cur->ExternalID = xmlStrdup(ExternalID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+52], eax
$LN5@xmlNewDtd:

; 905  :     if (SystemID != NULL)

	mov	eax, DWORD PTR _SystemID$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlNewDtd

; 906  : 	cur->SystemID = xmlStrdup(SystemID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+56], eax
$LN6@xmlNewDtd:

; 907  :     if (doc != NULL)

	test	edi, edi
	je	SHORT $LN7@xmlNewDtd

; 908  : 	doc->extSubset = cur;

	mov	DWORD PTR [edi+48], esi
$LN7@xmlNewDtd:

; 909  :     cur->doc = doc;

	mov	DWORD PTR [esi+32], edi

; 910  : 
; 911  :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN8@xmlNewDtd
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@xmlNewDtd

; 912  : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN8@xmlNewDtd:

; 913  :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 914  : }

	pop	ebp
	ret	0
_xmlNewDtd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlCreateIntSubset
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_ExternalID$ = 16					; size = 4
_SystemID$ = 20						; size = 4
_xmlCreateIntSubset PROC				; COMDAT

; 951  :                    const xmlChar *ExternalID, const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlCreateI

; 930  :     cur = doc->children;

	mov	eax, DWORD PTR [edi+12]

; 931  :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN28@xmlCreateI
	npad	4
$LL27@xmlCreateI:

; 932  : 	if (cur->type == XML_DTD_NODE)

	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	je	SHORT $LN26@xmlCreateI

; 933  : 	    return((xmlDtdPtr) cur);
; 934  : 	cur = cur->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL27@xmlCreateI
$LN28@xmlCreateI:

; 935  :     }
; 936  :     return((xmlDtdPtr) doc->intSubset);

	mov	eax, DWORD PTR [edi+44]
$LN26@xmlCreateI:

; 952  :     xmlDtdPtr cur;
; 953  : 
; 954  :     if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {

	test	eax, eax
	je	SHORT $LN4@xmlCreateI

; 955  : #ifdef DEBUG_TREE
; 956  :         xmlGenericError(xmlGenericErrorContext,
; 957  : 
; 958  :      "xmlCreateIntSubset(): document %s already have an internal subset\n",
; 959  : 	    doc->name);
; 960  : #endif
; 961  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 1047 : }

	pop	ebp
	ret	0
$LN4@xmlCreateI:
	push	esi

; 962  :     }
; 963  : 
; 964  :     /*
; 965  :      * Allocate a new DTD and fill the fields.
; 966  :      */
; 967  :     cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));

	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 968  :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlCreateI

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@INPJKJEA@building?5internal?5subset@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 969  : 	xmlTreeErrMemory("building internal subset");
; 970  : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1047 : }

	pop	ebp
	ret	0
$LN5@xmlCreateI:

; 971  :     }
; 972  :     memset(cur, 0, sizeof(xmlDtd));

	push	64					; 00000040H
	push	0
	push	esi
	call	_memset

; 973  :     cur->type = XML_DTD_NODE;
; 974  : 
; 975  :     if (name != NULL) {

	mov	eax, DWORD PTR _name$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], 14			; 0000000eH
	test	eax, eax
	je	SHORT $LN45@xmlCreateI

; 976  : 	cur->name = xmlStrdup(name);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 977  : 	if (cur->name == NULL) {

	test	eax, eax
	jne	SHORT $LN45@xmlCreateI

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@INPJKJEA@building?5internal?5subset@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 978  : 	    xmlTreeErrMemory("building internal subset");
; 979  : 	    xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 980  : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1047 : }

	pop	ebp
	ret	0
$LN45@xmlCreateI:

; 981  : 	}
; 982  :     }
; 983  :     if (ExternalID != NULL) {

	mov	eax, DWORD PTR _ExternalID$[ebp]
	test	eax, eax
	je	SHORT $LN46@xmlCreateI

; 984  : 	cur->ExternalID = xmlStrdup(ExternalID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+52], eax

; 985  : 	if (cur->ExternalID  == NULL) {

	test	eax, eax
	jne	SHORT $LN46@xmlCreateI

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@INPJKJEA@building?5internal?5subset@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 986  : 	    xmlTreeErrMemory("building internal subset");
; 987  : 	    if (cur->name != NULL)

	mov	eax, DWORD PTR [esi+8]

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	add	esp, 20					; 00000014H
	jmp	SHORT $LN52@xmlCreateI
$LN46@xmlCreateI:

; 988  : 	        xmlFree((char *)cur->name);
; 989  : 	    xmlFree(cur);
; 990  : 	    return(NULL);
; 991  : 	}
; 992  :     }
; 993  :     if (SystemID != NULL) {

	mov	eax, DWORD PTR _SystemID$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlCreateI

; 994  : 	cur->SystemID = xmlStrdup(SystemID);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+56], eax

; 995  : 	if (cur->SystemID == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlCreateI

; 996  : 	    xmlTreeErrMemory("building internal subset");

	push	OFFSET ??_C@_0BJ@INPJKJEA@building?5internal?5subset@
	call	_xmlTreeErrMemory

; 997  : 	    if (cur->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@xmlCreateI

; 998  : 	        xmlFree((char *)cur->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlCreateI:

; 999  : 	    if (cur->ExternalID != NULL)

	mov	eax, DWORD PTR [esi+52]
$LN52@xmlCreateI:

; 1000 : 	        xmlFree((char *)cur->ExternalID);
; 1001 : 	    xmlFree(cur);

	test	eax, eax
	je	SHORT $LN14@xmlCreateI
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlCreateI:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1002 : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 1047 : }

	pop	ebp
	ret	0
$LN12@xmlCreateI:

; 1003 : 	}
; 1004 :     }
; 1005 :     if (doc != NULL) {

	test	edi, edi
	je	SHORT $LN21@xmlCreateI

; 1006 : 	doc->intSubset = cur;

	mov	DWORD PTR [edi+44], esi

; 1007 : 	cur->parent = doc;

	mov	DWORD PTR [esi+20], edi

; 1008 : 	cur->doc = doc;

	mov	DWORD PTR [esi+32], edi

; 1009 : 	if (doc->children == NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $LN16@xmlCreateI

; 1010 : 	    doc->children = (xmlNodePtr) cur;

	mov	DWORD PTR [edi+12], esi

; 1011 : 	    doc->last = (xmlNodePtr) cur;

	mov	DWORD PTR [edi+16], esi

; 1012 : 	} else {

	jmp	SHORT $LN21@xmlCreateI
$LN16@xmlCreateI:

; 1013 : 	    if (doc->type == XML_HTML_DOCUMENT_NODE) {

	cmp	DWORD PTR [edi+4], 13			; 0000000dH
	jne	SHORT $LL2@xmlCreateI

; 1014 : 		xmlNodePtr prev;
; 1015 : 
; 1016 : 		prev = doc->children;
; 1017 : 		prev->prev = (xmlNodePtr) cur;

	mov	DWORD PTR [eax+28], esi

; 1018 : 		cur->next = prev;

	mov	DWORD PTR [esi+24], eax

; 1019 : 		doc->children = (xmlNodePtr) cur;

	mov	DWORD PTR [edi+12], esi

; 1020 : 	    } else {

	jmp	SHORT $LN21@xmlCreateI
$LL2@xmlCreateI:

; 1021 : 		xmlNodePtr next;
; 1022 : 
; 1023 : 		next = doc->children;
; 1024 : 		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN3@xmlCreateI

; 1025 : 		    next = next->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL2@xmlCreateI
$LN3@xmlCreateI:

; 1026 : 		if (next == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlCreateI

; 1027 : 		    cur->prev = doc->last;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+28], eax

; 1028 : 		    cur->prev->next = (xmlNodePtr) cur;

	mov	DWORD PTR [eax+24], esi

; 1029 : 		    cur->next = NULL;

	mov	DWORD PTR [esi+24], 0

; 1030 : 		    doc->last = (xmlNodePtr) cur;

	mov	DWORD PTR [edi+16], esi

; 1031 : 		} else {

	jmp	SHORT $LN21@xmlCreateI
$LN20@xmlCreateI:

; 1032 : 		    cur->next = next;

	mov	DWORD PTR [esi+24], eax

; 1033 : 		    cur->prev = next->prev;

	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [esi+28], ecx

; 1034 : 		    if (cur->prev == NULL)

	test	ecx, ecx
	jne	SHORT $LN22@xmlCreateI

; 1035 : 			doc->children = (xmlNodePtr) cur;

	mov	DWORD PTR [edi+12], esi
	jmp	SHORT $LN23@xmlCreateI
$LN22@xmlCreateI:

; 1036 : 		    else
; 1037 : 			cur->prev->next = (xmlNodePtr) cur;

	mov	DWORD PTR [ecx+24], esi
$LN23@xmlCreateI:

; 1038 : 		    next->prev = (xmlNodePtr) cur;

	mov	DWORD PTR [eax+28], esi
$LN21@xmlCreateI:

; 1039 : 		}
; 1040 : 	    }
; 1041 : 	}
; 1042 :     }
; 1043 : 
; 1044 :     if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN24@xmlCreateI
	call	___xmlRegisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN24@xmlCreateI

; 1045 : 	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);

	call	___xmlRegisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN24@xmlCreateI:

; 1046 :     return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 1047 : }

	pop	ebp
	ret	0
_xmlCreateIntSubset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferLength
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufferLength PROC					; COMDAT

; 7372 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlBufferL

; 7377 : }

	pop	ebp
	ret	0
$LN2@xmlBufferL:

; 7373 :     if(!buf)
; 7374 :         return 0;
; 7375 : 
; 7376 :     return buf->use;

	mov	eax, DWORD PTR [eax+4]

; 7377 : }

	pop	ebp
	ret	0
_xmlBufferLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferSetAllocationScheme
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_scheme$ = 12						; size = 4
_xmlBufferSetAllocationScheme PROC			; COMDAT

; 7141 :                              xmlBufferAllocationScheme scheme) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlBufferS

; 7142 :     if (buf == NULL) {
; 7143 : #ifdef DEBUG_BUFFER
; 7144 :         xmlGenericError(xmlGenericErrorContext,
; 7145 : 		"xmlBufferSetAllocationScheme: buf == NULL\n");
; 7146 : #endif
; 7147 :         return;
; 7148 :     }
; 7149 :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, 2
	je	SHORT $LN4@xmlBufferS
	cmp	eax, 3
	je	SHORT $LN4@xmlBufferS

; 7150 :         (buf->alloc == XML_BUFFER_ALLOC_IO)) return;
; 7151 :     if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
; 7152 :         (scheme == XML_BUFFER_ALLOC_EXACT) ||
; 7153 :         (scheme == XML_BUFFER_ALLOC_HYBRID) ||

	mov	eax, DWORD PTR _scheme$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlBufferS
	cmp	eax, 1
	je	SHORT $LN6@xmlBufferS
	cmp	eax, 4
	je	SHORT $LN6@xmlBufferS
	cmp	eax, 2
	jne	SHORT $LN4@xmlBufferS
$LN6@xmlBufferS:

; 7154 :         (scheme == XML_BUFFER_ALLOC_IMMUTABLE))
; 7155 : 	buf->alloc = scheme;

	mov	DWORD PTR [ecx+12], eax
$LN4@xmlBufferS:

; 7156 : }

	pop	ebp
	ret	0
_xmlBufferSetAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferDetach
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufferDetach PROC					; COMDAT

; 7085 : xmlBufferDetach(xmlBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buf$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlBufferD

; 7086 :     xmlChar *ret;
; 7087 : 
; 7088 :     if (buf == NULL)
; 7089 :         return(NULL);
; 7090 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [ecx+12], 2
	je	SHORT $LN5@xmlBufferD

; 7092 : 
; 7093 :     ret = buf->content;

	mov	eax, DWORD PTR [ecx]

; 7094 :     buf->content = NULL;

	mov	DWORD PTR [ecx], 0

; 7095 :     buf->size = 0;

	mov	DWORD PTR [ecx+8], 0

; 7096 :     buf->use = 0;

	mov	DWORD PTR [ecx+4], 0

; 7097 : 
; 7098 :     return ret;
; 7099 : }

	pop	ebp
	ret	0
$LN5@xmlBufferD:

; 7091 :         return(NULL);

	xor	eax, eax

; 7097 : 
; 7098 :     return ret;
; 7099 : }

	pop	ebp
	ret	0
_xmlBufferDetach ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufferContent PROC					; COMDAT

; 7354 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlBufferC

; 7359 : }

	pop	ebp
	ret	0
$LN2@xmlBufferC:

; 7355 :     if(!buf)
; 7356 :         return NULL;
; 7357 : 
; 7358 :     return buf->content;

	mov	eax, DWORD PTR [eax]

; 7359 : }

	pop	ebp
	ret	0
_xmlBufferContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferEmpty
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufferEmpty PROC					; COMDAT

; 7192 : xmlBufferEmpty(xmlBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlBufferE

; 7193 :     if (buf == NULL) return;
; 7194 :     if (buf->content == NULL) return;

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@xmlBufferE

; 7195 :     buf->use = 0;
; 7196 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) {

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	cmp	edx, 2
	jne	SHORT $LN4@xmlBufferE

; 7197 :         buf->content = BAD_CAST "";

	mov	DWORD PTR [eax], OFFSET ??_C@_00CNPNBAHC@@

; 7207 :     }
; 7208 : }

	pop	ebp
	ret	0
$LN4@xmlBufferE:

; 7198 :     } else if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	cmp	edx, 3
	jne	SHORT $LN6@xmlBufferE
	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN6@xmlBufferE

; 7199 :                (buf->contentIO != NULL)) {
; 7200 :         size_t start_buf = buf->content - buf->contentIO;
; 7201 : 
; 7202 : 	buf->size += start_buf;

	sub	ecx, edx

; 7203 :         buf->content = buf->contentIO;

	mov	DWORD PTR [eax], edx
	add	DWORD PTR [eax+8], ecx

; 7204 :         buf->content[0] = 0;

	mov	BYTE PTR [edx], 0

; 7207 :     }
; 7208 : }

	pop	ebp
	ret	0
$LN6@xmlBufferE:

; 7205 :     } else {
; 7206 :         buf->content[0] = 0;

	mov	BYTE PTR [ecx], 0
$LN7@xmlBufferE:

; 7207 :     }
; 7208 : }

	pop	ebp
	ret	0
_xmlBufferEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferGrow
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufferGrow PROC					; COMDAT

; 7265 : xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _len$[ebp]
	mov	ecx, OFFSET __59973643_tree@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlBufferG

; 7266 :     int size;
; 7267 :     xmlChar *newbuf;
; 7268 : 
; 7269 :     if (buf == NULL) return(-1);

	pop	esi
	or	eax, -1

; 7309 : }

	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlBufferG:

; 7270 : 
; 7271 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, 2
	je	SHORT $LN13@xmlBufferG

; 7272 :     if (len + buf->use < buf->size) return(0);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	add	eax, ebx
	cmp	eax, edx
	jb	SHORT $LN13@xmlBufferG

; 7273 : 
; 7274 :     /*
; 7275 :      * Windows has a BIG problem on realloc timing, so we try to double
; 7276 :      * the buffer size (if that's enough) (bug 146697)
; 7277 :      * Apparently BSD too, and it's probably best for linux too
; 7278 :      * On an embedded system this may be something to change
; 7279 :      */
; 7280 : #if 1
; 7281 :     if (buf->size > len)
; 7282 :         size = buf->size * 2;
; 7283 :     else
; 7284 :         size = buf->use + len + 100;
; 7285 : #else
; 7286 :     size = buf->use + len + 100;
; 7287 : #endif
; 7288 : 
; 7289 :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	add	eax, 100				; 00000064H
	cmp	edx, ebx
	push	edi
	lea	edi, DWORD PTR [edx+edx]
	cmovbe	edi, eax
	cmp	ecx, 3
	jne	SHORT $LN7@xmlBufferG
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN7@xmlBufferG

; 7290 :         size_t start_buf = buf->content - buf->contentIO;

	mov	ebx, DWORD PTR [esi]
	sub	ebx, ecx

; 7291 : 
; 7292 : 	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);

	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 7293 : 	if (newbuf == NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlBufferG

; 7294 : 	    xmlTreeErrMemory("growing buffer");
; 7295 : 	    return(-1);
; 7296 : 	}
; 7297 : 	buf->contentIO = newbuf;

	mov	DWORD PTR [esi+16], eax

; 7298 : 	buf->content = newbuf + start_buf;

	add	eax, ebx
$LN10@xmlBufferG:

; 7304 : 	}
; 7305 : 	buf->content = newbuf;
; 7306 :     }
; 7307 :     buf->size = size;

	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], edi

; 7308 :     return(buf->size - buf->use);

	sub	edi, DWORD PTR [esi+4]
	mov	eax, edi
	pop	edi
	pop	esi

; 7309 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlBufferG:

; 7299 :     } else {
; 7300 : 	newbuf = (xmlChar *) xmlRealloc(buf->content, size);

	push	edi
	push	DWORD PTR [esi]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 7301 : 	if (newbuf == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlBufferG
$LN12@xmlBufferG:

; 7302 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7303 : 	    return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 7309 : }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlBufferG:
	pop	esi

; 7272 :     if (len + buf->use < buf->size) return(0);

	xor	eax, eax

; 7309 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlBufferGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferShrink
_TEXT	SEGMENT
tv278 = -4						; size = 4
tv277 = 8						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlBufferShrink PROC					; COMDAT

; 7220 : xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN13@xmlBufferS

; 7221 :     if (buf == NULL) return(-1);
; 7222 :     if (len == 0) return(0);

	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlBufferS
	pop	edi
	xor	eax, eax

; 7253 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlBufferS:

; 7223 :     if (len > buf->use) return(-1);

	mov	edx, DWORD PTR [esi+4]
	cmp	edi, edx
	ja	$LN13@xmlBufferS

; 7224 : 
; 7225 :     buf->use -= len;
; 7226 :     if ((buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) ||

	mov	ecx, DWORD PTR [esi+12]
	sub	edx, edi
	mov	DWORD PTR [esi+4], edx
	cmp	ecx, 2
	je	SHORT $LN12@xmlBufferS
	cmp	ecx, 3
	jne	SHORT $LN5@xmlBufferS
	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN12@xmlBufferS
$LN5@xmlBufferS:

; 7246 : 	    }
; 7247 : 	}
; 7248 :     } else {
; 7249 : 	memmove(buf->content, &buf->content[len], buf->use);

	mov	ecx, DWORD PTR [esi]
	push	edx
	lea	eax, DWORD PTR [ecx+edi]
	push	eax
	push	ecx
	call	_memmove

; 7250 : 	buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR [ecx+eax], 0

; 7251 :     }
; 7252 :     return(len);

	mov	eax, edi
	pop	edi

; 7253 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlBufferS:

; 7227 :         ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {
; 7228 : 	/*
; 7229 : 	 * we just move the content pointer, but also make sure
; 7230 : 	 * the perceived buffer size has shrinked accordingly
; 7231 : 	 */
; 7232 :         buf->content += len;
; 7233 : 	buf->size -= len;

	mov	eax, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi]
	sub	eax, edi
	add	ebx, edi
	mov	DWORD PTR tv277[ebp], eax
	mov	DWORD PTR tv278[ebp], ebx
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+8], eax

; 7234 : 
; 7235 :         /*
; 7236 : 	 * sometimes though it maybe be better to really shrink
; 7237 : 	 * on IO buffers
; 7238 : 	 */
; 7239 : 	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	cmp	ecx, 3
	jne	SHORT $LN14@xmlBufferS
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN14@xmlBufferS

; 7240 : 	    size_t start_buf = buf->content - buf->contentIO;

	sub	ebx, eax

; 7241 : 	    if (start_buf >= buf->size) {

	cmp	ebx, DWORD PTR tv277[ebp]
	jb	SHORT $LN14@xmlBufferS

; 7242 : 		memmove(buf->contentIO, &buf->content[0], buf->use);

	push	edx
	push	DWORD PTR tv278[ebp]
	push	eax
	call	_memmove

; 7243 : 		buf->content = buf->contentIO;

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH

; 7244 : 		buf->content[buf->use] = 0;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], edx
	mov	BYTE PTR [edx+ecx], 0

; 7245 : 		buf->size += start_buf;

	add	DWORD PTR [esi+8], ebx
$LN14@xmlBufferS:

; 7251 :     }
; 7252 :     return(len);

	pop	ebx
	mov	eax, edi
	pop	edi

; 7253 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlBufferS:
	pop	edi

; 7223 :     if (len > buf->use) return(-1);

	or	eax, -1

; 7253 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufferShrink ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferCCat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufferCCat PROC					; COMDAT

; 7636 : xmlBufferCCat(xmlBufferPtr buf, const char *str) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN21@xmlBufferC

; 7637 :     const char *cur;
; 7638 : 
; 7639 :     if (buf == NULL)
; 7640 :         return(-1);
; 7641 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	SHORT $LN21@xmlBufferC

; 7642 :     if (str == NULL) {

	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN21@xmlBufferC

; 7648 :     }
; 7649 :     for (cur = str;*cur != 0;cur++) {

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN22@xmlBufferC
	mov	eax, DWORD PTR [esi+4]
	npad	5
$LL4@xmlBufferC:

; 7650 :         if (buf->use  + 10 >= buf->size) {

	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR [esi+8]
	jb	SHORT $LN17@xmlBufferC

; 7651 :             if (!xmlBufferResize(buf, buf->use+10)){

	push	eax
	push	esi
	call	_xmlBufferResize
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlBufferC
$LN17@xmlBufferC:

; 7654 :             }
; 7655 :         }
; 7656 :         buf->content[buf->use++] = *cur;

	mov	al, BYTE PTR [edi]
	inc	edi
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [edx+ecx], al
	inc	DWORD PTR [esi+4]
	cmp	BYTE PTR [edi], 0
	mov	eax, DWORD PTR [esi+4]
	jne	SHORT $LL4@xmlBufferC
$LN22@xmlBufferC:

; 7657 :     }
; 7658 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	pop	edi

; 7659 :     return 0;
; 7660 : }

	pop	esi
	mov	BYTE PTR [ecx+eax], 0
	xor	eax, eax
	pop	ebp
	ret	0
$LN14@xmlBufferC:

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7652 : 		xmlTreeErrMemory("growing buffer");
; 7653 :                 return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 7659 :     return 0;
; 7660 : }

	pop	esi
	pop	ebp
	ret	0
$LN21@xmlBufferC:
	pop	edi

; 7643 : #ifdef DEBUG_BUFFER
; 7644 :         xmlGenericError(xmlGenericErrorContext,
; 7645 : 		"xmlBufferCCat: str == NULL\n");
; 7646 : #endif
; 7647 : 	return -1;

	or	eax, -1

; 7659 :     return 0;
; 7660 : }

	pop	esi
	pop	ebp
	ret	0
_xmlBufferCCat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferCat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlBufferCat PROC					; COMDAT

; 7617 : xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN22@xmlBufferC

; 7618 :     if (buf == NULL)
; 7619 :         return(-1);
; 7620 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	SHORT $LN22@xmlBufferC

; 7621 :     if (str == NULL) return -1;

	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	je	SHORT $LN22@xmlBufferC

; 7518 :         len = xmlStrlen(str);

	push	edi
	push	ebx
	call	_xmlStrlen
	mov	edi, eax
	add	esp, 4

; 7519 : 
; 7520 :     if (len < 0) return -1;

	test	edi, edi
	jns	SHORT $LN23@xmlBufferC

; 7622 :     return xmlBufferAdd(buf, str, -1);

	pop	edi
	pop	esi

; 7520 :     if (len < 0) return -1;

	or	eax, -1

; 7623 : }

	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlBufferC:

; 7521 :     if (len == 0) return 0;

	je	SHORT $LN24@xmlBufferC

; 7522 : 
; 7523 :     needSize = buf->use + len + 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, 2
	add	eax, edi

; 7524 :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [esi+8]
	jbe	SHORT $LN21@xmlBufferC

; 7525 :         if (!xmlBufferResize(buf, needSize)){

	push	eax
	push	esi
	call	_xmlBufferResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlBufferC

; 7526 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7527 :             return XML_ERR_NO_MEMORY;

	mov	eax, 2

; 7622 :     return xmlBufferAdd(buf, str, -1);

	pop	edi
	pop	esi

; 7623 : }

	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlBufferC:

; 7531 :     memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));

	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi]
	push	edi
	push	ebx
	push	eax
	call	_memmove

; 7532 :     buf->use += len;
; 7533 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [esi+4], edi
	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR [ecx+eax], 0
$LN24@xmlBufferC:

; 7622 :     return xmlBufferAdd(buf, str, -1);

	pop	edi
	pop	esi
	xor	eax, eax

; 7623 : }

	pop	ebx
	pop	ebp
	ret	0
$LN22@xmlBufferC:
	pop	esi

; 7621 :     if (str == NULL) return -1;

	or	eax, -1

; 7623 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlBufferCat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferAddHead
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufferAddHead PROC					; COMDAT

; 7550 : xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN16@xmlBufferA

; 7551 :     unsigned int needSize;
; 7552 : 
; 7553 :     if (buf == NULL)
; 7554 :         return(-1);
; 7555 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [esi+12], 2
	je	$LN16@xmlBufferA

; 7556 :     if (str == NULL) {

	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	je	$LN16@xmlBufferA

; 7557 : #ifdef DEBUG_BUFFER
; 7558 :         xmlGenericError(xmlGenericErrorContext,
; 7559 : 		"xmlBufferAddHead: str == NULL\n");
; 7560 : #endif
; 7561 : 	return -1;
; 7562 :     }
; 7563 :     if (len < -1) {

	mov	edi, DWORD PTR _len$[ebp]
	cmp	edi, -1
	jl	$LN16@xmlBufferA

; 7564 : #ifdef DEBUG_BUFFER
; 7565 :         xmlGenericError(xmlGenericErrorContext,
; 7566 : 		"xmlBufferAddHead: len < 0\n");
; 7567 : #endif
; 7568 : 	return -1;
; 7569 :     }
; 7570 :     if (len == 0) return 0;

	test	edi, edi
	je	SHORT $LN18@xmlBufferA

; 7571 : 
; 7572 :     if (len < 0)

	jns	SHORT $LN19@xmlBufferA

; 7573 :         len = xmlStrlen(str);

	push	ebx
	call	_xmlStrlen
	mov	edi, eax
	add	esp, 4

; 7574 : 
; 7575 :     if (len <= 0) return -1;

	test	edi, edi
$LN19@xmlBufferA:
	jle	$LN16@xmlBufferA

; 7576 : 
; 7577 :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	cmp	DWORD PTR [esi+12], 3
	jne	SHORT $LN10@xmlBufferA
	mov	edx, DWORD PTR [esi+16]
	test	edx, edx
	je	SHORT $LN10@xmlBufferA

; 7578 :         size_t start_buf = buf->content - buf->contentIO;

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	sub	eax, edx

; 7579 : 
; 7580 : 	if (start_buf > (unsigned int) len) {

	cmp	eax, edi
	jbe	SHORT $LN10@xmlBufferA

; 7581 : 	    /*
; 7582 : 	     * We can add it in the space previously shrinked
; 7583 : 	     */
; 7584 : 	    buf->content -= len;
; 7585 :             memmove(&buf->content[0], str, len);

	push	edi
	sub	ecx, edi
	push	ebx
	push	ecx
	mov	DWORD PTR [esi], ecx
	call	_memmove

; 7586 : 	    buf->use += len;

	add	DWORD PTR [esi+4], edi
	add	esp, 12					; 0000000cH

; 7587 : 	    buf->size += len;

	add	DWORD PTR [esi+8], edi
$LN18@xmlBufferA:

; 7603 :     return 0;
; 7604 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlBufferA:

; 7588 : 	    return(0);
; 7589 : 	}
; 7590 :     }
; 7591 :     needSize = buf->use + len + 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, 2
	add	eax, edi

; 7592 :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [esi+8]
	jbe	SHORT $LN15@xmlBufferA

; 7593 :         if (!xmlBufferResize(buf, needSize)){

	push	eax
	push	esi
	call	_xmlBufferResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlBufferA

; 7594 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7595 :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 7603 :     return 0;
; 7604 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlBufferA:

; 7596 :         }
; 7597 :     }
; 7598 : 
; 7599 :     memmove(&buf->content[len], &buf->content[0], buf->use);

	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	eax
	add	eax, edi
	push	eax
	call	_memmove

; 7600 :     memmove(&buf->content[0], str, len);

	push	edi
	push	ebx
	push	DWORD PTR [esi]
	call	_memmove

; 7601 :     buf->use += len;

	add	DWORD PTR [esi+4], edi
	add	esp, 24					; 00000018H

; 7602 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	pop	edi

; 7603 :     return 0;
; 7604 : }

	pop	esi
	mov	BYTE PTR [ecx+eax], 0
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlBufferA:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlBufferAddHead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferAdd
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufferAdd PROC					; COMDAT

; 7501 : xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	test	ebx, ebx
	je	$LN3@xmlBufferA

; 7502 :     unsigned int needSize;
; 7503 : 
; 7504 :     if ((str == NULL) || (buf == NULL)) {

	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlBufferA

; 7505 : 	return -1;
; 7506 :     }
; 7507 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;

	cmp	DWORD PTR [edi+12], 2
	je	SHORT $LN3@xmlBufferA

; 7508 :     if (len < -1) {

	mov	esi, DWORD PTR _len$[ebp]
	cmp	esi, -1
	jl	SHORT $LN3@xmlBufferA

; 7509 : #ifdef DEBUG_BUFFER
; 7510 :         xmlGenericError(xmlGenericErrorContext,
; 7511 : 		"xmlBufferAdd: len < 0\n");
; 7512 : #endif
; 7513 : 	return -1;
; 7514 :     }
; 7515 :     if (len == 0) return 0;

	test	esi, esi
	je	SHORT $LN15@xmlBufferA

; 7516 : 
; 7517 :     if (len < 0)

	jns	SHORT $LN16@xmlBufferA

; 7518 :         len = xmlStrlen(str);

	push	ebx
	call	_xmlStrlen
	mov	esi, eax
	add	esp, 4

; 7519 : 
; 7520 :     if (len < 0) return -1;

	test	esi, esi
	js	SHORT $LN3@xmlBufferA
$LN16@xmlBufferA:

; 7521 :     if (len == 0) return 0;

	je	SHORT $LN15@xmlBufferA

; 7522 : 
; 7523 :     needSize = buf->use + len + 2;

	mov	eax, DWORD PTR [edi+4]
	add	eax, 2
	add	eax, esi

; 7524 :     if (needSize > buf->size){

	cmp	eax, DWORD PTR [edi+8]
	jbe	SHORT $LN14@xmlBufferA

; 7525 :         if (!xmlBufferResize(buf, needSize)){

	push	eax
	push	edi
	call	_xmlBufferResize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlBufferA

; 7526 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7527 :             return XML_ERR_NO_MEMORY;

	mov	eax, 2
	pop	edi

; 7534 :     return 0;
; 7535 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlBufferA:

; 7528 :         }
; 7529 :     }
; 7530 : 
; 7531 :     memmove(&buf->content[buf->use], str, len*sizeof(xmlChar));

	mov	eax, DWORD PTR [edi]
	add	eax, DWORD PTR [edi+4]
	push	esi
	push	ebx
	push	eax
	call	_memmove

; 7532 :     buf->use += len;
; 7533 :     buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [edi+4], esi
	mov	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR [ecx+eax], 0
$LN15@xmlBufferA:

; 7534 :     return 0;
; 7535 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlBufferA:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlBufferAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferDump
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_xmlBufferDump PROC					; COMDAT

; 7320 : xmlBufferDump(FILE *file, xmlBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlBufferD

; 7321 :     int ret;
; 7322 : 
; 7323 :     if (buf == NULL) {
; 7324 : #ifdef DEBUG_BUFFER
; 7325 :         xmlGenericError(xmlGenericErrorContext,
; 7326 : 		"xmlBufferDump: buf == NULL\n");
; 7327 : #endif
; 7328 : 	return(0);
; 7329 :     }
; 7330 :     if (buf->content == NULL) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xmlBufferD

; 7336 :     }
; 7337 :     if (file == NULL)

	mov	ecx, DWORD PTR _file$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlBufferD

; 7338 : 	file = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR [esi]
$LN4@xmlBufferD:

; 7339 :     ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);

	push	ecx
	push	DWORD PTR [esi+4]
	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	pop	esi

; 7340 :     return(ret);
; 7341 : }

	pop	ebp
	ret	0
$LN6@xmlBufferD:

; 7331 : #ifdef DEBUG_BUFFER
; 7332 :         xmlGenericError(xmlGenericErrorContext,
; 7333 : 		"xmlBufferDump: buf->content == NULL\n");
; 7334 : #endif
; 7335 : 	return(0);

	xor	eax, eax
	pop	esi

; 7340 :     return(ret);
; 7341 : }

	pop	ebp
	ret	0
_xmlBufferDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferFree
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_xmlBufferFree PROC					; COMDAT

; 7166 : xmlBufferFree(xmlBufferPtr buf) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlBufferF

; 7167 :     if (buf == NULL) {
; 7168 : #ifdef DEBUG_BUFFER
; 7169 :         xmlGenericError(xmlGenericErrorContext,
; 7170 : 		"xmlBufferFree: buf == NULL\n");
; 7171 : #endif
; 7172 : 	return;
; 7173 :     }
; 7174 : 
; 7175 :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, 3
	jne	SHORT $LN3@xmlBufferF
	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jne	SHORT $LN7@xmlBufferF
$LN3@xmlBufferF:

; 7176 :         (buf->contentIO != NULL)) {
; 7177 :         xmlFree(buf->contentIO);
; 7178 :     } else if ((buf->content != NULL) &&

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@xmlBufferF
	cmp	eax, 2
	je	SHORT $LN5@xmlBufferF
$LN7@xmlBufferF:

; 7179 :         (buf->alloc != XML_BUFFER_ALLOC_IMMUTABLE)) {
; 7180 :         xmlFree(buf->content);
; 7181 :     }
; 7182 :     xmlFree(buf);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlBufferF:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlBufferF:
	pop	esi

; 7183 : }

	pop	ebp
	ret	0
_xmlBufferFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferResize
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufferResize PROC					; COMDAT

; 7390 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	$LN44@xmlBufferR

; 7391 :     unsigned int newSize;
; 7392 :     xmlChar* rebuf = NULL;
; 7393 :     size_t start_buf;
; 7394 : 
; 7395 :     if (buf == NULL)
; 7396 :         return(0);
; 7397 : 
; 7398 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	mov	edx, DWORD PTR [edi+12]
	cmp	edx, 2
	je	$LN44@xmlBufferR

; 7399 : 
; 7400 :     /* Don't resize if we don't have to */
; 7401 :     if (size < buf->size)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [edi+8]
	cmp	ecx, ebx
	jae	SHORT $LN10@xmlBufferR

; 7402 :         return 1;

	pop	ebx
	mov	eax, 1
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
$LN10@xmlBufferR:
	push	esi

; 7403 : 
; 7404 :     /* figure out new size */
; 7405 :     switch (buf->alloc){

	cmp	edx, 4
	ja	$LN18@xmlBufferR
	jmp	DWORD PTR $LN48@xmlBufferR[edx*4]
$LN11@xmlBufferR:

; 7406 : 	case XML_BUFFER_ALLOC_IO:
; 7407 : 	case XML_BUFFER_ALLOC_DOUBLEIT:
; 7408 : 	    /*take care of empty case*/
; 7409 : 	    newSize = (buf->size ? buf->size*2 : size + 10);
; 7410 : 	    while (size > newSize) {

	test	ebx, ebx
	lea	eax, DWORD PTR [ecx+10]
	lea	esi, DWORD PTR [ebx+ebx]
	cmove	esi, eax
	cmp	ecx, esi
	jbe	SHORT $LN2@xmlBufferR
	npad	7
$LL4@xmlBufferR:

; 7411 : 	        if (newSize > UINT_MAX / 2) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN43@xmlBufferR

; 7412 : 	            xmlTreeErrMemory("growing buffer");
; 7413 : 	            return 0;
; 7414 : 	        }
; 7415 : 	        newSize *= 2;

	add	esi, esi
	cmp	ecx, esi
	ja	SHORT $LL4@xmlBufferR

; 7427 :                     if (newSize > UINT_MAX / 2) {

	jmp	SHORT $LN2@xmlBufferR
$LN13@xmlBufferR:

; 7416 : 	    }
; 7417 : 	    break;
; 7418 : 	case XML_BUFFER_ALLOC_EXACT:
; 7419 : 	    newSize = size+10;

	lea	esi, DWORD PTR [ecx+10]
$LN19@xmlBufferR:

; 7458 : 	}
; 7459 :     } else {
; 7460 : 	if (buf->content == NULL) {

	mov	eax, DWORD PTR [edi]
	push	esi
	test	eax, eax
	jne	$LN24@xmlBufferR

; 7461 : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	ebx, eax
	jmp	$LN28@xmlBufferR
$LN14@xmlBufferR:

; 7420 : 	    break;
; 7421 :         case XML_BUFFER_ALLOC_HYBRID:
; 7422 :             if (buf->use < BASE_BUFFER_SIZE)

	cmp	DWORD PTR [edi+4], 4096			; 00001000H
	jae	SHORT $LN15@xmlBufferR

; 7423 :                 newSize = size;

	mov	esi, ecx
	jmp	SHORT $LN19@xmlBufferR
$LN15@xmlBufferR:

; 7424 :             else {
; 7425 :                 newSize = buf->size * 2;

	lea	esi, DWORD PTR [ebx+ebx]

; 7426 :                 while (size > newSize) {

	cmp	ecx, esi
	jbe	SHORT $LN19@xmlBufferR
	npad	10
$LL6@xmlBufferR:

; 7427 :                     if (newSize > UINT_MAX / 2) {

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN43@xmlBufferR

; 7428 :                         xmlTreeErrMemory("growing buffer");
; 7429 :                         return 0;
; 7430 :                     }
; 7431 :                     newSize *= 2;

	add	esi, esi
	cmp	ecx, esi
	ja	SHORT $LL6@xmlBufferR

; 7427 :                     if (newSize > UINT_MAX / 2) {

	jmp	SHORT $LN19@xmlBufferR
$LN18@xmlBufferR:

; 7432 :                 }
; 7433 :             }
; 7434 :             break;
; 7435 : 
; 7436 : 	default:
; 7437 : 	    newSize = size+10;

	lea	esi, DWORD PTR [ecx+10]
$LN2@xmlBufferR:

; 7438 : 	    break;
; 7439 :     }
; 7440 : 
; 7441 :     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {

	cmp	edx, 3
	jne	SHORT $LN19@xmlBufferR
	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	je	SHORT $LN19@xmlBufferR

; 7442 :         start_buf = buf->content - buf->contentIO;

	mov	eax, DWORD PTR [edi]
	mov	ebx, eax
	sub	ebx, ecx

; 7443 : 
; 7444 :         if (start_buf > newSize) {

	cmp	ebx, esi
	jbe	SHORT $LN21@xmlBufferR

; 7445 : 	    /* move data back to start */
; 7446 : 	    memmove(buf->contentIO, buf->content, buf->use);

	push	DWORD PTR [edi+4]
	push	eax
	push	ecx
	call	_memmove

; 7447 : 	    buf->content = buf->contentIO;

	mov	ecx, DWORD PTR [edi+16]
	add	esp, 12					; 0000000cH

; 7448 : 	    buf->content[buf->use] = 0;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], ecx
	mov	BYTE PTR [ecx+eax], 0

; 7484 : 
; 7485 :     return 1;

	mov	eax, 1
	mov	DWORD PTR [edi+8], esi
	pop	esi
	pop	ebx
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
$LN21@xmlBufferR:

; 7449 : 	    buf->size += start_buf;
; 7450 : 	} else {
; 7451 : 	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 7452 : 	    if (rebuf == NULL) {

	test	eax, eax
	je	SHORT $LN43@xmlBufferR

; 7453 : 		xmlTreeErrMemory("growing buffer");
; 7454 : 		return 0;
; 7455 : 	    }
; 7456 : 	    buf->contentIO = rebuf;

	mov	DWORD PTR [edi+16], eax

; 7457 : 	    buf->content = rebuf + start_buf;

	add	eax, ebx

; 7480 : 	}
; 7481 : 	buf->content = rebuf;
; 7482 :     }
; 7483 :     buf->size = newSize;

	mov	DWORD PTR [edi+8], esi
	pop	esi
	mov	DWORD PTR [edi], eax

; 7484 : 
; 7485 :     return 1;

	mov	eax, 1
	pop	ebx
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
$LN24@xmlBufferR:

; 7462 : 	} else if (buf->size - buf->use < 100) {

	sub	ebx, DWORD PTR [edi+4]
	cmp	ebx, 100				; 00000064H
	jae	SHORT $LN26@xmlBufferR

; 7463 : 	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);

	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	ebx, eax

; 7464 :         } else {

	jmp	SHORT $LN28@xmlBufferR
$LN26@xmlBufferR:

; 7465 : 	    /*
; 7466 : 	     * if we are reallocating a buffer far from being full, it's
; 7467 : 	     * better to make a new allocation and copy only the used range
; 7468 : 	     * and free the old one.
; 7469 : 	     */
; 7470 : 	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);

	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 7471 : 	    if (rebuf != NULL) {

	test	ebx, ebx
	je	SHORT $LN43@xmlBufferR

; 7472 : 		memcpy(rebuf, buf->content, buf->use);

	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	push	ebx
	call	_memcpy

; 7473 : 		xmlFree(buf->content);

	push	DWORD PTR [edi]
	call	DWORD PTR _xmlFree

; 7474 : 		rebuf[buf->use] = 0;

	mov	eax, DWORD PTR [edi+4]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [ebx+eax], 0
$LN28@xmlBufferR:

; 7475 : 	    }
; 7476 : 	}
; 7477 : 	if (rebuf == NULL) {

	test	ebx, ebx
	je	SHORT $LN43@xmlBufferR

; 7480 : 	}
; 7481 : 	buf->content = rebuf;
; 7482 :     }
; 7483 :     buf->size = newSize;

	mov	DWORD PTR [edi+8], esi

; 7484 : 
; 7485 :     return 1;

	mov	eax, 1
	pop	esi
	mov	DWORD PTR [edi], ebx
	pop	ebx
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
$LN43@xmlBufferR:

; 7478 : 	    xmlTreeErrMemory("growing buffer");

	push	OFFSET ??_C@_0P@LKGMENGP@growing?5buffer@
	call	_xmlTreeErrMemory
	add	esp, 4

; 7479 : 	    return 0;

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
$LN44@xmlBufferR:

; 7391 :     unsigned int newSize;
; 7392 :     xmlChar* rebuf = NULL;
; 7393 :     size_t start_buf;
; 7394 : 
; 7395 :     if (buf == NULL)
; 7396 :         return(0);
; 7397 : 
; 7398 :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);

	xor	eax, eax
	pop	edi

; 7486 : }

	pop	ebp
	ret	0
	npad	1
$LN48@xmlBufferR:
	DD	$LN11@xmlBufferR
	DD	$LN13@xmlBufferR
	DD	$LN18@xmlBufferR
	DD	$LN11@xmlBufferR
	DD	$LN14@xmlBufferR
_xmlBufferResize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferCreateStatic
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlBufferCreateStatic PROC				; COMDAT

; 7114 : xmlBufferCreateStatic(void *mem, size_t size) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _mem$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlBufferC

; 7115 :     xmlBufferPtr ret;
; 7116 : 
; 7117 :     if ((mem == NULL) || (size == 0))

	mov	esi, DWORD PTR _size$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlBufferC

; 7118 :         return(NULL);
; 7119 : 
; 7120 :     ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 7121 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlBufferC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN3@xmlBufferC:
	pop	edi

; 7129 :     return(ret);
; 7130 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlBufferC:

; 7122 : 	xmlTreeErrMemory("creating buffer");
; 7123 :         return(NULL);
; 7124 :     }
; 7125 :     ret->use = size;
; 7126 :     ret->size = size;
; 7127 :     ret->alloc = XML_BUFFER_ALLOC_IMMUTABLE;
; 7128 :     ret->content = (xmlChar *) mem;

	mov	DWORD PTR [eax], edi
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], 2

; 7129 :     return(ret);
; 7130 : }

	pop	esi
	pop	ebp
	ret	0
_xmlBufferCreateStatic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferCreateSize
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlBufferCreateSize PROC				; COMDAT

; 7049 : xmlBufferCreateSize(size_t size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlBufferC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7050 :     xmlBufferPtr ret;
; 7051 : 
; 7052 :     ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));
; 7053 :     if (ret == NULL) {
; 7054 : 	xmlTreeErrMemory("creating buffer");
; 7055 :         return(NULL);

	xor	eax, eax
	pop	esi

; 7072 : }

	pop	ebp
	ret	0
$LN2@xmlBufferC:

; 7056 :     }
; 7057 :     ret->use = 0;

	mov	DWORD PTR [esi+4], 0

; 7058 :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme

; 7059 :     ret->size = (size ? size+2 : 0);         /* +1 for ending null */

	mov	ecx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+12], eax
	lea	eax, DWORD PTR [ecx+2]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	mov	DWORD PTR [esi+8], ecx

; 7060 :     if (ret->size){

	je	SHORT $LN3@xmlBufferC

; 7061 :         ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 7062 :         if (ret->content == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlBufferC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 7063 : 	    xmlTreeErrMemory("creating buffer");
; 7064 :             xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 7065 :             return(NULL);

	xor	eax, eax
	pop	esi

; 7072 : }

	pop	ebp
	ret	0
$LN5@xmlBufferC:

; 7066 :         }
; 7067 :         ret->content[0] = 0;

	mov	BYTE PTR [eax], 0

; 7070 :     ret->contentIO = NULL;
; 7071 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 7072 : }

	pop	ebp
	ret	0
$LN3@xmlBufferC:

; 7068 :     } else
; 7069 : 	ret->content = NULL;

	mov	DWORD PTR [esi], 0

; 7070 :     ret->contentIO = NULL;
; 7071 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 7072 : }

	pop	ebp
	ret	0
_xmlBufferCreateSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBufferCreate
_TEXT	SEGMENT
_xmlBufferCreate PROC					; COMDAT

; 7019 : xmlBufferCreate(void) {

	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlBufferC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 7020 :     xmlBufferPtr ret;
; 7021 : 
; 7022 :     ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));
; 7023 :     if (ret == NULL) {
; 7024 : 	xmlTreeErrMemory("creating buffer");
; 7025 :         return(NULL);

	xor	eax, eax
	pop	esi

; 7039 : }

	ret	0
$LN2@xmlBufferC:

; 7026 :     }
; 7027 :     ret->use = 0;

	mov	DWORD PTR [esi+4], 0

; 7028 :     ret->size = xmlDefaultBufferSize;

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], eax

; 7029 :     ret->alloc = xmlBufferAllocScheme;

	call	___xmlBufferAllocScheme

; 7030 :     ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));

	push	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 7031 :     if (ret->content == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlBufferC

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError

; 7032 : 	xmlTreeErrMemory("creating buffer");
; 7033 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 7034 :         return(NULL);

	xor	eax, eax
	pop	esi

; 7039 : }

	ret	0
$LN3@xmlBufferC:

; 7035 :     }
; 7036 :     ret->content[0] = 0;

	mov	BYTE PTR [eax], 0

; 7037 :     ret->contentIO = NULL;
; 7038 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+16], 0
	pop	esi

; 7039 : }

	ret	0
_xmlBufferCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlGetBufferAllocationScheme
_TEXT	SEGMENT
_xmlGetBufferAllocationScheme PROC			; COMDAT
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlBufferAllocScheme
	mov	eax, DWORD PTR [eax]
	ret	0
_xmlGetBufferAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSetBufferAllocationScheme
_TEXT	SEGMENT
_scheme$ = 8						; size = 4
_xmlSetBufferAllocationScheme PROC			; COMDAT

; 692  : xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _scheme$[ebp]
	cmp	esi, 1
	je	SHORT $LN3@xmlSetBuff

; 693  :     if ((scheme == XML_BUFFER_ALLOC_EXACT) ||
; 694  :         (scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||

	test	esi, esi
	je	SHORT $LN3@xmlSetBuff
	cmp	esi, 4
	jne	SHORT $LN2@xmlSetBuff
$LN3@xmlSetBuff:

; 695  :         (scheme == XML_BUFFER_ALLOC_HYBRID))
; 696  : 	xmlBufferAllocScheme = scheme;

	call	___xmlBufferAllocScheme
	mov	DWORD PTR [eax], esi
$LN2@xmlSetBuff:
	pop	esi

; 697  : }

	pop	ebp
	ret	0
_xmlSetBufferAllocationScheme ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSplitQName3
_TEXT	SEGMENT
_name$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlSplitQName3 PROC					; COMDAT

; 328  : xmlSplitQName3(const xmlChar *name, int *len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _name$[ebp]
	xor	ecx, ecx
	test	edx, edx
	je	SHORT $LN13@xmlSplitQN

; 329  :     int l = 0;
; 330  : 
; 331  :     if (name == NULL) return(NULL);
; 332  :     if (len == NULL) return(NULL);

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	je	SHORT $LN13@xmlSplitQN

; 333  : 
; 334  :     /* nasty but valid */
; 335  :     if (name[0] == ':')

	mov	al, BYTE PTR [edx]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN13@xmlSplitQN

; 336  : 	return(NULL);
; 337  : 
; 338  :     /*
; 339  :      * we are not trying to validate but just to cut, and yes it will
; 340  :      * work even if this is as set of UTF-8 encoded chars
; 341  :      */
; 342  :     while ((name[l] != 0) && (name[l] != ':'))

	test	al, al
	je	SHORT $LN14@xmlSplitQN
$LL2@xmlSplitQN:
	cmp	al, 58					; 0000003aH
	je	SHORT $LN14@xmlSplitQN
	mov	al, BYTE PTR [ecx+edx+1]

; 343  : 	l++;

	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlSplitQN
$LN14@xmlSplitQN:

; 344  : 
; 345  :     if (name[l] == 0)

	cmp	BYTE PTR [ecx+edx], 0
	je	SHORT $LN13@xmlSplitQN

; 347  : 
; 348  :     *len = l;
; 349  : 
; 350  :     return(&name[l+1]);

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi], ecx
	add	eax, ecx
	pop	esi

; 351  : }

	pop	ebp
	ret	0
$LN13@xmlSplitQN:

; 346  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_xmlSplitQName3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlSplitQName2
_TEXT	SEGMENT
_name$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlSplitQName2 PROC					; COMDAT

; 268  : xmlSplitQName2(const xmlChar *name, xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _prefix$[ebp]
	xor	ecx, ecx
	test	esi, esi
	je	$LN10@xmlSplitQN

; 269  :     int len = 0;
; 270  :     xmlChar *ret = NULL;
; 271  : 
; 272  :     if (prefix == NULL) return(NULL);
; 273  :     *prefix = NULL;

	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi], ecx

; 274  :     if (name == NULL) return(NULL);

	test	edx, edx
	je	SHORT $LN10@xmlSplitQN

; 275  : 
; 276  : #ifndef XML_XML_NAMESPACE
; 277  :     /* xml: prefix is not really a namespace */
; 278  :     if ((name[0] == 'x') && (name[1] == 'm') &&
; 279  :         (name[2] == 'l') && (name[3] == ':'))
; 280  : 	return(NULL);
; 281  : #endif
; 282  : 
; 283  :     /* nasty but valid */
; 284  :     if (name[0] == ':')

	mov	al, BYTE PTR [edx]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN10@xmlSplitQN

; 285  : 	return(NULL);
; 286  : 
; 287  :     /*
; 288  :      * we are not trying to validate but just to cut, and yes it will
; 289  :      * work even if this is as set of UTF-8 encoded chars
; 290  :      */
; 291  :     while ((name[len] != 0) && (name[len] != ':'))

	test	al, al
	je	SHORT $LN16@xmlSplitQN
	npad	1
$LL2@xmlSplitQN:
	cmp	al, 58					; 0000003aH
	je	SHORT $LN16@xmlSplitQN
	mov	al, BYTE PTR [ecx+edx+1]

; 292  : 	len++;

	inc	ecx
	test	al, al
	jne	SHORT $LL2@xmlSplitQN
$LN16@xmlSplitQN:

; 293  : 
; 294  :     if (name[len] == 0)

	cmp	BYTE PTR [ecx+edx], 0
	lea	edi, DWORD PTR [ecx+edx]
	je	SHORT $LN10@xmlSplitQN

; 295  : 	return(NULL);
; 296  : 
; 297  :     *prefix = xmlStrndup(name, len);

	push	ecx
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 298  :     if (*prefix == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlSplitQN

; 299  : 	xmlTreeErrMemory("QName split");

	push	OFFSET ??_C@_0M@GKLEBIKC@QName?5split@
	call	_xmlTreeErrMemory

; 308  : 	}
; 309  : 	return(NULL);
; 310  :     }
; 311  : 
; 312  :     return(ret);
; 313  : }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlSplitQN:

; 300  : 	return(NULL);
; 301  :     }
; 302  :     ret = xmlStrdup(&name[len + 1]);

	lea	eax, DWORD PTR [edi+1]
	push	eax
	call	_xmlStrdup
	add	esp, 4

; 303  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN1@xmlSplitQN

; 304  : 	xmlTreeErrMemory("QName split");

	push	OFFSET ??_C@_0M@GKLEBIKC@QName?5split@
	call	_xmlTreeErrMemory

; 305  : 	if (*prefix != NULL) {

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@xmlSplitQN

; 306  : 	    xmlFree(*prefix);

	push	eax
	call	DWORD PTR _xmlFree

; 307  : 	    *prefix = NULL;

	mov	DWORD PTR [esi], 0

; 308  : 	}
; 309  : 	return(NULL);
; 310  :     }
; 311  : 
; 312  :     return(ret);
; 313  : }

	add	esp, 4
$LN10@xmlSplitQN:
	xor	eax, eax
$LN1@xmlSplitQN:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlSplitQName2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlBuildQName
_TEXT	SEGMENT
_ncname$ = 8						; size = 4
_prefix$ = 12						; size = 4
_memory$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlBuildQName PROC					; COMDAT

; 224  : 	      xmlChar *memory, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ncname$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlBuildQN

; 248  : }

	pop	ebp
	ret	0
$LN2@xmlBuildQN:

; 225  :     int lenn, lenp;
; 226  :     xmlChar *ret;
; 227  : 
; 228  :     if (ncname == NULL) return(NULL);
; 229  :     if (prefix == NULL) return((xmlChar *) ncname);

	mov	ecx, DWORD PTR _prefix$[ebp]
	test	ecx, ecx
	je	$LN1@xmlBuildQN

; 230  : 
; 231  :     lenn = strlen((char *) ncname);

	push	edi
	mov	edi, eax
	lea	edx, DWORD PTR [edi+1]
$LL11@xmlBuildQN:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL11@xmlBuildQN
	push	esi

; 232  :     lenp = strlen((char *) prefix);

	mov	esi, ecx
	sub	edi, edx
	lea	edx, DWORD PTR [esi+1]
$LL12@xmlBuildQN:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL12@xmlBuildQN
	push	ebx

; 233  : 
; 234  :     if ((memory == NULL) || (len < lenn + lenp + 2)) {

	mov	ebx, DWORD PTR _memory$[ebp]
	sub	esi, edx
	test	ebx, ebx
	je	SHORT $LN6@xmlBuildQN
	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	cmp	DWORD PTR _len$[ebp], eax
	jge	SHORT $LN7@xmlBuildQN
$LN6@xmlBuildQN:

; 235  : 	ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, esi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 236  : 	if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN13@xmlBuildQN

; 80   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0P@LPKFEOPI@building?5QName@
	push	eax
	push	eax
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 237  : 	    xmlTreeErrMemory("building QName");
; 238  : 	    return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 248  : }

	pop	ebp
	ret	0
$LN13@xmlBuildQN:

; 236  : 	if (ret == NULL) {

	mov	ecx, DWORD PTR _prefix$[ebp]
$LN7@xmlBuildQN:

; 239  : 	}
; 240  :     } else {
; 241  : 	ret = memory;
; 242  :     }
; 243  :     memcpy(&ret[0], prefix, lenp);

	push	esi
	push	ecx
	push	ebx
	call	_memcpy

; 244  :     ret[lenp] = ':';

	add	esi, ebx

; 245  :     memcpy(&ret[lenp + 1], ncname, lenn);

	push	edi
	push	DWORD PTR _ncname$[ebp]
	lea	eax, DWORD PTR [esi+1]
	mov	BYTE PTR [esi], 58			; 0000003aH
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H

; 246  :     ret[lenn + lenp + 1] = 0;

	mov	BYTE PTR [esi+edi+1], 0

; 247  :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi
$LN1@xmlBuildQN:

; 248  : }

	pop	ebp
	ret	0
_xmlBuildQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlValidateNMToken
_TEXT	SEGMENT
_l$ = -4						; size = 4
_value$ = 8						; size = 4
_space$ = 12						; size = 4
_xmlValidateNMToken PROC				; COMDAT

; 614  : xmlValidateNMToken(const xmlChar *value, int space) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	ecx, edi
	test	edi, edi
	jne	SHORT $LN14@xmlValidat

; 615  :     const xmlChar *cur = value;
; 616  :     int c,l;
; 617  : 
; 618  :     if (value == NULL)
; 619  :         return(-1);

	or	eax, -1
	pop	edi

; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlValidat:
	push	ebx

; 620  :     /*
; 621  :      * First quick algorithm for ASCII range
; 622  :      */
; 623  :     if (space)

	mov	ebx, DWORD PTR _space$[ebp]
	test	ebx, ebx
	je	SHORT $LN128@xmlValidat
$LL2@xmlValidat:

; 624  : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlValidat
	cmp	al, 9
	jb	SHORT $LN17@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlValidat
$LN17@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN128@xmlValidat
$LN16@xmlValidat:
	inc	ecx
	jmp	SHORT $LL2@xmlValidat
$LN128@xmlValidat:

; 625  :     if (((*cur >= 'a') && (*cur <= 'z')) ||
; 626  :         ((*cur >= 'A') && (*cur <= 'Z')) ||
; 627  :         ((*cur >= '0') && (*cur <= '9')) ||
; 628  :         (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))

	mov	al, BYTE PTR [ecx]
	push	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN21@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN21@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN22@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN22@xmlValidat:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN23@xmlValidat
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN20@xmlValidat
$LN23@xmlValidat:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN20@xmlValidat
	cmp	al, 45					; 0000002dH
	je	SHORT $LN20@xmlValidat
	cmp	al, 46					; 0000002eH
	je	SHORT $LN20@xmlValidat
	cmp	al, 58					; 0000003aH
	jne	SHORT $try_complex$140
$LN20@xmlValidat:

; 629  : 	cur++;
; 630  :     else
; 631  : 	goto try_complex;
; 632  :     while (((*cur >= 'a') && (*cur <= 'z')) ||
; 633  : 	   ((*cur >= 'A') && (*cur <= 'Z')) ||
; 634  : 	   ((*cur >= '0') && (*cur <= '9')) ||
; 635  : 	   (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 97					; 00000061H
	jb	SHORT $LN25@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN25@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN26@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN26@xmlValidat:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN27@xmlValidat
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN20@xmlValidat
$LN27@xmlValidat:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN20@xmlValidat
	cmp	al, 45					; 0000002dH
	je	SHORT $LN20@xmlValidat
	cmp	al, 46					; 0000002eH
	je	SHORT $LN20@xmlValidat
	cmp	al, 58					; 0000003aH
	je	SHORT $LN20@xmlValidat

; 636  : 	cur++;
; 637  :     if (space)

	test	ebx, ebx
	je	SHORT $LN129@xmlValidat
$LL6@xmlValidat:

; 638  : 	while (IS_BLANK_CH(*cur)) cur++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN29@xmlValidat
	cmp	al, 9
	jb	SHORT $LN30@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN29@xmlValidat
$LN30@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN129@xmlValidat
$LN29@xmlValidat:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL6@xmlValidat
$LN129@xmlValidat:

; 639  :     if (*cur == 0)

	test	al, al
	je	$LN36@xmlValidat
$try_complex$140:

; 640  : 	return(0);
; 641  : 
; 642  : try_complex:
; 643  :     /*
; 644  :      * Second check for chars outside the ASCII range
; 645  :      */
; 646  :     cur = value;
; 647  :     c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 648  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN130@xmlValidat
	npad	5
$LL8@xmlValidat:

; 649  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	$LN49@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN39@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN38@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN39@xmlValidat
$LN38@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN130@xmlValidat
$LN39@xmlValidat:

; 650  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 651  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 652  : 	}

	jmp	SHORT $LL8@xmlValidat
$LN130@xmlValidat:

; 653  :     }
; 654  :     if (!(IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN49@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN43@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	$LN33@xmlValidat
$LN43@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN44@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	$LN33@xmlValidat
$LN44@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN46@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	$LN33@xmlValidat
$LN46@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN47@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	$LN33@xmlValidat
$LN47@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	$LN33@xmlValidat
	jmp	SHORT $LN111@xmlValidat
$LN49@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN33@xmlValidat
$LN111@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN136@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN51@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN33@xmlValidat
$LN51@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN33@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN118@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN33@xmlValidat
$LN118@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN59@xmlValidat
$LN136@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN112@xmlValidat
	jmp	SHORT $LN33@xmlValidat
$LN59@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@xmlValidat
$LN112@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN33@xmlValidat
	cmp	esi, 58					; 0000003aH
	je	SHORT $LN33@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN33@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN33@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN119@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN64@xmlValidat
$LN119@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN64@xmlValidat:
	test	eax, eax
	je	$LN125@xmlValidat
$LN33@xmlValidat:

; 655  :         (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)))
; 656  : 	return(1);
; 657  :     cur += l;
; 658  :     c = CUR_SCHAR(cur, l);
; 659  :     while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
; 660  : 	   (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {

	add	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN71@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN65@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN33@xmlValidat
$LN65@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN66@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN33@xmlValidat
$LN66@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN68@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN33@xmlValidat
$LN68@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN69@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN33@xmlValidat
$LN69@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN33@xmlValidat
	jmp	SHORT $LN114@xmlValidat
$LN71@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN33@xmlValidat
$LN114@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN138@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN73@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN33@xmlValidat
$LN73@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN33@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN120@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN33@xmlValidat
$LN120@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN81@xmlValidat
$LN138@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN115@xmlValidat
	jmp	$LN33@xmlValidat
$LN81@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN33@xmlValidat
$LN115@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN33@xmlValidat
	cmp	esi, 58					; 0000003aH
	je	$LN33@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN33@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN33@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN121@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN33@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN86@xmlValidat
$LN121@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN86@xmlValidat:
	test	eax, eax
	jne	$LN33@xmlValidat

; 661  : 	cur += l;
; 662  : 	c = CUR_SCHAR(cur, l);
; 663  :     }
; 664  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN131@xmlValidat
	npad	1
$LL12@xmlValidat:

; 665  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN131@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN88@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN87@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN88@xmlValidat
$LN87@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN131@xmlValidat
$LN88@xmlValidat:

; 666  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 667  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 668  : 	}

	jmp	SHORT $LL12@xmlValidat
$LN131@xmlValidat:

; 669  :     }
; 670  :     if (c != 0)

	test	esi, esi
	je	SHORT $LN36@xmlValidat
$LN125@xmlValidat:
	pop	esi
	pop	ebx

; 671  : 	return(1);

	mov	eax, 1
	pop	edi

; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlValidat:
	pop	esi
	pop	ebx

; 672  :     return(0);

	xor	eax, eax
	pop	edi

; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNMToken ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlValidateName
_TEXT	SEGMENT
_l$ = -4						; size = 4
_value$ = 8						; size = 4
_space$ = 12						; size = 4
_xmlValidateName PROC					; COMDAT

; 545  : xmlValidateName(const xmlChar *value, int space) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	ecx, edi
	test	edi, edi
	jne	SHORT $LN14@xmlValidat

; 546  :     const xmlChar *cur = value;
; 547  :     int c,l;
; 548  : 
; 549  :     if (value == NULL)
; 550  :         return(-1);

	or	eax, -1
	pop	edi

; 601  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlValidat:
	push	ebx

; 551  :     /*
; 552  :      * First quick algorithm for ASCII range
; 553  :      */
; 554  :     if (space)

	mov	ebx, DWORD PTR _space$[ebp]
	test	ebx, ebx
	je	SHORT $LN116@xmlValidat
$LL2@xmlValidat:

; 555  : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlValidat
	cmp	al, 9
	jb	SHORT $LN17@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlValidat
$LN17@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN116@xmlValidat
$LN16@xmlValidat:
	inc	ecx
	jmp	SHORT $LL2@xmlValidat
$LN116@xmlValidat:

; 556  :     if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
; 557  : 	(*cur == '_') || (*cur == ':'))

	mov	al, BYTE PTR [ecx]
	push	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN21@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN21@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN22@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN22@xmlValidat:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN20@xmlValidat
	cmp	al, 58					; 0000003aH
	jne	SHORT $try_complex$126
$LN20@xmlValidat:

; 558  : 	cur++;
; 559  :     else
; 560  : 	goto try_complex;
; 561  :     while (((*cur >= 'a') && (*cur <= 'z')) ||
; 562  : 	   ((*cur >= 'A') && (*cur <= 'Z')) ||
; 563  : 	   ((*cur >= '0') && (*cur <= '9')) ||
; 564  : 	   (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 97					; 00000061H
	jb	SHORT $LN24@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN24@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN25@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN25@xmlValidat:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN26@xmlValidat
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN20@xmlValidat
$LN26@xmlValidat:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN20@xmlValidat
	cmp	al, 45					; 0000002dH
	je	SHORT $LN20@xmlValidat
	cmp	al, 46					; 0000002eH
	je	SHORT $LN20@xmlValidat
	cmp	al, 58					; 0000003aH
	je	SHORT $LN20@xmlValidat

; 565  : 	cur++;
; 566  :     if (space)

	test	ebx, ebx
	je	SHORT $LN117@xmlValidat
$LL6@xmlValidat:

; 567  : 	while (IS_BLANK_CH(*cur)) cur++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN28@xmlValidat
	cmp	al, 9
	jb	SHORT $LN29@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN28@xmlValidat
$LN29@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN117@xmlValidat
$LN28@xmlValidat:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL6@xmlValidat
$LN117@xmlValidat:

; 568  :     if (*cur == 0)

	test	al, al
	je	$LN35@xmlValidat
$try_complex$126:

; 569  : 	return(0);
; 570  : 
; 571  : try_complex:
; 572  :     /*
; 573  :      * Second check for chars outside the ASCII range
; 574  :      */
; 575  :     cur = value;
; 576  :     c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 577  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN118@xmlValidat
	npad	5
$LL8@xmlValidat:

; 578  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN48@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN38@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN37@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN38@xmlValidat
$LN37@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN118@xmlValidat
$LN38@xmlValidat:

; 579  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 580  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 581  : 	}

	jmp	SHORT $LL8@xmlValidat
$LN118@xmlValidat:

; 582  :     }
; 583  :     if ((!IS_LETTER(c)) && (c != '_') && (c != ':'))

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN48@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN42@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	$LN32@xmlValidat
$LN42@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN43@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN32@xmlValidat
$LN43@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN45@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN32@xmlValidat
$LN45@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN46@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN32@xmlValidat
$LN46@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN32@xmlValidat
	jmp	SHORT $LN102@xmlValidat
$LN48@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@xmlValidat
$LN102@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN107@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN50@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN32@xmlValidat
$LN50@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN32@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN107@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN32@xmlValidat
$LN107@xmlValidat:
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN32@xmlValidat
	cmp	esi, 58					; 0000003aH
	jne	$LN113@xmlValidat
$LN32@xmlValidat:

; 584  : 	return(1);
; 585  :     cur += l;
; 586  :     c = CUR_SCHAR(cur, l);
; 587  :     while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') || (c == ':') ||
; 588  : 	   (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {

	add	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN62@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN56@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN32@xmlValidat
$LN56@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN57@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN32@xmlValidat
$LN57@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN59@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN32@xmlValidat
$LN59@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN60@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN32@xmlValidat
$LN60@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN32@xmlValidat
	jmp	SHORT $LN103@xmlValidat
$LN62@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@xmlValidat
$LN103@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN124@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN64@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN32@xmlValidat
$LN64@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN32@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN108@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN32@xmlValidat
$LN108@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN72@xmlValidat
$LN124@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN104@xmlValidat
	jmp	$LN32@xmlValidat
$LN72@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlValidat
$LN104@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN32@xmlValidat
	cmp	esi, 58					; 0000003aH
	je	$LN32@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN32@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN32@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN109@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN77@xmlValidat
$LN109@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN77@xmlValidat:
	test	eax, eax
	jne	$LN32@xmlValidat

; 589  : 	cur += l;
; 590  : 	c = CUR_SCHAR(cur, l);
; 591  :     }
; 592  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN119@xmlValidat
$LL12@xmlValidat:

; 593  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN119@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN79@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN78@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN79@xmlValidat
$LN78@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN119@xmlValidat
$LN79@xmlValidat:

; 594  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 595  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 596  : 	}

	jmp	SHORT $LL12@xmlValidat
$LN119@xmlValidat:

; 597  :     }
; 598  :     if (c != 0)

	test	esi, esi
	je	SHORT $LN35@xmlValidat
$LN113@xmlValidat:
	pop	esi
	pop	ebx

; 599  : 	return(1);

	mov	eax, 1
	pop	edi

; 601  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlValidat:
	pop	esi
	pop	ebx

; 600  :     return(0);

	xor	eax, eax
	pop	edi

; 601  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlValidateQName
_TEXT	SEGMENT
_l$ = -4						; size = 4
_value$ = 8						; size = 4
_space$ = 12						; size = 4
_xmlValidateQName PROC					; COMDAT

; 447  : xmlValidateQName(const xmlChar *value, int space) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	eax, edi
	test	edi, edi
	jne	SHORT $LN18@xmlValidat

; 448  :     const xmlChar *cur = value;
; 449  :     int c,l;
; 450  : 
; 451  :     if (value == NULL)
; 452  :         return(-1);

	or	eax, -1
	pop	edi

; 532  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlValidat:
	push	ebx

; 453  :     /*
; 454  :      * First quick algorithm for ASCII range
; 455  :      */
; 456  :     if (space)

	mov	ebx, DWORD PTR _space$[ebp]
	test	ebx, ebx
	je	SHORT $LN182@xmlValidat
$LL2@xmlValidat:

; 457  : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN20@xmlValidat
	cmp	cl, 9
	jb	SHORT $LN21@xmlValidat
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN20@xmlValidat
$LN21@xmlValidat:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN182@xmlValidat
$LN20@xmlValidat:
	inc	eax
	jmp	SHORT $LL2@xmlValidat
$LN182@xmlValidat:

; 458  :     if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||

	mov	cl, BYTE PTR [eax]
	push	esi
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN25@xmlValidat
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN24@xmlValidat
$LN25@xmlValidat:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN26@xmlValidat
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN24@xmlValidat
$LN26@xmlValidat:
	cmp	cl, 95					; 0000005fH
	jne	$try_complex$196
$LN24@xmlValidat:

; 459  : 	(*cur == '_'))
; 460  : 	cur++;
; 461  :     else
; 462  : 	goto try_complex;
; 463  :     while (((*cur >= 'a') && (*cur <= 'z')) ||
; 464  : 	   ((*cur >= 'A') && (*cur <= 'Z')) ||
; 465  : 	   ((*cur >= '0') && (*cur <= '9')) ||
; 466  : 	   (*cur == '_') || (*cur == '-') || (*cur == '.'))

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN28@xmlValidat
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN24@xmlValidat
$LN28@xmlValidat:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN29@xmlValidat
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN24@xmlValidat
$LN29@xmlValidat:
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN30@xmlValidat
	cmp	cl, 57					; 00000039H
	jbe	SHORT $LN24@xmlValidat
$LN30@xmlValidat:
	cmp	cl, 95					; 0000005fH
	je	SHORT $LN24@xmlValidat
	cmp	cl, 45					; 0000002dH
	je	SHORT $LN24@xmlValidat
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN24@xmlValidat

; 467  : 	cur++;
; 468  :     if (*cur == ':') {

	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN183@xmlValidat

; 469  : 	cur++;
; 470  : 	if (((*cur >= 'a') && (*cur <= 'z')) ||
; 471  : 	    ((*cur >= 'A') && (*cur <= 'Z')) ||

	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN35@xmlValidat
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN34@xmlValidat
$LN35@xmlValidat:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN36@xmlValidat
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN34@xmlValidat
$LN36@xmlValidat:
	cmp	cl, 95					; 0000005fH
	jne	SHORT $try_complex$196
$LN34@xmlValidat:

; 472  : 	    (*cur == '_'))
; 473  : 	    cur++;

	add	eax, 2
$LL6@xmlValidat:

; 474  : 	else
; 475  : 	    goto try_complex;
; 476  : 	while (((*cur >= 'a') && (*cur <= 'z')) ||
; 477  : 	       ((*cur >= 'A') && (*cur <= 'Z')) ||
; 478  : 	       ((*cur >= '0') && (*cur <= '9')) ||
; 479  : 	       (*cur == '_') || (*cur == '-') || (*cur == '.'))

	mov	cl, BYTE PTR [eax]
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN38@xmlValidat
	cmp	cl, 122					; 0000007aH
	jbe	SHORT $LN37@xmlValidat
$LN38@xmlValidat:
	cmp	cl, 65					; 00000041H
	jb	SHORT $LN39@xmlValidat
	cmp	cl, 90					; 0000005aH
	jbe	SHORT $LN37@xmlValidat
$LN39@xmlValidat:
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN40@xmlValidat
	cmp	cl, 57					; 00000039H
	jbe	SHORT $LN37@xmlValidat
$LN40@xmlValidat:
	cmp	cl, 95					; 0000005fH
	je	SHORT $LN37@xmlValidat
	cmp	cl, 45					; 0000002dH
	je	SHORT $LN37@xmlValidat
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN183@xmlValidat
$LN37@xmlValidat:

; 480  : 	    cur++;

	inc	eax
	jmp	SHORT $LL6@xmlValidat
$LN183@xmlValidat:

; 481  :     }
; 482  :     if (space)

	test	ebx, ebx
	je	SHORT $LN184@xmlValidat
	npad	4
$LL8@xmlValidat:

; 483  : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN42@xmlValidat
	cmp	cl, 9
	jb	SHORT $LN43@xmlValidat
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN42@xmlValidat
$LN43@xmlValidat:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN184@xmlValidat
$LN42@xmlValidat:
	inc	eax
	jmp	SHORT $LL8@xmlValidat
$LN184@xmlValidat:

; 484  :     if (*cur == 0)

	cmp	BYTE PTR [eax], 0
	je	$LN52@xmlValidat
$try_complex$196:

; 485  : 	return(0);
; 486  : 
; 487  : try_complex:
; 488  :     /*
; 489  :      * Second check for chars outside the ASCII range
; 490  :      */
; 491  :     cur = value;
; 492  :     c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 493  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN185@xmlValidat
$LL10@xmlValidat:

; 494  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN65@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN55@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN54@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN55@xmlValidat
$LN54@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN185@xmlValidat
$LN55@xmlValidat:

; 495  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 496  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 497  : 	}

	jmp	SHORT $LL10@xmlValidat
$LN185@xmlValidat:

; 498  :     }
; 499  :     if ((!IS_LETTER(c)) && (c != '_'))

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN65@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN59@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN46@xmlValidat
$LN59@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN60@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN46@xmlValidat
$LN60@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN62@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN46@xmlValidat
$LN62@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN63@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN46@xmlValidat
$LN63@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN46@xmlValidat
	jmp	SHORT $LN161@xmlValidat
$LN65@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN46@xmlValidat
$LN161@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN170@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN67@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN46@xmlValidat
$LN67@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN46@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN170@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN46@xmlValidat
$LN170@xmlValidat:
	cmp	esi, 95					; 0000005fH
	jne	$LN179@xmlValidat
$LN46@xmlValidat:

; 500  : 	return(1);
; 501  :     cur += l;
; 502  :     c = CUR_SCHAR(cur, l);
; 503  :     while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
; 504  : 	   (c == '-') || (c == '_') || IS_COMBINING(c) ||

	add	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN79@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN73@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN46@xmlValidat
$LN73@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN74@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN46@xmlValidat
$LN74@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN76@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN46@xmlValidat
$LN76@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN77@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN46@xmlValidat
$LN77@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN46@xmlValidat
	jmp	SHORT $LN162@xmlValidat
$LN79@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN46@xmlValidat
$LN162@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN192@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN81@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN46@xmlValidat
$LN81@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN46@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN171@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN46@xmlValidat
$LN171@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN89@xmlValidat
$LN192@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN163@xmlValidat
	jmp	$LN46@xmlValidat
$LN89@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN46@xmlValidat
$LN163@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN46@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN46@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN46@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN172@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN46@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN94@xmlValidat
$LN172@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN94@xmlValidat:
	test	eax, eax
	jne	$LN46@xmlValidat

; 505  : 	   IS_EXTENDER(c)) {
; 506  : 	cur += l;
; 507  : 	c = CUR_SCHAR(cur, l);
; 508  :     }
; 509  :     if (c == ':') {

	cmp	esi, 58					; 0000003aH
	jne	$LN186@xmlValidat

; 510  : 	cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 511  : 	c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 512  : 	if ((!IS_LETTER(c)) && (c != '_'))

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN101@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN95@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN49@xmlValidat
$LN95@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN96@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN49@xmlValidat
$LN96@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN98@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN49@xmlValidat
$LN98@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN99@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN49@xmlValidat
$LN99@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN49@xmlValidat
	jmp	SHORT $LN165@xmlValidat
$LN101@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN49@xmlValidat
$LN165@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN173@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN103@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN49@xmlValidat
$LN103@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN49@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN173@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN49@xmlValidat
$LN173@xmlValidat:
	cmp	esi, 95					; 0000005fH
	jne	$LN179@xmlValidat
$LN49@xmlValidat:

; 513  : 	    return(1);
; 514  : 	cur += l;
; 515  : 	c = CUR_SCHAR(cur, l);
; 516  : 	while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
; 517  : 	       (c == '-') || (c == '_') || IS_COMBINING(c) ||

	add	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN115@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN109@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN49@xmlValidat
$LN109@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN110@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN49@xmlValidat
$LN110@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN112@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN49@xmlValidat
$LN112@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN113@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN49@xmlValidat
$LN113@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN49@xmlValidat
	jmp	SHORT $LN166@xmlValidat
$LN115@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN49@xmlValidat
$LN166@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN194@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN117@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN49@xmlValidat
$LN117@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN49@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN174@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN49@xmlValidat
$LN174@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN125@xmlValidat
$LN194@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN167@xmlValidat
	jmp	$LN49@xmlValidat
$LN125@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN49@xmlValidat
$LN167@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN49@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN49@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN49@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN175@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN49@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN130@xmlValidat
$LN175@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN130@xmlValidat:
	test	eax, eax
	jne	$LN49@xmlValidat
$LN186@xmlValidat:

; 518  : 	       IS_EXTENDER(c)) {
; 519  : 	    cur += l;
; 520  : 	    c = CUR_SCHAR(cur, l);
; 521  : 	}
; 522  :     }
; 523  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN187@xmlValidat
	npad	6
$LL16@xmlValidat:

; 524  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN187@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN132@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN131@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN132@xmlValidat
$LN131@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN187@xmlValidat
$LN132@xmlValidat:

; 525  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 526  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 527  : 	}

	jmp	SHORT $LL16@xmlValidat
$LN187@xmlValidat:

; 528  :     }
; 529  :     if (c != 0)

	test	esi, esi
	je	SHORT $LN52@xmlValidat
$LN179@xmlValidat:
	pop	esi
	pop	ebx

; 530  : 	return(1);

	mov	eax, 1
	pop	edi

; 532  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlValidat:
	pop	esi
	pop	ebx

; 531  :     return(0);

	xor	eax, eax
	pop	edi

; 532  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\tree.c
;	COMDAT _xmlValidateNCName
_TEXT	SEGMENT
_l$ = -4						; size = 4
_value$ = 8						; size = 4
_space$ = 12						; size = 4
_xmlValidateNCName PROC					; COMDAT

; 373  : xmlValidateNCName(const xmlChar *value, int space) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __59973643_tree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _value$[ebp]
	mov	ecx, edi
	test	edi, edi
	jne	SHORT $LN14@xmlValidat

; 374  :     const xmlChar *cur = value;
; 375  :     int c,l;
; 376  : 
; 377  :     if (value == NULL)
; 378  :         return(-1);

	or	eax, -1
	pop	edi

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlValidat:
	push	ebx

; 379  : 
; 380  :     /*
; 381  :      * First quick algorithm for ASCII range
; 382  :      */
; 383  :     if (space)

	mov	ebx, DWORD PTR _space$[ebp]
	test	ebx, ebx
	je	SHORT $LN116@xmlValidat
$LL2@xmlValidat:

; 384  : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlValidat
	cmp	al, 9
	jb	SHORT $LN17@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlValidat
$LN17@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN116@xmlValidat
$LN16@xmlValidat:
	inc	ecx
	jmp	SHORT $LL2@xmlValidat
$LN116@xmlValidat:

; 385  :     if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||

	mov	al, BYTE PTR [ecx]
	push	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN21@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN21@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN22@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN22@xmlValidat:
	cmp	al, 95					; 0000005fH
	jne	SHORT $try_complex$126
$LN20@xmlValidat:

; 386  : 	(*cur == '_'))
; 387  : 	cur++;
; 388  :     else
; 389  : 	goto try_complex;
; 390  :     while (((*cur >= 'a') && (*cur <= 'z')) ||
; 391  : 	   ((*cur >= 'A') && (*cur <= 'Z')) ||
; 392  : 	   ((*cur >= '0') && (*cur <= '9')) ||
; 393  : 	   (*cur == '_') || (*cur == '-') || (*cur == '.'))

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 97					; 00000061H
	jb	SHORT $LN24@xmlValidat
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN20@xmlValidat
$LN24@xmlValidat:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN25@xmlValidat
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN20@xmlValidat
$LN25@xmlValidat:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN26@xmlValidat
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN20@xmlValidat
$LN26@xmlValidat:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN20@xmlValidat
	cmp	al, 45					; 0000002dH
	je	SHORT $LN20@xmlValidat
	cmp	al, 46					; 0000002eH
	je	SHORT $LN20@xmlValidat

; 394  : 	cur++;
; 395  :     if (space)

	test	ebx, ebx
	je	SHORT $LN117@xmlValidat
$LL6@xmlValidat:

; 396  : 	while (IS_BLANK_CH(*cur)) cur++;

	cmp	al, 32					; 00000020H
	je	SHORT $LN28@xmlValidat
	cmp	al, 9
	jb	SHORT $LN29@xmlValidat
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN28@xmlValidat
$LN29@xmlValidat:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN117@xmlValidat
$LN28@xmlValidat:
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	jmp	SHORT $LL6@xmlValidat
$LN117@xmlValidat:

; 397  :     if (*cur == 0)

	test	al, al
	je	$LN35@xmlValidat
$try_complex$126:

; 398  : 	return(0);
; 399  : 
; 400  : try_complex:
; 401  :     /*
; 402  :      * Second check for chars outside the ASCII range
; 403  :      */
; 404  :     cur = value;
; 405  :     c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 406  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN118@xmlValidat
$LL8@xmlValidat:

; 407  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN48@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN38@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN37@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN38@xmlValidat
$LN37@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN118@xmlValidat
$LN38@xmlValidat:

; 408  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 409  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 410  : 	}

	jmp	SHORT $LL8@xmlValidat
$LN118@xmlValidat:

; 411  :     }
; 412  :     if ((!IS_LETTER(c)) && (c != '_'))

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN48@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN42@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN32@xmlValidat
$LN42@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN43@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN32@xmlValidat
$LN43@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN45@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN32@xmlValidat
$LN45@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN46@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN32@xmlValidat
$LN46@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN32@xmlValidat
	jmp	SHORT $LN102@xmlValidat
$LN48@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@xmlValidat
$LN102@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN107@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN50@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LN32@xmlValidat
$LN50@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LN32@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN107@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN32@xmlValidat
$LN107@xmlValidat:
	cmp	esi, 95					; 0000005fH
	jne	$LN113@xmlValidat
$LN32@xmlValidat:

; 413  : 	return(1);
; 414  :     cur += l;
; 415  :     c = CUR_SCHAR(cur, l);
; 416  :     while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
; 417  : 	   (c == '-') || (c == '_') || IS_COMBINING(c) ||

	add	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	mov	esi, eax
	add	esp, 12					; 0000000cH
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN62@xmlValidat
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN56@xmlValidat
	cmp	esi, 90					; 0000005aH
	jle	SHORT $LN32@xmlValidat
$LN56@xmlValidat:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN57@xmlValidat
	cmp	esi, 122				; 0000007aH
	jle	SHORT $LN32@xmlValidat
$LN57@xmlValidat:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN59@xmlValidat
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LN32@xmlValidat
$LN59@xmlValidat:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN60@xmlValidat
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LN32@xmlValidat
$LN60@xmlValidat:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LN32@xmlValidat
	jmp	SHORT $LN103@xmlValidat
$LN62@xmlValidat:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@xmlValidat
$LN103@xmlValidat:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN124@xmlValidat
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN64@xmlValidat
	cmp	esi, 40869				; 00009fa5H
	jle	$LN32@xmlValidat
$LN64@xmlValidat:
	cmp	esi, 12295				; 00003007H
	je	$LN32@xmlValidat
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN108@xmlValidat
	cmp	esi, 12329				; 00003029H
	jle	$LN32@xmlValidat
$LN108@xmlValidat:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN72@xmlValidat
$LN124@xmlValidat:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN104@xmlValidat
	jmp	$LN32@xmlValidat
$LN72@xmlValidat:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlValidat
$LN104@xmlValidat:
	cmp	esi, 46					; 0000002eH
	je	$LN32@xmlValidat
	cmp	esi, 45					; 0000002dH
	je	$LN32@xmlValidat
	cmp	esi, 95					; 0000005fH
	je	$LN32@xmlValidat
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN109@xmlValidat
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN32@xmlValidat
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN77@xmlValidat
$LN109@xmlValidat:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN77@xmlValidat:
	test	eax, eax
	jne	$LN32@xmlValidat

; 418  : 	   IS_EXTENDER(c)) {
; 419  : 	cur += l;
; 420  : 	c = CUR_SCHAR(cur, l);
; 421  :     }
; 422  :     if (space) {

	test	ebx, ebx
	je	SHORT $LN119@xmlValidat
	npad	7
$LL12@xmlValidat:

; 423  : 	while (IS_BLANK(c)) {

	cmp	esi, 256				; 00000100H
	jge	SHORT $LN119@xmlValidat
	cmp	esi, 32					; 00000020H
	je	SHORT $LN79@xmlValidat
	cmp	esi, 9
	jl	SHORT $LN78@xmlValidat
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN79@xmlValidat
$LN78@xmlValidat:
	cmp	esi, 13					; 0000000dH
	jne	SHORT $LN119@xmlValidat
$LN79@xmlValidat:

; 424  : 	    cur += l;

	add	edi, DWORD PTR _l$[ebp]

; 425  : 	    c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 426  : 	}

	jmp	SHORT $LL12@xmlValidat
$LN119@xmlValidat:

; 427  :     }
; 428  :     if (c != 0)

	test	esi, esi
	je	SHORT $LN35@xmlValidat
$LN113@xmlValidat:
	pop	esi
	pop	ebx

; 429  : 	return(1);

	mov	eax, 1
	pop	edi

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlValidat:
	pop	esi
	pop	ebx

; 430  : 
; 431  :     return(0);

	xor	eax, eax
	pop	edi

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidateNCName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
