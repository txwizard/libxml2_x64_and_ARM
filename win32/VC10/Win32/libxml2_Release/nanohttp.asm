; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\nanohttp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__194286D1_winsock2@h DB 01H
__D940C302_ws2ipdef@h DB 01H
__6E172A35_ws2tcpip@h DB 01H
__331E732B_malloc@h DB 01H
__D1B760F5_wspiapi@h DB 01H
__BDFA7347_nanohttp@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf_s
PUBLIC	_snprintf
PUBLIC	_WspiapiStrdup@4
PUBLIC	_WspiapiNewAddrInfo@16
PUBLIC	_WspiapiLookupNode@24
PUBLIC	_WspiapiLegacyFreeAddrInfo@4
PUBLIC	_WspiapiLegacyGetAddrInfo@16
PUBLIC	_WspiapiLegacyGetNameInfo@28
PUBLIC	_WspiapiLoad@4
PUBLIC	_xmlNanoHTTPInit
PUBLIC	_xmlNanoHTTPCleanup
PUBLIC	_xmlNanoHTTPScanProxy
PUBLIC	_xmlNanoHTTPFetch
PUBLIC	_xmlNanoHTTPMethod
PUBLIC	_xmlNanoHTTPMethodRedir
PUBLIC	_xmlNanoHTTPOpen
PUBLIC	_xmlNanoHTTPOpenRedir
PUBLIC	_xmlNanoHTTPReturnCode
PUBLIC	_xmlNanoHTTPAuthHeader
PUBLIC	_xmlNanoHTTPRedir
PUBLIC	_xmlNanoHTTPContentLength
PUBLIC	_xmlNanoHTTPEncoding
PUBLIC	_xmlNanoHTTPMimeType
PUBLIC	_xmlNanoHTTPRead
PUBLIC	_xmlNanoHTTPSave
PUBLIC	_xmlNanoHTTPClose
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_03OCLLGKEH@udp@				; `string'
PUBLIC	??_C@_03FPEIBLKH@tcp@				; `string'
PUBLIC	??_C@_05LGDGBMPG@65535@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	?bInitialized@?1??WspiapiLoad@@9@9		; `WspiapiLoad'::`2'::bInitialized
PUBLIC	?rgtGlobal@?1??WspiapiLoad@@9@9			; `WspiapiLoad'::`2'::rgtGlobal
PUBLIC	??_C@_0M@MBIPAJOD@getaddrinfo@			; `string'
PUBLIC	??_C@_0M@NNJNLPKG@getnameinfo@			; `string'
PUBLIC	??_C@_0N@EHOPPMLH@freeaddrinfo@			; `string'
PUBLIC	??_C@_07LPPPKMHP@?2ws2_32@			; `string'
PUBLIC	??_C@_07OKMCKPF@?2wship6@			; `string'
PUBLIC	?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9	; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
PUBLIC	?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9	; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
PUBLIC	??_C@_08BOGLDIEC@no_proxy@			; `string'
PUBLIC	??_C@_0L@BKCFCEPH@http_proxy@			; `string'
PUBLIC	??_C@_0L@GDPFKPEL@HTTP_PROXY@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_04IAFLKNP@http@				; `string'
PUBLIC	??_C@_0O@FGOLBKPK@Syntax?5Error?6@		; `string'
PUBLIC	??_C@_0BD@NMNFIMM@allocating?5context@		; `string'
PUBLIC	??_C@_0N@OOKOIPEM@send?5failed?6@		; `string'
PUBLIC	??_C@_0BB@BIOIGIMH@allocating?5input@		; `string'
PUBLIC	??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@	; `string'
PUBLIC	??_C@_0N@NLPHEKBL@recv?5failed?6@		; `string'
PUBLIC	??_C@_05FKGKDBHO@HTTP?1@			; `string'
PUBLIC	??_C@_0O@PDMPCIFL@Content?9Type?3@		; `string'
PUBLIC	??_C@_08JPKHBDLJ@charset?$DN@			; `string'
PUBLIC	??_C@_0N@PPOPBCJG@ContentType?3@		; `string'
PUBLIC	??_C@_09GILIFLDG@Location?3@			; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1@			; `string'
PUBLIC	??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@		; `string'
PUBLIC	??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@	; `string'
PUBLIC	??_C@_0BC@FGDKEGD@Content?9Encoding?3@		; `string'
PUBLIC	??_C@_04HOHEGKBO@gzip@				; `string'
PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
PUBLIC	??_C@_0BA@DIGAFIOK@Content?9Length?3@		; `string'
PUBLIC	??_C@_0P@KCNIDCEL@socket?5failed?6@		; `string'
PUBLIC	??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@ ; `string'
PUBLIC	??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@ ; `string'
PUBLIC	??_C@_0P@NCGOJFHC@Connect?5failed@		; `string'
PUBLIC	??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@	; `string'
PUBLIC	??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@ ; `string'
PUBLIC	??_C@_0P@FGBLCELI@select?5failed?6@		; `string'
PUBLIC	??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@	; `string'
PUBLIC	??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@	; `string'
PUBLIC	??_C@_03HAPOJHBM@GET@				; `string'
PUBLIC	??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@	; `string'
PUBLIC	??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@ ; `string'
PUBLIC	??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@	; `string'
PUBLIC	??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@	; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs@			; `string'
PUBLIC	??_C@_03EMGHGGCK@?$DP?$CFs@			; `string'
PUBLIC	??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@ ; `string'
PUBLIC	??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlCharStrndup:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrncasecmp:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	___xmlIOErr:PROC
EXTRN	__imp___errno:PROC
EXTRN	_strchr:PROC
EXTRN	__imp__strcpy_s:PROC
EXTRN	__imp__strcat_s:PROC
EXTRN	__imp__strncpy_s:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp__getenv:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	_inflate@8:PROC
EXTRN	_inflateEnd@4:PROC
EXTRN	_inflateInit2_@16:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__ioctlsocket@12:PROC
EXTRN	__imp__getsockopt@20:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__ntohs@4:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__gethostbyaddr@12:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__getservbyport@8:PROC
EXTRN	__imp__getservbyname@8:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSACleanup@0:PROC
EXTRN	__imp__WSASetLastError@4:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlParseURIRaw:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ?bInitialized@?1??WspiapiLoad@@9@9
_BSS	SEGMENT
?bInitialized@?1??WspiapiLoad@@9@9 DD 01H DUP (?)	; `WspiapiLoad'::`2'::bInitialized
_BSS	ENDS
;	COMDAT ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9
_BSS	SEGMENT
?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9 DD 01H DUP (?) ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
_BSS	ENDS
;	COMDAT ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9
_BSS	SEGMENT
?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 DD 01H DUP (?) ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
_BSS	ENDS
_BSS	SEGMENT
_initialized DD	01H DUP (?)
_proxy	DD	01H DUP (?)
_proxyPort DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@ DB 'Content-Leng'
	DB	'th: %d', 0dH, 0aH, 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@ DB 'Content-Type: %s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@
CONST	SEGMENT
??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@ DB 'Accept-Encoding: g'
	DB	'zip', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@
CONST	SEGMENT
??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@ DB ' HTT'
	DB	'P/1.0', 0dH, 0aH, 'Host: %s:%d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@ DB ' HTTP/1.0', 0dH
	DB	0aH, 'Host: %s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHGGCK@?$DP?$CFs@
CONST	SEGMENT
??_C@_03EMGHGGCK@?$DP?$CFs@ DB '?%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@
CONST	SEGMENT
??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@ DB '%s http://%s%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@ DB '%s http://%s:%'
	DB	'd%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@
CONST	SEGMENT
??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@ DB 'allocating header buff'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@
CONST	SEGMENT
??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@ DB 'Failed to ide'
	DB	'ntify host in URI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@
CONST	SEGMENT
??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@ DB 'Not a valid HTTP URI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAPOJHBM@GET@
CONST	SEGMENT
??_C@_03HAPOJHBM@GET@ DB 'GET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@
CONST	SEGMENT
??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@ DB 'address size mismatch', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@
CONST	SEGMENT
??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@ DB 'getaddrinfo failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FGBLCELI@select?5failed?6@
CONST	SEGMENT
??_C@_0P@FGBLCELI@select?5failed?6@ DB 'select failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@
CONST	SEGMENT
??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@ DB 'Error connecti'
	DB	'ng to remote host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@
CONST	SEGMENT
??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@ DB 'getsockopt failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCGOJFHC@Connect?5failed@
CONST	SEGMENT
??_C@_0P@NCGOJFHC@Connect?5failed@ DB 'Connect failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@
CONST	SEGMENT
??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@ DB 'Connect attempt time'
	DB	'd out', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@
CONST	SEGMENT
??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@ DB 'error connect'
	DB	'ing to HTTP server', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCNIDCEL@socket?5failed?6@
CONST	SEGMENT
??_C@_0P@KCNIDCEL@socket?5failed?6@ DB 'socket failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DIGAFIOK@Content?9Length?3@
CONST	SEGMENT
??_C@_0BA@DIGAFIOK@Content?9Length?3@ DB 'Content-Length:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHEGKBO@gzip@
CONST	SEGMENT
??_C@_04HOHEGKBO@gzip@ DB 'gzip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGDKEGD@Content?9Encoding?3@
CONST	SEGMENT
??_C@_0BC@FGDKEGD@Content?9Encoding?3@ DB 'Content-Encoding:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@
CONST	SEGMENT
??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@ DB 'Proxy-Authenticate:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@
CONST	SEGMENT
??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@ DB 'WWW-Authenticate:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1@ DB 'http://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GILIFLDG@Location?3@
CONST	SEGMENT
??_C@_09GILIFLDG@Location?3@ DB 'Location:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PPOPBCJG@ContentType?3@
CONST	SEGMENT
??_C@_0N@PPOPBCJG@ContentType?3@ DB 'ContentType:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPKHBDLJ@charset?$DN@
CONST	SEGMENT
??_C@_08JPKHBDLJ@charset?$DN@ DB 'charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDMPCIFL@Content?9Type?3@
CONST	SEGMENT
??_C@_0O@PDMPCIFL@Content?9Type?3@ DB 'Content-Type:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKGKDBHO@HTTP?1@
CONST	SEGMENT
??_C@_05FKGKDBHO@HTTP?1@ DB 'HTTP/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLPHEKBL@recv?5failed?6@
CONST	SEGMENT
??_C@_0N@NLPHEKBL@recv?5failed?6@ DB 'recv failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
CONST	SEGMENT
??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@ DB 'allocating input buffer'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIOIGIMH@allocating?5input@
CONST	SEGMENT
??_C@_0BB@BIOIGIMH@allocating?5input@ DB 'allocating input', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOKOIPEM@send?5failed?6@
CONST	SEGMENT
??_C@_0N@OOKOIPEM@send?5failed?6@ DB 'send failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NMNFIMM@allocating?5context@
CONST	SEGMENT
??_C@_0BD@NMNFIMM@allocating?5context@ DB 'allocating context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
CONST	SEGMENT
??_C@_0O@FGOLBKPK@Syntax?5Error?6@ DB 'Syntax Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAFLKNP@http@
CONST	SEGMENT
??_C@_04IAFLKNP@http@ DB 'http', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDPFKPEL@HTTP_PROXY@
CONST	SEGMENT
??_C@_0L@GDPFKPEL@HTTP_PROXY@ DB 'HTTP_PROXY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKCFCEPH@http_proxy@
CONST	SEGMENT
??_C@_0L@BKCFCEPH@http_proxy@ DB 'http_proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOGLDIEC@no_proxy@
CONST	SEGMENT
??_C@_08BOGLDIEC@no_proxy@ DB 'no_proxy', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_timeout DD	03cH
_DATA	ENDS
;	COMDAT ??_C@_07OKMCKPF@?2wship6@
CONST	SEGMENT
??_C@_07OKMCKPF@?2wship6@ DB '\wship6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LPPPKMHP@?2ws2_32@
CONST	SEGMENT
??_C@_07LPPPKMHP@?2ws2_32@ DB '\ws2_32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHOPPMLH@freeaddrinfo@
CONST	SEGMENT
??_C@_0N@EHOPPMLH@freeaddrinfo@ DB 'freeaddrinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNJNLPKG@getnameinfo@
CONST	SEGMENT
??_C@_0M@NNJNLPKG@getnameinfo@ DB 'getnameinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MBIPAJOD@getaddrinfo@
CONST	SEGMENT
??_C@_0M@MBIPAJOD@getaddrinfo@ DB 'getaddrinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ?rgtGlobal@?1??WspiapiLoad@@9@9
_DATA	SEGMENT
?rgtGlobal@?1??WspiapiLoad@@9@9 DD FLAT:??_C@_0M@MBIPAJOD@getaddrinfo@ ; `WspiapiLoad'::`2'::rgtGlobal
	DD	FLAT:_WspiapiLegacyGetAddrInfo@16
	DD	FLAT:??_C@_0M@NNJNLPKG@getnameinfo@
	DD	FLAT:_WspiapiLegacyGetNameInfo@28
	DD	FLAT:??_C@_0N@EHOPPMLH@freeaddrinfo@
	DD	FLAT:_WspiapiLegacyFreeAddrInfo@4
_DATA	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGDGBMPG@65535@
CONST	SEGMENT
??_C@_05LGDGBMPG@65535@ DB '65535', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPEIBLKH@tcp@
CONST	SEGMENT
??_C@_03FPEIBLKH@tcp@ DB 'tcp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OCLLGKEH@udp@
CONST	SEGMENT
??_C@_03OCLLGKEH@udp@ DB 'udp', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPConnectHost
_TEXT	SEGMENT
_hints$1 = -52						; size = 32
_sockin$ = -20						; size = 16
_result$2 = -4						; size = 4
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_xmlNanoHTTPConnectHost PROC				; COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1018 :     if (!pfGetAddrInfo)

	mov	eax, DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9 ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
	xorps	xmm0, xmm0
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1079 : 	result = NULL;

	mov	DWORD PTR _result$2[ebp], 0

; 1080 : 	memset (&hints, 0,sizeof(hints));

	movups	XMMWORD PTR _hints$1[ebp], xmm0

; 1081 : 	hints.ai_socktype = SOCK_STREAM;

	mov	DWORD PTR _hints$1[ebp+8], 1
	movups	XMMWORD PTR _sockin$[ebp], xmm0
	movups	XMMWORD PTR _hints$1[ebp+16], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1018 :     if (!pfGetAddrInfo)

	test	eax, eax
	jne	SHORT $LN13@xmlNanoHTT

; 1019 :         pfGetAddrInfo   = (WSPIAPI_PGETADDRINFO) WspiapiLoad(0);

	push	eax
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9, eax ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
$LN13@xmlNanoHTT:
	push	esi

; 1020 : 
; 1021 :     iError = (*pfGetAddrInfo)(nodename, servname, hints, res);

	lea	ecx, DWORD PTR _result$2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _hints$1[ebp]
	push	ecx
	push	0
	push	DWORD PTR _host$[ebp]
	call	eax
	mov	esi, eax

; 1022 :     WSASetLastError(iError);

	push	esi
	call	DWORD PTR __imp__WSASetLastError@4
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1084 : 	if (status) {

	test	esi, esi
	je	SHORT $LN5@xmlNanoHTT

; 1085 : 	    __xmlIOErr(XML_FROM_HTTP, 0, "getaddrinfo failed\n");

	push	OFFSET ??_C@_0BE@NABACEGA@getaddrinfo?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1086 : 	    return INVALID_SOCKET;

	or	eax, -1
	pop	esi

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlNanoHTT:

; 1087 : 	}
; 1088 : 
; 1089 : 	for (res = result; res; res = res->ai_next) {

	mov	esi, DWORD PTR _result$2[ebp]
	push	ebx
	push	edi
	test	esi, esi
	je	SHORT $LN21@xmlNanoHTT
	mov	ebx, DWORD PTR _port$[ebp]
$LL4@xmlNanoHTT:

; 1090 : 	    if (res->ai_family == AF_INET) {

	cmp	DWORD PTR [esi+4], 2
	jne	SHORT $LN2@xmlNanoHTT

; 1091 : 		if ((size_t)res->ai_addrlen > sizeof(sockin)) {

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, 16					; 00000010H
	ja	$LN25@xmlNanoHTT

; 1095 : 		}
; 1096 : 		memcpy (&sockin, res->ai_addr, res->ai_addrlen);

	push	eax
	push	DWORD PTR [esi+24]
	lea	eax, DWORD PTR _sockin$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1097 : 		sockin.sin_port = htons (port);

	push	ebx
	call	DWORD PTR __imp__htons@4
	mov	WORD PTR _sockin$[ebp+2], ax

; 1098 : 		addr = (struct sockaddr *)&sockin;
; 1099 : #ifdef SUPPORT_IP6
; 1100 : 	    } else if (have_ipv6 () && (res->ai_family == AF_INET6)) {
; 1101 : 		if ((size_t)res->ai_addrlen > sizeof(sockin6)) {
; 1102 : 		    __xmlIOErr(XML_FROM_HTTP, 0, "address size mismatch\n");
; 1103 : 		    freeaddrinfo (result);
; 1104 : 		    return INVALID_SOCKET;
; 1105 : 		}
; 1106 : 		memcpy (&sockin6, res->ai_addr, res->ai_addrlen);
; 1107 : 		sockin6.sin6_port = htons (port);
; 1108 : 		addr = (struct sockaddr *)&sockin6;
; 1109 : #endif
; 1110 : 	    } else
; 1111 : 		continue;              /* for */
; 1112 : 
; 1113 : 	    s = xmlNanoHTTPConnectAttempt (addr);

	lea	eax, DWORD PTR _sockin$[ebp]
	push	eax
	call	_xmlNanoHTTPConnectAttempt
	mov	edi, eax
	add	esp, 4

; 1114 : 	    if (s != INVALID_SOCKET) {

	cmp	edi, -1
	jne	SHORT $LN26@xmlNanoHTT
$LN2@xmlNanoHTT:

; 1087 : 	}
; 1088 : 
; 1089 : 	for (res = result; res; res = res->ai_next) {

	mov	esi, DWORD PTR [esi+28]
	test	esi, esi
	jne	SHORT $LL4@xmlNanoHTT

; 1117 : 	    }
; 1118 : 	}
; 1119 : 
; 1120 : 	if (result)

	mov	esi, DWORD PTR _result$2[ebp]
	test	esi, esi
	je	SHORT $LN21@xmlNanoHTT
$LN35@xmlNanoHTT:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	mov	eax, DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	test	eax, eax
	jne	SHORT $LN22@xmlNanoHTT
	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN22@xmlNanoHTT:

; 1063 :     (*pfFreeAddrInfo)(ai);

	push	esi
	call	eax
$LN21@xmlNanoHTT:
	pop	edi
	pop	ebx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1217 :     return INVALID_SOCKET;

	or	eax, -1
	pop	esi

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlNanoHTT:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1061 :     if (!pfFreeAddrInfo)

	mov	eax, DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1115 : 		freeaddrinfo (result);

	mov	esi, DWORD PTR _result$2[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h

; 1061 :     if (!pfFreeAddrInfo)

	test	eax, eax
	jne	SHORT $LN19@xmlNanoHTT

; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN19@xmlNanoHTT:

; 1063 :     (*pfFreeAddrInfo)(ai);

	push	esi
	call	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c

; 1116 : 		return (s);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlNanoHTT:

; 1092 : 		    __xmlIOErr(XML_FROM_HTTP, 0, "address size mismatch\n");

	push	OFFSET ??_C@_0BH@OIBPAKHE@address?5size?5mismatch?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr

; 1093 : 		    freeaddrinfo (result);

	mov	esi, DWORD PTR _result$2[ebp]
	add	esp, 12					; 0000000cH

; 1094 : 		    return INVALID_SOCKET;

	jmp	SHORT $LN35@xmlNanoHTT
_xmlNanoHTTPConnectHost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPConnectAttempt
_TEXT	SEGMENT
_xfd$ = -536						; size = 260
_wfd$ = -276						; size = 260
_tv$ = -16						; size = 8
_len$1 = -8						; size = 4
_one$2 = -8						; size = 4
_status$ = -4						; size = 4
_addr$ = 8						; size = 4
_xmlNanoHTTPConnectAttempt PROC				; COMDAT

; 859  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	push	6
	push	1
	push	2
	call	DWORD PTR __imp__socket@12
	mov	esi, eax
	cmp	esi, -1
	jne	SHORT $LN18@xmlNanoHTT

; 860  : #ifndef HAVE_POLL_H
; 861  :     fd_set wfd;
; 862  : #ifdef _WINSOCKAPI_
; 863  :     fd_set xfd;
; 864  : #endif
; 865  :     struct timeval tv;
; 866  : #else /* !HAVE_POLL_H */
; 867  :     struct pollfd p;
; 868  : #endif /* !HAVE_POLL_H */
; 869  :     int status;
; 870  : 
; 871  :     int addrlen;
; 872  : 
; 873  :     SOCKET s;
; 874  : 
; 875  : #ifdef SUPPORT_IP6
; 876  :     if (addr->sa_family == AF_INET6) {
; 877  :         s = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
; 878  :         addrlen = sizeof(struct sockaddr_in6);
; 879  :     } else
; 880  : #endif
; 881  :     {
; 882  :         s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
; 883  :         addrlen = sizeof(struct sockaddr_in);
; 884  :     }
; 885  :     if (s == INVALID_SOCKET) {
; 886  : #ifdef DEBUG_HTTP
; 887  :         perror("socket");
; 888  : #endif
; 889  :         __xmlIOErr(XML_FROM_HTTP, 0, "socket failed\n");

	push	OFFSET ??_C@_0P@KCNIDCEL@socket?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1032 : }

	or	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlNanoHTT:

; 890  :         return INVALID_SOCKET;
; 891  :     }
; 892  : #ifdef _WINSOCKAPI_
; 893  :     {
; 894  :         u_long one = 1;
; 895  : 
; 896  :         status = ioctlsocket(s, FIONBIO, &one) == SOCKET_ERROR ? -1 : 0;

	lea	eax, DWORD PTR _one$2[ebp]
	mov	DWORD PTR _one$2[ebp], 1
	push	eax
	push	-2147195266				; 8004667eH
	push	esi
	call	DWORD PTR __imp__ioctlsocket@12
	inc	eax
	neg	eax

; 897  :     }
; 898  : #else /* _WINSOCKAPI_ */
; 899  : #if defined(VMS)
; 900  :     {
; 901  :         int enable = 1;
; 902  : 
; 903  :         status = ioctl(s, FIONBIO, &enable);
; 904  :     }
; 905  : #else /* VMS */
; 906  : #if defined(__BEOS__) && !defined(__HAIKU__)
; 907  :     {
; 908  :         bool noblock = true;
; 909  : 
; 910  :         status =
; 911  :             setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &noblock,
; 912  :                        sizeof(noblock));
; 913  :     }
; 914  : #else /* __BEOS__ */
; 915  :     if ((status = fcntl(s, F_GETFL, 0)) != -1) {
; 916  : #ifdef O_NONBLOCK
; 917  :         status |= O_NONBLOCK;
; 918  : #else /* O_NONBLOCK */
; 919  : #ifdef F_NDELAY
; 920  :         status |= F_NDELAY;
; 921  : #endif /* F_NDELAY */
; 922  : #endif /* !O_NONBLOCK */
; 923  :         status = fcntl(s, F_SETFL, status);
; 924  :     }
; 925  :     if (status < 0) {
; 926  : #ifdef DEBUG_HTTP
; 927  :         perror("nonblocking");
; 928  : #endif
; 929  :         __xmlIOErr(XML_FROM_HTTP, 0, "error setting non-blocking IO\n");
; 930  :         closesocket(s);
; 931  :         return INVALID_SOCKET;
; 932  :     }
; 933  : #endif /* !__BEOS__ */
; 934  : #endif /* !VMS */
; 935  : #endif /* !_WINSOCKAPI_ */
; 936  : 
; 937  :     if (connect(s, addr, addrlen) == -1) {

	push	16					; 00000010H
	push	DWORD PTR _addr$[ebp]
	sbb	eax, eax
	neg	eax
	dec	eax
	push	esi
	mov	DWORD PTR _status$[ebp], eax
	call	DWORD PTR __imp__connect@12
	cmp	eax, -1
	jne	SHORT $LN20@xmlNanoHTT

; 938  :         switch (socket_errno()) {

	call	_socket_errno
	sub	eax, 112				; 00000070H
	je	SHORT $LN20@xmlNanoHTT
	sub	eax, 28					; 0000001cH
	je	SHORT $LN20@xmlNanoHTT

; 939  :             case EINPROGRESS:
; 940  :             case EWOULDBLOCK:
; 941  :                 break;
; 942  :             default:
; 943  :                 __xmlIOErr(XML_FROM_HTTP, 0,

	push	OFFSET ??_C@_0CA@IEPMFIHD@error?5connecting?5to?5HTTP?5server@

; 944  :                            "error connecting to HTTP server");
; 945  :                 closesocket(s);
; 946  :                 return INVALID_SOCKET;

	jmp	$LN51@xmlNanoHTT
$LN20@xmlNanoHTT:

; 947  :         }
; 948  :     }
; 949  : #ifndef HAVE_POLL_H
; 950  :     tv.tv_sec = timeout;

	mov	eax, DWORD PTR _timeout
	mov	DWORD PTR _tv$[ebp], eax

; 951  :     tv.tv_usec = 0;
; 952  : 
; 953  : #ifdef _MSC_VER
; 954  : #pragma warning(push)
; 955  : #pragma warning(disable: 4018)
; 956  : #endif
; 957  : #ifndef _WINSOCKAPI_
; 958  :     if (s > FD_SETSIZE)
; 959  :         return INVALID_SOCKET;
; 960  : #endif
; 961  :     FD_ZERO(&wfd);
; 962  :     FD_SET(s, &wfd);
; 963  : 
; 964  : #ifdef _WINSOCKAPI_
; 965  :     FD_ZERO(&xfd);
; 966  :     FD_SET(s, &xfd);
; 967  : 
; 968  :     switch (select(s + 1, NULL, &wfd, &xfd, &tv))

	lea	eax, DWORD PTR _tv$[ebp]
	push	eax
	lea	eax, DWORD PTR _xfd$[ebp]
	mov	DWORD PTR _tv$[ebp+4], 0
	push	eax
	lea	eax, DWORD PTR _wfd$[ebp]
	mov	DWORD PTR _wfd$[ebp+4], esi
	push	eax
	push	0
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _wfd$[ebp], 1
	push	eax
	mov	DWORD PTR _xfd$[ebp+4], esi
	mov	DWORD PTR _xfd$[ebp], 1
	call	DWORD PTR __imp__select@20
	cmp	eax, -1
	je	$LN29@xmlNanoHTT
	test	eax, eax
	je	$LN28@xmlNanoHTT

; 991  :             closesocket(s);
; 992  :             return INVALID_SOCKET;
; 993  :     }
; 994  : 
; 995  : #ifndef HAVE_POLL_H
; 996  :     if (FD_ISSET(s, &wfd)
; 997  : #ifdef _WINSOCKAPI_
; 998  :         || FD_ISSET(s, &xfd)

	lea	eax, DWORD PTR _wfd$[ebp]
	push	eax
	push	esi
	call	___WSAFDIsSet@8
	test	eax, eax
	jne	SHORT $LN32@xmlNanoHTT
	lea	eax, DWORD PTR _xfd$[ebp]
	push	eax
	push	esi
	call	___WSAFDIsSet@8
	test	eax, eax
	jne	SHORT $LN32@xmlNanoHTT

; 1022 :             return INVALID_SOCKET;
; 1023 :         }
; 1024 :     } else {
; 1025 :         /* pbm */
; 1026 :         __xmlIOErr(XML_FROM_HTTP, 0, "select failed\n");

	push	OFFSET ??_C@_0P@FGBLCELI@select?5failed?6@

; 1027 :         closesocket(s);
; 1028 :         return INVALID_SOCKET;

	jmp	SHORT $LN51@xmlNanoHTT
$LN32@xmlNanoHTT:

; 999  : #endif
; 1000 :         )
; 1001 : #else /* !HAVE_POLL_H */
; 1002 :     if (p.revents == POLLOUT)
; 1003 : #endif /* !HAVE_POLL_H */
; 1004 :     {
; 1005 :         XML_SOCKLEN_T len;
; 1006 : 
; 1007 :         len = sizeof(status);
; 1008 : #ifdef SO_ERROR
; 1009 :         if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <

	lea	eax, DWORD PTR _len$1[ebp]
	mov	DWORD PTR _len$1[ebp], 4
	push	eax
	lea	eax, DWORD PTR _status$[ebp]
	push	eax
	push	4103					; 00001007H
	push	65535					; 0000ffffH
	push	esi
	call	DWORD PTR __imp__getsockopt@20
	test	eax, eax
	jns	SHORT $LN33@xmlNanoHTT

; 1010 :             0) {
; 1011 :             /* Solaris error code */
; 1012 :             __xmlIOErr(XML_FROM_HTTP, 0, "getsockopt failed\n");

	push	OFFSET ??_C@_0BD@MBFEIJEJ@getsockopt?5failed?6@

; 1013 :             closesocket(s);
; 1014 :             return INVALID_SOCKET;

	jmp	SHORT $LN51@xmlNanoHTT
$LN33@xmlNanoHTT:

; 1015 :         }
; 1016 : #endif
; 1017 :         if (status) {

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN34@xmlNanoHTT

; 1018 :             __xmlIOErr(XML_FROM_HTTP, 0,

	push	OFFSET ??_C@_0CA@PJNEJIM@Error?5connecting?5to?5remote?5host@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1019 :                        "Error connecting to remote host");
; 1020 :             closesocket(s);

	push	esi
	call	DWORD PTR __imp__closesocket@4

; 1021 :             errno = status;

	call	DWORD PTR __imp___errno
	mov	ecx, DWORD PTR _status$[ebp]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 1032 : }

	or	eax, -1
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlNanoHTT:

; 1029 :     }
; 1030 : 
; 1031 :     return (s);

	mov	eax, esi
	pop	esi

; 1032 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlNanoHTT:

; 969  : #else
; 970  :     switch (select(s + 1, NULL, &wfd, NULL, &tv))
; 971  : #endif
; 972  : #ifdef _MSC_VER
; 973  : #pragma warning(pop)
; 974  : #endif
; 975  : 
; 976  : #else /* !HAVE_POLL_H */
; 977  :     p.fd = s;
; 978  :     p.events = POLLOUT;
; 979  :     switch (poll(&p, 1, timeout * 1000))
; 980  : #endif /* !HAVE_POLL_H */
; 981  : 
; 982  :     {
; 983  :         case 0:
; 984  :             /* Time out */
; 985  :             __xmlIOErr(XML_FROM_HTTP, 0, "Connect attempt timed out");

	push	OFFSET ??_C@_0BK@JJCGCHLC@Connect?5attempt?5timed?5out@

; 986  :             closesocket(s);
; 987  :             return INVALID_SOCKET;

	jmp	SHORT $LN51@xmlNanoHTT
$LN29@xmlNanoHTT:

; 988  :         case -1:
; 989  :             /* Ermm.. ?? */
; 990  :             __xmlIOErr(XML_FROM_HTTP, 0, "Connect failed");

	push	OFFSET ??_C@_0P@NCGOJFHC@Connect?5failed@
$LN51@xmlNanoHTT:

; 1032 : }

	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
	push	esi
	call	DWORD PTR __imp__closesocket@4
	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPConnectAttempt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanAnswer
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_line$ = 12						; size = 4
_xmlNanoHTTPScanAnswer PROC				; COMDAT

; 706  : xmlNanoHTTPScanAnswer(xmlNanoHTTPCtxtPtr ctxt, const char *line) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _line$[ebp]
	test	esi, esi
	je	$LN74@xmlNanoHTT

; 707  :     const char *cur = line;
; 708  : 
; 709  :     if (line == NULL) return;
; 710  : 
; 711  :     if (!strncmp(line, "HTTP/", 5)) {

	push	ebx
	push	edi
	push	5
	push	OFFSET ??_C@_05FKGKDBHO@HTTP?1@
	push	esi
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN31@xmlNanoHTT

; 712  :         int version = 0;
; 713  : 	int ret = 0;
; 714  : 
; 715  : 	cur += 5;
; 716  : 	while ((*cur >= '0') && (*cur <= '9')) {

	mov	dl, BYTE PTR [esi+5]
	add	esi, 5
	xor	edi, edi
	xor	ebx, ebx
	cmp	dl, 48					; 00000030H
	jl	SHORT $LN156@xmlNanoHTT
	mov	al, dl
$LL2@xmlNanoHTT:
	mov	dl, al
	cmp	al, 57					; 00000039H
	jg	SHORT $LN156@xmlNanoHTT
	mov	dl, BYTE PTR [esi+1]

; 717  : 	    version *= 10;

	lea	edi, DWORD PTR [edi+edi*4]

; 718  : 	    version += *cur - '0';
; 719  : 	    cur++;

	inc	esi
	movsx	eax, al
	lea	edi, DWORD PTR [edi-24]
	lea	edi, DWORD PTR [eax+edi*2]
	mov	al, dl
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL2@xmlNanoHTT
$LN156@xmlNanoHTT:

; 720  : 	}
; 721  : 	if (*cur == '.') {

	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN33@xmlNanoHTT

; 722  : 	    cur++;
; 723  : 	    if ((*cur >= '0') && (*cur <= '9')) {

	mov	dl, BYTE PTR [esi+1]
	inc	esi
	mov	al, dl
	cmp	dl, 48					; 00000030H
	jl	SHORT $LN77@xmlNanoHTT
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN77@xmlNanoHTT

; 724  : 		version *= 10;
; 725  : 		version += *cur - '0';

	movsx	eax, dl
	lea	edi, DWORD PTR [edi+edi*4]

; 726  : 		cur++;

	inc	esi
	lea	edi, DWORD PTR [edi-24]
	lea	edi, DWORD PTR [eax+edi*2]
	mov	al, BYTE PTR [esi]
$LN77@xmlNanoHTT:

; 727  : 	    }
; 728  : 	    while ((*cur >= '0') && (*cur <= '9'))

	cmp	al, 48					; 00000030H
	jl	SHORT $LN157@xmlNanoHTT
	npad	6
$LL4@xmlNanoHTT:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN157@xmlNanoHTT
	mov	al, BYTE PTR [esi+1]

; 729  : 		cur++;

	inc	esi
	cmp	al, 48					; 00000030H
	jge	SHORT $LL4@xmlNanoHTT
$LN157@xmlNanoHTT:

; 730  : 	} else

	mov	dl, BYTE PTR [esi]
	jmp	SHORT $LN34@xmlNanoHTT
$LN33@xmlNanoHTT:

; 731  : 	    version *= 10;

	lea	edi, DWORD PTR [edi+edi*4]
	add	edi, edi
$LN34@xmlNanoHTT:

; 732  : 	if ((*cur != ' ') && (*cur != '\t')) return;

	cmp	dl, 32					; 00000020H
	je	SHORT $LN135@xmlNanoHTT
	cmp	dl, 9
	jne	$LN174@xmlNanoHTT
$LL6@xmlNanoHTT:

; 733  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	cmp	dl, 32					; 00000020H
	je	SHORT $LN135@xmlNanoHTT
	cmp	dl, 9
	jne	SHORT $LN7@xmlNanoHTT
$LN135@xmlNanoHTT:
	mov	dl, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL6@xmlNanoHTT
$LN7@xmlNanoHTT:

; 734  : 	if ((*cur < '0') || (*cur > '9')) return;

	lea	eax, DWORD PTR [edx-48]
	cmp	al, 9
	ja	$LN174@xmlNanoHTT
	npad	2
$LL8@xmlNanoHTT:

; 735  : 	while ((*cur >= '0') && (*cur <= '9')) {

	mov	al, dl
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN9@xmlNanoHTT

; 736  : 	    ret *= 10;
; 737  : 	    ret += *cur - '0';
; 738  : 	    cur++;

	inc	esi
	movsx	eax, dl
	lea	ebx, DWORD PTR [ebx+ebx*4]
	lea	ebx, DWORD PTR [ebx-24]
	mov	dl, BYTE PTR [esi]
	lea	ebx, DWORD PTR [eax+ebx*2]
	mov	al, dl
	cmp	dl, 48					; 00000030H
	jge	SHORT $LL8@xmlNanoHTT
$LN9@xmlNanoHTT:

; 739  : 	}
; 740  : 	if ((*cur != 0) && (*cur != ' ') && (*cur != '\t')) return;

	test	al, al
	je	SHORT $LN40@xmlNanoHTT
	cmp	al, 32					; 00000020H
	je	SHORT $LN40@xmlNanoHTT
	cmp	al, 9
	jne	$LN174@xmlNanoHTT
$LN40@xmlNanoHTT:

; 741  : 	ctxt->returnValue = ret;

	mov	eax, DWORD PTR _ctxt$[ebp]

; 742  :         ctxt->version = version;

	mov	DWORD PTR [eax+64], edi
	pop	edi
	mov	DWORD PTR [eax+60], ebx
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN31@xmlNanoHTT:

; 743  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Content-Type:", 13)) {

	push	13					; 0000000dH
	push	OFFSET ??_C@_0O@PDMPCIFL@Content?9Type?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN41@xmlNanoHTT

; 744  :         const xmlChar *charset, *last, *mime;
; 745  :         cur += 13;

	add	esi, 13					; 0000000dH
$LL10@xmlNanoHTT:

; 746  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN136@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN11@xmlNanoHTT
$LN136@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL10@xmlNanoHTT
$LN11@xmlNanoHTT:

; 747  : 	if (ctxt->contentType != NULL)

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ebx+72]
	test	eax, eax
	je	SHORT $LN44@xmlNanoHTT

; 748  : 	    xmlFree(ctxt->contentType);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN44@xmlNanoHTT:

; 749  : 	ctxt->contentType = xmlMemStrdup(cur);

	push	esi
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+72], eax
	add	esp, 4

; 750  : 	mime = (const xmlChar *) cur;
; 751  : 	last = mime;
; 752  : 	while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 753  : 	       (*last != ';') && (*last != ','))

	mov	al, BYTE PTR [esi]
	mov	edi, esi
	test	al, al
	je	SHORT $LN158@xmlNanoHTT
	npad	4
$LL12@xmlNanoHTT:
	cmp	al, 32					; 00000020H
	je	SHORT $LN158@xmlNanoHTT
	cmp	al, 9
	je	SHORT $LN158@xmlNanoHTT
	cmp	al, 59					; 0000003bH
	je	SHORT $LN158@xmlNanoHTT
	cmp	al, 44					; 0000002cH
	je	SHORT $LN158@xmlNanoHTT
	mov	al, BYTE PTR [edi+1]

; 754  : 	    last++;

	inc	edi
	test	al, al
	jne	SHORT $LL12@xmlNanoHTT
$LN158@xmlNanoHTT:

; 755  : 	if (ctxt->mimeType != NULL)

	mov	eax, DWORD PTR [ebx+88]
	test	eax, eax
	je	SHORT $LN45@xmlNanoHTT

; 756  : 	    xmlFree(ctxt->mimeType);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN45@xmlNanoHTT:

; 757  : 	ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);

	sub	edi, esi
	push	edi
	push	esi
	call	_xmlStrndup

; 758  : 	charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST "charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	push	DWORD PTR [ebx+72]
	mov	DWORD PTR [ebx+88], eax
	call	_xmlStrstr
	mov	edi, eax
	add	esp, 16					; 00000010H

; 759  : 	if (charset != NULL) {

	test	edi, edi
	je	$LN174@xmlNanoHTT

; 760  : 	    charset += 8;
; 761  : 	    last = charset;
; 762  : 	    while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 763  : 	           (*last != ';') && (*last != ','))

	mov	cl, BYTE PTR [edi+8]
	add	edi, 8
	mov	esi, edi
	test	cl, cl
	je	$LN161@xmlNanoHTT
	npad	1
$LL14@xmlNanoHTT:
	cmp	cl, 32					; 00000020H
	je	$LN161@xmlNanoHTT
	cmp	cl, 9
	je	$LN161@xmlNanoHTT
	cmp	cl, 59					; 0000003bH
	je	$LN161@xmlNanoHTT
	cmp	cl, 44					; 0000002cH
	je	$LN161@xmlNanoHTT
	mov	cl, BYTE PTR [esi+1]

; 764  : 		last++;

	inc	esi
	test	cl, cl
	jne	SHORT $LL14@xmlNanoHTT

; 765  : 	    if (ctxt->encoding != NULL)
; 766  : 	        xmlFree(ctxt->encoding);
; 767  : 	    ctxt->encoding = (char *) xmlStrndup(charset, last - charset);
; 768  : 	}

	jmp	$LN161@xmlNanoHTT
$LN41@xmlNanoHTT:

; 769  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"ContentType:", 12)) {

	push	12					; 0000000cH
	push	OFFSET ??_C@_0N@PPOPBCJG@ContentType?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN48@xmlNanoHTT

; 770  :         const xmlChar *charset, *last, *mime;
; 771  :         cur += 12;
; 772  : 	if (ctxt->contentType != NULL) return;

	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esi, 12					; 0000000cH
	cmp	DWORD PTR [ebx+72], eax
	jne	$LN174@xmlNanoHTT
$LL16@xmlNanoHTT:

; 773  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN137@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN17@xmlNanoHTT
$LN137@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL16@xmlNanoHTT
$LN17@xmlNanoHTT:

; 774  : 	ctxt->contentType = xmlMemStrdup(cur);

	push	esi
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ebx+72], eax
	add	esp, 4

; 775  : 	mime = (const xmlChar *) cur;
; 776  : 	last = mime;
; 777  : 	while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 778  : 	       (*last != ';') && (*last != ','))

	mov	al, BYTE PTR [esi]
	mov	edi, esi
	test	al, al
	je	SHORT $LN160@xmlNanoHTT
	npad	6
$LL18@xmlNanoHTT:
	cmp	al, 32					; 00000020H
	je	SHORT $LN160@xmlNanoHTT
	cmp	al, 9
	je	SHORT $LN160@xmlNanoHTT
	cmp	al, 59					; 0000003bH
	je	SHORT $LN160@xmlNanoHTT
	cmp	al, 44					; 0000002cH
	je	SHORT $LN160@xmlNanoHTT
	mov	al, BYTE PTR [edi+1]

; 779  : 	    last++;

	inc	edi
	test	al, al
	jne	SHORT $LL18@xmlNanoHTT
$LN160@xmlNanoHTT:

; 780  : 	if (ctxt->mimeType != NULL)

	mov	eax, DWORD PTR [ebx+88]
	test	eax, eax
	je	SHORT $LN52@xmlNanoHTT

; 781  : 	    xmlFree(ctxt->mimeType);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN52@xmlNanoHTT:

; 782  : 	ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);

	sub	edi, esi
	push	edi
	push	esi
	call	_xmlStrndup

; 783  : 	charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST "charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	push	DWORD PTR [ebx+72]
	mov	DWORD PTR [ebx+88], eax
	call	_xmlStrstr
	mov	edi, eax
	add	esp, 16					; 00000010H

; 784  : 	if (charset != NULL) {

	test	edi, edi
	je	$LN174@xmlNanoHTT

; 785  : 	    charset += 8;
; 786  : 	    last = charset;
; 787  : 	    while ((*last != 0) && (*last != ' ') && (*last != '\t') &&
; 788  : 	           (*last != ';') && (*last != ','))

	mov	cl, BYTE PTR [edi+8]
	add	edi, 8
	mov	esi, edi
	test	cl, cl
	je	SHORT $LN161@xmlNanoHTT
	npad	5
$LL20@xmlNanoHTT:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN161@xmlNanoHTT
	cmp	cl, 9
	je	SHORT $LN161@xmlNanoHTT
	cmp	cl, 59					; 0000003bH
	je	SHORT $LN161@xmlNanoHTT
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN161@xmlNanoHTT
	mov	cl, BYTE PTR [esi+1]

; 789  : 		last++;

	inc	esi
	test	cl, cl
	jne	SHORT $LL20@xmlNanoHTT
$LN161@xmlNanoHTT:

; 790  : 	    if (ctxt->encoding != NULL)
; 791  : 	        xmlFree(ctxt->encoding);

	mov	eax, DWORD PTR [ebx+84]
	test	eax, eax
	je	SHORT $LN54@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN54@xmlNanoHTT:

; 792  : 	    ctxt->encoding = (char *) xmlStrndup(charset, last - charset);

	sub	esi, edi
	push	esi
	push	edi
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR [ebx+84], eax
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN48@xmlNanoHTT:

; 793  : 	}
; 794  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Location:", 9)) {

	push	9
	push	OFFSET ??_C@_09GILIFLDG@Location?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN55@xmlNanoHTT

; 795  :         cur += 9;

	add	esi, 9
$LL22@xmlNanoHTT:

; 796  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN138@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN23@xmlNanoHTT
$LN138@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL22@xmlNanoHTT
$LN23@xmlNanoHTT:

; 797  : 	if (ctxt->location != NULL)

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edi+76]
	test	ecx, ecx
	je	SHORT $LN58@xmlNanoHTT

; 798  : 	    xmlFree(ctxt->location);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	al, BYTE PTR [esi]
	add	esp, 4
$LN58@xmlNanoHTT:

; 799  : 	if (*cur == '/') {

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN59@xmlNanoHTT

; 800  : 	    xmlChar *tmp_http = xmlStrdup(BAD_CAST "http://");

	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	call	_xmlStrdup

; 801  : 	    xmlChar *tmp_loc =

	push	DWORD PTR [edi+4]
	push	eax
	call	_xmlStrcat

; 802  : 	        xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);
; 803  : 	    ctxt->location =

	push	esi
	push	eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H

; 807  : 	}

	mov	DWORD PTR [edi+76], eax
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN59@xmlNanoHTT:

; 804  : 	        (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);
; 805  : 	} else {
; 806  : 	    ctxt->location = xmlMemStrdup(cur);

	push	esi
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4

; 807  : 	}

	mov	DWORD PTR [edi+76], eax
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN55@xmlNanoHTT:

; 808  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"WWW-Authenticate:", 17)) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@EALNDOCH@WWW?9Authenticate?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN61@xmlNanoHTT

; 809  :         cur += 17;

	add	esi, 17					; 00000011H
	npad	3
$LL24@xmlNanoHTT:

; 810  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN139@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN25@xmlNanoHTT
$LN139@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL24@xmlNanoHTT
$LN25@xmlNanoHTT:

; 811  : 	if (ctxt->authHeader != NULL)

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN64@xmlNanoHTT

; 812  : 	    xmlFree(ctxt->authHeader);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN64@xmlNanoHTT:

; 813  : 	ctxt->authHeader = xmlMemStrdup(cur);

	push	esi
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [edi+80], eax
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN61@xmlNanoHTT:

; 814  :     } else if (!xmlStrncasecmp(BAD_CAST line, BAD_CAST"Proxy-Authenticate:", 19)) {

	push	19					; 00000013H
	push	OFFSET ??_C@_0BE@EKBPAAMO@Proxy?9Authenticate?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN65@xmlNanoHTT

; 815  :         cur += 19;

	add	esi, 19					; 00000013H
	npad	6
$LL26@xmlNanoHTT:

; 816  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN140@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN27@xmlNanoHTT
$LN140@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL26@xmlNanoHTT
$LN27@xmlNanoHTT:

; 817  : 	if (ctxt->authHeader != NULL)

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN68@xmlNanoHTT

; 818  : 	    xmlFree(ctxt->authHeader);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN68@xmlNanoHTT:

; 819  : 	ctxt->authHeader = xmlMemStrdup(cur);

	push	esi
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [edi+80], eax
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN65@xmlNanoHTT:

; 820  : #ifdef LIBXML_ZLIB_ENABLED
; 821  :     } else if ( !xmlStrncasecmp( BAD_CAST line, BAD_CAST"Content-Encoding:", 17) ) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@FGDKEGD@Content?9Encoding?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN69@xmlNanoHTT

; 822  : 	cur += 17;

	add	esi, 17					; 00000011H
	npad	2
$LL28@xmlNanoHTT:

; 823  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN141@xmlNanoHTT
	cmp	al, 9
	jne	SHORT $LN29@xmlNanoHTT
$LN141@xmlNanoHTT:
	inc	esi
	jmp	SHORT $LL28@xmlNanoHTT
$LN29@xmlNanoHTT:

; 824  : 	if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST"gzip", 4) ) {

	push	4
	push	OFFSET ??_C@_04HOHEGKBO@gzip@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN174@xmlNanoHTT

; 825  : 	    ctxt->usesGzip = 1;

	mov	esi, DWORD PTR _ctxt$[ebp]

; 826  : 
; 827  : 	    ctxt->strm = xmlMalloc(sizeof(z_stream));

	push	56					; 00000038H
	mov	DWORD PTR [esi+96], 1
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+92], eax

; 828  : 
; 829  : 	    if (ctxt->strm != NULL) {

	test	eax, eax
	je	SHORT $LN174@xmlNanoHTT

; 830  : 		ctxt->strm->zalloc = Z_NULL;

	mov	DWORD PTR [eax+32], 0

; 831  : 		ctxt->strm->zfree = Z_NULL;

	mov	eax, DWORD PTR [esi+92]

; 832  : 		ctxt->strm->opaque = Z_NULL;
; 833  : 		ctxt->strm->avail_in = 0;
; 834  : 		ctxt->strm->next_in = Z_NULL;
; 835  : 
; 836  : 		inflateInit2( ctxt->strm, 31 );

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	31					; 0000001fH
	mov	DWORD PTR [eax+36], 0
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+40], 0
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax], 0
	push	DWORD PTR [esi+92]
	call	_inflateInit2_@16
	pop	edi
	pop	ebx
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
$LN69@xmlNanoHTT:

; 837  : 	    }
; 838  : 	}
; 839  : #endif
; 840  :     } else if ( !xmlStrncasecmp( BAD_CAST line, BAD_CAST"Content-Length:", 15) ) {

	push	15					; 0000000fH
	push	OFFSET ??_C@_0BA@DIGAFIOK@Content?9Length?3@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN174@xmlNanoHTT

; 841  : 	cur += 15;
; 842  : 	ctxt->ContentLength = strtol( cur, NULL, 10 );

	push	10					; 0000000aH
	push	eax
	lea	eax, DWORD PTR [esi+15]
	push	eax
	call	DWORD PTR __imp__strtol
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+68], eax
$LN174@xmlNanoHTT:
	pop	edi
	pop	ebx
$LN74@xmlNanoHTT:
	pop	esi

; 843  :     }
; 844  : }

	pop	ebp
	ret	0
_xmlNanoHTTPScanAnswer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPReadLine
_TEXT	SEGMENT
_buf$ = -4376						; size = 4096
_rfd$1 = -280						; size = 260
_tv$2 = -20						; size = 8
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_d_content$1$ = -8					; size = 4
_bp$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlNanoHTTPReadLine PROC				; COMDAT

; 660  : xmlNanoHTTPReadLine(xmlNanoHTTPCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	eax, 4376				; 00001118H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4

; 631  :         FD_SET(ctxt->fd, &rfd);

	mov	esi, DWORD PTR _ctxt$[ebp]

; 661  :     char buf[4096];
; 662  :     char *bp = buf;

	lea	ebx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _bp$1$[ebp], ebx

; 631  :         FD_SET(ctxt->fd, &rfd);

	mov	edx, DWORD PTR [esi+48]
	npad	7
$LL2@xmlNanoHTT:

; 666  : 	if (ctxt->inrptr == ctxt->inptr) {

	cmp	edx, DWORD PTR [esi+44]
	jne	$LN73@xmlNanoHTT

; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	test	BYTE PTR [esi+24], 2
	je	$LN56@xmlNanoHTT
$LL14@xmlNanoHTT:

; 544  :         if (ctxt->in == NULL) {

	mov	ebx, DWORD PTR [esi+36]
	test	ebx, ebx
	jne	SHORT $LN74@xmlNanoHTT

; 545  :             ctxt->in = (char *) xmlMallocAtomic(65000 * sizeof(char));

	push	65000					; 0000fde8H
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR [esi+36], ebx

; 546  :             if (ctxt->in == NULL) {

	test	ebx, ebx
	je	$LN49@xmlNanoHTT

; 549  :                 return (-1);
; 550  :             }
; 551  :             ctxt->inlen = 65000;

	mov	DWORD PTR [esi+52], 65000		; 0000fde8H

; 552  :             ctxt->inptr = ctxt->content = ctxt->inrptr = ctxt->in;

	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+44], ebx
$LN74@xmlNanoHTT:

; 553  :         }
; 554  :         if (ctxt->inrptr > ctxt->in + XML_NANO_HTTP_CHUNK) {

	mov	edi, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [ebx+4096]
	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR $T4[ebp], edi
	mov	DWORD PTR $T3[ebp], edx
	cmp	edi, eax
	jbe	SHORT $LN64@xmlNanoHTT

; 555  :             int delta = ctxt->inrptr - ctxt->in;
; 556  :             int len = ctxt->inptr - ctxt->inrptr;

	mov	eax, DWORD PTR $T4[ebp]
	sub	edi, ebx
	sub	edx, eax

; 557  : 
; 558  :             memmove(ctxt->in, ctxt->inrptr, len);

	push	edx
	push	eax
	push	ebx
	call	_memmove

; 559  :             ctxt->inrptr -= delta;

	sub	DWORD PTR [esi+48], edi
	add	esp, 12					; 0000000cH

; 560  :             ctxt->content -= delta;

	sub	DWORD PTR [esi+40], edi

; 561  :             ctxt->inptr -= delta;

	sub	DWORD PTR [esi+44], edi
	mov	eax, DWORD PTR [esi+48]
	mov	edi, eax
	mov	edx, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [esi+36]
	mov	DWORD PTR $T3[ebp], edx
$LN64@xmlNanoHTT:

; 562  :         }
; 563  :         if ((ctxt->in + ctxt->inlen) < (ctxt->inptr + XML_NANO_HTTP_CHUNK)) {

	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [edx+4096]
	add	ecx, ebx
	cmp	ecx, eax
	jae	SHORT $LN27@xmlNanoHTT

; 564  :             int d_inptr = ctxt->inptr - ctxt->in;
; 565  :             int d_content = ctxt->content - ctxt->in;

	mov	eax, DWORD PTR [esi+40]
	sub	eax, ebx
	mov	DWORD PTR _d_content$1$[ebp], eax

; 566  :             int d_inrptr = ctxt->inrptr - ctxt->in;
; 567  :             char *tmp_ptr = ctxt->in;
; 568  : 
; 569  :             ctxt->inlen *= 2;

	mov	eax, DWORD PTR [esi+52]
	add	eax, eax

; 570  :             ctxt->in = (char *) xmlRealloc(tmp_ptr, ctxt->inlen);

	push	eax
	push	ebx
	mov	DWORD PTR [esi+52], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+36], eax

; 571  :             if (ctxt->in == NULL) {

	test	eax, eax
	je	$LN50@xmlNanoHTT

; 575  :                 return (-1);
; 576  :             }
; 577  :             ctxt->inptr = ctxt->in + d_inptr;

	mov	edx, DWORD PTR $T3[ebp]
	mov	ecx, eax
	sub	ecx, ebx

; 578  :             ctxt->content = ctxt->in + d_content;
; 579  :             ctxt->inrptr = ctxt->in + d_inrptr;

	sub	edi, ebx
	add	edx, ecx
	mov	ecx, DWORD PTR _d_content$1$[ebp]
	add	ecx, eax
	mov	DWORD PTR [esi+44], edx
	add	edi, eax
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+48], edi
$LN27@xmlNanoHTT:

; 580  :         }
; 581  :         ctxt->last = recv(ctxt->fd, ctxt->inptr, XML_NANO_HTTP_CHUNK, 0);

	push	0
	push	4096					; 00001000H
	push	edx
	push	DWORD PTR [esi+20]
	call	DWORD PTR __imp__recv@16
	mov	DWORD PTR [esi+56], eax

; 582  :         if (ctxt->last > 0) {

	test	eax, eax
	jg	$LN51@xmlNanoHTT

; 584  :             return (ctxt->last);
; 585  :         }
; 586  :         if (ctxt->last == 0) {

	je	SHORT $LN79@xmlNanoHTT

; 587  :             return (0);
; 588  :         }
; 589  :         if (ctxt->last == -1) {

	cmp	eax, -1
	jne	SHORT $LN32@xmlNanoHTT

; 590  :             switch (socket_errno()) {

	call	_socket_errno
	cmp	eax, 112				; 00000070H
	jg	SHORT $LN40@xmlNanoHTT
	je	SHORT $LN32@xmlNanoHTT
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN32@xmlNanoHTT
	cmp	eax, 108				; 0000006cH
	jmp	$LN81@xmlNanoHTT
$LN40@xmlNanoHTT:
	cmp	eax, 140				; 0000008cH
	jne	$LN54@xmlNanoHTT
$LN32@xmlNanoHTT:

; 604  :                     return (-1);
; 605  :             }
; 606  :         }
; 607  : #ifdef HAVE_POLL_H
; 608  :         p.fd = ctxt->fd;
; 609  :         p.events = POLLIN;
; 610  :         if ((poll(&p, 1, timeout * 1000) < 1)
; 611  : #if defined(EINTR)
; 612  :             && (errno != EINTR)
; 613  : #endif
; 614  :             )
; 615  :             return (0);
; 616  : #else /* !HAVE_POLL_H */
; 617  : #ifndef _WINSOCKAPI_
; 618  :         if (ctxt->fd > FD_SETSIZE)
; 619  :             return 0;
; 620  : #endif
; 621  : 
; 622  :         tv.tv_sec = timeout;

	mov	eax, DWORD PTR _timeout

; 632  : 
; 633  : #ifdef _MSC_VER
; 634  : #pragma warning(pop)
; 635  : #endif
; 636  : 
; 637  :         if ((select(ctxt->fd + 1, &rfd, NULL, NULL, &tv) < 1)
; 638  : #if defined(EINTR)
; 639  :             && (socket_errno() != EINTR)

	lea	ecx, DWORD PTR _tv$2[ebp]
	push	ecx
	push	0
	mov	DWORD PTR _tv$2[ebp], eax
	lea	ecx, DWORD PTR _rfd$1[ebp]
	mov	eax, DWORD PTR [esi+20]
	push	0
	mov	DWORD PTR _rfd$1[ebp+4], eax
	inc	eax
	push	ecx
	push	eax
	mov	DWORD PTR _tv$2[ebp+4], 0
	mov	DWORD PTR _rfd$1[ebp], 1
	call	DWORD PTR __imp__select@20
	cmp	eax, 1
	jge	SHORT $LN38@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 4
	jne	SHORT $LN79@xmlNanoHTT
$LN38@xmlNanoHTT:

; 171  : }
; 172  : 
; 173  : /**
; 174  :  * A portability function
; 175  :  */
; 176  : static int socket_errno(void) {
; 177  : #ifdef _WINSOCKAPI_
; 178  :     int err = WSAGetLastError();
; 179  :     switch(err) {
; 180  :         case WSAECONNRESET:
; 181  :             return(ECONNRESET);
; 182  :         case WSAEINPROGRESS:
; 183  :             return(EINPROGRESS);
; 184  :         case WSAEINTR:
; 185  :             return(EINTR);
; 186  :         case WSAESHUTDOWN:
; 187  :             return(ESHUTDOWN);
; 188  :         case WSAEWOULDBLOCK:
; 189  :             return(EWOULDBLOCK);
; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }
; 197  : 
; 198  : #ifdef SUPPORT_IP6
; 199  : static
; 200  : int have_ipv6(void) {
; 201  :     SOCKET s;
; 202  : 
; 203  :     s = socket (AF_INET6, SOCK_STREAM, 0);
; 204  :     if (s != INVALID_SOCKET) {
; 205  : 	close (s);
; 206  : 	return (1);
; 207  :     }
; 208  :     return (0);
; 209  : }
; 210  : #endif
; 211  : 
; 212  : /**
; 213  :  * xmlNanoHTTPInit:
; 214  :  *
; 215  :  * Initialize the HTTP protocol layer.
; 216  :  * Currently it just checks for proxy informations
; 217  :  */
; 218  : 
; 219  : void
; 220  : xmlNanoHTTPInit(void) {
; 221  :     const char *env;
; 222  : #ifdef _WINSOCKAPI_
; 223  :     WSADATA wsaData;
; 224  : #endif
; 225  : 
; 226  :     if (initialized)
; 227  : 	return;
; 228  : 
; 229  : #ifdef _WINSOCKAPI_
; 230  :     if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
; 231  : 	return;
; 232  : #endif
; 233  : 
; 234  :     if (proxy == NULL) {
; 235  : 	proxyPort = 80;
; 236  : 	env = getenv("no_proxy");
; 237  : 	if (env && ((env[0] == '*') && (env[1] == 0)))
; 238  : 	    goto done;
; 239  : 	env = getenv("http_proxy");
; 240  : 	if (env != NULL) {
; 241  : 	    xmlNanoHTTPScanProxy(env);
; 242  : 	    goto done;
; 243  : 	}
; 244  : 	env = getenv("HTTP_PROXY");
; 245  : 	if (env != NULL) {
; 246  : 	    xmlNanoHTTPScanProxy(env);
; 247  : 	    goto done;
; 248  : 	}
; 249  :     }
; 250  : done:
; 251  :     initialized = 1;
; 252  : }
; 253  : 
; 254  : /**
; 255  :  * xmlNanoHTTPCleanup:
; 256  :  *
; 257  :  * Cleanup the HTTP protocol layer.
; 258  :  */
; 259  : 
; 260  : void
; 261  : xmlNanoHTTPCleanup(void) {
; 262  :     if (proxy != NULL) {
; 263  : 	xmlFree(proxy);
; 264  : 	proxy = NULL;
; 265  :     }
; 266  : #ifdef _WINSOCKAPI_
; 267  :     if (initialized)
; 268  : 	WSACleanup();
; 269  : #endif
; 270  :     initialized = 0;
; 271  :     return;
; 272  : }
; 273  : 
; 274  : /**
; 275  :  * xmlNanoHTTPScanURL:
; 276  :  * @ctxt:  an HTTP context
; 277  :  * @URL:  The URL used to initialize the context
; 278  :  *
; 279  :  * (Re)Initialize an HTTP context by parsing the URL and finding
; 280  :  * the protocol host port and path it indicates.
; 281  :  */
; 282  : 
; 283  : static void
; 284  : xmlNanoHTTPScanURL(xmlNanoHTTPCtxtPtr ctxt, const char *URL) {
; 285  :     xmlURIPtr uri;
; 286  :     int len;
; 287  : 
; 288  :     /*
; 289  :      * Clear any existing data from the context
; 290  :      */
; 291  :     if (ctxt->protocol != NULL) {
; 292  :         xmlFree(ctxt->protocol);
; 293  : 	ctxt->protocol = NULL;
; 294  :     }
; 295  :     if (ctxt->hostname != NULL) {
; 296  :         xmlFree(ctxt->hostname);
; 297  : 	ctxt->hostname = NULL;
; 298  :     }
; 299  :     if (ctxt->path != NULL) {
; 300  :         xmlFree(ctxt->path);
; 301  : 	ctxt->path = NULL;
; 302  :     }
; 303  :     if (ctxt->query != NULL) {
; 304  :         xmlFree(ctxt->query);
; 305  : 	ctxt->query = NULL;
; 306  :     }
; 307  :     if (URL == NULL) return;
; 308  : 
; 309  :     uri = xmlParseURIRaw(URL, 1);
; 310  :     if (uri == NULL)
; 311  : 	return;
; 312  : 
; 313  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {
; 314  : 	xmlFreeURI(uri);
; 315  : 	return;
; 316  :     }
; 317  : 
; 318  :     ctxt->protocol = xmlMemStrdup(uri->scheme);
; 319  :     /* special case of IPv6 addresses, the [] need to be removed */
; 320  :     if ((uri->server != NULL) && (*uri->server == '[')) {
; 321  :         len = strlen(uri->server);
; 322  : 	if ((len > 2) && (uri->server[len - 1] == ']')) {
; 323  : 	    ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);
; 324  : 	} else
; 325  : 	    ctxt->hostname = xmlMemStrdup(uri->server);
; 326  :     } else
; 327  : 	ctxt->hostname = xmlMemStrdup(uri->server);
; 328  :     if (uri->path != NULL)
; 329  : 	ctxt->path = xmlMemStrdup(uri->path);
; 330  :     else
; 331  : 	ctxt->path = xmlMemStrdup("/");
; 332  :     if (uri->query != NULL)
; 333  : 	ctxt->query = xmlMemStrdup(uri->query);
; 334  :     if (uri->port != 0)
; 335  : 	ctxt->port = uri->port;
; 336  : 
; 337  :     xmlFreeURI(uri);
; 338  : }
; 339  : 
; 340  : /**
; 341  :  * xmlNanoHTTPScanProxy:
; 342  :  * @URL:  The proxy URL used to initialize the proxy context
; 343  :  *
; 344  :  * (Re)Initialize the HTTP Proxy context by parsing the URL and finding
; 345  :  * the protocol host port it indicates.
; 346  :  * Should be like http://myproxy/ or http://myproxy:3128/
; 347  :  * A NULL URL cleans up proxy informations.
; 348  :  */
; 349  : 
; 350  : void
; 351  : xmlNanoHTTPScanProxy(const char *URL) {
; 352  :     xmlURIPtr uri;
; 353  : 
; 354  :     if (proxy != NULL) {
; 355  :         xmlFree(proxy);
; 356  : 	proxy = NULL;
; 357  :     }
; 358  :     proxyPort = 0;
; 359  : 
; 360  : #ifdef DEBUG_HTTP
; 361  :     if (URL == NULL)
; 362  : 	xmlGenericError(xmlGenericErrorContext,
; 363  : 		"Removing HTTP proxy info\n");
; 364  :     else
; 365  : 	xmlGenericError(xmlGenericErrorContext,
; 366  : 		"Using HTTP proxy %s\n", URL);
; 367  : #endif
; 368  :     if (URL == NULL) return;
; 369  : 
; 370  :     uri = xmlParseURIRaw(URL, 1);
; 371  :     if ((uri == NULL) || (uri->scheme == NULL) ||
; 372  : 	(strcmp(uri->scheme, "http")) || (uri->server == NULL)) {
; 373  : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Syntax Error\n");
; 374  : 	if (uri != NULL)
; 375  : 	    xmlFreeURI(uri);
; 376  : 	return;
; 377  :     }
; 378  : 
; 379  :     proxy = xmlMemStrdup(uri->server);
; 380  :     if (uri->port != 0)
; 381  : 	proxyPort = uri->port;
; 382  : 
; 383  :     xmlFreeURI(uri);
; 384  : }
; 385  : 
; 386  : /**
; 387  :  * xmlNanoHTTPNewCtxt:
; 388  :  * @URL:  The URL used to initialize the context
; 389  :  *
; 390  :  * Allocate and initialize a new HTTP context.
; 391  :  *
; 392  :  * Returns an HTTP context or NULL in case of error.
; 393  :  */
; 394  : 
; 395  : static xmlNanoHTTPCtxtPtr
; 396  : xmlNanoHTTPNewCtxt(const char *URL) {
; 397  :     xmlNanoHTTPCtxtPtr ret;
; 398  : 
; 399  :     ret = (xmlNanoHTTPCtxtPtr) xmlMalloc(sizeof(xmlNanoHTTPCtxt));
; 400  :     if (ret == NULL) {
; 401  :         xmlHTTPErrMemory("allocating context");
; 402  :         return(NULL);
; 403  :     }
; 404  : 
; 405  :     memset(ret, 0, sizeof(xmlNanoHTTPCtxt));
; 406  :     ret->port = 80;
; 407  :     ret->returnValue = 0;
; 408  :     ret->fd = INVALID_SOCKET;
; 409  :     ret->ContentLength = -1;
; 410  : 
; 411  :     xmlNanoHTTPScanURL(ret, URL);
; 412  : 
; 413  :     return(ret);
; 414  : }
; 415  : 
; 416  : /**
; 417  :  * xmlNanoHTTPFreeCtxt:
; 418  :  * @ctxt:  an HTTP context
; 419  :  *
; 420  :  * Frees the context after closing the connection.
; 421  :  */
; 422  : 
; 423  : static void
; 424  : xmlNanoHTTPFreeCtxt(xmlNanoHTTPCtxtPtr ctxt) {
; 425  :     if (ctxt == NULL) return;
; 426  :     if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);
; 427  :     if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);
; 428  :     if (ctxt->path != NULL) xmlFree(ctxt->path);
; 429  :     if (ctxt->query != NULL) xmlFree(ctxt->query);
; 430  :     if (ctxt->out != NULL) xmlFree(ctxt->out);
; 431  :     if (ctxt->in != NULL) xmlFree(ctxt->in);
; 432  :     if (ctxt->contentType != NULL) xmlFree(ctxt->contentType);
; 433  :     if (ctxt->encoding != NULL) xmlFree(ctxt->encoding);
; 434  :     if (ctxt->mimeType != NULL) xmlFree(ctxt->mimeType);
; 435  :     if (ctxt->location != NULL) xmlFree(ctxt->location);
; 436  :     if (ctxt->authHeader != NULL) xmlFree(ctxt->authHeader);
; 437  : #ifdef LIBXML_ZLIB_ENABLED
; 438  :     if (ctxt->strm != NULL) {
; 439  : 	inflateEnd(ctxt->strm);
; 440  : 	xmlFree(ctxt->strm);
; 441  :     }
; 442  : #endif
; 443  : 
; 444  :     ctxt->state = XML_NANO_HTTP_NONE;
; 445  :     if (ctxt->fd != INVALID_SOCKET) closesocket(ctxt->fd);
; 446  :     ctxt->fd = INVALID_SOCKET;
; 447  :     xmlFree(ctxt);
; 448  : }
; 449  : 
; 450  : /**
; 451  :  * xmlNanoHTTPSend:
; 452  :  * @ctxt:  an HTTP context
; 453  :  *
; 454  :  * Send the input needed to initiate the processing on the server side
; 455  :  * Returns number of bytes sent or -1 on error.
; 456  :  */
; 457  : 
; 458  : static int
; 459  : xmlNanoHTTPSend(xmlNanoHTTPCtxtPtr ctxt, const char *xmt_ptr, int outlen)
; 460  : {
; 461  :     int total_sent = 0;
; 462  : #ifdef HAVE_POLL_H
; 463  :     struct pollfd p;
; 464  : #else
; 465  :     struct timeval tv;
; 466  :     fd_set wfd;
; 467  : #endif
; 468  : 
; 469  :     if ((ctxt->state & XML_NANO_HTTP_WRITE) && (xmt_ptr != NULL)) {
; 470  :         while (total_sent < outlen) {
; 471  :             int nsent = send(ctxt->fd, SEND_ARG2_CAST (xmt_ptr + total_sent),
; 472  :                              outlen - total_sent, 0);
; 473  : 
; 474  :             if (nsent > 0)
; 475  :                 total_sent += nsent;
; 476  :             else if ((nsent == -1) &&
; 477  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 478  :                      (socket_errno() != EAGAIN) &&
; 479  : #endif
; 480  :                      (socket_errno() != EWOULDBLOCK)) {
; 481  :                 __xmlIOErr(XML_FROM_HTTP, 0, "send failed\n");
; 482  :                 if (total_sent == 0)
; 483  :                     total_sent = -1;
; 484  :                 break;
; 485  :             } else {
; 486  :                 /*
; 487  :                  * No data sent
; 488  :                  * Since non-blocking sockets are used, wait for
; 489  :                  * socket to be writable or default timeout prior
; 490  :                  * to retrying.
; 491  :                  */
; 492  : #ifndef HAVE_POLL_H
; 493  : #ifndef _WINSOCKAPI_
; 494  :                 if (ctxt->fd > FD_SETSIZE)
; 495  :                     return -1;
; 496  : #endif
; 497  : 
; 498  :                 tv.tv_sec = timeout;
; 499  :                 tv.tv_usec = 0;
; 500  :                 FD_ZERO(&wfd);
; 501  : #ifdef _MSC_VER
; 502  : #pragma warning(push)
; 503  : #pragma warning(disable: 4018)
; 504  : #endif
; 505  :                 FD_SET(ctxt->fd, &wfd);
; 506  : #ifdef _MSC_VER
; 507  : #pragma warning(pop)
; 508  : #endif
; 509  :                 (void) select(ctxt->fd + 1, NULL, &wfd, NULL, &tv);
; 510  : #else
; 511  :                 p.fd = ctxt->fd;
; 512  :                 p.events = POLLOUT;
; 513  :                 (void) poll(&p, 1, timeout * 1000);
; 514  : #endif /* !HAVE_POLL_H */
; 515  :             }
; 516  :         }
; 517  :     }
; 518  : 
; 519  :     return total_sent;
; 520  : }
; 521  : 
; 522  : /**
; 523  :  * xmlNanoHTTPRecv:
; 524  :  * @ctxt:  an HTTP context
; 525  :  *
; 526  :  * Read information coming from the HTTP connection.
; 527  :  * This is a blocking call (but it blocks in select(), not read()).
; 528  :  *
; 529  :  * Returns the number of byte read or -1 in case of error.
; 530  :  */
; 531  : 
; 532  : static int
; 533  : xmlNanoHTTPRecv(xmlNanoHTTPCtxtPtr ctxt)
; 534  : {
; 535  : #ifdef HAVE_POLL_H
; 536  :     struct pollfd p;
; 537  : #else
; 538  :     fd_set rfd;
; 539  :     struct timeval tv;
; 540  : #endif
; 541  : 
; 542  : 
; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	test	BYTE PTR [esi+24], 2
	jne	$LL14@xmlNanoHTT
$LN79@xmlNanoHTT:

; 667  : 	    if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {
; 668  : 		if (bp == buf)

	mov	ebx, DWORD PTR _bp$1$[ebp]
$LN56@xmlNanoHTT:
	lea	eax, DWORD PTR _buf$[ebp]
	cmp	ebx, eax
	jne	$LN58@xmlNanoHTT
$LN57@xmlNanoHTT:
	pop	edi

; 680  : 	    *bp = 0;
; 681  : 	    return(xmlMemStrdup(buf));
; 682  : 	}
; 683  : 	if (*bp != '\r')
; 684  : 	    bp++;
; 685  :     }
; 686  :     buf[4095] = 0;
; 687  :     return(xmlMemStrdup(buf));
; 688  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlNanoHTT:

; 583  :             ctxt->inptr += ctxt->last;

	add	DWORD PTR [esi+44], eax

; 669  : 		    return(NULL);
; 670  : 		else
; 671  : 		    *bp = 0;
; 672  : 		return(xmlMemStrdup(buf));
; 673  : 	    }
; 674  : 	    else if ( rc == -1 ) {

	cmp	eax, -1
	je	SHORT $LN57@xmlNanoHTT
	mov	ebx, DWORD PTR _bp$1$[ebp]
$LN73@xmlNanoHTT:

; 676  : 	    }
; 677  : 	}
; 678  : 	*bp = *ctxt->inrptr++;

	mov	eax, DWORD PTR [esi+48]
	mov	cl, BYTE PTR [eax]
	lea	edx, DWORD PTR [eax+1]
	mov	BYTE PTR [ebx], cl
	mov	DWORD PTR [esi+48], edx

; 679  : 	if (*bp == '\n') {

	cmp	cl, 10					; 0000000aH
	je	$LN58@xmlNanoHTT

; 663  :     int	rc;
; 664  : 
; 665  :     while (bp - buf < 4095) {

	cmp	cl, 13					; 0000000dH
	lea	eax, DWORD PTR [ebx+1]
	lea	ecx, DWORD PTR _buf$[ebp]
	cmove	eax, ebx
	mov	ebx, eax
	mov	DWORD PTR _bp$1$[ebp], eax
	sub	eax, ecx
	cmp	eax, 4095				; 00000fffH
	jl	$LL2@xmlNanoHTT

; 680  : 	    *bp = 0;
; 681  : 	    return(xmlMemStrdup(buf));
; 682  : 	}
; 683  : 	if (*bp != '\r')
; 684  : 	    bp++;
; 685  :     }
; 686  :     buf[4095] = 0;
; 687  :     return(xmlMemStrdup(buf));
; 688  : }

	mov	eax, ecx
	mov	BYTE PTR _buf$[ebp+4095], 0
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BB@BIOIGIMH@allocating?5input@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 548  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 675  : 	        return ( NULL );

	xor	eax, eax
	pop	edi

; 680  : 	    *bp = 0;
; 681  : 	    return(xmlMemStrdup(buf));
; 682  : 	}
; 683  : 	if (*bp != '\r')
; 684  : 	    bp++;
; 685  :     }
; 686  :     buf[4095] = 0;
; 687  :     return(xmlMemStrdup(buf));
; 688  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError

; 573  :                 xmlFree(tmp_ptr);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 574  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 675  : 	        return ( NULL );

	xor	eax, eax
	pop	edi

; 680  : 	    *bp = 0;
; 681  : 	    return(xmlMemStrdup(buf));
; 682  : 	}
; 683  : 	if (*bp != '\r')
; 684  : 	    bp++;
; 685  :     }
; 686  :     buf[4095] = 0;
; 687  :     return(xmlMemStrdup(buf));
; 688  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlNanoHTT:

; 590  :             switch (socket_errno()) {

	cmp	eax, 10058				; 0000274aH
$LN81@xmlNanoHTT:

; 591  :                 case EINPROGRESS:
; 592  :                 case EWOULDBLOCK:
; 593  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 594  :                 case EAGAIN:
; 595  : #endif
; 596  :                     break;
; 597  : 
; 598  :                 case ECONNRESET:
; 599  :                 case ESHUTDOWN:
; 600  :                     return (0);
; 601  : 
; 602  :                 default:
; 603  :                     __xmlIOErr(XML_FROM_HTTP, 0, "recv failed\n");

	je	$LN79@xmlNanoHTT
	push	OFFSET ??_C@_0N@NLPHEKBL@recv?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 675  : 	        return ( NULL );

	xor	eax, eax
	pop	edi

; 680  : 	    *bp = 0;
; 681  : 	    return(xmlMemStrdup(buf));
; 682  : 	}
; 683  : 	if (*bp != '\r')
; 684  : 	    bp++;
; 685  :     }
; 686  :     buf[4095] = 0;
; 687  :     return(xmlMemStrdup(buf));
; 688  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@xmlNanoHTT:
	lea	eax, DWORD PTR _buf$[ebp]
	mov	BYTE PTR [ebx], 0
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPReadLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRecv
_TEXT	SEGMENT
_rfd$ = -272						; size = 260
_tv$ = -12						; size = 8
$T1 = -4						; size = 4
$T2 = 8							; size = 4
_d_content$1$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_xmlNanoHTTPRecv PROC					; COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	test	BYTE PTR [esi+24], 2
	je	$LN3@xmlNanoHTT
$LL2@xmlNanoHTT:

; 544  :         if (ctxt->in == NULL) {

	mov	ebx, DWORD PTR [esi+36]
	test	ebx, ebx
	jne	SHORT $LN53@xmlNanoHTT

; 545  :             ctxt->in = (char *) xmlMallocAtomic(65000 * sizeof(char));

	push	65000					; 0000fde8H
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR [esi+36], ebx

; 546  :             if (ctxt->in == NULL) {

	test	ebx, ebx
	je	$LN36@xmlNanoHTT

; 550  :             }
; 551  :             ctxt->inlen = 65000;

	mov	DWORD PTR [esi+52], 65000		; 0000fde8H

; 552  :             ctxt->inptr = ctxt->content = ctxt->inrptr = ctxt->in;

	mov	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+44], ebx
$LN53@xmlNanoHTT:

; 553  :         }
; 554  :         if (ctxt->inrptr > ctxt->in + XML_NANO_HTTP_CHUNK) {

	mov	edi, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [ebx+4096]
	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR $T2[ebp], edi
	mov	DWORD PTR $T1[ebp], edx
	cmp	edi, eax
	jbe	SHORT $LN47@xmlNanoHTT

; 555  :             int delta = ctxt->inrptr - ctxt->in;
; 556  :             int len = ctxt->inptr - ctxt->inrptr;

	mov	eax, DWORD PTR $T2[ebp]
	sub	edi, ebx
	sub	edx, eax

; 557  : 
; 558  :             memmove(ctxt->in, ctxt->inrptr, len);

	push	edx
	push	eax
	push	ebx
	call	_memmove

; 559  :             ctxt->inrptr -= delta;

	sub	DWORD PTR [esi+48], edi
	add	esp, 12					; 0000000cH

; 560  :             ctxt->content -= delta;

	sub	DWORD PTR [esi+40], edi

; 561  :             ctxt->inptr -= delta;

	sub	DWORD PTR [esi+44], edi
	mov	eax, DWORD PTR [esi+48]
	mov	edi, eax
	mov	edx, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [esi+36]
	mov	DWORD PTR $T1[ebp], edx
$LN47@xmlNanoHTT:

; 562  :         }
; 563  :         if ((ctxt->in + ctxt->inlen) < (ctxt->inptr + XML_NANO_HTTP_CHUNK)) {

	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [edx+4096]
	add	ecx, ebx
	cmp	ecx, eax
	jae	SHORT $LN52@xmlNanoHTT

; 564  :             int d_inptr = ctxt->inptr - ctxt->in;
; 565  :             int d_content = ctxt->content - ctxt->in;

	mov	eax, DWORD PTR [esi+40]
	sub	eax, ebx
	mov	DWORD PTR _d_content$1$[ebp], eax

; 566  :             int d_inrptr = ctxt->inrptr - ctxt->in;
; 567  :             char *tmp_ptr = ctxt->in;
; 568  : 
; 569  :             ctxt->inlen *= 2;

	mov	eax, DWORD PTR [esi+52]
	add	eax, eax

; 570  :             ctxt->in = (char *) xmlRealloc(tmp_ptr, ctxt->inlen);

	push	eax
	push	ebx
	mov	DWORD PTR [esi+52], eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+36], eax

; 571  :             if (ctxt->in == NULL) {

	test	eax, eax
	je	$LN37@xmlNanoHTT

; 576  :             }
; 577  :             ctxt->inptr = ctxt->in + d_inptr;

	mov	edx, DWORD PTR $T1[ebp]

; 578  :             ctxt->content = ctxt->in + d_content;
; 579  :             ctxt->inrptr = ctxt->in + d_inrptr;

	sub	edi, ebx
	mov	ecx, DWORD PTR _d_content$1$[ebp]
	sub	edx, ebx
	add	edx, eax
	add	ecx, eax
	add	edi, eax
	mov	DWORD PTR [esi+44], edx
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+48], edi
$LN52@xmlNanoHTT:

; 580  :         }
; 581  :         ctxt->last = recv(ctxt->fd, ctxt->inptr, XML_NANO_HTTP_CHUNK, 0);

	push	0
	push	4096					; 00001000H
	push	edx
	push	DWORD PTR [esi+20]
	call	DWORD PTR __imp__recv@16
	mov	DWORD PTR [esi+56], eax

; 582  :         if (ctxt->last > 0) {

	test	eax, eax
	jg	$LN38@xmlNanoHTT

; 584  :             return (ctxt->last);
; 585  :         }
; 586  :         if (ctxt->last == 0) {

	je	SHORT $LN3@xmlNanoHTT

; 587  :             return (0);
; 588  :         }
; 589  :         if (ctxt->last == -1) {

	cmp	eax, -1
	jne	SHORT $LN20@xmlNanoHTT

; 590  :             switch (socket_errno()) {

	call	_socket_errno
	cmp	eax, 112				; 00000070H
	jg	SHORT $LN28@xmlNanoHTT
	je	SHORT $LN20@xmlNanoHTT
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN20@xmlNanoHTT
	cmp	eax, 108				; 0000006cH
	jmp	$LN55@xmlNanoHTT
$LN28@xmlNanoHTT:
	cmp	eax, 140				; 0000008cH
	jne	$LN41@xmlNanoHTT
$LN20@xmlNanoHTT:

; 605  :             }
; 606  :         }
; 607  : #ifdef HAVE_POLL_H
; 608  :         p.fd = ctxt->fd;
; 609  :         p.events = POLLIN;
; 610  :         if ((poll(&p, 1, timeout * 1000) < 1)
; 611  : #if defined(EINTR)
; 612  :             && (errno != EINTR)
; 613  : #endif
; 614  :             )
; 615  :             return (0);
; 616  : #else /* !HAVE_POLL_H */
; 617  : #ifndef _WINSOCKAPI_
; 618  :         if (ctxt->fd > FD_SETSIZE)
; 619  :             return 0;
; 620  : #endif
; 621  : 
; 622  :         tv.tv_sec = timeout;

	mov	eax, DWORD PTR _timeout

; 623  :         tv.tv_usec = 0;
; 624  :         FD_ZERO(&rfd);
; 625  : 
; 626  : #ifdef _MSC_VER
; 627  : #pragma warning(push)
; 628  : #pragma warning(disable: 4018)
; 629  : #endif
; 630  : 
; 631  :         FD_SET(ctxt->fd, &rfd);
; 632  : 
; 633  : #ifdef _MSC_VER
; 634  : #pragma warning(pop)
; 635  : #endif
; 636  : 
; 637  :         if ((select(ctxt->fd + 1, &rfd, NULL, NULL, &tv) < 1)
; 638  : #if defined(EINTR)
; 639  :             && (socket_errno() != EINTR)

	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	push	0
	mov	DWORD PTR _tv$[ebp], eax
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	eax, DWORD PTR [esi+20]
	push	0
	mov	DWORD PTR _rfd$[ebp+4], eax
	inc	eax
	push	ecx
	push	eax
	mov	DWORD PTR _tv$[ebp+4], 0
	mov	DWORD PTR _rfd$[ebp], 1
	call	DWORD PTR __imp__select@20
	cmp	eax, 1
	jge	SHORT $LN26@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 4
	jne	SHORT $LN3@xmlNanoHTT
$LN26@xmlNanoHTT:

; 535  : #ifdef HAVE_POLL_H
; 536  :     struct pollfd p;
; 537  : #else
; 538  :     fd_set rfd;
; 539  :     struct timeval tv;
; 540  : #endif
; 541  : 
; 542  : 
; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	test	BYTE PTR [esi+24], 2
	jne	$LL2@xmlNanoHTT
$LN3@xmlNanoHTT:
	pop	edi

; 640  : #endif
; 641  :             )
; 642  :             return (0);
; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }
; 645  :     return (0);
; 646  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BB@BIOIGIMH@allocating?5input@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 547  :                 xmlHTTPErrMemory("allocating input");
; 548  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 549  :                 return (-1);

	or	eax, -1
	pop	edi

; 640  : #endif
; 641  :             )
; 642  :             return (0);
; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }
; 645  :     return (0);
; 646  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError

; 572  :                 xmlHTTPErrMemory("allocating input buffer");
; 573  :                 xmlFree(tmp_ptr);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 574  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 575  :                 return (-1);

	or	eax, -1
	pop	edi

; 640  : #endif
; 641  :             )
; 642  :             return (0);
; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }
; 645  :     return (0);
; 646  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlNanoHTT:

; 590  :             switch (socket_errno()) {

	cmp	eax, 10058				; 0000274aH
$LN55@xmlNanoHTT:

; 591  :                 case EINPROGRESS:
; 592  :                 case EWOULDBLOCK:
; 593  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 594  :                 case EAGAIN:
; 595  : #endif
; 596  :                     break;
; 597  : 
; 598  :                 case ECONNRESET:
; 599  :                 case ESHUTDOWN:
; 600  :                     return (0);
; 601  : 
; 602  :                 default:
; 603  :                     __xmlIOErr(XML_FROM_HTTP, 0, "recv failed\n");

	je	SHORT $LN3@xmlNanoHTT
	push	OFFSET ??_C@_0N@NLPHEKBL@recv?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 604  :                     return (-1);

	or	eax, -1
	pop	edi

; 640  : #endif
; 641  :             )
; 642  :             return (0);
; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }
; 645  :     return (0);
; 646  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlNanoHTT:

; 583  :             ctxt->inptr += ctxt->last;

	add	DWORD PTR [esi+44], eax
	pop	edi

; 640  : #endif
; 641  :             )
; 642  :             return (0);
; 643  : #endif /* !HAVE_POLL_H */
; 644  :     }
; 645  :     return (0);
; 646  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPRecv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPSend
_TEXT	SEGMENT
_wfd$ = -268						; size = 260
_tv$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmt_ptr$ = 12						; size = 4
_outlen$ = 16						; size = 4
_xmlNanoHTTPSend PROC					; COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _outlen$[ebp]
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	test	BYTE PTR [ebx+24], 1
	je	$LN34@xmlNanoHTT

; 461  :     int total_sent = 0;
; 462  : #ifdef HAVE_POLL_H
; 463  :     struct pollfd p;
; 464  : #else
; 465  :     struct timeval tv;
; 466  :     fd_set wfd;
; 467  : #endif
; 468  : 
; 469  :     if ((ctxt->state & XML_NANO_HTTP_WRITE) && (xmt_ptr != NULL)) {

	mov	ecx, DWORD PTR _xmt_ptr$[ebp]
	test	ecx, ecx
	je	$LN34@xmlNanoHTT

; 470  :         while (total_sent < outlen) {

	test	edi, edi
	jle	$LN34@xmlNanoHTT
	npad	5
$LL2@xmlNanoHTT:

; 471  :             int nsent = send(ctxt->fd, SEND_ARG2_CAST (xmt_ptr + total_sent),

	push	0
	mov	eax, edi
	sub	eax, esi
	push	eax
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	DWORD PTR [ebx+20]
	call	DWORD PTR __imp__send@16

; 472  :                              outlen - total_sent, 0);
; 473  : 
; 474  :             if (nsent > 0)

	test	eax, eax
	jle	SHORT $LN11@xmlNanoHTT

; 475  :                 total_sent += nsent;

	add	esi, eax
	jmp	SHORT $LN14@xmlNanoHTT
$LN11@xmlNanoHTT:

; 476  :             else if ((nsent == -1) &&
; 477  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 478  :                      (socket_errno() != EAGAIN) &&

	cmp	eax, -1
	jne	SHORT $LN13@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN13@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 140				; 0000008cH
	jne	SHORT $LN23@xmlNanoHTT
$LN13@xmlNanoHTT:

; 483  :                     total_sent = -1;
; 484  :                 break;
; 485  :             } else {
; 486  :                 /*
; 487  :                  * No data sent
; 488  :                  * Since non-blocking sockets are used, wait for
; 489  :                  * socket to be writable or default timeout prior
; 490  :                  * to retrying.
; 491  :                  */
; 492  : #ifndef HAVE_POLL_H
; 493  : #ifndef _WINSOCKAPI_
; 494  :                 if (ctxt->fd > FD_SETSIZE)
; 495  :                     return -1;
; 496  : #endif
; 497  : 
; 498  :                 tv.tv_sec = timeout;

	mov	eax, DWORD PTR _timeout

; 499  :                 tv.tv_usec = 0;
; 500  :                 FD_ZERO(&wfd);
; 501  : #ifdef _MSC_VER
; 502  : #pragma warning(push)
; 503  : #pragma warning(disable: 4018)
; 504  : #endif
; 505  :                 FD_SET(ctxt->fd, &wfd);
; 506  : #ifdef _MSC_VER
; 507  : #pragma warning(pop)
; 508  : #endif
; 509  :                 (void) select(ctxt->fd + 1, NULL, &wfd, NULL, &tv);

	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	push	0
	mov	DWORD PTR _tv$[ebp], eax
	lea	ecx, DWORD PTR _wfd$[ebp]
	mov	eax, DWORD PTR [ebx+20]
	push	ecx
	mov	DWORD PTR _wfd$[ebp+4], eax
	inc	eax
	push	0
	push	eax
	mov	DWORD PTR _tv$[ebp+4], 0
	mov	DWORD PTR _wfd$[ebp], 1
	call	DWORD PTR __imp__select@20
$LN14@xmlNanoHTT:

; 470  :         while (total_sent < outlen) {

	cmp	esi, edi
	jge	SHORT $LN34@xmlNanoHTT
	mov	ecx, DWORD PTR _xmt_ptr$[ebp]
	jmp	SHORT $LL2@xmlNanoHTT
$LN23@xmlNanoHTT:

; 479  : #endif
; 480  :                      (socket_errno() != EWOULDBLOCK)) {
; 481  :                 __xmlIOErr(XML_FROM_HTTP, 0, "send failed\n");

	push	OFFSET ??_C@_0N@OOKOIPEM@send?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr

; 482  :                 if (total_sent == 0)

	or	eax, -1
	add	esp, 12					; 0000000cH
	test	esi, esi
	cmove	esi, eax
$LN34@xmlNanoHTT:

; 510  : #else
; 511  :                 p.fd = ctxt->fd;
; 512  :                 p.events = POLLOUT;
; 513  :                 (void) poll(&p, 1, timeout * 1000);
; 514  : #endif /* !HAVE_POLL_H */
; 515  :             }
; 516  :         }
; 517  :     }
; 518  : 
; 519  :     return total_sent;
; 520  : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPSend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFreeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlNanoHTTPFreeCtxt PROC				; COMDAT

; 424  : xmlNanoHTTPFreeCtxt(xmlNanoHTTPCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlNanoHTT

; 425  :     if (ctxt == NULL) return;
; 426  :     if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlNanoHTT:

; 427  :     if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlNanoHTT:

; 428  :     if (ctxt->path != NULL) xmlFree(ctxt->path);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlNanoHTT:

; 429  :     if (ctxt->query != NULL) xmlFree(ctxt->query);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNanoHTT:

; 430  :     if (ctxt->out != NULL) xmlFree(ctxt->out);

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN7@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlNanoHTT:

; 431  :     if (ctxt->in != NULL) xmlFree(ctxt->in);

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN8@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlNanoHTT:

; 432  :     if (ctxt->contentType != NULL) xmlFree(ctxt->contentType);

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN9@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlNanoHTT:

; 433  :     if (ctxt->encoding != NULL) xmlFree(ctxt->encoding);

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN10@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlNanoHTT:

; 434  :     if (ctxt->mimeType != NULL) xmlFree(ctxt->mimeType);

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	je	SHORT $LN11@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlNanoHTT:

; 435  :     if (ctxt->location != NULL) xmlFree(ctxt->location);

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN12@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlNanoHTT:

; 436  :     if (ctxt->authHeader != NULL) xmlFree(ctxt->authHeader);

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	je	SHORT $LN13@xmlNanoHTT
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlNanoHTT:

; 437  : #ifdef LIBXML_ZLIB_ENABLED
; 438  :     if (ctxt->strm != NULL) {

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN14@xmlNanoHTT

; 439  : 	inflateEnd(ctxt->strm);

	push	eax
	call	_inflateEnd@4

; 440  : 	xmlFree(ctxt->strm);

	push	DWORD PTR [esi+92]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlNanoHTT:

; 441  :     }
; 442  : #endif
; 443  : 
; 444  :     ctxt->state = XML_NANO_HTTP_NONE;
; 445  :     if (ctxt->fd != INVALID_SOCKET) closesocket(ctxt->fd);

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], 4
	cmp	eax, -1
	je	SHORT $LN15@xmlNanoHTT
	push	eax
	call	DWORD PTR __imp__closesocket@4
$LN15@xmlNanoHTT:

; 446  :     ctxt->fd = INVALID_SOCKET;
; 447  :     xmlFree(ctxt);

	push	esi
	mov	DWORD PTR [esi+20], -1
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlNanoHTT:
	pop	esi

; 448  : }

	pop	ebp
	ret	0
_xmlNanoHTTPFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPNewCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNanoHTTPNewCtxt PROC				; COMDAT

; 396  : xmlNanoHTTPNewCtxt(const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	100					; 00000064H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNanoHTT

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BD@NMNFIMM@allocating?5context@
	push	eax
	push	eax
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 397  :     xmlNanoHTTPCtxtPtr ret;
; 398  : 
; 399  :     ret = (xmlNanoHTTPCtxtPtr) xmlMalloc(sizeof(xmlNanoHTTPCtxt));
; 400  :     if (ret == NULL) {
; 401  :         xmlHTTPErrMemory("allocating context");
; 402  :         return(NULL);

	xor	eax, eax
	pop	esi

; 414  : }

	pop	ebp
	ret	0
$LN2@xmlNanoHTT:

; 403  :     }
; 404  : 
; 405  :     memset(ret, 0, sizeof(xmlNanoHTTPCtxt));

	push	100					; 00000064H
	push	0
	push	esi
	call	_memset

; 291  :     if (ctxt->protocol != NULL) {

	mov	eax, DWORD PTR [esi]

; 403  :     }
; 404  : 
; 405  :     memset(ret, 0, sizeof(xmlNanoHTTPCtxt));

	add	esp, 12					; 0000000cH

; 406  :     ret->port = 80;

	mov	DWORD PTR [esi+8], 80			; 00000050H

; 407  :     ret->returnValue = 0;
; 408  :     ret->fd = INVALID_SOCKET;

	mov	DWORD PTR [esi+20], -1

; 409  :     ret->ContentLength = -1;

	mov	DWORD PTR [esi+68], -1

; 291  :     if (ctxt->protocol != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlNanoHTT

; 292  :         xmlFree(ctxt->protocol);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 293  : 	ctxt->protocol = NULL;

	mov	DWORD PTR [esi], 0
$LN7@xmlNanoHTT:

; 294  :     }
; 295  :     if (ctxt->hostname != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN8@xmlNanoHTT

; 296  :         xmlFree(ctxt->hostname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 297  : 	ctxt->hostname = NULL;

	mov	DWORD PTR [esi+4], 0
$LN8@xmlNanoHTT:

; 298  :     }
; 299  :     if (ctxt->path != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@xmlNanoHTT

; 300  :         xmlFree(ctxt->path);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 301  : 	ctxt->path = NULL;

	mov	DWORD PTR [esi+12], 0
$LN9@xmlNanoHTT:

; 302  :     }
; 303  :     if (ctxt->query != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN10@xmlNanoHTT

; 304  :         xmlFree(ctxt->query);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 305  : 	ctxt->query = NULL;

	mov	DWORD PTR [esi+16], 0
$LN10@xmlNanoHTT:

; 306  :     }
; 307  :     if (URL == NULL) return;

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	$LN6@xmlNanoHTT

; 308  : 
; 309  :     uri = xmlParseURIRaw(URL, 1);

	push	edi
	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	edi, eax
	add	esp, 8

; 310  :     if (uri == NULL)

	test	edi, edi
	je	$LN25@xmlNanoHTT

; 311  : 	return;
; 312  : 
; 313  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN14@xmlNanoHTT
	cmp	DWORD PTR [edi+12], 0
	je	$LN14@xmlNanoHTT

; 315  : 	return;
; 316  :     }
; 317  : 
; 318  :     ctxt->protocol = xmlMemStrdup(uri->scheme);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi], eax
	add	esp, 4

; 319  :     /* special case of IPv6 addresses, the [] need to be removed */
; 320  :     if ((uri->server != NULL) && (*uri->server == '[')) {

	mov	edx, DWORD PTR [edi+12]
	test	edx, edx
	je	SHORT $LN15@xmlNanoHTT
	cmp	BYTE PTR [edx], 91			; 0000005bH
	jne	SHORT $LN15@xmlNanoHTT

; 321  :         len = strlen(uri->server);

	mov	ecx, edx
	push	ebx
	lea	ebx, DWORD PTR [ecx+1]
	npad	6
$LL24@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL24@xmlNanoHTT
	sub	ecx, ebx
	pop	ebx

; 322  : 	if ((len > 2) && (uri->server[len - 1] == ']')) {

	cmp	ecx, 2
	jle	SHORT $LN15@xmlNanoHTT
	cmp	BYTE PTR [edx+ecx-1], 93		; 0000005dH
	jne	SHORT $LN15@xmlNanoHTT

; 323  : 	    ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);

	lea	eax, DWORD PTR [ecx-2]
	push	eax
	lea	eax, DWORD PTR [edx+1]
	push	eax
	call	_xmlCharStrndup
	add	esp, 8

; 324  : 	} else

	jmp	SHORT $LN16@xmlNanoHTT
$LN15@xmlNanoHTT:

; 325  : 	    ctxt->hostname = xmlMemStrdup(uri->server);
; 326  :     } else
; 327  : 	ctxt->hostname = xmlMemStrdup(uri->server);
; 328  :     if (uri->path != NULL)

	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
$LN16@xmlNanoHTT:
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN19@xmlNanoHTT

; 329  : 	ctxt->path = xmlMemStrdup(uri->path);

	push	eax
	jmp	SHORT $LN26@xmlNanoHTT
$LN19@xmlNanoHTT:

; 330  :     else
; 331  : 	ctxt->path = xmlMemStrdup("/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
$LN26@xmlNanoHTT:

; 332  :     if (uri->query != NULL)

	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi+12], eax
	add	esp, 4
	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN21@xmlNanoHTT

; 333  : 	ctxt->query = xmlMemStrdup(uri->query);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax
$LN21@xmlNanoHTT:

; 334  :     if (uri->port != 0)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN14@xmlNanoHTT

; 335  : 	ctxt->port = uri->port;

	mov	DWORD PTR [esi+8], eax
$LN14@xmlNanoHTT:

; 314  : 	xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN25@xmlNanoHTT:
	pop	edi
$LN6@xmlNanoHTT:

; 410  : 
; 411  :     xmlNanoHTTPScanURL(ret, URL);
; 412  : 
; 413  :     return(ret);

	mov	eax, esi
	pop	esi

; 414  : }

	pop	ebp
	ret	0
_xmlNanoHTTPNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanURL
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlNanoHTTPScanURL PROC				; COMDAT

; 284  : xmlNanoHTTPScanURL(xmlNanoHTTPCtxtPtr ctxt, const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xmlNanoHTT

; 285  :     xmlURIPtr uri;
; 286  :     int len;
; 287  : 
; 288  :     /*
; 289  :      * Clear any existing data from the context
; 290  :      */
; 291  :     if (ctxt->protocol != NULL) {
; 292  :         xmlFree(ctxt->protocol);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 293  : 	ctxt->protocol = NULL;

	mov	DWORD PTR [esi], 0
$LN2@xmlNanoHTT:

; 294  :     }
; 295  :     if (ctxt->hostname != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlNanoHTT

; 296  :         xmlFree(ctxt->hostname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 297  : 	ctxt->hostname = NULL;

	mov	DWORD PTR [esi+4], 0
$LN3@xmlNanoHTT:

; 298  :     }
; 299  :     if (ctxt->path != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlNanoHTT

; 300  :         xmlFree(ctxt->path);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 301  : 	ctxt->path = NULL;

	mov	DWORD PTR [esi+12], 0
$LN4@xmlNanoHTT:

; 302  :     }
; 303  :     if (ctxt->query != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlNanoHTT

; 304  :         xmlFree(ctxt->query);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 305  : 	ctxt->query = NULL;

	mov	DWORD PTR [esi+16], 0
$LN5@xmlNanoHTT:

; 306  :     }
; 307  :     if (URL == NULL) return;

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	$LN1@xmlNanoHTT

; 308  : 
; 309  :     uri = xmlParseURIRaw(URL, 1);

	push	edi
	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	edi, eax
	add	esp, 8

; 310  :     if (uri == NULL)

	test	edi, edi
	je	$LN20@xmlNanoHTT

; 311  : 	return;
; 312  : 
; 313  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN9@xmlNanoHTT
	cmp	DWORD PTR [edi+12], 0
	je	$LN9@xmlNanoHTT

; 315  : 	return;
; 316  :     }
; 317  : 
; 318  :     ctxt->protocol = xmlMemStrdup(uri->scheme);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi], eax
	add	esp, 4

; 319  :     /* special case of IPv6 addresses, the [] need to be removed */
; 320  :     if ((uri->server != NULL) && (*uri->server == '[')) {

	mov	edx, DWORD PTR [edi+12]
	test	edx, edx
	je	SHORT $LN10@xmlNanoHTT
	cmp	BYTE PTR [edx], 91			; 0000005bH
	jne	SHORT $LN10@xmlNanoHTT

; 321  :         len = strlen(uri->server);

	mov	ecx, edx
	push	ebx
	lea	ebx, DWORD PTR [ecx+1]
$LL19@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL19@xmlNanoHTT
	sub	ecx, ebx
	pop	ebx

; 322  : 	if ((len > 2) && (uri->server[len - 1] == ']')) {

	cmp	ecx, 2
	jle	SHORT $LN10@xmlNanoHTT
	cmp	BYTE PTR [edx+ecx-1], 93		; 0000005dH
	jne	SHORT $LN10@xmlNanoHTT

; 323  : 	    ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);

	lea	eax, DWORD PTR [ecx-2]
	push	eax
	lea	eax, DWORD PTR [edx+1]
	push	eax
	call	_xmlCharStrndup
	add	esp, 8

; 324  : 	} else

	jmp	SHORT $LN11@xmlNanoHTT
$LN10@xmlNanoHTT:

; 325  : 	    ctxt->hostname = xmlMemStrdup(uri->server);
; 326  :     } else
; 327  : 	ctxt->hostname = xmlMemStrdup(uri->server);
; 328  :     if (uri->path != NULL)

	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
$LN11@xmlNanoHTT:
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN14@xmlNanoHTT

; 329  : 	ctxt->path = xmlMemStrdup(uri->path);

	push	eax
	jmp	SHORT $LN21@xmlNanoHTT
$LN14@xmlNanoHTT:

; 330  :     else
; 331  : 	ctxt->path = xmlMemStrdup("/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
$LN21@xmlNanoHTT:

; 332  :     if (uri->query != NULL)

	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi+12], eax
	add	esp, 4
	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN16@xmlNanoHTT

; 333  : 	ctxt->query = xmlMemStrdup(uri->query);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax
$LN16@xmlNanoHTT:

; 334  :     if (uri->port != 0)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN9@xmlNanoHTT

; 335  : 	ctxt->port = uri->port;

	mov	DWORD PTR [esi+8], eax
$LN9@xmlNanoHTT:

; 314  : 	xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN20@xmlNanoHTT:
	pop	edi
$LN1@xmlNanoHTT:
	pop	esi

; 336  : 
; 337  :     xmlFreeURI(uri);
; 338  : }

	pop	ebp
	ret	0
_xmlNanoHTTPScanURL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _socket_errno
_TEXT	SEGMENT
_socket_errno PROC					; COMDAT
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	call	DWORD PTR __imp__WSAGetLastError@0
	lea	ecx, DWORD PTR [eax-10004]
	cmp	ecx, 54					; 00000036H
	ja	SHORT $LN1@socket_err

; 177  : #ifdef _WINSOCKAPI_
; 178  :     int err = WSAGetLastError();
; 179  :     switch(err) {

	movzx	ecx, BYTE PTR $LN11@socket_err[ecx]
	jmp	DWORD PTR $LN13@socket_err[ecx*4]
$LN4@socket_err:

; 180  :         case WSAECONNRESET:
; 181  :             return(ECONNRESET);

	mov	eax, 108				; 0000006cH

; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	ret	0
$LN5@socket_err:

; 182  :         case WSAEINPROGRESS:
; 183  :             return(EINPROGRESS);

	mov	eax, 112				; 00000070H

; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	ret	0
$LN6@socket_err:

; 184  :         case WSAEINTR:
; 185  :             return(EINTR);

	mov	eax, 4

; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	ret	0
$LN7@socket_err:

; 186  :         case WSAESHUTDOWN:
; 187  :             return(ESHUTDOWN);

	mov	eax, 10058				; 0000274aH

; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	ret	0
$LN8@socket_err:

; 188  :         case WSAEWOULDBLOCK:
; 189  :             return(EWOULDBLOCK);

	mov	eax, 140				; 0000008cH
$LN1@socket_err:

; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }

	ret	0
	npad	1
$LN13@socket_err:
	DD	$LN6@socket_err
	DD	$LN8@socket_err
	DD	$LN5@socket_err
	DD	$LN4@socket_err
	DD	$LN7@socket_err
	DD	$LN1@socket_err
$LN11@socket_err:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
_socket_errno ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlHTTPErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlHTTPErrMemory PROC					; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 171  : }

	pop	ebp
	ret	0
_xmlHTTPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFetchContent
_TEXT	SEGMENT
_rfd$1 = -276						; size = 260
_tv$2 = -16						; size = 8
tv863 = -8						; size = 4
_dummy_int$ = -8					; size = 4
tv862 = -4						; size = 4
_d_content$1$ = 8					; size = 4
_ctx$ = 8						; size = 4
$T3 = 12						; size = 4
_ptr$ = 12						; size = 4
_rcvd_lgth$1$ = 16					; size = 4
_dummy_ptr$ = 16					; size = 4
_len$ = 16						; size = 4
_xmlNanoHTTPFetchContent PROC				; COMDAT

; 1822 : xmlNanoHTTPFetchContent( void * ctx, char ** ptr, int * len ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _len$[ebp]
	lea	ebx, DWORD PTR _dummy_int$[ebp]
	test	eax, eax
	lea	esi, DWORD PTR _dummy_ptr$[ebp]
	cmovne	ebx, eax
	mov	eax, DWORD PTR _ptr$[ebp]
	test	eax, eax
	mov	DWORD PTR tv863[ebp], ebx
	cmovne	esi, eax
	mov	DWORD PTR tv862[ebp], esi
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN7@xmlNanoHTT

; 1823 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1824 : 
; 1825 :     int			rc = 0;
; 1826 :     int			cur_lgth;
; 1827 :     int			rcvd_lgth;
; 1828 :     int			dummy_int;
; 1829 :     char *		dummy_ptr = NULL;
; 1830 : 
; 1831 :     /*  Dummy up return input parameters if not provided  */
; 1832 : 
; 1833 :     if ( len == NULL )
; 1834 :         len = &dummy_int;
; 1835 : 
; 1836 :     if ( ptr == NULL )
; 1837 :         ptr = &dummy_ptr;
; 1838 : 
; 1839 :     /*  But can't work without the context pointer  */
; 1840 : 
; 1841 :     if ( ( ctxt == NULL ) || ( ctxt->content == NULL ) ) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	$LN7@xmlNanoHTT

; 1845 :     }
; 1846 : 
; 1847 :     rcvd_lgth = ctxt->inptr - ctxt->content;

	mov	ebx, DWORD PTR [esi+44]
	sub	ebx, eax
	mov	DWORD PTR _rcvd_lgth$1$[ebp], ebx
	push	edi
$LL2@xmlNanoHTT:

; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	test	BYTE PTR [esi+24], 2
	je	$LN33@xmlNanoHTT
	npad	6
$LL14@xmlNanoHTT:

; 544  :         if (ctxt->in == NULL) {

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	jne	SHORT $LN71@xmlNanoHTT

; 545  :             ctxt->in = (char *) xmlMallocAtomic(65000 * sizeof(char));

	push	65000					; 0000fde8H
	call	DWORD PTR _xmlMallocAtomic
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+36], ecx

; 546  :             if (ctxt->in == NULL) {

	test	ecx, ecx
	je	$LN49@xmlNanoHTT

; 550  :             }
; 551  :             ctxt->inlen = 65000;

	mov	DWORD PTR [esi+52], 65000		; 0000fde8H

; 552  :             ctxt->inptr = ctxt->content = ctxt->inrptr = ctxt->in;

	mov	DWORD PTR [esi+48], ecx
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+44], ecx
$LN71@xmlNanoHTT:

; 553  :         }
; 554  :         if (ctxt->inrptr > ctxt->in + XML_NANO_HTTP_CHUNK) {

	mov	edx, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [ecx+4096]
	mov	ebx, DWORD PTR [esi+44]
	mov	DWORD PTR $T3[ebp], edx
	cmp	edx, eax
	jbe	SHORT $LN61@xmlNanoHTT

; 555  :             int delta = ctxt->inrptr - ctxt->in;
; 556  :             int len = ctxt->inptr - ctxt->inrptr;

	sub	ebx, edx
	mov	edi, edx

; 557  : 
; 558  :             memmove(ctxt->in, ctxt->inrptr, len);

	push	ebx
	push	edx
	push	ecx
	sub	edi, ecx
	call	_memmove

; 559  :             ctxt->inrptr -= delta;

	sub	DWORD PTR [esi+48], edi
	add	esp, 12					; 0000000cH

; 560  :             ctxt->content -= delta;

	sub	DWORD PTR [esi+40], edi
	mov	eax, DWORD PTR [esi+48]

; 561  :             ctxt->inptr -= delta;

	sub	DWORD PTR [esi+44], edi
	mov	ebx, DWORD PTR [esi+44]
	mov	DWORD PTR $T3[ebp], eax
$LN61@xmlNanoHTT:

; 562  :         }
; 563  :         if ((ctxt->in + ctxt->inlen) < (ctxt->inptr + XML_NANO_HTTP_CHUNK)) {

	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ebx+4096]
	mov	edi, DWORD PTR [esi+36]
	add	ecx, edi
	mov	edx, DWORD PTR [esi+40]
	cmp	ecx, eax
	jae	SHORT $LN70@xmlNanoHTT

; 564  :             int d_inptr = ctxt->inptr - ctxt->in;
; 565  :             int d_content = ctxt->content - ctxt->in;
; 566  :             int d_inrptr = ctxt->inrptr - ctxt->in;
; 567  :             char *tmp_ptr = ctxt->in;
; 568  : 
; 569  :             ctxt->inlen *= 2;

	mov	eax, DWORD PTR [esi+52]
	sub	edx, edi
	add	eax, eax
	mov	DWORD PTR _d_content$1$[ebp], edx

; 570  :             ctxt->in = (char *) xmlRealloc(tmp_ptr, ctxt->inlen);

	push	eax
	push	edi
	mov	DWORD PTR [esi+52], eax
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi+36], edx

; 571  :             if (ctxt->in == NULL) {

	test	edx, edx
	je	$LN50@xmlNanoHTT

; 576  :             }
; 577  :             ctxt->inptr = ctxt->in + d_inptr;
; 578  :             ctxt->content = ctxt->in + d_content;

	mov	eax, DWORD PTR _d_content$1$[ebp]
	mov	ecx, edx
	add	eax, edx
	sub	ecx, edi
	mov	DWORD PTR [esi+40], eax
	add	ebx, ecx

; 579  :             ctxt->inrptr = ctxt->in + d_inrptr;

	mov	eax, DWORD PTR $T3[ebp]
	add	eax, ecx
	mov	DWORD PTR [esi+44], ebx
	mov	DWORD PTR [esi+48], eax
$LN70@xmlNanoHTT:

; 580  :         }
; 581  :         ctxt->last = recv(ctxt->fd, ctxt->inptr, XML_NANO_HTTP_CHUNK, 0);

	push	0
	push	4096					; 00001000H
	push	ebx
	push	DWORD PTR [esi+20]
	call	DWORD PTR __imp__recv@16
	mov	DWORD PTR [esi+56], eax

; 582  :         if (ctxt->last > 0) {

	test	eax, eax
	jg	$LN51@xmlNanoHTT

; 584  :             return (ctxt->last);
; 585  :         }
; 586  :         if (ctxt->last == 0) {

	je	$LN76@xmlNanoHTT

; 587  :             return (0);
; 588  :         }
; 589  :         if (ctxt->last == -1) {

	cmp	eax, -1
	jne	SHORT $LN32@xmlNanoHTT

; 590  :             switch (socket_errno()) {

	call	_socket_errno
	cmp	eax, 112				; 00000070H
	jg	SHORT $LN40@xmlNanoHTT
	je	SHORT $LN32@xmlNanoHTT
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN32@xmlNanoHTT
	cmp	eax, 108				; 0000006cH
	jmp	$LN77@xmlNanoHTT
$LN40@xmlNanoHTT:
	cmp	eax, 140				; 0000008cH
	jne	$LN54@xmlNanoHTT
$LN32@xmlNanoHTT:

; 604  :                     return (-1);
; 605  :             }
; 606  :         }
; 607  : #ifdef HAVE_POLL_H
; 608  :         p.fd = ctxt->fd;
; 609  :         p.events = POLLIN;
; 610  :         if ((poll(&p, 1, timeout * 1000) < 1)
; 611  : #if defined(EINTR)
; 612  :             && (errno != EINTR)
; 613  : #endif
; 614  :             )
; 615  :             return (0);
; 616  : #else /* !HAVE_POLL_H */
; 617  : #ifndef _WINSOCKAPI_
; 618  :         if (ctxt->fd > FD_SETSIZE)
; 619  :             return 0;
; 620  : #endif
; 621  : 
; 622  :         tv.tv_sec = timeout;

	mov	eax, DWORD PTR _timeout

; 623  :         tv.tv_usec = 0;
; 624  :         FD_ZERO(&rfd);
; 625  : 
; 626  : #ifdef _MSC_VER
; 627  : #pragma warning(push)
; 628  : #pragma warning(disable: 4018)
; 629  : #endif
; 630  : 
; 631  :         FD_SET(ctxt->fd, &rfd);
; 632  : 
; 633  : #ifdef _MSC_VER
; 634  : #pragma warning(pop)
; 635  : #endif
; 636  : 
; 637  :         if ((select(ctxt->fd + 1, &rfd, NULL, NULL, &tv) < 1)
; 638  : #if defined(EINTR)
; 639  :             && (socket_errno() != EINTR)

	lea	ecx, DWORD PTR _tv$2[ebp]
	push	ecx
	push	0
	mov	DWORD PTR _tv$2[ebp], eax
	lea	ecx, DWORD PTR _rfd$1[ebp]
	mov	eax, DWORD PTR [esi+20]
	push	0
	mov	DWORD PTR _rfd$1[ebp+4], eax
	inc	eax
	push	ecx
	push	eax
	mov	DWORD PTR _tv$2[ebp+4], 0
	mov	DWORD PTR _rfd$1[ebp], 1
	call	DWORD PTR __imp__select@20
	cmp	eax, 1
	jge	SHORT $LN38@xmlNanoHTT
	call	_socket_errno
	cmp	eax, 4
	jne	$LN76@xmlNanoHTT
$LN38@xmlNanoHTT:

; 171  : }
; 172  : 
; 173  : /**
; 174  :  * A portability function
; 175  :  */
; 176  : static int socket_errno(void) {
; 177  : #ifdef _WINSOCKAPI_
; 178  :     int err = WSAGetLastError();
; 179  :     switch(err) {
; 180  :         case WSAECONNRESET:
; 181  :             return(ECONNRESET);
; 182  :         case WSAEINPROGRESS:
; 183  :             return(EINPROGRESS);
; 184  :         case WSAEINTR:
; 185  :             return(EINTR);
; 186  :         case WSAESHUTDOWN:
; 187  :             return(ESHUTDOWN);
; 188  :         case WSAEWOULDBLOCK:
; 189  :             return(EWOULDBLOCK);
; 190  :         default:
; 191  :             return(err);
; 192  :     }
; 193  : #else
; 194  :     return(errno);
; 195  : #endif
; 196  : }
; 197  : 
; 198  : #ifdef SUPPORT_IP6
; 199  : static
; 200  : int have_ipv6(void) {
; 201  :     SOCKET s;
; 202  : 
; 203  :     s = socket (AF_INET6, SOCK_STREAM, 0);
; 204  :     if (s != INVALID_SOCKET) {
; 205  : 	close (s);
; 206  : 	return (1);
; 207  :     }
; 208  :     return (0);
; 209  : }
; 210  : #endif
; 211  : 
; 212  : /**
; 213  :  * xmlNanoHTTPInit:
; 214  :  *
; 215  :  * Initialize the HTTP protocol layer.
; 216  :  * Currently it just checks for proxy informations
; 217  :  */
; 218  : 
; 219  : void
; 220  : xmlNanoHTTPInit(void) {
; 221  :     const char *env;
; 222  : #ifdef _WINSOCKAPI_
; 223  :     WSADATA wsaData;
; 224  : #endif
; 225  : 
; 226  :     if (initialized)
; 227  : 	return;
; 228  : 
; 229  : #ifdef _WINSOCKAPI_
; 230  :     if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
; 231  : 	return;
; 232  : #endif
; 233  : 
; 234  :     if (proxy == NULL) {
; 235  : 	proxyPort = 80;
; 236  : 	env = getenv("no_proxy");
; 237  : 	if (env && ((env[0] == '*') && (env[1] == 0)))
; 238  : 	    goto done;
; 239  : 	env = getenv("http_proxy");
; 240  : 	if (env != NULL) {
; 241  : 	    xmlNanoHTTPScanProxy(env);
; 242  : 	    goto done;
; 243  : 	}
; 244  : 	env = getenv("HTTP_PROXY");
; 245  : 	if (env != NULL) {
; 246  : 	    xmlNanoHTTPScanProxy(env);
; 247  : 	    goto done;
; 248  : 	}
; 249  :     }
; 250  : done:
; 251  :     initialized = 1;
; 252  : }
; 253  : 
; 254  : /**
; 255  :  * xmlNanoHTTPCleanup:
; 256  :  *
; 257  :  * Cleanup the HTTP protocol layer.
; 258  :  */
; 259  : 
; 260  : void
; 261  : xmlNanoHTTPCleanup(void) {
; 262  :     if (proxy != NULL) {
; 263  : 	xmlFree(proxy);
; 264  : 	proxy = NULL;
; 265  :     }
; 266  : #ifdef _WINSOCKAPI_
; 267  :     if (initialized)
; 268  : 	WSACleanup();
; 269  : #endif
; 270  :     initialized = 0;
; 271  :     return;
; 272  : }
; 273  : 
; 274  : /**
; 275  :  * xmlNanoHTTPScanURL:
; 276  :  * @ctxt:  an HTTP context
; 277  :  * @URL:  The URL used to initialize the context
; 278  :  *
; 279  :  * (Re)Initialize an HTTP context by parsing the URL and finding
; 280  :  * the protocol host port and path it indicates.
; 281  :  */
; 282  : 
; 283  : static void
; 284  : xmlNanoHTTPScanURL(xmlNanoHTTPCtxtPtr ctxt, const char *URL) {
; 285  :     xmlURIPtr uri;
; 286  :     int len;
; 287  : 
; 288  :     /*
; 289  :      * Clear any existing data from the context
; 290  :      */
; 291  :     if (ctxt->protocol != NULL) {
; 292  :         xmlFree(ctxt->protocol);
; 293  : 	ctxt->protocol = NULL;
; 294  :     }
; 295  :     if (ctxt->hostname != NULL) {
; 296  :         xmlFree(ctxt->hostname);
; 297  : 	ctxt->hostname = NULL;
; 298  :     }
; 299  :     if (ctxt->path != NULL) {
; 300  :         xmlFree(ctxt->path);
; 301  : 	ctxt->path = NULL;
; 302  :     }
; 303  :     if (ctxt->query != NULL) {
; 304  :         xmlFree(ctxt->query);
; 305  : 	ctxt->query = NULL;
; 306  :     }
; 307  :     if (URL == NULL) return;
; 308  : 
; 309  :     uri = xmlParseURIRaw(URL, 1);
; 310  :     if (uri == NULL)
; 311  : 	return;
; 312  : 
; 313  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {
; 314  : 	xmlFreeURI(uri);
; 315  : 	return;
; 316  :     }
; 317  : 
; 318  :     ctxt->protocol = xmlMemStrdup(uri->scheme);
; 319  :     /* special case of IPv6 addresses, the [] need to be removed */
; 320  :     if ((uri->server != NULL) && (*uri->server == '[')) {
; 321  :         len = strlen(uri->server);
; 322  : 	if ((len > 2) && (uri->server[len - 1] == ']')) {
; 323  : 	    ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);
; 324  : 	} else
; 325  : 	    ctxt->hostname = xmlMemStrdup(uri->server);
; 326  :     } else
; 327  : 	ctxt->hostname = xmlMemStrdup(uri->server);
; 328  :     if (uri->path != NULL)
; 329  : 	ctxt->path = xmlMemStrdup(uri->path);
; 330  :     else
; 331  : 	ctxt->path = xmlMemStrdup("/");
; 332  :     if (uri->query != NULL)
; 333  : 	ctxt->query = xmlMemStrdup(uri->query);
; 334  :     if (uri->port != 0)
; 335  : 	ctxt->port = uri->port;
; 336  : 
; 337  :     xmlFreeURI(uri);
; 338  : }
; 339  : 
; 340  : /**
; 341  :  * xmlNanoHTTPScanProxy:
; 342  :  * @URL:  The proxy URL used to initialize the proxy context
; 343  :  *
; 344  :  * (Re)Initialize the HTTP Proxy context by parsing the URL and finding
; 345  :  * the protocol host port it indicates.
; 346  :  * Should be like http://myproxy/ or http://myproxy:3128/
; 347  :  * A NULL URL cleans up proxy informations.
; 348  :  */
; 349  : 
; 350  : void
; 351  : xmlNanoHTTPScanProxy(const char *URL) {
; 352  :     xmlURIPtr uri;
; 353  : 
; 354  :     if (proxy != NULL) {
; 355  :         xmlFree(proxy);
; 356  : 	proxy = NULL;
; 357  :     }
; 358  :     proxyPort = 0;
; 359  : 
; 360  : #ifdef DEBUG_HTTP
; 361  :     if (URL == NULL)
; 362  : 	xmlGenericError(xmlGenericErrorContext,
; 363  : 		"Removing HTTP proxy info\n");
; 364  :     else
; 365  : 	xmlGenericError(xmlGenericErrorContext,
; 366  : 		"Using HTTP proxy %s\n", URL);
; 367  : #endif
; 368  :     if (URL == NULL) return;
; 369  : 
; 370  :     uri = xmlParseURIRaw(URL, 1);
; 371  :     if ((uri == NULL) || (uri->scheme == NULL) ||
; 372  : 	(strcmp(uri->scheme, "http")) || (uri->server == NULL)) {
; 373  : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Syntax Error\n");
; 374  : 	if (uri != NULL)
; 375  : 	    xmlFreeURI(uri);
; 376  : 	return;
; 377  :     }
; 378  : 
; 379  :     proxy = xmlMemStrdup(uri->server);
; 380  :     if (uri->port != 0)
; 381  : 	proxyPort = uri->port;
; 382  : 
; 383  :     xmlFreeURI(uri);
; 384  : }
; 385  : 
; 386  : /**
; 387  :  * xmlNanoHTTPNewCtxt:
; 388  :  * @URL:  The URL used to initialize the context
; 389  :  *
; 390  :  * Allocate and initialize a new HTTP context.
; 391  :  *
; 392  :  * Returns an HTTP context or NULL in case of error.
; 393  :  */
; 394  : 
; 395  : static xmlNanoHTTPCtxtPtr
; 396  : xmlNanoHTTPNewCtxt(const char *URL) {
; 397  :     xmlNanoHTTPCtxtPtr ret;
; 398  : 
; 399  :     ret = (xmlNanoHTTPCtxtPtr) xmlMalloc(sizeof(xmlNanoHTTPCtxt));
; 400  :     if (ret == NULL) {
; 401  :         xmlHTTPErrMemory("allocating context");
; 402  :         return(NULL);
; 403  :     }
; 404  : 
; 405  :     memset(ret, 0, sizeof(xmlNanoHTTPCtxt));
; 406  :     ret->port = 80;
; 407  :     ret->returnValue = 0;
; 408  :     ret->fd = INVALID_SOCKET;
; 409  :     ret->ContentLength = -1;
; 410  : 
; 411  :     xmlNanoHTTPScanURL(ret, URL);
; 412  : 
; 413  :     return(ret);
; 414  : }
; 415  : 
; 416  : /**
; 417  :  * xmlNanoHTTPFreeCtxt:
; 418  :  * @ctxt:  an HTTP context
; 419  :  *
; 420  :  * Frees the context after closing the connection.
; 421  :  */
; 422  : 
; 423  : static void
; 424  : xmlNanoHTTPFreeCtxt(xmlNanoHTTPCtxtPtr ctxt) {
; 425  :     if (ctxt == NULL) return;
; 426  :     if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);
; 427  :     if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);
; 428  :     if (ctxt->path != NULL) xmlFree(ctxt->path);
; 429  :     if (ctxt->query != NULL) xmlFree(ctxt->query);
; 430  :     if (ctxt->out != NULL) xmlFree(ctxt->out);
; 431  :     if (ctxt->in != NULL) xmlFree(ctxt->in);
; 432  :     if (ctxt->contentType != NULL) xmlFree(ctxt->contentType);
; 433  :     if (ctxt->encoding != NULL) xmlFree(ctxt->encoding);
; 434  :     if (ctxt->mimeType != NULL) xmlFree(ctxt->mimeType);
; 435  :     if (ctxt->location != NULL) xmlFree(ctxt->location);
; 436  :     if (ctxt->authHeader != NULL) xmlFree(ctxt->authHeader);
; 437  : #ifdef LIBXML_ZLIB_ENABLED
; 438  :     if (ctxt->strm != NULL) {
; 439  : 	inflateEnd(ctxt->strm);
; 440  : 	xmlFree(ctxt->strm);
; 441  :     }
; 442  : #endif
; 443  : 
; 444  :     ctxt->state = XML_NANO_HTTP_NONE;
; 445  :     if (ctxt->fd != INVALID_SOCKET) closesocket(ctxt->fd);
; 446  :     ctxt->fd = INVALID_SOCKET;
; 447  :     xmlFree(ctxt);
; 448  : }
; 449  : 
; 450  : /**
; 451  :  * xmlNanoHTTPSend:
; 452  :  * @ctxt:  an HTTP context
; 453  :  *
; 454  :  * Send the input needed to initiate the processing on the server side
; 455  :  * Returns number of bytes sent or -1 on error.
; 456  :  */
; 457  : 
; 458  : static int
; 459  : xmlNanoHTTPSend(xmlNanoHTTPCtxtPtr ctxt, const char *xmt_ptr, int outlen)
; 460  : {
; 461  :     int total_sent = 0;
; 462  : #ifdef HAVE_POLL_H
; 463  :     struct pollfd p;
; 464  : #else
; 465  :     struct timeval tv;
; 466  :     fd_set wfd;
; 467  : #endif
; 468  : 
; 469  :     if ((ctxt->state & XML_NANO_HTTP_WRITE) && (xmt_ptr != NULL)) {
; 470  :         while (total_sent < outlen) {
; 471  :             int nsent = send(ctxt->fd, SEND_ARG2_CAST (xmt_ptr + total_sent),
; 472  :                              outlen - total_sent, 0);
; 473  : 
; 474  :             if (nsent > 0)
; 475  :                 total_sent += nsent;
; 476  :             else if ((nsent == -1) &&
; 477  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 478  :                      (socket_errno() != EAGAIN) &&
; 479  : #endif
; 480  :                      (socket_errno() != EWOULDBLOCK)) {
; 481  :                 __xmlIOErr(XML_FROM_HTTP, 0, "send failed\n");
; 482  :                 if (total_sent == 0)
; 483  :                     total_sent = -1;
; 484  :                 break;
; 485  :             } else {
; 486  :                 /*
; 487  :                  * No data sent
; 488  :                  * Since non-blocking sockets are used, wait for
; 489  :                  * socket to be writable or default timeout prior
; 490  :                  * to retrying.
; 491  :                  */
; 492  : #ifndef HAVE_POLL_H
; 493  : #ifndef _WINSOCKAPI_
; 494  :                 if (ctxt->fd > FD_SETSIZE)
; 495  :                     return -1;
; 496  : #endif
; 497  : 
; 498  :                 tv.tv_sec = timeout;
; 499  :                 tv.tv_usec = 0;
; 500  :                 FD_ZERO(&wfd);
; 501  : #ifdef _MSC_VER
; 502  : #pragma warning(push)
; 503  : #pragma warning(disable: 4018)
; 504  : #endif
; 505  :                 FD_SET(ctxt->fd, &wfd);
; 506  : #ifdef _MSC_VER
; 507  : #pragma warning(pop)
; 508  : #endif
; 509  :                 (void) select(ctxt->fd + 1, NULL, &wfd, NULL, &tv);
; 510  : #else
; 511  :                 p.fd = ctxt->fd;
; 512  :                 p.events = POLLOUT;
; 513  :                 (void) poll(&p, 1, timeout * 1000);
; 514  : #endif /* !HAVE_POLL_H */
; 515  :             }
; 516  :         }
; 517  :     }
; 518  : 
; 519  :     return total_sent;
; 520  : }
; 521  : 
; 522  : /**
; 523  :  * xmlNanoHTTPRecv:
; 524  :  * @ctxt:  an HTTP context
; 525  :  *
; 526  :  * Read information coming from the HTTP connection.
; 527  :  * This is a blocking call (but it blocks in select(), not read()).
; 528  :  *
; 529  :  * Returns the number of byte read or -1 in case of error.
; 530  :  */
; 531  : 
; 532  : static int
; 533  : xmlNanoHTTPRecv(xmlNanoHTTPCtxtPtr ctxt)
; 534  : {
; 535  : #ifdef HAVE_POLL_H
; 536  :     struct pollfd p;
; 537  : #else
; 538  :     fd_set rfd;
; 539  :     struct timeval tv;
; 540  : #endif
; 541  : 
; 542  : 
; 543  :     while (ctxt->state & XML_NANO_HTTP_READ) {

	test	BYTE PTR [esi+24], 2
	jne	$LL14@xmlNanoHTT
	jmp	SHORT $LN76@xmlNanoHTT
$LN51@xmlNanoHTT:

; 1848 : 
; 1849 :     while ( (cur_lgth = xmlNanoHTTPRecv( ctxt )) > 0 ) {
; 1850 : 
; 1851 : 	rcvd_lgth += cur_lgth;

	mov	ebx, DWORD PTR _rcvd_lgth$1$[ebp]

; 583  :             ctxt->inptr += ctxt->last;

	add	DWORD PTR [esi+44], eax

; 1848 : 
; 1849 :     while ( (cur_lgth = xmlNanoHTTPRecv( ctxt )) > 0 ) {
; 1850 : 
; 1851 : 	rcvd_lgth += cur_lgth;

	add	ebx, eax

; 1852 : 	if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR _rcvd_lgth$1$[ebp], ebx
	test	eax, eax
	jle	$LL2@xmlNanoHTT
	cmp	ebx, eax
	jl	$LL2@xmlNanoHTT

; 1853 : 	    break;
; 1854 :     }

	jmp	SHORT $LN33@xmlNanoHTT
$LN49@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BB@BIOIGIMH@allocating?5input@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 548  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 549  :                 return (-1);

	jmp	SHORT $LN76@xmlNanoHTT
$LN50@xmlNanoHTT:

; 170  :     __xmlSimpleError(XML_FROM_HTTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@IFIOEEDJ@allocating?5input?5buffer@
	push	0
	push	0
	push	2
	push	10					; 0000000aH
	call	___xmlSimpleError

; 573  :                 xmlFree(tmp_ptr);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 574  :                 ctxt->last = -1;

	mov	DWORD PTR [esi+56], -1

; 575  :                 return (-1);

	jmp	SHORT $LN76@xmlNanoHTT
$LN54@xmlNanoHTT:

; 590  :             switch (socket_errno()) {

	cmp	eax, 10058				; 0000274aH
$LN77@xmlNanoHTT:

; 591  :                 case EINPROGRESS:
; 592  :                 case EWOULDBLOCK:
; 593  : #if defined(EAGAIN) && EAGAIN != EWOULDBLOCK
; 594  :                 case EAGAIN:
; 595  : #endif
; 596  :                     break;
; 597  : 
; 598  :                 case ECONNRESET:
; 599  :                 case ESHUTDOWN:
; 600  :                     return (0);
; 601  : 
; 602  :                 default:
; 603  :                     __xmlIOErr(XML_FROM_HTTP, 0, "recv failed\n");

	je	SHORT $LN76@xmlNanoHTT
	push	OFFSET ??_C@_0N@NLPHEKBL@recv?5failed?6@
	push	0
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN76@xmlNanoHTT:

; 1855 : 
; 1856 :     *ptr = ctxt->content;

	mov	ebx, DWORD PTR _rcvd_lgth$1$[ebp]
$LN33@xmlNanoHTT:
	mov	ecx, DWORD PTR tv862[ebp]
	mov	eax, DWORD PTR [esi+40]

; 1857 :     *len = rcvd_lgth;
; 1858 : 
; 1859 :     if ( ( ctxt->ContentLength > 0 ) && ( rcvd_lgth < ctxt->ContentLength ) )

	pop	edi
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR tv863[ebp]
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	jle	SHORT $LN9@xmlNanoHTT
	cmp	ebx, eax
	jge	SHORT $LN9@xmlNanoHTT

; 1860 :         rc = -1;

	or	ecx, -1
	pop	esi

; 1862 : 	rc = -1;
; 1863 : 
; 1864 :     return ( rc );

	mov	eax, ecx

; 1865 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlNanoHTT:

; 1861 :     else if ( rcvd_lgth == 0 )

	or	eax, -1
	mov	ecx, 0
	test	ebx, ebx
	pop	esi
	cmove	ecx, eax

; 1862 : 	rc = -1;
; 1863 : 
; 1864 :     return ( rc );

	mov	eax, ecx

; 1865 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlNanoHTT:

; 1842 :         *len = 0;
; 1843 : 	*ptr = NULL;

	mov	ecx, DWORD PTR tv862[ebp]

; 1844 : 	return ( -1 );

	or	eax, -1
	mov	DWORD PTR [ebx], 0
	pop	esi

; 1865 : }

	pop	ebx
	mov	DWORD PTR [ecx], 0
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPFetchContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPClose
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPClose PROC					; COMDAT

; 1329 : xmlNanoHTTPClose(void *ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlNanoHTT

; 1330 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1331 : 
; 1332 :     if (ctx == NULL) return;
; 1333 : 
; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	mov	DWORD PTR _ctx$[ebp], eax

; 1335 : }

	pop	ebp

; 1330 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1331 : 
; 1332 :     if (ctx == NULL) return;
; 1333 : 
; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	jmp	_xmlNanoHTTPFreeCtxt
$LN1@xmlNanoHTT:

; 1335 : }

	pop	ebp
	ret	0
_xmlNanoHTTPClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPSave
_TEXT	SEGMENT
_buf$ = -4						; size = 4
_len$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlNanoHTTPSave PROC					; COMDAT

; 1681 : xmlNanoHTTPSave(void *ctxt, const char *filename) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _buf$[ebp], 0
	test	edi, edi
	je	$LN3@xmlNanoHTT

; 1682 :     char *buf = NULL;
; 1683 :     int fd;
; 1684 :     int len;
; 1685 :     int ret = 0;
; 1686 : 
; 1687 :     if ((ctxt == NULL) || (filename == NULL)) return(-1);

	mov	esi, DWORD PTR _filename$[ebp]
	test	esi, esi
	je	$LN3@xmlNanoHTT

; 1688 : 
; 1689 :     if (!strcmp(filename, "-"))

	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, esi
$LL16@xmlNanoHTT:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN17@xmlNanoHTT
	test	dl, dl
	je	SHORT $LN18@xmlNanoHTT
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN17@xmlNanoHTT
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL16@xmlNanoHTT
$LN18@xmlNanoHTT:
	xor	eax, eax
	jmp	SHORT $LN19@xmlNanoHTT
$LN17@xmlNanoHTT:
	sbb	eax, eax
	or	eax, 1
$LN19@xmlNanoHTT:
	test	eax, eax
	jne	SHORT $LN4@xmlNanoHTT

; 1690 :         fd = 0;

	xor	esi, esi
$LN6@xmlNanoHTT:

; 1694 : 	    xmlNanoHTTPClose(ctxt);
; 1695 : 	    return(-1);
; 1696 : 	}
; 1697 :     }
; 1698 : 
; 1699 :     xmlNanoHTTPFetchContent( ctxt, &buf, &len );

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	edi
	call	_xmlNanoHTTPFetchContent

; 1700 :     if ( len > 0 ) {

	mov	eax, DWORD PTR _len$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN8@xmlNanoHTT

; 1701 : 	if (write(fd, buf, len) == -1) {

	push	eax
	push	DWORD PTR _buf$[ebp]
	push	esi
	call	DWORD PTR __imp__write
	or	ecx, -1
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	cmove	ebx, ecx
$LN8@xmlNanoHTT:

; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	push	edi
	call	_xmlNanoHTTPFreeCtxt

; 1702 : 	    ret = -1;
; 1703 : 	}
; 1704 :     }
; 1705 : 
; 1706 :     xmlNanoHTTPClose(ctxt);
; 1707 :     close(fd);

	push	esi
	call	DWORD PTR __imp__close
	add	esp, 8

; 1708 :     return(ret);

	mov	eax, ebx
	pop	edi

; 1709 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoHTT:

; 1691 :     else {
; 1692 :         fd = open(filename, O_CREAT | O_WRONLY, 0666);

	push	438					; 000001b6H
	push	257					; 00000101H
	push	esi
	call	DWORD PTR __imp__open
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1693 : 	if (fd < 0) {

	test	esi, esi
	jns	SHORT $LN6@xmlNanoHTT

; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	push	edi
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4
$LN3@xmlNanoHTT:
	pop	edi

; 1709 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPSave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRead
_TEXT	SEGMENT
_bytes_read$1$ = -4					; size = 4
_ctx$ = 8						; size = 4
_dest$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNanoHTTPRead PROC					; COMDAT

; 1274 : xmlNanoHTTPRead(void *ctx, void *dest, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	xor	edx, edx
	test	esi, esi
	je	$LN25@xmlNanoHTT

; 1275 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1276 : #ifdef LIBXML_ZLIB_ENABLED
; 1277 :     int bytes_read = 0;
; 1278 :     int orig_avail_in;
; 1279 :     int z_ret;
; 1280 : #endif
; 1281 : 
; 1282 :     if (ctx == NULL) return(-1);
; 1283 :     if (dest == NULL) return(-1);

	mov	edi, DWORD PTR _dest$[ebp]
	test	edi, edi
	je	$LN25@xmlNanoHTT

; 1284 :     if (len <= 0) return(0);

	push	ebx
	mov	ebx, DWORD PTR _len$[ebp]
	test	ebx, ebx
	jle	$LN24@xmlNanoHTT

; 1285 : 
; 1286 : #ifdef LIBXML_ZLIB_ENABLED
; 1287 :     if (ctxt->usesGzip == 1) {

	cmp	DWORD PTR [esi+96], 1
	jne	$LN17@xmlNanoHTT

; 1288 :         if (ctxt->strm == NULL) return(0);

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	$LN24@xmlNanoHTT

; 1289 : 
; 1290 :         ctxt->strm->next_out = dest;

	mov	DWORD PTR [eax+12], edi

; 1291 :         ctxt->strm->avail_out = len;

	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+16], ebx

; 1292 : 	ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+92]
	sub	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [eax+4], ecx

; 1293 : 
; 1294 :         while (ctxt->strm->avail_out > 0 &&

	mov	ecx, DWORD PTR [esi+92]
	cmp	DWORD PTR [ecx+16], edx
	jbe	SHORT $LN18@xmlNanoHTT
	xor	ebx, ebx
$LL2@xmlNanoHTT:
	cmp	DWORD PTR [ecx+4], 0
	ja	SHORT $LN11@xmlNanoHTT
	push	esi
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN26@xmlNanoHTT
	mov	ecx, DWORD PTR [esi+92]
$LN11@xmlNanoHTT:

; 1295 : 	       (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {
; 1296 :             orig_avail_in = ctxt->strm->avail_in =

	mov	edi, DWORD PTR [esi+44]
	sub	edi, ebx
	sub	edi, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx+4], edi

; 1297 : 			    ctxt->inptr - ctxt->inrptr - bytes_read;
; 1298 :             ctxt->strm->next_in = BAD_CAST (ctxt->inrptr + bytes_read);

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+92]
	add	ecx, ebx

; 1299 : 
; 1300 :             z_ret = inflate(ctxt->strm, Z_NO_FLUSH);

	push	0
	mov	DWORD PTR [eax], ecx
	push	DWORD PTR [esi+92]
	call	_inflate@8

; 1301 :             bytes_read += orig_avail_in - ctxt->strm->avail_in;

	mov	ecx, DWORD PTR [esi+92]
	sub	edi, DWORD PTR [ecx+4]
	add	ebx, edi

; 1302 : 
; 1303 :             if (z_ret != Z_OK) break;

	test	eax, eax
	jne	SHORT $LN26@xmlNanoHTT

; 1293 : 
; 1294 :         while (ctxt->strm->avail_out > 0 &&

	cmp	DWORD PTR [ecx+16], eax
	ja	SHORT $LL2@xmlNanoHTT
$LN26@xmlNanoHTT:
	mov	DWORD PTR _bytes_read$1$[ebp], ebx
	mov	ebx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _bytes_read$1$[ebp]
$LN18@xmlNanoHTT:

; 1304 : 	}
; 1305 : 
; 1306 :         ctxt->inrptr += bytes_read;
; 1307 :         return(len - ctxt->strm->avail_out);

	mov	eax, DWORD PTR [esi+92]
	add	DWORD PTR [esi+48], edx
	sub	ebx, DWORD PTR [eax+16]
	mov	eax, ebx
	pop	ebx
	pop	edi

; 1318 :     return(len);
; 1319 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlNanoHTT:

; 1308 :     }
; 1309 : #endif
; 1310 : 
; 1311 :     while (ctxt->inptr - ctxt->inrptr < len) {

	mov	eax, DWORD PTR [esi+44]
	sub	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	jge	SHORT $LN27@xmlNanoHTT
$LL4@xmlNanoHTT:

; 1312 :         if (xmlNanoHTTPRecv(ctxt) <= 0) break;

	push	esi
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN27@xmlNanoHTT

; 1308 :     }
; 1309 : #endif
; 1310 : 
; 1311 :     while (ctxt->inptr - ctxt->inrptr < len) {

	mov	eax, DWORD PTR [esi+44]
	sub	eax, DWORD PTR [esi+48]
	cmp	eax, ebx
	jl	SHORT $LL4@xmlNanoHTT
$LN27@xmlNanoHTT:

; 1313 :     }
; 1314 :     if (ctxt->inptr - ctxt->inrptr < len)

	mov	edx, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, edx
	cmp	ecx, ebx
	cmovl	ebx, ecx

; 1315 :         len = ctxt->inptr - ctxt->inrptr;
; 1316 :     memcpy(dest, ctxt->inrptr, len);

	push	ebx
	push	edx
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, ebx

; 1317 :     ctxt->inrptr += len;

	add	DWORD PTR [esi+48], ebx
	pop	ebx
	pop	edi

; 1318 :     return(len);
; 1319 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlNanoHTT:
	pop	ebx
	pop	edi

; 1288 :         if (ctxt->strm == NULL) return(0);

	xor	eax, eax

; 1318 :     return(len);
; 1319 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlNanoHTT:
	pop	edi

; 1275 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1276 : #ifdef LIBXML_ZLIB_ENABLED
; 1277 :     int bytes_read = 0;
; 1278 :     int orig_avail_in;
; 1279 :     int z_ret;
; 1280 : #endif
; 1281 : 
; 1282 :     if (ctx == NULL) return(-1);
; 1283 :     if (dest == NULL) return(-1);

	or	eax, -1

; 1318 :     return(len);
; 1319 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMimeType
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPMimeType PROC				; COMDAT

; 1803 : xmlNanoHTTPMimeType( void * ctx ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlNanoHTT

; 1807 : }

	pop	ebp
	ret	0
$LN3@xmlNanoHTT:

; 1804 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1805 : 
; 1806 :     return ( ( ctxt == NULL ) ? NULL : ctxt->mimeType );

	mov	eax, DWORD PTR [eax+88]

; 1807 : }

	pop	ebp
	ret	0
_xmlNanoHTTPMimeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPEncoding
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPEncoding PROC				; COMDAT

; 1788 : xmlNanoHTTPEncoding( void * ctx ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlNanoHTT

; 1792 : }

	pop	ebp
	ret	0
$LN3@xmlNanoHTT:

; 1789 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1790 : 
; 1791 :     return ( ( ctxt == NULL ) ? NULL : ctxt->encoding );

	mov	eax, DWORD PTR [eax+84]

; 1792 : }

	pop	ebp
	ret	0
_xmlNanoHTTPEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPContentLength
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPContentLength PROC				; COMDAT

; 1758 : xmlNanoHTTPContentLength( void * ctx ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlNanoHTT

; 1759 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1760 : 
; 1761 :     return ( ( ctxt == NULL ) ? -1 : ctxt->ContentLength );

	or	eax, -1

; 1762 : }

	pop	ebp
	ret	0
$LN3@xmlNanoHTT:

; 1759 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1760 : 
; 1761 :     return ( ( ctxt == NULL ) ? -1 : ctxt->ContentLength );

	mov	eax, DWORD PTR [eax+68]

; 1762 : }

	pop	ebp
	ret	0
_xmlNanoHTTPContentLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPRedir
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPRedir PROC					; COMDAT

; 1773 : xmlNanoHTTPRedir( void * ctx ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlNanoHTT

; 1777 : }

	pop	ebp
	ret	0
$LN3@xmlNanoHTT:

; 1774 :     xmlNanoHTTPCtxtPtr	ctxt = (xmlNanoHTTPCtxtPtr)ctx;
; 1775 : 
; 1776 :     return ( ( ctxt == NULL ) ? NULL : ctxt->location );

	mov	eax, DWORD PTR [eax+76]

; 1777 : }

	pop	ebp
	ret	0
_xmlNanoHTTPRedir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPAuthHeader
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPAuthHeader PROC				; COMDAT

; 1739 : xmlNanoHTTPAuthHeader(void *ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlNanoHTT

; 1745 : }

	pop	ebp
	ret	0
$LN2@xmlNanoHTT:

; 1740 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1741 : 
; 1742 :     if (ctxt == NULL) return(NULL);
; 1743 : 
; 1744 :     return(ctxt->authHeader);

	mov	eax, DWORD PTR [eax+80]

; 1745 : }

	pop	ebp
	ret	0
_xmlNanoHTTPAuthHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPReturnCode
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoHTTPReturnCode PROC				; COMDAT

; 1721 : xmlNanoHTTPReturnCode(void *ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlNanoHTT

; 1722 :     xmlNanoHTTPCtxtPtr ctxt = (xmlNanoHTTPCtxtPtr) ctx;
; 1723 : 
; 1724 :     if (ctxt == NULL) return(-1);

	or	eax, -1

; 1727 : }

	pop	ebp
	ret	0
$LN2@xmlNanoHTT:

; 1725 : 
; 1726 :     return(ctxt->returnValue);

	mov	eax, DWORD PTR [eax+60]

; 1727 : }

	pop	ebp
	ret	0
_xmlNanoHTTPReturnCode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPOpenRedir
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_contentType$ = 12					; size = 4
_redir$ = 16						; size = 4
_xmlNanoHTTPOpenRedir PROC				; COMDAT

; 1255 : xmlNanoHTTPOpenRedir(const char *URL, char **contentType, char **redir) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _contentType$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlNanoHTT

; 1256 :     if (contentType != NULL) *contentType = NULL;

	mov	DWORD PTR [eax], 0
$LN2@xmlNanoHTT:

; 1257 :     if (redir != NULL) *redir = NULL;

	mov	ecx, DWORD PTR _redir$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlNanoHTT
	mov	DWORD PTR [ecx], 0
$LN3@xmlNanoHTT:

; 1258 :     return(xmlNanoHTTPMethodRedir(URL, NULL, NULL, contentType, redir, NULL,0));

	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	DWORD PTR _URL$[ebp]
	call	_xmlNanoHTTPMethodRedir
	add	esp, 28					; 0000001cH

; 1259 : }

	pop	ebp
	ret	0
_xmlNanoHTTPOpenRedir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPOpen
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_contentType$ = 12					; size = 4
_xmlNanoHTTPOpen PROC					; COMDAT

; 1235 : xmlNanoHTTPOpen(const char *URL, char **contentType) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _contentType$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlNanoHTT

; 1236 :     if (contentType != NULL) *contentType = NULL;

	mov	DWORD PTR [eax], 0
$LN2@xmlNanoHTT:

; 1614 :     return(xmlNanoHTTPMethodRedir(URL, method, input, contentType,

	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	DWORD PTR _URL$[ebp]
	call	_xmlNanoHTTPMethodRedir
	add	esp, 28					; 0000001cH

; 1237 :     return(xmlNanoHTTPMethod(URL, NULL, NULL, contentType, NULL, 0));
; 1238 : }

	pop	ebp
	ret	0
_xmlNanoHTTPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMethodRedir
_TEXT	SEGMENT
_nbRedirects$1$ = -16					; size = 4
tv665 = -12						; size = 4
_redirURL$1$ = -8					; size = 4
_blen$3$ = -4						; size = 4
_URL$ = 8						; size = 4
_method$ = 12						; size = 4
_input$ = 16						; size = 4
_contentType$ = 20					; size = 4
_redir$ = 24						; size = 4
_headers$ = 28						; size = 4
_ilen$ = 32						; size = 4
_xmlNanoHTTPMethodRedir PROC				; COMDAT

; 1358 : 		  const char *headers, int ilen ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _URL$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _nbRedirects$1$[ebp], 0
	mov	DWORD PTR _redirURL$1$[ebp], ebx
	test	esi, esi
	je	$LN14@xmlNanoHTT

; 1359 :     xmlNanoHTTPCtxtPtr ctxt;
; 1360 :     char *bp, *p;
; 1361 :     int blen;
; 1362 :     SOCKET ret;
; 1363 :     int nbRedirects = 0;
; 1364 :     char *redirURL = NULL;
; 1365 : #ifdef DEBUG_HTTP
; 1366 :     int xmt_bytes;
; 1367 : #endif
; 1368 : 
; 1369 :     if (URL == NULL) return(NULL);
; 1370 :     if (method == NULL) method = "GET";
; 1371 :     xmlNanoHTTPInit();

	mov	eax, DWORD PTR _method$[ebp]
	mov	ecx, OFFSET ??_C@_03HAPOJHBM@GET@
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR tv665[ebp], ecx
	call	_xmlNanoHTTPInit
	npad	1
$retry$92:

; 1372 : 
; 1373 : retry:
; 1374 :     if (redirURL == NULL) {

	test	ebx, ebx
	jne	SHORT $LN8@xmlNanoHTT

; 1375 : 	ctxt = xmlNanoHTTPNewCtxt(URL);

	push	esi
	call	_xmlNanoHTTPNewCtxt
	mov	esi, eax
	add	esp, 4

; 1376 : 	if (ctxt == NULL)

	test	esi, esi
	je	$LN14@xmlNanoHTT

; 1377 : 	    return(NULL);
; 1378 :     } else {

	jmp	SHORT $LN9@xmlNanoHTT
$LN8@xmlNanoHTT:

; 1379 : 	ctxt = xmlNanoHTTPNewCtxt(redirURL);

	push	ebx
	call	_xmlNanoHTTPNewCtxt
	mov	esi, eax
	add	esp, 4

; 1380 : 	if (ctxt == NULL)

	test	esi, esi
	je	$LN14@xmlNanoHTT

; 1381 : 	    return(NULL);
; 1382 : 	ctxt->location = xmlMemStrdup(redirURL);

	push	ebx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+76], eax
$LN9@xmlNanoHTT:

; 1383 :     }
; 1384 : 
; 1385 :     if ((ctxt->protocol == NULL) || (strcmp(ctxt->protocol, "http"))) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN13@xmlNanoHTT
	mov	ecx, OFFSET ??_C@_04IAFLKNP@http@
$LL72@xmlNanoHTT:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN73@xmlNanoHTT
	test	dl, dl
	je	SHORT $LN74@xmlNanoHTT
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN73@xmlNanoHTT
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL72@xmlNanoHTT
$LN74@xmlNanoHTT:
	xor	eax, eax
	jmp	SHORT $LN75@xmlNanoHTT
$LN73@xmlNanoHTT:
	sbb	eax, eax
	or	eax, 1
$LN75@xmlNanoHTT:
	test	eax, eax
	jne	$LN13@xmlNanoHTT

; 1387 :         xmlNanoHTTPFreeCtxt(ctxt);
; 1388 : 	if (redirURL != NULL) xmlFree(redirURL);
; 1389 :         return(NULL);
; 1390 :     }
; 1391 :     if (ctxt->hostname == NULL) {

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	$LN62@xmlNanoHTT

; 1393 : 	           "Failed to identify host in URI");
; 1394 :         xmlNanoHTTPFreeCtxt(ctxt);
; 1395 : 	if (redirURL != NULL) xmlFree(redirURL);
; 1396 :         return(NULL);
; 1397 :     }
; 1398 :     if (proxy) {

	mov	edi, ecx
	lea	edx, DWORD PTR [edi+1]
$LL76@xmlNanoHTT:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL76@xmlNanoHTT
	mov	eax, DWORD PTR _proxy
	sub	edi, edx
	test	eax, eax
	je	SHORT $LN17@xmlNanoHTT

; 1399 : 	blen = strlen(ctxt->hostname) * 2 + 16;
; 1400 : 	ret = xmlNanoHTTPConnectHost(proxy, proxyPort);

	push	DWORD PTR _proxyPort
	lea	edi, DWORD PTR [edi*2+16]
	push	eax

; 1401 :     }

	jmp	SHORT $LN83@xmlNanoHTT
$LN17@xmlNanoHTT:

; 1402 :     else {
; 1403 : 	blen = strlen(ctxt->hostname);
; 1404 : 	ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);

	push	DWORD PTR [esi+8]
	push	ecx
$LN83@xmlNanoHTT:

; 1405 :     }
; 1406 :     if (ret == INVALID_SOCKET) {

	call	_xmlNanoHTTPConnectHost
	add	esp, 8
	cmp	eax, -1
	je	$LN63@xmlNanoHTT

; 1408 : 	if (redirURL != NULL) xmlFree(redirURL);
; 1409 :         return(NULL);
; 1410 :     }
; 1411 :     ctxt->fd = ret;
; 1412 : 
; 1413 :     if (input == NULL)
; 1414 : 	ilen = 0;
; 1415 :     else
; 1416 : 	blen += 36;
; 1417 : 
; 1418 :     if (headers != NULL)

	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [esi+20], eax
	xor	eax, eax
	test	ecx, ecx
	cmovne	eax, DWORD PTR _ilen$[ebp]
	mov	DWORD PTR _ilen$[ebp], eax
	lea	eax, DWORD PTR [edi+36]
	cmovne	edi, eax
	mov	eax, DWORD PTR _headers$[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlNanoHTT

; 1419 : 	blen += strlen(headers) + 2;

	mov	ecx, eax
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL77@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL77@xmlNanoHTT
	sub	ecx, edx
	add	edi, 2
	add	edi, ecx
$LN23@xmlNanoHTT:

; 1420 :     if (contentType && *contentType)

	mov	ebx, DWORD PTR _contentType$[ebp]
	test	ebx, ebx
	je	SHORT $LN24@xmlNanoHTT
	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN24@xmlNanoHTT

; 1421 : 	/* reserve for string plus 'Content-Type: \r\n" */
; 1422 : 	blen += strlen(*contentType) + 16;

	lea	edx, DWORD PTR [ecx+1]
	npad	2
$LL78@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL78@xmlNanoHTT
	sub	ecx, edx
	add	edi, 16					; 00000010H
	add	edi, ecx
$LN24@xmlNanoHTT:

; 1423 :     if (ctxt->query != NULL)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN25@xmlNanoHTT

; 1424 : 	/* 1 for '?' */
; 1425 : 	blen += strlen(ctxt->query) + 1;

	lea	edx, DWORD PTR [ecx+1]
$LL79@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL79@xmlNanoHTT
	sub	ecx, edx
	inc	edi
	add	edi, ecx
$LN25@xmlNanoHTT:

; 1426 :     blen += strlen(method) + strlen(ctxt->path) + 24;

	mov	ecx, DWORD PTR tv665[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL80@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL80@xmlNanoHTT
	sub	ecx, edx
	mov	edx, DWORD PTR [esi+12]
	lea	ebx, DWORD PTR [edx+1]
	npad	1
$LL81@xmlNanoHTT:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL81@xmlNanoHTT
	sub	edx, ebx

; 1427 : #ifdef LIBXML_ZLIB_ENABLED
; 1428 :     /* reserve for possible 'Accept-Encoding: gzip' string */
; 1429 :     blen += 23;

	add	edi, 47					; 0000002fH
	lea	eax, DWORD PTR [edx+ecx]
	add	edi, eax

; 1430 : #endif
; 1431 :     if (ctxt->port != 80) {

	cmp	DWORD PTR [esi+8], 80			; 00000050H
	mov	DWORD PTR _blen$3$[ebp], edi
	je	SHORT $LN28@xmlNanoHTT

; 1432 : 	/* reserve space for ':xxxxx', incl. potential proxy */
; 1433 : 	if (proxy)

	cmp	DWORD PTR _proxy, 0
	je	SHORT $LN27@xmlNanoHTT

; 1434 : 	    blen += 17;

	add	edi, 17					; 00000011H
	jmp	SHORT $LN84@xmlNanoHTT
$LN27@xmlNanoHTT:

; 1435 : 	else
; 1436 : 	    blen += 11;

	add	edi, 11					; 0000000bH
$LN84@xmlNanoHTT:

; 1437 :     }
; 1438 :     bp = (char*)xmlMallocAtomic(blen);

	mov	DWORD PTR _blen$3$[ebp], edi
$LN28@xmlNanoHTT:
	push	edi
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 1439 :     if ( bp == NULL ) {

	test	ebx, ebx
	je	$LN64@xmlNanoHTT

; 1442 : 	return ( NULL );
; 1443 :     }
; 1444 : 
; 1445 :     p = bp;
; 1446 : 
; 1447 :     if (proxy) {

	cmp	DWORD PTR _proxy, 0
	mov	eax, DWORD PTR [esi+12]
	push	eax
	je	SHORT $LN30@xmlNanoHTT

; 1448 : 	if (ctxt->port != 80) {

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, 80					; 00000050H
	je	SHORT $LN32@xmlNanoHTT

; 1449 : 	    p += snprintf( p, blen - (p - bp), "%s http://%s:%d%s",

	push	ecx
	push	edx
	push	DWORD PTR tv665[ebp]
	push	OFFSET ??_C@_0BC@EGOHMPNF@?$CFs?5http?3?1?1?$CFs?3?$CFd?$CFs@
	push	edi
	push	ebx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 1450 : 			method, ctxt->hostname,
; 1451 : 			ctxt->port, ctxt->path );
; 1452 : 	}

	jmp	SHORT $LN85@xmlNanoHTT
$LN32@xmlNanoHTT:

; 1453 : 	else
; 1454 : 	    p += snprintf( p, blen - (p - bp), "%s http://%s%s", method,

	push	edx
	push	DWORD PTR tv665[ebp]
	push	OFFSET ??_C@_0P@EIIHMMMN@?$CFs?5http?3?1?1?$CFs?$CFs@
	push	edi
	push	ebx
	call	_snprintf
	add	esp, 24					; 00000018H

; 1455 : 			ctxt->hostname, ctxt->path);
; 1456 :     }

	jmp	SHORT $LN85@xmlNanoHTT
$LN30@xmlNanoHTT:

; 1457 :     else
; 1458 : 	p += snprintf( p, blen - (p - bp), "%s %s", method, ctxt->path);

	push	DWORD PTR tv665[ebp]
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
	push	edi
	push	ebx
	call	_snprintf
	add	esp, 20					; 00000014H
$LN85@xmlNanoHTT:

; 1459 : 
; 1460 :     if (ctxt->query != NULL)

	lea	edi, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN34@xmlNanoHTT

; 1461 : 	p += snprintf( p, blen - (p - bp), "?%s", ctxt->query);

	push	eax
	mov	eax, ebx
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	push	OFFSET ??_C@_03EMGHGGCK@?$DP?$CFs@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 16					; 00000010H
	add	edi, eax
$LN34@xmlNanoHTT:

; 1462 : 
; 1463 :     if (ctxt->port == 80) {

	mov	edx, DWORD PTR [esi+8]
	mov	eax, ebx
	mov	ecx, DWORD PTR [esi+4]
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	cmp	edx, 80					; 00000050H
	jne	SHORT $LN35@xmlNanoHTT

; 1464 :         p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s\r\n",

	push	ecx
	push	OFFSET ??_C@_0BG@EGNPFNEM@?5HTTP?11?40?$AN?6Host?3?5?$CFs?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 16					; 00000010H

; 1465 : 		    ctxt->hostname);
; 1466 :     } else {

	jmp	SHORT $LN86@xmlNanoHTT
$LN35@xmlNanoHTT:

; 1467 :         p += snprintf( p, blen - (p - bp), " HTTP/1.0\r\nHost: %s:%d\r\n",

	push	edx
	push	ecx
	push	OFFSET ??_C@_0BJ@HMGEAMPD@?5HTTP?11?40?$AN?6Host?3?5?$CFs?3?$CFd?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 20					; 00000014H
$LN86@xmlNanoHTT:

; 1468 : 		    ctxt->hostname, ctxt->port);
; 1469 :     }
; 1470 : 
; 1471 : #ifdef LIBXML_ZLIB_ENABLED
; 1472 :     p += snprintf(p, blen - (p - bp), "Accept-Encoding: gzip\r\n");

	add	edi, eax
	mov	eax, ebx
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	push	OFFSET ??_C@_0BI@DHMFONHP@Accept?9Encoding?3?5gzip?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	edi, eax
	add	esp, 12					; 0000000cH

; 1473 : #endif
; 1474 : 
; 1475 :     if (contentType != NULL && *contentType)

	mov	eax, DWORD PTR _contentType$[ebp]
	test	eax, eax
	je	SHORT $LN37@xmlNanoHTT
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN37@xmlNanoHTT

; 1476 : 	p += snprintf(p, blen - (p - bp), "Content-Type: %s\r\n", *contentType);

	push	eax
	mov	eax, ebx
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	push	OFFSET ??_C@_0BD@KBHMLOB@Content?9Type?3?5?$CFs?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 16					; 00000010H
	add	edi, eax
$LN37@xmlNanoHTT:

; 1477 : 
; 1478 :     if (headers != NULL)

	mov	eax, DWORD PTR _headers$[ebp]
	test	eax, eax
	je	SHORT $LN38@xmlNanoHTT

; 1479 : 	p += snprintf( p, blen - (p - bp), "%s", headers );

	push	eax
	mov	eax, ebx
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 16					; 00000010H
	add	edi, eax
$LN38@xmlNanoHTT:

; 1480 : 
; 1481 :     if (input != NULL)

	mov	eax, ebx
	sub	eax, edi
	add	eax, DWORD PTR _blen$3$[ebp]
	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN39@xmlNanoHTT

; 1482 : 	snprintf(p, blen - (p - bp), "Content-Length: %d\r\n\r\n", ilen );

	push	DWORD PTR _ilen$[ebp]
	push	OFFSET ??_C@_0BH@HJCMLCON@Content?9Length?3?5?$CFd?$AN?6?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN40@xmlNanoHTT
$LN39@xmlNanoHTT:

; 1483 :     else
; 1484 : 	snprintf(p, blen - (p - bp), "\r\n");

	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6@
	push	eax
	push	edi
	call	_snprintf
	add	esp, 12					; 0000000cH
$LN40@xmlNanoHTT:

; 1485 : 
; 1486 : #ifdef DEBUG_HTTP
; 1487 :     xmlGenericError(xmlGenericErrorContext,
; 1488 : 	    "-> %s%s", proxy? "(Proxy) " : "", bp);
; 1489 :     if ((blen -= strlen(bp)+1) < 0)
; 1490 : 	xmlGenericError(xmlGenericErrorContext,
; 1491 : 		"ERROR: overflowed buffer by %d bytes\n", -blen);
; 1492 : #endif
; 1493 :     ctxt->outptr = ctxt->out = bp;
; 1494 :     ctxt->state = XML_NANO_HTTP_WRITE;
; 1495 :     blen = strlen( ctxt->out );

	mov	ecx, ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+24], 1
	lea	edx, DWORD PTR [ecx+1]
$LL82@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL82@xmlNanoHTT
	sub	ecx, edx

; 1496 : #ifdef DEBUG_HTTP
; 1497 :     xmt_bytes = xmlNanoHTTPSend(ctxt, ctxt->out, blen );
; 1498 :     if ( xmt_bytes != blen )
; 1499 :         xmlGenericError( xmlGenericErrorContext,
; 1500 : 			"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\n",
; 1501 : 			xmt_bytes, blen,
; 1502 : 			"bytes of HTTP headers sent to host",
; 1503 : 			ctxt->hostname );
; 1504 : #else
; 1505 :     xmlNanoHTTPSend(ctxt, ctxt->out, blen );

	push	ecx
	push	ebx
	push	esi
	call	_xmlNanoHTTPSend

; 1506 : #endif
; 1507 : 
; 1508 :     if ( input != NULL ) {

	mov	eax, DWORD PTR _input$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN41@xmlNanoHTT

; 1509 : #ifdef DEBUG_HTTP
; 1510 :         xmt_bytes = xmlNanoHTTPSend( ctxt, input, ilen );
; 1511 : 
; 1512 : 	if ( xmt_bytes != ilen )
; 1513 : 	    xmlGenericError( xmlGenericErrorContext,
; 1514 : 			"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\n",
; 1515 : 			xmt_bytes, ilen,
; 1516 : 			"bytes of HTTP content sent to host",
; 1517 : 			ctxt->hostname );
; 1518 : #else
; 1519 : 	xmlNanoHTTPSend( ctxt, input, ilen );

	push	DWORD PTR _ilen$[ebp]
	push	eax
	push	esi
	call	_xmlNanoHTTPSend
	add	esp, 12					; 0000000cH
$LN41@xmlNanoHTT:

; 1520 : #endif
; 1521 :     }
; 1522 : 
; 1523 :     ctxt->state = XML_NANO_HTTP_READ;
; 1524 : 
; 1525 :     while ((p = xmlNanoHTTPReadLine(ctxt)) != NULL) {

	push	esi
	mov	DWORD PTR [esi+24], 2
	call	_xmlNanoHTTPReadLine
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN3@xmlNanoHTT
	npad	1
$LL2@xmlNanoHTT:

; 1526 :         if (*p == 0) {

	cmp	BYTE PTR [edi], 0
	push	edi
	je	SHORT $LN58@xmlNanoHTT

; 1529 : 	    break;
; 1530 : 	}
; 1531 : 	xmlNanoHTTPScanAnswer(ctxt, p);

	push	esi
	call	_xmlNanoHTTPScanAnswer

; 1532 : 
; 1533 : #ifdef DEBUG_HTTP
; 1534 : 	xmlGenericError(xmlGenericErrorContext, "<- %s\n", p);
; 1535 : #endif
; 1536 :         xmlFree(p);

	push	edi
	call	DWORD PTR _xmlFree
	push	esi
	call	_xmlNanoHTTPReadLine
	mov	edi, eax
	add	esp, 16					; 00000010H
	test	edi, edi
	jne	SHORT $LL2@xmlNanoHTT

; 1439 :     if ( bp == NULL ) {

	jmp	SHORT $LN3@xmlNanoHTT
$LN58@xmlNanoHTT:

; 1527 : 	    ctxt->content = ctxt->inrptr;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+40], eax

; 1528 : 	    xmlFree(p);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlNanoHTT:

; 1537 :     }
; 1538 : 
; 1539 :     if ((ctxt->location != NULL) && (ctxt->returnValue >= 300) &&

	cmp	DWORD PTR [esi+76], 0
	je	$LN43@xmlNanoHTT
	mov	eax, DWORD PTR [esi+60]
	sub	eax, 300				; 0000012cH
	cmp	eax, 99					; 00000063H
	ja	SHORT $LN43@xmlNanoHTT
	npad	6
$LL4@xmlNanoHTT:

; 1540 :         (ctxt->returnValue < 400)) {
; 1541 : #ifdef DEBUG_HTTP
; 1542 : 	xmlGenericError(xmlGenericErrorContext,
; 1543 : 		"\nRedirect to: %s\n", ctxt->location);
; 1544 : #endif
; 1545 : 	while ( xmlNanoHTTPRecv(ctxt) > 0 )

	push	esi
	call	_xmlNanoHTTPRecv
	add	esp, 4
	test	eax, eax
	jg	SHORT $LL4@xmlNanoHTT

; 1546 :             ;
; 1547 :         if (nbRedirects < XML_NANO_HTTP_MAX_REDIR) {

	mov	edi, DWORD PTR _nbRedirects$1$[ebp]
	cmp	edi, 10					; 0000000aH
	jge	SHORT $LN44@xmlNanoHTT

; 1548 : 	    nbRedirects++;
; 1549 : 	    if (redirURL != NULL)

	mov	ecx, DWORD PTR _redirURL$1$[ebp]
	inc	edi
	mov	DWORD PTR _nbRedirects$1$[ebp], edi
	test	ecx, ecx
	je	SHORT $LN45@xmlNanoHTT

; 1550 : 		xmlFree(redirURL);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN45@xmlNanoHTT:

; 1551 : 	    redirURL = xmlMemStrdup(ctxt->location);

	push	DWORD PTR [esi+76]
	call	DWORD PTR _xmlMemStrdup
	mov	ebx, eax

; 1552 : 	    xmlNanoHTTPFreeCtxt(ctxt);

	push	esi
	mov	DWORD PTR _redirURL$1$[ebp], ebx
	call	_xmlNanoHTTPFreeCtxt

; 1553 : 	    goto retry;

	mov	esi, DWORD PTR _URL$[ebp]
	add	esp, 8
	jmp	$retry$92
$LN44@xmlNanoHTT:

; 1554 : 	}
; 1555 : 	xmlNanoHTTPFreeCtxt(ctxt);

	push	esi
	call	_xmlNanoHTTPFreeCtxt

; 1556 : 	if (redirURL != NULL) xmlFree(redirURL);

	mov	ecx, DWORD PTR _redirURL$1$[ebp]
	add	esp, 4
	test	ecx, ecx
	je	$LN14@xmlNanoHTT
	push	ecx

; 1592 : }

	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlNanoHTT:

; 1557 : #ifdef DEBUG_HTTP
; 1558 : 	xmlGenericError(xmlGenericErrorContext,
; 1559 : 		"xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\n");
; 1560 : #endif
; 1561 : 	return(NULL);
; 1562 :     }
; 1563 : 
; 1564 :     if (contentType != NULL) {

	mov	ebx, DWORD PTR _contentType$[ebp]
	test	ebx, ebx
	je	SHORT $LN49@xmlNanoHTT

; 1565 : 	if (ctxt->contentType != NULL)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN48@xmlNanoHTT

; 1566 : 	    *contentType = xmlMemStrdup(ctxt->contentType);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $LN49@xmlNanoHTT
$LN48@xmlNanoHTT:

; 1567 : 	else
; 1568 : 	    *contentType = NULL;

	mov	DWORD PTR [ebx], 0
$LN49@xmlNanoHTT:

; 1569 :     }
; 1570 : 
; 1571 :     if ((redir != NULL) && (redirURL != NULL)) {

	mov	eax, DWORD PTR _redir$[ebp]
	mov	ecx, DWORD PTR _redirURL$1$[ebp]
	test	eax, eax
	je	SHORT $LN50@xmlNanoHTT
	test	ecx, ecx
	je	SHORT $LN52@xmlNanoHTT

; 1572 : 	*redir = redirURL;

	pop	edi
	mov	DWORD PTR [eax], ecx

; 1578 :     }
; 1579 : 
; 1580 : #ifdef DEBUG_HTTP
; 1581 :     if (ctxt->contentType != NULL)
; 1582 : 	xmlGenericError(xmlGenericErrorContext,
; 1583 : 		"\nCode %d, content-type '%s'\n\n",
; 1584 : 	       ctxt->returnValue, ctxt->contentType);
; 1585 :     else
; 1586 : 	xmlGenericError(xmlGenericErrorContext,
; 1587 : 		"\nCode %d, no content-type\n\n",
; 1588 : 	       ctxt->returnValue);
; 1589 : #endif
; 1590 : 
; 1591 :     return((void *) ctxt);

	mov	eax, esi

; 1592 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlNanoHTT:
	pop	edi

; 1576 : 	if (redir != NULL)
; 1577 : 	    *redir = NULL;

	mov	DWORD PTR [eax], 0

; 1578 :     }
; 1579 : 
; 1580 : #ifdef DEBUG_HTTP
; 1581 :     if (ctxt->contentType != NULL)
; 1582 : 	xmlGenericError(xmlGenericErrorContext,
; 1583 : 		"\nCode %d, content-type '%s'\n\n",
; 1584 : 	       ctxt->returnValue, ctxt->contentType);
; 1585 :     else
; 1586 : 	xmlGenericError(xmlGenericErrorContext,
; 1587 : 		"\nCode %d, no content-type\n\n",
; 1588 : 	       ctxt->returnValue);
; 1589 : #endif
; 1590 : 
; 1591 :     return((void *) ctxt);

	mov	eax, esi

; 1592 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlNanoHTT:

; 1573 :     } else {
; 1574 : 	if (redirURL != NULL)

	test	ecx, ecx
	je	SHORT $LN53@xmlNanoHTT

; 1575 : 	    xmlFree(redirURL);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN53@xmlNanoHTT:

; 1578 :     }
; 1579 : 
; 1580 : #ifdef DEBUG_HTTP
; 1581 :     if (ctxt->contentType != NULL)
; 1582 : 	xmlGenericError(xmlGenericErrorContext,
; 1583 : 		"\nCode %d, content-type '%s'\n\n",
; 1584 : 	       ctxt->returnValue, ctxt->contentType);
; 1585 :     else
; 1586 : 	xmlGenericError(xmlGenericErrorContext,
; 1587 : 		"\nCode %d, no content-type\n\n",
; 1588 : 	       ctxt->returnValue);
; 1589 : #endif
; 1590 : 
; 1591 :     return((void *) ctxt);

	pop	edi
	mov	eax, esi

; 1592 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlNanoHTT:

; 1440 :         xmlNanoHTTPFreeCtxt( ctxt );

	push	esi
	call	_xmlNanoHTTPFreeCtxt

; 1441 : 	xmlHTTPErrMemory("allocating header buffer");

	push	OFFSET ??_C@_0BJ@BDBNHHKN@allocating?5header?5buffer@
	call	_xmlHTTPErrMemory
	add	esp, 8

; 1592 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@xmlNanoHTT:

; 1407 :         xmlNanoHTTPFreeCtxt(ctxt);

	push	esi
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4
	jmp	SHORT $LN89@xmlNanoHTT
$LN62@xmlNanoHTT:

; 1392 : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,

	push	OFFSET ??_C@_0BP@DMGJEOPF@Failed?5to?5identify?5host?5in?5URI@
	push	2022					; 000007e6H
	jmp	SHORT $LN90@xmlNanoHTT
$LN13@xmlNanoHTT:

; 1386 : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Not a valid HTTP URI");

	push	OFFSET ??_C@_0BF@ECOHPMPM@Not?5a?5valid?5HTTP?5URI@
	push	2020					; 000007e4H
$LN90@xmlNanoHTT:

; 1592 : }

	push	10					; 0000000aH
	call	___xmlIOErr
	push	esi
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 16					; 00000010H
$LN89@xmlNanoHTT:
	test	ebx, ebx
	je	SHORT $LN14@xmlNanoHTT
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlNanoHTT:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPMethodRedir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPMethod
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_method$ = 12						; size = 4
_input$ = 16						; size = 4
_contentType$ = 20					; size = 4
_headers$ = 24						; size = 4
_ilen$ = 28						; size = 4
_xmlNanoHTTPMethod PROC					; COMDAT

; 1613 :                   char **contentType, const char *headers, int ilen) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _ilen$[ebp]
	push	DWORD PTR _headers$[ebp]
	push	0
	push	DWORD PTR _contentType$[ebp]
	push	DWORD PTR _input$[ebp]
	push	DWORD PTR _method$[ebp]
	push	DWORD PTR _URL$[ebp]
	call	_xmlNanoHTTPMethodRedir
	add	esp, 28					; 0000001cH

; 1614 :     return(xmlNanoHTTPMethodRedir(URL, method, input, contentType,
; 1615 : 		                  NULL, headers, ilen));
; 1616 : }

	pop	ebp
	ret	0
_xmlNanoHTTPMethod ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPFetch
_TEXT	SEGMENT
_ret$1$ = -8						; size = 4
_buf$ = -4						; size = 4
_URL$ = 8						; size = 4
_len$ = 12						; size = 4
_filename$ = 12						; size = 4
_contentType$ = 16					; size = 4
_xmlNanoHTTPFetch PROC					; COMDAT

; 1632 : xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _buf$[ebp], 0
	mov	DWORD PTR _ret$1$[ebp], 0
	test	edi, edi
	je	$LN7@xmlNanoHTT

; 1236 :     if (contentType != NULL) *contentType = NULL;

	mov	esi, DWORD PTR _contentType$[ebp]
	test	esi, esi
	je	SHORT $LN23@xmlNanoHTT
	mov	DWORD PTR [esi], 0
$LN23@xmlNanoHTT:

; 1614 :     return(xmlNanoHTTPMethodRedir(URL, method, input, contentType,

	push	0
	push	0
	push	0
	push	esi
	push	0
	push	0
	push	DWORD PTR _URL$[ebp]
	call	_xmlNanoHTTPMethodRedir

; 1633 :     void *ctxt = NULL;
; 1634 :     char *buf = NULL;
; 1635 :     int fd;
; 1636 :     int len;
; 1637 :     int ret = 0;
; 1638 : 
; 1639 :     if (filename == NULL) return(-1);
; 1640 :     ctxt = xmlNanoHTTPOpen(URL, contentType);

	mov	ebx, eax

; 1614 :     return(xmlNanoHTTPMethodRedir(URL, method, input, contentType,

	add	esp, 28					; 0000001cH

; 1641 :     if (ctxt == NULL) return(-1);

	test	ebx, ebx
	je	$LN7@xmlNanoHTT

; 1642 : 
; 1643 :     if (!strcmp(filename, "-"))

	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, edi
$LL24@xmlNanoHTT:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN25@xmlNanoHTT
	test	dl, dl
	je	SHORT $LN26@xmlNanoHTT
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN25@xmlNanoHTT
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL24@xmlNanoHTT
$LN26@xmlNanoHTT:
	xor	eax, eax
	jmp	SHORT $LN27@xmlNanoHTT
$LN25@xmlNanoHTT:
	sbb	eax, eax
	or	eax, 1
$LN27@xmlNanoHTT:
	test	eax, eax
	jne	SHORT $LN4@xmlNanoHTT

; 1644 :         fd = 0;

	xor	edi, edi
$LN6@xmlNanoHTT:

; 1652 : 	    }
; 1653 : 	    return(-1);
; 1654 : 	}
; 1655 :     }
; 1656 : 
; 1657 :     xmlNanoHTTPFetchContent( ctxt, &buf, &len );

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	ebx
	call	_xmlNanoHTTPFetchContent

; 1658 :     if ( len > 0 ) {

	mov	eax, DWORD PTR _len$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN9@xmlNanoHTT

; 1659 : 	if (write(fd, buf, len) == -1) {

	push	eax
	push	DWORD PTR _buf$[ebp]
	push	edi
	call	DWORD PTR __imp__write
	or	edx, -1
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	eax, edx
	cmove	ecx, edx
	mov	DWORD PTR _ret$1$[ebp], ecx
$LN9@xmlNanoHTT:

; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	push	ebx
	call	_xmlNanoHTTPFreeCtxt

; 1660 : 	    ret = -1;
; 1661 : 	}
; 1662 :     }
; 1663 : 
; 1664 :     xmlNanoHTTPClose(ctxt);
; 1665 :     close(fd);

	push	edi
	call	DWORD PTR __imp__close

; 1666 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	edi

; 1667 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoHTT:

; 1645 :     else {
; 1646 :         fd = open(filename, O_CREAT | O_WRONLY, 00644);

	push	420					; 000001a4H
	push	257					; 00000101H
	push	edi
	call	DWORD PTR __imp__open
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1647 : 	if (fd < 0) {

	test	edi, edi
	jns	SHORT $LN6@xmlNanoHTT

; 1334 :     xmlNanoHTTPFreeCtxt(ctxt);

	push	ebx
	call	_xmlNanoHTTPFreeCtxt
	add	esp, 4

; 1648 : 	    xmlNanoHTTPClose(ctxt);
; 1649 : 	    if ((contentType != NULL) && (*contentType != NULL)) {

	test	esi, esi
	je	SHORT $LN7@xmlNanoHTT
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@xmlNanoHTT

; 1650 : 	        xmlFree(*contentType);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1651 : 		*contentType = NULL;

	mov	DWORD PTR [esi], 0
$LN7@xmlNanoHTT:

; 1667 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPFetch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPScanProxy
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNanoHTTPScanProxy PROC				; COMDAT

; 351  : xmlNanoHTTPScanProxy(const char *URL) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _proxy
	test	eax, eax
	je	SHORT $LN2@xmlNanoHTT

; 352  :     xmlURIPtr uri;
; 353  : 
; 354  :     if (proxy != NULL) {
; 355  :         xmlFree(proxy);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 356  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoHTT:

; 357  :     }
; 358  :     proxyPort = 0;
; 359  : 
; 360  : #ifdef DEBUG_HTTP
; 361  :     if (URL == NULL)
; 362  : 	xmlGenericError(xmlGenericErrorContext,
; 363  : 		"Removing HTTP proxy info\n");
; 364  :     else
; 365  : 	xmlGenericError(xmlGenericErrorContext,
; 366  : 		"Using HTTP proxy %s\n", URL);
; 367  : #endif
; 368  :     if (URL == NULL) return;

	mov	eax, DWORD PTR _URL$[ebp]
	mov	DWORD PTR _proxyPort, 0
	test	eax, eax
	je	$LN6@xmlNanoHTT

; 369  : 
; 370  :     uri = xmlParseURIRaw(URL, 1);

	push	esi
	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	esi, eax
	add	esp, 8

; 371  :     if ((uri == NULL) || (uri->scheme == NULL) ||
; 372  : 	(strcmp(uri->scheme, "http")) || (uri->server == NULL)) {

	test	esi, esi
	je	SHORT $LN5@xmlNanoHTT
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@xmlNanoHTT
	mov	edx, OFFSET ??_C@_04IAFLKNP@http@
	npad	4
$LL10@xmlNanoHTT:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN11@xmlNanoHTT
	test	al, al
	je	SHORT $LN12@xmlNanoHTT
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN11@xmlNanoHTT
	add	ecx, 2
	add	edx, 2
	test	al, al
	jne	SHORT $LL10@xmlNanoHTT
$LN12@xmlNanoHTT:
	xor	eax, eax
	jmp	SHORT $LN13@xmlNanoHTT
$LN11@xmlNanoHTT:
	sbb	eax, eax
	or	eax, 1
$LN13@xmlNanoHTT:
	test	eax, eax
	jne	SHORT $LN5@xmlNanoHTT
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@xmlNanoHTT

; 376  : 	return;
; 377  :     }
; 378  : 
; 379  :     proxy = xmlMemStrdup(uri->server);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR _proxy, eax
	add	esp, 4

; 380  :     if (uri->port != 0)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN9@xmlNanoHTT

; 381  : 	proxyPort = uri->port;

	push	esi
	mov	DWORD PTR _proxyPort, eax
	call	_xmlFreeURI
	add	esp, 4
	pop	esi

; 382  : 
; 383  :     xmlFreeURI(uri);
; 384  : }

	pop	ebp
	ret	0
$LN5@xmlNanoHTT:

; 373  : 	__xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, "Syntax Error\n");

	push	OFFSET ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
	push	2020					; 000007e4H
	push	10					; 0000000aH
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 374  : 	if (uri != NULL)

	test	esi, esi
	je	SHORT $LN14@xmlNanoHTT
$LN9@xmlNanoHTT:

; 375  : 	    xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4
$LN14@xmlNanoHTT:
	pop	esi
$LN6@xmlNanoHTT:

; 382  : 
; 383  :     xmlFreeURI(uri);
; 384  : }

	pop	ebp
	ret	0
_xmlNanoHTTPScanProxy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPCleanup
_TEXT	SEGMENT
_xmlNanoHTTPCleanup PROC				; COMDAT
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _proxy
	test	eax, eax
	je	SHORT $LN2@xmlNanoHTT

; 262  :     if (proxy != NULL) {
; 263  : 	xmlFree(proxy);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 264  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoHTT:

; 265  :     }
; 266  : #ifdef _WINSOCKAPI_
; 267  :     if (initialized)

	cmp	DWORD PTR _initialized, 0
	je	SHORT $LN5@xmlNanoHTT

; 268  : 	WSACleanup();

	call	DWORD PTR __imp__WSACleanup@0
$LN5@xmlNanoHTT:

; 269  : #endif
; 270  :     initialized = 0;
; 271  :     return;
; 272  : }

	mov	DWORD PTR _initialized, 0
	ret	0
_xmlNanoHTTPCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanohttp.c
;	COMDAT _xmlNanoHTTPInit
_TEXT	SEGMENT
_wsaData$ = -400					; size = 400
_xmlNanoHTTPInit PROC					; COMDAT

; 220  : xmlNanoHTTPInit(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	ecx, OFFSET __BDFA7347_nanohttp@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _initialized, 0
	jne	SHORT $LN1@xmlNanoHTT

; 221  :     const char *env;
; 222  : #ifdef _WINSOCKAPI_
; 223  :     WSADATA wsaData;
; 224  : #endif
; 225  : 
; 226  :     if (initialized)
; 227  : 	return;
; 228  : 
; 229  : #ifdef _WINSOCKAPI_
; 230  :     if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	push	257					; 00000101H
	call	DWORD PTR __imp__WSAStartup@8
	test	eax, eax
	jne	SHORT $LN1@xmlNanoHTT

; 231  : 	return;
; 232  : #endif
; 233  : 
; 234  :     if (proxy == NULL) {

	cmp	DWORD PTR _proxy, eax
	jne	SHORT $done$12

; 235  : 	proxyPort = 80;

	push	esi

; 236  : 	env = getenv("no_proxy");

	mov	esi, DWORD PTR __imp__getenv
	push	OFFSET ??_C@_08BOGLDIEC@no_proxy@
	mov	DWORD PTR _proxyPort, 80		; 00000050H
	call	esi
	add	esp, 4

; 237  : 	if (env && ((env[0] == '*') && (env[1] == 0)))

	test	eax, eax
	je	SHORT $LN5@xmlNanoHTT
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	SHORT $LN5@xmlNanoHTT
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN9@xmlNanoHTT
$LN5@xmlNanoHTT:

; 238  : 	    goto done;
; 239  : 	env = getenv("http_proxy");

	push	OFFSET ??_C@_0L@BKCFCEPH@http_proxy@
	call	esi
	add	esp, 4

; 240  : 	if (env != NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlNanoHTT

; 241  : 	    xmlNanoHTTPScanProxy(env);
; 242  : 	    goto done;
; 243  : 	}
; 244  : 	env = getenv("HTTP_PROXY");

	push	OFFSET ??_C@_0L@GDPFKPEL@HTTP_PROXY@
	call	esi
	add	esp, 4

; 245  : 	if (env != NULL) {

	test	eax, eax
	je	SHORT $LN9@xmlNanoHTT
$LN10@xmlNanoHTT:

; 246  : 	    xmlNanoHTTPScanProxy(env);

	push	eax
	call	_xmlNanoHTTPScanProxy
	add	esp, 4
$LN9@xmlNanoHTT:
	pop	esi
$done$12:

; 247  : 	    goto done;
; 248  : 	}
; 249  :     }
; 250  : done:
; 251  :     initialized = 1;

	mov	DWORD PTR _initialized, 1
$LN1@xmlNanoHTT:

; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoHTTPInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiFreeAddrInfo@4
_TEXT	SEGMENT
_ai$ = 8						; size = 4
_WspiapiFreeAddrInfo@4 PROC				; COMDAT

; 1058 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9 ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
	test	eax, eax
	jne	SHORT $LN2@WspiapiFre

; 1059 :     static WSPIAPI_PFREEADDRINFO    pfFreeAddrInfo   = NULL;
; 1060 : 
; 1061 :     if (!pfFreeAddrInfo)
; 1062 :         pfFreeAddrInfo  = (WSPIAPI_PFREEADDRINFO) WspiapiLoad(2);

	push	2
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfFreeAddrInfo@?1??WspiapiFreeAddrInfo@@9@9, eax ; `WspiapiFreeAddrInfo'::`2'::pfFreeAddrInfo
$LN2@WspiapiFre:

; 1064 : }

	pop	ebp

; 1063 :     (*pfFreeAddrInfo)(ai);

	jmp	eax
_WspiapiFreeAddrInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiGetAddrInfo@16
_TEXT	SEGMENT
_nodename$ = 8						; size = 4
_servname$ = 12						; size = 4
_hints$ = 16						; size = 4
_res$ = 20						; size = 4
_WspiapiGetAddrInfo@16 PROC				; COMDAT

; 1014 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9 ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
	test	eax, eax
	jne	SHORT $LN2@WspiapiGet

; 1015 :     int                             iError;
; 1016 :     static WSPIAPI_PGETADDRINFO     pfGetAddrInfo   = NULL;
; 1017 :     
; 1018 :     if (!pfGetAddrInfo)
; 1019 :         pfGetAddrInfo   = (WSPIAPI_PGETADDRINFO) WspiapiLoad(0);

	push	eax
	call	_WspiapiLoad@4
	mov	DWORD PTR ?pfGetAddrInfo@?1??WspiapiGetAddrInfo@@9@9, eax ; `WspiapiGetAddrInfo'::`2'::pfGetAddrInfo
$LN2@WspiapiGet:

; 1020 : 
; 1021 :     iError = (*pfGetAddrInfo)(nodename, servname, hints, res);

	push	esi
	push	DWORD PTR _res$[ebp]
	push	DWORD PTR _hints$[ebp]
	push	DWORD PTR _servname$[ebp]
	push	DWORD PTR _nodename$[ebp]
	call	eax
	mov	esi, eax

; 1022 :     WSASetLastError(iError);

	push	esi
	call	DWORD PTR __imp__WSASetLastError@4

; 1023 :     return iError;

	mov	eax, esi
	pop	esi

; 1024 : }

	pop	ebp
	ret	16					; 00000010H
_WspiapiGetAddrInfo@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLoad@4
_TEXT	SEGMENT
_SystemDir$1 = -556					; size = 261
_Path$2 = -292						; size = 268
_rgtLocal$ = -24					; size = 24
_wFunction$ = 8						; size = 2
_WspiapiLoad@4 PROC					; COMDAT

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR ?bInitialized@?1??WspiapiLoad@@9@9, 0 ; `WspiapiLoad'::`2'::bInitialized
	mov	DWORD PTR _rgtLocal$[ebp], OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	mov	DWORD PTR _rgtLocal$[ebp+4], OFFSET _WspiapiLegacyGetAddrInfo@16
	mov	DWORD PTR _rgtLocal$[ebp+8], OFFSET ??_C@_0M@NNJNLPKG@getnameinfo@
	mov	DWORD PTR _rgtLocal$[ebp+12], OFFSET _WspiapiLegacyGetNameInfo@28
	mov	DWORD PTR _rgtLocal$[ebp+16], OFFSET ??_C@_0N@EHOPPMLH@freeaddrinfo@
	mov	DWORD PTR _rgtLocal$[ebp+20], OFFSET _WspiapiLegacyFreeAddrInfo@4
	jne	$LN42@WspiapiLoa

; 908  :     HMODULE                 hLibrary        = NULL;
; 909  : 
; 910  :     // these static variables store state across calls, across threads.
; 911  :     static BOOL             bInitialized    = FALSE;
; 912  :     static WSPIAPI_FUNCTION rgtGlobal[]     = WSPIAPI_FUNCTION_ARRAY;
; 913  :     static const int        iNumGlobal      = (sizeof(rgtGlobal) /
; 914  :                                                sizeof(WSPIAPI_FUNCTION));
; 915  :     
; 916  :     // we overwrite rgtGlobal only if all routines exist in library.
; 917  :     WSPIAPI_FUNCTION        rgtLocal[]      = WSPIAPI_FUNCTION_ARRAY;
; 918  :     __analysis_assume((sizeof(rgtLocal)/sizeof(WSPIAPI_FUNCTION)) == iNumGlobal);
; 919  :     FARPROC                 fScratch        = NULL;
; 920  :     int                     i               = 0;
; 921  :     
; 922  :     
; 923  :     if (bInitialized)           // WspiapiLoad has already been called once
; 924  :         return (rgtGlobal[wFunction].pfAddress);
; 925  : 
; 926  :     for (;;)                    // breakout loop
; 927  :     {
; 928  :         CHAR SystemDir[MAX_PATH + 1];
; 929  :         CHAR Path[MAX_PATH + 8];
; 930  : 
; 931  :         if (GetSystemDirectoryA(SystemDir, MAX_PATH) == 0) 

	push	260					; 00000104H
	lea	eax, DWORD PTR _SystemDir$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemDirectoryA@8
	test	eax, eax
	je	$LN32@WspiapiLoa

; 932  :         {
; 933  :             break;
; 934  :         }
; 935  : 
; 936  :         // in Whistler and beyond...
; 937  :         // the routines are present in the WinSock 2 library (ws2_32.dll).
; 938  :         // printf("Looking in ws2_32 for getaddrinfo...\n");
; 939  :         _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);

	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _SystemDir$1[ebp]
	push	eax
	lea	eax, DWORD PTR _Path$2[ebp]
	push	268					; 0000010cH
	push	eax
	call	DWORD PTR __imp__strcpy_s

; 940  :         _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\ws2_32");

	push	OFFSET ??_C@_07LPPPKMHP@?2ws2_32@
	lea	eax, DWORD PTR _Path$2[ebp]
	push	268					; 0000010cH
	push	eax
	call	DWORD PTR __imp__strcat_s
	add	esp, 24					; 00000018H

; 941  :         hLibrary = LoadLibraryA(Path);

	lea	eax, DWORD PTR _Path$2[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4

; 942  :         if (hLibrary != NULL)

	mov	esi, DWORD PTR __imp__FreeLibrary@4
	mov	edi, eax
	mov	ebx, DWORD PTR __imp__GetProcAddress@8
	test	edi, edi
	je	SHORT $LN38@WspiapiLoa

; 943  :         {
; 944  :             fScratch = GetProcAddress(hLibrary, "getaddrinfo");

	push	OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	push	edi
	call	ebx

; 945  :             if (fScratch == NULL)

	test	eax, eax
	jne	SHORT $LN20@WspiapiLoa

; 946  :             {
; 947  :                 FreeLibrary(hLibrary);

	push	edi
	call	esi
$LN38@WspiapiLoa:

; 948  :                 hLibrary = NULL;
; 949  :             }
; 950  :         }
; 951  :         if (hLibrary != NULL)
; 952  :             break;
; 953  :         
; 954  : 
; 955  :         // in the IPv6 Technology Preview...        
; 956  :         // the routines are present in the IPv6 WinSock library (wship6.dll).
; 957  :         // printf("Looking in wship6 for getaddrinfo...\n");
; 958  :         _WSPIAPI_STRCPY_S(Path, _WSPIAPI_COUNTOF(Path), SystemDir);

	lea	eax, DWORD PTR _SystemDir$1[ebp]
	push	eax
	lea	eax, DWORD PTR _Path$2[ebp]
	push	268					; 0000010cH
	push	eax
	call	DWORD PTR __imp__strcpy_s

; 959  :         _WSPIAPI_STRCAT_S(Path, _WSPIAPI_COUNTOF(Path), "\\wship6");

	push	OFFSET ??_C@_07OKMCKPF@?2wship6@
	lea	eax, DWORD PTR _Path$2[ebp]
	push	268					; 0000010cH
	push	eax
	call	DWORD PTR __imp__strcat_s
	add	esp, 24					; 00000018H

; 960  :         hLibrary = LoadLibraryA(Path);

	lea	eax, DWORD PTR _Path$2[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	edi, eax

; 961  :         if (hLibrary != NULL)

	test	edi, edi
	je	SHORT $LN39@WspiapiLoa

; 962  :         {
; 963  :             fScratch = GetProcAddress(hLibrary, "getaddrinfo");

	push	OFFSET ??_C@_0M@MBIPAJOD@getaddrinfo@
	push	edi
	call	ebx

; 964  :             if (fScratch == NULL)

	test	eax, eax
	jne	SHORT $LN20@WspiapiLoa

; 965  :             {
; 966  :                 FreeLibrary(hLibrary);

	push	edi
	call	esi

; 967  :                 hLibrary = NULL;
; 968  :             }
; 969  :         }
; 970  : 
; 971  :         break;
; 972  :     }
; 973  : 
; 974  : 
; 975  :     if (hLibrary != NULL)

	jmp	SHORT $LN39@WspiapiLoa
$LN20@WspiapiLoa:

; 976  :     {
; 977  :         // use routines from this library...
; 978  :         // since getaddrinfo is here, we expect all routines to be here,
; 979  :         // but will fall back to IPv4-only if any of them is missing.
; 980  :         for (i = 0; i < iNumGlobal; i++)

	xor	esi, esi
$LL10@WspiapiLoa:

; 981  :         {
; 982  :             rgtLocal[i].pfAddress
; 983  :                 = GetProcAddress(hLibrary, rgtLocal[i].pszName);

	push	DWORD PTR _rgtLocal$[ebp+esi*8]
	push	edi
	call	ebx
	mov	DWORD PTR _rgtLocal$[ebp+esi*8+4], eax

; 984  :             if (rgtLocal[i].pfAddress == NULL)

	test	eax, eax
	je	SHORT $LN27@WspiapiLoa

; 976  :     {
; 977  :         // use routines from this library...
; 978  :         // since getaddrinfo is here, we expect all routines to be here,
; 979  :         // but will fall back to IPv4-only if any of them is missing.
; 980  :         for (i = 0; i < iNumGlobal; i++)

	inc	esi
	cmp	esi, 3
	jl	SHORT $LL10@WspiapiLoa

; 987  :                 hLibrary = NULL;
; 988  :                 break;
; 989  :             }
; 990  :         }
; 991  : 
; 992  :         if (hLibrary != NULL)
; 993  :         {
; 994  :             // printf("found!\n");
; 995  :             for (i = 0; i < iNumGlobal; i++)
; 996  :                 rgtGlobal[i].pfAddress = rgtLocal[i].pfAddress;

	mov	eax, DWORD PTR _rgtLocal$[ebp+4]
	mov	DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9+4, eax
	mov	eax, DWORD PTR _rgtLocal$[ebp+12]
	mov	DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9+12, eax
	mov	eax, DWORD PTR _rgtLocal$[ebp+20]
	mov	DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9+20, eax
	jmp	SHORT $LN39@WspiapiLoa
$LN27@WspiapiLoa:

; 985  :             {
; 986  :                 FreeLibrary(hLibrary);

	push	edi
	call	DWORD PTR __imp__FreeLibrary@4
$LN39@WspiapiLoa:
	pop	edi
	pop	esi
	pop	ebx
$LN32@WspiapiLoa:

; 997  :         }
; 998  :     }
; 999  :     
; 1000 :     bInitialized = TRUE;

	mov	DWORD PTR ?bInitialized@?1??WspiapiLoad@@9@9, 1 ; `WspiapiLoad'::`2'::bInitialized
$LN42@WspiapiLoa:

; 1001 :     return (rgtGlobal[wFunction].pfAddress);
; 1002 : }

	movzx	eax, WORD PTR _wFunction$[ebp]
	mov	eax, DWORD PTR ?rgtGlobal@?1??WspiapiLoad@@9@9[eax*8+4]
	mov	esp, ebp
	pop	ebp
	ret	4
_WspiapiLoad@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyGetNameInfo@28
_TEXT	SEGMENT
_szBuffer$ = -12					; size = 6
_tAddress$ = -4						; size = 4
_wPort$1$ = 8						; size = 4
tv228 = 8						; size = 4
_ptSocketAddress$ = 8					; size = 4
_tSocketLength$ = 12					; size = 4
_pszNodeName$ = 16					; size = 4
_tNodeLength$ = 20					; size = 4
_pszServiceName$ = 24					; size = 4
_tServiceLength$ = 28					; size = 4
_iFlags$ = 32						; size = 4
_WspiapiLegacyGetNameInfo@28 PROC			; COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR ??_C@_05LGDGBMPG@65535@
	mov	esi, DWORD PTR _ptSocketAddress$[ebp]
	mov	DWORD PTR _szBuffer$[ebp], eax
	mov	ax, WORD PTR ??_C@_05LGDGBMPG@65535@+4
	mov	WORD PTR _szBuffer$[ebp+4], ax
	test	esi, esi
	je	$LN5@WspiapiLeg

; 737  :     struct servent  *ptService;
; 738  :     WORD            wPort;    
; 739  :     char            szBuffer[]  = "65535";
; 740  :     char            *pszService = szBuffer;
; 741  : 
; 742  :     struct hostent  *ptHost;
; 743  :     struct in_addr  tAddress;
; 744  :     char            *pszNode    = NULL;
; 745  :     char            *pc         = NULL;
; 746  :     
; 747  : 
; 748  :     // sanity check ptSocketAddress and tSocketLength.
; 749  :     if ((!ptSocketAddress) || (tSocketLength < sizeof(struct sockaddr)))

	cmp	DWORD PTR _tSocketLength$[ebp], 16	; 00000010H
	jb	$LN5@WspiapiLeg

; 750  :         return EAI_FAIL;
; 751  :     
; 752  :     if (ptSocketAddress->sa_family != AF_INET)

	cmp	WORD PTR [esi], 2
	je	SHORT $LN6@WspiapiLeg

; 855  :         else
; 856  :             return EAI_FAIL;
; 857  :     }
; 858  : 
; 859  :     return 0;
; 860  : }

	pop	edi
	pop	esi
	mov	eax, 10047				; 0000273fH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN6@WspiapiLeg:

; 753  :         return EAI_FAMILY;
; 754  : 
; 755  :     if (tSocketLength < sizeof(struct sockaddr_in))
; 756  :         return EAI_FAIL;
; 757  :     
; 758  :     if (!(pszNodeName && tNodeLength) &&

	cmp	DWORD PTR _pszNodeName$[ebp], 0
	mov	edi, DWORD PTR _tServiceLength$[ebp]
	mov	edx, DWORD PTR _pszServiceName$[ebp]
	mov	ecx, DWORD PTR _tNodeLength$[ebp]
	je	SHORT $LN9@WspiapiLeg
	test	ecx, ecx
	jne	SHORT $LN8@WspiapiLeg
$LN9@WspiapiLeg:
	test	edx, edx
	je	$LN10@WspiapiLeg
	test	edi, edi
	je	$LN10@WspiapiLeg
$LN8@WspiapiLeg:

; 759  :         !(pszServiceName && tServiceLength))
; 760  :     {
; 761  :         return EAI_NONAME;    
; 762  :     }
; 763  : 
; 764  :     // the draft has the "bad flags" error code, so presumably we
; 765  :     // should check something here.  insisting that there aren't
; 766  :     // any unspecified flags set would break forward compatibility,
; 767  :     // however.  so we just check for non-sensical combinations.
; 768  :     if ((iFlags & NI_NUMERICHOST) && (iFlags & NI_NAMEREQD))

	mov	ebx, DWORD PTR _iFlags$[ebp]
	mov	eax, ebx
	and	eax, 6
	cmp	al, 6
	jne	SHORT $LN11@WspiapiLeg

; 855  :         else
; 856  :             return EAI_FAIL;
; 857  :     }
; 858  : 
; 859  :     return 0;
; 860  : }

	pop	edi
	pop	esi
	mov	eax, 10022				; 00002726H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN11@WspiapiLeg:

; 769  :     {                                                                       
; 770  :         return EAI_BADFLAGS;
; 771  :     }
; 772  :         
; 773  :     // translate the port to a service name (if requested).
; 774  :     if (pszServiceName && tServiceLength)

	test	edx, edx
	je	$LN18@WspiapiLeg
	test	edi, edi
	je	$LN18@WspiapiLeg

; 775  :     {
; 776  :         wPort = ((struct sockaddr_in *) ptSocketAddress)->sin_port;

	movzx	ecx, WORD PTR [esi+2]
	mov	DWORD PTR _wPort$1$[ebp], ecx

; 777  :         
; 778  :         if (iFlags & NI_NUMERICSERV)

	test	bl, 8
	je	SHORT $LN13@WspiapiLeg

; 779  :         {
; 780  :             // return numeric form of the address.
; 781  :             _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));

	push	ecx

; 782  :         }

	jmp	SHORT $LN36@WspiapiLeg
$LN13@WspiapiLeg:

; 783  :         else
; 784  :         {
; 785  :             // return service name corresponding to port.
; 786  :             ptService = getservbyport(wPort,

	test	bl, 16					; 00000010H
	mov	edx, 0
	mov	eax, OFFSET ??_C@_03OCLLGKEH@udp@
	cmove	eax, edx
	push	eax
	movzx	eax, cx
	push	eax
	call	DWORD PTR __imp__getservbyport@8

; 787  :                                       (iFlags & NI_DGRAM) ? "udp" : NULL);
; 788  :             if (ptService && ptService->s_name)

	test	eax, eax
	je	SHORT $LN15@WspiapiLeg
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN15@WspiapiLeg

; 789  :             {
; 790  :                 // lookup successful.
; 791  :                 pszService = ptService->s_name;

	mov	edx, eax

; 792  :             }

	jmp	SHORT $LN16@WspiapiLeg
$LN15@WspiapiLeg:

; 793  :             else
; 794  :             {
; 795  :                 // DRAFT: return numeric form of the port!
; 796  :                 _WSPIAPI_SPRINTF_S_1(szBuffer, _WSPIAPI_COUNTOF(szBuffer), "%u", ntohs(wPort));

	push	DWORD PTR _wPort$1$[ebp]
$LN36@WspiapiLeg:

; 797  :             }
; 798  :         }
; 799  :         
; 800  :         
; 801  :         if (tServiceLength > strlen(pszService))

	call	DWORD PTR __imp__ntohs@4
	movzx	eax, ax
	push	eax
	push	OFFSET ??_C@_02GMHACPFF@?$CFu@
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	6
	push	eax
	call	_sprintf_s
	lea	edx, DWORD PTR _szBuffer$[ebp]
	add	esp, 16					; 00000010H
$LN16@WspiapiLeg:
	mov	ecx, edx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv228[ebp], eax
	npad	2
$LL34@WspiapiLeg:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL34@WspiapiLeg
	sub	ecx, DWORD PTR tv228[ebp]
	cmp	edi, ecx
	jbe	$LN5@WspiapiLeg

; 802  :             _WSPIAPI_STRCPY_S(pszServiceName, tServiceLength, pszService);

	push	edx
	push	edi
	push	DWORD PTR _pszServiceName$[ebp]
	call	DWORD PTR __imp__strcpy_s
	mov	ecx, DWORD PTR _tNodeLength$[ebp]
	add	esp, 12					; 0000000cH
$LN18@WspiapiLeg:

; 803  :         else
; 804  :             return EAI_FAIL;
; 805  :     }
; 806  : 
; 807  :     
; 808  :     // translate the address to a node name (if requested).
; 809  :     if (pszNodeName && tNodeLength)

	mov	edi, DWORD PTR _pszNodeName$[ebp]
	test	edi, edi
	je	$LN32@WspiapiLeg
	test	ecx, ecx
	je	$LN32@WspiapiLeg

; 810  :     {    
; 811  :         // this is the IPv4-only version, so we have an IPv4 address.
; 812  :         tAddress = ((struct sockaddr_in *) ptSocketAddress)->sin_addr;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _tAddress$[ebp], eax

; 813  : 
; 814  :         if (iFlags & NI_NUMERICHOST)

	test	bl, 2
	je	SHORT $LN20@WspiapiLeg

; 815  :         {
; 816  :             // return numeric form of the address.
; 817  : #pragma warning(suppress: 4996)
; 818  :             pszNode  = inet_ntoa(tAddress);

	push	eax

; 819  :         }

	jmp	SHORT $LN37@WspiapiLeg
$LN20@WspiapiLeg:

; 820  :         else
; 821  :         {
; 822  :             // return node name corresponding to address.
; 823  : #pragma warning(suppress: 4996 38026)
; 824  :             ptHost = gethostbyaddr((char *) &tAddress, sizeof(struct in_addr), AF_INET);

	push	2
	push	4
	lea	eax, DWORD PTR _tAddress$[ebp]
	push	eax
	call	DWORD PTR __imp__gethostbyaddr@12

; 825  :             if (ptHost && ptHost->h_name)

	test	eax, eax
	je	SHORT $LN22@WspiapiLeg
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN22@WspiapiLeg

; 826  :             {
; 827  :                 // DNS lookup successful.
; 828  :                 // stop copying at a "." if NI_NOFQDN is specified.
; 829  :                 pszNode = ptHost->h_name;
; 830  :                 if ((iFlags & NI_NOFQDN) &&

	test	bl, 1
	je	SHORT $LN26@WspiapiLeg
	push	46					; 0000002eH
	push	esi
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@WspiapiLeg

; 831  :                     ((pc = strchr(pszNode, '.')) != NULL))
; 832  :                     *pc = '\0';

	mov	BYTE PTR [eax], 0

; 833  :             }

	jmp	SHORT $LN26@WspiapiLeg
$LN22@WspiapiLeg:

; 834  :             else
; 835  :             {
; 836  :                 // DNS lookup failed.  return numeric form of the address.
; 837  :                 if (iFlags & NI_NAMEREQD)

	test	bl, 4
	je	SHORT $LN25@WspiapiLeg

; 838  :                 {
; 839  :                     switch (WSAGetLastError())

	call	DWORD PTR __imp__WSAGetLastError@0
	sub	eax, 11001				; 00002af9H
	je	SHORT $LN10@WspiapiLeg
	sub	eax, 1
	je	SHORT $LN28@WspiapiLeg
	sub	eax, 1
	je	SHORT $LN5@WspiapiLeg
$LN10@WspiapiLeg:
	pop	edi

; 855  :         else
; 856  :             return EAI_FAIL;
; 857  :     }
; 858  : 
; 859  :     return 0;
; 860  : }

	pop	esi
	mov	eax, 11001				; 00002af9H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN28@WspiapiLeg:
	pop	edi
	pop	esi
	mov	eax, 11002				; 00002afaH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN25@WspiapiLeg:

; 840  :                     {
; 841  :                         case WSAHOST_NOT_FOUND: return EAI_NONAME;
; 842  :                         case WSATRY_AGAIN:      return EAI_AGAIN;
; 843  :                         case WSANO_RECOVERY:    return EAI_FAIL;
; 844  :                         default:                return EAI_NONAME;
; 845  :                     }
; 846  :                 }
; 847  :                 else
; 848  : #pragma warning(suppress: 4996)
; 849  :                     pszNode  = inet_ntoa(tAddress);

	push	DWORD PTR _tAddress$[ebp]
$LN37@WspiapiLeg:

; 850  :             }
; 851  :         }
; 852  : 
; 853  :         if (tNodeLength > strlen(pszNode))

	call	DWORD PTR __imp__inet_ntoa@4
	mov	esi, eax
$LN26@WspiapiLeg:
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
	npad	3
$LL35@WspiapiLeg:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL35@WspiapiLeg
	mov	eax, DWORD PTR _tNodeLength$[ebp]
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN5@WspiapiLeg

; 854  :             _WSPIAPI_STRCPY_S(pszNodeName, tNodeLength, pszNode);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
$LN32@WspiapiLeg:

; 855  :         else
; 856  :             return EAI_FAIL;
; 857  :     }
; 858  : 
; 859  :     return 0;
; 860  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN5@WspiapiLeg:
	pop	edi
	pop	esi
	mov	eax, 11003				; 00002afbH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_WspiapiLegacyGetNameInfo@28 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyGetAddrInfo@16
_TEXT	SEGMENT
_pc$ = -24						; size = 4
_iProtocol$1$ = -20					; size = 4
_wUdpPort$1$ = -16					; size = 4
_bClone$1$ = -12					; size = 4
_iFlags$1$ = -8						; size = 4
_wPort$1$ = -4						; size = 4
_dwAddress$1$ = 8					; size = 4
_pszNodeName$ = 8					; size = 4
_iProtocol$1$ = 12					; size = 4
_pszServiceName$ = 12					; size = 4
tv575 = 16						; size = 4
_ptHints$ = 16						; size = 4
_pptResult$ = 20					; size = 4
_WspiapiLegacyGetAddrInfo@16 PROC			; COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _pptResult$[ebp]
	xor	ebx, ebx
	mov	edi, DWORD PTR _pszNodeName$[ebp]
	xor	esi, esi
	mov	edx, DWORD PTR _pszServiceName$[ebp]
	mov	DWORD PTR _iFlags$1$[ebp], esi
	mov	DWORD PTR _iProtocol$1$[ebp], ebx
	mov	DWORD PTR _wPort$1$[ebp], ebx
	mov	DWORD PTR _pc$[ebp], ebx
	mov	DWORD PTR _bClone$1$[ebp], ebx
	mov	DWORD PTR _wUdpPort$1$[ebp], ebx
	mov	DWORD PTR [eax], ebx
	test	edi, edi
	jne	SHORT $LN2@WspiapiLeg

; 512  :     int                 iError      = 0;
; 513  :     int                 iFlags      = 0;
; 514  :     int                 iFamily     = PF_UNSPEC;
; 515  :     int                 iSocketType = 0;
; 516  :     int                 iProtocol   = 0;
; 517  :     WORD                wPort       = 0;
; 518  :     DWORD               dwAddress   = 0;
; 519  : 
; 520  :     struct servent      *ptService  = NULL;
; 521  :     char                *pc         = NULL;
; 522  :     BOOL                bClone      = FALSE;
; 523  :     WORD                wTcpPort    = 0;
; 524  :     WORD                wUdpPort    = 0;
; 525  :     
; 526  :     
; 527  :     // initialize pptResult with default return value.
; 528  :     *pptResult  = NULL;
; 529  : 
; 530  : 
; 531  :     ////////////////////////////////////////
; 532  :     // validate arguments...
; 533  :     //
; 534  :     
; 535  :     // both the node name and the service name can't be NULL.
; 536  :     if ((!pszNodeName) && (!pszServiceName))

	test	edx, edx
	jne	SHORT $LN2@WspiapiLeg

; 701  : }

	pop	edi
	pop	esi
	mov	eax, 11001				; 00002af9H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@WspiapiLeg:

; 537  :         return EAI_NONAME;
; 538  : 
; 539  :     // validate hints.
; 540  :     if (ptHints)

	mov	eax, DWORD PTR _ptHints$[ebp]
	test	eax, eax
	je	$LN3@WspiapiLeg

; 541  :     {
; 542  :         // all members other than ai_flags, ai_family, ai_socktype
; 543  :         // and ai_protocol must be zero or a null pointer.
; 544  :         if ((ptHints->ai_addrlen    != 0)       ||
; 545  :             (ptHints->ai_canonname  != NULL)    ||
; 546  :             (ptHints->ai_addr       != NULL)    ||

	cmp	DWORD PTR [eax+16], ebx
	jne	$LN5@WspiapiLeg
	cmp	DWORD PTR [eax+20], ebx
	jne	$LN5@WspiapiLeg
	cmp	DWORD PTR [eax+24], ebx
	jne	$LN5@WspiapiLeg
	cmp	DWORD PTR [eax+28], ebx
	jne	$LN5@WspiapiLeg

; 547  :             (ptHints->ai_next       != NULL))
; 548  :         {
; 549  :             return EAI_FAIL;
; 550  :         }
; 551  :         
; 552  :         // the spec has the "bad flags" error code, so presumably we
; 553  :         // should check something here.  insisting that there aren't
; 554  :         // any unspecified flags set would break forward compatibility,
; 555  :         // however.  so we just check for non-sensical combinations.
; 556  :         //
; 557  :         // we cannot come up with a canonical name given a null node name.
; 558  :         iFlags      = ptHints->ai_flags;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iFlags$1$[ebp], ecx

; 559  :         if ((iFlags & AI_CANONNAME) && !pszNodeName)

	test	cl, 2
	je	SHORT $LN6@WspiapiLeg
	test	edi, edi
	jne	SHORT $LN6@WspiapiLeg

; 701  : }

	pop	edi
	pop	esi
	mov	eax, 10022				; 00002726H
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@WspiapiLeg:

; 560  :             return EAI_BADFLAGS;
; 561  : 
; 562  :         // we only support a limited number of protocol families.
; 563  :         iFamily     = ptHints->ai_family;

	mov	ecx, DWORD PTR [eax+4]

; 564  :         if ((iFamily != PF_UNSPEC) && (iFamily != PF_INET))

	test	ecx, ecx
	je	SHORT $LN7@WspiapiLeg
	cmp	ecx, 2
	je	SHORT $LN7@WspiapiLeg

; 701  : }

	pop	edi
	pop	esi
	mov	eax, 10047				; 0000273fH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN7@WspiapiLeg:

; 565  :             return EAI_FAMILY;
; 566  : 
; 567  :         // we only support only these socket types.
; 568  :         iSocketType = ptHints->ai_socktype;

	mov	ebx, DWORD PTR [eax+8]

; 569  :         if ((iSocketType != 0)                  &&
; 570  :             (iSocketType != SOCK_STREAM)        &&
; 571  :             (iSocketType != SOCK_DGRAM)         &&

	test	ebx, ebx
	je	SHORT $LN8@WspiapiLeg
	cmp	ebx, 1
	je	SHORT $LN8@WspiapiLeg
	cmp	ebx, 2
	je	SHORT $LN8@WspiapiLeg
	cmp	ebx, 3
	je	SHORT $LN8@WspiapiLeg

; 701  : }

	pop	edi
	pop	esi
	mov	eax, 10044				; 0000273cH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN8@WspiapiLeg:

; 572  :             (iSocketType != SOCK_RAW))
; 573  :             return EAI_SOCKTYPE;
; 574  : 
; 575  :         // REVIEW: What if ai_socktype and ai_protocol are at odds?
; 576  :         iProtocol   = ptHints->ai_protocol;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _iProtocol$1$[ebp], eax
$LN3@WspiapiLeg:

; 577  :     }
; 578  : 
; 579  : 
; 580  :     ////////////////////////////////////////
; 581  :     // do service lookup...
; 582  : 
; 583  :     if (pszServiceName)

	mov	DWORD PTR tv575[ebp], ebx
	test	edx, edx
	je	$LN35@WspiapiLeg

; 584  :     {
; 585  :         wPort = (WORD) strtoul(pszServiceName, &pc, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _pc$[ebp]
	push	eax
	push	edx
	call	DWORD PTR __imp__strtoul
	movzx	ecx, ax
	add	esp, 12					; 0000000cH

; 586  :         if (*pc == '\0')        // numeric port string

	mov	eax, DWORD PTR _pc$[ebp]
	mov	DWORD PTR _wPort$1$[ebp], ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN10@WspiapiLeg

; 587  :         {
; 588  :             wPort = wTcpPort = wUdpPort = htons(wPort);

	push	ecx
	call	DWORD PTR __imp__htons@4
	movzx	eax, ax

; 589  :             if (iSocketType == 0)

	test	ebx, ebx
	mov	DWORD PTR _wUdpPort$1$[ebp], eax
	movzx	eax, ax
	mov	DWORD PTR _wPort$1$[ebp], eax
	mov	eax, 1
	cmove	ebx, eax

; 590  :             {
; 591  :                 bClone      = TRUE;
; 592  :                 iSocketType = SOCK_STREAM;
; 593  :             }
; 594  :         }

	xor	eax, eax
	cmp	DWORD PTR tv575[ebp], eax
	sete	al
	mov	DWORD PTR _bClone$1$[ebp], eax
	jmp	$LN35@WspiapiLeg
$LN5@WspiapiLeg:
	pop	edi

; 701  : }

	pop	esi
	mov	eax, 11003				; 00002afbH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN10@WspiapiLeg:

; 595  :         else                    // non numeric port string
; 596  :         {
; 597  :             if ((iSocketType == 0) || (iSocketType == SOCK_DGRAM))

	mov	eax, DWORD PTR __imp__getservbyname@8
	test	ebx, ebx
	je	SHORT $LN14@WspiapiLeg
	cmp	ebx, 2
	jne	SHORT $LN15@WspiapiLeg
$LN14@WspiapiLeg:

; 598  :             {
; 599  :                 ptService = getservbyname(pszServiceName, "udp");

	push	OFFSET ??_C@_03OCLLGKEH@udp@
	push	DWORD PTR _pszServiceName$[ebp]
	call	eax

; 600  :                 if (ptService)

	test	eax, eax
	je	SHORT $LN73@WspiapiLeg

; 601  :                     wPort = wUdpPort = ptService->s_port;

	movzx	eax, WORD PTR [eax+8]
	mov	DWORD PTR _wUdpPort$1$[ebp], eax
	movzx	eax, ax
	mov	DWORD PTR _wPort$1$[ebp], eax
$LN73@WspiapiLeg:

; 602  :             }
; 603  : 
; 604  :             if ((iSocketType == 0) || (iSocketType == SOCK_STREAM))

	mov	eax, DWORD PTR __imp__getservbyname@8
$LN15@WspiapiLeg:
	test	ebx, ebx
	je	SHORT $LN17@WspiapiLeg
	cmp	ebx, 1
	jne	SHORT $LN75@WspiapiLeg
$LN17@WspiapiLeg:

; 605  :             {
; 606  :                 ptService = getservbyname(pszServiceName, "tcp");

	push	OFFSET ??_C@_03FPEIBLKH@tcp@
	push	DWORD PTR _pszServiceName$[ebp]
	call	eax

; 607  :                 if (ptService)

	test	eax, eax
	je	SHORT $LN75@WspiapiLeg

; 608  :                     wPort = wTcpPort = ptService->s_port;

	movzx	eax, WORD PTR [eax+8]
	mov	ecx, eax
	mov	DWORD PTR _wPort$1$[ebp], ecx
	jmp	SHORT $LN18@WspiapiLeg
$LN75@WspiapiLeg:

; 609  :             }
; 610  :             
; 611  :             // assumes 0 is an invalid service port...
; 612  :             if (wPort == 0)     // no service exists

	mov	ecx, DWORD PTR _wPort$1$[ebp]
	xor	eax, eax
$LN18@WspiapiLeg:
	test	cx, cx
	jne	SHORT $LN19@WspiapiLeg

; 613  :                 return (iSocketType ? EAI_SERVICE : EAI_NONAME);

	pop	edi
	test	ebx, ebx
	mov	eax, 11001				; 00002af9H
	mov	ecx, 10109				; 0000277dH

; 701  : }

	pop	esi
	cmovne	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN19@WspiapiLeg:

; 614  : 
; 615  :             if (iSocketType == 0)

	test	ebx, ebx
	jne	SHORT $LN35@WspiapiLeg

; 616  :             {
; 617  :                 // if both tcp and udp, process tcp now & clone udp later.
; 618  :                 iSocketType = (wTcpPort) ? SOCK_STREAM : SOCK_DGRAM;

	test	ax, ax
	sete	bl
	inc	ebx

; 619  :                 bClone      = (wTcpPort && wUdpPort); 

	test	ax, ax
	je	SHORT $LN34@WspiapiLeg
	mov	DWORD PTR _bClone$1$[ebp], 1
	cmp	WORD PTR _wUdpPort$1$[ebp], si
	jne	SHORT $LN35@WspiapiLeg
$LN34@WspiapiLeg:
	mov	DWORD PTR _bClone$1$[ebp], esi
$LN35@WspiapiLeg:

; 620  :             }
; 621  :         }
; 622  :     }
; 623  :     
; 624  : 
; 625  : 
; 626  :     ////////////////////////////////////////
; 627  :     // do node name lookup...
; 628  : 
; 629  :     // if we weren't given a node name,
; 630  :     // return the wildcard or loopback address (depending on AI_PASSIVE).
; 631  :     //
; 632  :     // if we have a numeric host address string,
; 633  :     // return the binary address.
; 634  :     //
; 635  :     if ((!pszNodeName) || (WspiapiParseV4Address(pszNodeName, &dwAddress)))

	test	edi, edi
	je	$LN65@WspiapiLeg

; 163  :     for (pcNext = pszAddress; *pcNext != '\0'; pcNext++)

	mov	ecx, edi
	xor	edx, edx
	mov	cl, BYTE PTR [ecx]
	test	cl, cl
	je	SHORT $LN70@WspiapiLeg
$LL39@WspiapiLeg:
	cmp	cl, 46					; 0000002eH
	lea	eax, DWORD PTR [edx+1]
	mov	cl, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	cmovne	eax, edx
	mov	edx, eax
	test	cl, cl
	jne	SHORT $LL39@WspiapiLeg

; 164  :         if (*pcNext == '.')
; 165  :             iCount++;
; 166  :     if (iCount != 3)

	cmp	edx, 3
	jne	SHORT $LN70@WspiapiLeg

; 167  :         return FALSE;
; 168  : 
; 169  :     // return an error if dwAddress is INADDR_NONE (255.255.255.255)
; 170  :     // since this is never a valid argument to getaddrinfo.
; 171  : #pragma warning(suppress: 4996)
; 172  :     dwAddress = inet_addr(pszAddress);

	push	DWORD PTR _pszNodeName$[ebp]
	call	DWORD PTR __imp__inet_addr@4
	mov	edi, eax

; 173  :     if (dwAddress == INADDR_NONE)

	cmp	edi, -1
	jne	$LN24@WspiapiLeg
$LN70@WspiapiLeg:

; 664  :             }
; 665  :         }
; 666  :     }
; 667  : 
; 668  : 
; 669  :     // if we do not have a numeric host address string and
; 670  :     // AI_NUMERICHOST flag is set, return an error!
; 671  :     else if (iFlags & AI_NUMERICHOST)

	mov	eax, DWORD PTR _iFlags$1$[ebp]
	test	al, 4
	je	SHORT $LN29@WspiapiLeg

; 672  :     {
; 673  :         iError = EAI_NONAME;

	mov	esi, 11001				; 00002af9H
$LN72@WspiapiLeg:

; 690  :     {
; 691  :         iError = WspiapiClone(wUdpPort, *pptResult);
; 692  :     }
; 693  : 
; 694  :     if (iError)
; 695  :     {
; 696  :         WspiapiLegacyFreeAddrInfo(*pptResult);

	mov	ebx, DWORD PTR _pptResult$[ebp]
$LN64@WspiapiLeg:
	push	DWORD PTR [ebx]
	call	_WspiapiLegacyFreeAddrInfo@4

; 697  :         *pptResult  = NULL;        

	mov	DWORD PTR [ebx], 0
$LN32@WspiapiLeg:

; 698  :     }
; 699  : 
; 700  :     return (iError);

	pop	edi
	mov	eax, esi

; 701  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN29@WspiapiLeg:

; 674  :     }
; 675  :     
; 676  : 
; 677  :     // since we have a non-numeric node name,
; 678  :     // we have to do a regular node name lookup.
; 679  :     else
; 680  :     {
; 681  :         iError = WspiapiLookupNode(pszNodeName,

	push	DWORD PTR _pptResult$[ebp]
	and	eax, 2
	push	eax
	push	DWORD PTR _wPort$1$[ebp]
	push	DWORD PTR _iProtocol$1$[ebp]
	push	ebx
	push	DWORD PTR _pszNodeName$[ebp]
	call	_WspiapiLookupNode@24
	mov	esi, eax

; 682  :                                    iSocketType,
; 683  :                                    iProtocol,
; 684  :                                    wPort,
; 685  :                                    (iFlags & AI_CANONNAME),
; 686  :                                    pptResult);
; 687  :     }
; 688  : 
; 689  :     if (!iError && bClone)

	test	esi, esi
	jne	SHORT $LN72@WspiapiLeg
	mov	ebx, DWORD PTR _pptResult$[ebp]
$LN71@WspiapiLeg:
	cmp	DWORD PTR _bClone$1$[ebp], 0
	je	SHORT $LN32@WspiapiLeg

; 428  :     for (ptNext = ptResult; ptNext != NULL; )

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN49@WspiapiLeg
	mov	ebx, DWORD PTR __imp__calloc
$LL45@WspiapiLeg:

; 429  :     {
; 430  :         // create an addrinfo structure...
; 431  :         ptNew = WspiapiNewAddrInfo(

	mov	eax, DWORD PTR [edi+24]

; 211  :     ptNew       =

	push	32					; 00000020H
	push	1

; 431  :         ptNew = WspiapiNewAddrInfo(

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _dwAddress$1$[ebp], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _iProtocol$1$[ebp], eax

; 211  :     ptNew       =

	call	ebx
	mov	esi, eax
	add	esp, 8

; 212  :         (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
; 213  :     if (!ptNew)

	test	esi, esi
	je	$LN57@WspiapiLeg

; 214  :         return NULL;
; 215  : 
; 216  :     ptAddress   =

	push	16					; 00000010H
	push	1
	call	ebx
	add	esp, 8

; 217  :         (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
; 218  :     if (!ptAddress)

	test	eax, eax
	je	$LN69@WspiapiLeg

; 222  :         return NULL;
; 223  :     }
; 224  :     ptAddress->sin_family       = AF_INET;

	mov	ecx, 2
	mov	WORD PTR [eax], cx

; 225  :     ptAddress->sin_port         = wPort;

	mov	ecx, DWORD PTR _wUdpPort$1$[ebp]
	mov	WORD PTR [eax+2], cx

; 226  :     ptAddress->sin_addr.s_addr  = dwAddress;

	mov	ecx, DWORD PTR _dwAddress$1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 227  :     
; 228  :     // fill in the fields...
; 229  :     ptNew->ai_family            = PF_INET;
; 230  :     ptNew->ai_socktype          = iSocketType;
; 231  :     ptNew->ai_protocol          = iProtocol;

	mov	ecx, DWORD PTR _iProtocol$1$[ebp]
	mov	DWORD PTR [esi+4], 2
	mov	DWORD PTR [esi+8], 2
	mov	DWORD PTR [esi+12], ecx

; 232  :     ptNew->ai_addrlen           = sizeof(struct sockaddr_in);

	mov	DWORD PTR [esi+16], 16			; 00000010H

; 233  :     ptNew->ai_addr              = (struct sockaddr *) ptAddress;

	mov	DWORD PTR [esi+24], eax

; 440  :         ptNew->ai_next  = ptNext->ai_next;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax

; 441  :         ptNext->ai_next = ptNew;

	mov	DWORD PTR [edi+28], esi

; 442  :         ptNext          = ptNew->ai_next;

	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	jne	SHORT $LL45@WspiapiLeg
$LN49@WspiapiLeg:

; 447  :     
; 448  :     return 0;

	xor	esi, esi
	pop	edi

; 698  :     }
; 699  : 
; 700  :     return (iError);

	mov	eax, esi

; 701  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN65@WspiapiLeg:

; 636  :     {
; 637  :         if (!pszNodeName)
; 638  :         {
; 639  :             dwAddress = htonl((iFlags & AI_PASSIVE)

	test	BYTE PTR _iFlags$1$[ebp], 1
	mov	ecx, esi
	mov	eax, 2130706433				; 7f000001H
	cmovne	eax, ecx
	push	eax
	call	DWORD PTR __imp__htonl@4
	mov	edi, eax
$LN24@WspiapiLeg:

; 640  :                               ? INADDR_ANY
; 641  :                               : INADDR_LOOPBACK);
; 642  :         }
; 643  :         
; 644  :         // create an addrinfo structure...
; 645  :         *pptResult =

	push	edi
	push	DWORD PTR _wPort$1$[ebp]
	push	DWORD PTR _iProtocol$1$[ebp]
	push	ebx
	call	_WspiapiNewAddrInfo@16
	mov	ebx, DWORD PTR _pptResult$[ebp]

; 646  :             WspiapiNewAddrInfo(iSocketType, iProtocol, wPort, dwAddress);
; 647  :         if (!(*pptResult))

	test	eax, eax
	mov	ecx, 8
	cmove	esi, ecx
	mov	DWORD PTR [ebx], eax

; 648  :             iError = EAI_MEMORY;
; 649  :         
; 650  :         if (!iError && pszNodeName)

	test	esi, esi
	jne	$LN64@WspiapiLeg
	cmp	DWORD PTR _pszNodeName$[ebp], esi
	je	$LN71@WspiapiLeg

; 651  :         {
; 652  :             // implementation specific behavior: set AI_NUMERICHOST
; 653  :             // to indicate that we got a numeric host address string.
; 654  :             (*pptResult)->ai_flags |= AI_NUMERICHOST;

	or	DWORD PTR [eax], 4

; 655  :             
; 656  :             // return the numeric address string as the canonical name
; 657  :             if (iFlags & AI_CANONNAME)

	test	BYTE PTR _iFlags$1$[ebp], 2
	je	$LN71@WspiapiLeg

; 658  :             {
; 659  :                 (*pptResult)->ai_canonname =

	push	edi
	call	DWORD PTR __imp__inet_ntoa@4
	push	eax
	call	_WspiapiStrdup@4
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+20], eax

; 660  : #pragma warning(suppress: 4996)
; 661  :                     WspiapiStrdup(inet_ntoa(*((struct in_addr *) &dwAddress)));
; 662  :                 if (!(*pptResult)->ai_canonname)        

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+20], esi
	jne	$LN71@WspiapiLeg

; 663  :                     iError = EAI_MEMORY;

	mov	esi, 8

; 682  :                                    iSocketType,
; 683  :                                    iProtocol,
; 684  :                                    wPort,
; 685  :                                    (iFlags & AI_CANONNAME),
; 686  :                                    pptResult);
; 687  :     }
; 688  : 
; 689  :     if (!iError && bClone)

	jmp	$LN64@WspiapiLeg
$LN69@WspiapiLeg:

; 221  :         WspiapiFree(ptNew);

	push	esi
	call	DWORD PTR __imp__free
	add	esp, 4
$LN57@WspiapiLeg:

; 446  :         return EAI_MEMORY;

	mov	esi, 8
	jmp	$LN72@WspiapiLeg
_WspiapiLegacyGetAddrInfo@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLegacyFreeAddrInfo@4
_TEXT	SEGMENT
_ptHead$ = 8						; size = 4
_WspiapiLegacyFreeAddrInfo@4 PROC			; COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ptHead$[ebp]
	mov	ebx, esi
	test	esi, esi
	je	SHORT $LN3@WspiapiLeg
	push	edi
	mov	edi, DWORD PTR __imp__free
	npad	1
$LL4@WspiapiLeg:

; 469  :     struct addrinfo *ptNext;    // next strcture to free
; 470  : 
; 471  :     for (ptNext = ptHead; ptNext != NULL; ptNext = ptHead)
; 472  :     {
; 473  :         if (ptNext->ai_canonname)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN5@WspiapiLeg

; 474  :             WspiapiFree(ptNext->ai_canonname);

	push	eax
	call	edi
	add	esp, 4
$LN5@WspiapiLeg:

; 475  :         
; 476  :         if (ptNext->ai_addr)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@WspiapiLeg

; 477  :             WspiapiFree(ptNext->ai_addr);

	push	eax
	call	edi
	add	esp, 4
$LN6@WspiapiLeg:

; 478  : 
; 479  :         ptHead = ptNext->ai_next;

	mov	esi, DWORD PTR [esi+28]

; 480  :         WspiapiFree(ptNext);

	push	ebx
	call	edi
	add	esp, 4
	mov	ebx, esi
	test	esi, esi
	jne	SHORT $LL4@WspiapiLeg
	pop	edi
$LN3@WspiapiLeg:
	pop	esi

; 481  :     }
; 482  : }

	pop	ebx
	pop	ebp
	ret	4
_WspiapiLegacyFreeAddrInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiClone@8
_TEXT	SEGMENT
_iProtocol$1$ = -4					; size = 4
_wPort$ = 8						; size = 2
_dwAddress$1$ = 12					; size = 4
_ptResult$ = 12						; size = 4
_WspiapiClone@8 PROC					; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ptResult$[ebp]
	test	edi, edi
	je	SHORT $LN6@WspiapiClo
	mov	ebx, DWORD PTR __imp__calloc
	npad	2
$LL2@WspiapiClo:

; 425  :     struct addrinfo *ptNext = NULL;
; 426  :     struct addrinfo *ptNew  = NULL;
; 427  : 
; 428  :     for (ptNext = ptResult; ptNext != NULL; )
; 429  :     {
; 430  :         // create an addrinfo structure...
; 431  :         ptNew = WspiapiNewAddrInfo(

	mov	eax, DWORD PTR [edi+24]

; 211  :     ptNew       =

	push	32					; 00000020H
	push	1

; 425  :     struct addrinfo *ptNext = NULL;
; 426  :     struct addrinfo *ptNew  = NULL;
; 427  : 
; 428  :     for (ptNext = ptResult; ptNext != NULL; )
; 429  :     {
; 430  :         // create an addrinfo structure...
; 431  :         ptNew = WspiapiNewAddrInfo(

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _dwAddress$1$[ebp], eax
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _iProtocol$1$[ebp], eax

; 211  :     ptNew       =

	call	ebx
	mov	esi, eax
	add	esp, 8

; 212  :         (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
; 213  :     if (!ptNew)

	test	esi, esi
	je	SHORT $LN13@WspiapiClo

; 214  :         return NULL;
; 215  : 
; 216  :     ptAddress   =

	push	16					; 00000010H
	push	1
	call	ebx
	add	esp, 8

; 217  :         (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
; 218  :     if (!ptAddress)

	test	eax, eax
	je	SHORT $LN19@WspiapiClo

; 222  :         return NULL;
; 223  :     }
; 224  :     ptAddress->sin_family       = AF_INET;

	mov	ecx, 2
	mov	WORD PTR [eax], cx

; 225  :     ptAddress->sin_port         = wPort;

	mov	cx, WORD PTR _wPort$[ebp]
	mov	WORD PTR [eax+2], cx

; 226  :     ptAddress->sin_addr.s_addr  = dwAddress;

	mov	ecx, DWORD PTR _dwAddress$1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 227  :     
; 228  :     // fill in the fields...
; 229  :     ptNew->ai_family            = PF_INET;
; 230  :     ptNew->ai_socktype          = iSocketType;
; 231  :     ptNew->ai_protocol          = iProtocol;

	mov	ecx, DWORD PTR _iProtocol$1$[ebp]
	mov	DWORD PTR [esi+4], 2
	mov	DWORD PTR [esi+8], 2
	mov	DWORD PTR [esi+12], ecx

; 232  :     ptNew->ai_addrlen           = sizeof(struct sockaddr_in);

	mov	DWORD PTR [esi+16], 16			; 00000010H

; 233  :     ptNew->ai_addr              = (struct sockaddr *) ptAddress;

	mov	DWORD PTR [esi+24], eax

; 432  :             SOCK_DGRAM,
; 433  :             ptNext->ai_protocol,
; 434  :             wPort,
; 435  :             ((struct sockaddr_in *) ptNext->ai_addr)->sin_addr.s_addr);
; 436  :         if (!ptNew)
; 437  :             break;
; 438  : 
; 439  :         // link the cloned addrinfo
; 440  :         ptNew->ai_next  = ptNext->ai_next;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax

; 441  :         ptNext->ai_next = ptNew;

	mov	DWORD PTR [edi+28], esi

; 442  :         ptNext          = ptNew->ai_next;

	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	jne	SHORT $LL2@WspiapiClo
$LN6@WspiapiClo:
	pop	edi

; 443  :     }
; 444  : 
; 445  :     if (ptNext != NULL)
; 446  :         return EAI_MEMORY;
; 447  :     
; 448  :     return 0;
; 449  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN19@WspiapiClo:

; 221  :         WspiapiFree(ptNew);

	push	esi
	call	DWORD PTR __imp__free
	add	esp, 4
$LN13@WspiapiClo:
	pop	edi

; 443  :     }
; 444  : 
; 445  :     if (ptNext != NULL)
; 446  :         return EAI_MEMORY;
; 447  :     
; 448  :     return 0;
; 449  : }

	pop	esi
	mov	eax, 8
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_WspiapiClone@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiLookupNode@24
_TEXT	SEGMENT
_szFQDN2$ = -2068					; size = 1025
_szFQDN1$ = -1040					; size = 1025
_pszName$1$ = -12					; size = 4
_iAliasCount$1$ = -8					; size = 4
tv228 = -4						; size = 4
_pszAlias$1$ = -4					; size = 4
_pszNodeName$ = 8					; size = 4
_iSocketType$ = 12					; size = 4
_iProtocol$ = 16					; size = 4
_wPort$ = 20						; size = 2
_bAI_CANONNAME$ = 24					; size = 4
_pptResult$ = 28					; size = 4
_WspiapiLookupNode@24 PROC				; COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2068				; 00000814H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	push	1025					; 00000401H
	lea	eax, DWORD PTR _szFQDN1$[ebp]
	mov	DWORD PTR _iAliasCount$1$[ebp], 0
	push	0
	push	eax
	call	_memset
	push	1025					; 00000401H
	lea	eax, DWORD PTR _szFQDN2$[ebp]
	push	0
	push	eax
	call	_memset
	mov	ebx, DWORD PTR _pszNodeName$[ebp]
	lea	eax, DWORD PTR _szFQDN1$[ebp]
	push	1024					; 00000400H
	push	ebx
	push	1025					; 00000401H
	lea	esi, DWORD PTR _szFQDN2$[ebp]
	mov	DWORD PTR _pszName$1$[ebp], eax
	push	eax
	mov	DWORD PTR _pszAlias$1$[ebp], esi
	call	DWORD PTR __imp__strncpy_s
	add	esp, 40					; 00000028H
	npad	3
$LL2@WspiapiLoo:

; 270  :     struct addrinfo **pptNext   = pptResult;

	mov	eax, DWORD PTR _pptResult$[ebp]
	mov	edi, eax

; 271  :     struct hostent  *ptHost     = NULL;
; 272  :     char            **ppAddresses;
; 273  : 
; 274  :     *pptNext    = NULL;
; 275  :     pszAlias[0] = '\0';
; 276  : 
; 277  : #pragma warning(suppress: 4996 38026)
; 278  :     ptHost = gethostbyname(pszNodeName);

	push	ebx
	mov	BYTE PTR [esi], 0
	mov	DWORD PTR [eax], 0
	call	DWORD PTR __imp__gethostbyname@4
	mov	ebx, eax

; 279  :     if (ptHost)

	test	ebx, ebx
	je	$LN18@WspiapiLoo

; 280  :     {
; 281  :         if ((ptHost->h_addrtype == AF_INET)     &&

	cmp	WORD PTR [ebx+8], 2
	jne	SHORT $LN14@WspiapiLoo
	cmp	WORD PTR [ebx+10], 4
	jne	SHORT $LN14@WspiapiLoo

; 282  :             (ptHost->h_length   == sizeof(struct in_addr)))
; 283  :         {
; 284  :             for (ppAddresses    = ptHost->h_addr_list;

	mov	esi, DWORD PTR [ebx+12]

; 285  :                  *ppAddresses   != NULL;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@WspiapiLoo
$LL15@WspiapiLoo:

; 286  :                  ppAddresses++)
; 287  :             {
; 288  :                 // create an addrinfo structure...
; 289  :                 *pptNext = WspiapiNewAddrInfo(

	push	DWORD PTR [eax]
	push	DWORD PTR _wPort$[ebp]
	push	DWORD PTR _iProtocol$[ebp]
	push	DWORD PTR _iSocketType$[ebp]
	call	_WspiapiNewAddrInfo@16
	mov	DWORD PTR [edi], eax

; 290  :                     iSocketType,
; 291  :                     iProtocol,
; 292  :                     wPort,
; 293  :                     ((struct in_addr *) *ppAddresses)->s_addr);
; 294  :                 if (!*pptNext)

	test	eax, eax
	je	$LN29@WspiapiLoo

; 296  : 
; 297  :                 pptNext = &((*pptNext)->ai_next);

	add	esi, 4
	lea	edi, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LL15@WspiapiLoo
$LN14@WspiapiLoo:

; 298  :             }
; 299  :         }
; 300  : 
; 301  :         // pick up the canonical name.
; 302  :         _WSPIAPI_STRNCPY_S(pszAlias, NI_MAXHOST, ptHost->h_name, NI_MAXHOST - 1);

	push	1024					; 00000400H
	push	DWORD PTR [ebx]
	mov	ebx, DWORD PTR _pszAlias$1$[ebp]
	push	1025					; 00000401H
	push	ebx
	call	DWORD PTR __imp__strncpy_s

; 352  :     int     iError              = 0;
; 353  :     int     iAliasCount         = 0;
; 354  : 
; 355  :     char    szFQDN1[NI_MAXHOST] = "";
; 356  :     char    szFQDN2[NI_MAXHOST] = "";
; 357  :     char    *pszName            = szFQDN1;
; 358  :     char    *pszAlias           = szFQDN2;
; 359  :     char    *pszScratch         = NULL;
; 360  :     _WSPIAPI_STRNCPY_S(pszName, NI_MAXHOST, pszNodeName, NI_MAXHOST - 1);
; 361  :     
; 362  :     for (;;)
; 363  :     {
; 364  :         iError = WspiapiQueryDNS(pszNodeName,
; 365  :                                  iSocketType,
; 366  :                                  iProtocol,
; 367  :                                  wPort,
; 368  :                                  pszAlias,
; 369  :                                  pptResult);
; 370  :         if (iError)
; 371  :             break;
; 372  : 
; 373  :         // if we found addresses, then we are done.
; 374  :         if (*pptResult)

	mov	edi, DWORD PTR _pptResult$[ebp]

; 304  :         return 0;

	xor	esi, esi
	add	esp, 16					; 00000010H

; 352  :     int     iError              = 0;
; 353  :     int     iAliasCount         = 0;
; 354  : 
; 355  :     char    szFQDN1[NI_MAXHOST] = "";
; 356  :     char    szFQDN2[NI_MAXHOST] = "";
; 357  :     char    *pszName            = szFQDN1;
; 358  :     char    *pszAlias           = szFQDN2;
; 359  :     char    *pszScratch         = NULL;
; 360  :     _WSPIAPI_STRNCPY_S(pszName, NI_MAXHOST, pszNodeName, NI_MAXHOST - 1);
; 361  :     
; 362  :     for (;;)
; 363  :     {
; 364  :         iError = WspiapiQueryDNS(pszNodeName,
; 365  :                                  iSocketType,
; 366  :                                  iProtocol,
; 367  :                                  wPort,
; 368  :                                  pszAlias,
; 369  :                                  pptResult);
; 370  :         if (iError)
; 371  :             break;
; 372  : 
; 373  :         // if we found addresses, then we are done.
; 374  :         if (*pptResult)

	cmp	DWORD PTR [edi], esi
	jne	SHORT $LN39@WspiapiLoo

; 375  :             break;
; 376  : 
; 377  :         // stop infinite loops due to DNS misconfiguration.  there appears
; 378  :         // to be no particular recommended limit in RFCs 1034 and 1035.
; 379  :         if ((!strlen(pszAlias))             ||
; 380  :             (!strcmp(pszName, pszAlias))    ||

	mov	ecx, ebx
	lea	edx, DWORD PTR [ecx+1]
$LL40@WspiapiLoo:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL40@WspiapiLoo
	sub	ecx, edx
	je	$LN23@WspiapiLoo
	mov	esi, DWORD PTR _pszName$1$[ebp]
	mov	eax, ebx
	mov	ecx, esi
	npad	7
$LL41@WspiapiLoo:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN42@WspiapiLoo
	test	dl, dl
	je	SHORT $LN43@WspiapiLoo
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN42@WspiapiLoo
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL41@WspiapiLoo
$LN43@WspiapiLoo:
	xor	eax, eax
	jmp	SHORT $LN44@WspiapiLoo
$LN42@WspiapiLoo:
	sbb	eax, eax
	or	eax, 1
$LN44@WspiapiLoo:
	test	eax, eax
	je	SHORT $LN23@WspiapiLoo
	mov	eax, DWORD PTR _iAliasCount$1$[ebp]
	inc	eax
	mov	DWORD PTR _iAliasCount$1$[ebp], eax
	cmp	eax, 16					; 00000010H
	je	SHORT $LN23@WspiapiLoo

; 381  :             (++iAliasCount == 16))
; 382  :         {
; 383  :             iError = EAI_FAIL;
; 384  :             break;
; 385  :         }
; 386  : 
; 387  :         // there was a new CNAME, look again.
; 388  :         WspiapiSwap(pszName, pszAlias, pszScratch);

	mov	DWORD PTR _pszName$1$[ebp], ebx

; 389  :     }

	mov	ebx, DWORD PTR _pszNodeName$[ebp]
	mov	DWORD PTR _pszAlias$1$[ebp], esi
	jmp	$LL2@WspiapiLoo
$LN29@WspiapiLoo:

; 295  :                     return EAI_MEMORY;

	mov	esi, 8

; 395  :             iError = EAI_MEMORY;
; 396  :     }
; 397  : 
; 398  :     return iError;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN39@WspiapiLoo:

; 390  : 
; 391  :     if (!iError && bAI_CANONNAME)

	cmp	DWORD PTR _bAI_CANONNAME$[ebp], esi
	je	SHORT $LN10@WspiapiLoo

; 392  :     {
; 393  :         (*pptResult)->ai_canonname = WspiapiStrdup(pszAlias);

	push	ebx
	call	_WspiapiStrdup@4
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+20], eax

; 394  :         if (!(*pptResult)->ai_canonname)

	mov	ecx, 8
	mov	eax, DWORD PTR [edi]

; 395  :             iError = EAI_MEMORY;
; 396  :     }
; 397  : 
; 398  :     return iError;

	pop	edi
	cmp	DWORD PTR [eax+20], esi
	cmove	esi, ecx
	mov	eax, esi
	pop	esi
	pop	ebx

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN18@WspiapiLoo:

; 307  :     switch (WSAGetLastError())

	call	DWORD PTR __imp__WSAGetLastError@0
	add	eax, -11001				; ffffd507H
	cmp	eax, 3
	ja	SHORT $LN25@WspiapiLoo
	jmp	DWORD PTR $LN46@WspiapiLoo[eax*4]
$LN22@WspiapiLoo:

; 308  :     {
; 309  :         case WSAHOST_NOT_FOUND: return EAI_NONAME;
; 310  :         case WSATRY_AGAIN:      return EAI_AGAIN;

	mov	esi, 11002				; 00002afaH

; 395  :             iError = EAI_MEMORY;
; 396  :     }
; 397  : 
; 398  :     return iError;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN23@WspiapiLoo:

; 395  :             iError = EAI_MEMORY;
; 396  :     }
; 397  : 
; 398  :     return iError;

	mov	esi, 11003				; 00002afbH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN25@WspiapiLoo:

; 395  :             iError = EAI_MEMORY;
; 396  :     }
; 397  : 
; 398  :     return iError;

	mov	esi, 11001				; 00002af9H
$LN10@WspiapiLoo:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN46@WspiapiLoo:
	DD	$LN25@WspiapiLoo
	DD	$LN22@WspiapiLoo
	DD	$LN23@WspiapiLoo
	DD	$LN25@WspiapiLoo
_WspiapiLookupNode@24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiQueryDNS@24
_TEXT	SEGMENT
_pszNodeName$ = 8					; size = 4
_iSocketType$ = 12					; size = 4
_iProtocol$ = 16					; size = 4
_wPort$ = 20						; size = 2
_pszAlias$ = 24						; size = 4
_pptResult$ = 28					; size = 4
_WspiapiQueryDNS@24 PROC				; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _pptResult$[ebp]
	mov	eax, DWORD PTR _pszAlias$[ebp]
	push	DWORD PTR _pszNodeName$[ebp]
	mov	DWORD PTR [ebx], 0
	mov	BYTE PTR [eax], 0
	call	DWORD PTR __imp__gethostbyname@4
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN7@WspiapiQue

; 270  :     struct addrinfo **pptNext   = pptResult;
; 271  :     struct hostent  *ptHost     = NULL;
; 272  :     char            **ppAddresses;
; 273  : 
; 274  :     *pptNext    = NULL;
; 275  :     pszAlias[0] = '\0';
; 276  : 
; 277  : #pragma warning(suppress: 4996 38026)
; 278  :     ptHost = gethostbyname(pszNodeName);
; 279  :     if (ptHost)
; 280  :     {
; 281  :         if ((ptHost->h_addrtype == AF_INET)     &&

	cmp	WORD PTR [edi+8], 2
	push	esi
	jne	SHORT $LN3@WspiapiQue
	cmp	WORD PTR [edi+10], 4
	jne	SHORT $LN3@WspiapiQue

; 282  :             (ptHost->h_length   == sizeof(struct in_addr)))
; 283  :         {
; 284  :             for (ppAddresses    = ptHost->h_addr_list;

	mov	esi, DWORD PTR [edi+12]

; 285  :                  *ppAddresses   != NULL;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@WspiapiQue
$LL4@WspiapiQue:

; 286  :                  ppAddresses++)
; 287  :             {
; 288  :                 // create an addrinfo structure...
; 289  :                 *pptNext = WspiapiNewAddrInfo(

	push	DWORD PTR [eax]
	push	DWORD PTR _wPort$[ebp]
	push	DWORD PTR _iProtocol$[ebp]
	push	DWORD PTR _iSocketType$[ebp]
	call	_WspiapiNewAddrInfo@16
	mov	DWORD PTR [ebx], eax

; 290  :                     iSocketType,
; 291  :                     iProtocol,
; 292  :                     wPort,
; 293  :                     ((struct in_addr *) *ppAddresses)->s_addr);
; 294  :                 if (!*pptNext)

	test	eax, eax
	je	SHORT $LN17@WspiapiQue

; 296  : 
; 297  :                 pptNext = &((*pptNext)->ai_next);

	add	esi, 4
	lea	ebx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LL4@WspiapiQue
$LN3@WspiapiQue:

; 298  :             }
; 299  :         }
; 300  : 
; 301  :         // pick up the canonical name.
; 302  :         _WSPIAPI_STRNCPY_S(pszAlias, NI_MAXHOST, ptHost->h_name, NI_MAXHOST - 1);

	push	1024					; 00000400H
	push	DWORD PTR [edi]
	push	1025					; 00000401H
	push	DWORD PTR _pszAlias$[ebp]
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H

; 303  :         
; 304  :         return 0;

	xor	eax, eax
	pop	esi
	pop	edi

; 314  :     }
; 315  : }

	pop	ebx
	pop	ebp
	ret	24					; 00000018H
$LN17@WspiapiQue:
	pop	esi
	pop	edi

; 295  :                     return EAI_MEMORY;

	mov	eax, 8

; 314  :     }
; 315  : }

	pop	ebx
	pop	ebp
	ret	24					; 00000018H
$LN7@WspiapiQue:

; 305  :     }
; 306  :     
; 307  :     switch (WSAGetLastError())

	call	DWORD PTR __imp__WSAGetLastError@0
	add	eax, -11001				; ffffd507H
	cmp	eax, 3
	ja	SHORT $LN14@WspiapiQue
	jmp	DWORD PTR $LN23@WspiapiQue[eax*4]
$LN11@WspiapiQue:
	pop	edi

; 308  :     {
; 309  :         case WSAHOST_NOT_FOUND: return EAI_NONAME;
; 310  :         case WSATRY_AGAIN:      return EAI_AGAIN;

	mov	eax, 11002				; 00002afaH

; 314  :     }
; 315  : }

	pop	ebx
	pop	ebp
	ret	24					; 00000018H
$LN12@WspiapiQue:
	pop	edi

; 311  :         case WSANO_RECOVERY:    return EAI_FAIL;

	mov	eax, 11003				; 00002afbH

; 314  :     }
; 315  : }

	pop	ebx
	pop	ebp
	ret	24					; 00000018H
$LN14@WspiapiQue:
	pop	edi

; 312  :         case WSANO_DATA:        return EAI_NODATA;
; 313  :         default:                return EAI_NONAME;

	mov	eax, 11001				; 00002af9H

; 314  :     }
; 315  : }

	pop	ebx
	pop	ebp
	ret	24					; 00000018H
$LN23@WspiapiQue:
	DD	$LN14@WspiapiQue
	DD	$LN11@WspiapiQue
	DD	$LN12@WspiapiQue
	DD	$LN14@WspiapiQue
_WspiapiQueryDNS@24 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiNewAddrInfo@16
_TEXT	SEGMENT
_iSocketType$ = 8					; size = 4
_iProtocol$ = 12					; size = 4
_wPort$ = 16						; size = 2
_dwAddress$ = 20					; size = 4
_WspiapiNewAddrInfo@16 PROC				; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	push	1
	call	DWORD PTR __imp__calloc
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN5@WspiapiNew

; 207  :     struct addrinfo     *ptNew;
; 208  :     struct sockaddr_in  *ptAddress;
; 209  : 
; 210  :     // allocate a new addrinfo structure.
; 211  :     ptNew       =
; 212  :         (struct addrinfo *) WspiapiMalloc(sizeof(struct addrinfo));
; 213  :     if (!ptNew)
; 214  :         return NULL;
; 215  : 
; 216  :     ptAddress   =

	push	16					; 00000010H
	push	1
	call	DWORD PTR __imp__calloc
	mov	ecx, eax
	add	esp, 8

; 217  :         (struct sockaddr_in *) WspiapiMalloc(sizeof(struct sockaddr_in));
; 218  :     if (!ptAddress)

	test	ecx, ecx
	jne	SHORT $LN3@WspiapiNew

; 219  :     {
; 220  : #pragma warning(suppress: 6280)
; 221  :         WspiapiFree(ptNew);

	push	esi
	call	DWORD PTR __imp__free
	add	esp, 4
$LN5@WspiapiNew:

; 236  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	16					; 00000010H
$LN3@WspiapiNew:

; 222  :         return NULL;
; 223  :     }
; 224  :     ptAddress->sin_family       = AF_INET;

	mov	eax, 2
	mov	WORD PTR [ecx], ax

; 225  :     ptAddress->sin_port         = wPort;

	mov	ax, WORD PTR _wPort$[ebp]
	mov	WORD PTR [ecx+2], ax

; 226  :     ptAddress->sin_addr.s_addr  = dwAddress;

	mov	eax, DWORD PTR _dwAddress$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 227  :     
; 228  :     // fill in the fields...
; 229  :     ptNew->ai_family            = PF_INET;
; 230  :     ptNew->ai_socktype          = iSocketType;

	mov	eax, DWORD PTR _iSocketType$[ebp]
	mov	DWORD PTR [esi+8], eax

; 231  :     ptNew->ai_protocol          = iProtocol;

	mov	eax, DWORD PTR _iProtocol$[ebp]
	mov	DWORD PTR [esi+12], eax

; 232  :     ptNew->ai_addrlen           = sizeof(struct sockaddr_in);
; 233  :     ptNew->ai_addr              = (struct sockaddr *) ptAddress;
; 234  : 
; 235  :     return ptNew;

	mov	eax, esi
	mov	DWORD PTR [esi+4], 2
	mov	DWORD PTR [esi+16], 16			; 00000010H
	mov	DWORD PTR [esi+24], ecx
	pop	esi

; 236  : }

	pop	ebp
	ret	16					; 00000010H
_WspiapiNewAddrInfo@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiParseV4Address@8
_TEXT	SEGMENT
_pszAddress$ = 8					; size = 4
_pdwAddress$ = 12					; size = 4
_WspiapiParseV4Address@8 PROC				; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pszAddress$[ebp]
	xor	ecx, ecx
	mov	esi, edi
	mov	dl, BYTE PTR [edi]
	test	dl, dl
	je	SHORT $LN14@WspiapiPar
	npad	4
$LL4@WspiapiPar:

; 158  :     DWORD       dwAddress   = 0;
; 159  :     const char  *pcNext     = NULL;
; 160  :     int         iCount      = 0;
; 161  : 
; 162  :     // ensure there are 3 '.' (periods)
; 163  :     for (pcNext = pszAddress; *pcNext != '\0'; pcNext++)

	cmp	dl, 46					; 0000002eH
	lea	eax, DWORD PTR [ecx+1]
	mov	dl, BYTE PTR [esi+1]
	lea	esi, DWORD PTR [esi+1]
	cmovne	eax, ecx
	mov	ecx, eax
	test	dl, dl
	jne	SHORT $LL4@WspiapiPar

; 164  :         if (*pcNext == '.')
; 165  :             iCount++;
; 166  :     if (iCount != 3)

	cmp	ecx, 3
	jne	SHORT $LN14@WspiapiPar

; 167  :         return FALSE;
; 168  : 
; 169  :     // return an error if dwAddress is INADDR_NONE (255.255.255.255)
; 170  :     // since this is never a valid argument to getaddrinfo.
; 171  : #pragma warning(suppress: 4996)
; 172  :     dwAddress = inet_addr(pszAddress);

	push	edi
	call	DWORD PTR __imp__inet_addr@4

; 173  :     if (dwAddress == INADDR_NONE)

	cmp	eax, -1
	je	SHORT $LN14@WspiapiPar

; 175  : 
; 176  :     *pdwAddress = dwAddress;

	mov	ecx, DWORD PTR _pdwAddress$[ebp]
	pop	edi

; 177  :     return TRUE;
; 178  : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, 1
	pop	ebp
	ret	8
$LN14@WspiapiPar:
	pop	edi

; 174  :         return FALSE;

	xor	eax, eax

; 177  :     return TRUE;
; 178  : }

	pop	esi
	pop	ebp
	ret	8
_WspiapiParseV4Address@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\um\wspiapi.h
;	COMDAT _WspiapiStrdup@4
_TEXT	SEGMENT
_pszString$ = 8						; size = 4
_WspiapiStrdup@4 PROC					; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D1B760F5_wspiapi@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _pszString$[ebp]
	test	esi, esi
	je	SHORT $LN5@WspiapiStr

; 120  :     char    *pszMemory;
; 121  :     size_t  cchMemory;
; 122  : 
; 123  :     if (!pszString)
; 124  :         return(NULL);
; 125  : 
; 126  :     cchMemory = strlen(pszString) + 1;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL6@WspiapiStr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@WspiapiStr
	sub	eax, edx
	lea	ebx, DWORD PTR [eax+1]

; 127  :     pszMemory = (char *) WspiapiMalloc(cchMemory);

	push	ebx
	push	1
	call	DWORD PTR __imp__calloc
	mov	edi, eax
	add	esp, 8

; 128  :     if (!pszMemory)

	test	edi, edi
	je	SHORT $LN5@WspiapiStr

; 129  :         return(NULL);
; 130  : 
; 131  :     _WSPIAPI_STRCPY_S(pszMemory, cchMemory, pszString);

	push	esi
	push	ebx
	push	edi
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH

; 132  :     return pszMemory;

	mov	eax, edi
	pop	edi

; 133  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN5@WspiapiStr:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	4
_WspiapiStrdup@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s
	add	esp, 28					; 0000001cH

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);
; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1846 :             __crt_va_end(_ArgList);
; 1847 :             return _Result;

	pop	esi

; 1848 :         }

	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1497 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1498 :         int const _Result = __stdio_common_vsprintf_s(
; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;
; 1503 :     }

	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
