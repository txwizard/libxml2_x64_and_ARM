; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\HTMLtree.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07FJOBMBFC@checked@			; `string'
PUBLIC	??_C@_07HGKHBOGE@compact@			; `string'
PUBLIC	??_C@_07JDFLJJH@declare@			; `string'
PUBLIC	??_C@_05MBNCFBEN@defer@				; `string'
PUBLIC	??_C@_08BEHKFNNO@disabled@			; `string'
PUBLIC	??_C@_05HANCGNOO@ismap@				; `string'
PUBLIC	??_C@_08CKJFGDBG@multiple@			; `string'
PUBLIC	??_C@_06FFHHDLMH@nohref@			; `string'
PUBLIC	??_C@_08BOOCAMGJ@noresize@			; `string'
PUBLIC	??_C@_07NCHIIBII@noshade@			; `string'
PUBLIC	??_C@_06KMFGCGJP@nowrap@			; `string'
PUBLIC	??_C@_08JOKHDEJH@readonly@			; `string'
PUBLIC	??_C@_08CJLOJPNI@selected@			; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__E0C87F61_htmltree@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_08CJLOJPNI@selected@
CONST	SEGMENT
??_C@_08CJLOJPNI@selected@ DB 'selected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOKHDEJH@readonly@
CONST	SEGMENT
??_C@_08JOKHDEJH@readonly@ DB 'readonly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMFGCGJP@nowrap@
CONST	SEGMENT
??_C@_06KMFGCGJP@nowrap@ DB 'nowrap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCHIIBII@noshade@
CONST	SEGMENT
??_C@_07NCHIIBII@noshade@ DB 'noshade', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOOCAMGJ@noresize@
CONST	SEGMENT
??_C@_08BOOCAMGJ@noresize@ DB 'noresize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFHHDLMH@nohref@
CONST	SEGMENT
??_C@_06FFHHDLMH@nohref@ DB 'nohref', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKJFGDBG@multiple@
CONST	SEGMENT
??_C@_08CKJFGDBG@multiple@ DB 'multiple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HANCGNOO@ismap@
CONST	SEGMENT
??_C@_05HANCGNOO@ismap@ DB 'ismap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEHKFNNO@disabled@
CONST	SEGMENT
??_C@_08BEHKFNNO@disabled@ DB 'disabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBNCFBEN@defer@
CONST	SEGMENT
??_C@_05MBNCFBEN@defer@ DB 'defer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDFLJJH@declare@
CONST	SEGMENT
??_C@_07JDFLJJH@declare@ DB 'declare', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HGKHBOGE@compact@
CONST	SEGMENT
??_C@_07HGKHBOGE@compact@ DB 'compact', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJOBMBFC@checked@
CONST	SEGMENT
??_C@_07FJOBMBFC@checked@ DB 'checked', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_htmlGetMetaEncoding
PUBLIC	_htmlSetMetaEncoding
PUBLIC	_htmlDocDumpMemory
PUBLIC	_htmlDocDumpMemoryFormat
PUBLIC	_htmlDocDump
PUBLIC	_htmlSaveFile
PUBLIC	_htmlNodeDump
PUBLIC	_htmlNodeDumpFile
PUBLIC	_htmlNodeDumpFileFormat
PUBLIC	_htmlSaveFileEnc
PUBLIC	_htmlSaveFileFormat
PUBLIC	_htmlNodeDumpFormatOutput
PUBLIC	_htmlDocContentDumpOutput
PUBLIC	_htmlDocContentDumpFormatOutput
PUBLIC	_htmlNodeDumpOutput
PUBLIC	_htmlIsBooleanAttr
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04HLJJCGEF@meta@				; `string'
PUBLIC	??_C@_0L@NALBGOHO@http?9equiv@			; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type@		; `string'
PUBLIC	??_C@_07ICAJMOAO@content@			; `string'
PUBLIC	??_C@_08JPKHBDLJ@charset?$DN@			; `string'
PUBLIC	??_C@_08BNFGJBBK@Charset?$DN@			; `string'
PUBLIC	??_C@_08HFIPAJDM@CHARSET?$DN@			; `string'
PUBLIC	??_C@_09MMDENEKG@charset?5?$DN@			; `string'
PUBLIC	??_C@_09IDGJNHHG@Charset?5?$DN@			; `string'
PUBLIC	??_C@_09FBAMILBD@CHARSET?5?$DN@			; `string'
PUBLIC	??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@ ; `string'
PUBLIC	??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ ; `string'
PUBLIC	??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@	; `string'
PUBLIC	??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@	; `string'
PUBLIC	??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@	; `string'
PUBLIC	??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@ ; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_05OJENGABA@ascii@				; `string'
PUBLIC	??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@		; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BE@LDMALNEE@about?3legacy?9compat@	; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_02NEKEAGPN@?$DO?6@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_06DDLLCOJG@action@			; `string'
PUBLIC	??_C@_03LOJEKLML@src@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_04FFDNBKGC@?$DM?$CB?9?9@			; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@ ; `string'
PUBLIC	??_C@_03EAIBNEDB@?$DN?$CC?$CC@			; `string'
PUBLIC	??_C@_06OLONEIEH@script@			; `string'
PUBLIC	??_C@_05IAKJCFIM@style@				; `string'
PUBLIC	??_C@_02HFBBBACF@?$DM?$DP@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_04IEJGKNJ@body@				; `string'
PUBLIC	??_C@_03PBCCILOI@?$DO?$DM?1@			; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1@			; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrcasestr:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlNewProp:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddPrevSibling:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSetProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlEncodeEntitiesReentrant:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlParseCharEncoding:PROC
EXTRN	_xmlOutputBufferCreateFilename:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlOutputBufferWriteString:PROC
EXTRN	_xmlOutputBufferFlush:PROC
EXTRN	_xmlOutputBufferClose:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_htmlTagLookup:PROC
EXTRN	_xmlURIEscapeStr:PROC
EXTRN	_xmlBufCat:PROC
EXTRN	_xmlBufCCat:PROC
EXTRN	_xmlBufWriteQuotedString:PROC
EXTRN	_xmlBufFromBuffer:PROC
EXTRN	_xmlBufBackToBuffer:PROC
EXTRN	_xmlAllocOutputBufferInternal:PROC
EXTRN	_xmlNsListDumpOutput:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1@ DB '</', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PBCCILOI@?$DO?$DM?1@
CONST	SEGMENT
??_C@_03PBCCILOI@?$DO?$DM?1@ DB '></', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body@
CONST	SEGMENT
??_C@_04IEJGKNJ@body@ DB 'body', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HFBBBACF@?$DM?$DP@
CONST	SEGMENT
??_C@_02HFBBBACF@?$DM?$DP@ DB '<?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAKJCFIM@style@
CONST	SEGMENT
??_C@_05IAKJCFIM@style@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLONEIEH@script@
CONST	SEGMENT
??_C@_06OLONEIEH@script@ DB 'script', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAIBNEDB@?$DN?$CC?$CC@
CONST	SEGMENT
??_C@_03EAIBNEDB@?$DN?$CC?$CC@ DB '=""', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@
CONST	SEGMENT
??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@ DB '@/:=?;#%&,+'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_04FFDNBKGC@?$DM?$CB?9?9@ DB '<!--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOJEKLML@src@
CONST	SEGMENT
??_C@_03LOJEKLML@src@ DB 'src', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLLCOJG@action@
CONST	SEGMENT
??_C@_06DDLLCOJG@action@ DB 'action', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LDMALNEE@about?3legacy?9compat@
CONST	SEGMENT
??_C@_0BE@LDMALNEE@about?3legacy?9compat@ DB 'about:legacy-compat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
CONST	SEGMENT
??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@ DB '<!DOCTYPE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJENGABA@ascii@
CONST	SEGMENT
??_C@_05OJENGABA@ascii@ DB 'ascii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@
CONST	SEGMENT
??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@ DB 'allocating HTML '
	DB	'output buffer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
CONST	SEGMENT
??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@ DB 'unexpected error numb'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@
CONST	SEGMENT
??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@ DB 'HTML has no DOCTYPE', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@ DB 'unknown encoding %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
CONST	SEGMENT
??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@ DB 'invalid character val'
	DB	'ue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
CONST	SEGMENT
??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ DB 'string is not in UT'
	DB	'F-8', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_htmlBooleanAttrs DD FLAT:??_C@_07FJOBMBFC@checked@
	DD	FLAT:??_C@_07HGKHBOGE@compact@
	DD	FLAT:??_C@_07JDFLJJH@declare@
	DD	FLAT:??_C@_05MBNCFBEN@defer@
	DD	FLAT:??_C@_08BEHKFNNO@disabled@
	DD	FLAT:??_C@_05HANCGNOO@ismap@
	DD	FLAT:??_C@_08CKJFGDBG@multiple@
	DD	FLAT:??_C@_06FFHHDLMH@nohref@
	DD	FLAT:??_C@_08BOOCAMGJ@noresize@
	DD	FLAT:??_C@_07NCHIIBII@noshade@
	DD	FLAT:??_C@_06KMFGCGJP@nowrap@
	DD	FLAT:??_C@_08JOKHDEJH@readonly@
	DD	FLAT:??_C@_08CJLOJPNI@selected@
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@
CONST	SEGMENT
??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@ DB 'text/html; charse'
	DB	't=%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBAMILBD@CHARSET?5?$DN@
CONST	SEGMENT
??_C@_09FBAMILBD@CHARSET?5?$DN@ DB 'CHARSET =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDGJNHHG@Charset?5?$DN@
CONST	SEGMENT
??_C@_09IDGJNHHG@Charset?5?$DN@ DB 'Charset =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMDENEKG@charset?5?$DN@
CONST	SEGMENT
??_C@_09MMDENEKG@charset?5?$DN@ DB 'charset =', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFIPAJDM@CHARSET?$DN@
CONST	SEGMENT
??_C@_08HFIPAJDM@CHARSET?$DN@ DB 'CHARSET=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNFGJBBK@Charset?$DN@
CONST	SEGMENT
??_C@_08BNFGJBBK@Charset?$DN@ DB 'Charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPKHBDLJ@charset?$DN@
CONST	SEGMENT
??_C@_08JPKHBDLJ@charset?$DN@ DB 'charset=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICAJMOAO@content@
CONST	SEGMENT
??_C@_07ICAJMOAO@content@ DB 'content', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type@ DB 'Content-Type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NALBGOHO@http?9equiv@
CONST	SEGMENT
??_C@_0L@NALBGOHO@http?9equiv@ DB 'http-equiv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLJJCGEF@meta@
CONST	SEGMENT
??_C@_04HLJJCGEF@meta@ DB 'meta', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeListDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeListDumpOutput PROC				; COMDAT

; 796  : 	               xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@htmlNodeLi
	push	ebx
	mov	ebx, DWORD PTR _encoding$[ebp]
	push	edi
	mov	edi, DWORD PTR _format$[ebp]
	npad	3
$LL2@htmlNodeLi:

; 797  :     if (cur == NULL) {
; 798  : 	return;
; 799  :     }
; 800  :     while (cur != NULL) {
; 801  :         htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_htmlNodeDumpFormatOutput

; 802  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 20					; 00000014H
	test	esi, esi
	jne	SHORT $LL2@htmlNodeLi
	pop	edi
	pop	ebx
$LN3@htmlNodeLi:
	pop	esi

; 803  :     }
; 804  : }

	pop	ebp
	ret	0
_htmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlAttrListDumpOutput
_TEXT	SEGMENT
_value$1$ = -12						; size = 4
_start$1$ = -8						; size = 4
_escaped$1$ = -4					; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlAttrListDumpOutput PROC				; COMDAT

; 772  : htmlAttrListDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN3@htmlAttrLi
	push	esi
	push	edi
$LN50@htmlAttrLi:

; 692  :     xmlOutputBufferWriteString(buf, " ");

	mov	esi, DWORD PTR _buf$[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	esi
	call	_xmlOutputBufferWriteString

; 693  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@htmlAttrLi
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN13@htmlAttrLi

; 694  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	esi
	call	_xmlOutputBufferWriteString

; 695  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN13@htmlAttrLi:

; 696  :     }
; 697  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 698  :     if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {

	cmp	DWORD PTR [ebx+12], 0
	je	$LN16@htmlAttrLi
	push	DWORD PTR [ebx+8]
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	jne	$LN16@htmlAttrLi

; 699  : 	value = xmlNodeListGetString(doc, cur->children, 0);

	push	eax
	push	DWORD PTR [ebx+12]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNodeListGetString
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _value$1$[ebp], edi

; 700  : 	if (value) {

	test	edi, edi
	je	$LN15@htmlAttrLi

; 701  : 	    xmlOutputBufferWriteString(buf, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 702  : 	    if ((cur->ns == NULL) && (cur->parent != NULL) &&
; 703  : 		(cur->parent->ns == NULL) &&

	cmp	DWORD PTR [ebx+36], 0
	jne	$LN17@htmlAttrLi
	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	$LN17@htmlAttrLi
	cmp	DWORD PTR [eax+36], 0
	jne	$LN17@htmlAttrLi
	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	DWORD PTR [ebx+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@htmlAttrLi
	push	OFFSET ??_C@_06DDLLCOJG@action@
	push	DWORD PTR [ebx+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@htmlAttrLi
	push	OFFSET ??_C@_03LOJEKLML@src@
	push	DWORD PTR [ebx+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@htmlAttrLi
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [ebx+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN17@htmlAttrLi
	mov	eax, DWORD PTR [ebx+20]
	push	OFFSET ??_C@_01MCMALHOG@a@
	push	DWORD PTR [eax+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN17@htmlAttrLi
$LN19@htmlAttrLi:

; 704  : 		((!xmlStrcasecmp(cur->name, BAD_CAST "href")) ||
; 705  : 	         (!xmlStrcasecmp(cur->name, BAD_CAST "action")) ||
; 706  : 		 (!xmlStrcasecmp(cur->name, BAD_CAST "src")) ||
; 707  : 		 ((!xmlStrcasecmp(cur->name, BAD_CAST "name")) &&
; 708  : 		  (!xmlStrcasecmp(cur->parent->name, BAD_CAST "a"))))) {
; 709  : 		xmlChar *tmp = value;
; 710  : 		/* xmlURIEscapeStr() escapes '"' so it can be safely used. */
; 711  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [esi+16]
	call	_xmlBufCCat
	add	esp, 8
$LL7@htmlAttrLi:

; 712  : 
; 713  : 		while (IS_BLANK_CH(*tmp)) tmp++;

	mov	al, BYTE PTR [edi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN20@htmlAttrLi
	cmp	al, 9
	jb	SHORT $LN21@htmlAttrLi
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN20@htmlAttrLi
$LN21@htmlAttrLi:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LL9@htmlAttrLi
$LN20@htmlAttrLi:
	inc	edi
	jmp	SHORT $LL7@htmlAttrLi
$LL9@htmlAttrLi:

; 714  : 
; 715  : 		/* URI Escape everything, except server side includes. */
; 716  : 		for ( ; ; ) {
; 717  : 		    xmlChar *escaped;
; 718  : 		    xmlChar endChar;
; 719  : 		    xmlChar *end = NULL;
; 720  : 		    xmlChar *start = (xmlChar *)xmlStrstr(tmp, BAD_CAST "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	edi
	xor	esi, esi
	call	_xmlStrstr
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _start$1$[ebp], ebx

; 721  : 		    if (start != NULL) {

	test	ebx, ebx
	je	SHORT $LN23@htmlAttrLi

; 722  : 			end = (xmlChar *)xmlStrstr(tmp, BAD_CAST "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	edi
	call	_xmlStrstr
	mov	esi, eax
	add	esp, 8

; 723  : 			if (end != NULL) {

	test	esi, esi
	je	SHORT $LN23@htmlAttrLi

; 724  : 			    *start = '\0';

	mov	BYTE PTR [ebx], 0
$LN23@htmlAttrLi:

; 725  : 			}
; 726  : 		    }
; 727  : 
; 728  : 		    /* Escape the whole string, or until start (set to '\0'). */
; 729  : 		    escaped = xmlURIEscapeStr(tmp, BAD_CAST"@/:=?;#%&,+");

	push	OFFSET ??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@
	push	edi
	call	_xmlURIEscapeStr
	mov	ecx, DWORD PTR _buf$[ebp]
	add	esp, 8
	mov	DWORD PTR _escaped$1$[ebp], eax
	mov	ecx, DWORD PTR [ecx+16]

; 730  : 		    if (escaped != NULL) {

	test	eax, eax
	je	SHORT $LN24@htmlAttrLi

; 731  : 		        xmlBufCat(buf->buffer, escaped);

	push	eax
	push	ecx
	call	_xmlBufCat

; 732  : 		        xmlFree(escaped);

	push	DWORD PTR _escaped$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 733  : 		    } else {

	jmp	SHORT $LN25@htmlAttrLi
$LN24@htmlAttrLi:

; 734  : 		        xmlBufCat(buf->buffer, tmp);

	push	edi
	push	ecx
	call	_xmlBufCat
	add	esp, 8
$LN25@htmlAttrLi:

; 735  : 		    }
; 736  : 
; 737  : 		    if (end == NULL) { /* Everything has been written. */

	mov	eax, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN31@htmlAttrLi

; 738  : 			break;
; 739  : 		    }
; 740  : 
; 741  : 		    /* Do not escape anything within server side includes. */
; 742  : 		    *start = '<'; /* Restore the first character of "<!--". */
; 743  : 		    end += 3; /* strlen("-->") */
; 744  : 		    endChar = *end;
; 745  : 		    *end = '\0';
; 746  : 		    xmlBufCat(buf->buffer, start);

	push	DWORD PTR _start$1$[ebp]
	mov	BYTE PTR [ebx], 60			; 0000003cH
	mov	bl, BYTE PTR [esi+3]
	mov	BYTE PTR [esi+3], 0
	push	DWORD PTR [eax+16]
	call	_xmlBufCat
	add	esp, 8

; 747  : 		    *end = endChar;

	mov	BYTE PTR [esi+3], bl

; 748  : 		    tmp = end;

	lea	edi, DWORD PTR [esi+3]

; 749  : 		}

	jmp	$LL9@htmlAttrLi
$LN31@htmlAttrLi:

; 750  : 
; 751  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [eax+16]
	call	_xmlBufCCat

; 752  : 	    } else {

	mov	edi, DWORD PTR _value$1$[ebp]

; 754  : 	    }
; 755  : 	    xmlFree(value);

	add	esp, 8
	mov	ebx, DWORD PTR _cur$[ebp]
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 756  : 	} else  {

	jmp	SHORT $LN16@htmlAttrLi
$LN17@htmlAttrLi:

; 753  : 		xmlBufWriteQuotedString(buf->buffer, value);

	push	edi
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString

; 754  : 	    }
; 755  : 	    xmlFree(value);

	add	esp, 8
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 756  : 	} else  {

	jmp	SHORT $LN16@htmlAttrLi
$LN15@htmlAttrLi:

; 757  : 	    xmlOutputBufferWriteString(buf, "=\"\"");

	push	OFFSET ??_C@_03EAIBNEDB@?$DN?$CC?$CC@
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN16@htmlAttrLi:

; 773  :     if (cur == NULL) {
; 774  : 	return;
; 775  :     }
; 776  :     while (cur != NULL) {
; 777  :         htmlAttrDumpOutput(buf, doc, cur, encoding);
; 778  : 	cur = cur->next;

	mov	ebx, DWORD PTR [ebx+24]
	mov	DWORD PTR _cur$[ebp], ebx
	test	ebx, ebx
	jne	$LN50@htmlAttrLi
	pop	edi
	pop	esi
$LN3@htmlAttrLi:
	pop	ebx

; 779  :     }
; 780  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_htmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlAttrDumpOutput
_TEXT	SEGMENT
_value$1$ = -8						; size = 4
_start$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_escaped$1$ = 16					; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlAttrDumpOutput PROC				; COMDAT

; 679  : 	           const char *encoding ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN11@htmlAttrDu

; 680  :     xmlChar *value;
; 681  : 
; 682  :     /*
; 683  :      * The html output method should not escape a & character
; 684  :      * occurring in an attribute value immediately followed by
; 685  :      * a { character (see Section B.7.1 of the HTML 4.0 Recommendation).
; 686  :      * This is implemented in xmlEncodeEntitiesReentrant
; 687  :      */
; 688  : 
; 689  :     if (cur == NULL) {
; 690  : 	return;
; 691  :     }
; 692  :     xmlOutputBufferWriteString(buf, " ");

	push	ebx
	mov	ebx, DWORD PTR _buf$[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	ebx
	call	_xmlOutputBufferWriteString

; 693  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@htmlAttrDu
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN8@htmlAttrDu

; 694  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	ebx
	call	_xmlOutputBufferWriteString

; 695  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	ebx
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN8@htmlAttrDu:

; 696  :     }
; 697  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 698  :     if ((cur->children != NULL) && (!htmlIsBooleanAttr(cur->name))) {

	cmp	DWORD PTR [esi+12], 0
	je	$LN38@htmlAttrDu
	push	DWORD PTR [esi+8]
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	jne	$LN38@htmlAttrDu

; 699  : 	value = xmlNodeListGetString(doc, cur->children, 0);

	push	edi
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR _doc$[ebp]
	call	_xmlNodeListGetString
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _value$1$[ebp], edi

; 700  : 	if (value) {

	test	edi, edi
	je	$LN10@htmlAttrDu

; 701  : 	    xmlOutputBufferWriteString(buf, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	ebx
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 702  : 	    if ((cur->ns == NULL) && (cur->parent != NULL) &&
; 703  : 		(cur->parent->ns == NULL) &&

	cmp	DWORD PTR [esi+36], 0
	jne	$LN12@htmlAttrDu
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN12@htmlAttrDu
	cmp	DWORD PTR [eax+36], 0
	jne	$LN12@htmlAttrDu
	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_06DDLLCOJG@action@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_03LOJEKLML@src@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@htmlAttrDu
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN12@htmlAttrDu
	mov	eax, DWORD PTR [esi+20]
	push	OFFSET ??_C@_01MCMALHOG@a@
	push	DWORD PTR [eax+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN12@htmlAttrDu
$LN14@htmlAttrDu:

; 704  : 		((!xmlStrcasecmp(cur->name, BAD_CAST "href")) ||
; 705  : 	         (!xmlStrcasecmp(cur->name, BAD_CAST "action")) ||
; 706  : 		 (!xmlStrcasecmp(cur->name, BAD_CAST "src")) ||
; 707  : 		 ((!xmlStrcasecmp(cur->name, BAD_CAST "name")) &&
; 708  : 		  (!xmlStrcasecmp(cur->parent->name, BAD_CAST "a"))))) {
; 709  : 		xmlChar *tmp = value;
; 710  : 		/* xmlURIEscapeStr() escapes '"' so it can be safely used. */
; 711  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [ebx+16]
	call	_xmlBufCCat
	add	esp, 8
$LL2@htmlAttrDu:

; 712  : 
; 713  : 		while (IS_BLANK_CH(*tmp)) tmp++;

	mov	al, BYTE PTR [edi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@htmlAttrDu
	cmp	al, 9
	jb	SHORT $LN16@htmlAttrDu
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@htmlAttrDu
$LN16@htmlAttrDu:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LL4@htmlAttrDu
$LN15@htmlAttrDu:
	inc	edi
	jmp	SHORT $LL2@htmlAttrDu
$LL4@htmlAttrDu:

; 714  : 
; 715  : 		/* URI Escape everything, except server side includes. */
; 716  : 		for ( ; ; ) {
; 717  : 		    xmlChar *escaped;
; 718  : 		    xmlChar endChar;
; 719  : 		    xmlChar *end = NULL;
; 720  : 		    xmlChar *start = (xmlChar *)xmlStrstr(tmp, BAD_CAST "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	edi
	xor	esi, esi
	call	_xmlStrstr
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _start$1$[ebp], ebx

; 721  : 		    if (start != NULL) {

	test	ebx, ebx
	je	SHORT $LN18@htmlAttrDu

; 722  : 			end = (xmlChar *)xmlStrstr(tmp, BAD_CAST "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	edi
	call	_xmlStrstr
	mov	esi, eax
	add	esp, 8

; 723  : 			if (end != NULL) {

	test	esi, esi
	je	SHORT $LN18@htmlAttrDu

; 724  : 			    *start = '\0';

	mov	BYTE PTR [ebx], 0
$LN18@htmlAttrDu:

; 725  : 			}
; 726  : 		    }
; 727  : 
; 728  : 		    /* Escape the whole string, or until start (set to '\0'). */
; 729  : 		    escaped = xmlURIEscapeStr(tmp, BAD_CAST"@/:=?;#%&,+");

	push	OFFSET ??_C@_0M@LNGMBFJP@?$EA?1?3?$DN?$DP?$DL?$CD?$CF?$CG?0?$CL@
	push	edi
	call	_xmlURIEscapeStr
	mov	ecx, DWORD PTR _buf$[ebp]
	add	esp, 8
	mov	DWORD PTR _escaped$1$[ebp], eax
	mov	ecx, DWORD PTR [ecx+16]

; 730  : 		    if (escaped != NULL) {

	test	eax, eax
	je	SHORT $LN19@htmlAttrDu

; 731  : 		        xmlBufCat(buf->buffer, escaped);

	push	eax
	push	ecx
	call	_xmlBufCat

; 732  : 		        xmlFree(escaped);

	push	DWORD PTR _escaped$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 733  : 		    } else {

	jmp	SHORT $LN20@htmlAttrDu
$LN19@htmlAttrDu:

; 734  : 		        xmlBufCat(buf->buffer, tmp);

	push	edi
	push	ecx
	call	_xmlBufCat
	add	esp, 8
$LN20@htmlAttrDu:

; 735  : 		    }
; 736  : 
; 737  : 		    if (end == NULL) { /* Everything has been written. */

	mov	eax, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	SHORT $LN25@htmlAttrDu

; 738  : 			break;
; 739  : 		    }
; 740  : 
; 741  : 		    /* Do not escape anything within server side includes. */
; 742  : 		    *start = '<'; /* Restore the first character of "<!--". */
; 743  : 		    end += 3; /* strlen("-->") */
; 744  : 		    endChar = *end;
; 745  : 		    *end = '\0';
; 746  : 		    xmlBufCat(buf->buffer, start);

	push	DWORD PTR _start$1$[ebp]
	mov	BYTE PTR [ebx], 60			; 0000003cH
	mov	bl, BYTE PTR [esi+3]
	mov	BYTE PTR [esi+3], 0
	push	DWORD PTR [eax+16]
	call	_xmlBufCat
	add	esp, 8

; 747  : 		    *end = endChar;

	mov	BYTE PTR [esi+3], bl

; 748  : 		    tmp = end;

	lea	edi, DWORD PTR [esi+3]

; 749  : 		}

	jmp	$LL4@htmlAttrDu
$LN25@htmlAttrDu:

; 750  : 
; 751  : 		xmlBufCCat(buf->buffer, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [eax+16]
	call	_xmlBufCCat

; 752  : 	    } else {

	mov	edi, DWORD PTR _value$1$[ebp]

; 754  : 	    }
; 755  : 	    xmlFree(value);

	add	esp, 8
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	ebx
	pop	esi

; 758  : 	}
; 759  :     }
; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@htmlAttrDu:

; 753  : 		xmlBufWriteQuotedString(buf->buffer, value);

	push	edi
	push	DWORD PTR [ebx+16]
	call	_xmlBufWriteQuotedString

; 754  : 	    }
; 755  : 	    xmlFree(value);

	add	esp, 8
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	ebx
	pop	esi

; 758  : 	}
; 759  :     }
; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@htmlAttrDu:

; 756  : 	} else  {
; 757  : 	    xmlOutputBufferWriteString(buf, "=\"\"");

	push	OFFSET ??_C@_03EAIBNEDB@?$DN?$CC?$CC@
	push	ebx
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
$LN38@htmlAttrDu:
	pop	ebx
$LN11@htmlAttrDu:
	pop	esi

; 758  : 	}
; 759  :     }
; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_htmlAttrDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDtdDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlDtdDumpOutput PROC					; COMDAT

; 644  : 	          const char *encoding ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	mov	edi, DWORD PTR [eax+44]
	test	edi, edi
	jne	SHORT $LN2@htmlDtdDum

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@
	push	eax
	push	1402					; 0000057aH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	edi

; 666  : }

	pop	ebp
	ret	0
$LN2@htmlDtdDum:
	push	esi

; 645  :     xmlDtdPtr cur = doc->intSubset;
; 646  : 
; 647  :     if (cur == NULL) {
; 648  : 	htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);
; 649  : 	return;
; 650  :     }
; 651  :     xmlOutputBufferWriteString(buf, "<!DOCTYPE ");

	mov	esi, DWORD PTR _buf$[ebp]
	push	OFFSET ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
	push	esi
	call	_xmlOutputBufferWriteString

; 652  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H

; 653  :     if (cur->ExternalID != NULL) {

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN3@htmlDtdDum

; 654  : 	xmlOutputBufferWriteString(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	push	esi
	call	_xmlOutputBufferWriteString

; 655  : 	xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);

	push	DWORD PTR [edi+52]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 16					; 00000010H

; 656  : 	if (cur->SystemID != NULL) {

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN6@htmlDtdDum

; 657  : 	    xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@

; 658  : 	    xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
; 659  : 	}

	jmp	SHORT $LN17@htmlDtdDum
$LN3@htmlDtdDum:

; 660  :     } else if (cur->SystemID != NULL &&

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN6@htmlDtdDum
	push	OFFSET ??_C@_0BE@LDMALNEE@about?3legacy?9compat@
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@htmlDtdDum

; 661  : 	       xmlStrcmp(cur->SystemID, BAD_CAST "about:legacy-compat")) {
; 662  : 	xmlOutputBufferWriteString(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
$LN17@htmlDtdDum:

; 663  : 	xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
; 664  :     }
; 665  :     xmlOutputBufferWriteString(buf, ">\n");

	push	esi
	call	_xmlOutputBufferWriteString
	push	DWORD PTR [edi+56]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 16					; 00000010H
$LN6@htmlDtdDum:
	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	esi
	pop	edi

; 666  : }

	pop	ebp
	ret	0
_htmlDtdDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlBufNodeDumpFormat
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlBufNodeDumpFormat PROC				; COMDAT

; 409  : 	           int format) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN8@htmlBufNod

; 410  :     size_t use;
; 411  :     int ret;
; 412  :     xmlOutputBufferPtr outbuf;
; 413  : 
; 414  :     if (cur == NULL) {
; 415  : 	return (-1);
; 416  :     }
; 417  :     if (buf == NULL) {

	mov	ebx, DWORD PTR _buf$[ebp]
	test	ebx, ebx
	je	$LN8@htmlBufNod

; 419  :     }
; 420  :     outbuf = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));

	push	edi
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 421  :     if (outbuf == NULL) {

	test	edi, edi
	jne	SHORT $LN4@htmlBufNod

; 355  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@
	push	eax
	push	eax
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 422  :         htmlSaveErrMemory("allocating HTML output buffer");
; 423  : 	return (-1);

	or	eax, -1
	pop	edi
	pop	ebx

; 438  : }

	pop	ebp
	ret	0
$LN4@htmlBufNod:

; 424  :     }
; 425  :     memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));

	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+28], 0
	push	esi

; 426  :     outbuf->buffer = buf;
; 427  :     outbuf->encoder = NULL;
; 428  :     outbuf->writecallback = NULL;
; 429  :     outbuf->closecallback = NULL;
; 430  :     outbuf->context = NULL;
; 431  :     outbuf->written = 0;
; 432  : 
; 433  :     use = xmlBufUse(buf);

	push	ebx
	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+24], 0
	call	_xmlBufUse

; 434  :     htmlNodeDumpFormatOutput(outbuf, doc, cur, NULL, format);

	push	DWORD PTR _format$[ebp]
	mov	esi, eax
	push	0
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_htmlNodeDumpFormatOutput

; 435  :     xmlFree(outbuf);

	push	edi
	call	DWORD PTR _xmlFree

; 436  :     ret = xmlBufUse(buf) - use;

	push	ebx
	call	_xmlBufUse
	add	esp, 32					; 00000020H
	sub	eax, esi

; 437  :     return (ret);

	pop	esi
	pop	edi
	pop	ebx

; 438  : }

	pop	ebp
	ret	0
$LN8@htmlBufNod:

; 418  : 	return (-1);

	or	eax, -1
	pop	ebx

; 438  : }

	pop	ebp
	ret	0
_htmlBufNodeDumpFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveErr
_TEXT	SEGMENT
_code$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_htmlSaveErr PROC					; COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _code$[ebp]
	lea	eax, DWORD PTR [ecx-1400]
	cmp	eax, 3
	ja	SHORT $LN8@htmlSaveEr

; 369  :     const char *msg = NULL;
; 370  : 
; 371  :     switch(code) {

	jmp	DWORD PTR $LN11@htmlSaveEr[eax*4]
$LN4@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";
; 374  : 	    break;
; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";
; 377  : 	    break;
; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";
; 380  : 	    break;
; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";
; 383  : 	    break;
; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";
; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	pop	ebp
	ret	0
$LN5@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";
; 374  : 	    break;
; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";
; 377  : 	    break;
; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";
; 380  : 	    break;
; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";
; 383  : 	    break;
; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";
; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	pop	ebp
	ret	0
$LN6@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";
; 374  : 	    break;
; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";
; 377  : 	    break;
; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";
; 380  : 	    break;
; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";
; 383  : 	    break;
; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";
; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	pop	ebp
	ret	0
$LN7@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";
; 374  : 	    break;
; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";
; 377  : 	    break;
; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";
; 380  : 	    break;
; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";
; 383  : 	    break;
; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";
; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BF@DMLFPEHI@HTML?5has?5no?5DOCTYPE?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	pop	ebp
	ret	0
$LN8@htmlSaveEr:

; 372  :         case XML_SAVE_NOT_UTF8:
; 373  : 	    msg = "string is not in UTF-8\n";
; 374  : 	    break;
; 375  : 	case XML_SAVE_CHAR_INVALID:
; 376  : 	    msg = "invalid character value\n";
; 377  : 	    break;
; 378  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 379  : 	    msg = "unknown encoding %s\n";
; 380  : 	    break;
; 381  : 	case XML_SAVE_NO_DOCTYPE:
; 382  : 	    msg = "HTML has no DOCTYPE\n";
; 383  : 	    break;
; 384  : 	default:
; 385  : 	    msg = "unexpected error number\n";
; 386  :     }
; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 388  : }

	pop	ebp
	ret	0
	npad	1
$LN11@htmlSaveEr:
	DD	$LN4@htmlSaveEr
	DD	$LN5@htmlSaveEr
	DD	$LN7@htmlSaveEr
	DD	$LN6@htmlSaveEr
_htmlSaveErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_htmlSaveErrMemory PROC					; COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 355  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 356  : }

	pop	ebp
	ret	0
_htmlSaveErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlIsBooleanAttr
_TEXT	SEGMENT
_name$ = 8						; size = 4
_htmlIsBooleanAttr PROC					; COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _htmlBooleanAttrs
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN3@htmlIsBool
	mov	edi, DWORD PTR _name$[ebp]
	npad	3
$LL2@htmlIsBool:

; 325  :     int i = 0;
; 326  : 
; 327  :     while (htmlBooleanAttrs[i] != NULL) {
; 328  :         if (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[i], name) == 0)

	push	edi
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@htmlIsBool

; 330  :         i++;

	mov	eax, DWORD PTR _htmlBooleanAttrs[esi*4+4]
	inc	esi
	test	eax, eax
	jne	SHORT $LL2@htmlIsBool
$LN3@htmlIsBool:
	pop	edi

; 331  :     }
; 332  :     return 0;

	xor	eax, eax

; 333  : }

	pop	esi
	pop	ebp
	ret	0
$LN7@htmlIsBool:
	pop	edi

; 329  :             return 1;

	mov	eax, 1

; 333  : }

	pop	esi
	pop	ebp
	ret	0
_htmlIsBooleanAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_htmlNodeDumpOutput PROC				; COMDAT

; 1007 : 	           xmlNodePtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H

; 1008 :     htmlNodeDumpFormatOutput(buf, doc, cur, encoding, 1);
; 1009 : }

	pop	ebp
	ret	0
_htmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocContentDumpFormatOutput
_TEXT	SEGMENT
_type$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlDocContentDumpFormatOutput PROC			; COMDAT

; 1022 : 	                       const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@htmlDocCon

; 1023 :     int type;
; 1024 : 
; 1025 :     xmlInitParser();
; 1026 : 
; 1027 :     if ((buf == NULL) || (cur == NULL))

	push	edi
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN23@htmlDocCon

; 1028 :         return;
; 1029 : 
; 1030 :     /*
; 1031 :      * force to output the stuff as HTML, especially for entities
; 1032 :      */
; 1033 :     type = cur->type;

	mov	eax, DWORD PTR [edi+4]
	push	ebx

; 1034 :     cur->type = XML_HTML_DOCUMENT_NODE;
; 1035 :     if (cur->intSubset != NULL) {

	mov	ebx, DWORD PTR [edi+44]
	mov	DWORD PTR _type$1$[ebp], eax
	mov	DWORD PTR [edi+4], 13			; 0000000dH
	test	ebx, ebx
	je	$LN7@htmlDocCon

; 651  :     xmlOutputBufferWriteString(buf, "<!DOCTYPE ");

	push	OFFSET ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
	push	esi
	call	_xmlOutputBufferWriteString

; 652  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H

; 653  :     if (cur->ExternalID != NULL) {

	cmp	DWORD PTR [ebx+52], 0
	je	SHORT $LN9@htmlDocCon

; 654  : 	xmlOutputBufferWriteString(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	push	esi
	call	_xmlOutputBufferWriteString

; 655  : 	xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);

	push	DWORD PTR [ebx+52]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 16					; 00000010H

; 656  : 	if (cur->SystemID != NULL) {

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN12@htmlDocCon

; 657  : 	    xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@

; 658  : 	    xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
; 659  : 	}

	jmp	SHORT $LN24@htmlDocCon
$LN9@htmlDocCon:

; 660  :     } else if (cur->SystemID != NULL &&

	mov	eax, DWORD PTR [ebx+56]
	test	eax, eax
	je	SHORT $LN12@htmlDocCon
	push	OFFSET ??_C@_0BE@LDMALNEE@about?3legacy?9compat@
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@htmlDocCon

; 661  : 	       xmlStrcmp(cur->SystemID, BAD_CAST "about:legacy-compat")) {
; 662  : 	xmlOutputBufferWriteString(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
$LN24@htmlDocCon:

; 663  : 	xmlBufWriteQuotedString(buf->buffer, cur->SystemID);
; 664  :     }
; 665  :     xmlOutputBufferWriteString(buf, ">\n");

	push	esi
	call	_xmlOutputBufferWriteString
	push	DWORD PTR [ebx+56]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 16					; 00000010H
$LN12@htmlDocCon:
	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN7@htmlDocCon:

; 1036 :         htmlDtdDumpOutput(buf, cur, NULL);
; 1037 :     }
; 1038 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR [edi+12]
	pop	ebx
	test	eax, eax
	je	SHORT $LN5@htmlDocCon

; 1039 :         htmlNodeListDumpOutput(buf, cur, cur->children, encoding, format);

	push	DWORD PTR _format$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	eax
	push	edi
	push	esi
	call	_htmlNodeListDumpOutput
	add	esp, 20					; 00000014H
$LN5@htmlDocCon:

; 1040 :     }
; 1041 :     xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_xmlOutputBufferWriteString

; 1042 :     cur->type = (xmlElementType) type;

	mov	eax, DWORD PTR _type$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
$LN23@htmlDocCon:
	pop	edi
$LN3@htmlDocCon:
	pop	esi

; 1043 : }

	pop	ebp
	ret	0
_htmlDocContentDumpFormatOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocContentDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlDocContentDumpOutput PROC				; COMDAT

; 1055 : 	                 const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H

; 1056 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);
; 1057 : }

	pop	ebp
	ret	0
_htmlDocContentDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFormatOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeDumpFormatOutput PROC				; COMDAT

; 818  : 	                 xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@htmlNodeDu

; 819  :     const htmlElemDesc * info;
; 820  : 
; 821  :     xmlInitParser();
; 822  : 
; 823  :     if ((cur == NULL) || (buf == NULL)) {

	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	$LN56@htmlNodeDu

; 824  : 	return;
; 825  :     }
; 826  :     /*
; 827  :      * Special cases.
; 828  :      */
; 829  :     if (cur->type == XML_DTD_NODE)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 14					; 0000000eH
	je	$LN56@htmlNodeDu

; 830  : 	return;
; 831  :     if ((cur->type == XML_HTML_DOCUMENT_NODE) ||

	cmp	eax, 13					; 0000000dH
	je	$LN6@htmlNodeDu
	cmp	eax, 9
	je	$LN6@htmlNodeDu

; 832  :         (cur->type == XML_DOCUMENT_NODE)){
; 833  : 	htmlDocContentDumpOutput(buf, (xmlDocPtr) cur, encoding);
; 834  : 	return;
; 835  :     }
; 836  :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN7@htmlNodeDu

; 837  :         htmlAttrDumpOutput(buf, doc, (xmlAttrPtr) cur, encoding);

	push	DWORD PTR _encoding$[ebp]
	push	esi
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_htmlAttrDumpOutput
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN7@htmlNodeDu:

; 838  : 	return;
; 839  :     }
; 840  :     if (cur->type == HTML_TEXT_NODE) {

	cmp	eax, 3
	jne	$LN8@htmlNodeDu

; 841  : 	if (cur->content != NULL) {

	cmp	DWORD PTR [esi+40], 0
	je	$LN56@htmlNodeDu

; 842  : 	    if (((cur->name == (const xmlChar *)xmlStringText) ||
; 843  : 		 (cur->name != (const xmlChar *)xmlStringTextNoenc)) &&

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, OFFSET _xmlStringText
	je	SHORT $LN12@htmlNodeDu
	cmp	eax, OFFSET _xmlStringTextNoenc
	je	SHORT $LN10@htmlNodeDu
$LN12@htmlNodeDu:
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN52@htmlNodeDu
	push	OFFSET ??_C@_06OLONEIEH@script@
	push	DWORD PTR [eax+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@htmlNodeDu
	mov	eax, DWORD PTR [esi+20]
	push	OFFSET ??_C@_05IAKJCFIM@style@
	push	DWORD PTR [eax+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@htmlNodeDu
$LN10@htmlNodeDu:

; 853  : 		}
; 854  : 	    } else {
; 855  : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN52@htmlNodeDu:

; 844  : 		((cur->parent == NULL) ||
; 845  : 		 ((xmlStrcasecmp(cur->parent->name, BAD_CAST "script")) &&
; 846  : 		  (xmlStrcasecmp(cur->parent->name, BAD_CAST "style"))))) {
; 847  : 		xmlChar *buffer;
; 848  : 
; 849  : 		buffer = xmlEncodeEntitiesReentrant(doc, cur->content);

	push	DWORD PTR [esi+40]
	push	DWORD PTR _doc$[ebp]
	call	_xmlEncodeEntitiesReentrant
	mov	esi, eax
	add	esp, 8

; 850  : 		if (buffer != NULL) {

	test	esi, esi
	je	$LN56@htmlNodeDu

; 851  : 		    xmlOutputBufferWriteString(buf, (const char *)buffer);

	push	esi
	push	edi
	call	_xmlOutputBufferWriteString

; 852  : 		    xmlFree(buffer);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN8@htmlNodeDu:

; 856  : 	    }
; 857  : 	}
; 858  : 	return;
; 859  :     }
; 860  :     if (cur->type == HTML_COMMENT_NODE) {

	cmp	eax, 8
	jne	SHORT $LN15@htmlNodeDu

; 861  : 	if (cur->content != NULL) {

	cmp	DWORD PTR [esi+40], 0
	je	$LN56@htmlNodeDu

; 862  : 	    xmlOutputBufferWriteString(buf, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	edi
	call	_xmlOutputBufferWriteString

; 863  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString

; 864  : 	    xmlOutputBufferWriteString(buf, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN15@htmlNodeDu:

; 865  : 	}
; 866  : 	return;
; 867  :     }
; 868  :     if (cur->type == HTML_PI_NODE) {

	cmp	eax, 7
	jne	SHORT $LN17@htmlNodeDu

; 869  : 	if (cur->name == NULL)

	cmp	DWORD PTR [esi+8], 0
	je	$LN56@htmlNodeDu

; 870  : 	    return;
; 871  : 	xmlOutputBufferWriteString(buf, "<?");

	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	edi
	call	_xmlOutputBufferWriteString

; 872  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H

; 873  : 	if (cur->content != NULL) {

	cmp	DWORD PTR [esi+40], 0
	je	SHORT $LN19@htmlNodeDu

; 874  : 	    xmlOutputBufferWriteString(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	edi
	call	_xmlOutputBufferWriteString

; 875  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN19@htmlNodeDu:

; 876  : 	}
; 877  : 	xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN17@htmlNodeDu:

; 878  : 	return;
; 879  :     }
; 880  :     if (cur->type == HTML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	SHORT $LN20@htmlNodeDu

; 881  :         xmlOutputBufferWriteString(buf, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	edi
	call	_xmlOutputBufferWriteString

; 882  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 883  :         xmlOutputBufferWriteString(buf, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN20@htmlNodeDu:

; 884  : 	return;
; 885  :     }
; 886  :     if (cur->type == HTML_PRESERVE_NODE) {

	cmp	eax, 4
	jne	SHORT $LN21@htmlNodeDu

; 887  : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	$LN56@htmlNodeDu

; 888  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN21@htmlNodeDu:

; 889  : 	}
; 890  : 	return;
; 891  :     }
; 892  : 
; 893  :     /*
; 894  :      * Get specific HTML info for that node.
; 895  :      */
; 896  :     if (cur->ns == NULL)

	cmp	DWORD PTR [esi+36], 0
	push	ebx
	jne	SHORT $LN23@htmlNodeDu

; 897  : 	info = htmlTagLookup(cur->name);

	push	DWORD PTR [esi+8]
	call	_htmlTagLookup
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN24@htmlNodeDu
$LN23@htmlNodeDu:

; 898  :     else
; 899  : 	info = NULL;

	xor	ebx, ebx
$LN24@htmlNodeDu:

; 900  : 
; 901  :     xmlOutputBufferWriteString(buf, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	edi
	call	_xmlOutputBufferWriteString

; 902  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@htmlNodeDu
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN25@htmlNodeDu

; 903  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 904  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN25@htmlNodeDu:

; 905  :     }
; 906  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 907  :     if (cur->nsDef)

	mov	eax, DWORD PTR [esi+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@htmlNodeDu

; 908  : 	xmlNsListDumpOutput(buf, cur->nsDef);

	push	eax
	push	edi
	call	_xmlNsListDumpOutput
	add	esp, 8
$LN26@htmlNodeDu:

; 909  :     if (cur->properties != NULL)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN27@htmlNodeDu

; 910  :         htmlAttrListDumpOutput(buf, doc, cur->properties, encoding);

	push	DWORD PTR _encoding$[ebp]
	push	eax
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_htmlAttrListDumpOutput
	add	esp, 16					; 00000010H
$LN27@htmlNodeDu:

; 911  : 
; 912  :     if ((info != NULL) && (info->empty)) {

	test	ebx, ebx
	je	SHORT $LN28@htmlNodeDu
	cmp	BYTE PTR [ebx+7], 0
	je	SHORT $LN28@htmlNodeDu

; 913  :         xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 914  : 	if ((format) && (!info->isinline) && (cur->next != NULL)) {

	cmp	DWORD PTR _format$[ebp], 0

; 915  : 	    if ((cur->next->type != HTML_TEXT_NODE) &&
; 916  : 		(cur->next->type != HTML_ENTITY_REF_NODE) &&
; 917  : 		(cur->parent != NULL) &&
; 918  : 		(cur->parent->name != NULL) &&
; 919  : 		(cur->parent->name[0] != 'p')) /* p, pre, param */
; 920  : 		xmlOutputBufferWriteString(buf, "\n");
; 921  : 	}
; 922  : 	return;

	jmp	$LN59@htmlNodeDu
$LN28@htmlNodeDu:

; 923  :     }
; 924  :     if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN53@htmlNodeDu
	cmp	DWORD PTR [esi+40], 0
	jne	$LN55@htmlNodeDu
$LN53@htmlNodeDu:
	cmp	DWORD PTR [esi+12], 0
	jne	$LN55@htmlNodeDu

; 925  : 	(cur->children == NULL)) {
; 926  :         if ((info != NULL) && (info->saveEndTag != 0) &&
; 927  : 	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&

	test	ebx, ebx
	je	SHORT $LN33@htmlNodeDu
	cmp	BYTE PTR [ebx+6], 0
	je	SHORT $LN33@htmlNodeDu
	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	DWORD PTR [ebx]
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@htmlNodeDu
	push	OFFSET ??_C@_04IEJGKNJ@body@
	push	DWORD PTR [ebx]
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@htmlNodeDu
$LN33@htmlNodeDu:

; 928  : 	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
; 929  : 	    xmlOutputBufferWriteString(buf, ">");
; 930  : 	} else {
; 931  : 	    xmlOutputBufferWriteString(buf, "></");

	push	OFFSET ??_C@_03PBCCILOI@?$DO?$DM?1@
	push	edi
	call	_xmlOutputBufferWriteString

; 932  :             if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@htmlNodeDu
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN35@htmlNodeDu

; 933  :                 xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 934  :                 xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN35@htmlNodeDu:

; 935  :             }
; 936  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN34@htmlNodeDu:

; 937  : 	    xmlOutputBufferWriteString(buf, ">");
; 938  : 	}
; 939  : 	if ((format) && (cur->next != NULL) &&
; 940  :             (info != NULL) && (!info->isinline)) {

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN57@htmlNodeDu
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN57@htmlNodeDu
	test	ebx, ebx
	je	SHORT $LN57@htmlNodeDu
	cmp	BYTE PTR [ebx+10], 0
	je	$LN58@htmlNodeDu
$LN57@htmlNodeDu:
	pop	ebx
$LN56@htmlNodeDu:
	pop	edi
$LN3@htmlNodeDu:
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN55@htmlNodeDu:

; 941  : 	    if ((cur->next->type != HTML_TEXT_NODE) &&
; 942  : 		(cur->next->type != HTML_ENTITY_REF_NODE) &&
; 943  : 		(cur->parent != NULL) &&
; 944  : 		(cur->parent->name != NULL) &&
; 945  : 		(cur->parent->name[0] != 'p')) /* p, pre, param */
; 946  : 		xmlOutputBufferWriteString(buf, "\n");
; 947  : 	}
; 948  : 	return;
; 949  :     }
; 950  :     xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 951  :     if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN38@htmlNodeDu
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN38@htmlNodeDu

; 952  : 	(cur->content != NULL)) {
; 953  : 	    /*
; 954  : 	     * Uses the OutputBuffer property to automatically convert
; 955  : 	     * invalids to charrefs
; 956  : 	     */
; 957  : 
; 958  :             xmlOutputBufferWriteString(buf, (const char *) cur->content);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN38@htmlNodeDu:

; 959  :     }
; 960  :     if (cur->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN41@htmlNodeDu

; 961  :         if ((format) && (info != NULL) && (!info->isinline) &&
; 962  : 	    (cur->children->type != HTML_TEXT_NODE) &&
; 963  : 	    (cur->children->type != HTML_ENTITY_REF_NODE) &&
; 964  : 	    (cur->children != cur->last) &&
; 965  : 	    (cur->name != NULL) &&

	cmp	DWORD PTR _format$[ebp], 0
	mov	ecx, eax
	je	SHORT $LN40@htmlNodeDu
	test	ebx, ebx
	je	SHORT $LN40@htmlNodeDu
	cmp	BYTE PTR [ebx+10], 0
	jne	SHORT $LN40@htmlNodeDu
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 3
	je	SHORT $LN40@htmlNodeDu
	cmp	edx, 5
	je	SHORT $LN40@htmlNodeDu
	cmp	eax, DWORD PTR [esi+16]
	je	SHORT $LN40@htmlNodeDu
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	je	SHORT $LN40@htmlNodeDu
	cmp	BYTE PTR [edx], 112			; 00000070H
	je	SHORT $LN40@htmlNodeDu

; 966  : 	    (cur->name[0] != 'p')) /* p, pre, param */
; 967  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_xmlOutputBufferWriteString
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 8
$LN40@htmlNodeDu:

; 968  : 	htmlNodeListDumpOutput(buf, doc, cur->children, encoding, format);

	push	DWORD PTR _format$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	ecx
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_htmlNodeListDumpOutput
	add	esp, 20					; 00000014H

; 969  :         if ((format) && (info != NULL) && (!info->isinline) &&
; 970  : 	    (cur->last->type != HTML_TEXT_NODE) &&
; 971  : 	    (cur->last->type != HTML_ENTITY_REF_NODE) &&
; 972  : 	    (cur->children != cur->last) &&
; 973  : 	    (cur->name != NULL) &&

	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN41@htmlNodeDu
	test	ebx, ebx
	je	SHORT $LN41@htmlNodeDu
	cmp	BYTE PTR [ebx+10], 0
	jne	SHORT $LN41@htmlNodeDu
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 3
	je	SHORT $LN41@htmlNodeDu
	cmp	eax, 5
	je	SHORT $LN41@htmlNodeDu
	cmp	DWORD PTR [esi+12], ecx
	je	SHORT $LN41@htmlNodeDu
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN41@htmlNodeDu
	cmp	BYTE PTR [eax], 112			; 00000070H
	je	SHORT $LN41@htmlNodeDu

; 974  : 	    (cur->name[0] != 'p')) /* p, pre, param */
; 975  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN41@htmlNodeDu:

; 976  :     }
; 977  :     xmlOutputBufferWriteString(buf, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	edi
	call	_xmlOutputBufferWriteString

; 978  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@htmlNodeDu
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN42@htmlNodeDu

; 979  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 980  : 	xmlOutputBufferWriteString(buf, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H
$LN42@htmlNodeDu:

; 981  :     }
; 982  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 983  :     xmlOutputBufferWriteString(buf, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 16					; 00000010H

; 984  :     if ((format) && (info != NULL) && (!info->isinline) &&

	cmp	DWORD PTR _format$[ebp], 0
	je	$LN57@htmlNodeDu
	test	ebx, ebx
$LN59@htmlNodeDu:
	je	$LN57@htmlNodeDu
	cmp	BYTE PTR [ebx+10], 0
	jne	$LN57@htmlNodeDu
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	$LN57@htmlNodeDu
$LN58@htmlNodeDu:

; 985  : 	(cur->next != NULL)) {
; 986  :         if ((cur->next->type != HTML_TEXT_NODE) &&
; 987  : 	    (cur->next->type != HTML_ENTITY_REF_NODE) &&
; 988  : 	    (cur->parent != NULL) &&
; 989  : 	    (cur->parent->name != NULL) &&

	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 3
	je	$LN57@htmlNodeDu
	cmp	eax, 5
	je	$LN57@htmlNodeDu
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN57@htmlNodeDu
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	$LN57@htmlNodeDu
	cmp	BYTE PTR [eax], 112			; 00000070H
	je	$LN57@htmlNodeDu

; 990  : 	    (cur->parent->name[0] != 'p')) /* p, pre, param */
; 991  : 	    xmlOutputBufferWriteString(buf, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
$LN6@htmlNodeDu:

; 1056 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);

	push	1
	push	DWORD PTR _encoding$[ebp]
	push	esi
	push	edi
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 992  :     }
; 993  : }

	pop	ebp
	ret	0
_htmlNodeDumpFormatOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFileFormat
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlSaveFileFormat PROC				; COMDAT

; 1183 : 	           const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	$LN3@htmlSaveFi

; 1184 :     xmlOutputBufferPtr buf;
; 1185 :     xmlCharEncodingHandlerPtr handler = NULL;
; 1186 :     int ret;
; 1187 : 
; 1188 :     if ((cur == NULL) || (filename == NULL))

	cmp	DWORD PTR _filename$[ebp], edi
	je	$LN3@htmlSaveFi

; 1190 : 
; 1191 :     xmlInitParser();

	push	esi
	call	_xmlInitParser

; 1192 : 
; 1193 :     if (encoding != NULL) {

	mov	esi, DWORD PTR _encoding$[ebp]
	test	esi, esi
	je	SHORT $LN4@htmlSaveFi

; 1194 : 	xmlCharEncoding enc;
; 1195 : 
; 1196 : 	enc = xmlParseCharEncoding(encoding);

	push	esi
	call	_xmlParseCharEncoding
	add	esp, 4

; 1197 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	eax, 1
	je	SHORT $LN12@htmlSaveFi

; 1198 : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	esi
	call	_xmlFindCharEncodingHandler
	mov	edi, eax
	add	esp, 4

; 1199 : 	    if (handler == NULL)

	test	edi, edi
	jne	SHORT $LN12@htmlSaveFi

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	esi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
$LN12@htmlSaveFi:

; 1200 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 1201 : 	}
; 1202 :         htmlSetMetaEncoding(cur, (const xmlChar *) encoding);

	push	esi
	push	ebx
	call	_htmlSetMetaEncoding
	add	esp, 8

; 1203 :     } else {

	jmp	SHORT $LN9@htmlSaveFi
$LN4@htmlSaveFi:

; 1204 : 	htmlSetMetaEncoding(cur, (const xmlChar *) "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	ebx
	call	_htmlSetMetaEncoding

; 1205 : 
; 1206 :         /*
; 1207 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1208 :          */
; 1209 :         if (handler == NULL)
; 1210 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1211 :         if (handler == NULL)

	test	edi, edi
	jne	SHORT $LN9@htmlSaveFi

; 1212 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	edi, eax
$LN9@htmlSaveFi:

; 1213 :     }
; 1214 : 
; 1215 :     /*
; 1216 :      * save the content to a temp buffer.
; 1217 :      */
; 1218 :     buf = xmlOutputBufferCreateFilename(filename, handler, 0);

	push	0
	push	edi
	push	DWORD PTR _filename$[ebp]
	call	_xmlOutputBufferCreateFilename
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1219 :     if (buf == NULL) return(0);

	test	edi, edi
	jne	SHORT $LN10@htmlSaveFi

; 1224 :     return(ret);
; 1225 : }

	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN10@htmlSaveFi:

; 1220 : 
; 1221 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, format);

	push	DWORD PTR _format$[ebp]
	push	esi
	push	ebx
	push	edi
	call	_htmlDocContentDumpFormatOutput

; 1222 : 
; 1223 :     ret = xmlOutputBufferClose(buf);

	push	edi
	call	_xmlOutputBufferClose
	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 1224 :     return(ret);
; 1225 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@htmlSaveFi:
	pop	edi

; 1189 :         return(-1);

	or	eax, -1

; 1224 :     return(ret);
; 1225 : }

	pop	ebx
	pop	ebp
	ret	0
_htmlSaveFileFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFileEnc
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_htmlSaveFileEnc PROC					; COMDAT

; 1239 : htmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _filename$[ebp]
	call	_htmlSaveFileFormat
	add	esp, 16					; 00000010H

; 1240 :     return(htmlSaveFileFormat(filename, cur, encoding, 1));
; 1241 : }

	pop	ebp
	ret	0
_htmlSaveFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFileFormat
_TEXT	SEGMENT
_out$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_encoding$ = 20						; size = 4
_format$ = 24						; size = 4
_htmlNodeDumpFileFormat PROC				; COMDAT

; 489  : 	               xmlNodePtr cur, const char *encoding, int format) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	call	_xmlInitParser
	mov	edi, DWORD PTR _encoding$[ebp]
	test	edi, edi
	je	SHORT $LN19@htmlNodeDu

; 490  :     xmlOutputBufferPtr buf;
; 491  :     xmlCharEncodingHandlerPtr handler = NULL;
; 492  :     int ret;
; 493  : 
; 494  :     xmlInitParser();
; 495  : 
; 496  :     if (encoding != NULL) {
; 497  : 	xmlCharEncoding enc;
; 498  : 
; 499  : 	enc = xmlParseCharEncoding(encoding);

	push	edi
	call	_xmlParseCharEncoding
	add	esp, 4

; 500  : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	eax, 1
	je	SHORT $LN7@htmlNodeDu

; 501  : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 502  : 	    if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN7@htmlNodeDu

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 503  : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 504  : 	}
; 505  :     } else {

	jmp	SHORT $LN7@htmlNodeDu
$LN19@htmlNodeDu:

; 506  :         /*
; 507  :          * Fallback to HTML or ASCII when the encoding is unspecified
; 508  :          */
; 509  :         if (handler == NULL)
; 510  :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 511  :         if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN7@htmlNodeDu

; 512  :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	esi, eax
$LN7@htmlNodeDu:

; 513  :     }
; 514  : 
; 515  :     /*
; 516  :      * save the content to a temp buffer.
; 517  :      */
; 518  :     buf = xmlOutputBufferCreateFile(out, handler);

	push	esi
	push	DWORD PTR _out$[ebp]
	call	_xmlOutputBufferCreateFile
	mov	esi, eax
	add	esp, 8

; 519  :     if (buf == NULL) return(0);

	test	esi, esi
	jne	SHORT $LN8@htmlNodeDu

; 524  :     return(ret);
; 525  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@htmlNodeDu:

; 520  : 
; 521  :     htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);

	push	DWORD PTR _format$[ebp]
	push	edi
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	esi
	call	_htmlNodeDumpFormatOutput

; 522  : 
; 523  :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 24					; 00000018H
	pop	edi

; 524  :     return(ret);
; 525  : }

	pop	esi
	pop	ebp
	ret	0
_htmlNodeDumpFileFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDumpFile
_TEXT	SEGMENT
_out$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_htmlNodeDumpFile PROC					; COMDAT

; 537  : htmlNodeDumpFile(FILE *out, xmlDocPtr doc, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4

; 494  :     xmlInitParser();

	call	_xmlInitParser

; 495  : 
; 496  :     if (encoding != NULL) {
; 497  : 	xmlCharEncoding enc;
; 498  : 
; 499  : 	enc = xmlParseCharEncoding(encoding);
; 500  : 	if (enc != XML_CHAR_ENCODING_UTF8) {
; 501  : 	    handler = xmlFindCharEncodingHandler(encoding);
; 502  : 	    if (handler == NULL)
; 503  : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 504  : 	}
; 505  :     } else {
; 506  :         /*
; 507  :          * Fallback to HTML or ASCII when the encoding is unspecified
; 508  :          */
; 509  :         if (handler == NULL)
; 510  :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 511  :         if (handler == NULL)

	test	eax, eax
	jne	SHORT $LN9@htmlNodeDu

; 512  :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
$LN9@htmlNodeDu:
	push	esi

; 513  :     }
; 514  : 
; 515  :     /*
; 516  :      * save the content to a temp buffer.
; 517  :      */
; 518  :     buf = xmlOutputBufferCreateFile(out, handler);

	push	eax
	push	DWORD PTR _out$[ebp]
	call	_xmlOutputBufferCreateFile
	mov	esi, eax
	add	esp, 8

; 519  :     if (buf == NULL) return(0);

	test	esi, esi
	je	SHORT $LN3@htmlNodeDu

; 520  : 
; 521  :     htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);

	push	1
	push	0
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	esi
	call	_htmlNodeDumpFormatOutput

; 522  : 
; 523  :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 24					; 00000018H
$LN3@htmlNodeDu:
	pop	esi

; 538  :     htmlNodeDumpFileFormat(out, doc, cur, NULL, 1);
; 539  : }

	pop	ebp
	ret	0
_htmlNodeDumpFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlNodeDump
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_htmlNodeDump PROC					; COMDAT

; 452  : htmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN3@htmlNodeDu

; 453  :     xmlBufPtr buffer;
; 454  :     size_t ret;
; 455  : 
; 456  :     if ((buf == NULL) || (cur == NULL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@htmlNodeDu

; 457  :         return(-1);
; 458  : 
; 459  :     xmlInitParser();

	call	_xmlInitParser

; 460  :     buffer = xmlBufFromBuffer(buf);

	push	esi
	call	_xmlBufFromBuffer
	mov	ebx, eax
	add	esp, 4

; 461  :     if (buffer == NULL)

	test	ebx, ebx
	je	$LN3@htmlNodeDu

; 420  :     outbuf = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 421  :     if (outbuf == NULL) {

	test	edi, edi
	jne	SHORT $LN10@htmlNodeDu

; 355  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BO@IIMAGFKO@allocating?5HTML?5output?5buffer@
	push	eax
	push	eax
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 423  : 	return (-1);

	or	edi, -1
	jmp	SHORT $LN7@htmlNodeDu
$LN10@htmlNodeDu:

; 424  :     }
; 425  :     memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));

	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+28], 0

; 426  :     outbuf->buffer = buf;
; 427  :     outbuf->encoder = NULL;
; 428  :     outbuf->writecallback = NULL;
; 429  :     outbuf->closecallback = NULL;
; 430  :     outbuf->context = NULL;
; 431  :     outbuf->written = 0;
; 432  : 
; 433  :     use = xmlBufUse(buf);

	push	ebx
	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+24], 0
	call	_xmlBufUse

; 434  :     htmlNodeDumpFormatOutput(outbuf, doc, cur, NULL, format);

	push	1
	push	0
	push	DWORD PTR _cur$[ebp]
	mov	esi, eax
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_htmlNodeDumpFormatOutput

; 435  :     xmlFree(outbuf);

	push	edi
	call	DWORD PTR _xmlFree

; 436  :     ret = xmlBufUse(buf) - use;

	push	ebx
	call	_xmlBufUse
	mov	edi, eax
	add	esp, 32					; 00000020H
	sub	edi, esi
$LN7@htmlNodeDu:

; 462  :         return(-1);
; 463  : 
; 464  :     ret = htmlBufNodeDumpFormat(buffer, doc, cur, 1);
; 465  : 
; 466  :     xmlBufBackToBuffer(buffer);

	push	ebx
	call	_xmlBufBackToBuffer
	add	esp, 4

; 467  : 
; 468  :     if (ret > INT_MAX)

	cmp	edi, 2147483647				; 7fffffffH
	ja	SHORT $LN3@htmlNodeDu

; 469  :         return(-1);
; 470  :     return((int) ret);

	mov	eax, edi
	pop	edi

; 471  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@htmlNodeDu:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_htmlNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSaveFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_htmlSaveFile PROC					; COMDAT

; 1126 : htmlSaveFile(const char *filename, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	xor	esi, esi
	test	ebx, ebx
	je	$LN3@htmlSaveFi

; 1127 :     xmlOutputBufferPtr buf;
; 1128 :     xmlCharEncodingHandlerPtr handler = NULL;
; 1129 :     const char *encoding;
; 1130 :     int ret;
; 1131 : 
; 1132 :     if ((cur == NULL) || (filename == NULL))

	cmp	DWORD PTR _filename$[ebp], esi
	je	$LN3@htmlSaveFi

; 1134 : 
; 1135 :     xmlInitParser();

	push	edi
	call	_xmlInitParser

; 1136 : 
; 1137 :     encoding = (const char *) htmlGetMetaEncoding(cur);

	push	ebx
	call	_htmlGetMetaEncoding
	mov	edi, eax
	add	esp, 4

; 1138 : 
; 1139 :     if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN23@htmlSaveFi

; 1140 : 	xmlCharEncoding enc;
; 1141 : 
; 1142 : 	enc = xmlParseCharEncoding(encoding);

	push	edi
	call	_xmlParseCharEncoding
	add	esp, 4

; 1143 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	eax, 1
	je	SHORT $LN9@htmlSaveFi

; 1144 : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 1145 : 	    if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN9@htmlSaveFi

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1146 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 1147 : 	}
; 1148 :     } else {

	jmp	SHORT $LN9@htmlSaveFi
$LN23@htmlSaveFi:

; 1149 :         /*
; 1150 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1151 :          */
; 1152 :         if (handler == NULL)
; 1153 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 1154 :         if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN9@htmlSaveFi

; 1155 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	esi, eax
$LN9@htmlSaveFi:

; 1156 :     }
; 1157 : 
; 1158 :     /*
; 1159 :      * save the content to a temp buffer.
; 1160 :      */
; 1161 :     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);

	push	DWORD PTR [ebx+36]
	push	esi
	push	DWORD PTR _filename$[ebp]
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 1162 :     if (buf == NULL) return(0);

	pop	edi
	test	esi, esi
	jne	SHORT $LN10@htmlSaveFi
	pop	esi
	xor	eax, eax

; 1167 :     return(ret);
; 1168 : }

	pop	ebx
	pop	ebp
	ret	0
$LN10@htmlSaveFi:

; 1056 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);

	push	1
	push	0
	push	ebx
	push	esi
	call	_htmlDocContentDumpFormatOutput

; 1163 : 
; 1164 :     htmlDocContentDumpOutput(buf, cur, NULL);
; 1165 : 
; 1166 :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 20					; 00000014H
	pop	esi

; 1167 :     return(ret);
; 1168 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@htmlSaveFi:
	pop	esi

; 1133 :         return(-1);

	or	eax, -1

; 1167 :     return(ret);
; 1168 : }

	pop	ebx
	pop	ebp
	ret	0
_htmlSaveFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDump
_TEXT	SEGMENT
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_htmlDocDump PROC					; COMDAT

; 1075 : htmlDocDump(FILE *f, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	call	_xmlInitParser
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN3@htmlDocDum

; 1076 :     xmlOutputBufferPtr buf;
; 1077 :     xmlCharEncodingHandlerPtr handler = NULL;
; 1078 :     const char *encoding;
; 1079 :     int ret;
; 1080 : 
; 1081 :     xmlInitParser();
; 1082 : 
; 1083 :     if ((cur == NULL) || (f == NULL)) {

	cmp	DWORD PTR _f$[ebp], esi
	je	$LN3@htmlDocDum

; 1085 :     }
; 1086 : 
; 1087 :     encoding = (const char *) htmlGetMetaEncoding(cur);

	push	edi
	push	ebx
	call	_htmlGetMetaEncoding
	mov	edi, eax
	add	esp, 4

; 1088 : 
; 1089 :     if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN23@htmlDocDum

; 1090 : 	xmlCharEncoding enc;
; 1091 : 
; 1092 : 	enc = xmlParseCharEncoding(encoding);

	push	edi
	call	_xmlParseCharEncoding
	add	esp, 4

; 1093 : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	eax, 1
	je	SHORT $LN9@htmlDocDum

; 1094 : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 1095 : 	    if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN9@htmlDocDum

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1096 : 		htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 1097 : 	}
; 1098 :     } else {

	jmp	SHORT $LN9@htmlDocDum
$LN23@htmlDocDum:

; 1099 :         /*
; 1100 :          * Fallback to HTML or ASCII when the encoding is unspecified
; 1101 :          */
; 1102 :         if (handler == NULL)
; 1103 :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 1104 :         if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN9@htmlDocDum

; 1105 :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	esi, eax
$LN9@htmlDocDum:

; 1106 :     }
; 1107 : 
; 1108 :     buf = xmlOutputBufferCreateFile(f, handler);

	push	esi
	push	DWORD PTR _f$[ebp]
	call	_xmlOutputBufferCreateFile
	add	esp, 8
	mov	esi, eax

; 1109 :     if (buf == NULL) return(-1);

	pop	edi
	test	esi, esi
	je	SHORT $LN3@htmlDocDum

; 1056 :     htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);

	push	1
	push	0
	push	ebx
	push	esi
	call	_htmlDocContentDumpFormatOutput

; 1110 :     htmlDocContentDumpOutput(buf, cur, NULL);
; 1111 : 
; 1112 :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 20					; 00000014H
	pop	esi

; 1113 :     return(ret);
; 1114 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@htmlDocDum:
	pop	esi

; 1084 : 	return(-1);

	or	eax, -1

; 1113 :     return(ret);
; 1114 : }

	pop	ebx
	pop	ebp
	ret	0
_htmlDocDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDumpMemoryFormat
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_format$ = 20						; size = 4
_htmlDocDumpMemoryFormat PROC				; COMDAT

; 552  : htmlDocDumpMemoryFormat(xmlDocPtr cur, xmlChar**mem, int *size, int format) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	call	_xmlInitParser
	mov	eax, DWORD PTR _mem$[ebp]
	test	eax, eax
	je	$LN3@htmlDocDum

; 553  :     xmlOutputBufferPtr buf;
; 554  :     xmlCharEncodingHandlerPtr handler = NULL;
; 555  :     const char *encoding;
; 556  : 
; 557  :     xmlInitParser();
; 558  : 
; 559  :     if ((mem == NULL) || (size == NULL))

	push	ebx
	mov	ebx, DWORD PTR _size$[ebp]
	test	ebx, ebx
	je	$LN27@htmlDocDum

; 560  :         return;
; 561  :     if (cur == NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	push	edi
	test	ecx, ecx
	je	$LN25@htmlDocDum

; 562  : 	*mem = NULL;
; 563  : 	*size = 0;
; 564  : 	return;
; 565  :     }
; 566  : 
; 567  :     encoding = (const char *) htmlGetMetaEncoding(cur);

	push	ecx
	call	_htmlGetMetaEncoding
	mov	edi, eax
	add	esp, 4

; 568  : 
; 569  :     if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN24@htmlDocDum

; 570  : 	xmlCharEncoding enc;
; 571  : 
; 572  : 	enc = xmlParseCharEncoding(encoding);

	push	edi
	call	_xmlParseCharEncoding
	add	esp, 4

; 573  : 	if (enc != XML_CHAR_ENCODING_UTF8) {

	cmp	eax, 1
	je	SHORT $LN10@htmlDocDum

; 574  : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 575  : 	    if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN10@htmlDocDum

; 387  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 576  :                 htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 577  : 
; 578  : 	}
; 579  :     } else {

	jmp	SHORT $LN10@htmlDocDum
$LN24@htmlDocDum:

; 580  :         /*
; 581  :          * Fallback to HTML or ASCII when the encoding is unspecified
; 582  :          */
; 583  :         if (handler == NULL)
; 584  :             handler = xmlFindCharEncodingHandler("HTML");

	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 585  :         if (handler == NULL)

	test	esi, esi
	jne	SHORT $LN10@htmlDocDum

; 586  :             handler = xmlFindCharEncodingHandler("ascii");

	push	OFFSET ??_C@_05OJENGABA@ascii@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	esi, eax
$LN10@htmlDocDum:

; 587  :     }
; 588  : 
; 589  :     buf = xmlAllocOutputBufferInternal(handler);

	push	esi
	call	_xmlAllocOutputBufferInternal
	mov	esi, eax
	add	esp, 4

; 590  :     if (buf == NULL) {

	test	esi, esi
	je	SHORT $LN26@htmlDocDum

; 593  : 	return;
; 594  :     }
; 595  : 
; 596  :     htmlDocContentDumpFormatOutput(buf, cur, NULL, format);

	push	DWORD PTR _format$[ebp]
	push	0
	push	DWORD PTR _cur$[ebp]
	push	esi
	call	_htmlDocContentDumpFormatOutput

; 597  : 
; 598  :     xmlOutputBufferFlush(buf);

	push	esi
	call	_xmlOutputBufferFlush

; 599  :     if (buf->conv != NULL) {

	mov	eax, DWORD PTR [esi+20]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN12@htmlDocDum

; 600  : 	*size = xmlBufUse(buf->conv);

	push	eax
	call	_xmlBufUse
	mov	edi, eax
	mov	DWORD PTR [ebx], edi

; 601  : 	*mem = xmlStrndup(xmlBufContent(buf->conv), *size);

	mov	eax, DWORD PTR [esi+20]

; 602  :     } else {

	jmp	SHORT $LN29@htmlDocDum
$LN12@htmlDocDum:

; 603  : 	*size = xmlBufUse(buf->buffer);

	push	DWORD PTR [esi+16]
	call	_xmlBufUse
	mov	edi, eax
	mov	DWORD PTR [ebx], edi

; 604  : 	*mem = xmlStrndup(xmlBufContent(buf->buffer), *size);

	mov	eax, DWORD PTR [esi+16]
$LN29@htmlDocDum:

; 605  :     }
; 606  :     (void)xmlOutputBufferClose(buf);

	add	esp, 4
	push	eax
	call	_xmlBufContent
	push	edi
	push	eax
	call	_xmlStrndup
	mov	ecx, DWORD PTR _mem$[ebp]
	push	esi
	mov	DWORD PTR [ecx], eax
	call	_xmlOutputBufferClose
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 607  : }

	pop	ebp
	ret	0
$LN26@htmlDocDum:

; 590  :     if (buf == NULL) {

	mov	eax, DWORD PTR _mem$[ebp]
$LN25@htmlDocDum:

; 591  : 	*mem = NULL;

	mov	DWORD PTR [eax], 0

; 592  : 	*size = 0;

	mov	DWORD PTR [ebx], 0
	pop	edi
$LN27@htmlDocDum:
	pop	ebx
$LN3@htmlDocDum:
	pop	esi

; 607  : }

	pop	ebp
	ret	0
_htmlDocDumpMemoryFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlDocDumpMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_htmlDocDumpMemory PROC					; COMDAT

; 619  : htmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _mem$[ebp]
	push	DWORD PTR _cur$[ebp]
	call	_htmlDocDumpMemoryFormat
	add	esp, 16					; 00000010H

; 620  : 	htmlDocDumpMemoryFormat(cur, mem, size, 1);
; 621  : }

	pop	ebp
	ret	0
_htmlDocDumpMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlSetMetaEncoding
_TEXT	SEGMENT
_newcontent$ = -112					; size = 100
_http$1$ = -12						; size = 4
_head$1$ = -8						; size = 4
_content$1$ = -4					; size = 4
_doc$ = 8						; size = 4
_encoding$ = 12						; size = 4
_htmlSetMetaEncoding PROC				; COMDAT

; 164  : htmlSetMetaEncoding(htmlDocPtr doc, const xmlChar *encoding) {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _head$1$[ebp], 0
	mov	BYTE PTR _newcontent$[ebp], 0
	test	edi, edi
	je	$LN68@htmlSetMet

; 165  :     htmlNodePtr cur, meta = NULL, head = NULL;
; 166  :     const xmlChar *content = NULL;
; 167  :     char newcontent[100];
; 168  : 
; 169  :     newcontent[0] = 0;
; 170  : 
; 171  :     if (doc == NULL)
; 172  : 	return(-1);
; 173  : 
; 174  :     /* html isn't a real encoding it's just libxml2 way to get entities */
; 175  :     if (!xmlStrcasecmp(encoding, BAD_CAST "html"))

	mov	ebx, DWORD PTR _encoding$[ebp]
	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	ebx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@htmlSetMet

; 176  :         return(-1);
; 177  : 
; 178  :     if (encoding != NULL) {

	test	ebx, ebx
	je	SHORT $LN12@htmlSetMet

; 179  : 	snprintf(newcontent, sizeof(newcontent), "text/html; charset=%s",

	push	ebx
	push	OFFSET ??_C@_0BG@HLDJIGE@text?1html?$DL?5charset?$DN?$CFs@
	lea	eax, DWORD PTR _newcontent$[ebp]
	push	100					; 00000064H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 180  :                 (char *)encoding);
; 181  : 	newcontent[sizeof(newcontent) - 1] = 0;

	mov	BYTE PTR _newcontent$[ebp+99], 0
$LN12@htmlSetMet:

; 182  :     }
; 183  : 
; 184  :     cur = doc->children;

	mov	esi, DWORD PTR [edi+12]

; 185  : 
; 186  :     /*
; 187  :      * Search the html
; 188  :      */
; 189  :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN68@htmlSetMet
$LL2@htmlSetMet:

; 190  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN16@htmlSetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN16@htmlSetMet

; 191  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"html") == 0)

	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@htmlSetMet

; 192  : 		break;
; 193  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"head") == 0)

	push	OFFSET ??_C@_04NEODDMOL@head@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $found_head$73

; 194  : 		goto found_head;
; 195  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0)

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $found_meta$74
$LN16@htmlSetMet:

; 196  : 		goto found_meta;
; 197  : 	}
; 198  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@htmlSetMet
$LN68@htmlSetMet:
	pop	edi

; 297  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@htmlSetMet:

; 199  :     }
; 200  :     if (cur == NULL)
; 201  : 	return(-1);
; 202  :     cur = cur->children;

	mov	esi, DWORD PTR [esi+12]

; 203  : 
; 204  :     /*
; 205  :      * Search the head
; 206  :      */
; 207  :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN68@htmlSetMet
$LL4@htmlSetMet:

; 208  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN20@htmlSetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN20@htmlSetMet

; 209  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"head") == 0)

	push	OFFSET ??_C@_04NEODDMOL@head@
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $found_head$73

; 210  : 		break;
; 211  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	DWORD PTR [esi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@htmlSetMet
$LN20@htmlSetMet:

; 214  :             }
; 215  : 	}
; 216  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@htmlSetMet

; 297  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@htmlSetMet:

; 212  :                 head = cur->parent;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _head$1$[ebp], eax

; 213  : 		goto found_meta;

	jmp	SHORT $found_meta$74
$found_head$73:

; 217  :     }
; 218  :     if (cur == NULL)
; 219  : 	return(-1);
; 220  : found_head:
; 221  :     head = cur;

	mov	DWORD PTR _head$1$[ebp], esi

; 222  :     if (cur->children == NULL)

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	$LN65@htmlSetMet
$found_meta$74:

; 223  :         goto create;
; 224  :     cur = cur->children;
; 225  : 
; 226  : found_meta:
; 227  :     /*
; 228  :      * Search and update all the remaining the meta elements carrying
; 229  :      * encoding informations
; 230  :      */
; 231  :     while (cur != NULL) {

	test	esi, esi
	je	$LN65@htmlSetMet
$LL6@htmlSetMet:

; 232  : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN30@htmlSetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN30@htmlSetMet

; 233  : 	    if (xmlStrcasecmp(cur->name, BAD_CAST"meta") == 0) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	$LN30@htmlSetMet

; 234  : 		xmlAttrPtr attr = cur->properties;

	mov	edi, DWORD PTR [esi+44]

; 235  : 		int http;
; 236  : 		const xmlChar *value;
; 237  : 
; 238  : 		content = NULL;

	xor	ecx, ecx

; 239  : 		http = 0;

	xor	edx, edx
	mov	DWORD PTR _content$1$[ebp], ecx
	mov	DWORD PTR _http$1$[ebp], edx

; 240  : 		while (attr != NULL) {

	test	edi, edi
	je	$LN30@htmlSetMet
$LL8@htmlSetMet:

; 241  : 		    if ((attr->children != NULL) &&
; 242  : 		        (attr->children->type == XML_TEXT_NODE) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN29@htmlSetMet
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN29@htmlSetMet
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN29@htmlSetMet

; 243  : 		        (attr->children->next == NULL)) {
; 244  : 			value = attr->children->content;

	mov	ebx, DWORD PTR [eax+40]

; 245  : 			if ((!xmlStrcasecmp(attr->name, BAD_CAST"http-equiv"))
; 246  : 			 && (!xmlStrcasecmp(value, BAD_CAST"Content-Type")))

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	push	DWORD PTR [edi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@htmlSetMet
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	push	ebx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@htmlSetMet

; 247  : 			    http = 1;

	mov	ecx, DWORD PTR _content$1$[ebp]
	mov	edx, 1
	mov	DWORD PTR _http$1$[ebp], edx
	jmp	SHORT $LN66@htmlSetMet
$LN26@htmlSetMet:

; 248  : 			else
; 249  :                         {
; 250  :                            if ((value != NULL) &&

	test	ebx, ebx
	je	SHORT $LN69@htmlSetMet
	push	OFFSET ??_C@_07ICAJMOAO@content@
	push	DWORD PTR [edi+8]
	call	_xmlStrcasecmp
	mov	ecx, DWORD PTR _content$1$[ebp]
	add	esp, 8
	test	eax, eax
	cmove	ecx, ebx
	mov	DWORD PTR _content$1$[ebp], ecx
	jmp	SHORT $LN28@htmlSetMet
$LN69@htmlSetMet:
	mov	ecx, DWORD PTR _content$1$[ebp]
$LN28@htmlSetMet:

; 251  :                                (!xmlStrcasecmp(attr->name, BAD_CAST"content")))
; 252  : 			       content = value;
; 253  :                         }
; 254  : 		        if ((http != 0) && (content != NULL))

	mov	edx, DWORD PTR _http$1$[ebp]
	test	edx, edx
	je	SHORT $LN29@htmlSetMet
$LN66@htmlSetMet:
	test	ecx, ecx
	jne	SHORT $LN49@htmlSetMet
$LN29@htmlSetMet:

; 255  : 			    break;
; 256  : 		    }
; 257  : 		    attr = attr->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL8@htmlSetMet
$LN49@htmlSetMet:

; 258  : 		}
; 259  : 		if ((http != 0) && (content != NULL)) {

	test	edx, edx
	je	SHORT $LN30@htmlSetMet
	test	ecx, ecx
	jne	SHORT $LN31@htmlSetMet
$LN30@htmlSetMet:

; 260  : 		    meta = cur;
; 261  : 		    break;
; 262  : 		}
; 263  : 
; 264  : 	    }
; 265  : 	}
; 266  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL6@htmlSetMet

; 223  :         goto create;
; 224  :     cur = cur->children;
; 225  : 
; 226  : found_meta:
; 227  :     /*
; 228  :      * Search and update all the remaining the meta elements carrying
; 229  :      * encoding informations
; 230  :      */
; 231  :     while (cur != NULL) {

	mov	ebx, DWORD PTR _encoding$[ebp]
	mov	edi, DWORD PTR _doc$[ebp]
$LN65@htmlSetMet:

; 267  :     }
; 268  : create:
; 269  :     if (meta == NULL) {
; 270  :         if ((encoding != NULL) && (head != NULL)) {

	test	ebx, ebx
	je	$LN38@htmlSetMet
	mov	ebx, DWORD PTR _head$1$[ebp]
	test	ebx, ebx
	je	$LN38@htmlSetMet

; 271  :             /*
; 272  :              * Create a new Meta element with the right attributes
; 273  :              */
; 274  : 
; 275  :             meta = xmlNewDocNode(doc, NULL, BAD_CAST"meta", NULL);

	push	0
	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	0
	push	edi
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	esi, eax

; 276  :             if (head->children == NULL)

	mov	eax, DWORD PTR [ebx+12]
	push	esi
	test	eax, eax
	jne	SHORT $LN34@htmlSetMet

; 277  :                 xmlAddChild(head, meta);

	push	ebx
	call	_xmlAddChild
	jmp	SHORT $LN71@htmlSetMet
$LN31@htmlSetMet:

; 282  :         }
; 283  :     } else {
; 284  :         /* remove the meta tag if NULL is passed */
; 285  :         if (encoding == NULL) {

	mov	eax, DWORD PTR _encoding$[ebp]
	test	eax, eax
	jne	SHORT $LN36@htmlSetMet

; 286  :             xmlUnlinkNode(meta);

	push	esi
	call	_xmlUnlinkNode

; 287  :             xmlFreeNode(meta);

	push	esi
	call	_xmlFreeNode
	add	esp, 8

; 292  :         }
; 293  :     }
; 294  : 
; 295  : 
; 296  :     return(0);

	xor	eax, eax
	pop	edi

; 297  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@htmlSetMet:

; 288  :         }
; 289  :         /* change the document only if there is a real encoding change */
; 290  :         else if (xmlStrcasestr(content, encoding) == NULL) {

	push	eax
	push	ecx
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@htmlSetMet

; 291  :             xmlSetProp(meta, BAD_CAST"content", BAD_CAST newcontent);

	lea	eax, DWORD PTR _newcontent$[ebp]
	push	eax
	push	OFFSET ??_C@_07ICAJMOAO@content@
	push	esi
	call	_xmlSetProp
	add	esp, 12					; 0000000cH

; 292  :         }
; 293  :     }
; 294  : 
; 295  : 
; 296  :     return(0);

	xor	eax, eax
	pop	edi

; 297  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@htmlSetMet:

; 278  :             else
; 279  :                 xmlAddPrevSibling(head->children, meta);

	push	eax
	call	_xmlAddPrevSibling
$LN71@htmlSetMet:

; 280  :             xmlNewProp(meta, BAD_CAST"http-equiv", BAD_CAST"Content-Type");

	add	esp, 8
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	push	esi
	call	_xmlNewProp

; 281  :             xmlNewProp(meta, BAD_CAST"content", BAD_CAST newcontent);

	lea	eax, DWORD PTR _newcontent$[ebp]
	push	eax
	push	OFFSET ??_C@_07ICAJMOAO@content@
	push	esi
	call	_xmlNewProp
	add	esp, 24					; 00000018H
$LN38@htmlSetMet:

; 297  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlSetMetaEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\htmltree.c
;	COMDAT _htmlGetMetaEncoding
_TEXT	SEGMENT
_http$1$ = -4						; size = 4
_value$1$ = 8						; size = 4
_doc$ = 8						; size = 4
_htmlGetMetaEncoding PROC				; COMDAT

; 50   : htmlGetMetaEncoding(htmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __E0C87F61_htmltree@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN72@htmlGetMet

; 51   :     htmlNodePtr cur;
; 52   :     const xmlChar *content;
; 53   :     const xmlChar *encoding;
; 54   : 
; 55   :     if (doc == NULL)
; 56   : 	return(NULL);
; 57   :     cur = doc->children;
; 58   : 
; 59   :     /*
; 60   :      * Search the html
; 61   :      */
; 62   :     while (cur != NULL) {

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $LN72@htmlGetMet
	npad	1
$LL2@htmlGetMet:

; 63   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN16@htmlGetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN16@htmlGetMet

; 64   : 	    if (xmlStrEqual(cur->name, BAD_CAST"html"))

	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@htmlGetMet

; 65   : 		break;
; 66   : 	    if (xmlStrEqual(cur->name, BAD_CAST"head"))

	push	OFFSET ??_C@_04NEODDMOL@head@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found_head$75

; 67   : 		goto found_head;
; 68   : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found_meta$76
$LN16@htmlGetMet:

; 69   : 		goto found_meta;
; 70   : 	}
; 71   : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@htmlGetMet
$LN72@htmlGetMet:

; 126  :     }
; 127  :     return(NULL);

	xor	eax, eax
$LN1@htmlGetMet:
	pop	edi

; 148  :     }
; 149  :     return(encoding);
; 150  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@htmlGetMet:

; 72   :     }
; 73   :     if (cur == NULL)
; 74   : 	return(NULL);
; 75   :     cur = cur->children;

	mov	esi, DWORD PTR [esi+12]

; 76   : 
; 77   :     /*
; 78   :      * Search the head
; 79   :      */
; 80   :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN72@htmlGetMet
	npad	2
$LL4@htmlGetMet:

; 81   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN20@htmlGetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN20@htmlGetMet

; 82   : 	    if (xmlStrEqual(cur->name, BAD_CAST"head"))

	push	OFFSET ??_C@_04NEODDMOL@head@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found_head$75

; 83   : 		break;
; 84   : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found_meta$76
$LN20@htmlGetMet:

; 85   : 		goto found_meta;
; 86   : 	}
; 87   : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@htmlGetMet

; 148  :     }
; 149  :     return(encoding);
; 150  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$found_head$75:

; 88   :     }
; 89   :     if (cur == NULL)
; 90   : 	return(NULL);
; 91   : found_head:
; 92   :     cur = cur->children;

	mov	esi, DWORD PTR [esi+12]
$found_meta$76:

; 93   : 
; 94   :     /*
; 95   :      * Search the meta elements
; 96   :      */
; 97   : found_meta:
; 98   :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN72@htmlGetMet
	npad	6
$LL6@htmlGetMet:

; 99   : 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN9@htmlGetMet
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	$LN9@htmlGetMet

; 100  : 	    if (xmlStrEqual(cur->name, BAD_CAST"meta")) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@htmlGetMet

; 101  : 		xmlAttrPtr attr = cur->properties;

	mov	edi, DWORD PTR [esi+44]

; 102  : 		int http;
; 103  : 		const xmlChar *value;
; 104  : 
; 105  : 		content = NULL;

	xor	ebx, ebx

; 106  : 		http = 0;

	mov	DWORD PTR _http$1$[ebp], ebx

; 107  : 		while (attr != NULL) {

	test	edi, edi
	je	SHORT $LN9@htmlGetMet
$LL8@htmlGetMet:

; 108  : 		    if ((attr->children != NULL) &&
; 109  : 		        (attr->children->type == XML_TEXT_NODE) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN28@htmlGetMet
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN28@htmlGetMet
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN28@htmlGetMet

; 110  : 		        (attr->children->next == NULL)) {
; 111  : 			value = attr->children->content;

	mov	eax, DWORD PTR [eax+40]

; 112  : 			if ((!xmlStrcasecmp(attr->name, BAD_CAST"http-equiv"))
; 113  : 			 && (!xmlStrcasecmp(value, BAD_CAST"Content-Type")))

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	push	DWORD PTR [edi+8]
	mov	DWORD PTR _value$1$[ebp], eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@htmlGetMet
	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	push	DWORD PTR _value$1$[ebp]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@htmlGetMet

; 114  : 			    http = 1;

	mov	DWORD PTR _http$1$[ebp], 1
	jmp	SHORT $LN69@htmlGetMet
$LN25@htmlGetMet:

; 115  : 			else if ((value != NULL)
; 116  : 			 && (!xmlStrcasecmp(attr->name, BAD_CAST"content")))

	cmp	DWORD PTR _value$1$[ebp], 0
	je	SHORT $LN27@htmlGetMet
	push	OFFSET ??_C@_07ICAJMOAO@content@
	push	DWORD PTR [edi+8]
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	cmove	ebx, DWORD PTR _value$1$[ebp]
$LN27@htmlGetMet:

; 117  : 			    content = value;
; 118  : 			if ((http != 0) && (content != NULL))

	cmp	DWORD PTR _http$1$[ebp], 0
	je	SHORT $LN28@htmlGetMet
$LN69@htmlGetMet:
	test	ebx, ebx
	jne	SHORT $found_content$77
$LN28@htmlGetMet:

; 119  : 			    goto found_content;
; 120  : 		    }
; 121  : 		    attr = attr->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL8@htmlGetMet
$LN9@htmlGetMet:

; 122  : 		}
; 123  : 	    }
; 124  : 	}
; 125  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL6@htmlGetMet

; 148  :     }
; 149  :     return(encoding);
; 150  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$found_content$77:

; 128  : 
; 129  : found_content:
; 130  :     encoding = xmlStrstr(content, BAD_CAST"charset=");

	push	OFFSET ??_C@_08JPKHBDLJ@charset?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 131  :     if (encoding == NULL)

	test	eax, eax
	jne	SHORT $LN66@htmlGetMet

; 132  : 	encoding = xmlStrstr(content, BAD_CAST"Charset=");

	push	OFFSET ??_C@_08BNFGJBBK@Charset?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 133  :     if (encoding == NULL)

	test	eax, eax
	jne	SHORT $LN66@htmlGetMet

; 134  : 	encoding = xmlStrstr(content, BAD_CAST"CHARSET=");

	push	OFFSET ??_C@_08HFIPAJDM@CHARSET?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 135  :     if (encoding != NULL) {

	test	eax, eax
	jne	SHORT $LN66@htmlGetMet

; 137  :     } else {
; 138  : 	encoding = xmlStrstr(content, BAD_CAST"charset =");

	push	OFFSET ??_C@_09MMDENEKG@charset?5?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 139  : 	if (encoding == NULL)

	test	eax, eax
	jne	SHORT $LN65@htmlGetMet

; 140  : 	    encoding = xmlStrstr(content, BAD_CAST"Charset =");

	push	OFFSET ??_C@_09IDGJNHHG@Charset?5?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 141  : 	if (encoding == NULL)

	test	eax, eax
	jne	SHORT $LN65@htmlGetMet

; 142  : 	    encoding = xmlStrstr(content, BAD_CAST"CHARSET =");

	push	OFFSET ??_C@_09FBAMILBD@CHARSET?5?$DN@
	push	ebx
	call	_xmlStrstr
	add	esp, 8

; 143  : 	if (encoding != NULL)

	test	eax, eax
	je	$LN1@htmlGetMet
$LN65@htmlGetMet:

; 144  : 	    encoding += 9;

	add	eax, 9
	jmp	SHORT $LN35@htmlGetMet
$LN66@htmlGetMet:

; 136  : 	encoding += 8;

	add	eax, 8
$LN35@htmlGetMet:

; 145  :     }
; 146  :     if (encoding != NULL) {

	test	eax, eax
	je	$LN1@htmlGetMet
$LL10@htmlGetMet:

; 147  : 	while ((*encoding == ' ') || (*encoding == '\t')) encoding++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN59@htmlGetMet
	cmp	cl, 9
	jne	$LN1@htmlGetMet
$LN59@htmlGetMet:
	inc	eax
	jmp	SHORT $LL10@htmlGetMet
_htmlGetMetaEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
