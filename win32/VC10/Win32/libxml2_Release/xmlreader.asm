; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlreader.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__BC13D883_xmlreader@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_printf
PUBLIC	_xmlNewTextReader
PUBLIC	_xmlNewTextReaderFilename
PUBLIC	_xmlFreeTextReader
PUBLIC	_xmlTextReaderSetup
PUBLIC	_xmlTextReaderRead
PUBLIC	_xmlTextReaderReadInnerXml
PUBLIC	_xmlTextReaderReadOuterXml
PUBLIC	_xmlTextReaderReadString
PUBLIC	_xmlTextReaderReadAttributeValue
PUBLIC	_xmlTextReaderAttributeCount
PUBLIC	_xmlTextReaderDepth
PUBLIC	_xmlTextReaderHasAttributes
PUBLIC	_xmlTextReaderHasValue
PUBLIC	_xmlTextReaderIsDefault
PUBLIC	_xmlTextReaderIsEmptyElement
PUBLIC	_xmlTextReaderNodeType
PUBLIC	_xmlTextReaderQuoteChar
PUBLIC	_xmlTextReaderReadState
PUBLIC	_xmlTextReaderIsNamespaceDecl
PUBLIC	_xmlTextReaderConstBaseUri
PUBLIC	_xmlTextReaderConstLocalName
PUBLIC	_xmlTextReaderConstName
PUBLIC	_xmlTextReaderConstNamespaceUri
PUBLIC	_xmlTextReaderConstPrefix
PUBLIC	_xmlTextReaderConstXmlLang
PUBLIC	_xmlTextReaderConstString
PUBLIC	_xmlTextReaderConstValue
PUBLIC	_xmlTextReaderBaseUri
PUBLIC	_xmlTextReaderLocalName
PUBLIC	_xmlTextReaderName
PUBLIC	_xmlTextReaderNamespaceUri
PUBLIC	_xmlTextReaderPrefix
PUBLIC	_xmlTextReaderXmlLang
PUBLIC	_xmlTextReaderValue
PUBLIC	_xmlTextReaderClose
PUBLIC	_xmlTextReaderGetAttributeNo
PUBLIC	_xmlTextReaderGetAttribute
PUBLIC	_xmlTextReaderGetAttributeNs
PUBLIC	_xmlTextReaderGetRemainder
PUBLIC	_xmlTextReaderLookupNamespace
PUBLIC	_xmlTextReaderMoveToAttributeNo
PUBLIC	_xmlTextReaderMoveToAttribute
PUBLIC	_xmlTextReaderMoveToAttributeNs
PUBLIC	_xmlTextReaderMoveToFirstAttribute
PUBLIC	_xmlTextReaderMoveToNextAttribute
PUBLIC	_xmlTextReaderMoveToElement
PUBLIC	_xmlTextReaderNormalization
PUBLIC	_xmlTextReaderConstEncoding
PUBLIC	_xmlTextReaderSetParserProp
PUBLIC	_xmlTextReaderGetParserProp
PUBLIC	_xmlTextReaderCurrentNode
PUBLIC	_xmlTextReaderGetParserLineNumber
PUBLIC	_xmlTextReaderGetParserColumnNumber
PUBLIC	_xmlTextReaderPreserve
PUBLIC	_xmlTextReaderPreservePattern
PUBLIC	_xmlTextReaderCurrentDoc
PUBLIC	_xmlTextReaderExpand
PUBLIC	_xmlTextReaderNext
PUBLIC	_xmlTextReaderNextSibling
PUBLIC	_xmlTextReaderIsValid
PUBLIC	_xmlTextReaderRelaxNGValidate
PUBLIC	_xmlTextReaderRelaxNGValidateCtxt
PUBLIC	_xmlTextReaderRelaxNGSetSchema
PUBLIC	_xmlTextReaderSchemaValidate
PUBLIC	_xmlTextReaderSchemaValidateCtxt
PUBLIC	_xmlTextReaderSetSchema
PUBLIC	_xmlTextReaderConstXmlVersion
PUBLIC	_xmlTextReaderStandalone
PUBLIC	_xmlTextReaderByteConsumed
PUBLIC	_xmlReaderWalker
PUBLIC	_xmlReaderForDoc
PUBLIC	_xmlReaderForFile
PUBLIC	_xmlReaderForMemory
PUBLIC	_xmlReaderForFd
PUBLIC	_xmlReaderForIO
PUBLIC	_xmlReaderNewWalker
PUBLIC	_xmlReaderNewDoc
PUBLIC	_xmlReaderNewFile
PUBLIC	_xmlReaderNewMemory
PUBLIC	_xmlReaderNewFd
PUBLIC	_xmlReaderNewIO
PUBLIC	_xmlTextReaderLocatorLineNumber
PUBLIC	_xmlTextReaderLocatorBaseURI
PUBLIC	_xmlTextReaderSetErrorHandler
PUBLIC	_xmlTextReaderSetStructuredErrorHandler
PUBLIC	_xmlTextReaderGetErrorHandler
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BE@MPMNBMMA@xmlMalloc?5failed?5?$CB?6@	; `string'
PUBLIC	??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0BB@DOFEEJAH@Expand?5failed?5?$CB?6@	; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@ ; `string'
PUBLIC	??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@ ; `string'
PUBLIC	??_C@_0GL@PIJMIJNC@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@ ; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ ; `string'
PUBLIC	??_C@_05NOBOONOA@?$CDtext@			; `string'
PUBLIC	??_C@_0P@LIENAFBO@?$CDcdata?9section@		; `string'
PUBLIC	??_C@_08FBDKDMPC@?$CDcomment@			; `string'
PUBLIC	??_C@_09DFKKGJPK@?$CDdocument@			; `string'
PUBLIC	??_C@_0BD@FMMPJIKP@?$CDdocument?9fragment@	; `string'
PUBLIC	??_C@_0CE@MNBJMFAB@xmlTextReaderSetup?5?3?5malloc?5fai@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BE@KJPJIHAO@vsnprintf?5failed?5?$CB?6@	; `string'
PUBLIC	??_C@_07FHOHOHLG@include@			; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictQLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	_xmlBufferCat:PROC
EXTRN	_xmlFreeDtd:PROC
EXTRN	_xmlFreeNs:PROC
EXTRN	_xmlFreeNsList:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlCopyDtd:PROC
EXTRN	_xmlNewDocText:PROC
EXTRN	_xmlDocCopyNode:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlIsBlankNode:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlGetNoNsProp:PROC
EXTRN	_xmlGetNsProp:PROC
EXTRN	_xmlNodeListGetString:PROC
EXTRN	_xmlBufGetNodeContent:PROC
EXTRN	_xmlNodeGetLang:PROC
EXTRN	_xmlNodeGetSpacePreserve:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlNodeDump:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlParserError:PROC
EXTRN	_xmlParserWarning:PROC
EXTRN	_xmlParserValidityError:PROC
EXTRN	_xmlParserValidityWarning:PROC
EXTRN	_xmlIsID:PROC
EXTRN	_xmlFreeRefTable:PROC
EXTRN	_xmlValidatePushElement:PROC
EXTRN	_xmlValidatePushCData:PROC
EXTRN	_xmlValidatePopElement:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlAllocParserInputBuffer:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlParserInputBufferCreateFd:PROC
EXTRN	_xmlParserInputBufferCreateStatic:PROC
EXTRN	_xmlParserInputBufferCreateIO:PROC
EXTRN	_xmlParserInputBufferRead:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlStopParser:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	_xmlCreatePushParserCtxt:PROC
EXTRN	_xmlParseChunk:PROC
EXTRN	_xmlByteConsumed:PROC
EXTRN	_xmlCtxtReset:PROC
EXTRN	_xmlCtxtUseOptions:PROC
EXTRN	_xmlSAXVersion:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlDeregisterNodeDefaultValue:PROC
EXTRN	_xmlRelaxNGNewParserCtxt:PROC
EXTRN	_xmlRelaxNGFreeParserCtxt:PROC
EXTRN	_xmlRelaxNGSetParserErrors:PROC
EXTRN	_xmlRelaxNGParse:PROC
EXTRN	_xmlRelaxNGFree:PROC
EXTRN	_xmlRelaxNGSetValidErrors:PROC
EXTRN	_xmlRelaxNGSetValidStructuredErrors:PROC
EXTRN	_xmlRelaxNGNewValidCtxt:PROC
EXTRN	_xmlRelaxNGFreeValidCtxt:PROC
EXTRN	_xmlRelaxNGValidatePushElement:PROC
EXTRN	_xmlRelaxNGValidatePushCData:PROC
EXTRN	_xmlRelaxNGValidatePopElement:PROC
EXTRN	_xmlRelaxNGValidateFullElement:PROC
EXTRN	_xmlSchemaNewParserCtxt:PROC
EXTRN	_xmlSchemaFreeParserCtxt:PROC
EXTRN	_xmlSchemaSetParserErrors:PROC
EXTRN	_xmlSchemaIsValid:PROC
EXTRN	_xmlSchemaParse:PROC
EXTRN	_xmlSchemaFree:PROC
EXTRN	_xmlSchemaSetValidErrors:PROC
EXTRN	_xmlSchemaSetValidStructuredErrors:PROC
EXTRN	_xmlSchemaNewValidCtxt:PROC
EXTRN	_xmlSchemaFreeValidCtxt:PROC
EXTRN	_xmlSchemaSAXPlug:PROC
EXTRN	_xmlSchemaSAXUnplug:PROC
EXTRN	_xmlSchemaValidateSetLocator:PROC
EXTRN	_xmlSwitchToEncoding:PROC
EXTRN	_xmlNewInputStream:PROC
EXTRN	_inputPush:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlXIncludeNewContext:PROC
EXTRN	_xmlXIncludeSetFlags:PROC
EXTRN	_xmlXIncludeFreeContext:PROC
EXTRN	_xmlXIncludeProcessNode:PROC
EXTRN	_xmlFreePattern:PROC
EXTRN	_xmlPatterncompile:PROC
EXTRN	_xmlPatternMatch:PROC
EXTRN	_xmlBufCreateSize:PROC
EXTRN	_xmlBufSetAllocationScheme:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufEmpty:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
EXTRN	___xmlRegisterCallbacks:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_07FHOHOHLG@include@
CONST	SEGMENT
??_C@_07FHOHOHLG@include@ DB 'include', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KJPJIHAO@vsnprintf?5failed?5?$CB?6@
CONST	SEGMENT
??_C@_0BE@KJPJIHAO@vsnprintf?5failed?5?$CB?6@ DB 'vsnprintf failed !', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MNBJMFAB@xmlTextReaderSetup?5?3?5malloc?5fai@
CONST	SEGMENT
??_C@_0CE@MNBJMFAB@xmlTextReaderSetup?5?3?5malloc?5fai@ DB 'xmlTextReader'
	DB	'Setup : malloc failed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMMPJIKP@?$CDdocument?9fragment@
CONST	SEGMENT
??_C@_0BD@FMMPJIKP@?$CDdocument?9fragment@ DB '#document-fragment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFKKGJPK@?$CDdocument@
CONST	SEGMENT
??_C@_09DFKKGJPK@?$CDdocument@ DB '#document', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBDKDMPC@?$CDcomment@
CONST	SEGMENT
??_C@_08FBDKDMPC@?$CDcomment@ DB '#comment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LIENAFBO@?$CDcdata?9section@
CONST	SEGMENT
??_C@_0P@LIENAFBO@?$CDcdata?9section@ DB '#cdata-section', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NOBOONOA@?$CDtext@
CONST	SEGMENT
??_C@_05NOBOONOA@?$CDtext@ DB '#text', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
CONST	SEGMENT
??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ DB 'http://www.'
	DB	'w3.org/2000/xmlns/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
CONST	SEGMENT
??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@ DB 'xmlNewTextRea'
	DB	'der : malloc failed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@PIJMIJNC@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GL@PIJMIJNC@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlreader.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
CONST	SEGMENT
??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@ DB 'http://www'
	DB	'.w3.org/2001/XInclude', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
CONST	SEGMENT
??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@ DB 'http://www'
	DB	'.w3.org/2003/XInclude', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOFEEJAH@Expand?5failed?5?$CB?6@
CONST	SEGMENT
??_C@_0BB@DOFEEJAH@Expand?5failed?5?$CB?6@ DB 'Expand failed !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@
CONST	SEGMENT
??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@ DB 'xmlRealloc failed !', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPMNBMMA@xmlMalloc?5failed?5?$CB?6@
CONST	SEGMENT
??_C@_0BE@MPMNBMMA@xmlMalloc?5failed?5?$CB?6@ DB 'xmlMalloc failed !', 0aH
	DB	00H						; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderWarning
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderWarning PROC				; COMDAT

; 4878 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8

; 4843 :     if (str != NULL) {

	test	esi, esi
	je	SHORT $LN4@xmlTextRea

; 4841 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]

; 4844 :         if (reader->errorFunc)

	mov	edx, DWORD PTR [ecx+108]
	test	edx, edx
	je	SHORT $LN5@xmlTextRea

; 4845 :             reader->errorFunc(reader->errorFuncArg, str, severity,

	push	eax
	push	3
	push	esi
	push	DWORD PTR [ecx+112]
	call	edx
	add	esp, 16					; 00000010H
$LN5@xmlTextRea:

; 4846 :                               (xmlTextReaderLocatorPtr) ctx);
; 4847 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlTextRea:
	pop	esi

; 4879 :     va_list ap;
; 4880 : 
; 4881 :     va_start(ap, msg);
; 4882 :     xmlTextReaderGenericError(ctxt,
; 4883 :                               XML_PARSER_SEVERITY_WARNING,
; 4884 :                               xmlTextReaderBuildMessage(msg, ap));
; 4885 :     va_end(ap);
; 4886 : }

	pop	ebp
	ret	0
_xmlTextReaderWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderError PROC				; COMDAT

; 4865 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8

; 4843 :     if (str != NULL) {

	test	esi, esi
	je	SHORT $LN4@xmlTextRea

; 4841 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]

; 4844 :         if (reader->errorFunc)

	mov	edx, DWORD PTR [ecx+108]
	test	edx, edx
	je	SHORT $LN5@xmlTextRea

; 4845 :             reader->errorFunc(reader->errorFuncArg, str, severity,

	push	eax
	push	4
	push	esi
	push	DWORD PTR [ecx+112]
	call	edx
	add	esp, 16					; 00000010H
$LN5@xmlTextRea:

; 4846 :                               (xmlTextReaderLocatorPtr) ctx);
; 4847 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlTextRea:
	pop	esi

; 4866 :     va_list ap;
; 4867 : 
; 4868 :     va_start(ap, msg);
; 4869 :     xmlTextReaderGenericError(ctxt,
; 4870 :                               XML_PARSER_SEVERITY_ERROR,
; 4871 :                               xmlTextReaderBuildMessage(msg, ap));
; 4872 :     va_end(ap);
; 4873 : 
; 4874 : }

	pop	ebp
	ret	0
_xmlTextReaderError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGenericError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_severity$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlTextReaderGenericError PROC				; COMDAT

; 4838 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlTextRea

; 4839 :     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr) ctxt;
; 4840 : 
; 4841 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]

; 4842 : 
; 4843 :     if (str != NULL) {
; 4844 :         if (reader->errorFunc)

	mov	edx, DWORD PTR [ecx+108]
	test	edx, edx
	je	SHORT $LN3@xmlTextRea

; 4845 :             reader->errorFunc(reader->errorFuncArg, str, severity,

	push	eax
	push	DWORD PTR _severity$[ebp]
	push	esi
	push	DWORD PTR [ecx+112]
	call	edx
	add	esp, 16					; 00000010H
$LN3@xmlTextRea:

; 4846 :                               (xmlTextReaderLocatorPtr) ctx);
; 4847 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlTextRea:
	pop	esi

; 4848 :     }
; 4849 : }

	pop	ebp
	ret	0
_xmlTextReaderGenericError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSchemaValidateInternal
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xsd$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlTextReaderSchemaValidateInternal PROC		; COMDAT

; 4457 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlTextRea

; 4458 :     if (reader == NULL)
; 4459 :         return(-1);
; 4460 : 
; 4461 :     if ((xsd != NULL) && (ctxt != NULL))

	mov	ebx, DWORD PTR _xsd$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN24@xmlTextRea
	test	edi, edi
	je	SHORT $LN5@xmlTextRea
$LN6@xmlTextRea:
	pop	edi

; 4555 :     return(0);
; 4556 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlTextRea:

; 4462 : 	return(-1);
; 4463 : 
; 4464 :     if (((xsd != NULL) || (ctxt != NULL)) &&

	test	edi, edi
	je	SHORT $LN25@xmlTextRea
$LN5@xmlTextRea:
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN6@xmlTextRea
$LN25@xmlTextRea:

; 4465 : 	((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||
; 4466 :         (reader->ctxt == NULL)))
; 4467 : 	return(-1);
; 4468 : 
; 4469 :     /* Cleanup previous validation stuff. */
; 4470 :     if (reader->xsdPlug != NULL) {

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 4471 : 	xmlSchemaSAXUnplug(reader->xsdPlug);

	push	eax
	call	_xmlSchemaSAXUnplug
	add	esp, 4

; 4472 : 	reader->xsdPlug = NULL;

	mov	DWORD PTR [esi+152], 0
$LN7@xmlTextRea:

; 4473 :     }
; 4474 :     if (reader->xsdValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 4475 : 	if (! reader->xsdPreserveCtxt)

	cmp	DWORD PTR [esi+144], 0
	jne	SHORT $LN9@xmlTextRea

; 4476 : 	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN9@xmlTextRea:

; 4477 : 	reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0
$LN8@xmlTextRea:

; 4478 :     }
; 4479 :     reader->xsdPreserveCtxt = 0;
; 4480 :     if (reader->xsdSchemas != NULL) {

	mov	eax, DWORD PTR [esi+136]
	mov	DWORD PTR [esi+144], 0
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 4481 : 	xmlSchemaFree(reader->xsdSchemas);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 4482 : 	reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0
$LN10@xmlTextRea:

; 4483 :     }
; 4484 : 
; 4485 :     if ((xsd == NULL) && (ctxt == NULL)) {

	test	ebx, ebx
	jne	SHORT $LN23@xmlTextRea
	test	edi, edi
	je	$LN26@xmlTextRea

; 4518 : 	    return(-1);
; 4519 : 	}
; 4520 :     } else {
; 4521 : 	/* Use the given validation context. */
; 4522 : 	reader->xsdValidCtxt = ctxt;
; 4523 : 	reader->xsdPreserveCtxt = 1;
; 4524 : 	reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR [esi+144], 1
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	push	edi
	call	_xmlSchemaSAXPlug
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+152], eax

; 4525 : 	    &(reader->ctxt->sax),
; 4526 : 	    &(reader->ctxt->userData));
; 4527 : 	if (reader->xsdPlug == NULL) {

	test	eax, eax
	jne	$LN18@xmlTextRea

; 4528 : 	    reader->xsdValidCtxt = NULL;

	pop	edi
	mov	DWORD PTR [esi+140], eax

; 4529 : 	    reader->xsdPreserveCtxt = 0;

	mov	DWORD PTR [esi+144], eax

; 4555 :     return(0);
; 4556 : }

	or	eax, -1
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlTextRea:

; 4486 : 	/* We just want to deactivate the validation, so get out. */
; 4487 : 	return(0);
; 4488 :     }
; 4489 : 
; 4490 :     if (xsd != NULL) {
; 4491 : 	xmlSchemaParserCtxtPtr pctxt;
; 4492 : 	/* Parse the schema and create validation environment. */
; 4493 : 	pctxt = xmlSchemaNewParserCtxt(xsd);

	push	ebx
	call	_xmlSchemaNewParserCtxt
	add	esp, 4
	mov	edi, eax

; 4494 : 	if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN14@xmlTextRea

; 4495 : 	    xmlSchemaSetParserErrors(pctxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	edi
	call	_xmlSchemaSetParserErrors
	add	esp, 16					; 00000010H
$LN14@xmlTextRea:

; 4496 : 		xmlTextReaderValidityErrorRelay,
; 4497 : 		xmlTextReaderValidityWarningRelay,
; 4498 : 		reader);
; 4499 : 	}
; 4500 : 	reader->xsdSchemas = xmlSchemaParse(pctxt);

	push	edi
	call	_xmlSchemaParse

; 4501 : 	xmlSchemaFreeParserCtxt(pctxt);

	push	edi
	mov	DWORD PTR [esi+136], eax
	call	_xmlSchemaFreeParserCtxt

; 4502 : 	if (reader->xsdSchemas == NULL)

	mov	eax, DWORD PTR [esi+136]
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlTextRea

; 4503 : 	    return(-1);
; 4504 : 	reader->xsdValidCtxt = xmlSchemaNewValidCtxt(reader->xsdSchemas);

	push	eax
	call	_xmlSchemaNewValidCtxt
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+140], edx

; 4505 : 	if (reader->xsdValidCtxt == NULL) {

	test	edx, edx
	jne	SHORT $LN16@xmlTextRea

; 4506 : 	    xmlSchemaFree(reader->xsdSchemas);

	push	DWORD PTR [esi+136]
	call	_xmlSchemaFree
	add	esp, 4

; 4507 : 	    reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0

; 4555 :     return(0);
; 4556 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 4508 : 	    return(-1);
; 4509 : 	}
; 4510 : 	reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,

	mov	ecx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	push	edx
	call	_xmlSchemaSAXPlug
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+152], eax

; 4511 : 	    &(reader->ctxt->sax),
; 4512 : 	    &(reader->ctxt->userData));
; 4513 : 	if (reader->xsdPlug == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlTextRea

; 4514 : 	    xmlSchemaFree(reader->xsdSchemas);

	push	DWORD PTR [esi+136]
	call	_xmlSchemaFree

; 4515 : 	    reader->xsdSchemas = NULL;
; 4516 : 	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	DWORD PTR [esi+140]
	mov	DWORD PTR [esi+136], 0
	call	_xmlSchemaFreeValidCtxt
	add	esp, 8

; 4517 : 	    reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0

; 4555 :     return(0);
; 4556 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 4530 : 	    return(-1);
; 4531 : 	}
; 4532 :     }
; 4533 :     xmlSchemaValidateSetLocator(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderLocator
	push	DWORD PTR [esi+140]
	call	_xmlSchemaValidateSetLocator
	add	esp, 12					; 0000000cH

; 4534 :                                 xmlTextReaderLocator,
; 4535 : 				(void *) reader);
; 4536 :     /*
; 4537 :     * Redirect the validation context's error channels to use
; 4538 :     * the reader channels.
; 4539 :     * TODO: In case the user provides the validation context we
; 4540 :     *   could make this redirection optional.
; 4541 :     */
; 4542 :     if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN19@xmlTextRea

; 4543 : 	xmlSchemaSetValidErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H
$LN19@xmlTextRea:

; 4544 : 			 xmlTextReaderValidityErrorRelay,
; 4545 : 			 xmlTextReaderValidityWarningRelay,
; 4546 : 			 reader);
; 4547 :     }
; 4548 : 	if (reader->sErrorFunc != NULL) {

	cmp	DWORD PTR [esi+192], 0
	je	SHORT $LN20@xmlTextRea

; 4549 : 		xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN20@xmlTextRea:

; 4550 : 			xmlTextReaderValidityStructuredRelay,
; 4551 : 			reader);
; 4552 :     }
; 4553 :     reader->xsdValidErrors = 0;

	mov	DWORD PTR [esi+148], 0

; 4554 :     reader->validate = XML_TEXTREADER_VALIDATE_XSD;

	mov	DWORD PTR [esi+8], 4
$LN26@xmlTextRea:

; 4555 :     return(0);
; 4556 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderSchemaValidateInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRelaxNGValidateInternal
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_rng$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlTextReaderRelaxNGValidateInternal PROC		; COMDAT

; 4354 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlTextRea

; 4355 :     if (reader == NULL)
; 4356 : 	return(-1);
; 4357 : 
; 4358 :     if ((rng != NULL) && (ctxt != NULL))

	mov	ebx, DWORD PTR _rng$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN21@xmlTextRea
	test	edi, edi
	je	SHORT $LN5@xmlTextRea
$LN6@xmlTextRea:
	pop	edi

; 4435 :     return(0);
; 4436 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlTextRea:

; 4359 : 	return (-1);
; 4360 : 
; 4361 :     if (((rng != NULL) || (ctxt != NULL)) &&

	test	edi, edi
	je	SHORT $LN4@xmlTextRea
$LN5@xmlTextRea:
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN6@xmlTextRea
$LN4@xmlTextRea:

; 4362 : 	((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||
; 4363 : 	 (reader->ctxt == NULL)))
; 4364 : 	return(-1);
; 4365 : 
; 4366 :     /* Cleanup previous validation stuff. */
; 4367 :     if (reader->rngValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 4368 : 	if ( !reader->rngPreserveCtxt)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN8@xmlTextRea

; 4369 : 	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);

	push	eax
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4
$LN8@xmlTextRea:

; 4370 : 	reader->rngValidCtxt = NULL;

	mov	DWORD PTR [esi+120], 0
$LN7@xmlTextRea:

; 4371 :     }
; 4372 :     reader->rngPreserveCtxt = 0;
; 4373 :     if (reader->rngSchemas != NULL) {

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+124], 0
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 4374 : 	xmlRelaxNGFree(reader->rngSchemas);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4

; 4375 : 	reader->rngSchemas = NULL;

	mov	DWORD PTR [esi+116], 0
$LN9@xmlTextRea:

; 4376 :     }
; 4377 : 
; 4378 :     if ((rng == NULL) && (ctxt == NULL)) {

	test	ebx, ebx
	jne	SHORT $LN20@xmlTextRea
	test	edi, edi
	je	SHORT $LN22@xmlTextRea

; 4408 : 	    return(-1);
; 4409 : 	}
; 4410 :     } else {
; 4411 : 	/* Use the given validation context. */
; 4412 : 	reader->rngValidCtxt = ctxt;

	mov	DWORD PTR [esi+120], edi

; 4413 : 	reader->rngPreserveCtxt = 1;

	mov	DWORD PTR [esi+124], 1
$LN16@xmlTextRea:

; 4414 :     }
; 4415 :     /*
; 4416 :     * Redirect the validation context's error channels to use
; 4417 :     * the reader channels.
; 4418 :     * TODO: In case the user provides the validation context we
; 4419 :     *	could make this redirection optional.
; 4420 :     */
; 4421 :     if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN17@xmlTextRea

; 4422 : 	xmlRelaxNGSetValidErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	edi
	call	_xmlRelaxNGSetValidErrors
	add	esp, 16					; 00000010H
$LN17@xmlTextRea:

; 4423 : 			 xmlTextReaderValidityErrorRelay,
; 4424 : 			 xmlTextReaderValidityWarningRelay,
; 4425 : 			 reader);
; 4426 :     }
; 4427 : 	if (reader->sErrorFunc != NULL) {

	cmp	DWORD PTR [esi+192], 0
	je	SHORT $LN18@xmlTextRea

; 4428 : 		xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN18@xmlTextRea:

; 4429 : 			xmlTextReaderValidityStructuredRelay,
; 4430 : 			reader);
; 4431 :     }
; 4432 :     reader->rngValidErrors = 0;

	mov	DWORD PTR [esi+128], 0

; 4433 :     reader->rngFullNode = NULL;

	mov	DWORD PTR [esi+132], 0

; 4434 :     reader->validate = XML_TEXTREADER_VALIDATE_RNG;

	mov	DWORD PTR [esi+8], 2
$LN22@xmlTextRea:

; 4435 :     return(0);
; 4436 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN20@xmlTextRea:

; 4379 : 	/* We just want to deactivate the validation, so get out. */
; 4380 : 	return(0);
; 4381 :     }
; 4382 : 
; 4383 : 
; 4384 :     if (rng != NULL) {
; 4385 : 	xmlRelaxNGParserCtxtPtr pctxt;
; 4386 : 	/* Parse the schema and create validation environment. */
; 4387 : 
; 4388 : 	pctxt = xmlRelaxNGNewParserCtxt(rng);

	push	ebx
	call	_xmlRelaxNGNewParserCtxt
	add	esp, 4
	mov	edi, eax

; 4389 : 	if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN13@xmlTextRea

; 4390 : 	    xmlRelaxNGSetParserErrors(pctxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	edi
	call	_xmlRelaxNGSetParserErrors
	add	esp, 16					; 00000010H
$LN13@xmlTextRea:

; 4391 : 		xmlTextReaderValidityErrorRelay,
; 4392 : 		xmlTextReaderValidityWarningRelay,
; 4393 : 		reader);
; 4394 : 	}
; 4395 : 	if (reader->sErrorFunc != NULL) {

	cmp	DWORD PTR [esi+192], 0
	je	SHORT $LN14@xmlTextRea

; 4396 : 	    xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN14@xmlTextRea:

; 4397 : 		xmlTextReaderValidityStructuredRelay,
; 4398 : 		reader);
; 4399 : 	}
; 4400 : 	reader->rngSchemas = xmlRelaxNGParse(pctxt);

	push	edi
	call	_xmlRelaxNGParse

; 4401 : 	xmlRelaxNGFreeParserCtxt(pctxt);

	push	edi
	mov	DWORD PTR [esi+116], eax
	call	_xmlRelaxNGFreeParserCtxt

; 4402 : 	if (reader->rngSchemas == NULL)

	mov	eax, DWORD PTR [esi+116]
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlTextRea

; 4403 : 	    return(-1);
; 4404 : 	reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(reader->rngSchemas);

	push	eax
	call	_xmlRelaxNGNewValidCtxt
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi+120], edi

; 4405 : 	if (reader->rngValidCtxt == NULL) {

	test	edi, edi
	jne	$LN16@xmlTextRea

; 4406 : 	    xmlRelaxNGFree(reader->rngSchemas);

	push	DWORD PTR [esi+116]
	call	_xmlRelaxNGFree
	add	esp, 4

; 4407 : 	    reader->rngSchemas = NULL;

	mov	DWORD PTR [esi+116], edi

; 4435 :     return(0);
; 4436 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderRelaxNGValidateInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderLocator
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_xmlTextReaderLocator PROC				; COMDAT

; 4206 : xmlTextReaderLocator(void *ctx, const char **file, unsigned long *line) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlTextRea

; 4207 :     xmlTextReaderPtr reader;
; 4208 : 
; 4209 :     if ((ctx == NULL) || ((file == NULL) && (line == NULL)))

	mov	edi, DWORD PTR _file$[ebp]
	mov	esi, DWORD PTR _line$[ebp]
	test	edi, edi
	jne	SHORT $LN17@xmlTextRea
	test	esi, esi
	jne	SHORT $LN18@xmlTextRea
$LN3@xmlTextRea:
	pop	edi

; 4244 :     }
; 4245 :     return(-1);
; 4246 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlTextRea:

; 4210 :         return(-1);
; 4211 : 
; 4212 :     if (file != NULL)
; 4213 :         *file = NULL;

	mov	DWORD PTR [edi], 0

; 4214 :     if (line != NULL)

	test	esi, esi
	je	SHORT $LN5@xmlTextRea
$LN18@xmlTextRea:

; 4215 :         *line = 0;

	mov	DWORD PTR [esi], 0
$LN5@xmlTextRea:

; 4216 : 
; 4217 :     reader = (xmlTextReaderPtr) ctx;
; 4218 :     if ((reader->ctxt != NULL) && (reader->ctxt->input != NULL)) {

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 4219 : 	if (file != NULL)

	test	edi, edi
	je	SHORT $LN7@xmlTextRea

; 4220 : 	    *file = reader->ctxt->input->filename;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi], eax
$LN7@xmlTextRea:

; 4221 : 	if (line != NULL)

	test	esi, esi
	je	SHORT $LN8@xmlTextRea

; 4222 : 	    *line = reader->ctxt->input->line;

	mov	eax, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [esi], eax
$LN8@xmlTextRea:

; 4244 :     }
; 4245 :     return(-1);
; 4246 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 4223 : 	return(0);
; 4224 :     }
; 4225 :     if (reader->node != NULL) {

	mov	eax, DWORD PTR [ebx+64]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 4226 :         long res;
; 4227 : 	int ret = 0;

	xor	ecx, ecx

; 4228 : 
; 4229 : 	if (line != NULL) {

	test	esi, esi
	je	SHORT $LN12@xmlTextRea

; 4230 : 	    res = xmlGetLineNo(reader->node);

	push	eax
	call	_xmlGetLineNo
	add	esp, 4

; 4231 : 	    if (res > 0)

	test	eax, eax
	jle	SHORT $LN11@xmlTextRea

; 4232 : 	        *line = (unsigned long) res;

	mov	DWORD PTR [esi], eax
	xor	ecx, ecx
	jmp	SHORT $LN12@xmlTextRea
$LN11@xmlTextRea:

; 4233 : 	    else
; 4234 :                 ret = -1;

	or	ecx, -1
$LN12@xmlTextRea:

; 4235 : 	}
; 4236 :         if (file != NULL) {

	test	edi, edi
	je	SHORT $LN15@xmlTextRea

; 4237 : 	    xmlDocPtr doc = reader->node->doc;

	mov	eax, DWORD PTR [ebx+64]
	mov	eax, DWORD PTR [eax+32]

; 4238 : 	    if ((doc != NULL) && (doc->URL != NULL))

	test	eax, eax
	je	SHORT $LN14@xmlTextRea
	mov	eax, DWORD PTR [eax+72]
	test	eax, eax
	je	SHORT $LN14@xmlTextRea

; 4239 : 	        *file = (const char *) doc->URL;

	mov	DWORD PTR [edi], eax

; 4242 : 	}
; 4243 : 	return(ret);

	mov	eax, ecx
	pop	edi

; 4244 :     }
; 4245 :     return(-1);
; 4246 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlTextRea:

; 4240 : 	    else
; 4241 :                 ret = -1;

	or	ecx, -1
$LN15@xmlTextRea:
	pop	edi

; 4244 :     }
; 4245 :     return(-1);
; 4246 : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderLocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidityStructuredRelay
_TEXT	SEGMENT
_userData$ = 8						; size = 4
_error$ = 12						; size = 4
_xmlTextReaderValidityStructuredRelay PROC		; COMDAT

; 4122 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _userData$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	test	ecx, ecx
	je	SHORT $LN2@xmlTextRea

; 4123 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) userData;
; 4124 : 
; 4125 :     if (reader->sErrorFunc) {
; 4126 :         reader->sErrorFunc(reader->errorFuncArg, error);

	push	DWORD PTR _error$[ebp]
	push	DWORD PTR [eax+112]
	call	ecx

; 4127 :     } else {
; 4128 :         xmlTextReaderStructuredError(reader, error);
; 4129 :     }
; 4130 : }

	add	esp, 8
	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 4858 :     if (error && reader->sErrorFunc) {

	mov	ecx, DWORD PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlTextRea
	mov	eax, DWORD PTR [eax+272]
	mov	edx, DWORD PTR [eax+192]
	test	edx, edx
	je	SHORT $LN6@xmlTextRea

; 4859 :         reader->sErrorFunc(reader->errorFuncArg, (xmlErrorPtr) error);

	push	ecx
	push	DWORD PTR [eax+112]
	call	edx

; 4127 :     } else {
; 4128 :         xmlTextReaderStructuredError(reader, error);
; 4129 :     }
; 4130 : }

	add	esp, 8
$LN6@xmlTextRea:
	pop	ebp
	ret	0
_xmlTextReaderValidityStructuredRelay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderStructuredError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_xmlTextReaderStructuredError PROC			; COMDAT

; 4853 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _error$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlTextRea

; 4854 :     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr) ctxt;
; 4855 : 
; 4856 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 4857 : 
; 4858 :     if (error && reader->sErrorFunc) {

	mov	edx, DWORD PTR [eax+192]
	test	edx, edx
	je	SHORT $LN2@xmlTextRea

; 4859 :         reader->sErrorFunc(reader->errorFuncArg, (xmlErrorPtr) error);

	push	ecx
	push	DWORD PTR [eax+112]
	call	edx
	add	esp, 8
$LN2@xmlTextRea:

; 4860 :     }
; 4861 : }

	pop	ebp
	ret	0
_xmlTextReaderStructuredError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidityWarningRelay
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderValidityWarningRelay PROC			; COMDAT

; 4096 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	test	ecx, ecx
	jne	SHORT $LN2@xmlTextRea

; 4097 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx;
; 4098 : 
; 4099 :     char *str;
; 4100 : 
; 4101 :     va_list ap;
; 4102 : 
; 4103 :     va_start(ap, msg);
; 4104 :     str = xmlTextReaderBuildMessage(msg, ap);
; 4105 :     if (!reader->errorFunc) {
; 4106 :         xmlTextReaderValidityWarning(ctx, "%s", str);

	push	esi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	call	_xmlTextReaderValidityWarning
	add	esp, 12					; 0000000cH

; 4107 :     } else {

	jmp	SHORT $LN3@xmlTextRea
$LN2@xmlTextRea:

; 4108 :         reader->errorFunc(reader->errorFuncArg, str,

	push	0
	push	1
	push	esi
	push	DWORD PTR [eax+112]
	call	ecx
	add	esp, 16					; 00000010H
$LN3@xmlTextRea:

; 4109 :                           XML_PARSER_SEVERITY_VALIDITY_WARNING,
; 4110 :                           NULL /* locator */ );
; 4111 :     }
; 4112 :     if (str != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlTextRea

; 4113 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlTextRea:
	pop	esi

; 4114 :     va_end(ap);
; 4115 : }

	pop	ebp
	ret	0
_xmlTextReaderValidityWarningRelay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidityErrorRelay
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderValidityErrorRelay PROC			; COMDAT

; 4073 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	DWORD PTR _msg$[ebp]
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	test	ecx, ecx
	jne	SHORT $LN2@xmlTextRea

; 4074 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx;
; 4075 : 
; 4076 :     char *str;
; 4077 : 
; 4078 :     va_list ap;
; 4079 : 
; 4080 :     va_start(ap, msg);
; 4081 :     str = xmlTextReaderBuildMessage(msg, ap);
; 4082 :     if (!reader->errorFunc) {
; 4083 :         xmlTextReaderValidityError(ctx, "%s", str);

	push	esi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	call	_xmlTextReaderValidityError
	add	esp, 12					; 0000000cH

; 4084 :     } else {

	jmp	SHORT $LN3@xmlTextRea
$LN2@xmlTextRea:

; 4085 :         reader->errorFunc(reader->errorFuncArg, str,

	push	0
	push	2
	push	esi
	push	DWORD PTR [eax+112]
	call	ecx
	add	esp, 16					; 00000010H
$LN3@xmlTextRea:

; 4086 :                           XML_PARSER_SEVERITY_VALIDITY_ERROR,
; 4087 :                           NULL /* locator */ );
; 4088 :     }
; 4089 :     if (str != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlTextRea

; 4090 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlTextRea:
	pop	esi

; 4091 :     va_end(ap);
; 4092 : }

	pop	ebp
	ret	0
_xmlTextReaderValidityErrorRelay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidityWarning
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderValidityWarning PROC			; COMDAT

; 4910 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 4911 :     va_list ap;
; 4912 : 
; 4913 :     int len = xmlStrlen((const xmlChar *) msg);
; 4914 : 
; 4915 :     if ((len != 0) && (msg[len - 1] != ':')) {

	mov	ecx, DWORD PTR _msg$[ebp]
	cmp	BYTE PTR [eax+ecx-1], 58		; 0000003aH
	je	SHORT $LN5@xmlTextRea

; 4916 :         /*
; 4917 :          * some callbacks only report locator information:
; 4918 :          * skip them (mimicking behaviour in error.c)
; 4919 :          */
; 4920 :         va_start(ap, msg);
; 4921 :         xmlTextReaderGenericError(ctxt,

	push	esi
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	ecx
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8

; 4843 :     if (str != NULL) {

	test	esi, esi
	je	SHORT $LN8@xmlTextRea

; 4841 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]

; 4844 :         if (reader->errorFunc)

	mov	edx, DWORD PTR [ecx+108]
	test	edx, edx
	je	SHORT $LN6@xmlTextRea

; 4845 :             reader->errorFunc(reader->errorFuncArg, str, severity,

	push	eax
	push	1
	push	esi
	push	DWORD PTR [ecx+112]
	call	edx
	add	esp, 16					; 00000010H
$LN6@xmlTextRea:

; 4846 :                               (xmlTextReaderLocatorPtr) ctx);
; 4847 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlTextRea:
	pop	esi
$LN5@xmlTextRea:

; 4922 :                                   XML_PARSER_SEVERITY_VALIDITY_WARNING,
; 4923 :                                   xmlTextReaderBuildMessage(msg, ap));
; 4924 :         va_end(ap);
; 4925 :     }
; 4926 : }

	pop	ebp
	ret	0
_xmlTextReaderValidityWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidityError
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlTextReaderValidityError PROC			; COMDAT

; 4890 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	call	_xmlStrlen
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $LN5@xmlTextRea

; 4891 :     va_list ap;
; 4892 : 
; 4893 :     int len = xmlStrlen((const xmlChar *) msg);
; 4894 : 
; 4895 :     if ((len > 1) && (msg[len - 2] != ':')) {

	mov	ecx, DWORD PTR _msg$[ebp]
	cmp	BYTE PTR [eax+ecx-2], 58		; 0000003aH
	je	SHORT $LN5@xmlTextRea

; 4896 :         /*
; 4897 :          * some callbacks only report locator information:
; 4898 :          * skip them (mimicking behaviour in error.c)
; 4899 :          */
; 4900 :         va_start(ap, msg);
; 4901 :         xmlTextReaderGenericError(ctxt,

	push	esi
	lea	eax, DWORD PTR _msg$[ebp+4]
	push	eax
	push	ecx
	call	_xmlTextReaderBuildMessage
	mov	esi, eax
	add	esp, 8

; 4843 :     if (str != NULL) {

	test	esi, esi
	je	SHORT $LN8@xmlTextRea

; 4841 :     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]

; 4844 :         if (reader->errorFunc)

	mov	edx, DWORD PTR [ecx+108]
	test	edx, edx
	je	SHORT $LN6@xmlTextRea

; 4845 :             reader->errorFunc(reader->errorFuncArg, str, severity,

	push	eax
	push	2
	push	esi
	push	DWORD PTR [ecx+112]
	call	edx
	add	esp, 16					; 00000010H
$LN6@xmlTextRea:

; 4846 :                               (xmlTextReaderLocatorPtr) ctx);
; 4847 :         xmlFree(str);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlTextRea:
	pop	esi
$LN5@xmlTextRea:

; 4902 :                                   XML_PARSER_SEVERITY_VALIDITY_ERROR,
; 4903 :                                   xmlTextReaderBuildMessage(msg, ap));
; 4904 :         va_end(ap);
; 4905 :     }
; 4906 : }

	pop	ebp
	ret	0
_xmlTextReaderValidityError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderBuildMessage
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_ap$ = 12						; size = 4
_xmlTextReaderBuildMessage PROC				; COMDAT

; 4727 : xmlTextReaderBuildMessage(const char *msg, va_list ap) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	xor	edi, edi
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	push	DWORD PTR _ap$[ebp]
	mov	ecx, eax
	push	edi
	push	DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edi
	push	edi
	push	DWORD PTR [ecx+4]
	or	eax, 2
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c

; 4738 :         if (chars < 0) {

	test	eax, eax
	js	SHORT $LN16@xmlTextRea
$LL2@xmlTextRea:

; 4740 : 	    if (str)
; 4741 : 		xmlFree(str);
; 4742 : 	    return NULL;
; 4743 : 	}
; 4744 : 	if ((chars < size) || (size == MAX_ERR_MSG_SIZE))

	cmp	eax, esi
	jl	$LN7@xmlTextRea
	cmp	esi, 64000				; 0000fa00H
	je	$LN7@xmlTextRea

; 4745 :             break;
; 4746 :         if (chars < MAX_ERR_MSG_SIZE)
; 4747 : 	size = chars + 1;

	lea	esi, DWORD PTR [eax+1]
	cmp	eax, 64000				; 0000fa00H
	jl	SHORT $LN9@xmlTextRea

; 4748 : 	else
; 4749 : 		size = MAX_ERR_MSG_SIZE;

	mov	esi, 64000				; 0000fa00H
$LN9@xmlTextRea:

; 4750 :         if ((larger = (char *) xmlRealloc(str, size)) == NULL) {

	push	esi
	push	edi
	call	DWORD PTR _xmlRealloc
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN18@xmlTextRea

; 4755 :         }
; 4756 :         str = larger;

	mov	edi, ebx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	push	DWORD PTR _ap$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	esi
	push	ebx
	push	DWORD PTR [ecx+4]
	or	eax, 2
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c

; 4738 :         if (chars < 0) {

	test	eax, eax
	jns	SHORT $LL2@xmlTextRea
$LN16@xmlTextRea:

; 4739 : 	    xmlGenericError(xmlGenericErrorContext, "vsnprintf failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@KJPJIHAO@vsnprintf?5failed?5?$CB?6@
$LN23@xmlTextRea:

; 4754 :             return NULL;

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN11@xmlTextRea
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlTextRea:

; 4760 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 4751 : 	    xmlGenericError(xmlGenericErrorContext, "xmlRealloc failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@

; 4752 : 	    if (str)
; 4753 :                 xmlFree(str);

	jmp	SHORT $LN23@xmlTextRea
$LN7@xmlTextRea:

; 4757 :     }
; 4758 : 
; 4759 :     return str;

	mov	eax, edi
	pop	edi

; 4760 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderBuildMessage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderCollectSiblings
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlTextReaderCollectSiblings PROC			; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlTextRea

; 1246 :     xmlBufferPtr buffer;
; 1247 :     xmlChar *ret;
; 1248 : 
; 1249 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN8@xmlTextRea

; 1251 : 
; 1252 :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	ebx, eax

; 1253 :     if (buffer == NULL)

	test	ebx, ebx
	je	SHORT $LN8@xmlTextRea
	push	edi
$LL18@xmlTextRea:

; 1257 :        switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN11@xmlTextRea
	add	eax, -3					; fffffffdH
	cmp	eax, 1
	ja	SHORT $LN2@xmlTextRea

; 1258 :        case XML_TEXT_NODE:
; 1259 :        case XML_CDATA_SECTION_NODE:
; 1260 :            xmlBufferCat(buffer, node->content);

	push	DWORD PTR [esi+40]
	push	ebx
	call	_xmlBufferCat
	add	esp, 8

; 1261 :            break;

	jmp	SHORT $LN2@xmlTextRea
$LN11@xmlTextRea:

; 1262 :        case XML_ELEMENT_NODE: {
; 1263 :            xmlChar *tmp;
; 1264 : 
; 1265 : 	   tmp = xmlTextReaderCollectSiblings(node->children);

	push	DWORD PTR [esi+12]
	call	_xmlTextReaderCollectSiblings
	mov	edi, eax

; 1266 :            xmlBufferCat(buffer, tmp);

	push	edi
	push	ebx
	call	_xmlBufferCat

; 1267 : 	   xmlFree(tmp);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN2@xmlTextRea:

; 1254 :        return NULL;
; 1255 : 
; 1256 :     for ( ; node != NULL; node = node->next) {

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL18@xmlTextRea

; 1268 : 	   break;
; 1269 :        }
; 1270 :        default:
; 1271 :            break;
; 1272 :        }
; 1273 :     }
; 1274 :     ret = buffer->content;

	mov	esi, DWORD PTR [ebx]

; 1275 :     buffer->content = NULL;
; 1276 :     xmlBufferFree(buffer);

	push	ebx
	mov	DWORD PTR [ebx], 0
	call	_xmlBufferFree
	add	esp, 4

; 1277 :     return(ret);

	mov	eax, esi
	pop	edi
	pop	esi

; 1278 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlTextRea:
	pop	esi

; 1250 :         return(NULL);

	xor	eax, eax

; 1278 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderCollectSiblings ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderDoExpand
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderDoExpand PROC				; COMDAT

; 1210 : xmlTextReaderDoExpand(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlTextRea

; 1211 :     int val;
; 1212 : 
; 1213 :     if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))

	cmp	DWORD PTR [esi+64], 0
	je	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN6@xmlTextRea
$LL4@xmlTextRea:

; 1214 :         return(-1);
; 1215 :     do {
; 1216 : 	if (reader->ctxt->instate == XML_PARSER_EOF) return(1);

	mov	ecx, DWORD PTR [esi+20]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN30@xmlTextRea

; 1217 : 
; 1218 :         if (xmlTextReaderGetSuccessor(reader->node) != NULL)

	mov	eax, DWORD PTR [esi+64]

; 1188 :     if (cur == NULL) return(NULL) ; /* ERROR */

	test	eax, eax
	je	SHORT $LN15@xmlTextRea

; 1189 :     if (cur->next != NULL) return(cur->next) ;

	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN30@xmlTextRea
	npad	6
$LL16@xmlTextRea:

; 1190 :     do {
; 1191 :         cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 1192 :         if (cur == NULL) break;

	test	eax, eax
	je	SHORT $LN15@xmlTextRea

; 1193 :         if (cur->next != NULL) return(cur->next);

	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LL16@xmlTextRea

; 1230 :     return(1);
; 1231 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 1219 : 	    return(1);
; 1220 : 	if (reader->ctxt->nodeNr < reader->depth)

	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR [esi+72]
	jl	SHORT $LN30@xmlTextRea

; 1221 : 	    return(1);
; 1222 : 	if (reader->mode == XML_TEXTREADER_MODE_EOF)

	cmp	DWORD PTR [esi], 3
	je	SHORT $LN30@xmlTextRea

; 1223 : 	    return(1);
; 1224 : 	val = xmlTextReaderPushData(reader);

	push	esi
	call	_xmlTextReaderPushData
	add	esp, 4

; 1225 : 	if (val < 0){

	test	eax, eax
	js	SHORT $LN31@xmlTextRea

; 1227 : 	    return(-1);
; 1228 : 	}
; 1229 :     } while(reader->mode != XML_TEXTREADER_MODE_EOF);

	cmp	DWORD PTR [esi], 3
	jne	SHORT $LL4@xmlTextRea
$LN30@xmlTextRea:

; 1230 :     return(1);
; 1231 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN31@xmlTextRea:

; 1226 : 	    reader->mode = XML_TEXTREADER_MODE_ERROR;

	mov	DWORD PTR [esi], 2
$LN6@xmlTextRea:

; 1230 :     return(1);
; 1231 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderDoExpand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetSuccessor
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlTextReaderGetSuccessor PROC				; COMDAT

; 1187 : xmlTextReaderGetSuccessor(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 1188 :     if (cur == NULL) return(NULL) ; /* ERROR */
; 1189 :     if (cur->next != NULL) return(cur->next) ;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN1@xmlTextRea
	npad	5
$LL4@xmlTextRea:

; 1190 :     do {
; 1191 :         cur = cur->parent;

	mov	ecx, DWORD PTR [ecx+20]

; 1192 :         if (cur == NULL) break;

	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 1193 :         if (cur->next != NULL) return(cur->next);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LL4@xmlTextRea

; 1196 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 1194 :     } while (cur != NULL);
; 1195 :     return(cur);

	xor	eax, eax
$LN1@xmlTextRea:

; 1196 : }

	pop	ebp
	ret	0
_xmlTextReaderGetSuccessor ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidateEntity
_TEXT	SEGMENT
_ctxt$1$ = -4						; size = 4
_oldnode$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderValidateEntity PROC			; COMDAT

; 1090 : xmlTextReaderValidateEntity(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _reader$[ebp]
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR [ebx+64]
	mov	esi, edi
	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR _oldnode$1$[ebp], edi
	mov	DWORD PTR _ctxt$1$[ebp], ecx
$LL4@xmlTextRea:

; 1091 :     xmlNodePtr oldnode = reader->node;
; 1092 :     xmlNodePtr node = reader->node;
; 1093 :     xmlParserCtxtPtr ctxt = reader->ctxt;
; 1094 : 
; 1095 :     do {
; 1096 : 	if (node->type == XML_ENTITY_REF_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 5
	jne	SHORT $LN10@xmlTextRea

; 1097 : 	    /*
; 1098 : 	     * Case where the underlying tree is not availble, lookup the entity
; 1099 : 	     * and walk it.
; 1100 : 	     */
; 1101 : 	    if ((node->children == NULL) && (ctxt->sax != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN76@xmlTextRea
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea

; 1102 : 		(ctxt->sax->getEntity != NULL)) {
; 1103 : 		node->children = (xmlNodePtr)

	push	DWORD PTR [esi+8]
	push	ecx
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 1104 : 		    ctxt->sax->getEntity(ctxt, node->name);
; 1105 : 	    }
; 1106 : 
; 1107 : 	    if ((node->children != NULL) &&
; 1108 : 		(node->children->type == XML_ENTITY_DECL) &&

	test	eax, eax
	je	SHORT $LN13@xmlTextRea
$LN76@xmlTextRea:
	cmp	DWORD PTR [eax+4], 17			; 00000011H
	jne	SHORT $LN13@xmlTextRea
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN13@xmlTextRea

; 1109 : 		(node->children->children != NULL)) {
; 1110 : 		xmlTextReaderEntPush(reader, node);

	push	esi
	push	ebx
	call	_xmlTextReaderEntPush

; 1111 : 		node = node->children->children;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	mov	esi, DWORD PTR [eax+12]

; 1112 : 		continue;

	jmp	$LN2@xmlTextRea
$LN13@xmlTextRea:

; 1113 : 	    } else {
; 1114 : 		/*
; 1115 : 		 * The error has probably be raised already.
; 1116 : 		 */
; 1117 : 		if (node == oldnode)

	cmp	esi, edi
	je	$LN32@xmlTextRea

; 1118 : 		    break;
; 1119 : 		node = node->next;

	mov	esi, DWORD PTR [esi+24]

; 1120 : 	    }

	jmp	SHORT $LN18@xmlTextRea
$LN10@xmlTextRea:

; 1121 : #ifdef LIBXML_REGEXP_ENABLED
; 1122 : 	} else if (node->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	SHORT $LN16@xmlTextRea

; 1123 : 	    reader->node = node;
; 1124 : 	    xmlTextReaderValidatePush(reader);

	push	ebx
	mov	DWORD PTR [ebx+64], esi
	call	_xmlTextReaderValidatePush
	add	esp, 4
	jmp	SHORT $LN18@xmlTextRea
$LN16@xmlTextRea:

; 1125 : 	} else if ((node->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN19@xmlTextRea
	cmp	eax, 4
	jne	SHORT $LN18@xmlTextRea
$LN19@xmlTextRea:

; 1126 : 		   (node->type == XML_CDATA_SECTION_NODE)) {
; 1127 :             xmlTextReaderValidateCData(reader, node->content,

	push	DWORD PTR [esi+40]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [esi+40]
	push	ebx
	call	_xmlTextReaderValidateCData
	add	esp, 16					; 00000010H
$LN18@xmlTextRea:

; 1128 : 	                               xmlStrlen(node->content));
; 1129 : #endif
; 1130 : 	}
; 1131 : 
; 1132 : 	/*
; 1133 : 	 * go to next node
; 1134 : 	 */
; 1135 : 	if (node->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	$LN77@xmlTextRea

; 1136 : 	    node = node->children;
; 1137 : 	    continue;
; 1138 : 	} else if (node->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN22@xmlTextRea

; 1139 : 	    xmlTextReaderValidatePop(reader);

	push	ebx
	call	_xmlTextReaderValidatePop
	add	esp, 4

; 1140 : 	}
; 1141 : 	if (node->next != NULL) {
; 1142 : 	    node = node->next;
; 1143 : 	    continue;

	jmp	$LN22@xmlTextRea
$LL7@xmlTextRea:

; 1144 : 	}
; 1145 : 	do {
; 1146 : 	    node = node->parent;

	mov	esi, DWORD PTR [esi+20]

; 1147 : 	    if (node->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN59@xmlTextRea

; 1148 : 	        xmlNodePtr tmp;
; 1149 : 		if (reader->entNr == 0) {

	cmp	DWORD PTR [ebx+96], 0
	jne	SHORT $LN26@xmlTextRea

; 1150 : 		    while ((tmp = node->last) != NULL) {

	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	SHORT $LN72@xmlTextRea
	npad	7
$LL8@xmlTextRea:

; 1151 : 			if ((tmp->extra & NODE_IS_PRESERVED) == 0) {

	test	BYTE PTR [edi+58], 2
	jne	SHORT $LN72@xmlTextRea

; 1152 : 			    xmlUnlinkNode(tmp);

	push	edi
	call	_xmlUnlinkNode

; 1153 : 			    xmlTextReaderFreeNode(reader, tmp);

	push	edi
	push	ebx
	call	_xmlTextReaderFreeNode
	mov	edi, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	test	edi, edi
	jne	SHORT $LL8@xmlTextRea
$LN72@xmlTextRea:

; 1154 : 			} else
; 1155 : 			    break;
; 1156 : 		    }
; 1157 : 		}
; 1158 : 		reader->node = node;

	mov	edi, DWORD PTR _oldnode$1$[ebp]
$LN26@xmlTextRea:

; 1159 : 		xmlTextReaderValidatePop(reader);

	push	ebx
	mov	DWORD PTR [ebx+64], esi
	call	_xmlTextReaderValidatePop
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN59@xmlTextRea:

; 1160 : 	    }
; 1161 : 	    if ((node->type == XML_ENTITY_DECL) &&
; 1162 : 		(reader->ent != NULL) && (reader->ent->children == node)) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN34@xmlTextRea
	mov	eax, DWORD PTR [ebx+92]
	test	eax, eax
	je	SHORT $LN34@xmlTextRea
	cmp	DWORD PTR [eax+12], esi
	jne	SHORT $LN34@xmlTextRea

; 643  :     if (reader->entNr <= 0)

	mov	eax, DWORD PTR [ebx+96]
	test	eax, eax
	jg	SHORT $LN35@xmlTextRea

; 644  :         return (NULL);

	xor	esi, esi
	jmp	SHORT $LN34@xmlTextRea
$LN35@xmlTextRea:

; 645  :     reader->entNr--;
; 646  :     if (reader->entNr > 0)

	mov	ecx, DWORD PTR [ebx+104]
	dec	eax
	mov	DWORD PTR [ebx+96], eax
	test	eax, eax
	jle	SHORT $LN36@xmlTextRea

; 647  :         reader->ent = reader->entTab[reader->entNr - 1];

	mov	edx, DWORD PTR [ecx+eax*4-4]
	jmp	SHORT $LN37@xmlTextRea
$LN36@xmlTextRea:

; 648  :     else
; 649  :         reader->ent = NULL;

	xor	edx, edx
$LN37@xmlTextRea:

; 650  :     ret = reader->entTab[reader->entNr];

	mov	DWORD PTR [ebx+92], edx
	mov	esi, DWORD PTR [ecx+eax*4]

; 651  :     reader->entTab[reader->entNr] = NULL;

	mov	DWORD PTR [ecx+eax*4], 0
$LN34@xmlTextRea:

; 1163 : 		node = xmlTextReaderEntPop(reader);
; 1164 : 	    }
; 1165 : 	    if (node == oldnode)

	cmp	esi, edi
	je	SHORT $LN2@xmlTextRea
$LN22@xmlTextRea:

; 1166 : 		break;
; 1167 : 	    if (node->next != NULL) {
; 1168 : 		node = node->next;
; 1169 : 		break;
; 1170 : 	    }
; 1171 : 	} while ((node != NULL) && (node != oldnode));
; 1172 :     } while ((node != NULL) && (node != oldnode));

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	$LL7@xmlTextRea
$LN77@xmlTextRea:
	mov	esi, eax
$LN2@xmlTextRea:
	test	esi, esi
	je	SHORT $LN32@xmlTextRea
	cmp	esi, edi
	je	SHORT $LN32@xmlTextRea
	mov	ecx, DWORD PTR _ctxt$1$[ebp]
	jmp	$LL4@xmlTextRea
$LN32@xmlTextRea:

; 1173 :     reader->node = oldnode;
; 1174 : }

	mov	DWORD PTR [ebx+64], edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderValidateEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidatePop
_TEXT	SEGMENT
_qname$3$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderValidatePop PROC				; COMDAT

; 1039 : xmlTextReaderValidatePop(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	cmp	DWORD PTR [edi+8], 1
	mov	ebx, DWORD PTR [edi+64]
	jne	SHORT $LN6@xmlTextRea

; 1040 :     xmlNodePtr node = reader->node;
; 1041 : 
; 1042 : #ifdef LIBXML_VALID_ENABLED
; 1043 :     if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
; 1044 :         (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [eax+104], 1
	jne	SHORT $LN6@xmlTextRea

; 1045 : 	if ((node->ns == NULL) || (node->ns->prefix == NULL)) {

	mov	ecx, DWORD PTR [ebx+36]
	push	esi
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 1047 : 				    reader->ctxt->myDoc, node, node->name);
; 1048 : 	} else {
; 1049 : 	    /* TODO use the BuildQName interface */
; 1050 : 	    xmlChar *qname;
; 1051 : 
; 1052 : 	    qname = xmlStrdup(node->ns->prefix);

	push	ecx
	call	_xmlStrdup

; 1053 : 	    qname = xmlStrcat(qname, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 1054 : 	    qname = xmlStrcat(qname, node->name);

	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlStrcat

; 1055 : 	    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,

	mov	ecx, DWORD PTR [edi+20]
	mov	esi, ecx
	push	eax
	push	ebx
	mov	DWORD PTR _qname$3$[ebp], eax
	push	DWORD PTR [ecx+8]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	_xmlValidatePopElement
	and	DWORD PTR [esi+100], eax
	add	esp, 36					; 00000024H

; 1056 : 				    reader->ctxt->myDoc, node, qname);
; 1057 : 	    if (qname != NULL)

	mov	eax, DWORD PTR _qname$3$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea

; 1058 : 		xmlFree(qname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN12@xmlTextRea
$LN5@xmlTextRea:

; 1046 : 	    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,

	push	DWORD PTR [ebx+8]
	mov	esi, eax
	push	ebx
	push	DWORD PTR [eax+8]
	add	eax, 108				; 0000006cH
	push	eax
	call	_xmlValidatePopElement
	add	esp, 16					; 00000010H
	and	DWORD PTR [esi+100], eax
$LN12@xmlTextRea:
	pop	esi
$LN6@xmlTextRea:

; 1059 : 	}
; 1060 :     }
; 1061 : #endif /* LIBXML_VALID_ENABLED */
; 1062 : #ifdef LIBXML_SCHEMAS_ENABLED
; 1063 :     if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&

	cmp	DWORD PTR [edi+8], 2
	jne	SHORT $LN10@xmlTextRea
	mov	ecx, DWORD PTR [edi+120]
	test	ecx, ecx
	je	SHORT $LN10@xmlTextRea

; 1064 :                (reader->rngValidCtxt != NULL)) {
; 1065 : 	int ret;
; 1066 : 
; 1067 : 	if (reader->rngFullNode != NULL) {

	mov	eax, DWORD PTR [edi+132]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 1068 : 	    if (node == reader->rngFullNode)

	cmp	ebx, eax
	jne	SHORT $LN10@xmlTextRea

; 1069 : 	        reader->rngFullNode = NULL;

	mov	DWORD PTR [edi+132], 0
	pop	edi

; 1077 :     }
; 1078 : #endif
; 1079 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 1070 : 	    return;
; 1071 : 	}
; 1072 : 	ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,

	mov	eax, DWORD PTR [edi+20]
	push	ebx
	push	DWORD PTR [eax+8]
	push	ecx
	call	_xmlRelaxNGValidatePopElement
	add	esp, 12					; 0000000cH

; 1073 : 	                                   reader->ctxt->myDoc,
; 1074 : 					   node);
; 1075 : 	if (ret != 1)

	cmp	eax, 1
	je	SHORT $LN10@xmlTextRea

; 1076 : 	    reader->rngValidErrors++;

	inc	DWORD PTR [edi+128]
$LN10@xmlTextRea:
	pop	edi

; 1077 :     }
; 1078 : #endif
; 1079 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderValidatePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidateCData
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlTextReaderValidateCData PROC			; COMDAT

; 1011 :                            const xmlChar *data, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, 1
	jne	SHORT $LN2@xmlTextRea

; 1012 : #ifdef LIBXML_VALID_ENABLED
; 1013 :     if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
; 1014 :         (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {

	mov	edi, DWORD PTR [esi+20]
	test	edi, edi
	je	SHORT $LN5@xmlTextRea
	cmp	DWORD PTR [edi+104], 1
	jne	SHORT $LN5@xmlTextRea

; 1015 : 	reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,

	push	DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR [edi+108]
	push	ecx
	push	eax
	call	_xmlValidatePushCData
	mov	ecx, DWORD PTR _data$[ebp]
	add	esp, 12					; 0000000cH
	and	DWORD PTR [edi+100], eax
	mov	eax, DWORD PTR [esi+8]
$LN2@xmlTextRea:

; 1016 : 	                                            data, len);
; 1017 :     }
; 1018 : #endif /* LIBXML_VALID_ENABLED */
; 1019 : #ifdef LIBXML_SCHEMAS_ENABLED
; 1020 :     if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&

	cmp	eax, 2
	jne	SHORT $LN5@xmlTextRea
	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 1021 :                (reader->rngValidCtxt != NULL)) {
; 1022 : 	int ret;
; 1023 : 
; 1024 : 	if (reader->rngFullNode != NULL) return;

	cmp	DWORD PTR [esi+132], 0
	jne	SHORT $LN5@xmlTextRea

; 1025 : 	ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);

	push	DWORD PTR _len$[ebp]
	push	ecx
	push	eax
	call	_xmlRelaxNGValidatePushCData
	add	esp, 12					; 0000000cH

; 1026 : 	if (ret != 1)

	cmp	eax, 1
	je	SHORT $LN5@xmlTextRea

; 1027 : 	    reader->rngValidErrors++;

	inc	DWORD PTR [esi+128]
$LN5@xmlTextRea:
	pop	edi

; 1028 :     }
; 1029 : #endif
; 1030 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderValidateCData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValidatePush
_TEXT	SEGMENT
_qname$3$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderValidatePush PROC				; COMDAT

; 948  : xmlTextReaderValidatePush(xmlTextReaderPtr reader ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	cmp	DWORD PTR [edi+8], 1
	mov	ebx, DWORD PTR [edi+64]
	jne	SHORT $LN6@xmlTextRea

; 949  :     xmlNodePtr node = reader->node;
; 950  : 
; 951  : #ifdef LIBXML_VALID_ENABLED
; 952  :     if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&
; 953  :         (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [eax+104], 1
	jne	SHORT $LN6@xmlTextRea

; 954  : 	if ((node->ns == NULL) || (node->ns->prefix == NULL)) {

	mov	ecx, DWORD PTR [ebx+36]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 956  : 				    reader->ctxt->myDoc, node, node->name);
; 957  : 	} else {
; 958  : 	    /* TODO use the BuildQName interface */
; 959  : 	    xmlChar *qname;
; 960  : 
; 961  : 	    qname = xmlStrdup(node->ns->prefix);

	push	ecx
	call	_xmlStrdup

; 962  : 	    qname = xmlStrcat(qname, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 963  : 	    qname = xmlStrcat(qname, node->name);

	push	DWORD PTR [ebx+8]
	push	eax
	call	_xmlStrcat

; 964  : 	    reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,

	mov	ecx, DWORD PTR [edi+20]
	mov	esi, ecx
	push	eax
	push	ebx
	mov	DWORD PTR _qname$3$[ebp], eax
	push	DWORD PTR [ecx+8]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	_xmlValidatePushElement
	and	DWORD PTR [esi+100], eax
	add	esp, 36					; 00000024H

; 965  : 				    reader->ctxt->myDoc, node, qname);
; 966  : 	    if (qname != NULL)

	mov	eax, DWORD PTR _qname$3$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 967  : 		xmlFree(qname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN6@xmlTextRea
$LN5@xmlTextRea:

; 955  : 	    reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,

	push	DWORD PTR [ebx+8]
	mov	esi, eax
	push	ebx
	push	DWORD PTR [eax+8]
	add	eax, 108				; 0000006cH
	push	eax
	call	_xmlValidatePushElement
	add	esp, 16					; 00000010H
	and	DWORD PTR [esi+100], eax
$LN6@xmlTextRea:

; 968  : 	}
; 969  :     }
; 970  : #endif /* LIBXML_VALID_ENABLED */
; 971  : #ifdef LIBXML_SCHEMAS_ENABLED
; 972  :     if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&

	cmp	DWORD PTR [edi+8], 2
	jne	SHORT $LN12@xmlTextRea
	mov	ecx, DWORD PTR [edi+120]
	test	ecx, ecx
	je	SHORT $LN12@xmlTextRea

; 973  :                (reader->rngValidCtxt != NULL)) {
; 974  : 	int ret;
; 975  : 
; 976  : 	if (reader->rngFullNode != NULL) return;

	cmp	DWORD PTR [edi+132], 0
	jne	SHORT $LN12@xmlTextRea

; 977  : 	ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,

	mov	eax, DWORD PTR [edi+20]
	push	ebx
	push	DWORD PTR [eax+8]
	push	ecx
	call	_xmlRelaxNGValidatePushElement
	add	esp, 12					; 0000000cH

; 978  : 	                                    reader->ctxt->myDoc,
; 979  : 					    node);
; 980  : 	if (ret == 0) {

	test	eax, eax
	jne	SHORT $LN11@xmlTextRea

; 981  : 	    /*
; 982  : 	     * this element requires a full tree
; 983  : 	     */
; 984  : 	    node = xmlTextReaderExpand(reader);

	push	edi
	call	_xmlTextReaderExpand
	mov	esi, eax
	add	esp, 4

; 985  : 	    if (node == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlTextRea

; 986  : printf("Expand failed !\n");

	push	OFFSET ??_C@_0BB@DOFEEJAH@Expand?5failed?5?$CB?6@
	call	_printf
	add	esp, 4

; 996  : 	    reader->rngValidErrors++;

	inc	DWORD PTR [edi+128]
	pop	edi

; 997  :     }
; 998  : #endif
; 999  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 987  : 	        ret = -1;
; 988  : 	    } else {
; 989  : 		ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,

	mov	eax, DWORD PTR [edi+20]
	push	esi
	push	DWORD PTR [eax+8]
	push	DWORD PTR [edi+120]
	call	_xmlRelaxNGValidateFullElement
	add	esp, 12					; 0000000cH

; 990  : 						    reader->ctxt->myDoc,
; 991  : 						    node);
; 992  : 		reader->rngFullNode = node;

	mov	DWORD PTR [edi+132], esi
$LN11@xmlTextRea:

; 993  : 	    }
; 994  : 	}
; 995  : 	if (ret != 1)

	cmp	eax, 1
	je	SHORT $LN12@xmlTextRea

; 996  : 	    reader->rngValidErrors++;

	inc	DWORD PTR [edi+128]
$LN12@xmlTextRea:
	pop	edi

; 997  :     }
; 998  : #endif
; 999  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderValidatePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderPushData
_TEXT	SEGMENT
_oldstate$1$ = -4					; size = 4
_alloc$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderPushData PROC				; COMDAT

; 829  : xmlTextReaderPushData(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ebx, DWORD PTR [esi+28]
	test	ebx, ebx
	je	$LN5@xmlTextRea

; 830  :     xmlBufPtr inbuf;
; 831  :     int val, s;
; 832  :     xmlTextReaderState oldstate;
; 833  :     int alloc;
; 834  : 
; 835  :     if ((reader->input == NULL) || (reader->input->buffer == NULL))

	cmp	DWORD PTR [ebx+16], 0
	je	$LN5@xmlTextRea

; 836  : 	return(-1);
; 837  : 
; 838  :     oldstate = reader->state;

	mov	edi, DWORD PTR [esi+16]

; 839  :     reader->state = XML_TEXTREADER_NONE;

	mov	DWORD PTR [esi+16], -1

; 840  :     inbuf = reader->input->buffer;

	mov	ebx, DWORD PTR [ebx+16]

; 841  :     alloc = xmlBufGetAllocationScheme(inbuf);

	push	ebx
	mov	DWORD PTR _oldstate$1$[ebp], edi
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	mov	ecx, eax

; 842  : 
; 843  :     while (reader->state == XML_TEXTREADER_NONE) {

	cmp	DWORD PTR [esi+16], -1
	mov	DWORD PTR _alloc$1$[ebp], ecx
	jne	$LN21@xmlTextRea
$LL2@xmlTextRea:

; 844  : 	if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {

	push	ebx
	call	_xmlBufUse
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 4
	add	ecx, 512				; 00000200H
	cmp	eax, ecx
	jae	SHORT $LN12@xmlTextRea

; 845  : 	    /*
; 846  : 	     * Refill the buffer unless we are at the end of the stream
; 847  : 	     */
; 848  : 	    if (reader->mode != XML_TEXTREADER_MODE_EOF) {

	cmp	DWORD PTR [esi], 3
	je	$LN45@xmlTextRea

; 849  : 		val = xmlParserInputBufferRead(reader->input, 4096);

	push	4096					; 00001000H
	push	DWORD PTR [esi+28]
	call	_xmlParserInputBufferRead
	mov	ecx, eax
	add	esp, 8

; 850  : 		if ((val == 0) &&

	test	ecx, ecx
	jne	SHORT $LN46@xmlTextRea
	cmp	DWORD PTR _alloc$1$[ebp], 2
	jne	$LN36@xmlTextRea

; 851  : 		    (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {
; 852  : 		    if (xmlBufUse(inbuf) == reader->cur) {

	push	ebx
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, DWORD PTR [esi+60]
	jne	SHORT $LN12@xmlTextRea

; 853  : 			reader->mode = XML_TEXTREADER_MODE_EOF;

	mov	DWORD PTR [esi], 3

; 854  : 			reader->state = oldstate;

	mov	DWORD PTR [esi+16], edi
	jmp	SHORT $LN12@xmlTextRea
$LN46@xmlTextRea:

; 855  : 		    }
; 856  : 		} else if (val < 0) {

	jns	SHORT $LN12@xmlTextRea

; 857  : 		    reader->mode = XML_TEXTREADER_MODE_EOF;

	mov	DWORD PTR [esi], 3

; 858  : 		    reader->state = oldstate;

	mov	DWORD PTR [esi+16], edi

; 859  : 		    if ((oldstate != XML_TEXTREADER_START) ||

	test	edi, edi
	jne	$LN35@xmlTextRea
	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+8], edi
	jne	$LN35@xmlTextRea
$LN12@xmlTextRea:

; 865  : 		    break;
; 866  : 		}
; 867  : 
; 868  : 	    } else
; 869  : 		break;
; 870  : 	}
; 871  : 	/*
; 872  : 	 * parse by block of CHUNK_SIZE bytes, various tests show that
; 873  : 	 * it's the best tradeoff at least on a 1.2GH Duron
; 874  : 	 */
; 875  : 	if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {

	push	ebx
	call	_xmlBufUse
	mov	ecx, DWORD PTR [esi+60]
	add	esp, 4
	add	ecx, 512				; 00000200H
	cmp	eax, ecx
	jb	$LN17@xmlTextRea

; 876  : 	    val = xmlParseChunk(reader->ctxt,

	push	0
	push	512					; 00000200H
	push	ebx
	call	_xmlBufContent
	add	eax, DWORD PTR [esi+60]
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	_xmlParseChunk

; 877  :                  (const char *) xmlBufContent(inbuf) + reader->cur,
; 878  :                                 CHUNK_SIZE, 0);
; 879  : 	    reader->cur += CHUNK_SIZE;

	add	DWORD PTR [esi+60], 512			; 00000200H
	add	esp, 16					; 00000010H

; 880  : 	    if (val != 0)

	test	eax, eax
	je	SHORT $LN19@xmlTextRea

; 881  : 		reader->ctxt->wellFormed = 0;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+12], 0
$LN19@xmlTextRea:

; 882  : 	    if (reader->ctxt->wellFormed == 0)

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+12], 0
	je	$LN45@xmlTextRea

; 842  : 
; 843  :     while (reader->state == XML_TEXTREADER_NONE) {

	cmp	DWORD PTR [esi+16], -1
	je	$LL2@xmlTextRea
	jmp	$LN45@xmlTextRea
$LN36@xmlTextRea:

; 860  : 			(reader->ctxt->myDoc != NULL))
; 861  : 			return(val);
; 862  : 		} else if (val == 0) {
; 863  : 		    /* mark the end of the stream and process the remains */
; 864  : 		    reader->mode = XML_TEXTREADER_MODE_EOF;

	mov	DWORD PTR [esi], 3

; 892  : 	    break;
; 893  : 	}
; 894  :     }
; 895  : 
; 896  :     /*
; 897  :      * Discard the consumed input when needed and possible
; 898  :      */
; 899  :     if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {

	mov	eax, 3
$LN22@xmlTextRea:

; 910  : 
; 911  :     /*
; 912  :      * At the end of the stream signal that the work is done to the Push
; 913  :      * parser.
; 914  :      */
; 915  :     else if (reader->mode == XML_TEXTREADER_MODE_EOF) {

	cmp	eax, 3
	jne	SHORT $LN31@xmlTextRea

; 916  : 	if (reader->state != XML_TEXTREADER_DONE) {

	cmp	DWORD PTR [esi+16], 5
	je	SHORT $LN31@xmlTextRea

; 917  : 	    s = xmlBufUse(inbuf) - reader->cur;

	push	ebx
	call	_xmlBufUse
	sub	eax, DWORD PTR [esi+60]
	add	esp, 4

; 918  : 	    val = xmlParseChunk(reader->ctxt,

	push	1
	push	eax
	push	ebx
	call	_xmlBufContent
	add	eax, DWORD PTR [esi+60]
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	_xmlParseChunk

; 919  : 		 (const char *) xmlBufContent(inbuf) + reader->cur,
; 920  : 			        s, 1);
; 921  : 	    reader->cur = xmlBufUse(inbuf);

	push	ebx
	mov	edi, eax
	call	_xmlBufUse
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+60], eax

; 922  : 	    reader->state  = XML_TEXTREADER_DONE;

	mov	DWORD PTR [esi+16], 5

; 923  : 	    if (val != 0) {

	test	edi, edi
	je	SHORT $LN31@xmlTextRea

; 924  : 	        if (reader->ctxt->wellFormed)

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@xmlTextRea

; 925  : 		    reader->ctxt->wellFormed = 0;

	mov	DWORD PTR [eax+12], 0
$LN31@xmlTextRea:

; 926  : 		else
; 927  : 		    return(-1);
; 928  : 	    }
; 929  : 	}
; 930  :     }
; 931  :     reader->state = oldstate;

	mov	eax, DWORD PTR _oldstate$1$[ebp]
	mov	DWORD PTR [esi+16], eax

; 932  :     if (reader->ctxt->wellFormed == 0) {

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN32@xmlTextRea

; 933  : 	reader->mode = XML_TEXTREADER_MODE_EOF;

	mov	DWORD PTR [esi], 3
$LN5@xmlTextRea:
	pop	edi

; 934  :         return(-1);
; 935  :     }
; 936  : 
; 937  :     return(0);
; 938  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlTextRea:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlTextRea:

; 883  : 		break;
; 884  : 	} else {
; 885  : 	    s = xmlBufUse(inbuf) - reader->cur;

	push	ebx
	call	_xmlBufUse
	add	esp, 4
	mov	edi, eax
	sub	edi, DWORD PTR [esi+60]

; 886  : 	    val = xmlParseChunk(reader->ctxt,

	push	0
	push	edi
	push	ebx
	call	_xmlBufContent
	add	eax, DWORD PTR [esi+60]
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	_xmlParseChunk

; 887  : 		 (const char *) xmlBufContent(inbuf) + reader->cur,
; 888  : 			        s, 0);
; 889  : 	    reader->cur += s;

	add	DWORD PTR [esi+60], edi
	add	esp, 16					; 00000010H

; 890  : 	    if (val != 0)

	test	eax, eax
	je	SHORT $LN45@xmlTextRea

; 891  : 		reader->ctxt->wellFormed = 0;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+12], 0
$LN45@xmlTextRea:

; 892  : 	    break;
; 893  : 	}
; 894  :     }
; 895  : 
; 896  :     /*
; 897  :      * Discard the consumed input when needed and possible
; 898  :      */
; 899  :     if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {

	mov	ecx, DWORD PTR _alloc$1$[ebp]
$LN21@xmlTextRea:
	mov	eax, DWORD PTR [esi]
	cmp	eax, 1
	jne	$LN22@xmlTextRea

; 900  :         if (alloc != XML_BUFFER_ALLOC_IMMUTABLE) {

	cmp	ecx, 2
	je	SHORT $LN31@xmlTextRea

; 901  : 	    if ((reader->cur >= 4096) &&

	cmp	DWORD PTR [esi+60], 4096		; 00001000H
	jb	$LN31@xmlTextRea
	mov	edi, DWORD PTR [esi+60]
	push	ebx
	call	_xmlBufUse
	sub	eax, edi
	add	esp, 4
	cmp	eax, 512				; 00000200H
	ja	$LN31@xmlTextRea

; 902  : 		(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {
; 903  : 		val = xmlBufShrink(inbuf, reader->cur);

	push	edi
	push	ebx
	call	_xmlBufShrink
	add	esp, 8

; 904  : 		if (val >= 0) {

	test	eax, eax
	js	$LN31@xmlTextRea

; 905  : 		    reader->cur -= val;

	sub	DWORD PTR [esi+60], eax

; 906  : 		}
; 907  : 	    }
; 908  : 	}
; 909  :     }

	jmp	$LN31@xmlTextRea
$LN32@xmlTextRea:
	pop	edi

; 934  :         return(-1);
; 935  :     }
; 936  : 
; 937  :     return(0);
; 938  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderPushData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderCDataBlock
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlTextReaderCDataBlock PROC				; COMDAT

; 807  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 808  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 809  :     xmlTextReaderPtr reader = ctxt->_private;
; 810  : 
; 811  : #ifdef DEBUG_CALLBACKS
; 812  :     printf("xmlTextReaderCDataBlock()\n");
; 813  : #endif
; 814  :     if ((reader != NULL) && (reader->cdataBlock != NULL)) {

	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 815  : 	reader->cdataBlock(ctx, ch, len);

	mov	DWORD PTR _ctx$[ebp], ecx

; 816  :     }
; 817  : }

	pop	ebp

; 815  : 	reader->cdataBlock(ctx, ch, len);

	jmp	eax
$LN2@xmlTextRea:

; 816  :     }
; 817  : }

	pop	ebp
	ret	0
_xmlTextReaderCDataBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderCharacters
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_ch$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlTextReaderCharacters PROC				; COMDAT

; 785  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 786  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 787  :     xmlTextReaderPtr reader = ctxt->_private;
; 788  : 
; 789  : #ifdef DEBUG_CALLBACKS
; 790  :     printf("xmlTextReaderCharacters()\n");
; 791  : #endif
; 792  :     if ((reader != NULL) && (reader->characters != NULL)) {

	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 793  : 	reader->characters(ctx, ch, len);

	mov	DWORD PTR _ctx$[ebp], ecx

; 794  :     }
; 795  : }

	pop	ebp

; 793  : 	reader->characters(ctx, ch, len);

	jmp	eax
$LN2@xmlTextRea:

; 794  :     }
; 795  : }

	pop	ebp
	ret	0
_xmlTextReaderCharacters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderEndElementNs
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_xmlTextReaderEndElementNs PROC				; COMDAT

; 762  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 763  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 764  :     xmlTextReaderPtr reader = ctxt->_private;
; 765  : 
; 766  : #ifdef DEBUG_CALLBACKS
; 767  :     printf("xmlTextReaderEndElementNs(%s)\n", localname);
; 768  : #endif
; 769  :     if ((reader != NULL) && (reader->endElementNs != NULL)) {

	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 770  : 	reader->endElementNs(ctx, localname, prefix, URI);

	mov	DWORD PTR _ctx$[ebp], ecx

; 771  :     }
; 772  : }

	pop	ebp

; 770  : 	reader->endElementNs(ctx, localname, prefix, URI);

	jmp	eax
$LN2@xmlTextRea:

; 771  :     }
; 772  : }

	pop	ebp
	ret	0
_xmlTextReaderEndElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderStartElementNs
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_localname$ = 12					; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nb_namespaces$ = 24					; size = 4
_namespaces$ = 28					; size = 4
_nb_attributes$ = 32					; size = 4
_nb_defaulted$ = 36					; size = 4
_attributes$ = 40					; size = 4
_xmlTextReaderStartElementNs PROC			; COMDAT

; 728  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	mov	esi, DWORD PTR [edi+272]
	test	esi, esi
	je	SHORT $LN4@xmlTextRea

; 729  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 730  :     xmlTextReaderPtr reader = ctxt->_private;
; 731  : 
; 732  : #ifdef DEBUG_CALLBACKS
; 733  :     printf("xmlTextReaderStartElementNs(%s)\n", localname);
; 734  : #endif
; 735  :     if ((reader != NULL) && (reader->startElementNs != NULL)) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 736  : 	reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,

	push	DWORD PTR _attributes$[ebp]
	push	DWORD PTR _nb_defaulted$[ebp]
	push	DWORD PTR _nb_attributes$[ebp]
	push	DWORD PTR _namespaces$[ebp]
	push	DWORD PTR _nb_namespaces$[ebp]
	push	DWORD PTR _URI$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR _localname$[ebp]
	push	edi
	call	eax

; 737  : 	                       namespaces, nb_attributes, nb_defaulted,
; 738  : 			       attributes);
; 739  : 	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
; 740  : 	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&

	mov	ecx, DWORD PTR [edi+52]
	add	esp, 36					; 00000024H
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN3@xmlTextRea
	cmp	BYTE PTR [eax+1], 62			; 0000003eH
	jne	SHORT $LN3@xmlTextRea

; 741  : 	    (ctxt->input->cur[1] == '>'))
; 742  : 	    ctxt->node->extra = NODE_IS_EMPTY;

	mov	eax, 1
	mov	WORD PTR [ecx+58], ax
$LN3@xmlTextRea:

; 743  :     }
; 744  :     if (reader != NULL)
; 745  : 	reader->state = XML_TEXTREADER_ELEMENT;

	mov	DWORD PTR [esi+16], 1
$LN4@xmlTextRea:
	pop	edi

; 746  : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderStartElementNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderEndElement
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_fullname$ = 12						; size = 4
_xmlTextReaderEndElement PROC				; COMDAT

; 691  : xmlTextReaderEndElement(void *ctx, const xmlChar *fullname) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 692  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 693  :     xmlTextReaderPtr reader = ctxt->_private;
; 694  : 
; 695  : #ifdef DEBUG_CALLBACKS
; 696  :     printf("xmlTextReaderEndElement(%s)\n", fullname);
; 697  : #endif
; 698  :     if ((reader != NULL) && (reader->endElement != NULL)) {

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 699  : 	reader->endElement(ctx, fullname);

	mov	DWORD PTR _ctx$[ebp], ecx

; 700  :     }
; 701  : }

	pop	ebp

; 699  : 	reader->endElement(ctx, fullname);

	jmp	eax
$LN2@xmlTextRea:

; 700  :     }
; 701  : }

	pop	ebp
	ret	0
_xmlTextReaderEndElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderStartElement
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_fullname$ = 12						; size = 4
_atts$ = 16						; size = 4
_xmlTextReaderStartElement PROC				; COMDAT

; 665  : 	                  const xmlChar **atts) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	edi, DWORD PTR [esi+272]
	test	edi, edi
	je	SHORT $LN4@xmlTextRea

; 666  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 667  :     xmlTextReaderPtr reader = ctxt->_private;
; 668  : 
; 669  : #ifdef DEBUG_CALLBACKS
; 670  :     printf("xmlTextReaderStartElement(%s)\n", fullname);
; 671  : #endif
; 672  :     if ((reader != NULL) && (reader->startElement != NULL)) {

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 673  : 	reader->startElement(ctx, fullname, atts);

	push	DWORD PTR _atts$[ebp]
	push	DWORD PTR _fullname$[ebp]
	push	esi
	call	eax

; 674  : 	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
; 675  : 	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&

	mov	ecx, DWORD PTR [esi+52]
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN3@xmlTextRea
	cmp	BYTE PTR [eax+1], 62			; 0000003eH
	jne	SHORT $LN3@xmlTextRea

; 676  : 	    (ctxt->input->cur[1] == '>'))
; 677  : 	    ctxt->node->extra = NODE_IS_EMPTY;

	mov	eax, 1
	mov	WORD PTR [ecx+58], ax
$LN3@xmlTextRea:

; 678  :     }
; 679  :     if (reader != NULL)
; 680  : 	reader->state = XML_TEXTREADER_ELEMENT;

	mov	DWORD PTR [edi+16], 1
$LN4@xmlTextRea:
	pop	edi

; 681  : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderStartElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderEntPop
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderEntPop PROC				; COMDAT

; 640  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	mov	ecx, DWORD PTR [edx+96]
	test	ecx, ecx
	jg	SHORT $LN2@xmlTextRea

; 641  :     xmlNodePtr ret;
; 642  : 
; 643  :     if (reader->entNr <= 0)
; 644  :         return (NULL);

	xor	eax, eax

; 653  : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 645  :     reader->entNr--;

	dec	ecx
	mov	DWORD PTR [edx+96], ecx

; 646  :     if (reader->entNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@xmlTextRea

; 647  :         reader->ent = reader->entTab[reader->entNr - 1];

	mov	eax, DWORD PTR [edx+104]
	mov	eax, DWORD PTR [eax+ecx*4-4]

; 650  :     ret = reader->entTab[reader->entNr];

	mov	DWORD PTR [edx+92], eax
	mov	eax, DWORD PTR [edx+104]
	mov	edx, DWORD PTR [eax+ecx*4]

; 651  :     reader->entTab[reader->entNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 652  :     return (ret);

	mov	eax, edx

; 653  : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 648  :     else
; 649  :         reader->ent = NULL;

	xor	eax, eax

; 650  :     ret = reader->entTab[reader->entNr];

	mov	DWORD PTR [edx+92], eax
	mov	eax, DWORD PTR [edx+104]
	mov	edx, DWORD PTR [eax+ecx*4]

; 651  :     reader->entTab[reader->entNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 652  :     return (ret);

	mov	eax, edx

; 653  : }

	pop	ebp
	ret	0
_xmlTextReaderEntPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderEntPush
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlTextReaderEntPush PROC				; COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	cmp	DWORD PTR [esi+100], 0
	jg	SHORT $LN11@xmlTextRea

; 605  :     if (reader->entMax <= 0) {
; 606  : 	reader->entMax = 10;

	push	40					; 00000028H
	mov	DWORD PTR [esi+100], 10			; 0000000aH

; 607  : 	reader->entTab = (xmlNodePtr *) xmlMalloc(reader->entMax *

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+104], eax

; 608  : 		                                  sizeof(reader->entTab[0]));
; 609  :         if (reader->entTab == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlTextRea

; 610  :             xmlGenericError(xmlGenericErrorContext, "xmlMalloc failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@MPMNBMMA@xmlMalloc?5failed?5?$CB?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 611  :             return (0);

	xor	eax, eax
	pop	esi

; 628  : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 612  :         }
; 613  :     }
; 614  :     if (reader->entNr >= reader->entMax) {

	mov	eax, DWORD PTR [esi+100]
	cmp	DWORD PTR [esi+96], eax
	jl	SHORT $LN12@xmlTextRea

; 615  :         reader->entMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+100], eax

; 616  :         reader->entTab =

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+104]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+104], eax

; 617  :             (xmlNodePtr *) xmlRealloc(reader->entTab,
; 618  :                                       reader->entMax *
; 619  :                                       sizeof(reader->entTab[0]));
; 620  :         if (reader->entTab == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlTextRea

; 621  :             xmlGenericError(xmlGenericErrorContext, "xmlRealloc failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 622  :             return (0);

	xor	eax, eax
	pop	esi

; 628  : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 623  :         }
; 624  :     }
; 625  :     reader->entTab[reader->entNr] = value;

	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+104]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 626  :     reader->ent = value;
; 627  :     return (reader->entNr++);

	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+92], ecx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+96], ecx
	pop	esi

; 628  : }

	pop	ebp
	ret	0
_xmlTextReaderEntPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeDoc
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlTextReaderFreeDoc PROC				; COMDAT

; 518  : xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN1@xmlTextRea

; 519  :     xmlDtdPtr extSubset, intSubset;
; 520  : 
; 521  :     if (cur == NULL) return;
; 522  : 
; 523  :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN3@xmlTextRea
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlTextRea

; 524  : 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN3@xmlTextRea:

; 525  : 
; 526  :     /*
; 527  :      * Do this before freeing the children list to avoid ID lookups
; 528  :      */
; 529  :     if (cur->ids != NULL) xmlTextReaderFreeIDTable((xmlIDTablePtr) cur->ids);

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN17@xmlTextRea

; 507  :     xmlHashFree(table, xmlTextReaderFreeIDTableEntry);

	push	OFFSET _xmlTextReaderFreeIDTableEntry
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN17@xmlTextRea:

; 530  :     cur->ids = NULL;
; 531  :     if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [esi+64], 0
	test	eax, eax
	je	SHORT $LN5@xmlTextRea
	push	eax
	call	_xmlFreeRefTable
	add	esp, 4
$LN5@xmlTextRea:

; 532  :     cur->refs = NULL;
; 533  :     extSubset = cur->extSubset;

	mov	eax, DWORD PTR [esi+48]
	push	ebx

; 534  :     intSubset = cur->intSubset;
; 535  :     if (intSubset == extSubset)
; 536  : 	extSubset = NULL;
; 537  :     if (extSubset != NULL) {

	xor	ebx, ebx
	mov	DWORD PTR [esi+68], 0
	push	edi
	mov	edi, DWORD PTR [esi+44]
	cmp	edi, eax
	cmovne	ebx, eax
	test	ebx, ebx
	je	SHORT $LN7@xmlTextRea

; 538  : 	xmlUnlinkNode((xmlNodePtr) cur->extSubset);

	push	eax
	call	_xmlUnlinkNode

; 539  : 	cur->extSubset = NULL;
; 540  : 	xmlFreeDtd(extSubset);

	push	ebx
	mov	DWORD PTR [esi+48], 0
	call	_xmlFreeDtd
	add	esp, 8
$LN7@xmlTextRea:

; 541  :     }
; 542  :     if (intSubset != NULL) {

	test	edi, edi
	je	SHORT $LN8@xmlTextRea

; 543  : 	xmlUnlinkNode((xmlNodePtr) cur->intSubset);

	push	DWORD PTR [esi+44]
	call	_xmlUnlinkNode

; 544  : 	cur->intSubset = NULL;
; 545  : 	xmlFreeDtd(intSubset);

	push	edi
	mov	DWORD PTR [esi+44], 0
	call	_xmlFreeDtd
	add	esp, 8
$LN8@xmlTextRea:

; 546  :     }
; 547  : 
; 548  :     if (cur->children != NULL) xmlTextReaderFreeNodeList(reader, cur->children);

	mov	eax, DWORD PTR [esi+12]
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN9@xmlTextRea
	push	eax
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderFreeNodeList
	add	esp, 8
$LN9@xmlTextRea:

; 549  : 
; 550  :     if (cur->version != NULL) xmlFree((char *) cur->version);

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlTextRea:

; 551  :     if (cur->name != NULL) xmlFree((char *) cur->name);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlTextRea:

; 552  :     if (cur->encoding != NULL) xmlFree((char *) cur->encoding);

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlTextRea:

; 553  :     if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea
	push	eax
	call	_xmlFreeNsList
	add	esp, 4
$LN13@xmlTextRea:

; 554  :     if (cur->URL != NULL) xmlFree((char *) cur->URL);

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN14@xmlTextRea
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlTextRea:

; 555  :     if (cur->dict != NULL) xmlDictFree(cur->dict);

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	je	SHORT $LN15@xmlTextRea
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN15@xmlTextRea:

; 556  : 
; 557  :     xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlTextRea:
	pop	esi

; 558  : }

	pop	ebp
	ret	0
_xmlTextReaderFreeDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeIDTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlTextReaderFreeIDTable PROC				; COMDAT

; 506  : xmlTextReaderFreeIDTable(xmlIDTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET _xmlTextReaderFreeIDTableEntry
	push	DWORD PTR _table$[ebp]
	call	_xmlHashFree
	add	esp, 8

; 507  :     xmlHashFree(table, xmlTextReaderFreeIDTableEntry);
; 508  : }

	pop	ebp
	ret	0
_xmlTextReaderFreeIDTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeIDTableEntry
_TEXT	SEGMENT
_id$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlTextReaderFreeIDTableEntry PROC			; COMDAT

; 495  : xmlTextReaderFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4

; 234  :     if (id == NULL) return;

	mov	esi, DWORD PTR _id$[ebp]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN3@xmlTextRea

; 235  : 
; 236  :     if (id->doc != NULL)

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 237  :         dict = id->doc->dict;

	mov	eax, DWORD PTR [ecx+80]
$LN5@xmlTextRea:

; 238  : 
; 239  :     if (id->value != NULL)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN7@xmlTextRea

; 240  : 	DICT_FREE(id->value)

	test	eax, eax
	je	SHORT $LN8@xmlTextRea
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlTextRea
$LN8@xmlTextRea:
	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlTextRea:

; 241  :     xmlFree(id);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlTextRea:
	pop	esi

; 496  :     xmlFreeID((xmlIDPtr) id);
; 497  : }

	pop	ebp
	ret	0
_xmlTextReaderFreeIDTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreePropList
_TEXT	SEGMENT
_ID$1$ = -8						; size = 4
_dict$1$ = -4						; size = 4
_reader$ = 8						; size = 4
_next$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xmlTextReaderFreePropList PROC				; COMDAT

; 327  : xmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlTextRea
	push	ebx
	push	edi
	mov	edi, DWORD PTR _reader$[ebp]
$LL2@xmlTextRea:

; 328  :     xmlAttrPtr next;
; 329  : 
; 330  :     while (cur != NULL) {
; 331  :         next = cur->next;

	mov	ebx, DWORD PTR [esi+24]
	mov	DWORD PTR _next$1$[ebp], ebx

; 289  :     if ((reader != NULL) && (reader->ctxt != NULL))

	test	edi, edi
	je	SHORT $LN6@xmlTextRea
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 290  : 	dict = reader->ctxt->dict;

	mov	eax, DWORD PTR [eax+296]
	mov	DWORD PTR _dict$1$[ebp], eax
	jmp	SHORT $LN7@xmlTextRea
$LN6@xmlTextRea:

; 291  :     else
; 292  :         dict = NULL;

	mov	DWORD PTR _dict$1$[ebp], 0
$LN7@xmlTextRea:

; 293  :     if (cur == NULL) return;
; 294  : 
; 295  :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN9@xmlTextRea
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlTextRea

; 296  : 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN9@xmlTextRea:

; 297  : 
; 298  :     /* Check for ID removal -> leading to invalid references ! */
; 299  :     if ((cur->parent != NULL) && (cur->parent->doc != NULL) &&

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN25@xmlTextRea
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN25@xmlTextRea
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN11@xmlTextRea
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN25@xmlTextRea
$LN11@xmlTextRea:

; 300  : 	((cur->parent->doc->intSubset != NULL) ||
; 301  : 	 (cur->parent->doc->extSubset != NULL))) {
; 302  :         if (xmlIsID(cur->parent->doc, cur->parent, cur))

	push	esi
	push	ecx
	push	eax
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@xmlTextRea

; 303  : 	    xmlTextReaderRemoveID(cur->parent->doc, cur);

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+32]

; 259  :     if (doc == NULL) return(-1);

	test	eax, eax
	je	SHORT $LN25@xmlTextRea

; 260  :     if (attr == NULL) return(-1);
; 261  :     table = (xmlIDTablePtr) doc->ids;

	mov	ebx, DWORD PTR [eax+64]

; 262  :     if (table == NULL)

	test	ebx, ebx
	je	SHORT $LN61@xmlTextRea

; 263  :         return(-1);
; 264  : 
; 265  :     ID = xmlNodeListGetString(doc, attr->children, 1);

	push	1
	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ID$1$[ebp], eax

; 266  :     if (ID == NULL)

	test	eax, eax
	je	SHORT $LN61@xmlTextRea

; 267  : 	return(-1);
; 268  :     id = xmlHashLookup(table, ID);

	push	eax
	push	ebx
	call	_xmlHashLookup

; 269  :     xmlFree(ID);

	push	DWORD PTR _ID$1$[ebp]
	mov	ebx, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 270  :     if (id == NULL || id->attr != attr) {

	test	ebx, ebx
	je	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [ebx+8], esi
	jne	SHORT $LN61@xmlTextRea

; 271  : 	return(-1);
; 272  :     }
; 273  :     id->name = attr->name;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+12], eax

; 274  :     id->attr = NULL;

	mov	DWORD PTR [ebx+8], 0
$LN61@xmlTextRea:

; 305  :     if (cur->children != NULL)

	mov	ebx, DWORD PTR _next$1$[ebp]
$LN25@xmlTextRea:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea

; 306  :         xmlTextReaderFreeNodeList(reader, cur->children);

	push	eax
	push	edi
	call	_xmlTextReaderFreeNodeList
	add	esp, 8
$LN13@xmlTextRea:

; 307  : 
; 308  :     DICT_FREE(cur->name);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN14@xmlTextRea
	mov	ecx, DWORD PTR _dict$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@xmlTextRea
	push	eax
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlTextRea
$LN15@xmlTextRea:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlTextRea:

; 309  :     if ((reader != NULL) && (reader->ctxt != NULL) &&

	test	edi, edi
	je	SHORT $LN16@xmlTextRea
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN16@xmlTextRea
	cmp	DWORD PTR [eax+376], 100		; 00000064H
	jge	SHORT $LN16@xmlTextRea

; 310  :         (reader->ctxt->freeAttrsNr < 100)) {
; 311  :         cur->next = reader->ctxt->freeAttrs;

	mov	eax, DWORD PTR [eax+380]
	mov	DWORD PTR [esi+24], eax

; 312  : 	reader->ctxt->freeAttrs = cur;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+380], esi

; 313  : 	reader->ctxt->freeAttrsNr++;

	mov	eax, DWORD PTR [edi+20]
	inc	DWORD PTR [eax+376]

; 314  :     } else {

	jmp	SHORT $LN17@xmlTextRea
$LN16@xmlTextRea:

; 315  : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlTextRea:

; 332  :         xmlTextReaderFreeProp(reader, cur);
; 333  : 	cur = next;

	mov	esi, ebx
	test	ebx, ebx
	jne	$LL2@xmlTextRea
	pop	edi
	pop	ebx
$LN3@xmlTextRea:
	pop	esi

; 334  :     }
; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderFreePropList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeProp
_TEXT	SEGMENT
_dict$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_ID$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xmlTextReaderFreeProp PROC				; COMDAT

; 286  : xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlTextRea

; 287  :     xmlDictPtr dict;
; 288  : 
; 289  :     if ((reader != NULL) && (reader->ctxt != NULL))

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 290  : 	dict = reader->ctxt->dict;

	mov	eax, DWORD PTR [eax+296]
	mov	DWORD PTR _dict$1$[ebp], eax
	jmp	SHORT $LN3@xmlTextRea
$LN2@xmlTextRea:

; 291  :     else
; 292  :         dict = NULL;

	mov	DWORD PTR _dict$1$[ebp], 0
$LN3@xmlTextRea:

; 293  :     if (cur == NULL) return;

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN13@xmlTextRea

; 294  : 
; 295  :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN5@xmlTextRea
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlTextRea

; 296  : 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN5@xmlTextRea:

; 297  : 
; 298  :     /* Check for ID removal -> leading to invalid references ! */
; 299  :     if ((cur->parent != NULL) && (cur->parent->doc != NULL) &&

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN21@xmlTextRea
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN21@xmlTextRea
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN7@xmlTextRea
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN21@xmlTextRea
$LN7@xmlTextRea:

; 300  : 	((cur->parent->doc->intSubset != NULL) ||
; 301  : 	 (cur->parent->doc->extSubset != NULL))) {
; 302  :         if (xmlIsID(cur->parent->doc, cur->parent, cur))

	push	esi
	push	ecx
	push	eax
	call	_xmlIsID
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@xmlTextRea

; 303  : 	    xmlTextReaderRemoveID(cur->parent->doc, cur);

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+32]

; 259  :     if (doc == NULL) return(-1);

	test	eax, eax
	je	SHORT $LN21@xmlTextRea

; 260  :     if (attr == NULL) return(-1);
; 261  :     table = (xmlIDTablePtr) doc->ids;

	push	ebx
	mov	ebx, DWORD PTR [eax+64]

; 262  :     if (table == NULL)

	test	ebx, ebx
	je	SHORT $LN54@xmlTextRea

; 263  :         return(-1);
; 264  : 
; 265  :     ID = xmlNodeListGetString(doc, attr->children, 1);

	push	1
	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ID$1$[ebp], eax

; 266  :     if (ID == NULL)

	test	eax, eax
	je	SHORT $LN54@xmlTextRea

; 267  : 	return(-1);
; 268  :     id = xmlHashLookup(table, ID);

	push	eax
	push	ebx
	call	_xmlHashLookup

; 269  :     xmlFree(ID);

	push	DWORD PTR _ID$1$[ebp]
	mov	ebx, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 270  :     if (id == NULL || id->attr != attr) {

	test	ebx, ebx
	je	SHORT $LN54@xmlTextRea
	cmp	DWORD PTR [ebx+8], esi
	jne	SHORT $LN54@xmlTextRea

; 271  : 	return(-1);
; 272  :     }
; 273  :     id->name = attr->name;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+12], eax

; 274  :     id->attr = NULL;

	mov	DWORD PTR [ebx+8], 0
$LN54@xmlTextRea:
	pop	ebx
$LN21@xmlTextRea:

; 304  :     }
; 305  :     if (cur->children != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 306  :         xmlTextReaderFreeNodeList(reader, cur->children);

	push	eax
	push	edi
	call	_xmlTextReaderFreeNodeList
	add	esp, 8
$LN9@xmlTextRea:

; 307  : 
; 308  :     DICT_FREE(cur->name);

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN10@xmlTextRea
	mov	eax, DWORD PTR _dict$1$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlTextRea
$LN11@xmlTextRea:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlTextRea:

; 309  :     if ((reader != NULL) && (reader->ctxt != NULL) &&

	test	edi, edi
	je	SHORT $LN12@xmlTextRea
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea
	cmp	DWORD PTR [eax+376], 100		; 00000064H
	jge	SHORT $LN12@xmlTextRea

; 310  :         (reader->ctxt->freeAttrsNr < 100)) {
; 311  :         cur->next = reader->ctxt->freeAttrs;

	mov	eax, DWORD PTR [eax+380]
	mov	DWORD PTR [esi+24], eax

; 312  : 	reader->ctxt->freeAttrs = cur;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+380], esi

; 313  : 	reader->ctxt->freeAttrsNr++;

	mov	eax, DWORD PTR [edi+20]
	pop	edi

; 316  :     }
; 317  : }

	pop	esi
	inc	DWORD PTR [eax+376]
	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 314  :     } else {
; 315  : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlTextRea:

; 316  :     }
; 317  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderFreeProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRemoveID
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlTextReaderRemoveID PROC				; COMDAT

; 254  : xmlTextReaderRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 255  :     xmlIDTablePtr table;
; 256  :     xmlIDPtr id;
; 257  :     xmlChar *ID;
; 258  : 
; 259  :     if (doc == NULL) return(-1);
; 260  :     if (attr == NULL) return(-1);

	mov	esi, DWORD PTR _attr$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlTextRea

; 261  :     table = (xmlIDTablePtr) doc->ids;

	mov	edi, DWORD PTR [eax+64]

; 262  :     if (table == NULL)

	test	edi, edi
	je	SHORT $LN7@xmlTextRea

; 263  :         return(-1);
; 264  : 
; 265  :     ID = xmlNodeListGetString(doc, attr->children, 1);

	push	1
	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlNodeListGetString
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 266  :     if (ID == NULL)

	test	ebx, ebx
	je	SHORT $LN7@xmlTextRea

; 267  : 	return(-1);
; 268  :     id = xmlHashLookup(table, ID);

	push	ebx
	push	edi
	call	_xmlHashLookup

; 269  :     xmlFree(ID);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 270  :     if (id == NULL || id->attr != attr) {

	test	edi, edi
	je	SHORT $LN7@xmlTextRea
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN7@xmlTextRea

; 271  : 	return(-1);
; 272  :     }
; 273  :     id->name = attr->name;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+12], eax

; 274  :     id->attr = NULL;
; 275  :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edi+8], 0
	pop	edi

; 276  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlTextRea:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderRemoveID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlFreeID
_TEXT	SEGMENT
_id$ = 8						; size = 4
_xmlFreeID PROC						; COMDAT

; 231  : xmlFreeID(xmlIDPtr id) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _id$[ebp]
	xor	eax, eax
	test	esi, esi
	je	SHORT $LN1@xmlFreeID

; 232  :     xmlDictPtr dict = NULL;
; 233  : 
; 234  :     if (id == NULL) return;
; 235  : 
; 236  :     if (id->doc != NULL)

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN3@xmlFreeID

; 237  :         dict = id->doc->dict;

	mov	eax, DWORD PTR [ecx+80]
$LN3@xmlFreeID:

; 238  : 
; 239  :     if (id->value != NULL)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlFreeID

; 240  : 	DICT_FREE(id->value)

	test	eax, eax
	je	SHORT $LN6@xmlFreeID
	push	ecx
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlFreeID
$LN6@xmlFreeID:
	push	DWORD PTR [esi+4]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlFreeID:

; 241  :     xmlFree(id);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeID:
	pop	esi

; 242  : }

	pop	ebp
	ret	0
_xmlFreeID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeNodeList
_TEXT	SEGMENT
_next$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlTextReaderFreeNodeList PROC				; COMDAT

; 346  : xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlTextRea

; 347  :     xmlNodePtr next;
; 348  :     xmlDictPtr dict;
; 349  : 
; 350  :     if ((reader != NULL) && (reader->ctxt != NULL))

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 351  : 	dict = reader->ctxt->dict;

	mov	ebx, DWORD PTR [eax+296]
	jmp	SHORT $LN5@xmlTextRea
$LN4@xmlTextRea:

; 352  :     else
; 353  :         dict = NULL;

	xor	ebx, ebx
$LN5@xmlTextRea:

; 354  :     if (cur == NULL) return;

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlTextRea

; 355  :     if (cur->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN7@xmlTextRea

; 356  : 	xmlFreeNsList((xmlNsPtr) cur);

	push	esi
	call	_xmlFreeNsList

; 415  :     }
; 416  : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlTextRea:

; 357  : 	return;
; 358  :     }
; 359  :     if ((cur->type == XML_DOCUMENT_NODE) ||

	cmp	eax, 9
	je	$LN9@xmlTextRea
	cmp	eax, 13					; 0000000dH
	je	$LN9@xmlTextRea
	npad	5
$LL2@xmlTextRea:

; 362  : 	return;
; 363  :     }
; 364  :     while (cur != NULL) {
; 365  :         next = cur->next;
; 366  : 	/* unroll to speed up freeing the document */
; 367  : 	if (cur->type != XML_DTD_NODE) {

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _next$1$[ebp], eax
	cmp	ecx, 14					; 0000000eH
	je	$LN25@xmlTextRea

; 368  : 
; 369  : 	    if ((cur->children != NULL) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea
	cmp	ecx, 5
	je	SHORT $LN11@xmlTextRea

; 370  : 		(cur->type != XML_ENTITY_REF_NODE)) {
; 371  : 		if (cur->children->parent == cur)

	cmp	DWORD PTR [eax+20], esi
	jne	SHORT $LN12@xmlTextRea

; 372  : 		    xmlTextReaderFreeNodeList(reader, cur->children);

	push	eax
	push	edi
	call	_xmlTextReaderFreeNodeList
	add	esp, 8
$LN12@xmlTextRea:

; 373  : 		cur->children = NULL;

	mov	DWORD PTR [esi+12], 0
$LN11@xmlTextRea:

; 374  : 	    }
; 375  : 
; 376  : 	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN13@xmlTextRea
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN13@xmlTextRea

; 377  : 		xmlDeregisterNodeDefaultValue(cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN13@xmlTextRea:

; 378  : 
; 379  : 	    if (((cur->type == XML_ELEMENT_NODE) ||
; 380  : 		 (cur->type == XML_XINCLUDE_START) ||
; 381  : 		 (cur->type == XML_XINCLUDE_END)) &&

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 1
	je	SHORT $LN15@xmlTextRea
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN15@xmlTextRea
	cmp	ecx, 20					; 00000014H
	jne	SHORT $LN14@xmlTextRea
$LN15@xmlTextRea:
	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN14@xmlTextRea

; 382  : 		(cur->properties != NULL))
; 383  : 		xmlTextReaderFreePropList(reader, cur->properties);

	push	eax
	push	edi
	call	_xmlTextReaderFreePropList
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 8
$LN14@xmlTextRea:

; 384  : 	    if ((cur->content != (xmlChar *) &(cur->properties)) &&
; 385  : 	        (cur->type != XML_ELEMENT_NODE) &&
; 386  : 		(cur->type != XML_XINCLUDE_START) &&
; 387  : 		(cur->type != XML_XINCLUDE_END) &&

	mov	edx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR [esi+44]
	cmp	edx, eax
	je	SHORT $LN17@xmlTextRea
	cmp	ecx, 1
	je	SHORT $LN17@xmlTextRea
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN17@xmlTextRea
	cmp	ecx, 20					; 00000014H
	je	SHORT $LN17@xmlTextRea
	cmp	ecx, 5
	je	SHORT $LN17@xmlTextRea

; 388  : 		(cur->type != XML_ENTITY_REF_NODE)) {
; 389  : 		DICT_FREE(cur->content);

	test	edx, edx
	je	SHORT $LN17@xmlTextRea
	test	ebx, ebx
	je	SHORT $LN18@xmlTextRea
	push	edx
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlTextRea
$LN18@xmlTextRea:
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlTextRea:

; 390  : 	    }
; 391  : 	    if (((cur->type == XML_ELEMENT_NODE) ||
; 392  : 	         (cur->type == XML_XINCLUDE_START) ||
; 393  : 		 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN20@xmlTextRea
	cmp	eax, 19					; 00000013H
	je	SHORT $LN20@xmlTextRea
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN19@xmlTextRea
$LN20@xmlTextRea:
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN19@xmlTextRea

; 394  : 		(cur->nsDef != NULL))
; 395  : 		xmlFreeNsList(cur->nsDef);

	push	ecx
	call	_xmlFreeNsList
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN19@xmlTextRea:

; 396  : 
; 397  : 	    /*
; 398  : 	     * we don't free element names here they are interned now
; 399  : 	     */
; 400  : 	    if ((cur->type != XML_TEXT_NODE) &&

	cmp	eax, 3
	je	SHORT $LN22@xmlTextRea
	cmp	eax, 8
	je	SHORT $LN22@xmlTextRea

; 401  : 		(cur->type != XML_COMMENT_NODE))
; 402  : 		DICT_FREE(cur->name);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN22@xmlTextRea
	test	ebx, ebx
	je	SHORT $LN23@xmlTextRea
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@xmlTextRea
$LN23@xmlTextRea:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlTextRea:

; 403  : 	    if (((cur->type == XML_ELEMENT_NODE) ||
; 404  : 		 (cur->type == XML_TEXT_NODE)) &&
; 405  : 	        (reader != NULL) && (reader->ctxt != NULL) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN26@xmlTextRea
	cmp	eax, 3
	jne	SHORT $LN24@xmlTextRea
$LN26@xmlTextRea:
	test	edi, edi
	je	SHORT $LN24@xmlTextRea
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN24@xmlTextRea
	cmp	DWORD PTR [eax+368], 100		; 00000064H
	jge	SHORT $LN24@xmlTextRea

; 406  : 		(reader->ctxt->freeElemsNr < 100)) {
; 407  : 	        cur->next = reader->ctxt->freeElems;

	mov	eax, DWORD PTR [eax+372]
	mov	DWORD PTR [esi+24], eax

; 408  : 		reader->ctxt->freeElems = cur;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+372], esi

; 409  : 		reader->ctxt->freeElemsNr++;

	mov	eax, DWORD PTR [edi+20]
	inc	DWORD PTR [eax+368]

; 410  : 	    } else {

	jmp	SHORT $LN33@xmlTextRea
$LN24@xmlTextRea:

; 411  : 		xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN33@xmlTextRea:

; 412  : 	    }
; 413  : 	}
; 414  : 	cur = next;

	mov	eax, DWORD PTR _next$1$[ebp]
$LN25@xmlTextRea:
	mov	esi, eax
	test	eax, eax
	jne	$LL2@xmlTextRea

; 415  :     }
; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 360  : 	(cur->type == XML_HTML_DOCUMENT_NODE)) {
; 361  : 	xmlFreeDoc((xmlDocPtr) cur);

	push	esi
	call	_xmlFreeDoc

; 415  :     }
; 416  : }

	add	esp, 4
$LN3@xmlTextRea:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderFreeNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderFreeNode
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlTextReaderFreeNode PROC				; COMDAT

; 427  : xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	test	edi, edi
	je	SHORT $LN2@xmlTextRea

; 428  :     xmlDictPtr dict;
; 429  : 
; 430  :     if ((reader != NULL) && (reader->ctxt != NULL))

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN2@xmlTextRea

; 431  : 	dict = reader->ctxt->dict;

	mov	ebx, DWORD PTR [eax+296]
	jmp	SHORT $LN3@xmlTextRea
$LN2@xmlTextRea:

; 432  :     else
; 433  :         dict = NULL;

	xor	ebx, ebx
$LN3@xmlTextRea:

; 434  :     if (cur->type == XML_DTD_NODE) {

	mov	esi, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN4@xmlTextRea

; 435  : 	xmlFreeDtd((xmlDtdPtr) cur);

	push	esi
	call	_xmlFreeDtd

; 491  :     }
; 492  : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 436  : 	return;
; 437  :     }
; 438  :     if (cur->type == XML_NAMESPACE_DECL) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN5@xmlTextRea

; 439  : 	xmlFreeNs((xmlNsPtr) cur);

	push	esi
	call	_xmlFreeNs

; 491  :     }
; 492  : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 440  :         return;
; 441  :     }
; 442  :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN6@xmlTextRea

; 443  : 	xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);

	push	esi
	push	edi
	call	_xmlTextReaderFreeProp
	add	esp, 8
	pop	edi

; 491  :     }
; 492  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 444  : 	return;
; 445  :     }
; 446  : 
; 447  :     if ((cur->children != NULL) &&

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN7@xmlTextRea
	cmp	eax, 5
	je	SHORT $LN7@xmlTextRea

; 448  : 	(cur->type != XML_ENTITY_REF_NODE)) {
; 449  : 	if (cur->children->parent == cur)

	cmp	DWORD PTR [ecx+20], esi
	jne	SHORT $LN8@xmlTextRea

; 450  : 	    xmlTextReaderFreeNodeList(reader, cur->children);

	push	ecx
	push	edi
	call	_xmlTextReaderFreeNodeList
	add	esp, 8
$LN8@xmlTextRea:

; 451  : 	cur->children = NULL;

	mov	DWORD PTR [esi+12], 0
$LN7@xmlTextRea:

; 452  :     }
; 453  : 
; 454  :     if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))

	cmp	DWORD PTR ___xmlRegisterCallbacks, 0
	je	SHORT $LN9@xmlTextRea
	call	___xmlDeregisterNodeDefaultValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlTextRea

; 455  : 	xmlDeregisterNodeDefaultValue(cur);

	call	___xmlDeregisterNodeDefaultValue
	push	esi
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 4
$LN9@xmlTextRea:

; 456  : 
; 457  :     if (((cur->type == XML_ELEMENT_NODE) ||
; 458  : 	 (cur->type == XML_XINCLUDE_START) ||
; 459  : 	 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN11@xmlTextRea
	cmp	eax, 19					; 00000013H
	je	SHORT $LN11@xmlTextRea
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN10@xmlTextRea
$LN11@xmlTextRea:
	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 460  : 	(cur->properties != NULL))
; 461  : 	xmlTextReaderFreePropList(reader, cur->properties);

	push	eax
	push	edi
	call	_xmlTextReaderFreePropList
	add	esp, 8
$LN10@xmlTextRea:

; 462  :     if ((cur->content != (xmlChar *) &(cur->properties)) &&
; 463  :         (cur->type != XML_ELEMENT_NODE) &&
; 464  : 	(cur->type != XML_XINCLUDE_START) &&
; 465  : 	(cur->type != XML_XINCLUDE_END) &&

	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR [esi+44]
	cmp	ecx, eax
	je	SHORT $LN13@xmlTextRea
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN13@xmlTextRea
	cmp	eax, 19					; 00000013H
	je	SHORT $LN13@xmlTextRea
	cmp	eax, 20					; 00000014H
	je	SHORT $LN13@xmlTextRea
	cmp	eax, 5
	je	SHORT $LN13@xmlTextRea

; 466  : 	(cur->type != XML_ENTITY_REF_NODE)) {
; 467  : 	DICT_FREE(cur->content);

	test	ecx, ecx
	je	SHORT $LN13@xmlTextRea
	test	ebx, ebx
	je	SHORT $LN14@xmlTextRea
	push	ecx
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlTextRea
$LN14@xmlTextRea:
	push	DWORD PTR [esi+40]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlTextRea:

; 468  :     }
; 469  :     if (((cur->type == XML_ELEMENT_NODE) ||
; 470  : 	 (cur->type == XML_XINCLUDE_START) ||
; 471  : 	 (cur->type == XML_XINCLUDE_END)) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN16@xmlTextRea
	cmp	eax, 19					; 00000013H
	je	SHORT $LN16@xmlTextRea
	cmp	eax, 20					; 00000014H
	jne	SHORT $LN15@xmlTextRea
$LN16@xmlTextRea:
	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN15@xmlTextRea

; 472  : 	(cur->nsDef != NULL))
; 473  : 	xmlFreeNsList(cur->nsDef);

	push	ecx
	call	_xmlFreeNsList
	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
$LN15@xmlTextRea:

; 474  : 
; 475  :     /*
; 476  :      * we don't free names here they are interned now
; 477  :      */
; 478  :     if ((cur->type != XML_TEXT_NODE) &&

	cmp	eax, 3
	je	SHORT $LN18@xmlTextRea
	cmp	eax, 8
	je	SHORT $LN18@xmlTextRea

; 479  :         (cur->type != XML_COMMENT_NODE))
; 480  : 	DICT_FREE(cur->name);

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN18@xmlTextRea
	test	ebx, ebx
	je	SHORT $LN19@xmlTextRea
	push	eax
	push	ebx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlTextRea
$LN19@xmlTextRea:
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlTextRea:

; 481  : 
; 482  :     if (((cur->type == XML_ELEMENT_NODE) ||
; 483  : 	 (cur->type == XML_TEXT_NODE)) &&
; 484  : 	(reader != NULL) && (reader->ctxt != NULL) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN22@xmlTextRea
	cmp	eax, 3
	jne	SHORT $LN20@xmlTextRea
$LN22@xmlTextRea:
	test	edi, edi
	je	SHORT $LN20@xmlTextRea
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN20@xmlTextRea
	cmp	DWORD PTR [eax+368], 100		; 00000064H
	jge	SHORT $LN20@xmlTextRea

; 485  : 	(reader->ctxt->freeElemsNr < 100)) {
; 486  : 	cur->next = reader->ctxt->freeElems;

	mov	eax, DWORD PTR [eax+372]
	mov	DWORD PTR [esi+24], eax

; 487  : 	reader->ctxt->freeElems = cur;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+372], esi

; 488  : 	reader->ctxt->freeElemsNr++;

	mov	eax, DWORD PTR [edi+20]
	pop	edi

; 491  :     }
; 492  : }

	pop	esi
	pop	ebx
	inc	DWORD PTR [eax+368]
	pop	ebp
	ret	0
$LN20@xmlTextRea:

; 489  :     } else {
; 490  : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree

; 491  :     }
; 492  : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderFreeNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNextTree
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNextTree PROC				; COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlTextRea

; 1893 :     if (reader == NULL)
; 1894 :         return(-1);

	or	eax, -1
	pop	esi

; 1947 : 
; 1948 :     return(1);
; 1949 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 1895 : 
; 1896 :     if (reader->state == XML_TEXTREADER_END)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 2
	je	SHORT $LN15@xmlTextRea

; 1897 :         return(0);
; 1898 : 
; 1899 :     if (reader->node == NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	jne	SHORT $LN4@xmlTextRea

; 1900 :         if (reader->doc->children == NULL) {

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea
$LN14@xmlTextRea:

; 1947 : 
; 1948 :     return(1);
; 1949 : }

	mov	DWORD PTR [esi+64], eax
	mov	eax, 1
	mov	DWORD PTR [esi+16], 0
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 1901 :             reader->state = XML_TEXTREADER_END;
; 1902 :             return(0);
; 1903 :         }
; 1904 : 
; 1905 :         reader->node = reader->doc->children;
; 1906 :         reader->state = XML_TEXTREADER_START;
; 1907 :         return(1);
; 1908 :     }
; 1909 : 
; 1910 :     if (reader->state != XML_TEXTREADER_BACKTRACK) {

	cmp	ecx, 4
	je	SHORT $LN6@xmlTextRea

; 1911 : 	/* Here removed traversal to child, because we want to skip the subtree,
; 1912 : 	replace with traversal to sibling to skip subtree */
; 1913 :         if (reader->node->next != 0) {

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LN14@xmlTextRea

; 1914 : 	    /* Move to sibling if present,skipping sub-tree */
; 1915 :             reader->node = reader->node->next;
; 1916 :             reader->state = XML_TEXTREADER_START;
; 1917 :             return(1);
; 1918 :         }
; 1919 : 
; 1920 : 	/* if reader->node->next is NULL mean no subtree for current node,
; 1921 : 	so need to move to sibling of parent node if present */
; 1922 : 	reader->state = XML_TEXTREADER_BACKTRACK;
; 1923 : 	/* This will move to parent if present */
; 1924 : 	xmlTextReaderRead(reader);

	push	esi
	mov	DWORD PTR [esi+16], 4
	call	_xmlTextReaderRead
	mov	eax, DWORD PTR [esi+64]
	add	esp, 4
$LN6@xmlTextRea:

; 1925 :     }
; 1926 : 
; 1927 :     if (reader->node->next != 0) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN8@xmlTextRea

; 1928 :         reader->node = reader->node->next;

	mov	DWORD PTR [esi+64], ecx

; 1947 : 
; 1948 :     return(1);
; 1949 : }

	mov	eax, 1
	mov	DWORD PTR [esi+16], 0
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 1929 :         reader->state = XML_TEXTREADER_START;
; 1930 :         return(1);
; 1931 :     }
; 1932 : 
; 1933 :     if (reader->node->parent != 0) {

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 1934 :         if (reader->node->parent->type == XML_DOCUMENT_NODE) {

	cmp	DWORD PTR [eax+4], 9
	jne	SHORT $LN10@xmlTextRea
$LN12@xmlTextRea:

; 1935 :             reader->state = XML_TEXTREADER_END;

	mov	DWORD PTR [esi+16], 2
$LN15@xmlTextRea:

; 1947 : 
; 1948 :     return(1);
; 1949 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 1936 :             return(0);
; 1937 :         }
; 1938 : 
; 1939 :         reader->node = reader->node->parent;
; 1940 :         reader->depth--;

	dec	DWORD PTR [esi+72]

; 1941 :         reader->state = XML_TEXTREADER_BACKTRACK;
; 1942 : 	/* Repeat process to move to sibling of parent node if present */
; 1943 :         xmlTextReaderNextTree(reader);

	push	esi
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+16], 4
	call	_xmlTextReaderNextTree
	add	esp, 4
$LN9@xmlTextRea:

; 1944 :     }
; 1945 : 
; 1946 :     reader->state = XML_TEXTREADER_END;

	mov	DWORD PTR [esi+16], 2

; 1947 : 
; 1948 :     return(1);
; 1949 : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderNextTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadTree
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderReadTree PROC				; COMDAT

; 1962 : xmlTextReaderReadTree(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, 2
	jne	SHORT $LN19@xmlTextRea

; 1963 :     if (reader->state == XML_TEXTREADER_END)
; 1964 :         return(0);

	xor	eax, eax

; 2022 : }

	pop	ebp
	ret	0
$LN19@xmlTextRea:

; 1968 :         if (reader->doc->children == NULL) {

	mov	eax, DWORD PTR [ecx+64]
	push	esi
$next_node$27:

; 1965 : 
; 1966 : next_node:
; 1967 :     if (reader->node == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlTextRea

; 1968 :         if (reader->doc->children == NULL) {

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN18@xmlTextRea

; 1969 :             reader->state = XML_TEXTREADER_END;
; 1970 :             return(0);
; 1971 :         }
; 1972 : 
; 1973 :         reader->node = reader->doc->children;

	mov	DWORD PTR [ecx+64], eax

; 1974 :         reader->state = XML_TEXTREADER_START;

	xor	edx, edx
	mov	DWORD PTR [ecx+16], 0

; 1975 :         goto found_node;

	jmp	$found_node$28
$LN3@xmlTextRea:

; 1976 :     }
; 1977 : 
; 1978 :     if ((reader->state != XML_TEXTREADER_BACKTRACK) &&
; 1979 :         (reader->node->type != XML_DTD_NODE) &&
; 1980 :         (reader->node->type != XML_XINCLUDE_START) &&

	cmp	edx, 4
	je	SHORT $LN7@xmlTextRea
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 14					; 0000000eH
	je	SHORT $LN7@xmlTextRea
	cmp	edx, 19					; 00000013H
	je	SHORT $LN7@xmlTextRea
	cmp	edx, 5
	je	SHORT $LN7@xmlTextRea

; 1981 : 	(reader->node->type != XML_ENTITY_REF_NODE)) {
; 1982 :         if (reader->node->children != NULL) {

	mov	esi, DWORD PTR [eax+12]
	test	esi, esi
	je	SHORT $LN6@xmlTextRea

; 1983 :             reader->node = reader->node->children;
; 1984 :             reader->depth++;

	inc	DWORD PTR [ecx+72]

; 1985 :             reader->state = XML_TEXTREADER_START;

	mov	eax, esi
	mov	DWORD PTR [ecx+64], esi
	xor	edx, edx
	mov	DWORD PTR [ecx+16], 0

; 1986 :             goto found_node;

	jmp	SHORT $found_node$28
$LN6@xmlTextRea:

; 1987 :         }
; 1988 : 
; 1989 :         if (reader->node->type == XML_ATTRIBUTE_NODE) {

	cmp	edx, 2
	jne	SHORT $LN7@xmlTextRea

; 1990 :             reader->state = XML_TEXTREADER_BACKTRACK;

	mov	DWORD PTR [ecx+16], 4
	mov	edx, 4

; 1991 :             goto found_node;

	jmp	SHORT $found_node$28
$LN7@xmlTextRea:

; 1992 :         }
; 1993 :     }
; 1994 : 
; 1995 :     if (reader->node->next != NULL) {

	mov	esi, DWORD PTR [eax+24]
	test	esi, esi
	je	SHORT $LN8@xmlTextRea

; 1996 :         reader->node = reader->node->next;

	mov	DWORD PTR [ecx+64], esi

; 1997 :         reader->state = XML_TEXTREADER_START;

	xor	edx, edx
	mov	DWORD PTR [ecx+16], 0
	mov	eax, esi

; 1998 :         goto found_node;

	jmp	SHORT $found_node$28
$LN8@xmlTextRea:

; 1999 :     }
; 2000 : 
; 2001 :     if (reader->node->parent != NULL) {

	mov	edx, DWORD PTR [eax+20]
	test	edx, edx
	je	SHORT $LN9@xmlTextRea

; 2002 :         if ((reader->node->parent->type == XML_DOCUMENT_NODE) ||

	mov	esi, DWORD PTR [edx+4]
	mov	eax, edx
	cmp	esi, 9
	je	SHORT $LN18@xmlTextRea
	cmp	esi, 13					; 0000000dH
	je	SHORT $LN18@xmlTextRea

; 2006 :         }
; 2007 : 
; 2008 :         reader->node = reader->node->parent;
; 2009 :         reader->depth--;

	dec	DWORD PTR [ecx+72]
	mov	DWORD PTR [ecx+64], edx

; 2010 :         reader->state = XML_TEXTREADER_BACKTRACK;

	mov	edx, 4
	mov	DWORD PTR [ecx+16], 4

; 2011 :         goto found_node;

	jmp	SHORT $found_node$28
$LN9@xmlTextRea:

; 2012 :     }
; 2013 : 
; 2014 :     reader->state = XML_TEXTREADER_END;

	mov	DWORD PTR [ecx+16], 2
	mov	edx, 2
$found_node$28:

; 2015 : 
; 2016 : found_node:
; 2017 :     if ((reader->node->type == XML_XINCLUDE_START) ||

	mov	esi, DWORD PTR [eax+4]
	cmp	esi, 19					; 00000013H
	je	$next_node$27
	cmp	esi, 20					; 00000014H
	je	$next_node$27

; 2018 :         (reader->node->type == XML_XINCLUDE_END))
; 2019 : 	goto next_node;
; 2020 : 
; 2021 :     return(1);

	mov	eax, 1
	pop	esi

; 2022 : }

	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 2003 : 	    (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {
; 2004 :             reader->state = XML_TEXTREADER_END;

	mov	DWORD PTR [ecx+16], 2

; 2005 :             return(0);

	xor	eax, eax
	pop	esi

; 2022 : }

	pop	ebp
	ret	0
_xmlTextReaderReadTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetErrorHandler
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_f$ = 12						; size = 4
_arg$ = 16						; size = 4
_xmlTextReaderGetErrorHandler PROC			; COMDAT

; 5096 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlTextRea

; 5097 :     if (f != NULL)
; 5098 :         *f = reader->errorFunc;

	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx], eax
$LN2@xmlTextRea:

; 5099 :     if (arg != NULL)

	mov	ecx, DWORD PTR _arg$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 5100 :         *arg = reader->errorFuncArg;

	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx], eax
$LN3@xmlTextRea:

; 5101 : }

	pop	ebp
	ret	0
_xmlTextReaderGetErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSetStructuredErrorHandler
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_f$ = 12						; size = 4
_arg$ = 16						; size = 4
_xmlTextReaderSetStructuredErrorHandler PROC		; COMDAT

; 5008 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN2@xmlTextRea

; 5009 :     if (f != NULL) {
; 5010 :         reader->ctxt->sax->error = NULL;
; 5011 :         reader->ctxt->sax->serror = xmlTextReaderStructuredError;

	mov	DWORD PTR [eax+88], 0
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+124], OFFSET _xmlTextReaderStructuredError

; 5012 :         reader->ctxt->vctxt.error = xmlTextReaderValidityError;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+112], OFFSET _xmlTextReaderValidityError

; 5013 :         reader->ctxt->sax->warning = xmlTextReaderWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+84], OFFSET _xmlTextReaderWarning

; 5014 :         reader->ctxt->vctxt.warning = xmlTextReaderValidityWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+116], OFFSET _xmlTextReaderValidityWarning

; 5015 :         reader->sErrorFunc = f;
; 5016 :         reader->errorFunc = NULL;
; 5017 :         reader->errorFuncArg = arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR [esi+112], eax

; 5018 : #ifdef LIBXML_SCHEMAS_ENABLED
; 5019 :         if (reader->rngValidCtxt) {

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+192], ecx
	mov	DWORD PTR [esi+108], 0
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 5020 :             xmlRelaxNGSetValidErrors(reader->rngValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
	push	eax
	call	_xmlRelaxNGSetValidErrors

; 5021 :                                      reader);
; 5022 :             xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN4@xmlTextRea:

; 5023 :                                         xmlTextReaderValidityStructuredRelay,
; 5024 :                                                reader);
; 5025 :         }
; 5026 :         if (reader->xsdValidCtxt) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	$LN7@xmlTextRea

; 5027 :             xmlSchemaSetValidErrors(reader->xsdValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
	push	eax
	call	_xmlSchemaSetValidErrors

; 5028 :                                     reader);
; 5029 :             xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay

; 5055 :                                               reader);
; 5056 :         }
; 5057 : #endif
; 5058 :     }
; 5059 : }

	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 5030 :                                        xmlTextReaderValidityStructuredRelay,
; 5031 :                                               reader);
; 5032 :         }
; 5033 : #endif
; 5034 :     } else {
; 5035 :         /* restore defaults */
; 5036 :         reader->ctxt->sax->error = xmlParserError;

	mov	DWORD PTR [eax+88], OFFSET _xmlParserError

; 5037 :         reader->ctxt->sax->serror = NULL;

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+124], 0

; 5038 :         reader->ctxt->vctxt.error = xmlParserValidityError;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+112], OFFSET _xmlParserValidityError

; 5039 :         reader->ctxt->sax->warning = xmlParserWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+84], OFFSET _xmlParserWarning

; 5040 :         reader->ctxt->vctxt.warning = xmlParserValidityWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+116], OFFSET _xmlParserValidityWarning

; 5041 :         reader->errorFunc = NULL;
; 5042 :         reader->sErrorFunc = NULL;
; 5043 :         reader->errorFuncArg = NULL;
; 5044 : #ifdef LIBXML_SCHEMAS_ENABLED
; 5045 :         if (reader->rngValidCtxt) {

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+108], 0
	mov	DWORD PTR [esi+192], 0
	mov	DWORD PTR [esi+112], 0
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 5046 :             xmlRelaxNGSetValidErrors(reader->rngValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
	push	eax
	call	_xmlRelaxNGSetValidErrors

; 5047 :                                      reader);
; 5048 :             xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt, NULL,

	push	esi
	push	0
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN6@xmlTextRea:

; 5049 :                                                reader);
; 5050 :         }
; 5051 :         if (reader->xsdValidCtxt) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 5052 :             xmlSchemaSetValidErrors(reader->xsdValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
	push	eax
	call	_xmlSchemaSetValidErrors

; 5053 :                                     reader);
; 5054 :             xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt, NULL,

	push	esi
	push	0

; 5055 :                                               reader);
; 5056 :         }
; 5057 : #endif
; 5058 :     }
; 5059 : }

	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN7@xmlTextRea:
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderSetStructuredErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSetErrorHandler
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_f$ = 12						; size = 4
_arg$ = 16						; size = 4
_xmlTextReaderSetErrorHandler PROC			; COMDAT

; 4941 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN2@xmlTextRea

; 4942 :     if (f != NULL) {
; 4943 :         reader->ctxt->sax->error = xmlTextReaderError;
; 4944 :         reader->ctxt->sax->serror = NULL;

	mov	DWORD PTR [eax+88], OFFSET _xmlTextReaderError
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+124], 0

; 4945 :         reader->ctxt->vctxt.error = xmlTextReaderValidityError;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+112], OFFSET _xmlTextReaderValidityError

; 4946 :         reader->ctxt->sax->warning = xmlTextReaderWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+84], OFFSET _xmlTextReaderWarning

; 4947 :         reader->ctxt->vctxt.warning = xmlTextReaderValidityWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+116], OFFSET _xmlTextReaderValidityWarning

; 4948 :         reader->errorFunc = f;
; 4949 :         reader->sErrorFunc = NULL;
; 4950 :         reader->errorFuncArg = arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR [esi+112], eax

; 4951 : #ifdef LIBXML_SCHEMAS_ENABLED
; 4952 :         if (reader->rngValidCtxt) {

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+108], ecx
	mov	DWORD PTR [esi+192], 0
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 4953 :             xmlRelaxNGSetValidErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	eax
	call	_xmlRelaxNGSetValidErrors

; 4954 :                                      xmlTextReaderValidityErrorRelay,
; 4955 :                                      xmlTextReaderValidityWarningRelay,
; 4956 :                                      reader);
; 4957 :             xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt, NULL,

	push	esi
	push	0
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN4@xmlTextRea:

; 4958 :                                                reader);
; 4959 :         }
; 4960 :         if (reader->xsdValidCtxt) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	$LN7@xmlTextRea

; 4961 :             xmlSchemaSetValidErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay

; 4962 :                                     xmlTextReaderValidityErrorRelay,
; 4963 :                                     xmlTextReaderValidityWarningRelay,
; 4964 :                                     reader);
; 4965 :             xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt, NULL,
; 4966 :                                               reader);
; 4967 :         }
; 4968 : #endif
; 4969 :     } else {

	jmp	SHORT $LN9@xmlTextRea
$LN2@xmlTextRea:

; 4970 :         /* restore defaults */
; 4971 :         reader->ctxt->sax->error = xmlParserError;

	mov	DWORD PTR [eax+88], OFFSET _xmlParserError

; 4972 :         reader->ctxt->vctxt.error = xmlParserValidityError;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+112], OFFSET _xmlParserValidityError

; 4973 :         reader->ctxt->sax->warning = xmlParserWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+84], OFFSET _xmlParserWarning

; 4974 :         reader->ctxt->vctxt.warning = xmlParserValidityWarning;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+116], OFFSET _xmlParserValidityWarning

; 4975 :         reader->errorFunc = NULL;
; 4976 :         reader->sErrorFunc = NULL;
; 4977 :         reader->errorFuncArg = NULL;
; 4978 : #ifdef LIBXML_SCHEMAS_ENABLED
; 4979 :         if (reader->rngValidCtxt) {

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+108], 0
	mov	DWORD PTR [esi+192], 0
	mov	DWORD PTR [esi+112], 0
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 4980 :             xmlRelaxNGSetValidErrors(reader->rngValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
	push	eax
	call	_xmlRelaxNGSetValidErrors

; 4981 :                                      reader);
; 4982 :             xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt, NULL,

	push	esi
	push	0
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN6@xmlTextRea:

; 4983 :                                                reader);
; 4984 :         }
; 4985 :         if (reader->xsdValidCtxt) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 4986 :             xmlSchemaSetValidErrors(reader->xsdValidCtxt, NULL, NULL,

	push	esi
	push	0
	push	0
$LN9@xmlTextRea:

; 4987 :                                     reader);
; 4988 :             xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt, NULL,
; 4989 :                                               reader);
; 4990 :         }
; 4991 : #endif
; 4992 :     }
; 4993 : }

	push	eax
	call	_xmlSchemaSetValidErrors
	push	esi
	push	0
	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 28					; 0000001cH
$LN7@xmlTextRea:
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderSetErrorHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderLocatorBaseURI
_TEXT	SEGMENT
_locator$ = 8						; size = 4
_xmlTextReaderLocatorBaseURI PROC			; COMDAT

; 4808 : xmlTextReaderLocatorBaseURI(xmlTextReaderLocatorPtr locator) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _locator$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 4809 :     /* we know that locator is a xmlParserCtxtPtr */
; 4810 :     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr)locator;
; 4811 :     xmlChar *ret = NULL;
; 4812 : 
; 4813 :     if (locator == NULL)
; 4814 :         return(NULL);
; 4815 :     if (ctx->node != NULL) {

	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 4816 : 	ret = xmlNodeGetBase(NULL,ctx->node);

	push	ecx
	push	0
	call	_xmlNodeGetBase
	add	esp, 8

; 4826 : 	}
; 4827 : 	else {
; 4828 : 	    ret = NULL;
; 4829 : 	}
; 4830 :     }
; 4831 : 
; 4832 :     return ret;
; 4833 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 4817 :     }
; 4818 :     else {
; 4819 : 	/* inspired from error.c */
; 4820 : 	xmlParserInputPtr input;
; 4821 : 	input = ctx->input;

	mov	ecx, DWORD PTR [eax+36]

; 4822 : 	if ((input->filename == NULL) && (ctx->inputNr > 1))

	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@xmlTextRea
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, 1
	jle	SHORT $LN5@xmlTextRea

; 4823 : 	    input = ctx->inputTab[ctx->inputNr - 2];

	mov	eax, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR [eax+edx*4-8]
$LN5@xmlTextRea:

; 4824 : 	if (input != NULL) {

	test	ecx, ecx
	je	SHORT $LN6@xmlTextRea

; 4825 : 	    ret = xmlStrdup(BAD_CAST input->filename);

	push	DWORD PTR [ecx+4]
	call	_xmlStrdup
	add	esp, 4

; 4826 : 	}
; 4827 : 	else {
; 4828 : 	    ret = NULL;
; 4829 : 	}
; 4830 :     }
; 4831 : 
; 4832 :     return ret;
; 4833 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:
	xor	eax, eax
	pop	ebp
	ret	0
_xmlTextReaderLocatorBaseURI ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderLocatorLineNumber
_TEXT	SEGMENT
_locator$ = 8						; size = 4
_xmlTextReaderLocatorLineNumber PROC			; COMDAT

; 4771 : xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _locator$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 4772 :     /* we know that locator is a xmlParserCtxtPtr */
; 4773 :     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr)locator;
; 4774 :     int ret = -1;
; 4775 : 
; 4776 :     if (locator == NULL)
; 4777 :         return(-1);
; 4778 :     if (ctx->node != NULL) {

	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 4779 : 	ret = xmlGetLineNo(ctx->node);

	mov	DWORD PTR _locator$[ebp], ecx

; 4789 : 	}
; 4790 : 	else {
; 4791 : 	    ret = -1;
; 4792 : 	}
; 4793 :     }
; 4794 : 
; 4795 :     return ret;
; 4796 : }

	pop	ebp

; 4779 : 	ret = xmlGetLineNo(ctx->node);

	jmp	_xmlGetLineNo
$LN3@xmlTextRea:

; 4780 :     }
; 4781 :     else {
; 4782 : 	/* inspired from error.c */
; 4783 : 	xmlParserInputPtr input;
; 4784 : 	input = ctx->input;

	mov	ecx, DWORD PTR [eax+36]

; 4785 : 	if ((input->filename == NULL) && (ctx->inputNr > 1))

	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN5@xmlTextRea
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, 1
	jle	SHORT $LN5@xmlTextRea

; 4786 : 	    input = ctx->inputTab[ctx->inputNr - 2];

	mov	eax, DWORD PTR [eax+48]
	mov	ecx, DWORD PTR [eax+edx*4-8]
$LN5@xmlTextRea:

; 4787 : 	if (input != NULL) {

	test	ecx, ecx
	je	SHORT $LN6@xmlTextRea

; 4788 : 	    ret = input->line;

	mov	eax, DWORD PTR [ecx+28]

; 4789 : 	}
; 4790 : 	else {
; 4791 : 	    ret = -1;
; 4792 : 	}
; 4793 :     }
; 4794 : 
; 4795 :     return ret;
; 4796 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:
	or	eax, -1
	pop	ebp
	ret	0
_xmlTextReaderLocatorLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewIO
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_ioread$ = 12						; size = 4
_ioclose$ = 16						; size = 4
_ioctx$ = 20						; size = 4
_URL$ = 24						; size = 4
_encoding$ = 28						; size = 4
_options$ = 32						; size = 4
_xmlReaderNewIO PROC					; COMDAT

; 5732 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ioread$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlReaderN

; 5733 :     xmlParserInputBufferPtr input;
; 5734 : 
; 5735 :     if (ioread == NULL)
; 5736 :         return (-1);
; 5737 :     if (reader == NULL)

	cmp	DWORD PTR _reader$[ebp], 0
	je	SHORT $LN5@xmlReaderN

; 5738 :         return (-1);
; 5739 : 
; 5740 :     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	mov	esi, DWORD PTR _ioclose$[ebp]
	push	0
	push	DWORD PTR _ioctx$[ebp]
	push	esi
	push	eax
	call	_xmlParserInputBufferCreateIO
	add	esp, 16					; 00000010H

; 5741 :                                          XML_CHAR_ENCODING_NONE);
; 5742 :     if (input == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlReaderN

; 5743 :         if (ioclose != NULL)

	test	esi, esi
	je	SHORT $LN5@xmlReaderN

; 5744 :             ioclose(ioctx);

	push	DWORD PTR _ioctx$[ebp]
	call	esi
	add	esp, 4
$LN5@xmlReaderN:

; 5745 :         return (-1);

	or	eax, -1
	pop	esi

; 5748 : }

	pop	ebp
	ret	0
$LN4@xmlReaderN:

; 5746 :     }
; 5747 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	eax
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H
	pop	esi

; 5748 : }

	pop	ebp
	ret	0
_xmlReaderNewIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewFd
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_fd$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlReaderNewFd PROC					; COMDAT

; 5696 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _fd$[ebp]
	test	eax, eax
	js	SHORT $LN6@xmlReaderN

; 5697 :     xmlParserInputBufferPtr input;
; 5698 : 
; 5699 :     if (fd < 0)
; 5700 :         return (-1);
; 5701 :     if (reader == NULL)

	cmp	DWORD PTR _reader$[ebp], 0
	je	SHORT $LN6@xmlReaderN

; 5702 :         return (-1);
; 5703 : 
; 5704 :     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	push	0
	push	eax
	call	_xmlParserInputBufferCreateFd
	add	esp, 8

; 5705 :     if (input == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlReaderN

; 5707 :     input->closecallback = NULL;

	mov	DWORD PTR [eax+8], 0

; 5708 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	mov	DWORD PTR _fd$[ebp], eax

; 5709 : }

	pop	ebp

; 5708 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	jmp	_xmlTextReaderSetup
$LN6@xmlReaderN:

; 5706 :         return (-1);

	or	eax, -1

; 5709 : }

	pop	ebp
	ret	0
_xmlReaderNewFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewMemory
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlReaderNewMemory PROC				; COMDAT

; 5661 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _reader$[ebp], 0
	je	SHORT $LN6@xmlReaderN

; 5662 :     xmlParserInputBufferPtr input;
; 5663 : 
; 5664 :     if (reader == NULL)
; 5665 :         return (-1);
; 5666 :     if (buffer == NULL)

	mov	eax, DWORD PTR _buffer$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlReaderN

; 5667 :         return (-1);
; 5668 : 
; 5669 :     input = xmlParserInputBufferCreateStatic(buffer, size,

	push	0
	push	DWORD PTR _size$[ebp]
	push	eax
	call	_xmlParserInputBufferCreateStatic
	add	esp, 12					; 0000000cH

; 5670 :                                       XML_CHAR_ENCODING_NONE);
; 5671 :     if (input == NULL) {

	test	eax, eax
	je	SHORT $LN6@xmlReaderN

; 5673 :     }
; 5674 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	eax
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H

; 5675 : }

	pop	ebp
	ret	0
$LN6@xmlReaderN:

; 5672 :         return (-1);

	or	eax, -1

; 5675 : }

	pop	ebp
	ret	0
_xmlReaderNewMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewFile
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_filename$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReaderNewFile PROC					; COMDAT

; 5627 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlReaderN

; 5628 :     xmlParserInputBufferPtr input;
; 5629 : 
; 5630 :     if (filename == NULL)
; 5631 :         return (-1);
; 5632 :     if (reader == NULL)

	cmp	DWORD PTR _reader$[ebp], 0
	je	SHORT $LN6@xmlReaderN

; 5633 :         return (-1);
; 5634 : 
; 5635 :     input =

	push	0
	push	esi
	call	_xmlParserInputBufferCreateFilename
	add	esp, 8

; 5636 :         xmlParserInputBufferCreateFilename(filename,
; 5637 :                                            XML_CHAR_ENCODING_NONE);
; 5638 :     if (input == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlReaderN

; 5640 :     return (xmlTextReaderSetup(reader, input, filename, encoding, options));

	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	esi
	push	eax
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H
	pop	esi

; 5641 : }

	pop	ebp
	ret	0
$LN6@xmlReaderN:

; 5639 :         return (-1);

	or	eax, -1
	pop	esi

; 5641 : }

	pop	ebp
	ret	0
_xmlReaderNewFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewDoc
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_cur$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlReaderNewDoc PROC					; COMDAT

; 5597 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN10@xmlReaderN

; 5598 : 
; 5599 :     int len;
; 5600 : 
; 5601 :     if (cur == NULL)
; 5602 :         return (-1);
; 5603 :     if (reader == NULL)

	cmp	DWORD PTR _reader$[ebp], 0
	je	SHORT $LN10@xmlReaderN

; 5604 :         return (-1);
; 5605 : 
; 5606 :     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 5669 :     input = xmlParserInputBufferCreateStatic(buffer, size,

	push	0
	push	eax
	push	esi
	call	_xmlParserInputBufferCreateStatic
	add	esp, 16					; 00000010H

; 5670 :                                       XML_CHAR_ENCODING_NONE);
; 5671 :     if (input == NULL) {

	test	eax, eax
	je	SHORT $LN10@xmlReaderN
	pop	esi

; 5672 :         return (-1);
; 5673 :     }
; 5674 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	mov	DWORD PTR _cur$[ebp], eax

; 5607 :     return (xmlReaderNewMemory(reader, (const char *)cur, len,
; 5608 :                                URL, encoding, options));
; 5609 : }

	pop	ebp

; 5674 :     return (xmlTextReaderSetup(reader, input, URL, encoding, options));

	jmp	_xmlTextReaderSetup
$LN10@xmlReaderN:

; 5607 :     return (xmlReaderNewMemory(reader, (const char *)cur, len,
; 5608 :                                URL, encoding, options));
; 5609 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlReaderNewDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderNewWalker
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlReaderNewWalker PROC				; COMDAT

; 5548 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN10@xmlReaderN

; 5549 :     if (doc == NULL)
; 5550 :         return (-1);
; 5551 :     if (reader == NULL)

	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN10@xmlReaderN

; 5553 : 
; 5554 :     if (reader->input != NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN4@xmlReaderN

; 5555 :         xmlFreeParserInputBuffer(reader->input);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN4@xmlReaderN:

; 5556 :     }
; 5557 :     if (reader->ctxt != NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN5@xmlReaderN

; 5558 : 	xmlCtxtReset(reader->ctxt);

	push	eax
	call	_xmlCtxtReset
	add	esp, 4
$LN5@xmlReaderN:

; 5559 :     }
; 5560 : 
; 5561 :     reader->entNr = 0;
; 5562 :     reader->input = NULL;
; 5563 :     reader->mode = XML_TEXTREADER_MODE_INITIAL;
; 5564 :     reader->node = NULL;
; 5565 :     reader->curnode = NULL;
; 5566 :     reader->base = 0;
; 5567 :     reader->cur = 0;
; 5568 :     reader->allocs = XML_TEXTREADER_CTXT;
; 5569 :     reader->doc = doc;
; 5570 :     reader->state = XML_TEXTREADER_START;
; 5571 :     if (reader->dict == NULL) {

	cmp	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+12], 2
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+16], 0
	jne	SHORT $LN8@xmlReaderN

; 5572 :         if ((reader->ctxt != NULL) && (reader->ctxt->dict != NULL))

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN7@xmlReaderN
	mov	eax, DWORD PTR [eax+296]
	test	eax, eax
	jne	SHORT $LN11@xmlReaderN
$LN7@xmlReaderN:

; 5573 : 	    reader->dict = reader->ctxt->dict;
; 5574 : 	else
; 5575 : 	    reader->dict = xmlDictCreate();

	call	_xmlDictCreate
$LN11@xmlReaderN:

; 5576 :     }
; 5577 :     return(0);

	mov	DWORD PTR [esi+88], eax
$LN8@xmlReaderN:
	pop	edi
	xor	eax, eax

; 5578 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlReaderN:
	pop	edi

; 5552 :         return (-1);

	or	eax, -1

; 5578 : }

	pop	esi
	pop	ebp
	ret	0
_xmlReaderNewWalker ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderForIO
_TEXT	SEGMENT
_ioread$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlReaderForIO PROC					; COMDAT

; 5512 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ioread$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlReaderF

; 5513 :     xmlTextReaderPtr reader;
; 5514 :     xmlParserInputBufferPtr input;
; 5515 : 
; 5516 :     if (ioread == NULL)
; 5517 :         return (NULL);
; 5518 : 
; 5519 :     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	mov	ebx, DWORD PTR _ioctx$[ebp]
	mov	esi, DWORD PTR _ioclose$[ebp]
	push	0
	push	ebx
	push	esi
	push	eax
	call	_xmlParserInputBufferCreateIO
	mov	edi, eax
	add	esp, 16					; 00000010H

; 5520 :                                          XML_CHAR_ENCODING_NONE);
; 5521 :     if (input == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlReaderF

; 5522 :         if (ioclose != NULL)

	test	esi, esi
	je	SHORT $LN4@xmlReaderF

; 5523 :             ioclose(ioctx);

	push	ebx
	call	esi

; 5534 : }

	add	esp, 4
$LN4@xmlReaderF:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlReaderF:

; 5524 :         return (NULL);
; 5525 :     }
; 5526 :     reader = xmlNewTextReader(input, URL);

	mov	ebx, DWORD PTR _URL$[ebp]
	push	ebx
	push	edi
	call	_xmlNewTextReader
	mov	esi, eax
	add	esp, 8

; 5527 :     if (reader == NULL) {

	test	esi, esi
	jne	SHORT $LN5@xmlReaderF

; 5528 :         xmlFreeParserInputBuffer(input);

	push	edi
	call	_xmlFreeParserInputBuffer

; 5534 : }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlReaderF:

; 5529 :         return (NULL);
; 5530 :     }
; 5531 :     reader->allocs |= XML_TEXTREADER_INPUT;
; 5532 :     xmlTextReaderSetup(reader, NULL, URL, encoding, options);

	push	DWORD PTR _options$[ebp]
	or	DWORD PTR [esi+12], 1
	push	DWORD PTR _encoding$[ebp]
	push	ebx
	push	0
	push	esi
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H

; 5533 :     return (reader);

	mov	eax, esi
	pop	edi

; 5534 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlReaderForIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderForFd
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReaderForFd PROC					; COMDAT

; 5473 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _fd$[ebp]
	test	eax, eax
	js	SHORT $LN6@xmlReaderF

; 5474 :     xmlTextReaderPtr reader;
; 5475 :     xmlParserInputBufferPtr input;
; 5476 : 
; 5477 :     if (fd < 0)
; 5478 :         return (NULL);
; 5479 : 
; 5480 :     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	push	0
	push	eax
	call	_xmlParserInputBufferCreateFd
	mov	esi, eax
	add	esp, 8

; 5481 :     if (input == NULL)

	test	esi, esi
	je	SHORT $LN6@xmlReaderF

; 5483 :     input->closecallback = NULL;

	push	edi

; 5484 :     reader = xmlNewTextReader(input, URL);

	push	DWORD PTR _URL$[ebp]
	mov	DWORD PTR [esi+8], 0
	push	esi
	call	_xmlNewTextReader
	mov	edi, eax
	add	esp, 8

; 5485 :     if (reader == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlReaderF

; 5486 :         xmlFreeParserInputBuffer(input);

	push	esi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 5487 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 5492 : }

	pop	ebp
	ret	0
$LN4@xmlReaderF:

; 5488 :     }
; 5489 :     reader->allocs |= XML_TEXTREADER_INPUT;
; 5490 :     xmlTextReaderSetup(reader, NULL, URL, encoding, options);

	push	DWORD PTR _options$[ebp]
	or	DWORD PTR [edi+12], 1
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	0
	push	edi
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H

; 5491 :     return (reader);

	mov	eax, edi
	pop	edi
	pop	esi

; 5492 : }

	pop	ebp
	ret	0
$LN6@xmlReaderF:

; 5482 :         return (NULL);

	xor	eax, eax
	pop	esi

; 5492 : }

	pop	ebp
	ret	0
_xmlReaderForFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderForMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlReaderForMemory PROC				; COMDAT

; 5438 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_xmlParserInputBufferCreateStatic
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	jne	SHORT $LN2@xmlReaderF
	pop	edi

; 5455 : }

	pop	ebp
	ret	0
$LN2@xmlReaderF:
	push	esi

; 5439 :     xmlTextReaderPtr reader;
; 5440 :     xmlParserInputBufferPtr buf;
; 5441 : 
; 5442 :     buf = xmlParserInputBufferCreateStatic(buffer, size,
; 5443 :                                       XML_CHAR_ENCODING_NONE);
; 5444 :     if (buf == NULL) {
; 5445 :         return (NULL);
; 5446 :     }
; 5447 :     reader = xmlNewTextReader(buf, URL);

	push	DWORD PTR _URL$[ebp]
	push	edi
	call	_xmlNewTextReader
	mov	esi, eax
	add	esp, 8

; 5448 :     if (reader == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlReaderF

; 5449 :         xmlFreeParserInputBuffer(buf);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 5450 :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5455 : }

	pop	ebp
	ret	0
$LN3@xmlReaderF:

; 5451 :     }
; 5452 :     reader->allocs |= XML_TEXTREADER_INPUT;
; 5453 :     xmlTextReaderSetup(reader, NULL, URL, encoding, options);

	push	DWORD PTR _options$[ebp]
	or	DWORD PTR [esi+12], 1
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	0
	push	esi
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H

; 5454 :     return (reader);

	mov	eax, esi
	pop	esi
	pop	edi

; 5455 : }

	pop	ebp
	ret	0
_xmlReaderForMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderForFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlReaderForFile PROC					; COMDAT

; 5412 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _filename$[ebp]
	call	_xmlNewTextReaderFilename
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlReaderF
	pop	esi

; 5420 : }

	pop	ebp
	ret	0
$LN2@xmlReaderF:

; 5413 :     xmlTextReaderPtr reader;
; 5414 : 
; 5415 :     reader = xmlNewTextReaderFilename(filename);
; 5416 :     if (reader == NULL)
; 5417 :         return (NULL);
; 5418 :     xmlTextReaderSetup(reader, NULL, NULL, encoding, options);

	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	0
	push	0
	push	esi
	call	_xmlTextReaderSetup
	add	esp, 20					; 00000014H

; 5419 :     return (reader);

	mov	eax, esi
	pop	esi

; 5420 : }

	pop	ebp
	ret	0
_xmlReaderForFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderForDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReaderForDoc PROC					; COMDAT

; 5388 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlReaderF

; 5389 :     int len;
; 5390 : 
; 5391 :     if (cur == NULL)
; 5392 :         return (NULL);

	xor	eax, eax
	pop	esi

; 5396 :             ((const char *) cur, len, URL, encoding, options));
; 5397 : }

	pop	ebp
	ret	0
$LN2@xmlReaderF:

; 5393 :     len = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen

; 5394 : 
; 5395 :     return (xmlReaderForMemory

	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _URL$[ebp]
	push	eax
	push	esi
	call	_xmlReaderForMemory
	add	esp, 24					; 00000018H
	pop	esi

; 5396 :             ((const char *) cur, len, URL, encoding, options));
; 5397 : }

	pop	ebp
	ret	0
_xmlReaderForDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlReaderWalker
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlReaderWalker PROC					; COMDAT

; 5346 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlReaderW

; 5347 :     xmlTextReaderPtr ret;
; 5348 : 
; 5349 :     if (doc == NULL)
; 5350 :         return(NULL);

	xor	eax, eax
	pop	edi

; 5371 : }

	pop	ebp
	ret	0
$LN2@xmlReaderW:
	push	esi

; 5351 : 
; 5352 :     ret = xmlMalloc(sizeof(xmlTextReader));

	push	196					; 000000c4H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5353 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlReaderW

; 5354 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 5355 : 		"xmlNewTextReader : malloc failed\n");
; 5356 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 5371 : }

	pop	ebp
	ret	0
$LN3@xmlReaderW:

; 5357 :     }
; 5358 :     memset(ret, 0, sizeof(xmlTextReader));

	push	196					; 000000c4H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 5359 :     ret->entNr = 0;
; 5360 :     ret->input = NULL;
; 5361 :     ret->mode = XML_TEXTREADER_MODE_INITIAL;
; 5362 :     ret->node = NULL;
; 5363 :     ret->curnode = NULL;
; 5364 :     ret->base = 0;
; 5365 :     ret->cur = 0;
; 5366 :     ret->allocs = XML_TEXTREADER_CTXT;

	mov	DWORD PTR [esi+12], 2

; 5367 :     ret->doc = doc;

	mov	DWORD PTR [esi+4], edi

; 5368 :     ret->state = XML_TEXTREADER_START;

	mov	DWORD PTR [esi+16], 0

; 5369 :     ret->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR [esi+88], eax

; 5370 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5371 : }

	pop	ebp
	ret	0
_xmlReaderWalker ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderByteConsumed
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderByteConsumed PROC				; COMDAT

; 5329 : xmlTextReaderByteConsumed(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 5330 :     if ((reader == NULL) || (reader->ctxt == NULL))

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 5332 :     return(xmlByteConsumed(reader->ctxt));

	mov	DWORD PTR _reader$[ebp], eax

; 5333 : }

	pop	ebp

; 5332 :     return(xmlByteConsumed(reader->ctxt));

	jmp	_xmlByteConsumed
$LN3@xmlTextRea:

; 5331 :         return(-1);

	or	eax, -1

; 5333 : }

	pop	ebp
	ret	0
_xmlTextReaderByteConsumed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderStandalone
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderStandalone PROC				; COMDAT

; 4705 : xmlTextReaderStandalone(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlTextRea

; 4706 :     xmlDocPtr doc = NULL;
; 4707 :     if (reader == NULL)
; 4708 : 	return(-1);
; 4709 :     if (reader->doc != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN10@xmlTextRea

; 4710 :         doc = reader->doc;
; 4711 :     else if (reader->ctxt != NULL)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 4712 : 	doc = reader->ctxt->myDoc;

	mov	eax, DWORD PTR [eax+8]

; 4713 :     if (doc == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlTextRea
$LN10@xmlTextRea:

; 4715 : 
; 4716 :     return(doc->standalone);

	mov	eax, DWORD PTR [eax+40]

; 4717 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 4714 : 	return(-1);

	or	eax, -1

; 4717 : }

	pop	ebp
	ret	0
_xmlTextReaderStandalone ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstXmlVersion
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstXmlVersion PROC			; COMDAT

; 4677 : xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@xmlTextRea

; 4678 :     xmlDocPtr doc = NULL;
; 4679 :     if (reader == NULL)
; 4680 : 	return(NULL);
; 4681 :     if (reader->doc != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN13@xmlTextRea

; 4682 :         doc = reader->doc;
; 4683 :     else if (reader->ctxt != NULL)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea

; 4684 : 	doc = reader->ctxt->myDoc;

	mov	eax, DWORD PTR [eax+8]

; 4685 :     if (doc == NULL)

	test	eax, eax
	je	SHORT $LN11@xmlTextRea
$LN13@xmlTextRea:

; 4686 : 	return(NULL);
; 4687 : 
; 4688 :     if (doc->version == NULL)

	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea

; 4690 :     else
; 4691 :       return(CONSTSTR(doc->version));

	push	-1
	push	eax
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 4692 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 4689 : 	return(NULL);

	xor	eax, eax

; 4692 : }

	pop	ebp
	ret	0
_xmlTextReaderConstXmlVersion ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSetSchema
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_schema$ = 12						; size = 4
_xmlTextReaderSetSchema PROC				; COMDAT

; 4263 : xmlTextReaderSetSchema(xmlTextReaderPtr reader, xmlSchemaPtr schema) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN18@xmlTextRea

; 4264 :     if (reader == NULL)
; 4265 :         return(-1);
; 4266 :     if (schema == NULL) {

	cmp	DWORD PTR _schema$[ebp], 0
	jne	SHORT $LN3@xmlTextRea

; 4267 : 	if (reader->xsdPlug != NULL) {

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 4268 : 	    xmlSchemaSAXUnplug(reader->xsdPlug);

	push	eax
	call	_xmlSchemaSAXUnplug
	add	esp, 4

; 4269 : 	    reader->xsdPlug = NULL;

	mov	DWORD PTR [esi+152], 0
$LN4@xmlTextRea:

; 4270 : 	}
; 4271 :         if (reader->xsdValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 4272 : 	    if (! reader->xsdPreserveCtxt)

	cmp	DWORD PTR [esi+144], 0
	jne	SHORT $LN6@xmlTextRea

; 4273 : 		xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN6@xmlTextRea:

; 4274 : 	    reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0
$LN5@xmlTextRea:

; 4275 :         }
; 4276 : 	reader->xsdPreserveCtxt = 0;
; 4277 :         if (reader->xsdSchemas != NULL) {

	mov	eax, DWORD PTR [esi+136]
	mov	DWORD PTR [esi+144], 0
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 4278 : 	    xmlSchemaFree(reader->xsdSchemas);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 4279 : 	    reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0
$LN7@xmlTextRea:

; 4280 : 	}
; 4281 : 	return(0);

	xor	eax, eax
	pop	esi

; 4333 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 4282 :     }
; 4283 :     if (reader->mode != XML_TEXTREADER_MODE_INITIAL)

	cmp	DWORD PTR [esi], 0
	jne	$LN18@xmlTextRea

; 4284 : 	return(-1);
; 4285 :     if (reader->xsdPlug != NULL) {

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 4286 : 	xmlSchemaSAXUnplug(reader->xsdPlug);

	push	eax
	call	_xmlSchemaSAXUnplug
	add	esp, 4

; 4287 : 	reader->xsdPlug = NULL;

	mov	DWORD PTR [esi+152], 0
$LN9@xmlTextRea:

; 4288 :     }
; 4289 :     if (reader->xsdValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 4290 : 	if (! reader->xsdPreserveCtxt)

	cmp	DWORD PTR [esi+144], 0
	jne	SHORT $LN11@xmlTextRea

; 4291 : 	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN11@xmlTextRea:

; 4292 : 	reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0
$LN10@xmlTextRea:

; 4293 :     }
; 4294 :     reader->xsdPreserveCtxt = 0;
; 4295 :     if (reader->xsdSchemas != NULL) {

	mov	eax, DWORD PTR [esi+136]
	mov	DWORD PTR [esi+144], 0
	test	eax, eax
	je	SHORT $LN12@xmlTextRea

; 4296 : 	xmlSchemaFree(reader->xsdSchemas);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 4297 : 	reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0
$LN12@xmlTextRea:

; 4298 :     }
; 4299 :     reader->xsdValidCtxt = xmlSchemaNewValidCtxt(schema);

	push	DWORD PTR _schema$[ebp]
	call	_xmlSchemaNewValidCtxt
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi+140], edx

; 4300 :     if (reader->xsdValidCtxt == NULL) {

	test	edx, edx
	jne	SHORT $LN13@xmlTextRea

; 4301 : 	xmlSchemaFree(reader->xsdSchemas);

	push	DWORD PTR [esi+136]
	call	_xmlSchemaFree
	add	esp, 4

; 4302 : 	reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0
$LN18@xmlTextRea:

; 4333 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN13@xmlTextRea:

; 4303 :         return(-1);
; 4304 :     }
; 4305 :     reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,

	mov	ecx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	push	edx
	call	_xmlSchemaSAXPlug
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+152], eax

; 4306 :                                        &(reader->ctxt->sax),
; 4307 : 				       &(reader->ctxt->userData));
; 4308 :     if (reader->xsdPlug == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlTextRea

; 4309 : 	xmlSchemaFree(reader->xsdSchemas);

	push	DWORD PTR [esi+136]
	call	_xmlSchemaFree

; 4310 : 	reader->xsdSchemas = NULL;
; 4311 : 	xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	DWORD PTR [esi+140]
	mov	DWORD PTR [esi+136], 0
	call	_xmlSchemaFreeValidCtxt
	add	esp, 8

; 4312 : 	reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0

; 4333 : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN14@xmlTextRea:

; 4313 : 	return(-1);
; 4314 :     }
; 4315 :     xmlSchemaValidateSetLocator(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderLocator
	push	DWORD PTR [esi+140]
	call	_xmlSchemaValidateSetLocator
	add	esp, 12					; 0000000cH

; 4316 :                                 xmlTextReaderLocator,
; 4317 : 				(void *) reader);
; 4318 : 
; 4319 :     if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN15@xmlTextRea

; 4320 : 	xmlSchemaSetValidErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidErrors
	add	esp, 16					; 00000010H
$LN15@xmlTextRea:

; 4321 : 			xmlTextReaderValidityErrorRelay,
; 4322 : 			xmlTextReaderValidityWarningRelay,
; 4323 : 			reader);
; 4324 :     }
; 4325 : 	if (reader->sErrorFunc != NULL) {

	cmp	DWORD PTR [esi+192], 0
	je	SHORT $LN16@xmlTextRea

; 4326 : 		xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+140]
	call	_xmlSchemaSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN16@xmlTextRea:

; 4327 : 			xmlTextReaderValidityStructuredRelay,
; 4328 : 			reader);
; 4329 :     }
; 4330 :     reader->xsdValidErrors = 0;

	mov	DWORD PTR [esi+148], 0

; 4331 :     reader->validate = XML_TEXTREADER_VALIDATE_XSD;
; 4332 :     return(0);

	xor	eax, eax
	mov	DWORD PTR [esi+8], 4
	pop	esi

; 4333 : }

	pop	ebp
	ret	0
_xmlTextReaderSetSchema ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSchemaValidateCtxt
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlTextReaderSchemaValidateCtxt PROC			; COMDAT

; 4575 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	push	0
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderSchemaValidateInternal
	add	esp, 16					; 00000010H

; 4576 :     return(xmlTextReaderSchemaValidateInternal(reader, NULL, ctxt, options));
; 4577 : }

	pop	ebp
	ret	0
_xmlTextReaderSchemaValidateCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSchemaValidate
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xsd$ = 12						; size = 4
_xmlTextReaderSchemaValidate PROC			; COMDAT

; 4593 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _xsd$[ebp]
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderSchemaValidateInternal
	add	esp, 16					; 00000010H

; 4594 :     return(xmlTextReaderSchemaValidateInternal(reader, xsd, NULL, 0));
; 4595 : }

	pop	ebp
	ret	0
_xmlTextReaderSchemaValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRelaxNGSetSchema
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_schema$ = 12						; size = 4
_xmlTextReaderRelaxNGSetSchema PROC			; COMDAT

; 4146 : xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader, xmlRelaxNGPtr schema) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN15@xmlTextRea

; 4147 :     if (reader == NULL)
; 4148 :         return(-1);
; 4149 :     if (schema == NULL) {

	cmp	DWORD PTR _schema$[ebp], 0
	jne	SHORT $LN3@xmlTextRea

; 4150 :         if (reader->rngSchemas != NULL) {

	mov	eax, DWORD PTR [esi+116]
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 4151 : 	    xmlRelaxNGFree(reader->rngSchemas);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4

; 4152 : 	    reader->rngSchemas = NULL;

	mov	DWORD PTR [esi+116], 0
$LN4@xmlTextRea:

; 4153 : 	}
; 4154 :         if (reader->rngValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 4155 : 	    if (! reader->rngPreserveCtxt)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN6@xmlTextRea

; 4156 : 		xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);

	push	eax
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4
$LN6@xmlTextRea:

; 4157 : 	    reader->rngValidCtxt = NULL;

	mov	DWORD PTR [esi+120], 0
$LN5@xmlTextRea:

; 4158 :         }
; 4159 : 	reader->rngPreserveCtxt = 0;

	mov	DWORD PTR [esi+124], 0

; 4160 : 	return(0);

	xor	eax, eax
	pop	esi

; 4192 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 4161 :     }
; 4162 :     if (reader->mode != XML_TEXTREADER_MODE_INITIAL)

	cmp	DWORD PTR [esi], 0
	jne	$LN15@xmlTextRea

; 4163 : 	return(-1);
; 4164 :     if (reader->rngSchemas != NULL) {

	mov	eax, DWORD PTR [esi+116]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 4165 : 	xmlRelaxNGFree(reader->rngSchemas);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4

; 4166 : 	reader->rngSchemas = NULL;

	mov	DWORD PTR [esi+116], 0
$LN8@xmlTextRea:

; 4167 :     }
; 4168 :     if (reader->rngValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 4169 : 	if (! reader->rngPreserveCtxt)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN10@xmlTextRea

; 4170 : 	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);

	push	eax
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4
$LN10@xmlTextRea:

; 4171 : 	reader->rngValidCtxt = NULL;

	mov	DWORD PTR [esi+120], 0
$LN9@xmlTextRea:

; 4172 :     }
; 4173 :     reader->rngPreserveCtxt = 0;
; 4174 :     reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(schema);

	push	DWORD PTR _schema$[ebp]
	mov	DWORD PTR [esi+124], 0
	call	_xmlRelaxNGNewValidCtxt
	add	esp, 4
	mov	DWORD PTR [esi+120], eax

; 4175 :     if (reader->rngValidCtxt == NULL)

	test	eax, eax
	je	SHORT $LN15@xmlTextRea

; 4177 :     if (reader->errorFunc != NULL) {

	cmp	DWORD PTR [esi+108], 0
	je	SHORT $LN12@xmlTextRea

; 4178 : 	xmlRelaxNGSetValidErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityWarningRelay
	push	OFFSET _xmlTextReaderValidityErrorRelay
	push	eax
	call	_xmlRelaxNGSetValidErrors
	add	esp, 16					; 00000010H
$LN12@xmlTextRea:

; 4179 : 			xmlTextReaderValidityErrorRelay,
; 4180 : 			xmlTextReaderValidityWarningRelay,
; 4181 : 			reader);
; 4182 :     }
; 4183 : 	if (reader->sErrorFunc != NULL) {

	cmp	DWORD PTR [esi+192], 0
	je	SHORT $LN13@xmlTextRea

; 4184 : 		xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,

	push	esi
	push	OFFSET _xmlTextReaderValidityStructuredRelay
	push	DWORD PTR [esi+120]
	call	_xmlRelaxNGSetValidStructuredErrors
	add	esp, 12					; 0000000cH
$LN13@xmlTextRea:

; 4185 : 			xmlTextReaderValidityStructuredRelay,
; 4186 : 			reader);
; 4187 :     }
; 4188 :     reader->rngValidErrors = 0;

	mov	DWORD PTR [esi+128], 0

; 4189 :     reader->rngFullNode = NULL;
; 4190 :     reader->validate = XML_TEXTREADER_VALIDATE_RNG;
; 4191 :     return(0);

	xor	eax, eax
	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+8], 2
	pop	esi

; 4192 : }

	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 4176 :         return(-1);

	or	eax, -1
	pop	esi

; 4192 : }

	pop	ebp
	ret	0
_xmlTextReaderRelaxNGSetSchema ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRelaxNGValidateCtxt
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlTextReaderRelaxNGValidateCtxt PROC			; COMDAT

; 4614 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	push	0
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderRelaxNGValidateInternal
	add	esp, 16					; 00000010H

; 4615 :     return(xmlTextReaderRelaxNGValidateInternal(reader, NULL, ctxt, options));
; 4616 : }

	pop	ebp
	ret	0
_xmlTextReaderRelaxNGValidateCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRelaxNGValidate
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_rng$ = 12						; size = 4
_xmlTextReaderRelaxNGValidate PROC			; COMDAT

; 4632 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _rng$[ebp]
	push	DWORD PTR _reader$[ebp]
	call	_xmlTextReaderRelaxNGValidateInternal
	add	esp, 16					; 00000010H

; 4633 :     return(xmlTextReaderRelaxNGValidateInternal(reader, rng, NULL, 0));
; 4634 : }

	pop	ebp
	ret	0
_xmlTextReaderRelaxNGValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderIsValid
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderIsValid PROC				; COMDAT

; 5071 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlTextRea

; 5072 :     if (reader == NULL)
; 5073 :         return (-1);

	or	eax, -1

; 5083 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 5074 : #ifdef LIBXML_SCHEMAS_ENABLED
; 5075 :     if (reader->validate == XML_TEXTREADER_VALIDATE_RNG)

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, 2
	jne	SHORT $LN3@xmlTextRea

; 5076 :         return (reader->rngValidErrors == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+128], eax
	sete	al

; 5083 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 5077 :     if (reader->validate == XML_TEXTREADER_VALIDATE_XSD)

	cmp	eax, 4
	jne	SHORT $LN4@xmlTextRea

; 5078 :         return (reader->xsdValidErrors == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+148], eax
	sete	al

; 5083 : }

	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 5079 : #endif
; 5080 :     if ((reader->ctxt != NULL) && (reader->ctxt->validate == 1))

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea
	cmp	DWORD PTR [eax+104], 1
	jne	SHORT $LN5@xmlTextRea

; 5081 :         return (reader->ctxt->valid);

	mov	eax, DWORD PTR [eax+100]

; 5083 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 5082 :     return (0);

	xor	eax, eax

; 5083 : }

	pop	ebp
	ret	0
_xmlTextReaderIsValid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNextSibling
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNextSibling PROC				; COMDAT

; 2036 : xmlTextReaderNextSibling(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 2037 :     if (reader == NULL)
; 2038 :         return(-1);
; 2039 :     if (reader->doc == NULL) {

	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@xmlTextRea

; 2042 :     }
; 2043 : 
; 2044 :     if (reader->state == XML_TEXTREADER_END)

	cmp	DWORD PTR [eax+16], 2
	je	SHORT $LN6@xmlTextRea

; 2045 :         return(0);
; 2046 : 
; 2047 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	jne	SHORT $LN5@xmlTextRea

; 2048 :         return(xmlTextReaderNextTree(reader));

	mov	DWORD PTR _reader$[ebp], eax

; 2057 : }

	pop	ebp

; 2048 :         return(xmlTextReaderNextTree(reader));

	jmp	_xmlTextReaderNextTree
$LN5@xmlTextRea:

; 2049 : 
; 2050 :     if (reader->node->next != NULL) {

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	je	SHORT $LN6@xmlTextRea

; 2051 :         reader->node = reader->node->next;

	mov	DWORD PTR [eax+64], ecx

; 2052 :         reader->state = XML_TEXTREADER_START;

	mov	DWORD PTR [eax+16], 0

; 2053 :         return(1);

	mov	eax, 1

; 2057 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 2054 :     }
; 2055 : 
; 2056 :     return(0);

	xor	eax, eax

; 2057 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 2040 :         /* TODO */
; 2041 : 	return(-1);

	or	eax, -1

; 2057 : }

	pop	ebp
	ret	0
_xmlTextReaderNextSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNext
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNext PROC					; COMDAT

; 1669 : xmlTextReaderNext(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlTextRea

; 1670 :     int ret;
; 1671 :     xmlNodePtr cur;
; 1672 : 
; 1673 :     if (reader == NULL)
; 1674 : 	return(-1);

	or	eax, -1
	pop	esi

; 1689 :     return(xmlTextReaderRead(reader));
; 1690 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 1675 :     if (reader->doc != NULL)

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN6@xmlTextRea

; 1676 :         return(xmlTextReaderNextTree(reader));

	push	esi
	call	_xmlTextReaderNextTree
	add	esp, 4
	pop	esi

; 1689 :     return(xmlTextReaderRead(reader));
; 1690 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:
	push	edi

; 1677 :     cur = reader->node;

	mov	edi, DWORD PTR [esi+64]

; 1678 :     if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))

	test	edi, edi
	je	SHORT $LN8@xmlTextRea
	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN8@xmlTextRea

; 1680 :     if (reader->state == XML_TEXTREADER_END || reader->state == XML_TEXTREADER_BACKTRACK)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, 2
	je	SHORT $LN8@xmlTextRea
	cmp	eax, 4
	je	SHORT $LN8@xmlTextRea

; 1681 :         return(xmlTextReaderRead(reader));
; 1682 :     if (cur->extra & NODE_IS_EMPTY)

	test	BYTE PTR [edi+58], 1
	jne	SHORT $LN8@xmlTextRea
	npad	2
$LL4@xmlTextRea:

; 1683 :         return(xmlTextReaderRead(reader));
; 1684 :     do {
; 1685 :         ret = xmlTextReaderRead(reader);

	push	esi
	call	_xmlTextReaderRead
	add	esp, 4

; 1686 : 	if (ret != 1)

	cmp	eax, 1
	jne	SHORT $LN27@xmlTextRea

; 1687 : 	    return(ret);
; 1688 :     } while (reader->node != cur);

	cmp	DWORD PTR [esi+64], edi
	jne	SHORT $LL4@xmlTextRea
$LN8@xmlTextRea:

; 1679 :         return(xmlTextReaderRead(reader));

	push	esi
	call	_xmlTextReaderRead
	add	esp, 4
$LN27@xmlTextRea:
	pop	edi
	pop	esi

; 1689 :     return(xmlTextReaderRead(reader));
; 1690 : }

	pop	ebp
	ret	0
_xmlTextReaderNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderExpand
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderExpand PROC				; COMDAT

; 1646 : xmlTextReaderExpand(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlTextRea

; 1647 :     if ((reader == NULL) || (reader->node == NULL))

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 1649 :     if (reader->doc != NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN1@xmlTextRea

; 1650 :         return(reader->node);
; 1651 :     if (reader->ctxt == NULL)

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN3@xmlTextRea

; 1652 :         return(NULL);
; 1653 :     if (xmlTextReaderDoExpand(reader) < 0)

	push	esi
	call	_xmlTextReaderDoExpand
	add	esp, 4
	test	eax, eax
	js	SHORT $LN3@xmlTextRea

; 1654 :         return(NULL);
; 1655 :     return(reader->node);

	mov	eax, DWORD PTR [esi+64]
	pop	esi

; 1656 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 1648 :         return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:
	pop	esi

; 1656 : }

	pop	ebp
	ret	0
_xmlTextReaderExpand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderCurrentDoc
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderCurrentDoc PROC				; COMDAT

; 4044 : xmlTextReaderCurrentDoc(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 4045 :     if (reader == NULL)
; 4046 : 	return(NULL);
; 4047 :     if (reader->doc != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN1@xmlTextRea

; 4048 :         return(reader->doc);
; 4049 :     if ((reader->ctxt == NULL) || (reader->ctxt->myDoc == NULL))

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@xmlTextRea

; 4051 : 
; 4052 :     reader->preserve = 1;

	mov	DWORD PTR [ecx+80], 1

; 4053 :     return(reader->ctxt->myDoc);

	mov	eax, DWORD PTR [eax+8]

; 4054 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 4050 : 	return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:

; 4054 : }

	pop	ebp
	ret	0
_xmlTextReaderCurrentDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderPreservePattern
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_pattern$ = 12						; size = 4
_namespaces$ = 16					; size = 4
_xmlTextReaderPreservePattern PROC			; COMDAT

; 3994 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlTextRea

; 3995 :     xmlPatternPtr comp;
; 3996 : 
; 3997 :     if ((reader == NULL) || (pattern == NULL))

	mov	eax, DWORD PTR _pattern$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3998 : 	return(-1);
; 3999 : 
; 4000 :     comp = xmlPatterncompile(pattern, reader->dict, 0, namespaces);

	push	DWORD PTR _namespaces$[ebp]
	push	0
	push	DWORD PTR [edi+88]
	push	eax
	call	_xmlPatterncompile
	mov	esi, eax
	add	esp, 16					; 00000010H

; 4001 :     if (comp == NULL)

	test	esi, esi
	je	SHORT $LN3@xmlTextRea

; 4002 :         return(-1);
; 4003 : 
; 4004 :     if (reader->patternMax <= 0) {

	cmp	DWORD PTR [edi+176], 0
	jg	SHORT $LN13@xmlTextRea

; 4005 : 	reader->patternMax = 4;
; 4006 : 	reader->patternTab = (xmlPatternPtr *) xmlMalloc(reader->patternMax *

	push	16					; 00000010H
	mov	DWORD PTR [edi+176], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+180], eax

; 4007 : 					      sizeof(reader->patternTab[0]));
; 4008 :         if (reader->patternTab == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlTextRea

; 4009 :             xmlGenericError(xmlGenericErrorContext, "xmlMalloc failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BE@MPMNBMMA@xmlMalloc?5failed?5?$CB?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN3@xmlTextRea:

; 4028 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN13@xmlTextRea:

; 4010 :             return (-1);
; 4011 :         }
; 4012 :     }
; 4013 :     if (reader->patternNr >= reader->patternMax) {

	mov	ecx, DWORD PTR [edi+172]
	mov	eax, DWORD PTR [edi+176]
	cmp	ecx, eax
	jl	SHORT $LN14@xmlTextRea

; 4014 :         xmlPatternPtr *tmp;
; 4015 :         reader->patternMax *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+176], eax

; 4016 : 	tmp = (xmlPatternPtr *) xmlRealloc(reader->patternTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+180]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4017 :                                       reader->patternMax *
; 4018 :                                       sizeof(reader->patternTab[0]));
; 4019 :         if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlTextRea

; 4020 :             xmlGenericError(xmlGenericErrorContext, "xmlRealloc failed !\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BF@DCPGEBNC@xmlRealloc?5failed?5?$CB?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 4021 : 	    reader->patternMax /= 2;

	mov	eax, DWORD PTR [edi+176]
	add	esp, 8
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [edi+176], eax

; 4028 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 4022 :             return (-1);
; 4023 :         }
; 4024 : 	reader->patternTab = tmp;

	mov	ecx, DWORD PTR [edi+172]
	mov	DWORD PTR [edi+180], eax
$LN14@xmlTextRea:

; 4025 :     }
; 4026 :     reader->patternTab[reader->patternNr] = comp;

	mov	eax, DWORD PTR [edi+180]
	mov	DWORD PTR [eax+ecx*4], esi

; 4027 :     return(reader->patternNr++);

	mov	eax, DWORD PTR [edi+172]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi+172], ecx
	pop	edi

; 4028 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderPreservePattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderPreserve
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderPreserve PROC				; COMDAT

; 3950 : xmlTextReaderPreserve(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@xmlTextRea

; 3951 :     xmlNodePtr cur, parent;
; 3952 : 
; 3953 :     if (reader == NULL)
; 3954 : 	return(NULL);
; 3955 : 
; 3956 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	jne	SHORT $LN17@xmlTextRea

; 3957 :         cur = reader->curnode;
; 3958 :     else
; 3959 :         cur = reader->node;

	mov	eax, DWORD PTR [ecx+64]

; 3960 :     if (cur == NULL)

	test	eax, eax
	je	SHORT $LN15@xmlTextRea
$LN17@xmlTextRea:

; 3962 : 
; 3963 :     if ((cur->type != XML_DOCUMENT_NODE) && (cur->type != XML_DTD_NODE)) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 9
	je	SHORT $LN8@xmlTextRea
	cmp	edx, 14					; 0000000eH
	je	SHORT $LN8@xmlTextRea

; 3964 : 	cur->extra |= NODE_IS_PRESERVED;
; 3965 : 	cur->extra |= NODE_IS_SPRESERVED;

	or	WORD PTR [eax+58], 6
$LN8@xmlTextRea:

; 3966 :     }
; 3967 :     reader->preserves++;

	inc	DWORD PTR [ecx+184]

; 3968 : 
; 3969 :     parent = cur->parent;;

	mov	ecx, DWORD PTR [eax+20]

; 3970 :     while (parent != NULL) {

	test	ecx, ecx
	je	SHORT $LN1@xmlTextRea
$LL2@xmlTextRea:

; 3971 :         if (parent->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN9@xmlTextRea

; 3972 : 	    parent->extra |= NODE_IS_PRESERVED;

	or	WORD PTR [ecx+58], 2
$LN9@xmlTextRea:

; 3973 : 	parent = parent->parent;

	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	jne	SHORT $LL2@xmlTextRea

; 3974 :     }
; 3975 :     return(cur);
; 3976 : }

	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 3961 :         return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:

; 3974 :     }
; 3975 :     return(cur);
; 3976 : }

	pop	ebp
	ret	0
_xmlTextReaderPreserve ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetParserColumnNumber
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderGetParserColumnNumber PROC		; COMDAT

; 3911 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3912 :     if ((reader == NULL) || (reader->ctxt == NULL) ||

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3915 :     }
; 3916 :     return (reader->ctxt->input->col);

	mov	eax, DWORD PTR [eax+32]

; 3917 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3913 :         (reader->ctxt->input == NULL)) {
; 3914 :         return (0);

	xor	eax, eax

; 3917 : }

	pop	ebp
	ret	0
_xmlTextReaderGetParserColumnNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetParserLineNumber
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderGetParserLineNumber PROC			; COMDAT

; 3893 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3894 :     if ((reader == NULL) || (reader->ctxt == NULL) ||

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3897 :     }
; 3898 :     return (reader->ctxt->input->line);

	mov	eax, DWORD PTR [eax+28]

; 3899 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3895 :         (reader->ctxt->input == NULL)) {
; 3896 :         return (0);

	xor	eax, eax

; 3899 : }

	pop	ebp
	ret	0
_xmlTextReaderGetParserLineNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderCurrentNode
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderCurrentNode PROC				; COMDAT

; 3930 : xmlTextReaderCurrentNode(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlTextRea

; 3937 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 3931 :     if (reader == NULL)
; 3932 : 	return(NULL);
; 3933 : 
; 3934 :     if (reader->curnode != NULL)

	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3935 : 	return(reader->curnode);

	mov	eax, ecx

; 3937 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3936 :     return(reader->node);

	mov	eax, DWORD PTR [eax+64]

; 3937 : }

	pop	ebp
	ret	0
_xmlTextReaderCurrentNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetParserProp
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_prop$ = 12						; size = 4
_xmlTextReaderGetParserProp PROC			; COMDAT

; 3857 : xmlTextReaderGetParserProp(xmlTextReaderPtr reader, int prop) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlTextRea

; 3858 :     xmlParserProperties p = (xmlParserProperties) prop;
; 3859 :     xmlParserCtxtPtr ctxt;
; 3860 : 
; 3861 :     if ((reader == NULL) || (reader->ctxt == NULL))

	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 3863 :     ctxt = reader->ctxt;
; 3864 : 
; 3865 :     switch (p) {

	mov	eax, DWORD PTR _prop$[ebp]
	dec	eax
	cmp	eax, 3
	ja	SHORT $LN5@xmlTextRea
	jmp	DWORD PTR $LN16@xmlTextRea[eax*4]
$LN6@xmlTextRea:

; 3866 :         case XML_PARSER_LOADDTD:
; 3867 : 	    if ((ctxt->loadsubset != 0) || (ctxt->validate != 0))

	cmp	DWORD PTR [ecx+276], 0
	jne	SHORT $LN14@xmlTextRea
	cmp	DWORD PTR [ecx+104], 0
	jne	SHORT $LN14@xmlTextRea
$LN10@xmlTextRea:

; 3873 : 	    return(0);

	xor	eax, eax

; 3878 :     }
; 3879 :     return(-1);
; 3880 : }

	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 3868 : 		return(1);
; 3869 : 	    return(0);
; 3870 :         case XML_PARSER_DEFAULTATTRS:
; 3871 : 	    if (ctxt->loadsubset & XML_COMPLETE_ATTRS)

	test	BYTE PTR [ecx+276], 4
	je	SHORT $LN10@xmlTextRea
$LN14@xmlTextRea:

; 3872 : 		return(1);

	mov	eax, 1

; 3878 :     }
; 3879 :     return(-1);
; 3880 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 3874 :         case XML_PARSER_VALIDATE:
; 3875 : 	    return(reader->validate);

	mov	eax, DWORD PTR [edx+8]

; 3878 :     }
; 3879 :     return(-1);
; 3880 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3876 : 	case XML_PARSER_SUBST_ENTITIES:
; 3877 : 	    return(ctxt->replaceEntities);

	mov	eax, DWORD PTR [ecx+16]

; 3878 :     }
; 3879 :     return(-1);
; 3880 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 3862 : 	return(-1);

	or	eax, -1

; 3878 :     }
; 3879 :     return(-1);
; 3880 : }

	pop	ebp
	ret	0
	npad	3
$LN16@xmlTextRea:
	DD	$LN6@xmlTextRea
	DD	$LN9@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN12@xmlTextRea
_xmlTextReaderGetParserProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSetParserProp
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_prop$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlTextReaderSetParserProp PROC			; COMDAT

; 3800 : xmlTextReaderSetParserProp(xmlTextReaderPtr reader, int prop, int value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	test	edx, edx
	je	$LN5@xmlTextRea

; 3801 :     xmlParserProperties p = (xmlParserProperties) prop;
; 3802 :     xmlParserCtxtPtr ctxt;
; 3803 : 
; 3804 :     if ((reader == NULL) || (reader->ctxt == NULL))

	mov	ecx, DWORD PTR [edx+20]
	test	ecx, ecx
	je	$LN5@xmlTextRea

; 3806 :     ctxt = reader->ctxt;
; 3807 : 
; 3808 :     switch (p) {

	mov	eax, DWORD PTR _prop$[ebp]
	dec	eax
	cmp	eax, 3
	ja	$LN5@xmlTextRea
	jmp	DWORD PTR $LN23@xmlTextRea[eax*4]
$LN6@xmlTextRea:

; 3809 :         case XML_PARSER_LOADDTD:
; 3810 : 	    if (value != 0) {

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN7@xmlTextRea

; 3811 : 		if (ctxt->loadsubset == 0) {

	cmp	DWORD PTR [ecx+276], 0
	jne	SHORT $LN17@xmlTextRea

; 3812 : 		    if (reader->mode != XML_TEXTREADER_MODE_INITIAL)

	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@xmlTextRea

; 3813 : 			return(-1);
; 3814 : 		    ctxt->loadsubset = XML_DETECT_IDS;

	mov	DWORD PTR [ecx+276], 2

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN7@xmlTextRea:

; 3815 : 		}
; 3816 : 	    } else {
; 3817 : 		ctxt->loadsubset = 0;

	mov	DWORD PTR [ecx+276], 0

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 3818 : 	    }
; 3819 : 	    return(0);
; 3820 :         case XML_PARSER_DEFAULTATTRS:
; 3821 : 	    if (value != 0) {

	cmp	DWORD PTR _value$[ebp], 0
	mov	eax, DWORD PTR [ecx+276]
	je	SHORT $LN12@xmlTextRea

; 3822 : 		ctxt->loadsubset |= XML_COMPLETE_ATTRS;

	or	eax, 4
	mov	DWORD PTR [ecx+276], eax

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3823 : 	    } else {
; 3824 : 		if (ctxt->loadsubset & XML_COMPLETE_ATTRS)

	test	al, 4
	je	SHORT $LN17@xmlTextRea

; 3825 : 		    ctxt->loadsubset -= XML_COMPLETE_ATTRS;

	add	eax, -4					; fffffffcH
	mov	DWORD PTR [ecx+276], eax

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 3826 : 	    }
; 3827 : 	    return(0);
; 3828 :         case XML_PARSER_VALIDATE:
; 3829 : 	    if (value != 0) {

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN16@xmlTextRea

; 3830 : 		ctxt->validate = 1;

	mov	DWORD PTR [ecx+104], 1

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax
	mov	DWORD PTR [edx+8], 1

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 3831 : 		reader->validate = XML_TEXTREADER_VALIDATE_DTD;
; 3832 : 	    } else {
; 3833 : 		ctxt->validate = 0;

	mov	DWORD PTR [ecx+104], 0
$LN17@xmlTextRea:

; 3834 : 	    }
; 3835 : 	    return(0);

	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 3836 :         case XML_PARSER_SUBST_ENTITIES:
; 3837 : 	    if (value != 0) {
; 3838 : 		ctxt->replaceEntities = 1;
; 3839 : 	    } else {
; 3840 : 		ctxt->replaceEntities = 0;
; 3841 : 	    }
; 3842 : 	    return(0);

	xor	eax, eax
	cmp	DWORD PTR _value$[ebp], eax
	setne	al
	mov	DWORD PTR [ecx+16], eax
	xor	eax, eax

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 3805 : 	return(-1);

	or	eax, -1

; 3843 :     }
; 3844 :     return(-1);
; 3845 : }

	pop	ebp
	ret	0
$LN23@xmlTextRea:
	DD	$LN6@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN15@xmlTextRea
	DD	$LN18@xmlTextRea
_xmlTextReaderSetParserProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstEncoding
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstEncoding PROC			; COMDAT

; 2933 : xmlTextReaderConstEncoding(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@xmlTextRea

; 2934 :     xmlDocPtr doc = NULL;
; 2935 :     if (reader == NULL)
; 2936 : 	return(NULL);
; 2937 :     if (reader->doc != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN13@xmlTextRea

; 2938 :         doc = reader->doc;
; 2939 :     else if (reader->ctxt != NULL)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea

; 2940 : 	doc = reader->ctxt->myDoc;

	mov	eax, DWORD PTR [eax+8]

; 2941 :     if (doc == NULL)

	test	eax, eax
	je	SHORT $LN11@xmlTextRea
$LN13@xmlTextRea:

; 2942 : 	return(NULL);
; 2943 : 
; 2944 :     if (doc->encoding == NULL)

	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea

; 2946 :     else
; 2947 :       return(CONSTSTR(doc->encoding));

	push	-1
	push	eax
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 2948 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 2945 : 	return(NULL);

	xor	eax, eax

; 2948 : }

	pop	ebp
	ret	0
_xmlTextReaderConstEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNormalization
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNormalization PROC			; COMDAT

; 3775 : xmlTextReaderNormalization(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	cmp	DWORD PTR _reader$[ebp], eax
	setne	al
	lea	eax, DWORD PTR [eax*2-1]

; 3776 :     if (reader == NULL)
; 3777 : 	return(-1);
; 3778 :     return(1);
; 3779 : }

	pop	ebp
	ret	0
_xmlTextReaderNormalization ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToElement
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderMoveToElement PROC			; COMDAT

; 2865 : xmlTextReaderMoveToElement(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 2866 :     if (reader == NULL)
; 2867 : 	return(-1);
; 2868 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN7@xmlTextRea

; 2870 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN5@xmlTextRea

; 2871 : 	return(0);
; 2872 :     if (reader->curnode != NULL) {

	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN5@xmlTextRea

; 2873 : 	reader->curnode = NULL;

	mov	DWORD PTR [eax+68], 0

; 2874 : 	return(1);

	mov	eax, 1

; 2877 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 2875 :     }
; 2876 :     return(0);

	xor	eax, eax

; 2877 : }

	pop	ebp
	ret	0
$LN7@xmlTextRea:

; 2869 : 	return(-1);

	or	eax, -1

; 2877 : }

	pop	ebp
	ret	0
_xmlTextReaderMoveToElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToNextAttribute
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderMoveToNextAttribute PROC			; COMDAT

; 2826 : xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea

; 2827 :     if (reader == NULL)
; 2828 : 	return(-1);
; 2829 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN12@xmlTextRea

; 2831 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN10@xmlTextRea

; 2832 : 	return(0);
; 2833 :     if (reader->curnode == NULL)

	mov	edx, DWORD PTR [eax+68]
	test	edx, edx
	jne	SHORT $LN5@xmlTextRea

; 2834 : 	return(xmlTextReaderMoveToFirstAttribute(reader));

	mov	DWORD PTR _reader$[ebp], eax

; 2853 : }

	pop	ebp

; 2834 : 	return(xmlTextReaderMoveToFirstAttribute(reader));

	jmp	_xmlTextReaderMoveToFirstAttribute
$LN5@xmlTextRea:

; 2835 : 
; 2836 :     if (reader->curnode->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN6@xmlTextRea

; 2837 : 	xmlNsPtr ns = (xmlNsPtr) reader->curnode;
; 2838 : 	if (ns->next != NULL) {

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN8@xmlTextRea

; 2839 : 	    reader->curnode = (xmlNodePtr) ns->next;

	mov	DWORD PTR [eax+68], edx

; 2840 : 	    return(1);

	mov	eax, 1

; 2853 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 2841 : 	}
; 2842 : 	if (reader->node->properties != NULL) {

	mov	ecx, DWORD PTR [ecx+44]
$LN15@xmlTextRea:

; 2853 : }

	test	ecx, ecx
	je	SHORT $LN10@xmlTextRea
	mov	DWORD PTR [eax+68], ecx
	mov	eax, 1
	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 2843 : 	    reader->curnode = (xmlNodePtr) reader->node->properties;
; 2844 : 	    return(1);
; 2845 : 	}
; 2846 : 	return(0);
; 2847 :     } else if ((reader->curnode->type == XML_ATTRIBUTE_NODE) &&

	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN10@xmlTextRea
	mov	ecx, DWORD PTR [edx+24]

; 2848 : 	       (reader->curnode->next != NULL)) {
; 2849 : 	reader->curnode = reader->curnode->next;
; 2850 : 	return(1);

	jmp	SHORT $LN15@xmlTextRea
$LN10@xmlTextRea:

; 2851 :     }
; 2852 :     return(0);

	xor	eax, eax

; 2853 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 2830 : 	return(-1);

	or	eax, -1

; 2853 : }

	pop	ebp
	ret	0
_xmlTextReaderMoveToNextAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToFirstAttribute
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderMoveToFirstAttribute PROC			; COMDAT

; 2797 : xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlTextRea

; 2798 :     if (reader == NULL)
; 2799 : 	return(-1);
; 2800 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [ecx+64]
	test	eax, eax
	je	SHORT $LN8@xmlTextRea

; 2802 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN6@xmlTextRea

; 2803 : 	return(0);
; 2804 : 
; 2805 :     if (reader->node->nsDef != NULL) {

	mov	edx, DWORD PTR [eax+48]
	test	edx, edx
	je	SHORT $LN5@xmlTextRea

; 2806 : 	reader->curnode = (xmlNodePtr) reader->node->nsDef;

	mov	DWORD PTR [ecx+68], edx

; 2807 : 	return(1);

	mov	eax, 1

; 2814 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 2808 :     }
; 2809 :     if (reader->node->properties != NULL) {

	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 2810 : 	reader->curnode = (xmlNodePtr) reader->node->properties;

	mov	DWORD PTR [ecx+68], eax

; 2811 : 	return(1);

	mov	eax, 1

; 2814 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 2812 :     }
; 2813 :     return(0);

	xor	eax, eax

; 2814 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 2801 : 	return(-1);

	or	eax, -1

; 2814 : }

	pop	ebp
	ret	0
_xmlTextReaderMoveToFirstAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToAttributeNs
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_localName$ = 12					; size = 4
_namespaceURI$ = 16					; size = 4
_xmlTextReaderMoveToAttributeNs PROC			; COMDAT

; 2739 : 	const xmlChar *localName, const xmlChar *namespaceURI) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	xor	ebx, ebx
	test	ecx, ecx
	je	$LN7@xmlTextRea

; 2740 :     xmlAttrPtr prop;
; 2741 :     xmlNodePtr node;
; 2742 :     xmlNsPtr ns;
; 2743 :     xmlChar *prefix = NULL;
; 2744 : 
; 2745 :     if ((reader == NULL) || (localName == NULL) || (namespaceURI == NULL))

	mov	edi, DWORD PTR _localName$[ebp]
	test	edi, edi
	je	$LN7@xmlTextRea
	mov	eax, DWORD PTR _namespaceURI$[ebp]
	test	eax, eax
	je	$LN7@xmlTextRea

; 2746 : 	return(-1);
; 2747 :     if (reader->node == NULL)

	mov	esi, DWORD PTR [ecx+64]
	test	esi, esi
	je	$LN7@xmlTextRea

; 2748 : 	return(-1);
; 2749 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [esi+4], 1
	jne	$LN3@xmlTextRea

; 2750 : 	return(0);
; 2751 :     node = reader->node;
; 2752 : 
; 2753 :     if (xmlStrEqual(namespaceURI, BAD_CAST "http://www.w3.org/2000/xmlns/")) {

	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 2754 : 		if (! xmlStrEqual(localName, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax

; 2755 : 			prefix = BAD_CAST localName;
; 2756 : 		}
; 2757 : 		ns = reader->node->nsDef;

	mov	eax, DWORD PTR _reader$[ebp]
	cmove	ebx, edi
	mov	eax, DWORD PTR [eax+64]
	mov	esi, DWORD PTR [eax+48]

; 2758 : 		while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlTextRea
	npad	6
$LL2@xmlTextRea:

; 2759 : 			if ((prefix == NULL && ns->prefix == NULL) ||

	test	ebx, ebx
	jne	SHORT $LN27@xmlTextRea
	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN13@xmlTextRea
$LN27@xmlTextRea:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@xmlTextRea
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlTextRea
$LN12@xmlTextRea:

; 2760 : 				((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {
; 2761 : 				reader->curnode = (xmlNodePtr) ns;
; 2762 : 				return(1);
; 2763 : 			}
; 2764 : 			ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlTextRea

; 2783 :     }
; 2784 :     return(0);
; 2785 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlTextRea:
	mov	eax, DWORD PTR _reader$[ebp]
	pop	edi
	mov	DWORD PTR [eax+68], esi
	mov	eax, 1
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 2765 : 		}
; 2766 : 		return(0);
; 2767 :     }
; 2768 : 
; 2769 :     prop = node->properties;

	mov	esi, DWORD PTR [esi+44]

; 2770 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlTextRea
	mov	ebx, DWORD PTR _namespaceURI$[ebp]
$LL4@xmlTextRea:

; 2771 : 	/*
; 2772 : 	 * One need to have
; 2773 : 	 *   - same attribute names
; 2774 : 	 *   - and the attribute carrying that namespace
; 2775 : 	 */
; 2776 :         if (xmlStrEqual(prop->name, localName) &&

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlTextRea
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN15@xmlTextRea
	push	ebx
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlTextRea
$LN15@xmlTextRea:

; 2777 : 	    ((prop->ns != NULL) &&
; 2778 : 	     (xmlStrEqual(prop->ns->href, namespaceURI)))) {
; 2779 : 	    reader->curnode = (xmlNodePtr) prop;
; 2780 : 	    return(1);
; 2781 :         }
; 2782 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@xmlTextRea
$LN3@xmlTextRea:
	pop	edi

; 2783 :     }
; 2784 :     return(0);
; 2785 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlTextRea:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderMoveToAttributeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToAttribute
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_reader$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlTextReaderMoveToAttribute PROC			; COMDAT

; 2634 : xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	esi, esi
	je	$LN11@xmlTextRea

; 2635 :     xmlChar *prefix = NULL;
; 2636 :     xmlChar *localname;
; 2637 :     xmlNsPtr ns;
; 2638 :     xmlAttrPtr prop;
; 2639 : 
; 2640 :     if ((reader == NULL) || (name == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN11@xmlTextRea

; 2642 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN11@xmlTextRea

; 2643 : 	return(-1);
; 2644 : 
; 2645 :     /* TODO: handle the xmlDecl */
; 2646 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	push	edi
	jne	$LN23@xmlTextRea

; 2647 : 	return(0);
; 2648 : 
; 2649 :     localname = xmlSplitQName2(name, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	ebx
	call	_xmlSplitQName2
	add	esp, 8
	mov	edi, eax

; 2650 :     if (localname == NULL) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	test	edi, edi
	jne	$LN14@xmlTextRea

; 2651 : 	/*
; 2652 : 	 * Namespace default decl
; 2653 : 	 */
; 2654 : 	if (xmlStrEqual(name, BAD_CAST "xmlns")) {

	push	ebx
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlTextRea

; 2655 : 	    ns = reader->node->nsDef;

	mov	eax, DWORD PTR [ecx+48]

; 2656 : 	    while (ns != NULL) {

	test	eax, eax
	je	$LN23@xmlTextRea
	npad	6
$LL2@xmlTextRea:

; 2657 : 		if (ns->prefix == NULL) {

	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN31@xmlTextRea

; 2659 : 		    return(1);
; 2660 : 		}
; 2661 : 		ns = ns->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL2@xmlTextRea

; 2723 :     return(1);
; 2724 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlTextRea:

; 2658 : 		    reader->curnode = (xmlNodePtr) ns;

	mov	DWORD PTR [esi+68], eax
$LN25@xmlTextRea:
	pop	edi
	pop	esi

; 2676 : 		return(1);

	mov	eax, 1

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 2662 : 	    }
; 2663 : 	    return(0);
; 2664 : 	}
; 2665 : 
; 2666 : 	prop = reader->node->properties;

	mov	esi, DWORD PTR [ecx+44]

; 2667 : 	while (prop != NULL) {

	test	esi, esi
	je	$LN23@xmlTextRea
	npad	3
$LL4@xmlTextRea:

; 2668 : 	    /*
; 2669 : 	     * One need to have
; 2670 : 	     *   - same attribute names
; 2671 : 	     *   - and the attribute carrying that namespace
; 2672 : 	     */
; 2673 : 	    if ((xmlStrEqual(prop->name, name)) &&

	push	ebx
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlTextRea
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN18@xmlTextRea
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN18@xmlTextRea
$LN17@xmlTextRea:

; 2677 : 	    }
; 2678 : 	    prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@xmlTextRea

; 2716 :     return(0);

	pop	edi
	pop	esi
	xor	eax, eax

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 2674 : 		((prop->ns == NULL) || (prop->ns->prefix == NULL))) {
; 2675 : 		reader->curnode = (xmlNodePtr) prop;

	mov	eax, DWORD PTR _reader$[ebp]
	pop	edi
	mov	DWORD PTR [eax+68], esi

; 2676 : 		return(1);

	mov	eax, 1
	pop	esi

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlTextRea:

; 2679 : 	}
; 2680 : 	return(0);
; 2681 :     }
; 2682 : 
; 2683 :     /*
; 2684 :      * Namespace default decl
; 2685 :      */
; 2686 :     if (xmlStrEqual(prefix, BAD_CAST "xmlns")) {

	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrEqual
	mov	esi, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlTextRea

; 2687 : 	ns = reader->node->nsDef;

	mov	esi, DWORD PTR [esi+48]

; 2688 : 	while (ns != NULL) {

	test	esi, esi
	je	SHORT $not_found$51
$LL6@xmlTextRea:

; 2689 : 	    if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN20@xmlTextRea
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found$52
$LN20@xmlTextRea:

; 2690 : 		reader->curnode = (xmlNodePtr) ns;
; 2691 : 		goto found;
; 2692 : 	    }
; 2693 : 	    ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL6@xmlTextRea
$not_found$51:

; 2710 :     }
; 2711 : not_found:
; 2712 :     if (localname != NULL)
; 2713 :         xmlFree(localname);

	push	edi
	call	DWORD PTR _xmlFree

; 2714 :     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@xmlTextRea

; 2715 :         xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlTextRea:

; 2716 :     return(0);

	pop	edi
	pop	esi
	xor	eax, eax

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlTextRea:

; 2694 : 	}
; 2695 : 	goto not_found;
; 2696 :     }
; 2697 :     prop = reader->node->properties;

	mov	esi, DWORD PTR [esi+44]

; 2698 :     while (prop != NULL) {

	test	esi, esi
	je	SHORT $not_found$51
	npad	2
$LL8@xmlTextRea:

; 2699 : 	/*
; 2700 : 	 * One need to have
; 2701 : 	 *   - same attribute names
; 2702 : 	 *   - and the attribute carrying that namespace
; 2703 : 	 */
; 2704 : 	if ((xmlStrEqual(prop->name, localname)) &&
; 2705 : 	    (prop->ns != NULL) && (xmlStrEqual(prop->ns->prefix, prefix))) {

	push	edi
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlTextRea
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN21@xmlTextRea
	push	DWORD PTR _prefix$[ebp]
	push	DWORD PTR [eax+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $found$52
$LN21@xmlTextRea:

; 2706 : 	    reader->curnode = (xmlNodePtr) prop;
; 2707 : 	    goto found;
; 2708 : 	}
; 2709 : 	prop = prop->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL8@xmlTextRea

; 2698 :     while (prop != NULL) {

	jmp	SHORT $not_found$51
$found$52:

; 2717 : 
; 2718 : found:
; 2719 :     if (localname != NULL)

	mov	eax, DWORD PTR _reader$[ebp]

; 2720 :         xmlFree(localname);

	push	edi
	mov	DWORD PTR [eax+68], esi
	call	DWORD PTR _xmlFree

; 2721 :     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN25@xmlTextRea

; 2722 :         xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	mov	eax, 1
	pop	edi
	pop	esi

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlTextRea:
	pop	esi

; 2641 : 	return(-1);

	or	eax, -1

; 2723 :     return(1);
; 2724 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderMoveToAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderMoveToAttributeNo
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_no$ = 12						; size = 4
_xmlTextReaderMoveToAttributeNo PROC			; COMDAT

; 2585 : xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader, int no) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN24@xmlTextRea

; 2586 :     int i;
; 2587 :     xmlAttrPtr cur;
; 2588 :     xmlNsPtr ns;
; 2589 : 
; 2590 :     if (reader == NULL)
; 2591 : 	return(-1);
; 2592 :     if (reader->node == NULL)

	mov	edi, DWORD PTR [esi+64]
	test	edi, edi
	je	SHORT $LN24@xmlTextRea

; 2593 : 	return(-1);
; 2594 :     /* TODO: handle the xmlDecl */
; 2595 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN24@xmlTextRea

; 2597 : 
; 2598 :     reader->curnode = NULL;
; 2599 : 
; 2600 :     ns = reader->node->nsDef;
; 2601 :     for (i = 0;(i < no) && (ns != NULL);i++) {

	mov	edx, DWORD PTR _no$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+68], 0
	mov	ecx, DWORD PTR [edi+48]
	test	edx, edx
	jle	SHORT $LN3@xmlTextRea
$LL4@xmlTextRea:
	test	ecx, ecx
	je	SHORT $LN11@xmlTextRea

; 2602 : 	ns = ns->next;

	mov	ecx, DWORD PTR [ecx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL4@xmlTextRea
$LN3@xmlTextRea:

; 2603 :     }
; 2604 :     if (ns != NULL) {

	test	ecx, ecx
	jne	SHORT $LN6@xmlTextRea
$LN11@xmlTextRea:

; 2605 : 	reader->curnode = (xmlNodePtr) ns;
; 2606 : 	return(1);
; 2607 :     }
; 2608 : 
; 2609 :     cur = reader->node->properties;

	mov	ecx, DWORD PTR [edi+44]

; 2610 :     if (cur == NULL)

	test	ecx, ecx
	je	SHORT $LN17@xmlTextRea

; 2611 : 	return(0);
; 2612 :     for (;i < no;i++) {

	cmp	eax, edx
	jge	SHORT $LN6@xmlTextRea
$LL7@xmlTextRea:

; 2613 : 	cur = cur->next;

	mov	ecx, DWORD PTR [ecx+24]

; 2614 : 	if (cur == NULL)

	test	ecx, ecx
	je	SHORT $LN17@xmlTextRea

; 2611 : 	return(0);
; 2612 :     for (;i < no;i++) {

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL7@xmlTextRea
$LN6@xmlTextRea:
	pop	edi

; 2616 :     }
; 2617 :     /* TODO walk the DTD if present */
; 2618 : 
; 2619 :     reader->curnode = (xmlNodePtr) cur;
; 2620 :     return(1);
; 2621 : }

	mov	DWORD PTR [esi+68], ecx
	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN17@xmlTextRea:
	pop	edi

; 2615 : 	    return(0);

	xor	eax, eax

; 2616 :     }
; 2617 :     /* TODO walk the DTD if present */
; 2618 : 
; 2619 :     reader->curnode = (xmlNodePtr) cur;
; 2620 :     return(1);
; 2621 : }

	pop	esi
	pop	ebp
	ret	0
$LN24@xmlTextRea:
	pop	edi

; 2596 : 	return(-1);

	or	eax, -1

; 2616 :     }
; 2617 :     /* TODO walk the DTD if present */
; 2618 : 
; 2619 :     reader->curnode = (xmlNodePtr) cur;
; 2620 :     return(1);
; 2621 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderMoveToAttributeNo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderLookupNamespace
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlTextReaderLookupNamespace PROC			; COMDAT

; 2559 : xmlTextReaderLookupNamespace(xmlTextReaderPtr reader, const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 2560 :     xmlNsPtr ns;
; 2561 : 
; 2562 :     if (reader == NULL)
; 2563 : 	return(NULL);
; 2564 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 2565 : 	return(NULL);
; 2566 : 
; 2567 :     ns = xmlSearchNs(reader->node->doc, reader->node, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 2568 :     if (ns == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 2570 :     return(xmlStrdup(ns->href));

	push	DWORD PTR [eax+8]
	call	_xmlStrdup
	add	esp, 4

; 2571 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 2569 : 	return(NULL);

	xor	eax, eax

; 2571 : }

	pop	ebp
	ret	0
_xmlTextReaderLookupNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetRemainder
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderGetRemainder PROC				; COMDAT

; 2511 : xmlTextReaderGetRemainder(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN10@xmlTextRea

; 2512 :     xmlParserInputBufferPtr ret = NULL;
; 2513 : 
; 2514 :     if (reader == NULL)
; 2515 : 	return(NULL);
; 2516 :     if (reader->node == NULL)

	cmp	DWORD PTR [esi+64], 0
	je	$LN10@xmlTextRea

; 2517 : 	return(NULL);
; 2518 : 
; 2519 :     reader->node = NULL;
; 2520 :     reader->curnode = NULL;
; 2521 :     reader->mode = XML_TEXTREADER_MODE_EOF;
; 2522 :     if (reader->ctxt != NULL) {

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi], 3
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 2523 : 	xmlStopParser(reader->ctxt);

	push	eax
	call	_xmlStopParser

; 2524 : 	if (reader->ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 2525 : 	    if (reader->preserve == 0)

	cmp	DWORD PTR [esi+80], 0
	jne	SHORT $LN6@xmlTextRea

; 2526 : 		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);

	push	ecx
	push	esi
	call	_xmlTextReaderFreeDoc
	mov	eax, DWORD PTR [esi+20]
	add	esp, 8
$LN6@xmlTextRea:

; 2527 : 	    reader->ctxt->myDoc = NULL;

	mov	DWORD PTR [eax+8], 0
$LN5@xmlTextRea:

; 2528 : 	}
; 2529 :     }
; 2530 :     if (reader->allocs & XML_TEXTREADER_INPUT) {

	mov	ecx, DWORD PTR [esi+12]
	test	cl, 1
	je	SHORT $LN7@xmlTextRea

; 2531 : 	ret = reader->input;

	mov	eax, DWORD PTR [esi+28]

; 2532 : 	reader->input = NULL;
; 2533 : 	reader->allocs -= XML_TEXTREADER_INPUT;

	dec	ecx
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+12], ecx
	pop	esi

; 2542 : 	return(NULL);
; 2543 :     }
; 2544 :     return(ret);
; 2545 : }

	pop	ebp
	ret	0
$LN7@xmlTextRea:

; 2534 :     } else {
; 2535 : 	/*
; 2536 : 	 * Hum, one may need to duplicate the data structure because
; 2537 : 	 * without reference counting the input may be freed twice:
; 2538 : 	 *   - by the layer which allocated it.
; 2539 : 	 *   - by the layer to which would have been returned to.
; 2540 : 	 */
; 2541 : 	TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2541					; 000009edH
	push	OFFSET ??_C@_0GL@PIJMIJNC@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN10@xmlTextRea:

; 2542 : 	return(NULL);
; 2543 :     }
; 2544 :     return(ret);
; 2545 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderGetRemainder ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetAttributeNs
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_localName$ = 12					; size = 4
_namespaceURI$ = 16					; size = 4
_xmlTextReaderGetAttributeNs PROC			; COMDAT

; 2462 : 			    const xmlChar *namespaceURI) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	xor	ebx, ebx
	test	esi, esi
	je	SHORT $LN5@xmlTextRea

; 2463 :     xmlChar *prefix = NULL;
; 2464 :     xmlNsPtr ns;
; 2465 : 
; 2466 :     if ((reader == NULL) || (localName == NULL))

	mov	edi, DWORD PTR _localName$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlTextRea

; 2467 : 	return(NULL);
; 2468 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 2469 : 	return(NULL);
; 2470 :     if (reader->curnode != NULL)

	cmp	DWORD PTR [esi+68], ebx
	jne	SHORT $LN5@xmlTextRea

; 2471 : 	return(NULL);
; 2472 : 
; 2473 :     /* TODO: handle the xmlDecl */
; 2474 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN5@xmlTextRea

; 2475 : 	return(NULL);
; 2476 : 
; 2477 :     if (xmlStrEqual(namespaceURI, BAD_CAST "http://www.w3.org/2000/xmlns/")) {

	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	push	DWORD PTR _namespaceURI$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 2478 : 		if (! xmlStrEqual(localName, BAD_CAST "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax

; 2479 : 			prefix = BAD_CAST localName;
; 2480 : 		}
; 2481 : 		ns = reader->node->nsDef;

	mov	eax, DWORD PTR [esi+64]
	cmove	ebx, edi
	mov	esi, DWORD PTR [eax+48]

; 2482 : 		while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlTextRea
$LL2@xmlTextRea:

; 2483 : 			if ((prefix == NULL && ns->prefix == NULL) ||

	test	ebx, ebx
	jne	SHORT $LN20@xmlTextRea
	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN12@xmlTextRea
$LN20@xmlTextRea:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN11@xmlTextRea
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlTextRea
$LN11@xmlTextRea:

; 2486 : 			}
; 2487 : 			ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL2@xmlTextRea
$LN5@xmlTextRea:
	pop	edi

; 2493 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 2484 : 				((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {
; 2485 : 				return xmlStrdup(ns->href);

	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 2493 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 2488 : 		}
; 2489 : 		return NULL;
; 2490 :     }
; 2491 : 
; 2492 :     return(xmlGetNsProp(reader->node, localName, namespaceURI));

	push	DWORD PTR _namespaceURI$[ebp]
	push	edi
	push	DWORD PTR [esi+64]
	call	_xmlGetNsProp
	add	esp, 12					; 0000000cH
	pop	edi

; 2493 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderGetAttributeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetAttribute
_TEXT	SEGMENT
_prefix$ = -4						; size = 4
_reader$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlTextReaderGetAttribute PROC				; COMDAT

; 2389 : xmlTextReaderGetAttribute(xmlTextReaderPtr reader, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	mov	DWORD PTR _prefix$[ebp], 0
	test	esi, esi
	je	SHORT $LN7@xmlTextRea

; 2390 :     xmlChar *prefix = NULL;
; 2391 :     xmlChar *localname;
; 2392 :     xmlNsPtr ns;
; 2393 :     xmlChar *ret = NULL;
; 2394 : 
; 2395 :     if ((reader == NULL) || (name == NULL))

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	SHORT $LN7@xmlTextRea

; 2396 : 	return(NULL);
; 2397 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN7@xmlTextRea

; 2398 : 	return(NULL);
; 2399 :     if (reader->curnode != NULL)

	cmp	DWORD PTR [esi+68], 0
	jne	SHORT $LN7@xmlTextRea

; 2400 : 	return(NULL);
; 2401 : 
; 2402 :     /* TODO: handle the xmlDecl */
; 2403 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN7@xmlTextRea

; 2404 : 	return(NULL);
; 2405 : 
; 2406 :     localname = xmlSplitQName2(name, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	ebx
	call	_xmlSplitQName2
	add	esp, 8
	mov	edi, eax

; 2407 :     if (localname == NULL) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	test	edi, edi
	jne	SHORT $LN11@xmlTextRea

; 2408 : 		/*
; 2409 : 		 * Namespace default decl
; 2410 : 		 */
; 2411 : 		if (xmlStrEqual(name, BAD_CAST "xmlns")) {

	push	ebx
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlTextRea

; 2412 : 			ns = reader->node->nsDef;

	mov	eax, DWORD PTR [ecx+48]

; 2413 : 			while (ns != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlTextRea
$LL2@xmlTextRea:

; 2414 : 				if (ns->prefix == NULL) {

	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN22@xmlTextRea

; 2416 : 				}
; 2417 : 				ns = ns->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL2@xmlTextRea
$LN7@xmlTextRea:
	pop	edi

; 2445 :     return(ret);
; 2446 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlTextRea:

; 2415 : 					return(xmlStrdup(ns->href));

	push	DWORD PTR [eax+8]
	call	_xmlStrdup
	add	esp, 4
	pop	edi

; 2445 :     return(ret);
; 2446 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 2418 : 			}
; 2419 : 			return NULL;
; 2420 : 		}
; 2421 : 		return(xmlGetNoNsProp(reader->node, name));

	push	ebx
	push	ecx
	call	_xmlGetNoNsProp
	add	esp, 8
	pop	edi

; 2445 :     return(ret);
; 2446 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 2422 : 	}
; 2423 : 
; 2424 :     /*
; 2425 :      * Namespace default decl
; 2426 :      */
; 2427 :     if (xmlStrEqual(prefix, BAD_CAST "xmlns")) {

	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrEqual
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlTextRea

; 2428 : 		ns = reader->node->nsDef;

	mov	esi, DWORD PTR [ecx+48]

; 2429 : 		while (ns != NULL) {

	test	esi, esi
	je	SHORT $LN32@xmlTextRea
	npad	7
$LL4@xmlTextRea:

; 2430 : 			if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@xmlTextRea
	push	edi
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@xmlTextRea
$LN16@xmlTextRea:

; 2432 : 				break;
; 2433 : 			}
; 2434 : 			ns = ns->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlTextRea
$LN32@xmlTextRea:

; 2440 : 	}
; 2441 : 
; 2442 :     xmlFree(localname);

	xor	ebx, ebx
$LN17@xmlTextRea:
	push	edi
	call	DWORD PTR _xmlFree

; 2443 :     if (prefix != NULL)

	mov	eax, DWORD PTR _prefix$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@xmlTextRea

; 2444 :         xmlFree(prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlTextRea:

; 2445 :     return(ret);
; 2446 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlTextRea:

; 2431 : 				ret = xmlStrdup(ns->href);

	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN17@xmlTextRea
$LN14@xmlTextRea:

; 2435 : 		}
; 2436 :     } else {
; 2437 : 		ns = xmlSearchNs(reader->node->doc, reader->node, prefix);

	push	DWORD PTR _prefix$[ebp]
	push	ecx
	push	DWORD PTR [ecx+32]
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH

; 2438 : 		if (ns != NULL)

	test	eax, eax
	je	SHORT $LN32@xmlTextRea

; 2439 : 			ret = xmlGetNsProp(reader->node, localname, ns->href);

	push	DWORD PTR [eax+8]
	push	edi
	push	DWORD PTR [esi+64]
	call	_xmlGetNsProp
	add	esp, 12					; 0000000cH
	mov	ebx, eax
	jmp	SHORT $LN17@xmlTextRea
_xmlTextReaderGetAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderGetAttributeNo
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_no$ = 12						; size = 4
_xmlTextReaderGetAttributeNo PROC			; COMDAT

; 2340 : xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, int no) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN19@xmlTextRea

; 2341 :     xmlChar *ret;
; 2342 :     int i;
; 2343 :     xmlAttrPtr cur;
; 2344 :     xmlNsPtr ns;
; 2345 : 
; 2346 :     if (reader == NULL)
; 2347 : 	return(NULL);
; 2348 :     if (reader->node == NULL)

	mov	esi, DWORD PTR [eax+64]
	test	esi, esi
	je	SHORT $LN19@xmlTextRea

; 2349 : 	return(NULL);
; 2350 :     if (reader->curnode != NULL)

	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN19@xmlTextRea

; 2351 : 	return(NULL);
; 2352 :     /* TODO: handle the xmlDecl */
; 2353 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN19@xmlTextRea

; 2354 : 	return(NULL);
; 2355 : 
; 2356 :     ns = reader->node->nsDef;
; 2357 :     for (i = 0;(i < no) && (ns != NULL);i++) {

	mov	edx, DWORD PTR _no$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR [esi+48]
	test	edx, edx
	jle	SHORT $LN3@xmlTextRea
$LL4@xmlTextRea:
	test	ecx, ecx
	je	SHORT $LN12@xmlTextRea

; 2358 : 	ns = ns->next;

	mov	ecx, DWORD PTR [ecx]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL4@xmlTextRea
$LN3@xmlTextRea:

; 2359 :     }
; 2360 :     if (ns != NULL)

	test	ecx, ecx
	je	SHORT $LN12@xmlTextRea

; 2361 : 	return(xmlStrdup(ns->href));

	push	DWORD PTR [ecx+8]
	call	_xmlStrdup
	add	esp, 4
	pop	esi

; 2375 :     return(ret);
; 2376 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 2362 : 
; 2363 :     cur = reader->node->properties;

	mov	ecx, DWORD PTR [esi+44]

; 2364 :     if (cur == NULL)

	test	ecx, ecx
	je	SHORT $LN19@xmlTextRea

; 2365 : 	return(NULL);
; 2366 :     for (;i < no;i++) {

	cmp	eax, edx
	jge	SHORT $LN6@xmlTextRea
	npad	4
$LL7@xmlTextRea:

; 2367 : 	cur = cur->next;

	mov	ecx, DWORD PTR [ecx+24]

; 2368 : 	if (cur == NULL)

	test	ecx, ecx
	je	SHORT $LN19@xmlTextRea

; 2365 : 	return(NULL);
; 2366 :     for (;i < no;i++) {

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL7@xmlTextRea
$LN6@xmlTextRea:

; 2370 :     }
; 2371 :     /* TODO walk the DTD if present */
; 2372 : 
; 2373 :     ret = xmlNodeListGetString(reader->node->doc, cur->children, 1);

	push	1
	push	DWORD PTR [ecx+12]
	push	DWORD PTR [esi+32]
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH

; 2374 :     if (ret == NULL) return(xmlStrdup((xmlChar *)""));

	test	eax, eax
	jne	SHORT $LN1@xmlTextRea
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	pop	esi

; 2375 :     return(ret);
; 2376 : }

	pop	ebp
	ret	0
$LN19@xmlTextRea:

; 2369 : 	    return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:
	pop	esi

; 2375 :     return(ret);
; 2376 : }

	pop	ebp
	ret	0
_xmlTextReaderGetAttributeNo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderClose
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderClose PROC				; COMDAT

; 2307 : xmlTextReaderClose(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlTextRea

; 2308 :     if (reader == NULL)
; 2309 : 	return(-1);

	or	eax, -1
	pop	esi

; 2326 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 2310 :     reader->node = NULL;
; 2311 :     reader->curnode = NULL;
; 2312 :     reader->mode = XML_TEXTREADER_MODE_CLOSED;
; 2313 :     if (reader->ctxt != NULL) {

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi], 4
	test	eax, eax
	je	SHORT $LN4@xmlTextRea

; 2314 : 	xmlStopParser(reader->ctxt);

	push	eax
	call	_xmlStopParser

; 2315 : 	if (reader->ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN4@xmlTextRea

; 2316 : 	    if (reader->preserve == 0)

	cmp	DWORD PTR [esi+80], 0
	jne	SHORT $LN5@xmlTextRea

; 2317 : 		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);

	push	ecx
	push	esi
	call	_xmlTextReaderFreeDoc
	mov	eax, DWORD PTR [esi+20]
	add	esp, 8
$LN5@xmlTextRea:

; 2318 : 	    reader->ctxt->myDoc = NULL;

	mov	DWORD PTR [eax+8], 0
$LN4@xmlTextRea:

; 2319 : 	}
; 2320 :     }
; 2321 :     if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT)) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea
	test	BYTE PTR [esi+12], 1
	je	SHORT $LN6@xmlTextRea

; 2322 : 	xmlFreeParserInputBuffer(reader->input);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 2323 : 	reader->allocs -= XML_TEXTREADER_INPUT;

	dec	DWORD PTR [esi+12]
$LN6@xmlTextRea:

; 2324 :     }
; 2325 :     return(0);

	xor	eax, eax
	pop	esi

; 2326 : }

	pop	ebp
	ret	0
_xmlTextReaderClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderValue
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderValue PROC				; COMDAT

; 3564 : xmlTextReaderValue(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea

; 3565 :     xmlNodePtr node;
; 3566 :     if (reader == NULL)
; 3567 : 	return(NULL);
; 3568 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN13@xmlTextRea

; 3569 : 	return(NULL);
; 3570 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 3571 : 	node = reader->curnode;
; 3572 :     else
; 3573 : 	node = reader->node;
; 3574 : 
; 3575 :     switch (node->type) {

	mov	eax, DWORD PTR [ecx+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	SHORT $LN13@xmlTextRea
	movzx	eax, BYTE PTR $LN16@xmlTextRea[eax]
	jmp	DWORD PTR $LN20@xmlTextRea[eax*4]
$LN8@xmlTextRea:

; 3576 :         case XML_NAMESPACE_DECL:
; 3577 : 	    return(xmlStrdup(((xmlNsPtr) node)->href));

	push	DWORD PTR [ecx+8]
	call	_xmlStrdup
	add	esp, 4

; 3598 : }

	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 3578 :         case XML_ATTRIBUTE_NODE:{
; 3579 : 	    xmlAttrPtr attr = (xmlAttrPtr) node;
; 3580 : 
; 3581 : 	    if (attr->parent != NULL)

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+12]
	push	1
	push	ecx
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 3582 : 		return (xmlNodeListGetString

	push	DWORD PTR [eax+32]
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH

; 3598 : }

	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 3583 : 			(attr->parent->doc, attr->children, 1));
; 3584 : 	    else
; 3585 : 		return (xmlNodeListGetString(NULL, attr->children, 1));

	push	0
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH

; 3598 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3586 : 	    break;
; 3587 : 	}
; 3588 :         case XML_TEXT_NODE:
; 3589 :         case XML_CDATA_SECTION_NODE:
; 3590 :         case XML_PI_NODE:
; 3591 :         case XML_COMMENT_NODE:
; 3592 :             if (node->content != NULL)

	mov	eax, DWORD PTR [ecx+40]
	test	eax, eax
	je	SHORT $LN13@xmlTextRea

; 3593 :                 return (xmlStrdup(node->content));

	mov	DWORD PTR _reader$[ebp], eax

; 3598 : }

	pop	ebp

; 3593 :                 return (xmlStrdup(node->content));

	jmp	_xmlStrdup
$LN13@xmlTextRea:

; 3594 : 	default:
; 3595 : 	    break;
; 3596 :     }
; 3597 :     return(NULL);

	xor	eax, eax

; 3598 : }

	pop	ebp
	ret	0
	npad	1
$LN20@xmlTextRea:
	DD	$LN9@xmlTextRea
	DD	$LN12@xmlTextRea
	DD	$LN8@xmlTextRea
	DD	$LN13@xmlTextRea
$LN16@xmlTextRea:
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_xmlTextReaderValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderXmlLang
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderXmlLang PROC				; COMDAT

; 3711 : xmlTextReaderXmlLang(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 3712 :     if (reader == NULL)
; 3713 : 	return(NULL);
; 3714 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea

; 3716 :     return(xmlNodeGetLang(reader->node));

	mov	DWORD PTR _reader$[ebp], eax

; 3717 : }

	pop	ebp

; 3716 :     return(xmlNodeGetLang(reader->node));

	jmp	_xmlNodeGetLang
$LN5@xmlTextRea:

; 3715 : 	return(NULL);

	xor	eax, eax

; 3717 : }

	pop	ebp
	ret	0
_xmlTextReaderXmlLang ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderPrefix
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderPrefix PROC				; COMDAT

; 3319 : xmlTextReaderPrefix(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3320 :     xmlNodePtr node;
; 3321 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3323 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 3324 : 	node = reader->curnode;
; 3325 :     else
; 3326 : 	node = reader->node;
; 3327 :     if (node->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN6@xmlTextRea

; 3328 : 	xmlNsPtr ns = (xmlNsPtr) node;
; 3329 : 	if (ns->prefix == NULL)

	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN3@xmlTextRea

; 3330 : 	    return(NULL);
; 3331 : 	return(xmlStrdup(BAD_CAST "xmlns"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_05PPEFOGKI@xmlns@

; 3338 :     return(NULL);
; 3339 : }

	pop	ebp

; 3330 : 	    return(NULL);
; 3331 : 	return(xmlStrdup(BAD_CAST "xmlns"));

	jmp	_xmlStrdup
$LN6@xmlTextRea:

; 3332 :     }
; 3333 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN8@xmlTextRea
	cmp	eax, 2
	jne	SHORT $LN3@xmlTextRea
$LN8@xmlTextRea:

; 3334 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3335 : 	return(NULL);
; 3336 :     if ((node->ns != NULL) && (node->ns->prefix != NULL))

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3337 : 	return(xmlStrdup(node->ns->prefix));

	mov	DWORD PTR _reader$[ebp], eax

; 3338 :     return(NULL);
; 3339 : }

	pop	ebp

; 3337 : 	return(xmlStrdup(node->ns->prefix));

	jmp	_xmlStrdup
$LN3@xmlTextRea:

; 3322 : 	return(NULL);

	xor	eax, eax

; 3338 :     return(NULL);
; 3339 : }

	pop	ebp
	ret	0
_xmlTextReaderPrefix ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNamespaceUri
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNamespaceUri PROC				; COMDAT

; 3383 : xmlTextReaderNamespaceUri(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3384 :     xmlNodePtr node;
; 3385 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3387 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 3388 : 	node = reader->curnode;
; 3389 :     else
; 3390 : 	node = reader->node;
; 3391 :     if (node->type == XML_NAMESPACE_DECL)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN6@xmlTextRea

; 3392 : 	return(xmlStrdup(BAD_CAST "http://www.w3.org/2000/xmlns/"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@

; 3398 :     return(NULL);
; 3399 : }

	pop	ebp

; 3392 : 	return(xmlStrdup(BAD_CAST "http://www.w3.org/2000/xmlns/"));

	jmp	_xmlStrdup
$LN6@xmlTextRea:

; 3393 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN7@xmlTextRea
	cmp	eax, 2
	jne	SHORT $LN3@xmlTextRea
$LN7@xmlTextRea:

; 3394 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3395 : 	return(NULL);
; 3396 :     if (node->ns != NULL)

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3397 : 	return(xmlStrdup(node->ns->href));

	push	DWORD PTR [eax+8]
	call	_xmlStrdup
	add	esp, 4

; 3398 :     return(NULL);
; 3399 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3386 : 	return(NULL);

	xor	eax, eax

; 3398 :     return(NULL);
; 3399 : }

	pop	ebp
	ret	0
_xmlTextReaderNamespaceUri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderName
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderName PROC					; COMDAT

; 3175 : xmlTextReaderName(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	$LN5@xmlTextRea

; 3176 :     xmlNodePtr node;
; 3177 :     xmlChar *ret;
; 3178 : 
; 3179 :     if ((reader == NULL) || (reader->node == NULL))

	mov	esi, DWORD PTR [eax+64]
	test	esi, esi
	je	$LN5@xmlTextRea

; 3181 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	esi, eax

; 3182 : 	node = reader->curnode;
; 3183 :     else
; 3184 : 	node = reader->node;
; 3185 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN5@xmlTextRea
	movzx	eax, BYTE PTR $LN24@xmlTextRea[eax]
	jmp	DWORD PTR $LN28@xmlTextRea[eax*4]
$LN8@xmlTextRea:

; 3186 :         case XML_ELEMENT_NODE:
; 3187 :         case XML_ATTRIBUTE_NODE:
; 3188 : 	    if ((node->ns == NULL) ||

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 3189 : 		(node->ns->prefix == NULL))
; 3190 : 		return(xmlStrdup(node->name));
; 3191 : 
; 3192 : 	    ret = xmlStrdup(node->ns->prefix);

	push	eax
	call	_xmlStrdup

; 3193 : 	    ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 3194 : 	    ret = xmlStrcat(ret, node->name);

	push	DWORD PTR [esi+8]
	push	eax
	call	_xmlStrcat
	add	esp, 20					; 00000014H
	pop	esi

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp
	ret	0
$LN10@xmlTextRea:
	push	DWORD PTR [esi+8]
	call	_xmlStrdup
	add	esp, 4
	pop	esi
	pop	ebp
	ret	0
$LN11@xmlTextRea:
	pop	esi

; 3195 : 	    return(ret);
; 3196 :         case XML_TEXT_NODE:
; 3197 : 	    return(xmlStrdup(BAD_CAST "#text"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_05NOBOONOA@?$CDtext@

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp

; 3195 : 	    return(ret);
; 3196 :         case XML_TEXT_NODE:
; 3197 : 	    return(xmlStrdup(BAD_CAST "#text"));

	jmp	_xmlStrdup
$LN12@xmlTextRea:
	pop	esi

; 3198 :         case XML_CDATA_SECTION_NODE:
; 3199 : 	    return(xmlStrdup(BAD_CAST "#cdata-section"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_0P@LIENAFBO@?$CDcdata?9section@

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp

; 3198 :         case XML_CDATA_SECTION_NODE:
; 3199 : 	    return(xmlStrdup(BAD_CAST "#cdata-section"));

	jmp	_xmlStrdup
$LN15@xmlTextRea:
	pop	esi

; 3200 :         case XML_ENTITY_NODE:
; 3201 :         case XML_ENTITY_REF_NODE:
; 3202 : 	    return(xmlStrdup(node->name));
; 3203 :         case XML_PI_NODE:
; 3204 : 	    return(xmlStrdup(node->name));
; 3205 :         case XML_COMMENT_NODE:
; 3206 : 	    return(xmlStrdup(BAD_CAST "#comment"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_08FBDKDMPC@?$CDcomment@

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp

; 3200 :         case XML_ENTITY_NODE:
; 3201 :         case XML_ENTITY_REF_NODE:
; 3202 : 	    return(xmlStrdup(node->name));
; 3203 :         case XML_PI_NODE:
; 3204 : 	    return(xmlStrdup(node->name));
; 3205 :         case XML_COMMENT_NODE:
; 3206 : 	    return(xmlStrdup(BAD_CAST "#comment"));

	jmp	_xmlStrdup
$LN16@xmlTextRea:
	pop	esi

; 3207 :         case XML_DOCUMENT_NODE:
; 3208 :         case XML_HTML_DOCUMENT_NODE:
; 3209 : #ifdef LIBXML_DOCB_ENABLED
; 3210 :         case XML_DOCB_DOCUMENT_NODE:
; 3211 : #endif
; 3212 : 	    return(xmlStrdup(BAD_CAST "#document"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_09DFKKGJPK@?$CDdocument@

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp

; 3207 :         case XML_DOCUMENT_NODE:
; 3208 :         case XML_HTML_DOCUMENT_NODE:
; 3209 : #ifdef LIBXML_DOCB_ENABLED
; 3210 :         case XML_DOCB_DOCUMENT_NODE:
; 3211 : #endif
; 3212 : 	    return(xmlStrdup(BAD_CAST "#document"));

	jmp	_xmlStrdup
$LN17@xmlTextRea:
	pop	esi

; 3213 :         case XML_DOCUMENT_FRAG_NODE:
; 3214 : 	    return(xmlStrdup(BAD_CAST "#document-fragment"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_0BD@FMMPJIKP@?$CDdocument?9fragment@

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp

; 3213 :         case XML_DOCUMENT_FRAG_NODE:
; 3214 : 	    return(xmlStrdup(BAD_CAST "#document-fragment"));

	jmp	_xmlStrdup
$LN20@xmlTextRea:

; 3215 :         case XML_NOTATION_NODE:
; 3216 : 	    return(xmlStrdup(node->name));
; 3217 :         case XML_DOCUMENT_TYPE_NODE:
; 3218 :         case XML_DTD_NODE:
; 3219 : 	    return(xmlStrdup(node->name));
; 3220 :         case XML_NAMESPACE_DECL: {
; 3221 : 	    xmlNsPtr ns = (xmlNsPtr) node;
; 3222 : 
; 3223 : 	    ret = xmlStrdup(BAD_CAST "xmlns");

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	call	_xmlStrdup
	add	esp, 4

; 3224 : 	    if (ns->prefix == NULL)

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN1@xmlTextRea

; 3225 : 		return(ret);
; 3226 : 	    ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat

; 3227 : 	    ret = xmlStrcat(ret, ns->prefix);

	push	DWORD PTR [esi+12]
	push	eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H
	pop	esi

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 3180 : 	return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:
	pop	esi

; 3228 : 	    return(ret);
; 3229 : 	}
; 3230 : 
; 3231 :         case XML_ELEMENT_DECL:
; 3232 :         case XML_ATTRIBUTE_DECL:
; 3233 :         case XML_ENTITY_DECL:
; 3234 :         case XML_XINCLUDE_START:
; 3235 :         case XML_XINCLUDE_END:
; 3236 : 	    return(NULL);
; 3237 :     }
; 3238 :     return(NULL);
; 3239 : }

	pop	ebp
	ret	0
	npad	1
$LN28@xmlTextRea:
	DD	$LN8@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN12@xmlTextRea
	DD	$LN10@xmlTextRea
	DD	$LN15@xmlTextRea
	DD	$LN16@xmlTextRea
	DD	$LN17@xmlTextRea
	DD	$LN5@xmlTextRea
	DD	$LN20@xmlTextRea
$LN24@xmlTextRea:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	4
	DB	5
	DB	3
	DB	6
	DB	3
	DB	5
	DB	3
	DB	7
	DB	7
	DB	7
	DB	8
	DB	7
	DB	7
	DB	5
_xmlTextReaderName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderLocalName
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderLocalName PROC				; COMDAT

; 3113 : xmlTextReaderLocalName(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlTextRea

; 3114 :     xmlNodePtr node;
; 3115 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [edx+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3117 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [edx+68]
	test	eax, eax
	cmovne	ecx, eax

; 3118 : 	node = reader->curnode;
; 3119 :     else
; 3120 : 	node = reader->node;
; 3121 :     if (node->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN8@xmlTextRea

; 3122 : 	xmlNsPtr ns = (xmlNsPtr) node;
; 3123 : 	if (ns->prefix == NULL)

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN7@xmlTextRea

; 3124 : 	    return(xmlStrdup(BAD_CAST "xmlns"));

	mov	DWORD PTR _reader$[ebp], OFFSET ??_C@_05PPEFOGKI@xmlns@

; 3132 : }

	pop	ebp

; 3124 : 	    return(xmlStrdup(BAD_CAST "xmlns"));

	jmp	_xmlStrdup
$LN7@xmlTextRea:

; 3125 : 	else
; 3126 : 	    return(xmlStrdup(ns->prefix));

	mov	DWORD PTR _reader$[ebp], eax

; 3132 : }

	pop	ebp

; 3125 : 	else
; 3126 : 	    return(xmlStrdup(ns->prefix));

	jmp	_xmlStrdup
$LN8@xmlTextRea:

; 3127 :     }
; 3128 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN9@xmlTextRea
	cmp	eax, 2
	je	SHORT $LN9@xmlTextRea

; 3129 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3130 : 	return(xmlTextReaderName(reader));

	mov	DWORD PTR _reader$[ebp], edx

; 3132 : }

	pop	ebp

; 3129 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3130 : 	return(xmlTextReaderName(reader));

	jmp	_xmlTextReaderName
$LN9@xmlTextRea:

; 3131 :     return(xmlStrdup(node->name));

	push	DWORD PTR [ecx+8]
	call	_xmlStrdup
	add	esp, 4

; 3132 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3116 : 	return(NULL);

	xor	eax, eax

; 3132 : }

	pop	ebp
	ret	0
_xmlTextReaderLocalName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderBaseUri
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderBaseUri PROC				; COMDAT

; 3439 : xmlTextReaderBaseUri(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3440 :     if ((reader == NULL) || (reader->node == NULL))

	mov	eax, DWORD PTR [eax+64]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3442 :     return(xmlNodeGetBase(NULL, reader->node));

	push	eax
	push	0
	call	_xmlNodeGetBase
	add	esp, 8

; 3443 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3441 : 	return(NULL);

	xor	eax, eax

; 3443 : }

	pop	ebp
	ret	0
_xmlTextReaderBaseUri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstValue
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstValue PROC				; COMDAT

; 3610 : xmlTextReaderConstValue(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN17@xmlTextRea

; 3611 :     xmlNodePtr node;
; 3612 :     if (reader == NULL)
; 3613 : 	return(NULL);
; 3614 :     if (reader->node == NULL)

	mov	edi, DWORD PTR [esi+64]
	test	edi, edi
	je	SHORT $LN17@xmlTextRea

; 3615 : 	return(NULL);
; 3616 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	cmovne	edi, eax

; 3617 : 	node = reader->curnode;
; 3618 :     else
; 3619 : 	node = reader->node;
; 3620 : 
; 3621 :     switch (node->type) {

	mov	ecx, DWORD PTR [edi+4]
	add	ecx, -2					; fffffffeH
	cmp	ecx, 16					; 00000010H
	ja	SHORT $LN17@xmlTextRea
	movzx	ecx, BYTE PTR $LN19@xmlTextRea[ecx]
	jmp	DWORD PTR $LN21@xmlTextRea[ecx*4]
$LN8@xmlTextRea:

; 3622 :         case XML_NAMESPACE_DECL:
; 3623 : 	    return(((xmlNsPtr) node)->href);

	mov	eax, DWORD PTR [edi+8]
	pop	edi

; 3663 : 	default:
; 3664 : 	    break;
; 3665 :     }
; 3666 :     return(NULL);
; 3667 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 3624 :         case XML_ATTRIBUTE_NODE:{
; 3625 : 	    xmlAttrPtr attr = (xmlAttrPtr) node;
; 3626 : 	    const xmlChar *ret;
; 3627 : 
; 3628 : 	    if ((attr->children != NULL) &&
; 3629 : 	        (attr->children->type == XML_TEXT_NODE) &&

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN10@xmlTextRea
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN10@xmlTextRea

; 3630 : 		(attr->children->next == NULL))
; 3631 : 		return(attr->children->content);

	mov	eax, DWORD PTR [eax+40]
	pop	edi

; 3663 : 	default:
; 3664 : 	    break;
; 3665 :     }
; 3666 :     return(NULL);
; 3667 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 3632 : 	    else {
; 3633 : 		if (reader->buffer == NULL) {

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	jne	SHORT $LN12@xmlTextRea

; 3634 : 		    reader->buffer = xmlBufCreateSize(100);

	push	100					; 00000064H
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR [esi+84], eax

; 3635 :                     if (reader->buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlTextRea

; 3636 :                         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CE@MNBJMFAB@xmlTextReaderSetup?5?3?5malloc?5fai@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN17@xmlTextRea:

; 3663 : 	default:
; 3664 : 	    break;
; 3665 :     }
; 3666 :     return(NULL);
; 3667 : }

	xor	eax, eax
$LN1@xmlTextRea:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN14@xmlTextRea:

; 3637 :                                         "xmlTextReaderSetup : malloc failed\n");
; 3638 :                         return (NULL);
; 3639 :                     }
; 3640 : 		    xmlBufSetAllocationScheme(reader->buffer,

	push	5
	push	eax
	call	_xmlBufSetAllocationScheme
	add	esp, 8

; 3641 : 		                              XML_BUFFER_ALLOC_BOUNDED);
; 3642 :                 } else

	jmp	SHORT $LN13@xmlTextRea
$LN12@xmlTextRea:

; 3643 :                     xmlBufEmpty(reader->buffer);

	push	eax
	call	_xmlBufEmpty
	add	esp, 4
$LN13@xmlTextRea:

; 3644 : 	        xmlBufGetNodeContent(reader->buffer, node);

	push	edi
	push	DWORD PTR [esi+84]
	call	_xmlBufGetNodeContent

; 3645 : 		ret = xmlBufContent(reader->buffer);

	push	DWORD PTR [esi+84]
	call	_xmlBufContent
	add	esp, 12					; 0000000cH

; 3646 : 		if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN1@xmlTextRea

; 3647 : 		    /* error on the buffer best to reallocate */
; 3648 : 		    xmlBufFree(reader->buffer);

	push	DWORD PTR [esi+84]
	call	_xmlBufFree

; 3649 : 		    reader->buffer = xmlBufCreateSize(100);

	push	100					; 00000064H
	call	_xmlBufCreateSize

; 3650 : 		    xmlBufSetAllocationScheme(reader->buffer,

	push	5
	push	eax
	mov	DWORD PTR [esi+84], eax
	call	_xmlBufSetAllocationScheme
	add	esp, 16					; 00000010H

; 3651 : 		                              XML_BUFFER_ALLOC_BOUNDED);
; 3652 : 		    ret = BAD_CAST "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	pop	edi

; 3663 : 	default:
; 3664 : 	    break;
; 3665 :     }
; 3666 :     return(NULL);
; 3667 : }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 3653 : 		}
; 3654 : 		return(ret);
; 3655 : 	    }
; 3656 : 	    break;
; 3657 : 	}
; 3658 :         case XML_TEXT_NODE:
; 3659 :         case XML_CDATA_SECTION_NODE:
; 3660 :         case XML_PI_NODE:
; 3661 :         case XML_COMMENT_NODE:
; 3662 : 	    return(node->content);

	mov	eax, DWORD PTR [edi+40]
	pop	edi

; 3663 : 	default:
; 3664 : 	    break;
; 3665 :     }
; 3666 :     return(NULL);
; 3667 : }

	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN21@xmlTextRea:
	DD	$LN9@xmlTextRea
	DD	$LN16@xmlTextRea
	DD	$LN8@xmlTextRea
	DD	$LN17@xmlTextRea
$LN19@xmlTextRea:
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_xmlTextReaderConstValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstString
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlTextReaderConstString PROC				; COMDAT

; 3756 : xmlTextReaderConstString(xmlTextReaderPtr reader, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlTextRea

; 3760 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 3757 :     if (reader == NULL)
; 3758 : 	return(NULL);
; 3759 :     return(CONSTSTR(str));

	push	-1
	push	DWORD PTR _str$[ebp]
	push	DWORD PTR [eax+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3760 : }

	pop	ebp
	ret	0
_xmlTextReaderConstString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstXmlLang
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstXmlLang PROC				; COMDAT

; 3728 : xmlTextReaderConstXmlLang(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlTextRea

; 3729 :     xmlChar *tmp;
; 3730 :     const xmlChar *ret;
; 3731 : 
; 3732 :     if (reader == NULL)
; 3733 : 	return(NULL);
; 3734 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea

; 3735 : 	return(NULL);
; 3736 :     tmp = xmlNodeGetLang(reader->node);

	push	eax
	call	_xmlNodeGetLang
	mov	edi, eax
	add	esp, 4

; 3737 :     if (tmp == NULL)

	test	edi, edi
	je	SHORT $LN6@xmlTextRea

; 3739 :     ret = CONSTSTR(tmp);

	push	-1
	push	edi
	push	DWORD PTR [esi+88]
	call	_xmlDictLookup

; 3740 :     xmlFree(tmp);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 3741 :     return(ret);

	mov	eax, esi
	pop	edi

; 3742 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlTextRea:
	pop	edi

; 3738 :         return(NULL);

	xor	eax, eax

; 3742 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderConstXmlLang ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstPrefix
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstPrefix PROC				; COMDAT

; 3351 : xmlTextReaderConstPrefix(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlTextRea

; 3352 :     xmlNodePtr node;
; 3353 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [edx+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3355 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [edx+68]
	test	eax, eax
	cmovne	ecx, eax

; 3356 : 	node = reader->curnode;
; 3357 :     else
; 3358 : 	node = reader->node;
; 3359 :     if (node->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN6@xmlTextRea

; 3360 : 	xmlNsPtr ns = (xmlNsPtr) node;
; 3361 : 	if (ns->prefix == NULL)

	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN3@xmlTextRea

; 3362 : 	    return(NULL);
; 3363 : 	return(CONSTSTR(BAD_CAST "xmlns"));

	push	-1
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3370 :     return(NULL);
; 3371 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 3364 :     }
; 3365 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN8@xmlTextRea
	cmp	eax, 2
	jne	SHORT $LN3@xmlTextRea
$LN8@xmlTextRea:

; 3366 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3367 : 	return(NULL);
; 3368 :     if ((node->ns != NULL) && (node->ns->prefix != NULL))

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3369 : 	return(CONSTSTR(node->ns->prefix));

	push	-1
	push	eax
	push	DWORD PTR [edx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3370 :     return(NULL);
; 3371 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3354 : 	return(NULL);

	xor	eax, eax

; 3370 :     return(NULL);
; 3371 : }

	pop	ebp
	ret	0
_xmlTextReaderConstPrefix ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstNamespaceUri
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstNamespaceUri PROC			; COMDAT

; 3411 : xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3412 :     xmlNodePtr node;
; 3413 :     if ((reader == NULL) || (reader->node == NULL))

	mov	edx, DWORD PTR [ecx+64]
	test	edx, edx
	je	SHORT $LN3@xmlTextRea

; 3415 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	cmovne	edx, eax

; 3416 : 	node = reader->curnode;
; 3417 :     else
; 3418 : 	node = reader->node;
; 3419 :     if (node->type == XML_NAMESPACE_DECL)

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN6@xmlTextRea

; 3420 : 	return(CONSTSTR(BAD_CAST "http://www.w3.org/2000/xmlns/"));

	push	-1
	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3426 :     return(NULL);
; 3427 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 3421 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN7@xmlTextRea
	cmp	eax, 2
	jne	SHORT $LN3@xmlTextRea
$LN7@xmlTextRea:

; 3422 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3423 : 	return(NULL);
; 3424 :     if (node->ns != NULL)

	mov	eax, DWORD PTR [edx+36]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3425 : 	return(CONSTSTR(node->ns->href));

	push	-1
	push	DWORD PTR [eax+8]
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3426 :     return(NULL);
; 3427 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3414 : 	return(NULL);

	xor	eax, eax

; 3426 :     return(NULL);
; 3427 : }

	pop	ebp
	ret	0
_xmlTextReaderConstNamespaceUri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstName
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstName PROC				; COMDAT

; 3251 : xmlTextReaderConstName(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	$LN5@xmlTextRea

; 3252 :     xmlNodePtr node;
; 3253 : 
; 3254 :     if ((reader == NULL) || (reader->node == NULL))

	mov	edx, DWORD PTR [ecx+64]
	test	edx, edx
	je	$LN5@xmlTextRea

; 3256 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	cmovne	edx, eax

; 3257 : 	node = reader->curnode;
; 3258 :     else
; 3259 : 	node = reader->node;
; 3260 :     switch (node->type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN5@xmlTextRea
	movzx	eax, BYTE PTR $LN24@xmlTextRea[eax]
	jmp	DWORD PTR $LN26@xmlTextRea[eax*4]
$LN8@xmlTextRea:

; 3261 :         case XML_ELEMENT_NODE:
; 3262 :         case XML_ATTRIBUTE_NODE:
; 3263 : 	    if ((node->ns == NULL) ||

	mov	eax, DWORD PTR [edx+36]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN10@xmlTextRea

; 3266 : 	    return(CONSTQSTR(node->ns->prefix, node->name));

	push	DWORD PTR [edx+8]
	push	eax
	push	DWORD PTR [ecx+88]
	call	_xmlDictQLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 3264 : 		(node->ns->prefix == NULL))
; 3265 : 		return(node->name);

	mov	eax, DWORD PTR [edx+8]

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 3267 :         case XML_TEXT_NODE:
; 3268 : 	    return(CONSTSTR(BAD_CAST "#text"));

	push	-1
	push	OFFSET ??_C@_05NOBOONOA@?$CDtext@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3269 :         case XML_CDATA_SECTION_NODE:
; 3270 : 	    return(CONSTSTR(BAD_CAST "#cdata-section"));

	push	-1
	push	OFFSET ??_C@_0P@LIENAFBO@?$CDcdata?9section@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN13@xmlTextRea:
	push	-1
	push	DWORD PTR [edx+8]
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
$LN15@xmlTextRea:

; 3271 :         case XML_ENTITY_NODE:
; 3272 :         case XML_ENTITY_REF_NODE:
; 3273 : 	    return(CONSTSTR(node->name));
; 3274 :         case XML_PI_NODE:
; 3275 : 	    return(CONSTSTR(node->name));
; 3276 :         case XML_COMMENT_NODE:
; 3277 : 	    return(CONSTSTR(BAD_CAST "#comment"));

	push	-1
	push	OFFSET ??_C@_08FBDKDMPC@?$CDcomment@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 3278 :         case XML_DOCUMENT_NODE:
; 3279 :         case XML_HTML_DOCUMENT_NODE:
; 3280 : #ifdef LIBXML_DOCB_ENABLED
; 3281 :         case XML_DOCB_DOCUMENT_NODE:
; 3282 : #endif
; 3283 : 	    return(CONSTSTR(BAD_CAST "#document"));

	push	-1
	push	OFFSET ??_C@_09DFKKGJPK@?$CDdocument@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN17@xmlTextRea:

; 3284 :         case XML_DOCUMENT_FRAG_NODE:
; 3285 : 	    return(CONSTSTR(BAD_CAST "#document-fragment"));

	push	-1
	push	OFFSET ??_C@_0BD@FMMPJIKP@?$CDdocument?9fragment@
	push	DWORD PTR [ecx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN20@xmlTextRea:

; 3286 :         case XML_NOTATION_NODE:
; 3287 : 	    return(CONSTSTR(node->name));
; 3288 :         case XML_DOCUMENT_TYPE_NODE:
; 3289 :         case XML_DTD_NODE:
; 3290 : 	    return(CONSTSTR(node->name));
; 3291 :         case XML_NAMESPACE_DECL: {
; 3292 : 	    xmlNsPtr ns = (xmlNsPtr) node;
; 3293 : 
; 3294 : 	    if (ns->prefix == NULL)

	mov	edx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [ecx+88]
	test	edx, edx
	jne	SHORT $LN21@xmlTextRea

; 3295 : 		return(CONSTSTR(BAD_CAST "xmlns"));

	push	-1
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN21@xmlTextRea:

; 3296 : 	    return(CONSTQSTR(BAD_CAST "xmlns", ns->prefix));

	push	edx
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	eax
	call	_xmlDictQLookup
	add	esp, 12					; 0000000cH

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 3255 : 	return(NULL);

	xor	eax, eax

; 3297 : 	}
; 3298 : 
; 3299 :         case XML_ELEMENT_DECL:
; 3300 :         case XML_ATTRIBUTE_DECL:
; 3301 :         case XML_ENTITY_DECL:
; 3302 :         case XML_XINCLUDE_START:
; 3303 :         case XML_XINCLUDE_END:
; 3304 : 	    return(NULL);
; 3305 :     }
; 3306 :     return(NULL);
; 3307 : }

	pop	ebp
	ret	0
	npad	3
$LN26@xmlTextRea:
	DD	$LN8@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN12@xmlTextRea
	DD	$LN13@xmlTextRea
	DD	$LN15@xmlTextRea
	DD	$LN16@xmlTextRea
	DD	$LN17@xmlTextRea
	DD	$LN5@xmlTextRea
	DD	$LN20@xmlTextRea
$LN24@xmlTextRea:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	4
	DB	5
	DB	3
	DB	6
	DB	3
	DB	5
	DB	3
	DB	7
	DB	7
	DB	7
	DB	8
	DB	7
	DB	7
	DB	5
_xmlTextReaderConstName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstLocalName
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstLocalName PROC			; COMDAT

; 3144 : xmlTextReaderConstLocalName(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _reader$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlTextRea

; 3145 :     xmlNodePtr node;
; 3146 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [edx+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3148 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [edx+68]
	test	eax, eax
	cmovne	ecx, eax

; 3149 : 	node = reader->curnode;
; 3150 :     else
; 3151 : 	node = reader->node;
; 3152 :     if (node->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN8@xmlTextRea

; 3153 : 	xmlNsPtr ns = (xmlNsPtr) node;
; 3154 : 	if (ns->prefix == NULL)

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN1@xmlTextRea

; 3155 : 	    return(CONSTSTR(BAD_CAST "xmlns"));

	push	-1
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	DWORD PTR [edx+88]
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH

; 3163 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 3156 : 	else
; 3157 : 	    return(ns->prefix);
; 3158 :     }
; 3159 :     if ((node->type != XML_ELEMENT_NODE) &&

	cmp	eax, 1
	je	SHORT $LN9@xmlTextRea
	cmp	eax, 2
	je	SHORT $LN9@xmlTextRea

; 3160 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3161 : 	return(xmlTextReaderConstName(reader));

	mov	DWORD PTR _reader$[ebp], edx

; 3163 : }

	pop	ebp

; 3160 : 	(node->type != XML_ATTRIBUTE_NODE))
; 3161 : 	return(xmlTextReaderConstName(reader));

	jmp	_xmlTextReaderConstName
$LN9@xmlTextRea:

; 3162 :     return(node->name);

	mov	eax, DWORD PTR [ecx+8]

; 3163 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3147 : 	return(NULL);

	xor	eax, eax
$LN1@xmlTextRea:

; 3163 : }

	pop	ebp
	ret	0
_xmlTextReaderConstLocalName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderConstBaseUri
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderConstBaseUri PROC				; COMDAT

; 3455 : xmlTextReaderConstBaseUri(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlTextRea

; 3456 :     xmlChar *tmp;
; 3457 :     const xmlChar *ret;
; 3458 : 
; 3459 :     if ((reader == NULL) || (reader->node == NULL))

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3461 :     tmp = xmlNodeGetBase(NULL, reader->node);

	push	eax
	push	0
	call	_xmlNodeGetBase
	mov	edi, eax
	add	esp, 8

; 3462 :     if (tmp == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlTextRea

; 3463 :         return(NULL);
; 3464 :     ret = CONSTSTR(tmp);

	push	-1
	push	edi
	push	DWORD PTR [esi+88]
	call	_xmlDictLookup

; 3465 :     xmlFree(tmp);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 3466 :     return(ret);

	mov	eax, esi
	pop	edi

; 3467 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlTextRea:
	pop	edi

; 3460 : 	return(NULL);

	xor	eax, eax

; 3467 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderConstBaseUri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderIsNamespaceDecl
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderIsNamespaceDecl PROC			; COMDAT

; 4650 : xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlTextRea

; 4651 :     xmlNodePtr node;
; 4652 :     if (reader == NULL)
; 4653 : 	return(-1);
; 4654 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN9@xmlTextRea

; 4656 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 4657 : 	node = reader->curnode;
; 4658 :     else
; 4659 : 	node = reader->node;
; 4660 : 
; 4661 :     if (XML_NAMESPACE_DECL == node->type)

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	sete	al

; 4662 : 	return(1);
; 4663 :     else
; 4664 : 	return(0);
; 4665 : }

	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 4655 : 	return(-1);

	or	eax, -1

; 4662 : 	return(1);
; 4663 :     else
; 4664 : 	return(0);
; 4665 : }

	pop	ebp
	ret	0
_xmlTextReaderIsNamespaceDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadState
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderReadState PROC				; COMDAT

; 1629 : xmlTextReaderReadState(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlTextRea

; 1630 :     if (reader == NULL)
; 1631 : 	return(-1);

	or	eax, -1

; 1633 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 1632 :     return(reader->mode);

	mov	eax, DWORD PTR [eax]

; 1633 : }

	pop	ebp
	ret	0
_xmlTextReaderReadState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderQuoteChar
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderQuoteChar PROC				; COMDAT

; 3694 : xmlTextReaderQuoteChar(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	or	ecx, -1
	mov	eax, 34					; 00000022H
	cmp	DWORD PTR _reader$[ebp], 0
	cmove	eax, ecx

; 3695 :     if (reader == NULL)
; 3696 : 	return(-1);
; 3697 :     /* TODO maybe lookup the attribute value for " first */
; 3698 :     return((int) '"');
; 3699 : }

	pop	ebp
	ret	0
_xmlTextReaderQuoteChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderNodeType
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderNodeType PROC				; COMDAT

; 3011 : xmlTextReaderNodeType(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN2@xmlTextRea

; 3012 :     xmlNodePtr node;
; 3013 : 
; 3014 :     if (reader == NULL)
; 3015 : 	return(-1);
; 3016 :     if (reader->node == NULL)

	mov	edx, DWORD PTR [esi+64]
	test	edx, edx
	je	$LN26@xmlTextRea

; 3017 : 	return(XML_READER_TYPE_NONE);
; 3018 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [esi+68]
	mov	ecx, edx
	test	eax, eax
	cmovne	ecx, eax

; 3019 : 	node = reader->curnode;
; 3020 :     else
; 3021 : 	node = reader->node;
; 3022 :     switch (node->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN2@xmlTextRea
	jmp	DWORD PTR $LN29@xmlTextRea[eax*4]
$LN8@xmlTextRea:

; 3023 :         case XML_ELEMENT_NODE:
; 3024 : 	    if ((reader->state == XML_TEXTREADER_END) ||

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, 2
	je	SHORT $LN10@xmlTextRea
	cmp	eax, 4
	je	SHORT $LN10@xmlTextRea

; 3027 : 	    return(XML_READER_TYPE_ELEMENT);

	mov	eax, 1
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 3025 : 		(reader->state == XML_TEXTREADER_BACKTRACK))
; 3026 : 		return(XML_READER_TYPE_END_ELEMENT);

	mov	eax, 15					; 0000000fH
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 3028 :         case XML_NAMESPACE_DECL:
; 3029 :         case XML_ATTRIBUTE_NODE:
; 3030 : 	    return(XML_READER_TYPE_ATTRIBUTE);

	mov	eax, 2
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3031 :         case XML_TEXT_NODE:
; 3032 : 	    if (xmlIsBlankNode(reader->node)) {

	push	edx
	call	_xmlIsBlankNode
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@xmlTextRea

; 3033 : 		if (xmlNodeGetSpacePreserve(reader->node))

	push	DWORD PTR [esi+64]
	call	_xmlNodeGetSpacePreserve
	add	esp, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	add	eax, 13					; 0000000dH
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN13@xmlTextRea:

; 3034 : 		    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);
; 3035 : 		else
; 3036 : 		    return(XML_READER_TYPE_WHITESPACE);
; 3037 : 	    } else {
; 3038 : 		return(XML_READER_TYPE_TEXT);

	mov	eax, 3
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN14@xmlTextRea:

; 3039 : 	    }
; 3040 :         case XML_CDATA_SECTION_NODE:
; 3041 : 	    return(XML_READER_TYPE_CDATA);

	mov	eax, 4
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN18@xmlTextRea:

; 3042 :         case XML_ENTITY_REF_NODE:
; 3043 : 	    return(XML_READER_TYPE_ENTITY_REFERENCE);

	mov	eax, 5
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN19@xmlTextRea:

; 3044 :         case XML_ENTITY_NODE:
; 3045 : 	    return(XML_READER_TYPE_ENTITY);

	mov	eax, 6
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN20@xmlTextRea:

; 3046 :         case XML_PI_NODE:
; 3047 : 	    return(XML_READER_TYPE_PROCESSING_INSTRUCTION);

	mov	eax, 7
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN21@xmlTextRea:

; 3048 :         case XML_COMMENT_NODE:
; 3049 : 	    return(XML_READER_TYPE_COMMENT);

	mov	eax, 8
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN22@xmlTextRea:

; 3050 :         case XML_DOCUMENT_NODE:
; 3051 :         case XML_HTML_DOCUMENT_NODE:
; 3052 : #ifdef LIBXML_DOCB_ENABLED
; 3053 :         case XML_DOCB_DOCUMENT_NODE:
; 3054 : #endif
; 3055 : 	    return(XML_READER_TYPE_DOCUMENT);

	mov	eax, 9
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN23@xmlTextRea:

; 3056 :         case XML_DOCUMENT_FRAG_NODE:
; 3057 : 	    return(XML_READER_TYPE_DOCUMENT_FRAGMENT);

	mov	eax, 11					; 0000000bH
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN24@xmlTextRea:

; 3058 :         case XML_NOTATION_NODE:
; 3059 : 	    return(XML_READER_TYPE_NOTATION);

	mov	eax, 12					; 0000000cH
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN25@xmlTextRea:

; 3060 :         case XML_DOCUMENT_TYPE_NODE:
; 3061 :         case XML_DTD_NODE:
; 3062 : 	    return(XML_READER_TYPE_DOCUMENT_TYPE);

	mov	eax, 10					; 0000000aH
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN26@xmlTextRea:

; 3063 : 
; 3064 :         case XML_ELEMENT_DECL:
; 3065 :         case XML_ATTRIBUTE_DECL:
; 3066 :         case XML_ENTITY_DECL:
; 3067 :         case XML_XINCLUDE_START:
; 3068 :         case XML_XINCLUDE_END:
; 3069 : 	    return(XML_READER_TYPE_NONE);

	xor	eax, eax
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 3070 :     }
; 3071 :     return(-1);

	or	eax, -1
	pop	esi

; 3072 : }

	pop	ebp
	ret	0
	npad	2
$LN29@xmlTextRea:
	DD	$LN8@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN12@xmlTextRea
	DD	$LN14@xmlTextRea
	DD	$LN18@xmlTextRea
	DD	$LN19@xmlTextRea
	DD	$LN20@xmlTextRea
	DD	$LN21@xmlTextRea
	DD	$LN22@xmlTextRea
	DD	$LN25@xmlTextRea
	DD	$LN23@xmlTextRea
	DD	$LN24@xmlTextRea
	DD	$LN22@xmlTextRea
	DD	$LN25@xmlTextRea
	DD	$LN26@xmlTextRea
	DD	$LN26@xmlTextRea
	DD	$LN26@xmlTextRea
	DD	$LN11@xmlTextRea
	DD	$LN26@xmlTextRea
	DD	$LN26@xmlTextRea
	DD	$LN22@xmlTextRea
_xmlTextReaderNodeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderIsEmptyElement
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderIsEmptyElement PROC			; COMDAT

; 3083 : xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlTextRea

; 3084 :     if ((reader == NULL) || (reader->node == NULL))

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea

; 3086 :     if (reader->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN12@xmlTextRea

; 3087 : 	return(0);
; 3088 :     if (reader->curnode != NULL)

	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN12@xmlTextRea

; 3089 : 	return(0);
; 3090 :     if (reader->node->children != NULL)

	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN12@xmlTextRea

; 3091 : 	return(0);
; 3092 :     if (reader->state == XML_TEXTREADER_END)

	cmp	DWORD PTR [eax+16], 2
	je	SHORT $LN12@xmlTextRea

; 3094 :     if (reader->doc != NULL)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@xmlTextRea

; 3095 :         return(1);
; 3096 : #ifdef LIBXML_XINCLUDE_ENABLED
; 3097 :     if (reader->in_xinclude > 0)

	cmp	DWORD PTR [eax+168], 0
	jg	SHORT $LN11@xmlTextRea

; 3099 : #endif
; 3100 :     return((reader->node->extra & NODE_IS_EMPTY) != 0);

	movzx	eax, WORD PTR [ecx+58]
	and	eax, 1

; 3101 : }

	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 3098 :         return(1);

	mov	eax, 1

; 3101 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 3093 : 	return(0);

	xor	eax, eax

; 3101 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3085 : 	return(-1);

	or	eax, -1

; 3101 : }

	pop	ebp
	ret	0
_xmlTextReaderIsEmptyElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderIsDefault
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderIsDefault PROC				; COMDAT

; 3679 : xmlTextReaderIsDefault(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	dec	eax

; 3680 :     if (reader == NULL)
; 3681 : 	return(-1);
; 3682 :     return(0);
; 3683 : }

	pop	ebp
	ret	0
_xmlTextReaderIsDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderHasValue
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderHasValue PROC				; COMDAT

; 3529 : xmlTextReaderHasValue(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlTextRea

; 3530 :     xmlNodePtr node;
; 3531 :     if (reader == NULL)
; 3532 : 	return(-1);

	or	eax, -1

; 3552 : }

	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 3533 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN9@xmlTextRea

; 3534 : 	return(0);
; 3535 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 3536 : 	node = reader->curnode;
; 3537 :     else
; 3538 : 	node = reader->node;
; 3539 : 
; 3540 :     switch (node->type) {

	mov	eax, DWORD PTR [ecx+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	SHORT $LN9@xmlTextRea
	movzx	eax, BYTE PTR $LN11@xmlTextRea[eax]
	jmp	DWORD PTR $LN13@xmlTextRea[eax*4]
$LN8@xmlTextRea:

; 3541 :         case XML_ATTRIBUTE_NODE:
; 3542 :         case XML_TEXT_NODE:
; 3543 :         case XML_CDATA_SECTION_NODE:
; 3544 :         case XML_PI_NODE:
; 3545 :         case XML_COMMENT_NODE:
; 3546 :         case XML_NAMESPACE_DECL:
; 3547 : 	    return(1);

	mov	eax, 1

; 3552 : }

	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 3548 : 	default:
; 3549 : 	    break;
; 3550 :     }
; 3551 :     return(0);

	xor	eax, eax

; 3552 : }

	pop	ebp
	ret	0
$LN13@xmlTextRea:
	DD	$LN8@xmlTextRea
	DD	$LN9@xmlTextRea
$LN11@xmlTextRea:
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlTextReaderHasValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderHasAttributes
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderHasAttributes PROC			; COMDAT

; 3502 : xmlTextReaderHasAttributes(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlTextRea

; 3503 :     xmlNodePtr node;
; 3504 :     if (reader == NULL)
; 3505 : 	return(-1);

	or	eax, -1

; 3518 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 3506 :     if (reader->node == NULL)

	mov	ecx, DWORD PTR [eax+64]
	test	ecx, ecx
	je	SHORT $LN6@xmlTextRea

; 3507 : 	return(0);
; 3508 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [eax+68]
	test	eax, eax
	cmovne	ecx, eax

; 3509 : 	node = reader->curnode;
; 3510 :     else
; 3511 : 	node = reader->node;
; 3512 : 
; 3513 :     if ((node->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN6@xmlTextRea
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN7@xmlTextRea
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN6@xmlTextRea
$LN7@xmlTextRea:

; 3514 : 	((node->properties != NULL) || (node->nsDef != NULL)))
; 3515 : 	return(1);

	mov	eax, 1

; 3518 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 3516 :     /* TODO: handle the xmlDecl */
; 3517 :     return(0);

	xor	eax, eax

; 3518 : }

	pop	ebp
	ret	0
_xmlTextReaderHasAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderDepth
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderDepth PROC				; COMDAT

; 3478 : xmlTextReaderDepth(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _reader$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlTextRea

; 3479 :     if (reader == NULL)
; 3480 : 	return(-1);

	or	eax, -1

; 3491 : }

	pop	ebp
	ret	0
$LN2@xmlTextRea:

; 3481 :     if (reader->node == NULL)

	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN3@xmlTextRea

; 3482 : 	return(0);

	xor	eax, eax

; 3491 : }

	pop	ebp
	ret	0
$LN3@xmlTextRea:

; 3483 : 
; 3484 :     if (reader->curnode != NULL) {

	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	je	SHORT $LN4@xmlTextRea

; 3485 : 	if ((reader->curnode->type == XML_ATTRIBUTE_NODE) ||

	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, 2
	je	SHORT $LN6@xmlTextRea
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN6@xmlTextRea

; 3488 : 	return(reader->depth + 2);

	mov	eax, DWORD PTR [eax+72]
	add	eax, 2

; 3491 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 3486 : 	    (reader->curnode->type == XML_NAMESPACE_DECL))
; 3487 : 	    return(reader->depth + 1);

	mov	eax, DWORD PTR [eax+72]
	inc	eax

; 3491 : }

	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 3489 :     }
; 3490 :     return(reader->depth);

	mov	eax, DWORD PTR [eax+72]

; 3491 : }

	pop	ebp
	ret	0
_xmlTextReaderDepth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderAttributeCount
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderAttributeCount PROC			; COMDAT

; 2965 : xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@xmlTextRea

; 2966 :     int ret;
; 2967 :     xmlAttrPtr attr;
; 2968 :     xmlNsPtr ns;
; 2969 :     xmlNodePtr node;
; 2970 : 
; 2971 :     if (reader == NULL)
; 2972 : 	return(-1);

	or	eax, -1

; 2996 :     }
; 2997 :     return(ret);
; 2998 : }

	pop	ebp
	ret	0
$LN6@xmlTextRea:

; 2973 :     if (reader->node == NULL)

	mov	edx, DWORD PTR [ecx+64]
	test	edx, edx
	je	SHORT $LN12@xmlTextRea

; 2974 : 	return(0);
; 2975 : 
; 2976 :     if (reader->curnode != NULL)

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	cmovne	edx, eax

; 2977 : 	node = reader->curnode;
; 2978 :     else
; 2979 : 	node = reader->node;
; 2980 : 
; 2981 :     if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN12@xmlTextRea

; 2982 : 	return(0);
; 2983 :     if ((reader->state == XML_TEXTREADER_END) ||

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, 2
	je	SHORT $LN12@xmlTextRea
	cmp	eax, 4
	je	SHORT $LN12@xmlTextRea

; 2986 :     ret = 0;
; 2987 :     attr = node->properties;

	mov	ecx, DWORD PTR [edx+44]
	xor	eax, eax

; 2988 :     while (attr != NULL) {

	test	ecx, ecx
	je	SHORT $LN3@xmlTextRea
$LL2@xmlTextRea:

; 2989 : 	ret++;
; 2990 : 	attr = attr->next;

	mov	ecx, DWORD PTR [ecx+24]
	inc	eax
	test	ecx, ecx
	jne	SHORT $LL2@xmlTextRea
$LN3@xmlTextRea:

; 2991 :     }
; 2992 :     ns = node->nsDef;

	mov	ecx, DWORD PTR [edx+48]

; 2993 :     while (ns != NULL) {

	test	ecx, ecx
	je	SHORT $LN1@xmlTextRea
$LL4@xmlTextRea:

; 2994 : 	ret++;
; 2995 : 	ns = ns->next;

	mov	ecx, DWORD PTR [ecx]
	inc	eax
	test	ecx, ecx
	jne	SHORT $LL4@xmlTextRea

; 2996 :     }
; 2997 :     return(ret);
; 2998 : }

	pop	ebp
	ret	0
$LN12@xmlTextRea:

; 2984 : 	(reader->state == XML_TEXTREADER_BACKTRACK))
; 2985 : 	return(0);

	xor	eax, eax
$LN1@xmlTextRea:

; 2996 :     }
; 2997 :     return(ret);
; 2998 : }

	pop	ebp
	ret	0
_xmlTextReaderAttributeCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadAttributeValue
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderReadAttributeValue PROC			; COMDAT

; 2890 : xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN16@xmlTextRea

; 2891 :     if (reader == NULL)
; 2892 : 	return(-1);
; 2893 :     if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN16@xmlTextRea

; 2895 :     if (reader->curnode == NULL)

	push	edi
	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	je	$LN15@xmlTextRea

; 2896 : 	return(0);
; 2897 :     if (reader->curnode->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, 2
	jne	SHORT $LN5@xmlTextRea

; 2898 : 	if (reader->curnode->children == NULL)

	mov	eax, DWORD PTR [edi+12]

; 2899 : 	    return(0);
; 2900 : 	reader->curnode = reader->curnode->children;

	jmp	SHORT $LN19@xmlTextRea
$LN5@xmlTextRea:

; 2901 :     } else if (reader->curnode->type == XML_NAMESPACE_DECL) {

	cmp	ecx, 18					; 00000012H
	jne	SHORT $LN8@xmlTextRea

; 2902 : 	xmlNsPtr ns = (xmlNsPtr) reader->curnode;
; 2903 : 
; 2904 : 	if (reader->faketext == NULL) {

	mov	edx, DWORD PTR [esi+76]
	test	edx, edx
	jne	SHORT $LN10@xmlTextRea

; 2905 : 	    reader->faketext = xmlNewDocText(reader->node->doc,

	push	DWORD PTR [edi+8]
	push	DWORD PTR [eax+32]
	call	_xmlNewDocText
	add	esp, 8
	mov	DWORD PTR [esi+76], eax

; 2918 : 	reader->curnode = reader->curnode->next;
; 2919 :     }
; 2920 :     return(1);

	mov	DWORD PTR [esi+68], eax
	mov	eax, 1
	pop	edi
	pop	esi

; 2921 : }

	pop	ebp
	ret	0
$LN10@xmlTextRea:

; 2906 : 		                             ns->href);
; 2907 : 	} else {
; 2908 :             if ((reader->faketext->content != NULL) &&

	mov	ecx, DWORD PTR [edx+40]
	test	ecx, ecx
	je	SHORT $LN12@xmlTextRea
	lea	eax, DWORD PTR [edx+44]
	cmp	ecx, eax
	je	SHORT $LN12@xmlTextRea

; 2909 : 	        (reader->faketext->content !=
; 2910 : 		 (xmlChar *) &(reader->faketext->properties)))
; 2911 : 		xmlFree(reader->faketext->content);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlTextRea:

; 2912 : 	    reader->faketext->content = xmlStrdup(ns->href);

	push	DWORD PTR [edi+8]
	call	_xmlStrdup
	mov	ecx, DWORD PTR [esi+76]
	add	esp, 4
	mov	DWORD PTR [ecx+40], eax

; 2913 : 	}
; 2914 : 	reader->curnode = reader->faketext;

	mov	eax, DWORD PTR [esi+76]

; 2918 : 	reader->curnode = reader->curnode->next;
; 2919 :     }
; 2920 :     return(1);

	mov	DWORD PTR [esi+68], eax
	mov	eax, 1
	pop	edi
	pop	esi

; 2921 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 2915 :     } else {
; 2916 : 	if (reader->curnode->next == NULL)

	mov	eax, DWORD PTR [edi+24]
$LN19@xmlTextRea:

; 2918 : 	reader->curnode = reader->curnode->next;
; 2919 :     }
; 2920 :     return(1);

	test	eax, eax
	je	SHORT $LN15@xmlTextRea
	mov	DWORD PTR [esi+68], eax
	mov	eax, 1
	pop	edi
	pop	esi

; 2921 : }

	pop	ebp
	ret	0
$LN15@xmlTextRea:
	pop	edi

; 2917 : 	    return(0);

	xor	eax, eax
	pop	esi

; 2921 : }

	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 2894 : 	return(-1);

	or	eax, -1
	pop	esi

; 2921 : }

	pop	ebp
	ret	0
_xmlTextReaderReadAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadString
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlTextReaderReadString PROC				; COMDAT

; 1797 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _reader$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlTextRea

; 1798 :     xmlNodePtr node;
; 1799 : 
; 1800 :     if ((reader == NULL) || (reader->node == NULL))

	mov	esi, DWORD PTR [ecx+64]
	test	esi, esi
	je	SHORT $LN5@xmlTextRea

; 1802 : 
; 1803 :     node = (reader->curnode != NULL) ? reader->curnode : reader->node;

	mov	eax, DWORD PTR [ecx+68]
	test	eax, eax
	cmovne	esi, eax

; 1804 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	sub	eax, 1
	je	SHORT $LN8@xmlTextRea
	sub	eax, 1
	je	SHORT $LN10@xmlTextRea
	sub	eax, 1
	jne	SHORT $LN5@xmlTextRea

; 1805 :     case XML_TEXT_NODE:
; 1806 :        if (node->content != NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN5@xmlTextRea
	pop	esi

; 1807 :            return(xmlStrdup(node->content));

	mov	DWORD PTR _reader$[ebp], eax

; 1816 : 	break;
; 1817 :     default:
; 1818 :        break;
; 1819 :     }
; 1820 :     return(NULL);
; 1821 : }

	pop	ebp

; 1807 :            return(xmlStrdup(node->content));

	jmp	_xmlStrdup
$LN10@xmlTextRea:

; 1812 : 	}
; 1813 : 	break;
; 1814 :     case XML_ATTRIBUTE_NODE:
; 1815 : 	TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1815					; 00000717H
	push	OFFSET ??_C@_0GL@PIJMIJNC@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN5@xmlTextRea:

; 1801 :        return(NULL);

	xor	eax, eax
	pop	esi

; 1816 : 	break;
; 1817 :     default:
; 1818 :        break;
; 1819 :     }
; 1820 :     return(NULL);
; 1821 : }

	pop	ebp
	ret	0
$LN8@xmlTextRea:

; 1808 :        break;
; 1809 :     case XML_ELEMENT_NODE:
; 1810 : 	if (xmlTextReaderDoExpand(reader) != -1) {

	push	ecx
	call	_xmlTextReaderDoExpand
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN5@xmlTextRea

; 1811 : 	    return xmlTextReaderCollectSiblings(node->children);

	push	DWORD PTR [esi+12]
	call	_xmlTextReaderCollectSiblings
	add	esp, 4
	pop	esi

; 1816 : 	break;
; 1817 :     default:
; 1818 :        break;
; 1819 :     }
; 1820 :     return(NULL);
; 1821 : }

	pop	ebp
	ret	0
_xmlTextReaderReadString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadOuterXml
_TEXT	SEGMENT
_doc$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderReadOuterXml PROC				; COMDAT

; 1752 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _reader$[ebp]
	mov	esi, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR _doc$1$[ebp], ecx

; 1647 :     if ((reader == NULL) || (reader->node == NULL))

	test	esi, esi
	je	$LN14@xmlTextRea

; 1648 :         return(NULL);
; 1649 :     if (reader->doc != NULL)

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN10@xmlTextRea

; 1650 :         return(reader->node);

	mov	eax, esi
	jmp	SHORT $LN7@xmlTextRea
$LN10@xmlTextRea:

; 1651 :     if (reader->ctxt == NULL)

	cmp	DWORD PTR [edi+20], 0
	je	$LN14@xmlTextRea

; 1652 :         return(NULL);
; 1653 :     if (xmlTextReaderDoExpand(reader) < 0)

	push	edi
	call	_xmlTextReaderDoExpand
	add	esp, 4
	test	eax, eax
	js	SHORT $LN14@xmlTextRea

; 1654 :         return(NULL);
; 1655 :     return(reader->node);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR _doc$1$[ebp]
$LN7@xmlTextRea:

; 1753 :     xmlChar *resbuf;
; 1754 :     xmlNodePtr node;
; 1755 :     xmlBufferPtr buff;
; 1756 :     xmlDocPtr doc;
; 1757 : 
; 1758 :     node = reader->node;
; 1759 :     doc = node->doc;
; 1760 :     if (xmlTextReaderExpand(reader) == NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlTextRea

; 1762 :     }
; 1763 :     /* XXX: Why is the node copied? */
; 1764 : 	if (node->type == XML_DTD_NODE) {

	cmp	DWORD PTR [esi+4], 14			; 0000000eH
	push	ebx
	jne	SHORT $LN3@xmlTextRea

; 1765 : 		node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);

	push	esi
	call	_xmlCopyDtd
	add	esp, 4

; 1766 : 	} else {

	jmp	SHORT $LN16@xmlTextRea
$LN3@xmlTextRea:

; 1767 : 		node = xmlDocCopyNode(node, doc, 1);

	push	1
	push	ecx
	push	esi
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
$LN16@xmlTextRea:

; 1768 : 	}
; 1769 :     buff = xmlBufferCreate();

	mov	ebx, eax
	call	_xmlBufferCreate

; 1770 :     if (xmlNodeDump(buff, doc, node, 0, 0) == -1) {

	push	0
	push	0
	push	ebx
	push	DWORD PTR _doc$1$[ebp]
	mov	edi, eax
	push	edi
	call	_xmlNodeDump
	add	esp, 20					; 00000014H
	push	ebx
	cmp	eax, -1
	jne	SHORT $LN5@xmlTextRea

; 1771 :         xmlFreeNode(node);

	call	_xmlFreeNode

; 1772 :         xmlBufferFree(buff);

	push	edi
	call	_xmlBufferFree
	add	esp, 8

; 1773 :         return NULL;

	xor	eax, eax
	pop	ebx
	pop	edi

; 1782 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlTextRea:

; 1774 :     }
; 1775 : 
; 1776 :     resbuf = buff->content;

	mov	esi, DWORD PTR [edi]

; 1777 :     buff->content = NULL;

	mov	DWORD PTR [edi], 0

; 1778 : 
; 1779 :     xmlFreeNode(node);

	call	_xmlFreeNode

; 1780 :     xmlBufferFree(buff);

	push	edi
	call	_xmlBufferFree
	add	esp, 8

; 1781 :     return resbuf;

	mov	eax, esi
	pop	ebx
	pop	edi

; 1782 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlTextRea:
	pop	edi

; 1761 :         return NULL;

	xor	eax, eax

; 1782 : }

	pop	esi
	pop	ebp
	ret	0
_xmlTextReaderReadOuterXml ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderReadInnerXml
_TEXT	SEGMENT
_doc$1$ = -4						; size = 4
_buff$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderReadInnerXml PROC				; COMDAT

; 1705 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4

; 1647 :     if ((reader == NULL) || (reader->node == NULL))

	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN21@xmlTextRea
	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN21@xmlTextRea

; 1648 :         return(NULL);
; 1649 :     if (reader->doc != NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN24@xmlTextRea

; 1650 :         return(reader->node);
; 1651 :     if (reader->ctxt == NULL)

	cmp	DWORD PTR [esi+20], 0
	je	$LN21@xmlTextRea

; 1652 :         return(NULL);
; 1653 :     if (xmlTextReaderDoExpand(reader) < 0)

	push	esi
	call	_xmlTextReaderDoExpand
	add	esp, 4
	test	eax, eax
	js	$LN21@xmlTextRea

; 1654 :         return(NULL);
; 1655 :     return(reader->node);

	mov	eax, DWORD PTR [esi+64]
$LN24@xmlTextRea:

; 1706 :     xmlChar *resbuf;
; 1707 :     xmlNodePtr node, cur_node;
; 1708 :     xmlBufferPtr buff, buff2;
; 1709 :     xmlDocPtr doc;
; 1710 : 
; 1711 :     if (xmlTextReaderExpand(reader) == NULL) {

	mov	ecx, eax
	test	ecx, ecx
	je	$LN21@xmlTextRea

; 1713 :     }
; 1714 :     doc = reader->node->doc;

	push	ebx
	mov	ebx, DWORD PTR [eax+32]
	push	edi
	mov	DWORD PTR _doc$1$[ebp], ebx

; 1715 :     buff = xmlBufferCreate();

	call	_xmlBufferCreate

; 1716 :     for (cur_node = reader->node->children; cur_node != NULL;

	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR _buff$1$[ebp], eax
	mov	esi, DWORD PTR [ecx+12]
	test	esi, esi
	je	SHORT $LN3@xmlTextRea
	npad	3
$LL4@xmlTextRea:

; 1717 :          cur_node = cur_node->next) {
; 1718 :         /* XXX: Why is the node copied? */
; 1719 :         node = xmlDocCopyNode(cur_node, doc, 1);

	push	1
	push	ebx
	push	esi
	call	_xmlDocCopyNode
	mov	ebx, eax

; 1720 :         buff2 = xmlBufferCreate();

	call	_xmlBufferCreate

; 1721 :         if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {

	push	0
	push	0
	push	ebx
	push	DWORD PTR _doc$1$[ebp]
	mov	edi, eax
	push	edi
	call	_xmlNodeDump
	add	esp, 32					; 00000020H
	cmp	eax, -1
	je	SHORT $LN16@xmlTextRea

; 1726 :         }
; 1727 :         xmlBufferCat(buff, buff2->content);

	push	DWORD PTR [edi]
	push	DWORD PTR _buff$1$[ebp]
	call	_xmlBufferCat

; 1728 :         xmlFreeNode(node);

	push	ebx
	call	_xmlFreeNode

; 1729 :         xmlBufferFree(buff2);

	push	edi
	call	_xmlBufferFree
	mov	esi, DWORD PTR [esi+24]
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR _doc$1$[ebp]
	test	esi, esi
	jne	SHORT $LL4@xmlTextRea

; 1721 :         if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {

	mov	eax, DWORD PTR _buff$1$[ebp]
$LN3@xmlTextRea:

; 1730 :     }
; 1731 :     resbuf = buff->content;

	mov	esi, DWORD PTR [eax]

; 1732 :     buff->content = NULL;
; 1733 : 
; 1734 :     xmlBufferFree(buff);

	push	eax
	mov	DWORD PTR [eax], 0
	call	_xmlBufferFree
	add	esp, 4

; 1735 :     return resbuf;

	mov	eax, esi
	pop	edi
	pop	ebx
	pop	esi

; 1736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlTextRea:

; 1722 :             xmlFreeNode(node);

	push	ebx
	call	_xmlFreeNode

; 1723 :             xmlBufferFree(buff2);

	push	edi
	call	_xmlBufferFree

; 1724 :             xmlBufferFree(buff);

	push	DWORD PTR _buff$1$[ebp]
	call	_xmlBufferFree
	add	esp, 12					; 0000000cH

; 1725 :             return NULL;

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 1736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlTextRea:

; 1712 :         return NULL;

	xor	eax, eax
	pop	esi

; 1736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderReadInnerXml ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderRead
_TEXT	SEGMENT
_oldnode$1$ = -12					; size = 4
_olddepth$1$ = -8					; size = 4
_oldstate$1$ = -4					; size = 4
$T1 = 8							; size = 4
_reader$ = 8						; size = 4
_xmlTextReaderRead PROC					; COMDAT

; 1291 : xmlTextReaderRead(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	DWORD PTR _olddepth$1$[ebp], 0
	mov	DWORD PTR _oldstate$1$[ebp], 0
	mov	DWORD PTR _oldnode$1$[ebp], eax
	test	esi, esi
	je	$LN122@xmlTextRea

; 1292 :     int val, olddepth = 0;
; 1293 :     xmlTextReaderState oldstate = XML_TEXTREADER_START;
; 1294 :     xmlNodePtr oldnode = NULL;
; 1295 : 
; 1296 : 
; 1297 :     if (reader == NULL)
; 1298 : 	return(-1);
; 1299 :     reader->curnode = NULL;

	mov	edi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+68], eax

; 1300 :     if (reader->doc != NULL)

	test	edi, edi
	je	$LN11@xmlTextRea

; 1963 :     if (reader->state == XML_TEXTREADER_END)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 2
	je	$LN132@xmlTextRea

; 1968 :         if (reader->doc->children == NULL) {

	mov	eax, DWORD PTR [esi+64]
	npad	2
$next_node$134:

; 1964 :         return(0);
; 1965 : 
; 1966 : next_node:
; 1967 :     if (reader->node == NULL) {

	test	eax, eax
	jne	SHORT $LN74@xmlTextRea

; 1968 :         if (reader->doc->children == NULL) {

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN90@xmlTextRea

; 1969 :             reader->state = XML_TEXTREADER_END;
; 1970 :             return(0);
; 1971 :         }
; 1972 : 
; 1973 :         reader->node = reader->doc->children;

	mov	DWORD PTR [esi+64], eax

; 1974 :         reader->state = XML_TEXTREADER_START;

	xor	ecx, ecx
	mov	DWORD PTR [esi+16], 0

; 1975 :         goto found_node;

	jmp	$found_node$135
$LN74@xmlTextRea:

; 1976 :     }
; 1977 : 
; 1978 :     if ((reader->state != XML_TEXTREADER_BACKTRACK) &&
; 1979 :         (reader->node->type != XML_DTD_NODE) &&
; 1980 :         (reader->node->type != XML_XINCLUDE_START) &&

	cmp	ecx, 4
	je	SHORT $LN78@xmlTextRea
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN78@xmlTextRea
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN78@xmlTextRea
	cmp	ecx, 5
	je	SHORT $LN78@xmlTextRea

; 1981 : 	(reader->node->type != XML_ENTITY_REF_NODE)) {
; 1982 :         if (reader->node->children != NULL) {

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $LN77@xmlTextRea

; 1983 :             reader->node = reader->node->children;
; 1984 :             reader->depth++;

	inc	DWORD PTR [esi+72]

; 1985 :             reader->state = XML_TEXTREADER_START;

	mov	eax, edx
	mov	DWORD PTR [esi+64], edx
	xor	ecx, ecx
	mov	DWORD PTR [esi+16], 0

; 1986 :             goto found_node;

	jmp	SHORT $found_node$135
$LN77@xmlTextRea:

; 1987 :         }
; 1988 : 
; 1989 :         if (reader->node->type == XML_ATTRIBUTE_NODE) {

	cmp	ecx, 2
	jne	SHORT $LN78@xmlTextRea

; 1990 :             reader->state = XML_TEXTREADER_BACKTRACK;

	mov	DWORD PTR [esi+16], 4
	mov	ecx, 4

; 1991 :             goto found_node;

	jmp	SHORT $found_node$135
$LN78@xmlTextRea:

; 1992 :         }
; 1993 :     }
; 1994 : 
; 1995 :     if (reader->node->next != NULL) {

	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN79@xmlTextRea

; 1996 :         reader->node = reader->node->next;

	mov	DWORD PTR [esi+64], edx

; 1997 :         reader->state = XML_TEXTREADER_START;

	xor	ecx, ecx
	mov	DWORD PTR [esi+16], 0
	mov	eax, edx

; 1998 :         goto found_node;

	jmp	SHORT $found_node$135
$LN79@xmlTextRea:

; 1999 :     }
; 2000 : 
; 2001 :     if (reader->node->parent != NULL) {

	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN80@xmlTextRea

; 2002 :         if ((reader->node->parent->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, ecx
	cmp	edx, 9
	je	SHORT $LN90@xmlTextRea
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN90@xmlTextRea

; 2003 : 	    (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {
; 2004 :             reader->state = XML_TEXTREADER_END;
; 2005 :             return(0);
; 2006 :         }
; 2007 : 
; 2008 :         reader->node = reader->node->parent;
; 2009 :         reader->depth--;

	dec	DWORD PTR [esi+72]
	mov	DWORD PTR [esi+64], ecx

; 2010 :         reader->state = XML_TEXTREADER_BACKTRACK;

	mov	ecx, 4
	mov	DWORD PTR [esi+16], 4

; 2011 :         goto found_node;

	jmp	SHORT $found_node$135
$LN80@xmlTextRea:

; 2012 :     }
; 2013 : 
; 2014 :     reader->state = XML_TEXTREADER_END;

	mov	DWORD PTR [esi+16], 2
	mov	ecx, 2
$found_node$135:

; 2015 : 
; 2016 : found_node:
; 2017 :     if ((reader->node->type == XML_XINCLUDE_START) ||

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 19					; 00000013H
	je	$next_node$134
	cmp	edx, 20					; 00000014H
	jne	$LN70@xmlTextRea

; 2018 :         (reader->node->type == XML_XINCLUDE_END))
; 2019 : 	goto next_node;

	jmp	$next_node$134
$LN90@xmlTextRea:
	pop	edi

; 1617 :     return(0);
; 1618 : }

	mov	DWORD PTR [esi+16], 2
	xor	eax, eax
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlTextRea:

; 1301 :         return(xmlTextReaderReadTree(reader));
; 1302 :     if (reader->ctxt == NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN122@xmlTextRea

; 1303 : 	return(-1);
; 1304 : 
; 1305 : #ifdef DEBUG_READER
; 1306 :     fprintf(stderr, "\nREAD ");
; 1307 :     DUMP_READER
; 1308 : #endif
; 1309 :     if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {

	cmp	DWORD PTR [esi], 0
	jne	$LN13@xmlTextRea

; 1310 : 	reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;

	mov	DWORD PTR [esi], 1
$LL4@xmlTextRea:

; 1311 : 	/*
; 1312 : 	 * Initial state
; 1313 : 	 */
; 1314 : 	do {
; 1315 : 	    val = xmlTextReaderPushData(reader);

	push	esi
	call	_xmlTextReaderPushData
	add	esp, 4

; 1316 : 		if (val < 0){

	test	eax, eax
	js	$LN92@xmlTextRea

; 1318 : 			reader->state = XML_TEXTREADER_ERROR;
; 1319 : 		return(-1);
; 1320 : 		}
; 1321 : 	} while ((reader->ctxt->node == NULL) &&

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN17@xmlTextRea
	cmp	DWORD PTR [esi], 3
	lea	edi, DWORD PTR [esi+16]
	mov	DWORD PTR $T1[ebp], edi
	je	SHORT $LN120@xmlTextRea
	cmp	DWORD PTR [edi], 5
	jne	SHORT $LL4@xmlTextRea
	jmp	SHORT $LN118@xmlTextRea
$LN120@xmlTextRea:
	mov	DWORD PTR $T1[ebp], edi
$LN118@xmlTextRea:

; 1322 : 		 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&
; 1323 : 		  (reader->state != XML_TEXTREADER_DONE)));
; 1324 : 	if (reader->ctxt->node == NULL) {
; 1325 : 	    if (reader->ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN110@xmlTextRea

; 1326 : 		reader->node = reader->ctxt->myDoc->children;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+64], eax
	jmp	SHORT $LN19@xmlTextRea
$LN110@xmlTextRea:
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR $T1[ebp], edi
$LN19@xmlTextRea:

; 1327 : 	    }
; 1328 : 	    if (reader->node == NULL){

	test	eax, eax
	jne	SHORT $LN18@xmlTextRea

; 1329 : 			reader->mode = XML_TEXTREADER_MODE_ERROR;
; 1330 : 			reader->state = XML_TEXTREADER_ERROR;

	mov	DWORD PTR [edi], 6

; 1617 :     return(0);
; 1618 : }

	or	eax, -1
	pop	edi
	mov	DWORD PTR [esi], 2
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlTextRea:

; 1331 : 		return(-1);
; 1332 : 		}
; 1333 : 	    reader->state = XML_TEXTREADER_ELEMENT;
; 1334 : 	} else {
; 1335 : 	    if (reader->ctxt->myDoc != NULL) {

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN111@xmlTextRea

; 1336 : 		reader->node = reader->ctxt->myDoc->children;

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+64], ecx
	jmp	SHORT $LN21@xmlTextRea
$LN111@xmlTextRea:
	mov	ecx, DWORD PTR [esi+64]
$LN21@xmlTextRea:

; 1337 : 	    }
; 1338 : 	    if (reader->node == NULL)

	test	ecx, ecx
	jne	SHORT $LN22@xmlTextRea

; 1339 : 		reader->node = reader->ctxt->nodeTab[0];

	mov	eax, DWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+64], eax
$LN22@xmlTextRea:

; 1340 : 	    reader->state = XML_TEXTREADER_ELEMENT;

	lea	edi, DWORD PTR [esi+16]
	mov	DWORD PTR $T1[ebp], edi
$LN18@xmlTextRea:

; 1341 : 	}
; 1342 : 	reader->depth = 0;

	mov	DWORD PTR [edi], 1

; 1343 : 	reader->ctxt->parseMode = XML_PARSE_READER;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [eax+436], 5

; 1344 : 	goto node_found;

	jmp	$node_found$136
$LN92@xmlTextRea:
	pop	edi

; 1317 : 			reader->mode = XML_TEXTREADER_MODE_ERROR;

	mov	DWORD PTR [esi], 2

; 1617 :     return(0);
; 1618 : }

	or	eax, -1
	mov	DWORD PTR [esi+16], 6
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlTextRea:

; 1345 :     }
; 1346 :     oldstate = reader->state;
; 1347 :     olddepth = reader->ctxt->nodeNr;

	mov	edx, DWORD PTR [eax+56]
	lea	edi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edi]

; 1348 :     oldnode = reader->node;

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR $T1[ebp], edi
	mov	DWORD PTR _oldstate$1$[ebp], ecx
	mov	DWORD PTR _olddepth$1$[ebp], edx
	mov	DWORD PTR _oldnode$1$[ebp], eax
$get_next_node$137:

; 1349 : 
; 1350 : get_next_node:
; 1351 :     if (reader->node == NULL) {

	test	eax, eax
	je	$LN95@xmlTextRea
	npad	4
$LL5@xmlTextRea:

; 1353 : 	    return(0);
; 1354 : 	else
; 1355 : 	    return(-1);
; 1356 :     }
; 1357 : 
; 1358 :     /*
; 1359 :      * If we are not backtracking on ancestors or examined nodes,
; 1360 :      * that the parser didn't finished or that we arent at the end
; 1361 :      * of stream, continue processing.
; 1362 :      */
; 1363 :     while ((reader->node != NULL) && (reader->node->next == NULL) &&
; 1364 : 	   (reader->ctxt->nodeNr == olddepth) &&
; 1365 :            ((oldstate == XML_TEXTREADER_BACKTRACK) ||
; 1366 :             (reader->node->children == NULL) ||
; 1367 : 	    (reader->node->type == XML_ENTITY_REF_NODE) ||
; 1368 : 	    ((reader->node->children != NULL) &&
; 1369 : 	     (reader->node->children->type == XML_TEXT_NODE) &&
; 1370 : 	     (reader->node->children->next == NULL)) ||
; 1371 : 	    (reader->node->type == XML_DTD_NODE) ||
; 1372 : 	    (reader->node->type == XML_DOCUMENT_NODE) ||
; 1373 : 	    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&
; 1374 : 	   ((reader->ctxt->node == NULL) ||
; 1375 : 	    (reader->ctxt->node == reader->node) ||
; 1376 : 	    (reader->ctxt->node == reader->node->parent)) &&

	mov	ebx, DWORD PTR [eax+24]
	test	ebx, ebx
	jne	SHORT $LN6@xmlTextRea
	mov	edi, DWORD PTR [esi+20]
	cmp	DWORD PTR [edi+56], edx
	jne	SHORT $LN6@xmlTextRea
	cmp	ecx, 4
	je	SHORT $LN26@xmlTextRea
	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $LN26@xmlTextRea
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 5
	je	SHORT $LN26@xmlTextRea
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN27@xmlTextRea
	cmp	DWORD PTR [edx+24], ebx
	je	SHORT $LN26@xmlTextRea
$LN27@xmlTextRea:
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN26@xmlTextRea
	cmp	ecx, 9
	je	SHORT $LN26@xmlTextRea
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN131@xmlTextRea
$LN26@xmlTextRea:
	mov	ecx, DWORD PTR [edi+52]
	test	ecx, ecx
	je	SHORT $LN28@xmlTextRea
	cmp	ecx, eax
	je	SHORT $LN28@xmlTextRea
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN131@xmlTextRea
$LN28@xmlTextRea:
	cmp	DWORD PTR [edi+172], -1
	je	SHORT $LN131@xmlTextRea

; 1377 : 	   (reader->ctxt->instate != XML_PARSER_EOF)) {
; 1378 : 	val = xmlTextReaderPushData(reader);

	push	esi
	call	_xmlTextReaderPushData
	add	esp, 4

; 1379 : 	if (val < 0){

	test	eax, eax
	js	$LN93@xmlTextRea

; 1382 : 	    return(-1);
; 1383 : 	}
; 1384 : 	if (reader->node == NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$node_end$138

; 1353 : 	    return(0);
; 1354 : 	else
; 1355 : 	    return(-1);
; 1356 :     }
; 1357 : 
; 1358 :     /*
; 1359 :      * If we are not backtracking on ancestors or examined nodes,
; 1360 :      * that the parser didn't finished or that we arent at the end
; 1361 :      * of stream, continue processing.
; 1362 :      */
; 1363 :     while ((reader->node != NULL) && (reader->node->next == NULL) &&
; 1364 : 	   (reader->ctxt->nodeNr == olddepth) &&
; 1365 :            ((oldstate == XML_TEXTREADER_BACKTRACK) ||
; 1366 :             (reader->node->children == NULL) ||
; 1367 : 	    (reader->node->type == XML_ENTITY_REF_NODE) ||
; 1368 : 	    ((reader->node->children != NULL) &&
; 1369 : 	     (reader->node->children->type == XML_TEXT_NODE) &&
; 1370 : 	     (reader->node->children->next == NULL)) ||
; 1371 : 	    (reader->node->type == XML_DTD_NODE) ||
; 1372 : 	    (reader->node->type == XML_DOCUMENT_NODE) ||
; 1373 : 	    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&
; 1374 : 	   ((reader->ctxt->node == NULL) ||
; 1375 : 	    (reader->ctxt->node == reader->node) ||
; 1376 : 	    (reader->ctxt->node == reader->node->parent)) &&

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
	mov	edx, DWORD PTR _olddepth$1$[ebp]
	jmp	SHORT $LL5@xmlTextRea
$LN131@xmlTextRea:

; 1385 : 	    goto node_end;
; 1386 :     }
; 1387 :     if (oldstate != XML_TEXTREADER_BACKTRACK) {

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
$LN6@xmlTextRea:
	cmp	ecx, 4
	je	SHORT $LN32@xmlTextRea

; 1388 : 	if ((reader->node->children != NULL) &&
; 1389 : 	    (reader->node->type != XML_ENTITY_REF_NODE) &&
; 1390 : 	    (reader->node->type != XML_XINCLUDE_START) &&

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $LN32@xmlTextRea
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 5
	je	SHORT $LN128@xmlTextRea
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN128@xmlTextRea
	cmp	ecx, 14					; 0000000eH
	je	SHORT $LN128@xmlTextRea

; 1391 : 	    (reader->node->type != XML_DTD_NODE)) {
; 1392 : 	    reader->node = reader->node->children;
; 1393 : 	    reader->depth++;
; 1394 : 	    reader->state = XML_TEXTREADER_ELEMENT;

	mov	eax, DWORD PTR $T1[ebp]
	inc	DWORD PTR [esi+72]
	mov	DWORD PTR [esi+64], edx
	mov	DWORD PTR [eax], 1

; 1395 : 	    goto node_found;

	jmp	$node_found$136
$LN128@xmlTextRea:

; 1396 : 	}
; 1397 :     }
; 1398 :     if (reader->node->next != NULL) {

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
$LN32@xmlTextRea:
	test	ebx, ebx
	je	$LN33@xmlTextRea

; 1399 : 	if ((oldstate == XML_TEXTREADER_ELEMENT) &&
; 1400 :             (reader->node->type == XML_ELEMENT_NODE) &&
; 1401 : 	    (reader->node->children == NULL) &&
; 1402 : 	    ((reader->node->extra & NODE_IS_EMPTY) == 0)
; 1403 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1404 : 	    && (reader->in_xinclude <= 0)

	cmp	ecx, 1
	jne	SHORT $LN34@xmlTextRea
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN34@xmlTextRea
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN34@xmlTextRea
	test	BYTE PTR [eax+58], cl
	jne	SHORT $LN34@xmlTextRea
	cmp	DWORD PTR [esi+168], 0
	jg	SHORT $LN34@xmlTextRea

; 1405 : #endif
; 1406 : 	    ) {
; 1407 : 	    reader->state = XML_TEXTREADER_END;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], 2

; 1408 : 	    goto node_found;

	jmp	$node_found$136
$LN34@xmlTextRea:

; 1409 : 	}
; 1410 : #ifdef LIBXML_REGEXP_ENABLED
; 1411 : 	if ((reader->validate) &&

	cmp	DWORD PTR [esi+8], 0
	mov	ecx, eax
	je	SHORT $LN35@xmlTextRea
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN35@xmlTextRea

; 1412 : 	    (reader->node->type == XML_ELEMENT_NODE))
; 1413 : 	    xmlTextReaderValidatePop(reader);

	push	esi
	call	_xmlTextReaderValidatePop
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 4
$LN35@xmlTextRea:

; 1414 : #endif /* LIBXML_REGEXP_ENABLED */
; 1415 :         if ((reader->preserves > 0) &&

	mov	eax, DWORD PTR [esi+184]
	mov	edx, eax
	test	eax, eax
	jle	SHORT $LN36@xmlTextRea
	test	BYTE PTR [ecx+58], 4
	je	SHORT $LN36@xmlTextRea

; 1416 : 	    (reader->node->extra & NODE_IS_SPRESERVED))
; 1417 : 	    reader->preserves--;

	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+184], edx
$LN36@xmlTextRea:

; 1418 : 	reader->node = reader->node->next;
; 1419 : 	reader->state = XML_TEXTREADER_ELEMENT;

	mov	eax, DWORD PTR $T1[ebp]
	mov	edi, DWORD PTR [ecx+24]
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [eax], 1

; 1420 : 
; 1421 : 	/*
; 1422 : 	 * Cleanup of the old node
; 1423 : 	 */
; 1424 : 	if ((reader->preserves == 0) &&
; 1425 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1426 : 	    (reader->in_xinclude == 0) &&
; 1427 : #endif
; 1428 : 	    (reader->entNr == 0) &&
; 1429 : 	    (reader->node->prev != NULL) &&

	test	edx, edx
	jne	$node_found$136
	cmp	DWORD PTR [esi+168], edx
	jne	$node_found$136
	cmp	DWORD PTR [esi+96], edx
	jne	$node_found$136
	mov	edi, DWORD PTR [edi+28]
	test	edi, edi
	je	$node_found$136
	cmp	DWORD PTR [edi+4], 14			; 0000000eH
	je	$node_found$136

; 1430 :             (reader->node->prev->type != XML_DTD_NODE)) {
; 1431 : 	    xmlNodePtr tmp = reader->node->prev;
; 1432 : 	    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {

	test	BYTE PTR [edi+58], 2
	jne	$node_found$136

; 1433 : 		xmlUnlinkNode(tmp);

	push	edi
	call	_xmlUnlinkNode

; 1434 : 		xmlTextReaderFreeNode(reader, tmp);

	push	edi
	push	esi
	call	_xmlTextReaderFreeNode
	add	esp, 12					; 0000000cH

; 1435 : 	    }
; 1436 : 	}
; 1437 : 
; 1438 : 	goto node_found;

	jmp	$node_found$136
$LN33@xmlTextRea:

; 1439 :     }
; 1440 :     if ((oldstate == XML_TEXTREADER_ELEMENT) &&
; 1441 : 	(reader->node->type == XML_ELEMENT_NODE) &&
; 1442 : 	(reader->node->children == NULL) &&

	cmp	ecx, 1
	jne	SHORT $LN39@xmlTextRea
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN39@xmlTextRea
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN39@xmlTextRea
	test	BYTE PTR [eax+58], cl
	jne	SHORT $LN39@xmlTextRea

; 1443 : 	((reader->node->extra & NODE_IS_EMPTY) == 0)) {;
; 1444 : 	reader->state = XML_TEXTREADER_END;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], 2

; 1445 : 	goto node_found;

	jmp	$node_found$136
$LN39@xmlTextRea:

; 1446 :     }
; 1447 : #ifdef LIBXML_REGEXP_ENABLED
; 1448 :     if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))

	cmp	DWORD PTR [esi+8], 0
	mov	ecx, eax
	je	SHORT $LN40@xmlTextRea
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN40@xmlTextRea

; 1449 : 	xmlTextReaderValidatePop(reader);

	push	esi
	call	_xmlTextReaderValidatePop
	mov	ecx, DWORD PTR [esi+64]
	add	esp, 4
$LN40@xmlTextRea:

; 1450 : #endif /* LIBXML_REGEXP_ENABLED */
; 1451 :     if ((reader->preserves > 0) &&

	mov	eax, DWORD PTR [esi+184]
	mov	edx, eax
	test	eax, eax
	jle	SHORT $LN41@xmlTextRea
	test	BYTE PTR [ecx+58], 4
	je	SHORT $LN41@xmlTextRea

; 1452 : 	(reader->node->extra & NODE_IS_SPRESERVED))
; 1453 : 	reader->preserves--;

	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+184], edx
$LN41@xmlTextRea:

; 1454 :     reader->node = reader->node->parent;

	mov	edi, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi+64], edi

; 1455 :     if ((reader->node == NULL) ||
; 1456 : 	(reader->node->type == XML_DOCUMENT_NODE) ||
; 1457 : #ifdef LIBXML_DOCB_ENABLED
; 1458 : 	(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||

	test	edi, edi
	je	$LN43@xmlTextRea
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	$LN43@xmlTextRea
	cmp	eax, 21					; 00000015H
	je	$LN43@xmlTextRea
	cmp	eax, 13					; 0000000dH
	je	$LN43@xmlTextRea

; 1482 : 	}
; 1483 : 
; 1484 : 	goto node_end;
; 1485 :     }
; 1486 :     if ((reader->preserves == 0) &&
; 1487 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1488 :         (reader->in_xinclude == 0) &&
; 1489 : #endif
; 1490 : 	(reader->entNr == 0) &&
; 1491 :         (reader->node->last != NULL) &&

	test	edx, edx
	jne	SHORT $LN47@xmlTextRea
	cmp	DWORD PTR [esi+168], edx
	jne	SHORT $LN47@xmlTextRea
	cmp	DWORD PTR [esi+96], edx
	jne	SHORT $LN47@xmlTextRea
	mov	edi, DWORD PTR [edi+16]
	test	edi, edi
	je	SHORT $LN47@xmlTextRea
	test	BYTE PTR [edi+58], 2
	jne	SHORT $LN47@xmlTextRea

; 1492 :         ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {
; 1493 : 	xmlNodePtr tmp = reader->node->last;
; 1494 : 	xmlUnlinkNode(tmp);

	push	edi
	call	_xmlUnlinkNode

; 1495 : 	xmlTextReaderFreeNode(reader, tmp);

	push	edi
	push	esi
	call	_xmlTextReaderFreeNode
	add	esp, 12					; 0000000cH
$LN47@xmlTextRea:

; 1496 :     }
; 1497 :     reader->depth--;
; 1498 :     reader->state = XML_TEXTREADER_BACKTRACK;

	mov	eax, DWORD PTR $T1[ebp]
	dec	DWORD PTR [esi+72]
	mov	DWORD PTR [eax], 4
$node_found$136:

; 1499 : 
; 1500 : node_found:
; 1501 :     DUMP_READER
; 1502 : 
; 1503 :     /*
; 1504 :      * If we are in the middle of a piece of CDATA make sure it's finished
; 1505 :      */
; 1506 :     if ((reader->node != NULL) &&
; 1507 :         (reader->node->next == NULL) &&

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN50@xmlTextRea
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN50@xmlTextRea
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 3
	je	SHORT $LN49@xmlTextRea
	cmp	eax, 4
	jne	SHORT $LN50@xmlTextRea
$LN49@xmlTextRea:

; 1508 :         ((reader->node->type == XML_TEXT_NODE) ||
; 1509 : 	 (reader->node->type == XML_CDATA_SECTION_NODE))) {
; 1510 :             if (xmlTextReaderExpand(reader) == NULL)

	push	esi
	call	_xmlTextReaderExpand
	add	esp, 4
	test	eax, eax
	je	$LN122@xmlTextRea
$LN50@xmlTextRea:

; 1511 : 	        return -1;
; 1512 :     }
; 1513 : 
; 1514 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1515 :     /*
; 1516 :      * Handle XInclude if asked for
; 1517 :      */
; 1518 :     if ((reader->xinclude) && (reader->node != NULL) &&
; 1519 : 	(reader->node->type == XML_ELEMENT_NODE) &&
; 1520 : 	(reader->node->ns != NULL) &&

	cmp	DWORD PTR [esi+156], 0
	je	$LN51@xmlTextRea
	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN51@xmlTextRea
	cmp	DWORD PTR [eax+4], 1
	jne	$LN51@xmlTextRea
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	$LN51@xmlTextRea
	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN52@xmlTextRea
	mov	eax, DWORD PTR [esi+64]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@xmlTextRea
$LN52@xmlTextRea:

; 1521 : 	((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||
; 1522 : 	 (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {
; 1523 : 	if (reader->xincctxt == NULL) {

	cmp	DWORD PTR [esi+164], 0
	jne	SHORT $LN53@xmlTextRea

; 1524 : 	    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);

	mov	eax, DWORD PTR [esi+20]
	push	DWORD PTR [eax+8]
	call	_xmlXIncludeNewContext

; 1525 : 	    xmlXIncludeSetFlags(reader->xincctxt,

	mov	ecx, DWORD PTR [esi+188]
	and	ecx, -32769				; ffff7fffH
	mov	DWORD PTR [esi+164], eax
	push	ecx
	push	eax
	call	_xmlXIncludeSetFlags
	add	esp, 12					; 0000000cH
$LN53@xmlTextRea:

; 1526 : 	                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));
; 1527 : 	}
; 1528 : 	/*
; 1529 : 	 * expand that node and process it
; 1530 : 	 */
; 1531 : 	if (xmlTextReaderExpand(reader) == NULL)

	push	esi
	call	_xmlTextReaderExpand
	add	esp, 4
	test	eax, eax
	je	$LN122@xmlTextRea

; 1532 : 	    return -1;
; 1533 : 	xmlXIncludeProcessNode(reader->xincctxt, reader->node);

	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+164]
	call	_xmlXIncludeProcessNode
	add	esp, 8
$LN51@xmlTextRea:

; 1534 :     }
; 1535 :     if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	$LN57@xmlTextRea
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 19					; 00000013H
	jne	SHORT $LN55@xmlTextRea

; 1536 :         reader->in_xinclude++;

	inc	DWORD PTR [esi+168]

; 1537 : 	goto get_next_node;

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
	mov	edx, DWORD PTR _olddepth$1$[ebp]
	jmp	$get_next_node$137
$LN55@xmlTextRea:

; 1538 :     }
; 1539 :     if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {

	cmp	ecx, 20					; 00000014H
	jne	SHORT $LN112@xmlTextRea

; 1540 :         reader->in_xinclude--;

	dec	DWORD PTR [esi+168]

; 1541 : 	goto get_next_node;

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
	mov	edx, DWORD PTR _olddepth$1$[ebp]
	jmp	$get_next_node$137
$LN112@xmlTextRea:

; 1542 :     }
; 1543 : #endif
; 1544 :     /*
; 1545 :      * Handle entities enter and exit when in entity replacement mode
; 1546 :      */
; 1547 :     if ((reader->node != NULL) &&
; 1548 : 	(reader->node->type == XML_ENTITY_REF_NODE) &&
; 1549 : 	(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {

	cmp	ecx, 5
	jne	SHORT $LN57@xmlTextRea
	mov	edx, DWORD PTR [esi+20]
	test	edx, edx
	je	SHORT $LN57@xmlTextRea
	cmp	DWORD PTR [edx+16], 1
	jne	SHORT $LN57@xmlTextRea

; 1550 : 	/*
; 1551 : 	 * Case where the underlying tree is not availble, lookup the entity
; 1552 : 	 * and walk it.
; 1553 : 	 */
; 1554 : 	if ((reader->node->children == NULL) && (reader->ctxt->sax != NULL) &&

	cmp	DWORD PTR [eax+12], 0
	mov	ecx, eax
	jne	SHORT $LN59@xmlTextRea
	mov	edi, DWORD PTR [edx]
	test	edi, edi
	je	SHORT $LN59@xmlTextRea
	mov	ebx, DWORD PTR [edi+20]
	test	ebx, ebx
	je	SHORT $LN59@xmlTextRea

; 1555 : 	    (reader->ctxt->sax->getEntity != NULL)) {
; 1556 : 	    reader->node->children = (xmlNodePtr)

	push	DWORD PTR [eax+8]
	mov	edi, DWORD PTR [esi+64]
	push	edx
	call	ebx
	mov	DWORD PTR [edi+12], eax
	add	esp, 8
	mov	ecx, DWORD PTR [esi+64]
$LN59@xmlTextRea:

; 1557 : 		reader->ctxt->sax->getEntity(reader->ctxt, reader->node->name);
; 1558 : 	}
; 1559 : 
; 1560 : 	if ((reader->node->children != NULL) &&
; 1561 : 	    (reader->node->children->type == XML_ENTITY_DECL) &&

	mov	eax, DWORD PTR [ecx+12]
	mov	edi, ecx
	test	eax, eax
	je	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [eax+4], 17			; 00000011H
	jne	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN61@xmlTextRea

; 1562 : 	    (reader->node->children->children != NULL)) {
; 1563 : 	    xmlTextReaderEntPush(reader, reader->node);

	push	ecx
	push	esi
	call	_xmlTextReaderEntPush

; 1564 : 	    reader->node = reader->node->children->children;

	mov	eax, DWORD PTR [esi+64]
	add	esp, 8
	mov	eax, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+64], edi

; 1565 : 	}
; 1566 : #ifdef LIBXML_REGEXP_ENABLED
; 1567 :     } else if ((reader->node != NULL) &&

	jmp	SHORT $LN61@xmlTextRea
$LN57@xmlTextRea:

; 1568 : 	       (reader->node->type == XML_ENTITY_REF_NODE) &&
; 1569 : 	       (reader->ctxt != NULL) && (reader->validate)) {

	mov	edi, eax
	test	eax, eax
	je	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [eax+4], 5
	jne	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN61@xmlTextRea
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN61@xmlTextRea

; 1570 : 	xmlTextReaderValidateEntity(reader);

	push	esi
	call	_xmlTextReaderValidateEntity
	mov	edi, DWORD PTR [esi+64]
	add	esp, 4
$LN61@xmlTextRea:

; 1571 : #endif /* LIBXML_REGEXP_ENABLED */
; 1572 :     }
; 1573 :     if ((reader->node != NULL) &&
; 1574 : 	(reader->node->type == XML_ENTITY_DECL) &&
; 1575 : 	(reader->ent != NULL) && (reader->ent->children == reader->node)) {

	test	edi, edi
	je	SHORT $LN62@xmlTextRea
	cmp	DWORD PTR [edi+4], 17			; 00000011H
	jne	SHORT $LN62@xmlTextRea
	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN62@xmlTextRea
	cmp	DWORD PTR [eax+12], edi
	jne	SHORT $LN62@xmlTextRea

; 1576 : 	reader->node = xmlTextReaderEntPop(reader);

	push	esi
	call	_xmlTextReaderEntPop

; 1577 : 	reader->depth++;
; 1578 :         goto get_next_node;

	mov	ecx, DWORD PTR _oldstate$1$[ebp]
	add	esp, 4
	inc	DWORD PTR [esi+72]
	mov	edx, DWORD PTR _olddepth$1$[ebp]
	mov	DWORD PTR [esi+64], eax
	jmp	$get_next_node$137
$LN93@xmlTextRea:

; 1380 : 		reader->mode = XML_TEXTREADER_MODE_ERROR;
; 1381 : 		reader->state = XML_TEXTREADER_ERROR;

	mov	eax, DWORD PTR $T1[ebp]
	pop	edi
	mov	DWORD PTR [esi], 2

; 1617 :     return(0);
; 1618 : }

	pop	esi
	mov	DWORD PTR [eax], 6
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@xmlTextRea:

; 1579 :     }
; 1580 : #ifdef LIBXML_REGEXP_ENABLED
; 1581 :     if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN125@xmlTextRea
	test	edi, edi
	je	SHORT $LN125@xmlTextRea

; 1582 : 	xmlNodePtr node = reader->node;
; 1583 : 
; 1584 : 	if ((node->type == XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	jne	SHORT $LN64@xmlTextRea
	mov	ecx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 2
	je	SHORT $LN66@xmlTextRea
	cmp	eax, 4
	je	SHORT $LN66@xmlTextRea

; 1585 :             ((reader->state != XML_TEXTREADER_END) &&
; 1586 : 	     (reader->state != XML_TEXTREADER_BACKTRACK))) {
; 1587 : 	    xmlTextReaderValidatePush(reader);

	push	esi
	call	_xmlTextReaderValidatePush
	add	esp, 4
	jmp	SHORT $LN125@xmlTextRea
$LN64@xmlTextRea:

; 1588 : 	} else if ((node->type == XML_TEXT_NODE) ||

	cmp	eax, 3
	je	SHORT $LN67@xmlTextRea
	cmp	eax, 4
	jne	SHORT $LN125@xmlTextRea
$LN67@xmlTextRea:

; 1589 : 		   (node->type == XML_CDATA_SECTION_NODE)) {
; 1590 :             xmlTextReaderValidateCData(reader, node->content,

	push	DWORD PTR [edi+40]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlTextReaderValidateCData
	add	esp, 16					; 00000010H
$LN125@xmlTextRea:

; 1591 : 	                               xmlStrlen(node->content));
; 1592 : 	}
; 1593 :     }
; 1594 : #endif /* LIBXML_REGEXP_ENABLED */
; 1595 : #ifdef LIBXML_PATTERN_ENABLED
; 1596 :     if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&

	mov	ecx, DWORD PTR $T1[ebp]
$LN66@xmlTextRea:
	mov	eax, DWORD PTR [esi+172]
	test	eax, eax
	jle	SHORT $LN8@xmlTextRea
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 2
	je	SHORT $LN8@xmlTextRea
	cmp	ecx, 4
	je	SHORT $LN8@xmlTextRea

; 1597 :         (reader->state != XML_TEXTREADER_BACKTRACK)) {
; 1598 :         int i;
; 1599 : 	for (i = 0;i < reader->patternNr;i++) {

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN8@xmlTextRea
	npad	8
$LL9@xmlTextRea:

; 1600 : 	     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {

	mov	eax, DWORD PTR [esi+180]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [eax+edi*4]
	call	_xmlPatternMatch
	add	esp, 8
	cmp	eax, 1
	je	SHORT $LN99@xmlTextRea

; 1597 :         (reader->state != XML_TEXTREADER_BACKTRACK)) {
; 1598 :         int i;
; 1599 : 	for (i = 0;i < reader->patternNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+172]
	jl	SHORT $LL9@xmlTextRea

; 1600 : 	     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {

	jmp	SHORT $LN8@xmlTextRea
$LN99@xmlTextRea:

; 1601 : 	         xmlTextReaderPreserve(reader);

	push	esi
	call	_xmlTextReaderPreserve
	add	esp, 4
$LN8@xmlTextRea:

; 1602 : 		 break;
; 1603 :              }
; 1604 : 	}
; 1605 :     }
; 1606 : #endif /* LIBXML_PATTERN_ENABLED */
; 1607 : #ifdef LIBXML_SCHEMAS_ENABLED
; 1608 :     if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&
; 1609 :         (reader->xsdValidErrors == 0) &&

	cmp	DWORD PTR [esi+8], 4
	jne	SHORT $LN70@xmlTextRea
	cmp	DWORD PTR [esi+148], 0
	jne	SHORT $LN70@xmlTextRea
	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN70@xmlTextRea

; 1610 : 	(reader->xsdValidCtxt != NULL)) {
; 1611 : 	reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);

	push	eax
	call	_xmlSchemaIsValid
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR [esi+148], eax
$LN70@xmlTextRea:

; 1617 :     return(0);
; 1618 : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlTextRea:

; 1459 : #endif
; 1460 : 	(reader->node->type == XML_HTML_DOCUMENT_NODE)) {
; 1461 : 	if (reader->mode != XML_TEXTREADER_MODE_EOF) {

	cmp	DWORD PTR [esi], 3
	je	SHORT $LN121@xmlTextRea

; 1462 : 	    val = xmlParseChunk(reader->ctxt, "", 0, 1);

	push	1
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [esi+20]
	call	_xmlParseChunk

; 1463 : 	    reader->state = XML_TEXTREADER_DONE;

	mov	ecx, DWORD PTR $T1[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], 5

; 1464 : 	    if (val != 0)

	test	eax, eax
	jne	SHORT $LN122@xmlTextRea
$LN121@xmlTextRea:

; 1465 : 	        return(-1);
; 1466 : 	}
; 1467 : 	reader->node = NULL;
; 1468 : 	reader->depth = -1;
; 1469 : 
; 1470 : 	/*
; 1471 : 	 * Cleanup of the old node
; 1472 : 	 */
; 1473 : 	if ((oldnode != NULL) && (reader->preserves == 0) &&
; 1474 : #ifdef LIBXML_XINCLUDE_ENABLED
; 1475 : 	    (reader->in_xinclude == 0) &&
; 1476 : #endif
; 1477 : 	    (reader->entNr == 0) &&
; 1478 : 	    (oldnode->type != XML_DTD_NODE) &&

	mov	ebx, DWORD PTR _oldnode$1$[ebp]
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+72], -1
	test	ebx, ebx
	je	SHORT $node_end$138
	cmp	DWORD PTR [esi+184], 0
	jne	SHORT $node_end$138
	cmp	DWORD PTR [esi+168], 0
	jne	SHORT $node_end$138
	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $node_end$138
	cmp	DWORD PTR [ebx+4], 14			; 0000000eH
	je	SHORT $node_end$138
	test	BYTE PTR [ebx+58], 2
	jne	SHORT $node_end$138

; 1479 : 	    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {
; 1480 : 	    xmlUnlinkNode(oldnode);

	push	ebx
	call	_xmlUnlinkNode

; 1481 : 	    xmlTextReaderFreeNode(reader, oldnode);

	push	ebx
	push	esi
	call	_xmlTextReaderFreeNode
	add	esp, 12					; 0000000cH
$node_end$138:

; 1612 :     }
; 1613 : #endif /* LIBXML_PATTERN_ENABLED */
; 1614 :     return(1);
; 1615 : node_end:
; 1616 :     reader->state = XML_TEXTREADER_DONE;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], 5
$LN132@xmlTextRea:

; 1617 :     return(0);
; 1618 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@xmlTextRea:

; 1352 : 	if (reader->mode == XML_TEXTREADER_MODE_EOF)

	cmp	DWORD PTR [esi], 3
	je	SHORT $LN132@xmlTextRea
$LN122@xmlTextRea:
	pop	edi

; 1617 :     return(0);
; 1618 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlTextReaderRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlTextReaderSetup
_TEXT	SEGMENT
_options$1$ = 8						; size = 4
_reader$ = 8						; size = 4
_input$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlTextReaderSetup PROC				; COMDAT

; 5125 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _reader$[ebp]
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	jne	SHORT $LN4@xmlTextRea

; 5126 :     if (reader == NULL) {
; 5127 :         if (input != NULL)

	mov	eax, DWORD PTR _input$[ebp]
	test	eax, eax
	je	$LN49@xmlTextRea

; 5128 : 	    xmlFreeParserInputBuffer(input);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 5313 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlTextRea:

; 5129 :         return (-1);
; 5130 :     }
; 5131 : 
; 5132 :     /*
; 5133 :      * we force the generation of compact text nodes on the reader
; 5134 :      * since usr applications should never modify the tree
; 5135 :      */
; 5136 :     options |= XML_PARSE_COMPACT;

	mov	ebx, DWORD PTR _options$[ebp]

; 5137 : 
; 5138 :     reader->doc = NULL;
; 5139 :     reader->entNr = 0;
; 5140 :     reader->parserFlags = options;
; 5141 :     reader->validate = XML_TEXTREADER_NOT_VALIDATE;
; 5142 :     if ((input != NULL) && (reader->input != NULL) &&

	mov	edi, DWORD PTR _input$[ebp]
	or	ebx, 65536				; 00010000H
	mov	DWORD PTR _options$1$[ebp], ebx
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+188], ebx
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	je	SHORT $LN47@xmlTextRea
	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN6@xmlTextRea
	test	BYTE PTR [esi+12], 1
	je	SHORT $LN6@xmlTextRea

; 5143 :         (reader->allocs & XML_TEXTREADER_INPUT)) {
; 5144 : 	xmlFreeParserInputBuffer(reader->input);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 5145 : 	reader->input = NULL;
; 5146 : 	reader->allocs -= XML_TEXTREADER_INPUT;

	dec	DWORD PTR [esi+12]
$LN6@xmlTextRea:

; 5147 :     }
; 5148 :     if (input != NULL) {
; 5149 : 	reader->input = input;
; 5150 : 	reader->allocs |= XML_TEXTREADER_INPUT;

	or	DWORD PTR [esi+12], 1
	mov	DWORD PTR [esi+28], edi
$LN47@xmlTextRea:

; 5151 :     }
; 5152 :     if (reader->buffer == NULL)

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	jne	SHORT $LN9@xmlTextRea

; 5153 :         reader->buffer = xmlBufCreateSize(100);

	push	100					; 00000064H
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR [esi+84], eax

; 5154 :     if (reader->buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlTextRea
$LN53@xmlTextRea:

; 5313 : }

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CE@MNBJMFAB@xmlTextReaderSetup?5?3?5malloc?5fai@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN49@xmlTextRea:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlTextRea:

; 5155 :         xmlGenericError(xmlGenericErrorContext,
; 5156 :                         "xmlTextReaderSetup : malloc failed\n");
; 5157 :         return (-1);
; 5158 :     }
; 5159 :     /* no operation on a reader should require a huge buffer */
; 5160 :     xmlBufSetAllocationScheme(reader->buffer,

	push	5
	push	eax
	call	_xmlBufSetAllocationScheme

; 5161 : 			      XML_BUFFER_ALLOC_BOUNDED);
; 5162 :     if (reader->sax == NULL)

	mov	eax, DWORD PTR [esi+24]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlTextRea

; 5163 : 	reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));

	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+24], eax

; 5164 :     if (reader->sax == NULL) {

	test	eax, eax
	je	SHORT $LN53@xmlTextRea
$LN11@xmlTextRea:

; 5165 :         xmlGenericError(xmlGenericErrorContext,
; 5166 :                         "xmlTextReaderSetup : malloc failed\n");
; 5167 :         return (-1);
; 5168 :     }
; 5169 :     xmlSAXVersion(reader->sax, 2);

	push	2
	push	eax
	call	_xmlSAXVersion

; 5170 :     reader->startElement = reader->sax->startElement;

	mov	ecx, DWORD PTR [esi+24]
	add	esp, 8
	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+32], eax

; 5171 :     reader->sax->startElement = xmlTextReaderStartElement;

	mov	DWORD PTR [ecx+56], OFFSET _xmlTextReaderStartElement

; 5172 :     reader->endElement = reader->sax->endElement;

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [esi+36], eax

; 5173 :     reader->sax->endElement = xmlTextReaderEndElement;

	mov	DWORD PTR [ecx+60], OFFSET _xmlTextReaderEndElement

; 5174 : #ifdef LIBXML_SAX1_ENABLED
; 5175 :     if (reader->sax->initialized == XML_SAX2_MAGIC) {

	mov	ecx, DWORD PTR [esi+24]
	cmp	DWORD PTR [ecx+108], -554844497		; deedbeafH
	jne	SHORT $LN12@xmlTextRea

; 5176 : #endif /* LIBXML_SAX1_ENABLED */
; 5177 :         reader->startElementNs = reader->sax->startElementNs;

	mov	eax, DWORD PTR [ecx+116]
	mov	DWORD PTR [esi+40], eax

; 5178 :         reader->sax->startElementNs = xmlTextReaderStartElementNs;

	mov	DWORD PTR [ecx+116], OFFSET _xmlTextReaderStartElementNs

; 5179 :         reader->endElementNs = reader->sax->endElementNs;

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+120]
	mov	DWORD PTR [esi+44], eax

; 5180 :         reader->sax->endElementNs = xmlTextReaderEndElementNs;

	mov	DWORD PTR [ecx+120], OFFSET _xmlTextReaderEndElementNs
	mov	ecx, DWORD PTR [esi+24]

; 5181 : #ifdef LIBXML_SAX1_ENABLED
; 5182 :     } else {

	jmp	SHORT $LN13@xmlTextRea
$LN12@xmlTextRea:

; 5183 :         reader->startElementNs = NULL;

	mov	DWORD PTR [esi+40], 0

; 5184 :         reader->endElementNs = NULL;

	mov	DWORD PTR [esi+44], 0
$LN13@xmlTextRea:

; 5185 :     }
; 5186 : #endif /* LIBXML_SAX1_ENABLED */
; 5187 :     reader->characters = reader->sax->characters;

	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR [esi+48], eax

; 5188 :     reader->sax->characters = xmlTextReaderCharacters;

	mov	DWORD PTR [ecx+68], OFFSET _xmlTextReaderCharacters

; 5189 :     reader->sax->ignorableWhitespace = xmlTextReaderCharacters;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+72], OFFSET _xmlTextReaderCharacters

; 5190 :     reader->cdataBlock = reader->sax->cdataBlock;

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [ecx+100]
	mov	DWORD PTR [esi+52], eax

; 5191 :     reader->sax->cdataBlock = xmlTextReaderCDataBlock;

	mov	DWORD PTR [ecx+100], OFFSET _xmlTextReaderCDataBlock

; 5192 : 
; 5193 :     reader->mode = XML_TEXTREADER_MODE_INITIAL;

	mov	DWORD PTR [esi], 0

; 5194 :     reader->node = NULL;

	mov	DWORD PTR [esi+64], 0

; 5195 :     reader->curnode = NULL;

	mov	DWORD PTR [esi+68], 0

; 5196 :     if (input != NULL) {

	test	edi, edi
	je	$LN48@xmlTextRea

; 5197 :         if (xmlBufUse(reader->input->buffer) < 4) {

	mov	eax, DWORD PTR [esi+28]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 4
	jae	SHORT $LN15@xmlTextRea

; 5198 :             xmlParserInputBufferRead(input, 4);

	push	4
	push	edi
	call	_xmlParserInputBufferRead
	add	esp, 8
$LN15@xmlTextRea:

; 5199 :         }
; 5200 :         if (reader->ctxt == NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN16@xmlTextRea

; 5201 :             if (xmlBufUse(reader->input->buffer) >= 4) {

	mov	eax, DWORD PTR [esi+28]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 4
	jb	SHORT $LN18@xmlTextRea

; 5202 :                 reader->ctxt = xmlCreatePushParserCtxt(reader->sax, NULL,

	mov	eax, DWORD PTR [esi+28]

; 5203 : 		       (const char *) xmlBufContent(reader->input->buffer),
; 5204 :                                       4, URL);
; 5205 :                 reader->base = 0;
; 5206 :                 reader->cur = 4;

	mov	edi, 4
	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	add	esp, 4
	mov	ecx, edi

; 5207 :             } else {

	jmp	SHORT $LN19@xmlTextRea
$LN18@xmlTextRea:

; 5208 :                 reader->ctxt =
; 5209 :                     xmlCreatePushParserCtxt(reader->sax, NULL, NULL, 0, URL);
; 5210 :                 reader->base = 0;
; 5211 :                 reader->cur = 0;

	xor	edi, edi
	xor	eax, eax
	xor	ecx, ecx
$LN19@xmlTextRea:

; 5212 :             }
; 5213 :         } else {

	push	DWORD PTR _URL$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+24]
	push	0
	push	eax
	call	_xmlCreatePushParserCtxt
	mov	DWORD PTR [esi+20], eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+56], 0
	jmp	SHORT $LN17@xmlTextRea
$LN16@xmlTextRea:

; 5214 : 	    xmlParserInputPtr inputStream;
; 5215 : 	    xmlParserInputBufferPtr buf;
; 5216 : 	    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
; 5217 : 
; 5218 : 	    xmlCtxtReset(reader->ctxt);

	push	eax
	call	_xmlCtxtReset

; 5219 : 	    buf = xmlAllocParserInputBuffer(enc);

	push	0
	call	_xmlAllocParserInputBuffer
	mov	edi, eax
	add	esp, 8

; 5220 : 	    if (buf == NULL) return(-1);

	test	edi, edi
	je	$LN49@xmlTextRea

; 5221 : 	    inputStream = xmlNewInputStream(reader->ctxt);

	push	DWORD PTR [esi+20]
	call	_xmlNewInputStream
	mov	ebx, eax
	add	esp, 4

; 5222 : 	    if (inputStream == NULL) {

	test	ebx, ebx
	jne	SHORT $LN21@xmlTextRea

; 5223 : 		xmlFreeParserInputBuffer(buf);

	push	edi
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 5224 : 		return(-1);

	or	eax, -1
	pop	edi

; 5313 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlTextRea:

; 5225 : 	    }
; 5226 : 
; 5227 : 	    if (URL == NULL)

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlTextRea
$LN22@xmlTextRea:

; 5228 : 		inputStream->filename = NULL;
; 5229 : 	    else
; 5230 : 		inputStream->filename = (char *)

	push	eax
	call	_xmlCanonicPath
	add	esp, 4
$LN23@xmlTextRea:

; 5231 : 		    xmlCanonicPath((const xmlChar *) URL);
; 5232 : 	    inputStream->buf = buf;

	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx], edi

; 5233 :             xmlBufResetInput(buf->buffer, inputStream);

	push	ebx
	push	DWORD PTR [edi+16]
	call	_xmlBufResetInput

; 5234 : 
; 5235 : 	    inputPush(reader->ctxt, inputStream);

	push	ebx
	push	DWORD PTR [esi+20]
	call	_inputPush
	mov	ebx, DWORD PTR _options$1$[ebp]
	add	esp, 16					; 00000010H

; 5236 : 	    reader->cur = 0;

	xor	edi, edi
$LN17@xmlTextRea:

; 5237 : 	}
; 5238 :         if (reader->ctxt == NULL) {

	mov	DWORD PTR [esi+60], edi
	cmp	DWORD PTR [esi+20], 0
	je	$LN53@xmlTextRea
$LN48@xmlTextRea:

; 5239 :             xmlGenericError(xmlGenericErrorContext,
; 5240 :                             "xmlTextReaderSetup : malloc failed\n");
; 5241 :             return (-1);
; 5242 :         }
; 5243 :     }
; 5244 :     if (reader->dict != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [ecx+296]
	test	eax, eax
	je	SHORT $LN25@xmlTextRea

; 5245 :         if (reader->ctxt->dict != NULL) {

	test	edx, edx
	je	SHORT $LN27@xmlTextRea

; 5246 : 	    if (reader->dict != reader->ctxt->dict) {

	cmp	eax, edx
	je	SHORT $LN26@xmlTextRea

; 5247 : 		xmlDictFree(reader->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4

; 5248 : 		reader->dict = reader->ctxt->dict;
; 5249 : 	    }
; 5250 : 	} else {

	jmp	SHORT $LN52@xmlTextRea
$LN27@xmlTextRea:

; 5251 : 	    reader->ctxt->dict = reader->dict;

	mov	DWORD PTR [ecx+296], eax
	mov	ecx, DWORD PTR [esi+20]

; 5252 : 	}
; 5253 :     } else {

	jmp	SHORT $LN26@xmlTextRea
$LN25@xmlTextRea:

; 5254 : 	if (reader->ctxt->dict == NULL)

	test	edx, edx
	jne	SHORT $LN30@xmlTextRea

; 5255 : 	    reader->ctxt->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+296], eax
$LN52@xmlTextRea:

; 5256 :         reader->dict = reader->ctxt->dict;
; 5257 :     }
; 5258 :     reader->ctxt->_private = reader;

	mov	ecx, DWORD PTR [esi+20]
$LN30@xmlTextRea:
	mov	eax, DWORD PTR [ecx+296]
	mov	DWORD PTR [esi+88], eax
$LN26@xmlTextRea:
	mov	DWORD PTR [ecx+272], esi

; 5259 :     reader->ctxt->linenumbers = 1;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+280], 1

; 5260 :     reader->ctxt->dictNames = 1;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+364], 1

; 5261 :     /*
; 5262 :      * use the parser dictionary to allocate all elements and attributes names
; 5263 :      */
; 5264 :     reader->ctxt->docdict = 1;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+308], 1

; 5265 :     reader->ctxt->parseMode = XML_PARSE_READER;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+436], 5

; 5266 : 
; 5267 : #ifdef LIBXML_XINCLUDE_ENABLED
; 5268 :     if (reader->xincctxt != NULL) {

	mov	eax, DWORD PTR [esi+164]
	test	eax, eax
	je	SHORT $LN31@xmlTextRea

; 5269 : 	xmlXIncludeFreeContext(reader->xincctxt);

	push	eax
	call	_xmlXIncludeFreeContext
	add	esp, 4

; 5270 : 	reader->xincctxt = NULL;

	mov	DWORD PTR [esi+164], 0
$LN31@xmlTextRea:

; 5271 :     }
; 5272 :     if (options & XML_PARSE_XINCLUDE) {

	test	ebx, 1024				; 00000400H
	je	SHORT $LN32@xmlTextRea

; 5273 :         reader->xinclude = 1;
; 5274 : 	reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);

	push	-1
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [esi+88]
	mov	DWORD PTR [esi+156], 1
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+160], eax

; 5275 : 	options -= XML_PARSE_XINCLUDE;

	sub	ebx, 1024				; 00000400H

; 5276 :     } else

	jmp	SHORT $LN33@xmlTextRea
$LN32@xmlTextRea:

; 5277 :         reader->xinclude = 0;

	mov	DWORD PTR [esi+156], 0
$LN33@xmlTextRea:

; 5278 :     reader->in_xinclude = 0;
; 5279 : #endif
; 5280 : #ifdef LIBXML_PATTERN_ENABLED
; 5281 :     if (reader->patternTab == NULL) {

	cmp	DWORD PTR [esi+180], 0
	mov	DWORD PTR [esi+168], 0
	jne	SHORT $LN45@xmlTextRea

; 5282 :         reader->patternNr = 0;

	mov	DWORD PTR [esi+172], 0

; 5283 : 	reader->patternMax = 0;

	mov	DWORD PTR [esi+176], 0
	jmp	SHORT $LN3@xmlTextRea
$LN45@xmlTextRea:
	mov	ecx, DWORD PTR [esi+172]

; 5284 :     }
; 5285 :     while (reader->patternNr > 0) {

	test	ecx, ecx
	jle	SHORT $LN3@xmlTextRea
	npad	6
$LL2@xmlTextRea:

; 5286 :         reader->patternNr--;
; 5287 : 	if (reader->patternTab[reader->patternNr] != NULL) {

	mov	eax, DWORD PTR [esi+180]
	dec	ecx
	mov	DWORD PTR [esi+172], ecx
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN35@xmlTextRea

; 5288 : 	    xmlFreePattern(reader->patternTab[reader->patternNr]);

	push	eax
	call	_xmlFreePattern

; 5289 :             reader->patternTab[reader->patternNr] = NULL;

	mov	ecx, DWORD PTR [esi+172]
	add	esp, 4
	mov	eax, DWORD PTR [esi+180]
	mov	DWORD PTR [eax+ecx*4], 0
	mov	ecx, DWORD PTR [esi+172]
$LN35@xmlTextRea:

; 5284 :     }
; 5285 :     while (reader->patternNr > 0) {

	test	ecx, ecx
	jg	SHORT $LL2@xmlTextRea
$LN3@xmlTextRea:

; 5290 : 	}
; 5291 :     }
; 5292 : #endif
; 5293 : 
; 5294 :     if (options & XML_PARSE_DTDVALID)

	test	bl, 16					; 00000010H
	je	SHORT $LN36@xmlTextRea

; 5295 :         reader->validate = XML_TEXTREADER_VALIDATE_DTD;

	mov	DWORD PTR [esi+8], 1
$LN36@xmlTextRea:

; 5296 : 
; 5297 :     xmlCtxtUseOptions(reader->ctxt, options);

	push	ebx
	push	DWORD PTR [esi+20]
	call	_xmlCtxtUseOptions

; 5298 :     if (encoding != NULL) {

	mov	eax, DWORD PTR _encoding$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@xmlTextRea

; 5299 :         xmlCharEncodingHandlerPtr hdlr;
; 5300 : 
; 5301 :         hdlr = xmlFindCharEncodingHandler(encoding);

	push	eax
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 5302 :         if (hdlr != NULL)

	test	eax, eax
	je	SHORT $LN38@xmlTextRea

; 5303 :             xmlSwitchToEncoding(reader->ctxt, hdlr);

	push	eax
	push	DWORD PTR [esi+20]
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN38@xmlTextRea:

; 5304 :     }
; 5305 :     if ((URL != NULL) && (reader->ctxt->input != NULL) &&

	mov	ecx, DWORD PTR _URL$[ebp]
	test	ecx, ecx
	je	SHORT $LN39@xmlTextRea
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN39@xmlTextRea
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN39@xmlTextRea

; 5306 :         (reader->ctxt->input->filename == NULL))
; 5307 :         reader->ctxt->input->filename = (char *)

	push	ecx
	call	_xmlStrdup
	mov	ecx, DWORD PTR [esi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [ecx+36]
	mov	DWORD PTR [ecx+4], eax
$LN39@xmlTextRea:

; 5308 :             xmlStrdup((const xmlChar *) URL);
; 5309 : 
; 5310 :     reader->doc = NULL;

	pop	edi
	mov	DWORD PTR [esi+4], 0

; 5311 : 
; 5312 :     return (0);

	xor	eax, eax

; 5313 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlTextReaderSetup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlFreeTextReader
_TEXT	SEGMENT
_reader$ = 8						; size = 4
_xmlFreeTextReader PROC					; COMDAT

; 2218 : xmlFreeTextReader(xmlTextReaderPtr reader) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _reader$[ebp]
	test	esi, esi
	je	$LN1@xmlFreeTex

; 2219 :     if (reader == NULL)
; 2220 : 	return;
; 2221 : #ifdef LIBXML_SCHEMAS_ENABLED
; 2222 :     if (reader->rngSchemas != NULL) {

	mov	eax, DWORD PTR [esi+116]
	test	eax, eax
	je	SHORT $LN6@xmlFreeTex

; 2223 : 	xmlRelaxNGFree(reader->rngSchemas);

	push	eax
	call	_xmlRelaxNGFree
	add	esp, 4

; 2224 : 	reader->rngSchemas = NULL;

	mov	DWORD PTR [esi+116], 0
$LN6@xmlFreeTex:

; 2225 :     }
; 2226 :     if (reader->rngValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN7@xmlFreeTex

; 2227 : 	if (! reader->rngPreserveCtxt)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN8@xmlFreeTex

; 2228 : 	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);

	push	eax
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4
$LN8@xmlFreeTex:

; 2229 : 	reader->rngValidCtxt = NULL;

	mov	DWORD PTR [esi+120], 0
$LN7@xmlFreeTex:

; 2230 :     }
; 2231 :     if (reader->xsdPlug != NULL) {

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN9@xmlFreeTex

; 2232 : 	xmlSchemaSAXUnplug(reader->xsdPlug);

	push	eax
	call	_xmlSchemaSAXUnplug
	add	esp, 4

; 2233 : 	reader->xsdPlug = NULL;

	mov	DWORD PTR [esi+152], 0
$LN9@xmlFreeTex:

; 2234 :     }
; 2235 :     if (reader->xsdValidCtxt != NULL) {

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN10@xmlFreeTex

; 2236 : 	if (! reader->xsdPreserveCtxt)

	cmp	DWORD PTR [esi+144], 0
	jne	SHORT $LN11@xmlFreeTex

; 2237 : 	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);

	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4
$LN11@xmlFreeTex:

; 2238 : 	reader->xsdValidCtxt = NULL;

	mov	DWORD PTR [esi+140], 0
$LN10@xmlFreeTex:

; 2239 :     }
; 2240 :     if (reader->xsdSchemas != NULL) {

	mov	eax, DWORD PTR [esi+136]
	test	eax, eax
	je	SHORT $LN12@xmlFreeTex

; 2241 : 	xmlSchemaFree(reader->xsdSchemas);

	push	eax
	call	_xmlSchemaFree
	add	esp, 4

; 2242 : 	reader->xsdSchemas = NULL;

	mov	DWORD PTR [esi+136], 0
$LN12@xmlFreeTex:

; 2243 :     }
; 2244 : #endif
; 2245 : #ifdef LIBXML_XINCLUDE_ENABLED
; 2246 :     if (reader->xincctxt != NULL)

	mov	eax, DWORD PTR [esi+164]
	test	eax, eax
	je	SHORT $LN13@xmlFreeTex

; 2247 : 	xmlXIncludeFreeContext(reader->xincctxt);

	push	eax
	call	_xmlXIncludeFreeContext
	add	esp, 4
$LN13@xmlFreeTex:

; 2248 : #endif
; 2249 : #ifdef LIBXML_PATTERN_ENABLED
; 2250 :     if (reader->patternTab != NULL) {

	mov	eax, DWORD PTR [esi+180]
	test	eax, eax
	je	SHORT $LN14@xmlFreeTex

; 2251 :         int i;
; 2252 : 	for (i = 0;i < reader->patternNr;i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+172], edi
	jle	SHORT $LN3@xmlFreeTex

; 2253 : 	    if (reader->patternTab[i] != NULL)

	mov	edx, eax
$LL4@xmlFreeTex:
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $LN2@xmlFreeTex

; 2254 : 	        xmlFreePattern(reader->patternTab[i]);

	push	ecx
	call	_xmlFreePattern
	mov	eax, DWORD PTR [esi+180]
	add	esp, 4
	mov	edx, eax
$LN2@xmlFreeTex:

; 2251 :         int i;
; 2252 : 	for (i = 0;i < reader->patternNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+172]
	jl	SHORT $LL4@xmlFreeTex
	mov	eax, edx
$LN3@xmlFreeTex:

; 2255 : 	}
; 2256 : 	xmlFree(reader->patternTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN14@xmlFreeTex:

; 2257 :     }
; 2258 : #endif
; 2259 :     if (reader->faketext != NULL) {

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN16@xmlFreeTex

; 2260 : 	xmlFreeNode(reader->faketext);

	push	eax
	call	_xmlFreeNode
	add	esp, 4
$LN16@xmlFreeTex:

; 2261 :     }
; 2262 :     if (reader->ctxt != NULL) {

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN22@xmlFreeTex

; 2263 :         if (reader->dict == reader->ctxt->dict)

	mov	eax, DWORD PTR [esi+88]
	cmp	eax, DWORD PTR [ecx+296]
	jne	SHORT $LN18@xmlFreeTex

; 2264 : 	    reader->dict = NULL;

	mov	DWORD PTR [esi+88], 0
$LN18@xmlFreeTex:

; 2265 : 	if (reader->ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN19@xmlFreeTex

; 2266 : 	    if (reader->preserve == 0)

	cmp	DWORD PTR [esi+80], 0
	jne	SHORT $LN20@xmlFreeTex

; 2267 : 		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);

	push	eax
	push	esi
	call	_xmlTextReaderFreeDoc
	mov	ecx, DWORD PTR [esi+20]
	add	esp, 8
$LN20@xmlFreeTex:

; 2268 : 	    reader->ctxt->myDoc = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	ecx, DWORD PTR [esi+20]
$LN19@xmlFreeTex:

; 2269 : 	}
; 2270 : 	if ((reader->ctxt->vctxt.vstateTab != NULL) &&

	mov	eax, DWORD PTR [ecx+160]
	test	eax, eax
	je	SHORT $LN21@xmlFreeTex
	cmp	DWORD PTR [ecx+156], 0
	jle	SHORT $LN21@xmlFreeTex

; 2271 : 	    (reader->ctxt->vctxt.vstateMax > 0)){
; 2272 : 	    xmlFree(reader->ctxt->vctxt.vstateTab);

	push	eax
	call	DWORD PTR _xmlFree

; 2273 : 	    reader->ctxt->vctxt.vstateTab = NULL;

	mov	eax, DWORD PTR [esi+20]
	add	esp, 4
	mov	DWORD PTR [eax+160], 0

; 2274 : 	    reader->ctxt->vctxt.vstateMax = 0;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+156], 0
$LN21@xmlFreeTex:

; 2275 : 	}
; 2276 : 	if (reader->allocs & XML_TEXTREADER_CTXT)

	test	BYTE PTR [esi+12], 2
	je	SHORT $LN22@xmlFreeTex

; 2277 : 	    xmlFreeParserCtxt(reader->ctxt);

	push	DWORD PTR [esi+20]
	call	_xmlFreeParserCtxt
	add	esp, 4
$LN22@xmlFreeTex:

; 2278 :     }
; 2279 :     if (reader->sax != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN23@xmlFreeTex

; 2280 : 	xmlFree(reader->sax);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlFreeTex:

; 2281 :     if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT))

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN24@xmlFreeTex
	test	BYTE PTR [esi+12], 1
	je	SHORT $LN24@xmlFreeTex

; 2282 : 	xmlFreeParserInputBuffer(reader->input);

	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN24@xmlFreeTex:

; 2283 :     if (reader->buffer != NULL)

	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN25@xmlFreeTex

; 2284 :         xmlBufFree(reader->buffer);

	push	eax
	call	_xmlBufFree
	add	esp, 4
$LN25@xmlFreeTex:

; 2285 :     if (reader->entTab != NULL)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	je	SHORT $LN26@xmlFreeTex

; 2286 : 	xmlFree(reader->entTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN26@xmlFreeTex:

; 2287 :     if (reader->dict != NULL)

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	je	SHORT $LN27@xmlFreeTex

; 2288 :         xmlDictFree(reader->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN27@xmlFreeTex:

; 2289 :     xmlFree(reader);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeTex:
	pop	esi

; 2290 : }

	pop	ebp
	ret	0
_xmlFreeTextReader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlNewTextReaderFilename
_TEXT	SEGMENT
_URI$ = 8						; size = 4
_xmlNewTextReaderFilename PROC				; COMDAT

; 2188 : xmlNewTextReaderFilename(const char *URI) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _URI$[ebp]
	xor	esi, esi
	push	esi
	push	edi
	call	_xmlParserInputBufferCreateFilename
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN8@xmlNewText

; 2189 :     xmlParserInputBufferPtr input;
; 2190 :     xmlTextReaderPtr ret;
; 2191 :     char *directory = NULL;
; 2192 : 
; 2193 :     input = xmlParserInputBufferCreateFilename(URI, XML_CHAR_ENCODING_NONE);
; 2194 :     if (input == NULL)
; 2195 : 	return(NULL);
; 2196 :     ret = xmlNewTextReader(input, URI);

	push	edi
	push	ebx
	call	_xmlNewTextReader
	mov	edi, eax
	add	esp, 8

; 2197 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlNewText

; 2198 : 	xmlFreeParserInputBuffer(input);

	push	ebx
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN8@xmlNewText:

; 2209 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlNewText:

; 2199 : 	return(NULL);
; 2200 :     }
; 2201 :     ret->allocs |= XML_TEXTREADER_INPUT;
; 2202 :     if (ret->ctxt->directory == NULL)

	mov	eax, DWORD PTR [edi+20]
	or	DWORD PTR [edi+12], 1
	cmp	DWORD PTR [eax+180], esi
	jne	SHORT $LN4@xmlNewText

; 2203 :         directory = xmlParserGetDirectory(URI);

	push	DWORD PTR _URI$[ebp]
	call	_xmlParserGetDirectory
	mov	esi, eax
	add	esp, 4
	mov	eax, DWORD PTR [edi+20]
$LN4@xmlNewText:

; 2204 :     if ((ret->ctxt->directory == NULL) && (directory != NULL))

	cmp	DWORD PTR [eax+180], 0
	jne	SHORT $LN5@xmlNewText
	test	esi, esi
	je	SHORT $LN6@xmlNewText

; 2205 :         ret->ctxt->directory = (char *) xmlStrdup((xmlChar *) directory);

	push	esi
	call	_xmlStrdup
	mov	ecx, DWORD PTR [edi+20]
	add	esp, 4
	mov	DWORD PTR [ecx+180], eax
$LN5@xmlNewText:

; 2206 :     if (directory != NULL)

	test	esi, esi
	je	SHORT $LN6@xmlNewText

; 2207 : 	xmlFree(directory);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNewText:

; 2208 :     return(ret);

	mov	eax, edi
	pop	edi

; 2209 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlNewTextReaderFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlreader.c
;	COMDAT _xmlNewTextReader
_TEXT	SEGMENT
_input$ = 8						; size = 4
_URI$ = 12						; size = 4
_xmlNewTextReader PROC					; COMDAT

; 2074 : xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BC13D883_xmlreader@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _input$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlNewText

; 2075 :     xmlTextReaderPtr ret;
; 2076 : 
; 2077 :     if (input == NULL)
; 2078 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
$LN2@xmlNewText:
	push	edi

; 2079 :     ret = xmlMalloc(sizeof(xmlTextReader));

	push	196					; 000000c4H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 2080 :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlNewText

; 2081 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 2082 : 		"xmlNewTextReader : malloc failed\n");
; 2083 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
$LN3@xmlNewText:

; 2084 :     }
; 2085 :     memset(ret, 0, sizeof(xmlTextReader));

	push	196					; 000000c4H
	push	0
	push	edi
	call	_memset

; 2086 :     ret->doc = NULL;
; 2087 :     ret->entTab = NULL;
; 2088 :     ret->entMax = 0;
; 2089 :     ret->entNr = 0;
; 2090 :     ret->input = input;
; 2091 :     ret->buffer = xmlBufCreateSize(100);

	push	100					; 00000064H
	mov	DWORD PTR [edi+28], esi
	call	_xmlBufCreateSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+84], eax

; 2092 :     if (ret->buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlNewText

; 2093 :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree

; 2094 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 2095 : 		"xmlNewTextReader : malloc failed\n");
; 2096 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
$LN4@xmlNewText:

; 2097 :     }
; 2098 :     /* no operation on a reader should require a huge buffer */
; 2099 :     xmlBufSetAllocationScheme(ret->buffer,

	push	5
	push	eax
	call	_xmlBufSetAllocationScheme

; 2100 : 			      XML_BUFFER_ALLOC_BOUNDED);
; 2101 :     ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));

	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+24], eax

; 2102 :     if (ret->sax == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlNewText

; 2103 : 	xmlBufFree(ret->buffer);

	push	DWORD PTR [edi+84]
	call	_xmlBufFree

; 2104 : 	xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree

; 2105 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 2106 : 		"xmlNewTextReader : malloc failed\n");
; 2107 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
$LN5@xmlNewText:

; 2108 :     }
; 2109 :     xmlSAXVersion(ret->sax, 2);

	push	2
	push	eax
	call	_xmlSAXVersion

; 2110 :     ret->startElement = ret->sax->startElement;

	mov	ecx, DWORD PTR [edi+24]
	add	esp, 8
	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [edi+32], eax

; 2111 :     ret->sax->startElement = xmlTextReaderStartElement;

	mov	DWORD PTR [ecx+56], OFFSET _xmlTextReaderStartElement

; 2112 :     ret->endElement = ret->sax->endElement;

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edi+36], eax

; 2113 :     ret->sax->endElement = xmlTextReaderEndElement;

	mov	DWORD PTR [ecx+60], OFFSET _xmlTextReaderEndElement

; 2114 : #ifdef LIBXML_SAX1_ENABLED
; 2115 :     if (ret->sax->initialized == XML_SAX2_MAGIC) {

	mov	ecx, DWORD PTR [edi+24]
	cmp	DWORD PTR [ecx+108], -554844497		; deedbeafH
	jne	SHORT $LN6@xmlNewText

; 2116 : #endif /* LIBXML_SAX1_ENABLED */
; 2117 : 	ret->startElementNs = ret->sax->startElementNs;

	mov	eax, DWORD PTR [ecx+116]
	mov	DWORD PTR [edi+40], eax

; 2118 : 	ret->sax->startElementNs = xmlTextReaderStartElementNs;

	mov	DWORD PTR [ecx+116], OFFSET _xmlTextReaderStartElementNs

; 2119 : 	ret->endElementNs = ret->sax->endElementNs;

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+120]
	mov	DWORD PTR [edi+44], eax

; 2120 : 	ret->sax->endElementNs = xmlTextReaderEndElementNs;

	mov	DWORD PTR [ecx+120], OFFSET _xmlTextReaderEndElementNs
	mov	ecx, DWORD PTR [edi+24]

; 2121 : #ifdef LIBXML_SAX1_ENABLED
; 2122 :     } else {

	jmp	SHORT $LN7@xmlNewText
$LN6@xmlNewText:

; 2123 : 	ret->startElementNs = NULL;

	mov	DWORD PTR [edi+40], 0

; 2124 : 	ret->endElementNs = NULL;

	mov	DWORD PTR [edi+44], 0
$LN7@xmlNewText:

; 2125 :     }
; 2126 : #endif /* LIBXML_SAX1_ENABLED */
; 2127 :     ret->characters = ret->sax->characters;

	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR [edi+48], eax

; 2128 :     ret->sax->characters = xmlTextReaderCharacters;

	mov	DWORD PTR [ecx+68], OFFSET _xmlTextReaderCharacters

; 2129 :     ret->sax->ignorableWhitespace = xmlTextReaderCharacters;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+72], OFFSET _xmlTextReaderCharacters

; 2130 :     ret->cdataBlock = ret->sax->cdataBlock;

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+100]
	mov	DWORD PTR [edi+52], eax

; 2131 :     ret->sax->cdataBlock = xmlTextReaderCDataBlock;

	mov	DWORD PTR [ecx+100], OFFSET _xmlTextReaderCDataBlock

; 2132 : 
; 2133 :     ret->mode = XML_TEXTREADER_MODE_INITIAL;
; 2134 :     ret->node = NULL;
; 2135 :     ret->curnode = NULL;
; 2136 :     if (xmlBufUse(ret->input->buffer) < 4) {

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+64], 0
	mov	DWORD PTR [edi+68], 0
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 4
	jae	SHORT $LN8@xmlNewText

; 2137 : 	xmlParserInputBufferRead(input, 4);

	push	4
	push	esi
	call	_xmlParserInputBufferRead
	add	esp, 8
$LN8@xmlNewText:

; 2138 :     }
; 2139 :     if (xmlBufUse(ret->input->buffer) >= 4) {

	mov	eax, DWORD PTR [edi+28]
	push	DWORD PTR [eax+16]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 4
	jb	SHORT $LN9@xmlNewText

; 2140 : 	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,

	mov	eax, DWORD PTR [edi+28]

; 2141 : 			     (const char *) xmlBufContent(ret->input->buffer),
; 2142 :                                             4, URI);
; 2143 : 	ret->base = 0;
; 2144 : 	ret->cur = 4;

	mov	esi, 4
	push	DWORD PTR [eax+16]
	call	_xmlBufContent
	add	esp, 4
	mov	ecx, esi

; 2145 :     } else {

	jmp	SHORT $LN10@xmlNewText
$LN9@xmlNewText:

; 2146 : 	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);
; 2147 : 	ret->base = 0;
; 2148 : 	ret->cur = 0;

	xor	esi, esi
	xor	eax, eax
	xor	ecx, ecx
$LN10@xmlNewText:

; 2149 :     }
; 2150 : 
; 2151 :     if (ret->ctxt == NULL) {

	push	DWORD PTR _URI$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edi+24]
	push	0
	push	eax
	call	_xmlCreatePushParserCtxt
	mov	DWORD PTR [edi+20], eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+56], 0
	mov	DWORD PTR [edi+60], esi
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	jne	SHORT $LN11@xmlNewText

; 2152 :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@HCDAIILG@xmlNewTextReader?5?3?5malloc?5faile@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 2153 : 		"xmlNewTextReader : malloc failed\n");
; 2154 : 	xmlBufFree(ret->buffer);

	push	DWORD PTR [edi+84]
	call	_xmlBufFree

; 2155 : 	xmlFree(ret->sax);

	push	DWORD PTR [edi+24]
	call	DWORD PTR _xmlFree

; 2156 : 	xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2157 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
$LN11@xmlNewText:

; 2158 :     }
; 2159 :     ret->ctxt->parseMode = XML_PARSE_READER;

	mov	DWORD PTR [eax+436], 5

; 2160 :     ret->ctxt->_private = ret;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+272], edi

; 2161 :     ret->ctxt->linenumbers = 1;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+280], 1

; 2162 :     ret->ctxt->dictNames = 1;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+364], 1

; 2163 :     ret->allocs = XML_TEXTREADER_CTXT;
; 2164 :     /*
; 2165 :      * use the parser dictionary to allocate all elements and attributes names
; 2166 :      */
; 2167 :     ret->ctxt->docdict = 1;
; 2168 :     ret->dict = ret->ctxt->dict;
; 2169 : #ifdef LIBXML_XINCLUDE_ENABLED
; 2170 :     ret->xinclude = 0;
; 2171 : #endif
; 2172 : #ifdef LIBXML_PATTERN_ENABLED
; 2173 :     ret->patternMax = 0;
; 2174 :     ret->patternTab = NULL;
; 2175 : #endif
; 2176 :     return(ret);

	mov	eax, edi
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [edi+12], 2
	mov	DWORD PTR [ecx+308], 1
	mov	ecx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [ecx+296]
	mov	DWORD PTR [edi+88], ecx
	mov	DWORD PTR [edi+156], 0
	mov	DWORD PTR [edi+176], 0
	mov	DWORD PTR [edi+180], 0
	pop	edi
	pop	esi

; 2177 : }

	pop	ebp
	ret	0
_xmlNewTextReader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	esi, eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	edi
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 28					; 0000001cH

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);
; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

	pop	edi
	pop	esi

; 961  :     }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
