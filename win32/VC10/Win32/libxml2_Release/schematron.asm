; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\schematron.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@CBADNNMC@http?3?1?1purl?4oclc?4org?1dsdl?1schem@ ; `string'
PUBLIC	??_C@_0CD@PAAIHHGB@http?3?1?1www?4ascc?4net?1xml?1schemat@ ; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__D7D5901C_schematron@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0CD@PAAIHHGB@http?3?1?1www?4ascc?4net?1xml?1schemat@
CONST	SEGMENT
??_C@_0CD@PAAIHHGB@http?3?1?1www?4ascc?4net?1xml?1schemat@ DB 'http://www'
	DB	'.ascc.net/xml/schematron', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CBADNNMC@http?3?1?1purl?4oclc?4org?1dsdl?1schem@
CONST	SEGMENT
??_C@_0CF@CBADNNMC@http?3?1?1purl?4oclc?4org?1dsdl?1schem@ DB 'http://pur'
	DB	'l.oclc.org/dsdl/schematron', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlSchematronNewParserCtxt
PUBLIC	_xmlSchematronNewMemParserCtxt
PUBLIC	_xmlSchematronNewDocParserCtxt
PUBLIC	_xmlSchematronFreeParserCtxt
PUBLIC	_xmlSchematronParse
PUBLIC	_xmlSchematronFree
PUBLIC	_xmlSchematronSetValidStructuredErrors
PUBLIC	_xmlSchematronNewValidCtxt
PUBLIC	_xmlSchematronFreeValidCtxt
PUBLIC	_xmlSchematronValidateDoc
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CF@CDHGHDAB@Failed?5to?5compile?5test?5expressi@ ; `string'
PUBLIC	??_C@_0BH@EFIEABMK@allocating?5schema?5test@	; `string'
PUBLIC	??_C@_0CI@BJKODKAC@Failed?5to?5compile?5context?5expre@ ; `string'
PUBLIC	??_C@_0BH@NOHOGEKI@allocating?5schema?5rule@	; `string'
PUBLIC	??_C@_0BK@KCAFICNM@allocating?5schema?5pattern@	; `string'
PUBLIC	??_C@_0BC@BFLACGOA@allocating?5schema@		; `string'
PUBLIC	??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@ ; `string'
PUBLIC	??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@ ; `string'
PUBLIC	??_C@_0BN@GJJHFKFH@allocating?5parser?5namespaces@ ; `string'
PUBLIC	??_C@_07JKKCBBMM@context@			; `string'
PUBLIC	??_C@_0BO@OOKBPBKF@rule?5has?5no?5context?5attribute@ ; `string'
PUBLIC	??_C@_0CE@PPHKJDMN@rule?5has?5an?5empty?5context?5attri@ ; `string'
PUBLIC	??_C@_06GMEIIFFN@assert@			; `string'
PUBLIC	??_C@_04CEJDCDCH@test@				; `string'
PUBLIC	??_C@_0BN@CLPNCGJA@assert?5has?5no?5test?5attribute@ ; `string'
PUBLIC	??_C@_0CD@COBAHICO@assert?5has?5an?5empty?5test?5attrib@ ; `string'
PUBLIC	??_C@_06MHOMHIDM@report@			; `string'
PUBLIC	??_C@_0DG@GPEPPHEL@Expecting?5an?5assert?5or?5a?5report@ ; `string'
PUBLIC	??_C@_0CG@GJJAJNIB@rule?5has?5no?5assert?5nor?5report?5e@ ; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_04LPGJEGEF@rule@				; `string'
PUBLIC	??_C@_0CH@HMMHEKDJ@Expecting?5a?5rule?5element?5instea@ ; `string'
PUBLIC	??_C@_0BM@HPHJEBHK@Pattern?5has?5no?5rule?5element@ ; `string'
PUBLIC	??_C@_0CK@FENMHHNI@xmlSchematronParse?3?5could?5not?5l@ ; `string'
PUBLIC	??_C@_0CG@KJCFFGDH@xmlSchematronParse?3?5could?5not?5p@ ; `string'
PUBLIC	??_C@_0BB@IEONCAEH@in_memory_buffer@		; `string'
PUBLIC	??_C@_0CF@CKMAMFKI@The?5schema?5has?5no?5document?5elem@ ; `string'
PUBLIC	??_C@_06KICAKOOL@schema@			; `string'
PUBLIC	??_C@_0DH@PDEEDFDL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@ ; `string'
PUBLIC	??_C@_05PHLGJONK@title@				; `string'
PUBLIC	??_C@_02EGOFOKPC@ns@				; `string'
PUBLIC	??_C@_06CHGOAPND@prefix@			; `string'
PUBLIC	??_C@_03GBBABMJN@uri@				; `string'
PUBLIC	??_C@_0BG@GCEGAJCF@ns?5element?5has?5no?5uri@	; `string'
PUBLIC	??_C@_0BJ@FJJOLCKN@ns?5element?5has?5no?5prefix@ ; `string'
PUBLIC	??_C@_07CHFOACKJ@pattern@			; `string'
PUBLIC	??_C@_0CK@GKEBAOHO@Expecting?5a?5pattern?5element?5ins@ ; `string'
PUBLIC	??_C@_0CM@EHOBNHNH@The?5schematron?5document?5?8?$CFs?8?5ha@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_04LNEJFJGI@path@				; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BD@IJCBIFPI@node?5failed?5assert@	; `string'
PUBLIC	??_C@_0BD@CCIFHIJJ@node?5failed?5report@	; `string'
PUBLIC	??_C@_0BB@HNMKNBOB@?$CFs?5line?5?$CFld?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0N@IHDDKFAG@Pattern?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BO@JGCBGKGF@allocating?5validation?5context@ ; `string'
PUBLIC	__real@0000000000000000
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlGetNodePath:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlGetNoNsProp:PROC
EXTRN	_xmlNodeGetContent:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	_xmlReadMemory:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPathEval:PROC
EXTRN	_xmlXPathCtxtCompile:PROC
EXTRN	_xmlXPathCompiledEval:PROC
EXTRN	_xmlXPathFreeCompExpr:PROC
EXTRN	_xmlXPathIsNaN:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlFreePattern:PROC
EXTRN	_xmlPatterncompile:PROC
EXTRN	_xmlPatternMatch:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0BO@JGCBGKGF@allocating?5validation?5context@
CONST	SEGMENT
??_C@_0BO@JGCBGKGF@allocating?5validation?5context@ DB 'allocating valida'
	DB	'tion context', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IHDDKFAG@Pattern?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0N@IHDDKFAG@Pattern?3?5?$CFs?6@ DB 'Pattern: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNMKNBOB@?$CFs?5line?5?$CFld?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@HNMKNBOB@?$CFs?5line?5?$CFld?3?5?$CFs?6@ DB '%s line %ld: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCIFHIJJ@node?5failed?5report@
CONST	SEGMENT
??_C@_0BD@CCIFHIJJ@node?5failed?5report@ DB 'node failed report', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IJCBIFPI@node?5failed?5assert@
CONST	SEGMENT
??_C@_0BD@IJCBIFPI@node?5failed?5assert@ DB 'node failed assert', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\schematron.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNEJFJGI@path@
CONST	SEGMENT
??_C@_04LNEJFJGI@path@ DB 'path', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EHOBNHNH@The?5schematron?5document?5?8?$CFs?8?5ha@
CONST	SEGMENT
??_C@_0CM@EHOBNHNH@The?5schematron?5document?5?8?$CFs?8?5ha@ DB 'The sche'
	DB	'matron document ''%s'' has no pattern', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GKEBAOHO@Expecting?5a?5pattern?5element?5ins@
CONST	SEGMENT
??_C@_0CK@GKEBAOHO@Expecting?5a?5pattern?5element?5ins@ DB 'Expecting a p'
	DB	'attern element instead of %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHFOACKJ@pattern@
CONST	SEGMENT
??_C@_07CHFOACKJ@pattern@ DB 'pattern', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FJJOLCKN@ns?5element?5has?5no?5prefix@
CONST	SEGMENT
??_C@_0BJ@FJJOLCKN@ns?5element?5has?5no?5prefix@ DB 'ns element has no pr'
	DB	'efix', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCEGAJCF@ns?5element?5has?5no?5uri@
CONST	SEGMENT
??_C@_0BG@GCEGAJCF@ns?5element?5has?5no?5uri@ DB 'ns element has no uri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GBBABMJN@uri@
CONST	SEGMENT
??_C@_03GBBABMJN@uri@ DB 'uri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHGOAPND@prefix@
CONST	SEGMENT
??_C@_06CHGOAPND@prefix@ DB 'prefix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFOKPC@ns@
CONST	SEGMENT
??_C@_02EGOFOKPC@ns@ DB 'ns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title@
CONST	SEGMENT
??_C@_05PHLGJONK@title@ DB 'title', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PDEEDFDL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@
CONST	SEGMENT
??_C@_0DH@PDEEDFDL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@ DB 'The X'
	DB	'ML document ''%s'' is not a XML schematron document', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KICAKOOL@schema@
CONST	SEGMENT
??_C@_06KICAKOOL@schema@ DB 'schema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CKMAMFKI@The?5schema?5has?5no?5document?5elem@
CONST	SEGMENT
??_C@_0CF@CKMAMFKI@The?5schema?5has?5no?5document?5elem@ DB 'The schema h'
	DB	'as no document element.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEONCAEH@in_memory_buffer@
CONST	SEGMENT
??_C@_0BB@IEONCAEH@in_memory_buffer@ DB 'in_memory_buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KJCFFGDH@xmlSchematronParse?3?5could?5not?5p@
CONST	SEGMENT
??_C@_0CG@KJCFFGDH@xmlSchematronParse?3?5could?5not?5p@ DB 'xmlSchematron'
	DB	'Parse: could not parse.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FENMHHNI@xmlSchematronParse?3?5could?5not?5l@
CONST	SEGMENT
??_C@_0CK@FENMHHNI@xmlSchematronParse?3?5could?5not?5l@ DB 'xmlSchematron'
	DB	'Parse: could not load ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPHJEBHK@Pattern?5has?5no?5rule?5element@
CONST	SEGMENT
??_C@_0BM@HPHJEBHK@Pattern?5has?5no?5rule?5element@ DB 'Pattern has no ru'
	DB	'le element', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HMMHEKDJ@Expecting?5a?5rule?5element?5instea@
CONST	SEGMENT
??_C@_0CH@HMMHEKDJ@Expecting?5a?5rule?5element?5instea@ DB 'Expecting a r'
	DB	'ule element instead of %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPGJEGEF@rule@
CONST	SEGMENT
??_C@_04LPGJEGEF@rule@ DB 'rule', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GJJAJNIB@rule?5has?5no?5assert?5nor?5report?5e@
CONST	SEGMENT
??_C@_0CG@GJJAJNIB@rule?5has?5no?5assert?5nor?5report?5e@ DB 'rule has no'
	DB	' assert nor report element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GPEPPHEL@Expecting?5an?5assert?5or?5a?5report@
CONST	SEGMENT
??_C@_0DG@GPEPPHEL@Expecting?5an?5assert?5or?5a?5report@ DB 'Expecting an'
	DB	' assert or a report element instead of %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHOMHIDM@report@
CONST	SEGMENT
??_C@_06MHOMHIDM@report@ DB 'report', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@COBAHICO@assert?5has?5an?5empty?5test?5attrib@
CONST	SEGMENT
??_C@_0CD@COBAHICO@assert?5has?5an?5empty?5test?5attrib@ DB 'assert has a'
	DB	'n empty test attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLPNCGJA@assert?5has?5no?5test?5attribute@
CONST	SEGMENT
??_C@_0BN@CLPNCGJA@assert?5has?5no?5test?5attribute@ DB 'assert has no te'
	DB	'st attribute', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04CEJDCDCH@test@
CONST	SEGMENT
??_C@_04CEJDCDCH@test@ DB 'test', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMEIIFFN@assert@
CONST	SEGMENT
??_C@_06GMEIIFFN@assert@ DB 'assert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PPHKJDMN@rule?5has?5an?5empty?5context?5attri@
CONST	SEGMENT
??_C@_0CE@PPHKJDMN@rule?5has?5an?5empty?5context?5attri@ DB 'rule has an '
	DB	'empty context attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OOKBPBKF@rule?5has?5no?5context?5attribute@
CONST	SEGMENT
??_C@_0BO@OOKBPBKF@rule?5has?5no?5context?5attribute@ DB 'rule has no con'
	DB	'text attribute', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKKCBBMM@context@
CONST	SEGMENT
??_C@_07JKKCBBMM@context@ DB 'context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GJJHFKFH@allocating?5parser?5namespaces@
CONST	SEGMENT
??_C@_0BN@GJJHFKFH@allocating?5parser?5namespaces@ DB 'allocating parser '
	DB	'namespaces', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@
CONST	SEGMENT
??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@ DB 'allocating sc'
	DB	'hema parser XPath context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
CONST	SEGMENT
??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@ DB 'allocating sch'
	DB	'ema parser context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFLACGOA@allocating?5schema@
CONST	SEGMENT
??_C@_0BC@BFLACGOA@allocating?5schema@ DB 'allocating schema', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KCAFICNM@allocating?5schema?5pattern@
CONST	SEGMENT
??_C@_0BK@KCAFICNM@allocating?5schema?5pattern@ DB 'allocating schema pat'
	DB	'tern', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NOHOGEKI@allocating?5schema?5rule@
CONST	SEGMENT
??_C@_0BH@NOHOGEKI@allocating?5schema?5rule@ DB 'allocating schema rule', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BJKODKAC@Failed?5to?5compile?5context?5expre@
CONST	SEGMENT
??_C@_0CI@BJKODKAC@Failed?5to?5compile?5context?5expre@ DB 'Failed to com'
	DB	'pile context expression %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EFIEABMK@allocating?5schema?5test@
CONST	SEGMENT
??_C@_0BH@EFIEABMK@allocating?5schema?5test@ DB 'allocating schema test', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CDHGHDAB@Failed?5to?5compile?5test?5expressi@
CONST	SEGMENT
??_C@_0CF@CDHGHDAB@Failed?5to?5compile?5test?5expressi@ DB 'Failed to com'
	DB	'pile test expression %s', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlSchematronNs DD FLAT:??_C@_0CF@CBADNNMC@http?3?1?1purl?4oclc?4org?1dsdl?1schem@
_xmlOldSchematronNs DD FLAT:??_C@_0CD@PAAIHHGB@http?3?1?1www?4ascc?4net?1xml?1schemat@
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronRunTest
_TEXT	SEGMENT
_failed$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_test$ = 12						; size = 4
_instance$ = 16						; size = 4
_cur$ = 20						; size = 4
_pattern$ = 24						; size = 4
_xmlSchematronRunTest PROC				; COMDAT

; 1604 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	eax, DWORD PTR _instance$[ebp]
	mov	DWORD PTR _failed$1$[ebp], ebx
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _test$[ebp]
	push	DWORD PTR [edi+24]
	push	DWORD PTR [eax+16]
	call	_xmlXPathCompiledEval
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN4@xmlSchemat

; 1605 :     xmlXPathObjectPtr ret;
; 1606 :     int failed;
; 1607 : 
; 1608 :     failed = 0;
; 1609 :     ctxt->xctxt->doc = instance;
; 1610 :     ctxt->xctxt->node = cur;
; 1611 :     ret = xmlXPathCompiledEval(test->comp, ctxt->xctxt);
; 1612 :     if (ret == NULL) {
; 1613 : 	failed = 1;

	mov	ecx, DWORD PTR _test$[ebp]
	lea	eax, DWORD PTR [ebx+1]

; 1644 :     }
; 1645 :     if ((failed) && (test->type == XML_SCHEMATRON_ASSERT))

	cmp	DWORD PTR [ecx+4], eax

; 1646 :         ctxt->nberrors++;

	jmp	$LN27@xmlSchemat
$LN4@xmlSchemat:

; 1614 :     } else {
; 1615 :         switch (ret->type) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 9
	ja	SHORT $LN2@xmlSchemat
	jmp	DWORD PTR $LN29@xmlSchemat[eax*4]
$LN6@xmlSchemat:

; 1616 : 	    case XPATH_XSLT_TREE:
; 1617 : 	    case XPATH_NODESET:
; 1618 : 		if ((ret->nodesetval == NULL) ||

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN16@xmlSchemat
	cmp	DWORD PTR [eax], ebx

; 1619 : 		    (ret->nodesetval->nodeNr == 0))
; 1620 : 		    failed = 1;
; 1621 : 		break;

	jmp	SHORT $LN26@xmlSchemat
$LN9@xmlSchemat:

; 1622 : 	    case XPATH_BOOLEAN:
; 1623 : 		failed = !ret->boolval;

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	sete	bl

; 1624 : 		break;

	jmp	SHORT $LN25@xmlSchemat
$LN10@xmlSchemat:

; 1625 : 	    case XPATH_NUMBER:
; 1626 : 		if ((xmlXPathIsNaN(ret->floatval)) ||

	movsd	xmm0, QWORD PTR [esi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlSchemat
	movsd	xmm0, QWORD PTR [esi+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@xmlSchemat

; 1627 : 		    (ret->floatval == 0.0))
; 1628 : 		    failed = 1;
; 1629 : 		break;

	jmp	SHORT $LN16@xmlSchemat
$LN13@xmlSchemat:

; 1630 : 	    case XPATH_STRING:
; 1631 : 		if ((ret->stringval == NULL) ||

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN16@xmlSchemat
	cmp	BYTE PTR [eax], bl
$LN26@xmlSchemat:

; 1632 : 		    (ret->stringval[0] == 0))
; 1633 : 		    failed = 1;
; 1634 : 		break;
; 1635 : 	    case XPATH_UNDEFINED:
; 1636 : 	    case XPATH_POINT:
; 1637 : 	    case XPATH_RANGE:
; 1638 : 	    case XPATH_LOCATIONSET:
; 1639 : 	    case XPATH_USERS:
; 1640 : 		failed = 1;
; 1641 : 		break;
; 1642 : 	}
; 1643 : 	xmlXPathFreeObject(ret);

	jne	SHORT $LN2@xmlSchemat
$LN16@xmlSchemat:
	mov	ebx, 1
$LN25@xmlSchemat:
	mov	DWORD PTR _failed$1$[ebp], ebx
$LN2@xmlSchemat:
	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 1644 :     }
; 1645 :     if ((failed) && (test->type == XML_SCHEMATRON_ASSERT))

	test	ebx, ebx
	je	SHORT $LN22@xmlSchemat
	mov	ecx, DWORD PTR _test$[ebp]
	mov	eax, DWORD PTR _failed$1$[ebp]
	cmp	DWORD PTR [ecx+4], 1

; 1646 :         ctxt->nberrors++;

	jmp	SHORT $LN27@xmlSchemat
$LN22@xmlSchemat:

; 1647 :     else if ((!failed) && (test->type == XML_SCHEMATRON_REPORT))

	mov	eax, DWORD PTR _test$[ebp]
	cmp	DWORD PTR [eax+4], 2
	mov	eax, DWORD PTR _failed$1$[ebp]
$LN27@xmlSchemat:

; 1648 :         ctxt->nberrors++;
; 1649 : 
; 1650 :     xmlSchematronReportSuccess(ctxt, test, cur, pattern, !failed);

	jne	SHORT $LN19@xmlSchemat
	inc	DWORD PTR [edi+12]
$LN19@xmlSchemat:
	xor	ebx, ebx
	test	eax, eax
	sete	bl
	push	ebx
	push	DWORD PTR _pattern$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _test$[ebp]
	push	edi
	call	_xmlSchematronReportSuccess
	add	esp, 20					; 00000014H

; 1651 : 
; 1652 :     return(!failed);

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 1653 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@xmlSchemat:
	DD	$LN16@xmlSchemat
	DD	$LN6@xmlSchemat
	DD	$LN9@xmlSchemat
	DD	$LN10@xmlSchemat
	DD	$LN13@xmlSchemat
	DD	$LN16@xmlSchemat
	DD	$LN16@xmlSchemat
	DD	$LN16@xmlSchemat
	DD	$LN16@xmlSchemat
	DD	$LN6@xmlSchemat
_xmlSchematronRunTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNextNode
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlSchematronNextNode PROC				; COMDAT

; 1556 : xmlSchematronNextNode(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN15@xmlSchemat

; 1557 :     if (cur->children != NULL) {
; 1558 : 	/*
; 1559 : 	 * Do not descend on entities declarations
; 1560 : 	 */
; 1561 : 	if (cur->children->type != XML_ENTITY_DECL) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, 17					; 00000011H
	je	SHORT $LN15@xmlSchemat

; 1562 : 	    cur = cur->children;

	mov	eax, ecx

; 1563 : 	    /*
; 1564 : 	     * Skip DTDs
; 1565 : 	     */
; 1566 : 	    if (cur->type != XML_DTD_NODE)

	cmp	edx, 14					; 0000000eH
	jne	SHORT $LN1@xmlSchemat
$LN15@xmlSchemat:

; 1567 : 		return(cur);
; 1568 : 	}
; 1569 :     }
; 1570 : 
; 1571 :     while (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlSchemat
	npad	3
$LL2@xmlSchemat:

; 1572 : 	cur = cur->next;

	mov	eax, ecx

; 1573 : 	if ((cur->type != XML_ENTITY_DECL) &&

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN25@xmlSchemat
	cmp	ecx, 14					; 0000000eH
	jne	SHORT $LN1@xmlSchemat
$LN25@xmlSchemat:

; 1567 : 		return(cur);
; 1568 : 	}
; 1569 :     }
; 1570 : 
; 1571 :     while (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LL2@xmlSchemat
$LL6@xmlSchemat:

; 1574 : 	    (cur->type != XML_DTD_NODE))
; 1575 : 	    return(cur);
; 1576 :     }
; 1577 : 
; 1578 :     do {
; 1579 : 	cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 1580 : 	if (cur == NULL) break;

	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 1581 : 	if (cur->type == XML_DOCUMENT_NODE) return(NULL);

	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN5@xmlSchemat

; 1582 : 	if (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlSchemat

; 1583 : 	    cur = cur->next;
; 1584 : 	    return(cur);

	mov	eax, ecx

; 1588 : }

	pop	ebp
	ret	0
$LN5@xmlSchemat:

; 1585 : 	}
; 1586 :     } while (cur != NULL);
; 1587 :     return(cur);

	xor	eax, eax
$LN1@xmlSchemat:

; 1588 : }

	pop	ebp
	ret	0
_xmlSchematronNextNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronReportPattern
_TEXT	SEGMENT
_msg$1 = -1000						; size = 1000
_ctxt$ = 8						; size = 4
_pattern$ = 12						; size = 4
_xmlSchematronReportPattern PROC			; COMDAT

; 1451 : 			   xmlSchematronPatternPtr pattern) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1000				; 000003e8H
	mov	ecx, OFFSET __D7D5901C_schematron@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemat

; 1452 :     if ((ctxt == NULL) || (pattern == NULL))

	mov	eax, DWORD PTR _pattern$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 1453 :         return;
; 1454 :     if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) || (ctxt->flags & XML_SCHEMATRON_OUT_ERROR)) /* Error gives pattern name as part of error */

	mov	ecx, DWORD PTR [esi+4]
	test	cl, 9
	jne	SHORT $LN5@xmlSchemat

; 1455 :         return;
; 1456 :     if (ctxt->flags & XML_SCHEMATRON_OUT_XML) {

	test	cl, 4
	je	SHORT $LN6@xmlSchemat

; 1457 :         TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1457					; 000005b1H
	push	OFFSET ??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi

; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlSchemat:

; 1458 :     } else {
; 1459 : 	char msg[1000];
; 1460 : 
; 1461 : 	if (pattern->name == NULL)

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 1462 : 	    return;
; 1463 : 	snprintf(msg, 999, "Pattern: %s\n", (const char *) pattern->name);

	push	eax
	push	OFFSET ??_C@_0N@IHDDKFAG@Pattern?3?5?$CFs?6@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	999					; 000003e7H
	push	eax
	call	_snprintf

; 1464 : 	xmlSchematronReportOutput(ctxt, NULL, &msg[0]);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	0
	push	esi
	call	_xmlSchematronReportOutput
	add	esp, 28					; 0000001cH
$LN5@xmlSchemat:
	pop	esi

; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronReportPattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronReportSuccess
_TEXT	SEGMENT
_msg$1 = -1012						; size = 1000
_schannel$1$ = -12					; size = 4
_data$1$ = -8						; size = 4
_line$1$ = -4						; size = 4
_report$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_test$ = 12						; size = 4
_cur$ = 16						; size = 4
_pattern$ = 20						; size = 4
_success$ = 24						; size = 4
_xmlSchematronReportSuccess PROC			; COMDAT

; 1371 : 		   xmlSchematronTestPtr test, xmlNodePtr cur, xmlSchematronPatternPtr pattern, int success) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1012				; 000003f4H
	mov	ecx, OFFSET __D7D5901C_schematron@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN8@xmlSchemat

; 1372 :     if ((ctxt == NULL) || (cur == NULL) || (test == NULL))

	push	edi
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN28@xmlSchemat
	mov	ecx, DWORD PTR _test$[ebp]
	test	ecx, ecx
	je	$LN28@xmlSchemat

; 1373 :         return;
; 1374 :     /* if quiet and not SVRL report only failures */
; 1375 :     if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) &&
; 1376 :         ((ctxt->flags & XML_SCHEMATRON_OUT_XML) == 0) &&

	mov	edx, DWORD PTR [esi+4]
	mov	eax, edx
	and	al, 5
	cmp	al, 1
	jne	SHORT $LN26@xmlSchemat
	cmp	DWORD PTR [ecx+4], 2
	je	$LN28@xmlSchemat
$LN26@xmlSchemat:

; 1377 : 	(test->type == XML_SCHEMATRON_REPORT))
; 1378 :         return;
; 1379 :     if (ctxt->flags & XML_SCHEMATRON_OUT_XML) {

	test	dl, 4
	je	SHORT $LN5@xmlSchemat

; 1380 :         TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1380					; 00000564H
	push	OFFSET ??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 1439 :     }
; 1440 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlSchemat:

; 1381 :     } else {
; 1382 :         xmlChar *path;
; 1383 : 	char msg[1000];
; 1384 : 	long line;
; 1385 : 	const xmlChar *report = NULL;
; 1386 : 
; 1387 :         if (((test->type == XML_SCHEMATRON_REPORT) & (!success)) ||

	mov	edx, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	edx, 2
	push	ebx
	mov	ebx, DWORD PTR _success$[ebp]
	sete	cl
	xor	eax, eax
	test	ebx, ebx
	sete	al
	test	ecx, eax
	jne	$LN29@xmlSchemat
	xor	eax, eax
	cmp	edx, 1
	sete	al
	test	eax, ebx
	jne	$LN29@xmlSchemat

; 1388 : 	    ((test->type == XML_SCHEMATRON_ASSERT) & (success)))
; 1389 : 	    return;
; 1390 : 	line = xmlGetLineNo(cur);

	push	edi
	call	_xmlGetLineNo

; 1391 : 	path = xmlGetNodePath(cur);

	push	edi
	mov	DWORD PTR _line$1$[ebp], eax
	call	_xmlGetNodePath
	mov	ebx, eax
	add	esp, 8

; 1392 : 	if (path == NULL)

	test	ebx, ebx
	jne	SHORT $LN27@xmlSchemat

; 1393 : 	    path = (xmlChar *) cur->name;

	mov	ebx, DWORD PTR [edi+8]
$LN27@xmlSchemat:

; 1394 : #if 0
; 1395 : 	if ((test->report != NULL) && (test->report[0] != 0))
; 1396 : 	    report = test->report;
; 1397 : #endif
; 1398 : 	if (test->node != NULL)

	mov	eax, DWORD PTR _test$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN25@xmlSchemat

; 1399 :             report = xmlSchematronFormatReport(ctxt, test->node, cur);

	push	edi
	push	ecx
	push	esi
	call	_xmlSchematronFormatReport
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _report$1$[ebp], eax

; 1400 : 	if (report == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlSchemat
	mov	eax, DWORD PTR _test$[ebp]
$LN25@xmlSchemat:

; 1401 : 	    if (test->type == XML_SCHEMATRON_ASSERT) {

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN12@xmlSchemat

; 1402 :             report = xmlStrdup((const xmlChar *) "node failed assert");

	push	OFFSET ??_C@_0BD@IJCBIFPI@node?5failed?5assert@

; 1403 : 	    } else {

	jmp	SHORT $LN30@xmlSchemat
$LN12@xmlSchemat:

; 1404 :             report = xmlStrdup((const xmlChar *) "node failed report");

	push	OFFSET ??_C@_0BD@CCIFHIJJ@node?5failed?5report@
$LN30@xmlSchemat:

; 1405 : 	    }
; 1406 : 	    }
; 1407 : 	    snprintf(msg, 999, "%s line %ld: %s\n", (const char *) path,

	call	_xmlStrdup
	mov	DWORD PTR _report$1$[ebp], eax
	add	esp, 4
$LN13@xmlSchemat:
	push	eax
	push	DWORD PTR _line$1$[ebp]
	lea	eax, DWORD PTR _msg$1[ebp]
	push	ebx
	push	OFFSET ??_C@_0BB@HNMKNBOB@?$CFs?5line?5?$CFld?3?5?$CFs?6@
	push	999					; 000003e7H
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H

; 1408 : 		     line, (const char *) report);
; 1409 : 
; 1410 :     if (ctxt->flags & XML_SCHEMATRON_OUT_ERROR) {

	test	BYTE PTR [esi+4], 8
	je	SHORT $LN14@xmlSchemat

; 1411 :         xmlStructuredErrorFunc schannel = NULL;
; 1412 :         xmlGenericErrorFunc channel = NULL;
; 1413 :         void *data = NULL;
; 1414 : 
; 1415 :         if (ctxt != NULL) {
; 1416 :             if (ctxt->serror != NULL)

	mov	eax, DWORD PTR [esi+60]
	xor	edx, edx
	mov	DWORD PTR _schannel$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN18@xmlSchemat

; 1417 :                 schannel = ctxt->serror;
; 1418 :             else
; 1419 :                 channel = ctxt->error;

	mov	edx, DWORD PTR [esi+52]
$LN18@xmlSchemat:

; 1420 :             data = ctxt->userData;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR _data$1$[ebp], eax

; 1421 : 	}
; 1422 : 
; 1423 :         __xmlRaiseError(schannel, channel, data,

	mov	eax, DWORD PTR _pattern$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlSchemat
$LN21@xmlSchemat:
	mov	eax, DWORD PTR [eax+8]
$LN22@xmlSchemat:
	mov	esi, DWORD PTR _report$1$[ebp]
	lea	ecx, DWORD PTR _msg$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _test$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	esi
	push	ebx
	push	eax
	push	DWORD PTR _line$1$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ecx+4], 1
	push	0
	push	2
	setne	al
	add	eax, 4000				; 00000fa0H
	push	eax
	push	28					; 0000001cH
	push	edi
	push	0
	push	DWORD PTR _data$1$[ebp]
	push	edx
	push	DWORD PTR _schannel$1$[ebp]
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1424 :                         NULL, cur, XML_FROM_SCHEMATRONV,
; 1425 :                         (test->type == XML_SCHEMATRON_ASSERT)?XML_SCHEMATRONV_ASSERT:XML_SCHEMATRONV_REPORT,
; 1426 :                         XML_ERR_ERROR, NULL, line,
; 1427 :                         (pattern == NULL)?NULL:((const char *) pattern->name),
; 1428 :                         (const char *) path,
; 1429 :                         (const char *) report, 0, 0,
; 1430 :                         "%s", msg);
; 1431 :     } else {

	jmp	SHORT $LN15@xmlSchemat
$LN14@xmlSchemat:

; 1432 : 	xmlSchematronReportOutput(ctxt, cur, &msg[0]);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	edi
	push	esi
	call	_xmlSchematronReportOutput
	mov	esi, DWORD PTR _report$1$[ebp]
	add	esp, 12					; 0000000cH
$LN15@xmlSchemat:

; 1433 :     }
; 1434 : 
; 1435 :     xmlFree((char *) report);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1436 : 
; 1437 : 	if ((path != NULL) && (path != (xmlChar *) cur->name))

	test	ebx, ebx
	je	SHORT $LN29@xmlSchemat
	cmp	ebx, DWORD PTR [edi+8]
	je	SHORT $LN29@xmlSchemat

; 1438 : 	    xmlFree(path);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN29@xmlSchemat:
	pop	ebx
$LN28@xmlSchemat:
	pop	edi
$LN8@xmlSchemat:
	pop	esi

; 1439 :     }
; 1440 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronReportSuccess ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFormatReport
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_path$1$ = 12						; size = 4
_test$ = 12						; size = 4
_cur$ = 16						; size = 4
_xmlSchematronFormatReport PROC				; COMDAT

; 1294 : 			  xmlNodePtr test, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _test$[ebp]
	xor	esi, esi
	test	ebx, ebx
	je	$LN7@xmlSchemat

; 1295 :     xmlChar *ret = NULL;
; 1296 :     xmlNodePtr child, node;
; 1297 : 
; 1298 :     if ((test == NULL) || (cur == NULL))

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN7@xmlSchemat

; 1299 :         return(ret);
; 1300 : 
; 1301 :     child = test->children;

	mov	ebx, DWORD PTR [ebx+12]

; 1302 :     while (child != NULL) {

	test	ebx, ebx
	je	$LN3@xmlSchemat
$LL2@xmlSchemat:

; 1303 :         if ((child->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 3
	je	$LN41@xmlSchemat
	cmp	eax, 4
	je	$LN41@xmlSchemat

; 1306 : 	else if (IS_SCHEMATRON(child, "name")) {

	cmp	eax, 1
	jne	$LN21@xmlSchemat
	cmp	DWORD PTR [ebx+36], 0
	je	$LN21@xmlSchemat
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN21@xmlSchemat
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlSchemat
	mov	eax, DWORD PTR [ebx+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN21@xmlSchemat
$LN13@xmlSchemat:

; 1307 : 	    xmlChar *path;
; 1308 : 
; 1309 : 	    path = xmlGetNoNsProp(child, BAD_CAST "path");

	push	OFFSET ??_C@_04LNEJFJGI@path@
	push	ebx
	call	_xmlGetNoNsProp
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _path$1$[ebp], edx

; 1310 : 
; 1311 :             node = cur;
; 1312 : 	    if (path != NULL) {

	test	edx, edx
	je	SHORT $LN14@xmlSchemat

; 1248 :     if ((ctxt == NULL) || (cur == NULL) || (xpath == NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN44@xmlSchemat

; 1249 :         return(NULL);
; 1250 : 
; 1251 :     ctxt->xctxt->doc = cur->doc;

	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx], eax

; 1252 :     ctxt->xctxt->node = cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+4], ecx

; 1253 :     ret = xmlXPathEval(xpath, ctxt->xctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+24]
	push	edx
	call	_xmlXPathEval
	mov	ecx, eax
	add	esp, 8

; 1254 :     if (ret == NULL)

	test	ecx, ecx
	je	SHORT $LN44@xmlSchemat

; 1255 :         return(NULL);
; 1256 : 
; 1257 :     if ((ret->type == XPATH_NODESET) &&
; 1258 :         (ret->nodesetval != NULL) && (ret->nodesetval->nodeNr > 0))

	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN30@xmlSchemat
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN30@xmlSchemat
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN30@xmlSchemat

; 1259 : 	node = ret->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax]
$LN30@xmlSchemat:

; 1260 : 
; 1261 :     xmlXPathFreeObject(ret);

	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1313 : 	        node = xmlSchematronGetNode(ctxt, cur, path);
; 1314 : 		if (node == NULL)

	test	edi, edi
	jne	SHORT $LN15@xmlSchemat
$LN44@xmlSchemat:

; 1315 : 		    node = cur;

	mov	edi, DWORD PTR _cur$[ebp]
$LN15@xmlSchemat:

; 1316 : 		xmlFree(path);

	push	DWORD PTR _path$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlSchemat:

; 1317 : 	    }
; 1318 : 
; 1319 : 	    if ((node->ns == NULL) || (node->ns->prefix == NULL))

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN18@xmlSchemat
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN18@xmlSchemat

; 1320 : 	        ret = xmlStrcat(ret, node->name);
; 1321 : 	    else {
; 1322 : 	        ret = xmlStrcat(ret, node->ns->prefix);

	push	eax
	push	esi
	call	_xmlStrcat

; 1323 : 	        ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	eax
	call	_xmlStrcat
	add	esp, 16					; 00000010H

; 1324 : 	        ret = xmlStrcat(ret, node->name);

	mov	esi, eax
$LN18@xmlSchemat:

; 1325 : 	    }
; 1326 : 	} else {

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN12@xmlSchemat
$LN41@xmlSchemat:

; 1304 : 	    (child->type == XML_CDATA_SECTION_NODE))
; 1305 : 	    ret = xmlStrcat(ret, child->content);

	mov	eax, DWORD PTR [ebx+40]
$LN12@xmlSchemat:

; 1327 : 	    child = child->next;
; 1328 : 	    continue;
; 1329 : 	}
; 1330 : 
; 1331 : 	/*
; 1332 : 	 * remove superfluous \n
; 1333 : 	 */
; 1334 : 	if (ret != NULL) {

	push	eax
	push	esi
	call	_xmlStrcat
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN21@xmlSchemat

; 1335 : 	    int len = xmlStrlen(ret);

	push	esi
	call	_xmlStrlen
	add	esp, 4

; 1336 : 	    xmlChar c;
; 1337 : 
; 1338 : 	    if (len > 0) {

	test	eax, eax
	jle	SHORT $LN21@xmlSchemat

; 1339 : 		c = ret[len - 1];

	mov	cl, BYTE PTR [esi+eax-1]

; 1340 : 		if ((c == ' ') || (c == '\n') || (c == '\r') || (c == '\t')) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN23@xmlSchemat
	cmp	cl, 10					; 0000000aH
	je	SHORT $LL4@xmlSchemat
	cmp	cl, 13					; 0000000dH
	je	SHORT $LL4@xmlSchemat
	cmp	cl, 9
	jne	SHORT $LN21@xmlSchemat
	npad	7
$LL4@xmlSchemat:

; 1341 : 		    while ((c == ' ') || (c == '\n') ||
; 1342 : 		           (c == '\r') || (c == '\t')) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN23@xmlSchemat
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN23@xmlSchemat
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN23@xmlSchemat
	cmp	cl, 9
	jne	SHORT $LN35@xmlSchemat
$LN23@xmlSchemat:

; 1343 : 			len--;

	sub	eax, 1

; 1344 : 			if (len == 0)

	je	SHORT $LN35@xmlSchemat

; 1345 : 			    break;
; 1346 : 			c = ret[len - 1];

	mov	cl, BYTE PTR [esi+eax-1]

; 1347 : 		    }

	jmp	SHORT $LL4@xmlSchemat
$LN35@xmlSchemat:

; 1348 : 		    ret[len] = ' ';

	mov	WORD PTR [esi+eax], 32			; 00000020H
$LN21@xmlSchemat:

; 1302 :     while (child != NULL) {

	mov	eax, DWORD PTR [ebx+24]
	mov	ebx, eax
	test	eax, eax
	jne	$LL2@xmlSchemat
$LN3@xmlSchemat:
	pop	edi

; 1349 : 		    ret[len + 1] = 0;
; 1350 : 		}
; 1351 : 	    }
; 1352 : 	}
; 1353 : 
; 1354 :         child = child->next;
; 1355 :     }
; 1356 :     return(ret);

	mov	eax, esi

; 1357 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlSchematronFormatReport ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronReportOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlSchematronReportOutput PROC				; COMDAT

; 1276 :                           const char *msg) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1277 :     /* TODO */
; 1278 :     fprintf(stderr, "%s", msg);
; 1279 : }

	pop	ebp
	ret	0
_xmlSchematronReportOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronGetNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xpath$ = 16						; size = 4
_xmlSchematronGetNode PROC				; COMDAT

; 1244 :                      xmlNodePtr cur, const xmlChar *xpath) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	test	edx, edx
	je	SHORT $LN3@xmlSchemat

; 1245 :     xmlNodePtr node = NULL;
; 1246 :     xmlXPathObjectPtr ret;
; 1247 : 
; 1248 :     if ((ctxt == NULL) || (cur == NULL) || (xpath == NULL))

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlSchemat
	cmp	DWORD PTR _xpath$[ebp], esi
	je	SHORT $LN3@xmlSchemat

; 1250 : 
; 1251 :     ctxt->xctxt->doc = cur->doc;

	mov	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [ecx], eax

; 1252 :     ctxt->xctxt->node = cur;

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [eax+4], edi

; 1253 :     ret = xmlXPathEval(xpath, ctxt->xctxt);

	push	DWORD PTR [edx+24]
	push	DWORD PTR _xpath$[ebp]
	call	_xmlXPathEval
	mov	ecx, eax
	add	esp, 8

; 1254 :     if (ret == NULL)

	test	ecx, ecx
	je	SHORT $LN3@xmlSchemat

; 1255 :         return(NULL);
; 1256 : 
; 1257 :     if ((ret->type == XPATH_NODESET) &&
; 1258 :         (ret->nodesetval != NULL) && (ret->nodesetval->nodeNr > 0))

	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN5@xmlSchemat
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN5@xmlSchemat

; 1259 : 	node = ret->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax]
$LN5@xmlSchemat:

; 1260 : 
; 1261 :     xmlXPathFreeObject(ret);

	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1262 :     return(node);

	mov	eax, esi
	pop	edi

; 1263 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSchemat:
	pop	edi

; 1249 :         return(NULL);

	xor	eax, eax

; 1263 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSchematronGetNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronParsePattern
_TEXT	SEGMENT
_nbRules$1$ = -4					; size = 4
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_pat$ = 12						; size = 4
_xmlSchematronParsePattern PROC				; COMDAT

; 960  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _nbRules$1$[ebp], 0
	test	edi, edi
	je	SHORT $LN9@xmlSchemat

; 961  :     xmlNodePtr cur;
; 962  :     xmlSchematronPatternPtr pattern;
; 963  :     int nbRules = 0;
; 964  :     xmlChar *id;
; 965  : 
; 966  :     if ((ctxt == NULL) || (pat == NULL)) return;

	push	ebx
	mov	ebx, DWORD PTR _pat$[ebp]
	test	ebx, ebx
	je	SHORT $LN75@xmlSchemat

; 967  : 
; 968  :     id = xmlGetNoNsProp(pat, BAD_CAST "id");

	push	esi
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	ebx
	call	_xmlGetNoNsProp
	mov	esi, eax
	add	esp, 8

; 969  :     if (id == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlSchemat

; 970  : 	id = xmlGetNoNsProp(pat, BAD_CAST "name");

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	ebx
	call	_xmlGetNoNsProp
	add	esp, 8
	mov	esi, eax
$LN10@xmlSchemat:

; 971  :     }
; 972  :     pattern = xmlSchematronAddPattern(ctxt, ctxt->schema, pat, id);

	mov	ebx, DWORD PTR [edi+40]

; 489  :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) || (name == NULL))

	test	ebx, ebx
	je	SHORT $LN51@xmlSchemat
	test	esi, esi
	je	SHORT $LN76@xmlSchemat

; 490  :         return(NULL);
; 491  : 
; 492  :     ret = (xmlSchematronPatternPtr) xmlMalloc(sizeof(xmlSchematronPattern));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 493  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN27@xmlSchemat

; 494  :         xmlSchematronPErrMemory(ctxt, "allocating schema pattern", node);

	push	DWORD PTR _pat$[ebp]
	push	OFFSET ??_C@_0BK@KCAFICNM@allocating?5schema?5pattern@
	push	edi
	call	_xmlSchematronPErrMemory
	add	esp, 12					; 0000000cH
$LN51@xmlSchemat:

; 973  :     if (pattern == NULL) {
; 974  : 	if (id != NULL)

	test	esi, esi
	je	SHORT $LN76@xmlSchemat

; 975  : 	    xmlFree(id);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN76@xmlSchemat:
	pop	esi
$LN75@xmlSchemat:
	pop	ebx
$LN9@xmlSchemat:
	pop	edi

; 994  : 	    XML_SCHEMAP_NOROOT,
; 995  : 	    "Pattern has no rule element", NULL, NULL);
; 996  :     }
; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlSchemat:

; 497  :     memset(ret, 0, sizeof(xmlSchematronPattern));

	mov	DWORD PTR [eax+4], 0

; 498  :     ret->name = name;

	mov	DWORD PTR [eax+8], esi

; 499  :     ret->next = NULL;

	mov	DWORD PTR [eax], 0

; 500  :     if (schema->patterns == NULL) {

	mov	edx, DWORD PTR [ebx+36]
	test	edx, edx
	jne	SHORT $LN28@xmlSchemat

; 501  : 	schema->patterns = ret;

	mov	DWORD PTR [ebx+36], eax

; 502  :     } else {

	jmp	SHORT $LN11@xmlSchemat
$LN28@xmlSchemat:

; 503  :         xmlSchematronPatternPtr prev = schema->patterns;
; 504  : 
; 505  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN24@xmlSchemat
	npad	1
$LL23@xmlSchemat:
	mov	eax, DWORD PTR [ecx]

; 506  : 	     prev = prev->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL23@xmlSchemat
	mov	eax, DWORD PTR _ret$1$[ebp]
$LN24@xmlSchemat:

; 507  :         prev->next = ret;

	mov	DWORD PTR [edx], eax
$LN11@xmlSchemat:

; 976  :         return;
; 977  :     }
; 978  :     cur = pat->children;

	mov	ebx, DWORD PTR _pat$[ebp]
	mov	esi, DWORD PTR [ebx+12]

; 979  :     NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	$LN63@xmlSchemat
	npad	3
$LL2@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN13@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN13@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
$LN13@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemat
	jmp	$LN63@xmlSchemat
$LL4@xmlSchemat:

; 980  :     while (cur != NULL) {
; 981  : 	if (IS_SCHEMATRON(cur, "rule")) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN15@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN15@xmlSchemat
	push	OFFSET ??_C@_04LPGJEGEF@rule@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlSchemat
$LN17@xmlSchemat:

; 982  : 	    xmlSchematronParseRule(ctxt, pattern, cur);

	push	esi
	push	DWORD PTR _ret$1$[ebp]
	push	edi
	call	_xmlSchematronParseRule

; 983  : 	    nbRules++;

	mov	ebx, DWORD PTR _nbRules$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	ebx
	mov	DWORD PTR _nbRules$1$[ebp], ebx

; 984  : 	} else {

	jmp	SHORT $LN31@xmlSchemat
$LN15@xmlSchemat:

; 985  : 	    xmlSchematronPErr(ctxt, cur,

	mov	eax, DWORD PTR [esi+8]

; 262  :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	push	0
	push	eax
	push	OFFSET ??_C@_0CH@HMMHEKDJ@Expecting?5a?5rule?5element?5instea@
	push	0
	push	0
	push	0
	push	0
	push	eax
	inc	DWORD PTR [edi+28]
	push	0
	push	0
	push	2
	push	1759					; 000006dfH
	push	16					; 00000010H
	push	esi
	push	edi
	push	DWORD PTR [edi+68]
	push	DWORD PTR [edi+72]
	push	DWORD PTR [edi+80]
	call	___xmlRaiseError
	mov	ebx, DWORD PTR _nbRules$1$[ebp]
	add	esp, 72					; 00000048H
$LN31@xmlSchemat:

; 986  : 		XML_SCHEMAP_NOROOT,
; 987  : 		"Expecting a rule element instead of %s", cur->name, NULL);
; 988  : 	}
; 989  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 990  : 	NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	SHORT $LN66@xmlSchemat
	npad	3
$LL6@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN18@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN18@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL4@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL4@xmlSchemat
$LN18@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL6@xmlSchemat
$LN66@xmlSchemat:

; 991  :     }
; 992  :     if (nbRules == 0) {

	test	ebx, ebx
	jne	$LN76@xmlSchemat
	mov	ebx, DWORD PTR _pat$[ebp]
$LN63@xmlSchemat:

; 993  : 	xmlSchematronPErr(ctxt, pat,

	push	0
	push	0
	push	OFFSET ??_C@_0BM@HPHJEBHK@Pattern?5has?5no?5rule?5element@
	push	1759					; 000006dfH
	push	ebx
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebx
	pop	edi

; 994  : 	    XML_SCHEMAP_NOROOT,
; 995  : 	    "Pattern has no rule element", NULL, NULL);
; 996  :     }
; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronParsePattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronParseRule
_TEXT	SEGMENT
_pattern$1$ = -8					; size = 4
_nbChecks$1$ = -4					; size = 4
_ret$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_pattern$ = 12						; size = 4
_rule$ = 16						; size = 4
_xmlSchematronParseRule PROC				; COMDAT

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _nbChecks$1$[ebp], eax
	test	ebx, ebx
	je	$LN9@xmlSchemat

; 853  :     xmlNodePtr cur;
; 854  :     int nbChecks = 0;
; 855  :     xmlChar *test;
; 856  :     xmlChar *context;
; 857  :     xmlChar *report;
; 858  :     xmlSchematronRulePtr ruleptr;
; 859  :     xmlSchematronTestPtr testptr;
; 860  : 
; 861  :     if ((ctxt == NULL) || (rule == NULL)) return;

	push	edi
	mov	edi, DWORD PTR _rule$[ebp]
	test	edi, edi
	je	$LN95@xmlSchemat

; 862  : 
; 863  :     context = xmlGetNoNsProp(rule, BAD_CAST "context");

	push	esi
	push	OFFSET ??_C@_07JKKCBBMM@context@
	push	edi
	call	_xmlGetNoNsProp
	mov	esi, eax
	add	esp, 8

; 864  :     if (context == NULL) {

	test	esi, esi
	jne	SHORT $LN10@xmlSchemat

; 865  : 	xmlSchematronPErr(ctxt, rule,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BO@OOKBPBKF@rule?5has?5no?5context?5attribute@
	push	1759					; 000006dfH
	push	edi
	push	ebx
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi
	pop	ebx

; 946  : 	    XML_SCHEMAP_NOROOT,
; 947  : 	    "rule has no assert nor report element", NULL, NULL);
; 948  :     }
; 949  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSchemat:

; 866  : 	    XML_SCHEMAP_NOROOT,
; 867  : 	    "rule has no context attribute",
; 868  : 	    NULL, NULL);
; 869  : 	return;
; 870  :     } else if (context[0] == 0) {

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN12@xmlSchemat

; 871  : 	xmlSchematronPErr(ctxt, rule,

	push	0
	push	0
	push	OFFSET ??_C@_0CE@PPHKJDMN@rule?5has?5an?5empty?5context?5attri@
	push	1759					; 000006dfH
	push	edi
	push	ebx
	call	_xmlSchematronPErr

; 872  : 	    XML_SCHEMAP_NOROOT,
; 873  : 	    "rule has an empty context attribute",
; 874  : 	    NULL, NULL);
; 875  : 	xmlFree(context);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH
	pop	esi
	pop	edi
	pop	ebx

; 946  : 	    XML_SCHEMAP_NOROOT,
; 947  : 	    "rule has no assert nor report element", NULL, NULL);
; 948  :     }
; 949  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSchemat:

; 876  : 	return;
; 877  :     } else {
; 878  : 	ruleptr = xmlSchematronAddRule(ctxt, ctxt->schema, pattern,

	mov	edi, DWORD PTR [ebx+40]

; 398  :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||

	test	edi, edi
	je	SHORT $LN73@xmlSchemat

; 399  :         (context == NULL))
; 400  :         return(NULL);
; 401  : 
; 402  :     /*
; 403  :      * Try first to compile the pattern
; 404  :      */
; 405  :     pattern = xmlPatterncompile(context, ctxt->dict, XML_PATTERN_XPATH,

	push	DWORD PTR [ebx+52]
	push	1
	push	DWORD PTR [ebx+24]
	push	esi
	call	_xmlPatterncompile
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pattern$1$[ebp], eax

; 406  :                                 ctxt->namespaces);
; 407  :     if (pattern == NULL) {

	test	eax, eax
	jne	SHORT $LN44@xmlSchemat

; 408  : 	xmlSchematronPErr(ctxt, node,

	push	eax
	push	esi
	push	OFFSET ??_C@_0CI@BJKODKAC@Failed?5to?5compile?5context?5expre@
	push	1759					; 000006dfH
	push	DWORD PTR _rule$[ebp]
	push	ebx
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN44@xmlSchemat:

; 409  : 	    XML_SCHEMAP_NOROOT,
; 410  : 	    "Failed to compile context expression %s",
; 411  : 	    context, NULL);
; 412  :     }
; 413  : 
; 414  :     ret = (xmlSchematronRulePtr) xmlMalloc(sizeof(xmlSchematronRule));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], ecx

; 415  :     if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN45@xmlSchemat

; 416  :         xmlSchematronPErrMemory(ctxt, "allocating schema rule", node);

	push	DWORD PTR _rule$[ebp]
	push	OFFSET ??_C@_0BH@NOHOGEKI@allocating?5schema?5rule@
	push	ebx
	call	_xmlSchematronPErrMemory
	add	esp, 12					; 0000000cH
$LN73@xmlSchemat:

; 879  : 	                               rule, context, NULL);
; 880  : 	if (ruleptr == NULL) {
; 881  : 	    xmlFree(context);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN96@xmlSchemat:
	pop	esi
$LN95@xmlSchemat:
	pop	edi
$LN9@xmlSchemat:
	pop	ebx

; 946  : 	    XML_SCHEMAP_NOROOT,
; 947  : 	    "rule has no assert nor report element", NULL, NULL);
; 948  :     }
; 949  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlSchemat:

; 420  :     ret->node = node;

	mov	eax, DWORD PTR _rule$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+8], eax

; 421  :     ret->context = context;
; 422  :     ret->pattern = pattern;

	mov	eax, DWORD PTR _pattern$1$[ebp]
	mov	DWORD PTR [ecx+12], esi
	mov	DWORD PTR [ecx+20], eax

; 423  :     ret->report = report;

	mov	DWORD PTR [ecx+24], 0

; 424  :     ret->next = NULL;

	mov	DWORD PTR [ecx], 0

; 425  :     if (schema->rules == NULL) {

	mov	edx, DWORD PTR [edi+40]
	test	edx, edx
	jne	SHORT $LN46@xmlSchemat

; 426  : 	schema->rules = ret;

	mov	DWORD PTR [edi+40], ecx

; 427  :     } else {

	jmp	SHORT $LN47@xmlSchemat
$LN46@xmlSchemat:

; 428  :         xmlSchematronRulePtr prev = schema->rules;
; 429  : 
; 430  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN39@xmlSchemat
$LL38@xmlSchemat:
	mov	eax, DWORD PTR [ecx]

; 431  : 	     prev = prev->next;

	mov	edx, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL38@xmlSchemat
$LN39@xmlSchemat:

; 432  :         prev->next = ret;

	mov	ecx, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [edx], ecx
$LN47@xmlSchemat:

; 433  :     }
; 434  :     ret->patnext = NULL;
; 435  :     if (pat->rules == NULL) {

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN48@xmlSchemat

; 436  : 	pat->rules = ret;

	mov	edx, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [eax+4], edx

; 437  :     } else {

	jmp	SHORT $LN14@xmlSchemat
$LN48@xmlSchemat:

; 438  :         xmlSchematronRulePtr prev = pat->rules;
; 439  : 
; 440  : 	while (prev->patnext != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN41@xmlSchemat
$LL40@xmlSchemat:

; 441  : 	     prev = prev->patnext;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LL40@xmlSchemat
$LN41@xmlSchemat:

; 442  :         prev->patnext = ret;

	mov	edx, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN14@xmlSchemat:

; 882  : 	    return;
; 883  : 	}
; 884  :     }
; 885  : 
; 886  :     cur = rule->children;

	mov	esi, DWORD PTR _rule$[ebp]
	mov	esi, DWORD PTR [esi+12]

; 887  :     NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	$LN83@xmlSchemat
	npad	1
$LL2@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN15@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN15@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
$LN15@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemat
	jmp	$LN83@xmlSchemat
$LL4@xmlSchemat:

; 888  :     while (cur != NULL) {
; 889  : 	if (IS_SCHEMATRON(cur, "assert")) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN25@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	$LN17@xmlSchemat
	push	OFFSET ??_C@_06GMEIIFFN@assert@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN17@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlSchemat
$LN19@xmlSchemat:

; 890  : 	    nbChecks++;

	inc	DWORD PTR _nbChecks$1$[ebp]

; 891  : 	    test = xmlGetNoNsProp(cur, BAD_CAST "test");

	push	OFFSET ??_C@_04CEJDCDCH@test@
	push	esi
	call	_xmlGetNoNsProp
	mov	edi, eax
	add	esp, 8

; 892  : 	    if (test == NULL) {

	test	edi, edi
	jne	SHORT $LN20@xmlSchemat

; 893  : 		xmlSchematronPErr(ctxt, cur,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BN@CLPNCGJA@assert?5has?5no?5test?5attribute@
	jmp	$LN98@xmlSchemat
$LN20@xmlSchemat:

; 894  : 		    XML_SCHEMAP_NOROOT,
; 895  : 		    "assert has no test attribute",
; 896  : 		    NULL, NULL);
; 897  : 	    } else if (test[0] == 0) {

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN22@xmlSchemat
$LN100@xmlSchemat:

; 937  : 		XML_SCHEMAP_NOROOT,
; 938  : 		"Expecting an assert or a report element instead of %s",
; 939  : 		cur->name, NULL);
; 940  : 	}
; 941  : 	cur = cur->next;

	push	0
	push	0
	push	OFFSET ??_C@_0CD@COBAHICO@assert?5has?5an?5empty?5test?5attrib@
	push	1759					; 000006dfH
	push	esi
	push	ebx
	call	_xmlSchematronPErr
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH
	jmp	$LN26@xmlSchemat
$LN22@xmlSchemat:

; 898  : 		xmlSchematronPErr(ctxt, cur,
; 899  : 		    XML_SCHEMAP_NOROOT,
; 900  : 		    "assert has an empty test attribute",
; 901  : 		    NULL, NULL);
; 902  : 		xmlFree(test);
; 903  : 	    } else {
; 904  : 		/* TODO will need dynamic processing instead */
; 905  : 		report = xmlNodeGetContent(cur);

	push	esi
	call	_xmlNodeGetContent

; 906  : 
; 907  : 		testptr = xmlSchematronAddTest(ctxt, XML_SCHEMATRON_ASSERT,

	push	eax
	push	edi
	push	esi
	push	DWORD PTR _ret$1$[ebp]
	push	1

; 908  : 		                               ruleptr, cur, test, report);
; 909  : 		if (testptr == NULL)
; 910  : 		    xmlFree(test);
; 911  : 	    }

	jmp	$LN99@xmlSchemat
$LN17@xmlSchemat:

; 912  : 	} else if (IS_SCHEMATRON(cur, "report")) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN25@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	$LN25@xmlSchemat
	push	OFFSET ??_C@_06MHOMHIDM@report@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN25@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlSchemat
$LN27@xmlSchemat:

; 913  : 	    nbChecks++;

	inc	DWORD PTR _nbChecks$1$[ebp]

; 914  : 	    test = xmlGetNoNsProp(cur, BAD_CAST "test");

	push	OFFSET ??_C@_04CEJDCDCH@test@
	push	esi
	call	_xmlGetNoNsProp
	mov	edi, eax
	add	esp, 8

; 915  : 	    if (test == NULL) {

	test	edi, edi
	jne	SHORT $LN28@xmlSchemat

; 916  : 		xmlSchematronPErr(ctxt, cur,

	push	eax
	push	eax
	push	OFFSET ??_C@_0BN@CLPNCGJA@assert?5has?5no?5test?5attribute@
	jmp	SHORT $LN98@xmlSchemat
$LN28@xmlSchemat:

; 917  : 		    XML_SCHEMAP_NOROOT,
; 918  : 		    "assert has no test attribute",
; 919  : 		    NULL, NULL);
; 920  : 	    } else if (test[0] == 0) {

	cmp	BYTE PTR [edi], 0
	je	$LN100@xmlSchemat

; 921  : 		xmlSchematronPErr(ctxt, cur,
; 922  : 		    XML_SCHEMAP_NOROOT,
; 923  : 		    "assert has an empty test attribute",
; 924  : 		    NULL, NULL);
; 925  : 		xmlFree(test);
; 926  : 	    } else {
; 927  : 		/* TODO will need dynamic processing instead */
; 928  : 		report = xmlNodeGetContent(cur);

	push	esi
	call	_xmlNodeGetContent

; 929  : 
; 930  : 		testptr = xmlSchematronAddTest(ctxt, XML_SCHEMATRON_REPORT,

	push	eax
	push	edi
	push	esi
	push	DWORD PTR _ret$1$[ebp]
	push	2
$LN99@xmlSchemat:

; 937  : 		XML_SCHEMAP_NOROOT,
; 938  : 		"Expecting an assert or a report element instead of %s",
; 939  : 		cur->name, NULL);
; 940  : 	}
; 941  : 	cur = cur->next;

	push	ebx
	call	_xmlSchematronAddTest
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN26@xmlSchemat
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN26@xmlSchemat
$LN25@xmlSchemat:

; 931  : 		                               ruleptr, cur, test, report);
; 932  : 		if (testptr == NULL)
; 933  : 		    xmlFree(test);
; 934  : 	    }
; 935  : 	} else {
; 936  : 	    xmlSchematronPErr(ctxt, cur,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0DG@GPEPPHEL@Expecting?5an?5assert?5or?5a?5report@
$LN98@xmlSchemat:

; 937  : 		XML_SCHEMAP_NOROOT,
; 938  : 		"Expecting an assert or a report element instead of %s",
; 939  : 		cur->name, NULL);
; 940  : 	}
; 941  : 	cur = cur->next;

	push	1759					; 000006dfH
	push	esi
	push	ebx
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN26@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]

; 942  : 	NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	SHORT $LN86@xmlSchemat
	npad	3
$LL6@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN33@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN33@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL4@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL4@xmlSchemat
$LN33@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL6@xmlSchemat
$LN86@xmlSchemat:

; 943  :     }
; 944  :     if (nbChecks == 0) {

	cmp	DWORD PTR _nbChecks$1$[ebp], 0
	jne	$LN96@xmlSchemat
$LN83@xmlSchemat:

; 945  : 	xmlSchematronPErr(ctxt, rule,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@GJJAJNIB@rule?5has?5no?5assert?5nor?5report?5e@
	push	1759					; 000006dfH
	push	DWORD PTR _rule$[ebp]
	push	ebx
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi
	pop	ebx

; 946  : 	    XML_SCHEMAP_NOROOT,
; 947  : 	    "rule has no assert nor report element", NULL, NULL);
; 948  :     }
; 949  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronParseRule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronAddNamespace
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlSchematronAddNamespace PROC				; COMDAT

; 806  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [esi+52]
	test	edx, edx
	jne	SHORT $LN2@xmlSchemat

; 807  :     if (ctxt->namespaces == NULL) {
; 808  :         ctxt->maxNamespaces = 10;

	push	80					; 00000050H
	mov	DWORD PTR [esi+48], 10			; 0000000aH

; 809  :         ctxt->namespaces = (const xmlChar **)

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+52], eax

; 810  : 	    xmlMalloc(ctxt->maxNamespaces * 2 * sizeof(const xmlChar *));
; 811  : 	if (ctxt->namespaces == NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlSchemat

; 812  : 	    xmlSchematronPErrMemory(NULL, "allocating parser namespaces",
; 813  : 				    NULL);
; 814  : 	    return;
; 815  : 	}
; 816  :         ctxt->nbNamespaces = 0;

	mov	DWORD PTR [esi+44], 0
	jmp	SHORT $LN5@xmlSchemat
$LN2@xmlSchemat:

; 817  :     } else if (ctxt->nbNamespaces + 2 >= ctxt->maxNamespaces) {

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+48]
	add	eax, 2
	cmp	eax, ecx
	jl	SHORT $LN5@xmlSchemat

; 818  :         const xmlChar **tmp;
; 819  : 
; 820  : 	tmp = (const xmlChar **)

	shl	ecx, 4
	push	ecx
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 821  : 	    xmlRealloc((xmlChar **) ctxt->namespaces, ctxt->maxNamespaces * 4 *
; 822  : 	               sizeof(const xmlChar *));
; 823  : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemat
$LN14@xmlSchemat:

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BN@GJJHFKFH@allocating?5parser?5namespaces@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	esi

; 838  : 
; 839  : }

	pop	ebp
	ret	0
$LN6@xmlSchemat:

; 824  : 	    xmlSchematronPErrMemory(NULL, "allocating parser namespaces",
; 825  : 				    NULL);
; 826  : 	    return;
; 827  : 	}
; 828  :         ctxt->namespaces = tmp;

	mov	DWORD PTR [esi+52], eax

; 829  : 	ctxt->maxNamespaces *= 2;

	mov	eax, DWORD PTR [esi+48]
	add	eax, eax
	mov	DWORD PTR [esi+48], eax
$LN5@xmlSchemat:

; 830  :     }
; 831  :     ctxt->namespaces[2 * ctxt->nbNamespaces] =

	push	-1
	push	DWORD PTR _ns$[ebp]
	push	DWORD PTR [esi+24]
	call	_xmlDictLookup
	mov	edx, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+52]

; 832  :         xmlDictLookup(ctxt->dict, ns, -1);
; 833  :     ctxt->namespaces[2 * ctxt->nbNamespaces + 1] =

	push	-1
	push	DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx+edx*8], eax
	push	DWORD PTR [esi+24]
	call	_xmlDictLookup
	mov	edx, DWORD PTR [esi+44]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 834  :         xmlDictLookup(ctxt->dict, prefix, -1);
; 835  :     ctxt->nbNamespaces++;

	inc	DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+44]

; 836  :     ctxt->namespaces[2 * ctxt->nbNamespaces] = NULL;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+ecx*8], 0

; 837  :     ctxt->namespaces[2 * ctxt->nbNamespaces + 1] = NULL;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+52]
	pop	esi
	mov	DWORD PTR [eax+ecx*8+4], 0

; 838  : 
; 839  : }

	pop	ebp
	ret	0
_xmlSchematronAddNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNewSchematron
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchematronNewSchematron PROC			; COMDAT

; 541  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlSchemat

; 231  :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 232  :         ctxt->nberrors++;

	inc	DWORD PTR [eax+28]
$LN5@xmlSchemat:

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@BFLACGOA@allocating?5schema@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 542  :     xmlSchematronPtr ret;
; 543  : 
; 544  :     ret = (xmlSchematronPtr) xmlMalloc(sizeof(xmlSchematron));
; 545  :     if (ret == NULL) {
; 546  :         xmlSchematronPErrMemory(ctxt, "allocating schema", NULL);
; 547  :         return (NULL);

	xor	eax, eax
	pop	esi

; 554  : }

	pop	ebp
	ret	0
$LN2@xmlSchemat:

; 548  :     }
; 549  :     memset(ret, 0, sizeof(xmlSchematron));

	push	56					; 00000038H
	push	0
	push	esi
	call	_memset

; 550  :     ret->dict = ctxt->dict;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 551  :     xmlDictReference(ret->dict);

	push	eax
	mov	DWORD PTR [esi+20], eax
	call	_xmlDictReference
	add	esp, 16					; 00000010H

; 552  : 
; 553  :     return (ret);

	mov	eax, esi
	pop	esi

; 554  : }

	pop	ebp
	ret	0
_xmlSchematronNewSchematron ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFreePatterns
_TEXT	SEGMENT
_patterns$ = 8						; size = 4
_xmlSchematronFreePatterns PROC				; COMDAT

; 519  : xmlSchematronFreePatterns(xmlSchematronPatternPtr patterns) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _patterns$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemat
	push	edi
$LL2@xmlSchemat:

; 520  :     xmlSchematronPatternPtr next;
; 521  : 
; 522  :     while (patterns != NULL) {
; 523  :         next = patterns->next;
; 524  : 	if (patterns->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSchemat

; 525  : 	    xmlFree(patterns->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemat:

; 526  : 	xmlFree(patterns);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 527  : 	patterns = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlSchemat
	pop	edi
$LN3@xmlSchemat:
	pop	esi

; 528  :     }
; 529  : }

	pop	ebp
	ret	0
_xmlSchematronFreePatterns ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronAddPattern
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_node$ = 16						; size = 4
_name$ = 20						; size = 4
_xmlSchematronAddPattern PROC				; COMDAT

; 486  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN5@xmlSchemat

; 487  :     xmlSchematronPatternPtr ret;
; 488  : 
; 489  :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) || (name == NULL))

	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSchemat
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlSchemat
	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN5@xmlSchemat

; 491  : 
; 492  :     ret = (xmlSchematronPatternPtr) xmlMalloc(sizeof(xmlSchematronPattern));

	push	esi
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 493  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlSchemat

; 494  :         xmlSchematronPErrMemory(ctxt, "allocating schema pattern", node);

	push	DWORD PTR _node$[ebp]
	push	OFFSET ??_C@_0BK@KCAFICNM@allocating?5schema?5pattern@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSchematronPErrMemory
	add	esp, 12					; 0000000cH

; 495  :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 510  : }

	pop	ebp
	ret	0
$LN6@xmlSchemat:

; 496  :     }
; 497  :     memset(ret, 0, sizeof(xmlSchematronPattern));
; 498  :     ret->name = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], eax

; 499  :     ret->next = NULL;

	mov	DWORD PTR [esi], 0

; 500  :     if (schema->patterns == NULL) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LN7@xmlSchemat

; 501  : 	schema->patterns = ret;

	mov	DWORD PTR [edi+36], esi

; 508  :     }
; 509  :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 510  : }

	pop	ebp
	ret	0
$LN7@xmlSchemat:

; 502  :     } else {
; 503  :         xmlSchematronPatternPtr prev = schema->patterns;
; 504  : 
; 505  : 	while (prev->next != NULL)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN3@xmlSchemat
	npad	5
$LL2@xmlSchemat:
	mov	ecx, DWORD PTR [edx]

; 506  : 	     prev = prev->next;

	mov	eax, edx
	mov	edx, ecx
	test	ecx, ecx
	jne	SHORT $LL2@xmlSchemat
$LN3@xmlSchemat:

; 507  :         prev->next = ret;

	mov	DWORD PTR [eax], esi

; 508  :     }
; 509  :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 510  : }

	pop	ebp
	ret	0
$LN5@xmlSchemat:

; 490  :         return(NULL);

	xor	eax, eax
	pop	edi

; 510  : }

	pop	ebp
	ret	0
_xmlSchematronAddPattern ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFreeRules
_TEXT	SEGMENT
_next$1$ = 8						; size = 4
_rules$ = 8						; size = 4
_xmlSchematronFreeRules PROC				; COMDAT

; 454  : xmlSchematronFreeRules(xmlSchematronRulePtr rules) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _rules$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemat
	push	esi
	push	edi
	npad	5
$LL2@xmlSchemat:

; 455  :     xmlSchematronRulePtr next;
; 456  : 
; 457  :     while (rules != NULL) {
; 458  :         next = rules->next;
; 459  : 	if (rules->tests)

	mov	esi, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ebx]
	mov	DWORD PTR _next$1$[ebp], edi
	test	esi, esi
	je	SHORT $LN11@xmlSchemat
	npad	4
$LL10@xmlSchemat:

; 367  : 	if (tests->test != NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@xmlSchemat

; 368  : 	    xmlFree(tests->test);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemat:

; 369  : 	if (tests->comp != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN13@xmlSchemat

; 370  : 	    xmlXPathFreeCompExpr(tests->comp);

	push	eax
	call	_xmlXPathFreeCompExpr
	add	esp, 4
$LN13@xmlSchemat:

; 371  : 	if (tests->report != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN14@xmlSchemat

; 372  : 	    xmlFree(tests->report);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlSchemat:

; 373  : 	xmlFree(tests);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 374  : 	tests = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL10@xmlSchemat
	mov	edi, DWORD PTR _next$1$[ebp]
$LN11@xmlSchemat:

; 460  : 	    xmlSchematronFreeTests(rules->tests);
; 461  : 	if (rules->context != NULL)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 462  : 	    xmlFree(rules->context);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemat:

; 463  : 	if (rules->pattern)

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN6@xmlSchemat

; 464  : 	    xmlFreePattern(rules->pattern);

	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN6@xmlSchemat:

; 465  : 	if (rules->report != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN7@xmlSchemat

; 466  : 	    xmlFree(rules->report);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlSchemat:

; 467  : 	xmlFree(rules);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 468  : 	rules = next;

	mov	ebx, edi
	test	edi, edi
	jne	$LL2@xmlSchemat
	pop	edi
	pop	esi
$LN3@xmlSchemat:
	pop	ebx

; 469  :     }
; 470  : }

	pop	ebp
	ret	0
_xmlSchematronFreeRules ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronAddRule
_TEXT	SEGMENT
_pattern$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_schema$ = 12						; size = 4
_pat$ = 16						; size = 4
_node$ = 20						; size = 4
_context$ = 24						; size = 4
_report$ = 28						; size = 4
_xmlSchematronAddRule PROC				; COMDAT

; 394  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlSchemat

; 395  :     xmlSchematronRulePtr ret;
; 396  :     xmlPatternPtr pattern;
; 397  : 
; 398  :     if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||

	cmp	DWORD PTR _schema$[ebp], 0
	je	SHORT $LN7@xmlSchemat
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlSchemat
	mov	ebx, DWORD PTR _context$[ebp]
	test	ebx, ebx
	je	SHORT $LN7@xmlSchemat

; 399  :         (context == NULL))
; 400  :         return(NULL);
; 401  : 
; 402  :     /*
; 403  :      * Try first to compile the pattern
; 404  :      */
; 405  :     pattern = xmlPatterncompile(context, ctxt->dict, XML_PATTERN_XPATH,

	push	DWORD PTR [esi+52]
	push	1
	push	DWORD PTR [esi+24]
	push	ebx
	call	_xmlPatterncompile
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pattern$1$[ebp], eax

; 406  :                                 ctxt->namespaces);
; 407  :     if (pattern == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlSchemat

; 408  : 	xmlSchematronPErr(ctxt, node,

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CI@BJKODKAC@Failed?5to?5compile?5context?5expre@
	push	1759					; 000006dfH
	push	edi
	push	esi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN8@xmlSchemat:

; 409  : 	    XML_SCHEMAP_NOROOT,
; 410  : 	    "Failed to compile context expression %s",
; 411  : 	    context, NULL);
; 412  :     }
; 413  : 
; 414  :     ret = (xmlSchematronRulePtr) xmlMalloc(sizeof(xmlSchematronRule));

	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4

; 415  :     if (ret == NULL) {

	test	edx, edx
	jne	SHORT $LN9@xmlSchemat

; 416  :         xmlSchematronPErrMemory(ctxt, "allocating schema rule", node);

	push	edi
	push	OFFSET ??_C@_0BH@NOHOGEKI@allocating?5schema?5rule@
	push	esi
	call	_xmlSchematronPErrMemory
	add	esp, 12					; 0000000cH
$LN7@xmlSchemat:

; 442  :         prev->patnext = ret;
; 443  :     }
; 444  :     return (ret);
; 445  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlSchemat:

; 417  :         return (NULL);
; 418  :     }
; 419  :     memset(ret, 0, sizeof(xmlSchematronRule));
; 420  :     ret->node = node;
; 421  :     ret->context = context;
; 422  :     ret->pattern = pattern;

	mov	eax, DWORD PTR _pattern$1$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], eax

; 423  :     ret->report = report;

	mov	eax, DWORD PTR _report$[ebp]
	mov	DWORD PTR [edx+24], eax

; 424  :     ret->next = NULL;
; 425  :     if (schema->rules == NULL) {

	mov	eax, DWORD PTR _schema$[ebp]
	mov	DWORD PTR [edx+8], edi
	mov	DWORD PTR [edx+12], ebx
	mov	DWORD PTR [edx], 0
	mov	esi, DWORD PTR [eax+40]
	test	esi, esi
	jne	SHORT $LN10@xmlSchemat

; 426  : 	schema->rules = ret;

	mov	DWORD PTR [eax+40], edx

; 427  :     } else {

	jmp	SHORT $LN11@xmlSchemat
$LN10@xmlSchemat:

; 428  :         xmlSchematronRulePtr prev = schema->rules;
; 429  : 
; 430  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemat
	npad	5
$LL2@xmlSchemat:
	mov	eax, DWORD PTR [ecx]

; 431  : 	     prev = prev->next;

	mov	esi, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlSchemat
$LN3@xmlSchemat:

; 432  :         prev->next = ret;

	mov	DWORD PTR [esi], edx
$LN11@xmlSchemat:

; 433  :     }
; 434  :     ret->patnext = NULL;
; 435  :     if (pat->rules == NULL) {

	mov	eax, DWORD PTR _pat$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN12@xmlSchemat

; 442  :         prev->patnext = ret;
; 443  :     }
; 444  :     return (ret);
; 445  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax+4], edx
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlSchemat:

; 436  : 	pat->rules = ret;
; 437  :     } else {
; 438  :         xmlSchematronRulePtr prev = pat->rules;
; 439  : 
; 440  : 	while (prev->patnext != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat
	npad	2
$LL4@xmlSchemat:

; 441  : 	     prev = prev->patnext;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
$LN5@xmlSchemat:
	pop	edi

; 442  :         prev->patnext = ret;
; 443  :     }
; 444  :     return (ret);
; 445  : }

	pop	esi
	mov	DWORD PTR [ecx+4], edx
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
_xmlSchematronAddRule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFreeTests
_TEXT	SEGMENT
_tests$ = 8						; size = 4
_xmlSchematronFreeTests PROC				; COMDAT

; 362  : xmlSchematronFreeTests(xmlSchematronTestPtr tests) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _tests$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlSchemat
	push	edi
$LL2@xmlSchemat:

; 363  :     xmlSchematronTestPtr next;
; 364  : 
; 365  :     while (tests != NULL) {
; 366  :         next = tests->next;
; 367  : 	if (tests->test != NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlSchemat

; 368  : 	    xmlFree(tests->test);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemat:

; 369  : 	if (tests->comp != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 370  : 	    xmlXPathFreeCompExpr(tests->comp);

	push	eax
	call	_xmlXPathFreeCompExpr
	add	esp, 4
$LN5@xmlSchemat:

; 371  : 	if (tests->report != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@xmlSchemat

; 372  : 	    xmlFree(tests->report);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlSchemat:

; 373  : 	xmlFree(tests);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 374  : 	tests = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL2@xmlSchemat
	pop	edi
$LN3@xmlSchemat:
	pop	esi

; 375  :     }
; 376  : }

	pop	ebp
	ret	0
_xmlSchematronFreeTests ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronAddTest
_TEXT	SEGMENT
_comp$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_type$ = 12						; size = 4
_rule$ = 16						; size = 4
_node$ = 20						; size = 4
_test$ = 24						; size = 4
_report$ = 28						; size = 4
_xmlSchematronAddTest PROC				; COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlSchemat

; 312  :     xmlSchematronTestPtr ret;
; 313  :     xmlXPathCompExprPtr comp;
; 314  : 
; 315  :     if ((ctxt == NULL) || (rule == NULL) || (node == NULL) ||

	cmp	DWORD PTR _rule$[ebp], 0
	je	SHORT $LN5@xmlSchemat
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlSchemat
	mov	ebx, DWORD PTR _test$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlSchemat

; 316  :         (test == NULL))
; 317  :         return(NULL);
; 318  : 
; 319  :     /*
; 320  :      * try first to compile the test expression
; 321  :      */
; 322  :     comp = xmlXPathCtxtCompile(ctxt->xctxt, test);

	push	ebx
	push	DWORD PTR [esi+36]
	call	_xmlXPathCtxtCompile
	add	esp, 8
	mov	DWORD PTR _comp$1$[ebp], eax

; 323  :     if (comp == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSchemat

; 324  : 	xmlSchematronPErr(ctxt, node,

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CF@CDHGHDAB@Failed?5to?5compile?5test?5expressi@
	push	1759					; 000006dfH
	push	edi
	push	esi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN5@xmlSchemat:

; 353  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlSchemat:

; 325  : 	    XML_SCHEMAP_NOROOT,
; 326  : 	    "Failed to compile test expression %s",
; 327  : 	    test, NULL);
; 328  : 	return(NULL);
; 329  :     }
; 330  : 
; 331  :     ret = (xmlSchematronTestPtr) xmlMalloc(sizeof(xmlSchematronTest));

	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4

; 332  :     if (ret == NULL) {

	test	edx, edx
	jne	SHORT $LN7@xmlSchemat

; 333  :         xmlSchematronPErrMemory(ctxt, "allocating schema test", node);

	push	edi
	push	OFFSET ??_C@_0BH@EFIEABMK@allocating?5schema?5test@
	push	esi
	call	_xmlSchematronPErrMemory
	add	esp, 12					; 0000000cH

; 353  : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlSchemat:

; 334  :         return (NULL);
; 335  :     }
; 336  :     memset(ret, 0, sizeof(xmlSchematronTest));
; 337  :     ret->type = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+4], eax

; 338  :     ret->node = node;
; 339  :     ret->test = test;
; 340  :     ret->comp = comp;

	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	DWORD PTR [edx+16], eax

; 341  :     ret->report = report;

	mov	eax, DWORD PTR _report$[ebp]
	mov	DWORD PTR [edx+20], eax

; 342  :     ret->next = NULL;
; 343  :     if (rule->tests == NULL) {

	mov	eax, DWORD PTR _rule$[ebp]
	mov	DWORD PTR [edx+8], edi
	mov	DWORD PTR [edx+12], ebx
	mov	DWORD PTR [edx], 0
	mov	esi, DWORD PTR [eax+16]
	test	esi, esi
	jne	SHORT $LN8@xmlSchemat

; 353  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [eax+16], edx
	mov	eax, edx
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlSchemat:

; 344  : 	rule->tests = ret;
; 345  :     } else {
; 346  :         xmlSchematronTestPtr prev = rule->tests;
; 347  : 
; 348  : 	while (prev->next != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@xmlSchemat
	npad	6
$LL2@xmlSchemat:
	mov	eax, DWORD PTR [ecx]

; 349  : 	     prev = prev->next;

	mov	esi, ecx
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL2@xmlSchemat
$LN3@xmlSchemat:
	pop	edi

; 350  :         prev->next = ret;

	mov	DWORD PTR [esi], edx

; 351  :     }
; 352  :     return (ret);

	mov	eax, edx

; 353  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlSchematronAddTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronVErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchematronVErrMemory PROC				; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemat

; 279  :     if (ctxt != NULL) {
; 280  :         ctxt->nberrors++;
; 281  :         ctxt->err = XML_SCHEMAV_INTERNAL;

	inc	DWORD PTR [eax+12]
	mov	DWORD PTR [eax+16], 1818		; 0000071aH
$LN2@xmlSchemat:

; 282  :     }
; 283  :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	DWORD PTR _extra$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 284  :                      extra);
; 285  : }

	pop	ebp
	ret	0
_xmlSchematronVErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronPErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_str1$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlSchematronPErr PROC					; COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	xor	edi, edi
	xor	ebx, ebx
	test	edx, edx
	je	SHORT $LN2@xmlSchemat

; 252  :     xmlGenericErrorFunc channel = NULL;
; 253  :     xmlStructuredErrorFunc schannel = NULL;
; 254  :     void *data = NULL;
; 255  : 
; 256  :     if (ctxt != NULL) {
; 257  :         ctxt->nberrors++;
; 258  :         channel = ctxt->error;

	inc	DWORD PTR [edx+28]
	mov	esi, DWORD PTR [edx+72]

; 259  :         data = ctxt->userData;

	mov	ebx, DWORD PTR [edx+68]

; 260  : 	schannel = ctxt->serror;

	mov	edi, DWORD PTR [edx+80]
$LN2@xmlSchemat:

; 261  :     }
; 262  :     __xmlRaiseError(schannel, channel, data, ctxt, node, XML_FROM_SCHEMASP,

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	eax, DWORD PTR _str1$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	16					; 00000010H
	push	DWORD PTR _node$[ebp]
	push	edx
	push	ebx
	push	esi
	push	edi
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
	pop	edi
	pop	esi
	pop	ebx

; 263  :                     error, XML_ERR_ERROR, NULL, 0,
; 264  :                     (const char *) str1, (const char *) str2, NULL, 0, 0,
; 265  :                     msg, str1, str2);
; 266  : }

	pop	ebp
	ret	0
_xmlSchematronPErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronPErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_node$ = 16						; size = 4
_xmlSchematronPErrMemory PROC				; COMDAT

; 230  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlSchemat

; 231  :     if (ctxt != NULL)
; 232  :         ctxt->nberrors++;

	inc	DWORD PTR [eax+28]
$LN2@xmlSchemat:

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	DWORD PTR _extra$[ebp]
	push	0
	push	DWORD PTR _node$[ebp]
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 234  :                      extra);
; 235  : }

	pop	ebp
	ret	0
_xmlSchematronPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronValidateDoc
_TEXT	SEGMENT
_msg$1 = -1012						; size = 1000
_rule$1$ = -12						; size = 4
_pattern$1$ = -8					; size = 4
_cur$2$ = -4						; size = 4
_rule$2$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_instance$ = 12						; size = 4
_xmlSchematronValidateDoc PROC				; COMDAT

; 1667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1012				; 000003f4H
	mov	ecx, OFFSET __D7D5901C_schematron@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN17@xmlSchemat

; 1668 :     xmlNodePtr cur, root;
; 1669 :     xmlSchematronPatternPtr pattern;
; 1670 :     xmlSchematronRulePtr rule;
; 1671 :     xmlSchematronTestPtr test;
; 1672 : 
; 1673 :     if ((ctxt == NULL) || (ctxt->schema == NULL) ||
; 1674 :         (ctxt->schema->rules == NULL) || (instance == NULL))

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	$LN17@xmlSchemat
	cmp	DWORD PTR [eax+40], 0
	je	$LN17@xmlSchemat
	mov	edi, DWORD PTR _instance$[ebp]
	test	edi, edi
	je	$LN17@xmlSchemat

; 1676 :     ctxt->nberrors = 0;

	push	esi

; 1677 :     root = xmlDocGetRootElement(instance);

	push	edi
	mov	DWORD PTR [ebx+12], 0
	call	_xmlDocGetRootElement
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _cur$2$[ebp], esi

; 1678 :     if (root == NULL) {

	test	esi, esi
	jne	SHORT $LN18@xmlSchemat

; 1679 :         TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1679					; 0000068fH
	push	OFFSET ??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 1680 : 	ctxt->nberrors++;
; 1681 : 	return(1);

	mov	eax, 1
	inc	DWORD PTR [ebx+12]
	pop	esi
	pop	edi

; 1740 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlSchemat:

; 1682 :     }
; 1683 :     if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) ||

	mov	eax, DWORD PTR [ebx+4]
	test	al, 1
	jne	$LL2@xmlSchemat
	test	eax, eax
	je	$LL2@xmlSchemat

; 1704 : 	}
; 1705 :     } else {
; 1706 :         /*
; 1707 : 	 * Process all contexts one at a time
; 1708 : 	 */
; 1709 : 	pattern = ctxt->schema->patterns;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [eax+36]
	mov	DWORD PTR _pattern$1$[ebp], esi

; 1710 : 
; 1711 : 	while (pattern != NULL) {

	test	esi, esi
	je	$LN3@xmlSchemat
$LN69@xmlSchemat:
	mov	eax, DWORD PTR [ebx+4]
	test	al, 9

; 1454 :     if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) || (ctxt->flags & XML_SCHEMATRON_OUT_ERROR)) /* Error gives pattern name as part of error */

	jne	SHORT $LN29@xmlSchemat

; 1455 :         return;
; 1456 :     if (ctxt->flags & XML_SCHEMATRON_OUT_XML) {

	test	al, 4
	je	SHORT $LN30@xmlSchemat

; 1457 :         TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1457					; 000005b1H
	push	OFFSET ??_C@_0GM@OEFFILND@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 1458 :     } else {

	mov	esi, DWORD PTR _pattern$1$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN29@xmlSchemat
$LN30@xmlSchemat:

; 1459 : 	char msg[1000];
; 1460 : 
; 1461 : 	if (pattern->name == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN29@xmlSchemat

; 1462 : 	    return;
; 1463 : 	snprintf(msg, 999, "Pattern: %s\n", (const char *) pattern->name);

	push	eax
	push	OFFSET ??_C@_0N@IHDDKFAG@Pattern?3?5?$CFs?6@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	999					; 000003e7H
	push	eax
	call	_snprintf

; 1464 : 	xmlSchematronReportOutput(ctxt, NULL, &msg[0]);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	0
	push	ebx
	call	_xmlSchematronReportOutput
	add	esp, 28					; 0000001cH
$LN29@xmlSchemat:

; 1712 : 	    xmlSchematronReportPattern(ctxt, pattern);
; 1713 : 
; 1714 : 	    /*
; 1715 : 	     * TODO convert the pattern rule to a direct XPath and
; 1716 : 	     * compute directly instead of using the pattern matching
; 1717 : 	     * over the full document...
; 1718 : 	     * Check the exact semantic
; 1719 : 	     */
; 1720 : 	    cur = root;

	mov	edi, DWORD PTR _cur$2$[ebp]
$LL10@xmlSchemat:

; 1721 : 	    while (cur != NULL) {
; 1722 : 		rule = pattern->rules;

	mov	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR _rule$1$[ebp], ebx

; 1723 : 		while (rule != NULL) {

	test	ebx, ebx
	je	SHORT $LN13@xmlSchemat
$LL12@xmlSchemat:

; 1724 : 		    if (xmlPatternMatch(rule->pattern, cur) == 1) {

	push	edi
	push	DWORD PTR [ebx+20]
	call	_xmlPatternMatch
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN15@xmlSchemat

; 1725 : 			test = rule->tests;

	mov	esi, DWORD PTR [ebx+16]

; 1726 : 			while (test != NULL) {

	test	esi, esi
	je	SHORT $LN15@xmlSchemat
	mov	ebx, DWORD PTR _ctxt$[ebp]
	npad	3
$LL14@xmlSchemat:

; 1727 : 			    xmlSchematronRunTest(ctxt, test, instance, cur, pattern);

	push	DWORD PTR _pattern$1$[ebp]
	push	edi
	push	DWORD PTR _instance$[ebp]
	push	esi
	push	ebx
	call	_xmlSchematronRunTest

; 1728 : 			    test = test->next;

	mov	esi, DWORD PTR [esi]
	add	esp, 20					; 00000014H
	test	esi, esi
	jne	SHORT $LL14@xmlSchemat
	mov	ebx, DWORD PTR _rule$1$[ebp]
$LN15@xmlSchemat:

; 1729 : 			}
; 1730 : 		    }
; 1731 : 		    rule = rule->patnext;

	mov	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR _rule$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LL12@xmlSchemat
	mov	esi, DWORD PTR _pattern$1$[ebp]
$LN13@xmlSchemat:

; 1732 : 		}
; 1733 : 
; 1734 : 		cur = xmlSchematronNextNode(cur);

	push	edi
	call	_xmlSchematronNextNode
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LL10@xmlSchemat

; 1735 : 	    }
; 1736 : 	    pattern = pattern->next;

	mov	esi, DWORD PTR [esi]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _pattern$1$[ebp], esi
	test	esi, esi
	jne	$LN69@xmlSchemat

; 1737 : 	}
; 1738 :     }
; 1739 :     return(ctxt->nberrors);

	mov	eax, DWORD PTR [ebx+12]
	pop	esi
	pop	edi

; 1740 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LL2@xmlSchemat:

; 1684 :         (ctxt->flags == 0)) {
; 1685 : 	/*
; 1686 : 	 * we are just trying to assert the validity of the document,
; 1687 : 	 * speed primes over the output, run in a single pass
; 1688 : 	 */
; 1689 : 	cur = root;
; 1690 : 	while (cur != NULL) {
; 1691 : 	    rule = ctxt->schema->rules;

	mov	eax, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR [eax+40]
	mov	DWORD PTR _rule$2$[ebp], eax

; 1692 : 	    while (rule != NULL) {

	test	eax, eax
	je	SHORT $LN5@xmlSchemat
	npad	3
$LL4@xmlSchemat:

; 1693 : 		if (xmlPatternMatch(rule->pattern, cur) == 1) {

	push	esi
	push	DWORD PTR [eax+20]
	call	_xmlPatternMatch
	add	esp, 8
	cmp	eax, 1
	mov	eax, DWORD PTR _rule$2$[ebp]
	jne	SHORT $LN7@xmlSchemat

; 1694 : 		    test = rule->tests;

	mov	esi, DWORD PTR [eax+16]

; 1695 : 		    while (test != NULL) {

	test	esi, esi
	je	SHORT $LN63@xmlSchemat
	npad	5
$LL6@xmlSchemat:

; 1696 : 			xmlSchematronRunTest(ctxt, test, instance, cur, (xmlSchematronPatternPtr)rule->pattern);

	push	DWORD PTR [eax+20]
	push	DWORD PTR _cur$2$[ebp]
	push	edi
	push	esi
	push	ebx
	call	_xmlSchematronRunTest

; 1697 : 			test = test->next;

	mov	esi, DWORD PTR [esi]
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _rule$2$[ebp]
	test	esi, esi
	jne	SHORT $LL6@xmlSchemat
$LN63@xmlSchemat:

; 1698 : 		    }
; 1699 : 		}
; 1700 : 		rule = rule->next;

	mov	esi, DWORD PTR _cur$2$[ebp]
$LN7@xmlSchemat:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _rule$2$[ebp], eax
	test	eax, eax
	jne	SHORT $LL4@xmlSchemat
$LN5@xmlSchemat:

; 1701 : 	    }
; 1702 : 
; 1703 : 	    cur = xmlSchematronNextNode(cur);

	push	esi
	call	_xmlSchematronNextNode
	mov	esi, eax
	mov	DWORD PTR _cur$2$[ebp], eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LL2@xmlSchemat
$LN3@xmlSchemat:

; 1737 : 	}
; 1738 :     }
; 1739 :     return(ctxt->nberrors);

	mov	eax, DWORD PTR [ebx+12]
	pop	esi
	pop	edi

; 1740 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlSchemat:
	pop	edi

; 1675 :         return(-1);

	or	eax, -1

; 1740 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronValidateDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFreeValidCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchematronFreeValidCtxt PROC			; COMDAT

; 1545 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemat

; 1546 :     if (ctxt == NULL)
; 1547 :         return;
; 1548 :     if (ctxt->xctxt != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN3@xmlSchemat

; 1549 :         xmlXPathFreeContext(ctxt->xctxt);

	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4
$LN3@xmlSchemat:

; 1550 :     if (ctxt->dict != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlSchemat

; 1551 :         xmlDictFree(ctxt->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN4@xmlSchemat:

; 1552 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlSchemat:
	pop	esi

; 1553 : }

	pop	ebp
	ret	0
_xmlSchematronFreeValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNewValidCtxt
_TEXT	SEGMENT
_schema$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlSchematronNewValidCtxt PROC				; COMDAT

; 1506 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	push	64					; 00000040H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN5@xmlSchemat

; 283  :     __xmlSimpleError(XML_FROM_SCHEMASV, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BO@JGCBGKGF@allocating?5validation?5context@
	push	eax
	push	eax
	push	2
	push	17					; 00000011H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1507 :     int i;
; 1508 :     xmlSchematronValidCtxtPtr ret;
; 1509 : 
; 1510 :     ret = (xmlSchematronValidCtxtPtr) xmlMalloc(sizeof(xmlSchematronValidCtxt));
; 1511 :     if (ret == NULL) {
; 1512 :         xmlSchematronVErrMemory(NULL, "allocating validation context",
; 1513 :                                 NULL);
; 1514 :         return (NULL);

	xor	eax, eax
	pop	edi

; 1535 : }

	pop	ebp
	ret	0
$LN5@xmlSchemat:

; 1515 :     }
; 1516 :     memset(ret, 0, sizeof(xmlSchematronValidCtxt));

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+40], 0
	mov	DWORD PTR [edi+44], 0
	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+52], 0
	mov	DWORD PTR [edi+56], 0
	push	ebx

; 1517 :     ret->type = XML_STRON_CTXT_VALIDATOR;
; 1518 :     ret->schema = schema;

	mov	ebx, DWORD PTR _schema$[ebp]
	mov	DWORD PTR [edi+60], 0

; 1519 :     ret->xctxt = xmlXPathNewContext(NULL);

	push	0
	mov	DWORD PTR [edi], 2
	mov	DWORD PTR [edi+20], ebx
	call	_xmlXPathNewContext
	mov	ecx, eax
	add	esp, 4

; 1520 :     ret->flags = options;

	mov	eax, DWORD PTR _options$[ebp]
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+4], eax

; 1521 :     if (ret->xctxt == NULL) {

	test	ecx, ecx
	jne	SHORT $LN6@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@
	push	ecx
	push	ecx
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 1522 :         xmlSchematronPErrMemory(NULL, "allocating schema parser XPath context",
; 1523 :                                 NULL);
; 1524 : 	xmlSchematronFreeValidCtxt(ret);

	push	edi
	call	_xmlSchematronFreeValidCtxt
	add	esp, 24					; 00000018H

; 1525 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1535 : }

	pop	ebp
	ret	0
$LN6@xmlSchemat:
	push	esi

; 1526 :     }
; 1527 :     for (i = 0;i < schema->nbNamespaces;i++) {

	xor	esi, esi
	cmp	DWORD PTR [ebx+44], esi
	jle	SHORT $LN21@xmlSchemat
$LL4@xmlSchemat:

; 1528 :         if ((schema->namespaces[2 * i] == NULL) ||

	mov	eax, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [eax+esi*8]
	test	ecx, ecx
	je	SHORT $LN21@xmlSchemat
	mov	eax, DWORD PTR [eax+esi*8+4]
	test	eax, eax
	je	SHORT $LN21@xmlSchemat

; 1529 :             (schema->namespaces[2 * i + 1] == NULL))
; 1530 : 	    break;
; 1531 : 	xmlXPathRegisterNs(ret->xctxt, schema->namespaces[2 * i + 1],

	push	ecx
	push	eax
	push	DWORD PTR [edi+24]
	call	_xmlXPathRegisterNs
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebx+44]
	jl	SHORT $LL4@xmlSchemat
$LN21@xmlSchemat:

; 1532 : 	                   schema->namespaces[2 * i]);
; 1533 :     }
; 1534 :     return (ret);

	pop	esi
	pop	ebx
	mov	eax, edi
	pop	edi

; 1535 : }

	pop	ebp
	ret	0
_xmlSchematronNewValidCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronSetValidStructuredErrors
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_serror$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlSchematronSetValidStructuredErrors PROC		; COMDAT

; 1486 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlSchemat

; 1487 :     if (ctxt == NULL)
; 1488 :         return;
; 1489 :     ctxt->serror = serror;

	mov	eax, DWORD PTR _serror$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 1490 :     ctxt->error = NULL;
; 1491 :     ctxt->warning = NULL;
; 1492 :     ctxt->userData = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+48], eax
$LN1@xmlSchemat:

; 1493 : }

	pop	ebp
	ret	0
_xmlSchematronSetValidStructuredErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFree
_TEXT	SEGMENT
_next$1$ = -4						; size = 4
_schema$ = 8						; size = 4
_xmlSchematronFree PROC					; COMDAT

; 564  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _schema$[ebp]
	test	edi, edi
	je	$LN1@xmlSchemat

; 565  :     if (schema == NULL)
; 566  :         return;
; 567  : 
; 568  :     if ((schema->doc != NULL) && (!(schema->preserve)))

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSchemat
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN3@xmlSchemat

; 569  :         xmlFreeDoc(schema->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN3@xmlSchemat:

; 570  : 
; 571  :     if (schema->namespaces != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN4@xmlSchemat

; 572  :         xmlFree((char **) schema->namespaces);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlSchemat:

; 573  : 
; 574  :     xmlSchematronFreeRules(schema->rules);

	push	ebx
	mov	ebx, DWORD PTR [edi+40]
	push	esi

; 457  :     while (rules != NULL) {

	test	ebx, ebx
	je	$LN8@xmlSchemat
	npad	2
$LL7@xmlSchemat:

; 458  :         next = rules->next;
; 459  : 	if (rules->tests)

	mov	esi, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ebx]
	mov	DWORD PTR _next$1$[ebp], edi
	test	esi, esi
	je	SHORT $LN16@xmlSchemat
	npad	4
$LL15@xmlSchemat:

; 367  : 	if (tests->test != NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@xmlSchemat

; 368  : 	    xmlFree(tests->test);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlSchemat:

; 369  : 	if (tests->comp != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN18@xmlSchemat

; 370  : 	    xmlXPathFreeCompExpr(tests->comp);

	push	eax
	call	_xmlXPathFreeCompExpr
	add	esp, 4
$LN18@xmlSchemat:

; 371  : 	if (tests->report != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN19@xmlSchemat

; 372  : 	    xmlFree(tests->report);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlSchemat:

; 373  : 	xmlFree(tests);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 374  : 	tests = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL15@xmlSchemat
	mov	edi, DWORD PTR _next$1$[ebp]
$LN16@xmlSchemat:

; 461  : 	if (rules->context != NULL)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN10@xmlSchemat

; 462  : 	    xmlFree(rules->context);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSchemat:

; 463  : 	if (rules->pattern)

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN11@xmlSchemat

; 464  : 	    xmlFreePattern(rules->pattern);

	push	eax
	call	_xmlFreePattern
	add	esp, 4
$LN11@xmlSchemat:

; 465  : 	if (rules->report != NULL)

	mov	eax, DWORD PTR [ebx+24]
	test	eax, eax
	je	SHORT $LN12@xmlSchemat

; 466  : 	    xmlFree(rules->report);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN12@xmlSchemat:

; 467  : 	xmlFree(rules);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 468  : 	rules = next;

	mov	ebx, edi
	test	edi, edi
	jne	$LL7@xmlSchemat
	mov	edi, DWORD PTR _schema$[ebp]
$LN8@xmlSchemat:

; 575  :     xmlSchematronFreePatterns(schema->patterns);

	mov	esi, DWORD PTR [edi+36]

; 522  :     while (patterns != NULL) {

	test	esi, esi
	je	SHORT $LN23@xmlSchemat
$LL22@xmlSchemat:

; 523  :         next = patterns->next;
; 524  : 	if (patterns->name != NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN24@xmlSchemat

; 525  : 	    xmlFree(patterns->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlSchemat:

; 526  : 	xmlFree(patterns);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 527  : 	patterns = next;

	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL22@xmlSchemat
	mov	edi, DWORD PTR _schema$[ebp]
$LN23@xmlSchemat:

; 576  :     xmlDictFree(schema->dict);

	push	DWORD PTR [edi+20]
	call	_xmlDictFree

; 577  :     xmlFree(schema);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	esi
	pop	ebx
$LN1@xmlSchemat:
	pop	edi

; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronParse
_TEXT	SEGMENT
_uri$1$ = -16						; size = 4
_title$1$ = -16						; size = 4
_preserve$1$ = -12					; size = 4
_doc$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_root$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlSchematronParse PROC				; COMDAT

; 1078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _preserve$1$[ebp], ebx
	test	edi, edi
	je	$LN24@xmlSchemat

; 1079 :     xmlSchematronPtr ret = NULL;
; 1080 :     xmlDocPtr doc;
; 1081 :     xmlNodePtr root, cur;
; 1082 :     int preserve = 0;
; 1083 : 
; 1084 :     if (ctxt == NULL)
; 1085 :         return (NULL);
; 1086 : 
; 1087 :     ctxt->nberrors = 0;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+28], ebx

; 1088 : 
; 1089 :     /*
; 1090 :      * First step is to parse the input document into an DOM/Infoset
; 1091 :      */
; 1092 :     if (ctxt->URL != NULL) {

	test	eax, eax
	je	SHORT $LN15@xmlSchemat

; 1093 :         doc = xmlReadFile((const char *) ctxt->URL, NULL,

	push	2
	push	ebx
	push	eax
	call	_xmlReadFile
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$1$[ebp], esi

; 1094 : 	                  SCHEMATRON_PARSE_OPTIONS);
; 1095 :         if (doc == NULL) {

	test	esi, esi
	jne	$LN17@xmlSchemat

; 1096 : 	    xmlSchematronPErr(ctxt, NULL,

	push	eax
	push	DWORD PTR [edi+4]
	push	OFFSET ??_C@_0CK@FENMHHNI@xmlSchematronParse?3?5could?5not?5l@
	push	1757					; 000006ddH

; 1234 : }

	push	eax
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlSchemat:

; 1097 : 			  XML_SCHEMAP_FAILED_LOAD,
; 1098 :                           "xmlSchematronParse: could not load '%s'.\n",
; 1099 :                           ctxt->URL, NULL);
; 1100 :             return (NULL);
; 1101 :         }
; 1102 : 	ctxt->preserve = 0;
; 1103 :     } else if (ctxt->buffer != NULL) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN18@xmlSchemat

; 1104 :         doc = xmlReadMemory(ctxt->buffer, ctxt->size, NULL, NULL,

	push	2
	push	0
	push	0
	push	DWORD PTR [edi+20]
	push	eax
	call	_xmlReadMemory
	mov	esi, eax
	mov	DWORD PTR _doc$1$[ebp], eax
	add	esp, 20					; 00000014H

; 1105 : 	                    SCHEMATRON_PARSE_OPTIONS);
; 1106 :         if (doc == NULL) {

	test	esi, esi
	jne	SHORT $LN20@xmlSchemat

; 1107 : 	    xmlSchematronPErr(ctxt, NULL,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CG@KJCFFGDH@xmlSchematronParse?3?5could?5not?5p@
	push	1766					; 000006e6H

; 1234 : }

	push	eax
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlSchemat:

; 1108 : 			  XML_SCHEMAP_FAILED_PARSE,
; 1109 :                           "xmlSchematronParse: could not parse.\n",
; 1110 :                           NULL, NULL);
; 1111 :             return (NULL);
; 1112 :         }
; 1113 :         doc->URL = xmlStrdup(BAD_CAST "in_memory_buffer");

	push	OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	call	_xmlStrdup

; 1114 :         ctxt->URL = xmlDictLookup(ctxt->dict, BAD_CAST "in_memory_buffer", -1);

	push	-1
	mov	DWORD PTR [esi+72], eax
	push	OFFSET ??_C@_0BB@IEONCAEH@in_memory_buffer@
	push	DWORD PTR [edi+24]
	call	_xmlDictLookup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+4], eax
$LN17@xmlSchemat:

; 1122 : 		      XML_SCHEMAP_NOTHING_TO_PARSE,
; 1123 : 		      "xmlSchematronParse: could not parse.\n",
; 1124 : 		      NULL, NULL);
; 1125 :         return (NULL);
; 1126 :     }
; 1127 : 
; 1128 :     /*
; 1129 :      * Then extract the root and Schematron parse it
; 1130 :      */
; 1131 :     root = xmlDocGetRootElement(doc);

	mov	DWORD PTR [edi+12], ebx
	jmp	SHORT $LN22@xmlSchemat
$LN18@xmlSchemat:

; 1115 : 	ctxt->preserve = 0;
; 1116 :     } else if (ctxt->doc != NULL) {

	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR _doc$1$[ebp], esi
	test	esi, esi
	je	$LN21@xmlSchemat

; 1117 :         doc = ctxt->doc;
; 1118 : 	preserve = 1;

	mov	DWORD PTR _preserve$1$[ebp], 1

; 1119 : 	ctxt->preserve = 1;

	mov	DWORD PTR [edi+12], 1
$LN22@xmlSchemat:

; 1122 : 		      XML_SCHEMAP_NOTHING_TO_PARSE,
; 1123 : 		      "xmlSchematronParse: could not parse.\n",
; 1124 : 		      NULL, NULL);
; 1125 :         return (NULL);
; 1126 :     }
; 1127 : 
; 1128 :     /*
; 1129 :      * Then extract the root and Schematron parse it
; 1130 :      */
; 1131 :     root = xmlDocGetRootElement(doc);

	push	esi
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$1$[ebp], eax

; 1132 :     if (root == NULL) {

	test	eax, eax
	jne	SHORT $LN23@xmlSchemat

; 1133 : 	xmlSchematronPErr(ctxt, (xmlNodePtr) doc,

	push	eax
	push	eax
	push	OFFSET ??_C@_0CF@CKMAMFKI@The?5schema?5has?5no?5document?5elem@
	push	1759					; 000006dfH
	push	esi
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H

; 1134 : 		      XML_SCHEMAP_NOROOT,
; 1135 : 		      "The schema has no document element.\n", NULL, NULL);
; 1136 : 	if (!preserve) {

	cmp	DWORD PTR _preserve$1$[ebp], ebx
	jne	$LN24@xmlSchemat

; 1137 : 	    xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 4

; 1234 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlSchemat:

; 1138 : 	}
; 1139 :         return (NULL);
; 1140 :     }
; 1141 : 
; 1142 :     if (!IS_SCHEMATRON(root, "schema")) {

	cmp	DWORD PTR [eax+4], 1
	jne	$LN26@xmlSchemat
	cmp	DWORD PTR [eax+36], ebx
	je	$LN26@xmlSchemat
	push	OFFSET ??_C@_06KICAKOOL@schema@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _root$1$[ebp]
	je	$LN26@xmlSchemat
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN25@xmlSchemat
	mov	eax, DWORD PTR _root$1$[ebp]
	push	DWORD PTR _xmlOldSchematronNs
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN147@xmlSchemat
$LN25@xmlSchemat:

; 544  :     ret = (xmlSchematronPtr) xmlMalloc(sizeof(xmlSchematron));

	push	56					; 00000038H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], ebx

; 545  :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN58@xmlSchemat

; 232  :         ctxt->nberrors++;

	inc	DWORD PTR [edi+28]

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BC@BFLACGOA@allocating?5schema@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 547  :         return (NULL);

	jmp	$exit$157
$LN58@xmlSchemat:

; 548  :     }
; 549  :     memset(ret, 0, sizeof(xmlSchematron));

	push	56					; 00000038H
	push	0
	push	ebx
	call	_memset

; 550  :     ret->dict = ctxt->dict;

	mov	eax, DWORD PTR [edi+24]

; 551  :     xmlDictReference(ret->dict);

	push	eax
	mov	DWORD PTR [ebx+20], eax
	call	_xmlDictReference

; 1153 : 
; 1154 :     /*
; 1155 :      * scan the schema elements
; 1156 :      */
; 1157 :     cur = root->children;

	mov	eax, DWORD PTR _root$1$[ebp]

; 551  :     xmlDictReference(ret->dict);

	add	esp, 16					; 00000010H

; 1144 : 	    XML_SCHEMAP_NOROOT,
; 1145 : 	    "The XML document '%s' is not a XML schematron document",
; 1146 : 	    ctxt->URL, NULL);
; 1147 : 	goto exit;
; 1148 :     }
; 1149 :     ret = xmlSchematronNewSchematron(ctxt);
; 1150 :     if (ret == NULL)
; 1151 :         goto exit;
; 1152 :     ctxt->schema = ret;

	mov	DWORD PTR [edi+40], ebx

; 1153 : 
; 1154 :     /*
; 1155 :      * scan the schema elements
; 1156 :      */
; 1157 :     cur = root->children;

	mov	esi, DWORD PTR [eax+12]

; 1158 :     NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	$LN129@xmlSchemat
	npad	6
$LL2@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN28@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN28@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@xmlSchemat
$LN28@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlSchemat
	jmp	$LN146@xmlSchemat
$LN29@xmlSchemat:

; 1159 :     if (IS_SCHEMATRON(cur, "title")) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN138@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	$LL6@xmlSchemat
	push	OFFSET ??_C@_05PHLGJONK@title@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LL6@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LL6@xmlSchemat
$LN31@xmlSchemat:

; 1160 :         xmlChar *title = xmlNodeGetContent(cur);

	push	esi
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _title$1$[ebp], eax

; 1161 : 	if (title != NULL) {

	test	eax, eax
	je	SHORT $LN32@xmlSchemat

; 1162 : 	    ret->title = xmlDictLookup(ret->dict, title, -1);

	push	-1
	push	eax
	push	DWORD PTR [ebx+20]
	call	_xmlDictLookup

; 1163 : 	    xmlFree(title);

	push	DWORD PTR _title$1$[ebp]
	mov	DWORD PTR [ebx+24], eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN32@xmlSchemat:

; 1164 : 	}
; 1165 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1166 : 	NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	$LN146@xmlSchemat
$LL4@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN33@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN33@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL6@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL6@xmlSchemat
$LN33@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@xmlSchemat

; 1167 :     }
; 1168 :     while (IS_SCHEMATRON(cur, "ns")) {

	jmp	$LN146@xmlSchemat
	npad	3
$LL6@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	$LN138@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	$LN138@xmlSchemat
	push	OFFSET ??_C@_02EGOFOKPC@ns@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN138@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN35@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN138@xmlSchemat
$LN35@xmlSchemat:

; 1169 :         xmlChar *prefix = xmlGetNoNsProp(cur, BAD_CAST "prefix");

	push	OFFSET ??_C@_06CHGOAPND@prefix@
	push	esi
	call	_xmlGetNoNsProp

; 1170 :         xmlChar *uri = xmlGetNoNsProp(cur, BAD_CAST "uri");

	push	OFFSET ??_C@_03GBBABMJN@uri@
	push	esi
	mov	ebx, eax
	call	_xmlGetNoNsProp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _uri$1$[ebp], eax

; 1171 : 	if ((uri == NULL) || (uri[0] == 0)) {

	test	eax, eax
	je	SHORT $LN37@xmlSchemat
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN36@xmlSchemat
$LN37@xmlSchemat:

; 1172 : 	    xmlSchematronPErr(ctxt, cur,

	push	0
	push	0
	push	OFFSET ??_C@_0BG@GCEGAJCF@ns?5element?5has?5no?5uri@
	push	1759					; 000006dfH
	push	esi
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN36@xmlSchemat:

; 1173 : 		XML_SCHEMAP_NOROOT,
; 1174 : 		"ns element has no uri", NULL, NULL);
; 1175 : 	}
; 1176 : 	if ((prefix == NULL) || (prefix[0] == 0)) {

	test	ebx, ebx
	je	SHORT $LN39@xmlSchemat
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN38@xmlSchemat
$LN39@xmlSchemat:

; 1177 : 	    xmlSchematronPErr(ctxt, cur,

	push	0
	push	0
	push	OFFSET ??_C@_0BJ@FJJOLCKN@ns?5element?5has?5no?5prefix@
	push	1759					; 000006dfH
	push	esi
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN38@xmlSchemat:

; 1178 : 		XML_SCHEMAP_NOROOT,
; 1179 : 		"ns element has no prefix", NULL, NULL);
; 1180 : 	}
; 1181 : 	if ((prefix) && (uri)) {

	test	ebx, ebx
	je	$LN40@xmlSchemat
	mov	eax, DWORD PTR _uri$1$[ebp]
	test	eax, eax
	je	$LN41@xmlSchemat

; 1182 : 	    xmlXPathRegisterNs(ctxt->xctxt, prefix, uri);

	push	eax
	push	ebx
	push	DWORD PTR [edi+36]
	call	_xmlXPathRegisterNs

; 807  :     if (ctxt->namespaces == NULL) {

	mov	edx, DWORD PTR [edi+52]

; 1182 : 	    xmlXPathRegisterNs(ctxt->xctxt, prefix, uri);

	add	esp, 12					; 0000000cH

; 807  :     if (ctxt->namespaces == NULL) {

	test	edx, edx
	jne	SHORT $LN64@xmlSchemat

; 808  :         ctxt->maxNamespaces = 10;
; 809  :         ctxt->namespaces = (const xmlChar **)

	push	80					; 00000050H
	mov	DWORD PTR [edi+48], 10			; 0000000aH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+52], eax

; 810  : 	    xmlMalloc(ctxt->maxNamespaces * 2 * sizeof(const xmlChar *));
; 811  : 	if (ctxt->namespaces == NULL) {

	test	eax, eax
	je	SHORT $LN110@xmlSchemat

; 812  : 	    xmlSchematronPErrMemory(NULL, "allocating parser namespaces",
; 813  : 				    NULL);
; 814  : 	    return;
; 815  : 	}
; 816  :         ctxt->nbNamespaces = 0;

	mov	DWORD PTR [edi+44], 0
	jmp	SHORT $LN67@xmlSchemat
$LN64@xmlSchemat:

; 817  :     } else if (ctxt->nbNamespaces + 2 >= ctxt->maxNamespaces) {

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+48]
	add	eax, 2
	cmp	eax, ecx
	jl	SHORT $LN67@xmlSchemat

; 818  :         const xmlChar **tmp;
; 819  : 
; 820  : 	tmp = (const xmlChar **)

	shl	ecx, 4
	push	ecx
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 821  : 	    xmlRealloc((xmlChar **) ctxt->namespaces, ctxt->maxNamespaces * 4 *
; 822  : 	               sizeof(const xmlChar *));
; 823  : 	if (tmp == NULL) {

	test	eax, eax
	jne	SHORT $LN68@xmlSchemat
$LN110@xmlSchemat:

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0BN@GJJHFKFH@allocating?5parser?5namespaces@
	push	0
	push	0
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 826  : 	    return;

	jmp	SHORT $LN63@xmlSchemat
$LN68@xmlSchemat:

; 827  : 	}
; 828  :         ctxt->namespaces = tmp;

	mov	DWORD PTR [edi+52], eax

; 829  : 	ctxt->maxNamespaces *= 2;

	mov	eax, DWORD PTR [edi+48]
	add	eax, eax
	mov	DWORD PTR [edi+48], eax
$LN67@xmlSchemat:

; 830  :     }
; 831  :     ctxt->namespaces[2 * ctxt->nbNamespaces] =

	push	-1
	push	DWORD PTR _uri$1$[ebp]
	push	DWORD PTR [edi+24]
	call	_xmlDictLookup
	mov	edx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+52]

; 832  :         xmlDictLookup(ctxt->dict, ns, -1);
; 833  :     ctxt->namespaces[2 * ctxt->nbNamespaces + 1] =

	push	-1
	push	ebx
	mov	DWORD PTR [ecx+edx*8], eax
	push	DWORD PTR [edi+24]
	call	_xmlDictLookup
	mov	edx, DWORD PTR [edi+44]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 834  :         xmlDictLookup(ctxt->dict, prefix, -1);
; 835  :     ctxt->nbNamespaces++;

	inc	DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+44]

; 836  :     ctxt->namespaces[2 * ctxt->nbNamespaces] = NULL;

	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [eax+ecx*8], 0

; 837  :     ctxt->namespaces[2 * ctxt->nbNamespaces + 1] = NULL;

	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [eax+ecx*8+4], 0
$LN63@xmlSchemat:

; 1183 : 	    xmlSchematronAddNamespace(ctxt, prefix, uri);
; 1184 : 	    ret->nbNs++;

	mov	eax, DWORD PTR _ret$1$[ebp]
	inc	DWORD PTR [eax+28]
$LN40@xmlSchemat:

; 1185 : 	}
; 1186 : 	if (uri)

	mov	eax, DWORD PTR _uri$1$[ebp]
	test	eax, eax
	je	SHORT $LN41@xmlSchemat

; 1187 : 	    xmlFree(uri);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN41@xmlSchemat:

; 1188 : 	if (prefix)

	test	ebx, ebx
	je	SHORT $LN42@xmlSchemat

; 1189 : 	    xmlFree(prefix);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN42@xmlSchemat:

; 1190 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1191 : 	NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	SHORT $LN144@xmlSchemat
$LL8@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN43@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN43@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL6@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL6@xmlSchemat
$LN43@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL8@xmlSchemat
$LN144@xmlSchemat:

; 1204 :     }
; 1205 :     if (ret->nbPattern == 0) {

	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN146@xmlSchemat:
	mov	eax, DWORD PTR _root$1$[ebp]
$LN129@xmlSchemat:
	cmp	DWORD PTR [ebx+32], 0
	jne	$LN50@xmlSchemat

; 1206 : 	xmlSchematronPErr(ctxt, root,

	push	0
	push	DWORD PTR [edi+4]
	push	OFFSET ??_C@_0CM@EHOBNHNH@The?5schematron?5document?5?8?$CFs?8?5ha@
	push	1759					; 000006dfH
	push	eax
	push	edi
	call	_xmlSchematronPErr

; 1207 : 	    XML_SCHEMAP_NOROOT,
; 1208 : 	    "The schematron document '%s' has no pattern",
; 1209 : 	    ctxt->URL, NULL);
; 1210 : 	goto exit;

	mov	esi, DWORD PTR _doc$1$[ebp]
	jmp	$LN154@xmlSchemat
$LN138@xmlSchemat:
	mov	ebx, DWORD PTR _ret$1$[ebp]
	npad	4
$LL10@xmlSchemat:

; 1192 :     }
; 1193 :     while (cur != NULL) {
; 1194 : 	if (IS_SCHEMATRON(cur, "pattern")) {

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN45@xmlSchemat
	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN45@xmlSchemat
	push	OFFSET ??_C@_07CHFOACKJ@pattern@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@xmlSchemat
$LN47@xmlSchemat:

; 1195 : 	    xmlSchematronParsePattern(ctxt, cur);

	push	esi
	push	edi
	call	_xmlSchematronParsePattern
	add	esp, 8

; 1196 : 	    ret->nbPattern++;

	inc	DWORD PTR [ebx+32]

; 1197 : 	} else {

	jmp	SHORT $LN46@xmlSchemat
$LN45@xmlSchemat:

; 1198 : 	    xmlSchematronPErr(ctxt, cur,

	push	0
	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CK@GKEBAOHO@Expecting?5a?5pattern?5element?5ins@
	push	1759					; 000006dfH
	push	esi
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN46@xmlSchemat:

; 1199 : 		XML_SCHEMAP_NOROOT,
; 1200 : 		"Expecting a pattern element instead of %s", cur->name, NULL);
; 1201 : 	}
; 1202 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1203 : 	NEXT_SCHEMATRON(cur);

	test	esi, esi
	je	$LN146@xmlSchemat
$LL12@xmlSchemat:
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN48@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN48@xmlSchemat
	push	DWORD PTR _xmlSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL10@xmlSchemat
	mov	eax, DWORD PTR [esi+36]
	push	DWORD PTR _xmlOldSchematronNs
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LL10@xmlSchemat
$LN48@xmlSchemat:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL12@xmlSchemat

; 1191 : 	NEXT_SCHEMATRON(cur);

	jmp	$LN146@xmlSchemat
$LN50@xmlSchemat:

; 1211 :     }
; 1212 :     /* the original document must be kept for reporting */
; 1213 :     ret->doc = doc;
; 1214 :     if (preserve) {

	cmp	DWORD PTR _preserve$1$[ebp], 0
	mov	eax, DWORD PTR _doc$1$[ebp]
	mov	DWORD PTR [ebx+8], eax
	je	SHORT $LN52@xmlSchemat

; 1215 : 	    ret->preserve = 1;

	mov	DWORD PTR [ebx+4], 1

; 1216 :     }
; 1217 :     preserve = 1;

	jmp	SHORT $LN52@xmlSchemat
$LN147@xmlSchemat:

; 1138 : 	}
; 1139 :         return (NULL);
; 1140 :     }
; 1141 : 
; 1142 :     if (!IS_SCHEMATRON(root, "schema")) {

	mov	eax, DWORD PTR _root$1$[ebp]
$LN26@xmlSchemat:

; 1143 : 	xmlSchematronPErr(ctxt, root,

	push	0
	push	DWORD PTR [edi+4]
	push	OFFSET ??_C@_0DH@PDEEDFDL@The?5XML?5document?5?8?$CFs?8?5is?5not?5a?5@
	push	1759					; 000006dfH
	push	eax
	push	edi
	call	_xmlSchematronPErr
$LN154@xmlSchemat:

; 1218 : 
; 1219 : exit:
; 1220 :     if (!preserve) {

	add	esp, 24					; 00000018H
$exit$157:
	cmp	DWORD PTR _preserve$1$[ebp], 0
	jne	SHORT $LN52@xmlSchemat

; 1221 : 	xmlFreeDoc(doc);

	push	esi
	call	_xmlFreeDoc
	add	esp, 4
$LN52@xmlSchemat:

; 1222 :     }
; 1223 :     if (ret != NULL) {

	test	ebx, ebx
	je	SHORT $LN55@xmlSchemat

; 1224 : 	if (ctxt->nberrors != 0) {

	cmp	DWORD PTR [edi+28], 0
	je	SHORT $LN54@xmlSchemat

; 1225 : 	    xmlSchematronFree(ret);

	push	ebx
	call	_xmlSchematronFree
	add	esp, 4

; 1226 : 	    ret = NULL;

	xor	ebx, ebx

; 1231 : 	}
; 1232 :     }
; 1233 :     return (ret);

	mov	eax, ebx
	pop	edi

; 1234 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlSchemat:

; 1227 : 	} else {
; 1228 : 	    ret->namespaces = ctxt->namespaces;

	mov	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR [ebx+52], ecx

; 1229 : 	    ret->nbNamespaces = ctxt->nbNamespaces;

	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [ebx+44], ecx

; 1230 : 	    ctxt->namespaces = NULL;

	mov	DWORD PTR [edi+52], 0
$LN55@xmlSchemat:

; 1234 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemat:

; 1120 :     } else {
; 1121 : 	xmlSchematronPErr(ctxt, NULL,

	push	0
	push	0
	push	OFFSET ??_C@_0CG@KJCFFGDH@xmlSchematronParse?3?5could?5not?5p@
	push	1758					; 000006deH

; 1234 : }

	push	0
	push	edi
	call	_xmlSchematronPErr
	add	esp, 24					; 00000018H
$LN24@xmlSchemat:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchematronParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronFreeParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSchematronFreeParserCtxt PROC			; COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlSchemat

; 711  :     if (ctxt == NULL)
; 712  :         return;
; 713  :     if (ctxt->doc != NULL && !ctxt->preserve)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlSchemat
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN3@xmlSchemat

; 714  :         xmlFreeDoc(ctxt->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN3@xmlSchemat:

; 715  :     if (ctxt->xctxt != NULL) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN4@xmlSchemat

; 716  :         xmlXPathFreeContext(ctxt->xctxt);

	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4
$LN4@xmlSchemat:

; 717  :     }
; 718  :     if (ctxt->namespaces != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN5@xmlSchemat

; 719  :         xmlFree((char **) ctxt->namespaces);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlSchemat:

; 720  :     xmlDictFree(ctxt->dict);

	push	DWORD PTR [esi+24]
	call	_xmlDictFree

; 721  :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN1@xmlSchemat:
	pop	esi

; 722  : }

	pop	ebp
	ret	0
_xmlSchematronFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNewDocParserCtxt
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlSchematronNewDocParserCtxt PROC			; COMDAT

; 672  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlSchemat

; 673  :     xmlSchematronParserCtxtPtr ret;
; 674  : 
; 675  :     if (doc == NULL)
; 676  :         return (NULL);

	xor	eax, eax
	pop	edi

; 700  : }

	pop	ebp
	ret	0
$LN2@xmlSchemat:
	push	esi

; 677  : 
; 678  :     ret =

	push	84					; 00000054H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 679  :         (xmlSchematronParserCtxtPtr)
; 680  :         xmlMalloc(sizeof(xmlSchematronParserCtxt));
; 681  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 682  :         xmlSchematronPErrMemory(NULL, "allocating schema parser context",
; 683  :                                 NULL);
; 684  :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 700  : }

	pop	ebp
	ret	0
$LN3@xmlSchemat:

; 685  :     }
; 686  :     memset(ret, 0, sizeof(xmlSchematronParserCtxt));

	push	84					; 00000054H
	push	0
	push	esi
	call	_memset

; 687  :     ret->doc = doc;

	mov	DWORD PTR [esi+8], edi

; 688  :     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 689  :     /* The application has responsibility for the document */
; 690  :     ret->preserve = 1;
; 691  :     ret->xctxt = xmlXPathNewContext(doc);

	push	edi
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+12], 1
	call	_xmlXPathNewContext
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+36], eax

; 692  :     if (ret->xctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 693  :         xmlSchematronPErrMemory(NULL, "allocating schema parser XPath context",
; 694  :                                 NULL);
; 695  : 	xmlSchematronFreeParserCtxt(ret);

	push	esi
	call	_xmlSchematronFreeParserCtxt
	add	esp, 24					; 00000018H

; 696  :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 700  : }

	pop	ebp
	ret	0
$LN4@xmlSchemat:

; 697  :     }
; 698  : 
; 699  :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 700  : }

	pop	ebp
	ret	0
_xmlSchematronNewDocParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNewMemParserCtxt
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlSchematronNewMemParserCtxt PROC			; COMDAT

; 633  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _buffer$[ebp]
	test	ebx, ebx
	je	$LN3@xmlSchemat

; 634  :     xmlSchematronParserCtxtPtr ret;
; 635  : 
; 636  :     if ((buffer == NULL) || (size <= 0))

	mov	edi, DWORD PTR _size$[ebp]
	test	edi, edi
	jle	SHORT $LN3@xmlSchemat

; 638  : 
; 639  :     ret =

	push	esi
	push	84					; 00000054H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 640  :         (xmlSchematronParserCtxtPtr)
; 641  :         xmlMalloc(sizeof(xmlSchematronParserCtxt));
; 642  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 643  :         xmlSchematronPErrMemory(NULL, "allocating schema parser context",
; 644  :                                 NULL);
; 645  :         return (NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 659  : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlSchemat:

; 646  :     }
; 647  :     memset(ret, 0, sizeof(xmlSchematronParserCtxt));

	push	84					; 00000054H
	push	0
	push	esi
	call	_memset

; 648  :     ret->buffer = buffer;

	mov	DWORD PTR [esi+16], ebx

; 649  :     ret->size = size;

	mov	DWORD PTR [esi+20], edi

; 650  :     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 651  :     ret->xctxt = xmlXPathNewContext(NULL);

	push	0
	mov	DWORD PTR [esi+24], eax
	call	_xmlXPathNewContext
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+36], eax

; 652  :     if (ret->xctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 653  :         xmlSchematronPErrMemory(NULL, "allocating schema parser XPath context",
; 654  :                                 NULL);
; 655  : 	xmlSchematronFreeParserCtxt(ret);

	push	esi
	call	_xmlSchematronFreeParserCtxt
	add	esp, 24					; 00000018H
	xor	eax, eax
	pop	esi
	pop	edi

; 659  : }

	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlSchemat:

; 656  :         return (NULL);
; 657  :     }
; 658  :     return (ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 659  : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlSchemat:
	pop	edi

; 637  :         return (NULL);

	xor	eax, eax

; 659  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlSchematronNewMemParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\schematron.c
;	COMDAT _xmlSchematronNewParserCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlSchematronNewParserCtxt PROC			; COMDAT

; 591  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D7D5901C_schematron@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN2@xmlSchemat

; 592  :     xmlSchematronParserCtxtPtr ret;
; 593  : 
; 594  :     if (URL == NULL)
; 595  :         return (NULL);

	xor	eax, eax

; 619  : }

	pop	ebp
	ret	0
$LN2@xmlSchemat:
	push	esi

; 596  : 
; 597  :     ret =

	push	84					; 00000054H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 598  :         (xmlSchematronParserCtxtPtr)
; 599  :         xmlMalloc(sizeof(xmlSchematronParserCtxt));
; 600  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN3@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CB@NCMLFNIB@allocating?5schema?5parser?5contex@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 601  :         xmlSchematronPErrMemory(NULL, "allocating schema parser context",
; 602  :                                 NULL);
; 603  :         return (NULL);

	xor	eax, eax
	pop	esi

; 619  : }

	pop	ebp
	ret	0
$LN3@xmlSchemat:

; 604  :     }
; 605  :     memset(ret, 0, sizeof(xmlSchematronParserCtxt));

	push	80					; 00000050H
	lea	eax, DWORD PTR [esi+4]
	push	0
	push	eax
	call	_memset

; 606  :     ret->type = XML_STRON_CTXT_PARSER;

	mov	DWORD PTR [esi], 1

; 607  :     ret->dict = xmlDictCreate();

	call	_xmlDictCreate

; 608  :     ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);

	push	-1
	push	DWORD PTR _URL$[ebp]
	mov	DWORD PTR [esi+24], eax
	push	eax
	call	_xmlDictLookup

; 609  :     ret->includes = NULL;
; 610  :     ret->xctxt = xmlXPathNewContext(NULL);

	push	0
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+64], 0
	call	_xmlXPathNewContext
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+36], eax

; 611  :     if (ret->xctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSchemat

; 233  :     __xmlSimpleError(XML_FROM_SCHEMASP, XML_ERR_NO_MEMORY, node, NULL,

	push	OFFSET ??_C@_0CH@JIEMFKIC@allocating?5schema?5parser?5XPath?5@
	push	eax
	push	eax
	push	2
	push	16					; 00000010H
	call	___xmlSimpleError

; 612  :         xmlSchematronPErrMemory(NULL, "allocating schema parser XPath context",
; 613  :                                 NULL);
; 614  : 	xmlSchematronFreeParserCtxt(ret);

	push	esi
	call	_xmlSchematronFreeParserCtxt
	add	esp, 24					; 00000018H

; 615  :         return (NULL);

	xor	eax, eax
	pop	esi

; 619  : }

	pop	ebp
	ret	0
$LN4@xmlSchemat:

; 616  :     }
; 617  :     ret->xctxt->flags = XML_XPATH_CHECKNS;

	mov	DWORD PTR [eax+196], 1

; 618  :     return (ret);

	mov	eax, esi
	pop	esi

; 619  : }

	pop	ebp
	ret	0
_xmlSchematronNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
