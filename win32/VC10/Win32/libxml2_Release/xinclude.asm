; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xinclude.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__07371726_xinclude@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlXIncludeProcess
PUBLIC	_xmlXIncludeProcessFlags
PUBLIC	_xmlXIncludeProcessFlagsData
PUBLIC	_xmlXIncludeProcessTreeFlagsData
PUBLIC	_xmlXIncludeProcessTree
PUBLIC	_xmlXIncludeProcessTreeFlags
PUBLIC	_xmlXIncludeNewContext
PUBLIC	_xmlXIncludeSetFlags
PUBLIC	_xmlXIncludeFreeContext
PUBLIC	_xmlXIncludeProcessNode
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@ ; `string'
PUBLIC	??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@ ; `string'
PUBLIC	??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@	; `string'
PUBLIC	??_C@_0BK@NPNMIHKC@creating?5XInclude?5context@	; `string'
PUBLIC	??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0L@NDJLOKMA@adding?5URL@			; `string'
PUBLIC	??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ ; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05GOEGCMJM@parse@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_04CIMGMMMG@text@				; `string'
PUBLIC	??_C@_0BO@KBIJIENG@invalid?5value?5?$CFs?5for?5?8parse?8?6@ ; `string'
PUBLIC	??_C@_0BC@LNHFKIFC@failed?5build?5URL?6@	; `string'
PUBLIC	??_C@_08DNJCJFMK@xpointer@			; `string'
PUBLIC	??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0EC@PPIAEBNK@Invalid?5fragment?5identifier?5in?5@ ; `string'
PUBLIC	??_C@_0DD@GKECCJLJ@detected?5a?5local?5recursion?5with@ ; `string'
PUBLIC	??_C@_0P@NPOPFDNN@processing?5doc@		; `string'
PUBLIC	??_C@_0BA@KMMAMGLP@processing?5text@		; `string'
PUBLIC	??_C@_0CH@PEJDIBGL@mismatch?5in?5redefinition?5of?5ent@ ; `string'
PUBLIC	??_C@_0CD@PEMEOEGM@could?5not?5create?5XPointer?5conte@ ; `string'
PUBLIC	??_C@_0CB@CBJIEBBP@XPointer?5evaluation?5failed?3?5?$CD?$CFs@ ; `string'
PUBLIC	??_C@_0BO@BAOAOILH@XPointer?5is?5not?5a?5range?3?5?$CD?$CFs?6@ ; `string'
PUBLIC	??_C@_0CE@BOPHMAJL@XPointer?5selects?5an?5attribute?3?5@ ; `string'
PUBLIC	??_C@_0CD@OMDJDBLC@XPointer?5selects?5a?5namespace?3?5?$CD@ ; `string'
PUBLIC	??_C@_0CI@NPJMIHPM@XPointer?5selects?5unexpected?5nod@ ; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_0CG@KGJNPLJO@trying?5to?5build?5relative?5URI?5fr@ ; `string'
PUBLIC	??_C@_0CA@DKDEEGND@trying?5to?5rebuild?5base?5from?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CM@EOJCKNLM@fragment?5identifier?5forbidden?5f@ ; `string'
PUBLIC	??_C@_0CO@JGKFOGCG@text?5serialization?5of?5document?5@ ; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding@			; `string'
PUBLIC	??_C@_0BL@EIOJIGPP@encoding?5?$CFs?5not?5supported?6@ ; `string'
PUBLIC	??_C@_0BK@JOLCHMFH@?$CFs?5contains?5invalid?5char?6@ ; `string'
PUBLIC	??_C@_08LFBOCJLE@fallback@			; `string'
PUBLIC	??_C@_0CO@LMECEKCE@could?5not?5load?5?$CFs?0?5and?5no?5fallb@ ; `string'
PUBLIC	??_C@_0DF@GJKNHIHG@XInclude?5error?3?5would?5result?5in@ ; `string'
PUBLIC	??_C@_0BG@FIICHNCC@failed?5to?5build?5node?6@	; `string'
PUBLIC	??_C@_07FHOHOHLG@include@			; `string'
PUBLIC	??_C@_0BL@JFPJOKPM@?$CFs?5has?5an?5?8include?8?5child?6@ ; `string'
PUBLIC	??_C@_0CD@NFGHFOEO@?$CFs?5has?5multiple?5fallback?5childr@ ; `string'
PUBLIC	??_C@_0CF@BKGBMCAE@?$CFs?5is?5not?5the?5child?5of?5an?5?8incl@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlCreateIntSubset:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlNewTextLen:PROC
EXTRN	_xmlCopyNode:PROC
EXTRN	_xmlDocCopyNode:PROC
EXTRN	_xmlDocCopyNodeList:PROC
EXTRN	_xmlCopyNodeList:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddPrevSibling:PROC
EXTRN	_xmlAddNextSibling:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlGetNsProp:PROC
EXTRN	_xmlNodeAddContentLen:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlNodeSetBase:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlAddDocEntity:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlGetCharEncodingHandler:PROC
EXTRN	_xmlParseCharEncoding:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	_xmlParserInputBufferRead:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_xmlParseDocument:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	_xmlCtxtUseOptions:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlBuildRelativeURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlSaveUri:PROC
EXTRN	_xmlURIEscape:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPtrNewContext:PROC
EXTRN	_xmlXPtrEval:PROC
EXTRN	_xmlFreeInputStream:PROC
EXTRN	_inputPush:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlBufLength:PROC
EXTRN	_xmlXPtrAdvanceNode:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
;	COMDAT ??_C@_0CF@BKGBMCAE@?$CFs?5is?5not?5the?5child?5of?5an?5?8incl@
CONST	SEGMENT
??_C@_0CF@BKGBMCAE@?$CFs?5is?5not?5the?5child?5of?5an?5?8incl@ DB '%s is '
	DB	'not the child of an ''include''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NFGHFOEO@?$CFs?5has?5multiple?5fallback?5childr@
CONST	SEGMENT
??_C@_0CD@NFGHFOEO@?$CFs?5has?5multiple?5fallback?5childr@ DB '%s has mul'
	DB	'tiple fallback children', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JFPJOKPM@?$CFs?5has?5an?5?8include?8?5child?6@
CONST	SEGMENT
??_C@_0BL@JFPJOKPM@?$CFs?5has?5an?5?8include?8?5child?6@ DB '%s has an '''
	DB	'include'' child', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHOHOHLG@include@
CONST	SEGMENT
??_C@_07FHOHOHLG@include@ DB 'include', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FIICHNCC@failed?5to?5build?5node?6@
CONST	SEGMENT
??_C@_0BG@FIICHNCC@failed?5to?5build?5node?6@ DB 'failed to build node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GJKNHIHG@XInclude?5error?3?5would?5result?5in@
CONST	SEGMENT
??_C@_0DF@GJKNHIHG@XInclude?5error?3?5would?5result?5in@ DB 'XInclude err'
	DB	'or: would result in multiple root nodes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LMECEKCE@could?5not?5load?5?$CFs?0?5and?5no?5fallb@
CONST	SEGMENT
??_C@_0CO@LMECEKCE@could?5not?5load?5?$CFs?0?5and?5no?5fallb@ DB 'could n'
	DB	'ot load %s, and no fallback was found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LFBOCJLE@fallback@
CONST	SEGMENT
??_C@_08LFBOCJLE@fallback@ DB 'fallback', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JOLCHMFH@?$CFs?5contains?5invalid?5char?6@
CONST	SEGMENT
??_C@_0BK@JOLCHMFH@?$CFs?5contains?5invalid?5char?6@ DB '%s contains inva'
	DB	'lid char', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EIOJIGPP@encoding?5?$CFs?5not?5supported?6@
CONST	SEGMENT
??_C@_0BL@EIOJIGPP@encoding?5?$CFs?5not?5supported?6@ DB 'encoding %s not'
	DB	' supported', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding@ DB 'encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JGKFOGCG@text?5serialization?5of?5document?5@
CONST	SEGMENT
??_C@_0CO@JGKFOGCG@text?5serialization?5of?5document?5@ DB 'text serializ'
	DB	'ation of document not available', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EOJCKNLM@fragment?5identifier?5forbidden?5f@
CONST	SEGMENT
??_C@_0CM@EOJCKNLM@fragment?5identifier?5forbidden?5f@ DB 'fragment ident'
	DB	'ifier forbidden for text: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKDEEGND@trying?5to?5rebuild?5base?5from?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@DKDEEGND@trying?5to?5rebuild?5base?5from?5?$CFs?6@ DB 'trying t'
	DB	'o rebuild base from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KGJNPLJO@trying?5to?5build?5relative?5URI?5fr@
CONST	SEGMENT
??_C@_0CG@KGJNPLJO@trying?5to?5build?5relative?5URI?5fr@ DB 'trying to bu'
	DB	'ild relative URI from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NPJMIHPM@XPointer?5selects?5unexpected?5nod@
CONST	SEGMENT
??_C@_0CI@NPJMIHPM@XPointer?5selects?5unexpected?5nod@ DB 'XPointer selec'
	DB	'ts unexpected nodes: #%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OMDJDBLC@XPointer?5selects?5a?5namespace?3?5?$CD@
CONST	SEGMENT
??_C@_0CD@OMDJDBLC@XPointer?5selects?5a?5namespace?3?5?$CD@ DB 'XPointer '
	DB	'selects a namespace: #%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BOPHMAJL@XPointer?5selects?5an?5attribute?3?5@
CONST	SEGMENT
??_C@_0CE@BOPHMAJL@XPointer?5selects?5an?5attribute?3?5@ DB 'XPointer sel'
	DB	'ects an attribute: #%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BAOAOILH@XPointer?5is?5not?5a?5range?3?5?$CD?$CFs?6@
CONST	SEGMENT
??_C@_0BO@BAOAOILH@XPointer?5is?5not?5a?5range?3?5?$CD?$CFs?6@ DB 'XPoint'
	DB	'er is not a range: #%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBJIEBBP@XPointer?5evaluation?5failed?3?5?$CD?$CFs@
CONST	SEGMENT
??_C@_0CB@CBJIEBBP@XPointer?5evaluation?5failed?3?5?$CD?$CFs@ DB 'XPointe'
	DB	'r evaluation failed: #%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PEMEOEGM@could?5not?5create?5XPointer?5conte@
CONST	SEGMENT
??_C@_0CD@PEMEOEGM@could?5not?5create?5XPointer?5conte@ DB 'could not cre'
	DB	'ate XPointer context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PEJDIBGL@mismatch?5in?5redefinition?5of?5ent@
CONST	SEGMENT
??_C@_0CH@PEJDIBGL@mismatch?5in?5redefinition?5of?5ent@ DB 'mismatch in r'
	DB	'edefinition of entity %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMMAMGLP@processing?5text@
CONST	SEGMENT
??_C@_0BA@KMMAMGLP@processing?5text@ DB 'processing text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPOPFDNN@processing?5doc@
CONST	SEGMENT
??_C@_0P@NPOPFDNN@processing?5doc@ DB 'processing doc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GKECCJLJ@detected?5a?5local?5recursion?5with@
CONST	SEGMENT
??_C@_0DD@GKECCJLJ@detected?5a?5local?5recursion?5with@ DB 'detected a lo'
	DB	'cal recursion with no xpointer in %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@PPIAEBNK@Invalid?5fragment?5identifier?5in?5@
CONST	SEGMENT
??_C@_0EC@PPIAEBNK@Invalid?5fragment?5identifier?5in?5@ DB 'Invalid fragm'
	DB	'ent identifier in URI %s use the xpointer attribute', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@ DB 'invalid value URI %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNJCJFMK@xpointer@
CONST	SEGMENT
??_C@_08DNJCJFMK@xpointer@ DB 'xpointer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNHFKIFC@failed?5build?5URL?6@
CONST	SEGMENT
??_C@_0BC@LNHFKIFC@failed?5build?5URL?6@ DB 'failed build URL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KBIJIENG@invalid?5value?5?$CFs?5for?5?8parse?8?6@
CONST	SEGMENT
??_C@_0BO@KBIJIENG@invalid?5value?5?$CFs?5for?5?8parse?8?6@ DB 'invalid v'
	DB	'alue %s for ''parse''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIMGMMMG@text@
CONST	SEGMENT
??_C@_04CIMGMMMG@text@ DB 'text', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOEGCMJM@parse@
CONST	SEGMENT
??_C@_05GOEGCMJM@parse@ DB 'parse', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
CONST	SEGMENT
??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ DB 'cannot allocate'
	DB	' parser context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDJLOKMA@adding?5URL@
CONST	SEGMENT
??_C@_0L@NDJLOKMA@adding?5URL@ DB 'adding URL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@ DB 'detected a re'
	DB	'cursion in %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NPNMIHKC@creating?5XInclude?5context@
CONST	SEGMENT
??_C@_0BK@NPNMIHKC@creating?5XInclude?5context@ DB 'creating XInclude con'
	DB	'text', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
CONST	SEGMENT
??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@ DB 'growing XInclude conte'
	DB	'xt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
CONST	SEGMENT
??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@ DB 'http://www'
	DB	'.w3.org/2001/XInclude', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
CONST	SEGMENT
??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@ DB 'http://www'
	DB	'.w3.org/2003/XInclude', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeTestNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXIncludeTestNode PROC				; COMDAT

; 2286 : xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	$LN18@xmlXInclud

; 2287 :     if (node == NULL)
; 2288 : 	return(0);
; 2289 :     if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [edi+4], 1
	jne	$LN18@xmlXInclud

; 2290 : 	return(0);
; 2291 :     if (node->ns == NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	$LN18@xmlXInclud

; 2292 : 	return(0);
; 2293 :     if ((xmlStrEqual(node->ns->href, XINCLUDE_NS)) ||

	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlXInclud
	mov	eax, DWORD PTR [edi+36]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN18@xmlXInclud
$LN8@xmlXInclud:

; 2294 :         (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS))) {
; 2295 : 	if (xmlStrEqual(node->ns->href, XINCLUDE_OLD_NS)) {

	mov	eax, DWORD PTR [edi+36]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlXInclud

; 2296 : 	    if (ctxt->legacy == 0) {

	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN10@xmlXInclud

; 2297 : #if 0 /* wait for the XML Core Working Group to get something stable ! */
; 2298 : 		xmlXIncludeWarn(ctxt, node, XML_XINCLUDE_DEPRECATED_NS,
; 2299 : 	               "Deprecated XInclude namespace found, use %s",
; 2300 : 		                XINCLUDE_NS);
; 2301 : #endif
; 2302 : 	        ctxt->legacy = 1;

	mov	DWORD PTR [ebx+56], 1
$LN10@xmlXInclud:

; 2303 : 	    }
; 2304 : 	}
; 2305 : 	if (xmlStrEqual(node->name, XINCLUDE_NODE)) {

	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN11@xmlXInclud

; 2306 : 	    xmlNodePtr child = node->children;

	push	esi
	mov	esi, DWORD PTR [edi+12]

; 2307 : 	    int nb_fallback = 0;

	xor	ebx, ebx

; 2308 : 
; 2309 : 	    while (child != NULL) {

	test	esi, esi
	je	$LN16@xmlXInclud
	npad	5
$LL2@xmlXInclud:

; 2310 : 		if ((child->type == XML_ELEMENT_NODE) &&
; 2311 : 		    (child->ns != NULL) &&

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN15@xmlXInclud
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN15@xmlXInclud
	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlXInclud
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlXInclud
$LN13@xmlXInclud:

; 2312 : 		    ((xmlStrEqual(child->ns->href, XINCLUDE_NS)) ||
; 2313 : 		     (xmlStrEqual(child->ns->href, XINCLUDE_OLD_NS)))) {
; 2314 : 		    if (xmlStrEqual(child->name, XINCLUDE_NODE)) {

	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@xmlXInclud

; 2320 : 		    }
; 2321 : 		    if (xmlStrEqual(child->name, XINCLUDE_FALLBACK)) {

	push	OFFSET ??_C@_08LFBOCJLE@fallback@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlXInclud

; 2322 : 			nb_fallback++;

	inc	ebx
$LN15@xmlXInclud:

; 2323 : 		    }
; 2324 : 		}
; 2325 : 		child = child->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlXInclud

; 2326 : 	    }
; 2327 : 	    if (nb_fallback > 1) {

	cmp	ebx, 1
	jle	SHORT $LN16@xmlXInclud

; 2328 : 		xmlXIncludeErr(ctxt, node, XML_XINCLUDE_FALLBACKS_IN_INCLUDE,

	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	OFFSET ??_C@_0CD@NFGHFOEO@?$CFs?5has?5multiple?5fallback?5childr@
	push	1615					; 0000064fH
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
	xor	eax, eax
	pop	esi
	pop	edi

; 2350 : }

	pop	ebx
	pop	ebp
	ret	0
$LN23@xmlXInclud:

; 2315 : 			xmlXIncludeErr(ctxt, node,

	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	OFFSET ??_C@_0BL@JFPJOKPM@?$CFs?5has?5an?5?8include?8?5child?6@
	push	1614					; 0000064eH
	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 2316 : 			               XML_XINCLUDE_INCLUDE_IN_INCLUDE,
; 2317 : 				       "%s has an 'include' child\n",
; 2318 : 				       XINCLUDE_NODE);
; 2319 : 			return(0);

	xor	eax, eax
	pop	esi
	pop	edi

; 2350 : }

	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlXInclud:
	pop	esi
	pop	edi

; 2329 : 			       "%s has multiple fallback children\n",
; 2330 : 		               XINCLUDE_NODE);
; 2331 : 		return(0);
; 2332 : 	    }
; 2333 : 	    return(1);

	mov	eax, 1

; 2350 : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlXInclud:

; 2334 : 	}
; 2335 : 	if (xmlStrEqual(node->name, XINCLUDE_FALLBACK)) {

	push	OFFSET ??_C@_08LFBOCJLE@fallback@
	push	DWORD PTR [edi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlXInclud

; 2336 : 	    if ((node->parent == NULL) ||
; 2337 : 		(node->parent->type != XML_ELEMENT_NODE) ||
; 2338 : 		(node->parent->ns == NULL) ||
; 2339 : 		((!xmlStrEqual(node->parent->ns->href, XINCLUDE_NS)) &&
; 2340 : 		 (!xmlStrEqual(node->parent->ns->href, XINCLUDE_OLD_NS))) ||

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN19@xmlXInclud
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN19@xmlXInclud
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN19@xmlXInclud
	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@xmlXInclud
	mov	eax, DWORD PTR [edi+20]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	mov	eax, DWORD PTR [eax+36]
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlXInclud
$LN20@xmlXInclud:
	mov	eax, DWORD PTR [edi+20]
	push	OFFSET ??_C@_07FHOHOHLG@include@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@xmlXInclud
$LN19@xmlXInclud:

; 2341 : 		(!xmlStrEqual(node->parent->name, XINCLUDE_NODE))) {
; 2342 : 		xmlXIncludeErr(ctxt, node,

	push	OFFSET ??_C@_08LFBOCJLE@fallback@
	push	OFFSET ??_C@_0CF@BKGBMCAE@?$CFs?5is?5not?5the?5child?5of?5an?5?8incl@
	push	1616					; 00000650H
	push	edi
	push	ebx
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
$LN18@xmlXInclud:

; 2343 : 		               XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE,
; 2344 : 			       "%s is not the child of an 'include'\n",
; 2345 : 			       XINCLUDE_FALLBACK);
; 2346 : 	    }
; 2347 : 	}
; 2348 :     }
; 2349 :     return(0);

	pop	edi
	xor	eax, eax

; 2350 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlXIncludeTestNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeIncludeNode
_TEXT	SEGMENT
_end$2$ = -4						; size = 4
tv475 = 8						; size = 4
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_xmlXIncludeIncludeNode PROC				; COMDAT

; 2186 : xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN10@xmlXInclud

; 2187 :     xmlNodePtr cur, end, list, tmp;
; 2188 : 
; 2189 :     if (ctxt == NULL)
; 2190 : 	return(-1);
; 2191 :     if ((nr < 0) || (nr >= ctxt->incNr))

	mov	eax, DWORD PTR _nr$[ebp]
	test	eax, eax
	js	$LN10@xmlXInclud
	cmp	eax, DWORD PTR [ebx+8]
	jge	$LN10@xmlXInclud

; 2192 : 	return(-1);
; 2193 :     cur = ctxt->incTab[nr]->ref;

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR tv475[ebp], esi
	mov	ecx, DWORD PTR [eax+esi]
	mov	edi, DWORD PTR [ecx+12]

; 2194 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	test	edi, edi
	je	$LN10@xmlXInclud
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN10@xmlXInclud

; 2195 : 	return(-1);
; 2196 : 
; 2197 :     /*
; 2198 :      * If we stored an XPointer a late computation may be needed
; 2199 :      */
; 2200 :     if ((ctxt->incTab[nr]->inc == NULL) &&

	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN13@xmlXInclud
	mov	ecx, DWORD PTR [ecx+28]
	test	ecx, ecx
	je	SHORT $LN13@xmlXInclud

; 2201 : 	(ctxt->incTab[nr]->xptr != NULL)) {
; 2202 : 	ctxt->incTab[nr]->inc =

	mov	eax, DWORD PTR [ebx]
	push	ecx
	push	eax
	push	eax
	push	ebx
	call	_xmlXIncludeCopyXPointer
	mov	ecx, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	DWORD PTR [ecx+16], eax

; 2203 : 	    xmlXIncludeCopyXPointer(ctxt, ctxt->doc, ctxt->doc,
; 2204 : 		                    ctxt->incTab[nr]->xptr);
; 2205 : 	xmlXPathFreeObject(ctxt->incTab[nr]->xptr);

	mov	eax, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+esi]
	push	DWORD PTR [eax+28]
	call	_xmlXPathFreeObject

; 2206 : 	ctxt->incTab[nr]->xptr = NULL;

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR [eax+esi]
	mov	DWORD PTR [eax+28], 0
	mov	eax, DWORD PTR [ebx+16]
$LN13@xmlXInclud:

; 2207 :     }
; 2208 :     list = ctxt->incTab[nr]->inc;

	mov	eax, DWORD PTR [esi+eax]
	mov	esi, DWORD PTR [eax+16]

; 2209 :     ctxt->incTab[nr]->inc = NULL;

	mov	DWORD PTR [eax+16], 0

; 2210 : 
; 2211 :     /*
; 2212 :      * Check against the risk of generating a multi-rooted document
; 2213 :      */
; 2214 :     if ((cur->parent != NULL) &&

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN16@xmlXInclud
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN16@xmlXInclud

; 2215 : 	(cur->parent->type != XML_ELEMENT_NODE)) {
; 2216 : 	int nb_elem = 0;

	xor	edx, edx

; 2217 : 
; 2218 : 	tmp = list;

	mov	ecx, esi

; 2219 : 	while (tmp != NULL) {

	test	esi, esi
	je	SHORT $LN16@xmlXInclud
	npad	7
$LL2@xmlXInclud:

; 2220 : 	    if (tmp->type == XML_ELEMENT_NODE)
; 2221 : 		nb_elem++;
; 2222 : 	    tmp = tmp->next;

	cmp	DWORD PTR [ecx+4], 1
	lea	eax, DWORD PTR [edx+1]
	mov	ecx, DWORD PTR [ecx+24]
	cmovne	eax, edx
	mov	edx, eax
	test	ecx, ecx
	jne	SHORT $LL2@xmlXInclud

; 2223 : 	}
; 2224 : 	if (nb_elem > 1) {

	cmp	edx, 1
	jle	SHORT $LN16@xmlXInclud

; 2225 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	ecx
	push	OFFSET ??_C@_0DF@GJKNHIHG@XInclude?5error?3?5would?5result?5in@
	push	1611					; 0000064bH
$LN33@xmlXInclud:

; 2274 : }

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR tv475[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+12]
	push	ebx
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
$LN10@xmlXInclud:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXInclud:

; 2226 : 	                   XML_XINCLUDE_MULTIPLE_ROOT,
; 2227 : 		       "XInclude error: would result in multiple root nodes\n",
; 2228 : 			   NULL);
; 2229 : 	    return(-1);
; 2230 : 	}
; 2231 :     }
; 2232 : 
; 2233 :     if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {

	test	DWORD PTR [ebx+60], 32768		; 00008000H
	je	SHORT $LN17@xmlXInclud

; 2234 : 	/*
; 2235 : 	 * Add the list of nodes
; 2236 : 	 */
; 2237 : 	while (list != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlXInclud
	npad	1
$LL4@xmlXInclud:

; 2238 : 	    end = list;
; 2239 : 	    list = list->next;
; 2240 : 
; 2241 : 	    xmlAddPrevSibling(cur, end);

	push	esi
	mov	esi, DWORD PTR [esi+24]
	push	edi
	call	_xmlAddPrevSibling
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL4@xmlXInclud
$LN5@xmlXInclud:

; 2242 : 	}
; 2243 : 	xmlUnlinkNode(cur);

	push	edi
	call	_xmlUnlinkNode

; 2244 : 	xmlFreeNode(cur);

	push	edi
	call	_xmlFreeNode
	add	esp, 8

; 2269 : 	}
; 2270 :     }
; 2271 : 
; 2272 : 
; 2273 :     return(0);

	xor	eax, eax
	pop	edi

; 2274 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXInclud:

; 2245 :     } else {
; 2246 : 	/*
; 2247 : 	 * Change the current node as an XInclude start one, and add an
; 2248 : 	 * XInclude end one
; 2249 : 	 */
; 2250 : 	cur->type = XML_XINCLUDE_START;
; 2251 : 	end = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);

	push	0
	push	DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], 19			; 00000013H
	push	DWORD PTR [edi+36]
	push	DWORD PTR [edi+32]
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _end$2$[ebp], eax

; 2252 : 	if (end == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlXInclud

; 2253 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	eax
	push	OFFSET ??_C@_0BG@FIICHNCC@failed?5to?5build?5node?6@
	push	1609					; 00000649H

; 2254 : 	                   XML_XINCLUDE_BUILD_FAILED,
; 2255 : 			   "failed to build node\n", NULL);
; 2256 : 	    return(-1);

	jmp	$LN33@xmlXInclud
$LN19@xmlXInclud:

; 2257 : 	}
; 2258 : 	end->type = XML_XINCLUDE_END;

	mov	ebx, DWORD PTR _end$2$[ebp]

; 2259 : 	xmlAddNextSibling(cur, end);

	push	ebx
	push	edi
	mov	DWORD PTR [ebx+4], 20			; 00000014H
	call	_xmlAddNextSibling
	add	esp, 8

; 2260 : 
; 2261 : 	/*
; 2262 : 	 * Add the list of nodes
; 2263 : 	 */
; 2264 : 	while (list != NULL) {

	test	esi, esi
	je	SHORT $LN7@xmlXInclud
$LL6@xmlXInclud:

; 2265 : 	    cur = list;
; 2266 : 	    list = list->next;
; 2267 : 
; 2268 : 	    xmlAddPrevSibling(end, cur);

	push	esi
	mov	esi, DWORD PTR [esi+24]
	push	ebx
	call	_xmlAddPrevSibling
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL6@xmlXInclud
$LN7@xmlXInclud:
	pop	edi

; 2274 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeIncludeNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeLoadNode
_TEXT	SEGMENT
_newctxt$1$ = -32					; size = 4
_cur$1$ = -32						; size = 4
_oldBase$1$ = -28					; size = 4
_eschref$1$ = -28					; size = 4
_escbase$1$ = -24					; size = 4
_xml$1$ = -20						; size = 4
_base$1$ = -16						; size = 4
_href$1$ = -12						; size = 4
_parse$1$ = -8						; size = 4
tv493 = -4						; size = 4
_URI$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_xmlXIncludeLoadNode PROC				; COMDAT

; 2029 : xmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, int nr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _xml$1$[ebp], 1
	test	edi, edi
	je	$LN6@xmlXInclud

; 2030 :     xmlNodePtr cur;
; 2031 :     xmlChar *href;
; 2032 :     xmlChar *parse;
; 2033 :     xmlChar *base;
; 2034 :     xmlChar *oldBase;
; 2035 :     xmlChar *URI;
; 2036 :     int xml = 1; /* default Issue 64 */
; 2037 :     int ret;
; 2038 : 
; 2039 :     if (ctxt == NULL)
; 2040 : 	return(-1);
; 2041 :     if ((nr < 0) || (nr >= ctxt->incNr))

	mov	esi, DWORD PTR _nr$[ebp]
	test	esi, esi
	js	$LN6@xmlXInclud
	cmp	esi, DWORD PTR [edi+8]
	jge	$LN6@xmlXInclud

; 2042 : 	return(-1);
; 2043 :     cur = ctxt->incTab[nr]->ref;

	mov	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR tv493[ebp], ecx
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$1$[ebp], ebx

; 2044 :     if (cur == NULL)

	test	ebx, ebx
	je	$LN6@xmlXInclud

; 2045 : 	return(-1);
; 2046 : 
; 2047 :     /*
; 2048 :      * read the attributes
; 2049 :      */
; 2050 :     href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);

	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	ebx
	push	edi
	call	_xmlXIncludeGetProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _href$1$[ebp], eax

; 2051 :     if (href == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlXInclud

; 2052 : 	href = xmlStrdup(BAD_CAST ""); /* @@@@ href is now optional */

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _href$1$[ebp], eax

; 2053 : 	if (href == NULL)

	test	eax, eax
	je	$LN6@xmlXInclud
$LN9@xmlXInclud:

; 2054 : 	    return(-1);
; 2055 :     }
; 2056 :     parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);

	push	OFFSET ??_C@_05GOEGCMJM@parse@
	push	ebx
	push	edi
	call	_xmlXIncludeGetProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _parse$1$[ebp], eax

; 2057 :     if (parse != NULL) {

	test	eax, eax
	je	SHORT $LN14@xmlXInclud

; 2058 : 	if (xmlStrEqual(parse, XINCLUDE_PARSE_XML))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlXInclud

; 2059 : 	    xml = 1;

	mov	DWORD PTR _xml$1$[ebp], 1
$LN14@xmlXInclud:

; 2070 : 	    return(-1);
; 2071 : 	}
; 2072 :     }
; 2073 : 
; 2074 :     /*
; 2075 :      * compute the URI
; 2076 :      */
; 2077 :     base = xmlNodeGetBase(ctxt->doc, cur);

	push	ebx
	push	DWORD PTR [edi]
	call	_xmlNodeGetBase
	add	esp, 8
	mov	DWORD PTR _base$1$[ebp], eax

; 2078 :     if (base == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlXInclud

; 2079 : 	URI = xmlBuildURI(href, ctxt->doc->URL);

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+72]

; 2080 :     } else {

	jmp	SHORT $LN18@xmlXInclud
$LN11@xmlXInclud:

; 2060 : 	else if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))

	push	OFFSET ??_C@_04CIMGMMMG@text@
	push	DWORD PTR _parse$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlXInclud

; 2061 : 	    xml = 0;

	mov	DWORD PTR _xml$1$[ebp], 0
	jmp	SHORT $LN14@xmlXInclud
$LN13@xmlXInclud:

; 2062 : 	else {
; 2063 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR tv493[ebp]
	mov	ebx, DWORD PTR _parse$1$[ebp]
	push	ebx
	push	OFFSET ??_C@_0BO@KBIJIENG@invalid?5value?5?$CFs?5for?5?8parse?8?6@
	mov	eax, DWORD PTR [eax+ecx]
	push	1601					; 00000641H
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlXIncludeErr

; 2064 : 	                   XML_XINCLUDE_PARSE_VALUE,
; 2065 : 			   "invalid value %s for 'parse'\n", parse);
; 2066 : 	    if (href != NULL)

	mov	eax, DWORD PTR _href$1$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN15@xmlXInclud

; 2067 : 		xmlFree(href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlXInclud:

; 2068 : 	    if (parse != NULL)
; 2069 : 		xmlFree(parse);

	push	ebx

; 2173 :     return(0);
; 2174 : }

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlXInclud:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXInclud:

; 2081 : 	URI = xmlBuildURI(href, base);

	mov	ecx, eax
$LN18@xmlXInclud:

; 2082 :     }
; 2083 :     if (URI == NULL) {

	mov	ebx, DWORD PTR _href$1$[ebp]
	push	ecx
	push	ebx
	call	_xmlBuildURI
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _URI$1$[ebp], ecx
	test	ecx, ecx
	jne	$LN22@xmlXInclud

; 2084 : 	xmlChar *escbase;
; 2085 : 	xmlChar *eschref;
; 2086 : 	/*
; 2087 : 	 * Some escaping may be needed
; 2088 : 	 */
; 2089 : 	escbase = xmlURIEscape(base);

	push	DWORD PTR _base$1$[ebp]
	call	_xmlURIEscape

; 2090 : 	eschref = xmlURIEscape(href);

	push	ebx
	mov	DWORD PTR _escbase$1$[ebp], eax
	call	_xmlURIEscape

; 2091 : 	URI = xmlBuildURI(eschref, escbase);

	push	DWORD PTR _escbase$1$[ebp]
	mov	DWORD PTR _eschref$1$[ebp], eax
	push	eax
	call	_xmlBuildURI
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 2092 : 	if (escbase != NULL)

	mov	eax, DWORD PTR _escbase$1$[ebp]
	mov	DWORD PTR _URI$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN20@xmlXInclud

; 2093 : 	    xmlFree(escbase);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _URI$1$[ebp]
	add	esp, 4
$LN20@xmlXInclud:

; 2094 : 	if (eschref != NULL)

	mov	eax, DWORD PTR _eschref$1$[ebp]
	test	eax, eax
	je	SHORT $LN21@xmlXInclud

; 2095 : 	    xmlFree(eschref);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _URI$1$[ebp]
	add	esp, 4
$LN21@xmlXInclud:

; 2096 :     }
; 2097 :     if (URI == NULL) {

	test	ecx, ecx
	jne	SHORT $LN22@xmlXInclud

; 2098 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, DWORD PTR tv493[ebp]
	push	OFFSET ??_C@_0BC@LNHFKIFC@failed?5build?5URL?6@
	push	1605					; 00000645H
	mov	eax, DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlXIncludeErr

; 2099 : 	               XML_XINCLUDE_HREF_URI, "failed build URL\n", NULL);
; 2100 : 	if (parse != NULL)

	mov	eax, DWORD PTR _parse$1$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN23@xmlXInclud

; 2101 : 	    xmlFree(parse);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlXInclud:

; 2102 : 	if (href != NULL)

	test	ebx, ebx
	je	SHORT $LN24@xmlXInclud

; 2103 : 	    xmlFree(href);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlXInclud:

; 2104 : 	if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	$LN6@xmlXInclud

; 2105 : 	    xmlFree(base);

	push	eax

; 2173 :     return(0);
; 2174 : }

	call	DWORD PTR _xmlFree
	add	esp, 4
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlXInclud:

; 2106 : 	return(-1);
; 2107 :     }
; 2108 : #ifdef DEBUG_XINCLUDE
; 2109 :     xmlGenericError(xmlGenericErrorContext, "parse: %s\n",
; 2110 : 	    xml ? "xml": "text");
; 2111 :     xmlGenericError(xmlGenericErrorContext, "URI: %s\n", URI);
; 2112 : #endif
; 2113 : 
; 2114 :     /*
; 2115 :      * Save the base for this include (saving the current one)
; 2116 :      */
; 2117 :     oldBase = ctxt->base;
; 2118 :     ctxt->base = base;
; 2119 : 
; 2120 :     if (xml) {

	cmp	DWORD PTR _xml$1$[ebp], 0
	mov	eax, DWORD PTR [edi+64]
	push	esi
	mov	DWORD PTR _oldBase$1$[ebp], eax
	mov	eax, DWORD PTR _base$1$[ebp]
	push	ecx
	mov	DWORD PTR [edi+64], eax
	push	edi
	je	SHORT $LN26@xmlXInclud

; 2121 : 	ret = xmlXIncludeLoadDoc(ctxt, URI, nr);

	call	_xmlXIncludeLoadDoc

; 2122 : 	/* xmlXIncludeGetFragment(ctxt, cur, URI); */
; 2123 :     } else {

	jmp	SHORT $LN98@xmlXInclud
$LN26@xmlXInclud:

; 2124 : 	ret = xmlXIncludeLoadTxt(ctxt, URI, nr);

	call	_xmlXIncludeLoadTxt
$LN98@xmlXInclud:

; 2125 :     }
; 2126 : 
; 2127 :     /*
; 2128 :      * Restore the original base before checking for fallback
; 2129 :      */
; 2130 :     ctxt->base = oldBase;

	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _oldBase$1$[ebp]
	mov	DWORD PTR [edi+64], eax

; 2131 : 
; 2132 :     if (ret < 0) {

	test	ebx, ebx
	jns	$LN95@xmlXInclud

; 2133 : 	xmlNodePtr children;
; 2134 : 
; 2135 : 	/*
; 2136 : 	 * Time to try a fallback if availble
; 2137 : 	 */
; 2138 : #ifdef DEBUG_XINCLUDE
; 2139 : 	xmlGenericError(xmlGenericErrorContext, "error looking for fallback\n");
; 2140 : #endif
; 2141 : 	children = cur->children;

	mov	esi, DWORD PTR _cur$1$[ebp]
	mov	esi, DWORD PTR [esi+12]

; 2142 : 	while (children != NULL) {

	test	esi, esi
	je	$LN94@xmlXInclud
	npad	1
$LL2@xmlXInclud:

; 2143 : 	    if ((children->type == XML_ELEMENT_NODE) &&
; 2144 : 		(children->ns != NULL) &&
; 2145 : 		(xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&

	cmp	DWORD PTR [esi+4], 1
	jne	$LN31@xmlXInclud
	cmp	DWORD PTR [esi+36], 0
	je	$LN31@xmlXInclud
	push	OFFSET ??_C@_08LFBOCJLE@fallback@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN31@xmlXInclud
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@xmlXInclud
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN31@xmlXInclud
$LN30@xmlXInclud:

; 1965 :     int ret = 0;

	xor	ebx, ebx

; 1966 : 
; 1967 :     if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	$LN40@xmlXInclud

; 1968 :         (ctxt == NULL))
; 1969 : 	return(-1);
; 1970 :     if (fallback->children != NULL) {

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN41@xmlXInclud

; 1971 : 	/*
; 1972 : 	 * It's possible that the fallback also has 'includes'
; 1973 : 	 * (Bug 129969), so we re-process the fallback just in case
; 1974 : 	 */
; 1975 : 	newctxt = xmlXIncludeNewContext(ctxt->doc);

	push	DWORD PTR [edi]
	call	_xmlXIncludeNewContext
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _newctxt$1$[ebp], ebx

; 1976 : 	if (newctxt == NULL)

	test	ebx, ebx
	je	$LN40@xmlXInclud

; 1977 : 	    return (-1);
; 1978 : 	newctxt->_private = ctxt->_private;

	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [ebx+68], eax

; 1979 : 	newctxt->base = xmlStrdup(ctxt->base);	/* Inherit the base from the existing context */

	push	DWORD PTR [edi+64]
	call	_xmlStrdup
	mov	DWORD PTR [ebx+64], eax

; 1980 : 	xmlXIncludeSetFlags(newctxt, ctxt->parseFlags);

	push	DWORD PTR [edi+60]
	push	ebx
	call	_xmlXIncludeSetFlags

; 1981 : 	ret = xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback->children);

	push	DWORD PTR [esi+12]
	push	DWORD PTR [edi]
	push	ebx
	call	_xmlXIncludeDoProcess
	add	esp, 24					; 00000018H
	mov	ebx, eax

; 1982 : 	if (ctxt->nbErrors > 0)

	cmp	DWORD PTR [edi+52], 0
	jle	SHORT $LN44@xmlXInclud

; 1983 : 	    ret = -1;

	or	ebx, -1
	jmp	SHORT $LN46@xmlXInclud
$LN44@xmlXInclud:

; 1984 : 	else if (ret > 0)

	xor	eax, eax
	test	ebx, ebx
	cmovg	ebx, eax
$LN46@xmlXInclud:

; 1985 : 	    ret = 0;	/* xmlXIncludeDoProcess can return +ve number */
; 1986 : 	xmlXIncludeFreeContext(newctxt);

	push	DWORD PTR _newctxt$1$[ebp]
	call	_xmlXIncludeFreeContext

; 1987 : 
; 1988 : 	ctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,

	push	DWORD PTR [esi+12]
	push	DWORD PTR [edi]
	call	_xmlDocCopyNodeList
	mov	ecx, DWORD PTR [edi+16]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR tv493[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [ecx+16], eax

; 1989 : 	                                           fallback->children);
; 1990 :     } else {

	jmp	SHORT $LN42@xmlXInclud
$LN41@xmlXInclud:

; 1991 :         ctxt->incTab[nr]->inc = NULL;

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR tv493[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [eax+16], ebx

; 1992 : 	ctxt->incTab[nr]->emptyFb = 1;	/* flag empty callback */

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [eax+32], 1
$LN42@xmlXInclud:

; 2146 : 		((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||
; 2147 : 		 (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {
; 2148 : 		ret = xmlXIncludeLoadFallback(ctxt, children, nr);
; 2149 : 		if (ret == 0)

	test	ebx, ebx
	je	SHORT $LN99@xmlXInclud
	jmp	SHORT $LN31@xmlXInclud
$LN40@xmlXInclud:

; 2150 : 		    break;
; 2151 : 	    }
; 2152 : 	    children = children->next;

	or	ebx, -1
$LN31@xmlXInclud:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlXInclud
$LN94@xmlXInclud:

; 2153 : 	}
; 2154 :     }
; 2155 :     if (ret < 0) {

	test	ebx, ebx
$LN99@xmlXInclud:
	mov	esi, DWORD PTR _URI$1$[ebp]
	jns	SHORT $LN32@xmlXInclud

; 2156 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR tv493[ebp]
	push	esi
	push	OFFSET ??_C@_0CO@LMECEKCE@could?5not?5load?5?$CFs?0?5and?5no?5fallb@
	push	1604					; 00000644H
	mov	eax, DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
	jmp	SHORT $LN32@xmlXInclud
$LN95@xmlXInclud:

; 2131 : 
; 2132 :     if (ret < 0) {

	mov	esi, DWORD PTR _URI$1$[ebp]
$LN32@xmlXInclud:

; 2157 : 	               XML_XINCLUDE_NO_FALLBACK,
; 2158 : 		       "could not load %s, and no fallback was found\n",
; 2159 : 		       URI);
; 2160 :     }
; 2161 : 
; 2162 :     /*
; 2163 :      * Cleanup
; 2164 :      */
; 2165 :     if (URI != NULL)
; 2166 : 	xmlFree(URI);

	push	esi
	call	DWORD PTR _xmlFree

; 2167 :     if (parse != NULL)

	mov	eax, DWORD PTR _parse$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN34@xmlXInclud

; 2168 : 	xmlFree(parse);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlXInclud:

; 2169 :     if (href != NULL)

	mov	eax, DWORD PTR _href$1$[ebp]
	test	eax, eax
	je	SHORT $LN35@xmlXInclud

; 2170 : 	xmlFree(href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN35@xmlXInclud:

; 2171 :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	test	eax, eax
	je	SHORT $LN36@xmlXInclud

; 2172 : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlXInclud:

; 2173 :     return(0);
; 2174 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeLoadNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludePreProcessNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXIncludePreProcessNode PROC				; COMDAT

; 2014 : xmlXIncludePreProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXIncludeAddNode
	add	esp, 8
	xor	eax, eax

; 2015 :     xmlXIncludeAddNode(ctxt, node);
; 2016 :     return(NULL);
; 2017 : }

	pop	ebp
	ret	0
_xmlXIncludePreProcessNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeLoadFallback
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_newctxt$1$ = 12					; size = 4
_fallback$ = 12						; size = 4
_nr$ = 16						; size = 4
_xmlXIncludeLoadFallback PROC				; COMDAT

; 1963 : xmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _fallback$[ebp]
	xor	edi, edi
	test	ebx, ebx
	je	$LN3@xmlXInclud

; 1964 :     xmlXIncludeCtxtPtr newctxt;
; 1965 :     int ret = 0;
; 1966 : 
; 1967 :     if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||

	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN3@xmlXInclud
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlXInclud

; 1968 :         (ctxt == NULL))
; 1969 : 	return(-1);
; 1970 :     if (fallback->children != NULL) {

	cmp	DWORD PTR [ebx+12], edi
	je	SHORT $LN4@xmlXInclud

; 1971 : 	/*
; 1972 : 	 * It's possible that the fallback also has 'includes'
; 1973 : 	 * (Bug 129969), so we re-process the fallback just in case
; 1974 : 	 */
; 1975 : 	newctxt = xmlXIncludeNewContext(ctxt->doc);

	push	DWORD PTR [esi]
	call	_xmlXIncludeNewContext
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _newctxt$1$[ebp], edi

; 1976 : 	if (newctxt == NULL)

	test	edi, edi
	je	$LN3@xmlXInclud

; 1977 : 	    return (-1);
; 1978 : 	newctxt->_private = ctxt->_private;

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [edi+68], eax

; 1979 : 	newctxt->base = xmlStrdup(ctxt->base);	/* Inherit the base from the existing context */

	push	DWORD PTR [esi+64]
	call	_xmlStrdup
	mov	DWORD PTR [edi+64], eax

; 1980 : 	xmlXIncludeSetFlags(newctxt, ctxt->parseFlags);

	push	DWORD PTR [esi+60]
	push	edi
	call	_xmlXIncludeSetFlags

; 1981 : 	ret = xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback->children);

	push	DWORD PTR [ebx+12]
	push	DWORD PTR [esi]
	push	edi
	call	_xmlXIncludeDoProcess
	add	esp, 24					; 00000018H
	mov	edi, eax

; 1982 : 	if (ctxt->nbErrors > 0)

	cmp	DWORD PTR [esi+52], 0
	jle	SHORT $LN7@xmlXInclud

; 1983 : 	    ret = -1;

	or	edi, -1
	jmp	SHORT $LN9@xmlXInclud
$LN7@xmlXInclud:

; 1984 : 	else if (ret > 0)

	xor	eax, eax
	test	edi, edi
	cmovg	edi, eax
$LN9@xmlXInclud:

; 1985 : 	    ret = 0;	/* xmlXIncludeDoProcess can return +ve number */
; 1986 : 	xmlXIncludeFreeContext(newctxt);

	push	DWORD PTR _newctxt$1$[ebp]
	call	_xmlXIncludeFreeContext

; 1987 : 
; 1988 : 	ctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,

	push	DWORD PTR [ebx+12]
	push	DWORD PTR [esi]
	call	_xmlDocCopyNodeList
	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+16], eax

; 1993 :     }
; 1994 :     return(ret);

	mov	eax, edi
	pop	edi

; 1995 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlXInclud:

; 1989 : 	                                           fallback->children);
; 1990 :     } else {
; 1991 :         ctxt->incTab[nr]->inc = NULL;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+16], edi

; 1992 : 	ctxt->incTab[nr]->emptyFb = 1;	/* flag empty callback */

	mov	ecx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 1993 :     }
; 1994 :     return(ret);

	mov	eax, edi
	pop	edi

; 1995 : }

	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx+32], 1
	pop	ebp
	ret	0
$LN3@xmlXInclud:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlXIncludeLoadFallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeLoadTxt
_TEXT	SEGMENT
_inputStream$1$ = -32					; size = 4
_content$1$ = -28					; size = 4
_pctxt$1$ = -24						; size = 4
_l$1 = -20						; size = 4
_buf$1$ = -16						; size = 4
_xinclude_multibyte_fallback_used$1$ = -12		; size = 4
_node$1$ = -8						; size = 4
_URL$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_url$ = 12						; size = 4
_nr$ = 16						; size = 4
_xmlXIncludeLoadTxt PROC				; COMDAT

; 1797 : xmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _url$[ebp]
	xor	eax, eax
	push	edi
	mov	DWORD PTR _xinclude_multibyte_fallback_used$1$[ebp], eax
	call	_xmlParseURI
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN10@xmlXInclud

; 1798 :     xmlParserInputBufferPtr buf;
; 1799 :     xmlNodePtr node;
; 1800 :     xmlURIPtr uri;
; 1801 :     xmlChar *URL;
; 1802 :     int i;
; 1803 :     xmlChar *encoding = NULL;
; 1804 :     xmlCharEncoding enc = (xmlCharEncoding) 0;
; 1805 :     xmlParserCtxtPtr pctxt;
; 1806 :     xmlParserInputPtr inputStream;
; 1807 :     int xinclude_multibyte_fallback_used = 0;
; 1808 : 
; 1809 :     /*
; 1810 :      * Check the URL and remove any fragment identifier
; 1811 :      */
; 1812 :     uri = xmlParseURI((const char *)url);
; 1813 :     if (uri == NULL) {
; 1814 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	edi
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@

; 1798 :     xmlParserInputBufferPtr buf;
; 1799 :     xmlNodePtr node;
; 1800 :     xmlURIPtr uri;
; 1801 :     xmlChar *URL;
; 1802 :     int i;
; 1803 :     xmlChar *encoding = NULL;
; 1804 :     xmlCharEncoding enc = (xmlCharEncoding) 0;
; 1805 :     xmlParserCtxtPtr pctxt;
; 1806 :     xmlParserInputPtr inputStream;
; 1807 :     int xinclude_multibyte_fallback_used = 0;
; 1808 : 
; 1809 :     /*
; 1810 :      * Check the URL and remove any fragment identifier
; 1811 :      */
; 1812 :     uri = xmlParseURI((const char *)url);
; 1813 :     if (uri == NULL) {
; 1814 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,

	mov	ecx, DWORD PTR [edx+16]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	esi
	push	esi
	push	esi

; 1798 :     xmlParserInputBufferPtr buf;
; 1799 :     xmlNodePtr node;
; 1800 :     xmlURIPtr uri;
; 1801 :     xmlChar *URL;
; 1802 :     int i;
; 1803 :     xmlChar *encoding = NULL;
; 1804 :     xmlCharEncoding enc = (xmlCharEncoding) 0;
; 1805 :     xmlParserCtxtPtr pctxt;
; 1806 :     xmlParserInputPtr inputStream;
; 1807 :     int xinclude_multibyte_fallback_used = 0;
; 1808 : 
; 1809 :     /*
; 1810 :      * Check the URL and remove any fragment identifier
; 1811 :      */
; 1812 :     uri = xmlParseURI((const char *)url);
; 1813 :     if (uri == NULL) {
; 1814 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,

	mov	eax, DWORD PTR [ecx+eax*4]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	esi
	push	edi
	push	esi

; 1798 :     xmlParserInputBufferPtr buf;
; 1799 :     xmlNodePtr node;
; 1800 :     xmlURIPtr uri;
; 1801 :     xmlChar *URL;
; 1802 :     int i;
; 1803 :     xmlChar *encoding = NULL;
; 1804 :     xmlCharEncoding enc = (xmlCharEncoding) 0;
; 1805 :     xmlParserCtxtPtr pctxt;
; 1806 :     xmlParserInputPtr inputStream;
; 1807 :     int xinclude_multibyte_fallback_used = 0;
; 1808 : 
; 1809 :     /*
; 1810 :      * Check the URL and remove any fragment identifier
; 1811 :      */
; 1812 :     uri = xmlParseURI((const char *)url);
; 1813 :     if (uri == NULL) {
; 1814 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,

	mov	eax, DWORD PTR [eax+12]

; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [edx+52]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	esi
	push	2
	push	1605					; 00000645H
	push	11					; 0000000bH
	push	eax
	push	edx
	push	esi
	push	esi
	push	esi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1815 : 	               "invalid value URI %s\n", url);
; 1816 : 	return(-1);

	or	eax, -1
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXInclud:
	push	ebx

; 1817 :     }
; 1818 :     if (uri->fragment != NULL) {

	mov	ebx, DWORD PTR [esi+32]
	test	ebx, ebx
	je	SHORT $LN11@xmlXInclud

; 1819 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	ebx
	push	OFFSET ??_C@_0CM@EOJCKNLM@fragment?5identifier?5forbidden?5f@

; 1819 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,

	mov	ecx, DWORD PTR [edx+16]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	0
	push	0

; 1819 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,

	mov	eax, DWORD PTR [ecx+eax*4]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	ebx
	push	0

; 1819 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,

	mov	eax, DWORD PTR [eax+12]

; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [edx+52]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	2
	push	1606					; 00000646H
	push	11					; 0000000bH
	push	eax
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1820 : 	               "fragment identifier forbidden for text: %s\n",
; 1821 : 		       (const xmlChar *) uri->fragment);
; 1822 : 	xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 72					; 00000048H

; 1823 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXInclud:

; 1824 :     }
; 1825 :     URL = xmlSaveUri(uri);

	push	esi
	call	_xmlSaveUri
	mov	ebx, eax

; 1826 :     xmlFreeURI(uri);

	push	esi
	mov	DWORD PTR _URL$1$[ebp], ebx
	call	_xmlFreeURI
	add	esp, 8

; 1827 :     if (URL == NULL) {

	test	ebx, ebx
	jne	SHORT $LN12@xmlXInclud

; 1828 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]
	push	edi
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@
	mov	ecx, DWORD PTR [edx+16]
	push	1605					; 00000645H
	mov	eax, DWORD PTR [ecx+eax*4]
	push	DWORD PTR [eax+12]
	push	edx
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 1829 : 	               "invalid value URI %s\n", url);
; 1830 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXInclud:

; 1831 :     }
; 1832 : 
; 1833 :     /*
; 1834 :      * Handling of references to the local document are done
; 1835 :      * directly through ctxt->doc.
; 1836 :      */
; 1837 :     if (URL[0] == 0) {

	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN13@xmlXInclud

; 1838 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]
	push	0
	push	OFFSET ??_C@_0CO@JGKFOGCG@text?5serialization?5of?5document?5@
	mov	ecx, DWORD PTR [edx+16]
	push	1607					; 00000647H
	mov	eax, DWORD PTR [ecx+eax*4]
	push	DWORD PTR [eax+12]
	push	edx
	call	_xmlXIncludeErr

; 1839 : 	               XML_XINCLUDE_TEXT_DOCUMENT,
; 1840 : 		       "text serialization of document not available\n", NULL);
; 1841 : 	xmlFree(URL);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H

; 1842 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXInclud:

; 1843 :     }
; 1844 : 
; 1845 :     /*
; 1846 :      * Prevent reloading twice the document.
; 1847 :      */
; 1848 :     for (i = 0; i < ctxt->txtNr; i++) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [edi+20], esi
	jle	SHORT $LN3@xmlXInclud
$LL4@xmlXInclud:

; 1849 : 	if (xmlStrEqual(URL, ctxt->txturlTab[i])) {

	mov	eax, DWORD PTR [edi+32]
	push	DWORD PTR [eax+esi*4]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN67@xmlXInclud

; 1843 :     }
; 1844 : 
; 1845 :     /*
; 1846 :      * Prevent reloading twice the document.
; 1847 :      */
; 1848 :     for (i = 0; i < ctxt->txtNr; i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+20]
	jl	SHORT $LL4@xmlXInclud
$LN3@xmlXInclud:

; 1852 : 	}
; 1853 :     }
; 1854 :     /*
; 1855 :      * Try to get the encoding if available
; 1856 :      */
; 1857 :     if ((ctxt->incTab[nr] != NULL) && (ctxt->incTab[nr]->ref != NULL)) {

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	$LN92@xmlXInclud
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN92@xmlXInclud

; 1858 : 	encoding = xmlGetProp(ctxt->incTab[nr]->ref, XINCLUDE_PARSE_ENCODING);

	push	OFFSET ??_C@_08MLPGAEIK@encoding@
	push	eax
	call	_xmlGetProp
	mov	esi, eax
	add	esp, 8

; 1859 :     }
; 1860 :     if (encoding != NULL) {

	test	esi, esi
	je	SHORT $LN92@xmlXInclud

; 1861 : 	/*
; 1862 : 	 * TODO: we should not have to remap to the xmlCharEncoding
; 1863 : 	 *       predefined set, a better interface than
; 1864 : 	 *       xmlParserInputBufferCreateFilename should allow any
; 1865 : 	 *       encoding supported by iconv
; 1866 : 	 */
; 1867 :         enc = xmlParseCharEncoding((const char *) encoding);

	push	esi
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	ebx, eax

; 1868 : 	if (enc == XML_CHAR_ENCODING_ERROR) {

	push	esi
	cmp	ebx, -1
	jne	SHORT $LN17@xmlXInclud

; 1869 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	push	OFFSET ??_C@_0BL@EIOJIGPP@encoding?5?$CFs?5not?5supported?6@
	push	1610					; 0000064aH
	mov	eax, DWORD PTR [eax+ecx*4]
	push	DWORD PTR [eax+12]
	push	edi
	call	_xmlXIncludeErr

; 1870 : 	                   XML_XINCLUDE_UNKNOWN_ENCODING,
; 1871 : 			   "encoding %s not supported\n", encoding);
; 1872 : 	    xmlFree(encoding);

	push	esi
	call	DWORD PTR _xmlFree

; 1873 : 	    xmlFree(URL);

	mov	esi, DWORD PTR _URL$1$[ebp]
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 1874 : 	    return(-1);

	or	eax, ebx
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlXInclud:

; 1850 : 	    node = xmlCopyNode(ctxt->txtTab[i], 1);

	mov	eax, DWORD PTR [edi+28]
	push	1
	push	DWORD PTR [eax+esi*4]
	call	_xmlCopyNode

; 1851 : 	    goto loaded;

	mov	esi, DWORD PTR _URL$1$[ebp]
	add	esp, 8
	mov	ebx, eax
	jmp	$loaded$98
$LN17@xmlXInclud:

; 1875 : 	}
; 1876 : 	xmlFree(encoding);

	call	DWORD PTR _xmlFree
	add	esp, 4
	jmp	SHORT $LN16@xmlXInclud
$LN92@xmlXInclud:

; 1877 :     }
; 1878 : 
; 1879 :     /*
; 1880 :      * Load it.
; 1881 :      */
; 1882 :     pctxt = xmlNewParserCtxt();

	xor	ebx, ebx
$LN16@xmlXInclud:
	call	_xmlNewParserCtxt

; 1883 :     inputStream = xmlLoadExternalEntity((const char*)URL, NULL, pctxt);

	mov	edi, DWORD PTR _URL$1$[ebp]
	mov	esi, eax
	push	esi
	push	0
	push	edi
	mov	DWORD PTR _pctxt$1$[ebp], esi
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inputStream$1$[ebp], eax

; 1884 :     if(inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlXInclud

; 1885 : 	xmlFreeParserCtxt(pctxt);

	push	esi
	call	_xmlFreeParserCtxt

; 1886 : 	xmlFree(URL);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 1887 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlXInclud:

; 1888 :     }
; 1889 :     buf = inputStream->buf;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _buf$1$[ebp], esi

; 1890 :     if (buf == NULL) {

	test	esi, esi
	jne	SHORT $LN19@xmlXInclud

; 1891 : 	xmlFreeInputStream (inputStream);

	push	eax
	call	_xmlFreeInputStream

; 1892 : 	xmlFreeParserCtxt(pctxt);

	push	DWORD PTR _pctxt$1$[ebp]
	call	_xmlFreeParserCtxt

; 1893 : 	xmlFree(URL);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 1894 : 	return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXInclud:

; 1895 :     }
; 1896 :     if (buf->encoder)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN20@xmlXInclud

; 1897 : 	xmlCharEncCloseFunc(buf->encoder);

	push	eax
	call	_xmlCharEncCloseFunc
	add	esp, 4
$LN20@xmlXInclud:

; 1898 :     buf->encoder = xmlGetCharEncodingHandler(enc);

	push	ebx
	call	_xmlGetCharEncodingHandler

; 1899 :     node = xmlNewText(NULL);

	push	0
	mov	DWORD PTR [esi+12], eax
	call	_xmlNewText
	mov	DWORD PTR _node$1$[ebp], eax
$LN95@xmlXInclud:

; 1900 : 
; 1901 :     /*
; 1902 :      * Scan all chars from the resource and add the to the node
; 1903 :      */
; 1904 : xinclude_multibyte_fallback:
; 1905 :     while (xmlParserInputBufferRead(buf, 128) > 0) {

	add	esp, 8
	npad	1
$xinclude_multibyte_fallback$99:
	push	128					; 00000080H
	push	esi
	call	_xmlParserInputBufferRead
	add	esp, 8
	test	eax, eax
	jle	$LN6@xmlXInclud

; 1906 : 	int len;
; 1907 : 	const xmlChar *content;
; 1908 : 
; 1909 : 	content = xmlBufContent(buf->buffer);

	push	DWORD PTR [esi+16]
	call	_xmlBufContent

; 1910 : 	len = xmlBufLength(buf->buffer);

	push	DWORD PTR [esi+16]
	mov	edi, eax
	mov	DWORD PTR _content$1$[ebp], edi
	call	_xmlBufLength
	mov	ebx, eax
	add	esp, 8

; 1911 : 	for (i = 0;i < len;) {

	xor	esi, esi
	test	ebx, ebx
	jle	$LN8@xmlXInclud
	npad	6
$LL7@xmlXInclud:

; 1912 : 	    int cur;
; 1913 : 	    int l;
; 1914 : 
; 1915 : 	    cur = xmlStringCurrentChar(NULL, &content[i], &l);

	lea	eax, DWORD PTR _l$1[ebp]
	add	edi, esi
	push	eax
	push	edi
	push	0
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH

; 1916 : 	    if (!IS_CHAR(cur)) {

	cmp	eax, 256				; 00000100H
	jge	SHORT $LN34@xmlXInclud
	cmp	eax, 9
	jl	SHORT $LN26@xmlXInclud
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN30@xmlXInclud
$LN26@xmlXInclud:
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN30@xmlXInclud
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN30@xmlXInclud
$LN31@xmlXInclud:

; 1917 : 		/* Handle splitted multibyte char at buffer boundary */
; 1918 : 		if (((len - i) < 4) && (!xinclude_multibyte_fallback_used)) {

	sub	ebx, esi
	cmp	ebx, 4
	jge	SHORT $LN23@xmlXInclud
	cmp	DWORD PTR _xinclude_multibyte_fallback_used$1$[ebp], 0
	jne	SHORT $LN23@xmlXInclud

; 1919 : 		    xinclude_multibyte_fallback_used = 1;
; 1920 : 		    xmlBufShrink(buf->buffer, i);

	push	esi
	mov	esi, DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _xinclude_multibyte_fallback_used$1$[ebp], 1
	push	DWORD PTR [esi+16]
	call	_xmlBufShrink
	jmp	$LN95@xmlXInclud
$LN34@xmlXInclud:

; 1916 : 	    if (!IS_CHAR(cur)) {

	cmp	eax, 55295				; 0000d7ffH
	jle	SHORT $LN30@xmlXInclud
	cmp	eax, 57344				; 0000e000H
	jl	SHORT $LN29@xmlXInclud
	cmp	eax, 65533				; 0000fffdH
	jle	SHORT $LN30@xmlXInclud
$LN29@xmlXInclud:
	add	eax, -65536				; ffff0000H
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN31@xmlXInclud
$LN30@xmlXInclud:

; 1929 : 		}
; 1930 : 	    } else {
; 1931 : 		xinclude_multibyte_fallback_used = 0;
; 1932 : 		xmlNodeAddContentLen(node, &content[i], l);

	push	DWORD PTR _l$1[ebp]
	mov	DWORD PTR _xinclude_multibyte_fallback_used$1$[ebp], 0
	push	edi
	push	DWORD PTR _node$1$[ebp]
	call	_xmlNodeAddContentLen

; 1933 : 	    }
; 1934 : 	    i += l;

	add	esi, DWORD PTR _l$1[ebp]
	add	esp, 12					; 0000000cH
	mov	edi, DWORD PTR _content$1$[ebp]
	cmp	esi, ebx
	jl	$LL7@xmlXInclud
$LN8@xmlXInclud:

; 1935 : 	}
; 1936 : 	xmlBufShrink(buf->buffer, len);

	mov	esi, DWORD PTR _buf$1$[ebp]
	push	ebx
	push	DWORD PTR [esi+16]
	call	_xmlBufShrink

; 1937 :     }

	jmp	$LN95@xmlXInclud
$LN23@xmlXInclud:

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	mov	ebx, DWORD PTR _URL$1$[ebp]

; 1921 : 		    goto xinclude_multibyte_fallback;
; 1922 : 		} else {
; 1923 : 		    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _nr$[ebp]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	ebx
	push	OFFSET ??_C@_0BK@JOLCHMFH@?$CFs?5contains?5invalid?5char?6@

; 1921 : 		    goto xinclude_multibyte_fallback;
; 1922 : 		} else {
; 1923 : 		    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [ecx+16]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	0
	push	0

; 1921 : 		    goto xinclude_multibyte_fallback;
; 1922 : 		} else {
; 1923 : 		    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [eax+edx*4]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	ebx
	push	0

; 1921 : 		    goto xinclude_multibyte_fallback;
; 1922 : 		} else {
; 1923 : 		    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [eax+12]

; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [ecx+52]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	2
	push	1608					; 00000648H
	push	11					; 0000000bH
	push	eax
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1924 : 				   XML_XINCLUDE_INVALID_CHAR,
; 1925 : 				   "%s contains invalid char\n", URL);
; 1926 : 		    xmlFreeParserInputBuffer(buf);

	push	DWORD PTR _buf$1$[ebp]
	call	_xmlFreeParserInputBuffer
	add	esp, 72					; 00000048H

; 1927 : 		    xmlFree(URL);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1928 : 		    return(-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXInclud:

; 1938 :     xmlFreeParserCtxt(pctxt);

	push	DWORD PTR _pctxt$1$[ebp]
	call	_xmlFreeParserCtxt

; 762  :     if (ctxt->txtMax == 0) {

	mov	edi, DWORD PTR _ctxt$[ebp]

; 1938 :     xmlFreeParserCtxt(pctxt);

	add	esp, 4

; 762  :     if (ctxt->txtMax == 0) {

	cmp	DWORD PTR [edi+24], 0
	jne	SHORT $LN85@xmlXInclud

; 763  : 	ctxt->txtMax = 4;
; 764  :         ctxt->txtTab = (xmlNodePtr *) xmlMalloc(ctxt->txtMax *

	push	16					; 00000010H
	mov	DWORD PTR [edi+24], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+28], eax

; 765  : 		                          sizeof(ctxt->txtTab[0]));
; 766  :         if (ctxt->txtTab == NULL) {

	test	eax, eax
	jne	SHORT $LN47@xmlXInclud
$LN96@xmlXInclud:

; 1939 :     xmlXIncludeAddTxt(ctxt, node, URL);
; 1940 :     xmlFreeInputStream(inputStream);

	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+52]
	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	0
	push	0
	push	2
	push	2
	push	11					; 0000000bH
	push	0
	push	edi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	mov	ebx, DWORD PTR _node$1$[ebp]
	add	esp, 68					; 00000044H
	mov	esi, DWORD PTR _URL$1$[ebp]
	jmp	$LN45@xmlXInclud
$LN47@xmlXInclud:

; 770  :         ctxt->txturlTab = (xmlURL *) xmlMalloc(ctxt->txtMax *

	mov	eax, DWORD PTR [edi+24]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+32], eax

; 771  : 		                          sizeof(ctxt->txturlTab[0]));
; 772  :         if (ctxt->txturlTab == NULL) {

	test	eax, eax
	je	SHORT $LN96@xmlXInclud
$LN85@xmlXInclud:

; 773  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
; 774  : 	    return;
; 775  : 	}
; 776  :     }
; 777  :     if (ctxt->txtNr >= ctxt->txtMax) {

	mov	eax, DWORD PTR [edi+24]
	cmp	DWORD PTR [edi+20], eax
	jl	SHORT $LN86@xmlXInclud

; 778  : 	ctxt->txtMax *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+24], eax

; 779  :         ctxt->txtTab = (xmlNodePtr *) xmlRealloc(ctxt->txtTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [edi+28], eax

; 780  : 	             ctxt->txtMax * sizeof(ctxt->txtTab[0]));
; 781  :         if (ctxt->txtTab == NULL) {

	test	eax, eax
	je	SHORT $LN96@xmlXInclud

; 782  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
; 783  : 	    return;
; 784  : 	}
; 785  :         ctxt->txturlTab = (xmlURL *) xmlRealloc(ctxt->txturlTab,

	mov	eax, DWORD PTR [edi+24]
	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+32]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [edi+32], eax

; 786  : 	             ctxt->txtMax * sizeof(ctxt->txturlTab[0]));
; 787  :         if (ctxt->txturlTab == NULL) {

	test	eax, eax
	jne	SHORT $LN86@xmlXInclud

; 788  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");

	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	eax
	push	edi
	call	_xmlXIncludeErrMemory

; 789  : 	    return;

	mov	ebx, DWORD PTR _node$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _URL$1$[ebp]
	jmp	SHORT $LN45@xmlXInclud
$LN86@xmlXInclud:

; 790  : 	}
; 791  :     }
; 792  :     ctxt->txtTab[ctxt->txtNr] = txt;

	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+28]

; 793  :     ctxt->txturlTab[ctxt->txtNr] = xmlStrdup(url);

	mov	esi, DWORD PTR _URL$1$[ebp]
	mov	ebx, DWORD PTR _node$1$[ebp]
	push	esi
	mov	DWORD PTR [eax+ecx*4], ebx
	call	_xmlStrdup
	mov	edx, DWORD PTR [edi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [ecx+edx*4], eax

; 794  :     ctxt->txtNr++;

	inc	DWORD PTR [edi+20]
$LN45@xmlXInclud:

; 1939 :     xmlXIncludeAddTxt(ctxt, node, URL);
; 1940 :     xmlFreeInputStream(inputStream);

	push	DWORD PTR _inputStream$1$[ebp]
	call	_xmlFreeInputStream
	add	esp, 4
$loaded$98:

; 1941 : 
; 1942 : loaded:
; 1943 :     /*
; 1944 :      * Add the element as the replacement copy.
; 1945 :      */
; 1946 :     ctxt->incTab[nr]->inc = node;

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR _nr$[ebp]

; 1947 :     xmlFree(URL);

	push	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+16], ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1948 :     return(0);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1949 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeLoadTxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeLoadDoc
_TEXT	SEGMENT
_doc$1$ = -28						; size = 4
_relBase$1$ = -28					; size = 4
_xptr$1$ = -28						; size = 4
_saveFlags$1$ = -28					; size = 4
_uri$1$ = -28						; size = 4
tv1909 = -24						; size = 4
_target$1$ = -24					; size = 4
_base$1$ = -24						; size = 4
_data$1 = -20						; size = 8
_data$2 = -20						; size = 8
_curBase$2$ = -16					; size = 4
_set$1$ = -16						; size = 4
_doc$1$ = -12						; size = 4
tv1905 = -8						; size = 4
_fragment$1$ = -8					; size = 4
_URL$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_url$ = 12						; size = 4
_nr$ = 16						; size = 4
_xmlXIncludeLoadDoc PROC				; COMDAT

; 1404 : xmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _url$[ebp]
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR _fragment$1$[ebp], ebx
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _uri$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LN17@xmlXInclud

; 1405 :     xmlDocPtr doc;
; 1406 :     xmlURIPtr uri;
; 1407 :     xmlChar *URL;
; 1408 :     xmlChar *fragment = NULL;
; 1409 :     int i = 0;
; 1410 : #ifdef LIBXML_XPTR_ENABLED
; 1411 :     int saveFlags;
; 1412 : #endif
; 1413 : 
; 1414 : #ifdef DEBUG_XINCLUDE
; 1415 :     xmlGenericError(xmlGenericErrorContext, "Loading doc %s:%d\n", url, nr);
; 1416 : #endif
; 1417 :     /*
; 1418 :      * Check the URL and remove any fragment identifier
; 1419 :      */
; 1420 :     uri = xmlParseURI((const char *)url);
; 1421 :     if (uri == NULL) {
; 1422 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _nr$[ebp]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	esi
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@

; 1405 :     xmlDocPtr doc;
; 1406 :     xmlURIPtr uri;
; 1407 :     xmlChar *URL;
; 1408 :     xmlChar *fragment = NULL;
; 1409 :     int i = 0;
; 1410 : #ifdef LIBXML_XPTR_ENABLED
; 1411 :     int saveFlags;
; 1412 : #endif
; 1413 : 
; 1414 : #ifdef DEBUG_XINCLUDE
; 1415 :     xmlGenericError(xmlGenericErrorContext, "Loading doc %s:%d\n", url, nr);
; 1416 : #endif
; 1417 :     /*
; 1418 :      * Check the URL and remove any fragment identifier
; 1419 :      */
; 1420 :     uri = xmlParseURI((const char *)url);
; 1421 :     if (uri == NULL) {
; 1422 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	ecx, DWORD PTR [edx+16]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	edi
	push	edi
	push	edi

; 1405 :     xmlDocPtr doc;
; 1406 :     xmlURIPtr uri;
; 1407 :     xmlChar *URL;
; 1408 :     xmlChar *fragment = NULL;
; 1409 :     int i = 0;
; 1410 : #ifdef LIBXML_XPTR_ENABLED
; 1411 :     int saveFlags;
; 1412 : #endif
; 1413 : 
; 1414 : #ifdef DEBUG_XINCLUDE
; 1415 :     xmlGenericError(xmlGenericErrorContext, "Loading doc %s:%d\n", url, nr);
; 1416 : #endif
; 1417 :     /*
; 1418 :      * Check the URL and remove any fragment identifier
; 1419 :      */
; 1420 :     uri = xmlParseURI((const char *)url);
; 1421 :     if (uri == NULL) {
; 1422 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [ecx+eax*4]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	edi
	push	esi
	push	edi

; 1405 :     xmlDocPtr doc;
; 1406 :     xmlURIPtr uri;
; 1407 :     xmlChar *URL;
; 1408 :     xmlChar *fragment = NULL;
; 1409 :     int i = 0;
; 1410 : #ifdef LIBXML_XPTR_ENABLED
; 1411 :     int saveFlags;
; 1412 : #endif
; 1413 : 
; 1414 : #ifdef DEBUG_XINCLUDE
; 1415 :     xmlGenericError(xmlGenericErrorContext, "Loading doc %s:%d\n", url, nr);
; 1416 : #endif
; 1417 :     /*
; 1418 :      * Check the URL and remove any fragment identifier
; 1419 :      */
; 1420 :     uri = xmlParseURI((const char *)url);
; 1421 :     if (uri == NULL) {
; 1422 : 	xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [eax+12]

; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [edx+52]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	edi
	push	2
	push	1605					; 00000645H
	push	11					; 0000000bH
	push	eax
	push	edx
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1423 : 	               XML_XINCLUDE_HREF_URI,
; 1424 : 		       "invalid value URI %s\n", url);
; 1425 : 	return(-1);

	or	eax, -1
	pop	edi

; 1784 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXInclud:

; 1426 :     }
; 1427 :     if (uri->fragment != NULL) {

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN18@xmlXInclud

; 1428 : 	fragment = (xmlChar *) uri->fragment;

	mov	ebx, eax
	mov	DWORD PTR _fragment$1$[ebp], eax

; 1429 : 	uri->fragment = NULL;

	mov	DWORD PTR [edi+32], 0
$LN18@xmlXInclud:

; 1430 :     }
; 1431 :     if ((ctxt->incTab != NULL) && (ctxt->incTab[nr] != NULL) &&

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN19@xmlXInclud
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	je	SHORT $LN19@xmlXInclud
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN19@xmlXInclud

; 1432 :         (ctxt->incTab[nr]->fragment != NULL)) {
; 1433 : 	if (fragment != NULL) xmlFree(fragment);

	test	ebx, ebx
	je	SHORT $LN20@xmlXInclud
	push	ebx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
$LN20@xmlXInclud:

; 1434 : 	fragment = xmlStrdup(ctxt->incTab[nr]->fragment);

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	push	DWORD PTR [eax+4]
	call	_xmlStrdup
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _fragment$1$[ebp], ebx
$LN19@xmlXInclud:

; 1435 :     }
; 1436 :     URL = xmlSaveUri(uri);

	push	edi
	call	_xmlSaveUri

; 1437 :     xmlFreeURI(uri);

	push	DWORD PTR _uri$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _URL$1$[ebp], edi
	call	_xmlFreeURI
	add	esp, 8

; 1438 :     if (URL == NULL) {

	test	edi, edi
	jne	SHORT $LN21@xmlXInclud

; 1439 :         if (ctxt->incTab != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN22@xmlXInclud

; 1440 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	ecx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+12]
	jmp	SHORT $LN23@xmlXInclud
$LN22@xmlXInclud:

; 1441 : 			   XML_XINCLUDE_HREF_URI,
; 1442 : 			   "invalid value URI %s\n", url);
; 1443 : 	else
; 1444 : 	    xmlXIncludeErr(ctxt, NULL,

	xor	eax, eax
$LN23@xmlXInclud:

; 1445 : 			   XML_XINCLUDE_HREF_URI,
; 1446 : 			   "invalid value URI %s\n", url);
; 1447 : 	if (fragment != NULL)

	push	DWORD PTR _url$[ebp]
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@
	push	1605					; 00000645H
	push	eax
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
	test	ebx, ebx
	je	$LN30@xmlXInclud

; 1448 : 	    xmlFree(fragment);

	push	ebx

; 1502 : 	return(-1);

	call	DWORD PTR _xmlFree
	add	esp, 4
	or	eax, -1
	pop	edi

; 1784 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXInclud:

; 1449 : 	return(-1);
; 1450 :     }
; 1451 : 
; 1452 :     /*
; 1453 :      * Handling of references to the local document are done
; 1454 :      * directly through ctxt->doc.
; 1455 :      */
; 1456 :     if ((URL[0] == 0) || (URL[0] == '#') ||

	mov	al, BYTE PTR [edi]
	test	al, al
	je	$LN26@xmlXInclud
	cmp	al, 35					; 00000023H
	je	$LN26@xmlXInclud
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN25@xmlXInclud
	push	DWORD PTR [eax+72]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN26@xmlXInclud
$LN25@xmlXInclud:

; 1459 :         goto loaded;
; 1460 :     }
; 1461 : 
; 1462 :     /*
; 1463 :      * Prevent reloading twice the document.
; 1464 :      */
; 1465 :     for (i = 0; i < ctxt->incNr; i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	SHORT $LN140@xmlXInclud
$LL4@xmlXInclud:

; 1466 : 	if ((xmlStrEqual(URL, ctxt->incTab[i]->URI)) &&

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	DWORD PTR [eax]
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlXInclud
	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _doc$1$[ebp], edi
	test	edi, edi
	jne	$LN145@xmlXInclud
	mov	edi, DWORD PTR _URL$1$[ebp]
$LN2@xmlXInclud:

; 1459 :         goto loaded;
; 1460 :     }
; 1461 : 
; 1462 :     /*
; 1463 :      * Prevent reloading twice the document.
; 1464 :      */
; 1465 :     for (i = 0; i < ctxt->incNr; i++) {

	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL4@xmlXInclud
$LN140@xmlXInclud:

; 1467 : 	    (ctxt->incTab[i]->doc != NULL)) {
; 1468 : 	    doc = ctxt->incTab[i]->doc;
; 1469 : #ifdef DEBUG_XINCLUDE
; 1470 : 	    printf("Already loaded %s\n", URL);
; 1471 : #endif
; 1472 : 	    goto loaded;
; 1473 : 	}
; 1474 :     }
; 1475 : 
; 1476 :     /*
; 1477 :      * Load it.
; 1478 :      */
; 1479 : #ifdef DEBUG_XINCLUDE
; 1480 :     printf("loading %s\n", URL);
; 1481 : #endif
; 1482 : #ifdef LIBXML_XPTR_ENABLED
; 1483 :     /*
; 1484 :      * If this is an XPointer evaluation, we want to assure that
; 1485 :      * all entities have been resolved prior to processing the
; 1486 :      * referenced document
; 1487 :      */
; 1488 :     saveFlags = ctxt->parseFlags;
; 1489 :     if (fragment != NULL) {	/* if this is an XPointer eval */

	cmp	DWORD PTR _fragment$1$[ebp], 0
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR _saveFlags$1$[ebp], eax
	je	SHORT $LN28@xmlXInclud

; 1490 : 	ctxt->parseFlags |= XML_PARSE_NOENT;

	or	eax, 2
	mov	DWORD PTR [esi+60], eax
$LN28@xmlXInclud:

; 426  :     xmlInitParser();

	call	_xmlInitParser

; 427  : 
; 428  :     pctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	ebx, eax

; 429  :     if (pctxt == NULL) {

	test	ebx, ebx
	jne	SHORT $LN75@xmlXInclud

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	inc	DWORD PTR [esi+52]
	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	eax
	push	eax
	push	2
	push	2
	push	11					; 0000000bH
	push	eax
	push	esi
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 431  : 	return(NULL);

	xor	edi, edi
	mov	DWORD PTR _doc$1$[ebp], edi
	jmp	$LN74@xmlXInclud
$LN75@xmlXInclud:

; 432  :     }
; 433  : 
; 434  :     /*
; 435  :      * pass in the application data to the parser context.
; 436  :      */
; 437  :     pctxt->_private = ctxt->_private;

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [ebx+272], eax

; 438  : 
; 439  :     /*
; 440  :      * try to ensure that new documents included are actually
; 441  :      * built with the same dictionary as the including document.
; 442  :      */
; 443  :     if ((ctxt->doc != NULL) && (ctxt->doc->dict != NULL)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN76@xmlXInclud
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN76@xmlXInclud

; 444  :        if (pctxt->dict != NULL)

	mov	ecx, DWORD PTR [ebx+296]
	test	ecx, ecx
	je	SHORT $LN77@xmlXInclud

; 445  :             xmlDictFree(pctxt->dict);

	push	ecx
	call	_xmlDictFree
	mov	eax, DWORD PTR [esi]
	add	esp, 4
$LN77@xmlXInclud:

; 446  : 	pctxt->dict = ctxt->doc->dict;

	mov	eax, DWORD PTR [eax+80]

; 447  : 	xmlDictReference(pctxt->dict);

	push	eax
	mov	DWORD PTR [ebx+296], eax
	call	_xmlDictReference
	add	esp, 4
$LN76@xmlXInclud:

; 448  :     }
; 449  : 
; 450  :     xmlCtxtUseOptions(pctxt, ctxt->parseFlags | XML_PARSE_DTDLOAD);

	mov	eax, DWORD PTR [esi+60]
	or	eax, 4
	push	eax
	push	ebx
	call	_xmlCtxtUseOptions

; 451  : 
; 452  :     inputStream = xmlLoadExternalEntity(URL, NULL, pctxt);

	push	ebx
	push	0
	push	edi
	call	_xmlLoadExternalEntity
	add	esp, 20					; 00000014H

; 453  :     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN78@xmlXInclud

; 454  : 	xmlFreeParserCtxt(pctxt);

	push	ebx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 455  : 	return(NULL);

	xor	edi, edi
	mov	DWORD PTR _doc$1$[ebp], edi
	jmp	SHORT $LN74@xmlXInclud
$LN78@xmlXInclud:

; 456  :     }
; 457  : 
; 458  :     inputPush(pctxt, inputStream);

	push	eax
	push	ebx
	call	_inputPush
	add	esp, 8

; 459  : 
; 460  :     if (pctxt->directory == NULL)

	cmp	DWORD PTR [ebx+180], 0
	jne	SHORT $LN79@xmlXInclud

; 461  :         pctxt->directory = xmlParserGetDirectory(URL);

	push	edi
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR [ebx+180], eax
$LN79@xmlXInclud:

; 462  : 
; 463  :     pctxt->loadsubset |= XML_DETECT_IDS;

	or	DWORD PTR [ebx+276], 2

; 464  : 
; 465  :     xmlParseDocument(pctxt);

	push	ebx
	call	_xmlParseDocument
	add	esp, 4

; 466  : 
; 467  :     if (pctxt->wellFormed) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN80@xmlXInclud

; 468  :         ret = pctxt->myDoc;

	mov	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR _doc$1$[ebp], edi

; 469  :     }

	jmp	SHORT $LN81@xmlXInclud
$LN80@xmlXInclud:

; 470  :     else {
; 471  :         ret = NULL;
; 472  : 	if (pctxt->myDoc != NULL)

	mov	eax, DWORD PTR [ebx+8]
	xor	edi, edi
	mov	DWORD PTR _doc$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN82@xmlXInclud

; 473  : 	    xmlFreeDoc(pctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN82@xmlXInclud:

; 474  :         pctxt->myDoc = NULL;

	mov	DWORD PTR [ebx+8], edi
$LN81@xmlXInclud:

; 475  :     }
; 476  :     xmlFreeParserCtxt(pctxt);

	push	ebx
	call	_xmlFreeParserCtxt
	add	esp, 4
$LN74@xmlXInclud:

; 1491 :     }
; 1492 : #endif
; 1493 : 
; 1494 :     doc = xmlXIncludeParseFile(ctxt, (const char *)URL);
; 1495 : #ifdef LIBXML_XPTR_ENABLED
; 1496 :     ctxt->parseFlags = saveFlags;

	mov	eax, DWORD PTR _saveFlags$1$[ebp]
	mov	DWORD PTR [esi+60], eax

; 1497 : #endif
; 1498 :     if (doc == NULL) {

	test	edi, edi
	jne	SHORT $LN29@xmlXInclud

; 1499 : 	xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]
	call	DWORD PTR _xmlFree

; 1500 : 	if (fragment != NULL)

	mov	eax, DWORD PTR _fragment$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN30@xmlXInclud

; 1501 : 	    xmlFree(fragment);

	push	eax

; 1502 : 	return(-1);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN30@xmlXInclud:

; 1784 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlXInclud:

; 1503 :     }
; 1504 :     ctxt->incTab[nr]->doc = doc;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]

; 1505 :     /*
; 1506 :      * It's possible that the requested URL has been mapped to a
; 1507 :      * completely different location (e.g. through a catalog entry).
; 1508 :      * To check for this, we compare the URL with that of the doc
; 1509 :      * and change it if they disagree (bug 146988).
; 1510 :      */
; 1511 :    if (!xmlStrEqual(URL, doc->URL)) {

	mov	ebx, DWORD PTR _URL$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+8], edi
	push	DWORD PTR [edi+72]
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN150@xmlXInclud

; 1512 :        xmlFree(URL);

	push	ebx
	call	DWORD PTR _xmlFree

; 1513 :        URL = xmlStrdup(doc->URL);

	push	DWORD PTR [edi+72]
	call	_xmlStrdup
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _URL$1$[ebp], ecx
	jmp	SHORT $LN31@xmlXInclud
$LN150@xmlXInclud:

; 1505 :     /*
; 1506 :      * It's possible that the requested URL has been mapped to a
; 1507 :      * completely different location (e.g. through a catalog entry).
; 1508 :      * To check for this, we compare the URL with that of the doc
; 1509 :      * and change it if they disagree (bug 146988).
; 1510 :      */
; 1511 :    if (!xmlStrEqual(URL, doc->URL)) {

	mov	ecx, DWORD PTR _URL$1$[ebp]
$LN31@xmlXInclud:

; 1514 :    }
; 1515 :     for (i = nr + 1; i < ctxt->incNr; i++) {

	mov	ebx, DWORD PTR _nr$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN6@xmlXInclud
	npad	4
$LL7@xmlXInclud:

; 1516 : 	if (xmlStrEqual(URL, ctxt->incTab[i]->URI)) {

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	DWORD PTR [eax]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN118@xmlXInclud

; 1514 :    }
; 1515 :     for (i = nr + 1; i < ctxt->incNr; i++) {

	mov	ecx, DWORD PTR _URL$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL7@xmlXInclud

; 1516 : 	if (xmlStrEqual(URL, ctxt->incTab[i]->URI)) {

	jmp	SHORT $LN6@xmlXInclud
$LN118@xmlXInclud:

; 1517 : 	    ctxt->incTab[nr]->count++;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	DWORD PTR [eax+24]
$LN6@xmlXInclud:

; 1351 :     if ((from == NULL) || (from->intSubset == NULL))

	cmp	DWORD PTR [edi+44], 0

; 1518 : #ifdef DEBUG_XINCLUDE
; 1519 : 	    printf("Increasing %s count since reused\n", URL);
; 1520 : #endif
; 1521 :             break;
; 1522 : 	}
; 1523 :     }
; 1524 : 
; 1525 :     /*
; 1526 :      * Make sure we have all entities fixed up
; 1527 :      */
; 1528 :     xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _doc$1$[ebp], ebx

; 1351 :     if ((from == NULL) || (from->intSubset == NULL))

	je	$LN90@xmlXInclud

; 1352 : 	return(0);
; 1353 : 
; 1354 :     target = doc->intSubset;

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _target$1$[ebp], eax

; 1355 :     if (target == NULL) {

	test	eax, eax
	jne	SHORT $LN93@xmlXInclud

; 1356 : 	cur = xmlDocGetRootElement(doc);

	push	ebx
	call	_xmlDocGetRootElement
	add	esp, 4

; 1357 : 	if (cur == NULL)

	test	eax, eax
	je	$LN90@xmlXInclud

; 1358 : 	    return(-1);
; 1359 :         target = xmlCreateIntSubset(doc, cur->name, NULL, NULL);

	push	0
	push	0
	push	DWORD PTR [eax+8]
	push	ebx
	call	_xmlCreateIntSubset
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target$1$[ebp], eax

; 1360 : 	if (target == NULL)

	test	eax, eax
	je	SHORT $LN90@xmlXInclud
$LN93@xmlXInclud:

; 1361 : 	    return(-1);
; 1362 :     }
; 1363 : 
; 1364 :     source = from->intSubset;

	mov	eax, DWORD PTR [edi+44]

; 1365 :     if ((source != NULL) && (source->entities != NULL)) {

	test	eax, eax
	je	SHORT $LN94@xmlXInclud
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN94@xmlXInclud

; 1366 : 	xmlXIncludeMergeData data;
; 1367 : 
; 1368 : 	data.ctxt = ctxt;
; 1369 : 	data.doc = doc;
; 1370 : 
; 1371 : 	xmlHashScan((xmlHashTablePtr) source->entities,

	lea	ecx, DWORD PTR _data$2[ebp]
	mov	DWORD PTR _data$2[ebp+4], esi
	push	ecx
	push	OFFSET _xmlXIncludeMergeEntity
	push	eax
	mov	DWORD PTR _data$2[ebp], ebx
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN94@xmlXInclud:

; 1372 : 		    xmlXIncludeMergeEntity, &data);
; 1373 :     }
; 1374 :     source = from->extSubset;

	mov	ebx, DWORD PTR [edi+48]

; 1375 :     if ((source != NULL) && (source->entities != NULL)) {

	test	ebx, ebx
	je	SHORT $LN90@xmlXInclud
	cmp	DWORD PTR [ebx+48], 0
	je	SHORT $LN90@xmlXInclud

; 1376 : 	xmlXIncludeMergeData data;
; 1377 : 
; 1378 : 	data.ctxt = ctxt;
; 1379 : 	data.doc = doc;

	mov	eax, DWORD PTR _doc$1$[ebp]

; 1380 : 
; 1381 : 	/*
; 1382 : 	 * don't duplicate existing stuff when external subsets are the same
; 1383 : 	 */
; 1384 : 	if ((!xmlStrEqual(target->ExternalID, source->ExternalID)) &&

	push	DWORD PTR [ebx+52]
	mov	DWORD PTR _data$1[ebp], eax
	mov	eax, DWORD PTR _target$1$[ebp]
	mov	DWORD PTR _data$1[ebp+4], esi
	push	DWORD PTR [eax+52]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN90@xmlXInclud
	mov	eax, DWORD PTR _target$1$[ebp]
	push	DWORD PTR [ebx+56]
	push	DWORD PTR [eax+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN90@xmlXInclud

; 1385 : 	    (!xmlStrEqual(target->SystemID, source->SystemID))) {
; 1386 : 	    xmlHashScan((xmlHashTablePtr) source->entities,

	lea	eax, DWORD PTR _data$1[ebp]
	push	eax
	push	OFFSET _xmlXIncludeMergeEntity
	push	DWORD PTR [ebx+48]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN90@xmlXInclud:

; 684  :     newctxt = xmlXIncludeNewContext(doc);

	push	edi
	call	_xmlXIncludeNewContext
	mov	ebx, eax
	add	esp, 4

; 685  :     if (newctxt != NULL) {

	test	ebx, ebx
	je	SHORT $LN145@xmlXInclud

; 686  : 	/*
; 687  : 	 * Copy the private user data
; 688  : 	 */
; 689  : 	newctxt->_private = ctxt->_private;

	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [ebx+68], ecx

; 690  : 	/*
; 691  : 	 * Copy the existing document set
; 692  : 	 */
; 693  : 	newctxt->incMax = ctxt->incMax;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], eax

; 694  : 	newctxt->incNr = ctxt->incNr;

	mov	ecx, DWORD PTR [esi+8]

; 695  :         newctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(newctxt->incMax *

	shl	eax, 2
	push	eax
	mov	DWORD PTR [ebx+8], ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [ebx+16], eax

; 696  : 		                          sizeof(newctxt->incTab[0]));
; 697  :         if (newctxt->incTab == NULL) {

	test	eax, eax
	jne	SHORT $LN106@xmlXInclud

; 698  : 	    xmlXIncludeErrMemory(ctxt, (xmlNodePtr) doc, "processing doc");

	push	OFFSET ??_C@_0P@NPOPFDNN@processing?5doc@
	push	edi
	push	esi
	call	_xmlXIncludeErrMemory

; 699  : 	    xmlFree(newctxt);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
$LN145@xmlXInclud:

; 1529 : 
; 1530 :     /*
; 1531 :      * We don't need the DTD anymore, free up space
; 1532 :     if (doc->intSubset != NULL) {
; 1533 : 	xmlUnlinkNode((xmlNodePtr) doc->intSubset);
; 1534 : 	xmlFreeNode((xmlNodePtr) doc->intSubset);
; 1535 : 	doc->intSubset = NULL;
; 1536 :     }
; 1537 :     if (doc->extSubset != NULL) {
; 1538 : 	xmlUnlinkNode((xmlNodePtr) doc->extSubset);
; 1539 : 	xmlFreeNode((xmlNodePtr) doc->extSubset);
; 1540 : 	doc->extSubset = NULL;
; 1541 :     }
; 1542 :      */
; 1543 :     xmlXIncludeRecurseDoc(ctxt, doc, URL);
; 1544 : 
; 1545 : loaded:
; 1546 :     if (fragment == NULL) {

	mov	ebx, DWORD PTR _fragment$1$[ebp]
$loaded$160:
	test	ebx, ebx
	jne	$LN33@xmlXInclud

; 1547 : 	/*
; 1548 : 	 * Add the top children list as the replacement copy.
; 1549 : 	 */
; 1550 : 	if (doc == NULL)

	mov	eax, DWORD PTR _nr$[ebp]
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR tv1905[ebp], ebx
	test	edi, edi
	jne	$LN35@xmlXInclud

; 1551 : 	{
; 1552 : 	    /* Hopefully a DTD declaration won't be copied from
; 1553 : 	     * the same document */
; 1554 : 	    ctxt->incTab[nr]->inc = xmlCopyNodeList(ctxt->doc->children);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+12]
	call	_xmlCopyNodeList
	mov	ecx, DWORD PTR [esi+16]
	add	esp, 4
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [ecx+16], eax

; 1555 : 	} else {

	jmp	$LN152@xmlXInclud
$LN106@xmlXInclud:

; 705  : 	newctxt->urlMax = ctxt->urlMax;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [ebx+44], eax

; 706  : 	newctxt->urlNr = ctxt->urlNr;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [ebx+40], eax

; 707  : 	newctxt->urlTab = ctxt->urlTab;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [ebx+48], eax

; 708  : 
; 709  : 	/*
; 710  : 	 * Inherit the existing base
; 711  : 	 */
; 712  : 	newctxt->base = xmlStrdup(ctxt->base);

	push	DWORD PTR [esi+64]
	call	_xmlStrdup
	mov	DWORD PTR [ebx+64], eax

; 713  : 
; 714  : 	/*
; 715  : 	 * Inherit the documents already in use by other includes
; 716  : 	 */
; 717  : 	newctxt->incBase = ctxt->incNr;
; 718  : 	for (i = 0;i < ctxt->incNr;i++) {

	xor	edx, edx
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+8], edx
	jle	SHORT $LN100@xmlXInclud
	npad	6
$LL101@xmlXInclud:

; 719  : 	    newctxt->incTab[i] = ctxt->incTab[i];

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 720  : 	    newctxt->incTab[i]->count++; /* prevent the recursion from

	mov	eax, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+edx*4]
	inc	edx
	inc	DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [esi+8]
	jl	SHORT $LL101@xmlXInclud
$LN100@xmlXInclud:

; 721  : 					    freeing it */
; 722  : 	}
; 723  : 	/*
; 724  : 	 * The new context should also inherit the Parse Flags
; 725  : 	 * (bug 132597)
; 726  : 	 */
; 727  : 	newctxt->parseFlags = ctxt->parseFlags;

	mov	eax, DWORD PTR [esi+60]

; 728  : 	xmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc));

	push	edi
	mov	DWORD PTR [ebx+60], eax
	call	_xmlDocGetRootElement
	push	eax
	push	edi
	push	ebx
	call	_xmlXIncludeDoProcess

; 729  : 	for (i = 0;i < ctxt->incNr;i++) {

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN103@xmlXInclud
	npad	7
$LL104@xmlXInclud:

; 730  : 	    newctxt->incTab[i]->count--;

	mov	eax, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+ecx*4]
	dec	DWORD PTR [eax+24]

; 731  : 	    newctxt->incTab[i] = NULL;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL104@xmlXInclud
$LN103@xmlXInclud:

; 732  : 	}
; 733  : 
; 734  : 	/* urlTab may have been reallocated */
; 735  : 	ctxt->urlTab = newctxt->urlTab;

	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [esi+48], eax

; 736  : 	ctxt->urlMax = newctxt->urlMax;

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [esi+44], eax

; 737  : 
; 738  : 	newctxt->urlMax = 0;
; 739  : 	newctxt->urlNr = 0;
; 740  : 	newctxt->urlTab = NULL;
; 741  : 
; 742  : 	xmlXIncludeFreeContext(newctxt);

	push	ebx
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+40], 0
	mov	DWORD PTR [ebx+48], 0
	call	_xmlXIncludeFreeContext
	add	esp, 4
	jmp	$LN145@xmlXInclud
$LN26@xmlXInclud:

; 1457 : 	((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {
; 1458 : 	doc = NULL;

	xor	edi, edi
	mov	DWORD PTR _doc$1$[ebp], edi

; 685  :     if (newctxt != NULL) {

	jmp	$loaded$160
$LN35@xmlXInclud:

; 1556 : 	    ctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,

	push	DWORD PTR [edi+12]
	push	edi
	push	DWORD PTR [esi]
	push	esi
	call	_xmlXIncludeCopyNodeList
	mov	ecx, DWORD PTR [esi+16]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [ecx+16], eax

; 1557 : 		                                       doc, doc->children);
; 1558 : 	}
; 1559 :     }

	jmp	$LN34@xmlXInclud
$LN33@xmlXInclud:

; 1560 : #ifdef LIBXML_XPTR_ENABLED
; 1561 :     else {
; 1562 : 	/*
; 1563 : 	 * Computes the XPointer expression and make a copy used
; 1564 : 	 * as the replacement copy.
; 1565 : 	 */
; 1566 : 	xmlXPathObjectPtr xptr;
; 1567 : 	xmlXPathContextPtr xptrctxt;
; 1568 : 	xmlNodeSetPtr set;
; 1569 : 
; 1570 : 	if (doc == NULL) {

	test	edi, edi
	jne	SHORT $LN37@xmlXInclud

; 1571 : 	    xptrctxt = xmlXPtrNewContext(ctxt->doc, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+12]

; 1572 : 		                         NULL);
; 1573 : 	} else {

	jmp	SHORT $LN38@xmlXInclud
$LN37@xmlXInclud:

; 1574 : 	    xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);

	mov	ecx, edi
	xor	eax, eax
$LN38@xmlXInclud:

; 1575 : 	}
; 1576 : 	if (xptrctxt == NULL) {

	push	0
	push	eax
	push	ecx
	call	_xmlXPtrNewContext
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1909[ebp], eax
	test	eax, eax
	jne	SHORT $LN39@xmlXInclud

; 1577 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	OFFSET ??_C@_0CD@PEMEOEGM@could?5not?5create?5XPointer?5conte@
	push	0

; 1577 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [eax+ecx*4]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	0
	push	0

; 1577 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [eax+12]

; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [esi+52]

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	0
	push	0
	push	0
	push	2
	push	1612					; 0000064cH
	push	11					; 0000000bH
	push	eax
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError

; 1578 : 	                   XML_XINCLUDE_XPTR_FAILED,
; 1579 : 			   "could not create XPointer context\n", NULL);
; 1580 : 	    xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 1581 : 	    xmlFree(fragment);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1582 : 	    return(-1);

	or	eax, -1
	pop	edi

; 1784 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlXInclud:

; 1583 : 	}
; 1584 : 	xptr = xmlXPtrEval(fragment, xptrctxt);

	push	eax
	push	ebx
	call	_xmlXPtrEval
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _xptr$1$[ebp], edx

; 1585 : 	if (xptr == NULL) {

	test	edx, edx
	jne	SHORT $LN40@xmlXInclud

; 1586 : 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	ebx
	push	OFFSET ??_C@_0CB@CBJIEBBP@XPointer?5evaluation?5failed?3?5?$CD?$CFs@
	push	1612					; 0000064cH
$LN155@xmlXInclud:

; 1784 : }

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlXIncludeErr
	push	DWORD PTR tv1909[ebp]
	call	_xmlXPathFreeContext
	push	DWORD PTR _URL$1$[ebp]
	call	DWORD PTR _xmlFree
	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 32					; 00000020H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlXInclud:

; 1587 : 	                   XML_XINCLUDE_XPTR_FAILED,
; 1588 : 			   "XPointer evaluation failed: #%s\n",
; 1589 : 			   fragment);
; 1590 : 	    xmlXPathFreeContext(xptrctxt);
; 1591 : 	    xmlFree(URL);
; 1592 : 	    xmlFree(fragment);
; 1593 : 	    return(-1);
; 1594 : 	}
; 1595 : 	switch (xptr->type) {

	mov	eax, DWORD PTR [edx]
	cmp	eax, 9
	ja	SHORT $LN43@xmlXInclud
	movzx	eax, BYTE PTR $LN141@xmlXInclud[eax]
	jmp	DWORD PTR $LN158@xmlXInclud[eax*4]
$LN41@xmlXInclud:

; 1596 : 	    case XPATH_UNDEFINED:
; 1597 : 	    case XPATH_BOOLEAN:
; 1598 : 	    case XPATH_NUMBER:
; 1599 : 	    case XPATH_STRING:
; 1600 : 	    case XPATH_POINT:
; 1601 : 	    case XPATH_USERS:
; 1602 : 	    case XPATH_XSLT_TREE:
; 1603 : 		xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	ebx
	push	OFFSET ??_C@_0BO@BAOAOILH@XPointer?5is?5not?5a?5range?3?5?$CD?$CFs?6@
	push	1613					; 0000064dH

; 1604 : 		               XML_XINCLUDE_XPTR_RESULT,
; 1605 : 			       "XPointer is not a range: #%s\n",
; 1606 : 			       fragment);
; 1607 : 		xmlXPathFreeContext(xptrctxt);
; 1608 : 		xmlFree(URL);
; 1609 : 		xmlFree(fragment);
; 1610 : 		return(-1);

	jmp	SHORT $LN155@xmlXInclud
$LN42@xmlXInclud:

; 1611 : 	    case XPATH_NODESET:
; 1612 : 	        if ((xptr->nodesetval == NULL) ||

	mov	eax, DWORD PTR [edx+4]
	test	eax, eax
	je	SHORT $LN44@xmlXInclud
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN43@xmlXInclud
$LN44@xmlXInclud:

; 1613 : 		    (xptr->nodesetval->nodeNr <= 0)) {
; 1614 : 		    xmlXPathFreeContext(xptrctxt);

	push	DWORD PTR tv1909[ebp]
	call	_xmlXPathFreeContext

; 1615 : 		    xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]
	call	DWORD PTR _xmlFree

; 1616 : 		    xmlFree(fragment);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 1784 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlXInclud:

; 1617 : 		    return(-1);
; 1618 : 		}
; 1619 : 
; 1620 : 	    case XPATH_RANGE:
; 1621 : 	    case XPATH_LOCATIONSET:
; 1622 : 		break;
; 1623 : 	}
; 1624 : 	set = xptr->nodesetval;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _set$1$[ebp], eax

; 1625 : 	if (set != NULL) {

	test	eax, eax
	je	$LN11@xmlXInclud

; 1626 : 	    for (i = 0;i < set->nodeNr;i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax], ebx
	jle	$LN144@xmlXInclud
	mov	edi, DWORD PTR _fragment$1$[ebp]
$LL12@xmlXInclud:

; 1627 : 		if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ebx*4]
	test	eax, eax
	je	SHORT $LN10@xmlXInclud

; 1628 : 		    continue;
; 1629 : 		switch (set->nodeTab[i]->type) {

	mov	eax, DWORD PTR [eax+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN10@xmlXInclud
	movzx	eax, BYTE PTR $LN142@xmlXInclud[eax]
	jmp	DWORD PTR $LN159@xmlXInclud[eax*4]
$LN49@xmlXInclud:

; 1630 : 		    case XML_ELEMENT_NODE:
; 1631 : 		    case XML_TEXT_NODE:
; 1632 : 		    case XML_CDATA_SECTION_NODE:
; 1633 : 		    case XML_ENTITY_REF_NODE:
; 1634 : 		    case XML_ENTITY_NODE:
; 1635 : 		    case XML_PI_NODE:
; 1636 : 		    case XML_COMMENT_NODE:
; 1637 : 		    case XML_DOCUMENT_NODE:
; 1638 : 		    case XML_HTML_DOCUMENT_NODE:
; 1639 : #ifdef LIBXML_DOCB_ENABLED
; 1640 : 		    case XML_DOCB_DOCUMENT_NODE:
; 1641 : #endif
; 1642 : 			continue;
; 1643 : 
; 1644 : 		    case XML_ATTRIBUTE_NODE:
; 1645 : 			xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	edi
	push	OFFSET ??_C@_0CE@BOPHMAJL@XPointer?5selects?5an?5attribute?3?5@
$LN154@xmlXInclud:

; 1626 : 	    for (i = 0;i < set->nodeNr;i++) {

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	push	1613					; 0000064dH
	mov	eax, DWORD PTR [eax+ecx*4]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlXIncludeErr
	mov	ecx, DWORD PTR _set$1$[ebp]
	jmp	SHORT $LN153@xmlXInclud
$LN50@xmlXInclud:

; 1646 : 			               XML_XINCLUDE_XPTR_RESULT,
; 1647 : 				       "XPointer selects an attribute: #%s\n",
; 1648 : 				       fragment);
; 1649 : 			set->nodeTab[i] = NULL;
; 1650 : 			continue;
; 1651 : 		    case XML_NAMESPACE_DECL:
; 1652 : 			xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	push	edi
	push	OFFSET ??_C@_0CD@OMDJDBLC@XPointer?5selects?5a?5namespace?3?5?$CD@

; 1653 : 			               XML_XINCLUDE_XPTR_RESULT,
; 1654 : 				       "XPointer selects a namespace: #%s\n",
; 1655 : 				       fragment);
; 1656 : 			set->nodeTab[i] = NULL;
; 1657 : 			continue;

	jmp	SHORT $LN154@xmlXInclud
$LN51@xmlXInclud:

; 1658 : 		    case XML_DOCUMENT_TYPE_NODE:
; 1659 : 		    case XML_DOCUMENT_FRAG_NODE:
; 1660 : 		    case XML_NOTATION_NODE:
; 1661 : 		    case XML_DTD_NODE:
; 1662 : 		    case XML_ELEMENT_DECL:
; 1663 : 		    case XML_ATTRIBUTE_DECL:
; 1664 : 		    case XML_ENTITY_DECL:
; 1665 : 		    case XML_XINCLUDE_START:
; 1666 : 		    case XML_XINCLUDE_END:
; 1667 : 			xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _nr$[ebp]
	push	edi
	push	OFFSET ??_C@_0CI@NPJMIHPM@XPointer?5selects?5unexpected?5nod@
	push	1613					; 0000064dH
	mov	eax, DWORD PTR [eax+ecx*4]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlXIncludeErr

; 1668 : 			               XML_XINCLUDE_XPTR_RESULT,
; 1669 : 				   "XPointer selects unexpected nodes: #%s\n",
; 1670 : 				       fragment);
; 1671 : 			set->nodeTab[i] = NULL;

	mov	ecx, DWORD PTR _set$1$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ebx*4], 0
$LN153@xmlXInclud:

; 1626 : 	    for (i = 0;i < set->nodeNr;i++) {

	mov	eax, DWORD PTR [ecx+8]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [eax+ebx*4], 0
$LN10@xmlXInclud:
	mov	eax, DWORD PTR _set$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [eax]
	jl	$LL12@xmlXInclud
	mov	edi, DWORD PTR _doc$1$[ebp]
	mov	edx, DWORD PTR _xptr$1$[ebp]
$LN144@xmlXInclud:

; 1672 : 			set->nodeTab[i] = NULL;
; 1673 : 			continue; /* for */
; 1674 : 		}
; 1675 : 	    }
; 1676 : 	}
; 1677 : 	if (doc == NULL) {

	mov	ebx, DWORD PTR _fragment$1$[ebp]
$LN11@xmlXInclud:
	mov	eax, DWORD PTR _nr$[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv1905[ebp], ecx
	test	edi, edi
	jne	SHORT $LN52@xmlXInclud

; 1678 : 	    ctxt->incTab[nr]->xptr = xptr;

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [eax+28], edx

; 1679 : 	    ctxt->incTab[nr]->inc = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [eax+16], edi

; 1680 : 	} else {

	jmp	SHORT $LN53@xmlXInclud
$LN52@xmlXInclud:

; 1681 : 	    ctxt->incTab[nr]->inc =

	push	edx
	push	edi
	push	DWORD PTR [esi]
	push	esi
	call	_xmlXIncludeCopyXPointer
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR tv1905[ebp]

; 1682 : 		xmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);
; 1683 : 	    xmlXPathFreeObject(xptr);

	push	DWORD PTR _xptr$1$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [ecx+16], eax
	call	_xmlXPathFreeObject
	add	esp, 20					; 00000014H
$LN53@xmlXInclud:

; 1684 : 	}
; 1685 : 	xmlXPathFreeContext(xptrctxt);

	push	DWORD PTR tv1909[ebp]
	call	_xmlXPathFreeContext

; 1686 : 	xmlFree(fragment);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	ebx, DWORD PTR tv1905[ebp]
	add	esp, 8
$LN34@xmlXInclud:

; 1687 :     }
; 1688 : #endif
; 1689 : 
; 1690 :     /*
; 1691 :      * Do the xml:base fixup if needed
; 1692 :      */
; 1693 :     if ((doc != NULL) && (URL != NULL) &&
; 1694 :         (!(ctxt->parseFlags & XML_PARSE_NOBASEFIX)) &&

	test	edi, edi
	je	$LN149@xmlXInclud
	cmp	DWORD PTR _URL$1$[ebp], 0
	je	$LN149@xmlXInclud
	test	DWORD PTR [esi+60], 262144		; 00040000H
	jne	$LN149@xmlXInclud
	test	DWORD PTR [edi+88], 262144		; 00040000H
	jne	$LN149@xmlXInclud

; 1695 : 	(!(doc->parseFlags & XML_PARSE_NOBASEFIX))) {
; 1696 : 	xmlNodePtr node;
; 1697 : 	xmlChar *base;
; 1698 : 	xmlChar *curBase;
; 1699 : 
; 1700 : 	/*
; 1701 : 	 * The base is only adjusted if "necessary", i.e. if the xinclude node
; 1702 : 	 * has a base specified, or the URL is relative
; 1703 : 	 */
; 1704 : 	base = xmlGetNsProp(ctxt->incTab[nr]->ref, BAD_CAST "base",

	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	mov	eax, DWORD PTR [eax+ebx]
	push	DWORD PTR [eax+12]
	call	_xmlGetNsProp
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _base$1$[ebp], ebx

; 1705 : 			XML_XML_NAMESPACE);
; 1706 : 	if (base == NULL) {

	test	ebx, ebx
	jne	SHORT $LN58@xmlXInclud

; 1707 : 	    /*
; 1708 : 	     * No xml:base on the xinclude node, so we check whether the
; 1709 : 	     * URI base is different than (relative to) the context base
; 1710 : 	     */
; 1711 : 	    curBase = xmlBuildRelativeURI(URL, ctxt->base);

	push	DWORD PTR [esi+64]
	mov	edi, DWORD PTR _URL$1$[ebp]
	push	edi
	call	_xmlBuildRelativeURI
	mov	ebx, eax
	mov	DWORD PTR _base$1$[ebp], eax
	add	esp, 8

; 1712 : 	    if (curBase == NULL) {	/* Error return */

	test	ebx, ebx
	jne	SHORT $LN56@xmlXInclud

; 1713 : 	        xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR tv1905[ebp]
	push	edi
	push	OFFSET ??_C@_0CG@KGJNPLJO@trying?5to?5build?5relative?5URI?5fr@
	push	1605					; 00000645H
	mov	eax, DWORD PTR [eax+ebx]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 1714 : 	               XML_XINCLUDE_HREF_URI,
; 1715 : 		       "trying to build relative URI from %s\n", URL);
; 1716 : 	    } else {

	jmp	$LN60@xmlXInclud
$LN56@xmlXInclud:

; 1717 : 		/* If the URI doesn't contain a slash, it's not relative */
; 1718 : 	        if (!xmlStrchr(curBase, (xmlChar) '/'))

	push	47					; 0000002fH
	push	ebx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN58@xmlXInclud

; 1719 : 		    xmlFree(curBase);

	push	ebx
	call	DWORD PTR _xmlFree
	mov	ebx, DWORD PTR tv1905[ebp]
	add	esp, 4
	jmp	$LN60@xmlXInclud
$LN58@xmlXInclud:

; 1720 : 		else
; 1721 : 		    base = curBase;
; 1722 : 	    }
; 1723 : 	}
; 1724 : 	if (base != NULL) {	/* Adjustment may be needed */
; 1725 : 	    node = ctxt->incTab[nr]->inc;

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR tv1905[ebp]
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+16]

; 1726 : 	    while (node != NULL) {

	test	edi, edi
	je	$LN16@xmlXInclud
	npad	5
$LL15@xmlXInclud:

; 1727 : 		/* Only work on element nodes */
; 1728 : 		if (node->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1
	jne	$LN63@xmlXInclud

; 1729 : 		    curBase = xmlNodeGetBase(node->doc, node);

	push	edi
	push	DWORD PTR [edi+32]
	call	_xmlNodeGetBase
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _curBase$2$[ebp], ecx

; 1730 : 		    /* If no current base, set it */
; 1731 : 		    if (curBase == NULL) {

	test	ecx, ecx
	jne	SHORT $LN62@xmlXInclud

; 1732 : 			xmlNodeSetBase(node, base);

	push	ebx
	push	edi
	call	_xmlNodeSetBase
	add	esp, 8

; 1733 : 		    } else {

	jmp	$LN63@xmlXInclud
$LN62@xmlXInclud:

; 1734 : 			/*
; 1735 : 			 * If the current base is the same as the
; 1736 : 			 * URL of the document, then reset it to be
; 1737 : 			 * the specified xml:base or the relative URI
; 1738 : 			 */
; 1739 : 			if (xmlStrEqual(curBase, node->doc->URL)) {

	mov	eax, DWORD PTR [edi+32]
	push	DWORD PTR [eax+72]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@xmlXInclud

; 1740 : 			    xmlNodeSetBase(node, base);

	push	ebx
	push	edi
	call	_xmlNodeSetBase
	add	esp, 8

; 1741 : 			} else {

	jmp	SHORT $LN66@xmlXInclud
$LN64@xmlXInclud:

; 1742 : 			    /*
; 1743 : 			     * If the element already has an xml:base
; 1744 : 			     * set, then relativise it if necessary
; 1745 : 			     */
; 1746 : 			    xmlChar *xmlBase;
; 1747 : 			    xmlBase = xmlGetNsProp(node,

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	edi
	call	_xmlGetNsProp
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 1748 : 					    BAD_CAST "base",
; 1749 : 					    XML_XML_NAMESPACE);
; 1750 : 			    if (xmlBase != NULL) {

	test	ebx, ebx
	je	SHORT $LN143@xmlXInclud

; 1751 : 				xmlChar *relBase;
; 1752 : 				relBase = xmlBuildURI(xmlBase, base);

	push	DWORD PTR _base$1$[ebp]
	push	ebx
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _relBase$1$[ebp], eax

; 1753 : 				if (relBase == NULL) { /* error */

	test	eax, eax
	jne	SHORT $LN67@xmlXInclud

; 1754 : 				    xmlXIncludeErr(ctxt,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR tv1905[ebp]
	push	ebx
	push	OFFSET ??_C@_0CA@DKDEEGND@trying?5to?5rebuild?5base?5from?5?$CFs?6@
	push	1605					; 00000645H
	mov	eax, DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+12]
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 1755 : 						ctxt->incTab[nr]->ref,
; 1756 : 						XML_XINCLUDE_HREF_URI,
; 1757 : 					"trying to rebuild base from %s\n",
; 1758 : 						xmlBase);
; 1759 : 				} else {

	jmp	SHORT $LN68@xmlXInclud
$LN67@xmlXInclud:

; 1760 : 				    xmlNodeSetBase(node, relBase);

	push	eax
	push	edi
	call	_xmlNodeSetBase

; 1761 : 				    xmlFree(relBase);

	push	DWORD PTR _relBase$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN68@xmlXInclud:

; 1762 : 				}
; 1763 : 				xmlFree(xmlBase);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN143@xmlXInclud:

; 1764 : 			    }
; 1765 : 			}
; 1766 : 			xmlFree(curBase);

	mov	ebx, DWORD PTR _base$1$[ebp]
$LN66@xmlXInclud:
	push	DWORD PTR _curBase$2$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN63@xmlXInclud:

; 1767 : 		    }
; 1768 : 		}
; 1769 : 	        node = node->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	$LL15@xmlXInclud
$LN16@xmlXInclud:

; 1770 : 	    }
; 1771 : 	    xmlFree(base);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN149@xmlXInclud:

; 1772 : 	}
; 1773 :     }
; 1774 :     if ((nr < ctxt->incNr) && (ctxt->incTab[nr]->doc != NULL) &&

	mov	ebx, DWORD PTR tv1905[ebp]
$LN152@xmlXInclud:
	mov	edi, DWORD PTR _URL$1$[ebp]
$LN60@xmlXInclud:
	mov	eax, DWORD PTR _nr$[ebp]
	cmp	eax, DWORD PTR [esi+8]
	jge	SHORT $LN69@xmlXInclud
	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN69@xmlXInclud
	cmp	DWORD PTR [eax+24], 1
	jg	SHORT $LN69@xmlXInclud

; 1775 : 	(ctxt->incTab[nr]->count <= 1)) {
; 1776 : #ifdef DEBUG_XINCLUDE
; 1777 :         printf("freeing %s\n", ctxt->incTab[nr]->doc->URL);
; 1778 : #endif
; 1779 : 	xmlFreeDoc(ctxt->incTab[nr]->doc);

	push	ecx
	call	_xmlFreeDoc

; 1780 : 	ctxt->incTab[nr]->doc = NULL;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
	mov	eax, DWORD PTR [eax+ebx]
	mov	DWORD PTR [eax+8], 0
$LN69@xmlXInclud:

; 1781 :     }
; 1782 :     xmlFree(URL);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1783 :     return(0);

	xor	eax, eax
	pop	edi

; 1784 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN158@xmlXInclud:
	DD	$LN41@xmlXInclud
	DD	$LN42@xmlXInclud
	DD	$LN43@xmlXInclud
$LN141@xmlXInclud:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
	npad	2
$LN159@xmlXInclud:
	DD	$LN10@xmlXInclud
	DD	$LN49@xmlXInclud
	DD	$LN51@xmlXInclud
	DD	$LN50@xmlXInclud
$LN142@xmlXInclud:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	2
	DB	2
	DB	0
_xmlXIncludeLoadDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeMergeEntities
_TEXT	SEGMENT
_data$1 = -8						; size = 8
_data$2 = -8						; size = 8
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_from$ = 16						; size = 4
_xmlXIncludeMergeEntities PROC				; COMDAT

; 1344 : 	                 xmlDocPtr from) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __07371726_xinclude@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	$LN14@xmlXInclud

; 1345 :     xmlNodePtr cur;
; 1346 :     xmlDtdPtr target, source;
; 1347 : 
; 1348 :     if (ctxt == NULL)
; 1349 : 	return(-1);
; 1350 : 
; 1351 :     if ((from == NULL) || (from->intSubset == NULL))

	mov	esi, DWORD PTR _from$[ebp]
	test	esi, esi
	je	$LN4@xmlXInclud
	cmp	DWORD PTR [esi+44], 0
	je	$LN4@xmlXInclud

; 1352 : 	return(0);
; 1353 : 
; 1354 :     target = doc->intSubset;

	mov	edi, DWORD PTR _doc$[ebp]
	mov	ebx, DWORD PTR [edi+44]

; 1355 :     if (target == NULL) {

	test	ebx, ebx
	jne	SHORT $LN13@xmlXInclud

; 1356 : 	cur = xmlDocGetRootElement(doc);

	push	edi
	call	_xmlDocGetRootElement
	add	esp, 4

; 1357 : 	if (cur == NULL)

	test	eax, eax
	je	$LN14@xmlXInclud

; 1358 : 	    return(-1);
; 1359 :         target = xmlCreateIntSubset(doc, cur->name, NULL, NULL);

	push	ebx
	push	ebx
	push	DWORD PTR [eax+8]
	push	edi
	call	_xmlCreateIntSubset
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 1360 : 	if (target == NULL)

	test	ebx, ebx
	je	$LN14@xmlXInclud
	mov	eax, DWORD PTR _ctxt$[ebp]
$LN13@xmlXInclud:

; 1361 : 	    return(-1);
; 1362 :     }
; 1363 : 
; 1364 :     source = from->intSubset;

	mov	ecx, DWORD PTR [esi+44]

; 1365 :     if ((source != NULL) && (source->entities != NULL)) {

	test	ecx, ecx
	je	SHORT $LN8@xmlXInclud
	mov	ecx, DWORD PTR [ecx+48]
	test	ecx, ecx
	je	SHORT $LN8@xmlXInclud

; 1366 : 	xmlXIncludeMergeData data;
; 1367 : 
; 1368 : 	data.ctxt = ctxt;

	mov	DWORD PTR _data$2[ebp+4], eax

; 1369 : 	data.doc = doc;
; 1370 : 
; 1371 : 	xmlHashScan((xmlHashTablePtr) source->entities,

	lea	eax, DWORD PTR _data$2[ebp]
	push	eax
	push	OFFSET _xmlXIncludeMergeEntity
	push	ecx
	mov	DWORD PTR _data$2[ebp], edi
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN8@xmlXInclud:

; 1372 : 		    xmlXIncludeMergeEntity, &data);
; 1373 :     }
; 1374 :     source = from->extSubset;

	mov	esi, DWORD PTR [esi+48]

; 1375 :     if ((source != NULL) && (source->entities != NULL)) {

	test	esi, esi
	je	SHORT $LN4@xmlXInclud
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN4@xmlXInclud

; 1376 : 	xmlXIncludeMergeData data;
; 1377 : 
; 1378 : 	data.ctxt = ctxt;
; 1379 : 	data.doc = doc;
; 1380 : 
; 1381 : 	/*
; 1382 : 	 * don't duplicate existing stuff when external subsets are the same
; 1383 : 	 */
; 1384 : 	if ((!xmlStrEqual(target->ExternalID, source->ExternalID)) &&

	push	DWORD PTR [esi+52]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [ebx+52]
	mov	DWORD PTR _data$1[ebp+4], eax
	mov	DWORD PTR _data$1[ebp], edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlXInclud
	push	DWORD PTR [esi+56]
	push	DWORD PTR [ebx+56]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@xmlXInclud

; 1385 : 	    (!xmlStrEqual(target->SystemID, source->SystemID))) {
; 1386 : 	    xmlHashScan((xmlHashTablePtr) source->entities,

	lea	eax, DWORD PTR _data$1[ebp]
	push	eax
	push	OFFSET _xmlXIncludeMergeEntity
	push	DWORD PTR [esi+48]
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
$LN4@xmlXInclud:

; 1387 : 			xmlXIncludeMergeEntity, &data);
; 1388 : 	}
; 1389 :     }
; 1390 :     return(0);
; 1391 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlXInclud:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeMergeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeMergeEntity
_TEXT	SEGMENT
_ret$1$ = 8						; size = 4
_payload$ = 8						; size = 4
_vdata$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlXIncludeMergeEntity PROC				; COMDAT

; 1265 : 	               const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _payload$[ebp]
	test	esi, esi
	je	$LN24@xmlXInclud

; 1266 :     xmlEntityPtr ent = (xmlEntityPtr) payload;
; 1267 :     xmlXIncludeMergeDataPtr data = (xmlXIncludeMergeDataPtr) vdata;
; 1268 :     xmlEntityPtr ret, prev;
; 1269 :     xmlDocPtr doc;
; 1270 :     xmlXIncludeCtxtPtr ctxt;
; 1271 : 
; 1272 :     if ((ent == NULL) || (data == NULL))

	mov	eax, DWORD PTR _vdata$[ebp]
	test	eax, eax
	je	$LN24@xmlXInclud

; 1273 : 	return;
; 1274 :     ctxt = data->ctxt;

	push	ebx
	mov	ebx, DWORD PTR [eax+4]

; 1276 :     if ((ctxt == NULL) || (doc == NULL))

	test	ebx, ebx
	je	$LN30@xmlXInclud

; 1275 :     doc = data->doc;

	push	edi
	mov	edi, DWORD PTR [eax]

; 1276 :     if ((ctxt == NULL) || (doc == NULL))

	test	edi, edi
	je	$LN31@xmlXInclud

; 1277 : 	return;
; 1278 :     switch (ent->etype) {

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, 4
	jl	SHORT $LN11@xmlXInclud
	cmp	eax, 6
	jle	$LN31@xmlXInclud
$LN11@xmlXInclud:

; 1279 :         case XML_INTERNAL_PARAMETER_ENTITY:
; 1280 :         case XML_EXTERNAL_PARAMETER_ENTITY:
; 1281 :         case XML_INTERNAL_PREDEFINED_ENTITY:
; 1282 : 	    return;
; 1283 :         case XML_INTERNAL_GENERAL_ENTITY:
; 1284 :         case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1285 :         case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1286 : 	    break;
; 1287 :     }
; 1288 :     ret = xmlAddDocEntity(doc, ent->name, ent->etype, ent->ExternalID,

	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+52]
	push	eax
	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlAddDocEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$1$[ebp], eax

; 1289 : 			  ent->SystemID, ent->content);
; 1290 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN12@xmlXInclud

; 1291 : 	if (ent->URI != NULL)

	mov	ecx, DWORD PTR [esi+64]
	test	ecx, ecx
	je	$LN31@xmlXInclud

; 1292 : 	    ret->URI = xmlStrdup(ent->URI);

	push	ecx
	call	_xmlStrdup
	mov	ecx, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	edi
	pop	ebx
	mov	DWORD PTR [ecx+64], eax
	pop	esi

; 1328 :                    "mismatch in redefinition of entity %s\n",
; 1329 : 		   ent->name);
; 1330 : }

	pop	ebp
	ret	0
$LN12@xmlXInclud:

; 1293 :     } else {
; 1294 : 	prev = xmlGetDocEntity(doc, ent->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlGetDocEntity
	add	esp, 8

; 1295 : 	if (prev != NULL) {

	test	eax, eax
	je	SHORT $LN31@xmlXInclud

; 1296 : 	    if (ent->etype != prev->etype)

	mov	ecx, DWORD PTR [esi+48]
	cmp	ecx, DWORD PTR [eax+48]
	jne	SHORT $error$36

; 1297 : 		goto error;
; 1298 : 
; 1299 : 	    if ((ent->SystemID != NULL) && (prev->SystemID != NULL)) {

	mov	edx, DWORD PTR [esi+56]
	test	edx, edx
	je	SHORT $LN17@xmlXInclud
	mov	ecx, DWORD PTR [eax+56]
	test	ecx, ecx
	je	SHORT $LN17@xmlXInclud

; 1300 : 		if (!xmlStrEqual(ent->SystemID, prev->SystemID))

	push	ecx
	push	edx

; 1301 : 		    goto error;
; 1302 : 	    } else if ((ent->ExternalID != NULL) &&

	jmp	SHORT $LN33@xmlXInclud
$LN17@xmlXInclud:
	mov	edx, DWORD PTR [esi+52]
	test	edx, edx
	je	SHORT $LN20@xmlXInclud
	mov	ecx, DWORD PTR [eax+52]
	test	ecx, ecx
	je	SHORT $LN20@xmlXInclud

; 1303 : 		       (prev->ExternalID != NULL)) {
; 1304 : 		if (!xmlStrEqual(ent->ExternalID, prev->ExternalID))

	push	ecx
	push	edx

; 1305 : 		    goto error;
; 1306 : 	    } else if ((ent->content != NULL) && (prev->content != NULL)) {

	jmp	SHORT $LN33@xmlXInclud
$LN20@xmlXInclud:
	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $error$36
	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $error$36

; 1307 : 		if (!xmlStrEqual(ent->content, prev->content))

	push	eax
	push	ecx
$LN33@xmlXInclud:

; 1308 : 		    goto error;
; 1309 : 	    } else {
; 1310 : 		goto error;
; 1311 : 	    }
; 1312 : 
; 1313 : 	}
; 1314 :     }
; 1315 :     return;
; 1316 : error:
; 1317 :     switch (ent->etype) {

	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@xmlXInclud
$error$36:
	mov	eax, DWORD PTR [esi+48]
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN27@xmlXInclud
	movzx	eax, BYTE PTR $LN29@xmlXInclud[eax]
	jmp	DWORD PTR $LN35@xmlXInclud[eax*4]
$LN27@xmlXInclud:

; 1318 :         case XML_INTERNAL_PARAMETER_ENTITY:
; 1319 :         case XML_EXTERNAL_PARAMETER_ENTITY:
; 1320 :         case XML_INTERNAL_PREDEFINED_ENTITY:
; 1321 :         case XML_INTERNAL_GENERAL_ENTITY:
; 1322 :         case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1323 : 	    return;
; 1324 :         case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1325 : 	    break;
; 1326 :     }
; 1327 :     xmlXIncludeErr(ctxt, (xmlNodePtr) ent, XML_XINCLUDE_ENTITY_DEF_MISMATCH,

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0CH@PEJDIBGL@mismatch?5in?5redefinition?5of?5ent@
	push	1602					; 00000642H
	push	esi
	push	ebx
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
$LN31@xmlXInclud:
	pop	edi
$LN30@xmlXInclud:
	pop	ebx
$LN24@xmlXInclud:
	pop	esi

; 1328 :                    "mismatch in redefinition of entity %s\n",
; 1329 : 		   ent->name);
; 1330 : }

	pop	ebp
	ret	0
	npad	1
$LN35@xmlXInclud:
	DD	$LN31@xmlXInclud
	DD	$LN27@xmlXInclud
$LN29@xmlXInclud:
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
_xmlXIncludeMergeEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeCopyXPointer
_TEXT	SEGMENT
_set$1$ = -12						; size = 4
_i$2$ = -8						; size = 4
_list$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_source$ = 16						; size = 4
_obj$ = 20						; size = 4
_xmlXIncludeCopyXPointer PROC				; COMDAT

; 1125 : 	                xmlDocPtr source, xmlXPathObjectPtr obj) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _target$[ebp]
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _source$[ebp]
	xor	esi, esi
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _list$1$[ebp], 0
	test	edx, edx
	jne	SHORT $LN18@xmlXInclud

; 1126 :     xmlNodePtr list = NULL, last = NULL;
; 1127 :     int i;
; 1128 : 
; 1129 :     if (source == NULL)
; 1130 : 	source = ctxt->doc;

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR _source$[ebp], edx
$LN18@xmlXInclud:

; 1131 :     if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||

	test	ebx, ebx
	je	$LN20@xmlXInclud
	test	edi, edi
	je	$LN20@xmlXInclud
	test	edx, edx
	je	$LN20@xmlXInclud
	mov	ecx, DWORD PTR _obj$[ebp]
	test	ecx, ecx
	je	$LN20@xmlXInclud

; 1132 : 	(obj == NULL))
; 1133 : 	return(NULL);
; 1134 :     switch (obj->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 1
	je	$LN21@xmlXInclud
	sub	eax, 5
	je	SHORT $LN39@xmlXInclud
	sub	eax, 1
	jne	$LN5@xmlXInclud

; 1206 : 			last = last->next;
; 1207 : 		}
; 1208 : 	    }
; 1209 : 	    break;
; 1210 : 	}
; 1211 : #ifdef LIBXML_XPTR_ENABLED
; 1212 : 	case XPATH_LOCATIONSET: {
; 1213 : 	    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;

	mov	ebx, DWORD PTR [ecx+28]

; 1214 : 	    if (set == NULL)

	test	ebx, ebx
	je	$LN20@xmlXInclud

; 1215 : 		return(NULL);
; 1216 : 	    for (i = 0;i < set->locNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], esi
	jle	$LN5@xmlXInclud
	npad	1
$LL15@xmlXInclud:

; 1217 : 		if (last == NULL)

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+edi*4]
	push	edx
	push	DWORD PTR _target$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXIncludeCopyXPointer
	add	esp, 16					; 00000010H
	test	esi, esi
	jne	SHORT $LN36@xmlXInclud

; 1218 : 		    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,

	mov	esi, eax
	mov	DWORD PTR _list$1$[ebp], esi
	jmp	SHORT $LN37@xmlXInclud
$LN36@xmlXInclud:

; 1219 : 			                                  set->locTab[i]);
; 1220 : 		else
; 1221 : 		    xmlAddNextSibling(last,

	push	eax
	push	esi
	call	_xmlAddNextSibling
	add	esp, 8
$LN37@xmlXInclud:

; 1222 : 			    xmlXIncludeCopyXPointer(ctxt, target, source,
; 1223 : 				                    set->locTab[i]));
; 1224 : 		if (last != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlXInclud

; 1225 : 		    while (last->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN13@xmlXInclud
$LL16@xmlXInclud:

; 1226 : 			last = last->next;

	mov	esi, eax
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LL16@xmlXInclud
$LN13@xmlXInclud:

; 1215 : 		return(NULL);
; 1216 : 	    for (i = 0;i < set->locNr;i++) {

	mov	edx, DWORD PTR _source$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL15@xmlXInclud

; 1233 : #endif
; 1234 : 	case XPATH_POINT:
; 1235 : 	    /* points are ignored in XInclude */
; 1236 : 	    break;
; 1237 : 	default:
; 1238 : 	    break;
; 1239 :     }
; 1240 :     return(list);

	mov	eax, DWORD PTR _list$1$[ebp]
	pop	edi

; 1241 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlXInclud:

; 1227 : 		}
; 1228 : 	    }
; 1229 : 	    break;
; 1230 : 	}
; 1231 : 	case XPATH_RANGE:
; 1232 : 	    return(xmlXIncludeCopyRange(ctxt, target, source, obj));

	push	ecx
	push	edx
	push	edi
	push	ebx
	call	_xmlXIncludeCopyRange
	add	esp, 16					; 00000010H
	pop	edi

; 1241 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXInclud:

; 1135 :         case XPATH_NODESET: {
; 1136 : 	    xmlNodeSetPtr set = obj->nodesetval;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _set$1$[ebp], eax

; 1137 : 	    if (set == NULL)

	test	eax, eax
	je	$LN20@xmlXInclud

; 1138 : 		return(NULL);
; 1139 : 	    for (i = 0;i < set->nodeNr;i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	DWORD PTR [eax], ecx
	jle	$LN5@xmlXInclud
	npad	2
$LL6@xmlXInclud:

; 1140 : 		if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	je	SHORT $LN4@xmlXInclud

; 1141 : 		    continue;
; 1142 : 		switch (set->nodeTab[i]->type) {

	mov	eax, DWORD PTR [ecx+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 17					; 00000011H
	ja	$LN7@xmlXInclud
	movzx	eax, BYTE PTR $LN62@xmlXInclud[eax]
	jmp	DWORD PTR $LN67@xmlXInclud[eax*4]
$LN25@xmlXInclud:

; 1143 : 		    case XML_TEXT_NODE:
; 1144 : 		    case XML_CDATA_SECTION_NODE:
; 1145 : 		    case XML_ELEMENT_NODE:
; 1146 : 		    case XML_ENTITY_REF_NODE:
; 1147 : 		    case XML_ENTITY_NODE:
; 1148 : 		    case XML_PI_NODE:
; 1149 : 		    case XML_COMMENT_NODE:
; 1150 : 		    case XML_DOCUMENT_NODE:
; 1151 : 		    case XML_HTML_DOCUMENT_NODE:
; 1152 : #ifdef LIBXML_DOCB_ENABLED
; 1153 : 		    case XML_DOCB_DOCUMENT_NODE:
; 1154 : #endif
; 1155 : 		    case XML_XINCLUDE_END:
; 1156 : 			break;
; 1157 : 		    case XML_XINCLUDE_START: {
; 1158 : 	                xmlNodePtr tmp, cur = set->nodeTab[i];
; 1159 : 
; 1160 : 			cur = cur->next;

	mov	edi, DWORD PTR [ecx+24]

; 1161 : 			while (cur != NULL) {

	test	edi, edi
	je	SHORT $LN65@xmlXInclud
	npad	2
$LL9@xmlXInclud:

; 1162 : 			    switch(cur->type) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN26@xmlXInclud
	add	eax, -3					; fffffffdH
	cmp	eax, 5
	ja	SHORT $LN65@xmlXInclud
$LN26@xmlXInclud:

; 1163 : 				case XML_TEXT_NODE:
; 1164 : 				case XML_CDATA_SECTION_NODE:
; 1165 : 				case XML_ELEMENT_NODE:
; 1166 : 				case XML_ENTITY_REF_NODE:
; 1167 : 				case XML_ENTITY_NODE:
; 1168 : 				case XML_PI_NODE:
; 1169 : 				case XML_COMMENT_NODE:
; 1170 : 				    tmp = xmlXIncludeCopyNode(ctxt, target,

	push	edi
	push	edx
	push	DWORD PTR _target$[ebp]
	push	ebx
	call	_xmlXIncludeCopyNode
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 1171 : 							      source, cur);
; 1172 : 				    if (last == NULL) {

	test	esi, esi
	jne	SHORT $LN27@xmlXInclud

; 1173 : 					list = last = tmp;

	mov	esi, eax
	mov	DWORD PTR _list$1$[ebp], ebx

; 1174 : 				    } else {

	jmp	SHORT $LN28@xmlXInclud
$LN27@xmlXInclud:

; 1175 : 					xmlAddNextSibling(last, tmp);

	push	ebx
	push	esi
	call	_xmlAddNextSibling
	add	esp, 8

; 1176 : 					last = tmp;

	mov	esi, ebx
$LN28@xmlXInclud:

; 1177 : 				    }
; 1178 : 				    cur = cur->next;

	mov	edi, DWORD PTR [edi+24]
	mov	edx, DWORD PTR _source$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	jne	SHORT $LL9@xmlXInclud
$LN65@xmlXInclud:

; 1138 : 		return(NULL);
; 1139 : 	    for (i = 0;i < set->nodeNr;i++) {

	mov	edi, DWORD PTR _target$[ebp]
$LN4@xmlXInclud:
	mov	ecx, DWORD PTR _i$2$[ebp]
	mov	eax, DWORD PTR _set$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jl	$LL6@xmlXInclud
$LN5@xmlXInclud:

; 1233 : #endif
; 1234 : 	case XPATH_POINT:
; 1235 : 	    /* points are ignored in XInclude */
; 1236 : 	    break;
; 1237 : 	default:
; 1238 : 	    break;
; 1239 :     }
; 1240 :     return(list);

	mov	eax, DWORD PTR _list$1$[ebp]
	pop	edi

; 1241 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXInclud:

; 1179 : 				    continue;
; 1180 : 				default:
; 1181 : 				    break;
; 1182 : 			    }
; 1183 : 			    break;
; 1184 : 			}
; 1185 : 			continue;
; 1186 : 		    }
; 1187 : 		    case XML_ATTRIBUTE_NODE:
; 1188 : 		    case XML_NAMESPACE_DECL:
; 1189 : 		    case XML_DOCUMENT_TYPE_NODE:
; 1190 : 		    case XML_DOCUMENT_FRAG_NODE:
; 1191 : 		    case XML_NOTATION_NODE:
; 1192 : 		    case XML_DTD_NODE:
; 1193 : 		    case XML_ELEMENT_DECL:
; 1194 : 		    case XML_ATTRIBUTE_DECL:
; 1195 : 		    case XML_ENTITY_DECL:
; 1196 : 			continue; /* for */
; 1197 : 		}
; 1198 : 		if (last == NULL)

	push	ecx
	push	edx
	push	edi
	push	ebx
	call	_xmlXIncludeCopyNode
	add	esp, 16					; 00000010H
	test	esi, esi
	jne	SHORT $LN31@xmlXInclud

; 1199 : 		    list = last = xmlXIncludeCopyNode(ctxt, target, source,

	mov	edx, DWORD PTR _source$[ebp]
	mov	esi, eax
	mov	DWORD PTR _list$1$[ebp], esi
	jmp	SHORT $LN4@xmlXInclud
$LN31@xmlXInclud:

; 1200 : 			                              set->nodeTab[i]);
; 1201 : 		else {
; 1202 : 		    xmlAddNextSibling(last,

	push	eax
	push	esi
	call	_xmlAddNextSibling

; 1203 : 			    xmlXIncludeCopyNode(ctxt, target, source,
; 1204 : 				                set->nodeTab[i]));
; 1205 : 		    if (last->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	add	esp, 8
	mov	edx, DWORD PTR _source$[ebp]
	test	eax, eax
	cmovne	esi, eax
	jmp	SHORT $LN4@xmlXInclud
$LN20@xmlXInclud:
	pop	edi

; 1241 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN67@xmlXInclud:
	DD	$LN4@xmlXInclud
	DD	$LN25@xmlXInclud
	DD	$LN7@xmlXInclud
$LN62@xmlXInclud:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
_xmlXIncludeCopyXPointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeCopyRange
_TEXT	SEGMENT
_endLevel$1$ = -36					; size = 4
_endFlag$1$ = -32					; size = 4
_end$1$ = -28						; size = 4
$T1 = -24						; size = 4
_tmp$3$ = -20						; size = 4
_tmp$1$ = -20						; size = 4
_cur$1$ = -20						; size = 4
_listParent$1$ = -16					; size = 4
_start$1$ = -12						; size = 4
_lastLevel$1$ = -8					; size = 4
_level$ = -4						; size = 4
_index1$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_source$ = 16						; size = 4
_range$ = 20						; size = 4
_xmlXIncludeCopyRange PROC				; COMDAT

; 911  : 	                xmlDocPtr source, xmlXPathObjectPtr range) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	xor	edx, edx
	xor	ebx, ebx
	mov	DWORD PTR _listParent$1$[ebp], eax
	xor	esi, esi
	mov	DWORD PTR _level$[ebp], eax
	mov	DWORD PTR _lastLevel$1$[ebp], edx
	mov	DWORD PTR _endLevel$1$[ebp], eax
	mov	DWORD PTR _endFlag$1$[ebp], eax
	cmp	DWORD PTR _ctxt$[ebp], eax
	je	$LN11@xmlXInclud

; 912  :     /* pointers to generated nodes */
; 913  :     xmlNodePtr list = NULL, last = NULL, listParent = NULL;
; 914  :     xmlNodePtr tmp, tmp2;
; 915  :     /* pointers to traversal nodes */
; 916  :     xmlNodePtr start, cur, end;
; 917  :     int index1, index2;
; 918  :     int level = 0, lastLevel = 0, endLevel = 0, endFlag = 0;
; 919  : 
; 920  :     if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||

	mov	edi, DWORD PTR _target$[ebp]
	test	edi, edi
	je	$LN11@xmlXInclud
	cmp	DWORD PTR _source$[ebp], eax
	je	$LN11@xmlXInclud
	mov	ecx, DWORD PTR _range$[ebp]
	test	ecx, ecx
	je	$LN11@xmlXInclud

; 923  :     if (range->type != XPATH_RANGE)

	cmp	DWORD PTR [ecx], 6
	jne	$LN11@xmlXInclud

; 924  : 	return(NULL);
; 925  :     start = (xmlNodePtr) range->user;

	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _start$1$[ebp], edx

; 926  : 
; 927  :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	test	edx, edx
	je	$LN11@xmlXInclud
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	je	$LN11@xmlXInclud

; 928  : 	return(NULL);
; 929  :     end = range->user2;

	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _end$1$[ebp], edx

; 930  :     if (end == NULL)

	test	edx, edx
	jne	SHORT $LN15@xmlXInclud

; 931  : 	return(xmlDocCopyNode(start, target, 1));

	push	1
	push	edi
	push	DWORD PTR _start$1$[ebp]
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	pop	edi

; 1105 : 	    break;
; 1106 :     }
; 1107 :     return(list);
; 1108 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlXInclud:

; 932  :     if (end->type == XML_NAMESPACE_DECL)

	mov	edi, DWORD PTR _end$1$[ebp]
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN11@xmlXInclud

; 933  :         return(NULL);
; 934  : 
; 935  :     cur = start;
; 936  :     index1 = range->index;

	mov	edx, DWORD PTR [ecx+32]
	mov	edi, DWORD PTR _start$1$[ebp]

; 937  :     index2 = range->index2;

	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR _index1$1$[ebp], edx
	mov	edx, eax
	mov	DWORD PTR _cur$1$[ebp], edi
	mov	DWORD PTR $T1[ebp], ecx
$LL2@xmlXInclud:

; 947  : 	/*
; 948  : 	 * Check if our output tree needs a parent
; 949  : 	 */
; 950  : 	if (level < 0) {

	test	eax, eax
	jns	SHORT $LN59@xmlXInclud
	mov	edi, DWORD PTR _listParent$1$[ebp]
	npad	6
$LL4@xmlXInclud:

; 951  : 	    while (level < 0) {
; 952  : 	        /* copy must include namespaces and properties */
; 953  : 	        tmp2 = xmlDocCopyNode(listParent, target, 2);

	push	2
	push	DWORD PTR _target$[ebp]
	push	edi
	call	_xmlDocCopyNode
	mov	esi, eax

; 954  : 	        xmlAddChild(tmp2, list);

	push	ebx
	push	esi
	call	_xmlAddChild

; 955  : 	        list = tmp2;
; 956  : 	        listParent = listParent->parent;
; 957  : 	        level++;

	mov	eax, DWORD PTR _level$[ebp]
	add	esp, 20					; 00000014H
	mov	edi, DWORD PTR [edi+20]
	add	eax, 1
	mov	ebx, esi
	mov	DWORD PTR _level$[ebp], eax
	js	SHORT $LL4@xmlXInclud

; 958  : 	    }
; 959  : 	    last = list;
; 960  : 	    lastLevel = 0;

	xor	edx, edx
	mov	DWORD PTR _listParent$1$[ebp], edi
	mov	edi, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR _lastLevel$1$[ebp], edx
$LN59@xmlXInclud:

; 961  : 	}
; 962  : 	/*
; 963  : 	 * Check whether we need to change our insertion point
; 964  : 	 */
; 965  : 	while (level < lastLevel) {

	cmp	eax, edx
	jge	SHORT $LN7@xmlXInclud
	mov	ecx, edx
	sub	ecx, eax
	sub	edx, ecx
	mov	DWORD PTR _lastLevel$1$[ebp], edx
	npad	1
$LL6@xmlXInclud:

; 966  : 	    last = last->parent;

	mov	esi, DWORD PTR [esi+20]
	sub	ecx, 1
	jne	SHORT $LL6@xmlXInclud
$LN7@xmlXInclud:

; 967  : 	    lastLevel --;
; 968  : 	}
; 969  : 	if (cur == end) {	/* Are we at the end of the range? */

	mov	ecx, DWORD PTR [edi+4]
	cmp	edi, DWORD PTR _end$1$[ebp]
	jne	$LN18@xmlXInclud

; 970  : 	    if (cur->type == XML_TEXT_NODE) {

	cmp	ecx, 3
	je	$LN60@xmlXInclud

; 995  : 	    } else {	/* ending node not a text node */
; 996  : 	        endLevel = level;	/* remember the level of the end node */
; 997  : 		endFlag = 1;
; 998  : 		/* last node - need to take care of properties + namespaces */
; 999  : 		tmp = xmlDocCopyNode(cur, target, 2);

	push	2
	push	DWORD PTR _target$[ebp]
	mov	DWORD PTR _endLevel$1$[ebp], eax
	push	edi
	mov	DWORD PTR _endFlag$1$[ebp], 1
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$1$[ebp], eax

; 1000 : 		if (list == NULL) {

	test	ebx, ebx
	jne	SHORT $LN29@xmlXInclud

; 1001 : 		    list = tmp;

	mov	ebx, eax

; 1002 : 		    listParent = cur->parent;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _listParent$1$[ebp], eax

; 1003 : 		} else {

	mov	eax, DWORD PTR _level$[ebp]
	jmp	SHORT $LN32@xmlXInclud
$LN29@xmlXInclud:

; 1004 : 		    if (level == lastLevel)

	mov	ecx, DWORD PTR _lastLevel$1$[ebp]
	push	eax
	push	esi
	cmp	DWORD PTR _level$[ebp], ecx
	jne	SHORT $LN31@xmlXInclud

; 1005 : 			xmlAddNextSibling(last, tmp);

	call	_xmlAddNextSibling
	mov	eax, DWORD PTR _level$[ebp]
	jmp	SHORT $LN76@xmlXInclud
$LN31@xmlXInclud:

; 1006 : 		    else {
; 1007 : 			xmlAddChild(last, tmp);

	call	_xmlAddChild

; 1008 : 			lastLevel = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR _lastLevel$1$[ebp], eax
$LN76@xmlXInclud:

; 1009 : 		    }
; 1010 : 		}
; 1011 : 		last = tmp;

	add	esp, 8
$LN32@xmlXInclud:

; 1012 : 
; 1013 : 		if (index2 > 1) {

	mov	ecx, DWORD PTR $T1[ebp]
	mov	esi, DWORD PTR _tmp$1$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN33@xmlXInclud

; 1014 : 		    end = xmlXIncludeGetNthChild(cur, index2 - 1);

	lea	eax, DWORD PTR [ecx-1]
	push	eax
	push	edi
	call	_xmlXIncludeGetNthChild
	add	esp, 8
	mov	DWORD PTR _end$1$[ebp], eax

; 1015 : 		    index2 = 0;

	mov	eax, DWORD PTR _level$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR $T1[ebp], ecx
$LN33@xmlXInclud:

; 1016 : 		}
; 1017 : 		if ((cur == start) && (index1 > 1)) {

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	SHORT $LN34@xmlXInclud
	mov	ecx, DWORD PTR _index1$1$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN34@xmlXInclud

; 1018 : 		    cur = xmlXIncludeGetNthChild(cur, index1 - 1);

	lea	eax, DWORD PTR [ecx-1]
	push	eax
	push	edi
	call	_xmlXIncludeGetNthChild
	mov	edi, eax
	mov	DWORD PTR _cur$1$[ebp], eax

; 1019 : 		    index1 = 0;
; 1020 : 		}  else {

	mov	eax, DWORD PTR _level$[ebp]
	add	esp, 8

; 1022 : 		}
; 1023 : 		level++;	/* increment level to show change */

	inc	eax
	mov	DWORD PTR _index1$1$[ebp], 0
	mov	DWORD PTR _level$[ebp], eax

; 1024 : 		/*
; 1025 : 		 * Now gather the remaining nodes from cur to end
; 1026 : 		 */
; 1027 : 		continue;	/* while */

	jmp	$LN77@xmlXInclud
$LN34@xmlXInclud:

; 1021 : 		    cur = cur->children;

	mov	edi, DWORD PTR [edi+12]

; 1022 : 		}
; 1023 : 		level++;	/* increment level to show change */

	inc	eax
	mov	DWORD PTR _cur$1$[ebp], edi
	mov	DWORD PTR _level$[ebp], eax

; 1024 : 		/*
; 1025 : 		 * Now gather the remaining nodes from cur to end
; 1026 : 		 */
; 1027 : 		continue;	/* while */

	jmp	$LN77@xmlXInclud
$LN18@xmlXInclud:

; 1028 : 	    }
; 1029 : 	} else if (cur == start) {	/* Not at the end, are we at start? */

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	$LN36@xmlXInclud

; 1030 : 	    if ((cur->type == XML_TEXT_NODE) ||

	cmp	ecx, 3
	je	SHORT $LN40@xmlXInclud
	cmp	ecx, 4
	je	SHORT $LN40@xmlXInclud

; 1045 : 	    } else {		/* Not text node */
; 1046 : 	        /*
; 1047 : 		 * start of the range - need to take care of
; 1048 : 		 * properties and namespaces
; 1049 : 		 */
; 1050 : 		tmp = xmlDocCopyNode(cur, target, 2);

	push	2
	push	DWORD PTR _target$[ebp]
	push	edi
	call	_xmlDocCopyNode

; 1051 : 		list = last = tmp;

	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1052 : 		listParent = cur->parent;

	mov	eax, DWORD PTR [edi+20]
	mov	ebx, esi
	mov	DWORD PTR _listParent$1$[ebp], eax

; 1053 : 		if (index1 > 1) {	/* Do we need to position? */

	mov	eax, DWORD PTR _index1$1$[ebp]
	cmp	eax, 1
	jle	SHORT $LN44@xmlXInclud

; 1054 : 		    cur = xmlXIncludeGetNthChild(cur, index1 - 1);

	dec	eax
	push	eax
	push	edi
	call	_xmlXIncludeGetNthChild

; 1055 : 		    level = lastLevel = 1;

	mov	edx, 1

; 1056 : 		    index1 = 0;

	mov	DWORD PTR _index1$1$[ebp], 0
	mov	edi, eax
	mov	DWORD PTR _lastLevel$1$[ebp], edx
	mov	eax, edx
	mov	DWORD PTR _cur$1$[ebp], edi
	add	esp, 8
	mov	DWORD PTR _level$[ebp], eax

; 1057 : 		    /*
; 1058 : 		     * Now gather the remaining nodes from cur to end
; 1059 : 		     */
; 1060 : 		    continue; /* while */

	jmp	$LN53@xmlXInclud
$LN40@xmlXInclud:

; 1031 : 		(cur->type == XML_CDATA_SECTION_NODE)) {
; 1032 : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR [edi+40]

; 1033 : 
; 1034 : 		if (content == NULL) {

	test	eax, eax
	jne	SHORT $LN41@xmlXInclud

; 1035 : 		    tmp = xmlNewTextLen(NULL, 0);

	push	eax
	push	eax
	call	_xmlNewTextLen
	mov	ebx, eax
	add	esp, 8

; 1042 : 		}
; 1043 : 		last = list = tmp;
; 1044 : 		listParent = cur->parent;

	mov	eax, DWORD PTR [edi+20]

; 1061 : 		}
; 1062 : 	    }
; 1063 : 	} else {

	mov	esi, ebx
	mov	DWORD PTR _listParent$1$[ebp], eax
	jmp	SHORT $LN50@xmlXInclud
$LN41@xmlXInclud:

; 1036 : 		} else {
; 1037 : 		    if (index1 > 1) {

	mov	esi, DWORD PTR _index1$1$[ebp]
	cmp	esi, 1
	jle	SHORT $LN43@xmlXInclud

; 1038 : 			content += (index1 - 1);

	dec	eax
	add	eax, esi
$LN43@xmlXInclud:

; 1039 : 			index1 = 0;
; 1040 : 		    }
; 1041 : 		    tmp = xmlNewText(content);

	push	eax
	call	_xmlNewText
	mov	ebx, eax
	add	esp, 4
	xor	eax, eax
	cmp	esi, 1
	cmovle	eax, esi
	mov	DWORD PTR _index1$1$[ebp], eax

; 1042 : 		}
; 1043 : 		last = list = tmp;
; 1044 : 		listParent = cur->parent;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _listParent$1$[ebp], eax
$LN44@xmlXInclud:

; 1061 : 		}
; 1062 : 	    }
; 1063 : 	} else {

	mov	esi, ebx
	jmp	SHORT $LN50@xmlXInclud
$LN36@xmlXInclud:

; 1064 : 	    tmp = NULL;
; 1065 : 	    switch (cur->type) {

	add	ecx, -2					; fffffffeH
	cmp	ecx, 18					; 00000012H
	ja	SHORT $LN49@xmlXInclud
	movzx	eax, BYTE PTR $LN74@xmlXInclud[ecx]
	jmp	DWORD PTR $LN81@xmlXInclud[eax*4]
$LN49@xmlXInclud:

; 1066 : 		case XML_DTD_NODE:
; 1067 : 		case XML_ELEMENT_DECL:
; 1068 : 		case XML_ATTRIBUTE_DECL:
; 1069 : 		case XML_ENTITY_NODE:
; 1070 : 		    /* Do not copy DTD informations */
; 1071 : 		    break;
; 1072 : 		case XML_ENTITY_DECL:
; 1073 : 		    /* handle crossing entities -> stack needed */
; 1074 : 		    break;
; 1075 : 		case XML_XINCLUDE_START:
; 1076 : 		case XML_XINCLUDE_END:
; 1077 : 		    /* don't consider it part of the tree content */
; 1078 : 		    break;
; 1079 : 		case XML_ATTRIBUTE_NODE:
; 1080 : 		    /* Humm, should not happen ! */
; 1081 : 		    break;
; 1082 : 		default:
; 1083 : 		    /*
; 1084 : 		     * Middle of the range - need to take care of
; 1085 : 		     * properties and namespaces
; 1086 : 		     */
; 1087 : 		    tmp = xmlDocCopyNode(cur, target, 2);

	push	2
	push	DWORD PTR _target$[ebp]
	push	edi
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$3$[ebp], eax

; 1088 : 		    break;
; 1089 : 	    }
; 1090 : 	    if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN50@xmlXInclud

; 1091 : 		if (level == lastLevel)

	mov	ecx, DWORD PTR _lastLevel$1$[ebp]
	push	eax
	push	esi
	cmp	DWORD PTR _level$[ebp], ecx
	jne	SHORT $LN51@xmlXInclud

; 1092 : 		    xmlAddNextSibling(last, tmp);

	call	_xmlAddNextSibling
	jmp	SHORT $LN78@xmlXInclud
$LN51@xmlXInclud:

; 1093 : 		else {
; 1094 : 		    xmlAddChild(last, tmp);

	call	_xmlAddChild

; 1095 : 		    lastLevel = level;

	mov	ecx, DWORD PTR _level$[ebp]
	mov	DWORD PTR _lastLevel$1$[ebp], ecx
$LN78@xmlXInclud:

; 1096 : 		}
; 1097 : 		last = tmp;

	mov	esi, DWORD PTR _tmp$3$[ebp]
	add	esp, 8
$LN50@xmlXInclud:

; 1098 : 	    }
; 1099 : 	}
; 1100 : 	/*
; 1101 : 	 * Skip to next node in document order
; 1102 : 	 */
; 1103 : 	cur = xmlXPtrAdvanceNode(cur, &level);

	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	push	edi
	call	_xmlXPtrAdvanceNode
	mov	edi, eax
	add	esp, 8

; 1104 : 	if (endFlag && (level >= endLevel))

	cmp	DWORD PTR _endFlag$1$[ebp], 0
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR _cur$1$[ebp], edi
	je	SHORT $LN77@xmlXInclud
	cmp	eax, DWORD PTR _endLevel$1$[ebp]
	jge	SHORT $LN73@xmlXInclud
$LN77@xmlXInclud:

; 938  :     /*
; 939  :      * level is depth of the current node under consideration
; 940  :      * list is the pointer to the root of the output tree
; 941  :      * listParent is a pointer to the parent of output tree (within
; 942  :        the included file) in case we need to add another level
; 943  :      * last is a pointer to the last node added to the output tree
; 944  :      * lastLevel is the depth of last (relative to the root)
; 945  :      */
; 946  :     while (cur != NULL) {

	mov	edx, DWORD PTR _lastLevel$1$[ebp]
$LN53@xmlXInclud:
	test	edi, edi
	jne	$LL2@xmlXInclud

; 1105 : 	    break;
; 1106 :     }
; 1107 :     return(list);
; 1108 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlXInclud:

; 971  : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR [edi+40]

; 972  : 		int len;
; 973  : 
; 974  : 		if (content == NULL) {

	test	eax, eax
	jne	SHORT $LN22@xmlXInclud

; 975  : 		    tmp = xmlNewTextLen(NULL, 0);

	xor	edx, edx

; 976  : 		} else {

	jmp	SHORT $LN25@xmlXInclud
$LN22@xmlXInclud:

; 977  : 		    len = index2;
; 978  : 		    if ((cur == start) && (index1 > 1)) {

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	SHORT $LN24@xmlXInclud
	mov	ecx, DWORD PTR _index1$1$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN24@xmlXInclud

; 979  : 			content += (index1 - 1);
; 980  : 			len -= (index1 - 1);

	mov	edx, DWORD PTR $T1[ebp]
	dec	eax
	sub	edx, ecx
	add	eax, ecx
	inc	edx

; 981  : 		    } else {

	jmp	SHORT $LN25@xmlXInclud
$LN24@xmlXInclud:

; 982  : 			len = index2;

	mov	edx, DWORD PTR $T1[ebp]
$LN25@xmlXInclud:

; 983  : 		    }
; 984  : 		    tmp = xmlNewTextLen(content, len);
; 985  : 		}
; 986  : 		/* single sub text node selection */
; 987  : 		if (list == NULL)

	push	edx
	push	eax
	call	_xmlNewTextLen
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN1@xmlXInclud

; 988  : 		    return(tmp);
; 989  : 		/* prune and return full set */
; 990  : 		if (level == lastLevel)

	mov	ecx, DWORD PTR _lastLevel$1$[ebp]
	push	eax
	push	esi
	cmp	DWORD PTR _level$[ebp], ecx
	jne	SHORT $LN27@xmlXInclud

; 991  : 		    xmlAddNextSibling(last, tmp);

	call	_xmlAddNextSibling

; 994  : 		return(list);

	add	esp, 8

; 1105 : 	    break;
; 1106 :     }
; 1107 :     return(list);
; 1108 : }

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXInclud:

; 992  : 		else
; 993  : 		    xmlAddChild(last, tmp);

	call	_xmlAddChild

; 994  : 		return(list);

	add	esp, 8
$LN73@xmlXInclud:

; 1105 : 	    break;
; 1106 :     }
; 1107 :     return(list);
; 1108 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXInclud:

; 921  : 	(range == NULL))
; 922  : 	return(NULL);

	xor	eax, eax
$LN1@xmlXInclud:
	pop	edi

; 1105 : 	    break;
; 1106 :     }
; 1107 :     return(list);
; 1108 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN81@xmlXInclud:
	DD	$LN50@xmlXInclud
	DD	$LN49@xmlXInclud
$LN74@xmlXInclud:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
_xmlXIncludeCopyRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeGetNthChild
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_no$ = 12						; size = 4
_xmlXIncludeGetNthChild PROC				; COMDAT

; 877  : xmlXIncludeGetNthChild(xmlNodePtr cur, int no) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlXInclud

; 878  :     int i;
; 879  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN6@xmlXInclud

; 881  :     cur = cur->children;
; 882  :     for (i = 0;i <= no;cur = cur->next) {

	mov	esi, DWORD PTR _no$[ebp]
	xor	ecx, ecx
	mov	eax, DWORD PTR [eax+12]
	test	esi, esi
	js	SHORT $LN1@xmlXInclud
$LL4@xmlXInclud:

; 883  : 	if (cur == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlXInclud

; 884  : 	    return(cur);
; 885  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 886  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 1
	je	SHORT $LN9@xmlXInclud
	cmp	edx, 9
	je	SHORT $LN9@xmlXInclud
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN2@xmlXInclud
$LN9@xmlXInclud:

; 887  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 888  : 	    i++;

	inc	ecx

; 889  : 	    if (i == no)

	cmp	ecx, esi
	je	SHORT $LN1@xmlXInclud
$LN2@xmlXInclud:

; 881  :     cur = cur->children;
; 882  :     for (i = 0;i <= no;cur = cur->next) {

	mov	eax, DWORD PTR [eax+24]
	cmp	ecx, esi
	jle	SHORT $LL4@xmlXInclud
	pop	esi

; 890  : 		break;
; 891  : 	}
; 892  :     }
; 893  :     return(cur);
; 894  : }

	pop	ebp
	ret	0
$LN6@xmlXInclud:

; 880  :         return(NULL);

	xor	eax, eax
$LN1@xmlXInclud:
	pop	esi

; 890  : 		break;
; 891  : 	}
; 892  :     }
; 893  :     return(cur);
; 894  : }

	pop	ebp
	ret	0
_xmlXIncludeGetNthChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeCopyNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_source$ = 16						; size = 4
_elem$ = 20						; size = 4
_xmlXIncludeCopyNode PROC				; COMDAT

; 819  : 	            xmlDocPtr source, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlXInclud

; 820  :     xmlNodePtr result = NULL;
; 821  : 
; 822  :     if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||

	mov	ecx, DWORD PTR _target$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXInclud
	cmp	DWORD PTR _source$[ebp], 0
	je	SHORT $LN3@xmlXInclud
	mov	eax, DWORD PTR _elem$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud

; 825  :     if (elem->type == XML_DTD_NODE)

	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	je	SHORT $LN3@xmlXInclud

; 826  : 	return(NULL);
; 827  :     if (elem->type == XML_DOCUMENT_NODE)

	cmp	DWORD PTR [eax+4], 9
	jne	SHORT $LN5@xmlXInclud

; 828  : 	result = xmlXIncludeCopyNodeList(ctxt, target, source, elem->children);

	push	DWORD PTR [eax+12]
	push	DWORD PTR _source$[ebp]
	push	ecx
	push	edx
	call	_xmlXIncludeCopyNodeList
	add	esp, 16					; 00000010H

; 831  :     return(result);
; 832  : }

	pop	ebp
	ret	0
$LN5@xmlXInclud:

; 829  :     else
; 830  :         result = xmlDocCopyNode(elem, target, 1);

	push	1
	push	ecx
	push	eax
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH

; 831  :     return(result);
; 832  : }

	pop	ebp
	ret	0
$LN3@xmlXInclud:

; 823  : 	(elem == NULL))
; 824  : 	return(NULL);

	xor	eax, eax

; 831  :     return(result);
; 832  : }

	pop	ebp
	ret	0
_xmlXIncludeCopyNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeCopyNodeList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_target$ = 12						; size = 4
_source$ = 16						; size = 4
_elem$ = 20						; size = 4
_xmlXIncludeCopyNodeList PROC				; COMDAT

; 846  : 	                xmlDocPtr source, xmlNodePtr elem) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN5@xmlXInclud

; 847  :     xmlNodePtr cur, res, result = NULL, last = NULL;
; 848  : 
; 849  :     if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||

	mov	eax, DWORD PTR _target$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXInclud
	mov	edx, DWORD PTR _source$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlXInclud
	mov	esi, DWORD PTR _elem$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlXInclud
$LL2@xmlXInclud:

; 850  : 	(elem == NULL))
; 851  : 	return(NULL);
; 852  :     cur = elem;
; 853  :     while (cur != NULL) {
; 854  : 	res = xmlXIncludeCopyNode(ctxt, target, source, cur);

	push	esi
	push	edx
	push	eax
	push	ecx
	call	_xmlXIncludeCopyNode
	add	esp, 16					; 00000010H

; 855  : 	if (res != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlXInclud

; 856  : 	    if (result == NULL) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlXInclud

; 857  : 		result = last = res;

	mov	ebx, eax

; 858  : 	    } else {

	jmp	SHORT $LN21@xmlXInclud
$LN7@xmlXInclud:

; 859  : 		last->next = res;

	mov	DWORD PTR [edi+24], eax

; 860  : 		res->prev = last;

	mov	DWORD PTR [eax+28], edi
$LN21@xmlXInclud:

; 861  : 		last = res;
; 862  : 	    }
; 863  : 	}
; 864  : 	cur = cur->next;

	mov	edi, eax
$LN8@xmlXInclud:
	mov	esi, DWORD PTR [esi+24]
	mov	eax, DWORD PTR _target$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	test	esi, esi
	jne	SHORT $LL2@xmlXInclud

; 865  :     }
; 866  :     return(result);
; 867  : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlXInclud:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlXIncludeCopyNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeAddTxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_txt$ = 12						; size = 4
_url$ = 16						; size = 4
_xmlXIncludeAddTxt PROC					; COMDAT

; 758  : xmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, xmlNodePtr txt, const xmlURL url) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN16@xmlXInclud

; 759  : #ifdef DEBUG_XINCLUDE
; 760  :     xmlGenericError(xmlGenericErrorContext, "Adding text %s\n", url);
; 761  : #endif
; 762  :     if (ctxt->txtMax == 0) {
; 763  : 	ctxt->txtMax = 4;

	push	16					; 00000010H
	mov	DWORD PTR [esi+24], 4

; 764  :         ctxt->txtTab = (xmlNodePtr *) xmlMalloc(ctxt->txtMax *

	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 765  : 		                          sizeof(ctxt->txtTab[0]));
; 766  :         if (ctxt->txtTab == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlXInclud

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	inc	DWORD PTR [esi+52]
	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	eax
	push	eax
	push	2
	push	2
	push	11					; 0000000bH
	push	eax
	push	esi
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 795  : }

	pop	ebp
	ret	0
$LN3@xmlXInclud:

; 767  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
; 768  : 	    return;
; 769  : 	}
; 770  :         ctxt->txturlTab = (xmlURL *) xmlMalloc(ctxt->txtMax *

	mov	eax, DWORD PTR [esi+24]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+32], eax

; 771  : 		                          sizeof(ctxt->txturlTab[0]));
; 772  :         if (ctxt->txturlTab == NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlXInclud
$LN16@xmlXInclud:

; 773  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
; 774  : 	    return;
; 775  : 	}
; 776  :     }
; 777  :     if (ctxt->txtNr >= ctxt->txtMax) {

	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [esi+20], eax
	jl	SHORT $LN17@xmlXInclud

; 778  : 	ctxt->txtMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+24], eax

; 779  :         ctxt->txtTab = (xmlNodePtr *) xmlRealloc(ctxt->txtTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 780  : 	             ctxt->txtMax * sizeof(ctxt->txtTab[0]));
; 781  :         if (ctxt->txtTab == NULL) {

	test	eax, eax
	je	SHORT $LN18@xmlXInclud

; 782  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
; 783  : 	    return;
; 784  : 	}
; 785  :         ctxt->txturlTab = (xmlURL *) xmlRealloc(ctxt->txturlTab,

	mov	eax, DWORD PTR [esi+24]
	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+32]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+32], eax

; 786  : 	             ctxt->txtMax * sizeof(ctxt->txturlTab[0]));
; 787  :         if (ctxt->txturlTab == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlXInclud
$LN18@xmlXInclud:

; 788  : 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");

	push	OFFSET ??_C@_0BA@KMMAMGLP@processing?5text@
	push	0
	push	esi
	call	_xmlXIncludeErrMemory
	add	esp, 12					; 0000000cH
	pop	esi

; 795  : }

	pop	ebp
	ret	0
$LN17@xmlXInclud:

; 789  : 	    return;
; 790  : 	}
; 791  :     }
; 792  :     ctxt->txtTab[ctxt->txtNr] = txt;

	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR _txt$[ebp]

; 793  :     ctxt->txturlTab[ctxt->txtNr] = xmlStrdup(url);

	push	DWORD PTR _url$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	call	_xmlStrdup
	mov	edx, DWORD PTR [esi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+edx*4], eax

; 794  :     ctxt->txtNr++;

	inc	DWORD PTR [esi+20]
	pop	esi

; 795  : }

	pop	ebp
	ret	0
_xmlXIncludeAddTxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeRecurseDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_url$ = 16						; size = 4
_xmlXIncludeRecurseDoc PROC				; COMDAT

; 665  : 	              const xmlURL url ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _doc$[ebp]
	push	ebx
	call	_xmlXIncludeNewContext
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$LN8@xmlXInclud

; 666  :     xmlXIncludeCtxtPtr newctxt;
; 667  :     int i;
; 668  : 
; 669  :     /*
; 670  :      * Avoid recursion in already substitued resources
; 671  :     for (i = 0;i < ctxt->urlNr;i++) {
; 672  : 	if (xmlStrEqual(doc->URL, ctxt->urlTab[i]))
; 673  : 	    return;
; 674  :     }
; 675  :      */
; 676  : 
; 677  : #ifdef DEBUG_XINCLUDE
; 678  :     xmlGenericError(xmlGenericErrorContext, "Recursing in doc %s\n", doc->URL);
; 679  : #endif
; 680  :     /*
; 681  :      * Handle recursion here.
; 682  :      */
; 683  : 
; 684  :     newctxt = xmlXIncludeNewContext(doc);
; 685  :     if (newctxt != NULL) {
; 686  : 	/*
; 687  : 	 * Copy the private user data
; 688  : 	 */
; 689  : 	newctxt->_private = ctxt->_private;

	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax

; 690  : 	/*
; 691  : 	 * Copy the existing document set
; 692  : 	 */
; 693  : 	newctxt->incMax = ctxt->incMax;

	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], ecx

; 694  : 	newctxt->incNr = ctxt->incNr;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 695  :         newctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(newctxt->incMax *

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 696  : 		                          sizeof(newctxt->incTab[0]));
; 697  :         if (newctxt->incTab == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlXInclud

; 698  : 	    xmlXIncludeErrMemory(ctxt, (xmlNodePtr) doc, "processing doc");

	push	OFFSET ??_C@_0P@NPOPFDNN@processing?5doc@
	push	ebx
	push	edi
	call	_xmlXIncludeErrMemory

; 699  : 	    xmlFree(newctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 743  :     }
; 744  : #ifdef DEBUG_XINCLUDE
; 745  :     xmlGenericError(xmlGenericErrorContext, "Done recursing in doc %s\n", url);
; 746  : #endif
; 747  : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlXInclud:

; 700  : 	    return;
; 701  : 	}
; 702  : 	/*
; 703  : 	 * copy the urlTab
; 704  : 	 */
; 705  : 	newctxt->urlMax = ctxt->urlMax;

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+44], eax

; 706  : 	newctxt->urlNr = ctxt->urlNr;

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax

; 707  : 	newctxt->urlTab = ctxt->urlTab;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax

; 708  : 
; 709  : 	/*
; 710  : 	 * Inherit the existing base
; 711  : 	 */
; 712  : 	newctxt->base = xmlStrdup(ctxt->base);

	push	DWORD PTR [edi+64]
	call	_xmlStrdup
	mov	DWORD PTR [esi+64], eax

; 713  : 
; 714  : 	/*
; 715  : 	 * Inherit the documents already in use by other includes
; 716  : 	 */
; 717  : 	newctxt->incBase = ctxt->incNr;
; 718  : 	for (i = 0;i < ctxt->incNr;i++) {

	xor	edx, edx
	mov	eax, DWORD PTR [edi+8]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	cmp	DWORD PTR [edi+8], edx
	jle	SHORT $LN3@xmlXInclud
	npad	5
$LL4@xmlXInclud:

; 719  : 	    newctxt->incTab[i] = ctxt->incTab[i];

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 720  : 	    newctxt->incTab[i]->count++; /* prevent the recursion from

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+edx*4]
	inc	edx
	inc	DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [edi+8]
	jl	SHORT $LL4@xmlXInclud
$LN3@xmlXInclud:

; 721  : 					    freeing it */
; 722  : 	}
; 723  : 	/*
; 724  : 	 * The new context should also inherit the Parse Flags
; 725  : 	 * (bug 132597)
; 726  : 	 */
; 727  : 	newctxt->parseFlags = ctxt->parseFlags;

	mov	eax, DWORD PTR [edi+60]

; 728  : 	xmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc));

	push	ebx
	mov	DWORD PTR [esi+60], eax
	call	_xmlDocGetRootElement
	push	eax
	push	ebx
	push	esi
	call	_xmlXIncludeDoProcess

; 729  : 	for (i = 0;i < ctxt->incNr;i++) {

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [edi+8], ecx
	jle	SHORT $LN6@xmlXInclud
	npad	7
$LL7@xmlXInclud:

; 730  : 	    newctxt->incTab[i]->count--;

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+ecx*4]
	dec	DWORD PTR [eax+24]

; 731  : 	    newctxt->incTab[i] = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL7@xmlXInclud
$LN6@xmlXInclud:

; 732  : 	}
; 733  : 
; 734  : 	/* urlTab may have been reallocated */
; 735  : 	ctxt->urlTab = newctxt->urlTab;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [edi+48], eax

; 736  : 	ctxt->urlMax = newctxt->urlMax;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [edi+44], eax

; 737  : 
; 738  : 	newctxt->urlMax = 0;
; 739  : 	newctxt->urlNr = 0;
; 740  : 	newctxt->urlTab = NULL;
; 741  : 
; 742  : 	xmlXIncludeFreeContext(newctxt);

	push	esi
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+48], 0
	call	_xmlXIncludeFreeContext
	add	esp, 4
	pop	edi
$LN8@xmlXInclud:

; 743  :     }
; 744  : #ifdef DEBUG_XINCLUDE
; 745  :     xmlGenericError(xmlGenericErrorContext, "Done recursing in doc %s\n", url);
; 746  : #endif
; 747  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXIncludeRecurseDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeAddNode
_TEXT	SEGMENT
_eschref$1$ = -28					; size = 4
_escbase$1$ = -24					; size = 4
_local$1$ = -20						; size = 4
_base$1$ = -16						; size = 4
_fragment$1$ = -16					; size = 4
_uri$1$ = -12						; size = 4
_href$1$ = -12						; size = 4
_URL$1$ = -8						; size = 4
_parse$1$ = -8						; size = 4
_xml$1$ = -4						; size = 4
_URI$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXIncludeAddNode PROC				; COMDAT

; 489  : xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	eax, eax
	mov	DWORD PTR _xml$1$[ebp], 1
	mov	DWORD PTR _local$1$[ebp], eax
	test	esi, esi
	je	$LN65@xmlXInclud

; 490  :     xmlXIncludeRefPtr ref;
; 491  :     xmlURIPtr uri;
; 492  :     xmlChar *URL;
; 493  :     xmlChar *fragment = NULL;
; 494  :     xmlChar *href;
; 495  :     xmlChar *parse;
; 496  :     xmlChar *base;
; 497  :     xmlChar *URI;
; 498  :     int xml = 1, i; /* default Issue 64 */
; 499  :     int local = 0;
; 500  : 
; 501  : 
; 502  :     if (ctxt == NULL)
; 503  : 	return(-1);
; 504  :     if (cur == NULL)

	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	$LN65@xmlXInclud

; 505  : 	return(-1);
; 506  : 
; 507  : #ifdef DEBUG_XINCLUDE
; 508  :     xmlGenericError(xmlGenericErrorContext, "Add node\n");
; 509  : #endif
; 510  :     /*
; 511  :      * read the attributes
; 512  :      */
; 513  :     href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);

	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	ebx
	push	esi
	call	_xmlXIncludeGetProp
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _href$1$[ebp], edi

; 514  :     if (href == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlXInclud

; 515  : 	href = xmlStrdup(BAD_CAST ""); /* @@@@ href is now optional */

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	edi, eax
	mov	DWORD PTR _href$1$[ebp], eax
	add	esp, 4

; 516  : 	if (href == NULL)

	test	edi, edi
	je	$LN65@xmlXInclud
$LN8@xmlXInclud:

; 517  : 	    return(-1);
; 518  :     }
; 519  :     if ((href[0] == '#') || (href[0] == 0))

	mov	al, BYTE PTR [edi]
	cmp	al, 35					; 00000023H
	je	SHORT $LN10@xmlXInclud
	test	al, al
	jne	SHORT $LN9@xmlXInclud
$LN10@xmlXInclud:

; 520  : 	local = 1;

	mov	DWORD PTR _local$1$[ebp], 1
$LN9@xmlXInclud:

; 521  :     parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);

	push	OFFSET ??_C@_05GOEGCMJM@parse@
	push	ebx
	push	esi
	call	_xmlXIncludeGetProp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _parse$1$[ebp], eax

; 522  :     if (parse != NULL) {

	test	eax, eax
	je	SHORT $LN15@xmlXInclud

; 523  : 	if (xmlStrEqual(parse, XINCLUDE_PARSE_XML))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN12@xmlXInclud

; 524  : 	    xml = 1;

	mov	DWORD PTR _xml$1$[ebp], 1
$LN15@xmlXInclud:

; 534  : 	    return(-1);
; 535  : 	}
; 536  :     }
; 537  : 
; 538  :     /*
; 539  :      * compute the URI
; 540  :      */
; 541  :     base = xmlNodeGetBase(ctxt->doc, cur);

	push	ebx
	push	DWORD PTR [esi]
	call	_xmlNodeGetBase
	add	esp, 8
	mov	DWORD PTR _base$1$[ebp], eax

; 542  :     if (base == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlXInclud

; 543  : 	URI = xmlBuildURI(href, ctxt->doc->URL);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+72]
$LN18@xmlXInclud:

; 544  :     } else {
; 545  : 	URI = xmlBuildURI(href, base);
; 546  :     }
; 547  :     if (URI == NULL) {

	push	eax
	push	edi
	call	_xmlBuildURI
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _URI$1$[ebp], edi
	test	edi, edi
	jne	SHORT $LN22@xmlXInclud

; 548  : 	xmlChar *escbase;
; 549  : 	xmlChar *eschref;
; 550  : 	/*
; 551  : 	 * Some escaping may be needed
; 552  : 	 */
; 553  : 	escbase = xmlURIEscape(base);

	push	DWORD PTR _base$1$[ebp]
	call	_xmlURIEscape

; 554  : 	eschref = xmlURIEscape(href);

	push	DWORD PTR _href$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _escbase$1$[ebp], edi
	call	_xmlURIEscape

; 555  : 	URI = xmlBuildURI(eschref, escbase);

	push	edi
	push	eax
	mov	DWORD PTR _eschref$1$[ebp], eax
	call	_xmlBuildURI
	mov	edi, eax
	add	esp, 16					; 00000010H

; 556  : 	if (escbase != NULL)

	mov	eax, DWORD PTR _escbase$1$[ebp]
	mov	DWORD PTR _URI$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN21@xmlXInclud

; 557  : 	    xmlFree(escbase);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN21@xmlXInclud:

; 558  : 	if (eschref != NULL)

	mov	eax, DWORD PTR _eschref$1$[ebp]
	test	eax, eax
	je	SHORT $LN22@xmlXInclud

; 559  : 	    xmlFree(eschref);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlXInclud:

; 560  :     }
; 561  :     if (parse != NULL)

	mov	eax, DWORD PTR _parse$1$[ebp]
	test	eax, eax
	je	SHORT $LN23@xmlXInclud

; 562  : 	xmlFree(parse);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN23@xmlXInclud:

; 563  :     if (href != NULL)
; 564  : 	xmlFree(href);

	push	DWORD PTR _href$1$[ebp]
	call	DWORD PTR _xmlFree

; 565  :     if (base != NULL)

	mov	eax, DWORD PTR _base$1$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@xmlXInclud

; 566  : 	xmlFree(base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN25@xmlXInclud:

; 567  :     if (URI == NULL) {

	test	edi, edi
	jne	SHORT $LN26@xmlXInclud

; 568  : 	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,

	push	edi
	push	OFFSET ??_C@_0BC@LNHFKIFC@failed?5build?5URL?6@
	push	1605					; 00000645H

; 653  : }

	push	ebx
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
$LN65@xmlXInclud:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXInclud:

; 525  : 	else if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))

	push	OFFSET ??_C@_04CIMGMMMG@text@
	push	DWORD PTR _parse$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlXInclud

; 526  : 	    xml = 0;

	mov	DWORD PTR _xml$1$[ebp], 0
	jmp	$LN15@xmlXInclud
$LN14@xmlXInclud:

; 527  : 	else {
; 528  : 	    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_PARSE_VALUE,

	push	DWORD PTR _parse$1$[ebp]
	push	OFFSET ??_C@_0BO@KBIJIENG@invalid?5value?5?$CFs?5for?5?8parse?8?6@
	push	1601					; 00000641H
	push	ebx
	push	esi
	call	_xmlXIncludeErr

; 529  : 	                   "invalid value %s for 'parse'\n", parse);
; 530  : 	    if (href != NULL)
; 531  : 		xmlFree(href);

	push	edi
	call	DWORD PTR _xmlFree

; 532  : 	    if (parse != NULL)
; 533  : 		xmlFree(parse);

	push	DWORD PTR _parse$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 28					; 0000001cH

; 653  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlXInclud:

; 569  : 	               "failed build URL\n", NULL);
; 570  : 	return(-1);
; 571  :     }
; 572  :     fragment = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE_XPOINTER);

	push	OFFSET ??_C@_08DNJCJFMK@xpointer@
	push	ebx
	push	esi
	call	_xmlXIncludeGetProp

; 573  : 
; 574  :     /*
; 575  :      * Check the URL and remove any fragment identifier
; 576  :      */
; 577  :     uri = xmlParseURI((const char *)URI);

	push	DWORD PTR _URI$1$[ebp]
	mov	edi, eax
	mov	DWORD PTR _fragment$1$[ebp], edi
	call	_xmlParseURI
	add	esp, 16					; 00000010H
	mov	DWORD PTR _uri$1$[ebp], eax

; 578  :     if (uri == NULL) {

	test	eax, eax
	jne	SHORT $LN27@xmlXInclud

; 579  : 	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,

	push	DWORD PTR _URI$1$[ebp]
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@
	push	1605					; 00000645H
	push	ebx
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 580  : 	               "invalid value URI %s\n", URI);
; 581  : 	if (fragment != NULL)

	test	edi, edi
	je	SHORT $LN28@xmlXInclud

; 582  : 	    xmlFree(fragment);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN28@xmlXInclud:

; 583  : 	xmlFree(URI);

	push	DWORD PTR _URI$1$[ebp]

; 653  : }

	call	DWORD PTR _xmlFree
	add	esp, 4
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXInclud:

; 584  : 	return(-1);
; 585  :     }
; 586  : 
; 587  :     if (uri->fragment != NULL) {

	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN29@xmlXInclud

; 588  :         if (ctxt->legacy != 0) {

	cmp	DWORD PTR [esi+56], 0
	je	SHORT $LN30@xmlXInclud

; 589  : 	    if (fragment == NULL) {

	test	edi, edi
	jne	SHORT $LN32@xmlXInclud

; 590  : 		fragment = (xmlChar *) uri->fragment;

	mov	edi, ecx
	mov	DWORD PTR _fragment$1$[ebp], edi

; 591  : 	    } else {

	jmp	SHORT $LN33@xmlXInclud
$LN32@xmlXInclud:

; 592  : 		xmlFree(uri->fragment);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _uri$1$[ebp]
	add	esp, 4
$LN33@xmlXInclud:

; 602  : 	    return(-1);
; 603  : 	}
; 604  : 	uri->fragment = NULL;

	mov	DWORD PTR [eax+32], 0
$LN29@xmlXInclud:

; 605  :     }
; 606  :     URL = xmlSaveUri(uri);

	push	eax
	call	_xmlSaveUri

; 607  :     xmlFreeURI(uri);

	push	DWORD PTR _uri$1$[ebp]
	mov	DWORD PTR _URL$1$[ebp], eax
	call	_xmlFreeURI

; 608  :     xmlFree(URI);

	push	DWORD PTR _URI$1$[ebp]
	call	DWORD PTR _xmlFree

; 609  :     if (URL == NULL) {

	mov	ecx, DWORD PTR _URL$1$[ebp]
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	jne	SHORT $LN35@xmlXInclud

; 610  : 	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_HREF_URI,

	push	DWORD PTR _URI$1$[ebp]
	push	OFFSET ??_C@_0BG@NNKFOBEI@invalid?5value?5URI?5?$CFs?6@
	push	1605					; 00000645H
	jmp	SHORT $LN69@xmlXInclud
$LN30@xmlXInclud:

; 593  : 	    }
; 594  : 	} else {
; 595  : 	    xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_FRAGMENT_ID,

	push	DWORD PTR _URI$1$[ebp]
	push	OFFSET ??_C@_0EC@PPIAEBNK@Invalid?5fragment?5identifier?5in?5@
	push	1618					; 00000652H
	push	ebx
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H

; 596  :        "Invalid fragment identifier in URI %s use the xpointer attribute\n",
; 597  :                            URI);
; 598  : 	    if (fragment != NULL)

	test	edi, edi
	je	SHORT $LN34@xmlXInclud

; 599  : 	        xmlFree(fragment);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN34@xmlXInclud:

; 600  : 	    xmlFreeURI(uri);

	push	DWORD PTR _uri$1$[ebp]
	call	_xmlFreeURI

; 601  : 	    xmlFree(URI);

	push	DWORD PTR _URI$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8

; 653  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlXInclud:

; 611  : 	               "invalid value URI %s\n", URI);
; 612  : 	if (fragment != NULL)
; 613  : 	    xmlFree(fragment);
; 614  : 	return(-1);
; 615  :     }
; 616  : 
; 617  :     /*
; 618  :      * If local and xml then we need a fragment
; 619  :      */
; 620  :     if ((local == 1) && (xml == 1) &&

	mov	eax, DWORD PTR _local$1$[ebp]
	cmp	eax, 1
	jne	SHORT $LN37@xmlXInclud
	cmp	DWORD PTR _xml$1$[ebp], eax
	jne	SHORT $LN3@xmlXInclud
	test	edi, edi
	je	SHORT $LN38@xmlXInclud
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN3@xmlXInclud
$LN38@xmlXInclud:

; 621  :         ((fragment == NULL) || (fragment[0] == 0))) {
; 622  : 	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,

	push	ecx
	push	OFFSET ??_C@_0DD@GKECCJLJ@detected?5a?5local?5recursion?5with@
	push	1600					; 00000640H
$LN69@xmlXInclud:

; 653  : }

	push	ebx
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
	test	edi, edi
	je	$LN65@xmlXInclud
	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlXInclud:

; 623  : 	               "detected a local recursion with no xpointer in %s\n",
; 624  : 		       URL);
; 625  : 	if (fragment != NULL)
; 626  : 	    xmlFree(fragment);
; 627  : 	return(-1);
; 628  :     }
; 629  : 
; 630  :     /*
; 631  :      * Check the URL against the stack for recursions
; 632  :      */
; 633  :     if ((!local) && (xml == 1)) {

	test	eax, eax
	jne	SHORT $LN3@xmlXInclud
	cmp	DWORD PTR _xml$1$[ebp], 1
	jne	SHORT $LN3@xmlXInclud

; 634  : 	for (i = 0;i < ctxt->urlNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [esi+40], edi
	jle	SHORT $LN3@xmlXInclud
$LL4@xmlXInclud:

; 635  : 	    if (xmlStrEqual(URL, ctxt->urlTab[i])) {

	mov	eax, DWORD PTR [esi+48]
	push	DWORD PTR [eax+edi*4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@xmlXInclud

; 634  : 	for (i = 0;i < ctxt->urlNr;i++) {

	mov	ecx, DWORD PTR _URL$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [esi+40]
	jl	SHORT $LL4@xmlXInclud
$LN3@xmlXInclud:

; 232  :     ret = (xmlXIncludeRefPtr) xmlMalloc(sizeof(xmlXIncludeRef));

	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 233  :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN45@xmlXInclud

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	inc	DWORD PTR [esi+52]
	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	eax
	push	eax
	push	2
	push	2
	push	11					; 0000000bH
	push	ebx
	push	esi
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 653  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlXInclud:

; 636  : 		xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,

	push	DWORD PTR _URL$1$[ebp]
	push	OFFSET ??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@
	push	1600					; 00000640H

; 653  : }

	push	ebx
	push	esi
	call	_xmlXIncludeErr
	add	esp, 20					; 00000014H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlXInclud:

; 241  : 	ret->URI = xmlStrdup(URI);

	push	DWORD PTR _URL$1$[ebp]
	xorps	xmm0, xmm0

; 234  :         xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");
; 235  : 	return(NULL);
; 236  :     }
; 237  :     memset(ret, 0, sizeof(xmlXIncludeRef));

	movups	XMMWORD PTR [edi], xmm0
	movups	XMMWORD PTR [edi+16], xmm0
	mov	DWORD PTR [edi+32], 0

; 238  :     if (URI == NULL)
; 239  : 	ret->URI = NULL;
; 240  :     else
; 241  : 	ret->URI = xmlStrdup(URI);

	call	_xmlStrdup

; 242  :     ret->fragment = NULL;

	mov	DWORD PTR [edi], eax
	add	esp, 4
	mov	DWORD PTR [edi+4], 0

; 243  :     ret->ref = ref;

	mov	DWORD PTR [edi+12], ebx

; 244  :     ret->doc = NULL;

	mov	DWORD PTR [edi+8], 0

; 245  :     ret->count = 0;

	mov	DWORD PTR [edi+24], 0

; 246  :     ret->xml = 0;

	mov	DWORD PTR [edi+20], 0

; 247  :     ret->inc = NULL;

	mov	DWORD PTR [edi+16], 0

; 248  :     if (ctxt->incMax == 0) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN66@xmlXInclud

; 249  : 	ctxt->incMax = 4;
; 250  :         ctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(ctxt->incMax *

	push	16					; 00000010H
	mov	DWORD PTR [esi+12], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 251  : 					      sizeof(ctxt->incTab[0]));
; 252  :         if (ctxt->incTab == NULL) {

	test	eax, eax
	je	SHORT $LN68@xmlXInclud
$LN66@xmlXInclud:

; 253  : 	    xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");
; 254  : 	    xmlXIncludeFreeRef(ret);
; 255  : 	    return(NULL);
; 256  : 	}
; 257  :     }
; 258  :     if (ctxt->incNr >= ctxt->incMax) {

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [esi+8], eax
	jl	SHORT $LN67@xmlXInclud

; 259  : 	ctxt->incMax *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+12], eax

; 260  :         ctxt->incTab = (xmlXIncludeRefPtr *) xmlRealloc(ctxt->incTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [esi+16]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+16], eax

; 261  : 	             ctxt->incMax * sizeof(ctxt->incTab[0]));
; 262  :         if (ctxt->incTab == NULL) {

	test	eax, eax
	jne	SHORT $LN67@xmlXInclud
$LN68@xmlXInclud:

; 263  : 	    xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");

	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	ebx
	push	esi
	call	_xmlXIncludeErrMemory

; 264  : 	    xmlXIncludeFreeRef(ret);

	push	edi
	call	_xmlXIncludeFreeRef
	add	esp, 16					; 00000010H

; 653  : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlXInclud:

; 268  :     ctxt->incTab[ctxt->incNr++] = ret;

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+16]

; 651  :     xmlFree(URL);

	push	DWORD PTR _URL$1$[ebp]

; 268  :     ctxt->incTab[ctxt->incNr++] = ret;

	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi+8]

; 637  : 		               "detected a recursion in %s\n", URL);
; 638  : 		return(-1);
; 639  : 	    }
; 640  : 	}
; 641  :     }
; 642  : 
; 643  :     ref = xmlXIncludeNewRef(ctxt, URL, cur);
; 644  :     if (ref == NULL) {
; 645  : 	return(-1);
; 646  :     }
; 647  :     ref->fragment = fragment;

	mov	eax, DWORD PTR _fragment$1$[ebp]
	mov	DWORD PTR [edi+4], eax

; 648  :     ref->doc = NULL;
; 649  :     ref->xml = xml;

	mov	eax, DWORD PTR _xml$1$[ebp]
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+20], eax

; 650  :     ref->count = 1;

	mov	DWORD PTR [edi+24], 1

; 651  :     xmlFree(URL);

	call	DWORD PTR _xmlFree
	add	esp, 4

; 652  :     return(0);

	xor	eax, eax
	pop	edi

; 653  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeAddNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeParseFile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlXIncludeParseFile PROC				; COMDAT

; 421  : xmlXIncludeParseFile(xmlXIncludeCtxtPtr ctxt, const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	call	_xmlNewParserCtxt
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN2@xmlXInclud

; 111  :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlXInclud

; 112  : 	ctxt->nbErrors++;

	inc	DWORD PTR [eax+52]
$LN12@xmlXInclud:

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	0
	push	0
	push	2
	push	2
	push	11					; 0000000bH
	push	0
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 422  :     xmlDocPtr ret;
; 423  :     xmlParserCtxtPtr pctxt;
; 424  :     xmlParserInputPtr inputStream;
; 425  : 
; 426  :     xmlInitParser();
; 427  : 
; 428  :     pctxt = xmlNewParserCtxt();
; 429  :     if (pctxt == NULL) {
; 430  : 	xmlXIncludeErrMemory(ctxt, NULL, "cannot allocate parser context");
; 431  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 479  : }

	pop	ebp
	ret	0
$LN2@xmlXInclud:
	push	edi

; 432  :     }
; 433  : 
; 434  :     /*
; 435  :      * pass in the application data to the parser context.
; 436  :      */
; 437  :     pctxt->_private = ctxt->_private;

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+272], eax

; 438  : 
; 439  :     /*
; 440  :      * try to ensure that new documents included are actually
; 441  :      * built with the same dictionary as the including document.
; 442  :      */
; 443  :     if ((ctxt->doc != NULL) && (ctxt->doc->dict != NULL)) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN3@xmlXInclud

; 444  :        if (pctxt->dict != NULL)

	mov	ecx, DWORD PTR [esi+296]
	test	ecx, ecx
	je	SHORT $LN4@xmlXInclud

; 445  :             xmlDictFree(pctxt->dict);

	push	ecx
	call	_xmlDictFree
	mov	eax, DWORD PTR [edi]
	add	esp, 4
$LN4@xmlXInclud:

; 446  : 	pctxt->dict = ctxt->doc->dict;

	mov	eax, DWORD PTR [eax+80]

; 447  : 	xmlDictReference(pctxt->dict);

	push	eax
	mov	DWORD PTR [esi+296], eax
	call	_xmlDictReference
	add	esp, 4
$LN3@xmlXInclud:

; 448  :     }
; 449  : 
; 450  :     xmlCtxtUseOptions(pctxt, ctxt->parseFlags | XML_PARSE_DTDLOAD);

	mov	eax, DWORD PTR [edi+60]
	or	eax, 4
	push	eax
	push	esi
	call	_xmlCtxtUseOptions

; 451  : 
; 452  :     inputStream = xmlLoadExternalEntity(URL, NULL, pctxt);

	mov	edi, DWORD PTR _URL$[ebp]
	push	esi
	push	0
	push	edi
	call	_xmlLoadExternalEntity
	add	esp, 20					; 00000014H

; 453  :     if (inputStream == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlXInclud

; 454  : 	xmlFreeParserCtxt(pctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 455  : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 479  : }

	pop	ebp
	ret	0
$LN5@xmlXInclud:

; 456  :     }
; 457  : 
; 458  :     inputPush(pctxt, inputStream);

	push	eax
	push	esi
	call	_inputPush
	add	esp, 8

; 459  : 
; 460  :     if (pctxt->directory == NULL)

	cmp	DWORD PTR [esi+180], 0
	jne	SHORT $LN6@xmlXInclud

; 461  :         pctxt->directory = xmlParserGetDirectory(URL);

	push	edi
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR [esi+180], eax
$LN6@xmlXInclud:

; 462  : 
; 463  :     pctxt->loadsubset |= XML_DETECT_IDS;

	or	DWORD PTR [esi+276], 2

; 464  : 
; 465  :     xmlParseDocument(pctxt);

	push	esi
	call	_xmlParseDocument
	add	esp, 4

; 466  : 
; 467  :     if (pctxt->wellFormed) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN7@xmlXInclud

; 468  :         ret = pctxt->myDoc;

	mov	edi, DWORD PTR [esi+8]

; 474  :         pctxt->myDoc = NULL;
; 475  :     }
; 476  :     xmlFreeParserCtxt(pctxt);

	push	esi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 477  : 
; 478  :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 479  : }

	pop	ebp
	ret	0
$LN7@xmlXInclud:

; 469  :     }
; 470  :     else {
; 471  :         ret = NULL;
; 472  : 	if (pctxt->myDoc != NULL)

	mov	eax, DWORD PTR [esi+8]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN9@xmlXInclud

; 473  : 	    xmlFreeDoc(pctxt->myDoc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN9@xmlXInclud:

; 474  :         pctxt->myDoc = NULL;
; 475  :     }
; 476  :     xmlFreeParserCtxt(pctxt);

	push	esi
	mov	DWORD PTR [esi+8], edi
	call	_xmlFreeParserCtxt
	add	esp, 4

; 477  : 
; 478  :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 479  : }

	pop	ebp
	ret	0
_xmlXIncludeParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeURLPop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXIncludeURLPop PROC					; COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	test	ecx, ecx
	jle	SHORT $LN5@xmlXInclud

; 357  :     xmlChar * ret;
; 358  : 
; 359  :     if (ctxt->urlNr <= 0)
; 360  :         return;
; 361  :     ctxt->urlNr--;

	dec	ecx
	mov	DWORD PTR [edx+40], ecx

; 362  :     if (ctxt->urlNr > 0)

	test	ecx, ecx
	jle	SHORT $LN3@xmlXInclud

; 363  :         ctxt->url = ctxt->urlTab[ctxt->urlNr - 1];

	mov	eax, DWORD PTR [edx+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN4@xmlXInclud
$LN3@xmlXInclud:

; 364  :     else
; 365  :         ctxt->url = NULL;

	xor	eax, eax
$LN4@xmlXInclud:

; 366  :     ret = ctxt->urlTab[ctxt->urlNr];

	mov	DWORD PTR [edx+36], eax
	mov	eax, DWORD PTR [edx+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 367  :     ctxt->urlTab[ctxt->urlNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 368  :     if (ret != NULL)

	test	edx, edx
	je	SHORT $LN5@xmlXInclud

; 369  : 	xmlFree(ret);

	mov	DWORD PTR _ctxt$[ebp], edx

; 370  : }

	pop	ebp

; 369  : 	xmlFree(ret);

	jmp	DWORD PTR _xmlFree
$LN5@xmlXInclud:

; 370  : }

	pop	ebp
	ret	0
_xmlXIncludeURLPop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeURLPush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlXIncludeURLPush PROC				; COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@xmlXInclud

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+52]
	push	eax
	push	0
	push	0
	push	2
	push	1600					; 00000640H
	push	11					; 0000000bH
	push	0
	push	esi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 318  :     if (ctxt->urlNr > XINCLUDE_MAX_DEPTH) {
; 319  : 	xmlXIncludeErr(ctxt, NULL, XML_XINCLUDE_RECURSION,
; 320  : 	               "detected a recursion in %s\n", value);
; 321  : 	return(-1);

	or	eax, -1
	pop	esi

; 346  : }

	pop	ebp
	ret	0
$LN2@xmlXInclud:

; 322  :     }
; 323  :     if (ctxt->urlTab == NULL) {

	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	jne	SHORT $LN4@xmlXInclud

; 324  : 	ctxt->urlMax = 4;
; 325  : 	ctxt->urlNr = 0;
; 326  : 	ctxt->urlTab = (xmlChar * *) xmlMalloc(

	push	16					; 00000010H
	mov	DWORD PTR [esi+44], 4
	mov	DWORD PTR [esi+40], ecx
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [esi+48], ecx

; 327  : 		        ctxt->urlMax * sizeof(ctxt->urlTab[0]));
; 328  :         if (ctxt->urlTab == NULL) {

	test	ecx, ecx
	je	SHORT $LN14@xmlXInclud
	mov	eax, DWORD PTR [esi+40]
$LN4@xmlXInclud:

; 329  : 	    xmlXIncludeErrMemory(ctxt, NULL, "adding URL");
; 330  :             return (-1);
; 331  :         }
; 332  :     }
; 333  :     if (ctxt->urlNr >= ctxt->urlMax) {

	mov	edx, DWORD PTR [esi+44]
	cmp	eax, edx
	jl	SHORT $LN13@xmlXInclud

; 334  :         ctxt->urlMax *= 2;

	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [esi+44], eax

; 335  :         ctxt->urlTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [esi+48], eax

; 336  :             (xmlChar * *) xmlRealloc(ctxt->urlTab,
; 337  :                                       ctxt->urlMax *
; 338  :                                       sizeof(ctxt->urlTab[0]));
; 339  :         if (ctxt->urlTab == NULL) {

	test	eax, eax
	jne	SHORT $LN13@xmlXInclud
$LN14@xmlXInclud:

; 340  : 	    xmlXIncludeErrMemory(ctxt, NULL, "adding URL");

	push	OFFSET ??_C@_0L@NDJLOKMA@adding?5URL@
	push	0
	push	esi
	call	_xmlXIncludeErrMemory
	add	esp, 12					; 0000000cH

; 341  :             return (-1);

	or	eax, -1
	pop	esi

; 346  : }

	pop	ebp
	ret	0
$LN13@xmlXInclud:

; 342  :         }
; 343  :     }
; 344  :     ctxt->url = ctxt->urlTab[ctxt->urlNr] = xmlStrdup(value);

	push	DWORD PTR _value$[ebp]
	call	_xmlStrdup
	mov	edx, DWORD PTR [esi+40]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	DWORD PTR [esi+36], eax

; 345  :     return (ctxt->urlNr++);

	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+40], ecx
	pop	esi

; 346  : }

	pop	ebp
	ret	0
_xmlXIncludeURLPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeNewRef
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_URI$ = 12						; size = 4
_ref$ = 16						; size = 4
_xmlXIncludeNewRef PROC					; COMDAT

; 226  : 	          xmlNodePtr ref) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXInclud

; 111  :     if (ctxt != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN11@xmlXInclud

; 112  : 	ctxt->nbErrors++;

	inc	DWORD PTR [eax+52]
$LN11@xmlXInclud:

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	0
	push	0
	push	2
	push	2
	push	11					; 0000000bH
	push	DWORD PTR _ref$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 227  :     xmlXIncludeRefPtr ret;
; 228  : 
; 229  : #ifdef DEBUG_XINCLUDE
; 230  :     xmlGenericError(xmlGenericErrorContext, "New ref %s\n", URI);
; 231  : #endif
; 232  :     ret = (xmlXIncludeRefPtr) xmlMalloc(sizeof(xmlXIncludeRef));
; 233  :     if (ret == NULL) {
; 234  :         xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");
; 235  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 270  : }

	pop	ebp
	ret	0
$LN2@xmlXInclud:

; 236  :     }
; 237  :     memset(ret, 0, sizeof(xmlXIncludeRef));
; 238  :     if (URI == NULL)

	mov	eax, DWORD PTR _URI$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], 0
	test	eax, eax
	je	SHORT $LN4@xmlXInclud
$LN3@xmlXInclud:

; 239  : 	ret->URI = NULL;
; 240  :     else
; 241  : 	ret->URI = xmlStrdup(URI);

	push	eax
	call	_xmlStrdup
	add	esp, 4
$LN4@xmlXInclud:

; 242  :     ret->fragment = NULL;
; 243  :     ret->ref = ref;

	push	ebx
	mov	ebx, DWORD PTR _ref$[ebp]
	mov	DWORD PTR [esi], eax
	push	edi

; 244  :     ret->doc = NULL;
; 245  :     ret->count = 0;
; 246  :     ret->xml = 0;
; 247  :     ret->inc = NULL;
; 248  :     if (ctxt->incMax == 0) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN17@xmlXInclud

; 249  : 	ctxt->incMax = 4;
; 250  :         ctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(ctxt->incMax *

	push	16					; 00000010H
	mov	DWORD PTR [edi+12], 4
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+16], eax

; 251  : 					      sizeof(ctxt->incTab[0]));
; 252  :         if (ctxt->incTab == NULL) {

	test	eax, eax
	je	SHORT $LN19@xmlXInclud
$LN17@xmlXInclud:

; 253  : 	    xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");
; 254  : 	    xmlXIncludeFreeRef(ret);
; 255  : 	    return(NULL);
; 256  : 	}
; 257  :     }
; 258  :     if (ctxt->incNr >= ctxt->incMax) {

	mov	eax, DWORD PTR [edi+12]
	cmp	DWORD PTR [edi+8], eax
	jl	SHORT $LN18@xmlXInclud

; 259  : 	ctxt->incMax *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+12], eax

; 260  :         ctxt->incTab = (xmlXIncludeRefPtr *) xmlRealloc(ctxt->incTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+16]
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [edi+16], eax

; 261  : 	             ctxt->incMax * sizeof(ctxt->incTab[0]));
; 262  :         if (ctxt->incTab == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlXInclud
$LN19@xmlXInclud:

; 263  : 	    xmlXIncludeErrMemory(ctxt, ref, "growing XInclude context");

	push	OFFSET ??_C@_0BJ@LMPOCELI@growing?5XInclude?5context@
	push	ebx
	push	edi
	call	_xmlXIncludeErrMemory

; 264  : 	    xmlXIncludeFreeRef(ret);

	push	esi
	call	_xmlXIncludeFreeRef
	add	esp, 16					; 00000010H

; 265  : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 270  : }

	pop	ebp
	ret	0
$LN18@xmlXInclud:

; 266  : 	}
; 267  :     }
; 268  :     ctxt->incTab[ctxt->incNr++] = ret;

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [eax+ecx*4], esi

; 269  :     return(ret);

	mov	eax, esi
	inc	DWORD PTR [edi+8]
	pop	edi
	pop	ebx
	pop	esi

; 270  : }

	pop	ebp
	ret	0
_xmlXIncludeNewRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeFreeRef
_TEXT	SEGMENT
_ref$ = 8						; size = 4
_xmlXIncludeFreeRef PROC				; COMDAT

; 194  : xmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ref$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXInclud

; 195  :     if (ref == NULL)
; 196  : 	return;
; 197  : #ifdef DEBUG_XINCLUDE
; 198  :     xmlGenericError(xmlGenericErrorContext, "Freeing ref\n");
; 199  : #endif
; 200  :     if (ref->doc != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud

; 201  : #ifdef DEBUG_XINCLUDE
; 202  : 	xmlGenericError(xmlGenericErrorContext, "Freeing doc %s\n", ref->URI);
; 203  : #endif
; 204  : 	xmlFreeDoc(ref->doc);

	push	eax
	call	_xmlFreeDoc
	add	esp, 4
$LN3@xmlXInclud:

; 205  :     }
; 206  :     if (ref->URI != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlXInclud

; 207  : 	xmlFree(ref->URI);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlXInclud:

; 208  :     if (ref->fragment != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@xmlXInclud

; 209  : 	xmlFree(ref->fragment);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlXInclud:

; 210  :     if (ref->xptr != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN6@xmlXInclud

; 211  : 	xmlXPathFreeObject(ref->xptr);

	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN6@xmlXInclud:

; 212  :     xmlFree(ref);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXInclud:
	pop	esi

; 213  : }

	pop	ebp
	ret	0
_xmlXIncludeFreeRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeGetProp
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlXIncludeGetProp PROC				; COMDAT

; 173  :                    const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	mov	edi, DWORD PTR _cur$[ebp]
	push	esi
	push	OFFSET ??_C@_0CA@MIIEHMNN@http?3?1?1www?4w3?4org?12003?1XInclude@
	push	edi
	call	_xmlGetNsProp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@xmlXInclud

; 174  :     xmlChar *ret;
; 175  : 
; 176  :     ret = xmlGetNsProp(cur, XINCLUDE_NS, name);
; 177  :     if (ret != NULL)
; 178  :         return(ret);
; 179  :     if (ctxt->legacy != 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN4@xmlXInclud

; 180  : 	ret = xmlGetNsProp(cur, XINCLUDE_OLD_NS, name);

	push	esi
	push	OFFSET ??_C@_0CA@JAOIMFBM@http?3?1?1www?4w3?4org?12001?1XInclude@
	push	edi
	call	_xmlGetNsProp
	add	esp, 12					; 0000000cH

; 181  : 	if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlXInclud
$LN4@xmlXInclud:

; 182  : 	    return(ret);
; 183  :     }
; 184  :     ret = xmlGetProp(cur, name);

	push	esi
	push	edi
	call	_xmlGetProp
	add	esp, 8
$LN1@xmlXInclud:

; 185  :     return(ret);
; 186  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXIncludeGetProp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_error$ = 16						; size = 4
_msg$ = 20						; size = 4
_extra$ = 24						; size = 4
_xmlXIncludeErr PROC					; COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlXInclud

; 132  :     if (ctxt != NULL)
; 133  : 	ctxt->nbErrors++;

	inc	DWORD PTR [ecx+52]
$LN2@xmlXInclud:

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	11					; 0000000bH
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 135  :                     error, XML_ERR_ERROR, NULL, 0,
; 136  : 		    (const char *) extra, NULL, NULL, 0, 0,
; 137  : 		    msg, (const char *) extra);
; 138  : }

	pop	ebp
	ret	0
_xmlXIncludeErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_xmlXIncludeErrMemory PROC				; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlXInclud

; 111  :     if (ctxt != NULL)
; 112  : 	ctxt->nbErrors++;

	inc	DWORD PTR [ecx+52]
$LN2@xmlXInclud:

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	2
	push	11					; 0000000bH
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 114  :                     XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0,
; 115  : 		    extra, NULL, NULL, 0, 0,
; 116  : 		    "Memory allocation failed : %s\n", extra);
; 117  : }

	pop	ebp
	ret	0
_xmlXIncludeErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeDoProcess
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_tree$ = 16						; size = 4
_xmlXIncludeDoProcess PROC				; COMDAT

; 2364 : xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	ecx, ecx
	je	SHORT $LN14@xmlXInclud

; 2365 :     xmlNodePtr cur;
; 2366 :     int ret = 0;
; 2367 :     int i, start;
; 2368 : 
; 2369 :     if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))

	mov	eax, DWORD PTR _tree$[ebp]
	test	eax, eax
	je	SHORT $LN14@xmlXInclud
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN14@xmlXInclud

; 2371 :     if (ctxt == NULL)

	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN14@xmlXInclud

; 2372 : 	return(-1);
; 2373 : 
; 2374 :     if (doc->URL != NULL) {

	mov	esi, DWORD PTR [ecx+72]
	test	esi, esi
	je	$LN68@xmlXInclud

; 318  :     if (ctxt->urlNr > XINCLUDE_MAX_DEPTH) {

	mov	eax, DWORD PTR [edi+40]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@xmlXInclud

; 134  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	esi
	push	OFFSET ??_C@_0BM@FPMOMHKP@detected?5a?5recursion?5in?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+52]
	push	esi
	push	0
	push	0
	push	2
	push	1600					; 00000640H
	push	11					; 0000000bH
	push	0
	push	edi
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN14@xmlXInclud:
	pop	edi

; 2370 : 	return(-1);

	or	eax, -1

; 2446 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlXInclud:

; 323  :     if (ctxt->urlTab == NULL) {

	mov	ecx, DWORD PTR [edi+48]
	test	ecx, ecx
	jne	SHORT $LN37@xmlXInclud

; 324  : 	ctxt->urlMax = 4;
; 325  : 	ctxt->urlNr = 0;
; 326  : 	ctxt->urlTab = (xmlChar * *) xmlMalloc(

	push	16					; 00000010H
	mov	DWORD PTR [edi+44], 4
	mov	DWORD PTR [edi+40], ecx
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [edi+48], ecx

; 327  : 		        ctxt->urlMax * sizeof(ctxt->urlTab[0]));
; 328  :         if (ctxt->urlTab == NULL) {

	test	ecx, ecx
	je	SHORT $LN79@xmlXInclud
	mov	eax, DWORD PTR [edi+40]
$LN37@xmlXInclud:

; 329  : 	    xmlXIncludeErrMemory(ctxt, NULL, "adding URL");
; 330  :             return (-1);
; 331  :         }
; 332  :     }
; 333  :     if (ctxt->urlNr >= ctxt->urlMax) {

	mov	edx, DWORD PTR [edi+44]
	cmp	eax, edx
	jl	SHORT $LN78@xmlXInclud

; 334  :         ctxt->urlMax *= 2;

	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [edi+44], eax

; 335  :         ctxt->urlTab =

	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR [edi+48], eax

; 336  :             (xmlChar * *) xmlRealloc(ctxt->urlTab,
; 337  :                                       ctxt->urlMax *
; 338  :                                       sizeof(ctxt->urlTab[0]));
; 339  :         if (ctxt->urlTab == NULL) {

	test	eax, eax
	jne	SHORT $LN78@xmlXInclud
$LN79@xmlXInclud:

; 340  : 	    xmlXIncludeErrMemory(ctxt, NULL, "adding URL");

	push	OFFSET ??_C@_0L@NDJLOKMA@adding?5URL@
	push	0
	push	edi
	call	_xmlXIncludeErrMemory
	add	esp, 12					; 0000000cH

; 2370 : 	return(-1);

	or	eax, -1
	pop	edi

; 2446 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@xmlXInclud:

; 344  :     ctxt->url = ctxt->urlTab[ctxt->urlNr] = xmlStrdup(value);

	push	esi
	call	_xmlStrdup
	mov	ecx, DWORD PTR [edi+40]
	mov	edx, eax
	mov	eax, DWORD PTR [edi+48]
	add	esp, 4
	mov	DWORD PTR [eax+ecx*4], edx

; 345  :     return (ctxt->urlNr++);

	mov	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR [edi+36], edx
	mov	DWORD PTR _ret$1$[ebp], ecx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi+40], eax

; 2375 : 	ret = xmlXIncludeURLPush(ctxt, doc->URL);
; 2376 : 	if (ret < 0)

	test	ecx, ecx
	js	$LN14@xmlXInclud
	mov	eax, DWORD PTR _tree$[ebp]
$LN68@xmlXInclud:
	push	ebx

; 2377 : 	    return(-1);
; 2378 :     }
; 2379 :     start = ctxt->incNr;

	mov	ebx, DWORD PTR [edi+8]

; 2380 : 
; 2381 :     /*
; 2382 :      * First phase: lookup the elements in the document
; 2383 :      */
; 2384 :     cur = tree;

	mov	esi, eax

; 2385 :     if (xmlXIncludeTestNode(ctxt, cur) == 1)

	push	eax
	push	edi
	call	_xmlXIncludeTestNode
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN74@xmlXInclud

; 2386 : 	xmlXIncludePreProcessNode(ctxt, cur);

	push	DWORD PTR _tree$[ebp]
	push	edi
	call	_xmlXIncludePreProcessNode
	add	esp, 8
$LN74@xmlXInclud:
	mov	edx, DWORD PTR _tree$[ebp]
$LL2@xmlXInclud:

; 2387 :     while ((cur != NULL) && (cur != tree->parent)) {

	mov	ecx, DWORD PTR [edx+20]
	cmp	esi, ecx
	je	SHORT $LN59@xmlXInclud

; 2388 : 	/* TODO: need to work on entities -> stack */
; 2389 : 	if ((cur->children != NULL) &&
; 2390 : 	    (cur->children->type != XML_ENTITY_DECL) &&
; 2391 : 	    (cur->children->type != XML_XINCLUDE_START) &&

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN19@xmlXInclud
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 17					; 00000011H
	je	SHORT $LN85@xmlXInclud
	cmp	edx, 19					; 00000013H
	je	SHORT $LN85@xmlXInclud
	cmp	edx, 20					; 00000014H
	jne	SHORT $LN87@xmlXInclud
$LN85@xmlXInclud:

; 2392 : 	    (cur->children->type != XML_XINCLUDE_END)) {
; 2393 : 	    cur = cur->children;
; 2394 : 	    if (xmlXIncludeTestNode(ctxt, cur))
; 2395 : 		xmlXIncludePreProcessNode(ctxt, cur);
; 2396 : 	} else if (cur->next != NULL) {

	mov	edx, DWORD PTR _tree$[ebp]
$LN19@xmlXInclud:
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN22@xmlXInclud

; 2397 : 	    cur = cur->next;

	mov	esi, eax

; 2398 : 	    if (xmlXIncludeTestNode(ctxt, cur))

	push	esi
	push	edi
	call	_xmlXIncludeTestNode
	add	esp, 8
	test	eax, eax
	je	SHORT $LN82@xmlXInclud

; 2015 :     xmlXIncludeAddNode(ctxt, node);

	push	esi
	push	edi
	call	_xmlXIncludeAddNode

; 2399 : 		xmlXIncludePreProcessNode(ctxt, cur);
; 2400 : 	} else {

	jmp	SHORT $LN88@xmlXInclud
$LN22@xmlXInclud:

; 2401 : 	    if (cur == tree)

	cmp	esi, edx
	je	SHORT $LN59@xmlXInclud
	npad	6
$LL6@xmlXInclud:

; 2402 : 	        break;
; 2403 : 	    do {
; 2404 : 		cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 2405 : 		if ((cur == NULL) || (cur == tree->parent))

	test	esi, esi
	je	SHORT $LN59@xmlXInclud
	cmp	esi, ecx
	je	SHORT $LN5@xmlXInclud

; 2406 : 		    break; /* do */
; 2407 : 		if (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL6@xmlXInclud
$LN87@xmlXInclud:

; 2387 :     while ((cur != NULL) && (cur != tree->parent)) {

	mov	esi, eax
	push	esi
	push	edi
	call	_xmlXIncludeTestNode
	add	esp, 8
	test	eax, eax
	je	SHORT $LN82@xmlXInclud
	push	esi
	push	edi
	call	_xmlXIncludePreProcessNode
$LN88@xmlXInclud:
	add	esp, 8
$LN82@xmlXInclud:
	mov	edx, DWORD PTR _tree$[ebp]
$LN5@xmlXInclud:
	test	esi, esi
	jne	SHORT $LL2@xmlXInclud
$LN59@xmlXInclud:

; 2408 : 		    cur = cur->next;
; 2409 : 		    if (xmlXIncludeTestNode(ctxt, cur))
; 2410 : 			xmlXIncludePreProcessNode(ctxt, cur);
; 2411 : 		    break; /* do */
; 2412 : 		}
; 2413 : 	    } while (cur != NULL);
; 2414 : 	}
; 2415 :     }
; 2416 : 
; 2417 :     /*
; 2418 :      * Second Phase : collect the infosets fragments
; 2419 :      */
; 2420 :     for (i = start;i < ctxt->incNr; i++) {

	mov	eax, DWORD PTR [edi+8]
	cmp	ebx, eax
	jge	SHORT $LN8@xmlXInclud
	npad	6
$LL9@xmlXInclud:

; 2421 :         xmlXIncludeLoadNode(ctxt, i);

	push	ebx
	push	edi
	call	_xmlXIncludeLoadNode

; 2422 : 	ret++;

	inc	DWORD PTR _ret$1$[ebp]
	inc	ebx
	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	cmp	ebx, eax
	jl	SHORT $LL9@xmlXInclud
$LN8@xmlXInclud:

; 2423 :     }
; 2424 : 
; 2425 :     /*
; 2426 :      * Third phase: extend the original document infoset.
; 2427 :      *
; 2428 :      * Originally we bypassed the inclusion if there were any errors
; 2429 :      * encountered on any of the XIncludes.  A bug was raised (bug
; 2430 :      * 132588) requesting that we output the XIncludes without error,
; 2431 :      * so the check for inc!=NULL || xptr!=NULL was put in.  This may
; 2432 :      * give some other problems in the future, but for now it seems to
; 2433 :      * work ok.
; 2434 :      *
; 2435 :      */
; 2436 :     for (i = ctxt->incBase;i < ctxt->incNr; i++) {

	mov	esi, DWORD PTR [edi+4]
	pop	ebx
	cmp	esi, eax
	jge	SHORT $LN11@xmlXInclud
	npad	3
$LL12@xmlXInclud:

; 2437 : 	if ((ctxt->incTab[i]->inc != NULL) ||
; 2438 : 		(ctxt->incTab[i]->xptr != NULL) ||

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+esi*4]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN31@xmlXInclud
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN31@xmlXInclud
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN10@xmlXInclud
$LN31@xmlXInclud:

; 2439 : 		(ctxt->incTab[i]->emptyFb != 0))	/* (empty fallback) */
; 2440 : 	    xmlXIncludeIncludeNode(ctxt, i);

	push	esi
	push	edi
	call	_xmlXIncludeIncludeNode
	add	esp, 8
$LN10@xmlXInclud:

; 2423 :     }
; 2424 : 
; 2425 :     /*
; 2426 :      * Third phase: extend the original document infoset.
; 2427 :      *
; 2428 :      * Originally we bypassed the inclusion if there were any errors
; 2429 :      * encountered on any of the XIncludes.  A bug was raised (bug
; 2430 :      * 132588) requesting that we output the XIncludes without error,
; 2431 :      * so the check for inc!=NULL || xptr!=NULL was put in.  This may
; 2432 :      * give some other problems in the future, but for now it seems to
; 2433 :      * work ok.
; 2434 :      *
; 2435 :      */
; 2436 :     for (i = ctxt->incBase;i < ctxt->incNr; i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jl	SHORT $LL12@xmlXInclud
$LN11@xmlXInclud:

; 2441 :     }
; 2442 : 
; 2443 :     if (doc->URL != NULL)

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN50@xmlXInclud

; 359  :     if (ctxt->urlNr <= 0)

	mov	ecx, DWORD PTR [edi+40]
	test	ecx, ecx
	jle	SHORT $LN50@xmlXInclud

; 360  :         return;
; 361  :     ctxt->urlNr--;

	dec	ecx
	mov	DWORD PTR [edi+40], ecx

; 362  :     if (ctxt->urlNr > 0)

	test	ecx, ecx
	jle	SHORT $LN48@xmlXInclud

; 363  :         ctxt->url = ctxt->urlTab[ctxt->urlNr - 1];

	mov	eax, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN49@xmlXInclud
$LN48@xmlXInclud:

; 364  :     else
; 365  :         ctxt->url = NULL;

	xor	eax, eax
$LN49@xmlXInclud:

; 366  :     ret = ctxt->urlTab[ctxt->urlNr];

	mov	DWORD PTR [edi+36], eax
	mov	eax, DWORD PTR [edi+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 367  :     ctxt->urlTab[ctxt->urlNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 368  :     if (ret != NULL)

	test	edx, edx
	je	SHORT $LN50@xmlXInclud

; 369  : 	xmlFree(ret);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN50@xmlXInclud:

; 2444 : 	xmlXIncludeURLPop(ctxt);
; 2445 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 2446 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXIncludeDoProcess ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXIncludeProcessNode PROC				; COMDAT

; 2611 : xmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud

; 2612 :     int ret = 0;
; 2613 : 
; 2614 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||
; 2615 :         (node->doc == NULL) || (ctxt == NULL))

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN3@xmlXInclud
	mov	ecx, DWORD PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN3@xmlXInclud
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXInclud

; 2617 :     ret = xmlXIncludeDoProcess(ctxt, node->doc, node);

	push	eax
	push	ecx
	push	esi
	call	_xmlXIncludeDoProcess
	add	esp, 12					; 0000000cH

; 2618 :     if ((ret >= 0) && (ctxt->nbErrors > 0))

	test	eax, eax
	js	SHORT $LN1@xmlXInclud
	or	ecx, -1
	cmp	DWORD PTR [esi+52], 0
	pop	esi
	cmovg	eax, ecx

; 2619 : 	ret = -1;
; 2620 :     return(ret);
; 2621 : }

	pop	ebp
	ret	0
$LN3@xmlXInclud:

; 2616 : 	return(-1);

	or	eax, -1
$LN1@xmlXInclud:
	pop	esi

; 2619 : 	ret = -1;
; 2620 :     return(ret);
; 2621 : }

	pop	ebp
	ret	0
_xmlXIncludeProcessNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeFreeContext
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXIncludeFreeContext PROC				; COMDAT

; 379  : xmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXInclud

; 380  :     int i;
; 381  : 
; 382  : #ifdef DEBUG_XINCLUDE
; 383  :     xmlGenericError(xmlGenericErrorContext, "Freeing context\n");
; 384  : #endif
; 385  :     if (ctxt == NULL)
; 386  : 	return;
; 387  :     while (ctxt->urlNr > 0)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jle	SHORT $LN3@xmlXInclud
$LN38@xmlXInclud:

; 361  :     ctxt->urlNr--;

	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+40], ecx

; 362  :     if (ctxt->urlNr > 0)

	test	ecx, ecx
	jle	SHORT $LN22@xmlXInclud

; 363  :         ctxt->url = ctxt->urlTab[ctxt->urlNr - 1];

	mov	eax, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN23@xmlXInclud
$LN22@xmlXInclud:

; 364  :     else
; 365  :         ctxt->url = NULL;

	xor	eax, eax
$LN23@xmlXInclud:

; 366  :     ret = ctxt->urlTab[ctxt->urlNr];

	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax+ecx*4]

; 367  :     ctxt->urlTab[ctxt->urlNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 368  :     if (ret != NULL)

	test	edx, edx
	je	SHORT $LN24@xmlXInclud

; 369  : 	xmlFree(ret);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN24@xmlXInclud:

; 380  :     int i;
; 381  : 
; 382  : #ifdef DEBUG_XINCLUDE
; 383  :     xmlGenericError(xmlGenericErrorContext, "Freeing context\n");
; 384  : #endif
; 385  :     if (ctxt == NULL)
; 386  : 	return;
; 387  :     while (ctxt->urlNr > 0)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jg	SHORT $LN38@xmlXInclud
$LN3@xmlXInclud:

; 388  : 	xmlXIncludeURLPop(ctxt);
; 389  :     if (ctxt->urlTab != NULL)

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN11@xmlXInclud

; 390  : 	xmlFree(ctxt->urlTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlXInclud:

; 391  :     for (i = 0;i < ctxt->incNr;i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN5@xmlXInclud
$LL6@xmlXInclud:

; 392  : 	if (ctxt->incTab[i] != NULL)

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN4@xmlXInclud

; 393  : 	    xmlXIncludeFreeRef(ctxt->incTab[i]);

	push	eax
	call	_xmlXIncludeFreeRef
	add	esp, 4
$LN4@xmlXInclud:

; 391  :     for (i = 0;i < ctxt->incNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL6@xmlXInclud
$LN5@xmlXInclud:

; 394  :     }
; 395  :     if (ctxt->txturlTab != NULL) {

	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN8@xmlXInclud

; 396  : 	for (i = 0;i < ctxt->txtNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN8@xmlXInclud
	npad	7
$LL9@xmlXInclud:

; 397  : 	    if (ctxt->txturlTab[i] != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@xmlXInclud

; 398  : 		xmlFree(ctxt->txturlTab[i]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlXInclud:

; 396  : 	for (i = 0;i < ctxt->txtNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL9@xmlXInclud
$LN8@xmlXInclud:

; 399  : 	}
; 400  :     }
; 401  :     if (ctxt->incTab != NULL)

	mov	eax, DWORD PTR [esi+16]
	pop	edi
	test	eax, eax
	je	SHORT $LN15@xmlXInclud

; 402  : 	xmlFree(ctxt->incTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlXInclud:

; 403  :     if (ctxt->txtTab != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN16@xmlXInclud

; 404  : 	xmlFree(ctxt->txtTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlXInclud:

; 405  :     if (ctxt->txturlTab != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN17@xmlXInclud

; 406  : 	xmlFree(ctxt->txturlTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlXInclud:

; 407  :     if (ctxt->base != NULL) {

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN18@xmlXInclud

; 408  :         xmlFree(ctxt->base);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN18@xmlXInclud:

; 409  :     }
; 410  :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXInclud:
	pop	esi

; 411  : }

	pop	ebp
	ret	0
_xmlXIncludeFreeContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeSetFlags
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlXIncludeSetFlags PROC				; COMDAT

; 2458 : xmlXIncludeSetFlags(xmlXIncludeCtxtPtr ctxt, int flags) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlXInclud

; 2459 :     if (ctxt == NULL)
; 2460 :         return(-1);

	or	eax, -1

; 2463 : }

	pop	ebp
	ret	0
$LN2@xmlXInclud:

; 2461 :     ctxt->parseFlags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 2462 :     return(0);

	xor	eax, eax

; 2463 : }

	pop	ebp
	ret	0
_xmlXIncludeSetFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeNewContext
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlXIncludeNewContext PROC				; COMDAT

; 281  : xmlXIncludeNewContext(xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlXInclud

; 282  :     xmlXIncludeCtxtPtr ret;
; 283  : 
; 284  : #ifdef DEBUG_XINCLUDE
; 285  :     xmlGenericError(xmlGenericErrorContext, "New context\n");
; 286  : #endif
; 287  :     if (doc == NULL)
; 288  : 	return(NULL);
; 289  :     ret = (xmlXIncludeCtxtPtr) xmlMalloc(sizeof(xmlXIncludeCtxt));

	push	72					; 00000048H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 290  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlXInclud

; 113  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, node, XML_FROM_XINCLUDE,

	push	OFFSET ??_C@_0BK@NPNMIHKC@creating?5XInclude?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BK@NPNMIHKC@creating?5XInclude?5context@
	push	eax
	push	eax
	push	2
	push	2
	push	11					; 0000000bH
	push	esi
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN8@xmlXInclud:

; 302  :     return(ret);
; 303  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXInclud:

; 291  : 	xmlXIncludeErrMemory(NULL, (xmlNodePtr) doc,
; 292  : 	                     "creating XInclude context");
; 293  : 	return(NULL);
; 294  :     }
; 295  :     memset(ret, 0, sizeof(xmlXIncludeCtxt));

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+56], 0
	mov	DWORD PTR [eax+60], 0
	mov	DWORD PTR [eax+64], 0
	mov	DWORD PTR [eax+68], 0

; 296  :     ret->doc = doc;

	mov	DWORD PTR [eax], esi

; 297  :     ret->incNr = 0;

	mov	DWORD PTR [eax+8], 0

; 298  :     ret->incBase = 0;

	mov	DWORD PTR [eax+4], 0

; 299  :     ret->incMax = 0;

	mov	DWORD PTR [eax+12], 0

; 300  :     ret->incTab = NULL;

	mov	DWORD PTR [eax+16], 0

; 301  :     ret->nbErrors = 0;

	mov	DWORD PTR [eax+52], 0
	pop	esi

; 302  :     return(ret);
; 303  : }

	pop	ebp
	ret	0
_xmlXIncludeNewContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessTreeFlags
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlXIncludeProcessTreeFlags PROC			; COMDAT

; 2565 : xmlXIncludeProcessTreeFlags(xmlNodePtr tree, int flags) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _tree$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXInclud

; 2566 :     xmlXIncludeCtxtPtr ctxt;
; 2567 :     int ret = 0;
; 2568 : 
; 2569 :     if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN3@xmlXInclud
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud

; 2572 :     ctxt = xmlXIncludeNewContext(tree->doc);

	push	eax
	call	_xmlXIncludeNewContext
	mov	edi, eax
	add	esp, 4

; 2573 :     if (ctxt == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlXInclud

; 2574 : 	return(-1);
; 2575 :     ctxt->base = xmlNodeGetBase(tree->doc, tree);

	push	esi
	push	DWORD PTR [esi+32]
	call	_xmlNodeGetBase

; 2576 :     xmlXIncludeSetFlags(ctxt, flags);

	push	DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edi+64], eax
	push	edi
	call	_xmlXIncludeSetFlags

; 2577 :     ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);

	push	esi
	push	DWORD PTR [esi+32]
	push	edi
	call	_xmlXIncludeDoProcess
	mov	esi, eax
	add	esp, 28					; 0000001cH

; 2578 :     if ((ret >= 0) && (ctxt->nbErrors > 0))

	test	esi, esi
	js	SHORT $LN5@xmlXInclud
	or	eax, -1
	cmp	DWORD PTR [edi+52], 0
	cmovg	esi, eax
$LN5@xmlXInclud:

; 2579 : 	ret = -1;
; 2580 : 
; 2581 :     xmlXIncludeFreeContext(ctxt);

	push	edi
	call	_xmlXIncludeFreeContext
	add	esp, 4

; 2582 :     return(ret);

	mov	eax, esi
	pop	edi

; 2583 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXInclud:
	pop	edi

; 2570 :         (tree->doc == NULL))
; 2571 : 	return(-1);

	or	eax, -1

; 2583 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXIncludeProcessTreeFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessTree
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_xmlXIncludeProcessTree PROC				; COMDAT

; 2595 : xmlXIncludeProcessTree(xmlNodePtr tree) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _tree$[ebp]
	call	_xmlXIncludeProcessTreeFlags
	add	esp, 8

; 2596 :     return(xmlXIncludeProcessTreeFlags(tree, 0));
; 2597 : }

	pop	ebp
	ret	0
_xmlXIncludeProcessTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessTreeFlagsData
_TEXT	SEGMENT
_tree$ = 8						; size = 4
_flags$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlXIncludeProcessTreeFlagsData PROC			; COMDAT

; 2479 : xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _tree$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXInclud

; 2480 :     xmlXIncludeCtxtPtr ctxt;
; 2481 :     int ret = 0;
; 2482 : 
; 2483 :     if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN3@xmlXInclud
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN3@xmlXInclud

; 2486 : 
; 2487 :     ctxt = xmlXIncludeNewContext(tree->doc);

	push	eax
	call	_xmlXIncludeNewContext
	mov	edi, eax
	add	esp, 4

; 2488 :     if (ctxt == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlXInclud

; 2489 :         return(-1);
; 2490 :     ctxt->_private = data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edi+68], ecx

; 2491 :     ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);

	mov	ecx, DWORD PTR [esi+32]
	push	DWORD PTR [ecx+72]
	call	_xmlStrdup

; 2492 :     xmlXIncludeSetFlags(ctxt, flags);

	push	DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edi+64], eax
	push	edi
	call	_xmlXIncludeSetFlags

; 2493 :     ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);

	push	esi
	push	DWORD PTR [esi+32]
	push	edi
	call	_xmlXIncludeDoProcess
	mov	esi, eax
	add	esp, 24					; 00000018H

; 2494 :     if ((ret >= 0) && (ctxt->nbErrors > 0))

	test	esi, esi
	js	SHORT $LN5@xmlXInclud
	or	eax, -1
	cmp	DWORD PTR [edi+52], 0
	cmovg	esi, eax
$LN5@xmlXInclud:

; 2495 :         ret = -1;
; 2496 : 
; 2497 :     xmlXIncludeFreeContext(ctxt);

	push	edi
	call	_xmlXIncludeFreeContext
	add	esp, 4

; 2498 :     return(ret);

	mov	eax, esi
	pop	edi

; 2499 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXInclud:
	pop	edi

; 2484 :         (tree->doc == NULL))
; 2485 :         return(-1);

	or	eax, -1

; 2499 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXIncludeProcessTreeFlagsData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessFlagsData
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_flags$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlXIncludeProcessFlagsData PROC			; COMDAT

; 2514 : xmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXInclud

; 2515 :     xmlNodePtr tree;
; 2516 : 
; 2517 :     if (doc == NULL)
; 2518 : 	return(-1);
; 2519 :     tree = xmlDocGetRootElement(doc);

	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4

; 2520 :     if (tree == NULL)

	test	eax, eax
	je	SHORT $LN5@xmlXInclud

; 2522 :     return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));

	mov	DWORD PTR _doc$[ebp], eax

; 2523 : }

	pop	ebp

; 2522 :     return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));

	jmp	_xmlXIncludeProcessTreeFlagsData
$LN5@xmlXInclud:

; 2521 : 	return(-1);

	or	eax, -1

; 2523 : }

	pop	ebp
	ret	0
_xmlXIncludeProcessFlagsData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcessFlags
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_flags$ = 12						; size = 4
_xmlXIncludeProcessFlags PROC				; COMDAT

; 2536 : xmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4

; 2517 :     if (doc == NULL)

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlXInclud
$LN7@xmlXInclud:

; 2537 :     return xmlXIncludeProcessFlagsData(doc, flags, NULL);
; 2538 : }

	or	eax, -1
	pop	ebp
	ret	0
$LN4@xmlXInclud:

; 2519 :     tree = xmlDocGetRootElement(doc);

	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4

; 2520 :     if (tree == NULL)

	test	eax, eax
	je	SHORT $LN7@xmlXInclud

; 2521 : 	return(-1);
; 2522 :     return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));

	push	0
	push	DWORD PTR _flags$[ebp]
	push	eax
	call	_xmlXIncludeProcessTreeFlagsData
	add	esp, 12					; 0000000cH

; 2537 :     return xmlXIncludeProcessFlagsData(doc, flags, NULL);
; 2538 : }

	pop	ebp
	ret	0
_xmlXIncludeProcessFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xinclude.c
;	COMDAT _xmlXIncludeProcess
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlXIncludeProcess PROC				; COMDAT

; 2550 : xmlXIncludeProcess(xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __07371726_xinclude@c
	call	@__CheckForDebuggerJustMyCode@4

; 2517 :     if (doc == NULL)

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	jne	SHORT $LN6@xmlXInclud
$LN9@xmlXInclud:

; 2551 :     return(xmlXIncludeProcessFlags(doc, 0));
; 2552 : }

	or	eax, -1
	pop	ebp
	ret	0
$LN6@xmlXInclud:

; 2519 :     tree = xmlDocGetRootElement(doc);

	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4

; 2520 :     if (tree == NULL)

	test	eax, eax
	je	SHORT $LN9@xmlXInclud

; 2521 : 	return(-1);
; 2522 :     return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));

	push	0
	push	0
	push	eax
	call	_xmlXIncludeProcessTreeFlagsData
	add	esp, 12					; 0000000cH

; 2551 :     return(xmlXIncludeProcessFlags(doc, 0));
; 2552 : }

	pop	ebp
	ret	0
_xmlXIncludeProcess ENDP
_TEXT	ENDS
END
