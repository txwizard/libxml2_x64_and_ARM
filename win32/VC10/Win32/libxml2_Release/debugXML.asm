; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\debugXML.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__6FBE7998_debugxml@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_sscanf
PUBLIC	_xmlDebugDumpString
PUBLIC	_xmlDebugDumpAttr
PUBLIC	_xmlDebugDumpAttrList
PUBLIC	_xmlDebugDumpOneNode
PUBLIC	_xmlDebugDumpNode
PUBLIC	_xmlDebugDumpNodeList
PUBLIC	_xmlDebugDumpDocumentHead
PUBLIC	_xmlDebugDumpDocument
PUBLIC	_xmlDebugDumpDTD
PUBLIC	_xmlDebugDumpEntities
PUBLIC	_xmlDebugCheckDocument
PUBLIC	_xmlLsOneNode
PUBLIC	_xmlLsCountNode
PUBLIC	_xmlBoolToText
PUBLIC	_xmlShellPrintXPathError
PUBLIC	_xmlShellPrintXPathResult
PUBLIC	_xmlShellList
PUBLIC	_xmlShellBase
PUBLIC	_xmlShellDir
PUBLIC	_xmlShellLoad
PUBLIC	_xmlShellPrintNode
PUBLIC	_xmlShellCat
PUBLIC	_xmlShellWrite
PUBLIC	_xmlShellSave
PUBLIC	_xmlShellValidate
PUBLIC	_xmlShellDu
PUBLIC	_xmlShellPwd
PUBLIC	_xmlShell
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@ ; `string'
PUBLIC	??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@ ; `string'
PUBLIC	??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@ ; `string'
PUBLIC	??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@ ; `string'
PUBLIC	??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@ ; `string'
PUBLIC	??_C@_0N@BLMILKM@Name?5is?5NULL@		; `string'
PUBLIC	??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@ ; `string'
PUBLIC	??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@	; `string'
PUBLIC	??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@	; `string'
PUBLIC	??_C@_0L@OLLEMIAI@pseudoroot@			; `string'
PUBLIC	??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@ ; `string'
PUBLIC	??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@ ; `string'
PUBLIC	??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@ ; `string'
PUBLIC	??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@ ; `string'
PUBLIC	??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@ ; `string'
PUBLIC	??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@ ; `string'
PUBLIC	??_C@_07DALNPEGO@nbktext@			; `string'
PUBLIC	??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@ ; `string'
PUBLIC	??_C@_06LHGEHABH@?$CINULL?$CJ@			; `string'
PUBLIC	??_C@_03CANIHDGE@?$CD?$CFX@			; `string'
PUBLIC	??_C@_03KHICJKCI@?4?4?4@			; `string'
PUBLIC	??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@	; `string'
PUBLIC	??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@	; `string'
PUBLIC	??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@		; `string'
PUBLIC	??_C@_03DFGNODOE@DTD@				; `string'
PUBLIC	??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@		; `string'
PUBLIC	??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@ ; `string'
PUBLIC	??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@	; `string'
PUBLIC	??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@ ; `string'
PUBLIC	??_C@_07GLNLDEDP@?5for?5?$CFs@			; `string'
PUBLIC	??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@ ; `string'
PUBLIC	??_C@_06CIOOFICG@?5CDATA@			; `string'
PUBLIC	??_C@_03JFNHLDJD@?5ID@				; `string'
PUBLIC	??_C@_06JJHMNMLB@?5IDREF@			; `string'
PUBLIC	??_C@_07CNGJPBFB@?5IDREFS@			; `string'
PUBLIC	??_C@_07GLIJGNMP@?5ENTITY@			; `string'
PUBLIC	??_C@_09MILPKLMO@?5ENTITIES@			; `string'
PUBLIC	??_C@_08JLMONKHB@?5NMTOKEN@			; `string'
PUBLIC	??_C@_09LGAPIBOH@?5NMTOKENS@			; `string'
PUBLIC	??_C@_0N@DAGLJCMJ@?5ENUMERATION@		; `string'
PUBLIC	??_C@_0L@EOKHAFCK@?5NOTATION?5@			; `string'
PUBLIC	??_C@_03MFMGJBPJ@?$HM?$CFs@			; `string'
PUBLIC	??_C@_04KHAOAOAJ@?5?$CI?$CFs@			; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_04HBFELFIL@?4?4?4?$CJ@			; `string'
PUBLIC	??_C@_09GBLDHCFM@?5REQUIRED@			; `string'
PUBLIC	??_C@_08BNNMMLKP@?5IMPLIED@			; `string'
PUBLIC	??_C@_06MNDBCIDD@?5FIXED@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@ ; `string'
PUBLIC	??_C@_09LBEHMBNA@ELEMDECL?$CI@			; `string'
PUBLIC	??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@ ; `string'
PUBLIC	??_C@_0M@PIGJBKAD@?0?5UNDEFINED@		; `string'
PUBLIC	??_C@_07MPIOAGOH@?0?5EMPTY@			; `string'
PUBLIC	??_C@_05MNEHMNJK@?0?5ANY@			; `string'
PUBLIC	??_C@_08MPHAJKBG@?0?5MIXED?5@			; `string'
PUBLIC	??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@ ; `string'
PUBLIC	??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@		; `string'
PUBLIC	??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@ ; `string'
PUBLIC	??_C@_0M@PBKIGNE@?0?5internal?6@		; `string'
PUBLIC	??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@	; `string'
PUBLIC	??_C@_0M@FLIMFIIH@?0?5unparsed?6@		; `string'
PUBLIC	??_C@_0N@NMAFEAAG@?0?5parameter?6@		; `string'
PUBLIC	??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@	; `string'
PUBLIC	??_C@_0O@OLDJNJL@?0?5predefined?6@		; `string'
PUBLIC	??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@	; `string'
PUBLIC	??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_09MHAMBDHP@?5content?$DN@			; `string'
PUBLIC	??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@	; `string'
PUBLIC	??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@ ; `string'
PUBLIC	??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@ ; `string'
PUBLIC	??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@ ; `string'
PUBLIC	??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@	; `string'
PUBLIC	??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@ ; `string'
PUBLIC	??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@		; `string'
PUBLIC	??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@	; `string'
PUBLIC	??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@ ; `string'
PUBLIC	??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@ ; `string'
PUBLIC	??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@	; `string'
PUBLIC	??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@	; `string'
PUBLIC	??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@	; `string'
PUBLIC	??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_07HJADGDLG@URI?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_08INNCGMHH@content?$DN@			; `string'
PUBLIC	??_C@_0N@KCLOKEKK@Attr?5is?5NULL@		; `string'
PUBLIC	??_C@_0L@MPLGGCMF@ATTRIBUTE?5@			; `string'
PUBLIC	??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@	; `string'
PUBLIC	??_C@_0O@IPKFPFDL@node?5is?5NULL?6@		; `string'
PUBLIC	??_C@_08EDNNGDCO@ELEMENT?5@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@ ; `string'
PUBLIC	??_C@_0M@IDMICFJC@TEXT?5no?5enc@		; `string'
PUBLIC	??_C@_04OEPMCOLO@TEXT@				; `string'
PUBLIC	??_C@_09PKJIJFNN@?5compact?6@			; `string'
PUBLIC	??_C@_0L@IDACKBMB@?5interned?6@			; `string'
PUBLIC	??_C@_0P@HFCBAJGN@CDATA_SECTION?6@		; `string'
PUBLIC	??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@	; `string'
PUBLIC	??_C@_07PAIFPHKC@ENTITY?6@			; `string'
PUBLIC	??_C@_06JDGENMBJ@PI?5?$CFs?6@			; `string'
PUBLIC	??_C@_08OCMMJPAI@COMMENT?6@			; `string'
PUBLIC	??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@ ; `string'
PUBLIC	??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@		; `string'
PUBLIC	??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@		; `string'
PUBLIC	??_C@_09CPFNJPEP@NOTATION?6@			; `string'
PUBLIC	??_C@_0P@MIINKGDA@INCLUDE?5START?6@		; `string'
PUBLIC	??_C@_0N@DKMEHMHH@INCLUDE?5END?6@		; `string'
PUBLIC	??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@ ; `string'
PUBLIC	??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@	; `string'
PUBLIC	??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@ ; `string'
PUBLIC	??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@	; `string'
PUBLIC	??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@	; `string'
PUBLIC	??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@ ; `string'
PUBLIC	??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@	; `string'
PUBLIC	??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@	; `string'
PUBLIC	??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@	; `string'
PUBLIC	??_C@_09JFLEHAPI@DOCUMENT?6@			; `string'
PUBLIC	??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@		; `string'
PUBLIC	??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@	; `string'
PUBLIC	??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@	; `string'
PUBLIC	??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@	; `string'
PUBLIC	??_C@_05DFCJAACA@name?$DN@			; `string'
PUBLIC	??_C@_08CLMDBNEB@version?$DN@			; `string'
PUBLIC	??_C@_09GHEONEIE@encoding?$DN@			; `string'
PUBLIC	??_C@_04LLECLDGK@URL?$DN@			; `string'
PUBLIC	??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@	; `string'
PUBLIC	??_C@_0P@LECCLHEJ@Entity?5is?5NULL@		; `string'
PUBLIC	??_C@_05LLGELLBM@?$CFs?5?3?5@			; `string'
PUBLIC	??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@	; `string'
PUBLIC	??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@	; `string'
PUBLIC	??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@	; `string'
PUBLIC	??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@	; `string'
PUBLIC	??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@	; `string'
PUBLIC	??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@ ; `string'
PUBLIC	??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@		; `string'
PUBLIC	??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@ ; `string'
PUBLIC	??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@ ; `string'
PUBLIC	??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@ ; `string'
PUBLIC	??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@ ; `string'
PUBLIC	??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@		; `string'
PUBLIC	??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@	; `string'
PUBLIC	??_C@_05NJDBAOFA@NULL?6@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01PFHFFBPC@t@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e@				; `string'
PUBLIC	??_C@_01DDCIFGEA@E@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p@				; `string'
PUBLIC	??_C@_01PAPGNFGE@c@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d@				; `string'
PUBLIC	??_C@_01BDACAMKP@h@				; `string'
PUBLIC	??_C@_01GAPBHFFA@T@				; `string'
PUBLIC	??_C@_01BIAFAFID@F@				; `string'
PUBLIC	??_C@_01NANMIPIL@N@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n@				; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_05KPHFGMAO@?5?$CF8d?5@			; `string'
PUBLIC	??_C@_03DKEJHHJP@?$CFs?3@			; `string'
PUBLIC	??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@	; `string'
PUBLIC	??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@		; `string'
PUBLIC	??_C@_04HPMIDMKH@True@				; `string'
PUBLIC	??_C@_05MKDOIIA@False@				; `string'
PUBLIC	??_C@_06GGONACPB@Result@			; `string'
PUBLIC	??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@	; `string'
PUBLIC	??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@	; `string'
PUBLIC	??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@	; `string'
PUBLIC	??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@	; `string'
PUBLIC	??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@	; `string'
PUBLIC	??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@	; `string'
PUBLIC	??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@	; `string'
PUBLIC	??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@ ; `string'
PUBLIC	??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@		; `string'
PUBLIC	??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@	; `string'
PUBLIC	??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@	; `string'
PUBLIC	??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@	; `string'
PUBLIC	??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@ ; `string'
PUBLIC	??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@ ; `string'
PUBLIC	??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@ ; `string'
PUBLIC	??_C@_09EMODOEOP@defaultns@			; `string'
PUBLIC	??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@ ; `string'
PUBLIC	??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@ ; `string'
PUBLIC	??_C@_0O@DFGOKOFF@?$CFs?5validates?6@		; `string'
PUBLIC	??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@ ; `string'
PUBLIC	??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@ ; `string'
PUBLIC	??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@ ; `string'
PUBLIC	??_C@_02MJEAMPLK@?1?6@				; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5@				; `string'
PUBLIC	??_C@_04GBAPPDDB@?1?5?$DO?5@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_05LMGNBDMA@?$CFs?5?$DO?5@			; `string'
PUBLIC	??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@		; `string'
PUBLIC	??_C@_04BOPGELD@?$DP?5?$DO?5@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit@				; `string'
PUBLIC	??_C@_04KNNLNNGO@quit@				; `string'
PUBLIC	??_C@_03MDONDFG@bye@				; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@ ; `string'
PUBLIC	??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@ ; `string'
PUBLIC	??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@ ; `string'
PUBLIC	??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@ ; `string'
PUBLIC	??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@ ; `string'
PUBLIC	??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@ ; `string'
PUBLIC	??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@ ; `string'
PUBLIC	??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@ ; `string'
PUBLIC	??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@ ; `string'
PUBLIC	??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@ ; `string'
PUBLIC	??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@ ; `string'
PUBLIC	??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@ ; `string'
PUBLIC	??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@ ; `string'
PUBLIC	??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@ ; `string'
PUBLIC	??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@ ; `string'
PUBLIC	??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@ ; `string'
PUBLIC	??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@ ; `string'
PUBLIC	??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@ ; `string'
PUBLIC	??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@ ; `string'
PUBLIC	??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@ ; `string'
PUBLIC	??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@ ; `string'
PUBLIC	??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@ ; `string'
PUBLIC	??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@ ; `string'
PUBLIC	??_C@_08EBLJJHKN@validate@			; `string'
PUBLIC	??_C@_04EONOHKEP@load@				; `string'
PUBLIC	??_C@_07LADMNHNM@relaxng@			; `string'
PUBLIC	??_C@_04EMMDIJJL@save@				; `string'
PUBLIC	??_C@_05NGFEDHGN@write@				; `string'
PUBLIC	??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@ ; `string'
PUBLIC	??_C@_04LCNKLLJF@grep@				; `string'
PUBLIC	??_C@_04LIAPHEDB@free@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_03OFKLFAAJ@pwd@				; `string'
PUBLIC	??_C@_02BNCIMIKC@du@				; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_03KCHOJKKI@set@				; `string'
PUBLIC	??_C@_05DAFPCCNK@setns@				; `string'
PUBLIC	??_C@_09ENEJFFG@setrootns@			; `string'
PUBLIC	??_C@_05CNNIIAHK@xpath@				; `string'
PUBLIC	??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@ ; `string'
PUBLIC	??_C@_07NPGKGHNA@setbase@			; `string'
PUBLIC	??_C@_02EFGBDOJM@ls@				; `string'
PUBLIC	??_C@_03DAPAKLGM@dir@				; `string'
PUBLIC	??_C@_07BANGEKHA@whereis@			; `string'
PUBLIC	??_C@_02ELLOPNDH@cd@				; `string'
PUBLIC	??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@	; `string'
PUBLIC	??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@ ; `string'
PUBLIC	??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@ ; `string'
PUBLIC	??_C@_03PFGOGFOL@cat@				; `string'
PUBLIC	??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@		; `string'
PUBLIC	??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@	; `string'
PUBLIC	__xmm@20202020202020202020202020202020
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlCheckUTF8:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__free:PROC
EXTRN	_xmlMemShow:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlValidateName:PROC
EXTRN	_xmlFreeDtd:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlGetNodePath:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChildList:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlNodeSetBase:PROC
EXTRN	_xmlDocDump:PROC
EXTRN	_xmlElemDump:PROC
EXTRN	_xmlSaveFile:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlSnprintfElementContent:PROC
EXTRN	_xmlValidateDtd:PROC
EXTRN	_xmlValidateDocument:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlParseDTD:PROC
EXTRN	_xmlParseInNodeContext:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_htmlParseFile:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPathEval:PROC
EXTRN	_htmlDocDump:PROC
EXTRN	_htmlSaveFile:PROC
EXTRN	_htmlNodeDumpFile:PROC
EXTRN	_xmlXPathDebugDumpObject:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlRelaxNGNewParserCtxt:PROC
EXTRN	_xmlRelaxNGFreeParserCtxt:PROC
EXTRN	_xmlRelaxNGSetParserErrors:PROC
EXTRN	_xmlRelaxNGParse:PROC
EXTRN	_xmlRelaxNGFree:PROC
EXTRN	_xmlRelaxNGSetValidErrors:PROC
EXTRN	_xmlRelaxNGNewValidCtxt:PROC
EXTRN	_xmlRelaxNGFreeValidCtxt:PROC
EXTRN	_xmlRelaxNGValidateDoc:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
EXTRN	_xmlStringComment:BYTE
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@20202020202020202020202020202020
CONST	SEGMENT
__xmm@20202020202020202020202020202020 DB '                '
CONST	ENDS
;	COMDAT ??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@ DB 'Unknown command %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@
CONST	SEGMENT
??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@ DB ' -------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFGOGFOL@cat@
CONST	SEGMENT
??_C@_03PFGOGFOL@cat@ DB 'cat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@
CONST	SEGMENT
??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@ DB '%s is an empty '
	DB	'Node Set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@
CONST	SEGMENT
??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@ DB '%s is a %d Node '
	DB	'Set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@
CONST	SEGMENT
??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@ DB 'cannot cd to namespac'
	DB	'e', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELLOPNDH@cd@
CONST	SEGMENT
??_C@_02ELLOPNDH@cd@ DB 'cd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BANGEKHA@whereis@
CONST	SEGMENT
??_C@_07BANGEKHA@whereis@ DB 'whereis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAPAKLGM@dir@
CONST	SEGMENT
??_C@_03DAPAKLGM@dir@ DB 'dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EFGBDOJM@ls@
CONST	SEGMENT
??_C@_02EFGBDOJM@ls@ DB 'ls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NPGKGHNA@setbase@
CONST	SEGMENT
??_C@_07NPGKGHNA@setbase@ DB 'setbase', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@
CONST	SEGMENT
??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@ DB 'xpath: expression'
	DB	' required', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNNIIAHK@xpath@
CONST	SEGMENT
??_C@_05CNNIIAHK@xpath@ DB 'xpath', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ENEJFFG@setrootns@
CONST	SEGMENT
??_C@_09ENEJFFG@setrootns@ DB 'setrootns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DAFPCCNK@setns@
CONST	SEGMENT
??_C@_05DAFPCCNK@setns@ DB 'setns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCHOJKKI@set@
CONST	SEGMENT
??_C@_03KCHOJKKI@set@ DB 'set', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BNCIMIKC@du@
CONST	SEGMENT
??_C@_02BNCIMIKC@du@ DB 'du', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFKLFAAJ@pwd@
CONST	SEGMENT
??_C@_03OFKLFAAJ@pwd@ DB 'pwd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LIAPHEDB@free@
CONST	SEGMENT
??_C@_04LIAPHEDB@free@ DB 'free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LCNKLLJF@grep@
CONST	SEGMENT
??_C@_04LCNKLLJF@grep@ DB 'grep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@
CONST	SEGMENT
??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@ DB 'Write command'
	DB	' requires a filename argument', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write@
CONST	SEGMENT
??_C@_05NGFEDHGN@write@ DB 'write', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EMMDIJJL@save@
CONST	SEGMENT
??_C@_04EMMDIJJL@save@ DB 'save', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LADMNHNM@relaxng@
CONST	SEGMENT
??_C@_07LADMNHNM@relaxng@ DB 'relaxng', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EONOHKEP@load@
CONST	SEGMENT
??_C@_04EONOHKEP@load@ DB 'load', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBLJJHKN@validate@
CONST	SEGMENT
??_C@_08EBLJJHKN@validate@ DB 'validate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@
CONST	SEGMENT
??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@ DB 09H, 'grep '
	DB	'string  search for a string in the subtree', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@
CONST	SEGMENT
??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@ DB 09H, 'relaxn'
	DB	'g rng  validate the document against the Relax-NG schemas', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@
CONST	SEGMENT
??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@ DB 09H, 'vali'
	DB	'date     check the document for errors', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@
CONST	SEGMENT
??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@ DB 09H, 'w'
	DB	'rite [name] write the current node to the filename', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@
CONST	SEGMENT
??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@ DB 09H, 's'
	DB	'ave [name]  save this document to name or the original name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'quit '
	DB	'        leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@
CONST	SEGMENT
??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@ DB 09H, 'whe'
	DB	'reis      display absolute path of [path] or current working '
	DB	'directory', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@
CONST	SEGMENT
??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@ DB 09H, 'p'
	DB	'wd          display current working directory', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@
CONST	SEGMENT
??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@ DB 09H
	DB	'             the default namespace if any uses ''defaultns'' '
	DB	'prefix', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@
CONST	SEGMENT
??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@ DB 09H, 'setro'
	DB	'otns    register all namespace found on the root element', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@
CONST	SEGMENT
??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@ DB 09H
	DB	'             format for nsreg is: prefix=[nsuri] (i.e. prefix'
	DB	'= unsets a prefix)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@
CONST	SEGMENT
??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@ DB 09H, 'setns '
	DB	'nsreg  register a namespace to a prefix in the XPath evaluati'
	DB	'on context', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@
CONST	SEGMENT
??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@ DB 09H, 'xpath'
	DB	' expr   evaluate the XPath expression in that context and pri'
	DB	'nt the result', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@
CONST	SEGMENT
??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@ DB 09H, 'set xml'
	DB	'_fragment replace the current node content with the fragment '
	DB	'parsed in context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@
CONST	SEGMENT
??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@ DB 09H, 'l'
	DB	's [path]    list contents of path or the current directory', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@
CONST	SEGMENT
??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@ DB 09H, 'l'
	DB	'oad [name]  load a new document with name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@
CONST	SEGMENT
??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@ DB 09H, 'f'
	DB	'ree         display memory usage', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@
CONST	SEGMENT
??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@ DB 09H, 'h'
	DB	'elp         display this help', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'exit '
	DB	'        leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@
CONST	SEGMENT
??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@ DB 09H, 'd'
	DB	'u [path]    show the structure of the subtree under path or t'
	DB	'he current node', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@
CONST	SEGMENT
??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@ DB 09H, 'd'
	DB	'ir [path]   dumps informations about the node (namespace, att'
	DB	'ributes, content)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@
CONST	SEGMENT
??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@ DB 09H, 'c'
	DB	'd [path]    change directory to path or to root', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@
CONST	SEGMENT
??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@ DB 09H, 'c'
	DB	'at [node]   display node or current node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'bye '
	DB	'         leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@
CONST	SEGMENT
??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@ DB 09H, 'setba'
	DB	'se URI  change the XML base of the node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@
CONST	SEGMENT
??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@ DB 09H, 'b'
	DB	'ase         display XML base of the node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye@
CONST	SEGMENT
??_C@_03MDONDFG@bye@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit@ DB 'quit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit@ DB 'exit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BOPGELD@?$DP?5?$DO?5@
CONST	SEGMENT
??_C@_04BOPGELD@?$DP?5?$DO?5@ DB '? > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@
CONST	SEGMENT
??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@ DB '%s:%s > ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LMGNBDMA@?$CFs?5?$DO?5@
CONST	SEGMENT
??_C@_05LMGNBDMA@?$CFs?5?$DO?5@ DB '%s > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBAPPDDB@?1?5?$DO?5@
CONST	SEGMENT
??_C@_04GBAPPDDB@?1?5?$DO?5@ DB '/ > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJEAMPLK@?1?6@
CONST	SEGMENT
??_C@_02MJEAMPLK@?1?6@ DB '/', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@
CONST	SEGMENT
??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@ DB 'To save to '
	DB	'subparts of a document use the ''write'' command', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@ DB 'Failed to save to %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@ DB 'Failed to write to'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@
CONST	SEGMENT
??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@ DB '%s validat'
	DB	'ion generated an internal error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@
CONST	SEGMENT
??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@ DB '%s fails to validate'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFGOKOFF@?$CFs?5validates?6@
CONST	SEGMENT
??_C@_0O@DFGOKOFF@?$CFs?5validates?6@ DB '%s validates', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@
CONST	SEGMENT
??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@ DB 'Relax-NG'
	DB	' schema %s failed to compile', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@
CONST	SEGMENT
??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@ DB 'failed to parse cont'
	DB	'ent', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMODOEOP@defaultns@
CONST	SEGMENT
??_C@_09EMODOEOP@defaultns@ DB 'defaultns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@
CONST	SEGMENT
??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@ DB 'Error: unab'
	DB	'le to register NS with prefix="%s" and href="%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
CONST	SEGMENT
??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@ DB 'setn'
	DB	's: prefix=[nsuri] required', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@
CONST	SEGMENT
??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@ DB ' No base found '
	DB	'!!!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@ DB 'Is a string:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@
CONST	SEGMENT
??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@ DB 'Is a number:%0g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@
CONST	SEGMENT
??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@ DB 'Is a Boolean:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@
CONST	SEGMENT
??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@ DB 'Empty node set', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
CONST	SEGMENT
??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@ DB '%s is an XSLT '
	DB	'value tree', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
CONST	SEGMENT
??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@ DB '%s is user-defined', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
CONST	SEGMENT
??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@ DB '%s is a range', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
CONST	SEGMENT
??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@ DB '%s is a point', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
CONST	SEGMENT
??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@ DB '%s is a string', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
CONST	SEGMENT
??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@ DB '%s is a number', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
CONST	SEGMENT
??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@ DB '%s is a Boolean', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
CONST	SEGMENT
??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@ DB '%s: no such node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONACPB@Result@
CONST	SEGMENT
??_C@_06GGONACPB@Result@ DB 'Result', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKDOIIA@False@
CONST	SEGMENT
??_C@_05MKDOIIA@False@ DB 'False', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True@
CONST	SEGMENT
??_C@_04HPMIDMKH@True@ DB 'True', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@ DB '%s -> %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@ DB 'default -> %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKEJHHJP@?$CFs?3@
CONST	SEGMENT
??_C@_03DKEJHHJP@?$CFs?3@ DB '%s:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KPHFGMAO@?5?$CF8d?5@
CONST	SEGMENT
??_C@_05KPHFGMAO@?5?$CF8d?5@ DB ' %8d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n@ DB 'n', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NANMIPIL@N@
CONST	SEGMENT
??_C@_01NANMIPIL@N@ DB 'N', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F@
CONST	SEGMENT
??_C@_01BIAFAFID@F@ DB 'F', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T@
CONST	SEGMENT
??_C@_01GAPBHFFA@T@ DB 'T', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h@
CONST	SEGMENT
??_C@_01BDACAMKP@h@ DB 'h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d@
CONST	SEGMENT
??_C@_01LPLHEDKD@d@ DB 'd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c@
CONST	SEGMENT
??_C@_01PAPGNFGE@c@ DB 'c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p@
CONST	SEGMENT
??_C@_01JBBJJEPG@p@ DB 'p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E@
CONST	SEGMENT
??_C@_01DDCIFGEA@E@ DB 'E', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e@
CONST	SEGMENT
??_C@_01KGKMHCOC@e@ DB 'e', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C@
CONST	SEGMENT
??_C@_01GFHCPBMG@C@ DB 'C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t@
CONST	SEGMENT
??_C@_01PFHFFBPC@t@ DB 't', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJDBAOFA@NULL?6@
CONST	SEGMENT
??_C@_05NJDBAOFA@NULL?6@ DB 'NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@
CONST	SEGMENT
??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@ DB '    DTD is empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@
CONST	SEGMENT
??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@ DB 'DTD is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@
CONST	SEGMENT
??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@ DB 'No entities '
	DB	'in external subset', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@
CONST	SEGMENT
??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@ DB 'Entities in exte'
	DB	'rnal subset', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@
CONST	SEGMENT
??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@ DB 'No entities '
	DB	'in internal subset', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@
CONST	SEGMENT
??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@ DB 'Entities in inte'
	DB	'rnal subset', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@ DB 0aH, ' content "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@ DB 0aH, ' orig "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@ DB 'SYSTEM "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@ DB 'ID "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@ DB 'Unknown entity typ'
	DB	'e %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@
CONST	SEGMENT
??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@ DB 'EXTERNAL PARAMETER, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@
CONST	SEGMENT
??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@ DB 'INTERNAL PARAMETER, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@
CONST	SEGMENT
??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@ DB 'EXTERNAL UNPARSED, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@
CONST	SEGMENT
??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@ DB 'EXTERNAL PARSED, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@
CONST	SEGMENT
??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@ DB 'INTERNAL GENERAL, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLGELLBM@?$CFs?5?3?5@
CONST	SEGMENT
??_C@_05LLGELLBM@?$CFs?5?3?5@ DB '%s : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LECCLHEJ@Entity?5is?5NULL@
CONST	SEGMENT
??_C@_0P@LECCLHEJ@Entity?5is?5NULL@ DB 'Entity is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@
CONST	SEGMENT
??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@ DB 'standalone=true', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLECLDGK@URL?$DN@
CONST	SEGMENT
??_C@_04LLECLDGK@URL?$DN@ DB 'URL=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHEONEIE@encoding?$DN@
CONST	SEGMENT
??_C@_09GHEONEIE@encoding?$DN@ DB 'encoding=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLMDBNEB@version?$DN@
CONST	SEGMENT
??_C@_08CLMDBNEB@version?$DN@ DB 'version=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCJAACA@name?$DN@
CONST	SEGMENT
??_C@_05DFCJAACA@name?$DN@ DB 'name=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@
CONST	SEGMENT
??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@ DB 'Misplaced NOTATION no'
	DB	'de', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@
CONST	SEGMENT
??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@ DB 'Misplaced FRAGMENT no'
	DB	'de', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@
CONST	SEGMENT
??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@ DB 'Misplaced DOCTYPE node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@
CONST	SEGMENT
??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@ DB 'HTML DOCUMENT', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFLEHAPI@DOCUMENT?6@
CONST	SEGMENT
??_C@_09JFLEHAPI@DOCUMENT?6@ DB 'DOCUMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@
CONST	SEGMENT
??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@ DB 'Misplaced COMMENT node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@
CONST	SEGMENT
??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@ DB 'Misplaced PI node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@
CONST	SEGMENT
??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@ DB 'Misplaced ENTITY node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@
CONST	SEGMENT
??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@ DB 'Misplaced ENTITYREF '
	DB	'node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@
CONST	SEGMENT
??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@ DB 'Misplaced CDATA node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@
CONST	SEGMENT
??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@ DB 'Misplaced TEXT node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@
CONST	SEGMENT
??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@ DB 'Misplaced ATTRIBUTE '
	DB	'node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@
CONST	SEGMENT
??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@ DB 'Misplaced ELEMENT node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@ DB 'DOCUMENT == NULL'
	DB	' !', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@
CONST	SEGMENT
??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@ DB 'PBM: d'
	DB	'oc == NULL !!!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@ DB 'Unknown node type %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKMEHMHH@INCLUDE?5END?6@
CONST	SEGMENT
??_C@_0N@DKMEHMHH@INCLUDE?5END?6@ DB 'INCLUDE END', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIINKGDA@INCLUDE?5START?6@
CONST	SEGMENT
??_C@_0P@MIINKGDA@INCLUDE?5START?6@ DB 'INCLUDE START', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CPFNJPEP@NOTATION?6@
CONST	SEGMENT
??_C@_09CPFNJPEP@NOTATION?6@ DB 'NOTATION', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@
CONST	SEGMENT
??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@ DB 'DOCUMENT_FRAG', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@
CONST	SEGMENT
??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@ DB 'DOCUMENT_TYPE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@
CONST	SEGMENT
??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@ DB 'Error, DOCUMENT '
	DB	'found here', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OCMMJPAI@COMMENT?6@
CONST	SEGMENT
??_C@_08OCMMJPAI@COMMENT?6@ DB 'COMMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JDGENMBJ@PI?5?$CFs?6@
CONST	SEGMENT
??_C@_06JDGENMBJ@PI?5?$CFs?6@ DB 'PI %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PAIFPHKC@ENTITY?6@
CONST	SEGMENT
??_C@_07PAIFPHKC@ENTITY?6@ DB 'ENTITY', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@ DB 'ENTITY_REF(%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFCBAJGN@CDATA_SECTION?6@
CONST	SEGMENT
??_C@_0P@HFCBAJGN@CDATA_SECTION?6@ DB 'CDATA_SECTION', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IDACKBMB@?5interned?6@
CONST	SEGMENT
??_C@_0L@IDACKBMB@?5interned?6@ DB ' interned', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKJIJFNN@?5compact?6@
CONST	SEGMENT
??_C@_09PKJIJFNN@?5compact?6@ DB ' compact', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEPMCOLO@TEXT@
CONST	SEGMENT
??_C@_04OEPMCOLO@TEXT@ DB 'TEXT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDMICFJC@TEXT?5no?5enc@
CONST	SEGMENT
??_C@_0M@IDMICFJC@TEXT?5no?5enc@ DB 'TEXT no enc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@
CONST	SEGMENT
??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@ DB 'Error, ATTRIBUT'
	DB	'E found here', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDNNGDCO@ELEMENT?5@
CONST	SEGMENT
??_C@_08EDNNGDCO@ELEMENT?5@ DB 'ELEMENT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0O@IPKFPFDL@node?5is?5NULL?6@ DB 'node is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@
CONST	SEGMENT
??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@ DB 'Attribute has no name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPLGGCMF@ATTRIBUTE?5@
CONST	SEGMENT
??_C@_0L@MPLGGCMF@ATTRIBUTE?5@ DB 'ATTRIBUTE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCLOKEKK@Attr?5is?5NULL@
CONST	SEGMENT
??_C@_0N@KCLOKEKK@Attr?5is?5NULL@ DB 'Attr is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08INNCGMHH@content?$DN@
CONST	SEGMENT
??_C@_08INNCGMHH@content?$DN@ DB 'content=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HJADGDLG@URI?$DN?$CFs?6@
CONST	SEGMENT
??_C@_07HJADGDLG@URI?$DN?$CFs?6@ DB 'URI=%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@ DB 'SystemID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@ DB 'ExternalID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@
CONST	SEGMENT
??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@ DB 'ENTITY_%d ! ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@
CONST	SEGMENT
??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@ DB 'EXTERNAL_PARAMETER_EN'
	DB	'TITY ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@
CONST	SEGMENT
??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@ DB 'INTERNAL_PARAMETER_EN'
	DB	'TITY ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@
CONST	SEGMENT
??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@ DB 'EXTERNAL_GENERAL_'
	DB	'UNPARSED_ENTITY ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@
CONST	SEGMENT
??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@ DB 'EXTERNAL_GENERAL'
	DB	'_PARSED_ENTITY ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@
CONST	SEGMENT
??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@ DB 'INTERNAL_GENERAL_ENTITY'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@ DB 'Entity is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@
CONST	SEGMENT
??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@ DB 'default namespace hr'
	DB	'ef=', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@
CONST	SEGMENT
??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@ DB 'namespace %s href=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@
CONST	SEGMENT
??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@ DB 'Incomplete def'
	DB	'ault namespace href=NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@
CONST	SEGMENT
??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@ DB 'Incomple'
	DB	'te namespace %s href=NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@
CONST	SEGMENT
??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@ DB 'Node is not '
	DB	'a namespace declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@ DB 'namespace node is NUL'
	DB	'L', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHAMBDHP@?5content?$DN@
CONST	SEGMENT
??_C@_09MHAMBDHP@?5content?$DN@ DB ' content=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@
CONST	SEGMENT
??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@ DB ' URI=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@ DB ' SystemID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@ DB ' ExternalID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLDJNJL@?0?5predefined?6@
CONST	SEGMENT
??_C@_0O@OLDJNJL@?0?5predefined?6@ DB ', predefined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@
CONST	SEGMENT
??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@ DB ', external parameter', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMAFEAAG@?0?5parameter?6@
CONST	SEGMENT
??_C@_0N@NMAFEAAG@?0?5parameter?6@ DB ', parameter', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLIMFIIH@?0?5unparsed?6@
CONST	SEGMENT
??_C@_0M@FLIMFIIH@?0?5unparsed?6@ DB ', unparsed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@
CONST	SEGMENT
??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@ DB ', external parsed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBKIGNE@?0?5internal?6@
CONST	SEGMENT
??_C@_0M@PBKIGNE@?0?5internal?6@ DB ', internal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@
CONST	SEGMENT
??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@ DB 'Entity declara'
	DB	'tion has no name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@
CONST	SEGMENT
??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@ DB 'ENTITYDECL(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@
CONST	SEGMENT
??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@ DB 'Node is not '
	DB	'an entity declaration', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@ DB 'Entity declaratio'
	DB	'n is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPHAJKBG@?0?5MIXED?5@
CONST	SEGMENT
??_C@_08MPHAJKBG@?0?5MIXED?5@ DB ', MIXED ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNEHMNJK@?0?5ANY@
CONST	SEGMENT
??_C@_05MNEHMNJK@?0?5ANY@ DB ', ANY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPIOAGOH@?0?5EMPTY@
CONST	SEGMENT
??_C@_07MPIOAGOH@?0?5EMPTY@ DB ', EMPTY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIGJBKAD@?0?5UNDEFINED@
CONST	SEGMENT
??_C@_0M@PIGJBKAD@?0?5UNDEFINED@ DB ', UNDEFINED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@
CONST	SEGMENT
??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@ DB 'Element decla'
	DB	'ration has no name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBEHMBNA@ELEMDECL?$CI@
CONST	SEGMENT
??_C@_09LBEHMBNA@ELEMDECL?$CI@ DB 'ELEMDECL(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@
CONST	SEGMENT
??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@ DB 'Node is not '
	DB	'an element declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@ DB 'Element declarat'
	DB	'ion is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNDBCIDD@?5FIXED@
CONST	SEGMENT
??_C@_06MNDBCIDD@?5FIXED@ DB ' FIXED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNNMMLKP@?5IMPLIED@
CONST	SEGMENT
??_C@_08BNNMMLKP@?5IMPLIED@ DB ' IMPLIED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBLDHCFM@?5REQUIRED@
CONST	SEGMENT
??_C@_09GBLDHCFM@?5REQUIRED@ DB ' REQUIRED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBFELFIL@?4?4?4?$CJ@
CONST	SEGMENT
??_C@_04HBFELFIL@?4?4?4?$CJ@ DB '...)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KHAOAOAJ@?5?$CI?$CFs@
CONST	SEGMENT
??_C@_04KHAOAOAJ@?5?$CI?$CFs@ DB ' (%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFMGJBPJ@?$HM?$CFs@
CONST	SEGMENT
??_C@_03MFMGJBPJ@?$HM?$CFs@ DB '|%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOKHAFCK@?5NOTATION?5@
CONST	SEGMENT
??_C@_0L@EOKHAFCK@?5NOTATION?5@ DB ' NOTATION ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DAGLJCMJ@?5ENUMERATION@
CONST	SEGMENT
??_C@_0N@DAGLJCMJ@?5ENUMERATION@ DB ' ENUMERATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGAPIBOH@?5NMTOKENS@
CONST	SEGMENT
??_C@_09LGAPIBOH@?5NMTOKENS@ DB ' NMTOKENS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLMONKHB@?5NMTOKEN@
CONST	SEGMENT
??_C@_08JLMONKHB@?5NMTOKEN@ DB ' NMTOKEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MILPKLMO@?5ENTITIES@
CONST	SEGMENT
??_C@_09MILPKLMO@?5ENTITIES@ DB ' ENTITIES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLIJGNMP@?5ENTITY@
CONST	SEGMENT
??_C@_07GLIJGNMP@?5ENTITY@ DB ' ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNGJPBFB@?5IDREFS@
CONST	SEGMENT
??_C@_07CNGJPBFB@?5IDREFS@ DB ' IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJHMNMLB@?5IDREF@
CONST	SEGMENT
??_C@_06JJHMNMLB@?5IDREF@ DB ' IDREF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFNHLDJD@?5ID@
CONST	SEGMENT
??_C@_03JFNHLDJD@?5ID@ DB ' ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CIOOFICG@?5CDATA@
CONST	SEGMENT
??_C@_06CIOOFICG@?5CDATA@ DB ' CDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@
CONST	SEGMENT
??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@ DB 'Node attribut'
	DB	'e declaration has no element name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLNLDEDP@?5for?5?$CFs@
CONST	SEGMENT
??_C@_07GLNLDEDP@?5for?5?$CFs@ DB ' for %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@
CONST	SEGMENT
??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@ DB 'Node attribut'
	DB	'e declaration has no name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@ DB 'ATTRDECL(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@
CONST	SEGMENT
??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@ DB 'Node is not '
	DB	'an attribute declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@ DB 'Attribute decl'
	DB	'aration is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@
CONST	SEGMENT
??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@ DB ', SYSTEM %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@
CONST	SEGMENT
??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@ DB ', PUBLIC %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFGNODOE@DTD@
CONST	SEGMENT
??_C@_03DFGNODOE@DTD@ DB 'DTD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@ DB 'DTD(%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@
CONST	SEGMENT
??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@ DB 'Node is not a DTD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@ DB 'DTD node is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHICJKCI@?4?4?4@
CONST	SEGMENT
??_C@_03KHICJKCI@?4?4?4@ DB '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CANIHDGE@?$CD?$CFX@
CONST	SEGMENT
??_C@_03CANIHDGE@?$CD?$CFX@ DB '#%X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LHGEHABH@?$CINULL?$CJ@
CONST	SEGMENT
??_C@_06LHGEHABH@?$CINULL?$CJ@ DB '(NULL)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@
CONST	SEGMENT
??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@ DB 'CData sectio'
	DB	'n has non NULL name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@
CONST	SEGMENT
??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@ DB 'Comment '
	DB	'node has wrong name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@ DB 'Text node'
	DB	' has wrong name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DALNPEGO@nbktext@
CONST	SEGMENT
??_C@_07DALNPEGO@nbktext@ DB 'nbktext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
CONST	SEGMENT
??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@ DB 'Node ne'
	DB	'xt->prev : forward link wrong', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@
CONST	SEGMENT
??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@ DB 'Node has n'
	DB	'o next and not last of parent list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@
CONST	SEGMENT
??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@ DB 'Node pr'
	DB	'ev->next : back link wrong', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@
CONST	SEGMENT
??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@ DB 'Node has no'
	DB	' prev and not first of parent list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@
CONST	SEGMENT
??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@ DB 'Attr has no'
	DB	' prev and not first of attr list', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@
CONST	SEGMENT
??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@ DB 'Node doc di'
	DB	'ffers from parent''s one', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLLEMIAI@pseudoroot@
CONST	SEGMENT
??_C@_0L@OLLEMIAI@pseudoroot@ DB 'pseudoroot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@
CONST	SEGMENT
??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@ DB 'Node has no doc', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@
CONST	SEGMENT
??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@ DB 'Node has no parent', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@
CONST	SEGMENT
??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@ DB 'Name is not'
	DB	' from the document dictionary ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@ DB 'Name is not '
	DB	'an NCName ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLMILKM@Name?5is?5NULL@
CONST	SEGMENT
??_C@_0N@BLMILKM@Name?5is?5NULL@ DB 'Name is NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@
CONST	SEGMENT
??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@ DB 'String is not UTF-'
	DB	'8 %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@
CONST	SEGMENT
??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@ DB 'Referenc'
	DB	'e to namespace ''%s'' not on ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@
CONST	SEGMENT
??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@ DB 'Reference to '
	DB	'default namespace not on ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@
CONST	SEGMENT
??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@ DB 'Reference'
	DB	' to namespace ''%s'' not in scope', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@
CONST	SEGMENT
??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@ DB 'Reference to '
	DB	'default namespace not in scope', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRNGValidate
_TEXT	SEGMENT
_vctxt$1$ = -4						; size = 4
_sctxt$ = 8						; size = 4
_schemas$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRNGValidate PROC				; COMDAT

; 2359 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _schemas$[ebp]
	call	_xmlRelaxNGNewParserCtxt
	mov	edi, DWORD PTR __imp____acrt_iob_func
	mov	esi, eax
	push	2
	call	edi
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	push	esi
	call	_xmlRelaxNGSetParserErrors
	push	esi
	call	_xmlRelaxNGParse
	push	esi
	mov	ebx, eax
	call	_xmlRelaxNGFreeParserCtxt
	add	esp, 32					; 00000020H
	test	ebx, ebx
	jne	SHORT $LN2@xmlShellRN

; 2360 :     xmlRelaxNGPtr relaxngschemas;
; 2361 :     xmlRelaxNGParserCtxtPtr ctxt;
; 2362 :     xmlRelaxNGValidCtxtPtr vctxt;
; 2363 :     int ret;
; 2364 : 
; 2365 :     ctxt = xmlRelaxNGNewParserCtxt(schemas);
; 2366 :     xmlRelaxNGSetParserErrors(ctxt,
; 2367 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2368 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2369 : 	    stderr);
; 2370 :     relaxngschemas = xmlRelaxNGParse(ctxt);
; 2371 :     xmlRelaxNGFreeParserCtxt(ctxt);
; 2372 :     if (relaxngschemas == NULL) {
; 2373 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _schemas$[ebp]
	push	OFFSET ??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 2374 : 		"Relax-NG schema %s failed to compile\n", schemas);
; 2375 : 	return(-1);

	or	eax, -1
	pop	edi

; 2395 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlShellRN:

; 2376 :     }
; 2377 :     vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);

	push	ebx
	call	_xmlRelaxNGNewValidCtxt
	mov	esi, eax

; 2378 :     xmlRelaxNGSetValidErrors(vctxt,

	push	2
	mov	DWORD PTR _vctxt$1$[ebp], esi
	call	edi
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	push	esi
	call	_xmlRelaxNGSetValidErrors

; 2379 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2380 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2381 : 	    stderr);
; 2382 :     ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);

	mov	esi, DWORD PTR _sctxt$[ebp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR _vctxt$1$[ebp]
	call	_xmlRelaxNGValidateDoc
	mov	esi, DWORD PTR [esi]
	add	esp, 32					; 00000020H

; 2383 :     if (ret == 0) {

	push	2
	test	eax, eax
	jne	SHORT $LN9@xmlShellRN

; 2384 : 	fprintf(stderr, "%s validates\n", sctxt->filename);

	call	edi
	mov	ecx, OFFSET ??_C@_0O@DFGOKOFF@?$CFs?5validates?6@
	jmp	SHORT $LN10@xmlShellRN
$LN9@xmlShellRN:

; 2385 :     } else if (ret > 0) {

	jle	SHORT $LN5@xmlShellRN

; 2386 : 	fprintf(stderr, "%s fails to validate\n", sctxt->filename);

	call	edi
	mov	ecx, OFFSET ??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@

; 2387 :     } else {

	jmp	SHORT $LN10@xmlShellRN
$LN5@xmlShellRN:

; 2388 : 	fprintf(stderr, "%s validation generated an internal error\n",

	call	edi
	mov	ecx, OFFSET ??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@
$LN10@xmlShellRN:

; 2389 : 	       sctxt->filename);
; 2390 :     }
; 2391 :     xmlRelaxNGFreeValidCtxt(vctxt);

	add	esp, 4
	push	esi
	push	ecx
	push	eax
	call	_fprintf
	push	DWORD PTR _vctxt$1$[ebp]
	call	_xmlRelaxNGFreeValidCtxt

; 2392 :     if (relaxngschemas != NULL)
; 2393 : 	xmlRelaxNGFree(relaxngschemas);

	push	ebx
	call	_xmlRelaxNGFree
	add	esp, 20					; 00000014H

; 2394 :     return(0);

	xor	eax, eax
	pop	edi

; 2395 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellRNGValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSetContent
_TEXT	SEGMENT
_results$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSetContent PROC				; COMDAT

; 2313 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN6@xmlShellSe

; 2314 :     xmlNodePtr results;
; 2315 :     xmlParserErrors ret;
; 2316 : 
; 2317 :     if (!ctxt)
; 2318 :         return (0);
; 2319 :     if (node == NULL) {

	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	jne	SHORT $LN3@xmlShellSe
$LN12@xmlShellSe:

; 2338 :     }
; 2339 :     return (0);
; 2340 : }

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	DWORD PTR [edi+20]
	call	_fprintf
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlShellSe:

; 2320 : 	fprintf(ctxt->output, "NULL\n");
; 2321 : 	return (0);
; 2322 :     }
; 2323 :     if (value == NULL) {

	mov	edx, DWORD PTR _value$[ebp]
	test	edx, edx
	je	SHORT $LN12@xmlShellSe

; 2324 :         fprintf(ctxt->output, "NULL\n");
; 2325 : 	return (0);
; 2326 :     }
; 2327 : 
; 2328 :     ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);

	mov	ecx, edx
	push	ebx
	lea	ebx, DWORD PTR [ecx+1]
$LL9@xmlShellSe:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL9@xmlShellSe
	lea	eax, DWORD PTR _results$[ebp]
	sub	ecx, ebx
	push	eax
	push	0
	push	ecx
	push	edx
	push	esi
	call	_xmlParseInNodeContext
	add	esp, 20					; 00000014H
	pop	ebx

; 2329 :     if (ret == XML_ERR_OK) {

	test	eax, eax
	jne	SHORT $LN5@xmlShellSe

; 2330 : 	if (node->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN7@xmlShellSe

; 2331 : 	    xmlFreeNodeList(node->children);

	push	eax
	call	_xmlFreeNodeList
	add	esp, 4

; 2332 : 	    node->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 2333 : 	    node->last = NULL;

	mov	DWORD PTR [esi+16], 0
$LN7@xmlShellSe:

; 2334 : 	}
; 2335 : 	xmlAddChildList(node, results);

	push	DWORD PTR _results$[ebp]
	push	esi
	call	_xmlAddChildList

; 2338 :     }
; 2339 :     return (0);
; 2340 : }

	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlShellSe:

; 2336 :     } else {
; 2337 :         fprintf(ctxt->output, "failed to parse content\n");

	push	OFFSET ??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@

; 2338 :     }
; 2339 :     return (0);
; 2340 : }

	push	DWORD PTR [edi+20]
	call	_fprintf
	add	esp, 8
$LN6@xmlShellSe:
	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellSetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellGrep
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellGrep PROC					; COMDAT

; 2200 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN52@xmlShellGr

; 2201 :     if (!ctxt)
; 2202 :         return (0);
; 2203 :     if (node == NULL)

	push	esi
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN53@xmlShellGr

; 2204 : 	return (0);
; 2205 :     if (arg == NULL)

	push	edi
	mov	edi, DWORD PTR _arg$[ebp]
	test	edi, edi
	je	$LN57@xmlShellGr

; 2206 : 	return (0);
; 2207 : #ifdef LIBXML_REGEXP_ENABLED
; 2208 :     if ((xmlStrchr((xmlChar *) arg, '?')) ||
; 2209 : 	(xmlStrchr((xmlChar *) arg, '*')) ||
; 2210 : 	(xmlStrchr((xmlChar *) arg, '.')) ||

	push	63					; 0000003fH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlShellGr
	push	42					; 0000002aH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlShellGr
	push	46					; 0000002eH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlShellGr
	push	91					; 0000005bH
	push	edi
	call	_xmlStrchr
	add	esp, 8
	npad	7
$LL2@xmlShellGr:

; 2215 :         if (node->type == XML_COMMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 8
	jne	SHORT $LN11@xmlShellGr

; 2216 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	push	edi
	push	DWORD PTR [esi+40]
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlShellGr

; 2217 : 
; 2218 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node));

	push	esi
	call	_xmlGetNodePath
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2219 :                 xmlShellList(ctxt, NULL, node, NULL);

	push	0
	push	esi

; 2220 : 	    }

	jmp	SHORT $LN62@xmlShellGr
$LN11@xmlShellGr:

; 2221 :         } else if (node->type == XML_TEXT_NODE) {

	cmp	eax, 3
	jne	SHORT $LN15@xmlShellGr

; 2222 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	push	edi
	push	DWORD PTR [esi+40]
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlShellGr

; 2223 : 
; 2224 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node->parent));

	push	DWORD PTR [esi+20]
	call	_xmlGetNodePath
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2225 :                 xmlShellList(ctxt, NULL, node->parent, NULL);

	push	0
	push	DWORD PTR [esi+20]
$LN62@xmlShellGr:

; 2226 : 	    }
; 2227 :         }
; 2228 : 
; 2229 :         /*
; 2230 :          * Browse the full subtree, deep first
; 2231 :          */
; 2232 : 
; 2233 :         if ((node->type == XML_DOCUMENT_NODE) ||

	push	0
	push	ebx
	call	_xmlShellList
	add	esp, 32					; 00000020H
$LN15@xmlShellGr:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	je	SHORT $LN18@xmlShellGr
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN18@xmlShellGr

; 2236 :         } else if ((node->children != NULL)
; 2237 :                    && (node->type != XML_ENTITY_REF_NODE)) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN42@xmlShellGr
	cmp	eax, 5
	je	SHORT $LN42@xmlShellGr

; 2238 :             /* deep first */
; 2239 :             node = node->children;

	mov	esi, ecx
	jmp	SHORT $LN5@xmlShellGr
$LN42@xmlShellGr:

; 2240 :         } else if (node->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL4@xmlShellGr
$LN29@xmlShellGr:

; 2211 : 	(xmlStrchr((xmlChar *) arg, '['))) {
; 2212 :     }
; 2213 : #endif
; 2214 :     while (node != NULL) {

	mov	esi, eax
	jmp	SHORT $LN5@xmlShellGr
$LL4@xmlShellGr:

; 2241 :             /* then siblings */
; 2242 :             node = node->next;
; 2243 :         } else {
; 2244 :             /* go up to parents->next if needed */
; 2245 :             while (node != NULL) {
; 2246 :                 if (node->parent != NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	cmovne	esi, eax

; 2247 :                     node = node->parent;
; 2248 :                 }
; 2249 :                 if (node->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN29@xmlShellGr

; 2250 :                     node = node->next;
; 2251 :                     break;
; 2252 :                 }
; 2253 :                 if (node->parent == NULL) {

	cmp	DWORD PTR [esi+20], eax
	jne	SHORT $LL4@xmlShellGr
	pop	edi
	pop	esi
	pop	ebx

; 2261 : }

	pop	ebp
	ret	0
$LN18@xmlShellGr:

; 2234 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2235 :             node = ((xmlDocPtr) node)->children;

	mov	esi, DWORD PTR [esi+12]
$LN5@xmlShellGr:

; 2211 : 	(xmlStrchr((xmlChar *) arg, '['))) {
; 2212 :     }
; 2213 : #endif
; 2214 :     while (node != NULL) {

	test	esi, esi
	jne	$LL2@xmlShellGr
$LN57@xmlShellGr:
	pop	edi
	pop	esi

; 2254 :                     node = NULL;
; 2255 :                     break;
; 2256 :                 }
; 2257 :             }
; 2258 : 	}
; 2259 :     }
; 2260 :     return (0);

	xor	eax, eax
	pop	ebx

; 2261 : }

	pop	ebp
	ret	0
$LN53@xmlShellGr:
	pop	esi

; 2254 :                     node = NULL;
; 2255 :                     break;
; 2256 :                 }
; 2257 :             }
; 2258 : 	}
; 2259 :     }
; 2260 :     return (0);

	xor	eax, eax
	pop	ebx

; 2261 : }

	pop	ebp
	ret	0
$LN52@xmlShellGr:

; 2254 :                     node = NULL;
; 2255 :                     break;
; 2256 :                 }
; 2257 :             }
; 2258 : 	}
; 2259 :     }
; 2260 :     return (0);

	xor	eax, eax
	pop	ebx

; 2261 : }

	pop	ebp
	ret	0
_xmlShellGrep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRegisterRootNamespaces
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_root$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRegisterRootNamespaces PROC			; COMDAT

; 2167 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _root$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlShellRe

; 2168 :     xmlNsPtr ns;
; 2169 : 
; 2170 :     if ((root == NULL) || (root->type != XML_ELEMENT_NODE) ||
; 2171 :         (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))

	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN5@xmlShellRe
	mov	esi, DWORD PTR [esi+48]
	test	esi, esi
	je	SHORT $LN5@xmlShellRe
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlShellRe
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN5@xmlShellRe
$LL2@xmlShellRe:

; 2173 :     ns = root->nsDef;
; 2174 :     while (ns != NULL) {
; 2175 :         if (ns->prefix == NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, OFFSET ??_C@_09EMODOEOP@defaultns@

; 2176 : 	    xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST "defaultns", ns->href);
; 2177 : 	else
; 2178 : 	    xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);
; 2179 :         ns = ns->next;

	push	DWORD PTR [esi+8]
	test	eax, eax
	cmovne	ecx, eax
	mov	eax, DWORD PTR [edi+12]
	push	ecx
	push	eax
	call	_xmlXPathRegisterNs
	mov	esi, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL2@xmlShellRe

; 2180 :     }
; 2181 :     return(0);

	pop	edi
	xor	eax, eax

; 2182 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlShellRe:
	pop	edi

; 2172 : 	return(-1);

	or	eax, -1

; 2182 : }

	pop	esi
	pop	ebp
	ret	0
_xmlShellRegisterRootNamespaces ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRegisterNamespace
_TEXT	SEGMENT
_nsListDup$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRegisterNamespace PROC				; COMDAT

; 2111 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _arg$[ebp]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _nsListDup$1$[ebp], eax
	mov	esi, eax
	test	eax, eax
	je	SHORT $LN3@xmlShellRe
$LL2@xmlShellRe:

; 2120 : 	/* skip spaces */
; 2121 : 	/*while((*next) == ' ') next++;*/
; 2122 : 	if((*next) == '\0') break;

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN15@xmlShellRe

; 2123 : 
; 2124 : 	/* find prefix */
; 2125 : 	prefix = next;
; 2126 : 	next = (xmlChar*)xmlStrchr(next, '=');

	push	61					; 0000003dH
	push	esi
	mov	ebx, esi
	call	_xmlStrchr
	mov	edi, eax
	add	esp, 8

; 2127 : 	if(next == NULL) {

	test	edi, edi
	je	SHORT $LN11@xmlShellRe

; 2131 : 	}
; 2132 : 	*(next++) = '\0';

	mov	BYTE PTR [edi], 0
	inc	edi

; 2133 : 
; 2134 : 	/* find href */
; 2135 : 	href = next;
; 2136 : 	next = (xmlChar*)xmlStrchr(next, ' ');

	push	32					; 00000020H
	push	edi
	call	_xmlStrchr
	mov	esi, eax
	add	esp, 8

; 2137 : 	if(next != NULL) {

	test	esi, esi
	je	SHORT $LN6@xmlShellRe

; 2138 : 	    *(next++) = '\0';

	mov	BYTE PTR [esi], 0
	inc	esi
$LN6@xmlShellRe:

; 2139 : 	}
; 2140 : 
; 2141 : 	/* do register namespace */
; 2142 : 	if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR [eax+12]
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@xmlShellRe

; 2112 :     xmlChar* nsListDup;
; 2113 :     xmlChar* prefix;
; 2114 :     xmlChar* href;
; 2115 :     xmlChar* next;
; 2116 : 
; 2117 :     nsListDup = xmlStrdup((xmlChar *) arg);
; 2118 :     next = nsListDup;
; 2119 :     while(next != NULL) {

	test	esi, esi
	jne	SHORT $LL2@xmlShellRe
$LN15@xmlShellRe:

; 2146 : 	}
; 2147 :     }
; 2148 : 
; 2149 :     xmlFree(nsListDup);

	mov	eax, DWORD PTR _nsListDup$1$[ebp]
$LN3@xmlShellRe:
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2150 :     return(0);

	xor	eax, eax
	pop	edi

; 2151 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlShellRe:

; 2143 : 	    fprintf(ctxt->output,"Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", prefix, href);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	ebx
	push	OFFSET ??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@
	push	DWORD PTR [eax+20]
	call	_fprintf

; 2144 : 	    xmlFree(nsListDup);

	push	DWORD PTR _nsListDup$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2145 : 	    return(-1);

	or	eax, -1
	pop	edi

; 2151 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlShellRe:

; 2128 : 	    fprintf(ctxt->output, "setns: prefix=[nsuri] required\n");

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
	push	DWORD PTR [eax+20]
	call	_fprintf

; 2129 : 	    xmlFree(nsListDup);

	push	DWORD PTR _nsListDup$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 2130 : 	    return(-1);

	or	eax, -1
	pop	edi

; 2151 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellRegisterNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSetBase
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSetBase PROC					; COMDAT

; 2088 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _arg$[ebp]
	push	DWORD PTR _node$[ebp]
	call	_xmlNodeSetBase
	add	esp, 8
	xor	eax, eax

; 2089 :     xmlNodeSetBase(node, (xmlChar*) arg);
; 2090 :     return (0);
; 2091 : }

	pop	ebp
	ret	0
_xmlShellSetBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathResultCtxt
_TEXT	SEGMENT
tv264 = -8						; size = 8
_ctxt$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlShellPrintXPathResultCtxt PROC			; COMDAT

; 1934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN2@xmlShellPr

; 1935 :     if (!ctxt)
; 1936 :        return;
; 1937 : 
; 1938 :     if (list != NULL) {

	push	ebx
	mov	ebx, DWORD PTR _list$[ebp]
	test	ebx, ebx
	je	$LN25@xmlShellPr

; 1939 :         switch (list->type) {

	mov	eax, DWORD PTR [ebx]
	push	esi
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 3
	ja	$LN15@xmlShellPr
	jmp	DWORD PTR $LN29@xmlShellPr[ecx*4]
$LN9@xmlShellPr:

; 1940 :             case XPATH_NODESET:{
; 1941 : #ifdef LIBXML_OUTPUT_ENABLED
; 1942 :                     int indx;
; 1943 : 
; 1944 :                     if (list->nodesetval) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN10@xmlShellPr

; 1945 :                         for (indx = 0; indx < list->nodesetval->nodeNr;

	xor	esi, esi
	cmp	DWORD PTR [eax], esi
	jle	$LN26@xmlShellPr
	npad	1
$LL6@xmlShellPr:

; 1946 :                              indx++) {
; 1947 :                             xmlShellPrintNodeCtxt(ctxt,

	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+esi*4]
	push	edi
	call	_xmlShellPrintNodeCtxt
	mov	eax, DWORD PTR [ebx+4]
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL6@xmlShellPr
	pop	esi
	pop	ebx
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlShellPr:

; 1948 : 				    list->nodesetval->nodeTab[indx]);
; 1949 :                         }
; 1950 :                     } else {
; 1951 :                         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 1971 :                                 "Is a string:%s\n", list->stringval);
; 1972 :                 break;
; 1973 : 
; 1974 :             default:
; 1975 :                 xmlShellPrintXPathError(list->type, NULL);

	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlShellPr:

; 1798 :     if (boolval)

	mov	esi, DWORD PTR [ebx+8]

; 1952 :                                         "Empty node set\n");
; 1953 :                     }
; 1954 :                     break;
; 1955 : #else
; 1956 : 		    xmlGenericError(xmlGenericErrorContext,
; 1957 : 				    "Node set\n");
; 1958 : #endif /* LIBXML_OUTPUT_ENABLED */
; 1959 :                 }
; 1960 :             case XPATH_BOOLEAN:
; 1961 :                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	mov	edx, OFFSET ??_C@_04HPMIDMKH@True@
	test	esi, esi
	mov	ecx, OFFSET ??_C@_05MKDOIIA@False@
	cmovne	ecx, edx
	push	ecx
	push	OFFSET ??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlShellPr:

; 1962 :                                 "Is a Boolean:%s\n",
; 1963 :                                 xmlBoolToText(list->boolval));
; 1964 :                 break;
; 1965 :             case XPATH_NUMBER:
; 1966 :                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	movsd	xmm0, QWORD PTR [ebx+16]
	mov	esi, eax
	movsd	QWORD PTR tv264[ebp], xmm0
	call	___xmlGenericErrorContext
	movsd	xmm0, QWORD PTR tv264[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlShellPr:

; 1967 :                                 "Is a number:%0g\n", list->floatval);
; 1968 :                 break;
; 1969 :             case XPATH_STRING:
; 1970 :                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+24]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlShellPr:

; 1971 :                                 "Is a string:%s\n", list->stringval);
; 1972 :                 break;
; 1973 : 
; 1974 :             default:
; 1975 :                 xmlShellPrintXPathError(list->type, NULL);

	push	0
	push	eax
	call	_xmlShellPrintXPathError
	add	esp, 8
$LN26@xmlShellPr:
	pop	esi
$LN25@xmlShellPr:
	pop	ebx
$LN2@xmlShellPr:
	pop	edi

; 1976 :         }
; 1977 :     }
; 1978 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@xmlShellPr:
	DD	$LN9@xmlShellPr
	DD	$LN12@xmlShellPr
	DD	$LN13@xmlShellPr
	DD	$LN14@xmlShellPr
_xmlShellPrintXPathResultCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintNodeCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlShellPrintNodeCtxt PROC				; COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlShellPr

; 1893 :     FILE *fp;
; 1894 : 
; 1895 :     if (!node)
; 1896 :         return;
; 1897 :     if (ctxt == NULL)

	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlShellPr

; 1898 : 	fp = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	edi, eax
	jmp	SHORT $LN4@xmlShellPr
$LN3@xmlShellPr:

; 1899 :     else
; 1900 : 	fp = ctxt->output;

	mov	edi, DWORD PTR [edi+20]
$LN4@xmlShellPr:

; 1901 : 
; 1902 :     if (node->type == XML_DOCUMENT_NODE)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	jne	SHORT $LN5@xmlShellPr

; 1903 :         xmlDocDump(fp, (xmlDocPtr) node);

	push	esi
	push	edi
	call	_xmlDocDump
	add	esp, 8

; 1908 : 
; 1909 :     fprintf(fp, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 1910 : }

	pop	ebp
	ret	0
$LN5@xmlShellPr:

; 1904 :     else if (node->type == XML_ATTRIBUTE_NODE)

	cmp	eax, 2
	jne	SHORT $LN7@xmlShellPr

; 1905 :         xmlDebugDumpAttrList(fp, (xmlAttrPtr) node, 0);

	push	0
	push	esi
	push	edi
	call	_xmlDebugDumpAttrList
	jmp	SHORT $LN10@xmlShellPr
$LN7@xmlShellPr:

; 1906 :     else
; 1907 :         xmlElemDump(fp, node->doc, node);

	push	esi
	push	DWORD PTR [esi+32]
	push	edi
	call	_xmlElemDump
$LN10@xmlShellPr:

; 1908 : 
; 1909 :     fprintf(fp, "\n");

	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	edi
$LN1@xmlShellPr:
	pop	esi

; 1910 : }

	pop	ebp
	ret	0
_xmlShellPrintNodeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDTD
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlCtxtDumpDTD PROC					; COMDAT

; 1318 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dtd$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlCtxtDum

; 1319 :     if (dtd == NULL) {
; 1320 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], edi
	jne	SHORT $LN5@xmlCtxtDum

; 1321 :             fprintf(ctxt->output, "DTD is NULL\n");

	push	OFFSET ??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@
	push	DWORD PTR [eax]
	call	_fprintf
	add	esp, 8
	pop	edi

; 1331 :     }
; 1332 : }

	pop	ebp
	ret	0
$LN2@xmlCtxtDum:
	push	esi

; 1322 :         return;
; 1323 :     }
; 1324 :     xmlCtxtDumpDtdNode(ctxt, dtd);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	push	esi
	call	_xmlCtxtDumpDtdNode
	add	esp, 8

; 1325 :     if (dtd->children == NULL)

	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN4@xmlCtxtDum

; 1326 :         fprintf(ctxt->output, "    DTD is empty\n");

	push	OFFSET ??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	edi

; 1331 :     }
; 1332 : }

	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 1327 :     else {
; 1328 :         ctxt->depth++;

	inc	DWORD PTR [esi+108]

; 1329 :         xmlCtxtDumpNodeList(ctxt, dtd->children);

	push	DWORD PTR [edi+12]
	push	esi
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1330 :         ctxt->depth--;

	dec	DWORD PTR [esi+108]
	pop	esi
$LN5@xmlCtxtDum:
	pop	edi

; 1331 :     }
; 1332 : }

	pop	ebp
	ret	0
_xmlCtxtDumpDTD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntities
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpEntities PROC				; COMDAT

; 1286 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN9@xmlCtxtDum

; 1287 :     if (doc == NULL) return;
; 1288 :     xmlCtxtDumpDocHead(ctxt, doc);

	push	ebx
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	push	esi
	call	_xmlCtxtDumpDocHead

; 1289 :     if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {

	mov	eax, DWORD PTR [edi+44]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@xmlCtxtDum
	mov	ebx, DWORD PTR [eax+48]
	test	ebx, ebx
	je	SHORT $LN3@xmlCtxtDum

; 1290 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)
; 1291 :             doc->intSubset->entities;
; 1292 : 
; 1293 :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 1294 :             fprintf(ctxt->output, "Entities in internal subset\n");

	push	OFFSET ??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 1295 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	push	esi
	push	OFFSET _xmlCtxtDumpEntityCallback
	push	ebx
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 1296 :     } else

	jmp	SHORT $LN4@xmlCtxtDum
$LN3@xmlCtxtDum:

; 1297 :         fprintf(ctxt->output, "No entities in internal subset\n");

	push	OFFSET ??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN4@xmlCtxtDum:

; 1298 :     if ((doc->extSubset != NULL) && (doc->extSubset->entities != NULL)) {

	mov	edi, DWORD PTR [edi+48]
	test	edi, edi
	je	SHORT $LN6@xmlCtxtDum
	mov	edi, DWORD PTR [edi+48]
	test	edi, edi
	je	SHORT $LN6@xmlCtxtDum

; 1299 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)
; 1300 :             doc->extSubset->entities;
; 1301 : 
; 1302 :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN8@xmlCtxtDum

; 1303 :             fprintf(ctxt->output, "Entities in external subset\n");

	push	OFFSET ??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN8@xmlCtxtDum:

; 1304 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	push	esi
	push	OFFSET _xmlCtxtDumpEntityCallback
	push	edi
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 1307 : }

	pop	ebp
	ret	0
$LN6@xmlCtxtDum:

; 1305 :     } else if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN11@xmlCtxtDum

; 1306 :         fprintf(ctxt->output, "No entities in external subset\n");

	push	OFFSET ??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN11@xmlCtxtDum:
	pop	esi
	pop	ebx
$LN9@xmlCtxtDum:
	pop	edi

; 1307 : }

	pop	ebp
	ret	0
_xmlCtxtDumpEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntityCallback
_TEXT	SEGMENT
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCtxtDumpEntityCallback PROC				; COMDAT

; 1234 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR _payload$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [esi+124], 0
	jne	$LN6@xmlCtxtDum

; 1235 :     xmlEntityPtr cur = (xmlEntityPtr) payload;
; 1236 :     xmlDebugCtxtPtr ctxt = (xmlDebugCtxtPtr) data;
; 1237 :     if (cur == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlCtxtDum

; 1238 :         if (!ctxt->check)
; 1239 :             fprintf(ctxt->output, "Entity is NULL");

	push	OFFSET ??_C@_0P@LECCLHEJ@Entity?5is?5NULL@

; 1274 :     }
; 1275 : }

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 1240 :         return;
; 1241 :     }
; 1242 :     if (!ctxt->check) {
; 1243 :         fprintf(ctxt->output, "%s : ", (char *) cur->name);

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	push	DWORD PTR [esi]
	call	_fprintf

; 1244 :         switch (cur->etype) {

	mov	eax, DWORD PTR [edi+48]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 4
	ja	SHORT $LN12@xmlCtxtDum
	jmp	DWORD PTR $LN20@xmlCtxtDum[ecx*4]
$LN7@xmlCtxtDum:

; 1245 :             case XML_INTERNAL_GENERAL_ENTITY:
; 1246 :                 fprintf(ctxt->output, "INTERNAL GENERAL, ");

	push	OFFSET ??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 1247 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN8@xmlCtxtDum:

; 1248 :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1249 :                 fprintf(ctxt->output, "EXTERNAL PARSED, ");

	push	OFFSET ??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 1250 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN9@xmlCtxtDum:

; 1251 :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1252 :                 fprintf(ctxt->output, "EXTERNAL UNPARSED, ");

	push	OFFSET ??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 1253 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN10@xmlCtxtDum:

; 1254 :             case XML_INTERNAL_PARAMETER_ENTITY:
; 1255 :                 fprintf(ctxt->output, "INTERNAL PARAMETER, ");

	push	OFFSET ??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 1256 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN11@xmlCtxtDum:

; 1257 :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 1258 :                 fprintf(ctxt->output, "EXTERNAL PARAMETER, ");

	push	OFFSET ??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 1259 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 1260 :             default:
; 1261 : 		xmlDebugErr2(ctxt, XML_CHECK_ENTITY_TYPE,

	push	eax
	push	OFFSET ??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@
	push	5012					; 00001394H
	push	esi
	call	_xmlDebugErr2
	add	esp, 16					; 00000010H
$LN2@xmlCtxtDum:

; 1262 : 			     "Unknown entity type %d\n", cur->etype);
; 1263 :         }
; 1264 :         if (cur->ExternalID != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN13@xmlCtxtDum

; 1265 :             fprintf(ctxt->output, "ID \"%s\"", (char *) cur->ExternalID);

	push	eax
	push	OFFSET ??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN13@xmlCtxtDum:

; 1266 :         if (cur->SystemID != NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN14@xmlCtxtDum

; 1267 :             fprintf(ctxt->output, "SYSTEM \"%s\"", (char *) cur->SystemID);

	push	eax
	push	OFFSET ??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN14@xmlCtxtDum:

; 1268 :         if (cur->orig != NULL)

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN15@xmlCtxtDum

; 1269 :             fprintf(ctxt->output, "\n orig \"%s\"", (char *) cur->orig);

	push	eax
	push	OFFSET ??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN15@xmlCtxtDum:

; 1270 :         if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL))

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN16@xmlCtxtDum
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN16@xmlCtxtDum

; 1271 :             fprintf(ctxt->output, "\n content \"%s\"",

	push	eax
	push	OFFSET ??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtDum:

; 1272 :                     (char *) cur->content);
; 1273 :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@

; 1274 :     }
; 1275 : }

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN6@xmlCtxtDum:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN20@xmlCtxtDum:
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
_xmlCtxtDumpEntityCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocument
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocument PROC				; COMDAT

; 1215 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlCtxtDum

; 1216 :     if (doc == NULL) {
; 1217 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], esi
	jne	SHORT $LN4@xmlCtxtDum

; 1218 :             fprintf(ctxt->output, "DOCUMENT == NULL !\n");

	push	OFFSET ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
	push	DWORD PTR [eax]
	call	_fprintf
	add	esp, 8
	pop	esi

; 1228 :     }
; 1229 : }

	pop	ebp
	ret	0
$LN2@xmlCtxtDum:
	push	edi

; 1219 :         return;
; 1220 :     }
; 1221 :     xmlCtxtDumpDocumentHead(ctxt, doc);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlCtxtDumpDocumentHead

; 1222 :     if (((doc->type == XML_DOCUMENT_NODE) ||
; 1223 :          (doc->type == XML_HTML_DOCUMENT_NODE))
; 1224 :         && (doc->children != NULL)) {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 8
	cmp	eax, 9
	je	SHORT $LN5@xmlCtxtDum
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN7@xmlCtxtDum
$LN5@xmlCtxtDum:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN7@xmlCtxtDum

; 1225 :         ctxt->depth++;

	inc	DWORD PTR [edi+108]

; 1226 :         xmlCtxtDumpNodeList(ctxt, doc->children);

	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1227 :         ctxt->depth--;

	dec	DWORD PTR [edi+108]
$LN7@xmlCtxtDum:
	pop	edi
$LN4@xmlCtxtDum:
	pop	esi

; 1228 :     }
; 1229 : }

	pop	ebp
	ret	0
_xmlCtxtDumpDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocumentHead
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocumentHead PROC				; COMDAT

; 1175 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _doc$[ebp]
	test	edi, edi
	je	$LN9@xmlCtxtDum

; 1176 :     if (doc == NULL) return;
; 1177 :     xmlCtxtDumpDocHead(ctxt, doc);

	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	push	esi
	call	_xmlCtxtDumpDocHead
	add	esp, 8

; 1178 :     if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN8@xmlCtxtDum

; 1179 :         if (doc->name != NULL) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN4@xmlCtxtDum

; 1180 :             fprintf(ctxt->output, "name=");

	push	OFFSET ??_C@_05DFCJAACA@name?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 1181 :             xmlCtxtDumpString(ctxt, BAD_CAST doc->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 1182 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H
$LN4@xmlCtxtDum:

; 1183 :         }
; 1184 :         if (doc->version != NULL) {

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN5@xmlCtxtDum

; 1185 :             fprintf(ctxt->output, "version=");

	push	OFFSET ??_C@_08CLMDBNEB@version?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 1186 :             xmlCtxtDumpString(ctxt, doc->version);

	push	DWORD PTR [edi+56]
	push	esi
	call	_xmlCtxtDumpString

; 1187 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H
$LN5@xmlCtxtDum:

; 1188 :         }
; 1189 :         if (doc->encoding != NULL) {

	cmp	DWORD PTR [edi+60], 0
	je	SHORT $LN6@xmlCtxtDum

; 1190 :             fprintf(ctxt->output, "encoding=");

	push	OFFSET ??_C@_09GHEONEIE@encoding?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 1191 :             xmlCtxtDumpString(ctxt, doc->encoding);

	push	DWORD PTR [edi+60]
	push	esi
	call	_xmlCtxtDumpString

; 1192 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H
$LN6@xmlCtxtDum:

; 1193 :         }
; 1194 :         if (doc->URL != NULL) {

	cmp	DWORD PTR [edi+72], 0
	je	SHORT $LN7@xmlCtxtDum

; 1195 :             fprintf(ctxt->output, "URL=");

	push	OFFSET ??_C@_04LLECLDGK@URL?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 1196 :             xmlCtxtDumpString(ctxt, doc->URL);

	push	DWORD PTR [edi+72]
	push	esi
	call	_xmlCtxtDumpString

; 1197 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H
$LN7@xmlCtxtDum:

; 1198 :         }
; 1199 :         if (doc->standalone)

	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN8@xmlCtxtDum

; 1200 :             fprintf(ctxt->output, "standalone=true\n");

	push	OFFSET ??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN8@xmlCtxtDum:

; 1201 :     }
; 1202 :     if (doc->oldNs != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN11@xmlCtxtDum

; 1203 :         xmlCtxtDumpNamespaceList(ctxt, doc->oldNs);

	push	eax
	push	esi
	call	_xmlCtxtDumpNamespaceList
	add	esp, 8
$LN11@xmlCtxtDum:
	pop	esi
$LN9@xmlCtxtDum:
	pop	edi

; 1204 : }

	pop	ebp
	ret	0
_xmlCtxtDumpDocumentHead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocHead
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocHead PROC				; COMDAT

; 1099 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlCtxtDum

; 1100 :     if (doc == NULL) {
; 1101 :         if (!ctxt->check)

	cmp	DWORD PTR [eax+124], ecx
	jne	$LN23@xmlCtxtDum

; 1102 :             fprintf(ctxt->output, "DOCUMENT == NULL !\n");

	push	OFFSET ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
	push	DWORD PTR [eax]
	call	_fprintf
	add	esp, 8

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN4@xmlCtxtDum:
	push	esi

; 1103 :         return;
; 1104 :     }
; 1105 :     ctxt->node = (xmlNodePtr) doc;

	mov	DWORD PTR [eax+116], ecx

; 1106 : 
; 1107 :     switch (doc->type) {

	mov	esi, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [esi-1]
	cmp	edx, 12					; 0000000cH
	ja	$LN21@xmlCtxtDum
	jmp	DWORD PTR $LN27@xmlCtxtDum[edx*4]
$LN6@xmlCtxtDum:

; 1108 :         case XML_ELEMENT_NODE:
; 1109 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ELEMENT,

	push	OFFSET ??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@
	push	5000					; 00001388H
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN7@xmlCtxtDum:

; 1110 : 	                "Misplaced ELEMENT node\n");
; 1111 :             break;
; 1112 :         case XML_ATTRIBUTE_NODE:
; 1113 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ATTRIBUTE,

	push	OFFSET ??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@
	push	5001					; 00001389H
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN8@xmlCtxtDum:

; 1114 : 	                "Misplaced ATTRIBUTE node\n");
; 1115 :             break;
; 1116 :         case XML_TEXT_NODE:
; 1117 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_TEXT,

	push	OFFSET ??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@
	push	5002					; 0000138aH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN9@xmlCtxtDum:

; 1118 : 	                "Misplaced TEXT node\n");
; 1119 :             break;
; 1120 :         case XML_CDATA_SECTION_NODE:
; 1121 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_CDATA,

	push	OFFSET ??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@
	push	5003					; 0000138bH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN10@xmlCtxtDum:

; 1122 : 	                "Misplaced CDATA node\n");
; 1123 :             break;
; 1124 :         case XML_ENTITY_REF_NODE:
; 1125 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITYREF,

	push	OFFSET ??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@
	push	5004					; 0000138cH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN11@xmlCtxtDum:

; 1126 : 	                "Misplaced ENTITYREF node\n");
; 1127 :             break;
; 1128 :         case XML_ENTITY_NODE:
; 1129 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITY,

	push	OFFSET ??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@
	push	5005					; 0000138dH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN12@xmlCtxtDum:

; 1130 : 	                "Misplaced ENTITY node\n");
; 1131 :             break;
; 1132 :         case XML_PI_NODE:
; 1133 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_PI,

	push	OFFSET ??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@
	push	5006					; 0000138eH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN13@xmlCtxtDum:

; 1134 : 	                "Misplaced PI node\n");
; 1135 :             break;
; 1136 :         case XML_COMMENT_NODE:
; 1137 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_COMMENT,

	push	OFFSET ??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@
	push	5007					; 0000138fH
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN14@xmlCtxtDum:

; 1138 : 	                "Misplaced COMMENT node\n");
; 1139 :             break;
; 1140 :         case XML_DOCUMENT_NODE:
; 1141 : 	    if (!ctxt->check)

	cmp	DWORD PTR [eax+124], 0
	jne	$LN25@xmlCtxtDum

; 1142 : 		fprintf(ctxt->output, "DOCUMENT\n");

	push	OFFSET ??_C@_09JFLEHAPI@DOCUMENT?6@
	push	DWORD PTR [eax]
	call	_fprintf
	add	esp, 8
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN16@xmlCtxtDum:

; 1143 :             break;
; 1144 :         case XML_HTML_DOCUMENT_NODE:
; 1145 : 	    if (!ctxt->check)

	cmp	DWORD PTR [eax+124], 0
	jne	$LN25@xmlCtxtDum

; 1146 : 		fprintf(ctxt->output, "HTML DOCUMENT\n");

	push	OFFSET ??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@
	push	DWORD PTR [eax]
	call	_fprintf
	add	esp, 8
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN18@xmlCtxtDum:

; 1147 :             break;
; 1148 :         case XML_DOCUMENT_TYPE_NODE:
; 1149 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_DOCTYPE,

	push	OFFSET ??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@
	push	5008					; 00001390H
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN19@xmlCtxtDum:

; 1150 : 	                "Misplaced DOCTYPE node\n");
; 1151 :             break;
; 1152 :         case XML_DOCUMENT_FRAG_NODE:
; 1153 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_FRAGMENT,

	push	OFFSET ??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@
	push	5009					; 00001391H
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN20@xmlCtxtDum:

; 1154 : 	                "Misplaced FRAGMENT node\n");
; 1155 :             break;
; 1156 :         case XML_NOTATION_NODE:
; 1157 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_NOTATION,

	push	OFFSET ??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@
	push	5010					; 00001392H
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	esi

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN21@xmlCtxtDum:

; 171  :     __xmlRaiseError(NULL, NULL, NULL,

	push	esi
	push	OFFSET ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+128]
	push	0
	push	0
	push	0
	push	2
	push	5011					; 00001393H
	push	24					; 00000018H
	push	ecx
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN25@xmlCtxtDum:
	pop	esi
$LN23@xmlCtxtDum:

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;
; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	pop	ebp
	ret	0
$LN27@xmlCtxtDum:
	DD	$LN6@xmlCtxtDum
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN14@xmlCtxtDum
	DD	$LN18@xmlCtxtDum
	DD	$LN19@xmlCtxtDum
	DD	$LN20@xmlCtxtDum
	DD	$LN16@xmlCtxtDum
_xmlCtxtDumpDocHead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpNode PROC					; COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlCtxtDum

; 1064 :     if (node == NULL) {
; 1065 :         if (!ctxt->check) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN4@xmlCtxtDum

; 1066 :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 1067 :             fprintf(ctxt->output, "node is NULL\n");

	push	OFFSET ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 1077 :     }
; 1078 : }

	pop	ebp
	ret	0
$LN2@xmlCtxtDum:
	push	edi

; 1068 :         }
; 1069 :         return;
; 1070 :     }
; 1071 :     xmlCtxtDumpOneNode(ctxt, node);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	esi
	push	edi
	call	_xmlCtxtDumpOneNode

; 1072 :     if ((node->type != XML_NAMESPACE_DECL) &&
; 1073 :         (node->children != NULL) && (node->type != XML_ENTITY_REF_NODE)) {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 8
	cmp	eax, 18					; 00000012H
	je	SHORT $LN14@xmlCtxtDum
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN14@xmlCtxtDum
	cmp	eax, 5
	je	SHORT $LN14@xmlCtxtDum

; 1074 :         ctxt->depth++;

	inc	DWORD PTR [edi+108]

; 1075 :         xmlCtxtDumpNodeList(ctxt, node->children);

	mov	esi, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edi+108]

; 1091 :     while (node != NULL) {

	test	esi, esi
	je	SHORT $LN8@xmlCtxtDum
$LL7@xmlCtxtDum:

; 1092 :         xmlCtxtDumpNode(ctxt, node);

	push	esi
	push	edi
	call	_xmlCtxtDumpNode

; 1093 :         node = node->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL7@xmlCtxtDum
	mov	eax, DWORD PTR [edi+108]
$LN8@xmlCtxtDum:

; 1076 :         ctxt->depth--;

	dec	eax
	mov	DWORD PTR [edi+108], eax
$LN14@xmlCtxtDum:
	pop	edi
$LN4@xmlCtxtDum:
	pop	esi

; 1077 :     }
; 1078 : }

	pop	ebp
	ret	0
_xmlCtxtDumpNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpOneNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpOneNode PROC				; COMDAT

; 880  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	jne	SHORT $LN4@xmlCtxtDum

; 881  :     if (node == NULL) {
; 882  :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], edi
	jne	$LN1@xmlCtxtDum

; 883  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 884  :             fprintf(ctxt->output, "node is NULL\n");

	push	OFFSET ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 885  :         }
; 886  :         return;
; 887  :     }
; 888  :     ctxt->node = node;

	mov	DWORD PTR [esi+116], edi

; 889  : 
; 890  :     switch (node->type) {

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 19					; 00000013H
	ja	$LN48@xmlCtxtDum
	jmp	DWORD PTR $LN85@xmlCtxtDum[ecx*4]
$LN6@xmlCtxtDum:

; 891  :         case XML_ELEMENT_NODE:
; 892  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 893  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 894  :                 fprintf(ctxt->output, "ELEMENT ");

	push	OFFSET ??_C@_08EDNNGDCO@ELEMENT?5@
	push	DWORD PTR [esi]
	call	_fprintf

; 895  :                 if ((node->ns != NULL) && (node->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@xmlCtxtDum
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN8@xmlCtxtDum

; 896  :                     xmlCtxtDumpString(ctxt, node->ns->prefix);

	push	eax
	push	esi
	call	_xmlCtxtDumpString

; 897  :                     fprintf(ctxt->output, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN8@xmlCtxtDum:

; 898  :                 }
; 899  :                 xmlCtxtDumpString(ctxt, node->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 900  :                 fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H

; 901  :             }
; 902  :             break;

	jmp	$LN38@xmlCtxtDum
$LN9@xmlCtxtDum:

; 903  :         case XML_ATTRIBUTE_NODE:
; 904  :             if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN10@xmlCtxtDum

; 905  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN10@xmlCtxtDum:

; 906  :             fprintf(ctxt->output, "Error, ATTRIBUTE found here\n");

	push	OFFSET ??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@
$LN83@xmlCtxtDum:

; 1051 : }

	push	DWORD PTR [esi]
	call	_fprintf
	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN11@xmlCtxtDum:

; 907  :             xmlCtxtGenericNodeCheck(ctxt, node);
; 908  :             return;
; 909  :         case XML_TEXT_NODE:
; 910  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 911  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 912  :                 if (node->name == (const xmlChar *) xmlStringTextNoenc)
; 913  :                     fprintf(ctxt->output, "TEXT no enc");
; 914  :                 else
; 915  :                     fprintf(ctxt->output, "TEXT");
; 916  : 		if (ctxt->options & DUMP_TEXT_TYPE) {

	cmp	DWORD PTR [edi+8], OFFSET _xmlStringTextNoenc
	mov	ecx, OFFSET ??_C@_0M@IDMICFJC@TEXT?5no?5enc@
	mov	eax, OFFSET ??_C@_04OEPMCOLO@TEXT@
	cmove	eax, ecx
	push	eax
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
	test	BYTE PTR [esi+136], 1
	je	SHORT $LN15@xmlCtxtDum

; 917  : 		    if (node->content == (xmlChar *) &(node->properties))

	mov	ecx, DWORD PTR [edi+40]
	lea	eax, DWORD PTR [edi+44]
	cmp	ecx, eax
	jne	SHORT $LN17@xmlCtxtDum

; 920  : 			fprintf(ctxt->output, " interned\n");
; 921  : 		    else
; 922  : 			fprintf(ctxt->output, "\n");
; 923  : 		} else

	mov	eax, DWORD PTR [esi]
	mov	ecx, OFFSET ??_C@_09PKJIJFNN@?5compact?6@
	push	ecx
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN38@xmlCtxtDum
$LN17@xmlCtxtDum:

; 918  : 			fprintf(ctxt->output, " compact\n");
; 919  : 		    else if (xmlDictOwns(ctxt->dict, node->content) == 1)

	push	ecx
	push	DWORD PTR [esi+120]
	call	_xmlDictOwns
	add	esp, 8
	mov	edx, OFFSET ??_C@_01EEMJAFIK@?6@
	cmp	eax, 1
	mov	ecx, OFFSET ??_C@_0L@IDACKBMB@?5interned?6@

; 920  : 			fprintf(ctxt->output, " interned\n");
; 921  : 		    else
; 922  : 			fprintf(ctxt->output, "\n");
; 923  : 		} else

	mov	eax, DWORD PTR [esi]
	cmovne	ecx, edx
	push	ecx
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	$LN38@xmlCtxtDum
$LN15@xmlCtxtDum:

; 924  : 		    fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 925  :             }
; 926  :             break;

	jmp	$LN38@xmlCtxtDum
$LN21@xmlCtxtDum:

; 927  :         case XML_CDATA_SECTION_NODE:
; 928  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 929  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 930  :                 fprintf(ctxt->output, "CDATA_SECTION\n");

	push	OFFSET ??_C@_0P@HFCBAJGN@CDATA_SECTION?6@

; 931  :             }
; 932  :             break;

	jmp	$LN81@xmlCtxtDum
$LN23@xmlCtxtDum:

; 933  :         case XML_ENTITY_REF_NODE:
; 934  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 935  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 936  :                 fprintf(ctxt->output, "ENTITY_REF(%s)\n",

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H

; 937  :                         (char *) node->name);
; 938  :             }
; 939  :             break;

	jmp	$LN38@xmlCtxtDum
$LN25@xmlCtxtDum:

; 940  :         case XML_ENTITY_NODE:
; 941  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 942  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 943  :                 fprintf(ctxt->output, "ENTITY\n");

	push	OFFSET ??_C@_07PAIFPHKC@ENTITY?6@

; 944  :             }
; 945  :             break;

	jmp	$LN81@xmlCtxtDum
$LN27@xmlCtxtDum:

; 946  :         case XML_PI_NODE:
; 947  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN38@xmlCtxtDum

; 948  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 949  :                 fprintf(ctxt->output, "PI %s\n", (char *) node->name);

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_06JDGENMBJ@PI?5?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H

; 950  :             }
; 951  :             break;

	jmp	SHORT $LN38@xmlCtxtDum
$LN29@xmlCtxtDum:

; 952  :         case XML_COMMENT_NODE:
; 953  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN38@xmlCtxtDum

; 954  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 955  :                 fprintf(ctxt->output, "COMMENT\n");

	push	OFFSET ??_C@_08OCMMJPAI@COMMENT?6@

; 956  :             }
; 957  :             break;

	jmp	SHORT $LN81@xmlCtxtDum
$LN31@xmlCtxtDum:

; 958  :         case XML_DOCUMENT_NODE:
; 959  :         case XML_HTML_DOCUMENT_NODE:
; 960  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN32@xmlCtxtDum

; 961  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN32@xmlCtxtDum:

; 962  :             }
; 963  :             fprintf(ctxt->output, "Error, DOCUMENT found here\n");

	push	OFFSET ??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@

; 964  :             xmlCtxtGenericNodeCheck(ctxt, node);
; 965  :             return;

	jmp	$LN83@xmlCtxtDum
$LN33@xmlCtxtDum:

; 966  :         case XML_DOCUMENT_TYPE_NODE:
; 967  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN38@xmlCtxtDum

; 968  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 969  :                 fprintf(ctxt->output, "DOCUMENT_TYPE\n");

	push	OFFSET ??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@

; 970  :             }
; 971  :             break;

	jmp	SHORT $LN81@xmlCtxtDum
$LN35@xmlCtxtDum:

; 972  :         case XML_DOCUMENT_FRAG_NODE:
; 973  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN38@xmlCtxtDum

; 974  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 975  :                 fprintf(ctxt->output, "DOCUMENT_FRAG\n");

	push	OFFSET ??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@

; 976  :             }
; 977  :             break;

	jmp	SHORT $LN81@xmlCtxtDum
$LN37@xmlCtxtDum:

; 978  :         case XML_NOTATION_NODE:
; 979  :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN38@xmlCtxtDum

; 980  :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 981  :                 fprintf(ctxt->output, "NOTATION\n");

	push	OFFSET ??_C@_09CPFNJPEP@NOTATION?6@
$LN81@xmlCtxtDum:

; 1014 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,
; 1015 : 	                "Unknown node type %d\n", node->type);
; 1016 :             return;
; 1017 :     }
; 1018 :     if (node->doc == NULL) {

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN38@xmlCtxtDum:
	cmp	DWORD PTR [edi+32], 0
	jne	SHORT $LN50@xmlCtxtDum

; 1019 :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN51@xmlCtxtDum

; 1020 :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN51@xmlCtxtDum:

; 1021 :         }
; 1022 :         fprintf(ctxt->output, "PBM: doc == NULL !!!\n");

	push	OFFSET ??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN50@xmlCtxtDum:

; 1023 :     }
; 1024 :     ctxt->depth++;

	inc	DWORD PTR [esi+108]

; 1025 :     if ((node->type == XML_ELEMENT_NODE) && (node->nsDef != NULL))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	jne	SHORT $LN53@xmlCtxtDum
	mov	ecx, DWORD PTR [edi+48]
	test	ecx, ecx
	je	SHORT $LN52@xmlCtxtDum

; 1026 :         xmlCtxtDumpNamespaceList(ctxt, node->nsDef);

	push	ecx
	push	esi
	call	_xmlCtxtDumpNamespaceList
	mov	eax, DWORD PTR [edi+4]
	add	esp, 8
$LN52@xmlCtxtDum:

; 1027 :     if ((node->type == XML_ELEMENT_NODE) && (node->properties != NULL))

	cmp	eax, 1
	jne	SHORT $LN53@xmlCtxtDum
	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	$LN77@xmlCtxtDum

; 1028 :         xmlCtxtDumpAttrList(ctxt, node->properties);

	push	eax
	push	esi
	call	_xmlCtxtDumpAttrList
	mov	eax, DWORD PTR [edi+4]
	add	esp, 8
$LN53@xmlCtxtDum:

; 1029 :     if (node->type != XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	je	SHORT $LN54@xmlCtxtDum

; 1030 :         if ((node->type != XML_ELEMENT_NODE) && (node->content != NULL)) {

	cmp	eax, 1
	je	$LN77@xmlCtxtDum
	cmp	DWORD PTR [edi+40], 0
	je	$LN77@xmlCtxtDum

; 1031 :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN77@xmlCtxtDum

; 1032 :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 1033 :                 fprintf(ctxt->output, "content=");

	push	OFFSET ??_C@_08INNCGMHH@content?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 1034 :                 xmlCtxtDumpString(ctxt, node->content);

	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlCtxtDumpString

; 1035 :                 fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 1043 :             xmlCtxtDumpEntity(ctxt, ent);
; 1044 :     }
; 1045 :     ctxt->depth--;

	dec	DWORD PTR [esi+108]
	add	esp, 28					; 0000001cH

; 1046 : 
; 1047 :     /*
; 1048 :      * Do a bit of checking
; 1049 :      */
; 1050 :     xmlCtxtGenericNodeCheck(ctxt, node);

	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN54@xmlCtxtDum:
	push	ebx

; 1036 :             }
; 1037 :         }
; 1038 :     } else {
; 1039 :         xmlEntityPtr ent;
; 1040 : 
; 1041 :         ent = xmlGetDocEntity(node->doc, node->name);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+32]
	call	_xmlGetDocEntity
	mov	ebx, eax
	add	esp, 8

; 1042 :         if (ent != NULL)

	test	ebx, ebx
	je	$LN80@xmlCtxtDum

; 765  :     xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 766  : 
; 767  :     if (ent == NULL) {
; 768  :         if (!ctxt->check)
; 769  :             fprintf(ctxt->output, "Entity is NULL\n");
; 770  :         return;
; 771  :     }
; 772  :     if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN80@xmlCtxtDum

; 773  :         switch (ent->etype) {

	mov	ecx, DWORD PTR [ebx+48]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 4
	ja	SHORT $LN73@xmlCtxtDum
	jmp	DWORD PTR $LN86@xmlCtxtDum[eax*4]
$LN68@xmlCtxtDum:

; 774  :             case XML_INTERNAL_GENERAL_ENTITY:
; 775  :                 fprintf(ctxt->output, "INTERNAL_GENERAL_ENTITY ");

	push	OFFSET ??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 776  :                 break;

	jmp	SHORT $LN63@xmlCtxtDum
$LN69@xmlCtxtDum:

; 777  :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 778  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_PARSED_ENTITY ");

	push	OFFSET ??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 779  :                 break;

	jmp	SHORT $LN63@xmlCtxtDum
$LN70@xmlCtxtDum:

; 780  :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 781  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_UNPARSED_ENTITY ");

	push	OFFSET ??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 782  :                 break;

	jmp	SHORT $LN63@xmlCtxtDum
$LN71@xmlCtxtDum:

; 783  :             case XML_INTERNAL_PARAMETER_ENTITY:
; 784  :                 fprintf(ctxt->output, "INTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 785  :                 break;

	jmp	SHORT $LN63@xmlCtxtDum
$LN72@xmlCtxtDum:

; 786  :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 787  :                 fprintf(ctxt->output, "EXTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 788  :                 break;

	jmp	SHORT $LN63@xmlCtxtDum
$LN73@xmlCtxtDum:

; 789  :             default:
; 790  :                 fprintf(ctxt->output, "ENTITY_%d ! ", (int) ent->etype);

	push	ecx
	push	OFFSET ??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN63@xmlCtxtDum:

; 791  :         }
; 792  :         fprintf(ctxt->output, "%s\n", ent->name);

	push	DWORD PTR [ebx+8]
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH

; 793  :         if (ent->ExternalID) {

	cmp	DWORD PTR [ebx+52], 0
	je	SHORT $LN74@xmlCtxtDum

; 794  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 795  :             fprintf(ctxt->output, "ExternalID=%s\n",

	push	DWORD PTR [ebx+52]
	push	OFFSET ??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN74@xmlCtxtDum:

; 796  :                     (char *) ent->ExternalID);
; 797  :         }
; 798  :         if (ent->SystemID) {

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN75@xmlCtxtDum

; 799  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 800  :             fprintf(ctxt->output, "SystemID=%s\n", (char *) ent->SystemID);

	push	DWORD PTR [ebx+56]
	push	OFFSET ??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN75@xmlCtxtDum:

; 801  :         }
; 802  :         if (ent->URI) {

	cmp	DWORD PTR [ebx+64], 0
	je	SHORT $LN76@xmlCtxtDum

; 803  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 804  :             fprintf(ctxt->output, "URI=%s\n", (char *) ent->URI);

	push	DWORD PTR [ebx+64]
	push	OFFSET ??_C@_07HJADGDLG@URI?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN76@xmlCtxtDum:

; 805  :         }
; 806  :         if (ent->content) {

	cmp	DWORD PTR [ebx+40], 0
	je	SHORT $LN80@xmlCtxtDum

; 807  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 808  :             fprintf(ctxt->output, "content=");

	push	OFFSET ??_C@_08INNCGMHH@content?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 809  :             xmlCtxtDumpString(ctxt, ent->content);

	push	DWORD PTR [ebx+40]
	push	esi
	call	_xmlCtxtDumpString

; 810  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 28					; 0000001cH
$LN80@xmlCtxtDum:
	pop	ebx
$LN77@xmlCtxtDum:

; 1043 :             xmlCtxtDumpEntity(ctxt, ent);
; 1044 :     }
; 1045 :     ctxt->depth--;

	dec	DWORD PTR [esi+108]

; 1046 : 
; 1047 :     /*
; 1048 :      * Do a bit of checking
; 1049 :      */
; 1050 :     xmlCtxtGenericNodeCheck(ctxt, node);

	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN39@xmlCtxtDum:

; 982  :             }
; 983  :             break;
; 984  :         case XML_DTD_NODE:
; 985  :             xmlCtxtDumpDtdNode(ctxt, (xmlDtdPtr) node);

	push	edi
	push	esi
	call	_xmlCtxtDumpDtdNode
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN40@xmlCtxtDum:

; 986  :             return;
; 987  :         case XML_ELEMENT_DECL:
; 988  :             xmlCtxtDumpElemDecl(ctxt, (xmlElementPtr) node);

	push	edi
	push	esi
	call	_xmlCtxtDumpElemDecl
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN41@xmlCtxtDum:

; 989  :             return;
; 990  :         case XML_ATTRIBUTE_DECL:
; 991  :             xmlCtxtDumpAttrDecl(ctxt, (xmlAttributePtr) node);

	push	edi
	push	esi
	call	_xmlCtxtDumpAttrDecl
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN42@xmlCtxtDum:

; 992  :             return;
; 993  :         case XML_ENTITY_DECL:
; 994  :             xmlCtxtDumpEntityDecl(ctxt, (xmlEntityPtr) node);

	push	edi
	push	esi
	call	_xmlCtxtDumpEntityDecl
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN43@xmlCtxtDum:

; 995  :             return;
; 996  :         case XML_NAMESPACE_DECL:
; 997  :             xmlCtxtDumpNamespace(ctxt, (xmlNsPtr) node);

	push	edi
	push	esi
	call	_xmlCtxtDumpNamespace
	add	esp, 8
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN44@xmlCtxtDum:

; 998  :             return;
; 999  :         case XML_XINCLUDE_START:
; 1000 :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN1@xmlCtxtDum

; 1001 :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 1002 :                 fprintf(ctxt->output, "INCLUDE START\n");

	push	OFFSET ??_C@_0P@MIINKGDA@INCLUDE?5START?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN46@xmlCtxtDum:

; 1003 :             }
; 1004 :             return;
; 1005 :         case XML_XINCLUDE_END:
; 1006 :             if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN1@xmlCtxtDum

; 1007 :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 1008 :                 fprintf(ctxt->output, "INCLUDE END\n");

	push	OFFSET ??_C@_0N@DKMEHMHH@INCLUDE?5END?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
$LN48@xmlCtxtDum:

; 1009 :             }
; 1010 :             return;
; 1011 :         default:
; 1012 :             if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN49@xmlCtxtDum

; 1013 :                 xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces
	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	mov	edi, DWORD PTR [esi+116]
$LN49@xmlCtxtDum:

; 171  :     __xmlRaiseError(NULL, NULL, NULL,

	push	eax
	push	OFFSET ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5011					; 00001393H
	push	24					; 00000018H
	push	edi
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlCtxtDum:
	pop	edi

; 1051 : }

	pop	esi
	pop	ebp
	ret	0
	npad	3
$LN85@xmlCtxtDum:
	DD	$LN6@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
	DD	$LN21@xmlCtxtDum
	DD	$LN23@xmlCtxtDum
	DD	$LN25@xmlCtxtDum
	DD	$LN27@xmlCtxtDum
	DD	$LN29@xmlCtxtDum
	DD	$LN31@xmlCtxtDum
	DD	$LN33@xmlCtxtDum
	DD	$LN35@xmlCtxtDum
	DD	$LN37@xmlCtxtDum
	DD	$LN31@xmlCtxtDum
	DD	$LN39@xmlCtxtDum
	DD	$LN40@xmlCtxtDum
	DD	$LN41@xmlCtxtDum
	DD	$LN42@xmlCtxtDum
	DD	$LN43@xmlCtxtDum
	DD	$LN44@xmlCtxtDum
	DD	$LN46@xmlCtxtDum
$LN86@xmlCtxtDum:
	DD	$LN68@xmlCtxtDum
	DD	$LN69@xmlCtxtDum
	DD	$LN70@xmlCtxtDum
	DD	$LN71@xmlCtxtDum
	DD	$LN72@xmlCtxtDum
_xmlCtxtDumpOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttrList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttrList PROC				; COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _attr$[ebp]
	test	ebx, ebx
	je	$LN3@xmlCtxtDum
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	npad	2
$LL2@xmlCtxtDum:

; 140  :     if (ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN16@xmlCtxtDum

; 141  :         return;
; 142  :     if ((ctxt->output != NULL) && (ctxt->depth > 0)) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN16@xmlCtxtDum
	mov	edx, DWORD PTR [esi+108]
	test	edx, edx
	jle	SHORT $LN16@xmlCtxtDum

; 143  :         if (ctxt->depth < 50)

	cmp	edx, 50					; 00000032H
	jge	SHORT $LN15@xmlCtxtDum

; 144  :             fprintf(ctxt->output, "%s", &ctxt->shift[100 - 2 * ctxt->depth]);

	mov	eax, 52					; 00000034H
	sub	eax, edx
	lea	eax, DWORD PTR [esi+eax*2]
	jmp	SHORT $LN43@xmlCtxtDum
$LN15@xmlCtxtDum:

; 145  :         else
; 146  :             fprintf(ctxt->output, "%s", ctxt->shift);

	lea	eax, DWORD PTR [esi+4]
$LN43@xmlCtxtDum:

; 828  :     if (attr == NULL) {

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtDum:
	mov	eax, DWORD PTR [esi+124]
	test	ebx, ebx
	jne	SHORT $LN6@xmlCtxtDum

; 829  :         if (!ctxt->check)

	test	eax, eax
	jne	$LN5@xmlCtxtDum

; 830  :             fprintf(ctxt->output, "Attr is NULL");

	push	OFFSET ??_C@_0N@KCLOKEKK@Attr?5is?5NULL@
	push	DWORD PTR [esi]
	call	_fprintf

; 831  :         return;

	jmp	$LN44@xmlCtxtDum
$LN6@xmlCtxtDum:

; 832  :     }
; 833  :     if (!ctxt->check) {

	test	eax, eax
	jne	SHORT $LN9@xmlCtxtDum

; 834  :         fprintf(ctxt->output, "ATTRIBUTE ");

	push	OFFSET ??_C@_0L@MPLGGCMF@ATTRIBUTE?5@
	push	DWORD PTR [esi]
	call	_fprintf

; 835  : 	xmlCtxtDumpString(ctxt, attr->name);

	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlCtxtDumpString

; 836  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H

; 837  :         if (attr->children != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN9@xmlCtxtDum

; 838  :             ctxt->depth++;

	inc	DWORD PTR [esi+108]

; 839  :             xmlCtxtDumpNodeList(ctxt, attr->children);

	mov	edi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [esi+108]

; 1091 :     while (node != NULL) {

	test	edi, edi
	je	SHORT $LN20@xmlCtxtDum
$LL19@xmlCtxtDum:

; 1092 :         xmlCtxtDumpNode(ctxt, node);

	push	edi
	push	esi
	call	_xmlCtxtDumpNode

; 1093 :         node = node->next;

	mov	edi, DWORD PTR [edi+24]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LL19@xmlCtxtDum
	mov	eax, DWORD PTR [esi+108]
$LN20@xmlCtxtDum:

; 840  :             ctxt->depth--;

	dec	eax
	mov	DWORD PTR [esi+108], eax
$LN9@xmlCtxtDum:

; 841  :         }
; 842  :     }
; 843  :     if (attr->name == NULL)

	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN33@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5015					; 00001397H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN33@xmlCtxtDum:

; 850  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	esi
	call	_xmlCtxtGenericNodeCheck
$LN44@xmlCtxtDum:

; 864  :     while (attr != NULL) {
; 865  :         xmlCtxtDumpAttr(ctxt, attr);
; 866  :         attr = attr->next;

	add	esp, 8
$LN5@xmlCtxtDum:
	mov	ebx, DWORD PTR [ebx+24]
	test	ebx, ebx
	jne	$LL2@xmlCtxtDum
	pop	edi
	pop	esi
$LN3@xmlCtxtDum:
	pop	ebx

; 867  :     }
; 868  : }

	pop	ebp
	ret	0
_xmlCtxtDumpAttrList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttr PROC					; COMDAT

; 825  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	ebx, DWORD PTR _attr$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR [esi+124]
	test	ebx, ebx
	jne	SHORT $LN2@xmlCtxtDum

; 826  :     xmlCtxtDumpSpaces(ctxt);
; 827  : 
; 828  :     if (attr == NULL) {
; 829  :         if (!ctxt->check)

	test	eax, eax
	jne	$LN1@xmlCtxtDum

; 830  :             fprintf(ctxt->output, "Attr is NULL");

	push	OFFSET ??_C@_0N@KCLOKEKK@Attr?5is?5NULL@
	push	DWORD PTR [esi]
	call	_fprintf

; 851  : }

	add	esp, 8
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlCtxtDum:

; 831  :         return;
; 832  :     }
; 833  :     if (!ctxt->check) {

	test	eax, eax
	jne	SHORT $LN5@xmlCtxtDum

; 834  :         fprintf(ctxt->output, "ATTRIBUTE ");

	push	OFFSET ??_C@_0L@MPLGGCMF@ATTRIBUTE?5@
	push	DWORD PTR [esi]
	call	_fprintf

; 835  : 	xmlCtxtDumpString(ctxt, attr->name);

	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlCtxtDumpString

; 836  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H

; 837  :         if (attr->children != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN5@xmlCtxtDum

; 838  :             ctxt->depth++;

	inc	DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+108]
	push	edi

; 839  :             xmlCtxtDumpNodeList(ctxt, attr->children);

	mov	edi, DWORD PTR [ebx+12]

; 1091 :     while (node != NULL) {

	test	edi, edi
	je	SHORT $LN10@xmlCtxtDum
	npad	4
$LL9@xmlCtxtDum:

; 1092 :         xmlCtxtDumpNode(ctxt, node);

	push	edi
	push	esi
	call	_xmlCtxtDumpNode

; 1093 :         node = node->next;

	mov	edi, DWORD PTR [edi+24]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LL9@xmlCtxtDum
	mov	eax, DWORD PTR [esi+108]
$LN10@xmlCtxtDum:

; 840  :             ctxt->depth--;

	dec	eax
	mov	DWORD PTR [esi+108], eax
	pop	edi
$LN5@xmlCtxtDum:

; 841  :         }
; 842  :     }
; 843  :     if (attr->name == NULL)

	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN23@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5015					; 00001397H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN23@xmlCtxtDum:

; 844  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,
; 845  : 	            "Attribute has no name");
; 846  : 
; 847  :     /*
; 848  :      * Do a bit of checking
; 849  :      */
; 850  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	esi
	call	_xmlCtxtGenericNodeCheck

; 851  : }

	add	esp, 8
$LN1@xmlCtxtDum:
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlCtxtDumpAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntity
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlCtxtDumpEntity PROC					; COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR _ent$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlCtxtDumpSpaces
	add	esp, 4
	cmp	DWORD PTR [esi+124], 0
	jne	$LN16@xmlCtxtDum

; 765  :     xmlCtxtDumpSpaces(ctxt);
; 766  : 
; 767  :     if (ent == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlCtxtDum

; 768  :         if (!ctxt->check)
; 769  :             fprintf(ctxt->output, "Entity is NULL\n");

	push	OFFSET ??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
	pop	edi

; 811  :         }
; 812  :     }
; 813  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 770  :         return;
; 771  :     }
; 772  :     if (!ctxt->check) {
; 773  :         switch (ent->etype) {

	mov	ecx, DWORD PTR [edi+48]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 4
	ja	SHORT $LN12@xmlCtxtDum
	jmp	DWORD PTR $LN19@xmlCtxtDum[eax*4]
$LN7@xmlCtxtDum:

; 774  :             case XML_INTERNAL_GENERAL_ENTITY:
; 775  :                 fprintf(ctxt->output, "INTERNAL_GENERAL_ENTITY ");

	push	OFFSET ??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 776  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN8@xmlCtxtDum:

; 777  :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 778  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_PARSED_ENTITY ");

	push	OFFSET ??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 779  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN9@xmlCtxtDum:

; 780  :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 781  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_UNPARSED_ENTITY ");

	push	OFFSET ??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 782  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN10@xmlCtxtDum:

; 783  :             case XML_INTERNAL_PARAMETER_ENTITY:
; 784  :                 fprintf(ctxt->output, "INTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 785  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN11@xmlCtxtDum:

; 786  :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 787  :                 fprintf(ctxt->output, "EXTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 788  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 789  :             default:
; 790  :                 fprintf(ctxt->output, "ENTITY_%d ! ", (int) ent->etype);

	push	ecx
	push	OFFSET ??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xmlCtxtDum:

; 791  :         }
; 792  :         fprintf(ctxt->output, "%s\n", ent->name);

	push	DWORD PTR [edi+8]
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH

; 793  :         if (ent->ExternalID) {

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN13@xmlCtxtDum

; 794  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 795  :             fprintf(ctxt->output, "ExternalID=%s\n",

	push	DWORD PTR [edi+52]
	push	OFFSET ??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN13@xmlCtxtDum:

; 796  :                     (char *) ent->ExternalID);
; 797  :         }
; 798  :         if (ent->SystemID) {

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN14@xmlCtxtDum

; 799  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 800  :             fprintf(ctxt->output, "SystemID=%s\n", (char *) ent->SystemID);

	push	DWORD PTR [edi+56]
	push	OFFSET ??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN14@xmlCtxtDum:

; 801  :         }
; 802  :         if (ent->URI) {

	cmp	DWORD PTR [edi+64], 0
	je	SHORT $LN15@xmlCtxtDum

; 803  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 804  :             fprintf(ctxt->output, "URI=%s\n", (char *) ent->URI);

	push	DWORD PTR [edi+64]
	push	OFFSET ??_C@_07HJADGDLG@URI?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN15@xmlCtxtDum:

; 805  :         }
; 806  :         if (ent->content) {

	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN16@xmlCtxtDum

; 807  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 808  :             fprintf(ctxt->output, "content=");

	push	OFFSET ??_C@_08INNCGMHH@content?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 809  :             xmlCtxtDumpString(ctxt, ent->content);

	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlCtxtDumpString

; 810  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 28					; 0000001cH
$LN16@xmlCtxtDum:

; 811  :         }
; 812  :     }
; 813  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
	npad	2
$LN19@xmlCtxtDum:
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
_xmlCtxtDumpEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNamespaceList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlCtxtDumpNamespaceList PROC				; COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	$LN3@xmlCtxtDum
	npad	3
$LL2@xmlCtxtDum:

; 140  :     if (ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN21@xmlCtxtDum

; 141  :         return;
; 142  :     if ((ctxt->output != NULL) && (ctxt->depth > 0)) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN21@xmlCtxtDum
	mov	edx, DWORD PTR [esi+108]
	test	edx, edx
	jle	SHORT $LN21@xmlCtxtDum

; 143  :         if (ctxt->depth < 50)

	cmp	edx, 50					; 00000032H
	jge	SHORT $LN20@xmlCtxtDum

; 144  :             fprintf(ctxt->output, "%s", &ctxt->shift[100 - 2 * ctxt->depth]);

	mov	eax, 52					; 00000034H
	sub	eax, edx
	lea	eax, DWORD PTR [esi+eax*2]
	jmp	SHORT $LN33@xmlCtxtDum
$LN20@xmlCtxtDum:

; 145  :         else
; 146  :             fprintf(ctxt->output, "%s", ctxt->shift);

	lea	eax, DWORD PTR [esi+4]
$LN33@xmlCtxtDum:

; 721  :     if (ns == NULL) {

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN21@xmlCtxtDum:
	test	edi, edi
	jne	SHORT $LN6@xmlCtxtDum

; 722  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], edi
	jne	$LN13@xmlCtxtDum

; 723  :             fprintf(ctxt->output, "namespace node is NULL\n");

	push	OFFSET ??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8

; 724  :         return;

	jmp	$LN13@xmlCtxtDum
$LN6@xmlCtxtDum:

; 725  :     }
; 726  :     if (ns->type != XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN8@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@
	inc	DWORD PTR [esi+128]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	5027					; 000013a3H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]

; 729  :         return;

	jmp	SHORT $LN34@xmlCtxtDum
$LN8@xmlCtxtDum:

; 730  :     }
; 731  :     if (ns->href == NULL) {

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN9@xmlCtxtDum

; 732  :         if (ns->prefix != NULL)

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [esi+116]
	inc	DWORD PTR [esi+128]
	test	ecx, ecx
	je	SHORT $LN11@xmlCtxtDum

; 181  :     __xmlRaiseError(NULL, NULL, NULL,

	push	ecx
	push	OFFSET ??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@

; 733  : 	    xmlDebugErr3(ctxt, XML_CHECK_NO_HREF,

	jmp	SHORT $LN35@xmlCtxtDum
$LN11@xmlCtxtDum:

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
$LN35@xmlCtxtDum:

; 756  :     while (ns != NULL) {
; 757  :         xmlCtxtDumpNamespace(ctxt, ns);
; 758  :         ns = ns->next;

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	5028					; 000013a4H
	push	24					; 00000018H
	push	eax
$LN34@xmlCtxtDum:
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	jmp	SHORT $LN13@xmlCtxtDum
$LN9@xmlCtxtDum:

; 740  :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN13@xmlCtxtDum

; 741  :             if (ns->prefix != NULL)

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN14@xmlCtxtDum

; 742  :                 fprintf(ctxt->output, "namespace %s href=",

	push	ecx
	push	OFFSET ??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@xmlCtxtDum
$LN14@xmlCtxtDum:

; 743  :                         (char *) ns->prefix);
; 744  :             else
; 745  :                 fprintf(ctxt->output, "default namespace href=");

	push	OFFSET ??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@
	push	eax
	call	_fprintf
	add	esp, 8
$LN15@xmlCtxtDum:

; 746  : 
; 747  :             xmlCtxtDumpString(ctxt, ns->href);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 748  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN13@xmlCtxtDum:

; 756  :     while (ns != NULL) {
; 757  :         xmlCtxtDumpNamespace(ctxt, ns);
; 758  :         ns = ns->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	$LL2@xmlCtxtDum
$LN3@xmlCtxtDum:
	pop	edi

; 759  :     }
; 760  : }

	pop	esi
	pop	ebp
	ret	0
_xmlCtxtDumpNamespaceList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNamespace
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlCtxtDumpNamespace PROC				; COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	edi, DWORD PTR _ns$[ebp]
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlCtxtDum

; 719  :     xmlCtxtDumpSpaces(ctxt);
; 720  : 
; 721  :     if (ns == NULL) {
; 722  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], edi
	jne	$LN9@xmlCtxtDum

; 723  :             fprintf(ctxt->output, "namespace node is NULL\n");

	push	OFFSET ??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
	pop	edi

; 749  :         }
; 750  :     }
; 751  : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlCtxtDum:

; 724  :         return;
; 725  :     }
; 726  :     if (ns->type != XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN4@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5027					; 000013a3H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 749  :         }
; 750  :     }
; 751  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 727  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_NS_DECL,
; 728  : 	            "Node is not a namespace declaration");
; 729  :         return;
; 730  :     }
; 731  :     if (ns->href == NULL) {

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN5@xmlCtxtDum

; 732  :         if (ns->prefix != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN7@xmlCtxtDum

; 733  : 	    xmlDebugErr3(ctxt, XML_CHECK_NO_HREF,

	push	eax
	push	OFFSET ??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@
	push	5028					; 000013a4H
	push	esi
	call	_xmlDebugErr3

; 749  :         }
; 750  :     }
; 751  : }

	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlCtxtDum:

; 734  :                     "Incomplete namespace %s href=NULL\n",
; 735  :                     (char *) ns->prefix);
; 736  :         else
; 737  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_HREF,

	push	OFFSET ??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@
	push	5028					; 000013a4H
	push	esi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	pop	edi

; 749  :         }
; 750  :     }
; 751  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlCtxtDum:

; 738  :                     "Incomplete default namespace href=NULL\n");
; 739  :     } else {
; 740  :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN9@xmlCtxtDum

; 741  :             if (ns->prefix != NULL)

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN10@xmlCtxtDum

; 742  :                 fprintf(ctxt->output, "namespace %s href=",

	push	ecx
	push	OFFSET ??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@xmlCtxtDum
$LN10@xmlCtxtDum:

; 743  :                         (char *) ns->prefix);
; 744  :             else
; 745  :                 fprintf(ctxt->output, "default namespace href=");

	push	OFFSET ??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@
	push	eax
	call	_fprintf
	add	esp, 8
$LN11@xmlCtxtDum:

; 746  : 
; 747  :             xmlCtxtDumpString(ctxt, ns->href);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 748  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 749  :         }
; 750  :     }
; 751  : }

	add	esp, 16					; 00000010H
$LN9@xmlCtxtDum:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlCtxtDumpNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntityDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlCtxtDumpEntityDecl PROC				; COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	edi, DWORD PTR _ent$[ebp]
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN4@xmlCtxtDum

; 646  :     xmlCtxtDumpSpaces(ctxt);
; 647  : 
; 648  :     if (ent == NULL) {
; 649  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], edi
	jne	$LN1@xmlCtxtDum

; 650  :             fprintf(ctxt->output, "Entity declaration is NULL\n");

	push	OFFSET ??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 714  : }

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 651  :         return;
; 652  :     }
; 653  :     if (ent->type != XML_ENTITY_DECL) {

	cmp	DWORD PTR [edi+4], 17			; 00000011H
	je	SHORT $LN6@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5026					; 000013a2H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 714  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlCtxtDum:

; 654  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ENTITY_DECL,
; 655  : 	            "Node is not an entity declaration");
; 656  :         return;
; 657  :     }
; 658  :     if (ent->name != NULL) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN7@xmlCtxtDum

; 659  :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN20@xmlCtxtDum

; 660  :             fprintf(ctxt->output, "ENTITYDECL(");

	push	OFFSET ??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@
	push	DWORD PTR [esi]
	call	_fprintf

; 661  :             xmlCtxtDumpString(ctxt, ent->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 662  :             fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H

; 663  :         }
; 664  :     } else

	jmp	SHORT $LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 665  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@
	push	5015					; 00001397H
	push	esi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 666  : 	            "Entity declaration has no name");
; 667  :     if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN20@xmlCtxtDum

; 668  :         switch (ent->etype) {

	mov	eax, DWORD PTR [edi+48]
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN2@xmlCtxtDum
	jmp	DWORD PTR $LN28@xmlCtxtDum[eax*4]
$LN11@xmlCtxtDum:

; 669  :             case XML_INTERNAL_GENERAL_ENTITY:
; 670  :                 fprintf(ctxt->output, ", internal\n");

	push	OFFSET ??_C@_0M@PBKIGNE@?0?5internal?6@

; 671  :                 break;

	jmp	SHORT $LN26@xmlCtxtDum
$LN12@xmlCtxtDum:

; 672  :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 673  :                 fprintf(ctxt->output, ", external parsed\n");

	push	OFFSET ??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@

; 674  :                 break;

	jmp	SHORT $LN26@xmlCtxtDum
$LN13@xmlCtxtDum:

; 675  :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 676  :                 fprintf(ctxt->output, ", unparsed\n");

	push	OFFSET ??_C@_0M@FLIMFIIH@?0?5unparsed?6@

; 677  :                 break;

	jmp	SHORT $LN26@xmlCtxtDum
$LN14@xmlCtxtDum:

; 678  :             case XML_INTERNAL_PARAMETER_ENTITY:
; 679  :                 fprintf(ctxt->output, ", parameter\n");

	push	OFFSET ??_C@_0N@NMAFEAAG@?0?5parameter?6@

; 680  :                 break;

	jmp	SHORT $LN26@xmlCtxtDum
$LN15@xmlCtxtDum:

; 681  :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 682  :                 fprintf(ctxt->output, ", external parameter\n");

	push	OFFSET ??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@

; 683  :                 break;

	jmp	SHORT $LN26@xmlCtxtDum
$LN16@xmlCtxtDum:

; 684  :             case XML_INTERNAL_PREDEFINED_ENTITY:
; 685  :                 fprintf(ctxt->output, ", predefined\n");

	push	OFFSET ??_C@_0O@OLDJNJL@?0?5predefined?6@
$LN26@xmlCtxtDum:

; 686  :                 break;
; 687  :         }
; 688  :         if (ent->ExternalID) {

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:
	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN17@xmlCtxtDum

; 689  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 690  :             fprintf(ctxt->output, " ExternalID=%s\n",

	push	DWORD PTR [edi+52]
	push	OFFSET ??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN17@xmlCtxtDum:

; 691  :                     (char *) ent->ExternalID);
; 692  :         }
; 693  :         if (ent->SystemID) {

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN18@xmlCtxtDum

; 694  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 695  :             fprintf(ctxt->output, " SystemID=%s\n",

	push	DWORD PTR [edi+56]
	push	OFFSET ??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN18@xmlCtxtDum:

; 696  :                     (char *) ent->SystemID);
; 697  :         }
; 698  :         if (ent->URI != NULL) {

	cmp	DWORD PTR [edi+64], 0
	je	SHORT $LN19@xmlCtxtDum

; 699  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 700  :             fprintf(ctxt->output, " URI=%s\n", (char *) ent->URI);

	push	DWORD PTR [edi+64]
	push	OFFSET ??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 16					; 00000010H
$LN19@xmlCtxtDum:

; 701  :         }
; 702  :         if (ent->content) {

	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN20@xmlCtxtDum

; 703  :             xmlCtxtDumpSpaces(ctxt);

	push	esi
	call	_xmlCtxtDumpSpaces

; 704  :             fprintf(ctxt->output, " content=");

	push	OFFSET ??_C@_09MHAMBDHP@?5content?$DN@
	push	DWORD PTR [esi]
	call	_fprintf

; 705  :             xmlCtxtDumpString(ctxt, ent->content);

	push	DWORD PTR [edi+40]
	push	esi
	call	_xmlCtxtDumpString

; 706  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 28					; 0000001cH
$LN20@xmlCtxtDum:

; 707  :         }
; 708  :     }
; 709  : 
; 710  :     /*
; 711  :      * Do a bit of checking
; 712  :      */
; 713  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) ent);

	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck

; 714  : }

	add	esp, 8
$LN1@xmlCtxtDum:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
	npad	1
$LN28@xmlCtxtDum:
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN14@xmlCtxtDum
	DD	$LN15@xmlCtxtDum
	DD	$LN16@xmlCtxtDum
_xmlCtxtDumpEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpElemDecl
_TEXT	SEGMENT
_buf$1 = -5004						; size = 5001
_ctxt$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlCtxtDumpElemDecl PROC				; COMDAT

; 586  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5004				; 0000138cH
	call	__chkstk
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	edi, DWORD PTR _elem$[ebp]
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN4@xmlCtxtDum

; 587  :     xmlCtxtDumpSpaces(ctxt);
; 588  : 
; 589  :     if (elem == NULL) {
; 590  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], edi
	jne	$LN1@xmlCtxtDum

; 591  :             fprintf(ctxt->output, "Element declaration is NULL\n");

	push	OFFSET ??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 641  : }

	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 592  :         return;
; 593  :     }
; 594  :     if (elem->type != XML_ELEMENT_DECL) {

	cmp	DWORD PTR [edi+4], 15			; 0000000fH
	je	SHORT $LN6@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5025					; 000013a1H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 641  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCtxtDum:

; 595  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ELEM_DECL,
; 596  : 	            "Node is not an element declaration");
; 597  :         return;
; 598  :     }
; 599  :     if (elem->name != NULL) {

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN7@xmlCtxtDum

; 600  :         if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN10@xmlCtxtDum

; 601  :             fprintf(ctxt->output, "ELEMDECL(");

	push	OFFSET ??_C@_09LBEHMBNA@ELEMDECL?$CI@
	push	DWORD PTR [esi]
	call	_fprintf

; 602  :             xmlCtxtDumpString(ctxt, elem->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlCtxtDumpString

; 603  :             fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H

; 604  :         }
; 605  :     } else

	jmp	SHORT $LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 606  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@
	push	5015					; 00001397H
	push	esi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 607  : 	            "Element declaration has no name");
; 608  :     if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	$LN10@xmlCtxtDum

; 609  :         switch (elem->etype) {

	mov	eax, DWORD PTR [edi+36]
	cmp	eax, 4
	ja	SHORT $LN2@xmlCtxtDum
	jmp	DWORD PTR $LN24@xmlCtxtDum[eax*4]
$LN11@xmlCtxtDum:

; 610  :             case XML_ELEMENT_TYPE_UNDEFINED:
; 611  :                 fprintf(ctxt->output, ", UNDEFINED");

	push	OFFSET ??_C@_0M@PIGJBKAD@?0?5UNDEFINED@

; 612  :                 break;

	jmp	SHORT $LN22@xmlCtxtDum
$LN12@xmlCtxtDum:

; 613  :             case XML_ELEMENT_TYPE_EMPTY:
; 614  :                 fprintf(ctxt->output, ", EMPTY");

	push	OFFSET ??_C@_07MPIOAGOH@?0?5EMPTY@

; 615  :                 break;

	jmp	SHORT $LN22@xmlCtxtDum
$LN13@xmlCtxtDum:

; 616  :             case XML_ELEMENT_TYPE_ANY:
; 617  :                 fprintf(ctxt->output, ", ANY");

	push	OFFSET ??_C@_05MNEHMNJK@?0?5ANY@

; 618  :                 break;

	jmp	SHORT $LN22@xmlCtxtDum
$LN15@xmlCtxtDum:

; 619  :             case XML_ELEMENT_TYPE_MIXED:
; 620  :                 fprintf(ctxt->output, ", MIXED ");
; 621  :                 break;
; 622  :             case XML_ELEMENT_TYPE_ELEMENT:
; 623  :                 fprintf(ctxt->output, ", MIXED ");
; 624  :                 break;
; 625  :         }
; 626  :         if ((elem->type != XML_ELEMENT_NODE) && (elem->content != NULL)) {

	push	OFFSET ??_C@_08MPHAJKBG@?0?5MIXED?5@
$LN22@xmlCtxtDum:
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:
	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN16@xmlCtxtDum
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN16@xmlCtxtDum

; 627  :             char buf[5001];
; 628  : 
; 629  :             buf[0] = 0;
; 630  :             xmlSnprintfElementContent(buf, 5000, elem->content, 1);

	push	1
	push	eax
	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp], 0
	push	5000					; 00001388H
	push	eax
	call	_xmlSnprintfElementContent

; 631  :             buf[5000] = 0;
; 632  :             fprintf(ctxt->output, "%s", buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+5000], 0
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 28					; 0000001cH
$LN16@xmlCtxtDum:

; 633  :         }
; 634  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN10@xmlCtxtDum:

; 635  :     }
; 636  : 
; 637  :     /*
; 638  :      * Do a bit of checking
; 639  :      */
; 640  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) elem);

	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck

; 641  : }

	add	esp, 8
$LN1@xmlCtxtDum:
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN24@xmlCtxtDum:
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN15@xmlCtxtDum
	DD	$LN15@xmlCtxtDum
_xmlCtxtDumpElemDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttrDecl
_TEXT	SEGMENT
_cur$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttrDecl PROC				; COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	ebx, DWORD PTR _attr$[ebp]
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LN9@xmlCtxtDum

; 482  :     xmlCtxtDumpSpaces(ctxt);
; 483  : 
; 484  :     if (attr == NULL) {
; 485  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], ebx
	jne	$LN1@xmlCtxtDum

; 486  :             fprintf(ctxt->output, "Attribute declaration is NULL\n");

	push	OFFSET ??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 582  : }

	add	esp, 8
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlCtxtDum:

; 487  :         return;
; 488  :     }
; 489  :     if (attr->type != XML_ATTRIBUTE_DECL) {

	cmp	DWORD PTR [ebx+4], 16			; 00000010H
	je	SHORT $LN11@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5024					; 000013a0H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 582  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlCtxtDum:

; 490  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ATTR_DECL,
; 491  : 	            "Node is not an attribute declaration");
; 492  :         return;
; 493  :     }
; 494  :     if (attr->name != NULL) {

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN12@xmlCtxtDum

; 495  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN13@xmlCtxtDum

; 496  :             fprintf(ctxt->output, "ATTRDECL(%s)", (char *) attr->name);

	push	eax
	push	OFFSET ??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@
	push	DWORD PTR [esi]
	call	_fprintf

; 497  :     } else

	jmp	SHORT $LN49@xmlCtxtDum
$LN12@xmlCtxtDum:

; 498  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@
	push	5015					; 00001397H
	push	esi
	call	_xmlDebugErr
$LN49@xmlCtxtDum:

; 499  : 	            "Node attribute declaration has no name");
; 500  :     if (attr->elem != NULL) {

	add	esp, 12					; 0000000cH
$LN13@xmlCtxtDum:
	mov	eax, DWORD PTR [ebx+60]
	test	eax, eax
	je	SHORT $LN15@xmlCtxtDum

; 501  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], 0
	jne	$LN18@xmlCtxtDum

; 502  :             fprintf(ctxt->output, " for %s", (char *) attr->elem);

	push	eax
	push	OFFSET ??_C@_07GLNLDEDP@?5for?5?$CFs@
	push	DWORD PTR [esi]
	call	_fprintf

; 503  :     } else

	jmp	SHORT $LN51@xmlCtxtDum
$LN15@xmlCtxtDum:

; 504  : 	xmlDebugErr(ctxt, XML_CHECK_NO_ELEM,

	push	OFFSET ??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@
	push	5016					; 00001398H
	push	esi
	call	_xmlDebugErr
$LN51@xmlCtxtDum:

; 505  : 	            "Node attribute declaration has no element name");
; 506  :     if (!ctxt->check) {

	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+124], 0
	jne	$LN18@xmlCtxtDum

; 507  :         switch (attr->atype) {

	mov	eax, DWORD PTR [ebx+40]
	dec	eax
	cmp	eax, 9
	ja	SHORT $LN2@xmlCtxtDum
	jmp	DWORD PTR $LN56@xmlCtxtDum[eax*4]
$LN19@xmlCtxtDum:

; 508  :             case XML_ATTRIBUTE_CDATA:
; 509  :                 fprintf(ctxt->output, " CDATA");

	push	OFFSET ??_C@_06CIOOFICG@?5CDATA@

; 510  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN20@xmlCtxtDum:

; 511  :             case XML_ATTRIBUTE_ID:
; 512  :                 fprintf(ctxt->output, " ID");

	push	OFFSET ??_C@_03JFNHLDJD@?5ID@

; 513  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN21@xmlCtxtDum:

; 514  :             case XML_ATTRIBUTE_IDREF:
; 515  :                 fprintf(ctxt->output, " IDREF");

	push	OFFSET ??_C@_06JJHMNMLB@?5IDREF@

; 516  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN22@xmlCtxtDum:

; 517  :             case XML_ATTRIBUTE_IDREFS:
; 518  :                 fprintf(ctxt->output, " IDREFS");

	push	OFFSET ??_C@_07CNGJPBFB@?5IDREFS@

; 519  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN23@xmlCtxtDum:

; 520  :             case XML_ATTRIBUTE_ENTITY:
; 521  :                 fprintf(ctxt->output, " ENTITY");

	push	OFFSET ??_C@_07GLIJGNMP@?5ENTITY@

; 522  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN24@xmlCtxtDum:

; 523  :             case XML_ATTRIBUTE_ENTITIES:
; 524  :                 fprintf(ctxt->output, " ENTITIES");

	push	OFFSET ??_C@_09MILPKLMO@?5ENTITIES@

; 525  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN25@xmlCtxtDum:

; 526  :             case XML_ATTRIBUTE_NMTOKEN:
; 527  :                 fprintf(ctxt->output, " NMTOKEN");

	push	OFFSET ??_C@_08JLMONKHB@?5NMTOKEN@

; 528  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN26@xmlCtxtDum:

; 529  :             case XML_ATTRIBUTE_NMTOKENS:
; 530  :                 fprintf(ctxt->output, " NMTOKENS");

	push	OFFSET ??_C@_09LGAPIBOH@?5NMTOKENS@

; 531  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN27@xmlCtxtDum:

; 532  :             case XML_ATTRIBUTE_ENUMERATION:
; 533  :                 fprintf(ctxt->output, " ENUMERATION");

	push	OFFSET ??_C@_0N@DAGLJCMJ@?5ENUMERATION@

; 534  :                 break;

	jmp	SHORT $LN52@xmlCtxtDum
$LN28@xmlCtxtDum:

; 535  :             case XML_ATTRIBUTE_NOTATION:
; 536  :                 fprintf(ctxt->output, " NOTATION ");

	push	OFFSET ??_C@_0L@EOKHAFCK@?5NOTATION?5@
$LN52@xmlCtxtDum:

; 537  :                 break;
; 538  :         }
; 539  :         if (attr->tree != NULL) {

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:
	mov	eax, DWORD PTR [ebx+52]
	mov	DWORD PTR _cur$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN34@xmlCtxtDum

; 540  :             int indx;
; 541  :             xmlEnumerationPtr cur = attr->tree;
; 542  : 
; 543  :             for (indx = 0; indx < 5; indx++) {

	mov	ebx, DWORD PTR _cur$1$[ebp]
	mov	eax, OFFSET ??_C@_03MFMGJBPJ@?$HM?$CFs@
	push	edi
	xor	edi, edi
$LL6@xmlCtxtDum:

; 544  :                 if (indx != 0)
; 545  :                     fprintf(ctxt->output, "|%s", (char *) cur->name);
; 546  :                 else
; 547  :                     fprintf(ctxt->output, " (%s", (char *) cur->name);
; 548  :                 cur = cur->next;

	test	edi, edi
	mov	ecx, OFFSET ??_C@_04KHAOAOAJ@?5?$CI?$CFs@
	cmovne	ecx, eax
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	eax
	call	_fprintf
	mov	ebx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH

; 549  :                 if (cur == NULL)

	test	ebx, ebx
	je	SHORT $LN44@xmlCtxtDum

; 540  :             int indx;
; 541  :             xmlEnumerationPtr cur = attr->tree;
; 542  : 
; 543  :             for (indx = 0; indx < 5; indx++) {

	inc	edi
	mov	eax, OFFSET ??_C@_03MFMGJBPJ@?$HM?$CFs@
	cmp	edi, 5
	jl	SHORT $LL6@xmlCtxtDum
$LN44@xmlCtxtDum:

; 550  :                     break;
; 551  :             }
; 552  :             if (cur == NULL)

	mov	eax, DWORD PTR [esi]
	test	ebx, ebx
	mov	ebx, DWORD PTR _attr$[ebp]
	pop	edi
	jne	SHORT $LN33@xmlCtxtDum

; 553  :                 fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	jmp	SHORT $LN53@xmlCtxtDum
$LN33@xmlCtxtDum:

; 554  :             else
; 555  :                 fprintf(ctxt->output, "...)");

	push	OFFSET ??_C@_04HBFELFIL@?4?4?4?$CJ@
$LN53@xmlCtxtDum:

; 556  :         }
; 557  :         switch (attr->def) {

	push	eax
	call	_fprintf
	add	esp, 8
$LN34@xmlCtxtDum:
	mov	eax, DWORD PTR [ebx+44]
	sub	eax, 2
	je	SHORT $LN36@xmlCtxtDum
	sub	eax, 1
	je	SHORT $LN37@xmlCtxtDum
	sub	eax, 1
	jne	SHORT $LN7@xmlCtxtDum

; 566  :             case XML_ATTRIBUTE_FIXED:
; 567  :                 fprintf(ctxt->output, " FIXED");

	push	OFFSET ??_C@_06MNDBCIDD@?5FIXED@
	jmp	SHORT $LN54@xmlCtxtDum
$LN37@xmlCtxtDum:

; 562  :                 break;
; 563  :             case XML_ATTRIBUTE_IMPLIED:
; 564  :                 fprintf(ctxt->output, " IMPLIED");

	push	OFFSET ??_C@_08BNNMMLKP@?5IMPLIED@

; 565  :                 break;

	jmp	SHORT $LN54@xmlCtxtDum
$LN36@xmlCtxtDum:

; 558  :             case XML_ATTRIBUTE_NONE:
; 559  :                 break;
; 560  :             case XML_ATTRIBUTE_REQUIRED:
; 561  :                 fprintf(ctxt->output, " REQUIRED");

	push	OFFSET ??_C@_09GBLDHCFM@?5REQUIRED@
$LN54@xmlCtxtDum:

; 568  :                 break;
; 569  :         }
; 570  :         if (attr->defaultValue != NULL) {

	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:
	cmp	DWORD PTR [ebx+48], 0
	je	SHORT $LN39@xmlCtxtDum

; 571  :             fprintf(ctxt->output, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [esi]
	call	_fprintf

; 572  :             xmlCtxtDumpString(ctxt, attr->defaultValue);

	push	DWORD PTR [ebx+48]
	push	esi
	call	_xmlCtxtDumpString

; 573  :             fprintf(ctxt->output, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 24					; 00000018H
$LN39@xmlCtxtDum:

; 574  :         }
; 575  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN18@xmlCtxtDum:

; 576  :     }
; 577  : 
; 578  :     /*
; 579  :      * Do a bit of checking
; 580  :      */
; 581  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);

	push	ebx
	push	esi
	call	_xmlCtxtGenericNodeCheck

; 582  : }

	add	esp, 8
$LN1@xmlCtxtDum:
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlCtxtDum:
	DD	$LN19@xmlCtxtDum
	DD	$LN20@xmlCtxtDum
	DD	$LN21@xmlCtxtDum
	DD	$LN22@xmlCtxtDum
	DD	$LN23@xmlCtxtDum
	DD	$LN24@xmlCtxtDum
	DD	$LN25@xmlCtxtDum
	DD	$LN26@xmlCtxtDum
	DD	$LN27@xmlCtxtDum
	DD	$LN28@xmlCtxtDum
_xmlCtxtDumpAttrDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDtdNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlCtxtDumpDtdNode PROC				; COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	push	esi
	call	_xmlCtxtDumpSpaces
	mov	edi, DWORD PTR _dtd$[ebp]
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlCtxtDum

; 449  :     xmlCtxtDumpSpaces(ctxt);
; 450  : 
; 451  :     if (dtd == NULL) {
; 452  :         if (!ctxt->check)

	cmp	DWORD PTR [esi+124], edi
	jne	$LN1@xmlCtxtDum

; 453  :             fprintf(ctxt->output, "DTD node is NULL\n");

	push	OFFSET ??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@
	push	DWORD PTR [esi]
	call	_fprintf

; 477  : }

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlCtxtDum:

; 454  :         return;
; 455  :     }
; 456  : 
; 457  :     if (dtd->type != XML_DTD_NODE) {

	cmp	DWORD PTR [edi+4], 14			; 0000000eH
	je	SHORT $LN4@xmlCtxtDum

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [esi+128]
	push	0
	push	0
	push	0
	push	2
	push	5022					; 0000139eH
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 477  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 458  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_DTD,
; 459  : 	            "Node is not a DTD");
; 460  :         return;
; 461  :     }
; 462  :     if (!ctxt->check) {

	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 463  :         if (dtd->name != NULL)

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xmlCtxtDum

; 464  :             fprintf(ctxt->output, "DTD(%s)", (char *) dtd->name);

	push	ecx
	push	OFFSET ??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@xmlCtxtDum
$LN6@xmlCtxtDum:

; 465  :         else
; 466  :             fprintf(ctxt->output, "DTD");

	push	OFFSET ??_C@_03DFGNODOE@DTD@
	push	eax
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:

; 467  :         if (dtd->ExternalID != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN8@xmlCtxtDum

; 468  :             fprintf(ctxt->output, ", PUBLIC %s", (char *) dtd->ExternalID);

	push	eax
	push	OFFSET ??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 469  :         if (dtd->SystemID != NULL)

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN9@xmlCtxtDum

; 470  :             fprintf(ctxt->output, ", SYSTEM %s", (char *) dtd->SystemID);

	push	eax
	push	OFFSET ??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN9@xmlCtxtDum:

; 471  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [esi]
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 472  :     }
; 473  :     /*
; 474  :      * Do a bit of checking
; 475  :      */
; 476  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) dtd);

	push	edi
	push	esi
	call	_xmlCtxtGenericNodeCheck

; 477  : }

	add	esp, 8
$LN1@xmlCtxtDum:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlCtxtDumpDtdNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlCtxtDumpString PROC					; COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR [edi+124], 0
	jne	$LN1@xmlCtxtDum

; 424  :     int i;
; 425  : 
; 426  :     if (ctxt->check) {
; 427  :         return;
; 428  :     }
; 429  :     /* TODO: check UTF8 content of the string */
; 430  :     if (str == NULL) {

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	jne	SHORT $LN6@xmlCtxtDum

; 431  :         fprintf(ctxt->output, "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	DWORD PTR [edi]
	call	_fprintf
	add	esp, 8
	pop	edi

; 444  : }

	pop	ebp
	ret	0
$LN6@xmlCtxtDum:
	push	ebx

; 432  :         return;
; 433  :     }
; 434  :     for (i = 0; i < 40; i++)

	mov	ebx, DWORD PTR __imp__fputc
	push	esi
	xor	esi, esi
	npad	2
$LL4@xmlCtxtDum:

; 435  :         if (str[i] == 0)

	mov	al, BYTE PTR [esi+eax]
	test	al, al
	je	SHORT $LN21@xmlCtxtDum

; 436  :             return;
; 437  :         else if (IS_BLANK_CH(str[i]))

	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlCtxtDum
	cmp	al, 9
	jb	SHORT $LN12@xmlCtxtDum
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlCtxtDum
$LN12@xmlCtxtDum:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN11@xmlCtxtDum

; 439  :         else if (str[i] >= 0x80)

	mov	ecx, DWORD PTR [edi]
	movzx	edx, al
	cmp	al, 128					; 00000080H
	jb	SHORT $LN13@xmlCtxtDum

; 440  :             fprintf(ctxt->output, "#%X", str[i]);

	push	edx
	push	OFFSET ??_C@_03CANIHDGE@?$CD?$CFX@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@xmlCtxtDum
$LN13@xmlCtxtDum:

; 441  :         else
; 442  :             fputc(str[i], ctxt->output);

	push	ecx
	push	edx
	jmp	SHORT $LN23@xmlCtxtDum
$LN11@xmlCtxtDum:

; 438  :             fputc(' ', ctxt->output);

	push	DWORD PTR [edi]
	push	32					; 00000020H
$LN23@xmlCtxtDum:

; 432  :         return;
; 433  :     }
; 434  :     for (i = 0; i < 40; i++)

	call	ebx
	add	esp, 8
$LN2@xmlCtxtDum:
	mov	eax, DWORD PTR _str$[ebp]
	inc	esi
	cmp	esi, 40					; 00000028H
	jl	SHORT $LL4@xmlCtxtDum

; 443  :     fprintf(ctxt->output, "...");

	push	OFFSET ??_C@_03KHICJKCI@?4?4?4@
	push	DWORD PTR [edi]
	call	_fprintf
	add	esp, 8
$LN21@xmlCtxtDum:
	pop	esi
	pop	ebx
$LN1@xmlCtxtDum:
	pop	edi

; 444  : }

	pop	ebp
	ret	0
_xmlCtxtDumpString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtGenericNodeCheck
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtGenericNodeCheck PROC				; COMDAT

; 275  : xmlCtxtGenericNodeCheck(xmlDebugCtxtPtr ctxt, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+20], 0
	mov	ebx, DWORD PTR [esi+32]
	mov	eax, ebx
	jne	SHORT $LN44@xmlCtxtGen

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+128]
	push	0
	push	0
	push	0
	push	2
	push	5013					; 00001395H
	push	24					; 00000018H
	push	DWORD PTR [edi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	mov	eax, DWORD PTR [esi+32]
	add	esp, 68					; 00000044H
$LN44@xmlCtxtGen:

; 276  :     xmlDocPtr doc;
; 277  :     xmlDictPtr dict;
; 278  : 
; 279  :     doc = node->doc;
; 280  : 
; 281  :     if (node->parent == NULL)
; 282  :         xmlDebugErr(ctxt, XML_CHECK_NO_PARENT,
; 283  : 	            "Node has no parent\n");
; 284  :     if (node->doc == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlCtxtGen

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	push	eax
	push	eax
	push	eax
	inc	DWORD PTR [edi+128]
	push	eax
	push	eax
	push	eax
	push	2
	push	5014					; 00001396H
	push	24					; 00000018H
	push	DWORD PTR [edi+116]
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 285  :         xmlDebugErr(ctxt, XML_CHECK_NO_DOC,
; 286  : 	            "Node has no doc\n");
; 287  :         dict = NULL;
; 288  :     } else {

	jmp	SHORT $LN11@xmlCtxtGen
$LN7@xmlCtxtGen:

; 289  : 	dict = doc->dict;

	mov	eax, DWORD PTR [ebx+80]

; 290  : 	if ((dict == NULL) && (ctxt->nodict == 0)) {

	test	eax, eax
	jne	SHORT $LN9@xmlCtxtGen
	cmp	DWORD PTR [edi+132], eax
	jne	SHORT $LN9@xmlCtxtGen

; 291  : #if 0
; 292  :             /* desactivated right now as it raises too many errors */
; 293  : 	    if (doc->type == XML_DOCUMENT_NODE)
; 294  : 		xmlDebugErr(ctxt, XML_CHECK_NO_DICT,
; 295  : 			    "Document has no dictionary\n");
; 296  : #endif
; 297  : 	    ctxt->nodict = 1;

	mov	DWORD PTR [edi+132], 1
$LN9@xmlCtxtGen:

; 298  : 	}
; 299  : 	if (ctxt->doc == NULL)

	cmp	DWORD PTR [edi+112], 0
	jne	SHORT $LN10@xmlCtxtGen

; 300  : 	    ctxt->doc = doc;

	mov	DWORD PTR [edi+112], ebx
$LN10@xmlCtxtGen:

; 301  : 
; 302  : 	if (ctxt->dict == NULL) {

	cmp	DWORD PTR [edi+120], 0
	jne	SHORT $LN11@xmlCtxtGen

; 303  : 	    ctxt->dict = dict;

	mov	DWORD PTR [edi+120], eax
$LN11@xmlCtxtGen:

; 304  : 	}
; 305  :     }
; 306  :     if ((node->parent != NULL) && (node->doc != node->parent->doc) &&

	mov	ecx, DWORD PTR [esi+20]
	test	ecx, ecx
	je	SHORT $LN12@xmlCtxtGen
	mov	eax, DWORD PTR [esi+32]
	cmp	eax, DWORD PTR [ecx+32]
	je	SHORT $LN12@xmlCtxtGen
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlCtxtGen

; 307  :         (!xmlStrEqual(node->name, BAD_CAST "pseudoroot")))
; 308  :         xmlDebugErr(ctxt, XML_CHECK_WRONG_DOC,

	push	OFFSET ??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@
	push	5017					; 00001399H
	push	edi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN12@xmlCtxtGen:

; 309  : 	            "Node doc differs from parent's one\n");
; 310  :     if (node->prev == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN13@xmlCtxtGen

; 311  :         if (node->type == XML_ATTRIBUTE_NODE) {

	mov	eax, DWORD PTR [esi+20]

; 312  : 	    if ((node->parent != NULL) &&

	test	eax, eax
	je	SHORT $LN48@xmlCtxtGen

; 311  :         if (node->type == XML_ATTRIBUTE_NODE) {

	cmp	DWORD PTR [esi+4], 2
	jne	SHORT $LN15@xmlCtxtGen

; 312  : 	    if ((node->parent != NULL) &&

	cmp	esi, DWORD PTR [eax+44]
	je	SHORT $LN48@xmlCtxtGen

; 313  : 	        (node != (xmlNodePtr) node->parent->properties))
; 314  : 		xmlDebugErr(ctxt, XML_CHECK_NO_PREV,

	push	OFFSET ??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@
	push	5018					; 0000139aH
	push	edi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 315  :                     "Attr has no prev and not first of attr list\n");
; 316  : 
; 317  :         } else if ((node->parent != NULL) && (node->parent->children != node))

	jmp	SHORT $LN48@xmlCtxtGen
$LN15@xmlCtxtGen:
	cmp	DWORD PTR [eax+12], esi
	je	SHORT $LN48@xmlCtxtGen

; 318  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_PREV,

	push	OFFSET ??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@
	push	5018					; 0000139aH
	push	edi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 319  :                     "Node has no prev and not first of parent list\n");
; 320  :     } else {

	jmp	SHORT $LN48@xmlCtxtGen
$LN13@xmlCtxtGen:

; 321  :         if (node->prev->next != node)

	cmp	DWORD PTR [eax+24], esi
	je	SHORT $LN48@xmlCtxtGen

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+128]
	push	0
	push	0
	push	0
	push	2
	push	5019					; 0000139bH
	push	24					; 00000018H
	push	DWORD PTR [edi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN48@xmlCtxtGen:

; 322  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_PREV,
; 323  :                         "Node prev->next : back link wrong\n");
; 324  :     }
; 325  :     if (node->next == NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN20@xmlCtxtGen

; 326  : 	if ((node->parent != NULL) && (node->type != XML_ATTRIBUTE_NODE) &&
; 327  : 	    (node->parent->last != node) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN52@xmlCtxtGen
	cmp	DWORD PTR [esi+4], 2
	je	$LN52@xmlCtxtGen
	cmp	DWORD PTR [eax+16], esi
	je	$LN52@xmlCtxtGen
	cmp	DWORD PTR [eax+4], 1
	jne	$LN52@xmlCtxtGen

; 328  : 	    (node->parent->type == XML_ELEMENT_NODE))
; 329  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_NEXT,

	push	OFFSET ??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@
	push	5020					; 0000139cH
	push	edi
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 330  :                     "Node has no next and not last of parent list\n");
; 331  :     } else {

	jmp	$LN52@xmlCtxtGen
$LN20@xmlCtxtGen:

; 332  :         if (node->next->prev != node)

	cmp	DWORD PTR [eax+28], esi
	je	SHORT $LN50@xmlCtxtGen

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+128]
	push	0
	push	0
	push	0
	push	2
	push	5021					; 0000139dH
	push	24					; 00000018H
	push	DWORD PTR [edi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	mov	eax, DWORD PTR [esi+24]
	add	esp, 68					; 00000044H
$LN50@xmlCtxtGen:

; 333  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_NEXT,
; 334  :                     "Node next->prev : forward link wrong\n");
; 335  :         if (node->next->parent != node->parent)

	mov	eax, DWORD PTR [eax+20]
	cmp	eax, DWORD PTR [esi+20]
	je	SHORT $LN52@xmlCtxtGen

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [edi+128]
	push	0
	push	0
	push	0
	push	2
	push	5029					; 000013a5H
	push	24					; 00000018H
	push	DWORD PTR [edi+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN52@xmlCtxtGen:

; 336  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_PARENT,
; 337  :                     "Node next->prev : forward link wrong\n");
; 338  :     }
; 339  :     if (node->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN25@xmlCtxtGen

; 340  :         xmlNsPtr ns;
; 341  : 
; 342  : 	ns = node->nsDef;

	mov	ebx, DWORD PTR [esi+48]

; 343  : 	while (ns != NULL) {

	test	ebx, ebx
	je	SHORT $LN3@xmlCtxtGen
$LL2@xmlCtxtGen:

; 344  : 	    xmlCtxtNsCheckScope(ctxt, node, ns);

	push	ebx
	push	esi
	push	edi
	call	_xmlCtxtNsCheckScope

; 345  : 	    ns = ns->next;

	mov	ebx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	jne	SHORT $LL2@xmlCtxtGen

; 346  : 	}
; 347  : 	if (node->ns != NULL)
; 348  : 	    xmlCtxtNsCheckScope(ctxt, node, node->ns);
; 349  :     } else if (node->type == XML_ATTRIBUTE_NODE) {

	jmp	SHORT $LN3@xmlCtxtGen
$LN25@xmlCtxtGen:
	cmp	eax, 2
	jne	SHORT $LN29@xmlCtxtGen
$LN3@xmlCtxtGen:

; 350  : 	if (node->ns != NULL)
; 351  : 	    xmlCtxtNsCheckScope(ctxt, node, node->ns);
; 352  :     }
; 353  : 
; 354  :     if ((node->type != XML_ELEMENT_NODE) &&
; 355  : 	(node->type != XML_ATTRIBUTE_NODE) &&
; 356  : 	(node->type != XML_ELEMENT_DECL) &&
; 357  : 	(node->type != XML_ATTRIBUTE_DECL) &&
; 358  : 	(node->type != XML_DTD_NODE) &&
; 359  : 	(node->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN29@xmlCtxtGen
	push	eax
	push	esi
	push	edi
	call	_xmlCtxtNsCheckScope
	add	esp, 12					; 0000000cH
$LN29@xmlCtxtGen:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 2
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 15					; 0000000fH
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 16					; 00000010H
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN57@xmlCtxtGen
	cmp	eax, 9
	je	SHORT $LN57@xmlCtxtGen

; 360  : 	(node->type != XML_DOCUMENT_NODE)) {
; 361  : 	if (node->content != NULL)

	mov	ebx, DWORD PTR [esi+40]
	test	ebx, ebx
	je	SHORT $LN57@xmlCtxtGen

; 233  :     if (ctxt->check) {

	cmp	DWORD PTR [edi+124], 0
	je	SHORT $LN57@xmlCtxtGen

; 234  :         if (!xmlCheckUTF8(str)) {

	push	ebx
	call	_xmlCheckUTF8
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN57@xmlCtxtGen

; 235  : 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_UTF8,

	push	ebx
	push	OFFSET ??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@
	push	5032					; 000013a8H
	push	edi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN57@xmlCtxtGen:

; 362  : 	    xmlCtxtCheckString(ctxt, (const xmlChar *) node->content);
; 363  :     }
; 364  :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 7
	ja	$LN42@xmlCtxtGen
	jmp	DWORD PTR $LN66@xmlCtxtGen[eax*4]
$LN32@xmlCtxtGen:

; 397  : 			 "CData section has non NULL name '%s'",
; 398  : 			 (const char *) node->name);
; 399  : 	    break;
; 400  :         case XML_ENTITY_REF_NODE:
; 401  :         case XML_ENTITY_NODE:
; 402  :         case XML_DOCUMENT_TYPE_NODE:
; 403  :         case XML_DOCUMENT_FRAG_NODE:
; 404  :         case XML_NOTATION_NODE:
; 405  :         case XML_DTD_NODE:
; 406  :         case XML_ELEMENT_DECL:
; 407  :         case XML_ATTRIBUTE_DECL:
; 408  :         case XML_ENTITY_DECL:
; 409  :         case XML_NAMESPACE_DECL:
; 410  :         case XML_XINCLUDE_START:
; 411  :         case XML_XINCLUDE_END:
; 412  : #ifdef LIBXML_DOCB_ENABLED
; 413  :         case XML_DOCB_DOCUMENT_NODE:
; 414  : #endif
; 415  :         case XML_DOCUMENT_NODE:
; 416  :         case XML_HTML_DOCUMENT_NODE:
; 417  : 	    break;
; 418  :     }
; 419  : }

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlCtxtCheckName
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN33@xmlCtxtGen:

; 365  :         case XML_ELEMENT_NODE:
; 366  :         case XML_ATTRIBUTE_NODE:
; 367  : 	    xmlCtxtCheckName(ctxt, node->name);
; 368  : 	    break;
; 369  :         case XML_TEXT_NODE:
; 370  : 	    if ((node->name == xmlStringText) ||

	mov	ebx, DWORD PTR [esi+8]
	cmp	ebx, OFFSET _xmlStringText
	je	SHORT $LN42@xmlCtxtGen
	cmp	ebx, OFFSET _xmlStringTextNoenc
	je	SHORT $LN42@xmlCtxtGen

; 371  : 	        (node->name == xmlStringTextNoenc))
; 372  : 		break;
; 373  : 	    /* some case of entity substitution can lead to this */
; 374  : 	    if ((ctxt->dict != NULL) &&

	mov	eax, DWORD PTR [edi+120]
	test	eax, eax
	je	SHORT $LN36@xmlCtxtGen
	push	7
	push	OFFSET ??_C@_07DALNPEGO@nbktext@
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	je	SHORT $LN42@xmlCtxtGen
$LN36@xmlCtxtGen:

; 375  : 	        (node->name == xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
; 376  : 		                             7)))
; 377  : 		break;
; 378  : 
; 379  : 	    xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,

	push	ebx
	push	OFFSET ??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@
	push	5036					; 000013acH

; 397  : 			 "CData section has non NULL name '%s'",
; 398  : 			 (const char *) node->name);
; 399  : 	    break;
; 400  :         case XML_ENTITY_REF_NODE:
; 401  :         case XML_ENTITY_NODE:
; 402  :         case XML_DOCUMENT_TYPE_NODE:
; 403  :         case XML_DOCUMENT_FRAG_NODE:
; 404  :         case XML_NOTATION_NODE:
; 405  :         case XML_DTD_NODE:
; 406  :         case XML_ELEMENT_DECL:
; 407  :         case XML_ATTRIBUTE_DECL:
; 408  :         case XML_ENTITY_DECL:
; 409  :         case XML_NAMESPACE_DECL:
; 410  :         case XML_XINCLUDE_START:
; 411  :         case XML_XINCLUDE_END:
; 412  : #ifdef LIBXML_DOCB_ENABLED
; 413  :         case XML_DOCB_DOCUMENT_NODE:
; 414  : #endif
; 415  :         case XML_DOCUMENT_NODE:
; 416  :         case XML_HTML_DOCUMENT_NODE:
; 417  : 	    break;
; 418  :     }
; 419  : }

	push	edi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN37@xmlCtxtGen:

; 380  : 			 "Text node has wrong name '%s'",
; 381  : 			 (const char *) node->name);
; 382  : 	    break;
; 383  :         case XML_COMMENT_NODE:
; 384  : 	    if (node->name == xmlStringComment)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, OFFSET _xmlStringComment
	je	SHORT $LN42@xmlCtxtGen

; 385  : 		break;
; 386  : 	    xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,

	push	eax
	push	OFFSET ??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@
	push	5036					; 000013acH

; 397  : 			 "CData section has non NULL name '%s'",
; 398  : 			 (const char *) node->name);
; 399  : 	    break;
; 400  :         case XML_ENTITY_REF_NODE:
; 401  :         case XML_ENTITY_NODE:
; 402  :         case XML_DOCUMENT_TYPE_NODE:
; 403  :         case XML_DOCUMENT_FRAG_NODE:
; 404  :         case XML_NOTATION_NODE:
; 405  :         case XML_DTD_NODE:
; 406  :         case XML_ELEMENT_DECL:
; 407  :         case XML_ATTRIBUTE_DECL:
; 408  :         case XML_ENTITY_DECL:
; 409  :         case XML_NAMESPACE_DECL:
; 410  :         case XML_XINCLUDE_START:
; 411  :         case XML_XINCLUDE_END:
; 412  : #ifdef LIBXML_DOCB_ENABLED
; 413  :         case XML_DOCB_DOCUMENT_NODE:
; 414  : #endif
; 415  :         case XML_DOCUMENT_NODE:
; 416  :         case XML_HTML_DOCUMENT_NODE:
; 417  : 	    break;
; 418  :     }
; 419  : }

	push	edi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN40@xmlCtxtGen:

; 387  : 			 "Comment node has wrong name '%s'",
; 388  : 			 (const char *) node->name);
; 389  : 	    break;
; 390  :         case XML_PI_NODE:
; 391  : 	    xmlCtxtCheckName(ctxt, node->name);
; 392  : 	    break;
; 393  :         case XML_CDATA_SECTION_NODE:
; 394  : 	    if (node->name == NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN42@xmlCtxtGen

; 395  : 		break;
; 396  : 	    xmlDebugErr3(ctxt, XML_CHECK_NAME_NOT_NULL,

	push	eax
	push	OFFSET ??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@
	push	5037					; 000013adH

; 397  : 			 "CData section has non NULL name '%s'",
; 398  : 			 (const char *) node->name);
; 399  : 	    break;
; 400  :         case XML_ENTITY_REF_NODE:
; 401  :         case XML_ENTITY_NODE:
; 402  :         case XML_DOCUMENT_TYPE_NODE:
; 403  :         case XML_DOCUMENT_FRAG_NODE:
; 404  :         case XML_NOTATION_NODE:
; 405  :         case XML_DTD_NODE:
; 406  :         case XML_ELEMENT_DECL:
; 407  :         case XML_ATTRIBUTE_DECL:
; 408  :         case XML_ENTITY_DECL:
; 409  :         case XML_NAMESPACE_DECL:
; 410  :         case XML_XINCLUDE_START:
; 411  :         case XML_XINCLUDE_END:
; 412  : #ifdef LIBXML_DOCB_ENABLED
; 413  :         case XML_DOCB_DOCUMENT_NODE:
; 414  : #endif
; 415  :         case XML_DOCUMENT_NODE:
; 416  :         case XML_HTML_DOCUMENT_NODE:
; 417  : 	    break;
; 418  :     }
; 419  : }

	push	edi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN42@xmlCtxtGen:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN66@xmlCtxtGen:
	DD	$LN32@xmlCtxtGen
	DD	$LN32@xmlCtxtGen
	DD	$LN33@xmlCtxtGen
	DD	$LN40@xmlCtxtGen
	DD	$LN42@xmlCtxtGen
	DD	$LN42@xmlCtxtGen
	DD	$LN32@xmlCtxtGen
	DD	$LN37@xmlCtxtGen
_xmlCtxtGenericNodeCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtCheckName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCtxtCheckName PROC					; COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+124], 0
	je	$LN5@xmlCtxtChe

; 252  :     if (ctxt->check) {
; 253  : 	if (name == NULL) {

	push	edi
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlCtxtChe

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0N@BLMILKM@Name?5is?5NULL@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	push	edi
	push	edi
	push	edi
	inc	DWORD PTR [esi+128]
	push	edi
	push	edi
	push	edi
	push	2
	push	5015					; 00001397H
	push	24					; 00000018H
	push	DWORD PTR [esi+116]
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi
	pop	esi

; 268  : 			 "Name is not from the document dictionary '%s'",
; 269  : 			 (const char *) name);
; 270  : 	}
; 271  :     }
; 272  : }

	pop	ebp
	ret	0
$LN3@xmlCtxtChe:

; 254  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_NAME, "Name is NULL");
; 255  : 	    return;
; 256  : 	}
; 257  : #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
; 258  :         if (xmlValidateName(name, 0)) {

	push	0
	push	edi
	call	_xmlValidateName
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlCtxtChe

; 259  : 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_NCNAME,

	push	edi
	push	OFFSET ??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@
	push	5034					; 000013aaH
	push	esi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN4@xmlCtxtChe:

; 260  : 			 "Name is not an NCName '%s'", (const char *) name);
; 261  : 	}
; 262  : #endif
; 263  : 	if ((ctxt->dict != NULL) &&
; 264  : 	    (!xmlDictOwns(ctxt->dict, name)) &&

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN10@xmlCtxtChe
	push	edi
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlCtxtChe
	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN6@xmlCtxtChe
	test	DWORD PTR [eax+88], 4608		; 00001200H
	jne	SHORT $LN10@xmlCtxtChe
$LN6@xmlCtxtChe:

; 265  :             ((ctxt->doc == NULL) ||
; 266  :              ((ctxt->doc->parseFlags & (XML_PARSE_SAX1 | XML_PARSE_NODICT)) == 0))) {
; 267  : 	    xmlDebugErr3(ctxt, XML_CHECK_OUTSIDE_DICT,

	push	edi
	push	OFFSET ??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@
	push	5035					; 000013abH
	push	esi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN10@xmlCtxtChe:
	pop	edi
$LN5@xmlCtxtChe:
	pop	esi

; 268  : 			 "Name is not from the document dictionary '%s'",
; 269  : 			 (const char *) name);
; 270  : 	}
; 271  :     }
; 272  : }

	pop	ebp
	ret	0
_xmlCtxtCheckName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtCheckString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlCtxtCheckString PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlCtxtChe

; 232  :     if (str == NULL) return;
; 233  :     if (ctxt->check) {

	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edi+124], 0
	je	SHORT $LN6@xmlCtxtChe

; 234  :         if (!xmlCheckUTF8(str)) {

	push	esi
	call	_xmlCheckUTF8
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@xmlCtxtChe

; 235  : 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_UTF8,

	push	esi
	push	OFFSET ??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@
	push	5032					; 000013a8H
	push	edi
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN6@xmlCtxtChe:
	pop	edi
$LN4@xmlCtxtChe:
	pop	esi

; 236  : 			 "String is not UTF-8 %s", (const char *) str);
; 237  : 	}
; 238  :     }
; 239  : }

	pop	ebp
	ret	0
_xmlCtxtCheckString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtNsCheckScope
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlCtxtNsCheckScope PROC				; COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]

; 97   :     if ((node == NULL) || (ns == NULL))

	test	ebx, ebx
	je	$LN32@xmlCtxtNsC
	push	edi
	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	$LN63@xmlCtxtNsC

; 98   :         return(-1);
; 99   : 
; 100  :     if ((node->type != XML_ELEMENT_NODE) &&
; 101  : 	(node->type != XML_ATTRIBUTE_NODE) &&
; 102  : 	(node->type != XML_DOCUMENT_NODE) &&
; 103  : 	(node->type != XML_TEXT_NODE) &&
; 104  : 	(node->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	cmp	eax, 1
	je	SHORT $LL10@xmlCtxtNsC
	cmp	eax, 2
	je	SHORT $LL10@xmlCtxtNsC
	cmp	eax, 9
	je	SHORT $LL10@xmlCtxtNsC
	cmp	eax, 3
	je	SHORT $LL10@xmlCtxtNsC
	cmp	eax, 13					; 0000000dH
	je	SHORT $LL10@xmlCtxtNsC
	cmp	eax, 19					; 00000013H
	jne	$LN44@xmlCtxtNsC
	npad	5
$LL10@xmlCtxtNsC:

; 105  : 	(node->type != XML_XINCLUDE_START))
; 106  : 	return(-2);
; 107  : 
; 108  :     while ((node != NULL) &&

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	je	SHORT $LN19@xmlCtxtNsC
	cmp	eax, 2
	je	SHORT $LN17@xmlCtxtNsC
	cmp	eax, 3
	je	SHORT $LN17@xmlCtxtNsC
	cmp	eax, 19					; 00000013H
	je	SHORT $LN19@xmlCtxtNsC

; 125  :     }
; 126  :     /* the xml namespace may be declared on the document node */
; 127  :     if ((node != NULL) &&

	cmp	eax, 9
	je	SHORT $LN23@xmlCtxtNsC
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN54@xmlCtxtNsC
$LN23@xmlCtxtNsC:

; 128  :         ((node->type == XML_DOCUMENT_NODE) ||
; 129  : 	 (node->type == XML_HTML_DOCUMENT_NODE))) {
; 130  : 	 xmlNsPtr oldNs = ((xmlDocPtr) node)->oldNs;
; 131  : 	 if (oldNs == ns)

	cmp	DWORD PTR [ebx+52], edi
	je	$LN64@xmlCtxtNsC
$LN54@xmlCtxtNsC:

; 212  :         if (ns->prefix == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+116]
	inc	DWORD PTR [eax+128]
	test	edx, edx
	jne	SHORT $LN6@xmlCtxtNsC

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@

; 213  : 	    xmlDebugErr(ctxt, XML_CHECK_NS_ANCESTOR,

	jmp	SHORT $LN66@xmlCtxtNsC
$LN17@xmlCtxtNsC:

; 113  : 	if ((node->type == XML_ELEMENT_NODE) ||

	cmp	eax, 19					; 00000013H
	jne	SHORT $LN13@xmlCtxtNsC
$LN19@xmlCtxtNsC:

; 114  : 	    (node->type == XML_XINCLUDE_START)) {
; 115  : 	    cur = node->nsDef;

	mov	esi, DWORD PTR [ebx+48]

; 116  : 	    while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlCtxtNsC
$LL12@xmlCtxtNsC:

; 117  : 	        if (cur == ns)

	cmp	esi, edi
	je	$LN64@xmlCtxtNsC

; 118  : 		    return(1);
; 119  : 		if (xmlStrEqual(cur->prefix, ns->prefix))

	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN44@xmlCtxtNsC

; 120  : 		    return(-2);
; 121  : 		cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL12@xmlCtxtNsC
$LN13@xmlCtxtNsC:

; 122  : 	    }
; 123  : 	}
; 124  : 	node = node->parent;

	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	SHORT $LL10@xmlCtxtNsC

; 105  : 	(node->type != XML_XINCLUDE_START))
; 106  : 	return(-2);
; 107  : 
; 108  :     while ((node != NULL) &&

	jmp	SHORT $LN54@xmlCtxtNsC
$LN44@xmlCtxtNsC:

; 199  :     int ret;
; 200  : 
; 201  :     ret = xmlNsCheckScope(node, ns);
; 202  :     if (ret == -2) {
; 203  :         if (ns->prefix == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+116]
	inc	DWORD PTR [eax+128]
	test	edx, edx
	jne	SHORT $LN3@xmlCtxtNsC

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
$LN67@xmlCtxtNsC:

; 181  :     __xmlRaiseError(NULL, NULL, NULL,

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	5030					; 000013a6H
	jmp	SHORT $LN65@xmlCtxtNsC
$LN3@xmlCtxtNsC:
	push	edx
	push	OFFSET ??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@

; 204  : 	    xmlDebugErr(ctxt, XML_CHECK_NS_SCOPE,
; 205  : 			"Reference to default namespace not in scope\n");
; 206  : 	else
; 207  : 	    xmlDebugErr3(ctxt, XML_CHECK_NS_SCOPE,
; 208  : 			 "Reference to namespace '%s' not in scope\n",
; 209  : 			 (char *) ns->prefix);
; 210  :     }
; 211  :     if (ret == -3) {

	jmp	SHORT $LN67@xmlCtxtNsC
$LN6@xmlCtxtNsC:

; 181  :     __xmlRaiseError(NULL, NULL, NULL,

	push	edx
	push	OFFSET ??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@
$LN66@xmlCtxtNsC:
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	5031					; 000013a7H
$LN65@xmlCtxtNsC:
	push	24					; 00000018H
	push	ecx
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN64@xmlCtxtNsC:
	pop	esi
$LN63@xmlCtxtNsC:
	pop	edi
$LN32@xmlCtxtNsC:
	pop	ebx

; 214  : 			"Reference to default namespace not on ancestor\n");
; 215  : 	else
; 216  : 	    xmlDebugErr3(ctxt, XML_CHECK_NS_ANCESTOR,
; 217  : 			 "Reference to namespace '%s' not on ancestor\n",
; 218  : 			 (char *) ns->prefix);
; 219  :     }
; 220  : }

	pop	ebp
	ret	0
_xmlCtxtNsCheckScope ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr3
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlDebugErr3 PROC					; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+128]
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	24					; 00000018H
	push	DWORD PTR [eax+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 180  :     ctxt->errors++;
; 181  :     __xmlRaiseError(NULL, NULL, NULL,
; 182  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 183  : 		    error, XML_ERR_ERROR, NULL, 0,
; 184  : 		    NULL, NULL, NULL, 0, 0,
; 185  : 		    msg, extra);
; 186  : }

	pop	ebp
	ret	0
_xmlDebugErr3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlDebugErr2 PROC					; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+128]
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	24					; 00000018H
	push	DWORD PTR [eax+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 170  :     ctxt->errors++;
; 171  :     __xmlRaiseError(NULL, NULL, NULL,
; 172  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 173  : 		    error, XML_ERR_ERROR, NULL, 0,
; 174  : 		    NULL, NULL, NULL, 0, 0,
; 175  : 		    msg, extra);
; 176  : }

	pop	ebp
	ret	0
_xmlDebugErr2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlDebugErr PROC					; COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	inc	DWORD PTR [eax+128]
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR _error$[ebp]
	push	24					; 00000018H
	push	DWORD PTR [eax+116]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 160  :     ctxt->errors++;
; 161  :     __xmlRaiseError(NULL, NULL, NULL,
; 162  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 163  : 		    error, XML_ERR_ERROR, NULL, 0,
; 164  : 		    NULL, NULL, NULL, 0, 0,
; 165  : 		    "%s", msg);
; 166  : }

	pop	ebp
	ret	0
_xmlDebugErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpSpaces
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtDumpSpaces PROC					; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 140  :     if (ctxt->check)
; 141  :         return;
; 142  :     if ((ctxt->output != NULL) && (ctxt->depth > 0)) {

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@xmlCtxtDum
	push	esi
	mov	esi, DWORD PTR [ecx+108]
	test	esi, esi
	jle	SHORT $LN7@xmlCtxtDum

; 143  :         if (ctxt->depth < 50)

	cmp	esi, 50					; 00000032H
	jge	SHORT $LN4@xmlCtxtDum

; 144  :             fprintf(ctxt->output, "%s", &ctxt->shift[100 - 2 * ctxt->depth]);

	mov	eax, 52					; 00000034H
	sub	eax, esi
	lea	eax, DWORD PTR [ecx+eax*2]

; 145  :         else
; 146  :             fprintf(ctxt->output, "%s", ctxt->shift);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 147  :     }
; 148  : }

	pop	ebp
	ret	0
$LN4@xmlCtxtDum:

; 145  :         else
; 146  :             fprintf(ctxt->output, "%s", ctxt->shift);

	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN7@xmlCtxtDum:
	pop	esi
$LN5@xmlCtxtDum:

; 147  :     }
; 148  : }

	pop	ebp
	ret	0
_xmlCtxtDumpSpaces ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlNsCheckScope
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlNsCheckScope PROC					; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN7@xmlNsCheck

; 95   :     xmlNsPtr cur;
; 96   : 
; 97   :     if ((node == NULL) || (ns == NULL))

	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	$LN7@xmlNsCheck

; 99   : 
; 100  :     if ((node->type != XML_ELEMENT_NODE) &&
; 101  : 	(node->type != XML_ATTRIBUTE_NODE) &&
; 102  : 	(node->type != XML_DOCUMENT_NODE) &&
; 103  : 	(node->type != XML_TEXT_NODE) &&
; 104  : 	(node->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	cmp	eax, 1
	je	SHORT $LL2@xmlNsCheck
	cmp	eax, 2
	je	SHORT $LL2@xmlNsCheck
	cmp	eax, 9
	je	SHORT $LL2@xmlNsCheck
	cmp	eax, 3
	je	SHORT $LL2@xmlNsCheck
	cmp	eax, 13					; 0000000dH
	je	SHORT $LL2@xmlNsCheck
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN21@xmlNsCheck
$LL2@xmlNsCheck:

; 105  : 	(node->type != XML_XINCLUDE_START))
; 106  : 	return(-2);
; 107  : 
; 108  :     while ((node != NULL) &&

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 1
	je	SHORT $LN11@xmlNsCheck
	cmp	eax, 2
	je	SHORT $LN9@xmlNsCheck
	cmp	eax, 3
	je	SHORT $LN9@xmlNsCheck
	cmp	eax, 19					; 00000013H
	je	SHORT $LN11@xmlNsCheck

; 125  :     }
; 126  :     /* the xml namespace may be declared on the document node */
; 127  :     if ((node != NULL) &&

	cmp	eax, 9
	je	SHORT $LN15@xmlNsCheck
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN37@xmlNsCheck
$LN15@xmlNsCheck:

; 128  :         ((node->type == XML_DOCUMENT_NODE) ||
; 129  : 	 (node->type == XML_HTML_DOCUMENT_NODE))) {
; 130  : 	 xmlNsPtr oldNs = ((xmlDocPtr) node)->oldNs;
; 131  : 	 if (oldNs == ns)

	cmp	DWORD PTR [ebx+52], edi
	jne	SHORT $LN37@xmlNsCheck
$LN32@xmlNsCheck:
	pop	esi
	pop	edi

; 132  : 	     return(1);

	mov	eax, 1

; 135  : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlNsCheck:

; 109  :            ((node->type == XML_ELEMENT_NODE) ||
; 110  :             (node->type == XML_ATTRIBUTE_NODE) ||
; 111  :             (node->type == XML_TEXT_NODE) ||
; 112  : 	    (node->type == XML_XINCLUDE_START))) {
; 113  : 	if ((node->type == XML_ELEMENT_NODE) ||

	cmp	eax, 19					; 00000013H
	jne	SHORT $LN5@xmlNsCheck
$LN11@xmlNsCheck:

; 114  : 	    (node->type == XML_XINCLUDE_START)) {
; 115  : 	    cur = node->nsDef;

	mov	esi, DWORD PTR [ebx+48]

; 116  : 	    while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlNsCheck
$LL4@xmlNsCheck:

; 117  : 	        if (cur == ns)

	cmp	esi, edi
	je	SHORT $LN32@xmlNsCheck

; 118  : 		    return(1);
; 119  : 		if (xmlStrEqual(cur->prefix, ns->prefix))

	push	DWORD PTR [edi+12]
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlNsCheck

; 121  : 		cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	SHORT $LL4@xmlNsCheck
$LN5@xmlNsCheck:

; 122  : 	    }
; 123  : 	}
; 124  : 	node = node->parent;

	mov	ebx, DWORD PTR [ebx+20]
	test	ebx, ebx
	jne	SHORT $LL2@xmlNsCheck
$LN37@xmlNsCheck:
	pop	esi
	pop	edi

; 133  :     }
; 134  :     return(-3);

	mov	eax, -3					; fffffffdH

; 135  : }

	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlNsCheck:
	pop	esi
	pop	edi

; 120  : 		    return(-2);

	mov	eax, -2					; fffffffeH

; 135  : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlNsCheck:
	pop	edi

; 98   :         return(-1);

	or	eax, -1

; 135  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlNsCheckScope ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpCleanCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtDumpCleanCtxt PROC				; COMDAT
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlCtxtDumpCleanCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpInitCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtDumpInitCtxt PROC				; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	1
	mov	DWORD PTR [esi+108], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+128], 0
	call	DWORD PTR __imp____acrt_iob_func
	movaps	xmm0, XMMWORD PTR __xmm@20202020202020202020202020202020
	add	esp, 4
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+112], 0
	mov	DWORD PTR [esi+116], 0
	mov	DWORD PTR [esi+120], 0
	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+136], 0
	movups	XMMWORD PTR [esi+4], xmm0
	movups	XMMWORD PTR [esi+20], xmm0
	movups	XMMWORD PTR [esi+36], xmm0
	movups	XMMWORD PTR [esi+52], xmm0
	movups	XMMWORD PTR [esi+68], xmm0
	movups	XMMWORD PTR [esi+84], xmm0
	mov	DWORD PTR [esi+100], 538976288		; 20202020H
	mov	BYTE PTR [esi+104], 0
	pop	esi

; 59   :     int i;
; 60   : 
; 61   :     ctxt->depth = 0;
; 62   :     ctxt->check = 0;
; 63   :     ctxt->errors = 0;
; 64   :     ctxt->output = stdout;
; 65   :     ctxt->doc = NULL;
; 66   :     ctxt->node = NULL;
; 67   :     ctxt->dict = NULL;
; 68   :     ctxt->nodict = 0;
; 69   :     ctxt->options = 0;
; 70   :     for (i = 0; i < 100; i++)
; 71   :         ctxt->shift[i] = ' ';
; 72   :     ctxt->shift[100] = 0;
; 73   : }

	pop	ebp
	ret	0
_xmlCtxtDumpInitCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNodeList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpNodeList PROC				; COMDAT

; 1090 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlCtxtDum
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
$LN6@xmlCtxtDum:

; 1071 :     xmlCtxtDumpOneNode(ctxt, node);

	push	edi
	push	esi
	call	_xmlCtxtDumpOneNode

; 1072 :     if ((node->type != XML_NAMESPACE_DECL) &&
; 1073 :         (node->children != NULL) && (node->type != XML_ENTITY_REF_NODE)) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 8
	cmp	eax, 18					; 00000012H
	je	SHORT $LN8@xmlCtxtDum
	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN8@xmlCtxtDum
	cmp	eax, 5
	je	SHORT $LN8@xmlCtxtDum

; 1074 :         ctxt->depth++;

	inc	DWORD PTR [esi+108]

; 1075 :         xmlCtxtDumpNodeList(ctxt, node->children);

	push	DWORD PTR [edi+12]
	push	esi
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1076 :         ctxt->depth--;

	dec	DWORD PTR [esi+108]
$LN8@xmlCtxtDum:

; 1091 :     while (node != NULL) {
; 1092 :         xmlCtxtDumpNode(ctxt, node);
; 1093 :         node = node->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LN6@xmlCtxtDum
	pop	esi
$LN3@xmlCtxtDum:
	pop	edi

; 1094 :     }
; 1095 : }

	pop	ebp
	ret	0
_xmlCtxtDumpNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShell
_TEXT	SEGMENT
_dir$1 = -1512						; size = 500
_dir$2 = -1512						; size = 500
_prompt$ = -1012					; size = 500
_arg$ = -512						; size = 400
_command$ = -112					; size = 100
_results$3 = -12					; size = 4
_prefix$1$ = -8						; size = 4
_cmdline$1$ = -4					; size = 4
_nsListDup$1$ = 8					; size = 4
tv2190 = 8						; size = 4
_list$6$ = 8						; size = 4
_list$4$ = 8						; size = 4
_i$2$ = 8						; size = 4
_len$4 = 8						; size = 4
_doc$ = 8						; size = 4
_filename$ = 12						; size = 4
_input$ = 16						; size = 4
_output$ = 20						; size = 4
_xmlShell PROC						; COMDAT

; 2810 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1512				; 000005e8H
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR ??_C@_04GBAPPDDB@?1?5?$DO?5@
	mov	DWORD PTR _prompt$[ebp], eax
	mov	al, BYTE PTR ??_C@_04GBAPPDDB@?1?5?$DO?5@+4
	push	495					; 000001efH
	mov	BYTE PTR _prompt$[ebp+4], al
	lea	eax, DWORD PTR _prompt$[ebp+5]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN194@xmlShell

; 2811 :     char prompt[500] = "/ > ";
; 2812 :     char *cmdline = NULL, *cur;
; 2813 :     char command[100];
; 2814 :     char arg[400];
; 2815 :     int i;
; 2816 :     xmlShellCtxtPtr ctxt;
; 2817 :     xmlXPathObjectPtr list;
; 2818 : 
; 2819 :     if (doc == NULL)
; 2820 :         return;
; 2821 :     if (filename == NULL)

	push	edi
	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	je	$LN648@xmlShell

; 2822 :         return;
; 2823 :     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	je	$LN648@xmlShell

; 2824 :         return;
; 2825 :     if (output == NULL)

	push	esi
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN37@xmlShell

; 2826 :         output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN37@xmlShell:

; 2827 :     ctxt = (xmlShellCtxtPtr) xmlMalloc(sizeof(xmlShellCtxt));

	push	ebx
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 2828 :     if (ctxt == NULL)

	test	ebx, ebx
	je	$LN650@xmlShell

; 2829 :         return;
; 2830 :     ctxt->loaded = 0;
; 2831 :     ctxt->doc = doc;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ebx+4], eax

; 2832 :     ctxt->input = input;

	mov	eax, DWORD PTR _input$[ebp]

; 2833 :     ctxt->output = output;
; 2834 :     ctxt->filename = (char *) xmlStrdup((xmlChar *) filename);

	push	edi
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+24], eax
	mov	DWORD PTR [ebx+20], esi
	call	_xmlStrdup
	mov	DWORD PTR [ebx], eax

; 2835 :     ctxt->node = (xmlNodePtr) ctxt->doc;

	mov	eax, DWORD PTR [ebx+4]

; 2836 : 
; 2837 : #ifdef LIBXML_XPATH_ENABLED
; 2838 :     ctxt->pctxt = xmlXPathNewContext(ctxt->doc);

	push	eax
	mov	DWORD PTR [ebx+8], eax
	call	_xmlXPathNewContext
	add	esp, 8
	mov	DWORD PTR [ebx+12], eax

; 2839 :     if (ctxt->pctxt == NULL) {

	test	eax, eax
	jne	SHORT $LN551@xmlShell

; 2840 :         xmlFree(ctxt);

	push	ebx
	call	DWORD PTR _xmlFree

; 3423 :         free(cmdline);          /* not xmlFree here ! */

	add	esp, 4
	pop	ebx
	pop	esi
	pop	edi

; 3424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN551@xmlShell:
	mov	edi, DWORD PTR __imp__free
$LL2@xmlShell:

; 2841 :         return;
; 2842 :     }
; 2843 : #endif /* LIBXML_XPATH_ENABLED */
; 2844 :     while (1) {
; 2845 :         if (ctxt->node == (xmlNodePtr) ctxt->doc)

	mov	eax, DWORD PTR [ebx+8]
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN40@xmlShell

; 2846 :             snprintf(prompt, sizeof(prompt), "%s > ", "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
	jmp	SHORT $LN653@xmlShell
$LN40@xmlShell:

; 2847 :         else if ((ctxt->node != NULL) && (ctxt->node->name) &&
; 2848 :                  (ctxt->node->ns) && (ctxt->node->ns->prefix))

	test	eax, eax
	je	SHORT $LN44@xmlShell
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN44@xmlShell
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN42@xmlShell
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN42@xmlShell

; 2849 :             snprintf(prompt, sizeof(prompt), "%s:%s > ",

	push	ecx
	push	eax
	push	OFFSET ??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@
	lea	eax, DWORD PTR _prompt$[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN45@xmlShell
$LN42@xmlShell:

; 2850 :                      (ctxt->node->ns->prefix), ctxt->node->name);
; 2851 :         else if ((ctxt->node != NULL) && (ctxt->node->name))

	test	ecx, ecx
	je	SHORT $LN44@xmlShell

; 2852 :             snprintf(prompt, sizeof(prompt), "%s > ", ctxt->node->name);

	push	ecx
$LN653@xmlShell:

; 2855 :         prompt[sizeof(prompt) - 1] = 0;

	push	OFFSET ??_C@_05LMGNBDMA@?$CFs?5?$DO?5@
	lea	eax, DWORD PTR _prompt$[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN45@xmlShell
$LN44@xmlShell:

; 2853 :         else
; 2854 :             snprintf(prompt, sizeof(prompt), "? > ");

	push	OFFSET ??_C@_04BOPGELD@?$DP?5?$DO?5@
	lea	eax, DWORD PTR _prompt$[ebp]
	push	500					; 000001f4H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
$LN45@xmlShell:

; 2856 : 
; 2857 :         /*
; 2858 :          * Get a new command line
; 2859 :          */
; 2860 :         cmdline = ctxt->input(prompt);

	lea	eax, DWORD PTR _prompt$[ebp]
	mov	BYTE PTR _prompt$[ebp+499], 0
	push	eax
	mov	eax, DWORD PTR [ebx+24]
	call	eax
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _cmdline$1$[ebp], esi

; 2861 :         if (cmdline == NULL)

	test	esi, esi
	je	$LN279@xmlShell

; 2862 :             break;
; 2863 : 
; 2864 :         /*
; 2865 :          * Parse the command itself
; 2866 :          */
; 2867 :         cur = cmdline;

	mov	ecx, esi
$LL4@xmlShell:

; 2868 :         while ((*cur == ' ') || (*cur == '\t'))

	mov	dl, BYTE PTR [ecx]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN329@xmlShell
	cmp	dl, 9
	jne	SHORT $LN5@xmlShell
$LN329@xmlShell:

; 2869 :             cur++;

	inc	ecx
	jmp	SHORT $LL4@xmlShell
$LN5@xmlShell:

; 2870 :         i = 0;

	lea	esi, DWORD PTR _command$[ebp]
	xor	eax, eax
	sub	esi, ecx
	npad	2
$LL6@xmlShell:

; 2871 :         while ((*cur != ' ') && (*cur != '\t') &&
; 2872 :                (*cur != '\n') && (*cur != '\r')) {

	cmp	dl, 9
	je	SHORT $LN272@xmlShell
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN272@xmlShell
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN272@xmlShell

; 2873 :             if (*cur == 0)

	test	dl, dl
	je	SHORT $LN272@xmlShell

; 2874 :                 break;
; 2875 :             command[i++] = *cur++;

	mov	BYTE PTR [esi+ecx], dl
	inc	eax
	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	cmp	dl, 32					; 00000020H
	jne	SHORT $LL6@xmlShell
$LN272@xmlShell:

; 2876 :         }
; 2877 :         command[i] = 0;

	mov	BYTE PTR _command$[ebp+eax], 0

; 2878 :         if (i == 0)

	test	eax, eax
	je	$LL2@xmlShell
	npad	3
$LL8@xmlShell:

; 2879 :             continue;
; 2880 : 
; 2881 :         /*
; 2882 :          * Parse the argument
; 2883 :          */
; 2884 :         while ((*cur == ' ') || (*cur == '\t'))

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN330@xmlShell
	cmp	al, 9
	jne	SHORT $LN9@xmlShell
$LN330@xmlShell:

; 2885 :             cur++;

	inc	ecx
	jmp	SHORT $LL8@xmlShell
$LN9@xmlShell:

; 2886 :         i = 0;

	xor	esi, esi
	mov	DWORD PTR _i$2$[ebp], esi

; 2887 :         while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	cmp	al, 10					; 0000000aH
	je	SHORT $LN273@xmlShell

; 2879 :             continue;
; 2880 : 
; 2881 :         /*
; 2882 :          * Parse the argument
; 2883 :          */
; 2884 :         while ((*cur == ' ') || (*cur == '\t'))

	lea	edx, DWORD PTR _arg$[ebp]
	sub	edx, ecx
	npad	2
$LL10@xmlShell:

; 2887 :         while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	cmp	al, 13					; 0000000dH
	je	SHORT $LN618@xmlShell
	test	al, al
	je	SHORT $LN618@xmlShell

; 2888 :             if (*cur == 0)
; 2889 :                 break;
; 2890 :             arg[i++] = *cur++;

	mov	BYTE PTR [edx+ecx], al
	inc	esi
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	cmp	al, 10					; 0000000aH
	jne	SHORT $LL10@xmlShell
$LN618@xmlShell:
	mov	DWORD PTR _i$2$[ebp], esi
$LN273@xmlShell:

; 2891 :         }
; 2892 :         arg[i] = 0;

	mov	BYTE PTR _arg$[ebp+esi], 0

; 2893 : 
; 2894 :         /*
; 2895 :          * start interpreting the command
; 2896 :          */
; 2897 :         if (!strcmp(command, "exit"))

	lea	eax, DWORD PTR _command$[ebp]
	mov	ecx, OFFSET ??_C@_04MKNBDEPB@exit@
$LL409@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN410@xmlShell
	test	dl, dl
	je	SHORT $LN411@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN410@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL409@xmlShell
$LN411@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN412@xmlShell
$LN410@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN412@xmlShell:
	test	eax, eax
	je	$LN622@xmlShell

; 2898 :             break;
; 2899 :         if (!strcmp(command, "quit"))

	mov	ecx, OFFSET ??_C@_04KNNLNNGO@quit@
	lea	eax, DWORD PTR _command$[ebp]
	npad	4
$LL413@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN414@xmlShell
	test	dl, dl
	je	SHORT $LN415@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN414@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL413@xmlShell
$LN415@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN416@xmlShell
$LN414@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN416@xmlShell:
	test	eax, eax
	je	$LN622@xmlShell

; 2900 :             break;
; 2901 :         if (!strcmp(command, "bye"))

	mov	ecx, OFFSET ??_C@_03MDONDFG@bye@
	lea	eax, DWORD PTR _command$[ebp]
$LL417@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN418@xmlShell
	test	dl, dl
	je	SHORT $LN419@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN418@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL417@xmlShell
$LN419@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN420@xmlShell
$LN418@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN420@xmlShell:
	test	eax, eax
	je	$LN622@xmlShell

; 2902 :             break;
; 2903 : 		if (!strcmp(command, "help")) {

	mov	ecx, OFFSET ??_C@_04PCJFHION@help@
	lea	eax, DWORD PTR _command$[ebp]
	npad	6
$LL421@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN422@xmlShell
	test	dl, dl
	je	SHORT $LN423@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN422@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL421@xmlShell
$LN423@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN424@xmlShell
$LN422@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN424@xmlShell:
	test	eax, eax
	jne	$LN55@xmlShell

; 2904 : 		  fprintf(ctxt->output, "\tbase         display XML base of the node\n");

	push	OFFSET ??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2905 : 		  fprintf(ctxt->output, "\tsetbase URI  change the XML base of the node\n");

	push	OFFSET ??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2906 : 		  fprintf(ctxt->output, "\tbye          leave shell\n");

	push	OFFSET ??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2907 : 		  fprintf(ctxt->output, "\tcat [node]   display node or current node\n");

	push	OFFSET ??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2908 : 		  fprintf(ctxt->output, "\tcd [path]    change directory to path or to root\n");

	push	OFFSET ??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2909 : 		  fprintf(ctxt->output, "\tdir [path]   dumps informations about the node (namespace, attributes, content)\n");

	push	OFFSET ??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2910 : 		  fprintf(ctxt->output, "\tdu [path]    show the structure of the subtree under path or the current node\n");

	push	OFFSET ??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2911 : 		  fprintf(ctxt->output, "\texit         leave shell\n");

	push	OFFSET ??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 64					; 00000040H

; 2912 : 		  fprintf(ctxt->output, "\thelp         display this help\n");

	push	OFFSET ??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2913 : 		  fprintf(ctxt->output, "\tfree         display memory usage\n");

	push	OFFSET ??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2914 : 		  fprintf(ctxt->output, "\tload [name]  load a new document with name\n");

	push	OFFSET ??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2915 : 		  fprintf(ctxt->output, "\tls [path]    list contents of path or the current directory\n");

	push	OFFSET ??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2916 : 		  fprintf(ctxt->output, "\tset xml_fragment replace the current node content with the fragment parsed in context\n");

	push	OFFSET ??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2917 : #ifdef LIBXML_XPATH_ENABLED
; 2918 : 		  fprintf(ctxt->output, "\txpath expr   evaluate the XPath expression in that context and print the result\n");

	push	OFFSET ??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2919 : 		  fprintf(ctxt->output, "\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n");

	push	OFFSET ??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2920 : 		  fprintf(ctxt->output, "\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n");

	push	OFFSET ??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 64					; 00000040H

; 2921 : 		  fprintf(ctxt->output, "\tsetrootns    register all namespace found on the root element\n");

	push	OFFSET ??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2922 : 		  fprintf(ctxt->output, "\t             the default namespace if any uses 'defaultns' prefix\n");

	push	OFFSET ??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2923 : #endif /* LIBXML_XPATH_ENABLED */
; 2924 : 		  fprintf(ctxt->output, "\tpwd          display current working directory\n");

	push	OFFSET ??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2925 : 		  fprintf(ctxt->output, "\twhereis      display absolute path of [path] or current working directory\n");

	push	OFFSET ??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2926 : 		  fprintf(ctxt->output, "\tquit         leave shell\n");

	push	OFFSET ??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2927 : #ifdef LIBXML_OUTPUT_ENABLED
; 2928 : 		  fprintf(ctxt->output, "\tsave [name]  save this document to name or the original name\n");

	push	OFFSET ??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2929 : 		  fprintf(ctxt->output, "\twrite [name] write the current node to the filename\n");

	push	OFFSET ??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2930 : #endif /* LIBXML_OUTPUT_ENABLED */
; 2931 : #ifdef LIBXML_VALID_ENABLED
; 2932 : 		  fprintf(ctxt->output, "\tvalidate     check the document for errors\n");

	push	OFFSET ??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 64					; 00000040H

; 2933 : #endif /* LIBXML_VALID_ENABLED */
; 2934 : #ifdef LIBXML_SCHEMAS_ENABLED
; 2935 : 		  fprintf(ctxt->output, "\trelaxng rng  validate the document against the Relax-NG schemas\n");

	push	OFFSET ??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2936 : #endif
; 2937 : 		  fprintf(ctxt->output, "\tgrep string  search for a string in the subtree\n");

	push	OFFSET ??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN55@xmlShell:

; 2938 : #ifdef LIBXML_VALID_ENABLED
; 2939 :         } else if (!strcmp(command, "validate")) {

	mov	ecx, OFFSET ??_C@_08EBLJJHKN@validate@
	lea	eax, DWORD PTR _command$[ebp]
$LL425@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN426@xmlShell
	test	dl, dl
	je	SHORT $LN427@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN426@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL425@xmlShell
$LN427@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN428@xmlShell
$LN426@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN428@xmlShell:
	test	eax, eax
	jne	SHORT $LN57@xmlShell

; 2940 :             xmlShellValidate(ctxt, arg, NULL, NULL);

	push	eax
	push	eax
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	ebx
	call	_xmlShellValidate
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN57@xmlShell:

; 2941 : #endif /* LIBXML_VALID_ENABLED */
; 2942 :         } else if (!strcmp(command, "load")) {

	mov	ecx, OFFSET ??_C@_04EONOHKEP@load@
	lea	eax, DWORD PTR _command$[ebp]
$LL429@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN430@xmlShell
	test	dl, dl
	je	SHORT $LN431@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN430@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL429@xmlShell
$LN431@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN432@xmlShell
$LN430@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN432@xmlShell:
	test	eax, eax
	jne	SHORT $LN59@xmlShell

; 2943 :             xmlShellLoad(ctxt, arg, NULL, NULL);

	push	eax
	push	eax
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	ebx
	call	_xmlShellLoad
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN59@xmlShell:

; 2944 : #ifdef LIBXML_SCHEMAS_ENABLED
; 2945 :         } else if (!strcmp(command, "relaxng")) {

	mov	ecx, OFFSET ??_C@_07LADMNHNM@relaxng@
	lea	eax, DWORD PTR _command$[ebp]
$LL433@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN434@xmlShell
	test	dl, dl
	je	SHORT $LN435@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN434@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL433@xmlShell
$LN435@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN436@xmlShell
$LN434@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN436@xmlShell:
	test	eax, eax
	jne	$LN61@xmlShell

; 2365 :     ctxt = xmlRelaxNGNewParserCtxt(schemas);

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlRelaxNGNewParserCtxt

; 2366 :     xmlRelaxNGSetParserErrors(ctxt,

	push	2
	mov	esi, eax
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	push	esi
	call	_xmlRelaxNGSetParserErrors

; 2367 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2368 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2369 : 	    stderr);
; 2370 :     relaxngschemas = xmlRelaxNGParse(ctxt);

	push	esi
	call	_xmlRelaxNGParse

; 2371 :     xmlRelaxNGFreeParserCtxt(ctxt);

	push	esi
	mov	edi, eax
	call	_xmlRelaxNGFreeParserCtxt
	add	esp, 32					; 00000020H

; 2372 :     if (relaxngschemas == NULL) {

	test	edi, edi
	jne	SHORT $LN197@xmlShell

; 2373 : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free

; 2373 : 	xmlGenericError(xmlGenericErrorContext,

	add	esp, 12					; 0000000cH

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN197@xmlShell:

; 2377 :     vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);

	push	edi
	call	_xmlRelaxNGNewValidCtxt

; 2378 :     xmlRelaxNGSetValidErrors(vctxt,

	push	2
	mov	esi, eax
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	push	esi
	call	_xmlRelaxNGSetValidErrors

; 2379 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2380 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2381 : 	    stderr);
; 2382 :     ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);

	push	DWORD PTR [ebx+4]
	push	esi
	call	_xmlRelaxNGValidateDoc
	mov	ecx, DWORD PTR [ebx]
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv2190[ebp], ecx

; 2383 :     if (ret == 0) {

	push	2
	test	eax, eax
	jne	SHORT $LN655@xmlShell

; 2384 : 	fprintf(stderr, "%s validates\n", sctxt->filename);

	call	DWORD PTR __imp____acrt_iob_func
	mov	ecx, OFFSET ??_C@_0O@DFGOKOFF@?$CFs?5validates?6@
	jmp	SHORT $LN656@xmlShell
$LN655@xmlShell:

; 2385 :     } else if (ret > 0) {

	jle	SHORT $LN200@xmlShell

; 2386 : 	fprintf(stderr, "%s fails to validate\n", sctxt->filename);

	call	DWORD PTR __imp____acrt_iob_func
	mov	ecx, OFFSET ??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@

; 2387 :     } else {

	jmp	SHORT $LN656@xmlShell
$LN200@xmlShell:

; 2388 : 	fprintf(stderr, "%s validation generated an internal error\n",

	call	DWORD PTR __imp____acrt_iob_func
	mov	ecx, OFFSET ??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@
$LN656@xmlShell:

; 2389 : 	       sctxt->filename);
; 2390 :     }
; 2391 :     xmlRelaxNGFreeValidCtxt(vctxt);

	add	esp, 4
	push	DWORD PTR tv2190[ebp]
	push	ecx
	push	eax
	call	_fprintf
	push	esi
	call	_xmlRelaxNGFreeValidCtxt

; 2392 :     if (relaxngschemas != NULL)
; 2393 : 	xmlRelaxNGFree(relaxngschemas);

	push	edi
	call	_xmlRelaxNGFree

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free

; 2393 : 	xmlRelaxNGFree(relaxngschemas);

	add	esp, 20					; 00000014H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN61@xmlShell:

; 2946 :             xmlShellRNGValidate(ctxt, arg, NULL, NULL);
; 2947 : #endif
; 2948 : #ifdef LIBXML_OUTPUT_ENABLED
; 2949 :         } else if (!strcmp(command, "save")) {

	mov	ecx, OFFSET ??_C@_04EMMDIJJL@save@
	lea	eax, DWORD PTR _command$[ebp]
$LL437@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN438@xmlShell
	test	dl, dl
	je	SHORT $LN439@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN438@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL437@xmlShell
$LN439@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN440@xmlShell
$LN438@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN440@xmlShell:
	test	eax, eax
	jne	SHORT $LN63@xmlShell

; 2950 :             xmlShellSave(ctxt, arg, NULL, NULL);

	push	eax
	push	eax
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	ebx
	call	_xmlShellSave
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN63@xmlShell:

; 2951 :         } else if (!strcmp(command, "write")) {

	mov	ecx, OFFSET ??_C@_05NGFEDHGN@write@
	lea	eax, DWORD PTR _command$[ebp]
$LL441@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN442@xmlShell
	test	dl, dl
	je	SHORT $LN443@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN442@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL441@xmlShell
$LN443@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN444@xmlShell
$LN442@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN444@xmlShell:
	test	eax, eax
	jne	SHORT $LN65@xmlShell

; 2952 : 	    if (arg[0] == 0)

	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN67@xmlShell

; 2953 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN67@xmlShell:

; 2954 :                         "Write command requires a filename argument\n");
; 2955 : 	    else
; 2956 : 		xmlShellWrite(ctxt, arg, ctxt->node, NULL);

	push	0
	push	DWORD PTR [ebx+8]
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	ebx
	call	_xmlShellWrite
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN65@xmlShell:

; 2957 : #endif /* LIBXML_OUTPUT_ENABLED */
; 2958 :         } else if (!strcmp(command, "grep")) {

	mov	ecx, OFFSET ??_C@_04LCNKLLJF@grep@
	lea	eax, DWORD PTR _command$[ebp]
$LL445@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN446@xmlShell
	test	dl, dl
	je	SHORT $LN447@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN446@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL445@xmlShell
$LN447@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN448@xmlShell
$LN446@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN448@xmlShell:
	test	eax, eax
	jne	$LN69@xmlShell

; 2959 :             xmlShellGrep(ctxt, arg, ctxt->node, NULL);

	mov	esi, DWORD PTR [ebx+8]

; 2203 :     if (node == NULL)

	test	esi, esi
	je	$LN115@xmlShell

; 2204 : 	return (0);
; 2205 :     if (arg == NULL)
; 2206 : 	return (0);
; 2207 : #ifdef LIBXML_REGEXP_ENABLED
; 2208 :     if ((xmlStrchr((xmlChar *) arg, '?')) ||
; 2209 : 	(xmlStrchr((xmlChar *) arg, '*')) ||
; 2210 : 	(xmlStrchr((xmlChar *) arg, '.')) ||

	lea	eax, DWORD PTR _arg$[ebp]
	push	63					; 0000003fH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL205@xmlShell
	lea	eax, DWORD PTR _arg$[ebp]
	push	42					; 0000002aH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL205@xmlShell
	lea	eax, DWORD PTR _arg$[ebp]
	push	46					; 0000002eH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL205@xmlShell
	lea	eax, DWORD PTR _arg$[ebp]
	push	91					; 0000005bH
	push	eax
	call	_xmlStrchr
	add	esp, 8
	npad	3
$LL205@xmlShell:

; 2215 :         if (node->type == XML_COMMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 8
	jne	SHORT $LN214@xmlShell

; 2216 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	DWORD PTR [esi+40]
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN218@xmlShell

; 2217 : 
; 2218 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node));

	push	esi
	call	_xmlGetNodePath
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2219 :                 xmlShellList(ctxt, NULL, node, NULL);

	push	0
	push	esi

; 2220 : 	    }

	jmp	SHORT $LN657@xmlShell
$LN214@xmlShell:

; 2221 :         } else if (node->type == XML_TEXT_NODE) {

	cmp	eax, 3
	jne	SHORT $LN218@xmlShell

; 2222 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	DWORD PTR [esi+40]
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN218@xmlShell

; 2223 : 
; 2224 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node->parent));

	push	DWORD PTR [esi+20]
	call	_xmlGetNodePath
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2225 :                 xmlShellList(ctxt, NULL, node->parent, NULL);

	push	0
	push	DWORD PTR [esi+20]
$LN657@xmlShell:

; 2226 : 	    }
; 2227 :         }
; 2228 : 
; 2229 :         /*
; 2230 :          * Browse the full subtree, deep first
; 2231 :          */
; 2232 : 
; 2233 :         if ((node->type == XML_DOCUMENT_NODE) ||

	push	0
	push	ebx
	call	_xmlShellList
	add	esp, 32					; 00000020H
$LN218@xmlShell:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	je	SHORT $LN221@xmlShell
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN221@xmlShell

; 2236 :         } else if ((node->children != NULL)
; 2237 :                    && (node->type != XML_ENTITY_REF_NODE)) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN381@xmlShell
	cmp	eax, 5
	je	SHORT $LN381@xmlShell

; 2238 :             /* deep first */
; 2239 :             node = node->children;

	mov	esi, ecx
	jmp	SHORT $LN208@xmlShell
$LN381@xmlShell:

; 2240 :         } else if (node->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL207@xmlShell
$LN274@xmlShell:

; 2211 : 	(xmlStrchr((xmlChar *) arg, '['))) {
; 2212 :     }
; 2213 : #endif
; 2214 :     while (node != NULL) {

	mov	esi, eax
	jmp	SHORT $LN208@xmlShell
$LL207@xmlShell:

; 2241 :             /* then siblings */
; 2242 :             node = node->next;
; 2243 :         } else {
; 2244 :             /* go up to parents->next if needed */
; 2245 :             while (node != NULL) {
; 2246 :                 if (node->parent != NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	cmovne	esi, eax

; 2247 :                     node = node->parent;
; 2248 :                 }
; 2249 :                 if (node->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN274@xmlShell

; 2250 :                     node = node->next;
; 2251 :                     break;
; 2252 :                 }
; 2253 :                 if (node->parent == NULL) {

	cmp	DWORD PTR [esi+20], eax
	jne	SHORT $LL207@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN221@xmlShell:

; 2235 :             node = ((xmlDocPtr) node)->children;

	mov	esi, DWORD PTR [esi+12]
$LN208@xmlShell:

; 2211 : 	(xmlStrchr((xmlChar *) arg, '['))) {
; 2212 :     }
; 2213 : #endif
; 2214 :     while (node != NULL) {

	test	esi, esi
	jne	$LL205@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN69@xmlShell:

; 2960 :         } else if (!strcmp(command, "free")) {

	mov	ecx, OFFSET ??_C@_04LIAPHEDB@free@
	lea	eax, DWORD PTR _command$[ebp]
$LL449@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN450@xmlShell
	test	dl, dl
	je	SHORT $LN451@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN450@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL449@xmlShell
$LN451@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN452@xmlShell
$LN450@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN452@xmlShell:
	test	eax, eax
	jne	SHORT $LN71@xmlShell

; 2961 :             if (arg[0] == 0) {

	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN73@xmlShell

; 2962 :                 xmlMemShow(ctxt->output, 0);

	push	eax
	push	DWORD PTR [ebx+20]
	call	_xmlMemShow
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN73@xmlShell:

; 2963 :             } else {
; 2964 :                 int len = 0;
; 2965 : 
; 2966 :                 sscanf(arg, "%d", &len);

	lea	eax, DWORD PTR _len$4[ebp]
	mov	DWORD PTR _len$4[ebp], 0
	push	eax
	lea	eax, DWORD PTR _arg$[ebp]
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	push	eax
	call	_sscanf

; 2967 :                 xmlMemShow(ctxt->output, len);

	push	DWORD PTR _len$4[ebp]
	push	DWORD PTR [ebx+20]
	call	_xmlMemShow
	add	esp, 20					; 00000014H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN71@xmlShell:

; 2968 :             }
; 2969 :         } else if (!strcmp(command, "pwd")) {

	mov	ecx, OFFSET ??_C@_03OFKLFAAJ@pwd@
	lea	eax, DWORD PTR _command$[ebp]
	npad	6
$LL453@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN454@xmlShell
	test	dl, dl
	je	SHORT $LN455@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN454@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL453@xmlShell
$LN455@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN456@xmlShell
$LN454@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN456@xmlShell:
	test	eax, eax
	jne	SHORT $LN75@xmlShell

; 2970 :             char dir[500];
; 2971 : 
; 2972 :             if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))

	push	eax
	push	DWORD PTR [ebx+8]
$LN664@xmlShell:

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	lea	eax, DWORD PTR _dir$2[ebp]
	push	eax
	push	ebx
	call	_xmlShellPwd
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN115@xmlShell
	lea	eax, DWORD PTR _dir$2[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 12					; 0000000cH
	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN75@xmlShell:

; 2973 :                 fprintf(ctxt->output, "%s\n", dir);
; 2974 :         } else if (!strcmp(command, "du")) {

	mov	ecx, OFFSET ??_C@_02BNCIMIKC@du@
	lea	eax, DWORD PTR _command$[ebp]
$LL457@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN458@xmlShell
	test	dl, dl
	je	SHORT $LN459@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN458@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL457@xmlShell
$LN459@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN460@xmlShell
$LN458@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN460@xmlShell:
	test	eax, eax
	jne	$LN78@xmlShell

; 2975 :             if (arg[0] == 0) {

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN80@xmlShell

; 2976 :                 xmlShellDu(ctxt, NULL, ctxt->node, NULL);

	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_xmlShellDu
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN80@xmlShell:

; 2977 :             } else {
; 2978 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+4], ecx

; 2979 : #ifdef LIBXML_XPATH_ENABLED
; 2980 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 2981 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	lea	eax, DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlXPathEval
	mov	edi, eax
	add	esp, 8

; 2982 : #else
; 2983 :                 list = NULL;
; 2984 : #endif /* LIBXML_XPATH_ENABLED */
; 2985 :                 if (list != NULL) {

	test	edi, edi
	je	$LN118@xmlShell

; 2986 :                     switch (list->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 9
	ja	$LN12@xmlShell
	jmp	DWORD PTR $LN666@xmlShell[eax*4]
$LN84@xmlShell:

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	jmp	$LN658@xmlShell
$LN85@xmlShell:

; 2987 :                         case XPATH_UNDEFINED:
; 2988 :                             xmlGenericError(xmlGenericErrorContext,
; 2989 :                                             "%s: no such node\n", arg);
; 2990 :                             break;
; 2991 :                         case XPATH_NODESET:{
; 2992 :                             int indx;
; 2993 : 
; 2994 :                             if (list->nodesetval == NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN12@xmlShell

; 2995 :                                 break;
; 2996 : 
; 2997 :                             for (indx = 0;

	xor	esi, esi

; 2998 :                                  indx < list->nodesetval->nodeNr;

	cmp	DWORD PTR [eax], esi
	jle	$LN12@xmlShell
$LL16@xmlShell:

; 2999 :                                  indx++)
; 3000 :                                 xmlShellDu(ctxt, NULL,

	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR [eax+esi*4]
	push	0
	push	ebx
	call	_xmlShellDu
	mov	eax, DWORD PTR [edi+4]
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL16@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN87@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	jmp	$LN658@xmlShell
$LN88@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	jmp	$LN658@xmlShell
$LN89@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	jmp	$LN658@xmlShell
$LN90@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	jmp	SHORT $LN658@xmlShell
$LN91@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	jmp	SHORT $LN658@xmlShell
$LN93@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	jmp	SHORT $LN658@xmlShell
$LN94@xmlShell:
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
$LN658@xmlShell:
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN12@xmlShell:
	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN78@xmlShell:

; 3001 :                                            list->nodesetval->
; 3002 :                                            nodeTab[indx], NULL);
; 3003 :                             break;
; 3004 :                         }
; 3005 :                         case XPATH_BOOLEAN:
; 3006 :                             xmlGenericError(xmlGenericErrorContext,
; 3007 :                                             "%s is a Boolean\n", arg);
; 3008 :                             break;
; 3009 :                         case XPATH_NUMBER:
; 3010 :                             xmlGenericError(xmlGenericErrorContext,
; 3011 :                                             "%s is a number\n", arg);
; 3012 :                             break;
; 3013 :                         case XPATH_STRING:
; 3014 :                             xmlGenericError(xmlGenericErrorContext,
; 3015 :                                             "%s is a string\n", arg);
; 3016 :                             break;
; 3017 :                         case XPATH_POINT:
; 3018 :                             xmlGenericError(xmlGenericErrorContext,
; 3019 :                                             "%s is a point\n", arg);
; 3020 :                             break;
; 3021 :                         case XPATH_RANGE:
; 3022 :                             xmlGenericError(xmlGenericErrorContext,
; 3023 :                                             "%s is a range\n", arg);
; 3024 :                             break;
; 3025 :                         case XPATH_LOCATIONSET:
; 3026 :                             xmlGenericError(xmlGenericErrorContext,
; 3027 :                                             "%s is a range\n", arg);
; 3028 :                             break;
; 3029 :                         case XPATH_USERS:
; 3030 :                             xmlGenericError(xmlGenericErrorContext,
; 3031 :                                             "%s is user-defined\n", arg);
; 3032 :                             break;
; 3033 :                         case XPATH_XSLT_TREE:
; 3034 :                             xmlGenericError(xmlGenericErrorContext,
; 3035 :                                             "%s is an XSLT value tree\n",
; 3036 :                                             arg);
; 3037 :                             break;
; 3038 :                     }
; 3039 : #ifdef LIBXML_XPATH_ENABLED
; 3040 :                     xmlXPathFreeObject(list);
; 3041 : #endif
; 3042 :                 } else {
; 3043 :                     xmlGenericError(xmlGenericErrorContext,
; 3044 :                                     "%s: no such node\n", arg);
; 3045 :                 }
; 3046 :                 ctxt->pctxt->node = NULL;
; 3047 :             }
; 3048 :         } else if (!strcmp(command, "base")) {

	mov	ecx, OFFSET ??_C@_04BHIIPFEC@base@
	lea	eax, DWORD PTR _command$[ebp]
$LL461@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN462@xmlShell
	test	dl, dl
	je	SHORT $LN463@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN462@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL461@xmlShell
$LN463@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN464@xmlShell
$LN462@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN464@xmlShell:
	test	eax, eax
	jne	SHORT $LN95@xmlShell

; 3049 :             xmlShellBase(ctxt, NULL, ctxt->node, NULL);

	push	eax
	push	DWORD PTR [ebx+8]
	push	eax
	push	ebx
	call	_xmlShellBase
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN95@xmlShell:

; 3050 :         } else if (!strcmp(command, "set")) {

	mov	ecx, OFFSET ??_C@_03KCHOJKKI@set@
	lea	eax, DWORD PTR _command$[ebp]
$LL465@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN466@xmlShell
	test	dl, dl
	je	SHORT $LN467@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN466@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL465@xmlShell
$LN467@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN468@xmlShell
$LN466@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN468@xmlShell:
	test	eax, eax
	jne	$LN97@xmlShell

; 3051 : 	    xmlShellSetContent(ctxt, arg, ctxt->node, NULL);

	mov	esi, DWORD PTR [ebx+8]

; 2319 :     if (node == NULL) {

	test	esi, esi
	jne	SHORT $LN232@xmlShell

; 2320 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN232@xmlShell:

; 2328 :     ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);

	lea	ecx, DWORD PTR _arg$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL469@xmlShell:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL469@xmlShell
	lea	eax, DWORD PTR _results$3[ebp]
	sub	ecx, edx
	push	eax
	push	0
	push	ecx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	esi
	call	_xmlParseInNodeContext
	add	esp, 20					; 00000014H

; 2329 :     if (ret == XML_ERR_OK) {

	test	eax, eax
	jne	SHORT $LN234@xmlShell

; 2330 : 	if (node->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN236@xmlShell

; 2331 : 	    xmlFreeNodeList(node->children);

	push	eax
	call	_xmlFreeNodeList
	add	esp, 4

; 2332 : 	    node->children = NULL;

	mov	DWORD PTR [esi+12], 0

; 2333 : 	    node->last = NULL;

	mov	DWORD PTR [esi+16], 0
$LN236@xmlShell:

; 2334 : 	}
; 2335 : 	xmlAddChildList(node, results);

	push	DWORD PTR _results$3[ebp]
	push	esi
	call	_xmlAddChildList
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN234@xmlShell:

; 2337 :         fprintf(ctxt->output, "failed to parse content\n");

	push	OFFSET ??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN97@xmlShell:

; 3052 : #ifdef LIBXML_XPATH_ENABLED
; 3053 :         } else if (!strcmp(command, "setns")) {

	mov	ecx, OFFSET ??_C@_05DAFPCCNK@setns@
	lea	eax, DWORD PTR _command$[ebp]
$LL470@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN471@xmlShell
	test	dl, dl
	je	SHORT $LN472@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN471@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL470@xmlShell
$LN472@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN473@xmlShell
$LN471@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN473@xmlShell:
	test	eax, eax
	jne	$LN99@xmlShell

; 3054 :             if (arg[0] == 0) {

	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN101@xmlShell

; 3055 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN101@xmlShell:

; 2117 :     nsListDup = xmlStrdup((xmlChar *) arg);

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _nsListDup$1$[ebp], eax

; 2118 :     next = nsListDup;

	mov	esi, eax

; 2119 :     while(next != NULL) {

	test	eax, eax
	je	$LN240@xmlShell
$LL239@xmlShell:

; 2120 : 	/* skip spaces */
; 2121 : 	/*while((*next) == ' ') next++;*/
; 2122 : 	if((*next) == '\0') break;

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN619@xmlShell

; 2123 : 
; 2124 : 	/* find prefix */
; 2125 : 	prefix = next;
; 2126 : 	next = (xmlChar*)xmlStrchr(next, '=');

	push	61					; 0000003dH
	push	esi
	mov	DWORD PTR _prefix$1$[ebp], esi
	call	_xmlStrchr
	mov	edi, eax
	add	esp, 8

; 2127 : 	if(next == NULL) {

	test	edi, edi
	je	$LN277@xmlShell

; 2130 : 	    return(-1);
; 2131 : 	}
; 2132 : 	*(next++) = '\0';

	mov	BYTE PTR [edi], 0
	inc	edi

; 2133 : 
; 2134 : 	/* find href */
; 2135 : 	href = next;
; 2136 : 	next = (xmlChar*)xmlStrchr(next, ' ');

	push	32					; 00000020H
	push	edi
	call	_xmlStrchr
	mov	esi, eax
	add	esp, 8

; 2137 : 	if(next != NULL) {

	test	esi, esi
	je	SHORT $LN243@xmlShell

; 2138 : 	    *(next++) = '\0';

	mov	BYTE PTR [esi], 0
	inc	esi
$LN243@xmlShell:

; 2139 : 	}
; 2140 : 
; 2141 : 	/* do register namespace */
; 2142 : 	if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {

	push	edi
	push	DWORD PTR _prefix$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN278@xmlShell

; 2119 :     while(next != NULL) {

	test	esi, esi
	jne	SHORT $LL239@xmlShell
$LN619@xmlShell:

; 2145 : 	    return(-1);
; 2146 : 	}
; 2147 :     }
; 2148 : 
; 2149 :     xmlFree(nsListDup);

	mov	edi, DWORD PTR __imp__free
	mov	eax, DWORD PTR _nsListDup$1$[ebp]
$LN240@xmlShell:
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN278@xmlShell:

; 2143 : 	    fprintf(ctxt->output,"Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", prefix, href);

	push	edi
	push	DWORD PTR _prefix$1$[ebp]
	push	OFFSET ??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2144 : 	    xmlFree(nsListDup);

	push	DWORD PTR _nsListDup$1$[ebp]
	call	DWORD PTR _xmlFree

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free

; 2144 : 	    xmlFree(nsListDup);

	add	esp, 20					; 00000014H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN277@xmlShell:

; 2128 : 	    fprintf(ctxt->output, "setns: prefix=[nsuri] required\n");

	push	OFFSET ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf

; 2129 : 	    xmlFree(nsListDup);

	push	DWORD PTR _nsListDup$1$[ebp]
	call	DWORD PTR _xmlFree

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free

; 2129 : 	    xmlFree(nsListDup);

	add	esp, 12					; 0000000cH

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN99@xmlShell:

; 3056 : 				"setns: prefix=[nsuri] required\n");
; 3057 :             } else {
; 3058 :                 xmlShellRegisterNamespace(ctxt, arg, NULL, NULL);
; 3059 :             }
; 3060 :         } else if (!strcmp(command, "setrootns")) {

	mov	ecx, OFFSET ??_C@_09ENEJFFG@setrootns@
	lea	eax, DWORD PTR _command$[ebp]
	npad	7
$LL474@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN475@xmlShell
	test	dl, dl
	je	SHORT $LN476@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN475@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL474@xmlShell
$LN476@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN477@xmlShell
$LN475@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN477@xmlShell:
	test	eax, eax
	jne	SHORT $LN103@xmlShell

; 3061 : 	    xmlNodePtr root;
; 3062 : 
; 3063 : 	    root = xmlDocGetRootElement(ctxt->doc);

	push	DWORD PTR [ebx+4]
	call	_xmlDocGetRootElement
	add	esp, 4

; 2171 :         (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))

	test	eax, eax
	je	$LN115@xmlShell
	cmp	DWORD PTR [eax+4], 1
	jne	$LN115@xmlShell
	mov	esi, DWORD PTR [eax+48]
	test	esi, esi
	je	$LN115@xmlShell
	cmp	DWORD PTR [ebx+12], 0
	je	$LN115@xmlShell
	npad	5
$LL247@xmlShell:

; 2172 : 	return(-1);
; 2173 :     ns = root->nsDef;
; 2174 :     while (ns != NULL) {
; 2175 :         if (ns->prefix == NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, OFFSET ??_C@_09EMODOEOP@defaultns@

; 2176 : 	    xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST "defaultns", ns->href);
; 2177 : 	else
; 2178 : 	    xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);
; 2179 :         ns = ns->next;

	push	DWORD PTR [esi+8]
	test	eax, eax
	cmovne	ecx, eax
	mov	eax, DWORD PTR [ebx+12]
	push	ecx
	push	eax
	call	_xmlXPathRegisterNs
	mov	esi, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL247@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN103@xmlShell:

; 3064 : 	    xmlShellRegisterRootNamespaces(ctxt, NULL, root, NULL);
; 3065 :         } else if (!strcmp(command, "xpath")) {

	mov	ecx, OFFSET ??_C@_05CNNIIAHK@xpath@
	lea	eax, DWORD PTR _command$[ebp]
$LL478@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN479@xmlShell
	test	dl, dl
	je	SHORT $LN480@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN479@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL478@xmlShell
$LN480@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN481@xmlShell
$LN479@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN481@xmlShell:
	test	eax, eax
	jne	$LN105@xmlShell

; 3066 :             if (arg[0] == 0) {

	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN107@xmlShell

; 3067 : 		xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN107@xmlShell:

; 3068 : 				"xpath: expression required\n");
; 3069 : 	    } else {
; 3070 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 3071 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	lea	eax, DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlXPathEval
	mov	esi, eax

; 3072 : 		xmlXPathDebugDumpObject(ctxt->output, list, 0);

	push	0
	push	esi
	push	DWORD PTR [ebx+20]
	call	_xmlXPathDebugDumpObject

; 3073 : 		xmlXPathFreeObject(list);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 24					; 00000018H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN105@xmlShell:

; 3074 : 	    }
; 3075 : #endif /* LIBXML_XPATH_ENABLED */
; 3076 : #ifdef LIBXML_TREE_ENABLED
; 3077 :         } else if (!strcmp(command, "setbase")) {

	mov	ecx, OFFSET ??_C@_07NPGKGHNA@setbase@
	lea	eax, DWORD PTR _command$[ebp]
$LL482@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN483@xmlShell
	test	dl, dl
	je	SHORT $LN484@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN483@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL482@xmlShell
$LN484@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN485@xmlShell
$LN483@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN485@xmlShell:
	test	eax, eax
	jne	SHORT $LN109@xmlShell

; 2089 :     xmlNodeSetBase(node, (xmlChar*) arg);

	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	DWORD PTR [ebx+8]
	call	_xmlNodeSetBase
	add	esp, 8

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN109@xmlShell:

; 3078 :             xmlShellSetBase(ctxt, arg, ctxt->node, NULL);
; 3079 : #endif
; 3080 :         } else if ((!strcmp(command, "ls")) || (!strcmp(command, "dir"))) {

	mov	ecx, OFFSET ??_C@_02EFGBDOJM@ls@
	lea	eax, DWORD PTR _command$[ebp]
$LL486@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN487@xmlShell
	test	dl, dl
	je	SHORT $LN488@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN487@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL486@xmlShell
$LN488@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN489@xmlShell
$LN487@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN489@xmlShell:
	test	eax, eax
	je	$LN113@xmlShell
	mov	ecx, OFFSET ??_C@_03DAPAKLGM@dir@
	lea	eax, DWORD PTR _command$[ebp]
	npad	4
$LL490@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN491@xmlShell
	test	dl, dl
	je	SHORT $LN492@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN491@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL490@xmlShell
$LN492@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN493@xmlShell
$LN491@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN493@xmlShell:
	test	eax, eax
	je	$LN113@xmlShell

; 3160 :                     xmlGenericError(xmlGenericErrorContext,
; 3161 :                                     "%s: no such node\n", arg);
; 3162 :                 }
; 3163 :                 ctxt->pctxt->node = NULL;
; 3164 :             }
; 3165 :         } else if (!strcmp(command, "whereis")) {

	mov	ecx, OFFSET ??_C@_07BANGEKHA@whereis@
	lea	eax, DWORD PTR _command$[ebp]
$LL494@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN495@xmlShell
	test	dl, dl
	je	SHORT $LN496@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN495@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL494@xmlShell
$LN496@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN497@xmlShell
$LN495@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN497@xmlShell:
	test	eax, eax
	jne	$LN133@xmlShell

; 3166 :             char dir[500];
; 3167 : 
; 3168 :             if (arg[0] == 0) {

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN135@xmlShell

; 3169 :                 if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))

	push	eax
	push	ecx

; 3170 :                     fprintf(ctxt->output, "%s\n", dir);
; 3171 :             } else {

	jmp	$LN664@xmlShell
$LN135@xmlShell:

; 3172 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+4], ecx

; 3173 : #ifdef LIBXML_XPATH_ENABLED
; 3174 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	lea	eax, DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlXPathEval
	mov	edi, eax
	add	esp, 8

; 3175 : #else
; 3176 :                 list = NULL;
; 3177 : #endif /* LIBXML_XPATH_ENABLED */
; 3178 :                 if (list != NULL) {

	test	edi, edi
	je	$LN118@xmlShell

; 3179 :                     switch (list->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 9
	ja	$LN12@xmlShell
	jmp	DWORD PTR $LN667@xmlShell[eax*4]
$LN141@xmlShell:

; 3180 :                         case XPATH_UNDEFINED:
; 3181 :                             xmlGenericError(xmlGenericErrorContext,
; 3182 :                                             "%s: no such node\n", arg);
; 3183 :                             break;
; 3184 :                         case XPATH_NODESET:{
; 3185 :                                 int indx;
; 3186 : 
; 3187 : 				if (list->nodesetval == NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN12@xmlShell

; 3188 : 				    break;
; 3189 : 
; 3190 :                                 for (indx = 0;

	xor	esi, esi

; 3191 :                                      indx < list->nodesetval->nodeNr;

	cmp	DWORD PTR [eax], esi
	jle	$LN12@xmlShell
	npad	3
$LL26@xmlShell:

; 3193 :                                     if (!xmlShellPwd(ctxt, dir, list->nodesetval->

	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR [eax+esi*4]
	lea	eax, DWORD PTR _dir$1[ebp]
	push	eax
	push	ebx
	call	_xmlShellPwd
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN24@xmlShell

; 3194 :                                                      nodeTab[indx], NULL))
; 3195 :                                         fprintf(ctxt->output, "%s\n", dir);

	lea	eax, DWORD PTR _dir$1[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN24@xmlShell:

; 3192 :                                      indx++) {

	mov	eax, DWORD PTR [edi+4]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL26@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN133@xmlShell:

; 3196 :                                 }
; 3197 :                                 break;
; 3198 :                             }
; 3199 :                         case XPATH_BOOLEAN:
; 3200 :                             xmlGenericError(xmlGenericErrorContext,
; 3201 :                                             "%s is a Boolean\n", arg);
; 3202 :                             break;
; 3203 :                         case XPATH_NUMBER:
; 3204 :                             xmlGenericError(xmlGenericErrorContext,
; 3205 :                                             "%s is a number\n", arg);
; 3206 :                             break;
; 3207 :                         case XPATH_STRING:
; 3208 :                             xmlGenericError(xmlGenericErrorContext,
; 3209 :                                             "%s is a string\n", arg);
; 3210 :                             break;
; 3211 :                         case XPATH_POINT:
; 3212 :                             xmlGenericError(xmlGenericErrorContext,
; 3213 :                                             "%s is a point\n", arg);
; 3214 :                             break;
; 3215 :                         case XPATH_RANGE:
; 3216 :                             xmlGenericError(xmlGenericErrorContext,
; 3217 :                                             "%s is a range\n", arg);
; 3218 :                             break;
; 3219 :                         case XPATH_LOCATIONSET:
; 3220 :                             xmlGenericError(xmlGenericErrorContext,
; 3221 :                                             "%s is a range\n", arg);
; 3222 :                             break;
; 3223 :                         case XPATH_USERS:
; 3224 :                             xmlGenericError(xmlGenericErrorContext,
; 3225 :                                             "%s is user-defined\n", arg);
; 3226 :                             break;
; 3227 :                         case XPATH_XSLT_TREE:
; 3228 :                             xmlGenericError(xmlGenericErrorContext,
; 3229 :                                             "%s is an XSLT value tree\n",
; 3230 :                                             arg);
; 3231 :                             break;
; 3232 :                     }
; 3233 : #ifdef LIBXML_XPATH_ENABLED
; 3234 :                     xmlXPathFreeObject(list);
; 3235 : #endif
; 3236 :                 } else {
; 3237 :                     xmlGenericError(xmlGenericErrorContext,
; 3238 :                                     "%s: no such node\n", arg);
; 3239 :                 }
; 3240 :                 ctxt->pctxt->node = NULL;
; 3241 :             }
; 3242 :         } else if (!strcmp(command, "cd")) {

	mov	ecx, OFFSET ??_C@_02ELLOPNDH@cd@
	lea	eax, DWORD PTR _command$[ebp]
$LL498@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN499@xmlShell
	test	dl, dl
	je	SHORT $LN500@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN499@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL498@xmlShell
$LN500@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN501@xmlShell
$LN499@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN501@xmlShell:
	test	eax, eax
	jne	$LN152@xmlShell

; 3243 :             if (arg[0] == 0) {

	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN154@xmlShell

; 3244 :                 ctxt->node = (xmlNodePtr) ctxt->doc;

	mov	eax, DWORD PTR [ebx+4]

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	mov	DWORD PTR [ebx+8], eax
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN154@xmlShell:

; 3245 :             } else {
; 3246 : #ifdef LIBXML_XPATH_ENABLED
; 3247 :                 int l;
; 3248 : 
; 3249 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 3250 : 		l = strlen(arg);

	lea	ecx, DWORD PTR _arg$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL502@xmlShell:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL502@xmlShell
	sub	ecx, edx

; 3251 : 		if ((l >= 2) && (arg[l - 1] == '/'))

	cmp	ecx, 2
	jl	SHORT $LN156@xmlShell
	cmp	BYTE PTR _arg$[ebp+ecx-1], 47		; 0000002fH
	jne	SHORT $LN156@xmlShell

; 3252 : 		    arg[l - 1] = 0;

	mov	BYTE PTR _arg$[ebp+ecx-1], al
$LN156@xmlShell:

; 3253 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	push	DWORD PTR [ebx+12]
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlXPathEval
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _list$4$[ebp], edi

; 3254 : #else
; 3255 :                 list = NULL;
; 3256 : #endif /* LIBXML_XPATH_ENABLED */
; 3257 :                 if (list != NULL) {

	test	edi, edi
	je	$LN118@xmlShell

; 3258 :                     switch (list->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 9
	ja	$LN12@xmlShell
	jmp	DWORD PTR $LN668@xmlShell[eax*4]
$LN160@xmlShell:

; 3259 :                         case XPATH_UNDEFINED:
; 3260 :                             xmlGenericError(xmlGenericErrorContext,
; 3261 :                                             "%s: no such node\n", arg);
; 3262 :                             break;
; 3263 :                         case XPATH_NODESET:
; 3264 :                             if (list->nodesetval != NULL) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN161@xmlShell

; 3265 : 				if (list->nodesetval->nodeNr == 1) {

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN163@xmlShell

; 3266 : 				    ctxt->node = list->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+8], eax

; 3267 : 				    if ((ctxt->node != NULL) &&

	test	eax, eax
	je	$LN12@xmlShell
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	$LN12@xmlShell

; 3268 : 				        (ctxt->node->type ==
; 3269 : 					 XML_NAMESPACE_DECL)) {
; 3270 : 					xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 3271 : 						    "cannot cd to namespace\n");
; 3272 : 					ctxt->node = NULL;

	mov	DWORD PTR [ebx+8], 0

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN163@xmlShell:

; 3273 : 				    }
; 3274 : 				} else
; 3275 : 				    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	ecx, DWORD PTR _list$4$[ebp]
	mov	edi, eax
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	call	___xmlGenericErrorContext
	push	esi
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax

; 3276 : 						    "%s is a %d Node Set\n",
; 3277 : 						    arg,
; 3278 : 						    list->nodesetval->nodeNr);
; 3279 :                             } else

	mov	edi, DWORD PTR _list$4$[ebp]
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN161@xmlShell:

; 3280 :                                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@

; 3281 :                                                 "%s is an empty Node Set\n",
; 3282 :                                                 arg);
; 3283 :                             break;

	jmp	$LN658@xmlShell
$LN152@xmlShell:

; 3284 :                         case XPATH_BOOLEAN:
; 3285 :                             xmlGenericError(xmlGenericErrorContext,
; 3286 :                                             "%s is a Boolean\n", arg);
; 3287 :                             break;
; 3288 :                         case XPATH_NUMBER:
; 3289 :                             xmlGenericError(xmlGenericErrorContext,
; 3290 :                                             "%s is a number\n", arg);
; 3291 :                             break;
; 3292 :                         case XPATH_STRING:
; 3293 :                             xmlGenericError(xmlGenericErrorContext,
; 3294 :                                             "%s is a string\n", arg);
; 3295 :                             break;
; 3296 :                         case XPATH_POINT:
; 3297 :                             xmlGenericError(xmlGenericErrorContext,
; 3298 :                                             "%s is a point\n", arg);
; 3299 :                             break;
; 3300 :                         case XPATH_RANGE:
; 3301 :                             xmlGenericError(xmlGenericErrorContext,
; 3302 :                                             "%s is a range\n", arg);
; 3303 :                             break;
; 3304 :                         case XPATH_LOCATIONSET:
; 3305 :                             xmlGenericError(xmlGenericErrorContext,
; 3306 :                                             "%s is a range\n", arg);
; 3307 :                             break;
; 3308 :                         case XPATH_USERS:
; 3309 :                             xmlGenericError(xmlGenericErrorContext,
; 3310 :                                             "%s is user-defined\n", arg);
; 3311 :                             break;
; 3312 :                         case XPATH_XSLT_TREE:
; 3313 :                             xmlGenericError(xmlGenericErrorContext,
; 3314 :                                             "%s is an XSLT value tree\n",
; 3315 :                                             arg);
; 3316 :                             break;
; 3317 :                     }
; 3318 : #ifdef LIBXML_XPATH_ENABLED
; 3319 :                     xmlXPathFreeObject(list);
; 3320 : #endif
; 3321 :                 } else {
; 3322 :                     xmlGenericError(xmlGenericErrorContext,
; 3323 :                                     "%s: no such node\n", arg);
; 3324 :                 }
; 3325 :                 ctxt->pctxt->node = NULL;
; 3326 :             }
; 3327 : #ifdef LIBXML_OUTPUT_ENABLED
; 3328 :         } else if (!strcmp(command, "cat")) {

	mov	ecx, OFFSET ??_C@_03PFGOGFOL@cat@
	lea	eax, DWORD PTR _command$[ebp]
	npad	7
$LL503@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN504@xmlShell
	test	dl, dl
	je	SHORT $LN505@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN504@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL503@xmlShell
$LN505@xmlShell:
	xor	eax, eax
	jmp	SHORT $LN506@xmlShell
$LN504@xmlShell:
	sbb	eax, eax
	or	eax, 1
$LN506@xmlShell:
	test	eax, eax
	jne	$LN174@xmlShell

; 3329 :             if (arg[0] == 0) {

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR _arg$[ebp], al
	jne	SHORT $LN176@xmlShell

; 3330 :                 xmlShellCat(ctxt, NULL, ctxt->node, NULL);

	push	eax
	push	ecx
	push	eax
	push	ebx
	call	_xmlShellCat
	add	esp, 16					; 00000010H

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN176@xmlShell:

; 3331 :             } else {
; 3332 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+4], ecx

; 3333 : #ifdef LIBXML_XPATH_ENABLED
; 3334 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 3335 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	lea	eax, DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlXPathEval
	mov	edi, eax
	add	esp, 8

; 3336 : #else
; 3337 :                 list = NULL;
; 3338 : #endif /* LIBXML_XPATH_ENABLED */
; 3339 :                 if (list != NULL) {

	test	edi, edi
	je	$LN118@xmlShell

; 3340 :                     switch (list->type) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 9
	ja	$LN12@xmlShell
	jmp	DWORD PTR $LN669@xmlShell[eax*4]
$LN181@xmlShell:

; 3341 :                         case XPATH_UNDEFINED:
; 3342 :                             xmlGenericError(xmlGenericErrorContext,
; 3343 :                                             "%s: no such node\n", arg);
; 3344 :                             break;
; 3345 :                         case XPATH_NODESET:{
; 3346 :                                 int indx;
; 3347 : 
; 3348 : 				if (list->nodesetval == NULL)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN12@xmlShell

; 3349 : 				    break;
; 3350 : 
; 3351 :                                 for (indx = 0;

	xor	esi, esi

; 3352 :                                      indx < list->nodesetval->nodeNr;

	cmp	DWORD PTR [eax], esi
	jle	$LN12@xmlShell
$LL33@xmlShell:

; 3353 :                                      indx++) {
; 3354 :                                     if (i > 0)

	cmp	DWORD PTR _i$2$[ebp], 0
	jle	SHORT $LN183@xmlShell

; 3355 :                                         fprintf(ctxt->output, " -------\n");

	push	OFFSET ??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 8
$LN183@xmlShell:

; 3356 :                                     xmlShellCat(ctxt, NULL,

	mov	eax, DWORD PTR [edi+4]
	push	0
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+esi*4]
	push	0
	push	ebx
	call	_xmlShellCat
	mov	eax, DWORD PTR [edi+4]
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL33@xmlShell

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
	jmp	$LN119@xmlShell
$LN174@xmlShell:

; 3357 :                                                 list->nodesetval->
; 3358 :                                                 nodeTab[indx], NULL);
; 3359 :                                 }
; 3360 :                                 break;
; 3361 :                             }
; 3362 :                         case XPATH_BOOLEAN:
; 3363 :                             xmlGenericError(xmlGenericErrorContext,
; 3364 :                                             "%s is a Boolean\n", arg);
; 3365 :                             break;
; 3366 :                         case XPATH_NUMBER:
; 3367 :                             xmlGenericError(xmlGenericErrorContext,
; 3368 :                                             "%s is a number\n", arg);
; 3369 :                             break;
; 3370 :                         case XPATH_STRING:
; 3371 :                             xmlGenericError(xmlGenericErrorContext,
; 3372 :                                             "%s is a string\n", arg);
; 3373 :                             break;
; 3374 :                         case XPATH_POINT:
; 3375 :                             xmlGenericError(xmlGenericErrorContext,
; 3376 :                                             "%s is a point\n", arg);
; 3377 :                             break;
; 3378 :                         case XPATH_RANGE:
; 3379 :                             xmlGenericError(xmlGenericErrorContext,
; 3380 :                                             "%s is a range\n", arg);
; 3381 :                             break;
; 3382 :                         case XPATH_LOCATIONSET:
; 3383 :                             xmlGenericError(xmlGenericErrorContext,
; 3384 :                                             "%s is a range\n", arg);
; 3385 :                             break;
; 3386 :                         case XPATH_USERS:
; 3387 :                             xmlGenericError(xmlGenericErrorContext,
; 3388 :                                             "%s is user-defined\n", arg);
; 3389 :                             break;
; 3390 :                         case XPATH_XSLT_TREE:
; 3391 :                             xmlGenericError(xmlGenericErrorContext,
; 3392 :                                             "%s is an XSLT value tree\n",
; 3393 :                                             arg);
; 3394 :                             break;
; 3395 :                     }
; 3396 : #ifdef LIBXML_XPATH_ENABLED
; 3397 :                     xmlXPathFreeObject(list);
; 3398 : #endif
; 3399 :                 } else {
; 3400 :                     xmlGenericError(xmlGenericErrorContext,
; 3401 :                                     "%s: no such node\n", arg);
; 3402 :                 }
; 3403 :                 ctxt->pctxt->node = NULL;
; 3404 :             }
; 3405 : #endif /* LIBXML_OUTPUT_ENABLED */
; 3406 :         } else {
; 3407 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _command$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN113@xmlShell:

; 3081 :             int dir = (!strcmp(command, "dir"));

	mov	ecx, OFFSET ??_C@_03DAPAKLGM@dir@
	lea	eax, DWORD PTR _command$[ebp]
$LL507@xmlShell:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN508@xmlShell
	test	dl, dl
	je	SHORT $LN509@xmlShell
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN508@xmlShell
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL507@xmlShell
$LN509@xmlShell:
	xor	edi, edi
	jmp	SHORT $LN510@xmlShell
$LN508@xmlShell:
	sbb	edi, edi
	or	edi, 1
$LN510@xmlShell:

; 3082 : 
; 3083 :             if (arg[0] == 0) {

	cmp	BYTE PTR _arg$[ebp], 0
	mov	ecx, DWORD PTR [ebx+8]
	jne	SHORT $LN114@xmlShell

; 3084 :                 if (dir)

	push	0
	push	ecx
	push	0
	push	ebx
	test	edi, edi
	jne	SHORT $LN116@xmlShell

; 3085 :                     xmlShellDir(ctxt, NULL, ctxt->node, NULL);

	call	_xmlShellDir

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 16					; 00000010H
	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN116@xmlShell:

; 3086 :                 else
; 3087 :                     xmlShellList(ctxt, NULL, ctxt->node, NULL);

	call	_xmlShellList

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	edi, DWORD PTR __imp__free
	add	esp, 16					; 00000010H
	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN114@xmlShell:

; 3088 :             } else {
; 3089 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+4], ecx

; 3090 : #ifdef LIBXML_XPATH_ENABLED
; 3091 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 3092 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	lea	eax, DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	push	eax
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$6$[ebp], eax

; 3093 : #else
; 3094 :                 list = NULL;
; 3095 : #endif /* LIBXML_XPATH_ENABLED */
; 3096 :                 if (list != NULL) {

	test	eax, eax
	je	$LN118@xmlShell

; 3097 :                     switch (list->type) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 9
	ja	$LN17@xmlShell
	jmp	DWORD PTR $LN670@xmlShell[ecx*4]
$LN120@xmlShell:

; 3098 :                         case XPATH_UNDEFINED:
; 3099 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@

; 3100 :                                             "%s: no such node\n", arg);
; 3101 :                             break;

	jmp	$LN662@xmlShell
$LN121@xmlShell:

; 3102 :                         case XPATH_NODESET:{
; 3103 :                                 int indx;
; 3104 : 
; 3105 : 				if (list->nodesetval == NULL)

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN17@xmlShell

; 3106 : 				    break;
; 3107 : 
; 3108 :                                 for (indx = 0;

	xor	esi, esi

; 3109 :                                      indx < list->nodesetval->nodeNr;

	cmp	DWORD PTR [eax], esi
	jle	$LN17@xmlShell
	npad	7
$LL21@xmlShell:

; 3111 :                                     if (dir)

	mov	eax, DWORD PTR [eax+8]
	push	0
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	push	0
	push	ebx
	test	edi, edi
	jne	SHORT $LN123@xmlShell

; 3112 :                                         xmlShellDir(ctxt, NULL,

	call	_xmlShellDir
	jmp	SHORT $LN663@xmlShell
$LN123@xmlShell:

; 3113 :                                                     list->nodesetval->
; 3114 :                                                     nodeTab[indx], NULL);
; 3115 :                                     else
; 3116 :                                         xmlShellList(ctxt, NULL,

	call	_xmlShellList
$LN663@xmlShell:

; 3109 :                                      indx < list->nodesetval->nodeNr;

	mov	eax, DWORD PTR _list$6$[ebp]

; 3110 :                                      indx++) {

	inc	esi
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [eax+4]
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL21@xmlShell

; 3152 :                                             "%s is an XSLT value tree\n",
; 3153 :                                             arg);
; 3154 :                             break;
; 3155 :                     }
; 3156 : #ifdef LIBXML_XPATH_ENABLED
; 3157 :                     xmlXPathFreeObject(list);

	push	DWORD PTR _list$6$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4

; 3158 : #endif
; 3159 :                 } else {

	jmp	$LN119@xmlShell
$LN125@xmlShell:

; 3117 :                                                      list->nodesetval->
; 3118 :                                                      nodeTab[indx], NULL);
; 3119 :                                 }
; 3120 :                                 break;
; 3121 :                             }
; 3122 :                         case XPATH_BOOLEAN:
; 3123 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@

; 3124 :                                             "%s is a Boolean\n", arg);
; 3125 :                             break;

	jmp	$LN662@xmlShell
$LN126@xmlShell:

; 3126 :                         case XPATH_NUMBER:
; 3127 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@

; 3128 :                                             "%s is a number\n", arg);
; 3129 :                             break;

	jmp	$LN662@xmlShell
$LN127@xmlShell:

; 3130 :                         case XPATH_STRING:
; 3131 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@

; 3132 :                                             "%s is a string\n", arg);
; 3133 :                             break;

	jmp	SHORT $LN662@xmlShell
$LN128@xmlShell:

; 3134 :                         case XPATH_POINT:
; 3135 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@

; 3136 :                                             "%s is a point\n", arg);
; 3137 :                             break;

	jmp	SHORT $LN662@xmlShell
$LN129@xmlShell:

; 3152 :                                             "%s is an XSLT value tree\n",
; 3153 :                                             arg);
; 3154 :                             break;
; 3155 :                     }
; 3156 : #ifdef LIBXML_XPATH_ENABLED
; 3157 :                     xmlXPathFreeObject(list);

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	jmp	SHORT $LN662@xmlShell
$LN131@xmlShell:

; 3138 :                         case XPATH_RANGE:
; 3139 :                             xmlGenericError(xmlGenericErrorContext,
; 3140 :                                             "%s is a range\n", arg);
; 3141 :                             break;
; 3142 :                         case XPATH_LOCATIONSET:
; 3143 :                             xmlGenericError(xmlGenericErrorContext,
; 3144 :                                             "%s is a range\n", arg);
; 3145 :                             break;
; 3146 :                         case XPATH_USERS:
; 3147 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@

; 3148 :                                             "%s is user-defined\n", arg);
; 3149 :                             break;

	jmp	SHORT $LN662@xmlShell
$LN132@xmlShell:

; 3150 :                         case XPATH_XSLT_TREE:
; 3151 :                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
$LN662@xmlShell:

; 3152 :                                             "%s is an XSLT value tree\n",
; 3153 :                                             arg);
; 3154 :                             break;
; 3155 :                     }
; 3156 : #ifdef LIBXML_XPATH_ENABLED
; 3157 :                     xmlXPathFreeObject(list);

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN17@xmlShell:
	push	DWORD PTR _list$6$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4

; 3158 : #endif
; 3159 :                 } else {

	jmp	SHORT $LN119@xmlShell
$LN118@xmlShell:

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN119@xmlShell:
	mov	eax, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR __imp__free
	mov	DWORD PTR [eax+4], 0
$LN115@xmlShell:
	push	DWORD PTR _cmdline$1$[ebp]
	call	edi
	add	esp, 4
	jmp	$LL2@xmlShell
$LN622@xmlShell:

; 3411 : 	cmdline = NULL;
; 3412 :     }
; 3413 : #ifdef LIBXML_XPATH_ENABLED
; 3414 :     xmlXPathFreeContext(ctxt->pctxt);

	mov	esi, DWORD PTR _cmdline$1$[ebp]
$LN279@xmlShell:
	push	DWORD PTR [ebx+12]
	call	_xmlXPathFreeContext
	add	esp, 4

; 3415 : #endif /* LIBXML_XPATH_ENABLED */
; 3416 :     if (ctxt->loaded) {

	cmp	DWORD PTR [ebx+16], 0
	je	SHORT $LN192@xmlShell

; 3417 :         xmlFreeDoc(ctxt->doc);

	push	DWORD PTR [ebx+4]
	call	_xmlFreeDoc
	add	esp, 4
$LN192@xmlShell:

; 3418 :     }
; 3419 :     if (ctxt->filename != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN193@xmlShell

; 3420 :         xmlFree(ctxt->filename);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN193@xmlShell:

; 3421 :     xmlFree(ctxt);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3422 :     if (cmdline != NULL)

	test	esi, esi
	je	SHORT $LN650@xmlShell

; 3423 :         free(cmdline);          /* not xmlFree here ! */

	push	esi
	call	edi
	add	esp, 4
$LN650@xmlShell:
	pop	ebx
	pop	esi
$LN648@xmlShell:
	pop	edi
$LN194@xmlShell:

; 3424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN666@xmlShell:
	DD	$LN84@xmlShell
	DD	$LN85@xmlShell
	DD	$LN87@xmlShell
	DD	$LN88@xmlShell
	DD	$LN89@xmlShell
	DD	$LN90@xmlShell
	DD	$LN91@xmlShell
	DD	$LN91@xmlShell
	DD	$LN93@xmlShell
	DD	$LN94@xmlShell
$LN667@xmlShell:
	DD	$LN84@xmlShell
	DD	$LN141@xmlShell
	DD	$LN87@xmlShell
	DD	$LN88@xmlShell
	DD	$LN89@xmlShell
	DD	$LN90@xmlShell
	DD	$LN91@xmlShell
	DD	$LN91@xmlShell
	DD	$LN93@xmlShell
	DD	$LN94@xmlShell
$LN668@xmlShell:
	DD	$LN84@xmlShell
	DD	$LN160@xmlShell
	DD	$LN87@xmlShell
	DD	$LN88@xmlShell
	DD	$LN89@xmlShell
	DD	$LN90@xmlShell
	DD	$LN91@xmlShell
	DD	$LN91@xmlShell
	DD	$LN93@xmlShell
	DD	$LN94@xmlShell
$LN669@xmlShell:
	DD	$LN84@xmlShell
	DD	$LN181@xmlShell
	DD	$LN87@xmlShell
	DD	$LN88@xmlShell
	DD	$LN89@xmlShell
	DD	$LN90@xmlShell
	DD	$LN91@xmlShell
	DD	$LN91@xmlShell
	DD	$LN93@xmlShell
	DD	$LN94@xmlShell
$LN670@xmlShell:
	DD	$LN120@xmlShell
	DD	$LN121@xmlShell
	DD	$LN125@xmlShell
	DD	$LN126@xmlShell
	DD	$LN127@xmlShell
	DD	$LN128@xmlShell
	DD	$LN129@xmlShell
	DD	$LN129@xmlShell
	DD	$LN131@xmlShell
	DD	$LN132@xmlShell
_xmlShell ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPwd
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellPwd PROC					; COMDAT

; 2771 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlShellPw

; 2772 :     xmlChar *path;
; 2773 : 
; 2774 :     if ((node == NULL) || (buffer == NULL))

	mov	esi, DWORD PTR _buffer$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlShellPw

; 2776 : 
; 2777 :     path = xmlGetNodePath(node);

	push	eax
	call	_xmlGetNodePath
	mov	edi, eax
	add	esp, 4

; 2778 :     if (path == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlShellPw

; 2779 : 	return (-1);
; 2780 : 
; 2781 :     /*
; 2782 :      * This test prevents buffer overflow, because this routine
; 2783 :      * is only called by xmlShell, in which the second argument is
; 2784 :      * 500 chars long.
; 2785 :      * It is a dirty hack before a cleaner solution is found.
; 2786 :      * Documentation should mention that the second argument must
; 2787 :      * be at least 500 chars long, and could be stripped if too long.
; 2788 :      */
; 2789 :     snprintf(buffer, 499, "%s", path);

	push	edi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	499					; 000001f3H
	push	esi
	call	_snprintf

; 2790 :     buffer[499] = '0';
; 2791 :     xmlFree(path);

	push	edi
	mov	BYTE PTR [esi+499], 48			; 00000030H
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 2792 : 
; 2793 :     return (0);

	xor	eax, eax
	pop	edi

; 2794 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlShellPw:
	pop	edi

; 2775 :         return (-1);

	or	eax, -1

; 2794 : }

	pop	esi
	pop	ebp
	ret	0
_xmlShellPwd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellDu
_TEXT	SEGMENT
_indent$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_tree$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellDu PROC					; COMDAT

; 2687 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _indent$1$[ebp], edi
	test	ebx, ebx
	je	$LN50@xmlShellDu

; 2688 :     xmlNodePtr node;
; 2689 :     int indent = 0, i;
; 2690 : 
; 2691 :     if (!ctxt)
; 2692 : 	return (-1);
; 2693 : 
; 2694 :     if (tree == NULL)

	mov	edx, DWORD PTR _tree$[ebp]
	test	edx, edx
	je	$LN50@xmlShellDu

; 2696 :     node = tree;

	push	esi
	mov	esi, edx
	npad	2
$LL2@xmlShellDu:

; 2698 :         if ((node->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	je	SHORT $LN13@xmlShellDu
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN13@xmlShellDu

; 2701 :         } else if (node->type == XML_ELEMENT_NODE) {

	cmp	eax, 1
	jne	SHORT $LN14@xmlShellDu

; 2702 :             for (i = 0; i < indent; i++)

	test	edi, edi
	jle	SHORT $LN5@xmlShellDu
	mov	ebx, edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	npad	5
$LL6@xmlShellDu:

; 2703 :                 fprintf(ctxt->output, "  ");

	push	OFFSET ??_C@_02KNHHEEKP@?5?5@
	push	DWORD PTR [edi+20]
	call	_fprintf
	add	esp, 8
	sub	ebx, 1
	jne	SHORT $LL6@xmlShellDu
	mov	edi, DWORD PTR _indent$1$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN5@xmlShellDu:

; 2704 :             if ((node->ns) && (node->ns->prefix))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN16@xmlShellDu
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN16@xmlShellDu

; 2705 :                 fprintf(ctxt->output, "%s:", node->ns->prefix);

	push	eax
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlShellDu:

; 2706 :             fprintf(ctxt->output, "%s\n", node->name);

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2707 :         } else {

	jmp	SHORT $LN57@xmlShellDu
$LN13@xmlShellDu:

; 2699 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2700 :             fprintf(ctxt->output, "/\n");

	push	OFFSET ??_C@_02MJEAMPLK@?1?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 8
$LN57@xmlShellDu:

; 2708 :         }
; 2709 : 
; 2710 :         /*
; 2711 :          * Browse the full subtree, deep first
; 2712 :          */
; 2713 : 
; 2714 :         if ((node->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR _tree$[ebp]
$LN14@xmlShellDu:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	je	SHORT $LN19@xmlShellDu
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN19@xmlShellDu

; 2717 :         } else if ((node->children != NULL)
; 2718 :                    && (node->type != XML_ENTITY_REF_NODE)) {

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN20@xmlShellDu
	cmp	eax, 5
	je	SHORT $LN20@xmlShellDu

; 2719 :             /* deep first */
; 2720 :             node = node->children;
; 2721 :             indent++;

	inc	edi
	mov	esi, ecx
	mov	DWORD PTR _indent$1$[ebp], edi
	jmp	SHORT $LN25@xmlShellDu
$LN20@xmlShellDu:

; 2722 :         } else if ((node != tree) && (node->next != NULL)) {

	cmp	esi, edx
	je	SHORT $LN24@xmlShellDu
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL7@xmlShellDu

; 2723 :             /* then siblings */
; 2724 :             node = node->next;

	mov	esi, eax
	jmp	SHORT $LN25@xmlShellDu
$LL7@xmlShellDu:

; 2725 :         } else if (node != tree) {
; 2726 :             /* go up to parents->next if needed */
; 2727 :             while (node != tree) {
; 2728 :                 if (node->parent != NULL) {

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, edi
	test	eax, eax
	cmovne	esi, eax

; 2729 :                     node = node->parent;
; 2730 :                     indent--;
; 2731 :                 }
; 2732 :                 if ((node != tree) && (node->next != NULL)) {

	lea	edi, DWORD PTR [ecx-1]
	cmove	edi, ecx
	cmp	esi, edx
	je	SHORT $LN27@xmlShellDu
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN8@xmlShellDu
$LN27@xmlShellDu:

; 2733 :                     node = node->next;
; 2734 :                     break;
; 2735 :                 }
; 2736 :                 if (node->parent == NULL) {

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN36@xmlShellDu

; 2737 :                     node = NULL;
; 2738 :                     break;
; 2739 :                 }
; 2740 :                 if (node == tree) {

	cmp	esi, edx
	jne	SHORT $LL7@xmlShellDu
$LN36@xmlShellDu:

; 2741 :                     node = NULL;
; 2742 :                     break;
; 2743 :                 }
; 2744 :             }
; 2745 :             /* exit condition */
; 2746 :             if (node == tree)
; 2747 :                 node = NULL;
; 2748 :         } else

	xor	eax, eax
$LN8@xmlShellDu:
	xor	esi, esi
	mov	DWORD PTR _indent$1$[ebp], edi
	cmp	eax, edx
	cmovne	esi, eax
	jmp	SHORT $LN25@xmlShellDu
$LN19@xmlShellDu:

; 2715 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2716 :             node = ((xmlDocPtr) node)->children;

	mov	esi, DWORD PTR [esi+12]
$LN25@xmlShellDu:

; 2697 :     while (node != NULL) {

	test	esi, esi
	jne	$LL2@xmlShellDu
$LN24@xmlShellDu:

; 2749 :             node = NULL;
; 2750 :     }
; 2751 :     return (0);

	pop	esi
	pop	edi
	xor	eax, eax

; 2752 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlShellDu:
	pop	edi

; 2695 :         return (-1);

	or	eax, -1

; 2752 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellDu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellValidate
_TEXT	SEGMENT
_vctxt$ = -64						; size = 64
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellValidate PROC					; COMDAT

; 2645 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	or	edi, -1
	test	esi, esi
	je	SHORT $LN3@xmlShellVa

; 2646 :     xmlValidCtxt vctxt;
; 2647 :     int res = -1;
; 2648 : 
; 2649 :     if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN3@xmlShellVa

; 2650 :     vctxt.userData = stderr;

	push	ebx
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	mov	DWORD PTR _vctxt$[ebp], eax
	add	esp, 4

; 2651 :     vctxt.error = (xmlValidityErrorFunc) fprintf;
; 2652 :     vctxt.warning = (xmlValidityWarningFunc) fprintf;
; 2653 : 
; 2654 :     if ((dtd == NULL) || (dtd[0] == 0)) {

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR _vctxt$[ebp+4], OFFSET _fprintf
	mov	DWORD PTR _vctxt$[ebp+8], OFFSET _fprintf
	test	eax, eax
	je	SHORT $LN6@xmlShellVa
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN6@xmlShellVa

; 2656 :     } else {
; 2657 :         xmlDtdPtr subset;
; 2658 : 
; 2659 :         subset = xmlParseDTD(NULL, (xmlChar *) dtd);

	push	eax
	push	0
	call	_xmlParseDTD
	mov	ebx, eax
	add	esp, 8

; 2660 :         if (subset != NULL) {

	test	ebx, ebx
	je	SHORT $LN7@xmlShellVa

; 2661 :             res = xmlValidateDtd(&vctxt, ctxt->doc, subset);

	push	ebx
	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _vctxt$[ebp]
	push	eax
	call	_xmlValidateDtd

; 2662 : 
; 2663 :             xmlFreeDtd(subset);

	push	ebx
	mov	edi, eax
	call	_xmlFreeDtd
	add	esp, 16					; 00000010H

; 2664 :         }
; 2665 :     }
; 2666 :     return (res);

	mov	eax, edi
	pop	ebx
	pop	edi

; 2667 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlShellVa:

; 2655 :         res = xmlValidateDocument(&vctxt, ctxt->doc);

	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _vctxt$[ebp]
	push	eax
	call	_xmlValidateDocument
	add	esp, 8
	mov	edi, eax
$LN7@xmlShellVa:

; 2664 :         }
; 2665 :     }
; 2666 :     return (res);

	pop	ebx
	mov	eax, edi
	pop	edi

; 2667 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlShellVa:
	pop	edi

; 2646 :     xmlValidCtxt vctxt;
; 2647 :     int res = -1;
; 2648 : 
; 2649 :     if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);

	or	eax, -1

; 2667 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSave
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSave PROC					; COMDAT

; 2583 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	$LN5@xmlShellSa

; 2584 :     if ((ctxt == NULL) || (ctxt->doc == NULL))

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN5@xmlShellSa

; 2586 :     if ((filename == NULL) || (filename[0] == 0))

	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlShellSa
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN6@xmlShellSa
$LN7@xmlShellSa:

; 2587 :         filename = ctxt->filename;

	mov	edi, DWORD PTR [ecx]
$LN6@xmlShellSa:

; 2588 :     if (filename == NULL)

	test	edi, edi
	je	SHORT $LN5@xmlShellSa

; 2589 :         return (-1);
; 2590 : #ifdef W_OK
; 2591 :     if (access((char *) filename, W_OK)) {
; 2592 :         xmlGenericError(xmlGenericErrorContext,
; 2593 :                         "Cannot save to %s\n", filename);
; 2594 :         return (-1);
; 2595 :     }
; 2596 : #endif
; 2597 :     switch (ctxt->doc->type) {

	mov	ecx, DWORD PTR [eax+4]
	push	esi
	cmp	ecx, 9
	je	SHORT $LN9@xmlShellSa
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN11@xmlShellSa

; 2617 :         default:
; 2618 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 2619 : 	    "To save to subparts of a document use the 'write' command\n");
; 2620 :             return (-1);

	or	eax, -1
	pop	esi
	pop	edi

; 2624 : }

	pop	ebp
	ret	0
$LN11@xmlShellSa:

; 2600 :                 xmlGenericError(xmlGenericErrorContext,
; 2601 :                                 "Failed to save to %s\n", filename);
; 2602 :             }
; 2603 :             break;
; 2604 :         case XML_HTML_DOCUMENT_NODE:
; 2605 : #ifdef LIBXML_HTML_ENABLED
; 2606 :             if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {

	push	eax
	push	edi
	call	_htmlSaveFile

; 2607 :                 xmlGenericError(xmlGenericErrorContext,
; 2608 :                                 "Failed to save to %s\n", filename);
; 2609 :             }
; 2610 : #else
; 2611 :             if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
; 2612 :                 xmlGenericError(xmlGenericErrorContext,
; 2613 :                                 "Failed to save to %s\n", filename);
; 2614 :             }
; 2615 : #endif /* LIBXML_HTML_ENABLED */
; 2616 :             break;

	jmp	SHORT $LN17@xmlShellSa
$LN9@xmlShellSa:

; 2598 :         case XML_DOCUMENT_NODE:
; 2599 :             if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {

	push	eax
	push	edi
	call	_xmlSaveFile
$LN17@xmlShellSa:

; 2621 : 
; 2622 :     }
; 2623 :     return (0);

	add	esp, 8
	test	eax, eax
	jns	SHORT $LN10@xmlShellSa
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN10@xmlShellSa:
	pop	esi
	xor	eax, eax
	pop	edi

; 2624 : }

	pop	ebp
	ret	0
$LN5@xmlShellSa:

; 2585 :         return (-1);

	or	eax, -1
	pop	edi

; 2624 : }

	pop	ebp
	ret	0
_xmlShellSave ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellWrite
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellWrite PROC					; COMDAT

; 2515 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	$LN6@xmlShellWr

; 2516 :     if (node == NULL)
; 2517 :         return (-1);
; 2518 :     if ((filename == NULL) || (filename[0] == 0)) {

	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	je	$LN6@xmlShellWr
	cmp	BYTE PTR [edi], 0
	je	$LN6@xmlShellWr

; 2520 :     }
; 2521 : #ifdef W_OK
; 2522 :     if (access((char *) filename, W_OK)) {
; 2523 :         xmlGenericError(xmlGenericErrorContext,
; 2524 :                         "Cannot write to %s\n", filename);
; 2525 :         return (-1);
; 2526 :     }
; 2527 : #endif
; 2528 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	cmp	eax, 9
	je	SHORT $LN7@xmlShellWr
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN9@xmlShellWr

; 2542 :             }
; 2543 : #else
; 2544 :             if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
; 2545 :                 xmlGenericError(xmlGenericErrorContext,
; 2546 :                                 "Failed to write to %s\n", filename);
; 2547 :                 return (-1);
; 2548 :             }
; 2549 : #endif /* LIBXML_HTML_ENABLED */
; 2550 :             break;
; 2551 :         default:{
; 2552 :                 FILE *f;
; 2553 : 
; 2554 :                 f = fopen((char *) filename, "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	edi
	call	DWORD PTR __imp__fopen
	mov	ebx, eax
	add	esp, 8

; 2555 :                 if (f == NULL) {

	test	ebx, ebx
	je	SHORT $LN15@xmlShellWr

; 2556 :                     xmlGenericError(xmlGenericErrorContext,
; 2557 :                                     "Failed to write to %s\n", filename);
; 2558 :                     return (-1);
; 2559 :                 }
; 2560 :                 xmlElemDump(f, ctxt->doc, node);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	DWORD PTR [eax+4]
	push	ebx
	call	_xmlElemDump

; 2561 :                 fclose(f);

	push	ebx
	call	DWORD PTR __imp__fclose
	add	esp, 16					; 00000010H

; 2562 :             }
; 2563 :     }
; 2564 :     return (0);

	xor	eax, eax
	pop	ebx
	pop	edi

; 2565 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlShellWr:

; 2531 :                 xmlGenericError(xmlGenericErrorContext,
; 2532 :                                 "Failed to write to %s\n", filename);
; 2533 :                 return (-1);
; 2534 :             }
; 2535 :             break;
; 2536 :         case XML_HTML_DOCUMENT_NODE:
; 2537 : #ifdef LIBXML_HTML_ENABLED
; 2538 :             if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+4]
	push	edi
	call	_htmlSaveFile
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN8@xmlShellWr
$LN15@xmlShellWr:

; 2539 :                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 2540 :                                 "Failed to write to %s\n", filename);
; 2541 :                 return (-1);

	or	eax, -1
	pop	ebx
	pop	edi

; 2565 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlShellWr:

; 2529 :         case XML_DOCUMENT_NODE:
; 2530 :             if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+4]
	push	edi
	call	_xmlSaveFile
	add	esp, 8
	cmp	eax, -1
	jl	SHORT $LN15@xmlShellWr
$LN8@xmlShellWr:
	pop	ebx
	pop	edi

; 2562 :             }
; 2563 :     }
; 2564 :     return (0);

	xor	eax, eax

; 2565 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlShellWr:
	pop	edi

; 2519 :         return (-1);

	or	eax, -1

; 2565 : }

	pop	esi
	pop	ebp
	ret	0
_xmlShellWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellCat
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellCat PROC					; COMDAT

; 2414 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN11@xmlShellCa

; 2415 :     if (!ctxt)
; 2416 :         return (0);
; 2417 :     if (node == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlShellCa

; 2418 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@

; 2440 :     return (0);
; 2441 : }

	push	DWORD PTR [esi+20]
	call	_fprintf
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlShellCa:

; 2419 : 	return (0);
; 2420 :     }
; 2421 :     if (ctxt->doc->type == XML_HTML_DOCUMENT_NODE) {

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+20]
	push	eax
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN4@xmlShellCa

; 2422 : #ifdef LIBXML_HTML_ENABLED
; 2423 :         if (node->type == XML_HTML_DOCUMENT_NODE)

	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN6@xmlShellCa

; 2424 :             htmlDocDump(ctxt->output, (htmlDocPtr) node);

	push	ecx
	call	_htmlDocDump
	add	esp, 8
	jmp	SHORT $LN9@xmlShellCa
$LN6@xmlShellCa:

; 2425 :         else
; 2426 :             htmlNodeDumpFile(ctxt->output, ctxt->doc, node);

	push	edx
	push	ecx
	call	_htmlNodeDumpFile

; 2427 : #else
; 2428 :         if (node->type == XML_DOCUMENT_NODE)
; 2429 :             xmlDocDump(ctxt->output, (xmlDocPtr) node);
; 2430 :         else
; 2431 :             xmlElemDump(ctxt->output, ctxt->doc, node);
; 2432 : #endif /* LIBXML_HTML_ENABLED */
; 2433 :     } else {

	jmp	SHORT $LN13@xmlShellCa
$LN4@xmlShellCa:

; 2434 :         if (node->type == XML_DOCUMENT_NODE)

	cmp	DWORD PTR [eax+4], 9
	jne	SHORT $LN8@xmlShellCa

; 2435 :             xmlDocDump(ctxt->output, (xmlDocPtr) node);

	push	ecx
	call	_xmlDocDump
	add	esp, 8
	jmp	SHORT $LN9@xmlShellCa
$LN8@xmlShellCa:

; 2436 :         else
; 2437 :             xmlElemDump(ctxt->output, ctxt->doc, node);

	push	edx
	push	ecx
	call	_xmlElemDump
$LN13@xmlShellCa:

; 2438 :     }
; 2439 :     fprintf(ctxt->output, "\n");

	add	esp, 12					; 0000000cH
$LN9@xmlShellCa:
	push	OFFSET ??_C@_01EEMJAFIK@?6@

; 2440 :     return (0);
; 2441 : }

	push	DWORD PTR [esi+20]
	call	_fprintf
	add	esp, 8
$LN11@xmlShellCa:
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlShellCat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlShellPrintNode PROC					; COMDAT

; 1920 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1895 :     if (!node)

	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlShellPr

; 1896 :         return;
; 1897 :     if (ctxt == NULL)
; 1898 : 	fp = stdout;

	push	edi
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	mov	edi, eax
	add	esp, 4

; 1899 :     else
; 1900 : 	fp = ctxt->output;
; 1901 : 
; 1902 :     if (node->type == XML_DOCUMENT_NODE)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 9
	jne	SHORT $LN7@xmlShellPr

; 1903 :         xmlDocDump(fp, (xmlDocPtr) node);

	push	esi
	push	edi
	call	_xmlDocDump
	add	esp, 8

; 1908 : 
; 1909 :     fprintf(fp, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 1921 :     xmlShellPrintNodeCtxt(NULL, node);
; 1922 : }

	pop	ebp
	ret	0
$LN7@xmlShellPr:

; 1904 :     else if (node->type == XML_ATTRIBUTE_NODE)

	cmp	eax, 2
	jne	SHORT $LN9@xmlShellPr

; 1905 :         xmlDebugDumpAttrList(fp, (xmlAttrPtr) node, 0);

	push	0
	push	esi
	push	edi
	call	_xmlDebugDumpAttrList
	jmp	SHORT $LN12@xmlShellPr
$LN9@xmlShellPr:

; 1906 :     else
; 1907 :         xmlElemDump(fp, node->doc, node);

	push	esi
	push	DWORD PTR [esi+32]
	push	edi
	call	_xmlElemDump
$LN12@xmlShellPr:

; 1908 : 
; 1909 :     fprintf(fp, "\n");

	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	edi
$LN3@xmlShellPr:
	pop	esi

; 1921 :     xmlShellPrintNodeCtxt(NULL, node);
; 1922 : }

	pop	ebp
	ret	0
_xmlShellPrintNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellLoad
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellLoad PROC					; COMDAT

; 2460 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlShellLo

; 2461 :     xmlDocPtr doc;
; 2462 :     int html = 0;
; 2463 : 
; 2464 :     if ((ctxt == NULL) || (filename == NULL)) return(-1);

	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlShellLo

; 2465 :     if (ctxt->doc != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@xmlShellLo

; 2466 :         html = (ctxt->doc->type == XML_HTML_DOCUMENT_NODE);
; 2467 : 
; 2468 :     if (html) {

	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN5@xmlShellLo

; 2469 : #ifdef LIBXML_HTML_ENABLED
; 2470 :         doc = htmlParseFile(filename, NULL);

	push	0
	push	edi
	call	_htmlParseFile
	add	esp, 8

; 2471 : #else
; 2472 :         fprintf(ctxt->output, "HTML support not compiled in\n");
; 2473 :         doc = NULL;
; 2474 : #endif /* LIBXML_HTML_ENABLED */
; 2475 :     } else {

	jmp	SHORT $LN11@xmlShellLo
$LN5@xmlShellLo:

; 2476 :         doc = xmlReadFile(filename,NULL,0);

	push	0
	push	0
	push	edi
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
$LN11@xmlShellLo:

; 2477 :     }
; 2478 :     if (doc != NULL) {

	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN3@xmlShellLo

; 2479 :         if (ctxt->loaded == 1) {

	cmp	DWORD PTR [esi+16], 1
	jne	SHORT $LN9@xmlShellLo

; 2480 :             xmlFreeDoc(ctxt->doc);

	push	DWORD PTR [esi+4]
	call	_xmlFreeDoc
	add	esp, 4
$LN9@xmlShellLo:

; 2481 :         }
; 2482 :         ctxt->loaded = 1;
; 2483 : #ifdef LIBXML_XPATH_ENABLED
; 2484 :         xmlXPathFreeContext(ctxt->pctxt);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+16], 1
	call	_xmlXPathFreeContext

; 2485 : #endif /* LIBXML_XPATH_ENABLED */
; 2486 :         xmlFree(ctxt->filename);

	push	DWORD PTR [esi]
	call	DWORD PTR _xmlFree

; 2487 :         ctxt->doc = doc;
; 2488 :         ctxt->node = (xmlNodePtr) doc;
; 2489 : #ifdef LIBXML_XPATH_ENABLED
; 2490 :         ctxt->pctxt = xmlXPathNewContext(doc);

	push	ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	call	_xmlXPathNewContext

; 2491 : #endif /* LIBXML_XPATH_ENABLED */
; 2492 :         ctxt->filename = (char *) xmlCanonicPath((xmlChar *) filename);

	push	edi
	mov	DWORD PTR [esi+12], eax
	call	_xmlCanonicPath
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi], eax

; 2493 :     } else
; 2494 :         return (-1);
; 2495 :     return (0);

	xor	eax, eax
	pop	edi

; 2496 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlShellLo:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlShellLoad ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellDir
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellDir PROC					; COMDAT

; 2279 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlShellDi

; 2280 :     if (!ctxt)
; 2281 :         return (0);
; 2282 :     if (node == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlShellDi

; 2283 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	DWORD PTR [ecx+20]
	call	_fprintf

; 2293 :     }
; 2294 :     return (0);
; 2295 : }

	add	esp, 8
	xor	eax, eax
	pop	ebp
	ret	0
$LN3@xmlShellDi:

; 2284 : 	return (0);
; 2285 :     }
; 2286 :     if ((node->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 9
	je	SHORT $LN6@xmlShellDi
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN6@xmlShellDi

; 2289 :     } else if (node->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [ecx+20]
	push	0
	push	eax
	push	ecx
	cmp	edx, 2
	jne	SHORT $LN7@xmlShellDi

; 2290 :         xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr) node, 0);

	call	_xmlDebugDumpAttr
	add	esp, 12					; 0000000cH

; 2293 :     }
; 2294 :     return (0);
; 2295 : }

	xor	eax, eax
	pop	ebp
	ret	0
$LN7@xmlShellDi:

; 2291 :     } else {
; 2292 :         xmlDebugDumpOneNode(ctxt->output, node, 0);

	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH

; 2293 :     }
; 2294 :     return (0);
; 2295 : }

	xor	eax, eax
	pop	ebp
	ret	0
$LN6@xmlShellDi:

; 2287 :         (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2288 :         xmlDebugDumpDocumentHead(ctxt->output, (xmlDocPtr) node);

	push	eax
	push	DWORD PTR [ecx+20]
	call	_xmlDebugDumpDocumentHead

; 2293 :     }
; 2294 :     return (0);
; 2295 : }

	add	esp, 8
$LN8@xmlShellDi:
	xor	eax, eax
	pop	ebp
	ret	0
_xmlShellDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellBase
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellBase PROC					; COMDAT

; 2051 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlShellBa

; 2052 :     xmlChar *base;
; 2053 :     if (!ctxt)
; 2054 :         return 0;
; 2055 :     if (node == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlShellBa

; 2056 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	DWORD PTR [esi+20]
	call	_fprintf
	add	esp, 8

; 2067 :     }
; 2068 :     return (0);
; 2069 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlShellBa:
	push	edi

; 2057 : 	return (0);
; 2058 :     }
; 2059 : 
; 2060 :     base = xmlNodeGetBase(node->doc, node);

	push	eax
	push	DWORD PTR [eax+32]
	call	_xmlNodeGetBase
	mov	edi, eax
	add	esp, 8
	mov	eax, DWORD PTR [esi+20]

; 2061 : 
; 2062 :     if (base == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlShellBa

; 2063 :         fprintf(ctxt->output, " No base found !!!\n");

	push	OFFSET ??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@
	push	eax
	call	_fprintf
	add	esp, 8

; 2067 :     }
; 2068 :     return (0);
; 2069 : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlShellBa:

; 2064 :     } else {
; 2065 :         fprintf(ctxt->output, "%s\n", base);

	push	edi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	eax
	call	_fprintf

; 2066 :         xmlFree(base);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H
	pop	edi
$LN5@xmlShellBa:

; 2067 :     }
; 2068 :     return (0);
; 2069 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlShellBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellList PROC					; COMDAT

; 2008 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN3@xmlShellLi

; 2009 :     xmlNodePtr cur;
; 2010 :     if (!ctxt)
; 2011 :         return (0);
; 2012 :     if (node == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	jne	SHORT $LN5@xmlShellLi

; 2013 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	push	DWORD PTR [ebx+20]
	call	_fprintf
	add	esp, 8

; 2031 :     }
; 2032 :     return (0);
; 2033 : }

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlShellLi:

; 2014 : 	return (0);
; 2015 :     }
; 2016 :     if ((node->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 9
	je	SHORT $LN8@xmlShellLi
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@xmlShellLi

; 2019 :     } else if (node->type == XML_NAMESPACE_DECL) {

	cmp	ecx, 18					; 00000012H
	je	SHORT $LN79@xmlShellLi

; 2020 :         xmlLsOneNode(ctxt->output, node);
; 2021 :         return (0);
; 2022 :     } else if (node->children != NULL) {

	mov	esi, DWORD PTR [eax+12]
	test	esi, esi
	jne	SHORT $LN73@xmlShellLi
$LN79@xmlShellLi:

; 2031 :     }
; 2032 :     return (0);
; 2033 : }

	push	eax
	push	DWORD PTR [ebx+20]
	call	_xmlLsOneNode
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlShellLi:

; 2017 :         (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2018 :         cur = ((xmlDocPtr) node)->children;

	mov	esi, DWORD PTR [eax+12]

; 2023 :         cur = node->children;
; 2024 :     } else {
; 2025 :         xmlLsOneNode(ctxt->output, node);
; 2026 :         return (0);
; 2027 :     }
; 2028 :     while (cur != NULL) {

	test	esi, esi
	je	$LN3@xmlShellLi
$LN73@xmlShellLi:
	push	edi
	npad	2
$LL2@xmlShellLi:

; 2029 :         xmlLsOneNode(ctxt->output, cur);

	mov	edi, DWORD PTR [ebx+20]

; 1663 :     if (output == NULL) return;

	test	edi, edi
	je	$LN14@xmlShellLi

; 1664 :     if (node == NULL) {

	test	esi, esi
	jne	SHORT $LN20@xmlShellLi

; 1665 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@

; 1666 : 	return;

	jmp	$LN74@xmlShellLi
$LN20@xmlShellLi:

; 1667 :     }
; 1668 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN35@xmlShellLi
	jmp	DWORD PTR $LN81@xmlShellLi[eax*4]
$LN21@xmlShellLi:

; 1669 : 	case XML_ELEMENT_NODE:
; 1670 : 	    fprintf(output, "-");

	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@

; 1671 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN22@xmlShellLi:

; 1672 : 	case XML_ATTRIBUTE_NODE:
; 1673 : 	    fprintf(output, "a");

	mov	eax, OFFSET ??_C@_01MCMALHOG@a@

; 1674 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN23@xmlShellLi:

; 1675 : 	case XML_TEXT_NODE:
; 1676 : 	    fprintf(output, "t");

	mov	eax, OFFSET ??_C@_01PFHFFBPC@t@

; 1677 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN24@xmlShellLi:

; 1678 : 	case XML_CDATA_SECTION_NODE:
; 1679 : 	    fprintf(output, "C");

	mov	eax, OFFSET ??_C@_01GFHCPBMG@C@

; 1680 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN25@xmlShellLi:

; 1681 : 	case XML_ENTITY_REF_NODE:
; 1682 : 	    fprintf(output, "e");

	mov	eax, OFFSET ??_C@_01KGKMHCOC@e@

; 1683 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN26@xmlShellLi:

; 1684 : 	case XML_ENTITY_NODE:
; 1685 : 	    fprintf(output, "E");

	mov	eax, OFFSET ??_C@_01DDCIFGEA@E@

; 1686 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN27@xmlShellLi:

; 1687 : 	case XML_PI_NODE:
; 1688 : 	    fprintf(output, "p");

	mov	eax, OFFSET ??_C@_01JBBJJEPG@p@

; 1689 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN28@xmlShellLi:

; 1690 : 	case XML_COMMENT_NODE:
; 1691 : 	    fprintf(output, "c");

	mov	eax, OFFSET ??_C@_01PAPGNFGE@c@

; 1692 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN29@xmlShellLi:

; 1693 : 	case XML_DOCUMENT_NODE:
; 1694 : 	    fprintf(output, "d");

	mov	eax, OFFSET ??_C@_01LPLHEDKD@d@

; 1695 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN30@xmlShellLi:

; 1696 : 	case XML_HTML_DOCUMENT_NODE:
; 1697 : 	    fprintf(output, "h");

	mov	eax, OFFSET ??_C@_01BDACAMKP@h@

; 1698 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN31@xmlShellLi:

; 1699 : 	case XML_DOCUMENT_TYPE_NODE:
; 1700 : 	    fprintf(output, "T");

	mov	eax, OFFSET ??_C@_01GAPBHFFA@T@

; 1701 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN32@xmlShellLi:

; 1702 : 	case XML_DOCUMENT_FRAG_NODE:
; 1703 : 	    fprintf(output, "F");

	mov	eax, OFFSET ??_C@_01BIAFAFID@F@

; 1704 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN33@xmlShellLi:

; 1705 : 	case XML_NOTATION_NODE:
; 1706 : 	    fprintf(output, "N");

	mov	eax, OFFSET ??_C@_01NANMIPIL@N@

; 1707 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN34@xmlShellLi:

; 1708 : 	case XML_NAMESPACE_DECL:
; 1709 : 	    fprintf(output, "n");

	mov	eax, OFFSET ??_C@_01EFFIKLCJ@n@

; 1710 : 	    break;

	jmp	SHORT $LN15@xmlShellLi
$LN35@xmlShellLi:

; 1711 : 	default:
; 1712 : 	    fprintf(output, "?");

	mov	eax, OFFSET ??_C@_01OGPIMHDM@?$DP@
$LN15@xmlShellLi:

; 1713 :     }
; 1714 :     if (node->type != XML_NAMESPACE_DECL) {

	push	eax
	push	edi
	call	_fprintf
	add	esp, 8
	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN40@xmlShellLi

; 1715 : 	if (node->properties != NULL)
; 1716 : 	    fprintf(output, "a");
; 1717 : 	else
; 1718 : 	    fprintf(output, "-");
; 1719 : 	if (node->nsDef != NULL)

	cmp	DWORD PTR [esi+44], 0
	mov	ecx, OFFSET ??_C@_01MCMALHOG@a@
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@
	cmovne	eax, ecx
	push	eax
	push	edi
	call	_fprintf
	add	esp, 8
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN39@xmlShellLi

; 1720 : 	    fprintf(output, "n");

	push	OFFSET ??_C@_01EFFIKLCJ@n@
	jmp	SHORT $LN75@xmlShellLi
$LN39@xmlShellLi:

; 1721 : 	else
; 1722 : 	    fprintf(output, "-");

	push	OFFSET ??_C@_01JOAMLHOP@?9@
$LN75@xmlShellLi:

; 1723 :     }
; 1724 : 
; 1725 :     fprintf(output, " %8d ", xmlLsCountNode(node));

	push	edi
	call	_fprintf
	add	esp, 8
$LN40@xmlShellLi:
	push	esi
	call	_xmlLsCountNode
	push	eax
	push	OFFSET ??_C@_05KPHFGMAO@?5?$CF8d?5@
	push	edi
	call	_fprintf

; 1726 : 
; 1727 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 16					; 00000010H
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN64@xmlShellLi
	movzx	eax, BYTE PTR $LN71@xmlShellLi[eax]
	jmp	DWORD PTR $LN82@xmlShellLi[eax*4]
$LN41@xmlShellLi:

; 1728 : 	case XML_ELEMENT_NODE:
; 1729 : 	    if (node->name != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN65@xmlShellLi

; 1730 :                 if ((node->ns != NULL) && (node->ns->prefix != NULL))

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN43@xmlShellLi
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN43@xmlShellLi

; 1731 :                     fprintf(output, "%s:", node->ns->prefix);

	push	ecx
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH

; 1732 : 		fprintf(output, "%s", (const char *) node->name);
; 1733 :             }
; 1734 : 	    break;

	jmp	SHORT $LN43@xmlShellLi
$LN46@xmlShellLi:

; 1735 : 	case XML_ATTRIBUTE_NODE:
; 1736 : 	    if (node->name != NULL)
; 1737 : 		fprintf(output, "%s", (const char *) node->name);
; 1738 : 	    break;
; 1739 : 	case XML_TEXT_NODE:
; 1740 : 	    if (node->content != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN65@xmlShellLi

; 1741 : 		xmlDebugDumpString(output, node->content);

	push	eax
	push	edi
	call	_xmlDebugDumpString
	add	esp, 8

; 1742 :             }
; 1743 : 	    break;
; 1744 : 	case XML_CDATA_SECTION_NODE:
; 1745 : 	    break;
; 1746 : 	case XML_ENTITY_REF_NODE:
; 1747 : 	    if (node->name != NULL)
; 1748 : 		fprintf(output, "%s", (const char *) node->name);
; 1749 : 	    break;

	jmp	SHORT $LN65@xmlShellLi
$LN61@xmlShellLi:

; 1750 : 	case XML_ENTITY_NODE:
; 1751 : 	    if (node->name != NULL)
; 1752 : 		fprintf(output, "%s", (const char *) node->name);
; 1753 : 	    break;
; 1754 : 	case XML_PI_NODE:
; 1755 : 	    if (node->name != NULL)
; 1756 : 		fprintf(output, "%s", (const char *) node->name);
; 1757 : 	    break;
; 1758 : 	case XML_COMMENT_NODE:
; 1759 : 	    break;
; 1760 : 	case XML_DOCUMENT_NODE:
; 1761 : 	    break;
; 1762 : 	case XML_HTML_DOCUMENT_NODE:
; 1763 : 	    break;
; 1764 : 	case XML_DOCUMENT_TYPE_NODE:
; 1765 : 	    break;
; 1766 : 	case XML_DOCUMENT_FRAG_NODE:
; 1767 : 	    break;
; 1768 : 	case XML_NOTATION_NODE:
; 1769 : 	    break;
; 1770 : 	case XML_NAMESPACE_DECL: {
; 1771 : 	    xmlNsPtr ns = (xmlNsPtr) node;
; 1772 : 
; 1773 : 	    if (ns->prefix == NULL)

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	test	eax, eax
	jne	SHORT $LN62@xmlShellLi

; 1774 : 		fprintf(output, "default -> %s", (char *)ns->href);

	push	OFFSET ??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@
	jmp	SHORT $LN78@xmlShellLi
$LN62@xmlShellLi:

; 1775 : 	    else
; 1776 : 		fprintf(output, "%s -> %s", (char *)ns->prefix,

	push	eax
	push	OFFSET ??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@
	push	edi
	call	_fprintf
	add	esp, 16					; 00000010H

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;
; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)
; 1782 : 		fprintf(output, "%s", (const char *) node->name);
; 1783 :     }
; 1784 :     fprintf(output, "\n");

	jmp	SHORT $LN65@xmlShellLi
$LN64@xmlShellLi:
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN65@xmlShellLi
$LN43@xmlShellLi:
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
$LN78@xmlShellLi:
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN65@xmlShellLi:
	push	OFFSET ??_C@_01EEMJAFIK@?6@
$LN74@xmlShellLi:

; 2030 :         cur = cur->next;

	push	edi
	call	_fprintf
	add	esp, 8
$LN14@xmlShellLi:
	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	$LL2@xmlShellLi
	pop	edi
$LN3@xmlShellLi:
	pop	esi

; 2031 :     }
; 2032 :     return (0);
; 2033 : }

	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN81@xmlShellLi:
	DD	$LN21@xmlShellLi
	DD	$LN22@xmlShellLi
	DD	$LN23@xmlShellLi
	DD	$LN24@xmlShellLi
	DD	$LN25@xmlShellLi
	DD	$LN26@xmlShellLi
	DD	$LN27@xmlShellLi
	DD	$LN28@xmlShellLi
	DD	$LN29@xmlShellLi
	DD	$LN31@xmlShellLi
	DD	$LN32@xmlShellLi
	DD	$LN33@xmlShellLi
	DD	$LN30@xmlShellLi
	DD	$LN35@xmlShellLi
	DD	$LN35@xmlShellLi
	DD	$LN35@xmlShellLi
	DD	$LN35@xmlShellLi
	DD	$LN34@xmlShellLi
$LN82@xmlShellLi:
	DD	$LN41@xmlShellLi
	DD	$LN64@xmlShellLi
	DD	$LN46@xmlShellLi
	DD	$LN65@xmlShellLi
	DD	$LN61@xmlShellLi
	DD	$LN64@xmlShellLi
$LN71@xmlShellLi:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_xmlShellList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathResult
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlShellPrintXPathResult PROC				; COMDAT
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlShellPrintXPathResult ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathError
_TEXT	SEGMENT
_errorType$ = 8						; size = 4
_arg$ = 12						; size = 4
_xmlShellPrintXPathError PROC				; COMDAT

; 1829 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _arg$[ebp]
	mov	edi, OFFSET ??_C@_06GGONACPB@Result@
	test	eax, eax
	cmovne	edi, eax
	mov	eax, DWORD PTR _errorType$[ebp]
	cmp	eax, 9
	ja	$LN2@xmlShellPr

; 1830 :     const char *default_arg = "Result";
; 1831 : 
; 1832 :     if (!arg)
; 1833 :         arg = default_arg;
; 1834 : 
; 1835 :     switch (errorType) {

	push	esi
	jmp	DWORD PTR $LN18@xmlShellPr[eax*4]
$LN5@xmlShellPr:

; 1836 :         case XPATH_UNDEFINED:
; 1837 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN6@xmlShellPr:

; 1838 :                             "%s: no such node\n", arg);
; 1839 :             break;
; 1840 : 
; 1841 :         case XPATH_BOOLEAN:
; 1842 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN7@xmlShellPr:

; 1843 :                             "%s is a Boolean\n", arg);
; 1844 :             break;
; 1845 :         case XPATH_NUMBER:
; 1846 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN8@xmlShellPr:

; 1847 :                             "%s is a number\n", arg);
; 1848 :             break;
; 1849 :         case XPATH_STRING:
; 1850 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN9@xmlShellPr:

; 1851 :                             "%s is a string\n", arg);
; 1852 :             break;
; 1853 :         case XPATH_POINT:
; 1854 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN10@xmlShellPr:

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN12@xmlShellPr:

; 1855 :                             "%s is a point\n", arg);
; 1856 :             break;
; 1857 :         case XPATH_RANGE:
; 1858 :             xmlGenericError(xmlGenericErrorContext,
; 1859 :                             "%s is a range\n", arg);
; 1860 :             break;
; 1861 :         case XPATH_LOCATIONSET:
; 1862 :             xmlGenericError(xmlGenericErrorContext,
; 1863 :                             "%s is a range\n", arg);
; 1864 :             break;
; 1865 :         case XPATH_USERS:
; 1866 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
$LN13@xmlShellPr:

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;
; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$LN15@xmlShellPr:
	pop	esi
$LN2@xmlShellPr:
	pop	edi

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	ebp
	ret	0
	npad	1
$LN18@xmlShellPr:
	DD	$LN5@xmlShellPr
	DD	$LN15@xmlShellPr
	DD	$LN6@xmlShellPr
	DD	$LN7@xmlShellPr
	DD	$LN8@xmlShellPr
	DD	$LN9@xmlShellPr
	DD	$LN10@xmlShellPr
	DD	$LN10@xmlShellPr
	DD	$LN12@xmlShellPr
	DD	$LN13@xmlShellPr
_xmlShellPrintXPathError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlBoolToText
_TEXT	SEGMENT
_boolval$ = 8						; size = 4
_xmlBoolToText PROC					; COMDAT

; 1797 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _boolval$[ebp], 0
	mov	eax, OFFSET ??_C@_04HPMIDMKH@True@
	mov	ecx, OFFSET ??_C@_05MKDOIIA@False@
	cmove	eax, ecx

; 1798 :     if (boolval)
; 1799 :         return("True");
; 1800 :     else
; 1801 :         return("False");
; 1802 : }

	pop	ebp
	ret	0
_xmlBoolToText ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlLsCountNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlLsCountNode PROC					; COMDAT

; 1605 : xmlLsCountNode(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _node$[ebp]
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	ecx, ecx
	test	esi, esi
	jne	SHORT $LN7@xmlLsCount

; 1606 :     int ret = 0;
; 1607 :     xmlNodePtr list = NULL;
; 1608 : 
; 1609 :     if (node == NULL)
; 1610 : 	return(0);

	xor	eax, eax
	pop	esi

; 1652 : }

	pop	ebp
	ret	0
$LN7@xmlLsCount:

; 1611 : 
; 1612 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN5@xmlLsCount
	movzx	eax, BYTE PTR $LN19@xmlLsCount[eax]
	jmp	DWORD PTR $LN21@xmlLsCount[eax*4]
$LN11@xmlLsCount:

; 1613 : 	case XML_ELEMENT_NODE:
; 1614 : 	    list = node->children;
; 1615 : 	    break;
; 1616 : 	case XML_DOCUMENT_NODE:
; 1617 : 	case XML_HTML_DOCUMENT_NODE:
; 1618 : #ifdef LIBXML_DOCB_ENABLED
; 1619 : 	case XML_DOCB_DOCUMENT_NODE:
; 1620 : #endif
; 1621 : 	    list = ((xmlDocPtr) node)->children;
; 1622 : 	    break;
; 1623 : 	case XML_ATTRIBUTE_NODE:
; 1624 : 	    list = ((xmlAttrPtr) node)->children;
; 1625 : 	    break;
; 1626 : 	case XML_TEXT_NODE:
; 1627 : 	case XML_CDATA_SECTION_NODE:
; 1628 : 	case XML_PI_NODE:
; 1629 : 	case XML_COMMENT_NODE:
; 1630 : 	    if (node->content != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN5@xmlLsCount

; 1631 : 		ret = xmlStrlen(node->content);

	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	ecx, eax
	pop	esi

; 1652 : }

	pop	ebp
	ret	0
$LN13@xmlLsCount:

; 1632 :             }
; 1633 : 	    break;
; 1634 : 	case XML_ENTITY_REF_NODE:
; 1635 : 	case XML_DOCUMENT_TYPE_NODE:
; 1636 : 	case XML_ENTITY_NODE:
; 1637 : 	case XML_DOCUMENT_FRAG_NODE:
; 1638 : 	case XML_NOTATION_NODE:
; 1639 : 	case XML_DTD_NODE:
; 1640 :         case XML_ELEMENT_DECL:
; 1641 :         case XML_ATTRIBUTE_DECL:
; 1642 :         case XML_ENTITY_DECL:
; 1643 : 	case XML_NAMESPACE_DECL:
; 1644 : 	case XML_XINCLUDE_START:
; 1645 : 	case XML_XINCLUDE_END:
; 1646 : 	    ret = 1;

	mov	ecx, 1

; 1651 :     return(ret);

	mov	eax, ecx
	pop	esi

; 1652 : }

	pop	ebp
	ret	0
$LN2@xmlLsCount:

; 1647 : 	    break;
; 1648 :     }
; 1649 :     for (;list != NULL;ret++)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@xmlLsCount
	npad	7
$LL6@xmlLsCount:

; 1650 :         list = list->next;

	mov	eax, DWORD PTR [eax+24]
	inc	ecx
	test	eax, eax
	jne	SHORT $LL6@xmlLsCount
$LN5@xmlLsCount:

; 1651 :     return(ret);

	mov	eax, ecx
	pop	esi

; 1652 : }

	pop	ebp
	ret	0
	npad	3
$LN21@xmlLsCount:
	DD	$LN2@xmlLsCount
	DD	$LN11@xmlLsCount
	DD	$LN13@xmlLsCount
$LN19@xmlLsCount:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_xmlLsCountNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlLsOneNode
_TEXT	SEGMENT
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlLsOneNode PROC					; COMDAT

; 1662 : xmlLsOneNode(FILE *output, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	$LN1@xmlLsOneNo

; 1663 :     if (output == NULL) return;
; 1664 :     if (node == NULL) {

	push	edi
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	jne	SHORT $LN7@xmlLsOneNo

; 1665 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;
; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)
; 1782 : 		fprintf(output, "%s", (const char *) node->name);
; 1783 :     }
; 1784 :     fprintf(output, "\n");

	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 1785 : }

	pop	ebp
	ret	0
$LN7@xmlLsOneNo:

; 1666 : 	return;
; 1667 :     }
; 1668 :     switch (node->type) {

	mov	eax, DWORD PTR [edi+4]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN22@xmlLsOneNo
	jmp	DWORD PTR $LN62@xmlLsOneNo[eax*4]
$LN8@xmlLsOneNo:

; 1669 : 	case XML_ELEMENT_NODE:
; 1670 : 	    fprintf(output, "-");

	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@

; 1671 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN9@xmlLsOneNo:

; 1672 : 	case XML_ATTRIBUTE_NODE:
; 1673 : 	    fprintf(output, "a");

	mov	eax, OFFSET ??_C@_01MCMALHOG@a@

; 1674 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN10@xmlLsOneNo:

; 1675 : 	case XML_TEXT_NODE:
; 1676 : 	    fprintf(output, "t");

	mov	eax, OFFSET ??_C@_01PFHFFBPC@t@

; 1677 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN11@xmlLsOneNo:

; 1678 : 	case XML_CDATA_SECTION_NODE:
; 1679 : 	    fprintf(output, "C");

	mov	eax, OFFSET ??_C@_01GFHCPBMG@C@

; 1680 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN12@xmlLsOneNo:

; 1681 : 	case XML_ENTITY_REF_NODE:
; 1682 : 	    fprintf(output, "e");

	mov	eax, OFFSET ??_C@_01KGKMHCOC@e@

; 1683 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN13@xmlLsOneNo:

; 1684 : 	case XML_ENTITY_NODE:
; 1685 : 	    fprintf(output, "E");

	mov	eax, OFFSET ??_C@_01DDCIFGEA@E@

; 1686 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN14@xmlLsOneNo:

; 1687 : 	case XML_PI_NODE:
; 1688 : 	    fprintf(output, "p");

	mov	eax, OFFSET ??_C@_01JBBJJEPG@p@

; 1689 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN15@xmlLsOneNo:

; 1690 : 	case XML_COMMENT_NODE:
; 1691 : 	    fprintf(output, "c");

	mov	eax, OFFSET ??_C@_01PAPGNFGE@c@

; 1692 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN16@xmlLsOneNo:

; 1693 : 	case XML_DOCUMENT_NODE:
; 1694 : 	    fprintf(output, "d");

	mov	eax, OFFSET ??_C@_01LPLHEDKD@d@

; 1695 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN17@xmlLsOneNo:

; 1696 : 	case XML_HTML_DOCUMENT_NODE:
; 1697 : 	    fprintf(output, "h");

	mov	eax, OFFSET ??_C@_01BDACAMKP@h@

; 1698 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN18@xmlLsOneNo:

; 1699 : 	case XML_DOCUMENT_TYPE_NODE:
; 1700 : 	    fprintf(output, "T");

	mov	eax, OFFSET ??_C@_01GAPBHFFA@T@

; 1701 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN19@xmlLsOneNo:

; 1702 : 	case XML_DOCUMENT_FRAG_NODE:
; 1703 : 	    fprintf(output, "F");

	mov	eax, OFFSET ??_C@_01BIAFAFID@F@

; 1704 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN20@xmlLsOneNo:

; 1705 : 	case XML_NOTATION_NODE:
; 1706 : 	    fprintf(output, "N");

	mov	eax, OFFSET ??_C@_01NANMIPIL@N@

; 1707 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN21@xmlLsOneNo:

; 1708 : 	case XML_NAMESPACE_DECL:
; 1709 : 	    fprintf(output, "n");

	mov	eax, OFFSET ??_C@_01EFFIKLCJ@n@

; 1710 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN22@xmlLsOneNo:

; 1711 : 	default:
; 1712 : 	    fprintf(output, "?");

	mov	eax, OFFSET ??_C@_01OGPIMHDM@?$DP@
$LN2@xmlLsOneNo:

; 1713 :     }
; 1714 :     if (node->type != XML_NAMESPACE_DECL) {

	push	eax
	push	esi
	call	_fprintf
	add	esp, 8
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN27@xmlLsOneNo

; 1715 : 	if (node->properties != NULL)
; 1716 : 	    fprintf(output, "a");
; 1717 : 	else
; 1718 : 	    fprintf(output, "-");
; 1719 : 	if (node->nsDef != NULL)

	cmp	DWORD PTR [edi+44], 0
	mov	ecx, OFFSET ??_C@_01MCMALHOG@a@
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@
	cmovne	eax, ecx
	push	eax
	push	esi
	call	_fprintf
	add	esp, 8
	cmp	DWORD PTR [edi+48], 0
	je	SHORT $LN26@xmlLsOneNo

; 1720 : 	    fprintf(output, "n");

	push	OFFSET ??_C@_01EFFIKLCJ@n@
	jmp	SHORT $LN57@xmlLsOneNo
$LN26@xmlLsOneNo:

; 1721 : 	else
; 1722 : 	    fprintf(output, "-");

	push	OFFSET ??_C@_01JOAMLHOP@?9@
$LN57@xmlLsOneNo:

; 1723 :     }
; 1724 : 
; 1725 :     fprintf(output, " %8d ", xmlLsCountNode(node));

	push	esi
	call	_fprintf
	add	esp, 8
$LN27@xmlLsOneNo:
	push	edi
	call	_xmlLsCountNode
	push	eax
	push	OFFSET ??_C@_05KPHFGMAO@?5?$CF8d?5@
	push	esi
	call	_fprintf

; 1726 : 
; 1727 :     switch (node->type) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 16					; 00000010H
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	$LN51@xmlLsOneNo
	movzx	eax, BYTE PTR $LN54@xmlLsOneNo[eax]
	jmp	DWORD PTR $LN63@xmlLsOneNo[eax*4]
$LN28@xmlLsOneNo:

; 1728 : 	case XML_ELEMENT_NODE:
; 1729 : 	    if (node->name != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	$LN52@xmlLsOneNo

; 1730 :                 if ((node->ns != NULL) && (node->ns->prefix != NULL))

	mov	ecx, DWORD PTR [edi+36]
	test	ecx, ecx
	je	SHORT $LN30@xmlLsOneNo
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN30@xmlLsOneNo

; 1731 :                     fprintf(output, "%s:", node->ns->prefix);

	push	ecx
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH

; 1732 : 		fprintf(output, "%s", (const char *) node->name);
; 1733 :             }
; 1734 : 	    break;

	jmp	SHORT $LN30@xmlLsOneNo
$LN33@xmlLsOneNo:

; 1735 : 	case XML_ATTRIBUTE_NODE:
; 1736 : 	    if (node->name != NULL)
; 1737 : 		fprintf(output, "%s", (const char *) node->name);
; 1738 : 	    break;
; 1739 : 	case XML_TEXT_NODE:
; 1740 : 	    if (node->content != NULL) {

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN52@xmlLsOneNo

; 1741 : 		xmlDebugDumpString(output, node->content);

	push	eax
	push	esi
	call	_xmlDebugDumpString
	add	esp, 8

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;
; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)
; 1782 : 		fprintf(output, "%s", (const char *) node->name);
; 1783 :     }
; 1784 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 1785 : }

	pop	ebp
	ret	0
$LN48@xmlLsOneNo:

; 1742 :             }
; 1743 : 	    break;
; 1744 : 	case XML_CDATA_SECTION_NODE:
; 1745 : 	    break;
; 1746 : 	case XML_ENTITY_REF_NODE:
; 1747 : 	    if (node->name != NULL)
; 1748 : 		fprintf(output, "%s", (const char *) node->name);
; 1749 : 	    break;
; 1750 : 	case XML_ENTITY_NODE:
; 1751 : 	    if (node->name != NULL)
; 1752 : 		fprintf(output, "%s", (const char *) node->name);
; 1753 : 	    break;
; 1754 : 	case XML_PI_NODE:
; 1755 : 	    if (node->name != NULL)
; 1756 : 		fprintf(output, "%s", (const char *) node->name);
; 1757 : 	    break;
; 1758 : 	case XML_COMMENT_NODE:
; 1759 : 	    break;
; 1760 : 	case XML_DOCUMENT_NODE:
; 1761 : 	    break;
; 1762 : 	case XML_HTML_DOCUMENT_NODE:
; 1763 : 	    break;
; 1764 : 	case XML_DOCUMENT_TYPE_NODE:
; 1765 : 	    break;
; 1766 : 	case XML_DOCUMENT_FRAG_NODE:
; 1767 : 	    break;
; 1768 : 	case XML_NOTATION_NODE:
; 1769 : 	    break;
; 1770 : 	case XML_NAMESPACE_DECL: {
; 1771 : 	    xmlNsPtr ns = (xmlNsPtr) node;
; 1772 : 
; 1773 : 	    if (ns->prefix == NULL)

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [edi+8]
	push	eax
	test	ecx, ecx
	jne	SHORT $LN49@xmlLsOneNo

; 1774 : 		fprintf(output, "default -> %s", (char *)ns->href);

	push	OFFSET ??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@
	jmp	SHORT $LN60@xmlLsOneNo
$LN49@xmlLsOneNo:

; 1775 : 	    else
; 1776 : 		fprintf(output, "%s -> %s", (char *)ns->prefix,

	push	ecx
	push	OFFSET ??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;
; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)
; 1782 : 		fprintf(output, "%s", (const char *) node->name);
; 1783 :     }
; 1784 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
	pop	esi

; 1785 : }

	pop	ebp
	ret	0
$LN51@xmlLsOneNo:

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;
; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)
; 1782 : 		fprintf(output, "%s", (const char *) node->name);
; 1783 :     }
; 1784 :     fprintf(output, "\n");

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN52@xmlLsOneNo
$LN30@xmlLsOneNo:
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
$LN60@xmlLsOneNo:
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN52@xmlLsOneNo:
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	edi
$LN1@xmlLsOneNo:
	pop	esi

; 1785 : }

	pop	ebp
	ret	0
	npad	1
$LN62@xmlLsOneNo:
	DD	$LN8@xmlLsOneNo
	DD	$LN9@xmlLsOneNo
	DD	$LN10@xmlLsOneNo
	DD	$LN11@xmlLsOneNo
	DD	$LN12@xmlLsOneNo
	DD	$LN13@xmlLsOneNo
	DD	$LN14@xmlLsOneNo
	DD	$LN15@xmlLsOneNo
	DD	$LN16@xmlLsOneNo
	DD	$LN18@xmlLsOneNo
	DD	$LN19@xmlLsOneNo
	DD	$LN20@xmlLsOneNo
	DD	$LN17@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN21@xmlLsOneNo
$LN63@xmlLsOneNo:
	DD	$LN28@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
	DD	$LN33@xmlLsOneNo
	DD	$LN52@xmlLsOneNo
	DD	$LN48@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
$LN54@xmlLsOneNo:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_xmlLsOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugCheckDocument
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugCheckDocument PROC				; COMDAT

; 1577 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugCh

; 1578 :     xmlDebugCtxt ctxt;
; 1579 : 
; 1580 :     if (output == NULL)
; 1581 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugCh:

; 1582 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1583 :     ctxt.output = output;
; 1584 :     ctxt.check = 1;
; 1585 :     xmlCtxtDumpDocument(&ctxt, doc);

	push	DWORD PTR _doc$[ebp]
	lea	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ctxt$[ebp], esi
	push	eax
	mov	DWORD PTR _ctxt$[ebp+124], 1
	call	_xmlCtxtDumpDocument

; 1586 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1587 :     return(ctxt.errors);

	mov	eax, DWORD PTR _ctxt$[ebp+128]
	add	esp, 12					; 0000000cH
	pop	esi

; 1588 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugCheckDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpEntities
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpEntities PROC				; COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	$LN12@xmlDebugDu

; 1401 :     xmlDebugCtxt ctxt;
; 1402 : 
; 1403 :     if (output == NULL) return;
; 1404 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1405 :     ctxt.output = output;

	mov	DWORD PTR _ctxt$[ebp], esi
	add	esp, 4

; 1287 :     if (doc == NULL) return;

	mov	esi, DWORD PTR _doc$[ebp]
	test	esi, esi
	je	$LN12@xmlDebugDu

; 1288 :     xmlCtxtDumpDocHead(ctxt, doc);

	push	edi
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlCtxtDumpDocHead

; 1289 :     if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {

	mov	eax, DWORD PTR [esi+44]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlDebugDu
	mov	edi, DWORD PTR [eax+48]
	test	edi, edi
	je	SHORT $LN6@xmlDebugDu

; 1290 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)
; 1291 :             doc->intSubset->entities;
; 1292 : 
; 1293 :         if (!ctxt->check)

	cmp	DWORD PTR _ctxt$[ebp+124], 0
	jne	SHORT $LN8@xmlDebugDu

; 1294 :             fprintf(ctxt->output, "Entities in internal subset\n");

	push	OFFSET ??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_fprintf
	add	esp, 8
$LN8@xmlDebugDu:

; 1295 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	OFFSET _xmlCtxtDumpEntityCallback
	push	edi
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 1296 :     } else

	jmp	SHORT $LN7@xmlDebugDu
$LN6@xmlDebugDu:

; 1297 :         fprintf(ctxt->output, "No entities in internal subset\n");

	push	OFFSET ??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_fprintf
	add	esp, 8
$LN7@xmlDebugDu:

; 1298 :     if ((doc->extSubset != NULL) && (doc->extSubset->entities != NULL)) {

	mov	eax, DWORD PTR [esi+48]
	pop	edi
	test	eax, eax
	je	SHORT $LN9@xmlDebugDu
	mov	esi, DWORD PTR [eax+48]
	test	esi, esi
	je	SHORT $LN9@xmlDebugDu

; 1299 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)
; 1300 :             doc->extSubset->entities;
; 1301 : 
; 1302 :         if (!ctxt->check)

	cmp	DWORD PTR _ctxt$[ebp+124], 0
	jne	SHORT $LN11@xmlDebugDu

; 1303 :             fprintf(ctxt->output, "Entities in external subset\n");

	push	OFFSET ??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_fprintf
	add	esp, 8
$LN11@xmlDebugDu:

; 1304 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	OFFSET _xmlCtxtDumpEntityCallback
	push	esi
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
	pop	esi

; 1406 :     xmlCtxtDumpEntities(&ctxt, doc);
; 1407 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1408 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlDebugDu:

; 1305 :     } else if (!ctxt->check)

	cmp	DWORD PTR _ctxt$[ebp+124], 0
	jne	SHORT $LN12@xmlDebugDu

; 1306 :         fprintf(ctxt->output, "No entities in external subset\n");

	push	OFFSET ??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_fprintf
	add	esp, 8
$LN12@xmlDebugDu:
	pop	esi

; 1406 :     xmlCtxtDumpEntities(&ctxt, doc);
; 1407 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1408 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDTD
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlDebugDumpDTD PROC					; COMDAT

; 1547 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugDu

; 1548 :     xmlDebugCtxt ctxt;
; 1549 : 
; 1550 :     if (output == NULL)
; 1551 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugDu:

; 1552 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1553 :     ctxt.options |= DUMP_TEXT_TYPE;

	or	DWORD PTR _ctxt$[ebp+136], 1
	add	esp, 4

; 1319 :     if (dtd == NULL) {

	mov	edi, DWORD PTR _dtd$[ebp]

; 1554 :     ctxt.output = output;

	mov	DWORD PTR _ctxt$[ebp], esi

; 1319 :     if (dtd == NULL) {

	test	edi, edi
	jne	SHORT $LN5@xmlDebugDu

; 1320 :         if (!ctxt->check)

	cmp	DWORD PTR _ctxt$[ebp+124], edi
	jne	SHORT $LN8@xmlDebugDu

; 1321 :             fprintf(ctxt->output, "DTD is NULL\n");

	push	OFFSET ??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@
	push	esi
	call	_fprintf

; 1555 :     xmlCtxtDumpDTD(&ctxt, dtd);
; 1556 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1557 : }

	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlDebugDu:

; 1324 :     xmlCtxtDumpDtdNode(ctxt, dtd);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlCtxtDumpDtdNode

; 1325 :     if (dtd->children == NULL)

	mov	eax, DWORD PTR [edi+12]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlDebugDu

; 1326 :         fprintf(ctxt->output, "    DTD is empty\n");

	push	OFFSET ??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_fprintf

; 1555 :     xmlCtxtDumpDTD(&ctxt, dtd);
; 1556 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1557 : }

	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlDebugDu:

; 1328 :         ctxt->depth++;

	inc	DWORD PTR _ctxt$[ebp+108]

; 1329 :         xmlCtxtDumpNodeList(ctxt, dtd->children);

	push	eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpNodeList

; 1555 :     xmlCtxtDumpDTD(&ctxt, dtd);
; 1556 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1557 : }

	add	esp, 8
$LN8@xmlDebugDu:
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpDTD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDocument
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpDocument PROC				; COMDAT

; 1526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugDu

; 1527 :     xmlDebugCtxt ctxt;
; 1528 : 
; 1529 :     if (output == NULL)
; 1530 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugDu:

; 1531 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1532 :     ctxt.options |= DUMP_TEXT_TYPE;
; 1533 :     ctxt.output = output;
; 1534 :     xmlCtxtDumpDocument(&ctxt, doc);

	push	DWORD PTR _doc$[ebp]
	or	DWORD PTR _ctxt$[ebp+136], 1
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpDocument
	add	esp, 12					; 0000000cH
	pop	esi

; 1535 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1536 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpDocument ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDocumentHead
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpDocumentHead PROC				; COMDAT

; 1505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugDu

; 1506 :     xmlDebugCtxt ctxt;
; 1507 : 
; 1508 :     if (output == NULL)
; 1509 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugDu:

; 1510 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1511 :     ctxt.options |= DUMP_TEXT_TYPE;
; 1512 :     ctxt.output = output;
; 1513 :     xmlCtxtDumpDocumentHead(&ctxt, doc);

	push	DWORD PTR _doc$[ebp]
	or	DWORD PTR _ctxt$[ebp+136], 1
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpDocumentHead
	add	esp, 12					; 0000000cH
	pop	esi

; 1514 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1515 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpDocumentHead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpNodeList
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpNodeList PROC				; COMDAT

; 1484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugDu

; 1485 :     xmlDebugCtxt ctxt;
; 1486 : 
; 1487 :     if (output == NULL)
; 1488 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugDu:

; 1489 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1490 :     ctxt.output = output;
; 1491 :     ctxt.depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 1492 :     xmlCtxtDumpNodeList(&ctxt, node);

	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpNodeList
	add	esp, 12					; 0000000cH
	pop	esi

; 1493 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpNode
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpNode PROC					; COMDAT

; 1462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlDebugDu

; 1463 :     xmlDebugCtxt ctxt;
; 1464 : 
; 1465 :     if (output == NULL)
; 1466 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN2@xmlDebugDu:

; 1467 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1468 :     ctxt.output = output;
; 1469 :     ctxt.depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 1470 :     xmlCtxtDumpNode(&ctxt, node);

	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpNode
	add	esp, 12					; 0000000cH
	pop	esi

; 1471 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1472 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpOneNode
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpOneNode PROC				; COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlDebugDu

; 1442 :     xmlDebugCtxt ctxt;
; 1443 : 
; 1444 :     if (output == NULL) return;
; 1445 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1446 :     ctxt.output = output;
; 1447 :     ctxt.depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 1448 :     xmlCtxtDumpOneNode(&ctxt, node);

	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpOneNode
	add	esp, 12					; 0000000cH
$LN4@xmlDebugDu:
	pop	esi

; 1449 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1450 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpAttrList
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_attr$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpAttrList PROC				; COMDAT

; 1420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlDebugDu

; 1421 :     xmlDebugCtxt ctxt;
; 1422 : 
; 1423 :     if (output == NULL) return;
; 1424 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1425 :     ctxt.output = output;
; 1426 :     ctxt.depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 1427 :     xmlCtxtDumpAttrList(&ctxt, attr);

	push	DWORD PTR _attr$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpAttrList
	add	esp, 12					; 0000000cH
$LN4@xmlDebugDu:
	pop	esi

; 1428 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1429 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpAttrList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpAttr
_TEXT	SEGMENT
_ctxt$ = -140						; size = 140
_output$ = 8						; size = 4
_attr$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpAttr PROC					; COMDAT

; 1379 : xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlDebugDu

; 1380 :     xmlDebugCtxt ctxt;
; 1381 : 
; 1382 :     if (output == NULL) return;
; 1383 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt

; 1384 :     ctxt.output = output;
; 1385 :     ctxt.depth = depth;

	mov	eax, DWORD PTR _depth$[ebp]

; 1386 :     xmlCtxtDumpAttr(&ctxt, attr);

	push	DWORD PTR _attr$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], eax
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp], esi
	call	_xmlCtxtDumpAttr
	add	esp, 12					; 0000000cH
$LN4@xmlDebugDu:
	pop	esi

; 1387 :     xmlCtxtDumpCleanCtxt(&ctxt);
; 1388 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpAttr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpString
_TEXT	SEGMENT
_output$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlDebugDumpString PROC				; COMDAT

; 1349 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _output$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlDebugDu

; 1350 :     int i;
; 1351 : 
; 1352 :     if (output == NULL)
; 1353 : 	output = stdout;

	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	esi, eax
$LN5@xmlDebugDu:

; 1354 :     if (str == NULL) {

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	jne	SHORT $LN6@xmlDebugDu

; 1355 :         fprintf(output, "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	push	esi
	call	_fprintf
	add	esp, 8
	pop	esi

; 1368 : }

	pop	ebp
	ret	0
$LN6@xmlDebugDu:
	push	ebx

; 1356 :         return;
; 1357 :     }
; 1358 :     for (i = 0; i < 40; i++)

	mov	ebx, DWORD PTR __imp__fputc
	push	edi
	xor	edi, edi
$LL4@xmlDebugDu:

; 1359 :         if (str[i] == 0)

	mov	al, BYTE PTR [edi+eax]
	test	al, al
	je	SHORT $LN21@xmlDebugDu

; 1360 :             return;
; 1361 :         else if (IS_BLANK_CH(str[i]))

	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlDebugDu
	cmp	al, 9
	jb	SHORT $LN12@xmlDebugDu
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlDebugDu
$LN12@xmlDebugDu:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN11@xmlDebugDu

; 1363 :         else if (str[i] >= 0x80)

	movzx	ecx, al
	cmp	al, 128					; 00000080H
	jb	SHORT $LN13@xmlDebugDu

; 1364 :             fprintf(output, "#%X", str[i]);

	push	ecx
	push	OFFSET ??_C@_03CANIHDGE@?$CD?$CFX@
	push	esi
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@xmlDebugDu
$LN13@xmlDebugDu:

; 1365 :         else
; 1366 :             fputc(str[i], output);

	push	esi
	push	ecx
	jmp	SHORT $LN23@xmlDebugDu
$LN11@xmlDebugDu:

; 1362 :             fputc(' ', output);

	push	esi
	push	32					; 00000020H
$LN23@xmlDebugDu:

; 1356 :         return;
; 1357 :     }
; 1358 :     for (i = 0; i < 40; i++)

	call	ebx
	add	esp, 8
$LN2@xmlDebugDu:
	mov	eax, DWORD PTR _str$[ebp]
	inc	edi
	cmp	edi, 40					; 00000028H
	jl	SHORT $LL4@xmlDebugDu

; 1367 :     fprintf(output, "...");

	push	OFFSET ??_C@_03KHICJKCI@?4?4?4@
	push	esi
	call	_fprintf
	add	esp, 8
$LN21@xmlDebugDu:
	pop	edi
	pop	ebx
	pop	esi

; 1368 : }

	pop	ebp
	ret	0
_xmlDebugDumpString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 2176 :         return __stdio_common_vsscanf(

	call	___local_stdio_scanf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);
; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2275 :         __crt_va_end(_ArgList);
; 2276 :         return _Result;

	pop	esi

; 2277 :     }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_scanf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2176 :         return __stdio_common_vsscanf(
; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
