; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\nanoftp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__194286D1_winsock2@h DB 01H
__D940C302_ws2ipdef@h DB 01H
__6E172A35_ws2tcpip@h DB 01H
__331E732B_malloc@h DB 01H
__D1B760F5_wspiapi@h DB 01H
__D3ED00D9_nanoftp@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_snprintf
PUBLIC	_sscanf
PUBLIC	_xmlNanoFTPInit
PUBLIC	_xmlNanoFTPCleanup
PUBLIC	_xmlNanoFTPNewCtxt
PUBLIC	_xmlNanoFTPFreeCtxt
PUBLIC	_xmlNanoFTPConnectTo
PUBLIC	_xmlNanoFTPOpen
PUBLIC	_xmlNanoFTPConnect
PUBLIC	_xmlNanoFTPClose
PUBLIC	_xmlNanoFTPQuit
PUBLIC	_xmlNanoFTPScanProxy
PUBLIC	_xmlNanoFTPProxy
PUBLIC	_xmlNanoFTPUpdateURL
PUBLIC	_xmlNanoFTPGetResponse
PUBLIC	_xmlNanoFTPCheckResponse
PUBLIC	_xmlNanoFTPCwd
PUBLIC	_xmlNanoFTPDele
PUBLIC	_xmlNanoFTPGetConnection
PUBLIC	_xmlNanoFTPCloseConnection
PUBLIC	_xmlNanoFTPList
PUBLIC	_xmlNanoFTPGetSocket
PUBLIC	_xmlNanoFTPGet
PUBLIC	_xmlNanoFTPRead
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_08BOGLDIEC@no_proxy@			; `string'
PUBLIC	??_C@_09FLGENLMF@ftp_proxy@			; `string'
PUBLIC	??_C@_09KECINPKO@FTP_PROXY@			; `string'
PUBLIC	??_C@_0P@CAEEHGAA@ftp_proxy_user@		; `string'
PUBLIC	??_C@_0BD@DKAPHOHE@ftp_proxy_password@		; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_03LMDBDBEG@ftp@				; `string'
PUBLIC	??_C@_0O@FGOLBKPK@Syntax?5Error?6@		; `string'
PUBLIC	??_C@_0BH@FLMMHHFH@allocating?5FTP?5context@	; `string'
PUBLIC	??_C@_0M@KMFGCEDE@recv?5failed@			; `string'
PUBLIC	??_C@_06LGNCCACI@select@			; `string'
PUBLIC	??_C@_0BB@PKBEHKHF@USER?5anonymous?$AN?6@	; `string'
PUBLIC	??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_0M@EADLIJBM@send?5failed@			; `string'
PUBLIC	??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@	; `string'
PUBLIC	??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_06FIMJICNC@QUIT?$AN?6@			; `string'
PUBLIC	??_C@_0BF@FEIPFPME@gethostbyname?5failed@	; `string'
PUBLIC	??_C@_0BP@HGBHAFPD@gethostbyname?5address?5mismatch@ ; `string'
PUBLIC	??_C@_0O@FPJGNADN@socket?5failed@		; `string'
PUBLIC	??_C@_0BO@NKBHOJOC@Failed?5to?5create?5a?5connection@ ; `string'
PUBLIC	??_C@_09HOAIGJJF@SITE?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_0BE@OGNKDKIM@USER?5anonymous?$EA?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0N@NGBGKMKP@USER?5?$CFs?$EA?$CFs?$AN?6@	; `string'
PUBLIC	??_C@_0CK@GIDKJDCD@FTP?5server?5asking?5for?5ACCNT?5on?5@ ; `string'
PUBLIC	??_C@_08JEHOKOMP@CWD?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_09PCBACKIO@DELE?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_06OGKAIOED@PASV?$AN?6@			; `string'
PUBLIC	??_C@_0BC@GDCBJEOP@?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu@ ; `string'
PUBLIC	??_C@_0BI@FEMCDLGO@Invalid?5answer?5to?5PASV?6@	; `string'
PUBLIC	??_C@_0CD@LJAJBLLL@Failed?5to?5create?5a?5data?5connect@ ; `string'
PUBLIC	??_C@_0M@NNJMLKEI@bind?5failed@			; `string'
PUBLIC	??_C@_0O@MHKNJCGE@listen?5failed@		; `string'
PUBLIC	??_C@_0BJ@FJLKMNPA@PORT?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?$AN?6@ ; `string'
PUBLIC	??_C@_05KBOMEDGA@total@				; `string'
PUBLIC	??_C@_09PLPJIOKF@LIST?5?9L?$AN?6@		; `string'
PUBLIC	??_C@_0N@MNMMLKJL@LIST?5?9L?5?$CFs?$AN?6@	; `string'
PUBLIC	??_C@_04IFMDBHHF@recv@				; `string'
PUBLIC	??_C@_08NFILCCME@TYPE?5I?$AN?6@			; `string'
PUBLIC	??_C@_09NFIHFDPP@RETR?5?$CFs?$AN?6@		; `string'
PUBLIC	??_C@_06FNAPNHDD@ftp?3?1?1@			; `string'
EXTRN	_xmlStrndup:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	___xmlIOErr:PROC
EXTRN	_strchr:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__getenv:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlParseURIRaw:PROC
EXTRN	_xmlURIUnescapeString:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__getsockname@12:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSACleanup@0:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_initialized DD	01H DUP (?)
_proxy	DD	01H DUP (?)
_proxyPort DD	01H DUP (?)
_proxyUser DD	01H DUP (?)
_proxyPasswd DD	01H DUP (?)
_proxyType DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06FNAPNHDD@ftp?3?1?1@
CONST	SEGMENT
??_C@_06FNAPNHDD@ftp?3?1?1@ DB 'ftp://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFIHFDPP@RETR?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_09NFIHFDPP@RETR?5?$CFs?$AN?6@ DB 'RETR %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NFILCCME@TYPE?5I?$AN?6@
CONST	SEGMENT
??_C@_08NFILCCME@TYPE?5I?$AN?6@ DB 'TYPE I', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFMDBHHF@recv@
CONST	SEGMENT
??_C@_04IFMDBHHF@recv@ DB 'recv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MNMMLKJL@LIST?5?9L?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0N@MNMMLKJL@LIST?5?9L?5?$CFs?$AN?6@ DB 'LIST -L %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLPJIOKF@LIST?5?9L?$AN?6@
CONST	SEGMENT
??_C@_09PLPJIOKF@LIST?5?9L?$AN?6@ DB 'LIST -L', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBOMEDGA@total@
CONST	SEGMENT
??_C@_05KBOMEDGA@total@ DB 'total', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FJLKMNPA@PORT?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?$AN?6@
CONST	SEGMENT
??_C@_0BJ@FJLKMNPA@PORT?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?$AN?6@ DB 'P'
	DB	'ORT %d,%d,%d,%d,%d,%d', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHKNJCGE@listen?5failed@
CONST	SEGMENT
??_C@_0O@MHKNJCGE@listen?5failed@ DB 'listen failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNJMLKEI@bind?5failed@
CONST	SEGMENT
??_C@_0M@NNJMLKEI@bind?5failed@ DB 'bind failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LJAJBLLL@Failed?5to?5create?5a?5data?5connect@
CONST	SEGMENT
??_C@_0CD@LJAJBLLL@Failed?5to?5create?5a?5data?5connect@ DB 'Failed to cr'
	DB	'eate a data connection', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FEMCDLGO@Invalid?5answer?5to?5PASV?6@
CONST	SEGMENT
??_C@_0BI@FEMCDLGO@Invalid?5answer?5to?5PASV?6@ DB 'Invalid answer to PAS'
	DB	'V', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GDCBJEOP@?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu@
CONST	SEGMENT
??_C@_0BC@GDCBJEOP@?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu@ DB '%u,%u,%u'
	DB	',%u,%u,%u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGKAIOED@PASV?$AN?6@
CONST	SEGMENT
??_C@_06OGKAIOED@PASV?$AN?6@ DB 'PASV', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PCBACKIO@DELE?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_09PCBACKIO@DELE?5?$CFs?$AN?6@ DB 'DELE %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JEHOKOMP@CWD?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_08JEHOKOMP@CWD?5?$CFs?$AN?6@ DB 'CWD %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GIDKJDCD@FTP?5server?5asking?5for?5ACCNT?5on?5@
CONST	SEGMENT
??_C@_0CK@GIDKJDCD@FTP?5server?5asking?5for?5ACCNT?5on?5@ DB 'FTP server '
	DB	'asking for ACCNT on anonymous', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NGBGKMKP@USER?5?$CFs?$EA?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0N@NGBGKMKP@USER?5?$CFs?$EA?$CFs?$AN?6@ DB 'USER %s@%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGNKDKIM@USER?5anonymous?$EA?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BE@OGNKDKIM@USER?5anonymous?$EA?$CFs?$AN?6@ DB 'USER anonymous@%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOAIGJJF@SITE?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_09HOAIGJJF@SITE?5?$CFs?$AN?6@ DB 'SITE %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NKBHOJOC@Failed?5to?5create?5a?5connection@
CONST	SEGMENT
??_C@_0BO@NKBHOJOC@Failed?5to?5create?5a?5connection@ DB 'Failed to creat'
	DB	'e a connection', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPJGNADN@socket?5failed@
CONST	SEGMENT
??_C@_0O@FPJGNADN@socket?5failed@ DB 'socket failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HGBHAFPD@gethostbyname?5address?5mismatch@
CONST	SEGMENT
??_C@_0BP@HGBHAFPD@gethostbyname?5address?5mismatch@ DB 'gethostbyname ad'
	DB	'dress mismatch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEIPFPME@gethostbyname?5failed@
CONST	SEGMENT
??_C@_0BF@FEIPFPME@gethostbyname?5failed@ DB 'gethostbyname failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIMJICNC@QUIT?$AN?6@
CONST	SEGMENT
??_C@_06FIMJICNC@QUIT?$AN?6@ DB 'QUIT', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@ DB 'PASS %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@
CONST	SEGMENT
??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@ DB 'PASS anonymous@', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EADLIJBM@send?5failed@
CONST	SEGMENT
??_C@_0M@EADLIJBM@send?5failed@ DB 'send failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@ DB 'USER %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PKBEHKHF@USER?5anonymous?$AN?6@
CONST	SEGMENT
??_C@_0BB@PKBEHKHF@USER?5anonymous?$AN?6@ DB 'USER anonymous', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGNCCACI@select@
CONST	SEGMENT
??_C@_06LGNCCACI@select@ DB 'select', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KMFGCEDE@recv?5failed@
CONST	SEGMENT
??_C@_0M@KMFGCEDE@recv?5failed@ DB 'recv failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLMMHHFH@allocating?5FTP?5context@
CONST	SEGMENT
??_C@_0BH@FLMMHHFH@allocating?5FTP?5context@ DB 'allocating FTP context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
CONST	SEGMENT
??_C@_0O@FGOLBKPK@Syntax?5Error?6@ DB 'Syntax Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LMDBDBEG@ftp@
CONST	SEGMENT
??_C@_03LMDBDBEG@ftp@ DB 'ftp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DKAPHOHE@ftp_proxy_password@
CONST	SEGMENT
??_C@_0BD@DKAPHOHE@ftp_proxy_password@ DB 'ftp_proxy_password', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAEEHGAA@ftp_proxy_user@
CONST	SEGMENT
??_C@_0P@CAEEHGAA@ftp_proxy_user@ DB 'ftp_proxy_user', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KECINPKO@FTP_PROXY@
CONST	SEGMENT
??_C@_09KECINPKO@FTP_PROXY@ DB 'FTP_PROXY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLGENLMF@ftp_proxy@
CONST	SEGMENT
??_C@_09FLGENLMF@ftp_proxy@ DB 'ftp_proxy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOGLDIEC@no_proxy@
CONST	SEGMENT
??_C@_08BOGLDIEC@no_proxy@ DB 'no_proxy', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPParseList
_TEXT	SEGMENT
_filename$ = -208					; size = 151
_attrib$ = -56						; size = 11
_owner$ = -44						; size = 11
_group$ = -32						; size = 11
_size$1$ = -20						; size = 4
_links$1$ = -16						; size = 4
_month$ = -12						; size = 4
_day$1$ = -8						; size = 4
_hour$1$ = -4						; size = 4
_minute$1$ = 8						; size = 4
_list$ = 8						; size = 4
_callback$ = 12						; size = 4
_userData$ = 16						; size = 4
_xmlNanoFTPParseList PROC				; COMDAT

; 1598 : xmlNanoFTPParseList(const char *list, ftpListCallback callback, void *userData) {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _list$[ebp]
	xor	ebx, ebx
	push	5
	push	OFFSET ??_C@_05KBOMEDGA@total@
	push	edi
	mov	esi, edi
	mov	DWORD PTR _minute$1$[ebp], ebx
	mov	DWORD PTR _hour$1$[ebp], ebx
	mov	DWORD PTR _day$1$[ebp], ebx
	mov	DWORD PTR _size$1$[ebp], ebx
	mov	DWORD PTR _links$1$[ebp], ebx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN50@xmlNanoFTP

; 1599 :     const char *cur = list;
; 1600 :     char filename[151];
; 1601 :     char attrib[11];
; 1602 :     char owner[11];
; 1603 :     char group[11];
; 1604 :     char month[4];
; 1605 :     int year = 0;
; 1606 :     int minute = 0;
; 1607 :     int hour = 0;
; 1608 :     int day = 0;
; 1609 :     unsigned long size = 0;
; 1610 :     int links = 0;
; 1611 :     int i;
; 1612 : 
; 1613 :     if (!strncmp(cur, "total", 5)) {
; 1614 :         cur += 5;

	mov	cl, BYTE PTR [edi+5]
	lea	eax, DWORD PTR [edi+5]

; 1615 : 	while (*cur == ' ') cur++;

	cmp	cl, 32					; 00000020H
	jne	SHORT $LN87@xmlNanoFTP
	npad	4
$LL2@xmlNanoFTP:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, 32					; 00000020H
	je	SHORT $LL2@xmlNanoFTP
$LN87@xmlNanoFTP:

; 1616 : 	while ((*cur >= '0') && (*cur <= '9'))

	cmp	cl, 48					; 00000030H
	jl	SHORT $LL6@xmlNanoFTP
	npad	2
$LL4@xmlNanoFTP:
	cmp	cl, 57					; 00000039H
	jg	SHORT $LL6@xmlNanoFTP
	mov	cl, BYTE PTR [eax+1]

; 1617 : 	    links = (links * 10) + (*cur++ - '0');

	inc	eax
	cmp	cl, 48					; 00000030H
	jge	SHORT $LL4@xmlNanoFTP
	npad	2
$LL6@xmlNanoFTP:

; 1618 : 	while ((*cur == ' ') || (*cur == '\n')  || (*cur == '\r'))

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN52@xmlNanoFTP
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN52@xmlNanoFTP
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlNanoFTP
$LN52@xmlNanoFTP:

; 1619 : 	    cur++;

	inc	eax
	jmp	SHORT $LL6@xmlNanoFTP
$LN7@xmlNanoFTP:

; 1620 : 	return(cur - list);

	sub	eax, edi
	pop	edi

; 1710 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlNanoFTP:

; 1621 :     } else if (*list == '+') {

	mov	al, BYTE PTR [edi]
	cmp	al, 43					; 0000002bH
	je	$LN73@xmlNanoFTP
$LL8@xmlNanoFTP:

; 1622 : 	return(0);
; 1623 :     } else {
; 1624 : 	while ((*cur == ' ') || (*cur == '\n')  || (*cur == '\r'))

	cmp	al, 32					; 00000020H
	je	SHORT $LN55@xmlNanoFTP
	cmp	al, 10					; 0000000aH
	je	SHORT $LN55@xmlNanoFTP
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlNanoFTP
$LN55@xmlNanoFTP:

; 1625 : 	    cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL8@xmlNanoFTP
$LN9@xmlNanoFTP:

; 1626 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1627 : 	i = 0;

	xor	ecx, ecx
$LL10@xmlNanoFTP:

; 1629 : 	    if (i < 10)

	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN57@xmlNanoFTP

; 1630 : 		attrib[i++] = *cur;

	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _attrib$[ebp+ecx], al
	inc	ecx
$LN57@xmlNanoFTP:

; 1631 : 	    cur++;
; 1632 : 	    if (*cur == 0) return(0);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN73@xmlNanoFTP

; 1628 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	jne	SHORT $LL10@xmlNanoFTP

; 1633 : 	}
; 1634 : 	attrib[10] = 0;

	mov	BYTE PTR _attrib$[ebp+10], bl
$LL12@xmlNanoFTP:

; 1635 : 	while (*cur == ' ') cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL12@xmlNanoFTP

; 1636 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1637 : 	while ((*cur >= '0') && (*cur <= '9'))

	cmp	al, 48					; 00000030H
	jl	SHORT $LN93@xmlNanoFTP
	mov	dl, al
	xor	ecx, ecx
	npad	6
$LL14@xmlNanoFTP:
	mov	al, dl
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN402@xmlNanoFTP

; 1638 : 	    links = (links * 10) + (*cur++ - '0');

	movsx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	inc	esi
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [esi]
	mov	dl, al
	cmp	al, 48					; 00000030H
	jge	SHORT $LL14@xmlNanoFTP
$LN402@xmlNanoFTP:
	mov	DWORD PTR _links$1$[ebp], ecx
$LN93@xmlNanoFTP:

; 1639 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN17@xmlNanoFTP
$LL16@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL16@xmlNanoFTP
$LN17@xmlNanoFTP:

; 1640 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1641 : 	i = 0;

	xor	ecx, ecx

; 1642 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	je	SHORT $LN19@xmlNanoFTP
	mov	al, BYTE PTR [esi]
	npad	5
$LL18@xmlNanoFTP:

; 1643 : 	    if (i < 10)

	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN61@xmlNanoFTP

; 1644 : 		owner[i++] = *cur;

	mov	BYTE PTR _owner$[ebp+ecx], al
	inc	ecx
$LN61@xmlNanoFTP:

; 1645 : 	    cur++;
; 1646 : 	    if (*cur == 0) return(0);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN73@xmlNanoFTP

; 1642 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	jne	SHORT $LL18@xmlNanoFTP
$LN19@xmlNanoFTP:

; 1647 : 	}
; 1648 : 	owner[i] = 0;

	mov	BYTE PTR _owner$[ebp+ecx], bl

; 1649 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN21@xmlNanoFTP
$LL20@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL20@xmlNanoFTP
$LN21@xmlNanoFTP:

; 1650 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1651 : 	i = 0;

	xor	ecx, ecx

; 1652 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	je	SHORT $LN23@xmlNanoFTP
	mov	al, BYTE PTR [esi]
	npad	6
$LL22@xmlNanoFTP:

; 1653 : 	    if (i < 10)

	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN64@xmlNanoFTP

; 1654 : 		group[i++] = *cur;

	mov	BYTE PTR _group$[ebp+ecx], al
	inc	ecx
$LN64@xmlNanoFTP:

; 1655 : 	    cur++;
; 1656 : 	    if (*cur == 0) return(0);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN73@xmlNanoFTP

; 1652 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	jne	SHORT $LL22@xmlNanoFTP
$LN23@xmlNanoFTP:

; 1657 : 	}
; 1658 : 	group[i] = 0;

	mov	BYTE PTR _group$[ebp+ecx], bl

; 1659 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN25@xmlNanoFTP
$LL24@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL24@xmlNanoFTP
$LN25@xmlNanoFTP:

; 1660 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1661 : 	while ((*cur >= '0') && (*cur <= '9'))

	cmp	al, 48					; 00000030H
	jl	SHORT $LN99@xmlNanoFTP
	mov	dl, al
	xor	ecx, ecx
	npad	6
$LL26@xmlNanoFTP:
	mov	al, dl
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN403@xmlNanoFTP

; 1662 : 	    size = (size * 10) + (*cur++ - '0');

	movsx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	inc	esi
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [esi]
	mov	dl, al
	cmp	al, 48					; 00000030H
	jge	SHORT $LL26@xmlNanoFTP
$LN403@xmlNanoFTP:
	mov	DWORD PTR _size$1$[ebp], ecx
$LN99@xmlNanoFTP:

; 1663 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN29@xmlNanoFTP
$LL28@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL28@xmlNanoFTP
$LN29@xmlNanoFTP:

; 1664 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1665 : 	i = 0;

	xor	ecx, ecx

; 1666 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	je	SHORT $LN31@xmlNanoFTP
	mov	al, BYTE PTR [esi]
	npad	5
$LL30@xmlNanoFTP:

; 1667 : 	    if (i < 3)

	cmp	ecx, 3
	jge	SHORT $LN68@xmlNanoFTP

; 1668 : 		month[i++] = *cur;

	mov	BYTE PTR _month$[ebp+ecx], al
	inc	ecx
$LN68@xmlNanoFTP:

; 1669 : 	    cur++;
; 1670 : 	    if (*cur == 0) return(0);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	$LN73@xmlNanoFTP

; 1666 : 	while (*cur != ' ') {

	cmp	al, 32					; 00000020H
	jne	SHORT $LL30@xmlNanoFTP
$LN31@xmlNanoFTP:

; 1671 : 	}
; 1672 : 	month[i] = 0;

	mov	BYTE PTR _month$[ebp+ecx], bl

; 1673 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN33@xmlNanoFTP
$LL32@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL32@xmlNanoFTP
$LN33@xmlNanoFTP:

; 1674 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1675 :         while ((*cur >= '0') && (*cur <= '9'))

	cmp	al, 48					; 00000030H
	jl	SHORT $LN103@xmlNanoFTP
	mov	dl, al
	xor	ecx, ecx
	npad	6
$LL34@xmlNanoFTP:
	mov	al, dl
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN404@xmlNanoFTP

; 1676 : 	    day = (day * 10) + (*cur++ - '0');

	movsx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	inc	esi
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [esi]
	mov	dl, al
	cmp	al, 48					; 00000030H
	jge	SHORT $LL34@xmlNanoFTP
$LN404@xmlNanoFTP:
	mov	DWORD PTR _day$1$[ebp], ecx
$LN103@xmlNanoFTP:

; 1677 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN37@xmlNanoFTP
$LL36@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL36@xmlNanoFTP
$LN37@xmlNanoFTP:

; 1678 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1679 : 	if ((cur[1] == 0) || (cur[2] == 0)) return(0);

	mov	cl, BYTE PTR [esi+1]
	test	cl, cl
	je	$LN73@xmlNanoFTP
	mov	dl, BYTE PTR [esi+2]
	test	dl, dl
	je	$LN73@xmlNanoFTP

; 1680 : 	if ((cur[1] == ':') || (cur[2] == ':')) {

	cmp	cl, 58					; 0000003aH
	je	SHORT $LN105@xmlNanoFTP
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN105@xmlNanoFTP

; 1686 : 	} else {
; 1687 : 	    while ((*cur >= '0') && (*cur <= '9'))

	cmp	al, 48					; 00000030H
	jl	$LN41@xmlNanoFTP
	npad	5
$LL42@xmlNanoFTP:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN41@xmlNanoFTP

; 1688 : 		year = (year * 10) + (*cur++ - '0');

	movsx	eax, al
	lea	ebx, DWORD PTR [ebx+ebx*4]
	inc	esi
	lea	ebx, DWORD PTR [ebx-24]
	lea	ebx, DWORD PTR [eax+ebx*2]
	mov	al, BYTE PTR [esi]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL42@xmlNanoFTP

; 1696 : 	    cur++;
; 1697 : 	    if (*cur == 0) return(0);

	jmp	SHORT $LN41@xmlNanoFTP
$LN105@xmlNanoFTP:

; 1681 : 	    while ((*cur >= '0') && (*cur <= '9'))

	mov	cl, al
	cmp	al, 48					; 00000030H
	jl	SHORT $LN39@xmlNanoFTP
	xor	edx, edx
$LL38@xmlNanoFTP:
	mov	cl, al
	cmp	al, 57					; 00000039H
	jg	SHORT $LN405@xmlNanoFTP

; 1682 : 		hour = (hour * 10) + (*cur++ - '0');

	inc	esi
	movsx	eax, al
	lea	ecx, DWORD PTR [edx+edx*4]
	lea	edx, DWORD PTR [ecx-24]
	mov	cl, BYTE PTR [esi]
	lea	edx, DWORD PTR [eax+edx*2]
	mov	al, cl
	cmp	cl, 48					; 00000030H
	jge	SHORT $LL38@xmlNanoFTP
$LN405@xmlNanoFTP:
	mov	DWORD PTR _hour$1$[ebp], edx
$LN39@xmlNanoFTP:

; 1683 : 	    if (*cur == ':') cur++;

	mov	edx, esi
	mov	al, cl
	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN106@xmlNanoFTP
	mov	al, BYTE PTR [esi+1]
$LN106@xmlNanoFTP:

; 1684 : 	    while ((*cur >= '0') && (*cur <= '9'))

	inc	esi
	cmp	cl, 58					; 0000003aH
	cmovne	esi, edx
	cmp	al, 48					; 00000030H
	jl	SHORT $LN41@xmlNanoFTP
	mov	dl, al
	xor	ecx, ecx
	npad	5
$LL40@xmlNanoFTP:
	mov	al, dl
	cmp	dl, 57					; 00000039H
	jg	SHORT $LN406@xmlNanoFTP

; 1685 : 		minute = (minute * 10) + (*cur++ - '0');

	movsx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	inc	esi
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	al, BYTE PTR [esi]
	mov	dl, al
	cmp	al, 48					; 00000030H
	jge	SHORT $LL40@xmlNanoFTP
$LN406@xmlNanoFTP:
	mov	DWORD PTR _minute$1$[ebp], ecx
$LN41@xmlNanoFTP:

; 1689 : 	}
; 1690 : 	while (*cur == ' ') cur++;

	cmp	al, 32					; 00000020H
	jne	SHORT $LN45@xmlNanoFTP
$LL44@xmlNanoFTP:
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 32					; 00000020H
	je	SHORT $LL44@xmlNanoFTP
$LN45@xmlNanoFTP:

; 1691 : 	if (*cur == 0) return(0);

	test	al, al
	je	$LN73@xmlNanoFTP

; 1692 : 	i = 0;

	xor	ecx, ecx

; 1693 : 	while ((*cur != '\n')  && (*cur != '\r')) {

	cmp	al, 10					; 0000000aH
	je	SHORT $LN47@xmlNanoFTP
	npad	7
$LL46@xmlNanoFTP:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN47@xmlNanoFTP

; 1694 : 	    if (i < 150)

	cmp	ecx, 150				; 00000096H
	jge	SHORT $LN221@xmlNanoFTP

; 1695 : 		filename[i++] = *cur;

	mov	BYTE PTR _filename$[ebp+ecx], al
	inc	ecx
$LN221@xmlNanoFTP:

; 1696 : 	    cur++;
; 1697 : 	    if (*cur == 0) return(0);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	je	SHORT $LN73@xmlNanoFTP

; 1693 : 	while ((*cur != '\n')  && (*cur != '\r')) {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LL46@xmlNanoFTP
$LN47@xmlNanoFTP:

; 1698 : 	}
; 1699 : 	filename[i] = 0;

	mov	BYTE PTR _filename$[ebp+ecx], 0

; 1700 : 	if ((*cur != '\n') && (*cur != '\r'))

	cmp	al, 10					; 0000000aH
	je	SHORT $LN222@xmlNanoFTP
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN73@xmlNanoFTP
$LL48@xmlNanoFTP:

; 1701 : 	    return(0);
; 1702 : 	while ((*cur == '\n')  || (*cur == '\r'))

	cmp	al, 10					; 0000000aH
	je	SHORT $LN222@xmlNanoFTP
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN49@xmlNanoFTP
$LN222@xmlNanoFTP:

; 1703 : 	    cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	jmp	SHORT $LL48@xmlNanoFTP
$LN49@xmlNanoFTP:

; 1704 :     }
; 1705 :     if (callback != NULL) {

	mov	eax, DWORD PTR _callback$[ebp]
	test	eax, eax
	je	SHORT $LN83@xmlNanoFTP

; 1706 :         callback(userData, filename, attrib, owner, group, size, links,

	push	DWORD PTR _minute$1$[ebp]
	lea	ecx, DWORD PTR _month$[ebp]
	push	DWORD PTR _hour$1$[ebp]
	push	DWORD PTR _day$1$[ebp]
	push	ecx
	push	ebx
	push	DWORD PTR _links$1$[ebp]
	lea	ecx, DWORD PTR _group$[ebp]
	push	DWORD PTR _size$1$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _owner$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _attrib$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	DWORD PTR _userData$[ebp]
	call	eax
	add	esp, 48					; 00000030H
$LN83@xmlNanoFTP:

; 1707 : 		 year, month, day, hour, minute);
; 1708 :     }
; 1709 :     return(cur - list);

	sub	esi, edi
	pop	edi
	mov	eax, esi

; 1710 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlNanoFTP:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPParseList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPSendPasswd
_TEXT	SEGMENT
_buf$ = -200						; size = 200
_ctx$ = 8						; size = 4
_xmlNanoFTPSendPasswd PROC				; COMDAT

; 785  : xmlNanoFTPSendPasswd(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN2@xmlNanoFTP

; 786  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 787  :     char buf[200];
; 788  :     int len;
; 789  :     int res;
; 790  : 
; 791  :     if (ctxt->passwd == NULL)
; 792  : 	snprintf(buf, sizeof(buf), "PASS anonymous@\r\n");

	push	OFFSET ??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@xmlNanoFTP
$LN2@xmlNanoFTP:

; 793  :     else
; 794  : 	snprintf(buf, sizeof(buf), "PASS %s\r\n", ctxt->passwd);

	push	eax
	push	OFFSET ??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN3@xmlNanoFTP:

; 795  :     buf[sizeof(buf) - 1] = 0;
; 796  :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+199], 0
	lea	edx, DWORD PTR [ecx+1]
$LL6@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL6@xmlNanoFTP

; 797  : #ifdef DEBUG_FTP
; 798  :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 799  : #endif
; 800  :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16
	mov	esi, eax

; 801  :     if (res < 0) {

	test	esi, esi
	jns	SHORT $LN4@xmlNanoFTP

; 802  : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 803  : 	return(res);

	mov	eax, esi
	pop	esi

; 806  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoFTP:

; 804  :     }
; 805  :     return(0);

	xor	eax, eax
	pop	esi

; 806  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPSendPasswd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPSendUser
_TEXT	SEGMENT
_buf$ = -200						; size = 200
_ctx$ = 8						; size = 4
_xmlNanoFTPSendUser PROC				; COMDAT

; 757  : xmlNanoFTPSendUser(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jne	SHORT $LN2@xmlNanoFTP

; 758  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 759  :     char buf[200];
; 760  :     int len;
; 761  :     int res;
; 762  : 
; 763  :     if (ctxt->user == NULL)
; 764  : 	snprintf(buf, sizeof(buf), "USER anonymous\r\n");

	push	OFFSET ??_C@_0BB@PKBEHKHF@USER?5anonymous?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@xmlNanoFTP
$LN2@xmlNanoFTP:

; 765  :     else
; 766  : 	snprintf(buf, sizeof(buf), "USER %s\r\n", ctxt->user);

	push	eax
	push	OFFSET ??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN3@xmlNanoFTP:

; 767  :     buf[sizeof(buf) - 1] = 0;
; 768  :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+199], 0
	lea	edx, DWORD PTR [ecx+1]
$LL6@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL6@xmlNanoFTP

; 769  : #ifdef DEBUG_FTP
; 770  :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 771  : #endif
; 772  :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16
	mov	esi, eax

; 773  :     if (res < 0) {

	test	esi, esi
	jns	SHORT $LN4@xmlNanoFTP

; 774  : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 775  : 	return(res);

	mov	eax, esi
	pop	esi

; 778  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoFTP:

; 776  :     }
; 777  :     return(0);

	xor	eax, eax
	pop	esi

; 778  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPSendUser ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPReadResponse
_TEXT	SEGMENT
_res$1$ = -8						; size = 4
$T1 = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoFTPReadResponse PROC				; COMDAT

; 640  : xmlNanoFTPReadResponse(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _res$1$[ebp], -1
	test	ebx, ebx
	je	$LN9@xmlNanoFTP

; 641  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 642  :     char *ptr, *end;
; 643  :     int len;
; 644  :     int res = -1, cur = -1;
; 645  : 
; 646  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [ebx+44], -1
	je	$LN9@xmlNanoFTP
	npad	1
$get_more$71:

; 565  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [ebx+44], -1
	je	$LN9@xmlNanoFTP

; 566  : 
; 567  :     if ((ctxt->controlBufIndex < 0) || (ctxt->controlBufIndex > FTP_BUF_SIZE)) {

	mov	ecx, DWORD PTR [ebx+1088]
	cmp	ecx, 1024				; 00000400H
	ja	$LN9@xmlNanoFTP

; 568  : #ifdef DEBUG_FTP
; 569  :         xmlGenericError(xmlGenericErrorContext,
; 570  : 		"xmlNanoFTPGetMore : controlBufIndex = %d\n",
; 571  : 		ctxt->controlBufIndex);
; 572  : #endif
; 573  : 	return(-1);
; 574  :     }
; 575  : 
; 576  :     if ((ctxt->controlBufUsed < 0) || (ctxt->controlBufUsed > FTP_BUF_SIZE)) {

	mov	eax, DWORD PTR [ebx+1092]
	cmp	eax, 1024				; 00000400H
	ja	$LN9@xmlNanoFTP

; 577  : #ifdef DEBUG_FTP
; 578  :         xmlGenericError(xmlGenericErrorContext,
; 579  : 		"xmlNanoFTPGetMore : controlBufUsed = %d\n",
; 580  : 		ctxt->controlBufUsed);
; 581  : #endif
; 582  : 	return(-1);
; 583  :     }
; 584  :     if (ctxt->controlBufIndex > ctxt->controlBufUsed) {

	cmp	ecx, eax
	jg	$LN9@xmlNanoFTP

; 585  : #ifdef DEBUG_FTP
; 586  :         xmlGenericError(xmlGenericErrorContext,
; 587  : 		"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\n",
; 588  : 	       ctxt->controlBufIndex, ctxt->controlBufUsed);
; 589  : #endif
; 590  : 	return(-1);
; 591  :     }
; 592  : 
; 593  :     /*
; 594  :      * First pack the control buffer
; 595  :      */
; 596  :     if (ctxt->controlBufIndex > 0) {

	lea	esi, DWORD PTR [ebx+60]
	test	ecx, ecx
	jle	SHORT $LN67@xmlNanoFTP

; 597  : 	memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],

	sub	eax, ecx
	push	eax
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	esi
	call	_memmove

; 598  : 		ctxt->controlBufUsed - ctxt->controlBufIndex);
; 599  : 	ctxt->controlBufUsed -= ctxt->controlBufIndex;

	mov	eax, DWORD PTR [ebx+1088]
	add	esp, 12					; 0000000cH
	sub	DWORD PTR [ebx+1092], eax

; 600  : 	ctxt->controlBufIndex = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+1092]
	mov	edi, eax
	mov	DWORD PTR [ebx+1088], 0
	mov	DWORD PTR $T1[ebp], edi
	jmp	SHORT $LN27@xmlNanoFTP
$LN67@xmlNanoFTP:
	mov	edi, eax
	mov	DWORD PTR $T1[ebp], eax
$LN27@xmlNanoFTP:

; 601  :     }
; 602  :     size = FTP_BUF_SIZE - ctxt->controlBufUsed;

	mov	edx, 1024				; 00000400H
	sub	edx, eax

; 603  :     if (size == 0) {

	jne	SHORT $LN28@xmlNanoFTP

; 604  : #ifdef DEBUG_FTP
; 605  :         xmlGenericError(xmlGenericErrorContext,
; 606  : 		"xmlNanoFTPGetMore : buffer full %d \n", ctxt->controlBufUsed);
; 607  : #endif
; 608  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN19@xmlNanoFTP
$LN28@xmlNanoFTP:

; 609  :     }
; 610  : 
; 611  :     /*
; 612  :      * Read the amount left on the control connection
; 613  :      */
; 614  :     if ((len = recv(ctxt->controlFd, &ctxt->controlBuf[ctxt->controlBufIndex],
; 615  : 		    size, 0)) < 0) {

	push	0
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	DWORD PTR [ebx+44]
	call	DWORD PTR __imp__recv@16
	test	eax, eax
	js	$LN64@xmlNanoFTP

; 619  :         return(-1);
; 620  :     }
; 621  : #ifdef DEBUG_FTP
; 622  :     xmlGenericError(xmlGenericErrorContext,
; 623  : 	    "xmlNanoFTPGetMore : read %d [%d - %d]\n", len,
; 624  : 	   ctxt->controlBufUsed, ctxt->controlBufUsed + len);
; 625  : #endif
; 626  :     ctxt->controlBufUsed += len;

	add	DWORD PTR [ebx+1092], eax
	mov	ecx, DWORD PTR [ebx+1092]

; 627  :     ctxt->controlBuf[ctxt->controlBufUsed] = 0;

	mov	BYTE PTR [ecx+esi], 0

; 628  : 
; 629  :     return(len);

	mov	edi, DWORD PTR [ebx+1092]
	mov	DWORD PTR $T1[ebp], edi
$LN19@xmlNanoFTP:

; 647  : 
; 648  : get_more:
; 649  :     /*
; 650  :      * Assumes everything up to controlBuf[controlBufIndex] has been read
; 651  :      * and analyzed.
; 652  :      */
; 653  :     len = xmlNanoFTPGetMore(ctx);
; 654  :     if (len < 0) {
; 655  :         return(-1);
; 656  :     }
; 657  :     if ((ctxt->controlBufUsed == 0) && (len == 0)) {

	test	edi, edi
	jne	SHORT $LN11@xmlNanoFTP
	test	eax, eax
	je	$LN9@xmlNanoFTP
$LN11@xmlNanoFTP:

; 658  :         return(-1);
; 659  :     }
; 660  :     ptr = &ctxt->controlBuf[ctxt->controlBufIndex];

	mov	eax, DWORD PTR [ebx+1088]

; 661  :     end = &ctxt->controlBuf[ctxt->controlBufUsed];

	add	esi, edi
	add	eax, 60					; 0000003cH
	add	eax, ebx

; 662  : 
; 663  : #ifdef DEBUG_FTP
; 664  :     xmlGenericError(xmlGenericErrorContext,
; 665  : 	    "\n<<<\n%s\n--\n", ptr);
; 666  : #endif
; 667  :     while (ptr < end) {

	cmp	eax, esi
	jae	$LN3@xmlNanoFTP
$LL2@xmlNanoFTP:

; 668  :         cur = xmlNanoFTPParseResponse(ptr, end - ptr);

	mov	ecx, esi
	sub	ecx, eax

; 531  :     if (len < 3) return(-1);

	cmp	ecx, 3
	jl	SHORT $LN62@xmlNanoFTP

; 532  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN62@xmlNanoFTP

; 533  :         val = val * 10 + (*buf - '0');
; 534  :     else
; 535  :         return(0);
; 536  :     buf++;
; 537  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	ch, BYTE PTR [eax+1]
	mov	cl, ch
	movsx	edx, dl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN62@xmlNanoFTP

; 538  :         val = val * 10 + (*buf - '0');
; 539  :     else
; 540  :         return(0);
; 541  :     buf++;
; 542  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	bl, BYTE PTR [eax+2]
	mov	cl, bl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN62@xmlNanoFTP

; 543  :         val = val * 10 + (*buf - '0');

	movsx	ecx, ch
	lea	edx, DWORD PTR [edx+edx*4]
	lea	ecx, DWORD PTR [ecx+edx*2]
	lea	edx, DWORD PTR [ecx+ecx*4]
	movsx	ecx, bl
	lea	ecx, DWORD PTR [ecx+edx*2]
	add	ecx, -5328				; ffffeb30H

; 544  :     else
; 545  :         return(0);
; 546  :     buf++;
; 547  :     if (*buf == '-')

	cmp	BYTE PTR [eax+3], 45			; 0000002dH
	jne	SHORT $LN39@xmlNanoFTP

; 548  :         return(-val);

	neg	ecx
$LN39@xmlNanoFTP:

; 669  : 	if (cur > 0) {

	test	ecx, ecx
	jg	SHORT $LN46@xmlNanoFTP
$LN62@xmlNanoFTP:

; 682  : 	}
; 683  : 	while ((ptr < end) && (*ptr != '\n')) ptr++;

	cmp	eax, esi
	jae	SHORT $LN47@xmlNanoFTP
	npad	1
$LL6@xmlNanoFTP:
	mov	dl, BYTE PTR [eax]
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN7@xmlNanoFTP
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL6@xmlNanoFTP
$LN47@xmlNanoFTP:

; 685  : 	    ctxt->controlBufIndex = ctxt->controlBufUsed;

	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ebx+1088], eax

; 686  : 	    goto get_more;

	jmp	$get_more$71
$LN7@xmlNanoFTP:

; 684  : 	if (ptr >= end) {

	cmp	eax, esi
	jae	SHORT $LN47@xmlNanoFTP

; 662  : 
; 663  : #ifdef DEBUG_FTP
; 664  :     xmlGenericError(xmlGenericErrorContext,
; 665  : 	    "\n<<<\n%s\n--\n", ptr);
; 666  : #endif
; 667  :     while (ptr < end) {

	cmp	dl, 13					; 0000000dH
	lea	ecx, DWORD PTR [eax+1]
	cmove	ecx, eax
	mov	eax, ecx
	cmp	eax, esi
	jb	$LL2@xmlNanoFTP

; 647  : 
; 648  : get_more:
; 649  :     /*
; 650  :      * Assumes everything up to controlBuf[controlBufIndex] has been read
; 651  :      * and analyzed.
; 652  :      */
; 653  :     len = xmlNanoFTPGetMore(ctx);
; 654  :     if (len < 0) {
; 655  :         return(-1);
; 656  :     }
; 657  :     if ((ctxt->controlBufUsed == 0) && (len == 0)) {

	mov	ebx, DWORD PTR _ctx$[ebp]
$LN3@xmlNanoFTP:

; 687  : 	}
; 688  : 	if (*ptr != '\r') ptr++;
; 689  :     }
; 690  : 
; 691  :     if (res < 0) goto get_more;

	mov	ecx, DWORD PTR _res$1$[ebp]
	test	ecx, ecx
	js	$get_more$71

; 692  :     ctxt->controlBufIndex = ptr - ctxt->controlBuf;

	sub	eax, ebx
	sub	eax, 60					; 0000003cH
	mov	DWORD PTR [ebx+1088], eax

; 693  : #ifdef DEBUG_FTP
; 694  :     ptr = &ctxt->controlBuf[ctxt->controlBufIndex];
; 695  :     xmlGenericError(xmlGenericErrorContext, "\n---\n%s\n--\n", ptr);
; 696  : #endif
; 697  : 
; 698  : #ifdef DEBUG_FTP
; 699  :     xmlGenericError(xmlGenericErrorContext, "Got %d\n", res);
; 700  : #endif
; 701  :     return(res / 100);

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH

; 702  : }

	pop	esi
	add	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlNanoFTP:

; 670  : 	    /*
; 671  : 	     * Successfully scanned the control code, scratch
; 672  : 	     * till the end of the line, but keep the index to be
; 673  : 	     * able to analyze the result if needed.
; 674  : 	     */
; 675  : 	    res = cur;
; 676  : 	    ptr += 3;
; 677  : 	    ctxt->controlBufAnswer = ptr - ctxt->controlBuf;

	mov	ebx, DWORD PTR _ctx$[ebp]
	add	eax, 3
	mov	DWORD PTR _res$1$[ebp], ecx
	mov	ecx, eax
	sub	ecx, ebx
	sub	ecx, 60					; 0000003cH
	mov	DWORD PTR [ebx+1096], ecx

; 678  : 	    while ((ptr < end) && (*ptr != '\n')) ptr++;

	cmp	eax, esi
	jae	SHORT $LN69@xmlNanoFTP
	npad	1
$LL4@xmlNanoFTP:
	cmp	BYTE PTR [eax], 10			; 0000000aH
	je	SHORT $LN69@xmlNanoFTP
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL4@xmlNanoFTP
$LN69@xmlNanoFTP:

; 679  : 	    if (*ptr == '\n') ptr++;

	mov	dl, BYTE PTR [eax]
	mov	dh, dl
	cmp	dl, 10					; 0000000aH
	jne	SHORT $LN13@xmlNanoFTP
	mov	dh, BYTE PTR [eax+1]
$LN13@xmlNanoFTP:

; 680  : 	    if (*ptr == '\r') ptr++;
; 681  : 	    break;

	lea	ecx, DWORD PTR [eax+1]
	cmp	dl, 10					; 0000000aH
	cmovne	ecx, eax
	cmp	dh, 13					; 0000000dH
	lea	eax, DWORD PTR [ecx+1]
	cmovne	eax, ecx
	jmp	SHORT $LN3@xmlNanoFTP
$LN64@xmlNanoFTP:

; 616  : 	__xmlIOErr(XML_FROM_FTP, 0, "recv failed");

	push	OFFSET ??_C@_0M@KMFGCEDE@recv?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 617  : 	closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [ebx+44]
	call	DWORD PTR __imp__closesocket@4

; 618  :         ctxt->controlFd = INVALID_SOCKET;

	mov	DWORD PTR [ebx+44], -1
$LN9@xmlNanoFTP:
	pop	edi

; 702  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPReadResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPGetMore
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoFTPGetMore PROC					; COMDAT

; 560  : xmlNanoFTPGetMore(void *ctx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN3@xmlNanoFTP

; 561  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 562  :     int len;
; 563  :     int size;
; 564  : 
; 565  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [esi+44], -1
	je	$LN3@xmlNanoFTP

; 566  : 
; 567  :     if ((ctxt->controlBufIndex < 0) || (ctxt->controlBufIndex > FTP_BUF_SIZE)) {

	mov	eax, DWORD PTR [esi+1088]
	cmp	eax, 1024				; 00000400H
	ja	$LN3@xmlNanoFTP

; 568  : #ifdef DEBUG_FTP
; 569  :         xmlGenericError(xmlGenericErrorContext,
; 570  : 		"xmlNanoFTPGetMore : controlBufIndex = %d\n",
; 571  : 		ctxt->controlBufIndex);
; 572  : #endif
; 573  : 	return(-1);
; 574  :     }
; 575  : 
; 576  :     if ((ctxt->controlBufUsed < 0) || (ctxt->controlBufUsed > FTP_BUF_SIZE)) {

	mov	ecx, DWORD PTR [esi+1092]
	cmp	ecx, 1024				; 00000400H
	ja	$LN3@xmlNanoFTP

; 577  : #ifdef DEBUG_FTP
; 578  :         xmlGenericError(xmlGenericErrorContext,
; 579  : 		"xmlNanoFTPGetMore : controlBufUsed = %d\n",
; 580  : 		ctxt->controlBufUsed);
; 581  : #endif
; 582  : 	return(-1);
; 583  :     }
; 584  :     if (ctxt->controlBufIndex > ctxt->controlBufUsed) {

	cmp	eax, ecx
	jg	SHORT $LN3@xmlNanoFTP

; 585  : #ifdef DEBUG_FTP
; 586  :         xmlGenericError(xmlGenericErrorContext,
; 587  : 		"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\n",
; 588  : 	       ctxt->controlBufIndex, ctxt->controlBufUsed);
; 589  : #endif
; 590  : 	return(-1);
; 591  :     }
; 592  : 
; 593  :     /*
; 594  :      * First pack the control buffer
; 595  :      */
; 596  :     if (ctxt->controlBufIndex > 0) {

	test	eax, eax
	jle	SHORT $LN9@xmlNanoFTP

; 597  : 	memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],

	sub	ecx, eax
	add	eax, 60					; 0000003cH
	push	ecx
	add	eax, esi
	push	eax
	lea	eax, DWORD PTR [esi+60]
	push	eax
	call	_memmove

; 598  : 		ctxt->controlBufUsed - ctxt->controlBufIndex);
; 599  : 	ctxt->controlBufUsed -= ctxt->controlBufIndex;

	mov	eax, DWORD PTR [esi+1088]
	add	esp, 12					; 0000000cH
	sub	DWORD PTR [esi+1092], eax

; 600  : 	ctxt->controlBufIndex = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR [esi+1092]
	mov	DWORD PTR [esi+1088], 0
$LN9@xmlNanoFTP:

; 601  :     }
; 602  :     size = FTP_BUF_SIZE - ctxt->controlBufUsed;

	mov	edx, 1024				; 00000400H
	sub	edx, ecx

; 603  :     if (size == 0) {

	jne	SHORT $LN10@xmlNanoFTP

; 604  : #ifdef DEBUG_FTP
; 605  :         xmlGenericError(xmlGenericErrorContext,
; 606  : 		"xmlNanoFTPGetMore : buffer full %d \n", ctxt->controlBufUsed);
; 607  : #endif
; 608  : 	return(0);

	xor	eax, eax
	pop	esi

; 630  : }

	pop	ebp
	ret	0
$LN10@xmlNanoFTP:

; 609  :     }
; 610  : 
; 611  :     /*
; 612  :      * Read the amount left on the control connection
; 613  :      */
; 614  :     if ((len = recv(ctxt->controlFd, &ctxt->controlBuf[ctxt->controlBufIndex],
; 615  : 		    size, 0)) < 0) {

	push	0
	add	eax, 60					; 0000003cH
	push	edx
	add	eax, esi
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__recv@16
	mov	ecx, eax
	test	ecx, ecx
	jns	SHORT $LN11@xmlNanoFTP

; 616  : 	__xmlIOErr(XML_FROM_FTP, 0, "recv failed");

	push	OFFSET ??_C@_0M@KMFGCEDE@recv?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 617  : 	closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__closesocket@4

; 618  :         ctxt->controlFd = INVALID_SOCKET;

	mov	DWORD PTR [esi+44], -1
$LN3@xmlNanoFTP:

; 630  : }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN11@xmlNanoFTP:

; 619  :         return(-1);
; 620  :     }
; 621  : #ifdef DEBUG_FTP
; 622  :     xmlGenericError(xmlGenericErrorContext,
; 623  : 	    "xmlNanoFTPGetMore : read %d [%d - %d]\n", len,
; 624  : 	   ctxt->controlBufUsed, ctxt->controlBufUsed + len);
; 625  : #endif
; 626  :     ctxt->controlBufUsed += len;

	add	DWORD PTR [esi+1092], ecx
	mov	eax, DWORD PTR [esi+1092]

; 627  :     ctxt->controlBuf[ctxt->controlBufUsed] = 0;

	mov	BYTE PTR [eax+esi+60], 0

; 628  : 
; 629  :     return(len);

	mov	eax, ecx
	pop	esi

; 630  : }

	pop	ebp
	ret	0
_xmlNanoFTPGetMore ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPParseResponse
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlNanoFTPParseResponse PROC				; COMDAT

; 528  : xmlNanoFTPParseResponse(char *buf, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _len$[ebp], 3
	jge	SHORT $LN2@xmlNanoFTP

; 529  :     int val = 0;
; 530  : 
; 531  :     if (len < 3) return(-1);

	or	eax, -1

; 549  :     return(val);
; 550  : }

	pop	ebp
	ret	0
$LN2@xmlNanoFTP:

; 532  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	edx, DWORD PTR _buf$[ebp]
	push	ebx
	mov	cl, BYTE PTR [edx]
	mov	al, cl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN3@xmlNanoFTP

; 536  :     buf++;
; 537  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	ah, BYTE PTR [edx+1]
	mov	al, ah
	movsx	ecx, cl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN3@xmlNanoFTP

; 538  :         val = val * 10 + (*buf - '0');
; 539  :     else
; 540  :         return(0);
; 541  :     buf++;
; 542  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	bl, BYTE PTR [edx+2]
	mov	al, bl
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN3@xmlNanoFTP

; 543  :         val = val * 10 + (*buf - '0');

	movsx	eax, ah
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movsx	eax, bl
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -5328				; ffffeb30H

; 544  :     else
; 545  :         return(0);
; 546  :     buf++;
; 547  :     if (*buf == '-')

	cmp	BYTE PTR [edx+3], 45			; 0000002dH
	jne	SHORT $LN11@xmlNanoFTP

; 548  :         return(-val);

	neg	eax
	pop	ebx

; 549  :     return(val);
; 550  : }

	pop	ebp
	ret	0
$LN3@xmlNanoFTP:

; 533  :         val = val * 10 + (*buf - '0');
; 534  :     else
; 535  :         return(0);

	xor	eax, eax
$LN11@xmlNanoFTP:
	pop	ebx

; 549  :     return(val);
; 550  : }

	pop	ebp
	ret	0
_xmlNanoFTPParseResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPScanURL
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlNanoFTPScanURL PROC					; COMDAT

; 293  : xmlNanoFTPScanURL(void *ctx, const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xmlNanoFTP

; 294  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 295  :     xmlURIPtr uri;
; 296  : 
; 297  :     /*
; 298  :      * Clear any existing data from the context
; 299  :      */
; 300  :     if (ctxt->protocol != NULL) {
; 301  :         xmlFree(ctxt->protocol);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 302  : 	ctxt->protocol = NULL;

	mov	DWORD PTR [esi], 0
$LN2@xmlNanoFTP:

; 303  :     }
; 304  :     if (ctxt->hostname != NULL) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlNanoFTP

; 305  :         xmlFree(ctxt->hostname);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 306  : 	ctxt->hostname = NULL;

	mov	DWORD PTR [esi+4], 0
$LN3@xmlNanoFTP:

; 307  :     }
; 308  :     if (ctxt->path != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlNanoFTP

; 309  :         xmlFree(ctxt->path);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 310  : 	ctxt->path = NULL;

	mov	DWORD PTR [esi+12], 0
$LN4@xmlNanoFTP:

; 311  :     }
; 312  :     if (URL == NULL) return;

	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	$LN1@xmlNanoFTP

; 313  : 
; 314  :     uri = xmlParseURIRaw(URL, 1);

	push	edi
	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	edi, eax
	add	esp, 8

; 315  :     if (uri == NULL)

	test	edi, edi
	je	$LN16@xmlNanoFTP

; 316  : 	return;
; 317  : 
; 318  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN8@xmlNanoFTP
	cmp	DWORD PTR [edi+12], 0
	je	$LN8@xmlNanoFTP

; 320  : 	return;
; 321  :     }
; 322  : 
; 323  :     ctxt->protocol = xmlMemStrdup(uri->scheme);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi], eax

; 324  :     ctxt->hostname = xmlMemStrdup(uri->server);

	push	DWORD PTR [edi+12]
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi+4], eax
	add	esp, 8

; 325  :     if (uri->path != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN9@xmlNanoFTP

; 326  : 	ctxt->path = xmlMemStrdup(uri->path);

	push	eax
	jmp	SHORT $LN18@xmlNanoFTP
$LN9@xmlNanoFTP:

; 327  :     else
; 328  : 	ctxt->path = xmlMemStrdup("/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
$LN18@xmlNanoFTP:

; 329  :     if (uri->port != 0)

	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [esi+12], eax
	add	esp, 4
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN11@xmlNanoFTP

; 330  : 	ctxt->port = uri->port;

	mov	DWORD PTR [esi+8], eax
$LN11@xmlNanoFTP:

; 331  : 
; 332  :     if (uri->user != NULL) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN8@xmlNanoFTP

; 333  : 	char *cptr;
; 334  : 	if ((cptr=strchr(uri->user, ':')) == NULL)

	push	ebx
	push	58					; 0000003aH
	push	eax
	call	_strchr
	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN13@xmlNanoFTP

; 335  : 	    ctxt->user = xmlMemStrdup(uri->user);

	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	push	edi
	call	_xmlFreeURI
	add	esp, 4
	pop	edi
	pop	esi

; 340  : 	}
; 341  :     }
; 342  : 
; 343  :     xmlFreeURI(uri);
; 344  : 
; 345  : }

	pop	ebp
	ret	0
$LN13@xmlNanoFTP:

; 336  : 	else {
; 337  : 	    ctxt->user = (char *)xmlStrndup((xmlChar *)uri->user,

	mov	eax, ebx
	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	mov	DWORD PTR [esi+16], eax

; 338  : 			    (cptr - uri->user));
; 339  : 	    ctxt->passwd = xmlMemStrdup(cptr+1);

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], eax
	pop	ebx
$LN8@xmlNanoFTP:

; 319  : 	xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN16@xmlNanoFTP:
	pop	edi
$LN1@xmlNanoFTP:
	pop	esi

; 340  : 	}
; 341  :     }
; 342  : 
; 343  :     xmlFreeURI(uri);
; 344  : 
; 345  : }

	pop	ebp
	ret	0
_xmlNanoFTPScanURL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlFTPErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlFTPErrMemory PROC					; COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	9
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 168  :     __xmlSimpleError(XML_FROM_FTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 169  : }

	pop	ebp
	ret	0
_xmlFTPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPRead
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_dest$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlNanoFTPRead PROC					; COMDAT

; 1969 : xmlNanoFTPRead(void *ctx, void *dest, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN10@xmlNanoFTP

; 1970 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1971 : 
; 1972 :     if (ctx == NULL) return(-1);
; 1973 :     if (ctxt->dataFd == INVALID_SOCKET) return(0);

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, -1
	je	SHORT $LN9@xmlNanoFTP

; 1974 :     if (dest == NULL) return(-1);

	mov	ecx, DWORD PTR _dest$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@xmlNanoFTP

; 1975 :     if (len <= 0) return(0);

	mov	edx, DWORD PTR _len$[ebp]
	test	edx, edx
	jle	SHORT $LN9@xmlNanoFTP

; 1976 : 
; 1977 :     len = recv(ctxt->dataFd, dest, len, 0);

	push	edi
	push	0
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__recv@16
	mov	edi, eax

; 1978 :     if (len <= 0) {

	test	edi, edi
	jg	SHORT $LN6@xmlNanoFTP

; 1979 : 	if (len < 0)

	jns	SHORT $LN7@xmlNanoFTP

; 1980 : 	    __xmlIOErr(XML_FROM_FTP, 0, "recv failed");

	push	OFFSET ??_C@_0M@KMFGCEDE@recv?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN7@xmlNanoFTP:

; 1981 : 	xmlNanoFTPCloseConnection(ctxt);

	push	esi
	call	_xmlNanoFTPCloseConnection
	add	esp, 4
$LN6@xmlNanoFTP:

; 1982 :     }
; 1983 : #ifdef DEBUG_FTP
; 1984 :     xmlGenericError(xmlGenericErrorContext, "Recvd %d bytes\n", len);
; 1985 : #endif
; 1986 :     return(len);

	mov	eax, edi
	pop	edi
	pop	esi

; 1987 : }

	pop	ebp
	ret	0
$LN9@xmlNanoFTP:

; 1975 :     if (len <= 0) return(0);

	xor	eax, eax
	pop	esi

; 1987 : }

	pop	ebp
	ret	0
$LN10@xmlNanoFTP:

; 1974 :     if (dest == NULL) return(-1);

	or	eax, -1
	pop	esi

; 1987 : }

	pop	ebp
	ret	0
_xmlNanoFTPRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPGet
_TEXT	SEGMENT
_buf$ = -4364						; size = 4096
_rfd$ = -268						; size = 260
_tv$ = -8						; size = 8
_ctx$ = 8						; size = 4
_callback$ = 12						; size = 4
_userData$ = 16						; size = 4
_filename$ = 20						; size = 4
_xmlNanoFTPGet PROC					; COMDAT

; 1902 : 	      const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	eax, 4364				; 0000110cH
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN41@xmlNanoFTP

; 1903 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1904 :     char buf[4096];
; 1905 :     int len = 0, res;
; 1906 :     fd_set rfd;
; 1907 :     struct timeval tv;
; 1908 : 
; 1909 :     if (ctxt == NULL) return(-1);
; 1910 :     if ((filename == NULL) && (ctxt->path == NULL))

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	jne	SHORT $LN12@xmlNanoFTP
	cmp	DWORD PTR [esi+12], edi
	je	$LN41@xmlNanoFTP
$LN12@xmlNanoFTP:

; 1911 : 	return(-1);
; 1912 :     if (callback == NULL)

	mov	ebx, DWORD PTR _callback$[ebp]
	test	ebx, ebx
	je	$LN41@xmlNanoFTP

; 1913 : 	return(-1);
; 1914 :     if (xmlNanoFTPGetSocket(ctxt, filename) == INVALID_SOCKET)

	push	eax
	push	esi
	call	_xmlNanoFTPGetSocket
	add	esp, 8
	cmp	eax, -1
	je	$LN41@xmlNanoFTP
$LL4@xmlNanoFTP:

; 1915 : 	return(-1);
; 1916 : 
; 1917 :     do {
; 1918 : 	tv.tv_sec = 1;
; 1919 : 	tv.tv_usec = 0;
; 1920 : 	FD_ZERO(&rfd);
; 1921 : 	FD_SET(ctxt->dataFd, &rfd);

	mov	eax, DWORD PTR [esi+48]

; 1922 : 	res = select(ctxt->dataFd + 1, &rfd, NULL, NULL, &tv);

	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	push	0
	push	0
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	DWORD PTR _rfd$[ebp+4], eax
	push	ecx
	inc	eax
	mov	DWORD PTR _tv$[ebp], 1
	push	eax
	mov	DWORD PTR _tv$[ebp+4], 0
	mov	DWORD PTR _rfd$[ebp], 1
	call	DWORD PTR __imp__select@20

; 1923 : 	if (res < 0) {

	test	eax, eax
	js	$LN27@xmlNanoFTP

; 1924 : #ifdef DEBUG_FTP
; 1925 : 	    perror("select");
; 1926 : #endif
; 1927 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1928 : 	    return(-1);
; 1929 : 	}
; 1930 : 	if (res == 0) {

	jne	SHORT $LN19@xmlNanoFTP

; 1931 : 	    res = xmlNanoFTPCheckResponse(ctxt);

	push	esi
	call	_xmlNanoFTPCheckResponse
	add	esp, 4

; 1932 : 	    if (res < 0) {

	test	eax, eax
	js	$LN27@xmlNanoFTP

; 1933 : 		closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1934 : 		ctxt->dataFd = INVALID_SOCKET;
; 1935 : 		return(-1);
; 1936 : 	    }
; 1937 : 	    if (res == 2) {

	cmp	eax, 2
	jne	SHORT $LN2@xmlNanoFTP

; 1938 : 		closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__closesocket@4
	pop	edi
	mov	DWORD PTR [esi+48], -1

; 1939 : 		return(0);

	xor	eax, eax

; 1954 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlNanoFTP:

; 1940 : 	    }
; 1941 : 
; 1942 : 	    continue;
; 1943 : 	}
; 1944 : 	if ((len = recv(ctxt->dataFd, buf, sizeof(buf), 0)) < 0) {

	push	0
	push	4096					; 00001000H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__recv@16
	mov	edi, eax
	test	edi, edi
	js	SHORT $LN31@xmlNanoFTP

; 1947 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1948 : 	    return(-1);
; 1949 : 	}
; 1950 : 	callback(userData, buf, len);

	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR _userData$[ebp]
	call	ebx
	add	esp, 12					; 0000000cH
$LN2@xmlNanoFTP:

; 1951 :     } while (len != 0);

	test	edi, edi
	jne	$LL4@xmlNanoFTP

; 1952 : 
; 1953 :     return(xmlNanoFTPCloseConnection(ctxt));

	push	esi
	call	_xmlNanoFTPCloseConnection
	add	esp, 4
	pop	edi

; 1954 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlNanoFTP:

; 1945 : 	    __xmlIOErr(XML_FROM_FTP, 0, "recv failed");

	push	OFFSET ??_C@_0M@KMFGCEDE@recv?5failed@
	push	0
	push	9
	call	___xmlIOErr

; 1946 : 	    callback(userData, buf, len);

	push	edi
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR _userData$[ebp]
	call	ebx
	add	esp, 24					; 00000018H
$LN27@xmlNanoFTP:

; 1954 : }

	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__closesocket@4
	mov	DWORD PTR [esi+48], -1
$LN41@xmlNanoFTP:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPGetSocket
_TEXT	SEGMENT
_buf$ = -300						; size = 300
_ctx$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlNanoFTPGetSocket PROC				; COMDAT

; 1836 : xmlNanoFTPGetSocket(void *ctx, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN14@xmlNanoFTP

; 1837 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1838 :     char buf[300];
; 1839 :     int res, len;
; 1840 :     if (ctx == NULL)
; 1841 : 	return INVALID_SOCKET;
; 1842 :     if ((filename == NULL) && (ctxt->path == NULL))

	mov	edi, DWORD PTR _filename$[ebp]
	test	edi, edi
	jne	SHORT $LN13@xmlNanoFTP
	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN14@xmlNanoFTP
$LN13@xmlNanoFTP:

; 1843 : 	return INVALID_SOCKET;
; 1844 :     ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);

	push	esi
	call	_xmlNanoFTPGetConnection
	add	esp, 4
	mov	DWORD PTR [esi+48], eax

; 1845 :     if (ctxt->dataFd == INVALID_SOCKET)

	cmp	eax, -1
	je	SHORT $LN14@xmlNanoFTP

; 1846 : 	return INVALID_SOCKET;
; 1847 : 
; 1848 :     snprintf(buf, sizeof(buf), "TYPE I\r\n");

	push	OFFSET ??_C@_08NFILCCME@TYPE?5I?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	300					; 0000012cH
	push	eax
	call	_snprintf

; 1849 :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL15@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL15@xmlNanoFTP

; 1850 : #ifdef DEBUG_FTP
; 1851 :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1852 : #endif
; 1853 :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16

; 1854 :     if (res < 0) {

	test	eax, eax
	jns	SHORT $LN5@xmlNanoFTP
$LN18@xmlNanoFTP:

; 1885 : }

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN17@xmlNanoFTP:
	push	DWORD PTR [esi+48]
$LN19@xmlNanoFTP:
	call	DWORD PTR __imp__closesocket@4
	mov	DWORD PTR [esi+48], -1
$LN14@xmlNanoFTP:
	pop	edi
	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlNanoFTP:

; 1855 : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1856 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1857 : 	return INVALID_SOCKET;
; 1858 :     }
; 1859 :     res = xmlNanoFTPReadResponse(ctxt);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1860 :     if (res != 2) {

	cmp	eax, 2
	jne	SHORT $LN17@xmlNanoFTP

; 1861 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1862 : 	return INVALID_SOCKET;
; 1863 :     }
; 1864 :     if (filename == NULL)

	test	edi, edi
	jne	SHORT $LN7@xmlNanoFTP

; 1865 : 	snprintf(buf, sizeof(buf), "RETR %s\r\n", ctxt->path);

	mov	edi, DWORD PTR [esi+12]
$LN7@xmlNanoFTP:

; 1866 :     else
; 1867 : 	snprintf(buf, sizeof(buf), "RETR %s\r\n", filename);
; 1868 :     buf[sizeof(buf) - 1] = 0;

	push	edi
	push	OFFSET ??_C@_09NFIHFDPP@RETR?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	300					; 0000012cH
	push	eax
	call	_snprintf

; 1869 :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+299], 0
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
$LL16@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL16@xmlNanoFTP

; 1870 : #ifdef DEBUG_FTP
; 1871 :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1872 : #endif
; 1873 :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16

; 1874 :     if (res < 0) {

	test	eax, eax
	js	$LN18@xmlNanoFTP

; 1875 : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1876 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1877 : 	return INVALID_SOCKET;
; 1878 :     }
; 1879 :     res = xmlNanoFTPReadResponse(ctxt);

	push	esi
	call	_xmlNanoFTPReadResponse
	mov	ecx, DWORD PTR [esi+48]
	add	esp, 4

; 1880 :     if (res != 1) {

	cmp	eax, 1
	je	SHORT $LN10@xmlNanoFTP

; 1881 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	ecx

; 1882 : 	return INVALID_SOCKET;

	jmp	$LN19@xmlNanoFTP
$LN10@xmlNanoFTP:
	pop	edi

; 1883 :     }
; 1884 :     return(ctxt->dataFd);

	mov	eax, ecx

; 1885 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPGetSocket ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPList
_TEXT	SEGMENT
_buf$ = -4628						; size = 4097
_rfd$ = -528						; size = 260
_efd$ = -268						; size = 260
_tv$ = -8						; size = 8
_res$2$ = 8						; size = 4
_res$1$ = 8						; size = 4
_indx$1$ = 8						; size = 4
_ctx$ = 8						; size = 4
_callback$ = 12						; size = 4
_userData$ = 16						; size = 4
_filename$ = 20						; size = 4
_xmlNanoFTPList PROC					; COMDAT

; 1727 : 	       const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	eax, 4628				; 00001214H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctx$[ebp]
	xor	esi, esi
	test	edi, edi
	je	$LN73@xmlNanoFTP

; 1728 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1729 :     char buf[4096 + 1];
; 1730 :     int len, res;
; 1731 :     int indx = 0, base;
; 1732 :     fd_set rfd, efd;
; 1733 :     struct timeval tv;
; 1734 : 
; 1735 :     if (ctxt == NULL) return (-1);
; 1736 :     if (filename == NULL) {

	mov	ebx, DWORD PTR _filename$[ebp]
	test	ebx, ebx
	jne	SHORT $LN21@xmlNanoFTP

; 1737 :         if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)

	push	DWORD PTR [edi+12]
	push	edi
	call	_xmlNanoFTPCwd
	add	esp, 8
	cmp	eax, 1
	jl	$LN73@xmlNanoFTP

; 1738 : 	    return(-1);
; 1739 : 	ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);

	push	edi
	call	_xmlNanoFTPGetConnection
	add	esp, 4
	mov	DWORD PTR [edi+48], eax

; 1740 : 	if (ctxt->dataFd == INVALID_SOCKET)

	cmp	eax, -1
	je	$LN73@xmlNanoFTP

; 1741 : 	    return(-1);
; 1742 : 	snprintf(buf, sizeof(buf), "LIST -L\r\n");

	push	OFFSET ??_C@_09PLPJIOKF@LIST?5?9L?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	4097					; 00001001H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH

; 1743 :     } else {

	jmp	SHORT $LN22@xmlNanoFTP
$LN21@xmlNanoFTP:

; 1744 : 	if (filename[0] != '/') {

	cmp	BYTE PTR [ebx], 47			; 0000002fH
	je	SHORT $LN26@xmlNanoFTP

; 1745 : 	    if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)

	push	DWORD PTR [edi+12]
	push	edi
	call	_xmlNanoFTPCwd
	add	esp, 8
	cmp	eax, 1
	jl	$LN73@xmlNanoFTP
$LN26@xmlNanoFTP:

; 1746 : 		return(-1);
; 1747 : 	}
; 1748 : 	ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);

	push	edi
	call	_xmlNanoFTPGetConnection
	add	esp, 4
	mov	DWORD PTR [edi+48], eax

; 1749 : 	if (ctxt->dataFd == INVALID_SOCKET)

	cmp	eax, -1
	je	$LN73@xmlNanoFTP

; 1750 : 	    return(-1);
; 1751 : 	snprintf(buf, sizeof(buf), "LIST -L %s\r\n", filename);

	push	ebx
	push	OFFSET ??_C@_0N@MNMMLKJL@LIST?5?9L?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	4097					; 00001001H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN22@xmlNanoFTP:

; 1752 :     }
; 1753 :     buf[sizeof(buf) - 1] = 0;
; 1754 :     len = strlen(buf);

	lea	ebx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+4096], 0
	lea	ecx, DWORD PTR [ebx+1]
	npad	4
$LL78@xmlNanoFTP:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL78@xmlNanoFTP

; 1755 : #ifdef DEBUG_FTP
; 1756 :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1757 : #endif
; 1758 :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ebx, ecx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ebx
	push	eax
	push	DWORD PTR [edi+44]
	call	DWORD PTR __imp__send@16
	mov	DWORD PTR _res$1$[ebp], eax

; 1759 :     if (res < 0) {

	test	eax, eax
	jns	SHORT $LN28@xmlNanoFTP

; 1760 : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1761 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	DWORD PTR [edi+48]
	call	DWORD PTR __imp__closesocket@4

; 1762 : 	return(res);

	mov	eax, DWORD PTR _res$1$[ebp]
	mov	DWORD PTR [edi+48], -1
	pop	edi

; 1822 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlNanoFTP:

; 1763 :     }
; 1764 :     res = xmlNanoFTPReadResponse(ctxt);

	push	edi
	call	_xmlNanoFTPReadResponse
	add	esp, 4
	mov	DWORD PTR _res$2$[ebp], eax

; 1765 :     if (res != 1) {

	cmp	eax, 1
	je	SHORT $LL4@xmlNanoFTP

; 1766 : 	closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	DWORD PTR [edi+48]
	call	DWORD PTR __imp__closesocket@4

; 1767 : 	return(-res);

	mov	eax, DWORD PTR _res$2$[ebp]
	mov	DWORD PTR [edi+48], -1
	neg	eax
	pop	edi

; 1822 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL4@xmlNanoFTP:

; 1768 :     }
; 1769 : 
; 1770 :     do {
; 1771 : 	tv.tv_sec = 1;
; 1772 : 	tv.tv_usec = 0;
; 1773 : 	FD_ZERO(&rfd);
; 1774 : 	FD_SET(ctxt->dataFd, &rfd);

	mov	eax, DWORD PTR [edi+48]

; 1775 : 	FD_ZERO(&efd);
; 1776 : 	FD_SET(ctxt->dataFd, &efd);
; 1777 : 	res = select(ctxt->dataFd + 1, &rfd, NULL, &efd, &tv);

	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _efd$[ebp]
	mov	DWORD PTR _rfd$[ebp+4], eax
	push	ecx
	push	0
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	DWORD PTR _efd$[ebp+4], eax
	push	ecx
	inc	eax
	mov	DWORD PTR _tv$[ebp], 1
	push	eax
	mov	DWORD PTR _tv$[ebp+4], 0
	mov	DWORD PTR _rfd$[ebp], 1
	mov	DWORD PTR _efd$[ebp], 1
	call	DWORD PTR __imp__select@20

; 1778 : 	if (res < 0) {

	test	eax, eax
	js	$LN48@xmlNanoFTP

; 1779 : #ifdef DEBUG_FTP
; 1780 : 	    perror("select");
; 1781 : #endif
; 1782 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1783 : 	    return(-1);
; 1784 : 	}
; 1785 : 	if (res == 0) {

	jne	SHORT $LN37@xmlNanoFTP

; 1786 : 	    res = xmlNanoFTPCheckResponse(ctxt);

	push	edi
	call	_xmlNanoFTPCheckResponse
	add	esp, 4

; 1787 : 	    if (res < 0) {

	test	eax, eax
	js	$LN48@xmlNanoFTP

; 1788 : 		closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1789 : 		ctxt->dataFd = INVALID_SOCKET;
; 1790 : 		return(-1);
; 1791 : 	    }
; 1792 : 	    if (res == 2) {

	cmp	eax, 2
	jne	$LN2@xmlNanoFTP

; 1793 : 		closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	DWORD PTR [edi+48]
	call	DWORD PTR __imp__closesocket@4
	mov	DWORD PTR [edi+48], -1

; 1794 : 		return(0);

	xor	eax, eax
	pop	edi

; 1822 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlNanoFTP:

; 1795 : 	    }
; 1796 : 
; 1797 : 	    continue;
; 1798 : 	}
; 1799 : 
; 1800 : 	if ((len = recv(ctxt->dataFd, &buf[indx], sizeof(buf) - (indx + 1), 0)) < 0) {

	push	0
	mov	eax, 4096				; 00001000H
	sub	eax, esi
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, esi
	push	eax
	push	DWORD PTR [edi+48]
	call	DWORD PTR __imp__recv@16
	mov	ebx, eax
	test	ebx, ebx
	js	SHORT $LN52@xmlNanoFTP

; 1802 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1803 : 	    ctxt->dataFd = INVALID_SOCKET;
; 1804 : 	    return(-1);
; 1805 : 	}
; 1806 : #ifdef DEBUG_FTP
; 1807 :         write(1, &buf[indx], len);
; 1808 : #endif
; 1809 : 	indx += len;

	add	esi, ebx
	mov	DWORD PTR _indx$1$[ebp], esi

; 1810 : 	buf[indx] = 0;

	mov	BYTE PTR _buf$[ebp+esi], 0

; 1811 : 	base = 0;

	xor	esi, esi
	npad	5
$LL19@xmlNanoFTP:

; 1812 : 	do {
; 1813 : 	    res = xmlNanoFTPParseList(&buf[base], callback, userData);

	push	DWORD PTR _userData$[ebp]
	lea	eax, DWORD PTR _buf$[ebp]
	push	DWORD PTR _callback$[ebp]
	add	eax, esi
	push	eax
	call	_xmlNanoFTPParseList
	add	esp, 12					; 0000000cH

; 1814 : 	    base += res;

	add	esi, eax

; 1815 : 	} while (res > 0);

	test	eax, eax
	jg	SHORT $LL19@xmlNanoFTP

; 1816 : 
; 1817 : 	memmove(&buf[0], &buf[base], indx - base);

	mov	eax, DWORD PTR _indx$1$[ebp]
	sub	eax, esi
	push	eax
	mov	DWORD PTR _indx$1$[ebp], eax
	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, esi
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_memmove
	mov	esi, DWORD PTR _indx$1$[ebp]
	add	esp, 12					; 0000000cH
$LN2@xmlNanoFTP:

; 1818 : 	indx -= base;
; 1819 :     } while (len != 0);

	test	ebx, ebx
	jne	$LL4@xmlNanoFTP

; 1820 :     xmlNanoFTPCloseConnection(ctxt);

	push	edi
	call	_xmlNanoFTPCloseConnection
	add	esp, 4

; 1821 :     return(0);

	xor	eax, eax
	pop	edi

; 1822 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlNanoFTP:

; 1801 : 	    __xmlIOErr(XML_FROM_FTP, 0, "recv");

	push	OFFSET ??_C@_04IFMDBHHF@recv@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN48@xmlNanoFTP:

; 1822 : }

	push	DWORD PTR [edi+48]
	call	DWORD PTR __imp__closesocket@4
	mov	DWORD PTR [edi+48], -1
$LN73@xmlNanoFTP:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPCloseConnection
_TEXT	SEGMENT
_rfd$ = -528						; size = 260
_efd$ = -268						; size = 260
_tv$ = -8						; size = 8
_ctx$ = 8						; size = 4
_xmlNanoFTPCloseConnection PROC				; COMDAT

; 1547 : xmlNanoFTPCloseConnection(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN15@xmlNanoFTP

; 1548 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1549 :     int res;
; 1550 :     fd_set rfd, efd;
; 1551 :     struct timeval tv;
; 1552 : 
; 1553 :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [esi+44], -1
	je	$LN15@xmlNanoFTP

; 1554 : 
; 1555 :     closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	edi
	push	DWORD PTR [esi+48]
	mov	edi, DWORD PTR __imp__closesocket@4
	call	edi

; 1556 :     tv.tv_sec = 15;
; 1557 :     tv.tv_usec = 0;
; 1558 :     FD_ZERO(&rfd);
; 1559 :     FD_SET(ctxt->controlFd, &rfd);

	mov	eax, DWORD PTR [esi+44]

; 1560 :     FD_ZERO(&efd);
; 1561 :     FD_SET(ctxt->controlFd, &efd);
; 1562 :     res = select(ctxt->controlFd + 1, &rfd, NULL, &efd, &tv);

	lea	ecx, DWORD PTR _tv$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _efd$[ebp]
	mov	DWORD PTR _rfd$[ebp+4], eax
	push	ecx
	push	0
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	DWORD PTR _efd$[ebp+4], eax
	push	ecx
	inc	eax
	mov	DWORD PTR [esi+48], -1
	push	eax
	mov	DWORD PTR _tv$[ebp], 15			; 0000000fH
	mov	DWORD PTR _tv$[ebp+4], 0
	mov	DWORD PTR _rfd$[ebp], 1
	mov	DWORD PTR _efd$[ebp], 1
	call	DWORD PTR __imp__select@20

; 1563 :     if (res < 0) {

	test	eax, eax
	js	SHORT $LN45@xmlNanoFTP

; 1564 : #ifdef DEBUG_FTP
; 1565 : 	perror("select");
; 1566 : #endif
; 1567 : 	closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1568 : 	return(-1);
; 1569 :     }
; 1570 :     if (res == 0) {

	jne	SHORT $LN23@xmlNanoFTP

; 1571 : #ifdef DEBUG_FTP
; 1572 : 	xmlGenericError(xmlGenericErrorContext,
; 1573 : 		"xmlNanoFTPCloseConnection: timeout\n");
; 1574 : #endif
; 1575 : 	closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [esi+44]
	call	edi
	mov	DWORD PTR [esi+44], -1
$LN25@xmlNanoFTP:

; 1581 : 	}
; 1582 :     }
; 1583 :     return(0);

	pop	edi
	xor	eax, eax
	pop	esi

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1576 :     } else {
; 1577 : 	res = xmlNanoFTPGetResponse(ctxt);
; 1578 : 	if (res != 2) {

	cmp	eax, 2
	je	SHORT $LN25@xmlNanoFTP
$LN45@xmlNanoFTP:

; 1579 : 	    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [esi+44]
	call	edi
	pop	edi
	mov	DWORD PTR [esi+44], -1

; 1580 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlNanoFTP:

; 1548 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1549 :     int res;
; 1550 :     fd_set rfd, efd;
; 1551 :     struct timeval tv;
; 1552 : 
; 1553 :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	or	eax, -1
	pop	esi

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPCloseConnection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPGetConnection
_TEXT	SEGMENT
_buf$ = -252						; size = 200
_temp$ = -52						; size = 24
_dataAddr$ = -28					; size = 16
_dataAddrLen$ = -12					; size = 4
_ad$ = -8						; size = 6
_ctx$ = 8						; size = 4
_xmlNanoFTPGetConnection PROC				; COMDAT

; 1374 : xmlNanoFTPGetConnection(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN17@xmlNanoFTP

; 1375 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1376 :     char buf[200], *cur;
; 1377 :     int len, i;
; 1378 :     int res;
; 1379 :     unsigned char ad[6], *adp, *portp;
; 1380 :     unsigned int temp[6];
; 1381 : #ifdef SUPPORT_IP6
; 1382 :     struct sockaddr_storage dataAddr;
; 1383 : #else
; 1384 :     struct sockaddr_in dataAddr;
; 1385 : #endif
; 1386 :     XML_SOCKLEN_T dataAddrLen;
; 1387 : 
; 1388 :     if (ctxt == NULL) return INVALID_SOCKET;
; 1389 : 
; 1390 :     memset (&dataAddr, 0, sizeof(dataAddr));
; 1391 : #ifdef SUPPORT_IP6
; 1392 :     if ((ctxt->ftpAddr).ss_family == AF_INET6) {
; 1393 : 	ctxt->dataFd = socket (AF_INET6, SOCK_STREAM, IPPROTO_TCP);
; 1394 : 	((struct sockaddr_in6 *)&dataAddr)->sin6_family = AF_INET6;
; 1395 : 	dataAddrLen = sizeof(struct sockaddr_in6);
; 1396 :     } else
; 1397 : #endif
; 1398 :     {
; 1399 : 	ctxt->dataFd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);

	push	6
	push	1
	xorps	xmm0, xmm0
	push	2
	movups	XMMWORD PTR _dataAddr$[ebp], xmm0
	call	DWORD PTR __imp__socket@12
	mov	DWORD PTR [esi+48], eax

; 1400 : 	((struct sockaddr_in *)&dataAddr)->sin_family = AF_INET;

	mov	ecx, 2
	mov	WORD PTR _dataAddr$[ebp], cx

; 1401 : 	dataAddrLen = sizeof (struct sockaddr_in);

	mov	DWORD PTR _dataAddrLen$[ebp], 16	; 00000010H

; 1402 :     }
; 1403 : 
; 1404 :     if (ctxt->dataFd == INVALID_SOCKET) {

	cmp	eax, -1
	jne	SHORT $LN8@xmlNanoFTP

; 1405 : 	__xmlIOErr(XML_FROM_FTP, 0, "socket failed");

	push	OFFSET ??_C@_0O@FPJGNADN@socket?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1534 : 
; 1535 : }

	or	eax, -1
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlNanoFTP:

; 1406 : 	return INVALID_SOCKET;
; 1407 :     }
; 1408 : 
; 1409 :     if (ctxt->passive) {

	cmp	DWORD PTR [esi+40], 0
	je	$LN9@xmlNanoFTP

; 1410 : #ifdef SUPPORT_IP6
; 1411 : 	if ((ctxt->ftpAddr).ss_family == AF_INET6)
; 1412 : 	    snprintf (buf, sizeof(buf), "EPSV\r\n");
; 1413 : 	else
; 1414 : #endif
; 1415 : 	    snprintf (buf, sizeof(buf), "PASV\r\n");

	push	OFFSET ??_C@_06OGKAIOED@PASV?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf

; 1416 :         len = strlen (buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [ecx+1]
$LL41@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL41@xmlNanoFTP

; 1417 : #ifdef DEBUG_FTP
; 1418 : 	xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1419 : #endif
; 1420 : 	res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16

; 1421 : 	if (res < 0) {

	test	eax, eax
	jns	SHORT $LN11@xmlNanoFTP
$LN45@xmlNanoFTP:

; 1534 : 
; 1535 : }

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
$LN44@xmlNanoFTP:
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN46@xmlNanoFTP:
	push	DWORD PTR [esi+48]
$LN43@xmlNanoFTP:
	call	DWORD PTR __imp__closesocket@4
	pop	edi
	mov	DWORD PTR [esi+48], -1
	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlNanoFTP:

; 1422 : 	    __xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1423 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1424 : 	    return INVALID_SOCKET;
; 1425 : 	}
; 1426 :         res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse

; 1427 : 	if (res != 2) {

	mov	edi, DWORD PTR __imp__closesocket@4
	add	esp, 4
	cmp	eax, 2
	je	SHORT $LN40@xmlNanoFTP

; 1428 : 	    if (res == 5) {

	mov	ecx, DWORD PTR [esi+48]
	push	ecx
	cmp	eax, 5
	je	SHORT $LN43@xmlNanoFTP

; 1429 : 	        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1430 : 		return INVALID_SOCKET;
; 1431 : 	    } else {
; 1432 : 		/*
; 1433 : 		 * retry with an active connection
; 1434 : 		 */
; 1435 : 	        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	call	edi
	mov	DWORD PTR [esi+48], -1

; 1436 : 	        ctxt->passive = 0;

	mov	DWORD PTR [esi+40], 0
$LN40@xmlNanoFTP:

; 1437 : 	    }
; 1438 : 	}
; 1439 : 	cur = &ctxt->controlBuf[ctxt->controlBufAnswer];

	mov	eax, DWORD PTR [esi+1096]
	lea	ecx, DWORD PTR [esi+60]
	add	ecx, eax
$LL2@xmlNanoFTP:

; 1440 : 	while (((*cur < '0') || (*cur > '9')) && *cur != '\0') cur++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN15@xmlNanoFTP
	cmp	al, 57					; 00000039H
	jle	SHORT $LN3@xmlNanoFTP
$LN15@xmlNanoFTP:
	test	al, al
	je	SHORT $LN3@xmlNanoFTP
	inc	ecx
	jmp	SHORT $LL2@xmlNanoFTP
$LN3@xmlNanoFTP:

; 1441 : #ifdef SUPPORT_IP6
; 1442 : 	if ((ctxt->ftpAddr).ss_family == AF_INET6) {
; 1443 : 	    if (sscanf (cur, "%u", &temp[0]) != 1) {
; 1444 : 		__xmlIOErr(XML_FROM_FTP, XML_FTP_EPSV_ANSWER,
; 1445 : 			"Invalid answer to EPSV\n");
; 1446 : 		if (ctxt->dataFd != INVALID_SOCKET) {
; 1447 : 		    closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1448 : 		}
; 1449 : 		return INVALID_SOCKET;
; 1450 : 	    }
; 1451 : 	    memcpy (&((struct sockaddr_in6 *)&dataAddr)->sin6_addr, &((struct sockaddr_in6 *)&ctxt->ftpAddr)->sin6_addr, sizeof(struct in6_addr));
; 1452 : 	    ((struct sockaddr_in6 *)&dataAddr)->sin6_port = htons (temp[0]);
; 1453 : 	}
; 1454 : 	else
; 1455 : #endif
; 1456 : 	{
; 1457 : 	    if (sscanf (cur, "%u,%u,%u,%u,%u,%u", &temp[0], &temp[1], &temp[2],
; 1458 : 		&temp[3], &temp[4], &temp[5]) != 6) {

	lea	eax, DWORD PTR _temp$[ebp+20]
	push	eax
	lea	eax, DWORD PTR _temp$[ebp+16]
	push	eax
	lea	eax, DWORD PTR _temp$[ebp+12]
	push	eax
	lea	eax, DWORD PTR _temp$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _temp$[ebp+4]
	push	eax
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@GDCBJEOP@?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu?0?$CFu@
	push	ecx
	call	_sscanf
	add	esp, 32					; 00000020H
	cmp	eax, 6
	je	SHORT $LN16@xmlNanoFTP

; 1459 : 		__xmlIOErr(XML_FROM_FTP, XML_FTP_PASV_ANSWER,

	push	OFFSET ??_C@_0BI@FEMCDLGO@Invalid?5answer?5to?5PASV?6@
	push	2000					; 000007d0H
	push	9
	call	___xmlIOErr

; 1460 : 			"Invalid answer to PASV\n");
; 1461 : 		if (ctxt->dataFd != INVALID_SOCKET) {

	mov	eax, DWORD PTR [esi+48]
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $LN17@xmlNanoFTP

; 1462 : 		    closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	eax

; 1534 : 
; 1535 : }

	call	edi
	mov	DWORD PTR [esi+48], -1
$LN17@xmlNanoFTP:
	pop	edi
	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlNanoFTP:

; 1463 : 		}
; 1464 : 		return INVALID_SOCKET;
; 1465 : 	    }
; 1466 : 	    for (i=0; i<6; i++) ad[i] = (unsigned char) (temp[i] & 0xff);

	movzx	eax, BYTE PTR _temp$[ebp]

; 1467 : 	    memcpy (&((struct sockaddr_in *)&dataAddr)->sin_addr, &ad[0], 4);
; 1468 : 	    memcpy (&((struct sockaddr_in *)&dataAddr)->sin_port, &ad[4], 2);
; 1469 : 	}
; 1470 : 
; 1471 : 	if (connect(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {

	push	DWORD PTR _dataAddrLen$[ebp]
	mov	BYTE PTR _ad$[ebp], al
	movzx	eax, BYTE PTR _temp$[ebp+4]
	mov	BYTE PTR _ad$[ebp+1], al
	movzx	eax, BYTE PTR _temp$[ebp+8]
	mov	BYTE PTR _ad$[ebp+2], al
	movzx	eax, BYTE PTR _temp$[ebp+12]
	mov	BYTE PTR _ad$[ebp+3], al
	movzx	eax, BYTE PTR _temp$[ebp+16]
	mov	BYTE PTR _ad$[ebp+4], al
	movzx	eax, BYTE PTR _temp$[ebp+20]
	mov	BYTE PTR _ad$[ebp+5], al
	mov	eax, DWORD PTR _ad$[ebp]
	mov	DWORD PTR _dataAddr$[ebp+4], eax
	mov	ax, WORD PTR _ad$[ebp+4]
	mov	WORD PTR _dataAddr$[ebp+2], ax
	lea	eax, DWORD PTR _dataAddr$[ebp]
	push	eax
	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__connect@12
	test	eax, eax
	jns	$LN22@xmlNanoFTP

; 1472 : 	    __xmlIOErr(XML_FROM_FTP, 0, "Failed to create a data connection");

	push	OFFSET ??_C@_0CD@LJAJBLLL@Failed?5to?5create?5a?5data?5connect@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1473 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;

	push	DWORD PTR [esi+48]

; 1534 : 
; 1535 : }

	call	edi
	pop	edi
	mov	DWORD PTR [esi+48], -1
	or	eax, -1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlNanoFTP:

; 1474 : 	    return INVALID_SOCKET;
; 1475 : 	}
; 1476 :     } else {
; 1477 :         getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);

	mov	edi, DWORD PTR __imp__getsockname@12
	lea	ecx, DWORD PTR _dataAddrLen$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dataAddr$[ebp]
	push	ecx
	push	eax
	call	edi

; 1478 : #ifdef SUPPORT_IP6
; 1479 : 	if ((ctxt->ftpAddr).ss_family == AF_INET6)
; 1480 : 	    ((struct sockaddr_in6 *)&dataAddr)->sin6_port = 0;
; 1481 : 	else
; 1482 : #endif
; 1483 : 	    ((struct sockaddr_in *)&dataAddr)->sin_port = 0;
; 1484 : 
; 1485 : 	if (bind(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {

	push	DWORD PTR _dataAddrLen$[ebp]
	xor	eax, eax
	mov	WORD PTR _dataAddr$[ebp+2], ax
	lea	eax, DWORD PTR _dataAddr$[ebp]
	push	eax
	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__bind@12
	test	eax, eax
	jns	SHORT $LN19@xmlNanoFTP

; 1486 : 	    __xmlIOErr(XML_FROM_FTP, 0, "bind failed");

	push	OFFSET ??_C@_0M@NNJMLKEI@bind?5failed@

; 1487 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1488 : 	    return INVALID_SOCKET;

	jmp	$LN44@xmlNanoFTP
$LN19@xmlNanoFTP:

; 1489 : 	}
; 1490 :         getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);

	lea	eax, DWORD PTR _dataAddrLen$[ebp]
	push	eax
	lea	eax, DWORD PTR _dataAddr$[ebp]
	push	eax
	push	DWORD PTR [esi+48]
	call	edi

; 1491 : 
; 1492 : 	if (listen(ctxt->dataFd, 1) < 0) {

	push	1
	push	DWORD PTR [esi+48]
	call	DWORD PTR __imp__listen@8
	test	eax, eax
	jns	SHORT $LN20@xmlNanoFTP

; 1493 : 	    __xmlIOErr(XML_FROM_FTP, 0, "listen failed");

	push	OFFSET ??_C@_0O@MHKNJCGE@listen?5failed@

; 1494 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1495 : 	    return INVALID_SOCKET;

	jmp	$LN44@xmlNanoFTP
$LN20@xmlNanoFTP:

; 1496 : 	}
; 1497 : #ifdef SUPPORT_IP6
; 1498 : 	if ((ctxt->ftpAddr).ss_family == AF_INET6) {
; 1499 : 	    char buf6[INET6_ADDRSTRLEN];
; 1500 : 	    inet_ntop (AF_INET6, &((struct sockaddr_in6 *)&dataAddr)->sin6_addr,
; 1501 : 		    buf6, INET6_ADDRSTRLEN);
; 1502 : 	    adp = (unsigned char *) buf6;
; 1503 : 	    portp = (unsigned char *) &((struct sockaddr_in6 *)&dataAddr)->sin6_port;
; 1504 : 	    snprintf (buf, sizeof(buf), "EPRT |2|%s|%s|\r\n", adp, portp);
; 1505 :         } else
; 1506 : #endif
; 1507 : 	{
; 1508 : 	    adp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_addr;
; 1509 : 	    portp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_port;
; 1510 : 	    snprintf (buf, sizeof(buf), "PORT %d,%d,%d,%d,%d,%d\r\n",

	movzx	eax, BYTE PTR _dataAddr$[ebp+3]
	push	eax
	movzx	eax, BYTE PTR _dataAddr$[ebp+2]
	push	eax
	movzx	eax, BYTE PTR _dataAddr$[ebp+7]
	push	eax
	movzx	eax, BYTE PTR _dataAddr$[ebp+6]
	push	eax
	movzx	eax, BYTE PTR _dataAddr$[ebp+5]
	push	eax
	movzx	eax, BYTE PTR _dataAddr$[ebp+4]
	push	eax
	push	OFFSET ??_C@_0BJ@FJLKMNPA@PORT?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf

; 1511 : 	    adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,
; 1512 : 	    portp[0] & 0xff, portp[1] & 0xff);
; 1513 : 	}
; 1514 : 
; 1515 :         buf[sizeof(buf) - 1] = 0;
; 1516 :         len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+199], 0
	add	esp, 36					; 00000024H
	lea	edx, DWORD PTR [ecx+1]
$LL42@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL42@xmlNanoFTP

; 1517 : #ifdef DEBUG_FTP
; 1518 : 	xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1519 : #endif
; 1520 : 
; 1521 : 	res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16

; 1522 : 	if (res < 0) {

	test	eax, eax
	js	$LN45@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1523 : 	    __xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1524 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1525 : 	    return INVALID_SOCKET;
; 1526 : 	}
; 1527 :         res = xmlNanoFTPGetResponse(ctxt);
; 1528 : 	if (res != 2) {

	cmp	eax, 2
	jne	$LN46@xmlNanoFTP
$LN22@xmlNanoFTP:

; 1529 : 	    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;
; 1530 : 	    return INVALID_SOCKET;
; 1531 :         }
; 1532 :     }
; 1533 :     return(ctxt->dataFd);

	mov	eax, DWORD PTR [esi+48]
	pop	edi

; 1534 : 
; 1535 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPGetConnection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPDele
_TEXT	SEGMENT
_buf$ = -400						; size = 400
_ctx$ = 8						; size = 4
_file$ = 12						; size = 4
_xmlNanoFTPDele PROC					; COMDAT

; 1324 : xmlNanoFTPDele(void *ctx, const char *file) {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN3@xmlNanoFTP

; 1325 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1326 :     char buf[400];
; 1327 :     int len;
; 1328 :     int res;
; 1329 : 
; 1330 :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET) ||

	cmp	DWORD PTR [esi+44], -1
	je	$LN3@xmlNanoFTP
	mov	eax, DWORD PTR _file$[ebp]
	test	eax, eax
	je	$LN3@xmlNanoFTP

; 1332 : 
; 1333 :     /*
; 1334 :      * Expected response code for DELE:
; 1335 :      *
; 1336 :      * DELE
; 1337 :      *       250
; 1338 :      *       450, 550
; 1339 :      *       500, 501, 502, 421, 530
; 1340 :      */
; 1341 : 
; 1342 :     snprintf(buf, sizeof(buf), "DELE %s\r\n", file);

	push	eax
	push	OFFSET ??_C@_09PCBACKIO@DELE?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf

; 1343 :     buf[sizeof(buf) - 1] = 0;
; 1344 :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+399], 0
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL11@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL11@xmlNanoFTP

; 1345 : #ifdef DEBUG_FTP
; 1346 :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1347 : #endif
; 1348 :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16
	mov	edi, eax

; 1349 :     if (res < 0) {

	test	edi, edi
	jns	SHORT $LN4@xmlNanoFTP

; 1350 : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1351 : 	return(res);

	mov	eax, edi
	pop	edi

; 1359 : 	return(0);
; 1360 :     }
; 1361 :     return(0);
; 1362 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1352 :     }
; 1353 :     res = xmlNanoFTPGetResponse(ctxt);
; 1354 :     if (res == 4) {

	cmp	eax, 4
	je	SHORT $LN3@xmlNanoFTP

; 1355 : 	return(-1);
; 1356 :     }
; 1357 :     if (res == 2) return(1);

	cmp	eax, 2
	jne	SHORT $LN6@xmlNanoFTP
	pop	edi
	mov	eax, 1

; 1359 : 	return(0);
; 1360 :     }
; 1361 :     return(0);
; 1362 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlNanoFTP:
	pop	edi

; 1358 :     if (res == 5) {

	xor	eax, eax

; 1359 : 	return(0);
; 1360 :     }
; 1361 :     return(0);
; 1362 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlNanoFTP:
	pop	edi

; 1331 :         (file == NULL)) return(-1);

	or	eax, -1

; 1359 : 	return(0);
; 1360 :     }
; 1361 :     return(0);
; 1362 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPDele ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPCwd
_TEXT	SEGMENT
_buf$ = -400						; size = 400
_ctx$ = 8						; size = 4
_directory$ = 12					; size = 4
_xmlNanoFTPCwd PROC					; COMDAT

; 1275 : xmlNanoFTPCwd(void *ctx, const char *directory) {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN3@xmlNanoFTP

; 1276 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1277 :     char buf[400];
; 1278 :     int len;
; 1279 :     int res;
; 1280 : 
; 1281 :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [esi+44], -1
	je	$LN3@xmlNanoFTP

; 1282 :     if (directory == NULL) return 0;

	mov	eax, DWORD PTR _directory$[ebp]
	test	eax, eax
	je	$LN12@xmlNanoFTP

; 1283 : 
; 1284 :     /*
; 1285 :      * Expected response code for CWD:
; 1286 :      *
; 1287 :      * CWD
; 1288 :      *     250
; 1289 :      *     500, 501, 502, 421, 530, 550
; 1290 :      */
; 1291 :     snprintf(buf, sizeof(buf), "CWD %s\r\n", directory);

	push	eax
	push	OFFSET ??_C@_08JEHOKOMP@CWD?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf

; 1292 :     buf[sizeof(buf) - 1] = 0;
; 1293 :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	mov	BYTE PTR _buf$[ebp+399], 0
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL13@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL13@xmlNanoFTP

; 1294 : #ifdef DEBUG_FTP
; 1295 :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1296 : #endif
; 1297 :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16
	mov	edi, eax

; 1298 :     if (res < 0) {

	test	edi, edi
	jns	SHORT $LN5@xmlNanoFTP

; 1299 : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1300 : 	return(res);

	mov	eax, edi
	pop	edi

; 1307 :     if (res == 5) {
; 1308 : 	return(0);
; 1309 :     }
; 1310 :     return(0);
; 1311 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1301 :     }
; 1302 :     res = xmlNanoFTPGetResponse(ctxt);
; 1303 :     if (res == 4) {

	cmp	eax, 4
	je	SHORT $LN3@xmlNanoFTP

; 1304 : 	return(-1);
; 1305 :     }
; 1306 :     if (res == 2) return(1);

	cmp	eax, 2
	jne	SHORT $LN12@xmlNanoFTP
	pop	edi
	mov	eax, 1

; 1307 :     if (res == 5) {
; 1308 : 	return(0);
; 1309 :     }
; 1310 :     return(0);
; 1311 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlNanoFTP:
	pop	edi
	xor	eax, eax
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlNanoFTP:
	pop	edi

; 1276 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 1277 :     char buf[400];
; 1278 :     int len;
; 1279 :     int res;
; 1280 : 
; 1281 :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	or	eax, -1

; 1307 :     if (res == 5) {
; 1308 : 	return(0);
; 1309 :     }
; 1310 :     return(0);
; 1311 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPCwd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPCheckResponse
_TEXT	SEGMENT
_rfd$ = -276						; size = 260
_tv$ = -16						; size = 8
_res$1$ = -8						; size = 4
$T1 = -4						; size = 4
_ctx$ = 8						; size = 4
_xmlNanoFTPCheckResponse PROC				; COMDAT

; 730  : xmlNanoFTPCheckResponse(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctx$[ebp]
	test	ebx, ebx
	je	$LN11@xmlNanoFTP

; 731  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 732  :     fd_set rfd;
; 733  :     struct timeval tv;
; 734  : 
; 735  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, -1
	je	$LN11@xmlNanoFTP

; 736  :     tv.tv_sec = 0;
; 737  :     tv.tv_usec = 0;
; 738  :     FD_ZERO(&rfd);
; 739  :     FD_SET(ctxt->controlFd, &rfd);
; 740  :     switch(select(ctxt->controlFd + 1, &rfd, NULL, NULL, &tv)) {

	lea	ecx, DWORD PTR _tv$[ebp]
	mov	DWORD PTR _rfd$[ebp+4], eax
	push	ecx
	push	0
	push	0
	lea	ecx, DWORD PTR _rfd$[ebp]
	mov	DWORD PTR _tv$[ebp], 0
	push	ecx
	inc	eax
	mov	DWORD PTR _tv$[ebp+4], 0
	push	eax
	mov	DWORD PTR _rfd$[ebp], 1
	call	DWORD PTR __imp__select@20
	cmp	eax, -1
	je	$LN16@xmlNanoFTP
	test	eax, eax
	je	$LN15@xmlNanoFTP

; 646  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [ebx+44], -1
	push	esi
	push	edi
	mov	DWORD PTR _res$1$[ebp], -1
	je	$LN26@xmlNanoFTP
$get_more$95:

; 565  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [ebx+44], -1
	je	$LN26@xmlNanoFTP

; 566  : 
; 567  :     if ((ctxt->controlBufIndex < 0) || (ctxt->controlBufIndex > FTP_BUF_SIZE)) {

	mov	ecx, DWORD PTR [ebx+1088]
	cmp	ecx, 1024				; 00000400H
	ja	$LN26@xmlNanoFTP

; 568  : #ifdef DEBUG_FTP
; 569  :         xmlGenericError(xmlGenericErrorContext,
; 570  : 		"xmlNanoFTPGetMore : controlBufIndex = %d\n",
; 571  : 		ctxt->controlBufIndex);
; 572  : #endif
; 573  : 	return(-1);
; 574  :     }
; 575  : 
; 576  :     if ((ctxt->controlBufUsed < 0) || (ctxt->controlBufUsed > FTP_BUF_SIZE)) {

	mov	eax, DWORD PTR [ebx+1092]
	cmp	eax, 1024				; 00000400H
	ja	$LN26@xmlNanoFTP

; 577  : #ifdef DEBUG_FTP
; 578  :         xmlGenericError(xmlGenericErrorContext,
; 579  : 		"xmlNanoFTPGetMore : controlBufUsed = %d\n",
; 580  : 		ctxt->controlBufUsed);
; 581  : #endif
; 582  : 	return(-1);
; 583  :     }
; 584  :     if (ctxt->controlBufIndex > ctxt->controlBufUsed) {

	cmp	ecx, eax
	jg	$LN26@xmlNanoFTP

; 585  : #ifdef DEBUG_FTP
; 586  :         xmlGenericError(xmlGenericErrorContext,
; 587  : 		"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\n",
; 588  : 	       ctxt->controlBufIndex, ctxt->controlBufUsed);
; 589  : #endif
; 590  : 	return(-1);
; 591  :     }
; 592  : 
; 593  :     /*
; 594  :      * First pack the control buffer
; 595  :      */
; 596  :     if (ctxt->controlBufIndex > 0) {

	lea	esi, DWORD PTR [ebx+60]
	test	ecx, ecx
	jle	SHORT $LN91@xmlNanoFTP

; 597  : 	memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],

	sub	eax, ecx
	push	eax
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	esi
	call	_memmove

; 598  : 		ctxt->controlBufUsed - ctxt->controlBufIndex);
; 599  : 	ctxt->controlBufUsed -= ctxt->controlBufIndex;

	mov	eax, DWORD PTR [ebx+1088]
	add	esp, 12					; 0000000cH
	sub	DWORD PTR [ebx+1092], eax

; 600  : 	ctxt->controlBufIndex = 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+1092]
	mov	edi, eax
	mov	DWORD PTR [ebx+1088], 0
	mov	DWORD PTR $T1[ebp], edi
	jmp	SHORT $LN44@xmlNanoFTP
$LN91@xmlNanoFTP:
	mov	edi, eax
	mov	DWORD PTR $T1[ebp], eax
$LN44@xmlNanoFTP:

; 601  :     }
; 602  :     size = FTP_BUF_SIZE - ctxt->controlBufUsed;

	mov	edx, 1024				; 00000400H
	sub	edx, eax

; 603  :     if (size == 0) {

	jne	SHORT $LN45@xmlNanoFTP

; 604  : #ifdef DEBUG_FTP
; 605  :         xmlGenericError(xmlGenericErrorContext,
; 606  : 		"xmlNanoFTPGetMore : buffer full %d \n", ctxt->controlBufUsed);
; 607  : #endif
; 608  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN36@xmlNanoFTP
$LN45@xmlNanoFTP:

; 609  :     }
; 610  : 
; 611  :     /*
; 612  :      * Read the amount left on the control connection
; 613  :      */
; 614  :     if ((len = recv(ctxt->controlFd, &ctxt->controlBuf[ctxt->controlBufIndex],
; 615  : 		    size, 0)) < 0) {

	push	0
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	DWORD PTR [ebx+44]
	call	DWORD PTR __imp__recv@16
	test	eax, eax
	js	$LN88@xmlNanoFTP

; 619  :         return(-1);
; 620  :     }
; 621  : #ifdef DEBUG_FTP
; 622  :     xmlGenericError(xmlGenericErrorContext,
; 623  : 	    "xmlNanoFTPGetMore : read %d [%d - %d]\n", len,
; 624  : 	   ctxt->controlBufUsed, ctxt->controlBufUsed + len);
; 625  : #endif
; 626  :     ctxt->controlBufUsed += len;

	add	DWORD PTR [ebx+1092], eax
	mov	ecx, DWORD PTR [ebx+1092]

; 627  :     ctxt->controlBuf[ctxt->controlBufUsed] = 0;

	mov	BYTE PTR [ecx+esi], 0

; 628  : 
; 629  :     return(len);

	mov	edi, DWORD PTR [ebx+1092]
	mov	DWORD PTR $T1[ebp], edi
$LN36@xmlNanoFTP:

; 657  :     if ((ctxt->controlBufUsed == 0) && (len == 0)) {

	test	edi, edi
	jne	SHORT $LN28@xmlNanoFTP
	test	eax, eax
	je	$LN26@xmlNanoFTP
$LN28@xmlNanoFTP:

; 658  :         return(-1);
; 659  :     }
; 660  :     ptr = &ctxt->controlBuf[ctxt->controlBufIndex];

	mov	eax, DWORD PTR [ebx+1088]

; 661  :     end = &ctxt->controlBuf[ctxt->controlBufUsed];

	add	esi, edi
	add	eax, 60					; 0000003cH
	add	eax, ebx

; 662  : 
; 663  : #ifdef DEBUG_FTP
; 664  :     xmlGenericError(xmlGenericErrorContext,
; 665  : 	    "\n<<<\n%s\n--\n", ptr);
; 666  : #endif
; 667  :     while (ptr < end) {

	cmp	eax, esi
	jae	$LN20@xmlNanoFTP
	npad	7
$LL19@xmlNanoFTP:

; 668  :         cur = xmlNanoFTPParseResponse(ptr, end - ptr);

	mov	ecx, esi
	sub	ecx, eax

; 531  :     if (len < 3) return(-1);

	cmp	ecx, 3
	jl	SHORT $LN86@xmlNanoFTP

; 532  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN86@xmlNanoFTP

; 533  :         val = val * 10 + (*buf - '0');
; 534  :     else
; 535  :         return(0);
; 536  :     buf++;
; 537  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	ch, BYTE PTR [eax+1]
	mov	cl, ch
	movsx	edx, dl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN86@xmlNanoFTP

; 538  :         val = val * 10 + (*buf - '0');
; 539  :     else
; 540  :         return(0);
; 541  :     buf++;
; 542  :     if ((*buf >= '0') && (*buf <= '9'))

	mov	bl, BYTE PTR [eax+2]
	mov	cl, bl
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN86@xmlNanoFTP

; 543  :         val = val * 10 + (*buf - '0');

	movsx	ecx, ch
	lea	edx, DWORD PTR [edx+edx*4]
	lea	ecx, DWORD PTR [ecx+edx*2]
	lea	edx, DWORD PTR [ecx+ecx*4]
	movsx	ecx, bl
	lea	ecx, DWORD PTR [ecx+edx*2]
	add	ecx, -5328				; ffffeb30H

; 544  :     else
; 545  :         return(0);
; 546  :     buf++;
; 547  :     if (*buf == '-')

	cmp	BYTE PTR [eax+3], 45			; 0000002dH
	jne	SHORT $LN56@xmlNanoFTP

; 548  :         return(-val);

	neg	ecx
$LN56@xmlNanoFTP:

; 669  : 	if (cur > 0) {

	test	ecx, ecx
	jg	SHORT $LN65@xmlNanoFTP
$LN86@xmlNanoFTP:

; 682  : 	}
; 683  : 	while ((ptr < end) && (*ptr != '\n')) ptr++;

	cmp	eax, esi
	jae	SHORT $LN66@xmlNanoFTP
	npad	6
$LL23@xmlNanoFTP:
	mov	dl, BYTE PTR [eax]
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN24@xmlNanoFTP
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL23@xmlNanoFTP
$LN66@xmlNanoFTP:

; 685  : 	    ctxt->controlBufIndex = ctxt->controlBufUsed;

	mov	ebx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ebx+1088], eax

; 686  : 	    goto get_more;

	jmp	$get_more$95
$LN24@xmlNanoFTP:

; 684  : 	if (ptr >= end) {

	cmp	eax, esi
	jae	SHORT $LN66@xmlNanoFTP

; 662  : 
; 663  : #ifdef DEBUG_FTP
; 664  :     xmlGenericError(xmlGenericErrorContext,
; 665  : 	    "\n<<<\n%s\n--\n", ptr);
; 666  : #endif
; 667  :     while (ptr < end) {

	cmp	dl, 13					; 0000000dH
	lea	ecx, DWORD PTR [eax+1]
	cmove	ecx, eax
	mov	eax, ecx
	cmp	eax, esi
	jb	$LL19@xmlNanoFTP

; 647  : 
; 648  : get_more:
; 649  :     /*
; 650  :      * Assumes everything up to controlBuf[controlBufIndex] has been read
; 651  :      * and analyzed.
; 652  :      */
; 653  :     len = xmlNanoFTPGetMore(ctx);
; 654  :     if (len < 0) {
; 655  :         return(-1);
; 656  :     }
; 657  :     if ((ctxt->controlBufUsed == 0) && (len == 0)) {

	mov	ebx, DWORD PTR _ctx$[ebp]
$LN20@xmlNanoFTP:

; 687  : 	}
; 688  : 	if (*ptr != '\r') ptr++;
; 689  :     }
; 690  : 
; 691  :     if (res < 0) goto get_more;

	mov	ecx, DWORD PTR _res$1$[ebp]
	test	ecx, ecx
	js	$get_more$95

; 692  :     ctxt->controlBufIndex = ptr - ctxt->controlBuf;

	sub	eax, ebx
	sub	eax, 60					; 0000003cH
	mov	DWORD PTR [ebx+1088], eax

; 693  : #ifdef DEBUG_FTP
; 694  :     ptr = &ctxt->controlBuf[ctxt->controlBufIndex];
; 695  :     xmlGenericError(xmlGenericErrorContext, "\n---\n%s\n--\n", ptr);
; 696  : #endif
; 697  : 
; 698  : #ifdef DEBUG_FTP
; 699  :     xmlGenericError(xmlGenericErrorContext, "Got %d\n", res);
; 700  : #endif
; 701  :     return(res / 100);

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 745  : 	    return(-1);
; 746  : 
; 747  :     }
; 748  : 
; 749  :     return(xmlNanoFTPReadResponse(ctx));

	pop	edi

; 701  :     return(res / 100);

	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH

; 745  : 	    return(-1);
; 746  : 
; 747  :     }
; 748  : 
; 749  :     return(xmlNanoFTPReadResponse(ctx));

	pop	esi

; 701  :     return(res / 100);

	add	eax, edx
	pop	ebx

; 750  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlNanoFTP:

; 677  : 	    ctxt->controlBufAnswer = ptr - ctxt->controlBuf;

	mov	ebx, DWORD PTR _ctx$[ebp]
	add	eax, 3
	mov	DWORD PTR _res$1$[ebp], ecx
	mov	ecx, eax
	sub	ecx, ebx
	sub	ecx, 60					; 0000003cH
	mov	DWORD PTR [ebx+1096], ecx

; 678  : 	    while ((ptr < end) && (*ptr != '\n')) ptr++;

	cmp	eax, esi
	jae	SHORT $LN93@xmlNanoFTP
	npad	1
$LL21@xmlNanoFTP:
	cmp	BYTE PTR [eax], 10			; 0000000aH
	je	SHORT $LN93@xmlNanoFTP
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL21@xmlNanoFTP
$LN93@xmlNanoFTP:

; 679  : 	    if (*ptr == '\n') ptr++;

	mov	dl, BYTE PTR [eax]
	mov	dh, dl
	cmp	dl, 10					; 0000000aH
	jne	SHORT $LN30@xmlNanoFTP
	mov	dh, BYTE PTR [eax+1]
$LN30@xmlNanoFTP:

; 680  : 	    if (*ptr == '\r') ptr++;
; 681  : 	    break;

	lea	ecx, DWORD PTR [eax+1]
	cmp	dl, 10					; 0000000aH
	cmovne	ecx, eax
	cmp	dh, 13					; 0000000dH
	lea	eax, DWORD PTR [ecx+1]
	cmovne	eax, ecx
	jmp	SHORT $LN20@xmlNanoFTP
$LN88@xmlNanoFTP:

; 616  : 	__xmlIOErr(XML_FROM_FTP, 0, "recv failed");

	push	OFFSET ??_C@_0M@KMFGCEDE@recv?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 617  : 	closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [ebx+44]
	call	DWORD PTR __imp__closesocket@4

; 618  :         ctxt->controlFd = INVALID_SOCKET;

	mov	DWORD PTR [ebx+44], -1
$LN26@xmlNanoFTP:

; 745  : 	    return(-1);
; 746  : 
; 747  :     }
; 748  : 
; 749  :     return(xmlNanoFTPReadResponse(ctx));

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 750  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlNanoFTP:

; 741  : 	case 0:
; 742  : 	    return(0);

	xor	eax, eax
	pop	ebx

; 750  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlNanoFTP:

; 743  : 	case -1:
; 744  : 	    __xmlIOErr(XML_FROM_FTP, 0, "select");

	push	OFFSET ??_C@_06LGNCCACI@select@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN11@xmlNanoFTP:

; 750  : }

	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPCheckResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPGetResponse
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoFTPGetResponse PROC				; COMDAT

; 713  : xmlNanoFTPGetResponse(void *ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4

; 717  : 
; 718  :     return(res);
; 719  : }

	pop	ebp

; 714  :     int res;
; 715  : 
; 716  :     res = xmlNanoFTPReadResponse(ctx);

	jmp	_xmlNanoFTPReadResponse
_xmlNanoFTPGetResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPUpdateURL
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_URL$ = 12						; size = 4
_xmlNanoFTPUpdateURL PROC				; COMDAT

; 362  : xmlNanoFTPUpdateURL(void *ctx, const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _URL$[ebp]
	test	eax, eax
	je	$LN16@xmlNanoFTP

; 363  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 364  :     xmlURIPtr uri;
; 365  : 
; 366  :     if (URL == NULL)
; 367  : 	return(-1);
; 368  :     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN16@xmlNanoFTP

; 369  : 	return(-1);
; 370  :     if (ctxt->protocol == NULL)

	cmp	DWORD PTR [esi], 0
	je	$LN16@xmlNanoFTP

; 371  : 	return(-1);
; 372  :     if (ctxt->hostname == NULL)

	cmp	DWORD PTR [esi+4], 0
	je	$LN16@xmlNanoFTP

; 373  : 	return(-1);
; 374  : 
; 375  :     uri = xmlParseURIRaw(URL, 1);

	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	edi, eax
	add	esp, 8

; 376  :     if (uri == NULL)

	test	edi, edi
	je	$LN16@xmlNanoFTP

; 377  : 	return(-1);
; 378  : 
; 379  :     if ((uri->scheme == NULL) || (uri->server == NULL)) {

	mov	edx, DWORD PTR [edi]
	test	edx, edx
	je	$LN8@xmlNanoFTP
	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	$LN8@xmlNanoFTP

; 381  : 	return(-1);
; 382  :     }
; 383  :     if ((strcmp(ctxt->protocol, uri->scheme)) ||
; 384  : 	(strcmp(ctxt->hostname, uri->server)) ||

	mov	eax, DWORD PTR [esi]
	push	ebx
$LL17@xmlNanoFTP:
	mov	bl, BYTE PTR [eax]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN18@xmlNanoFTP
	test	bl, bl
	je	SHORT $LN19@xmlNanoFTP
	mov	bl, BYTE PTR [eax+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN18@xmlNanoFTP
	add	eax, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL17@xmlNanoFTP
$LN19@xmlNanoFTP:
	xor	eax, eax
	jmp	SHORT $LN20@xmlNanoFTP
$LN18@xmlNanoFTP:
	sbb	eax, eax
	or	eax, 1
$LN20@xmlNanoFTP:
	pop	ebx
	test	eax, eax
	jne	$LN8@xmlNanoFTP
	mov	eax, DWORD PTR [esi+4]
$LL21@xmlNanoFTP:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN22@xmlNanoFTP
	test	dl, dl
	je	SHORT $LN23@xmlNanoFTP
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN22@xmlNanoFTP
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL21@xmlNanoFTP
$LN23@xmlNanoFTP:
	xor	eax, eax
	jmp	SHORT $LN24@xmlNanoFTP
$LN22@xmlNanoFTP:
	sbb	eax, eax
	or	eax, 1
$LN24@xmlNanoFTP:
	test	eax, eax
	jne	SHORT $LN8@xmlNanoFTP
	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN11@xmlNanoFTP
	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN8@xmlNanoFTP

; 385  : 	((uri->port != 0) && (ctxt->port != uri->port))) {
; 386  : 	xmlFreeURI(uri);
; 387  : 	return(-1);
; 388  :     }
; 389  : 
; 390  :     if (uri->port != 0)
; 391  : 	ctxt->port = uri->port;

	mov	DWORD PTR [esi+8], eax
$LN11@xmlNanoFTP:

; 392  : 
; 393  :     if (ctxt->path != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@xmlNanoFTP

; 394  : 	xmlFree(ctxt->path);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 395  : 	ctxt->path = NULL;

	mov	DWORD PTR [esi+12], 0
$LN12@xmlNanoFTP:

; 396  :     }
; 397  : 
; 398  :     if (uri->path == NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	jne	SHORT $LN13@xmlNanoFTP

; 399  :         ctxt->path = xmlMemStrdup("/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
	jmp	SHORT $LN25@xmlNanoFTP
$LN13@xmlNanoFTP:

; 400  :     else
; 401  : 	ctxt->path = xmlMemStrdup(uri->path);

	push	eax
$LN25@xmlNanoFTP:

; 402  : 
; 403  :     xmlFreeURI(uri);

	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
	push	edi
	call	_xmlFreeURI
	add	esp, 4

; 404  : 
; 405  :     return(0);

	xor	eax, eax
	pop	edi

; 406  : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlNanoFTP:

; 380  : 	xmlFreeURI(uri);

	push	edi
	call	_xmlFreeURI
	add	esp, 4
$LN16@xmlNanoFTP:

; 406  : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
_xmlNanoFTPUpdateURL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPProxy
_TEXT	SEGMENT
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_user$ = 16						; size = 4
_passwd$ = 20						; size = 4
_type$ = 24						; size = 4
_xmlNanoFTPProxy PROC					; COMDAT

; 260  : 	        const char *passwd, int type) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _proxy
	test	eax, eax
	je	SHORT $LN2@xmlNanoFTP

; 261  :     if (proxy != NULL) {
; 262  : 	xmlFree(proxy);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 263  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoFTP:

; 264  :     }
; 265  :     if (proxyUser != NULL) {

	mov	eax, DWORD PTR _proxyUser
	test	eax, eax
	je	SHORT $LN3@xmlNanoFTP

; 266  : 	xmlFree(proxyUser);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 267  : 	proxyUser = NULL;

	mov	DWORD PTR _proxyUser, 0
$LN3@xmlNanoFTP:

; 268  :     }
; 269  :     if (proxyPasswd != NULL) {

	mov	eax, DWORD PTR _proxyPasswd
	test	eax, eax
	je	SHORT $LN4@xmlNanoFTP

; 270  : 	xmlFree(proxyPasswd);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 271  : 	proxyPasswd = NULL;

	mov	DWORD PTR _proxyPasswd, 0
$LN4@xmlNanoFTP:

; 272  :     }
; 273  :     if (host)

	mov	eax, DWORD PTR _host$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlNanoFTP

; 274  : 	proxy = xmlMemStrdup(host);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR _proxy, eax
$LN5@xmlNanoFTP:

; 275  :     if (user)

	mov	eax, DWORD PTR _user$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlNanoFTP

; 276  : 	proxyUser = xmlMemStrdup(user);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR _proxyUser, eax
$LN6@xmlNanoFTP:

; 277  :     if (passwd)

	mov	eax, DWORD PTR _passwd$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlNanoFTP

; 278  : 	proxyPasswd = xmlMemStrdup(passwd);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR _proxyPasswd, eax
$LN9@xmlNanoFTP:

; 279  :     proxyPort = port;
; 280  :     proxyType = type;
; 281  : }

	mov	eax, DWORD PTR _port$[ebp]
	mov	DWORD PTR _proxyPort, eax
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _proxyType, eax
	pop	ebp
	ret	0
_xmlNanoFTPProxy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPScanProxy
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNanoFTPScanProxy PROC				; COMDAT

; 419  : xmlNanoFTPScanProxy(const char *URL) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _proxy
	test	eax, eax
	je	SHORT $LN2@xmlNanoFTP

; 420  :     xmlURIPtr uri;
; 421  : 
; 422  :     if (proxy != NULL) {
; 423  :         xmlFree(proxy);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 424  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoFTP:

; 425  :     }
; 426  :     proxyPort = 0;
; 427  : 
; 428  : #ifdef DEBUG_FTP
; 429  :     if (URL == NULL)
; 430  : 	xmlGenericError(xmlGenericErrorContext,
; 431  : 		"Removing FTP proxy info\n");
; 432  :     else
; 433  : 	xmlGenericError(xmlGenericErrorContext,
; 434  : 		"Using FTP proxy %s\n", URL);
; 435  : #endif
; 436  :     if (URL == NULL) return;

	mov	eax, DWORD PTR _URL$[ebp]
	mov	DWORD PTR _proxyPort, 0
	test	eax, eax
	je	$LN6@xmlNanoFTP

; 437  : 
; 438  :     uri = xmlParseURIRaw(URL, 1);

	push	esi
	push	1
	push	eax
	call	_xmlParseURIRaw
	mov	esi, eax
	add	esp, 8

; 439  :     if ((uri == NULL) || (uri->scheme == NULL) ||
; 440  : 	(strcmp(uri->scheme, "ftp")) || (uri->server == NULL)) {

	test	esi, esi
	je	SHORT $LN5@xmlNanoFTP
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@xmlNanoFTP
	mov	edx, OFFSET ??_C@_03LMDBDBEG@ftp@
	npad	4
$LL10@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN11@xmlNanoFTP
	test	al, al
	je	SHORT $LN12@xmlNanoFTP
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN11@xmlNanoFTP
	add	ecx, 2
	add	edx, 2
	test	al, al
	jne	SHORT $LL10@xmlNanoFTP
$LN12@xmlNanoFTP:
	xor	eax, eax
	jmp	SHORT $LN13@xmlNanoFTP
$LN11@xmlNanoFTP:
	sbb	eax, eax
	or	eax, 1
$LN13@xmlNanoFTP:
	test	eax, eax
	jne	SHORT $LN5@xmlNanoFTP
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@xmlNanoFTP

; 444  : 	return;
; 445  :     }
; 446  : 
; 447  :     proxy = xmlMemStrdup(uri->server);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	DWORD PTR _proxy, eax
	add	esp, 4

; 448  :     if (uri->port != 0)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN9@xmlNanoFTP

; 449  : 	proxyPort = uri->port;

	push	esi
	mov	DWORD PTR _proxyPort, eax
	call	_xmlFreeURI
	add	esp, 4
	pop	esi

; 450  : 
; 451  :     xmlFreeURI(uri);
; 452  : }

	pop	ebp
	ret	0
$LN5@xmlNanoFTP:

; 441  : 	__xmlIOErr(XML_FROM_FTP, XML_FTP_URL_SYNTAX, "Syntax Error\n");

	push	OFFSET ??_C@_0O@FGOLBKPK@Syntax?5Error?6@
	push	2003					; 000007d3H
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 442  : 	if (uri != NULL)

	test	esi, esi
	je	SHORT $LN14@xmlNanoFTP
$LN9@xmlNanoFTP:

; 443  : 	    xmlFreeURI(uri);

	push	esi
	call	_xmlFreeURI
	add	esp, 4
$LN14@xmlNanoFTP:
	pop	esi
$LN6@xmlNanoFTP:

; 450  : 
; 451  :     xmlFreeURI(uri);
; 452  : }

	pop	ebp
	ret	0
_xmlNanoFTPScanProxy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPQuit
_TEXT	SEGMENT
_buf$ = -200						; size = 200
_ctx$ = 8						; size = 4
_xmlNanoFTPQuit PROC					; COMDAT

; 819  : xmlNanoFTPQuit(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlNanoFTP

; 820  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 821  :     char buf[200];
; 822  :     int len, res;
; 823  : 
; 824  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	cmp	DWORD PTR [esi+44], -1
	je	SHORT $LN3@xmlNanoFTP

; 825  : 
; 826  :     snprintf(buf, sizeof(buf), "QUIT\r\n");

	push	OFFSET ??_C@_06FIMJICNC@QUIT?$AN?6@
	lea	eax, DWORD PTR _buf$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf

; 827  :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$[ebp]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [ecx+1]
$LL6@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL6@xmlNanoFTP

; 828  : #ifdef DEBUG_FTP
; 829  :     xmlGenericError(xmlGenericErrorContext, "%s", buf); /* Just to be consistent, even though we know it can't have a % in it */
; 830  : #endif
; 831  :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__send@16
	mov	esi, eax

; 832  :     if (res < 0) {

	test	esi, esi
	jns	SHORT $LN4@xmlNanoFTP

; 833  : 	__xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 834  : 	return(res);

	mov	eax, esi
	pop	esi

; 837  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlNanoFTP:

; 835  :     }
; 836  :     return(0);

	xor	eax, eax
	pop	esi

; 837  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlNanoFTP:

; 820  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 821  :     char buf[200];
; 822  :     int len, res;
; 823  : 
; 824  :     if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);

	or	eax, -1
	pop	esi

; 837  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPQuit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPClose
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoFTPClose PROC					; COMDAT

; 2031 : xmlNanoFTPClose(void *ctx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlNanoFTP

; 2032 :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 2033 : 
; 2034 :     if (ctxt == NULL)
; 2035 : 	return(-1);

	or	eax, -1
	pop	esi

; 2048 : }

	pop	ebp
	ret	0
$LN2@xmlNanoFTP:

; 2036 : 
; 2037 :     if (ctxt->dataFd != INVALID_SOCKET) {

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, -1
	je	SHORT $LN3@xmlNanoFTP

; 2038 : 	closesocket(ctxt->dataFd);

	push	eax
	call	DWORD PTR __imp__closesocket@4

; 2039 : 	ctxt->dataFd = INVALID_SOCKET;

	mov	DWORD PTR [esi+48], -1
$LN3@xmlNanoFTP:

; 2040 :     }
; 2041 :     if (ctxt->controlFd != INVALID_SOCKET) {

	cmp	DWORD PTR [esi+44], -1
	je	SHORT $LN4@xmlNanoFTP

; 2042 : 	xmlNanoFTPQuit(ctxt);

	push	esi
	call	_xmlNanoFTPQuit
	add	esp, 4

; 2043 : 	closesocket(ctxt->controlFd);

	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__closesocket@4

; 2044 : 	ctxt->controlFd = INVALID_SOCKET;

	mov	DWORD PTR [esi+44], -1
$LN4@xmlNanoFTP:

; 2045 :     }
; 2046 :     xmlNanoFTPFreeCtxt(ctxt);

	push	esi
	call	_xmlNanoFTPFreeCtxt
	add	esp, 4

; 2047 :     return(0);

	xor	eax, eax
	pop	esi

; 2048 : }

	pop	ebp
	ret	0
_xmlNanoFTPClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPConnect
_TEXT	SEGMENT
_buf$1 = -400						; size = 400
_buf$2 = -200						; size = 200
_buf$3 = -200						; size = 200
_ctx$ = 8						; size = 4
_xmlNanoFTPConnect PROC					; COMDAT

; 849  : xmlNanoFTPConnect(void *ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN87@xmlNanoFTP

; 850  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 851  :     struct hostent *hp;
; 852  :     int port;
; 853  :     int res;
; 854  :     int addrlen = sizeof (struct sockaddr_in);
; 855  : 
; 856  :     if (ctxt == NULL)
; 857  : 	return(-1);
; 858  :     if (ctxt->hostname == NULL)

	cmp	DWORD PTR [esi+4], 0
	je	$LN87@xmlNanoFTP

; 860  : 
; 861  :     /*
; 862  :      * do the blocking DNS query.
; 863  :      */
; 864  :     if (proxy) {

	mov	eax, DWORD PTR _proxy
	push	edi

; 865  :         port = proxyPort;

	mov	edi, DWORD PTR _proxyPort
	test	eax, eax
	jne	SHORT $LN13@xmlNanoFTP

; 866  :     } else {
; 867  : 	port = ctxt->port;

	mov	edi, DWORD PTR [esi+8]
$LN13@xmlNanoFTP:

; 868  :     }
; 869  :     if (port == 0)

	test	edi, edi
	mov	ecx, 21					; 00000015H
	push	ebx
	cmove	edi, ecx

; 870  : 	port = 21;
; 871  : 
; 872  :     memset (&ctxt->ftpAddr, 0, sizeof(ctxt->ftpAddr));

	lea	ebx, DWORD PTR [esi+24]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ebx], xmm0

; 873  : 
; 874  : #ifdef SUPPORT_IP6
; 875  :     if (have_ipv6 ()) {
; 876  : 	struct addrinfo hints, *tmp, *result;
; 877  : 
; 878  : 	result = NULL;
; 879  : 	memset (&hints, 0, sizeof(hints));
; 880  : 	hints.ai_socktype = SOCK_STREAM;
; 881  : 
; 882  : 	if (proxy) {
; 883  : 	    if (getaddrinfo (proxy, NULL, &hints, &result) != 0) {
; 884  : 		__xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed");
; 885  : 		return (-1);
; 886  : 	    }
; 887  : 	}
; 888  : 	else
; 889  : 	    if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) {
; 890  : 		__xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed");
; 891  : 		return (-1);
; 892  : 	    }
; 893  : 
; 894  : 	for (tmp = result; tmp; tmp = tmp->ai_next)
; 895  : 	    if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6)
; 896  : 		break;
; 897  : 
; 898  : 	if (!tmp) {
; 899  : 	    if (result)
; 900  : 		freeaddrinfo (result);
; 901  : 	    __xmlIOErr(XML_FROM_FTP, 0, "getaddrinfo failed");
; 902  : 	    return (-1);
; 903  : 	}
; 904  : 	if ((size_t)tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) {
; 905  : 	    if (result)
; 906  : 		freeaddrinfo (result);
; 907  : 	    __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname address mismatch");
; 908  : 	    return (-1);
; 909  : 	}
; 910  : 	if (tmp->ai_family == AF_INET6) {
; 911  : 	    memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);
; 912  : 	    ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port);
; 913  : 	    ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0);
; 914  : 	}
; 915  : 	else {
; 916  : 	    memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);
; 917  : 	    ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port);
; 918  : 	    ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);
; 919  : 	}
; 920  : 	addrlen = tmp->ai_addrlen;
; 921  : 	freeaddrinfo (result);
; 922  :     }
; 923  :     else
; 924  : #endif
; 925  :     {
; 926  : 	if (proxy)

	test	eax, eax
	je	SHORT $LN15@xmlNanoFTP

; 927  : 	    hp = gethostbyname (GETHOSTBYNAME_ARG_CAST proxy);

	push	eax
	jmp	SHORT $LN97@xmlNanoFTP
$LN15@xmlNanoFTP:

; 928  : 	else
; 929  : 	    hp = gethostbyname (GETHOSTBYNAME_ARG_CAST ctxt->hostname);

	push	DWORD PTR [esi+4]
$LN97@xmlNanoFTP:

; 930  : 	if (hp == NULL) {

	call	DWORD PTR __imp__gethostbyname@4
	mov	ecx, eax
	test	ecx, ecx
	jne	SHORT $LN17@xmlNanoFTP

; 931  : 	    __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname failed");

	push	OFFSET ??_C@_0BF@FEIPFPME@gethostbyname?5failed@
	push	eax
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1220 : 	    return(-1);

	or	eax, -1
	pop	ebx
	pop	edi
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlNanoFTP:

; 932  : 	    return (-1);
; 933  : 	}
; 934  : 	if ((unsigned int) hp->h_length >

	cmp	WORD PTR [ecx+10], 4
	jbe	SHORT $LN18@xmlNanoFTP

; 935  : 	    sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) {
; 936  : 	    __xmlIOErr(XML_FROM_FTP, 0, "gethostbyname address mismatch");

	push	OFFSET ??_C@_0BP@HGBHAFPD@gethostbyname?5address?5mismatch@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1220 : 	    return(-1);

	or	eax, -1
	pop	ebx
	pop	edi
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlNanoFTP:

; 937  : 	    return (-1);
; 938  : 	}
; 939  : 
; 940  : 	/*
; 941  : 	 * Prepare the socket
; 942  : 	 */
; 943  : 	((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR [ebx], ax

; 944  : 	memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr,

	movsx	eax, WORD PTR [ecx+10]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR [esi+28]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 945  : 		hp->h_addr_list[0], hp->h_length);
; 946  : 	((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port =

	push	edi
	call	DWORD PTR __imp__htons@4

; 947  :              (unsigned short)htons ((unsigned short)port);
; 948  : 	ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);

	push	0
	push	1
	push	2
	mov	WORD PTR [esi+26], ax
	call	DWORD PTR __imp__socket@12
	mov	DWORD PTR [esi+44], eax

; 949  : 	addrlen = sizeof (struct sockaddr_in);
; 950  :     }
; 951  : 
; 952  :     if (ctxt->controlFd == INVALID_SOCKET) {

	cmp	eax, -1
	jne	SHORT $LN19@xmlNanoFTP

; 953  : 	__xmlIOErr(XML_FROM_FTP, 0, "socket failed");

	push	OFFSET ??_C@_0O@FPJGNADN@socket?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1220 : 	    return(-1);

	or	eax, -1
	pop	ebx
	pop	edi
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlNanoFTP:

; 954  :         return(-1);
; 955  :     }
; 956  : 
; 957  :     /*
; 958  :      * Do the connect.
; 959  :      */
; 960  :     if (connect(ctxt->controlFd, (struct sockaddr *) &ctxt->ftpAddr,
; 961  : 	    addrlen) < 0) {

	push	16					; 00000010H
	push	ebx
	push	eax
	call	DWORD PTR __imp__connect@12
	test	eax, eax
	jns	SHORT $LN20@xmlNanoFTP

; 962  : 	__xmlIOErr(XML_FROM_FTP, 0, "Failed to create a connection");

	push	OFFSET ??_C@_0BO@NKBHOJOC@Failed?5to?5create?5a?5connection@
	push	0

; 963  :         closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 964  :         ctxt->controlFd = INVALID_SOCKET;
; 965  : 	return(-1);

	jmp	$LN98@xmlNanoFTP
$LN20@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 966  :     }
; 967  : 
; 968  :     /*
; 969  :      * Wait for the HELLO from the server.
; 970  :      */
; 971  :     res = xmlNanoFTPGetResponse(ctxt);
; 972  :     if (res != 2) {

	cmp	eax, 2
	jne	$LN58@xmlNanoFTP

; 973  :         closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 974  :         ctxt->controlFd = INVALID_SOCKET;
; 975  : 	return(-1);
; 976  :     }
; 977  : 
; 978  :     /*
; 979  :      * State diagram for the login operation on the FTP server
; 980  :      *
; 981  :      * Reference: RFC 959
; 982  :      *
; 983  :      *                       1
; 984  :      * +---+   USER    +---+------------->+---+
; 985  :      * | B |---------->| W | 2       ---->| E |
; 986  :      * +---+           +---+------  |  -->+---+
; 987  :      *                  | |       | | |
; 988  :      *                3 | | 4,5   | | |
; 989  :      *    --------------   -----  | | |
; 990  :      *   |                      | | | |
; 991  :      *   |                      | | | |
; 992  :      *   |                 ---------  |
; 993  :      *   |               1|     | |   |
; 994  :      *   V                |     | |   |
; 995  :      * +---+   PASS    +---+ 2  |  ------>+---+
; 996  :      * |   |---------->| W |------------->| S |
; 997  :      * +---+           +---+   ---------->+---+
; 998  :      *                  | |   | |     |
; 999  :      *                3 | |4,5| |     |
; 1000 :      *    --------------   --------   |
; 1001 :      *   |                    | |  |  |
; 1002 :      *   |                    | |  |  |
; 1003 :      *   |                 -----------
; 1004 :      *   |             1,3|   | |  |
; 1005 :      *   V                |  2| |  |
; 1006 :      * +---+   ACCT    +---+--  |   ----->+---+
; 1007 :      * |   |---------->| W | 4,5 -------->| F |
; 1008 :      * +---+           +---+------------->+---+
; 1009 :      *
; 1010 :      * Of course in case of using a proxy this get really nasty and is not
; 1011 :      * standardized at all :-(
; 1012 :      */
; 1013 :     if (proxy) {

	cmp	DWORD PTR _proxy, 0
	mov	ebx, DWORD PTR __imp__send@16
	je	$LN4@xmlNanoFTP

; 1014 :         int len;
; 1015 : 	char buf[400];
; 1016 : 
; 1017 :         if (proxyUser != NULL) {

	mov	eax, DWORD PTR _proxyUser
	test	eax, eax
	je	$LN31@xmlNanoFTP

; 1018 : 	    /*
; 1019 : 	     * We need proxy auth
; 1020 : 	     */
; 1021 : 	    snprintf(buf, sizeof(buf), "USER %s\r\n", proxyUser);

	push	eax
	push	OFFSET ??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf

; 1022 :             buf[sizeof(buf) - 1] = 0;
; 1023 :             len = strlen(buf);

	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+399], 0
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
	npad	3
$LL88@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL88@xmlNanoFTP

; 1024 : #ifdef DEBUG_FTP
; 1025 : 	    xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1026 : #endif
; 1027 : 	    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx
	mov	edi, eax

; 1028 : 	    if (res < 0) {

	test	edi, edi
	js	$LN100@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1029 : 		__xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1030 : 		closesocket(ctxt->controlFd);
; 1031 : 		ctxt->controlFd = INVALID_SOCKET;
; 1032 : 	        return(res);
; 1033 : 	    }
; 1034 : 	    res = xmlNanoFTPGetResponse(ctxt);
; 1035 : 	    switch (res) {

	sub	eax, 1
	je	$LN31@xmlNanoFTP
	sub	eax, 1
	je	SHORT $LN25@xmlNanoFTP
	sub	eax, 1
	jne	$LN58@xmlNanoFTP

; 1038 : 			break;
; 1039 :                     /* Falls through. */
; 1040 : 		case 3:
; 1041 : 		    if (proxyPasswd != NULL)

	mov	eax, DWORD PTR _proxyPasswd
	test	eax, eax
	jne	SHORT $LN86@xmlNanoFTP

; 1043 : 		    else
; 1044 : 			snprintf(buf, sizeof(buf), "PASS anonymous@\r\n");

	push	OFFSET ??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN29@xmlNanoFTP
$LN25@xmlNanoFTP:

; 1036 : 		case 2:
; 1037 : 		    if (proxyPasswd == NULL)

	mov	eax, DWORD PTR _proxyPasswd
	test	eax, eax
	je	SHORT $LN31@xmlNanoFTP
$LN86@xmlNanoFTP:

; 1042 : 			snprintf(buf, sizeof(buf), "PASS %s\r\n", proxyPasswd);

	push	eax
	push	OFFSET ??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN29@xmlNanoFTP:

; 1045 :                     buf[sizeof(buf) - 1] = 0;
; 1046 :                     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+399], 0
	lea	edx, DWORD PTR [ecx+1]
$LL89@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL89@xmlNanoFTP

; 1047 : #ifdef DEBUG_FTP
; 1048 : 		    xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1049 : #endif
; 1050 : 		    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx
	mov	edi, eax

; 1051 : 		    if (res < 0) {

	test	edi, edi
	js	$LN100@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1052 : 			__xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1053 : 			closesocket(ctxt->controlFd);
; 1054 : 			ctxt->controlFd = INVALID_SOCKET;
; 1055 : 			return(res);
; 1056 : 		    }
; 1057 : 		    res = xmlNanoFTPGetResponse(ctxt);
; 1058 : 		    if (res > 3) {

	cmp	eax, 3
	jg	$LN58@xmlNanoFTP
$LN31@xmlNanoFTP:

; 1059 : 			closesocket(ctxt->controlFd);
; 1060 : 			ctxt->controlFd = INVALID_SOCKET;
; 1061 : 			return(-1);
; 1062 : 		    }
; 1063 : 		    break;
; 1064 : 		case 1:
; 1065 : 		    break;
; 1066 : 		case 4:
; 1067 : 		case 5:
; 1068 : 		case -1:
; 1069 : 		default:
; 1070 : 		    closesocket(ctxt->controlFd);
; 1071 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1072 : 		    return(-1);
; 1073 : 	    }
; 1074 : 	}
; 1075 : 
; 1076 : 	/*
; 1077 : 	 * We assume we don't need more authentication to the proxy
; 1078 : 	 * and that it succeeded :-\
; 1079 : 	 */
; 1080 : 	switch (proxyType) {

	mov	eax, DWORD PTR _proxyType
	test	eax, eax
	js	$LN58@xmlNanoFTP
	cmp	eax, 1
	jle	SHORT $LN34@xmlNanoFTP
	cmp	eax, 2
	je	$LN37@xmlNanoFTP
	jmp	$LN58@xmlNanoFTP
$LN34@xmlNanoFTP:

; 1081 : 	    case 0:
; 1082 : 		/* we will try in sequence */
; 1083 : 	    case 1:
; 1084 : 		/* Using SITE command */
; 1085 : 		snprintf(buf, sizeof(buf), "SITE %s\r\n", ctxt->hostname);

	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _buf$1[ebp]
	push	OFFSET ??_C@_09HOAIGJJF@SITE?5?$CFs?$AN?6@
	push	400					; 00000190H
	push	eax
	call	_snprintf

; 1086 :                 buf[sizeof(buf) - 1] = 0;
; 1087 :                 len = strlen(buf);

	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+399], 0
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [ecx+1]
$LL90@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL90@xmlNanoFTP

; 1088 : #ifdef DEBUG_FTP
; 1089 : 		xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1090 : #endif
; 1091 : 		res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx
	mov	edi, eax

; 1092 : 		if (res < 0) {

	test	edi, edi
	js	$LN100@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1093 : 		    __xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1094 : 		    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1095 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1096 : 		    return(res);
; 1097 : 		}
; 1098 : 		res = xmlNanoFTPGetResponse(ctxt);
; 1099 : 		if (res == 2) {

	cmp	eax, 2
	jne	SHORT $LN36@xmlNanoFTP

; 1100 : 		    /* we assume it worked :-\ 1 is error for SITE command */
; 1101 : 		    proxyType = 1;

	mov	DWORD PTR _proxyType, 1
$LN4@xmlNanoFTP:

; 763  :     if (ctxt->user == NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jne	$LN73@xmlNanoFTP

; 764  : 	snprintf(buf, sizeof(buf), "USER anonymous\r\n");

	push	OFFSET ??_C@_0BB@PKBEHKHF@USER?5anonymous?$AN?6@
	lea	eax, DWORD PTR _buf$3[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	$LN74@xmlNanoFTP
$LN36@xmlNanoFTP:

; 1102 : 		    break;
; 1103 : 		}
; 1104 : 		if (proxyType == 1) {

	cmp	DWORD PTR _proxyType, 1
	je	$LN58@xmlNanoFTP
$LN37@xmlNanoFTP:

; 1105 : 		    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1106 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1107 : 		    return(-1);
; 1108 : 		}
; 1109 :                 /* Falls through. */
; 1110 : 	    case 2:
; 1111 : 		/* USER user@host command */
; 1112 : 		if (ctxt->user == NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+16]
	push	eax
	lea	eax, DWORD PTR _buf$1[ebp]
	test	ecx, ecx
	jne	SHORT $LN39@xmlNanoFTP

; 1113 : 		    snprintf(buf, sizeof(buf), "USER anonymous@%s\r\n",

	push	OFFSET ??_C@_0BE@OGNKDKIM@USER?5anonymous?$EA?$CFs?$AN?6@
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN40@xmlNanoFTP
$LN39@xmlNanoFTP:

; 1114 : 			           ctxt->hostname);
; 1115 : 		else
; 1116 : 		    snprintf(buf, sizeof(buf), "USER %s@%s\r\n",

	push	ecx
	push	OFFSET ??_C@_0N@NGBGKMKP@USER?5?$CFs?$EA?$CFs?$AN?6@
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
$LN40@xmlNanoFTP:

; 1117 : 			           ctxt->user, ctxt->hostname);
; 1118 :                 buf[sizeof(buf) - 1] = 0;
; 1119 :                 len = strlen(buf);

	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+399], 0
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL91@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL91@xmlNanoFTP

; 1120 : #ifdef DEBUG_FTP
; 1121 : 		xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1122 : #endif
; 1123 : 		res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx
	mov	edi, eax

; 1124 : 		if (res < 0) {

	test	edi, edi
	js	$LN100@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1125 : 		    __xmlIOErr(XML_FROM_FTP, 0, "send failed");
; 1126 : 		    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1127 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1128 : 		    return(res);
; 1129 : 		}
; 1130 : 		res = xmlNanoFTPGetResponse(ctxt);
; 1131 : 		if ((res == 1) || (res == 2)) {

	cmp	eax, 1
	je	$LN43@xmlNanoFTP
	cmp	eax, 2
	je	$LN43@xmlNanoFTP

; 1135 : 		}
; 1136 : 		if (ctxt->passwd == NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN44@xmlNanoFTP

; 1137 : 		    snprintf(buf, sizeof(buf), "PASS anonymous@\r\n");

	push	OFFSET ??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN45@xmlNanoFTP
$LN44@xmlNanoFTP:

; 1138 : 		else
; 1139 : 		    snprintf(buf, sizeof(buf), "PASS %s\r\n", ctxt->passwd);

	push	eax
	push	OFFSET ??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	400					; 00000190H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN45@xmlNanoFTP:

; 1140 :                 buf[sizeof(buf) - 1] = 0;
; 1141 :                 len = strlen(buf);

	lea	ecx, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+399], 0
	lea	edx, DWORD PTR [ecx+1]
$LL92@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL92@xmlNanoFTP

; 1142 : #ifdef DEBUG_FTP
; 1143 : 		xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 1144 : #endif
; 1145 : 		res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$1[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx
	mov	edi, eax

; 1146 : 		if (res < 0) {

	test	edi, edi
	jns	SHORT $LN46@xmlNanoFTP
$LN100@xmlNanoFTP:

; 1147 : 		    __xmlIOErr(XML_FROM_FTP, 0, "send failed");

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1148 : 		    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__closesocket@4
	pop	ebx

; 1149 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1150 : 		    return(res);

	mov	eax, edi
	mov	DWORD PTR [esi+44], -1
	pop	edi
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1151 : 		}
; 1152 : 		res = xmlNanoFTPGetResponse(ctxt);
; 1153 : 		if ((res == 1) || (res == 2)) {

	cmp	eax, 1
	je	SHORT $LN43@xmlNanoFTP
	cmp	eax, 2
	jne	$LN58@xmlNanoFTP
$LN43@xmlNanoFTP:

; 1132 : 		    /* we assume it worked :-\ */
; 1133 : 		    proxyType = 2;

	mov	DWORD PTR _proxyType, 2
$LN52@xmlNanoFTP:
	pop	ebx
	pop	edi

; 1134 : 		    return(0);

	xor	eax, eax
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlNanoFTP:

; 766  : 	snprintf(buf, sizeof(buf), "USER %s\r\n", ctxt->user);

	push	eax
	push	OFFSET ??_C@_09FIJAECMI@USER?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$3[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN74@xmlNanoFTP:

; 767  :     buf[sizeof(buf) - 1] = 0;
; 768  :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$3[ebp]
	mov	BYTE PTR _buf$3[ebp+199], 0
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL93@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL93@xmlNanoFTP

; 769  : #ifdef DEBUG_FTP
; 770  :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 771  : #endif
; 772  :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$3[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx

; 773  :     if (res < 0) {

	test	eax, eax
	js	$LN101@xmlNanoFTP

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1154 : 		    /* we assume it worked :-\ */
; 1155 : 		    proxyType = 2;
; 1156 : 		    return(0);
; 1157 : 		}
; 1158 : 		if (proxyType == 2) {
; 1159 : 		    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1160 : 		    ctxt->controlFd = INVALID_SOCKET;
; 1161 : 		    return(-1);
; 1162 : 		}
; 1163 :                 /* Falls through. */
; 1164 : 	    case 3:
; 1165 : 		/*
; 1166 : 		 * If you need support for other Proxy authentication scheme
; 1167 : 		 * send the code or at least the sequence in use.
; 1168 : 		 */
; 1169 : 	    default:
; 1170 : 		closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1171 : 		ctxt->controlFd = INVALID_SOCKET;
; 1172 : 		return(-1);
; 1173 : 	}
; 1174 :     }
; 1175 :     /*
; 1176 :      * Non-proxy handling.
; 1177 :      */
; 1178 :     res = xmlNanoFTPSendUser(ctxt);
; 1179 :     if (res < 0) {
; 1180 :         closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1181 :         ctxt->controlFd = INVALID_SOCKET;
; 1182 : 	return(-1);
; 1183 :     }
; 1184 :     res = xmlNanoFTPGetResponse(ctxt);
; 1185 :     switch (res) {

	sub	eax, 2
	je	SHORT $LN52@xmlNanoFTP
	sub	eax, 1
	jne	$LN58@xmlNanoFTP

; 791  :     if (ctxt->passwd == NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN80@xmlNanoFTP

; 792  : 	snprintf(buf, sizeof(buf), "PASS anonymous@\r\n");

	push	OFFSET ??_C@_0BC@JNJBALOJ@PASS?5anonymous?$EA?$AN?6@
	lea	eax, DWORD PTR _buf$2[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN81@xmlNanoFTP
$LN80@xmlNanoFTP:

; 793  :     else
; 794  : 	snprintf(buf, sizeof(buf), "PASS %s\r\n", ctxt->passwd);

	push	eax
	push	OFFSET ??_C@_09CACMNAGD@PASS?5?$CFs?$AN?6@
	lea	eax, DWORD PTR _buf$2[ebp]
	push	200					; 000000c8H
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN81@xmlNanoFTP:

; 795  :     buf[sizeof(buf) - 1] = 0;
; 796  :     len = strlen(buf);

	lea	ecx, DWORD PTR _buf$2[ebp]
	mov	BYTE PTR _buf$2[ebp+199], 0
	lea	edx, DWORD PTR [ecx+1]
$LL94@xmlNanoFTP:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL94@xmlNanoFTP

; 797  : #ifdef DEBUG_FTP
; 798  :     xmlGenericError(xmlGenericErrorContext, "%s", buf);
; 799  : #endif
; 800  :     res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);

	push	0
	sub	ecx, edx
	lea	eax, DWORD PTR _buf$2[ebp]
	push	ecx
	push	eax
	push	DWORD PTR [esi+44]
	call	ebx

; 801  :     if (res < 0) {

	test	eax, eax
	jns	SHORT $LN55@xmlNanoFTP
$LN101@xmlNanoFTP:

; 1207 : 	case 2:
; 1208 : 	    break;
; 1209 : 	case 3:
; 1210 : 	    __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,

	push	OFFSET ??_C@_0M@EADLIJBM@send?5failed@
	push	0
	jmp	SHORT $LN98@xmlNanoFTP
$LN55@xmlNanoFTP:

; 716  :     res = xmlNanoFTPReadResponse(ctx);

	push	esi
	call	_xmlNanoFTPReadResponse
	add	esp, 4

; 1186 : 	case 2:
; 1187 : 	    return(0);
; 1188 : 	case 3:
; 1189 : 	    break;
; 1190 : 	case 1:
; 1191 : 	case 4:
; 1192 : 	case 5:
; 1193 :         case -1:
; 1194 : 	default:
; 1195 : 	    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1196 : 	    ctxt->controlFd = INVALID_SOCKET;
; 1197 : 	    return(-1);
; 1198 :     }
; 1199 :     res = xmlNanoFTPSendPasswd(ctxt);
; 1200 :     if (res < 0) {
; 1201 :         closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;
; 1202 :         ctxt->controlFd = INVALID_SOCKET;
; 1203 : 	return(-1);
; 1204 :     }
; 1205 :     res = xmlNanoFTPGetResponse(ctxt);
; 1206 :     switch (res) {

	sub	eax, 2
	je	$LN52@xmlNanoFTP
	sub	eax, 1
	jne	SHORT $LN58@xmlNanoFTP

; 1207 : 	case 2:
; 1208 : 	    break;
; 1209 : 	case 3:
; 1210 : 	    __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,

	push	OFFSET ??_C@_0CK@GIDKJDCD@FTP?5server?5asking?5for?5ACCNT?5on?5@
	push	2002					; 000007d2H
$LN98@xmlNanoFTP:
	push	9
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN58@xmlNanoFTP:

; 1211 : 		       "FTP server asking for ACCNT on anonymous\n");
; 1212 :            /* Falls through. */
; 1213 : 	case 1:
; 1214 : 	case 4:
; 1215 : 	case 5:
; 1216 :         case -1:
; 1217 : 	default:
; 1218 : 	    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;

	push	DWORD PTR [esi+44]
	call	DWORD PTR __imp__closesocket@4
	pop	ebx
	pop	edi

; 1219 : 	    ctxt->controlFd = INVALID_SOCKET;

	mov	DWORD PTR [esi+44], -1

; 1220 : 	    return(-1);

	or	eax, -1
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@xmlNanoFTP:

; 859  : 	return(-1);

	or	eax, -1
	pop	esi

; 1221 :     }
; 1222 : 
; 1223 :     return(0);
; 1224 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPConnect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPOpen
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNanoFTPOpen PROC					; COMDAT

; 1999 : xmlNanoFTPOpen(const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlNanoFTPInit
	mov	esi, DWORD PTR _URL$[ebp]
	test	esi, esi
	je	SHORT $LN9@xmlNanoFTP

; 2000 :     xmlNanoFTPCtxtPtr ctxt;
; 2001 :     SOCKET sock;
; 2002 : 
; 2003 :     xmlNanoFTPInit();
; 2004 :     if (URL == NULL) return(NULL);
; 2005 :     if (strncmp("ftp://", URL, 6)) return(NULL);

	push	6
	push	esi
	push	OFFSET ??_C@_06FNAPNHDD@ftp?3?1?1@
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@xmlNanoFTP

; 2006 : 
; 2007 :     ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(URL);

	push	esi
	call	_xmlNanoFTPNewCtxt
	mov	esi, eax
	add	esp, 4

; 2008 :     if (ctxt == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN9@xmlNanoFTP

; 2009 :     if (xmlNanoFTPConnect(ctxt) < 0) {

	push	esi
	call	_xmlNanoFTPConnect
	add	esp, 4
	test	eax, eax
	js	SHORT $LN8@xmlNanoFTP

; 2010 : 	xmlNanoFTPFreeCtxt(ctxt);
; 2011 : 	return(NULL);
; 2012 :     }
; 2013 :     sock = xmlNanoFTPGetSocket(ctxt, ctxt->path);

	push	DWORD PTR [esi+12]
	push	esi
	call	_xmlNanoFTPGetSocket
	add	esp, 8

; 2014 :     if (sock == INVALID_SOCKET) {

	cmp	eax, -1
	je	SHORT $LN8@xmlNanoFTP

; 2016 : 	return(NULL);
; 2017 :     }
; 2018 :     return(ctxt);

	mov	eax, esi
	pop	esi

; 2019 : }

	pop	ebp
	ret	0
$LN8@xmlNanoFTP:

; 2015 : 	xmlNanoFTPFreeCtxt(ctxt);

	push	esi
	call	_xmlNanoFTPFreeCtxt
	add	esp, 4
$LN9@xmlNanoFTP:

; 2019 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlNanoFTPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPConnectTo
_TEXT	SEGMENT
_server$ = 8						; size = 4
_port$ = 12						; size = 4
_xmlNanoFTPConnectTo PROC				; COMDAT

; 1237 : xmlNanoFTPConnectTo(const char *server, int port) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlNanoFTPInit
	cmp	DWORD PTR _server$[ebp], 0
	je	SHORT $LN10@xmlNanoFTP

; 1238 :     xmlNanoFTPCtxtPtr ctxt;
; 1239 :     int res;
; 1240 : 
; 1241 :     xmlNanoFTPInit();
; 1242 :     if (server == NULL)
; 1243 : 	return(NULL);
; 1244 :     if (port <= 0)

	mov	edi, DWORD PTR _port$[ebp]
	test	edi, edi
	jle	SHORT $LN10@xmlNanoFTP

; 1245 : 	return(NULL);
; 1246 :     ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(NULL);

	push	0
	call	_xmlNanoFTPNewCtxt
	mov	esi, eax
	add	esp, 4

; 1247 :     if (ctxt == NULL)

	test	esi, esi
	je	SHORT $LN10@xmlNanoFTP

; 1248 :         return(NULL);
; 1249 :     ctxt->hostname = xmlMemStrdup(server);

	push	DWORD PTR _server$[ebp]
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 1250 :     if (ctxt->hostname == NULL) {

	test	eax, eax
	je	SHORT $LN9@xmlNanoFTP

; 1251 : 	xmlNanoFTPFreeCtxt(ctxt);
; 1252 : 	return(NULL);
; 1253 :     }
; 1254 :     if (port != 0)
; 1255 : 	ctxt->port = port;
; 1256 :     res = xmlNanoFTPConnect(ctxt);

	push	esi
	mov	DWORD PTR [esi+8], edi
	call	_xmlNanoFTPConnect
	add	esp, 4

; 1257 :     if (res < 0) {

	test	eax, eax
	js	SHORT $LN9@xmlNanoFTP

; 1259 : 	return(NULL);
; 1260 :     }
; 1261 :     return(ctxt);

	pop	edi
	mov	eax, esi

; 1262 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlNanoFTP:

; 1258 : 	xmlNanoFTPFreeCtxt(ctxt);

	push	esi
	call	_xmlNanoFTPFreeCtxt
	add	esp, 4
$LN10@xmlNanoFTP:

; 1262 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlNanoFTPConnectTo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPFreeCtxt
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlNanoFTPFreeCtxt PROC				; COMDAT

; 500  : xmlNanoFTPFreeCtxt(void * ctx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctx$[ebp]
	test	esi, esi
	je	$LN1@xmlNanoFTP

; 501  :     xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;
; 502  :     if (ctxt == NULL) return;
; 503  :     if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@xmlNanoFTP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlNanoFTP:

; 504  :     if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@xmlNanoFTP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlNanoFTP:

; 505  :     if (ctxt->path != NULL) xmlFree(ctxt->path);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@xmlNanoFTP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlNanoFTP:

; 506  :     if (ctxt->user != NULL) xmlFree(ctxt->user);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@xmlNanoFTP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNanoFTP:

; 507  :     if (ctxt->passwd != NULL) xmlFree(ctxt->passwd);

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN7@xmlNanoFTP
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlNanoFTP:

; 508  :     ctxt->passive = 1;
; 509  :     if (ctxt->controlFd != INVALID_SOCKET) closesocket(ctxt->controlFd);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+40], 1
	cmp	eax, -1
	je	SHORT $LN8@xmlNanoFTP
	push	eax
	call	DWORD PTR __imp__closesocket@4
$LN8@xmlNanoFTP:

; 510  :     ctxt->controlFd = INVALID_SOCKET;
; 511  :     ctxt->controlBufIndex = -1;
; 512  :     ctxt->controlBufUsed = -1;
; 513  :     xmlFree(ctxt);

	push	esi
	mov	DWORD PTR [esi+44], -1
	mov	DWORD PTR [esi+1088], -1
	mov	DWORD PTR [esi+1092], -1
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlNanoFTP:
	pop	esi

; 514  : }

	pop	ebp
	ret	0
_xmlNanoFTPFreeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPNewCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNanoFTPNewCtxt PROC					; COMDAT

; 464  : xmlNanoFTPNewCtxt(const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1100					; 0000044cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNanoFTP

; 168  :     __xmlSimpleError(XML_FROM_FTP, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BH@FLMMHHFH@allocating?5FTP?5context@
	push	eax
	push	eax
	push	2
	push	9
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 465  :     xmlNanoFTPCtxtPtr ret;
; 466  :     char *unescaped;
; 467  : 
; 468  :     ret = (xmlNanoFTPCtxtPtr) xmlMalloc(sizeof(xmlNanoFTPCtxt));
; 469  :     if (ret == NULL) {
; 470  :         xmlFTPErrMemory("allocating FTP context");
; 471  :         return(NULL);

	xor	eax, eax
	pop	esi

; 490  : }

	pop	ebp
	ret	0
$LN2@xmlNanoFTP:
	push	ebx
	push	edi

; 472  :     }
; 473  : 
; 474  :     memset(ret, 0, sizeof(xmlNanoFTPCtxt));

	push	1100					; 0000044cH
	push	0
	push	esi
	call	_memset

; 475  :     ret->port = 21;
; 476  :     ret->passive = 1;
; 477  :     ret->returnValue = 0;
; 478  :     ret->controlBufIndex = 0;
; 479  :     ret->controlBufUsed = 0;
; 480  :     ret->controlFd = INVALID_SOCKET;
; 481  : 
; 482  :     unescaped = xmlURIUnescapeString(URL, 0, NULL);

	mov	edi, DWORD PTR _URL$[ebp]
	push	0
	push	0
	push	edi
	mov	DWORD PTR [esi+8], 21			; 00000015H
	mov	DWORD PTR [esi+40], 1
	mov	DWORD PTR [esi+44], -1
	call	_xmlURIUnescapeString
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 483  :     if (unescaped != NULL) {

	test	ebx, ebx
	je	SHORT $LN3@xmlNanoFTP

; 484  : 	xmlNanoFTPScanURL(ret, unescaped);

	push	ebx
	push	esi
	call	_xmlNanoFTPScanURL

; 485  : 	xmlFree(unescaped);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 488  : 
; 489  :     return(ret);

	mov	eax, esi
	pop	edi
	pop	ebx
	pop	esi

; 490  : }

	pop	ebp
	ret	0
$LN3@xmlNanoFTP:

; 486  :     } else if (URL != NULL)

	test	edi, edi
	je	SHORT $LN5@xmlNanoFTP

; 487  : 	xmlNanoFTPScanURL(ret, URL);

	push	edi
	push	esi
	call	_xmlNanoFTPScanURL
	add	esp, 8
$LN5@xmlNanoFTP:

; 488  : 
; 489  :     return(ret);

	pop	edi
	pop	ebx
	mov	eax, esi
	pop	esi

; 490  : }

	pop	ebp
	ret	0
_xmlNanoFTPNewCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPCleanup
_TEXT	SEGMENT
_xmlNanoFTPCleanup PROC					; COMDAT
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _proxy
	test	eax, eax
	je	SHORT $LN2@xmlNanoFTP

; 226  :     if (proxy != NULL) {
; 227  : 	xmlFree(proxy);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 228  : 	proxy = NULL;

	mov	DWORD PTR _proxy, 0
$LN2@xmlNanoFTP:

; 229  :     }
; 230  :     if (proxyUser != NULL) {

	mov	eax, DWORD PTR _proxyUser
	test	eax, eax
	je	SHORT $LN3@xmlNanoFTP

; 231  : 	xmlFree(proxyUser);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 232  : 	proxyUser = NULL;

	mov	DWORD PTR _proxyUser, 0
$LN3@xmlNanoFTP:

; 233  :     }
; 234  :     if (proxyPasswd != NULL) {

	mov	eax, DWORD PTR _proxyPasswd
	test	eax, eax
	je	SHORT $LN4@xmlNanoFTP

; 235  : 	xmlFree(proxyPasswd);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 236  : 	proxyPasswd = NULL;

	mov	DWORD PTR _proxyPasswd, 0
$LN4@xmlNanoFTP:

; 237  :     }
; 238  : #ifdef _WINSOCKAPI_
; 239  :     if (initialized)

	cmp	DWORD PTR _initialized, 0
	je	SHORT $LN7@xmlNanoFTP

; 240  : 	WSACleanup();

	call	DWORD PTR __imp__WSACleanup@0
$LN7@xmlNanoFTP:

; 241  : #endif
; 242  :     initialized = 0;
; 243  : }

	mov	DWORD PTR _initialized, 0
	ret	0
_xmlNanoFTPCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\nanoftp.c
;	COMDAT _xmlNanoFTPInit
_TEXT	SEGMENT
_wsaData$ = -400					; size = 400
_xmlNanoFTPInit PROC					; COMDAT

; 180  : xmlNanoFTPInit(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	ecx, OFFSET __D3ED00D9_nanoftp@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _initialized, 0
	jne	$LN1@xmlNanoFTP

; 181  :     const char *env;
; 182  : #ifdef _WINSOCKAPI_
; 183  :     WSADATA wsaData;
; 184  : #endif
; 185  : 
; 186  :     if (initialized)
; 187  : 	return;
; 188  : 
; 189  : #ifdef _WINSOCKAPI_
; 190  :     if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	push	257					; 00000101H
	call	DWORD PTR __imp__WSAStartup@8
	test	eax, eax
	jne	$LN1@xmlNanoFTP

; 191  : 	return;
; 192  : #endif
; 193  : 
; 194  :     proxyPort = 21;

	push	esi

; 195  :     env = getenv("no_proxy");

	mov	esi, DWORD PTR __imp__getenv
	push	OFFSET ??_C@_08BOGLDIEC@no_proxy@
	mov	DWORD PTR _proxyPort, 21		; 00000015H
	call	esi
	add	esp, 4

; 196  :     if (env && ((env[0] == '*' ) && (env[1] == 0)))

	test	eax, eax
	je	SHORT $LN4@xmlNanoFTP
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	SHORT $LN4@xmlNanoFTP
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN11@xmlNanoFTP
$LN4@xmlNanoFTP:

; 197  : 	return;
; 198  :     env = getenv("ftp_proxy");

	push	OFFSET ??_C@_09FLGENLMF@ftp_proxy@
	call	esi
	add	esp, 4

; 199  :     if (env != NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlNanoFTP

; 200  : 	xmlNanoFTPScanProxy(env);
; 201  :     } else {
; 202  : 	env = getenv("FTP_PROXY");

	push	OFFSET ??_C@_09KECINPKO@FTP_PROXY@
	call	esi
	add	esp, 4

; 203  : 	if (env != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlNanoFTP
$LN12@xmlNanoFTP:

; 204  : 	    xmlNanoFTPScanProxy(env);
; 205  : 	}
; 206  :     }
; 207  :     env = getenv("ftp_proxy_user");

	push	eax
	call	_xmlNanoFTPScanProxy
	add	esp, 4
$LN7@xmlNanoFTP:
	push	OFFSET ??_C@_0P@CAEEHGAA@ftp_proxy_user@
	call	esi
	add	esp, 4

; 208  :     if (env != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlNanoFTP

; 209  : 	proxyUser = xmlMemStrdup(env);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR _proxyUser, eax
$LN8@xmlNanoFTP:

; 210  :     }
; 211  :     env = getenv("ftp_proxy_password");

	push	OFFSET ??_C@_0BD@DKAPHOHE@ftp_proxy_password@
	call	esi
	add	esp, 4

; 212  :     if (env != NULL) {

	test	eax, eax
	je	SHORT $LN9@xmlNanoFTP

; 213  : 	proxyPasswd = xmlMemStrdup(env);

	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR _proxyPasswd, eax
$LN9@xmlNanoFTP:

; 214  :     }
; 215  :     initialized = 1;

	mov	DWORD PTR _initialized, 1
$LN11@xmlNanoFTP:
	pop	esi
$LN1@xmlNanoFTP:

; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNanoFTPInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 2176 :         return __stdio_common_vsscanf(

	call	___local_stdio_scanf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);
; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2275 :         __crt_va_end(_ArgList);
; 2276 :         return _Result;

	pop	esi

; 2277 :     }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_scanf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2176 :         return __stdio_common_vsscanf(
; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
