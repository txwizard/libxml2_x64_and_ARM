; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\error.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__67926DEE_error@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_xmlSetGenericErrorFunc
PUBLIC	_initGenericErrorDefaultFunc
PUBLIC	_xmlSetStructuredErrorFunc
PUBLIC	_xmlParserError
PUBLIC	_xmlParserWarning
PUBLIC	_xmlParserValidityError
PUBLIC	_xmlParserValidityWarning
PUBLIC	_xmlParserPrintFileInfo
PUBLIC	_xmlParserPrintFileContext
PUBLIC	_xmlGetLastError
PUBLIC	_xmlResetLastError
PUBLIC	_xmlCtxtGetLastError
PUBLIC	_xmlCtxtResetLastError
PUBLIC	_xmlResetError
PUBLIC	_xmlCopyError
PUBLIC	___xmlRaiseError
PUBLIC	___xmlSimpleError
PUBLIC	_xmlGenericErrorDefaultFunc
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@		; `string'
PUBLIC	??_C@_0BC@FMCMLLAH@Entity?3?5line?5?$CFd?3?5@	; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0N@MLFICIIN@element?5?$CFs?3?5@		; `string'
PUBLIC	??_C@_07CNNNFPCP@parser?5@			; `string'
PUBLIC	??_C@_0L@BNCDLIEB@namespace?5@			; `string'
PUBLIC	??_C@_09BIOOFDLF@validity?5@			; `string'
PUBLIC	??_C@_0N@IENDNEBE@HTML?5parser?5@		; `string'
PUBLIC	??_C@_07KICHBFMM@memory?5@			; `string'
PUBLIC	??_C@_07NOLKHGJF@output?5@			; `string'
PUBLIC	??_C@_04HKCNGDON@I?1O?5@			; `string'
PUBLIC	??_C@_09JKGAONDL@XInclude?5@			; `string'
PUBLIC	??_C@_06ONGIFIKK@XPath?5@			; `string'
PUBLIC	??_C@_07IGPLNGGH@regexp?5@			; `string'
PUBLIC	??_C@_07KEPCOONB@module?5@			; `string'
PUBLIC	??_C@_0BC@MEEJMAME@Schemas?5validity?5@		; `string'
PUBLIC	??_C@_0BA@COGPIGL@Schemas?5parser?5@		; `string'
PUBLIC	??_C@_0BB@FGPKBGBA@Relax?9NG?5parser?5@		; `string'
PUBLIC	??_C@_0BD@EPDAPLJK@Relax?9NG?5validity?5@	; `string'
PUBLIC	??_C@_08NOLMNIGP@Catalog?5@			; `string'
PUBLIC	??_C@_05MLHJFMDG@C14N?5@			; `string'
PUBLIC	??_C@_05POKACEJG@XSLT?5@			; `string'
PUBLIC	??_C@_09JICCLIJI@encoding?5@			; `string'
PUBLIC	??_C@_0M@LAKDBFM@schematron?5@			; `string'
PUBLIC	??_C@_0BB@FACNAIAH@internal?5buffer?5@		; `string'
PUBLIC	??_C@_04ECOFBNJN@URI?5@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_0L@HNPIBIGM@warning?5?3?5@		; `string'
PUBLIC	??_C@_08PMHKJNKP@error?5?3?5@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BE@LHHHBFLE@out?5of?5memory?5error@	; `string'
PUBLIC	??_C@_08JJLLLDHF@?$CFs?3?$CFd?3?5?6@		; `string'
PUBLIC	??_C@_0BD@GENHFBJC@Entity?3?5line?5?$CFd?3?5?6@	; `string'
PUBLIC	??_C@_0BK@ONMNHCCC@No?5error?5message?5provided@ ; `string'
PUBLIC	??_C@_04CMBCJJJD@href@				; `string'
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_07FJOHCPOO@error?3?5@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_09GFHECBDK@warning?3?5@			; `string'
PUBLIC	??_C@_0BB@DJCEBDOI@validity?5error?3?5@		; `string'
PUBLIC	??_C@_0BD@BMEBJKPI@validity?5warning?3?5@	; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_xmlGetLineNo:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	___xmlLastError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlStructuredError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlStructuredErrorContext:PROC
EXTRN	___xmlGetWarningsDefaultValue:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?had_info@?1??xmlParserValidityError@@9@9 DD 01H DUP (?) ; `xmlParserValidityError'::`2'::had_info
_BSS	ENDS
;	COMDAT ??_C@_0BD@BMEBJKPI@validity?5warning?3?5@
CONST	SEGMENT
??_C@_0BD@BMEBJKPI@validity?5warning?3?5@ DB 'validity warning: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DJCEBDOI@validity?5error?3?5@
CONST	SEGMENT
??_C@_0BB@DJCEBDOI@validity?5error?3?5@ DB 'validity error: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GFHECBDK@warning?3?5@
CONST	SEGMENT
??_C@_09GFHECBDK@warning?3?5@ DB 'warning: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJOHCPOO@error?3?5@
CONST	SEGMENT
??_C@_07FJOHCPOO@error?3?5@ DB 'error: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBCJJJD@href@
CONST	SEGMENT
??_C@_04CMBCJJJD@href@ DB 'href', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ONMNHCCC@No?5error?5message?5provided@
CONST	SEGMENT
??_C@_0BK@ONMNHCCC@No?5error?5message?5provided@ DB 'No error message pro'
	DB	'vided', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GENHFBJC@Entity?3?5line?5?$CFd?3?5?6@
CONST	SEGMENT
??_C@_0BD@GENHFBJC@Entity?3?5line?5?$CFd?3?5?6@ DB 'Entity: line %d: ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08JJLLLDHF@?$CFs?3?$CFd?3?5?6@
CONST	SEGMENT
??_C@_08JJLLLDHF@?$CFs?3?$CFd?3?5?6@ DB '%s:%d: ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHHHBFLE@out?5of?5memory?5error@
CONST	SEGMENT
??_C@_0BE@LHHHBFLE@out?5of?5memory?5error@ DB 'out of memory error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMHKJNKP@error?5?3?5@
CONST	SEGMENT
??_C@_08PMHKJNKP@error?5?3?5@ DB 'error : ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNPIBIGM@warning?5?3?5@
CONST	SEGMENT
??_C@_0L@HNPIBIGM@warning?5?3?5@ DB 'warning : ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECOFBNJN@URI?5@
CONST	SEGMENT
??_C@_04ECOFBNJN@URI?5@ DB 'URI ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FACNAIAH@internal?5buffer?5@
CONST	SEGMENT
??_C@_0BB@FACNAIAH@internal?5buffer?5@ DB 'internal buffer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAKDBFM@schematron?5@
CONST	SEGMENT
??_C@_0M@LAKDBFM@schematron?5@ DB 'schematron ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JICCLIJI@encoding?5@
CONST	SEGMENT
??_C@_09JICCLIJI@encoding?5@ DB 'encoding ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05POKACEJG@XSLT?5@
CONST	SEGMENT
??_C@_05POKACEJG@XSLT?5@ DB 'XSLT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLHJFMDG@C14N?5@
CONST	SEGMENT
??_C@_05MLHJFMDG@C14N?5@ DB 'C14N ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NOLMNIGP@Catalog?5@
CONST	SEGMENT
??_C@_08NOLMNIGP@Catalog?5@ DB 'Catalog ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPDAPLJK@Relax?9NG?5validity?5@
CONST	SEGMENT
??_C@_0BD@EPDAPLJK@Relax?9NG?5validity?5@ DB 'Relax-NG validity ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGPKBGBA@Relax?9NG?5parser?5@
CONST	SEGMENT
??_C@_0BB@FGPKBGBA@Relax?9NG?5parser?5@ DB 'Relax-NG parser ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@COGPIGL@Schemas?5parser?5@
CONST	SEGMENT
??_C@_0BA@COGPIGL@Schemas?5parser?5@ DB 'Schemas parser ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEEJMAME@Schemas?5validity?5@
CONST	SEGMENT
??_C@_0BC@MEEJMAME@Schemas?5validity?5@ DB 'Schemas validity ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEPCOONB@module?5@
CONST	SEGMENT
??_C@_07KEPCOONB@module?5@ DB 'module ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGPLNGGH@regexp?5@
CONST	SEGMENT
??_C@_07IGPLNGGH@regexp?5@ DB 'regexp ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ONGIFIKK@XPath?5@
CONST	SEGMENT
??_C@_06ONGIFIKK@XPath?5@ DB 'XPath ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKGAONDL@XInclude?5@
CONST	SEGMENT
??_C@_09JKGAONDL@XInclude?5@ DB 'XInclude ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKCNGDON@I?1O?5@
CONST	SEGMENT
??_C@_04HKCNGDON@I?1O?5@ DB 'I/O ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NOLKHGJF@output?5@
CONST	SEGMENT
??_C@_07NOLKHGJF@output?5@ DB 'output ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KICHBFMM@memory?5@
CONST	SEGMENT
??_C@_07KICHBFMM@memory?5@ DB 'memory ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IENDNEBE@HTML?5parser?5@
CONST	SEGMENT
??_C@_0N@IENDNEBE@HTML?5parser?5@ DB 'HTML parser ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIOOFDLF@validity?5@
CONST	SEGMENT
??_C@_09BIOOFDLF@validity?5@ DB 'validity ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNCDLIEB@namespace?5@
CONST	SEGMENT
??_C@_0L@BNCDLIEB@namespace?5@ DB 'namespace ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNNNFPCP@parser?5@
CONST	SEGMENT
??_C@_07CNNNFPCP@parser?5@ DB 'parser ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MLFICIIN@element?5?$CFs?3?5@
CONST	SEGMENT
??_C@_0N@MLFICIIN@element?5?$CFs?3?5@ DB 'element %s: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMCMLLAH@Entity?3?5line?5?$CFd?3?5@
CONST	SEGMENT
??_C@_0BC@FMCMLLAH@Entity?3?5line?5?$CFd?3?5@ DB 'Entity: line %d: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@
CONST	SEGMENT
??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@ DB '%s:%d: ', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlReportError
_TEXT	SEGMENT
_buf$1 = -172						; size = 150
_level$1$ = -20						; size = 4
_cur$1$ = -16						; size = 4
_input$1$ = -12						; size = 4
_domain$1$ = -8						; size = 4
_line$1$ = -4						; size = 4
_err$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_str$ = 16						; size = 4
_channel$ = 20						; size = 4
_data$ = 24						; size = 4
_xmlReportError PROC					; COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _err$[ebp]
	xor	edx, edx
	mov	DWORD PTR _input$1$[ebp], 0
	mov	DWORD PTR _cur$1$[ebp], edx
	test	edi, edi
	je	$LN62@xmlReportE

; 248  :     char *file = NULL;
; 249  :     int line = 0;
; 250  :     int code = -1;
; 251  :     int domain;
; 252  :     const xmlChar *name = NULL;
; 253  :     xmlNodePtr node;
; 254  :     xmlErrorLevel level;
; 255  :     xmlParserInputPtr input = NULL;
; 256  :     xmlParserInputPtr cur = NULL;
; 257  : 
; 258  :     if (err == NULL)
; 259  :         return;
; 260  : 
; 261  :     if (channel == NULL) {

	push	ebx
	push	esi
	mov	esi, DWORD PTR _channel$[ebp]
	test	esi, esi
	jne	SHORT $LN68@xmlReportE

; 262  : 	channel = xmlGenericError;

	call	___xmlGenericError
	mov	esi, DWORD PTR [eax]

; 263  : 	data = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	ebx, DWORD PTR [eax]
	jmp	SHORT $LN10@xmlReportE
$LN68@xmlReportE:

; 248  :     char *file = NULL;
; 249  :     int line = 0;
; 250  :     int code = -1;
; 251  :     int domain;
; 252  :     const xmlChar *name = NULL;
; 253  :     xmlNodePtr node;
; 254  :     xmlErrorLevel level;
; 255  :     xmlParserInputPtr input = NULL;
; 256  :     xmlParserInputPtr cur = NULL;
; 257  : 
; 258  :     if (err == NULL)
; 259  :         return;
; 260  : 
; 261  :     if (channel == NULL) {

	mov	ebx, DWORD PTR _data$[ebp]
$LN10@xmlReportE:

; 264  :     }
; 265  :     file = err->file;
; 266  :     line = err->line;
; 267  :     code = err->code;
; 268  :     domain = err->domain;
; 269  :     level = err->level;
; 270  :     node = err->node;
; 271  : 
; 272  :     if (code == XML_ERR_OK)

	cmp	DWORD PTR [edi+4], 0
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR _line$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _domain$1$[ebp], eax
	mov	DWORD PTR _level$1$[ebp], ecx
	je	$LN71@xmlReportE

; 273  :         return;
; 274  : 
; 275  :     if ((node != NULL) && (node->type == XML_ELEMENT_NODE))

	mov	ecx, DWORD PTR [edi+48]
	test	ecx, ecx
	je	SHORT $LN70@xmlReportE
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN70@xmlReportE

; 276  :         name = node->name;

	mov	edi, DWORD PTR [ecx+8]
	jmp	SHORT $LN12@xmlReportE
$LN70@xmlReportE:

; 277  : 
; 278  :     /*
; 279  :      * Maintain the compatibility with the legacy error handling
; 280  :      */
; 281  :     if (ctxt != NULL) {

	xor	edi, edi
$LN12@xmlReportE:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@xmlReportE

; 282  :         input = ctxt->input;

	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _input$1$[ebp], edx

; 283  :         if ((input != NULL) && (input->filename == NULL) &&

	test	edx, edx
	je	$LN22@xmlReportE
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN15@xmlReportE
	mov	ecx, DWORD PTR [ecx+40]
	cmp	ecx, 1
	jle	SHORT $LN15@xmlReportE

; 284  :             (ctxt->inputNr > 1)) {
; 285  :             cur = input;
; 286  :             input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _cur$1$[ebp], edx
	mov	eax, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [eax+ecx*4-8]
	mov	eax, DWORD PTR _domain$1$[ebp]
	mov	DWORD PTR _input$1$[ebp], edx
$LN15@xmlReportE:

; 287  :         }
; 288  :         if (input != NULL) {

	test	edx, edx
	je	SHORT $LN22@xmlReportE

; 289  :             if (input->filename)

	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN17@xmlReportE

; 290  :                 channel(data, "%s:%d: ", input->filename, input->line);

	push	DWORD PTR [edx+28]
	push	ecx
	push	OFFSET ??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@
	push	ebx
	call	esi
	add	esp, 16					; 00000010H
	jmp	SHORT $LN22@xmlReportE
$LN17@xmlReportE:

; 291  :             else if ((line != 0) && (domain == XML_FROM_PARSER))

	cmp	DWORD PTR _line$1$[ebp], 0
	je	SHORT $LN22@xmlReportE
	cmp	eax, 1
	jne	SHORT $LN22@xmlReportE

; 292  :                 channel(data, "Entity: line %d: ", input->line);

	push	DWORD PTR [edx+28]

; 293  :         }
; 294  :     } else {

	jmp	SHORT $LN73@xmlReportE
$LN13@xmlReportE:

; 295  :         if (file != NULL)

	test	edx, edx
	je	SHORT $LN20@xmlReportE

; 296  :             channel(data, "%s:%d: ", file, line);

	push	DWORD PTR _line$1$[ebp]
	push	edx
	push	OFFSET ??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@
	push	ebx
	call	esi
	add	esp, 16					; 00000010H
	jmp	SHORT $LN22@xmlReportE
$LN20@xmlReportE:

; 297  :         else if ((line != 0) &&

	mov	ecx, DWORD PTR _line$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@xmlReportE
	cmp	eax, 1
	je	SHORT $LN23@xmlReportE
	cmp	eax, 17					; 00000011H
	je	SHORT $LN23@xmlReportE
	cmp	eax, 16					; 00000010H
	je	SHORT $LN23@xmlReportE
	cmp	eax, 4
	je	SHORT $LN23@xmlReportE
	cmp	eax, 18					; 00000012H
	je	SHORT $LN23@xmlReportE
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN22@xmlReportE
$LN23@xmlReportE:

; 298  : 	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
; 299  : 		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
; 300  : 		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
; 301  :             channel(data, "Entity: line %d: ", line);

	push	ecx
$LN73@xmlReportE:

; 302  :     }
; 303  :     if (name != NULL) {

	push	OFFSET ??_C@_0BC@FMCMLLAH@Entity?3?5line?5?$CFd?3?5@
	push	ebx
	call	esi
	add	esp, 12					; 0000000cH
$LN22@xmlReportE:
	test	edi, edi
	je	SHORT $LN24@xmlReportE

; 304  :         channel(data, "element %s: ", name);

	push	edi
	push	OFFSET ??_C@_0N@MLFICIIN@element?5?$CFs?3?5@
	push	ebx
	call	esi
	add	esp, 12					; 0000000cH
$LN24@xmlReportE:

; 305  :     }
; 306  :     switch (domain) {

	mov	eax, DWORD PTR _domain$1$[ebp]
	dec	eax
	cmp	eax, 29					; 0000001dH
	ja	$LN48@xmlReportE
	jmp	DWORD PTR $LN79@xmlReportE[eax*4]
$LN26@xmlReportE:

; 307  :         case XML_FROM_PARSER:
; 308  :             channel(data, "parser ");
; 309  :             break;
; 310  :         case XML_FROM_NAMESPACE:
; 311  :             channel(data, "namespace ");

	push	OFFSET ??_C@_0L@BNCDLIEB@namespace?5@

; 312  :             break;

	jmp	$LN74@xmlReportE
$LN27@xmlReportE:

; 313  :         case XML_FROM_DTD:
; 314  :         case XML_FROM_VALID:
; 315  :             channel(data, "validity ");

	push	OFFSET ??_C@_09BIOOFDLF@validity?5@

; 316  :             break;

	jmp	$LN74@xmlReportE
$LN28@xmlReportE:

; 317  :         case XML_FROM_HTML:
; 318  :             channel(data, "HTML parser ");

	push	OFFSET ??_C@_0N@IENDNEBE@HTML?5parser?5@

; 319  :             break;

	jmp	$LN74@xmlReportE
$LN29@xmlReportE:

; 320  :         case XML_FROM_MEMORY:
; 321  :             channel(data, "memory ");

	push	OFFSET ??_C@_07KICHBFMM@memory?5@

; 322  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN30@xmlReportE:

; 323  :         case XML_FROM_OUTPUT:
; 324  :             channel(data, "output ");

	push	OFFSET ??_C@_07NOLKHGJF@output?5@

; 325  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN31@xmlReportE:

; 326  :         case XML_FROM_IO:
; 327  :             channel(data, "I/O ");

	push	OFFSET ??_C@_04HKCNGDON@I?1O?5@

; 328  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN32@xmlReportE:

; 329  :         case XML_FROM_XINCLUDE:
; 330  :             channel(data, "XInclude ");

	push	OFFSET ??_C@_09JKGAONDL@XInclude?5@

; 331  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN33@xmlReportE:

; 332  :         case XML_FROM_XPATH:
; 333  :             channel(data, "XPath ");

	push	OFFSET ??_C@_06ONGIFIKK@XPath?5@

; 334  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN34@xmlReportE:

; 335  :         case XML_FROM_XPOINTER:
; 336  :             channel(data, "parser ");

	push	OFFSET ??_C@_07CNNNFPCP@parser?5@

; 337  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN35@xmlReportE:

; 338  :         case XML_FROM_REGEXP:
; 339  :             channel(data, "regexp ");

	push	OFFSET ??_C@_07IGPLNGGH@regexp?5@

; 340  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN36@xmlReportE:

; 341  :         case XML_FROM_MODULE:
; 342  :             channel(data, "module ");

	push	OFFSET ??_C@_07KEPCOONB@module?5@

; 343  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN37@xmlReportE:

; 344  :         case XML_FROM_SCHEMASV:
; 345  :             channel(data, "Schemas validity ");

	push	OFFSET ??_C@_0BC@MEEJMAME@Schemas?5validity?5@

; 346  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN38@xmlReportE:

; 347  :         case XML_FROM_SCHEMASP:
; 348  :             channel(data, "Schemas parser ");

	push	OFFSET ??_C@_0BA@COGPIGL@Schemas?5parser?5@

; 349  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN39@xmlReportE:

; 350  :         case XML_FROM_RELAXNGP:
; 351  :             channel(data, "Relax-NG parser ");

	push	OFFSET ??_C@_0BB@FGPKBGBA@Relax?9NG?5parser?5@

; 352  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN40@xmlReportE:

; 353  :         case XML_FROM_RELAXNGV:
; 354  :             channel(data, "Relax-NG validity ");

	push	OFFSET ??_C@_0BD@EPDAPLJK@Relax?9NG?5validity?5@

; 355  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN41@xmlReportE:

; 356  :         case XML_FROM_CATALOG:
; 357  :             channel(data, "Catalog ");

	push	OFFSET ??_C@_08NOLMNIGP@Catalog?5@

; 358  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN42@xmlReportE:

; 359  :         case XML_FROM_C14N:
; 360  :             channel(data, "C14N ");

	push	OFFSET ??_C@_05MLHJFMDG@C14N?5@

; 361  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN43@xmlReportE:

; 362  :         case XML_FROM_XSLT:
; 363  :             channel(data, "XSLT ");

	push	OFFSET ??_C@_05POKACEJG@XSLT?5@

; 364  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN44@xmlReportE:

; 365  :         case XML_FROM_I18N:
; 366  :             channel(data, "encoding ");

	push	OFFSET ??_C@_09JICCLIJI@encoding?5@

; 367  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN45@xmlReportE:

; 368  :         case XML_FROM_SCHEMATRONV:
; 369  :             channel(data, "schematron ");

	push	OFFSET ??_C@_0M@LAKDBFM@schematron?5@

; 370  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN46@xmlReportE:

; 371  :         case XML_FROM_BUFFER:
; 372  :             channel(data, "internal buffer ");

	push	OFFSET ??_C@_0BB@FACNAIAH@internal?5buffer?5@

; 373  :             break;

	jmp	SHORT $LN74@xmlReportE
$LN47@xmlReportE:

; 374  :         case XML_FROM_URI:
; 375  :             channel(data, "URI ");

	push	OFFSET ??_C@_04ECOFBNJN@URI?5@
$LN74@xmlReportE:

; 376  :             break;
; 377  :         default:
; 378  :             break;
; 379  :     }
; 380  :     switch (level) {

	push	ebx
	call	esi
	add	esp, 8
$LN48@xmlReportE:
	mov	eax, DWORD PTR _level$1$[ebp]
	cmp	eax, 3
	ja	SHORT $LN4@xmlReportE
	jmp	DWORD PTR $LN80@xmlReportE[eax*4]
$LN49@xmlReportE:

; 381  :         case XML_ERR_NONE:
; 382  :             channel(data, ": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@

; 383  :             break;

	jmp	SHORT $LN75@xmlReportE
$LN50@xmlReportE:

; 384  :         case XML_ERR_WARNING:
; 385  :             channel(data, "warning : ");

	push	OFFSET ??_C@_0L@HNPIBIGM@warning?5?3?5@

; 386  :             break;

	jmp	SHORT $LN75@xmlReportE
$LN52@xmlReportE:

; 387  :         case XML_ERR_ERROR:
; 388  :             channel(data, "error : ");
; 389  :             break;
; 390  :         case XML_ERR_FATAL:
; 391  :             channel(data, "error : ");

	push	OFFSET ??_C@_08PMHKJNKP@error?5?3?5@
$LN75@xmlReportE:

; 392  :             break;
; 393  :     }
; 394  :     if (str != NULL) {

	push	ebx
	call	esi
	add	esp, 8
$LN4@xmlReportE:
	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN53@xmlReportE

; 395  :         int len;
; 396  : 	len = xmlStrlen((const xmlChar *)str);

	push	edi
	call	_xmlStrlen
	add	esp, 4

; 397  : 	if ((len > 0) && (str[len - 1] != '\n'))

	test	eax, eax
	jle	SHORT $LN55@xmlReportE
	cmp	BYTE PTR [eax+edi-1], 10		; 0000000aH
	je	SHORT $LN55@xmlReportE

; 398  : 	    channel(data, "%s\n", str);

	push	edi
	jmp	SHORT $LN76@xmlReportE
$LN55@xmlReportE:

; 399  : 	else
; 400  : 	    channel(data, "%s", str);

	push	edi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@

; 401  :     } else {

	jmp	SHORT $LN77@xmlReportE
$LN53@xmlReportE:

; 402  :         channel(data, "%s\n", "out of memory error");

	push	OFFSET ??_C@_0BE@LHHHBFLE@out?5of?5memory?5error@
$LN76@xmlReportE:

; 403  :     }
; 404  : 
; 405  :     if (ctxt != NULL) {

	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
$LN77@xmlReportE:
	push	ebx
	call	esi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN58@xmlReportE

; 406  :         xmlParserPrintFileContextInternal(input, channel, data);

	push	ebx
	push	esi
	push	DWORD PTR _input$1$[ebp]
	call	_xmlParserPrintFileContextInternal

; 407  :         if (cur != NULL) {

	mov	edi, DWORD PTR _cur$1$[ebp]
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN58@xmlReportE

; 408  :             if (cur->filename)

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN59@xmlReportE

; 409  :                 channel(data, "%s:%d: \n", cur->filename, cur->line);

	push	DWORD PTR [edi+28]
	push	eax
	push	OFFSET ??_C@_08JJLLLDHF@?$CFs?3?$CFd?3?5?6@
	push	ebx
	call	esi
	add	esp, 16					; 00000010H
	jmp	SHORT $LN61@xmlReportE
$LN59@xmlReportE:

; 410  :             else if ((line != 0) && (domain == XML_FROM_PARSER))

	cmp	DWORD PTR _line$1$[ebp], 0
	je	SHORT $LN61@xmlReportE
	cmp	DWORD PTR _domain$1$[ebp], 1
	jne	SHORT $LN61@xmlReportE

; 411  :                 channel(data, "Entity: line %d: \n", cur->line);

	push	DWORD PTR [edi+28]
	push	OFFSET ??_C@_0BD@GENHFBJC@Entity?3?5line?5?$CFd?3?5?6@
	push	ebx
	call	esi
	add	esp, 12					; 0000000cH
$LN61@xmlReportE:

; 412  :             xmlParserPrintFileContextInternal(cur, channel, data);

	push	ebx
	push	esi
	push	edi
	call	_xmlParserPrintFileContextInternal
	add	esp, 12					; 0000000cH
$LN58@xmlReportE:

; 413  :         }
; 414  :     }
; 415  :     if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
; 416  :         (err->int1 < 100) &&

	cmp	DWORD PTR _domain$1$[ebp], 12		; 0000000cH
	jne	SHORT $LN71@xmlReportE
	mov	edi, DWORD PTR _err$[ebp]
	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN71@xmlReportE
	cmp	DWORD PTR [edi+36], 100			; 00000064H
	jge	SHORT $LN71@xmlReportE
	push	eax
	call	_xmlStrlen
	add	esp, 4
	cmp	DWORD PTR [edi+36], eax
	jge	SHORT $LN71@xmlReportE

; 417  : 	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
; 418  : 	xmlChar buf[150];
; 419  : 	int i;
; 420  : 
; 421  : 	channel(data, "%s\n", err->str1);

	push	DWORD PTR [edi+24]
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	ebx
	call	esi

; 422  : 	for (i=0;i < err->int1;i++)

	mov	ecx, DWORD PTR [edi+36]
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN7@xmlReportE

; 417  : 	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
; 418  : 	xmlChar buf[150];
; 419  : 	int i;
; 420  : 
; 421  : 	channel(data, "%s\n", err->str1);

	mov	edx, ecx
	lea	edi, DWORD PTR _buf$1[ebp]
	shr	ecx, 2
	mov	eax, 538976288				; 20202020H
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb
	mov	eax, edx
$LN7@xmlReportE:

; 423  : 	     buf[i] = ' ';
; 424  : 	buf[i++] = '^';

	mov	WORD PTR _buf$1[ebp+eax], 94		; 0000005eH

; 425  : 	buf[i] = 0;
; 426  : 	channel(data, "%s\n", buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	ebx
	call	esi
	add	esp, 12					; 0000000cH
$LN71@xmlReportE:
	pop	esi
	pop	ebx
$LN62@xmlReportE:
	pop	edi

; 427  :     }
; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN79@xmlReportE:
	DD	$LN34@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN26@xmlReportE
	DD	$LN27@xmlReportE
	DD	$LN28@xmlReportE
	DD	$LN29@xmlReportE
	DD	$LN30@xmlReportE
	DD	$LN31@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN32@xmlReportE
	DD	$LN33@xmlReportE
	DD	$LN34@xmlReportE
	DD	$LN35@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN38@xmlReportE
	DD	$LN37@xmlReportE
	DD	$LN39@xmlReportE
	DD	$LN40@xmlReportE
	DD	$LN41@xmlReportE
	DD	$LN42@xmlReportE
	DD	$LN43@xmlReportE
	DD	$LN27@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN48@xmlReportE
	DD	$LN36@xmlReportE
	DD	$LN44@xmlReportE
	DD	$LN45@xmlReportE
	DD	$LN46@xmlReportE
	DD	$LN47@xmlReportE
$LN80@xmlReportE:
	DD	$LN49@xmlReportE
	DD	$LN50@xmlReportE
	DD	$LN52@xmlReportE
	DD	$LN52@xmlReportE
_xmlReportError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserPrintFileContextInternal
_TEXT	SEGMENT
_content$ = -84						; size = 81
_input$ = 8						; size = 4
_channel$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlParserPrintFileContextInternal PROC			; COMDAT

; 174  : 		xmlGenericErrorFunc channel, void *data ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	ecx, OFFSET __67926DEE_error@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _input$[ebp]
	test	esi, esi
	je	$LN11@xmlParserP

; 175  :     const xmlChar *cur, *base;
; 176  :     unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
; 177  :     xmlChar  content[81]; /* space for 80 chars + line terminator */
; 178  :     xmlChar *ctnt;
; 179  : 
; 180  :     if ((input == NULL) || (input->cur == NULL))

	push	edi
	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	$LN39@xmlParserP

; 181  :         return;
; 182  : 
; 183  :     cur = input->cur;
; 184  :     base = input->base;

	mov	esi, DWORD PTR [esi+12]
	mov	eax, edi

; 185  :     /* skip backwards over any end-of-lines */
; 186  :     while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {

	cmp	eax, esi
	jbe	SHORT $LN36@xmlParserP
$LL2@xmlParserP:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN30@xmlParserP
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN36@xmlParserP
$LN30@xmlParserP:

; 187  : 	cur--;

	dec	eax
	cmp	eax, esi
	ja	SHORT $LL2@xmlParserP
$LN36@xmlParserP:

; 188  :     }
; 189  :     n = 0;

	xor	ecx, ecx
$LL4@xmlParserP:

; 190  :     /* search backwards for beginning-of-line (to max buff size) */
; 191  :     while ((n++ < (sizeof(content)-1)) && (cur > base) &&
; 192  : 	   (*(cur) != '\n') && (*(cur) != '\r'))

	inc	ecx
	cmp	eax, esi
	jbe	SHORT $LN22@xmlParserP
	mov	dl, BYTE PTR [eax]
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN14@xmlParserP
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN22@xmlParserP

; 193  :         cur--;

	dec	eax
	cmp	ecx, 80					; 00000050H
	jb	SHORT $LL4@xmlParserP
$LN22@xmlParserP:

; 194  :     if ((*(cur) == '\n') || (*(cur) == '\r')) cur++;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN14@xmlParserP
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN13@xmlParserP
$LN14@xmlParserP:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
$LN13@xmlParserP:

; 195  :     /* calculate the error position in terms of the current position */
; 196  :     col = input->cur - cur;

	sub	edi, eax

; 197  :     /* search forward for end-of-line (to max buff size) */
; 198  :     n = 0;
; 199  :     ctnt = content;

	lea	edx, DWORD PTR _content$[ebp]
	xor	esi, esi
	push	ebx

; 200  :     /* copy selected text to our buffer */
; 201  :     while ((*cur != 0) && (*(cur) != '\n') &&
; 202  : 	   (*(cur) != '\r') && (n < sizeof(content)-1)) {

	test	cl, cl
	je	SHORT $LN37@xmlParserP

; 185  :     /* skip backwards over any end-of-lines */
; 186  :     while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {

	mov	ebx, edx
	sub	eax, ebx
	npad	5
$LL6@xmlParserP:

; 200  :     /* copy selected text to our buffer */
; 201  :     while ((*cur != 0) && (*(cur) != '\n') &&
; 202  : 	   (*(cur) != '\r') && (n < sizeof(content)-1)) {

	cmp	cl, 10					; 0000000aH
	je	SHORT $LN37@xmlParserP
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN37@xmlParserP
	cmp	esi, 80					; 00000050H
	jae	SHORT $LN37@xmlParserP

; 203  : 		*ctnt++ = *cur++;

	movzx	ecx, BYTE PTR [eax+edx]

; 204  : 	n++;

	inc	esi
	mov	BYTE PTR [edx], cl
	inc	edx
	mov	cl, BYTE PTR [eax+edx]
	test	cl, cl
	jne	SHORT $LL6@xmlParserP
$LN37@xmlParserP:

; 205  :     }
; 206  :     *ctnt = 0;
; 207  :     /* print out the selected text */
; 208  :     channel(data ,"%s\n", content);

	mov	esi, DWORD PTR _data$[ebp]
	lea	eax, DWORD PTR _content$[ebp]
	mov	ebx, DWORD PTR _channel$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	esi
	mov	BYTE PTR [edx], 0
	call	ebx
	add	esp, 12					; 0000000cH

; 209  :     /* create blank line with problem pointer */
; 210  :     n = 0;
; 211  :     ctnt = content;

	lea	ecx, DWORD PTR _content$[ebp]
	xor	edx, edx

; 212  :     /* (leave buffer space for pointer + line terminator) */
; 213  :     while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {

	test	edi, edi
	je	SHORT $LN38@xmlParserP
	npad	1
$LL8@xmlParserP:
	mov	eax, edx
	inc	edx
	cmp	eax, 79					; 0000004fH
	jae	SHORT $LN38@xmlParserP
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN38@xmlParserP

; 214  : 	if (*(ctnt) != '\t')

	cmp	al, 9
	je	SHORT $LN35@xmlParserP

; 215  : 	    *(ctnt) = ' ';

	mov	BYTE PTR [ecx], 32			; 00000020H
$LN35@xmlParserP:

; 216  : 	ctnt++;

	inc	ecx
	cmp	edx, edi
	jb	SHORT $LL8@xmlParserP
$LN38@xmlParserP:

; 217  :     }
; 218  :     *ctnt++ = '^';
; 219  :     *ctnt = 0;
; 220  :     channel(data ,"%s\n", content);

	lea	eax, DWORD PTR _content$[ebp]
	mov	WORD PTR [ecx], 94			; 0000005eH
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	esi
	call	ebx
	add	esp, 12					; 0000000cH
	pop	ebx
$LN39@xmlParserP:
	pop	edi
$LN11@xmlParserP:
	pop	esi

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserPrintFileContextInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlGenericErrorDefaultFunc
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlGenericErrorDefaultFunc PROC			; COMDAT

; 71   : xmlGenericErrorDefaultFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericErrorContext
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@xmlGeneric

; 72   :     va_list args;
; 73   : 
; 74   :     if (xmlGenericErrorContext == NULL)
; 75   : 	xmlGenericErrorContext = (void *) stderr;

	call	___xmlGenericErrorContext
	push	2
	mov	esi, eax
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	DWORD PTR [esi], eax
$LN2@xmlGeneric:

; 76   : 
; 77   :     va_start(args, msg);
; 78   :     vfprintf((FILE *)xmlGenericErrorContext, msg, args);

	mov	edi, DWORD PTR _msg$[ebp]
	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	push	edi
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 80   : }

	pop	ebp
	ret	0
_xmlGenericErrorDefaultFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT ___xmlSimpleError
_TEXT	SEGMENT
_domain$ = 8						; size = 4
_code$ = 12						; size = 4
_node$ = 16						; size = 4
_msg$ = 20						; size = 4
_extra$ = 24						; size = 4
___xmlSimpleError PROC					; COMDAT

; 653  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _code$[ebp]
	mov	eax, DWORD PTR _extra$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN2@xmlSimpleE

; 654  : 
; 655  :     if (code == XML_ERR_NO_MEMORY) {
; 656  : 	if (extra)

	test	eax, eax
	je	SHORT $LN4@xmlSimpleE

; 657  : 	    __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	ecx
	jmp	SHORT $LN7@xmlSimpleE
$LN4@xmlSimpleE:

; 658  : 			    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 659  : 			    NULL, NULL, 0, 0,
; 660  : 			    "Memory allocation failed : %s\n", extra);
; 661  : 	else
; 662  : 	    __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	DWORD PTR _domain$[ebp]
	push	DWORD PTR _node$[ebp]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H

; 667  : 			code, XML_ERR_ERROR, NULL, 0, extra,
; 668  : 			NULL, NULL, 0, 0, msg, extra);
; 669  :     }
; 670  : }

	pop	ebp
	ret	0
$LN2@xmlSimpleE:

; 663  : 			    XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 664  : 			    NULL, NULL, 0, 0, "Memory allocation failed\n");
; 665  :     } else {
; 666  : 	__xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,

	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	ecx
$LN7@xmlSimpleE:

; 667  : 			code, XML_ERR_ERROR, NULL, 0, extra,
; 668  : 			NULL, NULL, 0, 0, msg, extra);
; 669  :     }
; 670  : }

	push	DWORD PTR _domain$[ebp]
	push	DWORD PTR _node$[ebp]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	ebp
	ret	0
___xmlSimpleError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT ___xmlRaiseError
_TEXT	SEGMENT
_to$1$ = -24						; size = 4
_baseptr$1$ = -20					; size = 4
_ctxt$1$ = -16						; size = 4
_schannel$1$ = -12					; size = 4
_str$1$ = -8						; size = 4
_data$1$ = -4						; size = 4
_schannel$ = 8						; size = 4
_channel$ = 12						; size = 4
_data$ = 16						; size = 4
_ctx$ = 20						; size = 4
_line$1$ = 24						; size = 4
_nod$ = 24						; size = 4
_domain$ = 28						; size = 4
_code$ = 32						; size = 4
_level$ = 36						; size = 4
_file$ = 40						; size = 4
_line$ = 44						; size = 4
_str1$ = 48						; size = 4
_str2$ = 52						; size = 4
_str3$ = 56						; size = 4
_int1$ = 60						; size = 4
_col$ = 64						; size = 4
_msg$ = 68						; size = 4
___xmlRaiseError PROC					; COMDAT

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _nod$[ebp]
	xor	eax, eax
	mov	DWORD PTR _ctxt$1$[ebp], eax
	call	___xmlLastError
	cmp	DWORD PTR _code$[ebp], 0
	mov	edi, eax
	mov	DWORD PTR _to$1$[ebp], edi
	mov	DWORD PTR _baseptr$1$[ebp], 0
	je	$LN67@xmlRaiseEr

; 462  :     xmlParserCtxtPtr ctxt = NULL;
; 463  :     xmlNodePtr node = (xmlNodePtr) nod;
; 464  :     char *str = NULL;
; 465  :     xmlParserInputPtr input = NULL;
; 466  :     xmlErrorPtr to = &xmlLastError;
; 467  :     xmlNodePtr baseptr = NULL;
; 468  : 
; 469  :     if (code == XML_ERR_OK)
; 470  :         return;
; 471  :     if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))

	call	___xmlGetWarningsDefaultValue
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@xmlRaiseEr
	cmp	DWORD PTR _level$[ebp], 1
	je	$LN67@xmlRaiseEr
$LN10@xmlRaiseEr:

; 472  :         return;
; 473  :     if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
; 474  :         (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
; 475  : 	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {

	mov	eax, DWORD PTR _domain$[ebp]
	push	esi
	cmp	eax, 1
	je	SHORT $LN12@xmlRaiseEr
	cmp	eax, 5
	je	SHORT $LN12@xmlRaiseEr
	cmp	eax, 4
	je	SHORT $LN12@xmlRaiseEr
	cmp	eax, 3
	je	SHORT $LN12@xmlRaiseEr
	cmp	eax, 8
	je	SHORT $LN12@xmlRaiseEr
	cmp	eax, 23					; 00000017H
	je	SHORT $LN12@xmlRaiseEr
	mov	ecx, DWORD PTR _schannel$[ebp]
	mov	esi, DWORD PTR _data$[ebp]
	mov	DWORD PTR _schannel$1$[ebp], ecx
	jmp	SHORT $LN102@xmlRaiseEr
$LN12@xmlRaiseEr:

; 476  : 	ctxt = (xmlParserCtxtPtr) ctx;
; 477  : 	if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&
; 478  : 	    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&

	mov	ecx, DWORD PTR _schannel$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR _ctxt$1$[ebp], edx
	mov	DWORD PTR _schannel$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LN91@xmlRaiseEr
	test	edx, edx
	je	SHORT $LN90@xmlRaiseEr
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN90@xmlRaiseEr
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN90@xmlRaiseEr
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _schannel$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN90@xmlRaiseEr

; 479  : 	    (ctxt->sax->serror != NULL)) {
; 480  : 	    schannel = ctxt->sax->serror;
; 481  : 	    data = ctxt->userData;

	mov	esi, DWORD PTR [edx+4]
$LN102@xmlRaiseEr:

; 482  : 	}
; 483  :     }
; 484  :     /*
; 485  :      * Check if structured error handler set
; 486  :      */
; 487  :     if (schannel == NULL) {

	mov	DWORD PTR _data$1$[ebp], esi
	test	ecx, ecx
	jne	SHORT $LN15@xmlRaiseEr

; 476  : 	ctxt = (xmlParserCtxtPtr) ctx;
; 477  : 	if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&
; 478  : 	    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&

	jmp	SHORT $LN87@xmlRaiseEr
$LN90@xmlRaiseEr:
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _data$1$[ebp], eax
$LN87@xmlRaiseEr:

; 488  : 	schannel = xmlStructuredError;

	call	___xmlStructuredError
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _schannel$1$[ebp], eax

; 489  : 	/*
; 490  : 	 * if user has defined handler, change data ptr to user's choice
; 491  : 	 */
; 492  : 	if (schannel != NULL)

	test	eax, eax
	je	SHORT $LN15@xmlRaiseEr

; 493  : 	    data = xmlStructuredErrorContext;

	call	___xmlStructuredErrorContext
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN103@xmlRaiseEr
$LN91@xmlRaiseEr:

; 476  : 	ctxt = (xmlParserCtxtPtr) ctx;
; 477  : 	if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&
; 478  : 	    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&

	mov	eax, DWORD PTR _data$[ebp]
$LN103@xmlRaiseEr:

; 494  :     }
; 495  :     /*
; 496  :      * Formatting the message
; 497  :      */
; 498  :     if (msg == NULL) {

	mov	DWORD PTR _data$1$[ebp], eax
$LN15@xmlRaiseEr:
	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN16@xmlRaiseEr

; 499  :         str = (char *) xmlStrdup(BAD_CAST "No error message provided");

	push	OFFSET ??_C@_0BK@ONMNHCCC@No?5error?5message?5provided@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _str$1$[ebp], eax

; 500  :     } else {

	jmp	$LN75@xmlRaiseEr
$LN16@xmlRaiseEr:

; 501  :         XML_GET_VAR_STR(msg, str);

	push	150					; 00000096H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _str$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN75@xmlRaiseEr
	mov	edi, 150				; 00000096H
	or	ebx, -1
	npad	4
$LL2@xmlRaiseEr:
	mov	esi, DWORD PTR _msg$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _str$1$[ebp]
	or	ecx, 2
	push	edi
	push	esi
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 501  :         XML_GET_VAR_STR(msg, str);

	cmp	eax, ecx
	jle	SHORT $LN22@xmlRaiseEr
	cmp	eax, edi
	jge	SHORT $LN21@xmlRaiseEr
	cmp	ebx, eax
	je	SHORT $LN97@xmlRaiseEr
	mov	ebx, eax
$LN21@xmlRaiseEr:
	inc	edi
	add	edi, eax
	jmp	SHORT $LN23@xmlRaiseEr
$LN22@xmlRaiseEr:
	add	edi, 100				; 00000064H
$LN23@xmlRaiseEr:
	push	edi
	push	esi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN97@xmlRaiseEr
	mov	DWORD PTR _str$1$[ebp], eax
	cmp	edi, 64000				; 0000fa00H
	jl	SHORT $LL2@xmlRaiseEr
$LN97@xmlRaiseEr:
	mov	ebx, DWORD PTR _nod$[ebp]
	mov	edi, DWORD PTR _to$1$[ebp]
$LN75@xmlRaiseEr:

; 502  :     }
; 503  : 
; 504  :     /*
; 505  :      * specific processing if a parser context is provided
; 506  :      */
; 507  :     if (ctxt != NULL) {

	mov	edx, DWORD PTR _ctxt$1$[ebp]
	test	edx, edx
	je	SHORT $LN25@xmlRaiseEr

; 508  :         if (file == NULL) {

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN92@xmlRaiseEr

; 509  :             input = ctxt->input;

	mov	eax, DWORD PTR [edx+36]

; 510  :             if ((input != NULL) && (input->filename == NULL) &&

	test	eax, eax
	je	SHORT $LN92@xmlRaiseEr
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN28@xmlRaiseEr
	mov	ecx, DWORD PTR [edx+40]
	cmp	ecx, 1
	jle	SHORT $LN28@xmlRaiseEr

; 511  :                 (ctxt->inputNr > 1)) {
; 512  :                 input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR [edx+48]
	mov	eax, DWORD PTR [eax+ecx*4-8]
$LN28@xmlRaiseEr:

; 513  :             }
; 514  :             if (input != NULL) {

	test	eax, eax
	je	SHORT $LN92@xmlRaiseEr

; 515  :                 file = input->filename;
; 516  :                 line = input->line;

	mov	ecx, DWORD PTR [eax+28]

; 517  :                 col = input->col;
; 518  :             }
; 519  :         }
; 520  :         to = &ctxt->lastError;

	lea	edi, DWORD PTR [edx+384]
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR _line$1$[ebp], ecx
	mov	DWORD PTR _col$[ebp], eax
	jmp	$LN34@xmlRaiseEr
$LN92@xmlRaiseEr:

; 513  :             }
; 514  :             if (input != NULL) {

	mov	eax, DWORD PTR _line$[ebp]

; 517  :                 col = input->col;
; 518  :             }
; 519  :         }
; 520  :         to = &ctxt->lastError;

	lea	edi, DWORD PTR [edx+384]
	mov	esi, DWORD PTR _file$[ebp]
	mov	DWORD PTR _line$1$[ebp], eax
	jmp	$LN34@xmlRaiseEr
$LN25@xmlRaiseEr:

; 521  :     } else if ((node != NULL) && (file == NULL)) {

	test	ebx, ebx
	je	SHORT $LN95@xmlRaiseEr
	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN96@xmlRaiseEr

; 522  : 	int i;
; 523  : 
; 524  : 	if ((node->doc != NULL) && (node->doc->URL != NULL)) {

	mov	eax, DWORD PTR [ebx+32]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN31@xmlRaiseEr
	cmp	DWORD PTR [eax+72], ecx
	cmovne	ecx, ebx
	mov	DWORD PTR _baseptr$1$[ebp], ecx
$LN31@xmlRaiseEr:

; 525  : 	    baseptr = node;
; 526  : /*	    file = (const char *) node->doc->URL; */
; 527  : 	}
; 528  : 	for (i = 0;

	xor	eax, eax
	npad	1
$LL6@xmlRaiseEr:

; 529  : 	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));

	test	ebx, ebx
	je	SHORT $LN5@xmlRaiseEr
	cmp	DWORD PTR [ebx+4], 1
	je	SHORT $LN5@xmlRaiseEr

; 530  : 	     i++)
; 531  : 	     node = node->parent;

	mov	ebx, DWORD PTR [ebx+20]
	inc	eax
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LL6@xmlRaiseEr
$LN5@xmlRaiseEr:

; 532  :         if ((baseptr == NULL) && (node != NULL) &&
; 533  : 	    (node->doc != NULL) && (node->doc->URL != NULL))

	test	ecx, ecx
	jne	SHORT $LN32@xmlRaiseEr
	test	ebx, ebx
	je	SHORT $LN93@xmlRaiseEr
	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN32@xmlRaiseEr
	cmp	DWORD PTR [eax+72], ecx
	cmovne	ecx, ebx
	mov	DWORD PTR _baseptr$1$[ebp], ecx
$LN32@xmlRaiseEr:

; 534  : 	    baseptr = node;
; 535  : 
; 536  : 	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))

	test	ebx, ebx
	je	SHORT $LN93@xmlRaiseEr
	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN93@xmlRaiseEr

; 537  : 	    line = node->line;

	movzx	esi, WORD PTR [ebx+56]
	jmp	SHORT $LN104@xmlRaiseEr
$LN93@xmlRaiseEr:

; 534  : 	    baseptr = node;
; 535  : 
; 536  : 	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))

	mov	esi, DWORD PTR _line$[ebp]
$LN104@xmlRaiseEr:

; 538  : 	if ((line == 0) || (line == 65535))

	mov	DWORD PTR _line$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN35@xmlRaiseEr
	cmp	esi, 65535				; 0000ffffH
	jne	SHORT $LN98@xmlRaiseEr
$LN35@xmlRaiseEr:

; 539  : 	    line = xmlGetLineNo(node);

	push	ebx
	call	_xmlGetLineNo
	add	esp, 4
	jmp	SHORT $LN109@xmlRaiseEr
$LN96@xmlRaiseEr:

; 521  :     } else if ((node != NULL) && (file == NULL)) {

	mov	esi, DWORD PTR _line$[ebp]
	mov	DWORD PTR _line$1$[ebp], esi
	jmp	SHORT $LN98@xmlRaiseEr
$LN95@xmlRaiseEr:
	mov	eax, DWORD PTR _line$[ebp]
$LN109@xmlRaiseEr:

; 540  :     }
; 541  : 
; 542  :     /*
; 543  :      * Save the information about the error
; 544  :      */
; 545  :     xmlResetError(to);

	mov	DWORD PTR _line$1$[ebp], eax
$LN98@xmlRaiseEr:
	mov	esi, DWORD PTR _file$[ebp]
$LN34@xmlRaiseEr:
	push	edi
	call	_xmlResetError

; 546  :     to->domain = domain;

	mov	eax, DWORD PTR _domain$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 547  :     to->code = code;

	mov	eax, DWORD PTR _code$[ebp]
	mov	DWORD PTR [edi+4], eax

; 548  :     to->message = str;

	mov	eax, DWORD PTR _str$1$[ebp]
	mov	DWORD PTR [edi+8], eax

; 549  :     to->level = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [edi+12], eax

; 550  :     if (file != NULL)

	test	esi, esi
	je	SHORT $LN36@xmlRaiseEr

; 551  :         to->file = (char *) xmlStrdup((const xmlChar *) file);

	push	esi
	jmp	$LN105@xmlRaiseEr
$LN36@xmlRaiseEr:

; 552  :     else if (baseptr != NULL) {

	mov	edx, DWORD PTR _baseptr$1$[ebp]
	test	edx, edx
	je	$LN49@xmlRaiseEr

; 553  : #ifdef LIBXML_XINCLUDE_ENABLED
; 554  : 	/*
; 555  : 	 * We check if the error is within an XInclude section and,
; 556  : 	 * if so, attempt to print out the href of the XInclude instead
; 557  : 	 * of the usual "base" (doc->URL) for the node (bug 152623).
; 558  : 	 */
; 559  :         xmlNodePtr prev = baseptr;

	mov	esi, edx

; 560  : 	int inclcount = 0;

	xor	eax, eax
$LL7@xmlRaiseEr:

; 562  : 	    if (prev->prev == NULL)

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN39@xmlRaiseEr

; 563  : 	        prev = prev->parent;

	mov	esi, DWORD PTR [esi+20]
	jmp	SHORT $LN44@xmlRaiseEr
$LN39@xmlRaiseEr:

; 564  : 	    else {
; 565  : 	        prev = prev->prev;

	mov	esi, ecx

; 566  : 		if (prev->type == XML_XINCLUDE_START) {

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 19					; 00000013H
	jne	SHORT $LN41@xmlRaiseEr

; 567  : 		    if (--inclcount < 0)

	sub	eax, 1
	js	SHORT $LN77@xmlRaiseEr

; 568  : 		        break;
; 569  : 		} else if (prev->type == XML_XINCLUDE_END)

	jmp	SHORT $LN44@xmlRaiseEr
$LN41@xmlRaiseEr:
	cmp	ecx, 20					; 00000014H
	jne	SHORT $LN44@xmlRaiseEr

; 570  : 		    inclcount++;

	inc	eax
$LN44@xmlRaiseEr:

; 561  : 	while (prev != NULL) {

	test	esi, esi
	jne	SHORT $LL7@xmlRaiseEr
$LN77@xmlRaiseEr:

; 571  : 	    }
; 572  : 	}
; 573  : 	if (prev != NULL) {

	test	esi, esi
	je	SHORT $LN45@xmlRaiseEr

; 574  : 	    if (prev->type == XML_XINCLUDE_START) {

	cmp	DWORD PTR [esi+4], 19			; 00000013H
	push	OFFSET ??_C@_04CMBCJJJD@href@
	push	esi
	jne	SHORT $LN47@xmlRaiseEr

; 575  : 		prev->type = XML_ELEMENT_NODE;

	mov	DWORD PTR [esi+4], 1

; 576  : 		to->file = (char *) xmlGetProp(prev, BAD_CAST "href");

	call	_xmlGetProp
	mov	DWORD PTR [edi+16], eax
	add	esp, 8

; 577  : 		prev->type = XML_XINCLUDE_START;

	mov	DWORD PTR [esi+4], 19			; 00000013H

; 578  : 	    } else {

	jmp	SHORT $LN46@xmlRaiseEr
$LN47@xmlRaiseEr:

; 579  : 		to->file = (char *) xmlGetProp(prev, BAD_CAST "href");

	call	_xmlGetProp
	add	esp, 8

; 580  : 	    }
; 581  : 	} else

	jmp	SHORT $LN106@xmlRaiseEr
$LN45@xmlRaiseEr:

; 582  : #endif
; 583  : 	    to->file = (char *) xmlStrdup(baseptr->doc->URL);

	mov	eax, DWORD PTR [edx+32]
	push	DWORD PTR [eax+72]
	call	_xmlStrdup
	add	esp, 4
$LN106@xmlRaiseEr:

; 584  : 	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {

	mov	DWORD PTR [edi+16], eax
$LN46@xmlRaiseEr:
	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN49@xmlRaiseEr
	test	ebx, ebx
	je	SHORT $LN49@xmlRaiseEr
	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN49@xmlRaiseEr

; 585  : 	    to->file = (char *) xmlStrdup(node->doc->URL);

	push	DWORD PTR [eax+72]
$LN105@xmlRaiseEr:

; 586  : 	}
; 587  :     }
; 588  :     to->line = line;

	call	_xmlStrdup
	mov	DWORD PTR [edi+16], eax
	add	esp, 4
$LN49@xmlRaiseEr:
	mov	eax, DWORD PTR _line$1$[ebp]
	mov	DWORD PTR [edi+20], eax

; 589  :     if (str1 != NULL)

	mov	eax, DWORD PTR _str1$[ebp]
	test	eax, eax
	je	SHORT $LN50@xmlRaiseEr

; 590  :         to->str1 = (char *) xmlStrdup((const xmlChar *) str1);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+24], eax
$LN50@xmlRaiseEr:

; 591  :     if (str2 != NULL)

	mov	eax, DWORD PTR _str2$[ebp]
	test	eax, eax
	je	SHORT $LN51@xmlRaiseEr

; 592  :         to->str2 = (char *) xmlStrdup((const xmlChar *) str2);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+28], eax
$LN51@xmlRaiseEr:

; 593  :     if (str3 != NULL)

	mov	eax, DWORD PTR _str3$[ebp]
	test	eax, eax
	je	SHORT $LN52@xmlRaiseEr

; 594  :         to->str3 = (char *) xmlStrdup((const xmlChar *) str3);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+32], eax
$LN52@xmlRaiseEr:

; 595  :     to->int1 = int1;

	mov	eax, DWORD PTR _int1$[ebp]
	mov	DWORD PTR [edi+36], eax

; 596  :     to->int2 = col;

	mov	eax, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edi+40], eax

; 597  :     to->node = node;
; 598  :     to->ctxt = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [edi+48], ebx
	mov	DWORD PTR [edi+44], eax

; 599  : 
; 600  :     if (to != &xmlLastError)

	call	___xmlLastError
	cmp	edi, eax
	je	SHORT $LN53@xmlRaiseEr

; 601  :         xmlCopyError(to,&xmlLastError);

	call	___xmlLastError
	push	eax
	push	edi
	call	_xmlCopyError
	add	esp, 8
$LN53@xmlRaiseEr:

; 602  : 
; 603  :     if (schannel != NULL) {

	mov	eax, DWORD PTR _schannel$1$[ebp]
	test	eax, eax
	je	SHORT $LN54@xmlRaiseEr

; 604  : 	schannel(data, to);

	push	edi
	push	DWORD PTR _data$1$[ebp]
	call	eax
	add	esp, 8
	pop	esi
	pop	edi

; 639  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlRaiseEr:

; 605  : 	return;
; 606  :     }
; 607  : 
; 608  :     /*
; 609  :      * Find the callback channel if channel param is NULL
; 610  :      */
; 611  :     if ((ctxt != NULL) && (channel == NULL) &&
; 612  :         (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {

	mov	ebx, DWORD PTR _channel$[ebp]
	mov	esi, DWORD PTR _ctxt$1$[ebp]
	test	ebx, ebx
	jne	SHORT $LN86@xmlRaiseEr
	test	esi, esi
	je	SHORT $LN55@xmlRaiseEr
	call	___xmlStructuredError
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN55@xmlRaiseEr
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN55@xmlRaiseEr

; 613  :         if (level == XML_ERR_WARNING)

	cmp	DWORD PTR _level$[ebp], 1
	jne	SHORT $LN57@xmlRaiseEr

; 614  : 	    channel = ctxt->sax->warning;

	mov	ebx, DWORD PTR [eax+84]

; 617  : 	data = ctxt->userData;

	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN107@xmlRaiseEr
$LN57@xmlRaiseEr:

; 615  :         else
; 616  : 	    channel = ctxt->sax->error;

	mov	ebx, DWORD PTR [eax+88]

; 617  : 	data = ctxt->userData;

	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $LN107@xmlRaiseEr
$LN55@xmlRaiseEr:

; 618  :     } else if (channel == NULL) {
; 619  : 	channel = xmlGenericError;

	call	___xmlGenericError
	mov	ebx, DWORD PTR [eax]

; 620  : 	if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN60@xmlRaiseEr

; 621  : 	    data = ctxt;

	mov	DWORD PTR _data$1$[ebp], esi

; 622  : 	} else {

	jmp	SHORT $LN61@xmlRaiseEr
$LN60@xmlRaiseEr:

; 623  : 	    data = xmlGenericErrorContext;

	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
$LN107@xmlRaiseEr:

; 624  : 	}
; 625  :     }
; 626  :     if (channel == NULL)

	mov	DWORD PTR _data$1$[ebp], eax
$LN61@xmlRaiseEr:
	test	ebx, ebx
	je	SHORT $LN101@xmlRaiseEr
$LN86@xmlRaiseEr:

; 627  :         return;
; 628  : 
; 629  :     if ((channel == xmlParserError) ||
; 630  :         (channel == xmlParserWarning) ||
; 631  : 	(channel == xmlParserValidityError) ||

	cmp	ebx, OFFSET _xmlParserError
	je	SHORT $LN65@xmlRaiseEr
	cmp	ebx, OFFSET _xmlParserWarning
	je	SHORT $LN65@xmlRaiseEr
	cmp	ebx, OFFSET _xmlParserValidityError
	je	SHORT $LN65@xmlRaiseEr
	cmp	ebx, OFFSET _xmlParserValidityWarning
	je	SHORT $LN65@xmlRaiseEr

; 634  :     else if ((channel == (xmlGenericErrorFunc) fprintf) ||

	cmp	ebx, OFFSET _fprintf
	je	SHORT $LN68@xmlRaiseEr
	cmp	ebx, OFFSET _xmlGenericErrorDefaultFunc
	je	SHORT $LN68@xmlRaiseEr

; 637  :     else
; 638  : 	channel(data, "%s", str);

	push	DWORD PTR _str$1$[ebp]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR _data$1$[ebp]
	call	ebx
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi

; 639  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@xmlRaiseEr:

; 635  :              (channel == xmlGenericErrorDefaultFunc))
; 636  : 	xmlReportError(to, ctxt, str, channel, data);

	push	DWORD PTR _data$1$[ebp]
	push	ebx
	push	DWORD PTR _str$1$[ebp]
	push	esi
	push	edi
	call	_xmlReportError
	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 639  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@xmlRaiseEr:

; 632  : 	(channel == xmlParserValidityWarning))
; 633  : 	xmlReportError(to, ctxt, str, NULL, NULL);

	push	0
	push	0
	push	DWORD PTR _str$1$[ebp]
	push	esi
	push	edi
	call	_xmlReportError
	add	esp, 20					; 00000014H
$LN101@xmlRaiseEr:
	pop	esi
$LN67@xmlRaiseEr:
	pop	edi

; 639  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___xmlRaiseError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlCopyError
_TEXT	SEGMENT
_str3$1$ = -12						; size = 4
_str2$1$ = -8						; size = 4
_str1$1$ = -4						; size = 4
_file$1$ = 8						; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_xmlCopyError PROC					; COMDAT

; 957  : xmlCopyError(xmlErrorPtr from, xmlErrorPtr to) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __67926DEE_error@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _from$[ebp]
	test	edi, edi
	je	$LN3@xmlCopyErr

; 958  :     char *message, *file, *str1, *str2, *str3;
; 959  : 
; 960  :     if ((from == NULL) || (to == NULL))

	mov	esi, DWORD PTR _to$[ebp]
	test	esi, esi
	je	$LN3@xmlCopyErr

; 962  : 
; 963  :     message = (char *) xmlStrdup((xmlChar *) from->message);

	push	ebx
	push	DWORD PTR [edi+8]
	call	_xmlStrdup

; 964  :     file = (char *) xmlStrdup ((xmlChar *) from->file);

	push	DWORD PTR [edi+16]
	mov	ebx, eax
	call	_xmlStrdup

; 965  :     str1 = (char *) xmlStrdup ((xmlChar *) from->str1);

	push	DWORD PTR [edi+24]
	mov	DWORD PTR _file$1$[ebp], eax
	call	_xmlStrdup

; 966  :     str2 = (char *) xmlStrdup ((xmlChar *) from->str2);

	push	DWORD PTR [edi+28]
	mov	DWORD PTR _str1$1$[ebp], eax
	call	_xmlStrdup

; 967  :     str3 = (char *) xmlStrdup ((xmlChar *) from->str3);

	push	DWORD PTR [edi+32]
	mov	DWORD PTR _str2$1$[ebp], eax
	call	_xmlStrdup

; 968  : 
; 969  :     if (to->message != NULL)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _str3$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN4@xmlCopyErr

; 970  :         xmlFree(to->message);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlCopyErr:

; 971  :     if (to->file != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlCopyErr

; 972  :         xmlFree(to->file);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlCopyErr:

; 973  :     if (to->str1 != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@xmlCopyErr

; 974  :         xmlFree(to->str1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlCopyErr:

; 975  :     if (to->str2 != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN7@xmlCopyErr

; 976  :         xmlFree(to->str2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlCopyErr:

; 977  :     if (to->str3 != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN8@xmlCopyErr

; 978  :         xmlFree(to->str3);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlCopyErr:

; 979  :     to->domain = from->domain;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 980  :     to->code = from->code;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 981  :     to->level = from->level;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax

; 982  :     to->line = from->line;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], eax

; 983  :     to->node = from->node;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax

; 984  :     to->int1 = from->int1;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax

; 985  :     to->int2 = from->int2;

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax

; 986  :     to->node = from->node;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax

; 987  :     to->ctxt = from->ctxt;

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+44], eax

; 988  :     to->message = message;
; 989  :     to->file = file;

	mov	eax, DWORD PTR _file$1$[ebp]
	mov	DWORD PTR [esi+16], eax

; 990  :     to->str1 = str1;

	mov	eax, DWORD PTR _str1$1$[ebp]
	mov	DWORD PTR [esi+24], eax

; 991  :     to->str2 = str2;

	mov	eax, DWORD PTR _str2$1$[ebp]
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+28], eax

; 992  :     to->str3 = str3;

	mov	eax, DWORD PTR _str3$1$[ebp]

; 993  : 
; 994  :     return 0;

	pop	ebx
	mov	DWORD PTR [esi+32], eax
	xor	eax, eax
	pop	edi

; 995  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlCopyErr:
	pop	edi

; 961  :         return(-1);

	or	eax, -1

; 995  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCopyError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlResetError
_TEXT	SEGMENT
_err$ = 8						; size = 4
_xmlResetError PROC					; COMDAT

; 874  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _err$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlResetEr

; 875  :     if (err == NULL)
; 876  :         return;
; 877  :     if (err->code == XML_ERR_OK)

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN1@xmlResetEr

; 878  :         return;
; 879  :     if (err->message != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlResetEr

; 880  :         xmlFree(err->message);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlResetEr:

; 881  :     if (err->file != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlResetEr

; 882  :         xmlFree(err->file);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlResetEr:

; 883  :     if (err->str1 != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@xmlResetEr

; 884  :         xmlFree(err->str1);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlResetEr:

; 885  :     if (err->str2 != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN7@xmlResetEr

; 886  :         xmlFree(err->str2);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlResetEr:

; 887  :     if (err->str3 != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN8@xmlResetEr

; 888  :         xmlFree(err->str3);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN8@xmlResetEr:

; 889  :     memset(err, 0, sizeof(xmlError));

	push	52					; 00000034H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@xmlResetEr:
	pop	esi

; 890  :     err->code = XML_ERR_OK;
; 891  : }

	pop	ebp
	ret	0
_xmlResetError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlCtxtResetLastError
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlCtxtResetLastError PROC				; COMDAT

; 936  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlCtxtRes

; 937  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 938  : 
; 939  :     if (ctxt == NULL)
; 940  :         return;
; 941  :     ctxt->errNo = XML_ERR_OK;

	cmp	DWORD PTR [eax+388], 0
	mov	DWORD PTR [eax+84], 0

; 942  :     if (ctxt->lastError.code == XML_ERR_OK)

	je	SHORT $LN1@xmlCtxtRes

; 943  :         return;
; 944  :     xmlResetError(&ctxt->lastError);

	add	eax, 384				; 00000180H
	mov	DWORD PTR _ctx$[ebp], eax

; 945  : }

	pop	ebp

; 943  :         return;
; 944  :     xmlResetError(&ctxt->lastError);

	jmp	_xmlResetError
$LN1@xmlCtxtRes:

; 945  : }

	pop	ebp
	ret	0
_xmlCtxtResetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlCtxtGetLastError
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_xmlCtxtGetLastError PROC				; COMDAT

; 917  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlCtxtGet

; 918  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 919  : 
; 920  :     if (ctxt == NULL)
; 921  :         return (NULL);
; 922  :     if (ctxt->lastError.code == XML_ERR_OK)

	cmp	DWORD PTR [eax+388], 0
	je	SHORT $LN5@xmlCtxtGet

; 924  :     return (&ctxt->lastError);

	add	eax, 384				; 00000180H

; 925  : }

	pop	ebp
	ret	0
$LN5@xmlCtxtGet:

; 923  :         return (NULL);

	xor	eax, eax

; 925  : }

	pop	ebp
	ret	0
_xmlCtxtGetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlResetLastError
_TEXT	SEGMENT
_xmlResetLastError PROC					; COMDAT
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlLastError
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@xmlResetLa

; 902  :     if (xmlLastError.code == XML_ERR_OK)
; 903  :         return;
; 904  :     xmlResetError(&xmlLastError);

	call	___xmlLastError
	push	eax
	call	_xmlResetError
	pop	ecx
$LN1@xmlResetLa:

; 905  : }

	ret	0
_xmlResetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlGetLastError
_TEXT	SEGMENT
_xmlGetLastError PROC					; COMDAT
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlLastError
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@xmlGetLast

; 861  :     if (xmlLastError.code == XML_ERR_OK)
; 862  :         return (NULL);

	xor	eax, eax

; 864  : }

	ret	0
$LN2@xmlGetLast:

; 863  :     return (&xmlLastError);

	jmp	___xmlLastError
_xmlGetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserPrintFileContext
_TEXT	SEGMENT
_input$ = 8						; size = 4
_xmlParserPrintFileContext PROC				; COMDAT

; 230  : xmlParserPrintFileContext(xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	DWORD PTR _input$[ebp]
	call	_xmlParserPrintFileContextInternal
	add	esp, 12					; 0000000cH
	pop	esi

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,
; 232  :                                      xmlGenericErrorContext);
; 233  : }

	pop	ebp
	ret	0
_xmlParserPrintFileContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserPrintFileInfo
_TEXT	SEGMENT
tv184 = 8						; size = 4
_input$ = 8						; size = 4
_xmlParserPrintFileInfo PROC				; COMDAT

; 153  : xmlParserPrintFileInfo(xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _input$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlParserP

; 154  :     if (input != NULL) {
; 155  : 	if (input->filename)

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edi+4]
	call	___xmlGenericError
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR tv184[ebp], eax
	test	esi, esi
	je	SHORT $LN3@xmlParserP

; 156  : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, DWORD PTR [edi+4]
	call	___xmlGenericErrorContext
	push	DWORD PTR tv184[ebp]
	push	esi
	push	OFFSET ??_C@_07FCDHCGBN@?$CFs?3?$CFd?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 161  : 		    "Entity: line %d: ", input->line);
; 162  :     }
; 163  : }

	pop	ebp
	ret	0
$LN3@xmlParserP:

; 157  : 		    "%s:%d: ", input->filename,
; 158  : 		    input->line);
; 159  : 	else
; 160  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericErrorContext
	push	DWORD PTR tv184[ebp]
	push	OFFSET ??_C@_0BC@FMCMLLAH@Entity?3?5line?5?$CFd?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
$LN4@xmlParserP:
	pop	edi

; 161  : 		    "Entity: line %d: ", input->line);
; 162  :     }
; 163  : }

	pop	ebp
	ret	0
_xmlParserPrintFileInfo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserValidityWarning
_TEXT	SEGMENT
_prev_size$1$ = -8					; size = 4
_input$1$ = -4						; size = 4
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlParserValidityWarning PROC				; COMDAT

; 818  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR _input$1$[ebp], 0
	call	_xmlStrlen
	mov	edi, DWORD PTR _ctx$[ebp]
	add	esp, 4
	test	edi, edi
	je	SHORT $LN4@xmlParserV

; 819  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 820  :     xmlParserInputPtr input = NULL;
; 821  :     char * str;
; 822  :     int len = xmlStrlen((const xmlChar *) msg);
; 823  : 
; 824  :     if ((ctxt != NULL) && (len != 0) && (msg[len - 1] != ':')) {

	test	eax, eax
	je	SHORT $LN4@xmlParserV
	mov	ecx, DWORD PTR _msg$[ebp]
	cmp	BYTE PTR [eax+ecx-1], 58		; 0000003aH
	je	SHORT $LN4@xmlParserV

; 825  : 	input = ctxt->input;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _input$1$[ebp], eax

; 826  : 	if ((input->filename == NULL) && (ctxt->inputNr > 1))

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@xmlParserV
	mov	ecx, DWORD PTR [edi+40]
	cmp	ecx, 1
	jle	SHORT $LN5@xmlParserV

; 827  : 	    input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [eax+ecx*4-8]
	mov	DWORD PTR _input$1$[ebp], eax
$LN5@xmlParserV:

; 828  : 
; 829  : 	xmlParserPrintFileInfo(input);

	push	eax
	call	_xmlParserPrintFileInfo
	add	esp, 4
$LN4@xmlParserV:

; 830  :     }
; 831  : 
; 832  :     xmlGenericError(xmlGenericErrorContext, "validity warning: ");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BD@BMEBJKPI@validity?5warning?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 833  :     XML_GET_VAR_STR(msg, str);

	push	150					; 00000096H
	mov	DWORD PTR _prev_size$1$[ebp], -1
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	SHORT $LN21@xmlParserV
	mov	esi, 150				; 00000096H
$LL2@xmlParserV:
	mov	edi, DWORD PTR _msg$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	ebx
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 833  :     XML_GET_VAR_STR(msg, str);

	cmp	eax, ecx
	jle	SHORT $LN10@xmlParserV
	cmp	eax, esi
	jge	SHORT $LN9@xmlParserV
	cmp	DWORD PTR _prev_size$1$[ebp], eax
	je	SHORT $LN26@xmlParserV
	mov	DWORD PTR _prev_size$1$[ebp], eax
$LN9@xmlParserV:
	inc	esi
	add	esi, eax
	jmp	SHORT $LN11@xmlParserV
$LN10@xmlParserV:
	add	esi, 100				; 00000064H
$LN11@xmlParserV:
	push	esi
	push	ebx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@xmlParserV
	mov	ebx, eax
	cmp	esi, 64000				; 0000fa00H
	jl	SHORT $LL2@xmlParserV
$LN26@xmlParserV:
	mov	edi, DWORD PTR _ctx$[ebp]
$LN21@xmlParserV:

; 834  :     xmlGenericError(xmlGenericErrorContext, "%s", str);

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 835  :     if (str != NULL)

	test	ebx, ebx
	je	SHORT $LN13@xmlParserV

; 836  : 	xmlFree(str);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParserV:

; 837  : 
; 838  :     if (ctxt != NULL) {

	test	edi, edi
	je	SHORT $LN18@xmlParserV

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	DWORD PTR _input$1$[ebp]
	call	_xmlParserPrintFileContextInternal
	add	esp, 12					; 0000000cH
$LN18@xmlParserV:
	pop	edi

; 839  : 	xmlParserPrintFileContext(input);
; 840  :     }
; 841  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserValidityWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserValidityError
_TEXT	SEGMENT
_prev_size$1$ = -8					; size = 4
_input$1$ = -4						; size = 4
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlParserValidityError PROC				; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR _input$1$[ebp], 0
	call	_xmlStrlen
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $LN4@xmlParserV

; 775  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 776  :     xmlParserInputPtr input = NULL;
; 777  :     char * str;
; 778  :     int len = xmlStrlen((const xmlChar *) msg);
; 779  :     static int had_info = 0;
; 780  : 
; 781  :     if ((len > 1) && (msg[len - 2] != ':')) {

	mov	ecx, DWORD PTR _msg$[ebp]
	cmp	BYTE PTR [eax+ecx-2], 58		; 0000003aH
	je	SHORT $LN4@xmlParserV

; 782  : 	if (ctxt != NULL) {

	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlParserV

; 783  : 	    input = ctxt->input;

	mov	ebx, DWORD PTR [eax+36]
	mov	DWORD PTR _input$1$[ebp], ebx

; 784  : 	    if ((input->filename == NULL) && (ctxt->inputNr > 1))

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN7@xmlParserV
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN7@xmlParserV

; 785  : 		input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR [eax+48]
	mov	ebx, DWORD PTR [eax+ecx*4-8]
	mov	DWORD PTR _input$1$[ebp], ebx
$LN7@xmlParserV:

; 786  : 
; 787  : 	    if (had_info == 0) {

	cmp	DWORD PTR ?had_info@?1??xmlParserValidityError@@9@9, 0
	jne	SHORT $LN8@xmlParserV

; 788  : 		xmlParserPrintFileInfo(input);

	push	ebx
	call	_xmlParserPrintFileInfo
	add	esp, 4
$LN8@xmlParserV:

; 789  : 	    }
; 790  : 	}
; 791  : 	xmlGenericError(xmlGenericErrorContext, "validity error: ");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0BB@DJCEBDOI@validity?5error?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 792  : 	had_info = 0;

	xor	eax, eax

; 793  :     } else {

	jmp	SHORT $LN5@xmlParserV
$LN4@xmlParserV:

; 794  : 	had_info = 1;

	mov	eax, 1
$LN5@xmlParserV:

; 797  :     XML_GET_VAR_STR(msg, str);

	push	150					; 00000096H
	mov	DWORD PTR ?had_info@?1??xmlParserValidityError@@9@9, eax
	mov	DWORD PTR _prev_size$1$[ebp], -1
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	SHORT $LN29@xmlParserV
	mov	esi, 150				; 00000096H
$LL2@xmlParserV:
	mov	edi, DWORD PTR _msg$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	ebx
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 797  :     XML_GET_VAR_STR(msg, str);

	cmp	eax, ecx
	jle	SHORT $LN13@xmlParserV
	cmp	eax, esi
	jge	SHORT $LN12@xmlParserV
	cmp	DWORD PTR _prev_size$1$[ebp], eax
	je	SHORT $LN29@xmlParserV
	mov	DWORD PTR _prev_size$1$[ebp], eax
$LN12@xmlParserV:
	inc	esi
	add	esi, eax
	jmp	SHORT $LN14@xmlParserV
$LN13@xmlParserV:
	add	esi, 100				; 00000064H
$LN14@xmlParserV:
	push	esi
	push	ebx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParserV
	mov	ebx, eax
	cmp	esi, 64000				; 0000fa00H
	jl	SHORT $LL2@xmlParserV
$LN29@xmlParserV:

; 798  :     xmlGenericError(xmlGenericErrorContext, "%s", str);

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 799  :     if (str != NULL)

	test	ebx, ebx
	je	SHORT $LN16@xmlParserV

; 800  : 	xmlFree(str);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlParserV:

; 801  : 
; 802  :     if ((ctxt != NULL) && (input != NULL)) {

	cmp	DWORD PTR _ctx$[ebp], 0
	je	SHORT $LN21@xmlParserV
	mov	edi, DWORD PTR _input$1$[ebp]
	test	edi, edi
	je	SHORT $LN21@xmlParserV

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	edi
	call	_xmlParserPrintFileContextInternal
	add	esp, 12					; 0000000cH
$LN21@xmlParserV:
	pop	edi

; 803  : 	xmlParserPrintFileContext(input);
; 804  :     }
; 805  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserValidityError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserWarning
_TEXT	SEGMENT
_cur$1$ = -12						; size = 4
_prev_size$1$ = -8					; size = 4
_input$1$ = -4						; size = 4
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlParserWarning PROC					; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	xor	edi, edi
	mov	DWORD PTR _input$1$[ebp], 0
	mov	DWORD PTR _cur$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN4@xmlParserW

; 726  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 727  :     xmlParserInputPtr input = NULL;
; 728  :     xmlParserInputPtr cur = NULL;
; 729  :     char * str;
; 730  : 
; 731  :     if (ctxt != NULL) {
; 732  : 	input = ctxt->input;

	mov	edi, DWORD PTR [eax+36]
	mov	DWORD PTR _input$1$[ebp], edi

; 733  : 	if ((input != NULL) && (input->filename == NULL) &&

	test	edi, edi
	je	SHORT $LN5@xmlParserW
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN5@xmlParserW
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN5@xmlParserW

; 734  : 	    (ctxt->inputNr > 1)) {
; 735  : 	    cur = input;
; 736  : 	    input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR _cur$1$[ebp], edi
	mov	edi, DWORD PTR [eax+ecx*4-8]
	mov	DWORD PTR _input$1$[ebp], edi
$LN5@xmlParserW:

; 737  : 	}
; 738  : 	xmlParserPrintFileInfo(input);

	push	edi
	call	_xmlParserPrintFileInfo
	add	esp, 4
$LN4@xmlParserW:

; 739  :     }
; 740  : 
; 741  :     xmlGenericError(xmlGenericErrorContext, "warning: ");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_09GFHECBDK@warning?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 742  :     XML_GET_VAR_STR(msg, str);

	push	150					; 00000096H
	mov	DWORD PTR _prev_size$1$[ebp], -1
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	SHORT $LN29@xmlParserW
	mov	esi, 150				; 00000096H
	npad	5
$LL2@xmlParserW:
	mov	edi, DWORD PTR _msg$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	ebx
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 742  :     XML_GET_VAR_STR(msg, str);

	cmp	eax, ecx
	jle	SHORT $LN10@xmlParserW
	cmp	eax, esi
	jge	SHORT $LN9@xmlParserW
	cmp	DWORD PTR _prev_size$1$[ebp], eax
	je	SHORT $LN29@xmlParserW
	mov	DWORD PTR _prev_size$1$[ebp], eax
$LN9@xmlParserW:
	inc	esi
	add	esi, eax
	jmp	SHORT $LN11@xmlParserW
$LN10@xmlParserW:
	add	esi, 100				; 00000064H
$LN11@xmlParserW:
	push	esi
	push	ebx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParserW
	mov	ebx, eax
	cmp	esi, 64000				; 0000fa00H
	jl	SHORT $LL2@xmlParserW
$LN29@xmlParserW:

; 743  :     xmlGenericError(xmlGenericErrorContext, "%s", str);

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 744  :     if (str != NULL)

	test	ebx, ebx
	je	SHORT $LN13@xmlParserW

; 745  : 	xmlFree(str);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParserW:

; 746  : 
; 747  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctx$[ebp], 0
	je	SHORT $LN21@xmlParserW

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	DWORD PTR _input$1$[ebp]
	call	_xmlParserPrintFileContextInternal

; 748  : 	xmlParserPrintFileContext(input);
; 749  : 	if (cur != NULL) {

	mov	ebx, DWORD PTR _cur$1$[ebp]

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	add	esp, 12					; 0000000cH

; 748  : 	xmlParserPrintFileContext(input);
; 749  : 	if (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN21@xmlParserW

; 750  : 	    xmlParserPrintFileInfo(cur);

	push	ebx
	call	_xmlParserPrintFileInfo

; 751  : 	    xmlGenericError(xmlGenericErrorContext, "\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	ebx
	call	_xmlParserPrintFileContextInternal
	add	esp, 24					; 00000018H
$LN21@xmlParserW:
	pop	edi

; 752  : 	    xmlParserPrintFileContext(cur);
; 753  : 	}
; 754  :     }
; 755  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserWarning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlParserError
_TEXT	SEGMENT
_cur$1$ = -12						; size = 4
_prev_size$1$ = -8					; size = 4
_input$1$ = -4						; size = 4
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlParserError PROC					; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	xor	edi, edi
	mov	DWORD PTR _input$1$[ebp], 0
	mov	DWORD PTR _cur$1$[ebp], edi
	test	eax, eax
	je	SHORT $LN4@xmlParserE

; 683  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 684  :     xmlParserInputPtr input = NULL;
; 685  :     xmlParserInputPtr cur = NULL;
; 686  :     char * str;
; 687  : 
; 688  :     if (ctxt != NULL) {
; 689  : 	input = ctxt->input;

	mov	edi, DWORD PTR [eax+36]
	mov	DWORD PTR _input$1$[ebp], edi

; 690  : 	if ((input != NULL) && (input->filename == NULL) &&

	test	edi, edi
	je	SHORT $LN5@xmlParserE
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN5@xmlParserE
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN5@xmlParserE

; 691  : 	    (ctxt->inputNr > 1)) {
; 692  : 	    cur = input;
; 693  : 	    input = ctxt->inputTab[ctxt->inputNr - 2];

	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR _cur$1$[ebp], edi
	mov	edi, DWORD PTR [eax+ecx*4-8]
	mov	DWORD PTR _input$1$[ebp], edi
$LN5@xmlParserE:

; 694  : 	}
; 695  : 	xmlParserPrintFileInfo(input);

	push	edi
	call	_xmlParserPrintFileInfo
	add	esp, 4
$LN4@xmlParserE:

; 696  :     }
; 697  : 
; 698  :     xmlGenericError(xmlGenericErrorContext, "error: ");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_07FJOHCPOO@error?3?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 699  :     XML_GET_VAR_STR(msg, str);

	push	150					; 00000096H
	mov	DWORD PTR _prev_size$1$[ebp], -1
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	SHORT $LN29@xmlParserE
	mov	esi, 150				; 00000096H
	npad	5
$LL2@xmlParserE:
	mov	edi, DWORD PTR _msg$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	esi
	push	ebx
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c

; 699  :     XML_GET_VAR_STR(msg, str);

	cmp	eax, ecx
	jle	SHORT $LN10@xmlParserE
	cmp	eax, esi
	jge	SHORT $LN9@xmlParserE
	cmp	DWORD PTR _prev_size$1$[ebp], eax
	je	SHORT $LN29@xmlParserE
	mov	DWORD PTR _prev_size$1$[ebp], eax
$LN9@xmlParserE:
	inc	esi
	add	esi, eax
	jmp	SHORT $LN11@xmlParserE
$LN10@xmlParserE:
	add	esi, 100				; 00000064H
$LN11@xmlParserE:
	push	esi
	push	ebx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlParserE
	mov	ebx, eax
	cmp	esi, 64000				; 0000fa00H
	jl	SHORT $LL2@xmlParserE
$LN29@xmlParserE:

; 700  :     xmlGenericError(xmlGenericErrorContext, "%s", str);

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 701  :     if (str != NULL)

	test	ebx, ebx
	je	SHORT $LN13@xmlParserE

; 702  : 	xmlFree(str);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN13@xmlParserE:

; 703  : 
; 704  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctx$[ebp], 0
	je	SHORT $LN21@xmlParserE

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	DWORD PTR _input$1$[ebp]
	call	_xmlParserPrintFileContextInternal

; 705  : 	xmlParserPrintFileContext(input);
; 706  : 	if (cur != NULL) {

	mov	ebx, DWORD PTR _cur$1$[ebp]

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	add	esp, 12					; 0000000cH

; 705  : 	xmlParserPrintFileContext(input);
; 706  : 	if (cur != NULL) {

	test	ebx, ebx
	je	SHORT $LN21@xmlParserE

; 707  : 	    xmlParserPrintFileInfo(cur);

	push	ebx
	call	_xmlParserPrintFileInfo

; 708  : 	    xmlGenericError(xmlGenericErrorContext, "\n");

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 231  :    xmlParserPrintFileContextInternal(input, xmlGenericError,

	call	___xmlGenericErrorContext
	mov	esi, DWORD PTR [eax]
	call	___xmlGenericError
	push	esi
	push	DWORD PTR [eax]
	push	ebx
	call	_xmlParserPrintFileContextInternal
	add	esp, 24					; 00000018H
$LN21@xmlParserE:
	pop	edi

; 709  : 	    xmlParserPrintFileContext(cur);
; 710  : 	}
; 711  :     }
; 712  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlSetStructuredErrorFunc
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_handler$ = 12						; size = 4
_xmlSetStructuredErrorFunc PROC				; COMDAT

; 134  : xmlSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlStructuredErrorContext
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [eax], ecx
	call	___xmlStructuredError
	mov	ecx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [eax], ecx

; 135  :     xmlStructuredErrorContext = ctx;
; 136  :     xmlStructuredError = handler;
; 137  : }

	pop	ebp
	ret	0
_xmlSetStructuredErrorFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _initGenericErrorDefaultFunc
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_initGenericErrorDefaultFunc PROC			; COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericError
	mov	ecx, eax
	mov	eax, DWORD PTR _handler$[ebp]
	test	eax, eax
	jne	SHORT $LN2@initGeneri

; 96   : }

	mov	DWORD PTR [ecx], OFFSET _xmlGenericErrorDefaultFunc
	pop	ebp
	ret	0
$LN2@initGeneri:

; 92   :     if (handler == NULL)
; 93   :         xmlGenericError = xmlGenericErrorDefaultFunc;
; 94   :     else
; 95   :         xmlGenericError = (*handler);

	mov	eax, DWORD PTR [eax]

; 96   : }

	mov	DWORD PTR [ecx], eax
	pop	ebp
	ret	0
_initGenericErrorDefaultFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\error.c
;	COMDAT _xmlSetGenericErrorFunc
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_handler$ = 12						; size = 4
_xmlSetGenericErrorFunc PROC				; COMDAT

; 113  : xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _handler$[ebp]
	mov	ecx, OFFSET __67926DEE_error@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR [eax], ecx
	call	___xmlGenericError
	test	esi, esi
	mov	ecx, OFFSET _xmlGenericErrorDefaultFunc
	cmove	esi, ecx
	mov	DWORD PTR [eax], esi
	pop	esi

; 114  :     xmlGenericErrorContext = ctx;
; 115  :     if (handler != NULL)
; 116  : 	xmlGenericError = handler;
; 117  :     else
; 118  : 	xmlGenericError = xmlGenericErrorDefaultFunc;
; 119  : }

	pop	ebp
	ret	0
_xmlSetGenericErrorFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vfprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vfprintf PROC						; COMDAT

; 656  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 657  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 658  :     }

	pop	ebp
	ret	0
_vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
