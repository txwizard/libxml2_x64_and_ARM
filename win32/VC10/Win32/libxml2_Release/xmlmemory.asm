; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlmemory.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__7B7A869E_ctype@h DB 01H
__D8018AA9_xmlmemory@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_fprintf
PUBLIC	_sscanf
PUBLIC	_xmlMemSetup
PUBLIC	_xmlMemGet
PUBLIC	_xmlGcMemSetup
PUBLIC	_xmlGcMemGet
PUBLIC	_xmlInitMemory
PUBLIC	_xmlCleanupMemory
PUBLIC	_xmlMemUsed
PUBLIC	_xmlMemBlocks
PUBLIC	_xmlMemDisplay
PUBLIC	_xmlMemDisplayLast
PUBLIC	_xmlMemShow
PUBLIC	_xmlMemoryDump
PUBLIC	_xmlMemMalloc
PUBLIC	_xmlMemRealloc
PUBLIC	_xmlMemFree
PUBLIC	_xmlMemoryStrdup
PUBLIC	_xmlMallocLoc
PUBLIC	_xmlReallocLoc
PUBLIC	_xmlMallocAtomicLoc
PUBLIC	_xmlMemStrdupLoc
PUBLIC	_xmlMallocBreakpoint
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@ ; `string'
PUBLIC	??_C@_0CC@KENAJNOB@xmlMallocLoc?5?3?5Unsigned?5overflo@ ; `string'
PUBLIC	??_C@_0CC@GHPBNICE@xmlMallocLoc?5?3?5Out?5of?5free?5spac@ ; `string'
PUBLIC	??_C@_0BF@EOHFMDNL@?$CFp?5?3?5Malloc?$CI?$CFlu?$CJ?5Ok?6@ ; `string'
PUBLIC	??_C@_0CI@KCPHLLJL@xmlMallocAtomicLoc?5?3?5Unsigned?5o@ ; `string'
PUBLIC	??_C@_0CI@GBNGPOFO@xmlMallocAtomicLoc?5?3?5Out?5of?5fre@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_0CD@EKEGIKEO@xmlReallocLoc?5?3?5Unsigned?5overfl@ ; `string'
PUBLIC	??_C@_0BP@EHGEOOF@?$CFp?5?3?5Realloced?$CI?$CFlu?5?9?$DO?5?$CFlu?$CJ?5Ok?6@ ; `string'
PUBLIC	??_C@_0CI@FDKALOEN@trying?5to?5free?5pointer?5from?5fre@ ; `string'
PUBLIC	??_C@_0O@EGNDPFML@?$CFp?5?3?5Freed?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0BG@PIJFHHCD@xmlMemFree?$CI?$CFp?$CJ?5error?6@ ; `string'
PUBLIC	??_C@_0CF@MMHEHJPP@xmlMemStrdupLoc?5?3?5Unsigned?5over@ ; `string'
PUBLIC	??_C@_0BC@KPBPMJFD@?$CFp?5?3?5Strdup?$CI?$CJ?5Ok?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0M@CNJBCEKM@?4memorylist@			; `string'
PUBLIC	??_C@_0DD@OBJABBCC@Memory?5list?5not?5compiled?5?$CIMEM_L@ ; `string'
PUBLIC	??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@ ; `string'
PUBLIC	??_C@_0CL@DBCIPLIB@?5?5?5?5?5?5MEMORY?5ALLOCATED?5?3?5?$CFlu?0?5M@ ; `string'
PUBLIC	??_C@_0BD@GCGPPOKD@XML_MEM_BREAKPOINT@		; `string'
PUBLIC	??_C@_03BKPMHLPH@?$CFud@			; `string'
PUBLIC	??_C@_0O@IPGKJECE@XML_MEM_TRACE@		; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__getenv:PROC
EXTRN	_xmlNewMutex:PROC
EXTRN	_xmlMutexLock:PROC
EXTRN	_xmlMutexUnlock:PROC
EXTRN	_xmlFreeMutex:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlMemInitialized DD 01H DUP (?)
_debugMemSize DD 01H DUP (?)
_debugMemBlocks DD 01H DUP (?)
_debugMaxMemSize DD 01H DUP (?)
_xmlMemMutex DD	01H DUP (?)
_block	DD	01H DUP (?)
_xmlMemStopAtBlock DD 01H DUP (?)
_xmlMemTraceBlockAt DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPGKJECE@XML_MEM_TRACE@
CONST	SEGMENT
??_C@_0O@IPGKJECE@XML_MEM_TRACE@ DB 'XML_MEM_TRACE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BKPMHLPH@?$CFud@
CONST	SEGMENT
??_C@_03BKPMHLPH@?$CFud@ DB '%ud', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GCGPPOKD@XML_MEM_BREAKPOINT@
CONST	SEGMENT
??_C@_0BD@GCGPPOKD@XML_MEM_BREAKPOINT@ DB 'XML_MEM_BREAKPOINT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DBCIPLIB@?5?5?5?5?5?5MEMORY?5ALLOCATED?5?3?5?$CFlu?0?5M@
CONST	SEGMENT
??_C@_0CL@DBCIPLIB@?5?5?5?5?5?5MEMORY?5ALLOCATED?5?3?5?$CFlu?0?5M@ DB '  '
	DB	'    MEMORY ALLOCATED : %lu, MAX was %lu', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@
CONST	SEGMENT
??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@ DB 'Memor'
	DB	'y tag error occurs :%p ', 0aH, 09H, ' bye', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OBJABBCC@Memory?5list?5not?5compiled?5?$CIMEM_L@
CONST	SEGMENT
??_C@_0DD@OBJABBCC@Memory?5list?5not?5compiled?5?$CIMEM_L@ DB 'Memory lis'
	DB	't not compiled (MEM_LIST not defined !)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CNJBCEKM@?4memorylist@
CONST	SEGMENT
??_C@_0M@CNJBCEKM@?4memorylist@ DB '.memorylist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPBPMJFD@?$CFp?5?3?5Strdup?$CI?$CJ?5Ok?6@
CONST	SEGMENT
??_C@_0BC@KPBPMJFD@?$CFp?5?3?5Strdup?$CI?$CJ?5Ok?6@ DB '%p : Strdup() Ok', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MMHEHJPP@xmlMemStrdupLoc?5?3?5Unsigned?5over@
CONST	SEGMENT
??_C@_0CF@MMHEHJPP@xmlMemStrdupLoc?5?3?5Unsigned?5over@ DB 'xmlMemStrdupL'
	DB	'oc : Unsigned overflow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PIJFHHCD@xmlMemFree?$CI?$CFp?$CJ?5error?6@
CONST	SEGMENT
??_C@_0BG@PIJFHHCD@xmlMemFree?$CI?$CFp?$CJ?5error?6@ DB 'xmlMemFree(%p) e'
	DB	'rror', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EGNDPFML@?$CFp?5?3?5Freed?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0O@EGNDPFML@?$CFp?5?3?5Freed?$CI?$CJ?6@ DB '%p : Freed()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDKALOEN@trying?5to?5free?5pointer?5from?5fre@
CONST	SEGMENT
??_C@_0CI@FDKALOEN@trying?5to?5free?5pointer?5from?5fre@ DB 'trying to fr'
	DB	'ee pointer from freed area', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EHGEOOF@?$CFp?5?3?5Realloced?$CI?$CFlu?5?9?$DO?5?$CFlu?$CJ?5Ok?6@
CONST	SEGMENT
??_C@_0BP@EHGEOOF@?$CFp?5?3?5Realloced?$CI?$CFlu?5?9?$DO?5?$CFlu?$CJ?5Ok?6@ DB '%'
	DB	'p : Realloced(%lu -> %lu) Ok', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EKEGIKEO@xmlReallocLoc?5?3?5Unsigned?5overfl@
CONST	SEGMENT
??_C@_0CD@EKEGIKEO@xmlReallocLoc?5?3?5Unsigned?5overfl@ DB 'xmlReallocLoc'
	DB	' : Unsigned overflow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GBNGPOFO@xmlMallocAtomicLoc?5?3?5Out?5of?5fre@
CONST	SEGMENT
??_C@_0CI@GBNGPOFO@xmlMallocAtomicLoc?5?3?5Out?5of?5fre@ DB 'xmlMallocAto'
	DB	'micLoc : Out of free space', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KCPHLLJL@xmlMallocAtomicLoc?5?3?5Unsigned?5o@
CONST	SEGMENT
??_C@_0CI@KCPHLLJL@xmlMallocAtomicLoc?5?3?5Unsigned?5o@ DB 'xmlMallocAtom'
	DB	'icLoc : Unsigned overflow', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EOHFMDNL@?$CFp?5?3?5Malloc?$CI?$CFlu?$CJ?5Ok?6@
CONST	SEGMENT
??_C@_0BF@EOHFMDNL@?$CFp?5?3?5Malloc?$CI?$CFlu?$CJ?5Ok?6@ DB '%p : Malloc'
	DB	'(%lu) Ok', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GHPBNICE@xmlMallocLoc?5?3?5Out?5of?5free?5spac@
CONST	SEGMENT
??_C@_0CC@GHPBNICE@xmlMallocLoc?5?3?5Out?5of?5free?5spac@ DB 'xmlMallocLo'
	DB	'c : Out of free space', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KENAJNOB@xmlMallocLoc?5?3?5Unsigned?5overflo@
CONST	SEGMENT
??_C@_0CC@KENAJNOB@xmlMallocLoc?5?3?5Unsigned?5overflo@ DB 'xmlMallocLoc '
	DB	': Unsigned overflow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@
CONST	SEGMENT
??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@ DB 'xmlMallocBreak'
	DB	'point reached on block %d', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _debugmem_tag_error
_TEXT	SEGMENT
_p$ = 8							; size = 4
_debugmem_tag_error PROC				; COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _p$[ebp]
	push	OFFSET ??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi

; 864  :      xmlGenericError(xmlGenericErrorContext,
; 865  : 	     "Memory tag error occurs :%p \n\t bye\n", p);
; 866  : #ifdef MEM_LIST
; 867  :      if (stderr)
; 868  :      xmlMemDisplay(stderr);
; 869  : #endif
; 870  : }

	pop	ebp
	ret	0
_debugmem_tag_error ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMallocBreakpoint
_TEXT	SEGMENT
_xmlMallocBreakpoint PROC				; COMDAT

; 145  : xmlMallocBreakpoint(void) {

	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _xmlMemStopAtBlock
	push	OFFSET ??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	esi
	ret	0
_xmlMallocBreakpoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemStrdupLoc
_TEXT	SEGMENT
_str$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_xmlMemStrdupLoc PROC					; COMDAT

; 508  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL15@xmlMemStrd:

; 509  :     char *s;
; 510  :     size_t size = strlen(str) + 1;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL15@xmlMemStrd
	sub	ecx, edx

; 511  :     MEMHDR *p;
; 512  : 
; 513  :     if (!xmlMemInitialized) xmlInitMemory();

	cmp	DWORD PTR _xmlMemInitialized, 0
	lea	ebx, DWORD PTR [ecx+1]
	jne	SHORT $LN2@xmlMemStrd
	call	_xmlInitMemory
$LN2@xmlMemStrd:

; 514  :     TEST_POINT
; 515  : 
; 516  :     if (size > (MAX_SIZE_T - RESERVE_SIZE)) {

	cmp	ebx, -25				; ffffffe7H
	jbe	SHORT $LN3@xmlMemStrd

; 517  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CF@MMHEHJPP@xmlMemStrdupLoc?5?3?5Unsigned?5over@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 518  : 		"xmlMemStrdupLoc : Unsigned overflow\n");
; 519  : 	xmlMemoryDump();
; 520  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 557  : 
; 558  : error:
; 559  :     return(NULL);
; 560  : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlMemStrd:

; 521  :     }
; 522  : 
; 523  :     p = (MEMHDR *) malloc(RESERVE_SIZE+size);

	lea	eax, DWORD PTR [ebx+24]
	push	edi
	push	eax
	call	DWORD PTR __imp__malloc
	mov	edi, eax
	add	esp, 4

; 524  :     if (!p) {

	test	edi, edi
	jne	SHORT $LN4@xmlMemStrd
$error$18:
	pop	edi
	pop	esi

; 557  : 
; 558  : error:
; 559  :     return(NULL);
; 560  : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlMemStrd:

; 525  :       goto error;
; 526  :     }
; 527  :     p->mh_tag = MEMTAG;
; 528  :     p->mh_size = size;
; 529  :     p->mh_type = STRDUP_TYPE;
; 530  :     p->mh_file = file;

	mov	eax, DWORD PTR _file$[ebp]

; 531  :     p->mh_line = line;
; 532  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [edi], 23205			; 00005aa5H
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+4], 3
	mov	DWORD PTR [edi+20], eax
	call	_xmlMutexLock

; 533  :     p->mh_number = ++block;

	mov	eax, DWORD PTR _block

; 534  :     debugMemSize += size;

	mov	ecx, DWORD PTR _debugMemSize
	inc	eax

; 535  :     debugMemBlocks++;

	inc	DWORD PTR _debugMemBlocks
	add	ecx, ebx

; 536  :     if (debugMemSize > debugMaxMemSize) debugMaxMemSize = debugMemSize;
; 537  : #ifdef MEM_LIST
; 538  :     debugmem_list_add(p);
; 539  : #endif
; 540  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR _block, eax
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR _debugMaxMemSize
	cmp	ecx, eax
	mov	DWORD PTR _debugMemSize, ecx
	cmova	eax, ecx
	mov	DWORD PTR _debugMaxMemSize, eax
	call	_xmlMutexUnlock

; 541  : 
; 542  :     s = (char *) HDR_2_CLIENT(p);
; 543  : 
; 544  :     if (xmlMemStopAtBlock == p->mh_number) xmlMallocBreakpoint();

	mov	eax, DWORD PTR _xmlMemStopAtBlock
	lea	ebx, DWORD PTR [edi+24]
	add	esp, 8
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN6@xmlMemStrd
	call	_xmlMallocBreakpoint
$LN6@xmlMemStrd:

; 545  : 
; 546  :     strcpy(s,str);

	mov	ecx, ebx
	sub	ecx, esi
	npad	5
$LL9@xmlMemStrd:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL9@xmlMemStrd

; 547  : 
; 548  :     TEST_POINT
; 549  : 
; 550  :     if (xmlMemTraceBlockAt == s) {

	cmp	DWORD PTR _xmlMemTraceBlockAt, ebx
	jne	SHORT $LN7@xmlMemStrd

; 551  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _xmlMemTraceBlockAt
	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_0BC@KPBPMJFD@?$CFp?5?3?5Strdup?$CI?$CJ?5Ok?6@
	push	DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH

; 552  : 			"%p : Strdup() Ok\n", xmlMemTraceBlockAt);
; 553  : 	xmlMallocBreakpoint();

	call	_xmlMallocBreakpoint
$LN7@xmlMemStrd:

; 554  :     }
; 555  : 
; 556  :     return(s);

	pop	edi
	pop	esi
	mov	eax, ebx

; 557  : 
; 558  : error:
; 559  :     return(NULL);
; 560  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlMemStrdupLoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMallocAtomicLoc
_TEXT	SEGMENT
_size$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_xmlMallocAtomicLoc PROC				; COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlMemInitialized, 0
	jne	SHORT $LN2@xmlMallocA

; 240  :     MEMHDR *p;
; 241  :     void *ret;
; 242  : 
; 243  :     if (!xmlMemInitialized) xmlInitMemory();

	call	_xmlInitMemory
$LN2@xmlMallocA:
	push	esi
	push	edi

; 244  : #ifdef DEBUG_MEMORY
; 245  :     xmlGenericError(xmlGenericErrorContext,
; 246  : 	    "Malloc(%d)\n",size);
; 247  : #endif
; 248  : 
; 249  :     TEST_POINT
; 250  : 
; 251  :     if (size > (MAX_SIZE_T - RESERVE_SIZE)) {

	mov	edi, DWORD PTR _size$[ebp]
	cmp	edi, -25				; ffffffe7H
	jbe	SHORT $LN3@xmlMallocA

; 252  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CI@KCPHLLJL@xmlMallocAtomicLoc?5?3?5Unsigned?5o@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 253  : 		"xmlMallocAtomicLoc : Unsigned overflow\n");
; 254  : 	xmlMemoryDump();
; 255  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 300  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlMallocA:

; 256  :     }
; 257  : 
; 258  :     p = (MEMHDR *) malloc(RESERVE_SIZE+size);

	lea	eax, DWORD PTR [edi+24]
	push	eax
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 259  : 
; 260  :     if (!p) {

	test	esi, esi
	jne	SHORT $LN4@xmlMallocA

; 261  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CI@GBNGPOFO@xmlMallocAtomicLoc?5?3?5Out?5of?5fre@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 262  : 		"xmlMallocAtomicLoc : Out of free space\n");
; 263  : 	xmlMemoryDump();
; 264  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 300  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlMallocA:

; 265  :     }
; 266  :     p->mh_tag = MEMTAG;
; 267  :     p->mh_size = size;
; 268  :     p->mh_type = MALLOC_ATOMIC_TYPE;
; 269  :     p->mh_file = file;

	mov	eax, DWORD PTR _file$[ebp]

; 270  :     p->mh_line = line;
; 271  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [esi], 23205			; 00005aa5H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 4
	mov	DWORD PTR [esi+20], eax
	call	_xmlMutexLock

; 272  :     p->mh_number = ++block;

	mov	eax, DWORD PTR _block

; 273  :     debugMemSize += size;

	mov	ecx, DWORD PTR _debugMemSize
	inc	eax

; 274  :     debugMemBlocks++;

	inc	DWORD PTR _debugMemBlocks
	add	ecx, edi

; 275  :     if (debugMemSize > debugMaxMemSize) debugMaxMemSize = debugMemSize;
; 276  : #ifdef MEM_LIST
; 277  :     debugmem_list_add(p);
; 278  : #endif
; 279  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR _block, eax
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _debugMaxMemSize
	cmp	ecx, eax
	mov	DWORD PTR _debugMemSize, ecx
	cmova	eax, ecx
	mov	DWORD PTR _debugMaxMemSize, eax
	call	_xmlMutexUnlock

; 280  : 
; 281  : #ifdef DEBUG_MEMORY
; 282  :     xmlGenericError(xmlGenericErrorContext,
; 283  : 	    "Malloc(%d) Ok\n",size);
; 284  : #endif
; 285  : 
; 286  :     if (xmlMemStopAtBlock == p->mh_number) xmlMallocBreakpoint();

	mov	eax, DWORD PTR _xmlMemStopAtBlock
	add	esp, 8
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN6@xmlMallocA
	call	_xmlMallocBreakpoint
$LN6@xmlMallocA:
	push	ebx

; 287  : 
; 288  :     ret = HDR_2_CLIENT(p);

	lea	ebx, DWORD PTR [esi+24]

; 289  : 
; 290  :     if (xmlMemTraceBlockAt == ret) {

	cmp	DWORD PTR _xmlMemTraceBlockAt, ebx
	jne	SHORT $LN7@xmlMallocA

; 291  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	push	edi
	push	DWORD PTR _xmlMemTraceBlockAt
	push	OFFSET ??_C@_0BF@EOHFMDNL@?$CFp?5?3?5Malloc?$CI?$CFlu?$CJ?5Ok?6@
	push	DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H

; 292  : 			"%p : Malloc(%lu) Ok\n", xmlMemTraceBlockAt,
; 293  : 			(long unsigned)size);
; 294  : 	xmlMallocBreakpoint();

	call	_xmlMallocBreakpoint
$LN7@xmlMallocA:

; 295  :     }
; 296  : 
; 297  :     TEST_POINT
; 298  : 
; 299  :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 300  : }

	pop	esi
	pop	ebp
	ret	0
_xmlMallocAtomicLoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlReallocLoc
_TEXT	SEGMENT
_number$1$ = -4						; size = 4
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_file$ = 16						; size = 4
_line$ = 20						; size = 4
_xmlReallocLoc PROC					; COMDAT

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ptr$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlRealloc

; 331  :     MEMHDR *p, *tmp;
; 332  :     unsigned long number;
; 333  : #ifdef DEBUG_MEMORY
; 334  :     size_t oldsize;
; 335  : #endif
; 336  : 
; 337  :     if (ptr == NULL)
; 338  :         return(xmlMallocLoc(size, file, line));

	push	DWORD PTR _line$[ebp]
	push	DWORD PTR _file$[ebp]
	push	DWORD PTR _size$[ebp]
	call	_xmlMallocLoc
	add	esp, 12					; 0000000cH
	pop	esi

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlRealloc:

; 339  : 
; 340  :     if (!xmlMemInitialized) xmlInitMemory();

	cmp	DWORD PTR _xmlMemInitialized, 0
	jne	SHORT $LN3@xmlRealloc
	call	_xmlInitMemory
$LN3@xmlRealloc:

; 341  :     TEST_POINT
; 342  : 
; 343  :     p = CLIENT_2_HDR(ptr);
; 344  :     number = p->mh_number;

	mov	eax, DWORD PTR [esi-16]
	push	edi
	lea	edi, DWORD PTR [esi-24]
	mov	DWORD PTR _number$1$[ebp], eax

; 345  :     if (xmlMemStopAtBlock == number) xmlMallocBreakpoint();

	cmp	DWORD PTR _xmlMemStopAtBlock, eax
	jne	SHORT $LN11@xmlRealloc

; 146  :     xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _xmlMemStopAtBlock
	push	OFFSET ??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _ptr$[ebp]
	add	esp, 12					; 0000000cH
$LN11@xmlRealloc:

; 346  :     if (p->mh_tag != MEMTAG) {

	cmp	DWORD PTR [edi], 23205			; 00005aa5H
	push	ebx
	je	SHORT $LN5@xmlRealloc

; 864  :      xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 404  : 
; 405  : error:
; 406  :     return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlRealloc:

; 347  :        Mem_Tag_Err(p);
; 348  : 	 goto error;
; 349  :     }
; 350  :     p->mh_tag = ~MEMTAG;
; 351  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR [edi], -23206			; ffffa55aH
	call	_xmlMutexLock

; 352  :     debugMemSize -= p->mh_size;

	mov	eax, DWORD PTR [edi+12]

; 353  :     debugMemBlocks--;
; 354  : #ifdef DEBUG_MEMORY
; 355  :     oldsize = p->mh_size;
; 356  : #endif
; 357  : #ifdef MEM_LIST
; 358  :     debugmem_list_delete(p);
; 359  : #endif
; 360  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	sub	DWORD PTR _debugMemSize, eax
	dec	DWORD PTR _debugMemBlocks
	call	_xmlMutexUnlock

; 361  : 
; 362  :     if (size > (MAX_SIZE_T - RESERVE_SIZE)) {

	mov	eax, DWORD PTR _size$[ebp]
	add	esp, 8
	cmp	eax, -25				; ffffffe7H
	jbe	SHORT $LN6@xmlRealloc

; 363  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CD@EKEGIKEO@xmlReallocLoc?5?3?5Unsigned?5overfl@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 364  : 		"xmlReallocLoc : Unsigned overflow\n");
; 365  : 	xmlMemoryDump();
; 366  : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlRealloc:

; 367  :     }
; 368  : 
; 369  :     tmp = (MEMHDR *) realloc(p,RESERVE_SIZE+size);

	add	eax, 24					; 00000018H
	push	eax
	push	edi
	call	DWORD PTR __imp__realloc
	mov	ebx, eax
	add	esp, 8

; 370  :     if (!tmp) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlRealloc

; 371  : 	 free(p);

	push	edi
	call	DWORD PTR __imp__free
	add	esp, 4
$error$20:

; 404  : 
; 405  : error:
; 406  :     return(NULL);

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlRealloc:

; 372  : 	 goto error;
; 373  :     }
; 374  :     p = tmp;
; 375  :     if (xmlMemTraceBlockAt == ptr) {

	cmp	DWORD PTR _xmlMemTraceBlockAt, esi
	jne	SHORT $LN8@xmlRealloc

; 376  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+12]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _size$[ebp]
	push	esi
	push	DWORD PTR _xmlMemTraceBlockAt
	push	OFFSET ??_C@_0BP@EHGEOOF@?$CFp?5?3?5Realloced?$CI?$CFlu?5?9?$DO?5?$CFlu?$CJ?5Ok?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 20					; 00000014H

; 377  : 			"%p : Realloced(%lu -> %lu) Ok\n",
; 378  : 			xmlMemTraceBlockAt, (long unsigned)p->mh_size,
; 379  : 			(long unsigned)size);
; 380  : 	xmlMallocBreakpoint();

	call	_xmlMallocBreakpoint
$LN8@xmlRealloc:

; 381  :     }
; 382  :     p->mh_tag = MEMTAG;
; 383  :     p->mh_number = number;

	mov	eax, DWORD PTR _number$1$[ebp]

; 384  :     p->mh_type = REALLOC_TYPE;
; 385  :     p->mh_size = size;
; 386  :     p->mh_file = file;
; 387  :     p->mh_line = line;
; 388  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	esi, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ebx+8], eax
	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ebx+16], eax
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [ebx], 23205			; 00005aa5H
	mov	DWORD PTR [ebx+4], 2
	mov	DWORD PTR [ebx+12], esi
	mov	DWORD PTR [ebx+20], eax
	call	_xmlMutexLock

; 389  :     debugMemSize += size;

	mov	ecx, DWORD PTR _debugMemSize

; 390  :     debugMemBlocks++;
; 391  :     if (debugMemSize > debugMaxMemSize) debugMaxMemSize = debugMemSize;

	mov	eax, DWORD PTR _debugMaxMemSize
	add	ecx, esi
	inc	DWORD PTR _debugMemBlocks
	cmp	ecx, eax

; 392  : #ifdef MEM_LIST
; 393  :     debugmem_list_add(p);
; 394  : #endif
; 395  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	cmova	eax, ecx
	mov	DWORD PTR _debugMemSize, ecx
	mov	DWORD PTR _debugMaxMemSize, eax
	call	_xmlMutexUnlock
	add	esp, 8

; 396  : 
; 397  :     TEST_POINT
; 398  : 
; 399  : #ifdef DEBUG_MEMORY
; 400  :     xmlGenericError(xmlGenericErrorContext,
; 401  : 	    "Realloced(%d to %d) Ok\n", oldsize, size);
; 402  : #endif
; 403  :     return(HDR_2_CLIENT(p));

	lea	eax, DWORD PTR [ebx+24]
	pop	ebx
	pop	edi
	pop	esi

; 407  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReallocLoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMallocLoc
_TEXT	SEGMENT
_size$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_xmlMallocLoc PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlMemInitialized, 0
	jne	SHORT $LN2@xmlMallocL

; 164  :     MEMHDR *p;
; 165  :     void *ret;
; 166  : 
; 167  :     if (!xmlMemInitialized) xmlInitMemory();

	call	_xmlInitMemory
$LN2@xmlMallocL:
	push	esi
	push	edi

; 168  : #ifdef DEBUG_MEMORY
; 169  :     xmlGenericError(xmlGenericErrorContext,
; 170  : 	    "Malloc(%d)\n",size);
; 171  : #endif
; 172  : 
; 173  :     TEST_POINT
; 174  : 
; 175  :     if (size > (MAX_SIZE_T - RESERVE_SIZE)) {

	mov	edi, DWORD PTR _size$[ebp]
	cmp	edi, -25				; ffffffe7H
	jbe	SHORT $LN3@xmlMallocL

; 176  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@KENAJNOB@xmlMallocLoc?5?3?5Unsigned?5overflo@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 177  : 		"xmlMallocLoc : Unsigned overflow\n");
; 178  : 	xmlMemoryDump();
; 179  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 224  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlMallocL:

; 180  :     }
; 181  : 
; 182  :     p = (MEMHDR *) malloc(RESERVE_SIZE+size);

	lea	eax, DWORD PTR [edi+24]
	push	eax
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 183  : 
; 184  :     if (!p) {

	test	esi, esi
	jne	SHORT $LN4@xmlMallocL

; 185  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CC@GHPBNICE@xmlMallocLoc?5?3?5Out?5of?5free?5spac@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 186  : 		"xmlMallocLoc : Out of free space\n");
; 187  : 	xmlMemoryDump();
; 188  : 	return(NULL);

	xor	eax, eax
	pop	edi

; 224  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlMallocL:

; 189  :     }
; 190  :     p->mh_tag = MEMTAG;
; 191  :     p->mh_size = size;
; 192  :     p->mh_type = MALLOC_TYPE;
; 193  :     p->mh_file = file;

	mov	eax, DWORD PTR _file$[ebp]

; 194  :     p->mh_line = line;
; 195  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [esi], 23205			; 00005aa5H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+20], eax
	call	_xmlMutexLock

; 196  :     p->mh_number = ++block;

	mov	eax, DWORD PTR _block

; 197  :     debugMemSize += size;

	mov	ecx, DWORD PTR _debugMemSize
	inc	eax

; 198  :     debugMemBlocks++;

	inc	DWORD PTR _debugMemBlocks
	add	ecx, edi

; 199  :     if (debugMemSize > debugMaxMemSize) debugMaxMemSize = debugMemSize;
; 200  : #ifdef MEM_LIST
; 201  :     debugmem_list_add(p);
; 202  : #endif
; 203  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	mov	DWORD PTR _block, eax
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _debugMaxMemSize
	cmp	ecx, eax
	mov	DWORD PTR _debugMemSize, ecx
	cmova	eax, ecx
	mov	DWORD PTR _debugMaxMemSize, eax
	call	_xmlMutexUnlock

; 204  : 
; 205  : #ifdef DEBUG_MEMORY
; 206  :     xmlGenericError(xmlGenericErrorContext,
; 207  : 	    "Malloc(%d) Ok\n",size);
; 208  : #endif
; 209  : 
; 210  :     if (xmlMemStopAtBlock == p->mh_number) xmlMallocBreakpoint();

	mov	eax, DWORD PTR _xmlMemStopAtBlock
	add	esp, 8
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN6@xmlMallocL
	call	_xmlMallocBreakpoint
$LN6@xmlMallocL:
	push	ebx

; 211  : 
; 212  :     ret = HDR_2_CLIENT(p);

	lea	ebx, DWORD PTR [esi+24]

; 213  : 
; 214  :     if (xmlMemTraceBlockAt == ret) {

	cmp	DWORD PTR _xmlMemTraceBlockAt, ebx
	jne	SHORT $LN7@xmlMallocL

; 215  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [esi]
	push	edi
	push	DWORD PTR _xmlMemTraceBlockAt
	push	OFFSET ??_C@_0BF@EOHFMDNL@?$CFp?5?3?5Malloc?$CI?$CFlu?$CJ?5Ok?6@
	push	DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H

; 216  : 			"%p : Malloc(%lu) Ok\n", xmlMemTraceBlockAt,
; 217  : 			(long unsigned)size);
; 218  : 	xmlMallocBreakpoint();

	call	_xmlMallocBreakpoint
$LN7@xmlMallocL:

; 219  :     }
; 220  : 
; 221  :     TEST_POINT
; 222  : 
; 223  :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 224  : }

	pop	esi
	pop	ebp
	ret	0
_xmlMallocLoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemoryStrdup
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlMemoryStrdup PROC					; COMDAT

; 572  : xmlMemoryStrdup(const char *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	DWORD PTR _str$[ebp]
	call	_xmlMemStrdupLoc
	add	esp, 12					; 0000000cH

; 573  :     return(xmlMemStrdupLoc(str, "none", 0));
; 574  : }

	pop	ebp
	ret	0
_xmlMemoryStrdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemFree
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_xmlMemFree PROC					; COMDAT

; 432  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ptr$[ebp]
	test	ebx, ebx
	je	$LN10@xmlMemFree

; 433  :     MEMHDR *p;
; 434  :     char *target;
; 435  : #ifdef DEBUG_MEMORY
; 436  :     size_t size;
; 437  : #endif
; 438  : 
; 439  :     if (ptr == NULL)
; 440  : 	return;
; 441  : 
; 442  :     if (ptr == (void *) -1) {

	push	esi
	push	edi
	cmp	ebx, -1
	jne	SHORT $LN3@xmlMemFree

; 443  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CI@FDKALOEN@trying?5to?5free?5pointer?5from?5fre@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 444  : 	    "trying to free pointer from freed area\n");
; 445  :         goto error;

	jmp	SHORT $error$16
$LN3@xmlMemFree:

; 446  :     }
; 447  : 
; 448  :     if (xmlMemTraceBlockAt == ptr) {

	cmp	DWORD PTR _xmlMemTraceBlockAt, ebx
	jne	SHORT $LN4@xmlMemFree

; 449  : 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _xmlMemTraceBlockAt
	push	OFFSET ??_C@_0O@EGNDPFML@?$CFp?5?3?5Freed?$CI?$CJ?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 450  : 			"%p : Freed()\n", xmlMemTraceBlockAt);
; 451  : 	xmlMallocBreakpoint();

	call	_xmlMallocBreakpoint
$LN4@xmlMemFree:

; 452  :     }
; 453  : 
; 454  :     TEST_POINT
; 455  : 
; 456  :     target = (char *) ptr;
; 457  : 
; 458  :     p = CLIENT_2_HDR(ptr);
; 459  :     if (p->mh_tag != MEMTAG) {

	cmp	DWORD PTR [ebx-24], 23205		; 00005aa5H
	lea	edi, DWORD PTR [ebx-24]
	je	SHORT $LN5@xmlMemFree

; 864  :      xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	edi
	push	OFFSET ??_C@_0CE@GGGDAPNO@Memory?5tag?5error?5occurs?5?3?$CFp?5?6?7?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH
$error$16:

; 478  : 
; 479  :     TEST_POINT
; 480  : 
; 481  : #ifdef DEBUG_MEMORY
; 482  :     xmlGenericError(xmlGenericErrorContext,
; 483  : 	    "Freed(%d) Ok\n", size);
; 484  : #endif
; 485  : 
; 486  :     return;
; 487  : 
; 488  : error:
; 489  :     xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	ebx
	push	OFFSET ??_C@_0BG@PIJFHHCD@xmlMemFree?$CI?$CFp?$CJ?5error?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 146  :     xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	DWORD PTR _xmlMemStopAtBlock
	push	OFFSET ??_C@_0CJ@PFFCFAIM@xmlMallocBreakpoint?5reached?5on?5@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 476  : 
; 477  :     free(p);

	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 490  : 	    "xmlMemFree(%p) error\n", ptr);
; 491  :     xmlMallocBreakpoint();
; 492  :     return;
; 493  : }

	pop	ebp
	ret	0
$LN5@xmlMemFree:

; 460  :         Mem_Tag_Err(p);
; 461  :         goto error;
; 462  :     }
; 463  :     if (xmlMemStopAtBlock == p->mh_number) xmlMallocBreakpoint();

	mov	eax, DWORD PTR _xmlMemStopAtBlock
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN6@xmlMemFree
	call	_xmlMallocBreakpoint
$LN6@xmlMemFree:

; 464  :     p->mh_tag = ~MEMTAG;
; 465  :     memset(target, -1, p->mh_size);

	push	DWORD PTR [edi+12]
	mov	DWORD PTR [edi], -23206			; ffffa55aH
	push	-1
	push	ebx
	call	_memset

; 466  :     xmlMutexLock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	call	_xmlMutexLock

; 467  :     debugMemSize -= p->mh_size;

	mov	eax, DWORD PTR [edi+12]

; 468  :     debugMemBlocks--;
; 469  : #ifdef DEBUG_MEMORY
; 470  :     size = p->mh_size;
; 471  : #endif
; 472  : #ifdef MEM_LIST
; 473  :     debugmem_list_delete(p);
; 474  : #endif
; 475  :     xmlMutexUnlock(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	sub	DWORD PTR _debugMemSize, eax
	dec	DWORD PTR _debugMemBlocks
	call	_xmlMutexUnlock

; 476  : 
; 477  :     free(p);

	push	edi
	call	DWORD PTR __imp__free
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
$LN10@xmlMemFree:
	pop	ebx

; 490  : 	    "xmlMemFree(%p) error\n", ptr);
; 491  :     xmlMallocBreakpoint();
; 492  :     return;
; 493  : }

	pop	ebp
	ret	0
_xmlMemFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemRealloc
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlMemRealloc PROC					; COMDAT

; 420  : xmlMemRealloc(void *ptr,size_t size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _ptr$[ebp]
	call	_xmlReallocLoc
	add	esp, 16					; 00000010H

; 421  :     return(xmlReallocLoc(ptr, size, "none", 0));
; 422  : }

	pop	ebp
	ret	0
_xmlMemRealloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemMalloc
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlMemMalloc PROC					; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	DWORD PTR _size$[ebp]
	call	_xmlMallocLoc
	add	esp, 12					; 0000000cH

; 313  :     return(xmlMallocLoc(size, "none", 0));
; 314  : }

	pop	ebp
	ret	0
_xmlMemMalloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemoryDump
_TEXT	SEGMENT
_xmlMemoryDump PROC					; COMDAT
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	jmp	@__CheckForDebuggerJustMyCode@4
_xmlMemoryDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemShow
_TEXT	SEGMENT
_fp$ = 8						; size = 4
_nr$ = 12						; size = 4
_xmlMemShow PROC					; COMDAT

; 887  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _fp$[ebp]
	test	eax, eax
	je	SHORT $LN2@xmlMemShow

; 888  : #ifdef MEM_LIST
; 889  :     MEMHDR *p;
; 890  : #endif
; 891  : 
; 892  :     if (fp != NULL)
; 893  : 	fprintf(fp,"      MEMORY ALLOCATED : %lu, MAX was %lu\n",

	push	DWORD PTR _debugMaxMemSize
	push	DWORD PTR _debugMemSize
	push	OFFSET ??_C@_0CL@DBCIPLIB@?5?5?5?5?5?5MEMORY?5ALLOCATED?5?3?5?$CFlu?0?5M@
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN2@xmlMemShow:

; 894  : 		debugMemSize, debugMaxMemSize);
; 895  : #ifdef MEM_LIST
; 896  :     xmlMutexLock(xmlMemMutex);
; 897  :     if (nr > 0) {
; 898  : 	fprintf(fp,"NUMBER   SIZE  TYPE   WHERE\n");
; 899  : 	p = memlist;
; 900  : 	while ((p) && nr > 0) {
; 901  : 	      fprintf(fp,"%6lu %6lu ",p->mh_number,(unsigned long)p->mh_size);
; 902  : 	    switch (p->mh_type) {
; 903  : 	       case STRDUP_TYPE:fprintf(fp,"strdup()  in ");break;
; 904  : 	       case MALLOC_TYPE:fprintf(fp,"malloc()  in ");break;
; 905  : 	       case MALLOC_ATOMIC_TYPE:fprintf(fp,"atomicmalloc()  in ");break;
; 906  : 	      case REALLOC_TYPE:fprintf(fp,"realloc() in ");break;
; 907  : 	      case REALLOC_ATOMIC_TYPE:fprintf(fp,"atomicrealloc() in ");break;
; 908  : 		default:fprintf(fp,"   ???    in ");break;
; 909  : 	    }
; 910  : 	    if (p->mh_file != NULL)
; 911  : 	        fprintf(fp,"%s(%u)", p->mh_file, p->mh_line);
; 912  : 	    if (p->mh_tag != MEMTAG)
; 913  : 		fprintf(fp,"  INVALID");
; 914  : 	    xmlMemContentShow(fp, p);
; 915  : 	    fprintf(fp,"\n");
; 916  : 	    nr--;
; 917  : 	    p = p->mh_next;
; 918  : 	}
; 919  :     }
; 920  :     xmlMutexUnlock(xmlMemMutex);
; 921  : #endif /* MEM_LIST */
; 922  : }

	pop	ebp
	ret	0
_xmlMemShow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemDisplayLast
_TEXT	SEGMENT
_fp$ = 8						; size = 4
_nbBytes$ = 12						; size = 4
_xmlMemDisplayLast PROC					; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _nbBytes$[ebp], 0
	mov	esi, DWORD PTR _fp$[ebp]
	mov	edi, esi
	jle	SHORT $LN5@xmlMemDisp

; 687  : #ifdef MEM_LIST
; 688  :     MEMHDR *p;
; 689  :     unsigned idx;
; 690  :     int     nb = 0;
; 691  : #endif
; 692  :     FILE *old_fp = fp;
; 693  : 
; 694  :     if (nbBytes <= 0)
; 695  :         return;
; 696  : 
; 697  :     if (fp == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlMemDisp

; 698  : 	fp = fopen(".memorylist", "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0M@CNJBCEKM@?4memorylist@
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 699  : 	if (fp == NULL)

	test	esi, esi
	je	SHORT $LN5@xmlMemDisp
$LN4@xmlMemDisp:

; 700  : 	    return;
; 701  :     }
; 702  : 
; 703  : #ifdef MEM_LIST
; 704  :     fprintf(fp,"   Last %li MEMORY ALLOCATED : %lu, MAX was %lu\n",
; 705  :             nbBytes, debugMemSize, debugMaxMemSize);
; 706  :     fprintf(fp,"BLOCK  NUMBER   SIZE  TYPE\n");
; 707  :     idx = 0;
; 708  :     xmlMutexLock(xmlMemMutex);
; 709  :     p = memlist;
; 710  :     while ((p) && (nbBytes > 0)) {
; 711  : 	  fprintf(fp,"%-5u  %6lu %6lu ",idx++,p->mh_number,
; 712  : 		  (unsigned long)p->mh_size);
; 713  :         switch (p->mh_type) {
; 714  :            case STRDUP_TYPE:fprintf(fp,"strdup()  in ");break;
; 715  :            case MALLOC_TYPE:fprintf(fp,"malloc()  in ");break;
; 716  :            case REALLOC_TYPE:fprintf(fp,"realloc() in ");break;
; 717  :            case MALLOC_ATOMIC_TYPE:fprintf(fp,"atomicmalloc()  in ");break;
; 718  :            case REALLOC_ATOMIC_TYPE:fprintf(fp,"atomicrealloc() in ");break;
; 719  :            default:
; 720  : 	        fprintf(fp,"Unknown memory block, may be corrupted");
; 721  : 		xmlMutexUnlock(xmlMemMutex);
; 722  : 		if (old_fp == NULL)
; 723  : 		    fclose(fp);
; 724  : 		return;
; 725  :         }
; 726  : 	if (p->mh_file != NULL) fprintf(fp,"%s(%u)", p->mh_file, p->mh_line);
; 727  :         if (p->mh_tag != MEMTAG)
; 728  : 	      fprintf(fp,"  INVALID");
; 729  :         nb++;
; 730  : 	if (nb < 100)
; 731  : 	    xmlMemContentShow(fp, p);
; 732  : 	else
; 733  : 	    fprintf(fp," skip");
; 734  : 
; 735  :         fprintf(fp,"\n");
; 736  : 	nbBytes -= (unsigned long)p->mh_size;
; 737  :         p = p->mh_next;
; 738  :     }
; 739  :     xmlMutexUnlock(xmlMemMutex);
; 740  : #else
; 741  :     fprintf(fp,"Memory list not compiled (MEM_LIST not defined !)\n");

	push	OFFSET ??_C@_0DD@OBJABBCC@Memory?5list?5not?5compiled?5?$CIMEM_L@
	push	esi
	call	_fprintf
	add	esp, 8

; 742  : #endif
; 743  :     if (old_fp == NULL)

	test	edi, edi
	jne	SHORT $LN5@xmlMemDisp

; 744  : 	fclose(fp);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN5@xmlMemDisp:

; 745  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlMemDisplayLast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemDisplay
_TEXT	SEGMENT
_fp$ = 8						; size = 4
_xmlMemDisplay PROC					; COMDAT

; 757  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fp$[ebp]
	mov	edi, esi
	test	esi, esi
	jne	SHORT $LN3@xmlMemDisp

; 758  : #ifdef MEM_LIST
; 759  :     MEMHDR *p;
; 760  :     unsigned idx;
; 761  :     int     nb = 0;
; 762  : #if defined(HAVE_LOCALTIME) && defined(HAVE_STRFTIME)
; 763  :     time_t currentTime;
; 764  :     char buf[500];
; 765  :     struct tm * tstruct;
; 766  : #endif
; 767  : #endif
; 768  :     FILE *old_fp = fp;
; 769  : 
; 770  :     if (fp == NULL) {
; 771  : 	fp = fopen(".memorylist", "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0M@CNJBCEKM@?4memorylist@
	call	DWORD PTR __imp__fopen
	mov	esi, eax
	add	esp, 8

; 772  : 	if (fp == NULL)

	test	esi, esi
	je	SHORT $LN4@xmlMemDisp
$LN3@xmlMemDisp:

; 773  : 	    return;
; 774  :     }
; 775  : 
; 776  : #ifdef MEM_LIST
; 777  : #if defined(HAVE_LOCALTIME) && defined(HAVE_STRFTIME)
; 778  :     currentTime = time(NULL);
; 779  :     tstruct = localtime(&currentTime);
; 780  :     strftime(buf, sizeof(buf) - 1, "%I:%M:%S %p", tstruct);
; 781  :     fprintf(fp,"      %s\n\n", buf);
; 782  : #endif
; 783  : 
; 784  : 
; 785  :     fprintf(fp,"      MEMORY ALLOCATED : %lu, MAX was %lu\n",
; 786  :             debugMemSize, debugMaxMemSize);
; 787  :     fprintf(fp,"BLOCK  NUMBER   SIZE  TYPE\n");
; 788  :     idx = 0;
; 789  :     xmlMutexLock(xmlMemMutex);
; 790  :     p = memlist;
; 791  :     while (p) {
; 792  : 	  fprintf(fp,"%-5u  %6lu %6lu ",idx++,p->mh_number,
; 793  : 		  (unsigned long)p->mh_size);
; 794  :         switch (p->mh_type) {
; 795  :            case STRDUP_TYPE:fprintf(fp,"strdup()  in ");break;
; 796  :            case MALLOC_TYPE:fprintf(fp,"malloc()  in ");break;
; 797  :            case REALLOC_TYPE:fprintf(fp,"realloc() in ");break;
; 798  :            case MALLOC_ATOMIC_TYPE:fprintf(fp,"atomicmalloc()  in ");break;
; 799  :            case REALLOC_ATOMIC_TYPE:fprintf(fp,"atomicrealloc() in ");break;
; 800  :            default:
; 801  : 	        fprintf(fp,"Unknown memory block, may be corrupted");
; 802  : 		xmlMutexUnlock(xmlMemMutex);
; 803  : 		if (old_fp == NULL)
; 804  : 		    fclose(fp);
; 805  : 		return;
; 806  :         }
; 807  : 	if (p->mh_file != NULL) fprintf(fp,"%s(%u)", p->mh_file, p->mh_line);
; 808  :         if (p->mh_tag != MEMTAG)
; 809  : 	      fprintf(fp,"  INVALID");
; 810  :         nb++;
; 811  : 	if (nb < 100)
; 812  : 	    xmlMemContentShow(fp, p);
; 813  : 	else
; 814  : 	    fprintf(fp," skip");
; 815  : 
; 816  :         fprintf(fp,"\n");
; 817  :         p = p->mh_next;
; 818  :     }
; 819  :     xmlMutexUnlock(xmlMemMutex);
; 820  : #else
; 821  :     fprintf(fp,"Memory list not compiled (MEM_LIST not defined !)\n");

	push	OFFSET ??_C@_0DD@OBJABBCC@Memory?5list?5not?5compiled?5?$CIMEM_L@
	push	esi
	call	_fprintf
	add	esp, 8

; 822  : #endif
; 823  :     if (old_fp == NULL)

	test	edi, edi
	jne	SHORT $LN4@xmlMemDisp

; 824  : 	fclose(fp);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN4@xmlMemDisp:

; 825  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlMemDisplay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemBlocks
_TEXT	SEGMENT
_xmlMemBlocks PROC					; COMDAT

; 603  : xmlMemBlocks(void) {

	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _xmlMemMutex
	call	_xmlMutexLock
	push	DWORD PTR _xmlMemMutex
	mov	esi, DWORD PTR _debugMemBlocks
	call	_xmlMutexUnlock
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	0
_xmlMemBlocks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemUsed
_TEXT	SEGMENT
_xmlMemUsed PROC					; COMDAT

; 585  : xmlMemUsed(void) {

	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _xmlMemMutex
	call	_xmlMutexLock
	push	DWORD PTR _xmlMemMutex
	mov	esi, DWORD PTR _debugMemSize
	call	_xmlMutexUnlock
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	0
_xmlMemUsed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlCleanupMemory
_TEXT	SEGMENT
_xmlCleanupMemory PROC					; COMDAT
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlMemInitialized, 0
	je	SHORT $LN1@xmlCleanup

; 1009 : #ifdef DEBUG_MEMORY
; 1010 :      xmlGenericError(xmlGenericErrorContext,
; 1011 : 	     "xmlCleanupMemory()\n");
; 1012 : #endif
; 1013 :     if (xmlMemInitialized == 0)
; 1014 :         return;
; 1015 : 
; 1016 :     xmlFreeMutex(xmlMemMutex);

	push	DWORD PTR _xmlMemMutex
	call	_xmlFreeMutex
	add	esp, 4

; 1017 :     xmlMemMutex = NULL;

	mov	DWORD PTR _xmlMemMutex, 0

; 1018 :     xmlMemInitialized = 0;

	mov	DWORD PTR _xmlMemInitialized, 0
$LN1@xmlCleanup:

; 1019 : #ifdef DEBUG_MEMORY
; 1020 :      xmlGenericError(xmlGenericErrorContext,
; 1021 : 	     "xmlCleanupMemory() Ok\n");
; 1022 : #endif
; 1023 : }

	ret	0
_xmlCleanupMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlInitMemory
_TEXT	SEGMENT
_xmlInitMemory PROC					; COMDAT
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlMemInitialized, 0
	je	SHORT $LN2@xmlInitMem

; 966  : #ifdef HAVE_STDLIB_H
; 967  :      char *breakpoint;
; 968  : #endif
; 969  : #ifdef DEBUG_MEMORY
; 970  :      xmlGenericError(xmlGenericErrorContext,
; 971  : 	     "xmlInitMemory()\n");
; 972  : #endif
; 973  :     /*
; 974  :      This is really not good code (see Bug 130419).  Suggestions for
; 975  :      improvement will be welcome!
; 976  :     */
; 977  :      if (xmlMemInitialized) return(-1);

	or	eax, -1

; 999  : }

	ret	0
$LN2@xmlInitMem:

; 978  :      xmlMemInitialized = 1;

	mov	DWORD PTR _xmlMemInitialized, 1

; 979  :      xmlMemMutex = xmlNewMutex();

	call	_xmlNewMutex

; 980  : 
; 981  : #ifdef HAVE_STDLIB_H
; 982  :      breakpoint = getenv("XML_MEM_BREAKPOINT");

	push	OFFSET ??_C@_0BD@GCGPPOKD@XML_MEM_BREAKPOINT@
	mov	DWORD PTR _xmlMemMutex, eax
	call	DWORD PTR __imp__getenv
	add	esp, 4

; 983  :      if (breakpoint != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlInitMem

; 984  :          sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);

	push	OFFSET _xmlMemStopAtBlock
	push	OFFSET ??_C@_03BKPMHLPH@?$CFud@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
$LN3@xmlInitMem:

; 985  :      }
; 986  : #endif
; 987  : #ifdef HAVE_STDLIB_H
; 988  :      breakpoint = getenv("XML_MEM_TRACE");

	push	OFFSET ??_C@_0O@IPGKJECE@XML_MEM_TRACE@
	call	DWORD PTR __imp__getenv
	add	esp, 4

; 989  :      if (breakpoint != NULL) {

	test	eax, eax
	je	SHORT $LN4@xmlInitMem

; 990  :          sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);

	push	OFFSET _xmlMemTraceBlockAt
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
$LN4@xmlInitMem:

; 991  :      }
; 992  : #endif
; 993  : 
; 994  : #ifdef DEBUG_MEMORY
; 995  :      xmlGenericError(xmlGenericErrorContext,
; 996  : 	     "xmlInitMemory() Ok\n");
; 997  : #endif
; 998  :      return(0);

	xor	eax, eax

; 999  : }

	ret	0
_xmlInitMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlGcMemGet
_TEXT	SEGMENT
_freeFunc$ = 8						; size = 4
_mallocFunc$ = 12					; size = 4
_mallocAtomicFunc$ = 16					; size = 4
_reallocFunc$ = 20					; size = 4
_strdupFunc$ = 24					; size = 4
_xmlGcMemGet PROC					; COMDAT

; 1153 : 	    xmlStrdupFunc *strdupFunc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _freeFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlGcMemGe

; 1154 :     if (freeFunc != NULL) *freeFunc = xmlFree;

	mov	eax, DWORD PTR _xmlFree
	mov	DWORD PTR [ecx], eax
$LN2@xmlGcMemGe:

; 1155 :     if (mallocFunc != NULL) *mallocFunc = xmlMalloc;

	mov	ecx, DWORD PTR _mallocFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlGcMemGe
	mov	eax, DWORD PTR _xmlMalloc
	mov	DWORD PTR [ecx], eax
$LN3@xmlGcMemGe:

; 1156 :     if (mallocAtomicFunc != NULL) *mallocAtomicFunc = xmlMallocAtomic;

	mov	ecx, DWORD PTR _mallocAtomicFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlGcMemGe
	mov	eax, DWORD PTR _xmlMallocAtomic
	mov	DWORD PTR [ecx], eax
$LN4@xmlGcMemGe:

; 1157 :     if (reallocFunc != NULL) *reallocFunc = xmlRealloc;

	mov	ecx, DWORD PTR _reallocFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlGcMemGe
	mov	eax, DWORD PTR _xmlRealloc
	mov	DWORD PTR [ecx], eax
$LN5@xmlGcMemGe:

; 1158 :     if (strdupFunc != NULL) *strdupFunc = xmlMemStrdup;

	mov	ecx, DWORD PTR _strdupFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlGcMemGe
	mov	eax, DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ecx], eax
$LN8@xmlGcMemGe:

; 1159 :     return(0);
; 1160 : }

	xor	eax, eax
	pop	ebp
	ret	0
_xmlGcMemGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlGcMemSetup
_TEXT	SEGMENT
_freeFunc$ = 8						; size = 4
_mallocFunc$ = 12					; size = 4
_mallocAtomicFunc$ = 16					; size = 4
_reallocFunc$ = 20					; size = 4
_strdupFunc$ = 24					; size = 4
_xmlGcMemSetup PROC					; COMDAT

; 1109 : 	      xmlStrdupFunc strdupFunc) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _freeFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlGcMemSe

; 1110 : #ifdef DEBUG_MEMORY
; 1111 :      xmlGenericError(xmlGenericErrorContext,
; 1112 : 	     "xmlGcMemSetup()\n");
; 1113 : #endif
; 1114 :     if (freeFunc == NULL)
; 1115 : 	return(-1);
; 1116 :     if (mallocFunc == NULL)

	mov	eax, DWORD PTR _mallocFunc$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlGcMemSe

; 1117 : 	return(-1);
; 1118 :     if (mallocAtomicFunc == NULL)

	mov	edx, DWORD PTR _mallocAtomicFunc$[ebp]
	test	edx, edx
	je	SHORT $LN8@xmlGcMemSe

; 1119 : 	return(-1);
; 1120 :     if (reallocFunc == NULL)

	mov	esi, DWORD PTR _reallocFunc$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlGcMemSe

; 1121 : 	return(-1);
; 1122 :     if (strdupFunc == NULL)

	mov	edi, DWORD PTR _strdupFunc$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlGcMemSe

; 1124 :     xmlFree = freeFunc;
; 1125 :     xmlMalloc = mallocFunc;
; 1126 :     xmlMallocAtomic = mallocAtomicFunc;
; 1127 :     xmlRealloc = reallocFunc;
; 1128 :     xmlMemStrdup = strdupFunc;

	mov	DWORD PTR _xmlMemStrdup, edi
	pop	edi
	mov	DWORD PTR _xmlMalloc, eax

; 1129 : #ifdef DEBUG_MEMORY
; 1130 :      xmlGenericError(xmlGenericErrorContext,
; 1131 : 	     "xmlGcMemSetup() Ok\n");
; 1132 : #endif
; 1133 :     return(0);

	xor	eax, eax
	mov	DWORD PTR _xmlRealloc, esi
	mov	DWORD PTR _xmlFree, ecx
	mov	DWORD PTR _xmlMallocAtomic, edx

; 1134 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlGcMemSe:
	pop	edi

; 1123 : 	return(-1);

	or	eax, -1

; 1134 : }

	pop	esi
	pop	ebp
	ret	0
_xmlGcMemSetup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemGet
_TEXT	SEGMENT
_freeFunc$ = 8						; size = 4
_mallocFunc$ = 12					; size = 4
_reallocFunc$ = 16					; size = 4
_strdupFunc$ = 20					; size = 4
_xmlMemGet PROC						; COMDAT

; 1080 : 	  xmlReallocFunc *reallocFunc, xmlStrdupFunc *strdupFunc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _freeFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@xmlMemGet

; 1081 :     if (freeFunc != NULL) *freeFunc = xmlFree;

	mov	eax, DWORD PTR _xmlFree
	mov	DWORD PTR [ecx], eax
$LN2@xmlMemGet:

; 1082 :     if (mallocFunc != NULL) *mallocFunc = xmlMalloc;

	mov	ecx, DWORD PTR _mallocFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlMemGet
	mov	eax, DWORD PTR _xmlMalloc
	mov	DWORD PTR [ecx], eax
$LN3@xmlMemGet:

; 1083 :     if (reallocFunc != NULL) *reallocFunc = xmlRealloc;

	mov	ecx, DWORD PTR _reallocFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlMemGet
	mov	eax, DWORD PTR _xmlRealloc
	mov	DWORD PTR [ecx], eax
$LN4@xmlMemGet:

; 1084 :     if (strdupFunc != NULL) *strdupFunc = xmlMemStrdup;

	mov	ecx, DWORD PTR _strdupFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlMemGet
	mov	eax, DWORD PTR _xmlMemStrdup
	mov	DWORD PTR [ecx], eax
$LN7@xmlMemGet:

; 1085 :     return(0);
; 1086 : }

	xor	eax, eax
	pop	ebp
	ret	0
_xmlMemGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlmemory.c
;	COMDAT _xmlMemSetup
_TEXT	SEGMENT
_freeFunc$ = 8						; size = 4
_mallocFunc$ = 12					; size = 4
_reallocFunc$ = 16					; size = 4
_strdupFunc$ = 20					; size = 4
_xmlMemSetup PROC					; COMDAT

; 1042 :             xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __D8018AA9_xmlmemory@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _freeFunc$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlMemSetu

; 1043 : #ifdef DEBUG_MEMORY
; 1044 :      xmlGenericError(xmlGenericErrorContext,
; 1045 : 	     "xmlMemSetup()\n");
; 1046 : #endif
; 1047 :     if (freeFunc == NULL)
; 1048 : 	return(-1);
; 1049 :     if (mallocFunc == NULL)

	mov	eax, DWORD PTR _mallocFunc$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlMemSetu

; 1050 : 	return(-1);
; 1051 :     if (reallocFunc == NULL)

	mov	edx, DWORD PTR _reallocFunc$[ebp]
	test	edx, edx
	je	SHORT $LN7@xmlMemSetu

; 1052 : 	return(-1);
; 1053 :     if (strdupFunc == NULL)

	mov	esi, DWORD PTR _strdupFunc$[ebp]
	test	esi, esi
	je	SHORT $LN7@xmlMemSetu

; 1055 :     xmlFree = freeFunc;
; 1056 :     xmlMalloc = mallocFunc;

	mov	DWORD PTR _xmlMalloc, eax

; 1057 :     xmlMallocAtomic = mallocFunc;

	mov	DWORD PTR _xmlMallocAtomic, eax

; 1058 :     xmlRealloc = reallocFunc;
; 1059 :     xmlMemStrdup = strdupFunc;
; 1060 : #ifdef DEBUG_MEMORY
; 1061 :      xmlGenericError(xmlGenericErrorContext,
; 1062 : 	     "xmlMemSetup() Ok\n");
; 1063 : #endif
; 1064 :     return(0);

	xor	eax, eax
	mov	DWORD PTR _xmlMemStrdup, esi
	mov	DWORD PTR _xmlFree, ecx
	mov	DWORD PTR _xmlRealloc, edx
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN7@xmlMemSetu:

; 1054 : 	return(-1);

	or	eax, -1
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
_xmlMemSetup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 2176 :         return __stdio_common_vsscanf(

	call	___local_stdio_scanf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);
; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2275 :         __crt_va_end(_ArgList);
; 2276 :         return _Result;

	pop	esi

; 2277 :     }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_scanf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2176 :         return __stdio_common_vsscanf(
; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
