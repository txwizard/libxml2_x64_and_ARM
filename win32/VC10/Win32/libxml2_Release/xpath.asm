; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xpath.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_03KDKBKEMD@Ok?6@				; `string'
PUBLIC	??_C@_0BB@OKMDJLIM@Number?5encoding?6@		; `string'
PUBLIC	??_C@_0BE@HEBMIFHL@Unfinished?5literal?6@	; `string'
PUBLIC	??_C@_0BC@KLADNOLA@Start?5of?5literal?6@	; `string'
PUBLIC	??_C@_0CD@PCDALDFN@Expected?5$?5for?5variable?5referen@ ; `string'
PUBLIC	??_C@_0BE@JIMEOEEA@Undefined?5variable?6@	; `string'
PUBLIC	??_C@_0BD@MFLBJOMG@Invalid?5predicate?6@	; `string'
PUBLIC	??_C@_0BE@CGBIHHBE@Invalid?5expression?6@	; `string'
PUBLIC	??_C@_0BN@DKJEIEAC@Missing?5closing?5curly?5brace?6@ ; `string'
PUBLIC	??_C@_0BH@FDADKKDC@Unregistered?5function?6@	; `string'
PUBLIC	??_C@_0BB@NCMBGCMG@Invalid?5operand?6@		; `string'
PUBLIC	??_C@_0O@HECJPNOD@Invalid?5type?6@		; `string'
PUBLIC	??_C@_0BN@CGCHLLOB@Invalid?5number?5of?5arguments?6@ ; `string'
PUBLIC	??_C@_0BG@JMBOPCAE@Invalid?5context?5size?6@	; `string'
PUBLIC	??_C@_0BK@CKPBPDPH@Invalid?5context?5position?6@ ; `string'
PUBLIC	??_C@_0BJ@OGCHFJAK@Memory?5allocation?5error?6@	; `string'
PUBLIC	??_C@_0O@JJFGCDGG@Syntax?5error?6@		; `string'
PUBLIC	??_C@_0BA@IPNFPAOO@Resource?5error?6@		; `string'
PUBLIC	??_C@_0BE@ILOLKABH@Sub?5resource?5error?6@	; `string'
PUBLIC	??_C@_0BM@FJPIKKBA@Undefined?5namespace?5prefix?6@ ; `string'
PUBLIC	??_C@_0BA@ONCPONLN@Encoding?5error?6@		; `string'
PUBLIC	??_C@_0BH@FAHNGONI@Char?5out?5of?5XML?5range?6@	; `string'
PUBLIC	??_C@_0BP@HNOPDOE@Invalid?5or?5incomplete?5context?6@ ; `string'
PUBLIC	??_C@_0BD@MEAKLJLB@Stack?5usage?5error?6@	; `string'
PUBLIC	??_C@_0BE@EKOADJON@Forbidden?5variable?6@	; `string'
PUBLIC	??_C@_0BF@NKLLLIIE@?$DP?$DP?5Unknown?5error?5?$DP?$DP?6@ ; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BF@NKLLLIIE@?$DP?$DP?5Unknown?5error?5?$DP?$DP?6@
CONST	SEGMENT
??_C@_0BF@NKLLLIIE@?$DP?$DP?5Unknown?5error?5?$DP?$DP?6@ DB '?? Unknown e'
	DB	'rror ??', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKOADJON@Forbidden?5variable?6@
CONST	SEGMENT
??_C@_0BE@EKOADJON@Forbidden?5variable?6@ DB 'Forbidden variable', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MEAKLJLB@Stack?5usage?5error?6@
CONST	SEGMENT
??_C@_0BD@MEAKLJLB@Stack?5usage?5error?6@ DB 'Stack usage error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HNOPDOE@Invalid?5or?5incomplete?5context?6@
CONST	SEGMENT
??_C@_0BP@HNOPDOE@Invalid?5or?5incomplete?5context?6@ DB 'Invalid or inco'
	DB	'mplete context', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FAHNGONI@Char?5out?5of?5XML?5range?6@
CONST	SEGMENT
??_C@_0BH@FAHNGONI@Char?5out?5of?5XML?5range?6@ DB 'Char out of XML range'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ONCPONLN@Encoding?5error?6@
CONST	SEGMENT
??_C@_0BA@ONCPONLN@Encoding?5error?6@ DB 'Encoding error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJPIKKBA@Undefined?5namespace?5prefix?6@
CONST	SEGMENT
??_C@_0BM@FJPIKKBA@Undefined?5namespace?5prefix?6@ DB 'Undefined namespac'
	DB	'e prefix', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILOLKABH@Sub?5resource?5error?6@
CONST	SEGMENT
??_C@_0BE@ILOLKABH@Sub?5resource?5error?6@ DB 'Sub resource error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPNFPAOO@Resource?5error?6@
CONST	SEGMENT
??_C@_0BA@IPNFPAOO@Resource?5error?6@ DB 'Resource error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JJFGCDGG@Syntax?5error?6@
CONST	SEGMENT
??_C@_0O@JJFGCDGG@Syntax?5error?6@ DB 'Syntax error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OGCHFJAK@Memory?5allocation?5error?6@
CONST	SEGMENT
??_C@_0BJ@OGCHFJAK@Memory?5allocation?5error?6@ DB 'Memory allocation err'
	DB	'or', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CKPBPDPH@Invalid?5context?5position?6@
CONST	SEGMENT
??_C@_0BK@CKPBPDPH@Invalid?5context?5position?6@ DB 'Invalid context posi'
	DB	'tion', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMBOPCAE@Invalid?5context?5size?6@
CONST	SEGMENT
??_C@_0BG@JMBOPCAE@Invalid?5context?5size?6@ DB 'Invalid context size', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CGCHLLOB@Invalid?5number?5of?5arguments?6@
CONST	SEGMENT
??_C@_0BN@CGCHLLOB@Invalid?5number?5of?5arguments?6@ DB 'Invalid number o'
	DB	'f arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HECJPNOD@Invalid?5type?6@
CONST	SEGMENT
??_C@_0O@HECJPNOD@Invalid?5type?6@ DB 'Invalid type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NCMBGCMG@Invalid?5operand?6@
CONST	SEGMENT
??_C@_0BB@NCMBGCMG@Invalid?5operand?6@ DB 'Invalid operand', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FDADKKDC@Unregistered?5function?6@
CONST	SEGMENT
??_C@_0BH@FDADKKDC@Unregistered?5function?6@ DB 'Unregistered function', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DKJEIEAC@Missing?5closing?5curly?5brace?6@
CONST	SEGMENT
??_C@_0BN@DKJEIEAC@Missing?5closing?5curly?5brace?6@ DB 'Missing closing '
	DB	'curly brace', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CGBIHHBE@Invalid?5expression?6@
CONST	SEGMENT
??_C@_0BE@CGBIHHBE@Invalid?5expression?6@ DB 'Invalid expression', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFLBJOMG@Invalid?5predicate?6@
CONST	SEGMENT
??_C@_0BD@MFLBJOMG@Invalid?5predicate?6@ DB 'Invalid predicate', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JIMEOEEA@Undefined?5variable?6@
CONST	SEGMENT
??_C@_0BE@JIMEOEEA@Undefined?5variable?6@ DB 'Undefined variable', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PCDALDFN@Expected?5$?5for?5variable?5referen@
CONST	SEGMENT
??_C@_0CD@PCDALDFN@Expected?5$?5for?5variable?5referen@ DB 'Expected $ fo'
	DB	'r variable reference', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLADNOLA@Start?5of?5literal?6@
CONST	SEGMENT
??_C@_0BC@KLADNOLA@Start?5of?5literal?6@ DB 'Start of literal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HEBMIFHL@Unfinished?5literal?6@
CONST	SEGMENT
??_C@_0BE@HEBMIFHL@Unfinished?5literal?6@ DB 'Unfinished literal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OKMDJLIM@Number?5encoding?6@
CONST	SEGMENT
??_C@_0BB@OKMDJLIM@Number?5encoding?6@ DB 'Number encoding', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDKBKEMD@Ok?6@
CONST	SEGMENT
??_C@_03KDKBKEMD@Ok?6@ DB 'Ok', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlXPathXMLNamespaceStruct DD 00H
	DD	012H
	DD	FLAT:??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	DD	FLAT:??_C@_03PJHHNEEI@xml@
	DD	00H
	DD	00H
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__C4BA4707_timsort@h DB 01H
__9DBA2A81_xpath@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlXPathFreeObject
PUBLIC	_xmlXPathNodeSetCreate
PUBLIC	_xmlXPathFreeNodeSetList
PUBLIC	_xmlXPathFreeNodeSet
PUBLIC	_xmlXPathObjectCopy
PUBLIC	_xmlXPathCmpNodes
PUBLIC	_xmlXPathCastNumberToBoolean
PUBLIC	_xmlXPathCastStringToBoolean
PUBLIC	_xmlXPathCastNodeSetToBoolean
PUBLIC	_xmlXPathCastToBoolean
PUBLIC	_xmlXPathCastBooleanToNumber
PUBLIC	_xmlXPathCastStringToNumber
PUBLIC	_xmlXPathCastNodeToNumber
PUBLIC	_xmlXPathCastNodeSetToNumber
PUBLIC	_xmlXPathCastToNumber
PUBLIC	_xmlXPathCastBooleanToString
PUBLIC	_xmlXPathCastNumberToString
PUBLIC	_xmlXPathCastNodeToString
PUBLIC	_xmlXPathCastNodeSetToString
PUBLIC	_xmlXPathCastToString
PUBLIC	_xmlXPathConvertBoolean
PUBLIC	_xmlXPathConvertNumber
PUBLIC	_xmlXPathConvertString
PUBLIC	_xmlXPathNewContext
PUBLIC	_xmlXPathFreeContext
PUBLIC	_xmlXPathContextSetCache
PUBLIC	_xmlXPathOrderDocElems
PUBLIC	_xmlXPathSetContextNode
PUBLIC	_xmlXPathNodeEval
PUBLIC	_xmlXPathEval
PUBLIC	_xmlXPathEvalExpression
PUBLIC	_xmlXPathEvalPredicate
PUBLIC	_xmlXPathCompile
PUBLIC	_xmlXPathCtxtCompile
PUBLIC	_xmlXPathCompiledEval
PUBLIC	_xmlXPathCompiledEvalToBoolean
PUBLIC	_xmlXPathFreeCompExpr
PUBLIC	_xmlXPathInit
PUBLIC	_xmlXPathIsNaN
PUBLIC	_xmlXPathIsInf
PUBLIC	_xmlXPathPopBoolean
PUBLIC	_xmlXPathPopNumber
PUBLIC	_xmlXPathPopString
PUBLIC	_xmlXPathPopNodeSet
PUBLIC	_xmlXPathPopExternal
PUBLIC	_xmlXPathRegisterVariableLookup
PUBLIC	_xmlXPathRegisterFuncLookup
PUBLIC	_xmlXPatherror
PUBLIC	_xmlXPathErr
PUBLIC	_xmlXPathDebugDumpObject
PUBLIC	_xmlXPathDebugDumpCompExpr
PUBLIC	_xmlXPathNodeSetContains
PUBLIC	_xmlXPathDifference
PUBLIC	_xmlXPathIntersection
PUBLIC	_xmlXPathDistinctSorted
PUBLIC	_xmlXPathDistinct
PUBLIC	_xmlXPathHasSameNodes
PUBLIC	_xmlXPathNodeLeadingSorted
PUBLIC	_xmlXPathLeadingSorted
PUBLIC	_xmlXPathNodeLeading
PUBLIC	_xmlXPathLeading
PUBLIC	_xmlXPathNodeTrailingSorted
PUBLIC	_xmlXPathTrailingSorted
PUBLIC	_xmlXPathNodeTrailing
PUBLIC	_xmlXPathTrailing
PUBLIC	_xmlXPathRegisterNs
PUBLIC	_xmlXPathNsLookup
PUBLIC	_xmlXPathRegisteredNsCleanup
PUBLIC	_xmlXPathRegisterFunc
PUBLIC	_xmlXPathRegisterFuncNS
PUBLIC	_xmlXPathRegisterVariable
PUBLIC	_xmlXPathRegisterVariableNS
PUBLIC	_xmlXPathFunctionLookup
PUBLIC	_xmlXPathFunctionLookupNS
PUBLIC	_xmlXPathRegisteredFuncsCleanup
PUBLIC	_xmlXPathVariableLookup
PUBLIC	_xmlXPathVariableLookupNS
PUBLIC	_xmlXPathRegisteredVariablesCleanup
PUBLIC	_xmlXPathNewParserContext
PUBLIC	_xmlXPathFreeParserContext
PUBLIC	_valuePop
PUBLIC	_valuePush
PUBLIC	_xmlXPathNewString
PUBLIC	_xmlXPathNewCString
PUBLIC	_xmlXPathWrapString
PUBLIC	_xmlXPathWrapCString
PUBLIC	_xmlXPathNewFloat
PUBLIC	_xmlXPathNewBoolean
PUBLIC	_xmlXPathNewNodeSet
PUBLIC	_xmlXPathNewValueTree
PUBLIC	_xmlXPathNodeSetAdd
PUBLIC	_xmlXPathNodeSetAddUnique
PUBLIC	_xmlXPathNodeSetAddNs
PUBLIC	_xmlXPathNodeSetSort
PUBLIC	_xmlXPathRoot
PUBLIC	_xmlXPathEvalExpr
PUBLIC	_xmlXPathParseName
PUBLIC	_xmlXPathParseNCName
PUBLIC	_xmlXPathStringEvalNumber
PUBLIC	_xmlXPathEvaluatePredicateResult
PUBLIC	_xmlXPathRegisterAllFunctions
PUBLIC	_xmlXPathNodeSetMerge
PUBLIC	_xmlXPathNodeSetDel
PUBLIC	_xmlXPathNodeSetRemove
PUBLIC	_xmlXPathNewNodeSetList
PUBLIC	_xmlXPathWrapNodeSet
PUBLIC	_xmlXPathWrapExternal
PUBLIC	_xmlXPathEqualValues
PUBLIC	_xmlXPathNotEqualValues
PUBLIC	_xmlXPathCompareValues
PUBLIC	_xmlXPathValueFlipSign
PUBLIC	_xmlXPathAddValues
PUBLIC	_xmlXPathSubValues
PUBLIC	_xmlXPathMultValues
PUBLIC	_xmlXPathDivValues
PUBLIC	_xmlXPathModValues
PUBLIC	_xmlXPathIsNodeType
PUBLIC	_xmlXPathNextSelf
PUBLIC	_xmlXPathNextChild
PUBLIC	_xmlXPathNextDescendant
PUBLIC	_xmlXPathNextDescendantOrSelf
PUBLIC	_xmlXPathNextParent
PUBLIC	_xmlXPathNextAncestorOrSelf
PUBLIC	_xmlXPathNextFollowingSibling
PUBLIC	_xmlXPathNextFollowing
PUBLIC	_xmlXPathNextNamespace
PUBLIC	_xmlXPathNextAttribute
PUBLIC	_xmlXPathNextPreceding
PUBLIC	_xmlXPathNextAncestor
PUBLIC	_xmlXPathNextPrecedingSibling
PUBLIC	_xmlXPathLastFunction
PUBLIC	_xmlXPathPositionFunction
PUBLIC	_xmlXPathCountFunction
PUBLIC	_xmlXPathIdFunction
PUBLIC	_xmlXPathLocalNameFunction
PUBLIC	_xmlXPathNamespaceURIFunction
PUBLIC	_xmlXPathStringFunction
PUBLIC	_xmlXPathStringLengthFunction
PUBLIC	_xmlXPathConcatFunction
PUBLIC	_xmlXPathContainsFunction
PUBLIC	_xmlXPathStartsWithFunction
PUBLIC	_xmlXPathSubstringFunction
PUBLIC	_xmlXPathSubstringBeforeFunction
PUBLIC	_xmlXPathSubstringAfterFunction
PUBLIC	_xmlXPathNormalizeFunction
PUBLIC	_xmlXPathTranslateFunction
PUBLIC	_xmlXPathNotFunction
PUBLIC	_xmlXPathTrueFunction
PUBLIC	_xmlXPathFalseFunction
PUBLIC	_xmlXPathLangFunction
PUBLIC	_xmlXPathNumberFunction
PUBLIC	_xmlXPathSumFunction
PUBLIC	_xmlXPathFloorFunction
PUBLIC	_xmlXPathCeilingFunction
PUBLIC	_xmlXPathRoundFunction
PUBLIC	_xmlXPathBooleanFunction
PUBLIC	_xmlXPathNodeSetFreeNs
PUBLIC	_libxml_domnode_binary_insertion_sort
PUBLIC	_libxml_domnode_tim_sort
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0EA@JENGBCEE@Error?5allocating?5temporary?5stor@ ; `string'
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@ ; `string'
PUBLIC	??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@ ; `string'
PUBLIC	??_C@_0BG@OMFEJMIL@allocating?5component?6@	; `string'
PUBLIC	??_C@_0BC@EIFELMJ@allocating?5steps?6@		; `string'
PUBLIC	??_C@_0N@GHHFFDFC@adding?5step?6@		; `string'
PUBLIC	??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@	; `string'
PUBLIC	??_C@_03LHHHGGIK@?5?1?6@			; `string'
PUBLIC	??_C@_0BD@CEACDENF@NodeSet?5is?5NULL?5?$CB?6@	; `string'
PUBLIC	??_C@_0BI@CGJHGOLK@Set?5contains?5?$CFd?5nodes?3?6@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0BG@ODIPEGMA@Value?5Tree?5is?5NULL?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BH@OMGEHPOG@LocationSet?5is?5NULL?5?$CB?6@ ; `string'
PUBLIC	??_C@_05GJKEPAIO@?$CFd?5?3?5@			; `string'
PUBLIC	??_C@_0BI@CIBIAOEE@Object?5is?5empty?5?$CINULL?$CJ?6@ ; `string'
PUBLIC	??_C@_0BJ@EGAONLPM@Object?5is?5uninitialized?6@	; `string'
PUBLIC	??_C@_0BI@NCNINNMM@Object?5is?5a?5Node?5Set?5?3?6@ ; `string'
PUBLIC	??_C@_0CA@NNPHAPO@Object?5is?5an?5XSLT?5value?5tree?5?3?6@ ; `string'
PUBLIC	??_C@_0BH@GPCPEGOI@Object?5is?5a?5Boolean?5?3?5@ ; `string'
PUBLIC	??_C@_05LFIOBDML@true?6@			; `string'
PUBLIC	??_C@_06NIOGPBNO@false?6@			; `string'
PUBLIC	??_C@_0BP@DBNKIPBA@Object?5is?5a?5number?5?3?5Infinity?6@ ; `string'
PUBLIC	??_C@_0CA@CMBCDMBH@Object?5is?5a?5number?5?3?5?9Infinity?6@ ; `string'
PUBLIC	??_C@_0BK@JAENJFCB@Object?5is?5a?5number?5?3?5NaN?6@ ; `string'
PUBLIC	??_C@_0BI@KDLCNKPI@Object?5is?5a?5number?5?3?50?6@ ; `string'
PUBLIC	??_C@_0BK@DKICMGNF@Object?5is?5a?5number?5?3?5?$CF0g?6@ ; `string'
PUBLIC	??_C@_0BG@IHKNOBPJ@Object?5is?5a?5string?5?3?5@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0CF@IDHPHOMH@Object?5is?5a?5point?5?3?5index?5?$CFd?5in@ ; `string'
PUBLIC	??_C@_0BP@BGPHFANM@Object?5is?5a?5collapsed?5range?5?3?6@ ; `string'
PUBLIC	??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@		; `string'
PUBLIC	??_C@_05GHBGFBPP@node?6@			; `string'
PUBLIC	??_C@_0BF@JIJMPGFP@Object?5is?5a?5range?5?3?6@	; `string'
PUBLIC	??_C@_05KCOAJPAG@From?5@			; `string'
PUBLIC	??_C@_03EMNLBAKJ@To?5@				; `string'
PUBLIC	??_C@_0BL@DOOMBINH@Object?5is?5a?5Location?5Set?3?6@ ; `string'
PUBLIC	??_C@_0BI@JJDBNCDG@Object?5is?5user?5defined?6@	; `string'
PUBLIC	??_C@_0O@IEEDPMEL@Step?5is?5NULL?6@		; `string'
PUBLIC	??_C@_03JMGAKCCH@END@				; `string'
PUBLIC	??_C@_03BDACDFHA@AND@				; `string'
PUBLIC	??_C@_02PDPFNDMG@OR@				; `string'
PUBLIC	??_C@_07MELFAPHK@EQUAL?5?$DN@			; `string'
PUBLIC	??_C@_08MPMADPIH@EQUAL?5?$CB?$DN@		; `string'
PUBLIC	??_C@_05OHCBIKNL@CMP?5?$DM@			; `string'
PUBLIC	??_C@_05NFBHOIFJ@CMP?5?$DO@			; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_06IPAPPNJ@PLUS?5?9@			; `string'
PUBLIC	??_C@_06FOKKFIFP@PLUS?5?$CL@			; `string'
PUBLIC	??_C@_0N@GEIAIOPG@PLUS?5unary?5?9@		; `string'
PUBLIC	??_C@_0P@FAIBJAJD@PLUS?5unary?5?9?5?9@		; `string'
PUBLIC	??_C@_06JFEGAKAJ@MULT?5?$CK@			; `string'
PUBLIC	??_C@_08HELPMGMA@MULT?5div@			; `string'
PUBLIC	??_C@_08HFMOIFCL@MULT?5mod@			; `string'
PUBLIC	??_C@_05GJNJOPB@UNION@				; `string'
PUBLIC	??_C@_04BNGIIOIP@ROOT@				; `string'
PUBLIC	??_C@_04OHPEDIPN@NODE@				; `string'
PUBLIC	??_C@_04DEPGJHBM@SORT@				; `string'
PUBLIC	??_C@_08BCOGFDOM@COLLECT?5@			; `string'
PUBLIC	??_C@_0O@CBBIECFC@?5?8ancestors?8?5@		; `string'
PUBLIC	??_C@_0BG@IJDLJMNP@?5?8ancestors?9or?9self?8?5@	; `string'
PUBLIC	??_C@_0P@IMBNHOPA@?5?8attributes?8?5@		; `string'
PUBLIC	??_C@_09DMHOAOKE@?5?8child?8?5@			; `string'
PUBLIC	??_C@_0P@COPGHIIE@?5?8descendant?8?5@		; `string'
PUBLIC	??_C@_0BH@OLEEPEHL@?5?8descendant?9or?9self?8?5@ ; `string'
PUBLIC	??_C@_0O@HPGIPOGE@?5?8following?8?5@		; `string'
PUBLIC	??_C@_0BH@KMMFLMJK@?5?8following?9siblings?8?5@	; `string'
PUBLIC	??_C@_0O@DIAKOKEE@?5?8namespace?8?5@		; `string'
PUBLIC	??_C@_0L@BKJAGPFG@?5?8parent?8?5@		; `string'
PUBLIC	??_C@_0O@BNHFEBDE@?5?8preceding?8?5@		; `string'
PUBLIC	??_C@_0BG@LJHOBDKP@?5?8preceding?9sibling?8?5@	; `string'
PUBLIC	??_C@_08HAEBALG@?5?8self?8?5@			; `string'
PUBLIC	??_C@_07MJDJHLDE@?8none?8?5@			; `string'
PUBLIC	??_C@_07MIHANB@?8type?8?5@			; `string'
PUBLIC	??_C@_05CCBNMHGJ@?8PI?8?5@			; `string'
PUBLIC	??_C@_06COJFFNFM@?8all?8?5@			; `string'
PUBLIC	??_C@_0N@CLKBKNNJ@?8namespace?8?5@		; `string'
PUBLIC	??_C@_07LEJDGAJE@?8name?8?5@			; `string'
PUBLIC	??_C@_07IDIJGDJF@?8node?8?5@			; `string'
PUBLIC	??_C@_0L@BBLKKJMH@?8comment?8?5@		; `string'
PUBLIC	??_C@_07KMAJMJAK@?8text?8?5@			; `string'
PUBLIC	??_C@_03DKEJHHJP@?$CFs?3@			; `string'
PUBLIC	??_C@_05MNKHOCPF@ELEM?5@			; `string'
PUBLIC	??_C@_0P@MLBLHJNB@VARIABLE?5?$CFs?3?$CFs@	; `string'
PUBLIC	??_C@_0M@MLPGFJHH@VARIABLE?5?$CFs@		; `string'
PUBLIC	??_C@_0BI@JIAOIFFJ@FUNCTION?5?$CFs?3?$CFs?$CI?$CFd?5args?$CJ@ ; `string'
PUBLIC	??_C@_0BF@LKMAOONC@FUNCTION?5?$CFs?$CI?$CFd?5args?$CJ@ ; `string'
PUBLIC	??_C@_03CNBDDMKH@ARG@				; `string'
PUBLIC	??_C@_09NKOLJOJL@PREDICATE@			; `string'
PUBLIC	??_C@_06EKKPGGCG@FILTER@			; `string'
PUBLIC	??_C@_07LNDIAM@RANGETO@				; `string'
PUBLIC	??_C@_0M@BEEHJFLN@UNKNOWN?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BG@FMDDAOLJ@Streaming?5Expression?6@	; `string'
PUBLIC	??_C@_0CD@DHBDACDN@Compiled?5Expression?5?3?5?$CFd?5elemen@ ; `string'
PUBLIC	??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@	; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0CB@EAFHACKN@XPath?5stack?5depth?5limit?5reached@ ; `string'
PUBLIC	??_C@_0P@LENPPBCI@pushing?5value?6@		; `string'
PUBLIC	??_C@_08KEBCLIFP@Infinity@			; `string'
PUBLIC	??_C@_09BLDCEMOH@?9Infinity@			; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_05PPJAHJKF@?$CF?$CK?4?$CKe@		; `string'
PUBLIC	??_C@_05POONKFEF@?$CF0?4?$CKf@			; `string'
PUBLIC	??_C@_0BH@EHGBBAJH@duplicating?5namespace?6@	; `string'
PUBLIC	??_C@_0BC@LBLPMNCN@creating?5nodeset?6@		; `string'
PUBLIC	??_C@_0BB@HLDFGIFL@growing?5nodeset?6@		; `string'
PUBLIC	??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@ ; `string'
PUBLIC	??_C@_0BB@IMBJKAMG@merging?5nodeset?6@		; `string'
PUBLIC	??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@ ; `string'
PUBLIC	??_C@_0BM@FFJIGPKH@creating?5result?5value?5tree?6@ ; `string'
PUBLIC	??_C@_0BK@DGDFHNNJ@creating?5node?5set?5object?6@ ; `string'
PUBLIC	??_C@_0BH@FGBKIIOK@creating?5float?5object?6@	; `string'
PUBLIC	??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@	; `string'
PUBLIC	??_C@_0BI@BJAGDAFP@creating?5string?5object?6@	; `string'
PUBLIC	??_C@_0BG@ENIHPAML@creating?5user?5object?6@	; `string'
PUBLIC	??_C@_0BA@KJDNPDLE@copying?5object?6@		; `string'
PUBLIC	??_C@_0CJ@OPCFGEGG@xmlXPathObjectCopy?3?5unsupported@ ; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0BC@GBNJEJGK@creating?5context?6@		; `string'
PUBLIC	??_C@_0BJ@KFGJCHDI@creating?5parser?5context?6@	; `string'
PUBLIC	??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@ ; `string'
PUBLIC	??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@	; `string'
PUBLIC	??_C@_0EL@MECKCKJO@xmlXPathCompareNodeSetValue?3?5Ca@ ; `string'
PUBLIC	??_C@_0BC@MHFGEIED@fake?5node?5libxslt@		; `string'
PUBLIC	??_C@_0DA@NKGEEAEF@xmlXPathTranslateFunction?3?5Inva@ ; `string'
PUBLIC	??_C@_04CLMONKIF@node@				; `string'
PUBLIC	??_C@_04CIMGMMMG@text@				; `string'
PUBLIC	??_C@_07GJGNEJFD@comment@			; `string'
PUBLIC	??_C@_0BH@NNLCFMHO@processing?9instruction@	; `string'
PUBLIC	??_C@_05IOMEMJEC@count@				; `string'
PUBLIC	??_C@_02MOLJINC@?3?3@				; `string'
PUBLIC	??_C@_08KHINJAEH@range?9to@			; `string'
PUBLIC	??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_08HBEFDOBD@ancestor@			; `string'
PUBLIC	??_C@_0BB@OLBPNJCF@ancestor?9or?9self@		; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute@			; `string'
PUBLIC	??_C@_05GPGNDLEK@child@				; `string'
PUBLIC	??_C@_0L@NJLDCKIO@descendant@			; `string'
PUBLIC	??_C@_0BD@EPJHOOIL@descendant?9or?9self@	; `string'
PUBLIC	??_C@_09BEIPBMDN@following@			; `string'
PUBLIC	??_C@_0BC@LMFKEKDG@following?9sibling@		; `string'
PUBLIC	??_C@_09KPMGAFNI@namespace@			; `string'
PUBLIC	??_C@_06MLKDMCBD@parent@			; `string'
PUBLIC	??_C@_09MGMONEC@preceding@			; `string'
PUBLIC	??_C@_0BC@MLGDENAI@preceding?9sibling@		; `string'
PUBLIC	??_C@_04PJDNGLKJ@self@				; `string'
PUBLIC	??_C@_04PLGBGIDD@last@				; `string'
PUBLIC	??_C@_0DO@IDAPNIMJ@xmlXPathCompOpEval?3?5variable?5?$CFs@ ; `string'
PUBLIC	??_C@_0CF@LMIGLEJC@xmlXPathCompOpEval?3?5parameter?5e@ ; `string'
PUBLIC	??_C@_0DO@MGJDMDIG@xmlXPathCompOpEval?3?5function?5?$CFs@ ; `string'
PUBLIC	??_C@_0CL@KAMILNDJ@xmlXPathCompOpEval?3?5function?5?$CFs@ ; `string'
PUBLIC	??_C@_0CJ@OFCEKGJC@XPath?3?5unknown?5precompiled?5oper@ ; `string'
PUBLIC	??_C@_0CJ@GKOHPKDK@xmlXPathRunEval?3?5last?5is?5less?5t@ ; `string'
PUBLIC	??_C@_0BN@BJKHBGFI@allocating?5namespaces?5array?6@ ; `string'
PUBLIC	??_C@_0CC@FJFLGALO@allocating?5streamable?5expressio@ ; `string'
PUBLIC	??_C@_0BG@PBKLCIKP@NULL?5context?5pointer?6@	; `string'
PUBLIC	??_C@_0CP@KKKCDCLL@xmlXPathCompiledEval?3?5No?5result@ ; `string'
PUBLIC	??_C@_0DH@OEPEKFKA@xmlXPathCompiledEval?3?5?$CFd?5object@ ; `string'
PUBLIC	??_C@_07GOBOHMJA@boolean@			; `string'
PUBLIC	??_C@_07EANFIDJB@ceiling@			; `string'
PUBLIC	??_C@_06CMLIEHFC@concat@			; `string'
PUBLIC	??_C@_08JKMOLGCD@contains@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_05PBJFFIGL@floor@				; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_0L@JNMMKGPH@local?9name@			; `string'
PUBLIC	??_C@_03NJKJADM@not@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0O@LIBIEKOH@namespace?9uri@		; `string'
PUBLIC	??_C@_0BA@GMCNNFIH@normalize?9space@		; `string'
PUBLIC	??_C@_06EBGNBFIA@number@			; `string'
PUBLIC	??_C@_08OAGMDKAF@position@			; `string'
PUBLIC	??_C@_05MIMAKCN@round@				; `string'
PUBLIC	??_C@_06ICGJLFIM@string@			; `string'
PUBLIC	??_C@_0O@NOLAIBIG@string?9length@		; `string'
PUBLIC	??_C@_0M@MENNCJLJ@starts?9with@			; `string'
PUBLIC	??_C@_09MJALBNED@substring@			; `string'
PUBLIC	??_C@_0BB@KKJFBMPK@substring?9before@		; `string'
PUBLIC	??_C@_0BA@JEDLCCAF@substring?9after@		; `string'
PUBLIC	??_C@_03CFFIJAMA@sum@				; `string'
PUBLIC	??_C@_09ODNGOEIO@translate@			; `string'
PUBLIC	??_C@_0CL@DABLMGPH@http?3?1?1www?4w3?4org?12002?108?1xquer@ ; `string'
PUBLIC	??_C@_0L@ODIBMOLP@escape?9uri@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@41cdcd6500000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@7ff0000000000000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@c1e0000000000000
PUBLIC	__real@fff0000000000000
PUBLIC	__real@fff8000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlStrPrintf:PROC
EXTRN	_xmlUTF8Strsize:PROC
EXTRN	_xmlUTF8Strpos:PROC
EXTRN	_xmlUTF8Strloc:PROC
EXTRN	_xmlUTF8Strsub:PROC
EXTRN	_xmlUTF8Strlen:PROC
EXTRN	__imp___dclass:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__toupper:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlBuildQName:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlGetNsList:PROC
EXTRN	_xmlNodeGetContent:PROC
EXTRN	_xmlNodeGetLang:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashDefaultDeallocator:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashUpdateEntry:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashUpdateEntry2:PROC
EXTRN	_xmlHashRemoveEntry:PROC
EXTRN	_xmlHashRemoveEntry2:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlResetError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlGetID:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlCopyChar:PROC
EXTRN	_xmlXPtrLocationSetCreate:PROC
EXTRN	_xmlXPtrFreeLocationSet:PROC
EXTRN	_xmlXPtrLocationSetMerge:PROC
EXTRN	_xmlXPtrNewRange:PROC
EXTRN	_xmlXPtrNewRangeNodeObject:PROC
EXTRN	_xmlXPtrLocationSetAdd:PROC
EXTRN	_xmlXPtrWrapLocationSet:PROC
EXTRN	_xmlDebugDumpString:PROC
EXTRN	_xmlDebugDumpAttr:PROC
EXTRN	_xmlDebugDumpOneNode:PROC
EXTRN	_xmlFreePattern:PROC
EXTRN	_xmlFreePatternList:PROC
EXTRN	_xmlPatterncompile:PROC
EXTRN	_xmlPatternStreamable:PROC
EXTRN	_xmlPatternMaxDepth:PROC
EXTRN	_xmlPatternMinDepth:PROC
EXTRN	_xmlPatternFromRoot:PROC
EXTRN	_xmlPatternGetStreamCtxt:PROC
EXTRN	_xmlFreeStreamCtxt:PROC
EXTRN	_xmlStreamPushNode:PROC
EXTRN	_xmlStreamPush:PROC
EXTRN	_xmlStreamPop:PROC
EXTRN	_xmlStreamWantsAnyNode:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufAdd:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__CIfmod:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	_ceil:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@fff8000000000000
CONST	SEGMENT
__real@fff8000000000000 DQ 0fff8000000000000r	; -nan(ind)
CONST	ENDS
;	COMDAT __real@fff0000000000000
CONST	SEGMENT
__real@fff0000000000000 DQ 0fff0000000000000r	; -inf
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+09
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@7ff0000000000000
CONST	SEGMENT
__real@7ff0000000000000 DQ 07ff0000000000000r	; inf
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-05
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0L@ODIBMOLP@escape?9uri@
CONST	SEGMENT
??_C@_0L@ODIBMOLP@escape?9uri@ DB 'escape-uri', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DABLMGPH@http?3?1?1www?4w3?4org?12002?108?1xquer@
CONST	SEGMENT
??_C@_0CL@DABLMGPH@http?3?1?1www?4w3?4org?12002?108?1xquer@ DB 'http://ww'
	DB	'w.w3.org/2002/08/xquery-functions', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate@ DB 'translate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFFIJAMA@sum@
CONST	SEGMENT
??_C@_03CFFIJAMA@sum@ DB 'sum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JEDLCCAF@substring?9after@
CONST	SEGMENT
??_C@_0BA@JEDLCCAF@substring?9after@ DB 'substring-after', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KKJFBMPK@substring?9before@
CONST	SEGMENT
??_C@_0BB@KKJFBMPK@substring?9before@ DB 'substring-before', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MJALBNED@substring@
CONST	SEGMENT
??_C@_09MJALBNED@substring@ DB 'substring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MENNCJLJ@starts?9with@
CONST	SEGMENT
??_C@_0M@MENNCJLJ@starts?9with@ DB 'starts-with', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOLAIBIG@string?9length@
CONST	SEGMENT
??_C@_0O@NOLAIBIG@string?9length@ DB 'string-length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string@
CONST	SEGMENT
??_C@_06ICGJLFIM@string@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIMAKCN@round@
CONST	SEGMENT
??_C@_05MIMAKCN@round@ DB 'round', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAGMDKAF@position@
CONST	SEGMENT
??_C@_08OAGMDKAF@position@ DB 'position', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBGNBFIA@number@
CONST	SEGMENT
??_C@_06EBGNBFIA@number@ DB 'number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMCNNFIH@normalize?9space@
CONST	SEGMENT
??_C@_0BA@GMCNNFIH@normalize?9space@ DB 'normalize-space', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LIBIEKOH@namespace?9uri@
CONST	SEGMENT
??_C@_0O@LIBIEKOH@namespace?9uri@ DB 'namespace-uri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJKJADM@not@
CONST	SEGMENT
??_C@_03NJKJADM@not@ DB 'not', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNMMKGPH@local?9name@
CONST	SEGMENT
??_C@_0L@JNMMKGPH@local?9name@ DB 'local-name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBJFFIGL@floor@
CONST	SEGMENT
??_C@_05PBJFFIGL@floor@ DB 'floor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKMOLGCD@contains@
CONST	SEGMENT
??_C@_08JKMOLGCD@contains@ DB 'contains', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMLIEHFC@concat@
CONST	SEGMENT
??_C@_06CMLIEHFC@concat@ DB 'concat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EANFIDJB@ceiling@
CONST	SEGMENT
??_C@_07EANFIDJB@ceiling@ DB 'ceiling', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOBOHMJA@boolean@
CONST	SEGMENT
??_C@_07GOBOHMJA@boolean@ DB 'boolean', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OEPEKFKA@xmlXPathCompiledEval?3?5?$CFd?5object@
CONST	SEGMENT
??_C@_0DH@OEPEKFKA@xmlXPathCompiledEval?3?5?$CFd?5object@ DB 'xmlXPathCom'
	DB	'piledEval: %d object(s) left on the stack.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KKKCDCLL@xmlXPathCompiledEval?3?5No?5result@
CONST	SEGMENT
??_C@_0CP@KKKCDCLL@xmlXPathCompiledEval?3?5No?5result@ DB 'xmlXPathCompil'
	DB	'edEval: No result on the stack.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PBKLCIKP@NULL?5context?5pointer?6@
CONST	SEGMENT
??_C@_0BG@PBKLCIKP@NULL?5context?5pointer?6@ DB 'NULL context pointer', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FJFLGALO@allocating?5streamable?5expressio@
CONST	SEGMENT
??_C@_0CC@FJFLGALO@allocating?5streamable?5expressio@ DB 'allocating stre'
	DB	'amable expression', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BJKHBGFI@allocating?5namespaces?5array?6@
CONST	SEGMENT
??_C@_0BN@BJKHBGFI@allocating?5namespaces?5array?6@ DB 'allocating namesp'
	DB	'aces array', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GKOHPKDK@xmlXPathRunEval?3?5last?5is?5less?5t@
CONST	SEGMENT
??_C@_0CJ@GKOHPKDK@xmlXPathRunEval?3?5last?5is?5less?5t@ DB 'xmlXPathRunE'
	DB	'val: last is less than zero', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OFCEKGJC@XPath?3?5unknown?5precompiled?5oper@
CONST	SEGMENT
??_C@_0CJ@OFCEKGJC@XPath?3?5unknown?5precompiled?5oper@ DB 'XPath: unknow'
	DB	'n precompiled operation %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KAMILNDJ@xmlXPathCompOpEval?3?5function?5?$CFs@
CONST	SEGMENT
??_C@_0CL@KAMILNDJ@xmlXPathCompOpEval?3?5function?5?$CFs@ DB 'xmlXPathCom'
	DB	'pOpEval: function %s not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MGJDMDIG@xmlXPathCompOpEval?3?5function?5?$CFs@
CONST	SEGMENT
??_C@_0DO@MGJDMDIG@xmlXPathCompOpEval?3?5function?5?$CFs@ DB 'xmlXPathCom'
	DB	'pOpEval: function %s bound to undefined prefix %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LMIGLEJC@xmlXPathCompOpEval?3?5parameter?5e@
CONST	SEGMENT
??_C@_0CF@LMIGLEJC@xmlXPathCompOpEval?3?5parameter?5e@ DB 'xmlXPathCompOp'
	DB	'Eval: parameter error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IDAPNIMJ@xmlXPathCompOpEval?3?5variable?5?$CFs@
CONST	SEGMENT
??_C@_0DO@IDAPNIMJ@xmlXPathCompOpEval?3?5variable?5?$CFs@ DB 'xmlXPathCom'
	DB	'pOpEval: variable %s bound to undefined prefix %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLGBGIDD@last@
CONST	SEGMENT
??_C@_04PLGBGIDD@last@ DB 'last', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJDNGLKJ@self@
CONST	SEGMENT
??_C@_04PJDNGLKJ@self@ DB 'self', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLGDENAI@preceding?9sibling@
CONST	SEGMENT
??_C@_0BC@MLGDENAI@preceding?9sibling@ DB 'preceding-sibling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MGMONEC@preceding@
CONST	SEGMENT
??_C@_09MGMONEC@preceding@ DB 'preceding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLKDMCBD@parent@
CONST	SEGMENT
??_C@_06MLKDMCBD@parent@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KPMGAFNI@namespace@
CONST	SEGMENT
??_C@_09KPMGAFNI@namespace@ DB 'namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMFKEKDG@following?9sibling@
CONST	SEGMENT
??_C@_0BC@LMFKEKDG@following?9sibling@ DB 'following-sibling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BEIPBMDN@following@
CONST	SEGMENT
??_C@_09BEIPBMDN@following@ DB 'following', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPJHOOIL@descendant?9or?9self@
CONST	SEGMENT
??_C@_0BD@EPJHOOIL@descendant?9or?9self@ DB 'descendant-or-self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NJLDCKIO@descendant@
CONST	SEGMENT
??_C@_0L@NJLDCKIO@descendant@ DB 'descendant', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GPGNDLEK@child@
CONST	SEGMENT
??_C@_05GPGNDLEK@child@ DB 'child', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute@ DB 'attribute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OLBPNJCF@ancestor?9or?9self@
CONST	SEGMENT
??_C@_0BB@OLBPNJCF@ancestor?9or?9self@ DB 'ancestor-or-self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBEFDOBD@ancestor@
CONST	SEGMENT
??_C@_08HBEFDOBD@ancestor@ DB 'ancestor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ DB 'Internal erro'
	DB	'r at %s:%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KHINJAEH@range?9to@
CONST	SEGMENT
??_C@_08KHINJAEH@range?9to@ DB 'range-to', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MOLJINC@?3?3@
CONST	SEGMENT
??_C@_02MOLJINC@?3?3@ DB '::', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count@
CONST	SEGMENT
??_C@_05IOMEMJEC@count@ DB 'count', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NNLCFMHO@processing?9instruction@
CONST	SEGMENT
??_C@_0BH@NNLCFMHO@processing?9instruction@ DB 'processing-instruction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJGNEJFD@comment@
CONST	SEGMENT
??_C@_07GJGNEJFD@comment@ DB 'comment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIMGMMMG@text@
CONST	SEGMENT
??_C@_04CIMGMMMG@text@ DB 'text', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLMONKIF@node@
CONST	SEGMENT
??_C@_04CLMONKIF@node@ DB 'node', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NKGEEAEF@xmlXPathTranslateFunction?3?5Inva@
CONST	SEGMENT
??_C@_0DA@NKGEEAEF@xmlXPathTranslateFunction?3?5Inva@ DB 'xmlXPathTransla'
	DB	'teFunction: Invalid UTF8 string', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MHFGEIED@fake?5node?5libxslt@
CONST	SEGMENT
??_C@_0BC@MHFGEIED@fake?5node?5libxslt@ DB 'fake node libxslt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MECKCKJO@xmlXPathCompareNodeSetValue?3?5Ca@
CONST	SEGMENT
??_C@_0EL@MECKCKJO@xmlXPathCompareNodeSetValue?3?5Ca@ DB 'xmlXPathCompare'
	DB	'NodeSetValue: Can''t compare node set and object of type %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
CONST	SEGMENT
??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@ DB 'comparing nodesets', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
CONST	SEGMENT
??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@ DB 'creating evaluati'
	DB	'on context', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KFGJCHDI@creating?5parser?5context?6@
CONST	SEGMENT
??_C@_0BJ@KFGJCHDI@creating?5parser?5context?6@ DB 'creating parser conte'
	DB	'xt', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBNJEJGK@creating?5context?6@
CONST	SEGMENT
??_C@_0BC@GBNJEJGK@creating?5context?6@ DB 'creating context', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OPCFGEGG@xmlXPathObjectCopy?3?5unsupported@
CONST	SEGMENT
??_C@_0CJ@OPCFGEGG@xmlXPathObjectCopy?3?5unsupported@ DB 'xmlXPathObjectC'
	DB	'opy: unsupported type %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KJDNPDLE@copying?5object?6@
CONST	SEGMENT
??_C@_0BA@KJDNPDLE@copying?5object?6@ DB 'copying object', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENIHPAML@creating?5user?5object?6@
CONST	SEGMENT
??_C@_0BG@ENIHPAML@creating?5user?5object?6@ DB 'creating user object', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
CONST	SEGMENT
??_C@_0BI@BJAGDAFP@creating?5string?5object?6@ DB 'creating string object'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
CONST	SEGMENT
??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@ DB 'creating boolean obje'
	DB	'ct', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGBKIIOK@creating?5float?5object?6@
CONST	SEGMENT
??_C@_0BH@FGBKIIOK@creating?5float?5object?6@ DB 'creating float object', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DGDFHNNJ@creating?5node?5set?5object?6@
CONST	SEGMENT
??_C@_0BK@DGDFHNNJ@creating?5node?5set?5object?6@ DB 'creating node set o'
	DB	'bject', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFJIGPKH@creating?5result?5value?5tree?6@
CONST	SEGMENT
??_C@_0BM@FFJIGPKH@creating?5result?5value?5tree?6@ DB 'creating result v'
	DB	'alue tree', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
CONST	SEGMENT
??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@ DB 'merging nodeset hi'
	DB	't limit', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
CONST	SEGMENT
??_C@_0BB@IMBJKAMG@merging?5nodeset?6@ DB 'merging nodeset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
CONST	SEGMENT
??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@ DB 'growing nodeset hit'
	DB	' limit', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@
CONST	SEGMENT
??_C@_0BB@HLDFGIFL@growing?5nodeset?6@ DB 'growing nodeset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
CONST	SEGMENT
??_C@_0BC@LBLPMNCN@creating?5nodeset?6@ DB 'creating nodeset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EHGBBAJH@duplicating?5namespace?6@
CONST	SEGMENT
??_C@_0BH@EHGBBAJH@duplicating?5namespace?6@ DB 'duplicating namespace', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05POONKFEF@?$CF0?4?$CKf@
CONST	SEGMENT
??_C@_05POONKFEF@?$CF0?4?$CKf@ DB '%0.*f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPJAHJKF@?$CF?$CK?4?$CKe@
CONST	SEGMENT
??_C@_05PPJAHJKF@?$CF?$CK?4?$CKe@ DB '%*.*e', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLDCEMOH@?9Infinity@
CONST	SEGMENT
??_C@_09BLDCEMOH@?9Infinity@ DB '-Infinity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity@ DB 'Infinity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LENPPBCI@pushing?5value?6@
CONST	SEGMENT
??_C@_0P@LENPPBCI@pushing?5value?6@ DB 'pushing value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EAFHACKN@XPath?5stack?5depth?5limit?5reached@
CONST	SEGMENT
??_C@_0CB@EAFHACKN@XPath?5stack?5depth?5limit?5reached@ DB 'XPath stack d'
	DB	'epth limit reached', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xpath.c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@
CONST	SEGMENT
??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@ DB 'creating object cache', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DHBDACDN@Compiled?5Expression?5?3?5?$CFd?5elemen@
CONST	SEGMENT
??_C@_0CD@DHBDACDN@Compiled?5Expression?5?3?5?$CFd?5elemen@ DB 'Compiled '
	DB	'Expression : %d elements', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMDDAOLJ@Streaming?5Expression?6@
CONST	SEGMENT
??_C@_0BG@FMDDAOLJ@Streaming?5Expression?6@ DB 'Streaming Expression', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BEEHJFLN@UNKNOWN?5?$CFd?6@
CONST	SEGMENT
??_C@_0M@BEEHJFLN@UNKNOWN?5?$CFd?6@ DB 'UNKNOWN %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNDIAM@RANGETO@
CONST	SEGMENT
??_C@_07LNDIAM@RANGETO@ DB 'RANGETO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKKPGGCG@FILTER@
CONST	SEGMENT
??_C@_06EKKPGGCG@FILTER@ DB 'FILTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKOLJOJL@PREDICATE@
CONST	SEGMENT
??_C@_09NKOLJOJL@PREDICATE@ DB 'PREDICATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNBDDMKH@ARG@
CONST	SEGMENT
??_C@_03CNBDDMKH@ARG@ DB 'ARG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LKMAOONC@FUNCTION?5?$CFs?$CI?$CFd?5args?$CJ@
CONST	SEGMENT
??_C@_0BF@LKMAOONC@FUNCTION?5?$CFs?$CI?$CFd?5args?$CJ@ DB 'FUNCTION %s(%d'
	DB	' args)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JIAOIFFJ@FUNCTION?5?$CFs?3?$CFs?$CI?$CFd?5args?$CJ@
CONST	SEGMENT
??_C@_0BI@JIAOIFFJ@FUNCTION?5?$CFs?3?$CFs?$CI?$CFd?5args?$CJ@ DB 'FUNCTIO'
	DB	'N %s:%s(%d args)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLPGFJHH@VARIABLE?5?$CFs@
CONST	SEGMENT
??_C@_0M@MLPGFJHH@VARIABLE?5?$CFs@ DB 'VARIABLE %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLBLHJNB@VARIABLE?5?$CFs?3?$CFs@
CONST	SEGMENT
??_C@_0P@MLBLHJNB@VARIABLE?5?$CFs?3?$CFs@ DB 'VARIABLE %s:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNKHOCPF@ELEM?5@
CONST	SEGMENT
??_C@_05MNKHOCPF@ELEM?5@ DB 'ELEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKEJHHJP@?$CFs?3@
CONST	SEGMENT
??_C@_03DKEJHHJP@?$CFs?3@ DB '%s:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMAJMJAK@?8text?8?5@
CONST	SEGMENT
??_C@_07KMAJMJAK@?8text?8?5@ DB '''text'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBLKKJMH@?8comment?8?5@
CONST	SEGMENT
??_C@_0L@BBLKKJMH@?8comment?8?5@ DB '''comment'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDIJGDJF@?8node?8?5@
CONST	SEGMENT
??_C@_07IDIJGDJF@?8node?8?5@ DB '''node'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEJDGAJE@?8name?8?5@
CONST	SEGMENT
??_C@_07LEJDGAJE@?8name?8?5@ DB '''name'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLKBKNNJ@?8namespace?8?5@
CONST	SEGMENT
??_C@_0N@CLKBKNNJ@?8namespace?8?5@ DB '''namespace'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06COJFFNFM@?8all?8?5@
CONST	SEGMENT
??_C@_06COJFFNFM@?8all?8?5@ DB '''all'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCBNMHGJ@?8PI?8?5@
CONST	SEGMENT
??_C@_05CCBNMHGJ@?8PI?8?5@ DB '''PI'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIHANB@?8type?8?5@
CONST	SEGMENT
??_C@_07MIHANB@?8type?8?5@ DB '''type'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJDJHLDE@?8none?8?5@
CONST	SEGMENT
??_C@_07MJDJHLDE@?8none?8?5@ DB '''none'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAEBALG@?5?8self?8?5@
CONST	SEGMENT
??_C@_08HAEBALG@?5?8self?8?5@ DB ' ''self'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LJHOBDKP@?5?8preceding?9sibling?8?5@
CONST	SEGMENT
??_C@_0BG@LJHOBDKP@?5?8preceding?9sibling?8?5@ DB ' ''preceding-sibling'''
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNHFEBDE@?5?8preceding?8?5@
CONST	SEGMENT
??_C@_0O@BNHFEBDE@?5?8preceding?8?5@ DB ' ''preceding'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKJAGPFG@?5?8parent?8?5@
CONST	SEGMENT
??_C@_0L@BKJAGPFG@?5?8parent?8?5@ DB ' ''parent'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DIAKOKEE@?5?8namespace?8?5@
CONST	SEGMENT
??_C@_0O@DIAKOKEE@?5?8namespace?8?5@ DB ' ''namespace'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KMMFLMJK@?5?8following?9siblings?8?5@
CONST	SEGMENT
??_C@_0BH@KMMFLMJK@?5?8following?9siblings?8?5@ DB ' ''following-siblings'
	DB	''' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HPGIPOGE@?5?8following?8?5@
CONST	SEGMENT
??_C@_0O@HPGIPOGE@?5?8following?8?5@ DB ' ''following'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OLEEPEHL@?5?8descendant?9or?9self?8?5@
CONST	SEGMENT
??_C@_0BH@OLEEPEHL@?5?8descendant?9or?9self?8?5@ DB ' ''descendant-or-sel'
	DB	'f'' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@COPGHIIE@?5?8descendant?8?5@
CONST	SEGMENT
??_C@_0P@COPGHIIE@?5?8descendant?8?5@ DB ' ''descendant'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMHOAOKE@?5?8child?8?5@
CONST	SEGMENT
??_C@_09DMHOAOKE@?5?8child?8?5@ DB ' ''child'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMBNHOPA@?5?8attributes?8?5@
CONST	SEGMENT
??_C@_0P@IMBNHOPA@?5?8attributes?8?5@ DB ' ''attributes'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJDLJMNP@?5?8ancestors?9or?9self?8?5@
CONST	SEGMENT
??_C@_0BG@IJDLJMNP@?5?8ancestors?9or?9self?8?5@ DB ' ''ancestors-or-self'''
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBBIECFC@?5?8ancestors?8?5@
CONST	SEGMENT
??_C@_0O@CBBIECFC@?5?8ancestors?8?5@ DB ' ''ancestors'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCOGFDOM@COLLECT?5@
CONST	SEGMENT
??_C@_08BCOGFDOM@COLLECT?5@ DB 'COLLECT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEPGJHBM@SORT@
CONST	SEGMENT
??_C@_04DEPGJHBM@SORT@ DB 'SORT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHPEDIPN@NODE@
CONST	SEGMENT
??_C@_04OHPEDIPN@NODE@ DB 'NODE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BNGIIOIP@ROOT@
CONST	SEGMENT
??_C@_04BNGIIOIP@ROOT@ DB 'ROOT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJNJOPB@UNION@
CONST	SEGMENT
??_C@_05GJNJOPB@UNION@ DB 'UNION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFMOIFCL@MULT?5mod@
CONST	SEGMENT
??_C@_08HFMOIFCL@MULT?5mod@ DB 'MULT mod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HELPMGMA@MULT?5div@
CONST	SEGMENT
??_C@_08HELPMGMA@MULT?5div@ DB 'MULT div', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JFEGAKAJ@MULT?5?$CK@
CONST	SEGMENT
??_C@_06JFEGAKAJ@MULT?5?$CK@ DB 'MULT *', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FAIBJAJD@PLUS?5unary?5?9?5?9@
CONST	SEGMENT
??_C@_0P@FAIBJAJD@PLUS?5unary?5?9?5?9@ DB 'PLUS unary - -', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GEIAIOPG@PLUS?5unary?5?9@
CONST	SEGMENT
??_C@_0N@GEIAIOPG@PLUS?5unary?5?9@ DB 'PLUS unary -', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOKKFIFP@PLUS?5?$CL@
CONST	SEGMENT
??_C@_06FOKKFIFP@PLUS?5?$CL@ DB 'PLUS +', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPAPPNJ@PLUS?5?9@
CONST	SEGMENT
??_C@_06IPAPPNJ@PLUS?5?9@ DB 'PLUS -', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFBHOIFJ@CMP?5?$DO@
CONST	SEGMENT
??_C@_05NFBHOIFJ@CMP?5?$DO@ DB 'CMP >', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OHCBIKNL@CMP?5?$DM@
CONST	SEGMENT
??_C@_05OHCBIKNL@CMP?5?$DM@ DB 'CMP <', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPMADPIH@EQUAL?5?$CB?$DN@
CONST	SEGMENT
??_C@_08MPMADPIH@EQUAL?5?$CB?$DN@ DB 'EQUAL !=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MELFAPHK@EQUAL?5?$DN@
CONST	SEGMENT
??_C@_07MELFAPHK@EQUAL?5?$DN@ DB 'EQUAL =', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDPFNDMG@OR@
CONST	SEGMENT
??_C@_02PDPFNDMG@OR@ DB 'OR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDACDFHA@AND@
CONST	SEGMENT
??_C@_03BDACDFHA@AND@ DB 'AND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMGAKCCH@END@
CONST	SEGMENT
??_C@_03JMGAKCCH@END@ DB 'END', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IEEDPMEL@Step?5is?5NULL?6@
CONST	SEGMENT
??_C@_0O@IEEDPMEL@Step?5is?5NULL?6@ DB 'Step is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JJDBNCDG@Object?5is?5user?5defined?6@
CONST	SEGMENT
??_C@_0BI@JJDBNCDG@Object?5is?5user?5defined?6@ DB 'Object is user define'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOOMBINH@Object?5is?5a?5Location?5Set?3?6@
CONST	SEGMENT
??_C@_0BL@DOOMBINH@Object?5is?5a?5Location?5Set?3?6@ DB 'Object is a Loca'
	DB	'tion Set:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMNLBAKJ@To?5@
CONST	SEGMENT
??_C@_03EMNLBAKJ@To?5@ DB 'To ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCOAJPAG@From?5@
CONST	SEGMENT
??_C@_05KCOAJPAG@From?5@ DB 'From ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JIJMPGFP@Object?5is?5a?5range?5?3?6@
CONST	SEGMENT
??_C@_0BF@JIJMPGFP@Object?5is?5a?5range?5?3?6@ DB 'Object is a range :', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05GHBGFBPP@node?6@
CONST	SEGMENT
??_C@_05GHBGFBPP@node?6@ DB 'node', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@
CONST	SEGMENT
??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@ DB 'index %d in ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BGPHFANM@Object?5is?5a?5collapsed?5range?5?3?6@
CONST	SEGMENT
??_C@_0BP@BGPHFANM@Object?5is?5a?5collapsed?5range?5?3?6@ DB 'Object is a'
	DB	' collapsed range :', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IDHPHOMH@Object?5is?5a?5point?5?3?5index?5?$CFd?5in@
CONST	SEGMENT
??_C@_0CF@IDHPHOMH@Object?5is?5a?5point?5?3?5index?5?$CFd?5in@ DB 'Object'
	DB	' is a point : index %d in node', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IHKNOBPJ@Object?5is?5a?5string?5?3?5@
CONST	SEGMENT
??_C@_0BG@IHKNOBPJ@Object?5is?5a?5string?5?3?5@ DB 'Object is a string : '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DKICMGNF@Object?5is?5a?5number?5?3?5?$CF0g?6@
CONST	SEGMENT
??_C@_0BK@DKICMGNF@Object?5is?5a?5number?5?3?5?$CF0g?6@ DB 'Object is a n'
	DB	'umber : %0g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLCNKPI@Object?5is?5a?5number?5?3?50?6@
CONST	SEGMENT
??_C@_0BI@KDLCNKPI@Object?5is?5a?5number?5?3?50?6@ DB 'Object is a number'
	DB	' : 0', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JAENJFCB@Object?5is?5a?5number?5?3?5NaN?6@
CONST	SEGMENT
??_C@_0BK@JAENJFCB@Object?5is?5a?5number?5?3?5NaN?6@ DB 'Object is a numb'
	DB	'er : NaN', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CMBCDMBH@Object?5is?5a?5number?5?3?5?9Infinity?6@
CONST	SEGMENT
??_C@_0CA@CMBCDMBH@Object?5is?5a?5number?5?3?5?9Infinity?6@ DB 'Object is'
	DB	' a number : -Infinity', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DBNKIPBA@Object?5is?5a?5number?5?3?5Infinity?6@
CONST	SEGMENT
??_C@_0BP@DBNKIPBA@Object?5is?5a?5number?5?3?5Infinity?6@ DB 'Object is a'
	DB	' number : Infinity', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NIOGPBNO@false?6@
CONST	SEGMENT
??_C@_06NIOGPBNO@false?6@ DB 'false', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LFIOBDML@true?6@
CONST	SEGMENT
??_C@_05LFIOBDML@true?6@ DB 'true', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPCPEGOI@Object?5is?5a?5Boolean?5?3?5@
CONST	SEGMENT
??_C@_0BH@GPCPEGOI@Object?5is?5a?5Boolean?5?3?5@ DB 'Object is a Boolean '
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NNPHAPO@Object?5is?5an?5XSLT?5value?5tree?5?3?6@
CONST	SEGMENT
??_C@_0CA@NNPHAPO@Object?5is?5an?5XSLT?5value?5tree?5?3?6@ DB 'Object is '
	DB	'an XSLT value tree :', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NCNINNMM@Object?5is?5a?5Node?5Set?5?3?6@
CONST	SEGMENT
??_C@_0BI@NCNINNMM@Object?5is?5a?5Node?5Set?5?3?6@ DB 'Object is a Node S'
	DB	'et :', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EGAONLPM@Object?5is?5uninitialized?6@
CONST	SEGMENT
??_C@_0BJ@EGAONLPM@Object?5is?5uninitialized?6@ DB 'Object is uninitializ'
	DB	'ed', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CIBIAOEE@Object?5is?5empty?5?$CINULL?$CJ?6@
CONST	SEGMENT
??_C@_0BI@CIBIAOEE@Object?5is?5empty?5?$CINULL?$CJ?6@ DB 'Object is empty'
	DB	' (NULL)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJKEPAIO@?$CFd?5?3?5@
CONST	SEGMENT
??_C@_05GJKEPAIO@?$CFd?5?3?5@ DB '%d : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OMGEHPOG@LocationSet?5is?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BH@OMGEHPOG@LocationSet?5is?5NULL?5?$CB?6@ DB 'LocationSet is NULL'
	DB	' !', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ODIPEGMA@Value?5Tree?5is?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BG@ODIPEGMA@Value?5Tree?5is?5NULL?5?$CB?6@ DB 'Value Tree is NULL '
	DB	'!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CGJHGOLK@Set?5contains?5?$CFd?5nodes?3?6@
CONST	SEGMENT
??_C@_0BI@CGJHGOLK@Set?5contains?5?$CFd?5nodes?3?6@ DB 'Set contains %d n'
	DB	'odes:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CEACDENF@NodeSet?5is?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BD@CEACDENF@NodeSet?5is?5NULL?5?$CB?6@ DB 'NodeSet is NULL !', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHHHGGIK@?5?1?6@
CONST	SEGMENT
??_C@_03LHHHGGIK@?5?1?6@ DB ' /', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@ DB 'Node is NULL !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHHFFDFC@adding?5step?6@
CONST	SEGMENT
??_C@_0N@GHHFFDFC@adding?5step?6@ DB 'adding step', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EIFELMJ@allocating?5steps?6@
CONST	SEGMENT
??_C@_0BC@EIFELMJ@allocating?5steps?6@ DB 'allocating steps', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OMFEJMIL@allocating?5component?6@
CONST	SEGMENT
??_C@_0BG@OMFEJMIL@allocating?5component?6@ DB 'allocating component', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@
CONST	SEGMENT
??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@ DB 'xmlPointerList'
	DB	'AddSize: re-allocating item', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@
CONST	SEGMENT
??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@ DB 'xmlPointerListC'
	DB	'reate: allocating item', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlXPathXMLNamespace DD FLAT:_xmlXPathXMLNamespaceStruct
	ORG $+4
_xmlXPathErrorMessages DD FLAT:??_C@_03KDKBKEMD@Ok?6@
	DD	FLAT:??_C@_0BB@OKMDJLIM@Number?5encoding?6@
	DD	FLAT:??_C@_0BE@HEBMIFHL@Unfinished?5literal?6@
	DD	FLAT:??_C@_0BC@KLADNOLA@Start?5of?5literal?6@
	DD	FLAT:??_C@_0CD@PCDALDFN@Expected?5$?5for?5variable?5referen@
	DD	FLAT:??_C@_0BE@JIMEOEEA@Undefined?5variable?6@
	DD	FLAT:??_C@_0BD@MFLBJOMG@Invalid?5predicate?6@
	DD	FLAT:??_C@_0BE@CGBIHHBE@Invalid?5expression?6@
	DD	FLAT:??_C@_0BN@DKJEIEAC@Missing?5closing?5curly?5brace?6@
	DD	FLAT:??_C@_0BH@FDADKKDC@Unregistered?5function?6@
	DD	FLAT:??_C@_0BB@NCMBGCMG@Invalid?5operand?6@
	DD	FLAT:??_C@_0O@HECJPNOD@Invalid?5type?6@
	DD	FLAT:??_C@_0BN@CGCHLLOB@Invalid?5number?5of?5arguments?6@
	DD	FLAT:??_C@_0BG@JMBOPCAE@Invalid?5context?5size?6@
	DD	FLAT:??_C@_0BK@CKPBPDPH@Invalid?5context?5position?6@
	DD	FLAT:??_C@_0BJ@OGCHFJAK@Memory?5allocation?5error?6@
	DD	FLAT:??_C@_0O@JJFGCDGG@Syntax?5error?6@
	DD	FLAT:??_C@_0BA@IPNFPAOO@Resource?5error?6@
	DD	FLAT:??_C@_0BE@ILOLKABH@Sub?5resource?5error?6@
	DD	FLAT:??_C@_0BM@FJPIKKBA@Undefined?5namespace?5prefix?6@
	DD	FLAT:??_C@_0BA@ONCPONLN@Encoding?5error?6@
	DD	FLAT:??_C@_0BH@FAHNGONI@Char?5out?5of?5XML?5range?6@
	DD	FLAT:??_C@_0BP@HNOPDOE@Invalid?5or?5incomplete?5context?6@
	DD	FLAT:??_C@_0BD@MEAKLJLB@Stack?5usage?5error?6@
	DD	FLAT:??_C@_0BE@EKOADJON@Forbidden?5variable?6@
	DD	FLAT:??_C@_0BF@NKLLLIIE@?$DP?$DP?5Unknown?5error?5?$DP?$DP?6@
_DATA	ENDS
;	COMDAT ??_C@_0EA@JENGBCEE@Error?5allocating?5temporary?5stor@
CONST	SEGMENT
??_C@_0EA@JENGBCEE@Error?5allocating?5temporary?5stor@ DB 'Error allocati'
	DB	'ng temporary storage for tim sort: need %lu bytes', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEscapeUriFunction
_TEXT	SEGMENT
_escape_reserved$1$ = -12				; size = 4
_str$1$ = -8						; size = 4
_escape$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathEscapeUriFunction PROC				; COMDAT

; 15001: xmlXPathEscapeUriFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathEs

; 15002:     xmlXPathObjectPtr str;
; 15003:     int escape_reserved;
; 15004:     xmlBufPtr target;
; 15005:     xmlChar *cptr;
; 15006:     xmlChar escape[4];
; 15007: 
; 15008:     CHECK_ARITY(2);

	cmp	DWORD PTR _nargs$[ebp], 2
	je	SHORT $LN6@xmlXPathEs
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 15059: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathEs:

; 15002:     xmlXPathObjectPtr str;
; 15003:     int escape_reserved;
; 15004:     xmlBufPtr target;
; 15005:     xmlChar *cptr;
; 15006:     xmlChar escape[4];
; 15007: 
; 15008:     CHECK_ARITY(2);

	mov	eax, DWORD PTR [edi+44]
	add	eax, 2
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN7@xmlXPathEs
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 15059: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathEs:

; 15009: 
; 15010:     escape_reserved = xmlXPathPopBoolean(ctxt);

	push	edi
	call	_xmlXPathPopBoolean

; 15011: 
; 15012:     CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	add	esp, 4
	mov	DWORD PTR _escape_reserved$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathEs
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN8@xmlXPathEs
	push	1
	push	edi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN8@xmlXPathEs:

; 15013:     str = valuePop(ctxt);

	push	ebx
	push	edi
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _str$1$[ebp], eax

; 15014: 
; 15015:     target = xmlBufCreate();

	call	_xmlBufCreate
	mov	ebx, eax

; 15016: 
; 15017:     escape[0] = '%';

	mov	BYTE PTR _escape$[ebp], 37		; 00000025H

; 15018:     escape[3] = 0;

	mov	BYTE PTR _escape$[ebp+3], 0

; 15019: 
; 15020:     if (target) {

	test	ebx, ebx
	je	$LN3@xmlXPathEs

; 15021: 	for (cptr = str->stringval; *cptr; cptr++) {

	push	esi
	mov	esi, DWORD PTR _str$1$[ebp]
	mov	esi, DWORD PTR [esi+24]
	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	$LN33@xmlXPathEs
	mov	edi, DWORD PTR _escape_reserved$1$[ebp]
$LL4@xmlXPathEs:

; 15022: 	    if ((*cptr >= 'A' && *cptr <= 'Z') ||
; 15023: 		(*cptr >= 'a' && *cptr <= 'z') ||
; 15024: 		(*cptr >= '0' && *cptr <= '9') ||
; 15025: 		*cptr == '-' || *cptr == '_' || *cptr == '.' ||
; 15026: 		*cptr == '!' || *cptr == '~' || *cptr == '*' ||
; 15027: 		*cptr == '\''|| *cptr == '(' || *cptr == ')' ||
; 15028: 		(*cptr == '%' &&
; 15029: 		 ((cptr[1] >= 'A' && cptr[1] <= 'F') ||
; 15030: 		  (cptr[1] >= 'a' && cptr[1] <= 'f') ||
; 15031: 		  (cptr[1] >= '0' && cptr[1] <= '9')) &&
; 15032: 		 ((cptr[2] >= 'A' && cptr[2] <= 'F') ||
; 15033: 		  (cptr[2] >= 'a' && cptr[2] <= 'f') ||
; 15034: 		  (cptr[2] >= '0' && cptr[2] <= '9'))) ||

	cmp	cl, 65					; 00000041H
	jb	SHORT $LN13@xmlXPathEs
	cmp	cl, 90					; 0000005aH
	jbe	$LN23@xmlXPathEs
$LN13@xmlXPathEs:
	cmp	cl, 97					; 00000061H
	jb	SHORT $LN14@xmlXPathEs
	cmp	cl, 122					; 0000007aH
	jbe	$LN23@xmlXPathEs
$LN14@xmlXPathEs:
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN15@xmlXPathEs
	cmp	cl, 57					; 00000039H
	jbe	$LN23@xmlXPathEs
$LN15@xmlXPathEs:
	cmp	cl, 45					; 0000002dH
	je	$LN23@xmlXPathEs
	cmp	cl, 95					; 0000005fH
	je	$LN23@xmlXPathEs
	cmp	cl, 46					; 0000002eH
	je	$LN23@xmlXPathEs
	cmp	cl, 33					; 00000021H
	je	$LN23@xmlXPathEs
	cmp	cl, 126					; 0000007eH
	je	$LN23@xmlXPathEs
	cmp	cl, 42					; 0000002aH
	je	$LN23@xmlXPathEs
	cmp	cl, 39					; 00000027H
	je	$LN23@xmlXPathEs
	cmp	cl, 40					; 00000028H
	je	$LN23@xmlXPathEs
	cmp	cl, 41					; 00000029H
	je	$LN23@xmlXPathEs
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN22@xmlXPathEs
	mov	al, BYTE PTR [esi+1]
	cmp	al, 65					; 00000041H
	jb	SHORT $LN18@xmlXPathEs
	cmp	al, 70					; 00000046H
	jbe	SHORT $LN17@xmlXPathEs
$LN18@xmlXPathEs:
	cmp	al, 97					; 00000061H
	jb	SHORT $LN19@xmlXPathEs
	cmp	al, 102					; 00000066H
	jbe	SHORT $LN17@xmlXPathEs
$LN19@xmlXPathEs:
	sub	al, 48					; 00000030H
	cmp	al, 9
	ja	SHORT $LN22@xmlXPathEs
$LN17@xmlXPathEs:
	mov	al, BYTE PTR [esi+2]
	cmp	al, 65					; 00000041H
	jb	SHORT $LN20@xmlXPathEs
	cmp	al, 70					; 00000046H
	jbe	$LN23@xmlXPathEs
$LN20@xmlXPathEs:
	cmp	al, 97					; 00000061H
	jb	SHORT $LN21@xmlXPathEs
	cmp	al, 102					; 00000066H
	jbe	SHORT $LN23@xmlXPathEs
$LN21@xmlXPathEs:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN22@xmlXPathEs
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN23@xmlXPathEs
$LN22@xmlXPathEs:
	test	edi, edi
	jne	SHORT $LN10@xmlXPathEs
	cmp	cl, 59					; 0000003bH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 47					; 0000002fH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 63					; 0000003fH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 58					; 0000003aH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 64					; 00000040H
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 38					; 00000026H
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 61					; 0000003dH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 36					; 00000024H
	je	SHORT $LN23@xmlXPathEs
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN23@xmlXPathEs
$LN10@xmlXPathEs:

; 15041: 	    } else {
; 15042: 		if ((*cptr >> 4) < 10)

	shr	cl, 4
	cmp	cl, 10					; 0000000aH
	jae	SHORT $LN24@xmlXPathEs

; 15043: 		    escape[1] = '0' + (*cptr >> 4);

	add	cl, 48					; 00000030H
	jmp	SHORT $LN34@xmlXPathEs
$LN24@xmlXPathEs:

; 15044: 		else
; 15045: 		    escape[1] = 'A' - 10 + (*cptr >> 4);

	add	cl, 55					; 00000037H
$LN34@xmlXPathEs:

; 15046: 		if ((*cptr & 0xF) < 10)

	mov	BYTE PTR _escape$[ebp+1], cl
	mov	al, BYTE PTR [esi]
	and	al, 15					; 0000000fH
	cmp	al, 10					; 0000000aH
	jae	SHORT $LN26@xmlXPathEs

; 15047: 		    escape[2] = '0' + (*cptr & 0xF);

	add	al, 48					; 00000030H

; 15050: 
; 15051: 		xmlBufAdd(target, &escape[0], 3);

	mov	ecx, 3
	mov	BYTE PTR _escape$[ebp+2], al
	lea	eax, DWORD PTR _escape$[ebp]
	jmp	SHORT $LN2@xmlXPathEs
$LN26@xmlXPathEs:

; 15048: 		else
; 15049: 		    escape[2] = 'A' - 10 + (*cptr & 0xF);

	add	al, 55					; 00000037H

; 15050: 
; 15051: 		xmlBufAdd(target, &escape[0], 3);

	mov	ecx, 3
	mov	BYTE PTR _escape$[ebp+2], al
	lea	eax, DWORD PTR _escape$[ebp]
	jmp	SHORT $LN2@xmlXPathEs
$LN23@xmlXPathEs:

; 15035: 		(!escape_reserved &&
; 15036: 		 (*cptr == ';' || *cptr == '/' || *cptr == '?' ||
; 15037: 		  *cptr == ':' || *cptr == '@' || *cptr == '&' ||
; 15038: 		  *cptr == '=' || *cptr == '+' || *cptr == '$' ||
; 15039: 		  *cptr == ','))) {
; 15040: 		xmlBufAdd(target, cptr, 1);

	mov	eax, esi
	mov	ecx, 1
$LN2@xmlXPathEs:

; 15021: 	for (cptr = str->stringval; *cptr; cptr++) {

	push	ecx
	push	eax
	push	ebx
	call	_xmlBufAdd
	mov	cl, BYTE PTR [esi+1]
	inc	esi
	add	esp, 12					; 0000000cH
	test	cl, cl
	jne	$LL4@xmlXPathEs
	mov	edi, DWORD PTR _ctxt$[ebp]
$LN33@xmlXPathEs:
	pop	esi
$LN3@xmlXPathEs:

; 15052: 	    }
; 15053: 	}
; 15054:     }
; 15055:     valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	ebx
	call	_xmlBufContent
	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	edi
	call	_valuePush

; 15056: 	xmlBufContent(target)));
; 15057:     xmlBufFree(target);

	push	ebx
	call	_xmlBufFree

; 15058:     xmlXPathReleaseObject(ctxt->context, str);

	push	DWORD PTR _str$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 32					; 00000020H
	pop	ebx
$LN1@xmlXPathEs:
	pop	edi

; 15059: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathEscapeUriFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompiledEvalInternal
_TEXT	SEGMENT
_res$1$ = -8						; size = 4
_resObj$1$ = -4						; size = 4
_comp$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_resObjPtr$ = 16					; size = 4
_toBool$ = 20						; size = 4
_xmlXPathCompiledEvalInternal PROC			; COMDAT

; 14712: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlXPathCo

; 14713:     xmlXPathParserContextPtr pctxt;
; 14714:     xmlXPathObjectPtr resObj;
; 14715: #ifndef LIBXML_THREAD_ENABLED
; 14716:     static int reentance = 0;
; 14717: #endif
; 14718:     int res;
; 14719: 
; 14720:     CHECK_CTXT_NEG(ctxt)

	push	OFFSET ??_C@_0BG@PBKLCIKP@NULL?5context?5pointer?6@
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	push	14720					; 00003980H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	3
	push	1
	push	12					; 0000000cH
	push	esi
	push	esi
	push	esi
	push	esi
	push	esi
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
	or	eax, -1
	pop	esi

; 14769: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathCo:
	push	edi

; 14721: 
; 14722:     if (comp == NULL)

	mov	edi, DWORD PTR _comp$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlXPathCo

; 14723: 	return(-1);

	pop	edi
	or	eax, -1
	pop	esi

; 14769: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 499  :     xmlXPathNAN = NAN;

	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR _xmlXPathNAN, xmm0

; 500  :     xmlXPathPINF = INFINITY;

	movsd	xmm0, QWORD PTR __real@7ff0000000000000
	movsd	QWORD PTR _xmlXPathPINF, xmm0

; 501  :     xmlXPathNINF = -INFINITY;

	movsd	xmm0, QWORD PTR __real@fff0000000000000
	push	ebx

; 6273 :     ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));

	push	48					; 00000030H

; 501  :     xmlXPathNINF = -INFINITY;

	movsd	QWORD PTR _xmlXPathNINF, xmm0

; 6273 :     ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));

	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 6274 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN16@xmlXPathCo

; 6275 :         xmlXPathErrMemory(ctxt, "creating evaluation context\n");

	push	OFFSET ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
	push	esi
	call	_xmlXPathErrMemory
	add	esp, 8

; 6276 : 	return(NULL);

	jmp	SHORT $LN15@xmlXPathCo
$LN16@xmlXPathCo:

; 6277 :     }
; 6278 :     memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));

	push	48					; 00000030H
	push	0
	push	ebx
	call	_memset

; 6279 : 
; 6280 :     /* Allocate the value stack */
; 6281 :     ret->valueTab = (xmlXPathObjectPtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+28], eax

; 6282 :                      xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
; 6283 :     if (ret->valueTab == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlXPathCo

; 6284 : 	xmlFree(ret);

	push	ebx
	call	DWORD PTR _xmlFree

; 6285 : 	xmlXPathErrMemory(ctxt, "creating evaluation context\n");

	push	OFFSET ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
	push	esi
	call	_xmlXPathErrMemory
	add	esp, 12					; 0000000cH

; 6286 : 	return(NULL);

	xor	ebx, ebx
	jmp	SHORT $LN15@xmlXPathCo
$LN17@xmlXPathCo:

; 6287 :     }
; 6288 :     ret->valueNr = 0;

	mov	DWORD PTR [ebx+20], 0

; 6289 :     ret->valueMax = 10;

	mov	DWORD PTR [ebx+24], 10			; 0000000aH

; 6290 :     ret->value = NULL;

	mov	DWORD PTR [ebx+16], 0

; 6291 :     ret->valueFrame = 0;

	mov	DWORD PTR [ebx+44], 0

; 6292 : 
; 6293 :     ret->context = ctxt;

	mov	DWORD PTR [ebx+12], esi

; 6294 :     ret->comp = comp;

	mov	DWORD PTR [ebx+32], edi
$LN15@xmlXPathCo:

; 14724:     xmlXPathInit();
; 14725: 
; 14726: #ifndef LIBXML_THREAD_ENABLED
; 14727:     reentance++;
; 14728:     if (reentance > 1)
; 14729: 	xmlXPathDisableOptimizer = 1;
; 14730: #endif
; 14731: 
; 14732: #ifdef DEBUG_EVAL_COUNTS
; 14733:     comp->nb++;
; 14734:     if ((comp->string != NULL) && (comp->nb > 100)) {
; 14735: 	fprintf(stderr, "100 x %s\n", comp->string);
; 14736: 	comp->nb = 0;
; 14737:     }
; 14738: #endif
; 14739:     pctxt = xmlXPathCompParserContext(comp, ctxt);
; 14740:     res = xmlXPathRunEval(pctxt, toBool);

	mov	edi, DWORD PTR _toBool$[ebp]
	push	edi
	push	ebx
	call	_xmlXPathRunEval
	add	esp, 8
	mov	DWORD PTR _res$1$[ebp], eax

; 14741: 
; 14742:     if (pctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN4@xmlXPathCo

; 14743:         resObj = NULL;

	xor	eax, eax

; 14744:     } else {

	jmp	SHORT $LN9@xmlXPathCo
$LN4@xmlXPathCo:

; 14745:         resObj = valuePop(pctxt);

	push	ebx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _resObj$1$[ebp], eax

; 14746:         if (resObj == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlXPathCo

; 14747:             if (!toBool)

	test	edi, edi
	jne	SHORT $LN9@xmlXPathCo

; 14748:                 xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CP@KKKCDCLL@xmlXPathCompiledEval?3?5No?5result@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8

; 14749:                     "xmlXPathCompiledEval: No result on the stack.\n");
; 14750:         } else if (pctxt->valueNr > 0) {

	jmp	SHORT $LN20@xmlXPathCo
$LN6@xmlXPathCo:
	cmp	DWORD PTR [ebx+20], 0
	jle	SHORT $LN9@xmlXPathCo

; 14751:             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+20]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0DH@OEPEKFKA@xmlXPathCompiledEval?3?5?$CFd?5object@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
$LN20@xmlXPathCo:

; 14752:                 "xmlXPathCompiledEval: %d object(s) left on the stack.\n",
; 14753:                 pctxt->valueNr);
; 14754:         }
; 14755:     }
; 14756: 
; 14757:     if (resObjPtr)

	mov	eax, DWORD PTR _resObj$1$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
$LN9@xmlXPathCo:
	mov	ecx, DWORD PTR _resObjPtr$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@xmlXPathCo

; 14758:         *resObjPtr = resObj;

	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN11@xmlXPathCo
$LN10@xmlXPathCo:

; 14759:     else
; 14760:         xmlXPathReleaseObject(ctxt, resObj);

	push	eax
	push	esi
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN11@xmlXPathCo:

; 14761: 
; 14762:     pctxt->comp = NULL;
; 14763:     xmlXPathFreeParserContext(pctxt);

	push	ebx
	mov	DWORD PTR [ebx+32], 0
	call	_xmlXPathFreeParserContext

; 14764: #ifndef LIBXML_THREAD_ENABLED
; 14765:     reentance--;
; 14766: #endif
; 14767: 
; 14768:     return(res);

	mov	eax, DWORD PTR _res$1$[ebp]
	add	esp, 4
	pop	ebx
	pop	edi
	pop	esi

; 14769: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompiledEvalInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathOptimizeExpression
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_op$ = 12						; size = 4
_xmlXPathOptimizeExpression PROC			; COMDAT

; 14556: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _op$[ebp]
	push	edi
	mov	edi, DWORD PTR _comp$[ebp]
	npad	5
$LL13@xmlXPathOp:
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR [esi]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN8@xmlXPathOp

; 14557:     /*
; 14558:     * Try to rewrite "descendant-or-self::node()/foo" to an optimized
; 14559:     * internal representation.
; 14560:     */
; 14561: 
; 14562:     if ((op->op == XPATH_OP_COLLECT /* 11 */) &&
; 14563:         (op->ch1 != -1) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN18@xmlXPathOp
	cmp	DWORD PTR [esi+8], -1
	jne	SHORT $LN18@xmlXPathOp

; 14564:         (op->ch2 == -1 /* no predicate */))
; 14565:     {
; 14566:         xmlXPathStepOpPtr prevop = &comp->steps[op->ch1];

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]

; 14567: 
; 14568:         if ((prevop->op == XPATH_OP_COLLECT /* 11 */) &&
; 14569:             ((xmlXPathAxisVal) prevop->value ==
; 14570:                 AXIS_DESCENDANT_OR_SELF) &&
; 14571:             (prevop->ch2 == -1) &&
; 14572:             ((xmlXPathTestVal) prevop->value2 == NODE_TEST_TYPE) &&

	cmp	DWORD PTR [eax+ecx*8], 10		; 0000000aH
	lea	ecx, DWORD PTR [eax+ecx*8]
	jne	SHORT $LN18@xmlXPathOp
	cmp	DWORD PTR [ecx+12], 6
	jne	SHORT $LN18@xmlXPathOp
	cmp	DWORD PTR [ecx+8], -1
	jne	SHORT $LN18@xmlXPathOp
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN18@xmlXPathOp
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN18@xmlXPathOp

; 14573:             ((xmlXPathTypeVal) prevop->value3 == NODE_TYPE_NODE))
; 14574:         {
; 14575:             /*
; 14576:             * This is a "descendant-or-self::node()" without predicates.
; 14577:             * Try to eliminate it.
; 14578:             */
; 14579: 
; 14580:             switch ((xmlXPathAxisVal) op->value) {

	mov	eax, DWORD PTR [esi+12]
	add	eax, -4					; fffffffcH
	cmp	eax, 9
	ja	SHORT $LN18@xmlXPathOp
	movzx	eax, BYTE PTR $LN19@xmlXPathOp[eax]
	jmp	DWORD PTR $LN21@xmlXPathOp[eax*4]
$LN6@xmlXPathOp:

; 14581:                 case AXIS_CHILD:
; 14582:                 case AXIS_DESCENDANT:
; 14583:                     /*
; 14584:                     * Convert "descendant-or-self::node()/child::" or
; 14585:                     * "descendant-or-self::node()/descendant::" to
; 14586:                     * "descendant::"
; 14587:                     */
; 14588:                     op->ch1   = prevop->ch1;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 14589:                     op->value = AXIS_DESCENDANT;

	mov	DWORD PTR [esi+12], 5

; 14590:                     break;

	jmp	SHORT $LN18@xmlXPathOp
$LN7@xmlXPathOp:

; 14591:                 case AXIS_SELF:
; 14592:                 case AXIS_DESCENDANT_OR_SELF:
; 14593:                     /*
; 14594:                     * Convert "descendant-or-self::node()/self::" or
; 14595:                     * "descendant-or-self::node()/descendant-or-self::" to
; 14596:                     * to "descendant-or-self::"
; 14597:                     */
; 14598:                     op->ch1   = prevop->ch1;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 14599:                     op->value = AXIS_DESCENDANT_OR_SELF;

	mov	DWORD PTR [esi+12], 6

; 14600:                     break;
; 14601:                 default:
; 14602:                     break;
; 14603:             }
; 14604: 	}
; 14605:     }
; 14606: 
; 14607:     /* OP_VALUE has invalid ch1. */
; 14608:     if (op->op == XPATH_OP_VALUE)

	jmp	SHORT $LN18@xmlXPathOp
$LN8@xmlXPathOp:
	cmp	eax, 11					; 0000000bH
	je	SHORT $LN15@xmlXPathOp
$LN18@xmlXPathOp:

; 14609:         return;
; 14610: 
; 14611:     /* Recurse */
; 14612:     if (op->ch1 != -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN10@xmlXPathOp

; 14613:         xmlXPathOptimizeExpression(comp, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	edi
	call	_xmlXPathOptimizeExpression
	add	esp, 8
$LN10@xmlXPathOp:

; 14614:     if (op->ch2 != -1)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, -1
	je	SHORT $LN15@xmlXPathOp

; 14615: 	xmlXPathOptimizeExpression(comp, &comp->steps[op->ch2]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]
	lea	esi, DWORD PTR [eax+ecx*8]
	jmp	$LL13@xmlXPathOp
$LN15@xmlXPathOp:
	pop	edi

; 14616: }

	pop	esi
	pop	ebp
	ret	0
	npad	1
$LN21@xmlXPathOp:
	DD	$LN6@xmlXPathOp
	DD	$LN7@xmlXPathOp
	DD	$LN18@xmlXPathOp
$LN19@xmlXPathOp:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_xmlXPathOptimizeExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathTryStreamCompile
_TEXT	SEGMENT
_dict$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlXPathTryStreamCompile PROC				; COMDAT

; 14483: xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	xor	ebx, ebx
	push	91					; 0000005bH
	push	esi
	mov	DWORD PTR _dict$1$[ebp], ebx
	xor	edi, edi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	$LN5@xmlXPathTr

; 14484:     /*
; 14485:      * Optimization: use streaming patterns when the XPath expression can
; 14486:      * be compiled to a stream lookup
; 14487:      */
; 14488:     xmlPatternPtr stream;
; 14489:     xmlXPathCompExprPtr comp;
; 14490:     xmlDictPtr dict = NULL;
; 14491:     const xmlChar **namespaces = NULL;
; 14492:     xmlNsPtr ns;
; 14493:     int i, j;
; 14494: 
; 14495:     if ((!xmlStrchr(str, '[')) && (!xmlStrchr(str, '(')) &&

	push	40					; 00000028H
	push	esi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	$LN5@xmlXPathTr
	push	64					; 00000040H
	push	esi
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	$LN5@xmlXPathTr

; 14496:         (!xmlStrchr(str, '@'))) {
; 14497: 	const xmlChar *tmp;
; 14498: 
; 14499: 	/*
; 14500: 	 * We don't try to handle expressions using the verbose axis
; 14501: 	 * specifiers ("::"), just the simplied form at this point.
; 14502: 	 * Additionally, if there is no list of namespaces available and
; 14503: 	 *  there's a ":" in the expression, indicating a prefixed QName,
; 14504: 	 *  then we won't try to compile either. xmlPatterncompile() needs
; 14505: 	 *  to have a list of namespaces at compilation time in order to
; 14506: 	 *  compile prefixed name tests.
; 14507: 	 */
; 14508: 	tmp = xmlStrchr(str, ':');

	push	58					; 0000003aH
	push	esi
	call	_xmlStrchr

; 14509: 	if ((tmp != NULL) &&

	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlXPathTr
	test	esi, esi
	je	$LN5@xmlXPathTr
	cmp	DWORD PTR [esi+60], ebx
	je	$LN5@xmlXPathTr
	cmp	BYTE PTR [eax+1], 58			; 0000003aH
	je	$LN5@xmlXPathTr
$LN21@xmlXPathTr:

; 14510: 	    ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))
; 14511: 	    return(NULL);
; 14512: 
; 14513: 	if (ctxt != NULL) {

	test	esi, esi
	je	SHORT $LN9@xmlXPathTr

; 14514: 	    dict = ctxt->dict;
; 14515: 	    if (ctxt->nsNr > 0) {

	mov	eax, DWORD PTR [esi+60]
	mov	ebx, DWORD PTR [esi+192]
	mov	DWORD PTR _dict$1$[ebp], ebx
	test	eax, eax
	jle	SHORT $LN9@xmlXPathTr

; 14516: 		namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));

	lea	eax, DWORD PTR [eax*8+8]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 14517: 		if (namespaces == NULL) {

	test	edi, edi
	jne	SHORT $LN10@xmlXPathTr

; 14518: 		    xmlXPathErrMemory(ctxt, "allocating namespaces array\n");

	push	OFFSET ??_C@_0BN@BJKHBGFI@allocating?5namespaces?5array?6@
	push	esi
	call	_xmlXPathErrMemory
	add	esp, 8

; 14549:     }
; 14550:     return(NULL);
; 14551: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathTr:

; 14519: 		    return(NULL);
; 14520: 		}
; 14521: 		for (i = 0, j = 0; (j < ctxt->nsNr); j++) {

	xor	edx, edx
	cmp	DWORD PTR [esi+60], edx
	jle	SHORT $LN3@xmlXPathTr
	xor	ebx, ebx
	npad	4
$LL4@xmlXPathTr:

; 14522: 		    ns = ctxt->namespaces[j];

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [eax+ebx*4]
	inc	ebx

; 14523: 		    namespaces[i++] = ns->href;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edi+edx*4], eax

; 14524: 		    namespaces[i++] = ns->prefix;

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edi+edx*4+4], eax
	add	edx, 2
	cmp	ebx, DWORD PTR [esi+60]
	jl	SHORT $LL4@xmlXPathTr
	mov	ebx, DWORD PTR _dict$1$[ebp]
$LN3@xmlXPathTr:

; 14525: 		}
; 14526: 		namespaces[i++] = NULL;

	mov	DWORD PTR [edi+edx*4], 0

; 14527: 		namespaces[i] = NULL;

	mov	DWORD PTR [edi+edx*4+4], 0
$LN9@xmlXPathTr:

; 14528: 	    }
; 14529: 	}
; 14530: 
; 14531: 	stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH,

	push	edi
	push	1
	push	ebx
	push	DWORD PTR _str$[ebp]
	call	_xmlPatterncompile
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 14532: 			&namespaces[0]);
; 14533: 	if (namespaces != NULL) {

	test	edi, edi
	je	SHORT $LN11@xmlXPathTr

; 14534: 	    xmlFree((xmlChar **)namespaces);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlXPathTr:

; 14535: 	}
; 14536: 	if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {

	test	ebx, ebx
	je	SHORT $LN12@xmlXPathTr
	push	ebx
	call	_xmlPatternStreamable
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN12@xmlXPathTr

; 14537: 	    comp = xmlXPathNewCompExpr();

	call	_xmlXPathNewCompExpr
	mov	edi, eax

; 14538: 	    if (comp == NULL) {

	test	edi, edi
	jne	SHORT $LN13@xmlXPathTr

; 14539: 		xmlXPathErrMemory(ctxt, "allocating streamable expression\n");

	push	OFFSET ??_C@_0CC@FJFLGALO@allocating?5streamable?5expressio@
	push	esi
	call	_xmlXPathErrMemory
	add	esp, 8

; 14549:     }
; 14550:     return(NULL);
; 14551: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathTr:

; 14540: 		return(NULL);
; 14541: 	    }
; 14542: 	    comp->stream = stream;
; 14543: 	    comp->dict = dict;

	mov	eax, DWORD PTR _dict$1$[ebp]
	mov	DWORD PTR [edi+24], ebx
	mov	DWORD PTR [edi+20], eax

; 14544: 	    if (comp->dict)

	test	eax, eax
	je	SHORT $LN14@xmlXPathTr

; 14545: 		xmlDictReference(comp->dict);

	push	eax
	call	_xmlDictReference
	add	esp, 4
$LN14@xmlXPathTr:

; 14546: 	    return(comp);

	mov	eax, edi
	pop	edi

; 14549:     }
; 14550:     return(NULL);
; 14551: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathTr:

; 14547: 	}
; 14548: 	xmlFreePattern(stream);

	push	ebx
	call	_xmlFreePattern
	add	esp, 4
$LN5@xmlXPathTr:

; 14549:     }
; 14550:     return(NULL);
; 14551: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathTryStreamCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRunEval
_TEXT	SEGMENT
_resObj$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_toBool$ = 12						; size = 4
_xmlXPathRunEval PROC					; COMDAT

; 14309: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlXPathRu

; 14310:     xmlXPathCompExprPtr comp;
; 14311: 
; 14312:     if ((ctxt == NULL) || (ctxt->comp == NULL))

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	$LN3@xmlXPathRu

; 14313: 	return(-1);
; 14314: 
; 14315:     if (ctxt->valueTab == NULL) {

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN4@xmlXPathRu

; 14316: 	/* Allocate the value stack */
; 14317: 	ctxt->valueTab = (xmlXPathObjectPtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 14318: 			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
; 14319: 	if (ctxt->valueTab == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlXPathRu

; 673  : 	xmlXPathErrMemory(ctxt->context, extra);

	push	OFFSET ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 15			; 0000000fH
	call	_xmlXPathErrMemory

; 14320: 	    xmlXPathPErrMemory(ctxt, "creating evaluation context\n");
; 14321: 	    xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH
$LN5@xmlXPathRu:

; 14322: 	}
; 14323: 	ctxt->valueNr = 0;
; 14324: 	ctxt->valueMax = 10;
; 14325: 	ctxt->value = NULL;
; 14326:         ctxt->valueFrame = 0;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 10			; 0000000aH
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+44], 0
$LN4@xmlXPathRu:

; 14327:     }
; 14328: #ifdef XPATH_STREAMING
; 14329:     if (ctxt->comp->stream) {

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN11@xmlXPathRu

; 14330: 	int res;
; 14331: 
; 14332: 	if (toBool) {

	cmp	DWORD PTR _toBool$[ebp], 0
	mov	ecx, DWORD PTR [esi+12]
	je	SHORT $LN7@xmlXPathRu

; 14333: 	    /*
; 14334: 	    * Evaluation to boolean result.
; 14335: 	    */
; 14336: 	    res = xmlXPathRunStreamEval(ctxt->context,

	push	1
	push	0
	push	eax
	push	ecx
	call	_xmlXPathRunStreamEval
	add	esp, 16					; 00000010H

; 14337: 		ctxt->comp->stream, NULL, 1);
; 14338: 	    if (res != -1)

	cmp	eax, -1
	je	SHORT $LN11@xmlXPathRu
	pop	esi

; 14375: }

	pop	ebp
	ret	0
$LN7@xmlXPathRu:

; 14339: 		return(res);
; 14340: 	} else {
; 14341: 	    xmlXPathObjectPtr resObj = NULL;
; 14342: 
; 14343: 	    /*
; 14344: 	    * Evaluation to a sequence.
; 14345: 	    */
; 14346: 	    res = xmlXPathRunStreamEval(ctxt->context,

	push	0
	lea	edx, DWORD PTR _resObj$1[ebp]
	mov	DWORD PTR _resObj$1[ebp], 0
	push	edx
	push	eax
	push	ecx
	call	_xmlXPathRunStreamEval
	add	esp, 16					; 00000010H

; 14347: 		ctxt->comp->stream, &resObj, 0);
; 14348: 
; 14349: 	    if ((res != -1) && (resObj != NULL)) {

	cmp	eax, -1
	mov	eax, DWORD PTR _resObj$1[ebp]
	je	SHORT $LN10@xmlXPathRu
	test	eax, eax
	je	SHORT $LN11@xmlXPathRu

; 14350: 		valuePush(ctxt, resObj);

	push	eax
	push	esi
	call	_valuePush
	add	esp, 8

; 14351: 		return(0);

	xor	eax, eax
	pop	esi

; 14375: }

	pop	ebp
	ret	0
$LN10@xmlXPathRu:

; 14352: 	    }
; 14353: 	    if (resObj != NULL)

	test	eax, eax
	je	SHORT $LN11@xmlXPathRu

; 14354: 		xmlXPathReleaseObject(ctxt->context, resObj);

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN11@xmlXPathRu:

; 14355: 	}
; 14356: 	/*
; 14357: 	* QUESTION TODO: This falls back to normal XPath evaluation
; 14358: 	* if res == -1. Is this intended?
; 14359: 	*/
; 14360:     }
; 14361: #endif
; 14362:     comp = ctxt->comp;

	mov	edx, DWORD PTR [esi+32]

; 14363:     if (comp->last < 0) {

	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	jns	SHORT $LN12@xmlXPathRu

; 14364: 	xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CJ@GKOHPKDK@xmlXPathRunEval?3?5last?5is?5less?5t@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN3@xmlXPathRu:

; 14375: }

	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlXPathRu:

; 14365: 	    "xmlXPathRunEval: last is less than zero\n");
; 14366: 	return(-1);
; 14367:     }
; 14368:     if (toBool)

	cmp	DWORD PTR _toBool$[ebp], 0
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	je	SHORT $LN13@xmlXPathRu

; 14369: 	return(xmlXPathCompOpEvalToBoolean(ctxt,

	push	0
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalToBoolean
	add	esp, 12					; 0000000cH
	pop	esi

; 14375: }

	pop	ebp
	ret	0
$LN13@xmlXPathRu:

; 14370: 	    &comp->steps[comp->last], 0));
; 14371:     else
; 14372: 	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);

	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8

; 14373: 
; 14374:     return(0);

	xor	eax, eax
	pop	esi

; 14375: }

	pop	ebp
	ret	0
_xmlXPathRunEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRunStreamEval
_TEXT	SEGMENT
_nb_nodes$1$ = -20					; size = 4
_min_depth$1$ = -16					; size = 4
_patstream$1$ = -16					; size = 4
_max_depth$2$ = -12					; size = 4
_limit$1$ = -8						; size = 4
_eval_all_nodes$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_comp$ = 12						; size = 4
_resultSeq$ = 16					; size = 4
_toBool$ = 20						; size = 4
_xmlXPathRunStreamEval PROC				; COMDAT

; 14076: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _limit$1$[ebp], eax
	mov	DWORD PTR _nb_nodes$1$[ebp], eax
	cmp	DWORD PTR _ctxt$[ebp], eax
	je	$LN17@xmlXPathRu

; 14077:     int max_depth, min_depth;
; 14078:     int from_root;
; 14079:     int ret, depth;
; 14080:     int eval_all_nodes;
; 14081:     xmlNodePtr cur = NULL, limit = NULL;
; 14082:     xmlStreamCtxtPtr patstream = NULL;
; 14083: 
; 14084:     int nb_nodes = 0;
; 14085: 
; 14086:     if ((ctxt == NULL) || (comp == NULL))

	mov	edi, DWORD PTR _comp$[ebp]
	test	edi, edi
	je	$LN17@xmlXPathRu

; 14087:         return(-1);
; 14088:     max_depth = xmlPatternMaxDepth(comp);

	push	edi
	call	_xmlPatternMaxDepth
	add	esp, 4

; 14089:     if (max_depth == -1)

	cmp	eax, -1
	je	$LN17@xmlXPathRu

; 14090:         return(-1);
; 14091:     if (max_depth == -2)

	cmp	eax, -2					; fffffffeH
	mov	ecx, 10000				; 00002710H

; 14092:         max_depth = 10000;
; 14093:     min_depth = xmlPatternMinDepth(comp);

	push	edi
	cmove	eax, ecx
	mov	DWORD PTR _max_depth$2$[ebp], eax
	call	_xmlPatternMinDepth
	add	esp, 4
	mov	DWORD PTR _min_depth$1$[ebp], eax

; 14094:     if (min_depth == -1)

	cmp	eax, -1
	je	$LN17@xmlXPathRu

; 14095:         return(-1);
; 14096:     from_root = xmlPatternFromRoot(comp);

	push	edi
	call	_xmlPatternFromRoot
	mov	ebx, eax
	add	esp, 4

; 14097:     if (from_root < 0)

	test	ebx, ebx
	js	$LN17@xmlXPathRu

; 14098:         return(-1);
; 14099: #if 0
; 14100:     printf("stream eval: depth %d from root %d\n", max_depth, from_root);
; 14101: #endif
; 14102: 
; 14103:     if (! toBool) {

	mov	eax, DWORD PTR _toBool$[ebp]
	test	eax, eax
	jne	SHORT $LN133@xmlXPathRu

; 14104: 	if (resultSeq == NULL)

	cmp	DWORD PTR _resultSeq$[ebp], esi
	je	$LN17@xmlXPathRu

; 14105: 	    return(-1);
; 14106: 	*resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);

	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathCacheNewNodeSet
	mov	ecx, DWORD PTR _resultSeq$[ebp]
	add	esp, 8
	mov	DWORD PTR [ecx], eax

; 14107: 	if (*resultSeq == NULL)

	test	eax, eax
	je	$LN17@xmlXPathRu

; 14098:         return(-1);
; 14099: #if 0
; 14100:     printf("stream eval: depth %d from root %d\n", max_depth, from_root);
; 14101: #endif
; 14102: 
; 14103:     if (! toBool) {

	mov	eax, DWORD PTR _toBool$[ebp]
	jmp	SHORT $LN97@xmlXPathRu
$LN133@xmlXPathRu:
	mov	ecx, DWORD PTR _resultSeq$[ebp]
$LN97@xmlXPathRu:

; 14108: 	    return(-1);
; 14109:     }
; 14110: 
; 14111:     /*
; 14112:      * handle the special cases of "/" amd "." being matched
; 14113:      */
; 14114:     if (min_depth == 0) {

	cmp	DWORD PTR _min_depth$1$[ebp], esi
	jne	SHORT $LN27@xmlXPathRu

; 14115: 	if (from_root) {

	test	ebx, ebx
	je	SHORT $LN26@xmlXPathRu

; 14116: 	    /* Select "/" */
; 14117: 	    if (toBool)

	test	eax, eax
	jne	$LN72@xmlXPathRu

; 14118: 		return(1);
; 14119: 	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax]

; 14120: 		                     (xmlNodePtr) ctxt->doc);
; 14121: 	} else {

	jmp	SHORT $LN137@xmlXPathRu
$LN26@xmlXPathRu:

; 14122: 	    /* Select "self::node()" */
; 14123: 	    if (toBool)

	test	eax, eax
	jne	$LN72@xmlXPathRu

; 14124: 		return(1);
; 14125: 	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, ctxt->node);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR [eax+4]
$LN137@xmlXPathRu:

; 14126: 	}
; 14127:     }
; 14128:     if (max_depth == 0) {

	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [eax+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
$LN27@xmlXPathRu:
	cmp	DWORD PTR _max_depth$2$[ebp], esi
	je	$LN71@xmlXPathRu

; 14129: 	return(0);
; 14130:     }
; 14131: 
; 14132:     if (from_root) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	SHORT $LN31@xmlXPathRu

; 14133:         cur = (xmlNodePtr)ctxt->doc;

	mov	esi, DWORD PTR [eax]
	jmp	SHORT $LN33@xmlXPathRu
$LN31@xmlXPathRu:

; 14134:     } else if (ctxt->node != NULL) {

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	$LN71@xmlXPathRu

; 14135:         switch (ctxt->node->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN35@xmlXPathRu
	movzx	eax, BYTE PTR $LN119@xmlXPathRu[eax]
	jmp	DWORD PTR $LN139@xmlXPathRu[eax*4]
$LN34@xmlXPathRu:

; 14136:             case XML_ELEMENT_NODE:
; 14137:             case XML_DOCUMENT_NODE:
; 14138:             case XML_DOCUMENT_FRAG_NODE:
; 14139:             case XML_HTML_DOCUMENT_NODE:
; 14140: #ifdef LIBXML_DOCB_ENABLED
; 14141:             case XML_DOCB_DOCUMENT_NODE:
; 14142: #endif
; 14143: 	        cur = ctxt->node;

	mov	esi, ecx
$LN35@xmlXPathRu:

; 14144: 		break;
; 14145:             case XML_ATTRIBUTE_NODE:
; 14146:             case XML_TEXT_NODE:
; 14147:             case XML_CDATA_SECTION_NODE:
; 14148:             case XML_ENTITY_REF_NODE:
; 14149:             case XML_ENTITY_NODE:
; 14150:             case XML_PI_NODE:
; 14151:             case XML_COMMENT_NODE:
; 14152:             case XML_NOTATION_NODE:
; 14153:             case XML_DTD_NODE:
; 14154:             case XML_DOCUMENT_TYPE_NODE:
; 14155:             case XML_ELEMENT_DECL:
; 14156:             case XML_ATTRIBUTE_DECL:
; 14157:             case XML_ENTITY_DECL:
; 14158:             case XML_NAMESPACE_DECL:
; 14159:             case XML_XINCLUDE_START:
; 14160:             case XML_XINCLUDE_END:
; 14161: 		break;
; 14162: 	}
; 14163: 	limit = cur;

	mov	DWORD PTR _limit$1$[ebp], esi
$LN33@xmlXPathRu:

; 14164:     }
; 14165:     if (cur == NULL) {

	test	esi, esi
	je	$LN71@xmlXPathRu

; 14166:         return(0);
; 14167:     }
; 14168: 
; 14169:     patstream = xmlPatternGetStreamCtxt(comp);

	push	edi
	call	_xmlPatternGetStreamCtxt
	add	esp, 4
	mov	DWORD PTR _patstream$1$[ebp], eax

; 14170:     if (patstream == NULL) {

	test	eax, eax
	je	$LN71@xmlXPathRu

; 14171: 	/*
; 14172: 	* QUESTION TODO: Is this an error?
; 14173: 	*/
; 14174: 	return(0);
; 14175:     }
; 14176: 
; 14177:     eval_all_nodes = xmlStreamWantsAnyNode(patstream);

	push	eax
	call	_xmlStreamWantsAnyNode
	add	esp, 4
	mov	edx, eax

; 14178: 
; 14179:     if (from_root) {

	test	ebx, ebx
	mov	DWORD PTR _eval_all_nodes$1$[ebp], edx
	mov	ebx, DWORD PTR _patstream$1$[ebp]
	je	SHORT $LN41@xmlXPathRu

; 14180: 	ret = xmlStreamPush(patstream, NULL, NULL);

	push	0
	push	0
	push	ebx
	call	_xmlStreamPush
	add	esp, 12					; 0000000cH

; 14181: 	if (ret < 0) {

	test	eax, eax
	js	SHORT $LN132@xmlXPathRu

; 14182: 	} else if (ret == 1) {

	cmp	eax, 1
	jne	SHORT $LN132@xmlXPathRu

; 14183: 	    if (toBool)

	cmp	DWORD PTR _toBool$[ebp], 0
	jne	$return_1$141

; 14184: 		goto return_1;
; 14185: 	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur);

	mov	eax, DWORD PTR _resultSeq$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
$LN132@xmlXPathRu:

; 14186: 	}
; 14187:     }
; 14188:     depth = 0;

	mov	edx, DWORD PTR _eval_all_nodes$1$[ebp]
$LN41@xmlXPathRu:
	xor	edi, edi
	npad	1
$scan_children$142:

; 14224: 			    (cur->type != XML_DTD_NODE))
; 14225: 			    goto next_node;
; 14226: 		    }
; 14227: 		}
; 14228: 	    default:
; 14229: 		break;
; 14230: 	}
; 14231: 
; 14232: scan_children:
; 14233: 	if (cur->type == XML_NAMESPACE_DECL) break;

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	$done$143

; 14234: 	if ((cur->children != NULL) && (depth < max_depth)) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN60@xmlXPathRu
	cmp	edi, DWORD PTR _max_depth$2$[ebp]
	jge	SHORT $LN60@xmlXPathRu

; 14235: 	    /*
; 14236: 	     * Do not descend on entities declarations
; 14237: 	     */
; 14238: 	    if (cur->children->type != XML_ENTITY_DECL) {

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN60@xmlXPathRu

; 14239: 		cur = cur->children;
; 14240: 		depth++;

	inc	edi
	mov	esi, eax

; 14241: 		/*
; 14242: 		 * Skip DTDs
; 14243: 		 */
; 14244: 		if (cur->type != XML_DTD_NODE)

	cmp	ecx, 14					; 0000000eH
	jne	SHORT $LN4@xmlXPathRu
$LN60@xmlXPathRu:

; 14245: 		    continue;
; 14246: 	    }
; 14247: 	}
; 14248: 
; 14249: 	if (cur == limit)

	mov	ecx, DWORD PTR _limit$1$[ebp]
	cmp	esi, ecx
	je	$done$143

; 14250: 	    break;
; 14251: 
; 14252: 	while (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL15@xmlXPathRu
$LL11@xmlXPathRu:

; 14253: 	    cur = cur->next;

	mov	esi, eax

; 14254: 	    if ((cur->type != XML_ENTITY_DECL) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 17					; 00000011H
	je	SHORT $LN98@xmlXPathRu
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LL6@xmlXPathRu
$LN98@xmlXPathRu:

; 14250: 	    break;
; 14251: 
; 14252: 	while (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LL11@xmlXPathRu
	npad	2
$LL15@xmlXPathRu:

; 14255: 		(cur->type != XML_DTD_NODE))
; 14256: 		goto next_node;
; 14257: 	}
; 14258: 
; 14259: 	do {
; 14260: 	    cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 14261: 	    depth--;

	dec	edi

; 14262: 	    if ((cur == NULL) || (cur == limit))

	test	esi, esi
	je	$done$143
	cmp	esi, ecx
	je	$done$143

; 14263: 	        goto done;
; 14264: 	    if (cur->type == XML_ELEMENT_NODE) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN68@xmlXPathRu

; 14265: 		ret = xmlStreamPop(patstream);
; 14266: 	    } else if ((eval_all_nodes) &&

	test	edx, edx
	je	SHORT $LN67@xmlXPathRu
	cmp	eax, 3
	je	SHORT $LN68@xmlXPathRu
	cmp	eax, 4
	je	SHORT $LN68@xmlXPathRu
	cmp	eax, 8
	je	SHORT $LN68@xmlXPathRu
	cmp	eax, 7
	jne	SHORT $LN67@xmlXPathRu
$LN68@xmlXPathRu:

; 14267: 		((cur->type == XML_TEXT_NODE) ||
; 14268: 		 (cur->type == XML_CDATA_SECTION_NODE) ||
; 14269: 		 (cur->type == XML_COMMENT_NODE) ||
; 14270: 		 (cur->type == XML_PI_NODE)))
; 14271: 	    {
; 14272: 		ret = xmlStreamPop(patstream);

	push	ebx
	call	_xmlStreamPop
	mov	ecx, DWORD PTR _limit$1$[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _eval_all_nodes$1$[ebp]
$LN67@xmlXPathRu:

; 14273: 	    }
; 14274: 	    if (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL15@xmlXPathRu

; 14275: 		cur = cur->next;

	mov	esi, eax
$LN4@xmlXPathRu:

; 14276: 		break;
; 14277: 	    }
; 14278: 	} while (cur != NULL);
; 14279: 
; 14280:     } while ((cur != NULL) && (depth >= 0));

	test	esi, esi
	je	$done$143
	test	edi, edi
	js	$done$143
	npad	4
$LL6@xmlXPathRu:
$next_node$144:

; 14189:     goto scan_children;
; 14190: next_node:
; 14191:     do {
; 14192:         nb_nodes++;
; 14193: 
; 14194: 	switch (cur->type) {

	mov	ecx, DWORD PTR [esi+4]
	inc	DWORD PTR _nb_nodes$1$[ebp]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 7
	ja	$scan_children$142
	movzx	eax, BYTE PTR $LN120@xmlXPathRu[eax]
	jmp	DWORD PTR $LN140@xmlXPathRu[eax*4]
$LN43@xmlXPathRu:

; 14195: 	    case XML_ELEMENT_NODE:
; 14196: 	    case XML_TEXT_NODE:
; 14197: 	    case XML_CDATA_SECTION_NODE:
; 14198: 	    case XML_COMMENT_NODE:
; 14199: 	    case XML_PI_NODE:
; 14200: 		if (cur->type == XML_ELEMENT_NODE) {

	cmp	ecx, 1
	jne	SHORT $LN44@xmlXPathRu

; 14201: 		    ret = xmlStreamPush(patstream, cur->name,

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN74@xmlXPathRu
	mov	eax, DWORD PTR [eax+8]
	push	eax
	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlStreamPush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN47@xmlXPathRu
$LN74@xmlXPathRu:
	xor	eax, eax
	push	eax
	push	DWORD PTR [esi+8]
	push	ebx
	call	_xmlStreamPush
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN47@xmlXPathRu
$LN44@xmlXPathRu:

; 14202: 				(cur->ns ? cur->ns->href : NULL));
; 14203: 		} else if (eval_all_nodes)

	test	edx, edx
	je	$scan_children$142

; 14204: 		    ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);

	push	ecx
	push	0
	push	0
	push	ebx
	call	_xmlStreamPushNode
	add	esp, 16					; 00000010H
$LN47@xmlXPathRu:

; 14205: 		else
; 14206: 		    break;
; 14207: 
; 14208: 		if (ret < 0) {

	test	eax, eax
	js	SHORT $LN52@xmlXPathRu

; 14209: 		    /* NOP. */
; 14210: 		} else if (ret == 1) {

	cmp	eax, 1
	jne	SHORT $LN52@xmlXPathRu

; 14211: 		    if (toBool)

	cmp	DWORD PTR _toBool$[ebp], 0
	jne	SHORT $return_1$141

; 14212: 			goto return_1;
; 14213: 		    if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur)
; 14214: 		        < 0) {

	mov	eax, DWORD PTR _resultSeq$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN52@xmlXPathRu

; 14215: 			ctxt->lastError.domain = XML_FROM_XPATH;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+136], 12			; 0000000cH

; 14216: 			ctxt->lastError.code = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [eax+140], 2
$LN52@xmlXPathRu:

; 14217: 		    }
; 14218: 		}
; 14219: 		if ((cur->children == NULL) || (depth >= max_depth)) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN54@xmlXPathRu
	mov	edx, DWORD PTR _eval_all_nodes$1$[ebp]
	cmp	edi, DWORD PTR _max_depth$2$[ebp]
	jl	$scan_children$142
$LN54@xmlXPathRu:

; 14220: 		    ret = xmlStreamPop(patstream);

	push	ebx
	call	_xmlStreamPop
	add	esp, 4
	npad	5
$LL9@xmlXPathRu:

; 14221: 		    while (cur->next != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN118@xmlXPathRu

; 14222: 			cur = cur->next;

	mov	esi, eax

; 14223: 			if ((cur->type != XML_ENTITY_DECL) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 17					; 00000011H
	je	SHORT $LL9@xmlXPathRu
	cmp	eax, 14					; 0000000eH
	je	SHORT $LL9@xmlXPathRu
	mov	edx, DWORD PTR _eval_all_nodes$1$[ebp]
	jmp	$LL6@xmlXPathRu
$LN118@xmlXPathRu:

; 14216: 			ctxt->lastError.code = XML_ERR_NO_MEMORY;

	mov	edx, DWORD PTR _eval_all_nodes$1$[ebp]
	jmp	$scan_children$142
$return_1$141:

; 14291:     return(0);
; 14292: 
; 14293: return_1:
; 14294:     if (patstream)

	test	ebx, ebx
	je	SHORT $LN72@xmlXPathRu

; 14295: 	xmlFreeStreamCtxt(patstream);

	push	ebx
	call	_xmlFreeStreamCtxt
	add	esp, 4
$LN72@xmlXPathRu:

; 14296:     return(1);
; 14297: }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$done$143:

; 14281: 
; 14282: done:
; 14283: 
; 14284: #if 0
; 14285:     printf("stream eval: checked %d nodes selected %d\n",
; 14286:            nb_nodes, retObj->nodesetval->nodeNr);
; 14287: #endif
; 14288: 
; 14289:     if (patstream)

	test	ebx, ebx
	je	SHORT $LN71@xmlXPathRu

; 14290: 	xmlFreeStreamCtxt(patstream);

	push	ebx
	call	_xmlFreeStreamCtxt
	add	esp, 4
$LN71@xmlXPathRu:

; 14296:     return(1);
; 14297: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXPathRu:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN139@xmlXPathRu:
	DD	$LN34@xmlXPathRu
	DD	$LN35@xmlXPathRu
$LN119@xmlXPathRu:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	npad	3
$LN140@xmlXPathRu:
	DD	$LN43@xmlXPathRu
	DD	$scan_children$142
$LN120@xmlXPathRu:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
_xmlXPathRunStreamEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalLast
_TEXT	SEGMENT
_total$1$ = -8						; size = 4
_cur$1$ = -4						; size = 4
_arg2$1$ = 8						; size = 4
_comp$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_last$ = 16						; size = 4
_xmlXPathCompOpEvalLast PROC				; COMDAT

; 12834: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jne	$LN31@xmlXPathCo

; 12835:     int total = 0, cur;
; 12836:     xmlXPathCompExprPtr comp;
; 12837:     xmlXPathObjectPtr arg1, arg2;
; 12838: 
; 12839:     CHECK_ERROR0;
; 12840:     comp = ctxt->comp;

	mov	edi, DWORD PTR _op$[ebp]
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR _comp$1$[ebp], edx

; 12841:     switch (op->op) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 17					; 00000011H
	ja	$LN29@xmlXPathCo
	movzx	eax, BYTE PTR $LN32@xmlXPathCo[eax]
	jmp	DWORD PTR $LN34@xmlXPathCo[eax*4]
$LN6@xmlXPathCo:

; 12842:         case XPATH_OP_END:
; 12843:             return (0);
; 12844:         case XPATH_OP_UNION:
; 12845:             total =

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _last$[ebp]
	push	ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalLast
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _total$1$[ebp], eax

; 12846:                 xmlXPathCompOpEvalLast(ctxt, &comp->steps[op->ch1], last);
; 12847: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12848:             if ((ctxt->value != NULL)
; 12849:                 && (ctxt->value->type == XPATH_NODESET)
; 12850:                 && (ctxt->value->nodesetval != NULL)
; 12851:                 && (ctxt->value->nodesetval->nodeNr >= 1)) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN8@xmlXPathCo
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathCo
	cmp	DWORD PTR [ecx], 1
	jl	SHORT $LN8@xmlXPathCo

; 12852:                 /*
; 12853:                  * limit tree traversing to first node in the result
; 12854:                  */
; 12855: 		if (ctxt->value->nodesetval->nodeNr > 1)

	jle	SHORT $LN9@xmlXPathCo

; 12856: 		    xmlXPathNodeSetSort(ctxt->value->nodesetval);

	push	ecx
	call	_xmlXPathNodeSetSort
	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
$LN9@xmlXPathCo:

; 12857:                 *last =

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [ebx], eax
$LN8@xmlXPathCo:

; 12858:                     ctxt->value->nodesetval->nodeTab[ctxt->value->
; 12859:                                                      nodesetval->nodeNr -
; 12860:                                                      1];
; 12861:             }
; 12862:             cur =

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalLast
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$1$[ebp], eax

; 12863:                 xmlXPathCompOpEvalLast(ctxt, &comp->steps[op->ch2], last);
; 12864: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12865:             if ((ctxt->value != NULL)
; 12866:                 && (ctxt->value->type == XPATH_NODESET)
; 12867:                 && (ctxt->value->nodesetval != NULL)
; 12868:                 && (ctxt->value->nodesetval->nodeNr >= 1)) { /* TODO: NOP ? */
; 12869:             }
; 12870: 
; 12871:             arg2 = valuePop(ctxt);

	push	esi
	call	_valuePop

; 12872:             arg1 = valuePop(ctxt);

	push	esi
	mov	DWORD PTR _arg2$1$[ebp], eax
	call	_valuePop
	mov	ebx, eax
	add	esp, 8

; 12873:             if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||
; 12874:                 (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {

	test	ebx, ebx
	je	SHORT $LN13@xmlXPathCo
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN13@xmlXPathCo
	mov	eax, DWORD PTR _arg2$1$[ebp]
	test	eax, eax
	je	SHORT $LN13@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN13@xmlXPathCo

; 12878:             }
; 12879: 
; 12880:             arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,

	push	DWORD PTR [eax+4]
	push	DWORD PTR [ebx+4]
	call	_xmlXPathNodeSetMerge

; 12881:                                                     arg2->nodesetval);
; 12882:             valuePush(ctxt, arg1);

	push	ebx
	push	esi
	mov	DWORD PTR [ebx+4], eax
	call	_valuePush

; 12883: 	    xmlXPathReleaseObject(ctxt->context, arg2);

	push	DWORD PTR _arg2$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12884:             /* optimizer */
; 12885: 	    if (total > cur)

	mov	esi, DWORD PTR _cur$1$[ebp]
	add	esp, 24					; 00000018H
	mov	ebx, DWORD PTR _total$1$[ebp]
	cmp	ebx, esi
	jle	SHORT $LN14@xmlXPathCo

; 12886: 		xmlXPathCompSwap(op);

	push	edi
	call	_xmlXPathCompSwap
	add	esp, 4
$LN14@xmlXPathCo:

; 12887:             return (total + cur);

	pop	edi
	lea	eax, DWORD PTR [esi+ebx]

; 12930:     }
; 12931: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathCo:

; 12875: 	        xmlXPathReleaseObject(ctxt->context, arg1);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12876: 	        xmlXPathReleaseObject(ctxt->context, arg2);

	push	DWORD PTR _arg2$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12877:                 XP_ERROR0(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
$LN31@xmlXPathCo:

; 12930:     }
; 12931: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlXPathCo:

; 12888:         case XPATH_OP_ROOT:
; 12889:             xmlXPathRoot(ctxt);

	push	esi
	call	_xmlXPathRoot
	add	esp, 4

; 12930:     }
; 12931: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXPathCo:

; 12890:             return (0);
; 12891:         case XPATH_OP_NODE:
; 12892:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN18@xmlXPathCo

; 12893:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	ebx, eax

; 12894: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN31@xmlXPathCo
	mov	edx, DWORD PTR _comp$1$[ebp]
$LN18@xmlXPathCo:

; 12895:             if (op->ch2 != -1)

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, -1
	je	SHORT $LN20@xmlXPathCo

; 12896:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	ebx, eax

; 12897: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN31@xmlXPathCo
$LN20@xmlXPathCo:

; 12898: 	    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 12899: 		ctxt->context->node));
; 12900:             return (total);

	mov	eax, ebx
	pop	edi

; 12930:     }
; 12931: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXPathCo:

; 12901:         case XPATH_OP_COLLECT:{
; 12902:                 if (op->ch1 == -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	$LN31@xmlXPathCo

; 12903:                     return (0);
; 12904: 
; 12905:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	ebx, eax

; 12906: 		CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12907: 
; 12908:                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, last, 0);

	push	0
	push	DWORD PTR _last$[ebp]
	push	0
	push	edi
	push	esi
	call	_xmlXPathNodeCollectAndTest
	add	esp, 20					; 00000014H
	add	eax, ebx
	pop	edi

; 12930:     }
; 12931: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlXPathCo:

; 12909:                 return (total);
; 12910:             }
; 12911:         case XPATH_OP_VALUE:
; 12912:             valuePush(ctxt,

	push	DWORD PTR [edi+24]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 12930:     }
; 12931: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlXPathCo:

; 12913:                       xmlXPathCacheObjectCopy(ctxt->context,
; 12914: 			(xmlXPathObjectPtr) op->value4));
; 12915:             return (0);
; 12916:         case XPATH_OP_SORT:
; 12917:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN27@xmlXPathCo

; 12918:                 total +=

	push	DWORD PTR _last$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalLast
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 12919:                     xmlXPathCompOpEvalLast(ctxt, &comp->steps[op->ch1],
; 12920:                                            last);
; 12921: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo
$LN27@xmlXPathCo:

; 12922:             if ((ctxt->value != NULL)
; 12923:                 && (ctxt->value->type == XPATH_NODESET)
; 12924:                 && (ctxt->value->nodesetval != NULL)
; 12925: 		&& (ctxt->value->nodesetval->nodeNr > 1))

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN28@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN28@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN28@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	SHORT $LN28@xmlXPathCo

; 12926:                 xmlXPathNodeSetSort(ctxt->value->nodesetval);

	push	eax
	call	_xmlXPathNodeSetSort
	add	esp, 4
$LN28@xmlXPathCo:

; 12930:     }
; 12931: }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlXPathCo:

; 12927:             return (total);
; 12928:         default:
; 12929:             return (xmlXPathCompOpEval(ctxt, op));

	push	edi
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	pop	edi

; 12930:     }
; 12931: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlXPathCo:
	DD	$LN31@xmlXPathCo
	DD	$LN6@xmlXPathCo
	DD	$LN15@xmlXPathCo
	DD	$LN16@xmlXPathCo
	DD	$LN21@xmlXPathCo
	DD	$LN24@xmlXPathCo
	DD	$LN25@xmlXPathCo
	DD	$LN29@xmlXPathCo
$LN32@xmlXPathCo:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_xmlXPathCompOpEvalLast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalFilterFirst
_TEXT	SEGMENT
_oldpp$1$ = -40						; size = 4
tv1186 = -40						; size = 4
_oldcs$1$ = -36						; size = 4
_obj$2$ = -36						; size = 4
_oldnode$2$ = -32					; size = 4
_oldnode$1$ = -32					; size = 4
_oldDoc$1$ = -28					; size = 4
_obj$1$ = -28						; size = 4
_oldcs$2$ = -24						; size = 4
tv1184 = -24						; size = 4
_oldpp$2$ = -20						; size = 4
tv1188 = -20						; size = 4
_comp$1$ = -16						; size = 4
_oldset$1$ = -12					; size = 4
_i$1$ = -12						; size = 4
_i$2$ = -8						; size = 4
_oldlocset$1$ = -8					; size = 4
_total$2$ = -4						; size = 4
_newset$1$ = 8						; size = 4
_newlocset$1$ = 8					; size = 4
_last$1 = 8						; size = 4
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_first$ = 16						; size = 4
_xmlXPathCompOpEvalFilterFirst PROC			; COMDAT

; 12937: {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	mov	DWORD PTR _total$2$[ebp], edx
	cmp	DWORD PTR [esi+8], edx
	jne	$LN62@xmlXPathCo

; 12938:     int total = 0;
; 12939:     xmlXPathCompExprPtr comp;
; 12940:     xmlXPathObjectPtr res;
; 12941:     xmlXPathObjectPtr obj;
; 12942:     xmlNodeSetPtr oldset;
; 12943:     xmlNodePtr oldnode;
; 12944:     xmlDocPtr oldDoc;
; 12945:     int oldcs, oldpp;
; 12946:     int i;
; 12947: 
; 12948:     CHECK_ERROR0;
; 12949:     comp = ctxt->comp;

	mov	ebx, DWORD PTR _op$[ebp]
	mov	edi, DWORD PTR [esi+32]
	mov	DWORD PTR _comp$1$[ebp], edi

; 12950:     /*
; 12951:     * Optimization for ()[last()] selection i.e. the last elem
; 12952:     */
; 12953:     if ((op->ch1 != -1) && (op->ch2 != -1) &&
; 12954: 	(comp->steps[op->ch1].op == XPATH_OP_SORT) &&

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, -1
	je	$LN10@xmlXPathCo
	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, -1
	je	$LN10@xmlXPathCo
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [edx+eax*8], 17		; 00000011H
	jne	$LN70@xmlXPathCo
	lea	eax, DWORD PTR [ecx+ecx*4]
	cmp	DWORD PTR [edx+eax*8], 17		; 00000011H
	jne	$LN70@xmlXPathCo

; 12955: 	(comp->steps[op->ch2].op == XPATH_OP_SORT)) {
; 12956: 	int f = comp->steps[op->ch2].ch1;

	mov	eax, DWORD PTR [edx+eax*8+4]

; 12957: 
; 12958: 	if ((f != -1) &&
; 12959: 	    (comp->steps[f].op == XPATH_OP_FUNCTION) &&
; 12960: 	    (comp->steps[f].value5 == NULL) &&
; 12961: 	    (comp->steps[f].value == 0) &&
; 12962: 	    (comp->steps[f].value4 != NULL) &&

	cmp	eax, -1
	je	$LN70@xmlXPathCo
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [edx+eax*8], 13		; 0000000dH
	jne	$LN70@xmlXPathCo
	cmp	DWORD PTR [edx+eax*8+28], 0
	jne	$LN70@xmlXPathCo
	cmp	DWORD PTR [edx+eax*8+12], 0
	jne	$LN70@xmlXPathCo
	mov	eax, DWORD PTR [edx+eax*8+24]
	test	eax, eax
	je	SHORT $LN70@xmlXPathCo
	push	OFFSET ??_C@_04PLGBGIDD@last@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlXPathCo

; 12963: 	    (xmlStrEqual
; 12964: 	    (comp->steps[f].value4, BAD_CAST "last"))) {
; 12965: 	    xmlNodePtr last = NULL;
; 12966: 
; 12967: 	    total +=

	lea	eax, DWORD PTR _last$1[ebp]
	mov	DWORD PTR _last$1[ebp], 0
	push	eax
	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalLast
	add	esp, 12					; 0000000cH
	mov	edi, eax

; 12968: 		xmlXPathCompOpEvalLast(ctxt,
; 12969: 		    &comp->steps[op->ch1],
; 12970: 		    &last);
; 12971: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN62@xmlXPathCo

; 12972: 	    /*
; 12973: 	    * The nodeset should be in document order,
; 12974: 	    * Keep only the last value
; 12975: 	    */
; 12976: 	    if ((ctxt->value != NULL) &&
; 12977: 		(ctxt->value->type == XPATH_NODESET) &&
; 12978: 		(ctxt->value->nodesetval != NULL) &&
; 12979: 		(ctxt->value->nodesetval->nodeTab != NULL) &&

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN12@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN12@xmlXPathCo
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN12@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	SHORT $LN12@xmlXPathCo

; 12980: 		(ctxt->value->nodesetval->nodeNr > 1)) {
; 12981:                 xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);

	push	eax
	call	_xmlXPathNodeSetKeepLast

; 12982: 		*first = *(ctxt->value->nodesetval->nodeTab);

	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@xmlXPathCo:

; 12983: 	    }
; 12984: 	    return (total);

	mov	eax, edi
	pop	edi

; 13198:     }
; 13199:     return(total);
; 13200: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlXPathCo:

; 12985: 	}
; 12986:     }
; 12987: 
; 12988:     if (op->ch1 != -1)

	xor	edx, edx
$LN10@xmlXPathCo:
	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, -1
	je	SHORT $LN13@xmlXPathCo

; 12989: 	total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	DWORD PTR _total$2$[ebp], eax
	mov	edx, eax
$LN13@xmlXPathCo:

; 12990:     CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN62@xmlXPathCo

; 12991:     if (op->ch2 == -1)

	cmp	DWORD PTR [ebx+8], -1
	je	$LN35@xmlXPathCo

; 12992: 	return (total);
; 12993:     if (ctxt->value == NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN35@xmlXPathCo

; 12994: 	return (total);
; 12995: 
; 12996: #ifdef LIBXML_XPTR_ENABLED
; 12997:     /*
; 12998:     * Hum are we filtering the result of an XPointer expression
; 12999:     */
; 13000:     if (ctxt->value->type == XPATH_LOCATIONSET) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 7
	jne	$LN17@xmlXPathCo

; 13001: 	xmlXPathObjectPtr tmp = NULL;
; 13002: 	xmlLocationSetPtr newlocset = NULL;
; 13003: 	xmlLocationSetPtr oldlocset;
; 13004: 
; 13005: 	/*
; 13006: 	* Extract the old locset, and then evaluate the result of the
; 13007: 	* expression for all the element in the locset. use it to grow
; 13008: 	* up a new locset.
; 13009: 	*/
; 13010: 	CHECK_TYPE0(XPATH_LOCATIONSET);
; 13011: 
; 13012: 	if ((ctxt->value->user == NULL) ||

	mov	eax, DWORD PTR [eax+28]
	xor	edi, edi
	test	eax, eax
	je	$LN35@xmlXPathCo
	cmp	DWORD PTR [eax], edi
	je	$LN35@xmlXPathCo

; 13013:             (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))
; 13014: 	    return (total);
; 13015: 
; 13016: 	obj = valuePop(ctxt);

	push	esi
	call	_valuePop

; 13017: 	oldlocset = obj->user;
; 13018:         oldnode = ctxt->context->node;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _obj$1$[ebp], eax

; 13019:         oldcs = ctxt->context->contextSize;
; 13020:         oldpp = ctxt->context->proximityPosition;
; 13021: 
; 13022: 	newlocset = xmlXPtrLocationSetCreate(NULL);

	push	edi
	mov	ebx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldnode$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _oldcs$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _oldlocset$1$[ebp], ebx
	mov	DWORD PTR _oldpp$1$[ebp], eax
	call	_xmlXPtrLocationSetCreate

; 13023: 
; 13024: 	for (i = 0; i < oldlocset->locNr; i++) {

	xor	edx, edx
	mov	DWORD PTR _newlocset$1$[ebp], eax
	add	esp, 8
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	DWORD PTR [ebx], edx
	jle	$LN32@xmlXPathCo
	npad	9
$LL4@xmlXPathCo:

; 13025: 	    /*
; 13026: 	    * Run the evaluation with a node list made of a
; 13027: 	    * single item in the nodelocset.
; 13028: 	    */
; 13029: 	    ctxt->context->node = oldlocset->locTab[i]->user;

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [edx*4]
	mov	DWORD PTR tv1188[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+4], eax

; 13030: 	    ctxt->context->contextSize = oldlocset->locNr;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+68], eax

; 13031: 	    ctxt->context->proximityPosition = i + 1;

	lea	ecx, DWORD PTR [edx+1]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv1184[ebp], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx+4]

; 13032: 	    if (tmp == NULL) {

	push	eax
	test	edi, edi
	jne	SHORT $LN22@xmlXPathCo

; 13033: 		tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	push	ecx
	call	_xmlXPathCacheNewNodeSet
	add	esp, 8
	mov	edi, eax

; 13034: 		    ctxt->context->node);
; 13035: 	    } else {

	jmp	SHORT $LN24@xmlXPathCo
$LN22@xmlXPathCo:

; 13036: 		if (xmlXPathNodeSetAddUnique(tmp->nodesetval,
; 13037: 		                             ctxt->context->node) < 0) {

	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN24@xmlXPathCo

; 13038: 		    ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH
$LN24@xmlXPathCo:

; 13039: 		}
; 13040: 	    }
; 13041: 	    valuePush(ctxt, tmp);

	push	edi
	push	esi
	call	_valuePush

; 13042: 	    if (op->ch2 != -1)

	mov	eax, DWORD PTR _op$[ebp]
	add	esp, 8
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -1
	je	SHORT $LN25@xmlXPathCo

; 13043: 		total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	DWORD PTR _total$2$[ebp], eax
$LN25@xmlXPathCo:

; 13044: 	    if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [esi+8], 0
	jne	$LN52@xmlXPathCo

; 13047: 	    }
; 13048: 	    /*
; 13049: 	    * The result of the evaluation need to be tested to
; 13050: 	    * decided whether the filter succeeded or not
; 13051: 	    */
; 13052: 	    res = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax

; 13053: 	    if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	push	ebx
	push	esi
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo

; 13054: 		xmlXPtrLocationSetAdd(newlocset,

	mov	ecx, DWORD PTR _oldlocset$1$[ebp]
	mov	eax, DWORD PTR tv1188[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [eax+ecx]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 16					; 00000010H
$LN27@xmlXPathCo:

; 13055: 		    xmlXPathCacheObjectCopy(ctxt->context,
; 13056: 			oldlocset->locTab[i]));
; 13057: 	    }
; 13058: 	    /*
; 13059: 	    * Cleanup
; 13060: 	    */
; 13061: 	    if (res != NULL) {

	test	ebx, ebx
	je	SHORT $LN28@xmlXPathCo

; 13062: 		xmlXPathReleaseObject(ctxt->context, res);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN28@xmlXPathCo:

; 13063: 	    }
; 13064: 	    if (ctxt->value == tmp) {

	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN29@xmlXPathCo

; 13065: 		valuePop(ctxt);

	push	esi
	call	_valuePop

; 13066: 		xmlXPathNodeSetClear(tmp->nodesetval, 1);

	push	1
	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetClear
	add	esp, 12					; 0000000cH

; 13067: 		/*
; 13068: 		* REVISIT TODO: Don't create a temporary nodeset
; 13069: 		* for everly iteration.
; 13070: 		*/
; 13071: 		/* OLD: xmlXPathFreeObject(res); */
; 13072: 	    } else

	jmp	SHORT $LN30@xmlXPathCo
$LN29@xmlXPathCo:

; 13073: 		tmp = NULL;

	xor	edi, edi
$LN30@xmlXPathCo:

; 13074: 	    /*
; 13075: 	    * Only put the first node in the result, then leave.
; 13076: 	    */
; 13077: 	    if (newlocset->locNr > 0) {

	mov	eax, DWORD PTR _newlocset$1$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN53@xmlXPathCo

; 13023: 
; 13024: 	for (i = 0; i < oldlocset->locNr; i++) {

	mov	ebx, DWORD PTR _oldlocset$1$[ebp]
	mov	edx, DWORD PTR tv1184[ebp]
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, DWORD PTR [ebx]
	jl	$LL4@xmlXPathCo

; 13177: 	    /*
; 13178: 	    * Only put the first node in the result, then leave.
; 13179: 	    */
; 13180: 	    if (newset->nodeNr > 0) {

	jmp	SHORT $LN3@xmlXPathCo
$LN53@xmlXPathCo:

; 13078: 		*first = (xmlNodePtr) oldlocset->locTab[i]->user;

	mov	eax, DWORD PTR _oldlocset$1$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@xmlXPathCo:

; 13079: 		break;
; 13080: 	    }
; 13081: 	}
; 13082: 	if (tmp != NULL) {

	test	edi, edi
	je	SHORT $LN32@xmlXPathCo

; 13083: 	    xmlXPathReleaseObject(ctxt->context, tmp);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN32@xmlXPathCo:

; 13084: 	}
; 13085: 	/*
; 13086: 	* The result is used as the new evaluation locset.
; 13087: 	*/
; 13088: 	valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));

	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 12					; 0000000cH
$xptr_error$72:

; 13089: xptr_error:
; 13090: 	xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 13091: 	ctxt->context->node = oldnode;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	mov	ecx, DWORD PTR _oldnode$1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13092: 	ctxt->context->contextSize = oldcs;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _oldcs$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax+68], ecx

; 13093: 	ctxt->context->proximityPosition = oldpp;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _oldpp$1$[ebp]

; 13198:     }
; 13199:     return(total);
; 13200: }

	pop	esi
	pop	ebx
	mov	DWORD PTR [eax+72], ecx
	mov	eax, DWORD PTR _total$2$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlXPathCo:

; 13045:                 xmlXPtrFreeLocationSet(newlocset);

	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrFreeLocationSet
	add	esp, 4

; 13046:                 goto xptr_error;

	jmp	SHORT $xptr_error$72
$LN17@xmlXPathCo:

; 13094: 	return (total);
; 13095:     }
; 13096: #endif /* LIBXML_XPTR_ENABLED */
; 13097: 
; 13098:     /*
; 13099:     * Extract the old set, and then evaluate the result of the
; 13100:     * expression for all the element in the set. use it to grow
; 13101:     * up a new set.
; 13102:     */
; 13103:     CHECK_TYPE0(XPATH_NODESET);

	cmp	ecx, 1
	jne	$LN34@xmlXPathCo

; 13104: 
; 13105:     if ((ctxt->value->nodesetval != NULL) &&

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN35@xmlXPathCo
	cmp	DWORD PTR [eax], 0
	je	$LN35@xmlXPathCo

; 13106:         (ctxt->value->nodesetval->nodeNr != 0)) {
; 13107: 	xmlNodeSetPtr newset;
; 13108: 	xmlXPathObjectPtr tmp = NULL;
; 13109: 
; 13110:         obj = valuePop(ctxt);

	push	esi
	xor	edi, edi
	call	_valuePop

; 13111:         oldset = obj->nodesetval;
; 13112:         oldnode = ctxt->context->node;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _obj$2$[ebp], eax

; 13113:         oldDoc = ctxt->context->doc;
; 13114:         oldcs = ctxt->context->contextSize;
; 13115:         oldpp = ctxt->context->proximityPosition;
; 13116: 
; 13117: 	/*
; 13118: 	* Initialize the new set.
; 13119: 	* Also set the xpath document in case things like
; 13120: 	* key() evaluation are attempted on the predicate
; 13121: 	*/
; 13122: 	newset = xmlXPathNodeSetCreate(NULL);

	push	edi
	mov	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldnode$2$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _oldDoc$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _oldcs$2$[ebp], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _oldset$1$[ebp], ebx
	mov	DWORD PTR _oldpp$2$[ebp], eax
	call	_xmlXPathNodeSetCreate

; 13123:         /* XXX what if xmlXPathNodeSetCreate returned NULL? */
; 13124: 
; 13125: 	for (i = 0; i < oldset->nodeNr; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _newset$1$[ebp], eax
	add	esp, 8
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	$LN48@xmlXPathCo
	npad	9
$LL7@xmlXPathCo:

; 13126: 	    /*
; 13127: 	    * Run the evaluation with a node list made of
; 13128: 	    * a single item in the nodeset.
; 13129: 	    */
; 13130: 	    ctxt->context->node = oldset->nodeTab[i];

	mov	eax, DWORD PTR [ebx+8]
	lea	edx, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR tv1186[ebp], edx
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+4], eax

; 13131: 	    if ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edx+eax]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN36@xmlXPathCo
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	je	SHORT $LN36@xmlXPathCo

; 13132: 		(oldset->nodeTab[i]->doc != NULL))
; 13133: 		ctxt->context->doc = oldset->nodeTab[i]->doc;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], ecx
$LN36@xmlXPathCo:

; 13134: 	    if (tmp == NULL) {

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	test	edi, edi
	jne	SHORT $LN37@xmlXPathCo

; 13135: 		tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	push	eax
	call	_xmlXPathCacheNewNodeSet
	add	esp, 8
	mov	edi, eax

; 13136: 		    ctxt->context->node);
; 13137: 	    } else {

	jmp	SHORT $LN39@xmlXPathCo
$LN37@xmlXPathCo:

; 13138: 		if (xmlXPathNodeSetAddUnique(tmp->nodesetval,
; 13139: 		                             ctxt->context->node) < 0) {

	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN39@xmlXPathCo

; 13140: 		    ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH
$LN39@xmlXPathCo:

; 13141: 		}
; 13142: 	    }
; 13143: 	    valuePush(ctxt, tmp);

	push	edi
	push	esi
	call	_valuePush

; 13144: 	    ctxt->context->contextSize = oldset->nodeNr;

	mov	ecx, DWORD PTR [esi+12]
	add	esp, 8
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+68], eax

; 13145: 	    ctxt->context->proximityPosition = i + 1;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _i$2$[ebp]
	inc	ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	mov	DWORD PTR [eax+72], ecx

; 13146: 	    if (op->ch2 != -1)

	mov	eax, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -1
	je	SHORT $LN40@xmlXPathCo

; 13147: 		total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	DWORD PTR _total$2$[ebp], eax
$LN40@xmlXPathCo:

; 13148: 	    if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [esi+8], 0
	jne	$LN54@xmlXPathCo

; 13151: 	    }
; 13152: 	    /*
; 13153: 	    * The result of the evaluation needs to be tested to
; 13154: 	    * decide whether the filter succeeded or not
; 13155: 	    */
; 13156: 	    res = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax

; 13157: 	    if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	push	ebx
	push	esi
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN43@xmlXPathCo

; 13158: 		if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i]) < 0)

	mov	ecx, DWORD PTR _oldset$1$[ebp]
	mov	eax, DWORD PTR tv1186[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [eax+ecx]
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPathNodeSetAdd
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN43@xmlXPathCo

; 13159: 		    ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH
$LN43@xmlXPathCo:

; 13160: 	    }
; 13161: 	    /*
; 13162: 	    * Cleanup
; 13163: 	    */
; 13164: 	    if (res != NULL) {

	test	ebx, ebx
	je	SHORT $LN44@xmlXPathCo

; 13165: 		xmlXPathReleaseObject(ctxt->context, res);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN44@xmlXPathCo:

; 13166: 	    }
; 13167: 	    if (ctxt->value == tmp) {

	cmp	DWORD PTR [esi+16], edi
	jne	SHORT $LN45@xmlXPathCo

; 13168: 		valuePop(ctxt);

	push	esi
	call	_valuePop

; 13169: 		/*
; 13170: 		* Don't free the temporary nodeset
; 13171: 		* in order to avoid massive recreation inside this
; 13172: 		* loop.
; 13173: 		*/
; 13174: 		xmlXPathNodeSetClear(tmp->nodesetval, 1);

	push	1
	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetClear
	add	esp, 12					; 0000000cH

; 13175: 	    } else

	jmp	SHORT $LN46@xmlXPathCo
$LN45@xmlXPathCo:

; 13176: 		tmp = NULL;

	xor	edi, edi
$LN46@xmlXPathCo:

; 13177: 	    /*
; 13178: 	    * Only put the first node in the result, then leave.
; 13179: 	    */
; 13180: 	    if (newset->nodeNr > 0) {

	mov	eax, DWORD PTR _newset$1$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN55@xmlXPathCo

; 13123:         /* XXX what if xmlXPathNodeSetCreate returned NULL? */
; 13124: 
; 13125: 	for (i = 0; i < oldset->nodeNr; i++) {

	mov	ebx, DWORD PTR _oldset$1$[ebp]
	mov	ecx, DWORD PTR _i$2$[ebp]
	cmp	ecx, DWORD PTR [ebx]
	jl	$LL7@xmlXPathCo

; 13177: 	    /*
; 13178: 	    * Only put the first node in the result, then leave.
; 13179: 	    */
; 13180: 	    if (newset->nodeNr > 0) {

	jmp	SHORT $LN6@xmlXPathCo
$LN55@xmlXPathCo:

; 13181: 		*first = *(newset->nodeTab);

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _newset$1$[ebp]
$LN6@xmlXPathCo:

; 13182: 		break;
; 13183: 	    }
; 13184: 	}
; 13185: 	if (tmp != NULL) {

	test	edi, edi
	je	SHORT $LN48@xmlXPathCo

; 13186: 	    xmlXPathReleaseObject(ctxt->context, tmp);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	mov	eax, DWORD PTR _newset$1$[ebp]
	add	esp, 8
$LN48@xmlXPathCo:

; 13187: 	}
; 13188: 	/*
; 13189: 	* The result is used as the new evaluation set.
; 13190: 	*/
; 13191: 	valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, newset));

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$error$73:

; 13192: error:
; 13193: 	xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$2$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 13194: 	ctxt->context->node = oldnode;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 8
	mov	ecx, DWORD PTR _oldnode$2$[ebp]
	mov	edx, DWORD PTR _total$2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13195: 	ctxt->context->doc = oldDoc;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _oldDoc$1$[ebp]
	mov	DWORD PTR [eax], ecx

; 13196: 	ctxt->context->contextSize = oldcs;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _oldcs$2$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 13197: 	ctxt->context->proximityPosition = oldpp;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _oldpp$2$[ebp]
	mov	DWORD PTR [eax+72], ecx
$LN35@xmlXPathCo:

; 13198:     }
; 13199:     return(total);
; 13200: }

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlXPathCo:

; 13149: 		xmlXPathFreeNodeSet(newset);

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPathFreeNodeSet
	add	esp, 4

; 13150:                 goto error;

	jmp	SHORT $error$73
$LN34@xmlXPathCo:

; 13094: 	return (total);
; 13095:     }
; 13096: #endif /* LIBXML_XPTR_ENABLED */
; 13097: 
; 13098:     /*
; 13099:     * Extract the old set, and then evaluate the result of the
; 13100:     * expression for all the element in the set. use it to grow
; 13101:     * up a new set.
; 13102:     */
; 13103:     CHECK_TYPE0(XPATH_NODESET);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN62@xmlXPathCo:

; 13198:     }
; 13199:     return(total);
; 13200: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompOpEvalFilterFirst ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeCollectAndTest
_TEXT	SEGMENT
_oldContextNode$1$ = -92				; size = 4
_contextSeq$1$ = -88					; size = 4
_hasPredicateRange$1$ = -84				; size = 4
_type$1$ = -80						; size = 4
_test$1$ = -76						; size = 4
_obj$1$ = -72						; size = 4
_name$1$ = -68						; size = 4
_axis$1$ = -64						; size = 4
_URI$1$ = -60						; size = 4
_prefix$1$ = -56					; size = 4
_contextIdx$1$ = -52					; size = 4
_hasNsNodes$1$ = -48					; size = 4
_mergeAndClear$1$ = -44					; size = 4
_total$1$ = -40						; size = 4
_predOp$1$ = -36					; size = 4
_last$1$ = -32						; size = 4
_first$1$ = -28						; size = 4
_next$1$ = -24						; size = 4
_outSeq$1$ = -20					; size = 4
_breakOnFirstHit$1$ = -16				; size = 4
_hasAxisRange$1$ = -12					; size = 4
_maxPos$1$ = -8						; size = 4
_seq$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xpctxt$1$ = 12						; size = 4
_op$ = 12						; size = 4
_first$ = 16						; size = 4
_last$ = 20						; size = 4
_toBool$ = 24						; size = 4
_xmlXPathNodeCollectAndTest PROC			; COMDAT

; 12060: {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _op$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _URI$1$[ebp], 0
	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [ebx+12]
	mov	DWORD PTR _axis$1$[ebp], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _test$1$[ebp], eax
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _type$1$[ebp], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _prefix$1$[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _name$1$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _total$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _xpctxt$1$[ebp], edi
	test	eax, eax
	je	$LN16@xmlXPathNo

; 12061: 
; 12062: #define XP_TEST_HIT \
; 12063:     if (hasAxisRange != 0) { \
; 12064: 	if (++pos == maxPos) { \
; 12065: 	    if (addNode(seq, cur) < 0) \
; 12066: 	        ctxt->error = XPATH_MEMORY_ERROR; \
; 12067: 	    goto axis_range_end; } \
; 12068:     } else { \
; 12069: 	if (addNode(seq, cur) < 0) \
; 12070: 	    ctxt->error = XPATH_MEMORY_ERROR; \
; 12071: 	if (breakOnFirstHit) goto first_hit; }
; 12072: 
; 12073: #define XP_TEST_HIT_NS \
; 12074:     if (hasAxisRange != 0) { \
; 12075: 	if (++pos == maxPos) { \
; 12076: 	    hasNsNodes = 1; \
; 12077: 	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
; 12078: 	        ctxt->error = XPATH_MEMORY_ERROR; \
; 12079: 	goto axis_range_end; } \
; 12080:     } else { \
; 12081: 	hasNsNodes = 1; \
; 12082: 	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
; 12083: 	    ctxt->error = XPATH_MEMORY_ERROR; \
; 12084: 	if (breakOnFirstHit) goto first_hit; }
; 12085: 
; 12086:     xmlXPathAxisVal axis = (xmlXPathAxisVal) op->value;
; 12087:     xmlXPathTestVal test = (xmlXPathTestVal) op->value2;
; 12088:     xmlXPathTypeVal type = (xmlXPathTypeVal) op->value3;
; 12089:     const xmlChar *prefix = op->value4;
; 12090:     const xmlChar *name = op->value5;
; 12091:     const xmlChar *URI = NULL;
; 12092: 
; 12093: #ifdef DEBUG_STEP
; 12094:     int nbMatches = 0, prevMatches = 0;
; 12095: #endif
; 12096:     int total = 0, hasNsNodes = 0;
; 12097:     /* The popped object holding the context nodes */
; 12098:     xmlXPathObjectPtr obj;
; 12099:     /* The set of context nodes for the node tests */
; 12100:     xmlNodeSetPtr contextSeq;
; 12101:     int contextIdx;
; 12102:     xmlNodePtr contextNode;
; 12103:     /* The final resulting node set wrt to all context nodes */
; 12104:     xmlNodeSetPtr outSeq;
; 12105:     /*
; 12106:     * The temporary resulting node set wrt 1 context node.
; 12107:     * Used to feed predicate evaluation.
; 12108:     */
; 12109:     xmlNodeSetPtr seq;
; 12110:     xmlNodePtr cur;
; 12111:     /* First predicate operator */
; 12112:     xmlXPathStepOpPtr predOp;
; 12113:     int maxPos; /* The requested position() (when a "[n]" predicate) */
; 12114:     int hasPredicateRange, hasAxisRange, pos, size, newSize;
; 12115:     int breakOnFirstHit;
; 12116: 
; 12117:     xmlXPathTraversalFunction next = NULL;
; 12118:     int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
; 12119:     xmlXPathNodeSetMergeFunction mergeAndClear;
; 12120:     xmlNodePtr oldContextNode;
; 12121:     xmlXPathContextPtr xpctxt = ctxt->context;
; 12122: 
; 12123: 
; 12124:     CHECK_TYPE0(XPATH_NODESET);

	cmp	DWORD PTR [eax], 1
	jne	$LN16@xmlXPathNo

; 12125:     obj = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	ecx, eax
	add	esp, 4

; 12126:     /*
; 12127:     * Setup namespaces.
; 12128:     */
; 12129:     if (prefix != NULL) {

	mov	eax, DWORD PTR _prefix$1$[ebp]
	mov	DWORD PTR _obj$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN18@xmlXPathNo

; 12130:         URI = xmlXPathNsLookup(xpctxt, prefix);

	push	eax
	push	edi
	call	_xmlXPathNsLookup
	add	esp, 8
	mov	DWORD PTR _URI$1$[ebp], eax

; 12131:         if (URI == NULL) {

	test	eax, eax
	jne	SHORT $LN343@xmlXPathNo

; 12132: 	    xmlXPathReleaseObject(xpctxt, obj);

	push	DWORD PTR _obj$1$[ebp]
	push	edi
	call	_xmlXPathReleaseObject

; 12133:             XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);

	push	19					; 00000013H
	push	ebx
	call	_xmlXPathErr
	add	esp, 16					; 00000010H

; 12695: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN343@xmlXPathNo:

; 12131:         if (URI == NULL) {

	mov	ecx, DWORD PTR _obj$1$[ebp]
$LN18@xmlXPathNo:

; 12134: 	}
; 12135:     }
; 12136:     /*
; 12137:     * Setup axis.
; 12138:     *
; 12139:     * MAYBE FUTURE TODO: merging optimizations:
; 12140:     * - If the nodes to be traversed wrt to the initial nodes and
; 12141:     *   the current axis cannot overlap, then we could avoid searching
; 12142:     *   for duplicates during the merge.
; 12143:     *   But the question is how/when to evaluate if they cannot overlap.
; 12144:     *   Example: if we know that for two initial nodes, the one is
; 12145:     *   not in the ancestor-or-self axis of the other, then we could safely
; 12146:     *   avoid a duplicate-aware merge, if the axis to be traversed is e.g.
; 12147:     *   the descendant-or-self axis.
; 12148:     */
; 12149:     mergeAndClear = xmlXPathNodeSetMergeAndClear;
; 12150:     switch (axis) {

	mov	eax, DWORD PTR _axis$1$[ebp]
	dec	eax
	mov	DWORD PTR _mergeAndClear$1$[ebp], OFFSET _xmlXPathNodeSetMergeAndClear
	cmp	eax, 12					; 0000000cH
	ja	$LN303@xmlXPathNo
	jmp	DWORD PTR $LN368@xmlXPathNo[eax*4]
$LN19@xmlXPathNo:

; 12151:         case AXIS_ANCESTOR:
; 12152:             first = NULL;

	xor	eax, eax

; 12153:             next = xmlXPathNextAncestor;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextAncestor
	mov	DWORD PTR _first$1$[ebp], eax

; 12154:             break;

	mov	eax, DWORD PTR _last$[ebp]
	jmp	$LN349@xmlXPathNo
$LN20@xmlXPathNo:

; 12155:         case AXIS_ANCESTOR_OR_SELF:
; 12156:             first = NULL;

	xor	eax, eax

; 12157:             next = xmlXPathNextAncestorOrSelf;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextAncestorOrSelf
	mov	DWORD PTR _first$1$[ebp], eax

; 12158:             break;

	mov	eax, DWORD PTR _last$[ebp]
	jmp	$LN349@xmlXPathNo
$LN21@xmlXPathNo:

; 12159:         case AXIS_ATTRIBUTE:
; 12160:             first = NULL;
; 12161: 	    last = NULL;
; 12162:             next = xmlXPathNextAttribute;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextAttribute

; 12163: 	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
; 12164:             break;

	jmp	$LN350@xmlXPathNo
$LN22@xmlXPathNo:

; 12165:         case AXIS_CHILD:
; 12166: 	    last = NULL;

	xor	eax, eax
	mov	DWORD PTR _last$1$[ebp], eax

; 12167: 	    if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&

	mov	eax, DWORD PTR _test$1$[ebp]
	cmp	eax, 5
	je	SHORT $LN25@xmlXPathNo
	cmp	eax, 3
	jne	SHORT $LN23@xmlXPathNo
$LN25@xmlXPathNo:
	cmp	DWORD PTR _type$1$[ebp], 0

; 12168: 		(type == NODE_TYPE_NODE))
; 12169: 	    {
; 12170: 		/*
; 12171: 		* Optimization if an element node type is 'element'.
; 12172: 		*/
; 12173: 		next = xmlXPathNextChildElement;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextChildElement
	je	SHORT $LN24@xmlXPathNo
$LN23@xmlXPathNo:

; 12174: 	    } else
; 12175: 		next = xmlXPathNextChild;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextChild
$LN24@xmlXPathNo:

; 12176: 	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
; 12177:             break;

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _mergeAndClear$1$[ebp], OFFSET _xmlXPathNodeSetMergeAndClearNoDupls
	mov	DWORD PTR _first$1$[ebp], eax
	jmp	$LN35@xmlXPathNo
$LN26@xmlXPathNo:

; 12178:         case AXIS_DESCENDANT:
; 12179: 	    last = NULL;

	xor	eax, eax

; 12180:             next = xmlXPathNextDescendant;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextDescendant
	mov	DWORD PTR _last$1$[ebp], eax

; 12181:             break;

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _first$1$[ebp], eax
	jmp	$LN35@xmlXPathNo
$LN27@xmlXPathNo:

; 12182:         case AXIS_DESCENDANT_OR_SELF:
; 12183: 	    last = NULL;

	xor	eax, eax

; 12184:             next = xmlXPathNextDescendantOrSelf;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextDescendantOrSelf
	mov	DWORD PTR _last$1$[ebp], eax

; 12185:             break;

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _first$1$[ebp], eax
	jmp	SHORT $LN35@xmlXPathNo
$LN28@xmlXPathNo:

; 12186:         case AXIS_FOLLOWING:
; 12187: 	    last = NULL;

	xor	eax, eax

; 12188:             next = xmlXPathNextFollowing;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextFollowing
	mov	DWORD PTR _last$1$[ebp], eax

; 12189:             break;

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _first$1$[ebp], eax
	jmp	SHORT $LN35@xmlXPathNo
$LN29@xmlXPathNo:

; 12190:         case AXIS_FOLLOWING_SIBLING:
; 12191: 	    last = NULL;

	xor	eax, eax

; 12192:             next = xmlXPathNextFollowingSibling;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextFollowingSibling
	mov	DWORD PTR _last$1$[ebp], eax

; 12193:             break;

	mov	eax, DWORD PTR _first$[ebp]
	mov	DWORD PTR _first$1$[ebp], eax
	jmp	SHORT $LN35@xmlXPathNo
$LN30@xmlXPathNo:

; 12194:         case AXIS_NAMESPACE:
; 12195:             first = NULL;
; 12196: 	    last = NULL;
; 12197:             next = (xmlXPathTraversalFunction) xmlXPathNextNamespace;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextNamespace

; 12198: 	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
; 12199:             break;

	jmp	SHORT $LN350@xmlXPathNo
$LN31@xmlXPathNo:

; 12200:         case AXIS_PARENT:
; 12201:             first = NULL;

	xor	eax, eax

; 12202:             next = xmlXPathNextParent;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextParent
	mov	DWORD PTR _first$1$[ebp], eax

; 12203:             break;

	mov	eax, DWORD PTR _last$[ebp]
	jmp	SHORT $LN349@xmlXPathNo
$LN32@xmlXPathNo:

; 12204:         case AXIS_PRECEDING:
; 12205:             first = NULL;

	xor	eax, eax

; 12206:             next = xmlXPathNextPrecedingInternal;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextPrecedingInternal
	mov	DWORD PTR _first$1$[ebp], eax

; 12207:             break;

	mov	eax, DWORD PTR _last$[ebp]
	jmp	SHORT $LN349@xmlXPathNo
$LN33@xmlXPathNo:

; 12208:         case AXIS_PRECEDING_SIBLING:
; 12209:             first = NULL;

	xor	eax, eax

; 12210:             next = xmlXPathNextPrecedingSibling;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextPrecedingSibling
	mov	DWORD PTR _first$1$[ebp], eax

; 12211:             break;

	mov	eax, DWORD PTR _last$[ebp]
	jmp	SHORT $LN349@xmlXPathNo
$LN34@xmlXPathNo:

; 12212:         case AXIS_SELF:
; 12213:             first = NULL;
; 12214: 	    last = NULL;
; 12215:             next = xmlXPathNextSelf;

	mov	DWORD PTR _next$1$[ebp], OFFSET _xmlXPathNextSelf
$LN350@xmlXPathNo:

; 12227:         return(0);
; 12228:     }
; 12229:     contextSeq = obj->nodesetval;

	xor	eax, eax
	mov	DWORD PTR _mergeAndClear$1$[ebp], OFFSET _xmlXPathNodeSetMergeAndClearNoDupls
	mov	DWORD PTR _first$1$[ebp], eax
$LN349@xmlXPathNo:
	mov	DWORD PTR _last$1$[ebp], eax
$LN35@xmlXPathNo:
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _contextSeq$1$[ebp], eax

; 12230:     if ((contextSeq == NULL) || (contextSeq->nodeNr <= 0)) {

	test	eax, eax
	je	$LN37@xmlXPathNo
	cmp	DWORD PTR [eax], 0
	jle	$LN37@xmlXPathNo

; 12233:         return(0);
; 12234:     }
; 12235:     /*
; 12236:     * Predicate optimization ---------------------------------------------
; 12237:     * If this step has a last predicate, which contains a position(),
; 12238:     * then we'll optimize (although not exactly "position()", but only
; 12239:     * the  short-hand form, i.e., "[n]".
; 12240:     *
; 12241:     * Example - expression "/foo[parent::bar][1]":
; 12242:     *
; 12243:     * COLLECT 'child' 'name' 'node' foo    -- op (we are here)
; 12244:     *   ROOT                               -- op->ch1
; 12245:     *   PREDICATE                          -- op->ch2 (predOp)
; 12246:     *     PREDICATE                          -- predOp->ch1 = [parent::bar]
; 12247:     *       SORT
; 12248:     *         COLLECT  'parent' 'name' 'node' bar
; 12249:     *           NODE
; 12250:     *     ELEM Object is a number : 1        -- predOp->ch2 = [1]
; 12251:     *
; 12252:     */
; 12253:     maxPos = 0;
; 12254:     predOp = NULL;
; 12255:     hasPredicateRange = 0;
; 12256:     hasAxisRange = 0;
; 12257:     if (op->ch2 != -1) {

	mov	ecx, DWORD PTR [esi+8]
	xor	edx, edx
	mov	DWORD PTR _maxPos$1$[ebp], 0
	mov	DWORD PTR _predOp$1$[ebp], edx
	mov	DWORD PTR _hasPredicateRange$1$[ebp], edx
	mov	DWORD PTR _hasAxisRange$1$[ebp], edx
	cmp	ecx, -1
	je	$LN41@xmlXPathNo

; 12258: 	/*
; 12259: 	* There's at least one predicate. 16 == XPATH_OP_PREDICATE
; 12260: 	*/
; 12261: 	predOp = &ctxt->comp->steps[op->ch2];

	mov	eax, DWORD PTR [ebx+32]
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [edx+eax*8]

; 12020:     if ((op->op != XPATH_OP_PREDICATE) && (op->op != XPATH_OP_FILTER))

	mov	eax, DWORD PTR [ecx]

; 12258: 	/*
; 12259: 	* There's at least one predicate. 16 == XPATH_OP_PREDICATE
; 12260: 	*/
; 12261: 	predOp = &ctxt->comp->steps[op->ch2];

	mov	DWORD PTR _predOp$1$[ebp], ecx

; 12020:     if ((op->op != XPATH_OP_PREDICATE) && (op->op != XPATH_OP_FILTER))

	cmp	eax, 15					; 0000000fH
	je	SHORT $LN244@xmlXPathNo
	cmp	eax, 16					; 00000010H
	jne	$LN342@xmlXPathNo
$LN244@xmlXPathNo:

; 12021: 	return(0);
; 12022: 
; 12023:     if (op->ch2 != -1) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, -1
	je	SHORT $LN342@xmlXPathNo

; 12024: 	exprOp = &ctxt->comp->steps[op->ch2];

	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*8]

; 12025:     } else
; 12026: 	return(0);
; 12027: 
; 12028:     if ((exprOp != NULL) &&
; 12029: 	(exprOp->op == XPATH_OP_VALUE) &&
; 12030: 	(exprOp->value4 != NULL) &&

	test	eax, eax
	je	SHORT $LN342@xmlXPathNo
	cmp	DWORD PTR [eax], 11			; 0000000bH
	jne	SHORT $LN342@xmlXPathNo
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN342@xmlXPathNo
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN342@xmlXPathNo

; 12031: 	(((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))
; 12032:     {
; 12033:         double floatval = ((xmlXPathObjectPtr) exprOp->value4)->floatval;

	movsd	xmm1, QWORD PTR [eax+16]

; 12034: 
; 12035: 	/*
; 12036: 	* We have a "[n]" predicate here.
; 12037: 	* TODO: Unfortunately this simplistic test here is not
; 12038: 	* able to detect a position() predicate in compound
; 12039: 	* expressions like "[@attr = 'a" and position() = 1],
; 12040: 	* and even not the usage of position() in
; 12041: 	* "[position() = 1]"; thus - obviously - a position-range,
; 12042: 	* like it "[position() < 5]", is also not detected.
; 12043: 	* Maybe we could rewrite the AST to ease the optimization.
; 12044: 	*/
; 12045: 
; 12046:         if ((floatval > INT_MIN) && (floatval < INT_MAX)) {

	comisd	xmm1, QWORD PTR __real@c1e0000000000000
	jbe	SHORT $LN342@xmlXPathNo
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, xmm1
	jbe	SHORT $LN342@xmlXPathNo

; 12047: 	    *maxPos = (int) floatval;

	cvttsd2si edi, xmm1
	mov	DWORD PTR _maxPos$1$[ebp], edi
	movd	xmm0, edi

; 12048:             if (floatval == (double) *maxPos)

	mov	edi, DWORD PTR _xpctxt$1$[ebp]
	cvtdq2pd xmm0, xmm0
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN342@xmlXPathNo

; 12262: 	if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {
; 12263: 	    if (predOp->ch1 != -1) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, -1
	je	SHORT $LN40@xmlXPathNo

; 12264: 		/*
; 12265: 		* Use the next inner predicate operator.
; 12266: 		*/
; 12267: 		predOp = &ctxt->comp->steps[predOp->ch1];

	lea	eax, DWORD PTR [eax+eax*4]

; 12268: 		hasPredicateRange = 1;

	mov	DWORD PTR _hasPredicateRange$1$[ebp], 1
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _predOp$1$[ebp], edx

; 12269: 	    } else {

	jmp	SHORT $LN41@xmlXPathNo
$LN40@xmlXPathNo:

; 12270: 		/*
; 12271: 		* There's no other predicate than the [n] predicate.
; 12272: 		*/
; 12273: 		predOp = NULL;

	xor	edx, edx

; 12274: 		hasAxisRange = 1;

	mov	DWORD PTR _hasAxisRange$1$[ebp], 1
	mov	DWORD PTR _predOp$1$[ebp], edx

; 12048:             if (floatval == (double) *maxPos)

	jmp	SHORT $LN41@xmlXPathNo
$LN342@xmlXPathNo:

; 12275: 	    }
; 12276: 	}
; 12277:     }
; 12278:     breakOnFirstHit = ((toBool) && (predOp == NULL)) ? 1 : 0;

	mov	edx, ecx
$LN41@xmlXPathNo:
	cmp	DWORD PTR _toBool$[ebp], 0
	je	SHORT $LN241@xmlXPathNo
	mov	DWORD PTR _breakOnFirstHit$1$[ebp], 1
	test	edx, edx
	je	SHORT $LN242@xmlXPathNo
$LN241@xmlXPathNo:
	mov	DWORD PTR _breakOnFirstHit$1$[ebp], 0
$LN242@xmlXPathNo:

; 12279:     /*
; 12280:     * Axis traversal -----------------------------------------------------
; 12281:     */
; 12282:     /*
; 12283:      * 2.3 Node Tests
; 12284:      *  - For the attribute axis, the principal node type is attribute.
; 12285:      *  - For the namespace axis, the principal node type is namespace.
; 12286:      *  - For other axes, the principal node type is element.
; 12287:      *
; 12288:      * A node test * is true for any node of the
; 12289:      * principal node type. For example, child::* will
; 12290:      * select all element children of the context node
; 12291:      */
; 12292:     oldContextNode = xpctxt->node;

	mov	eax, DWORD PTR [edi+4]

; 12293:     addNode = xmlXPathNodeSetAddUnique;
; 12294:     outSeq = NULL;
; 12295:     seq = NULL;

	xor	esi, esi
	mov	DWORD PTR _oldContextNode$1$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _outSeq$1$[ebp], eax

; 12296:     contextNode = NULL;
; 12297:     contextIdx = 0;

	xor	ecx, ecx
	mov	DWORD PTR _seq$1$[ebp], esi

; 12552: 	    goto error;
; 12553: 
; 12554:         /*
; 12555: 	* Apply predicates.
; 12556: 	*/
; 12557:         if ((predOp != NULL) && (seq->nodeNr > 0)) {

	jmp	SHORT $LL4@xmlXPathNo
$LN314@xmlXPathNo:

; 12606: 	    } else if (seq->nodeNr > 0) {

	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	npad	8
$LL312@xmlXPathNo:

; 12298: 
; 12299: 
; 12300:     while (((contextIdx < contextSeq->nodeNr) || (contextNode != NULL)) &&

	mov	esi, DWORD PTR _seq$1$[ebp]
$LN357@xmlXPathNo:
	mov	edi, DWORD PTR _xpctxt$1$[ebp]
	npad	10
$LL4@xmlXPathNo:
	mov	eax, DWORD PTR _contextSeq$1$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN311@xmlXPathNo
	cmp	DWORD PTR [ebx+8], 0
	jne	$LN311@xmlXPathNo

; 12301:            (ctxt->error == XPATH_EXPRESSION_OK)) {
; 12302: 	xpctxt->node = contextSeq->nodeTab[contextIdx++];

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR _contextIdx$1$[ebp], ecx

; 12303: 
; 12304: 	if (seq == NULL) {

	test	esi, esi
	jne	SHORT $LN44@xmlXPathNo

; 12305: 	    seq = xmlXPathNodeSetCreate(NULL);

	push	esi
	call	_xmlXPathNodeSetCreate
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _seq$1$[ebp], esi

; 12306: 	    if (seq == NULL) {

	test	esi, esi
	je	$LN293@xmlXPathNo
$LN44@xmlXPathNo:
	mov	eax, DWORD PTR _ctxt$[ebp]

; 12309: 	    }
; 12310: 	}
; 12311: 	/*
; 12312: 	* Traverse the axis and test the nodes.
; 12313: 	*/
; 12314: 	pos = 0;

	xor	ebx, ebx

; 12315: 	cur = NULL;

	xor	edi, edi

; 12316: 	hasNsNodes = 0;

	mov	DWORD PTR _hasNsNodes$1$[ebp], ebx
$LL8@xmlXPathNo:

; 12317:         do {
; 12318:             cur = next(ctxt, cur);

	push	edi
	push	eax
	call	DWORD PTR _next$1$[ebp]
	mov	edi, eax
	add	esp, 8

; 12319:             if (cur == NULL)

	test	edi, edi
	je	$LN7@xmlXPathNo

; 12320:                 break;
; 12321: 
; 12322: 	    /*
; 12323: 	    * QUESTION TODO: What does the "first" and "last" stuff do?
; 12324: 	    */
; 12325:             if ((first != NULL) && (*first != NULL)) {

	mov	eax, DWORD PTR _first$1$[ebp]
	test	eax, eax
	je	SHORT $LN334@xmlXPathNo
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN334@xmlXPathNo

; 12326: 		if (*first == cur)

	cmp	ecx, edi
	je	$LN7@xmlXPathNo

; 12327: 		    break;
; 12328: 		if (((total % 256) == 0) &&

	mov	edx, DWORD PTR _total$1$[ebp]
	mov	eax, edx
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN346@xmlXPathNo
	dec	eax
	or	eax, -256				; ffffff00H
	add	eax, 1
$LN346@xmlXPathNo:
	jne	SHORT $LN48@xmlXPathNo
	push	edi
	push	ecx
	call	_xmlXPathCmpNodesExt
	add	esp, 8
	test	eax, eax
	jns	$LN7@xmlXPathNo
$LN334@xmlXPathNo:

; 12329: #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
; 12330: 		    (xmlXPathCmpNodesExt(*first, cur) >= 0))
; 12331: #else
; 12332: 		    (xmlXPathCmpNodes(*first, cur) >= 0))
; 12333: #endif
; 12334: 		{
; 12335: 		    break;
; 12336: 		}
; 12337: 	    }
; 12338: 	    if ((last != NULL) && (*last != NULL)) {

	mov	edx, DWORD PTR _total$1$[ebp]
$LN48@xmlXPathNo:
	mov	eax, DWORD PTR _last$1$[ebp]
	test	eax, eax
	je	SHORT $LN51@xmlXPathNo
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN51@xmlXPathNo

; 12339: 		if (*last == cur)

	cmp	ecx, edi
	je	$LN7@xmlXPathNo

; 12340: 		    break;
; 12341: 		if (((total % 256) == 0) &&

	mov	eax, edx
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN347@xmlXPathNo
	dec	eax
	or	eax, -256				; ffffff00H
	add	eax, 1
$LN347@xmlXPathNo:
	jne	SHORT $LN51@xmlXPathNo
	push	ecx
	push	edi
	call	_xmlXPathCmpNodesExt
	add	esp, 8
	test	eax, eax
	jns	$LN7@xmlXPathNo
$LN51@xmlXPathNo:

; 12342: #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
; 12343: 		    (xmlXPathCmpNodesExt(cur, *last) >= 0))
; 12344: #else
; 12345: 		    (xmlXPathCmpNodes(cur, *last) >= 0))
; 12346: #endif
; 12347: 		{
; 12348: 		    break;
; 12349: 		}
; 12350: 	    }
; 12351: 
; 12352:             total++;

	inc	DWORD PTR _total$1$[ebp]

; 12353: 
; 12354: #ifdef DEBUG_STEP
; 12355:             xmlGenericError(xmlGenericErrorContext, " %s", cur->name);
; 12356: #endif
; 12357: 
; 12358: 	    switch (test) {

	mov	eax, DWORD PTR _test$1$[ebp]
	cmp	eax, 5
	ja	$LN6@xmlXPathNo
	jmp	DWORD PTR $LN369@xmlXPathNo[eax*4]
$LN53@xmlXPathNo:

; 12363:                 case NODE_TEST_TYPE:
; 12364: 		    if (type == NODE_TYPE_NODE) {

	mov	ecx, DWORD PTR _type$1$[ebp]
	mov	eax, DWORD PTR [edi+4]
	test	ecx, ecx
	jne	SHORT $LN54@xmlXPathNo

; 12365: 			switch (cur->type) {

	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN6@xmlXPathNo
	movzx	eax, BYTE PTR $LN306@xmlXPathNo[eax]
	jmp	DWORD PTR $LN370@xmlXPathNo[eax*4]
$LN63@xmlXPathNo:

; 12366: 			    case XML_DOCUMENT_NODE:
; 12367: 			    case XML_HTML_DOCUMENT_NODE:
; 12368: #ifdef LIBXML_DOCB_ENABLED
; 12369: 			    case XML_DOCB_DOCUMENT_NODE:
; 12370: #endif
; 12371: 			    case XML_ELEMENT_NODE:
; 12372: 			    case XML_ATTRIBUTE_NODE:
; 12373: 			    case XML_PI_NODE:
; 12374: 			    case XML_COMMENT_NODE:
; 12375: 			    case XML_CDATA_SECTION_NODE:
; 12376: 			    case XML_TEXT_NODE:
; 12377: 				XP_TEST_HIT
; 12378: 				break;
; 12379: 			    case XML_NAMESPACE_DECL: {
; 12380: 				if (axis == AXIS_NAMESPACE) {

	cmp	DWORD PTR _axis$1$[ebp], 9
	jne	SHORT $LN64@xmlXPathNo

; 12381: 				    XP_TEST_HIT_NS

	cmp	DWORD PTR _hasAxisRange$1$[ebp], 0
	je	SHORT $LN66@xmlXPathNo
	inc	ebx
	cmp	ebx, DWORD PTR _maxPos$1$[ebp]
	jne	$LN6@xmlXPathNo
$LN261@xmlXPathNo:

; 12511: 
; 12512: 	goto apply_predicates;
; 12513: 
; 12514: axis_range_end: /* ----------------------------------------------------- */
; 12515: 	/*
; 12516: 	* We have a "/foo[n]", and position() = n was reached.
; 12517: 	* Note that we can have as well "/foo/::parent::foo[1]", so
; 12518: 	* a duplicate-aware merge is still needed.
; 12519: 	* Merge with the result.
; 12520: 	*/
; 12521: 	if (outSeq == NULL) {

	push	edi
	mov	edi, DWORD PTR _xpctxt$1$[ebp]
	push	DWORD PTR [edi+4]
	push	esi
	call	_xmlXPathNodeSetAddNs
	add	esp, 12					; 0000000cH
	jmp	$LN364@xmlXPathNo
$LN66@xmlXPathNo:

; 12502:                                 }
; 12503:                             }
; 12504:                             break;
; 12505:                         default:
; 12506:                             break;
; 12507:                     }
; 12508:                     break;
; 12509: 	    } /* switch(test) */
; 12510:         } while ((cur != NULL) && (ctxt->error == XPATH_EXPRESSION_OK));

	mov	eax, DWORD PTR _xpctxt$1$[ebp]
	push	edi
	mov	DWORD PTR _hasNsNodes$1$[ebp], 1
	push	DWORD PTR [eax+4]
	push	esi
	call	_xmlXPathNodeSetAddNs
	add	esp, 12					; 0000000cH
	jmp	$LN355@xmlXPathNo
$LN64@xmlXPathNo:

; 12382: 				} else {
; 12383: 	                            hasNsNodes = 1;

	mov	DWORD PTR _hasNsNodes$1$[ebp], 1

; 12384: 				    XP_TEST_HIT
; 12385: 				}
; 12386: 				break;
; 12387:                             }
; 12388: 			    default:
; 12389: 				break;
; 12390: 			}
; 12391: 		    } else if (cur->type == (xmlElementType) type) {

	jmp	SHORT $LN56@xmlXPathNo
$LN54@xmlXPathNo:
	cmp	eax, ecx
	jne	SHORT $LN79@xmlXPathNo

; 12392: 			if (cur->type == XML_NAMESPACE_DECL)

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN56@xmlXPathNo

; 12393: 			    XP_TEST_HIT_NS

	cmp	DWORD PTR _hasAxisRange$1$[ebp], 0
	je	SHORT $LN66@xmlXPathNo
	inc	ebx
	cmp	ebx, DWORD PTR _maxPos$1$[ebp]
	je	SHORT $LN261@xmlXPathNo
	jmp	$LN6@xmlXPathNo
$LN79@xmlXPathNo:

; 12394: 			else
; 12395: 			    XP_TEST_HIT
; 12396: 		    } else if ((type == NODE_TYPE_TEXT) &&

	cmp	ecx, 3
	jne	$LN6@xmlXPathNo
	cmp	eax, 4
	jne	$LN6@xmlXPathNo

; 12397: 			 (cur->type == XML_CDATA_SECTION_NODE))
; 12398: 		    {
; 12399: 			XP_TEST_HIT
; 12400: 		    }
; 12401: 		    break;

	jmp	SHORT $LN56@xmlXPathNo
$LN102@xmlXPathNo:

; 12402:                 case NODE_TEST_PI:
; 12403:                     if ((cur->type == XML_PI_NODE) &&

	cmp	DWORD PTR [edi+4], 7
	jne	$LN6@xmlXPathNo
	mov	eax, DWORD PTR _name$1$[ebp]
	test	eax, eax
	je	SHORT $LN56@xmlXPathNo
	push	DWORD PTR [edi+8]
	push	eax

; 12404:                         ((name == NULL) || xmlStrEqual(name, cur->name)))
; 12405: 		    {
; 12406: 			XP_TEST_HIT
; 12407:                     }
; 12408:                     break;

	jmp	SHORT $LN365@xmlXPathNo
$LN111@xmlXPathNo:

; 12409:                 case NODE_TEST_ALL:
; 12410:                     if (axis == AXIS_ATTRIBUTE) {

	mov	ecx, DWORD PTR _axis$1$[ebp]
	cmp	ecx, 3
	jne	SHORT $LN112@xmlXPathNo

; 12411:                         if (cur->type == XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [edi+4], 2
$LN366@xmlXPathNo:

; 12502:                                 }
; 12503:                             }
; 12504:                             break;
; 12505:                         default:
; 12506:                             break;
; 12507:                     }
; 12508:                     break;
; 12509: 	    } /* switch(test) */
; 12510:         } while ((cur != NULL) && (ctxt->error == XPATH_EXPRESSION_OK));

	jne	$LN6@xmlXPathNo
	cmp	DWORD PTR _prefix$1$[ebp], 0
	je	SHORT $LN56@xmlXPathNo
$LN166@xmlXPathNo:
	mov	eax, DWORD PTR [edi+36]
$LN184@xmlXPathNo:
	test	eax, eax
	je	$LN6@xmlXPathNo
	push	DWORD PTR [eax+8]
	push	DWORD PTR _URI$1$[ebp]
$LN365@xmlXPathNo:
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlXPathNo
$LN56@xmlXPathNo:
	cmp	DWORD PTR _hasAxisRange$1$[ebp], 0
	je	$LN176@xmlXPathNo
	inc	ebx
	cmp	ebx, DWORD PTR _maxPos$1$[ebp]
	jne	$LN6@xmlXPathNo

; 12511: 
; 12512: 	goto apply_predicates;
; 12513: 
; 12514: axis_range_end: /* ----------------------------------------------------- */
; 12515: 	/*
; 12516: 	* We have a "/foo[n]", and position() = n was reached.
; 12517: 	* Note that we can have as well "/foo/::parent::foo[1]", so
; 12518: 	* a duplicate-aware merge is still needed.
; 12519: 	* Merge with the result.
; 12520: 	*/
; 12521: 	if (outSeq == NULL) {

	push	edi
	push	esi
	call	_xmlXPathNodeSetAddUnique
	mov	edi, DWORD PTR _xpctxt$1$[ebp]
	add	esp, 8
$LN364@xmlXPathNo:
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jns	SHORT $axis_range_end$371
	mov	DWORD PTR [ebx+8], 15			; 0000000fH
$axis_range_end$371:
	mov	eax, DWORD PTR _outSeq$1$[ebp]
	test	eax, eax
	jne	$LN212@xmlXPathNo

; 12522: 	    outSeq = seq;

	mov	DWORD PTR _outSeq$1$[ebp], esi

; 12523: 	    seq = NULL;

	xor	esi, esi
	mov	DWORD PTR _seq$1$[ebp], esi

; 12524: 	} else

	jmp	$LN213@xmlXPathNo
$LN112@xmlXPathNo:

; 12412: 			{
; 12413:                             if (prefix == NULL)
; 12414: 			    {
; 12415: 				XP_TEST_HIT
; 12416:                             } else if ((cur->ns != NULL) &&
; 12417: 				(xmlStrEqual(URI, cur->ns->href)))
; 12418: 			    {
; 12419: 				XP_TEST_HIT
; 12420:                             }
; 12421:                         }
; 12422:                     } else if (axis == AXIS_NAMESPACE) {

	cmp	ecx, 9
	jne	SHORT $LN130@xmlXPathNo

; 12423:                         if (cur->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	$LN6@xmlXPathNo

; 12424: 			{
; 12425: 			    XP_TEST_HIT_NS

	cmp	DWORD PTR _hasAxisRange$1$[ebp], 0
	je	$LN66@xmlXPathNo
	inc	ebx
	cmp	ebx, DWORD PTR _maxPos$1$[ebp]
	je	$LN261@xmlXPathNo
	jmp	$LN6@xmlXPathNo
$LN130@xmlXPathNo:

; 12426:                         }
; 12427:                     } else {
; 12428:                         if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [edi+4], 1

; 12429:                             if (prefix == NULL)
; 12430: 			    {
; 12431: 				XP_TEST_HIT

	jmp	$LN366@xmlXPathNo
$LN155@xmlXPathNo:

; 12432: 
; 12433:                             } else if ((cur->ns != NULL) &&
; 12434: 				(xmlStrEqual(URI, cur->ns->href)))
; 12435: 			    {
; 12436: 				XP_TEST_HIT
; 12437:                             }
; 12438:                         }
; 12439:                     }
; 12440:                     break;
; 12441:                 case NODE_TEST_NS:{
; 12442:                         TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	12442					; 0000309aH
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 12443:                         break;

	jmp	$LN6@xmlXPathNo
$LN156@xmlXPathNo:

; 12444:                     }
; 12445:                 case NODE_TEST_NAME:
; 12446:                     if (axis == AXIS_ATTRIBUTE) {

	mov	ecx, DWORD PTR _axis$1$[ebp]
	cmp	ecx, 3
	jne	SHORT $LN157@xmlXPathNo

; 12447:                         if (cur->type != XML_ATTRIBUTE_NODE)

	cmp	DWORD PTR [edi+4], 2
	jne	$LN6@xmlXPathNo

; 12448: 			    break;
; 12449: 		    } else if (axis == AXIS_NAMESPACE) {

	lea	eax, DWORD PTR [ecx-1]
	jmp	SHORT $LN163@xmlXPathNo
$LN157@xmlXPathNo:
	cmp	ecx, 9
	jne	SHORT $LN160@xmlXPathNo

; 12450:                         if (cur->type != XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	$LN6@xmlXPathNo

; 12451: 			    break;
; 12452: 		    } else {

	lea	eax, DWORD PTR [ecx+9]
	jmp	SHORT $LN163@xmlXPathNo
$LN160@xmlXPathNo:

; 12453: 		        if (cur->type != XML_ELEMENT_NODE)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	jne	$LN6@xmlXPathNo
$LN163@xmlXPathNo:

; 12454: 			    break;
; 12455: 		    }
; 12456:                     switch (cur->type) {

	sub	eax, 1
	je	SHORT $LN164@xmlXPathNo
	sub	eax, 1
	je	SHORT $LN182@xmlXPathNo
	sub	eax, 16					; 00000010H
	jne	$LN6@xmlXPathNo

; 12484:                                         if ((attr->ns != NULL) &&
; 12485:                                             (xmlStrEqual(URI,
; 12486: 					      attr->ns->href)))
; 12487: 					{
; 12488: 					    XP_TEST_HIT
; 12489:                                         }
; 12490:                                     }
; 12491:                                 }
; 12492:                                 break;
; 12493:                             }
; 12494:                         case XML_NAMESPACE_DECL:
; 12495:                             if (cur->type == XML_NAMESPACE_DECL) {
; 12496:                                 xmlNsPtr ns = (xmlNsPtr) cur;
; 12497: 
; 12498:                                 if ((ns->prefix != NULL) && (name != NULL)
; 12499:                                     && (xmlStrEqual(ns->prefix, name)))

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN6@xmlXPathNo
	mov	ecx, DWORD PTR _name$1$[ebp]
	test	ecx, ecx
	je	$LN6@xmlXPathNo
	push	ecx
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN6@xmlXPathNo

; 12500: 				{
; 12501: 				    XP_TEST_HIT_NS

	cmp	DWORD PTR _hasAxisRange$1$[ebp], 0
	je	$LN66@xmlXPathNo
	inc	ebx
	cmp	ebx, DWORD PTR _maxPos$1$[ebp]
	je	$LN261@xmlXPathNo
	jmp	SHORT $LN6@xmlXPathNo
$LN182@xmlXPathNo:

; 12465:                                     if ((cur->ns != NULL) &&
; 12466:                                         (xmlStrEqual(URI, cur->ns->href)))
; 12467: 				    {
; 12468: 					XP_TEST_HIT
; 12469:                                     }
; 12470:                                 }
; 12471:                             }
; 12472:                             break;
; 12473:                         case XML_ATTRIBUTE_NODE:{
; 12474:                                 xmlAttrPtr attr = (xmlAttrPtr) cur;
; 12475: 
; 12476:                                 if (xmlStrEqual(name, attr->name)) {

	push	DWORD PTR [edi+8]
	push	DWORD PTR _name$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlXPathNo

; 12477:                                     if (prefix == NULL) {

	cmp	DWORD PTR _prefix$1$[ebp], 0
	mov	eax, DWORD PTR [edi+36]
	jne	$LN184@xmlXPathNo

; 12478:                                         if ((attr->ns == NULL) ||

	test	eax, eax
	je	$LN56@xmlXPathNo
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@xmlXPathNo

; 12479:                                             (attr->ns->prefix == NULL))
; 12480: 					{
; 12481: 					    XP_TEST_HIT
; 12482:                                         }
; 12483:                                     } else {

	jmp	$LN56@xmlXPathNo
$LN164@xmlXPathNo:

; 12457:                         case XML_ELEMENT_NODE:
; 12458:                             if (xmlStrEqual(name, cur->name)) {

	push	DWORD PTR [edi+8]
	push	DWORD PTR _name$1$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlXPathNo

; 12459:                                 if (prefix == NULL) {

	cmp	DWORD PTR _prefix$1$[ebp], 0
	jne	$LN166@xmlXPathNo

; 12460:                                     if (cur->ns == NULL)

	cmp	DWORD PTR [edi+36], 0
	jne	SHORT $LN6@xmlXPathNo

; 12461: 				    {
; 12462: 					XP_TEST_HIT
; 12463:                                     }
; 12464:                                 } else {

	jmp	$LN56@xmlXPathNo
$LN176@xmlXPathNo:

; 12502:                                 }
; 12503:                             }
; 12504:                             break;
; 12505:                         default:
; 12506:                             break;
; 12507:                     }
; 12508:                     break;
; 12509: 	    } /* switch(test) */
; 12510:         } while ((cur != NULL) && (ctxt->error == XPATH_EXPRESSION_OK));

	push	edi
	push	esi
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
$LN355@xmlXPathNo:
	test	eax, eax
	jns	SHORT $LN180@xmlXPathNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 15			; 0000000fH
$LN180@xmlXPathNo:
	cmp	DWORD PTR _breakOnFirstHit$1$[ebp], 0
	jne	$first_hit$372
$LN6@xmlXPathNo:
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN7@xmlXPathNo
	mov	esi, DWORD PTR _seq$1$[ebp]
	jmp	$LL8@xmlXPathNo
$LN212@xmlXPathNo:

; 12525: 	    outSeq = mergeAndClear(outSeq, seq, 0);

	push	0
	push	esi
	push	eax
	call	DWORD PTR _mergeAndClear$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _outSeq$1$[ebp], eax
$LN213@xmlXPathNo:

; 12526: 	/*
; 12527: 	* Break if only a true/false result was requested.
; 12528: 	*/
; 12529: 	if (toBool)

	cmp	DWORD PTR _toBool$[ebp], 0
	jne	$LN311@xmlXPathNo

; 12530: 	    break;
; 12531: 	continue;

	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	jmp	$LL4@xmlXPathNo
$LN7@xmlXPathNo:
$apply_predicates$373:

; 12543: 	break;
; 12544: 
; 12545: #ifdef DEBUG_STEP
; 12546: 	if (seq != NULL)
; 12547: 	    nbMatches += seq->nodeNr;
; 12548: #endif
; 12549: 
; 12550: apply_predicates: /* --------------------------------------------------- */
; 12551:         if (ctxt->error != XPATH_EXPRESSION_OK)

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _seq$1$[ebp]
	cmp	DWORD PTR [ebx+8], 0
	jne	$error$374

; 12552: 	    goto error;
; 12553: 
; 12554:         /*
; 12555: 	* Apply predicates.
; 12556: 	*/
; 12557:         if ((predOp != NULL) && (seq->nodeNr > 0)) {

	mov	edx, DWORD PTR _predOp$1$[ebp]
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	test	edx, edx
	je	$LN300@xmlXPathNo
	test	esi, esi
	jle	$LL312@xmlXPathNo

; 12558: 	    /*
; 12559: 	    * E.g. when we have a "/foo[some expression][n]".
; 12560: 	    */
; 12561: 	    /*
; 12562: 	    * QUESTION TODO: The old predicate evaluation took into
; 12563: 	    *  account location-sets.
; 12564: 	    *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)
; 12565: 	    *  Do we expect such a set here?
; 12566: 	    *  All what I learned now from the evaluation semantics
; 12567: 	    *  does not indicate that a location-set will be processed
; 12568: 	    *  here, so this looks OK.
; 12569: 	    */
; 12570: 	    /*
; 12571: 	    * Iterate over all predicates, starting with the outermost
; 12572: 	    * predicate.
; 12573: 	    * TODO: Problem: we cannot execute the inner predicates first
; 12574: 	    *  since we cannot go back *up* the operator tree!
; 12575: 	    *  Options we have:
; 12576: 	    *  1) Use of recursive functions (like is it currently done
; 12577: 	    *     via xmlXPathCompOpEval())
; 12578: 	    *  2) Add a predicate evaluation information stack to the
; 12579: 	    *     context struct
; 12580: 	    *  3) Change the way the operators are linked; we need a
; 12581: 	    *     "parent" field on xmlXPathStepOp
; 12582: 	    *
; 12583: 	    * For the moment, I'll try to solve this with a recursive
; 12584: 	    * function: xmlXPathCompOpEvalPredicate().
; 12585: 	    */
; 12586: 	    size = seq->nodeNr;
; 12587: 	    if (hasPredicateRange != 0)

	cmp	DWORD PTR _hasPredicateRange$1$[ebp], 0
	push	DWORD PTR _hasNsNodes$1$[ebp]
	je	SHORT $LN220@xmlXPathNo

; 12588: 		newSize = xmlXPathCompOpEvalPositionalPredicate(ctxt,

	mov	eax, DWORD PTR _maxPos$1$[ebp]
	push	eax
	push	eax
	push	esi
	push	edi
	push	edx
	push	ebx
	call	_xmlXPathCompOpEvalPositionalPredicate
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN356@xmlXPathNo
$LN220@xmlXPathNo:

; 12589: 		    predOp, seq, size, maxPos, maxPos, hasNsNodes);
; 12590: 	    else
; 12591: 		newSize = xmlXPathCompOpEvalPredicate(ctxt,

	push	esi
	push	edi
	push	edx
	push	ebx
	call	_xmlXPathCompOpEvalPredicate
	add	esp, 20					; 00000014H
$LN356@xmlXPathNo:

; 12592: 		    predOp, seq, size, hasNsNodes);
; 12593: 
; 12594: 	    if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	mov	ecx, eax
	jne	$LN296@xmlXPathNo

; 12596: 		goto error;
; 12597: 	    }
; 12598: 	    /*
; 12599: 	    * Add the filtered set of nodes to the result node set.
; 12600: 	    */
; 12601: 	    if (newSize == 0) {

	test	ecx, ecx
	jne	SHORT $LN223@xmlXPathNo

; 12602: 		/*
; 12603: 		* The predicates filtered all nodes out.
; 12604: 		*/
; 12605: 		xmlXPathNodeSetClear(seq, hasNsNodes);

	push	DWORD PTR _hasNsNodes$1$[ebp]
	mov	esi, DWORD PTR _seq$1$[ebp]
	push	esi
	call	_xmlXPathNodeSetClear
	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	add	esp, 8
	jmp	$LN357@xmlXPathNo
$LN223@xmlXPathNo:

; 12606: 	    } else if (seq->nodeNr > 0) {

	cmp	DWORD PTR [edi], 0
	jle	$LN314@xmlXPathNo

; 12607: 		/*
; 12608: 		* Add to result set.
; 12609: 		*/
; 12610: 		if (outSeq == NULL) {

	mov	edx, DWORD PTR _outSeq$1$[ebp]
	test	edx, edx
	jne	SHORT $LN226@xmlXPathNo

; 12611: 		    if (size != newSize) {

	cmp	esi, ecx
	je	SHORT $LN228@xmlXPathNo

; 12612: 			/*
; 12613: 			* We need to merge and clear here, since
; 12614: 			* the sequence will contained NULLed entries.
; 12615: 			*/
; 12616: 			outSeq = mergeAndClear(NULL, seq, 1);

	mov	esi, DWORD PTR _seq$1$[ebp]
	push	1
	push	esi
	push	edx

; 12617: 		    } else {

	jmp	SHORT $LN358@xmlXPathNo
$LN228@xmlXPathNo:

; 12618: 			outSeq = seq;
; 12619: 			seq = NULL;

	xor	esi, esi
	mov	DWORD PTR _outSeq$1$[ebp], edi
	mov	DWORD PTR _seq$1$[ebp], esi

; 12620: 		    }
; 12621: 		} else

	jmp	SHORT $LN227@xmlXPathNo
$LN226@xmlXPathNo:

; 12622: 		    outSeq = mergeAndClear(outSeq, seq,

	xor	eax, eax
	cmp	esi, ecx
	mov	esi, DWORD PTR _seq$1$[ebp]
	setne	al
	push	eax
	push	esi
	push	edx
$LN358@xmlXPathNo:

; 12623: 			(size != newSize) ? 1: 0);
; 12624: 		/*
; 12625: 		* Break if only a true/false result was requested.
; 12626: 		*/
; 12627: 		if (toBool)

	call	DWORD PTR _mergeAndClear$1$[ebp]
	mov	DWORD PTR _outSeq$1$[ebp], eax
	add	esp, 12					; 0000000cH
$LN227@xmlXPathNo:
	cmp	DWORD PTR _toBool$[ebp], 0
	jne	SHORT $LN311@xmlXPathNo

; 12628: 		    break;
; 12629: 	    }

	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	jmp	$LN357@xmlXPathNo
$LN300@xmlXPathNo:

; 12630:         } else if (seq->nodeNr > 0) {

	test	esi, esi
	jle	$LL312@xmlXPathNo

; 12631: 	    /*
; 12632: 	    * Add to result set.
; 12633: 	    */
; 12634: 	    if (outSeq == NULL) {

	mov	eax, DWORD PTR _outSeq$1$[ebp]
	test	eax, eax
	jne	SHORT $LN232@xmlXPathNo

; 12635: 		outSeq = seq;
; 12636: 		seq = NULL;
; 12637: 	    } else {

	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	xor	esi, esi
	mov	DWORD PTR _outSeq$1$[ebp], edi
	mov	DWORD PTR _seq$1$[ebp], esi
	jmp	$LN357@xmlXPathNo
$LN232@xmlXPathNo:

; 12638: 		outSeq = mergeAndClear(outSeq, seq, 0);

	mov	esi, DWORD PTR _seq$1$[ebp]
	push	0
	push	esi
	push	eax
	call	DWORD PTR _mergeAndClear$1$[ebp]

; 12639: 	    }
; 12640: 	}
; 12641:     }

	mov	ecx, DWORD PTR _contextIdx$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _outSeq$1$[ebp], eax
	jmp	$LN357@xmlXPathNo
$LN293@xmlXPathNo:

; 12307: 		total = 0;

	mov	DWORD PTR _total$1$[ebp], 0

; 12308: 		goto error;

	jmp	SHORT $LN311@xmlXPathNo
$first_hit$372:

; 12532: 
; 12533: first_hit: /* ---------------------------------------------------------- */
; 12534: 	/*
; 12535: 	* Break if only a true/false result was requested and
; 12536: 	* no predicates existed and a node test succeeded.
; 12537: 	*/
; 12538: 	if (outSeq == NULL) {

	mov	eax, DWORD PTR _outSeq$1$[ebp]
	test	eax, eax
	jne	SHORT $LN215@xmlXPathNo

; 12539: 	    outSeq = seq;
; 12540: 	    seq = NULL;
; 12541: 	} else

	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _outSeq$1$[ebp], esi
	jmp	SHORT $error$374
$LN215@xmlXPathNo:

; 12542: 	    outSeq = mergeAndClear(outSeq, seq, 0);

	push	0
	push	esi
	push	eax
	call	DWORD PTR _mergeAndClear$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _outSeq$1$[ebp], eax
$LN360@xmlXPathNo:

; 12642: 
; 12643: error:
; 12644:     if ((obj->boolval) && (obj->user != NULL)) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
$LN311@xmlXPathNo:
	mov	edi, DWORD PTR _seq$1$[ebp]
$error$374:
	mov	edx, DWORD PTR _obj$1$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN234@xmlXPathNo
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN234@xmlXPathNo

; 12645: 	/*
; 12646: 	* QUESTION TODO: What does this do and why?
; 12647: 	* TODO: Do we have to do this also for the "error"
; 12648: 	* cleanup further down?
; 12649: 	*/
; 12650: 	ctxt->value->boolval = 1;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax+8], 1

; 12651: 	ctxt->value->user = obj->user;

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 12652: 	obj->user = NULL;

	mov	DWORD PTR [edx+28], 0

; 12653: 	obj->boolval = 0;

	mov	DWORD PTR [edx+8], 0
$LN234@xmlXPathNo:

; 12654:     }
; 12655:     xmlXPathReleaseObject(xpctxt, obj);

	mov	esi, DWORD PTR _xpctxt$1$[ebp]
	push	edx
	push	esi
	call	_xmlXPathReleaseObject

; 12656: 
; 12657:     /*
; 12658:     * Ensure we return at least an emtpy set.
; 12659:     */
; 12660:     if (outSeq == NULL) {

	mov	eax, DWORD PTR _outSeq$1$[ebp]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN237@xmlXPathNo

; 12661: 	if ((seq != NULL) && (seq->nodeNr == 0))

	test	edi, edi
	je	SHORT $LN236@xmlXPathNo
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN236@xmlXPathNo

; 12662: 	    outSeq = seq;

	mov	eax, edi
	jmp	SHORT $LN361@xmlXPathNo
$LN52@xmlXPathNo:

; 12359:                 case NODE_TEST_NONE:
; 12360: 		    total = 0;

	mov	DWORD PTR _total$1$[ebp], 0

; 12361:                     STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	12361					; 00003049H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 12362: 		    goto error;

	jmp	$LN360@xmlXPathNo
$LN296@xmlXPathNo:

; 12595: 		total = 0;

	mov	DWORD PTR _total$1$[ebp], 0
	jmp	$error$374
$LN236@xmlXPathNo:

; 12663: 	else
; 12664: 	    outSeq = xmlXPathNodeSetCreate(NULL);

	push	0
	call	_xmlXPathNodeSetCreate
	add	esp, 4
$LN361@xmlXPathNo:

; 12665:         /* XXX what if xmlXPathNodeSetCreate returned NULL here? */
; 12666:     }
; 12667:     if ((seq != NULL) && (seq != outSeq)) {

	mov	DWORD PTR _outSeq$1$[ebp], eax
$LN237@xmlXPathNo:
	test	edi, edi
	je	SHORT $LN238@xmlXPathNo
	cmp	edi, eax
	je	SHORT $LN238@xmlXPathNo

; 12668: 	 xmlXPathFreeNodeSet(seq);

	push	edi
	call	_xmlXPathFreeNodeSet
	add	esp, 4
$LN238@xmlXPathNo:

; 12669:     }
; 12670:     /*
; 12671:     * Hand over the result. Better to push the set also in
; 12672:     * case of errors.
; 12673:     */
; 12674:     valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, outSeq));

	mov	eax, DWORD PTR _outSeq$1$[ebp]
	push	eax
	push	esi
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	ebx
	call	_valuePush

; 12675:     /*
; 12676:     * Reset the context node.
; 12677:     */
; 12678:     xpctxt->node = oldContextNode;
; 12679:     /*
; 12680:     * When traversing the namespace axis in "toBool" mode, it's
; 12681:     * possible that tmpNsList wasn't freed.
; 12682:     */
; 12683:     if (xpctxt->tmpNsList != NULL) {

	mov	ecx, DWORD PTR [esi+120]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _oldContextNode$1$[ebp]
	mov	DWORD PTR [esi+4], eax
	test	ecx, ecx
	je	SHORT $LN239@xmlXPathNo

; 12684:         xmlFree(xpctxt->tmpNsList);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 12685:         xpctxt->tmpNsList = NULL;

	mov	DWORD PTR [esi+120], 0
$LN239@xmlXPathNo:

; 12686:     }
; 12687: 
; 12688: #ifdef DEBUG_STEP
; 12689:     xmlGenericError(xmlGenericErrorContext,
; 12690: 	"\nExamined %d nodes, found %d nodes at that step\n",
; 12691: 	total, nbMatches);
; 12692: #endif
; 12693: 
; 12694:     return(total);

	mov	eax, DWORD PTR _total$1$[ebp]
	pop	edi

; 12695: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlXPathNo:

; 12231: 	xmlXPathReleaseObject(xpctxt, obj);

	push	ecx
	push	edi
	call	_xmlXPathReleaseObject

; 12232:         valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, NULL));

	push	0
	push	edi
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 24					; 00000018H

; 12695: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN303@xmlXPathNo:

; 12216: 	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
; 12217:             break;
; 12218:     }
; 12219: 
; 12220: #ifdef DEBUG_STEP
; 12221:     xmlXPathDebugDumpStepAxis(op,
; 12222: 	(obj->nodesetval != NULL) ? obj->nodesetval->nodeNr : 0);
; 12223: #endif
; 12224: 
; 12225:     if (next == NULL) {
; 12226: 	xmlXPathReleaseObject(xpctxt, obj);

	push	ecx
	push	edi
	call	_xmlXPathReleaseObject

; 12695: }

	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXPathNo:

; 12061: 
; 12062: #define XP_TEST_HIT \
; 12063:     if (hasAxisRange != 0) { \
; 12064: 	if (++pos == maxPos) { \
; 12065: 	    if (addNode(seq, cur) < 0) \
; 12066: 	        ctxt->error = XPATH_MEMORY_ERROR; \
; 12067: 	    goto axis_range_end; } \
; 12068:     } else { \
; 12069: 	if (addNode(seq, cur) < 0) \
; 12070: 	    ctxt->error = XPATH_MEMORY_ERROR; \
; 12071: 	if (breakOnFirstHit) goto first_hit; }
; 12072: 
; 12073: #define XP_TEST_HIT_NS \
; 12074:     if (hasAxisRange != 0) { \
; 12075: 	if (++pos == maxPos) { \
; 12076: 	    hasNsNodes = 1; \
; 12077: 	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
; 12078: 	        ctxt->error = XPATH_MEMORY_ERROR; \
; 12079: 	goto axis_range_end; } \
; 12080:     } else { \
; 12081: 	hasNsNodes = 1; \
; 12082: 	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
; 12083: 	    ctxt->error = XPATH_MEMORY_ERROR; \
; 12084: 	if (breakOnFirstHit) goto first_hit; }
; 12085: 
; 12086:     xmlXPathAxisVal axis = (xmlXPathAxisVal) op->value;
; 12087:     xmlXPathTestVal test = (xmlXPathTestVal) op->value2;
; 12088:     xmlXPathTypeVal type = (xmlXPathTypeVal) op->value3;
; 12089:     const xmlChar *prefix = op->value4;
; 12090:     const xmlChar *name = op->value5;
; 12091:     const xmlChar *URI = NULL;
; 12092: 
; 12093: #ifdef DEBUG_STEP
; 12094:     int nbMatches = 0, prevMatches = 0;
; 12095: #endif
; 12096:     int total = 0, hasNsNodes = 0;
; 12097:     /* The popped object holding the context nodes */
; 12098:     xmlXPathObjectPtr obj;
; 12099:     /* The set of context nodes for the node tests */
; 12100:     xmlNodeSetPtr contextSeq;
; 12101:     int contextIdx;
; 12102:     xmlNodePtr contextNode;
; 12103:     /* The final resulting node set wrt to all context nodes */
; 12104:     xmlNodeSetPtr outSeq;
; 12105:     /*
; 12106:     * The temporary resulting node set wrt 1 context node.
; 12107:     * Used to feed predicate evaluation.
; 12108:     */
; 12109:     xmlNodeSetPtr seq;
; 12110:     xmlNodePtr cur;
; 12111:     /* First predicate operator */
; 12112:     xmlXPathStepOpPtr predOp;
; 12113:     int maxPos; /* The requested position() (when a "[n]" predicate) */
; 12114:     int hasPredicateRange, hasAxisRange, pos, size, newSize;
; 12115:     int breakOnFirstHit;
; 12116: 
; 12117:     xmlXPathTraversalFunction next = NULL;
; 12118:     int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
; 12119:     xmlXPathNodeSetMergeFunction mergeAndClear;
; 12120:     xmlNodePtr oldContextNode;
; 12121:     xmlXPathContextPtr xpctxt = ctxt->context;
; 12122: 
; 12123: 
; 12124:     CHECK_TYPE0(XPATH_NODESET);

	push	11					; 0000000bH
	push	ebx
	call	_xmlXPathErr

; 12695: }

	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN368@xmlXPathNo:
	DD	$LN19@xmlXPathNo
	DD	$LN20@xmlXPathNo
	DD	$LN21@xmlXPathNo
	DD	$LN22@xmlXPathNo
	DD	$LN26@xmlXPathNo
	DD	$LN27@xmlXPathNo
	DD	$LN28@xmlXPathNo
	DD	$LN29@xmlXPathNo
	DD	$LN30@xmlXPathNo
	DD	$LN31@xmlXPathNo
	DD	$LN32@xmlXPathNo
	DD	$LN33@xmlXPathNo
	DD	$LN34@xmlXPathNo
$LN369@xmlXPathNo:
	DD	$LN52@xmlXPathNo
	DD	$LN53@xmlXPathNo
	DD	$LN102@xmlXPathNo
	DD	$LN111@xmlXPathNo
	DD	$LN155@xmlXPathNo
	DD	$LN156@xmlXPathNo
$LN370@xmlXPathNo:
	DD	$LN56@xmlXPathNo
	DD	$LN63@xmlXPathNo
	DD	$LN6@xmlXPathNo
$LN306@xmlXPathNo:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	0
_xmlXPathNodeCollectAndTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsPositionalPredicate
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_maxPos$ = 16						; size = 4
_xmlXPathIsPositionalPredicate PROC			; COMDAT

; 12003: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 15					; 0000000fH
	je	SHORT $LN2@xmlXPathIs

; 12004: 
; 12005:     xmlXPathStepOpPtr exprOp;
; 12006: 
; 12007:     /*
; 12008:     * BIG NOTE: This is not intended for XPATH_OP_FILTER yet!
; 12009:     */
; 12010: 
; 12011:     /*
; 12012:     * If not -1, then ch1 will point to:
; 12013:     * 1) For predicates (XPATH_OP_PREDICATE):
; 12014:     *    - an inner predicate operator
; 12015:     * 2) For filters (XPATH_OP_FILTER):
; 12016:     *    - an inner filter operater OR
; 12017:     *    - an expression selecting the node set.
; 12018:     *      E.g. "key('a', 'b')" or "(//foo | //bar)".
; 12019:     */
; 12020:     if ((op->op != XPATH_OP_PREDICATE) && (op->op != XPATH_OP_FILTER))

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN3@xmlXPathIs
$LN2@xmlXPathIs:

; 12021: 	return(0);
; 12022: 
; 12023:     if (op->ch2 != -1) {

	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, -1
	je	SHORT $LN3@xmlXPathIs

; 12024: 	exprOp = &ctxt->comp->steps[op->ch2];

	mov	eax, DWORD PTR _ctxt$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]

; 12027: 
; 12028:     if ((exprOp != NULL) &&
; 12029: 	(exprOp->op == XPATH_OP_VALUE) &&
; 12030: 	(exprOp->value4 != NULL) &&

	test	eax, eax
	je	SHORT $LN3@xmlXPathIs
	cmp	DWORD PTR [eax], 11			; 0000000bH
	jne	SHORT $LN3@xmlXPathIs
	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN3@xmlXPathIs
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN3@xmlXPathIs

; 12031: 	(((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))
; 12032:     {
; 12033:         double floatval = ((xmlXPathObjectPtr) exprOp->value4)->floatval;

	movsd	xmm1, QWORD PTR [eax+16]

; 12034: 
; 12035: 	/*
; 12036: 	* We have a "[n]" predicate here.
; 12037: 	* TODO: Unfortunately this simplistic test here is not
; 12038: 	* able to detect a position() predicate in compound
; 12039: 	* expressions like "[@attr = 'a" and position() = 1],
; 12040: 	* and even not the usage of position() in
; 12041: 	* "[position() = 1]"; thus - obviously - a position-range,
; 12042: 	* like it "[position() < 5]", is also not detected.
; 12043: 	* Maybe we could rewrite the AST to ease the optimization.
; 12044: 	*/
; 12045: 
; 12046:         if ((floatval > INT_MIN) && (floatval < INT_MAX)) {

	comisd	xmm1, QWORD PTR __real@c1e0000000000000
	jbe	SHORT $LN3@xmlXPathIs
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, xmm1
	jbe	SHORT $LN3@xmlXPathIs

; 12047: 	    *maxPos = (int) floatval;

	mov	eax, DWORD PTR _maxPos$[ebp]
	cvttsd2si ecx, xmm1
	mov	DWORD PTR [eax], ecx
	movd	xmm0, ecx

; 12048:             if (floatval == (double) *maxPos)

	cvtdq2pd xmm0, xmm0
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@xmlXPathIs

; 12049:                 return(1);

	mov	eax, 1

; 12050:         }
; 12051:     }
; 12052:     return(0);
; 12053: }

	pop	ebp
	ret	0
$LN3@xmlXPathIs:

; 12025:     } else
; 12026: 	return(0);

	xor	eax, eax

; 12050:         }
; 12051:     }
; 12052:     return(0);
; 12053: }

	pop	ebp
	ret	0
_xmlXPathIsPositionalPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalPositionalPredicate
_TEXT	SEGMENT
_oldpp$1$ = -52						; size = 4
_oldcs$1$ = -48						; size = 4
_oldContextDoc$1$ = -44					; size = 4
_oldContextNode$1$ = -40				; size = 4
tv653 = -36						; size = 4
_ret$1$ = -32						; size = 4
_exprOp$1$ = -28					; size = 4
_pos$1$ = -24						; size = 4
_res$1$ = -20						; size = 4
_contextPos$1$ = -16					; size = 4
_contextSize$1$ = -12					; size = 4
_newContextSize$1$ = -8					; size = 4
_i$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xpctxt$1$ = 12						; size = 4
_op$ = 12						; size = 4
_set$ = 16						; size = 4
_contextSize$ = 20					; size = 4
_minPos$ = 24						; size = 4
_maxPos$ = 28						; size = 4
_hasNsNodes$ = 32					; size = 4
_xmlXPathCompOpEvalPositionalPredicate PROC		; COMDAT

; 11804: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _op$[ebp]
	mov	ebx, DWORD PTR _hasNsNodes$[ebp]
	mov	edx, DWORD PTR _set$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, -1
	je	SHORT $LN71@xmlXPathCo

; 11806: 	xmlXPathCompExprPtr comp = ctxt->comp;
; 11807: 	if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {
; 11808: 	    /*
; 11809: 	    * TODO: raise an internal error.
; 11810: 	    */
; 11811: 	}
; 11812: 	contextSize = xmlXPathCompOpEvalPredicate(ctxt,

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	ebx
	push	DWORD PTR _contextSize$[ebp]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalPredicate
	add	esp, 20					; 00000014H
	mov	DWORD PTR _contextSize$1$[ebp], eax

; 11813: 	    &comp->steps[op->ch1], set, contextSize, hasNsNodes);
; 11814: 	CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN69@xmlXPathCo

; 11815: 	if (contextSize <= 0)

	test	eax, eax
	jg	SHORT $LN76@xmlXPathCo
$LN69@xmlXPathCo:
	pop	edi

; 11995:     }
; 11996:     return(contextSize);
; 11997: }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@xmlXPathCo:

; 11805:     if (op->ch1 != -1) {

	mov	eax, DWORD PTR _contextSize$[ebp]
	mov	DWORD PTR _contextSize$1$[ebp], eax

; 11815: 	if (contextSize <= 0)

	jmp	SHORT $LN10@xmlXPathCo
$LN76@xmlXPathCo:
	mov	edx, DWORD PTR _set$[ebp]
$LN10@xmlXPathCo:

; 11816: 	    return(0);
; 11817:     }
; 11818:     /*
; 11819:     * Check if the node set contains a sufficient number of nodes for
; 11820:     * the requested range.
; 11821:     */
; 11822:     if (contextSize < minPos) {

	cmp	eax, DWORD PTR _minPos$[ebp]
	jge	SHORT $LN11@xmlXPathCo

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);

	push	ebx
	push	0
	push	edx
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 12					; 0000000cH

; 11823: 	xmlXPathNodeSetClear(set, hasNsNodes);
; 11824: 	return(0);

	xor	eax, eax
	pop	edi

; 11995:     }
; 11996:     return(contextSize);
; 11997: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPathCo:

; 11825:     }
; 11826:     if (op->ch2 == -1) {

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, -1
	je	$LN1@xmlXPathCo

; 11827: 	/*
; 11828: 	* TODO: Can this ever happen?
; 11829: 	*/
; 11830: 	return (contextSize);
; 11831:     } else {
; 11832: 	xmlDocPtr oldContextDoc;
; 11833:         int oldcs, oldpp;
; 11834: 	int i, pos = 0, newContextSize = 0, contextPos = 0, res;
; 11835: 	xmlXPathStepOpPtr exprOp;
; 11836: 	xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;
; 11837: 	xmlNodePtr oldContextNode, contextNode = NULL;
; 11838: 	xmlXPathContextPtr xpctxt = ctxt->context;

	mov	edx, DWORD PTR [esi+12]

; 11839:         int frame;
; 11840: 
; 11841: #ifdef LIBXML_XPTR_ENABLED
; 11842: 	    /*
; 11843: 	    * URGENT TODO: Check the following:
; 11844: 	    *  We don't expect location sets if evaluating prediates, right?
; 11845: 	    *  Only filters should expect location sets, right?
; 11846: 	*/
; 11847: #endif /* LIBXML_XPTR_ENABLED */
; 11848: 
; 11849: 	/*
; 11850: 	* Save old context.
; 11851: 	*/
; 11852: 	oldContextNode = xpctxt->node;
; 11853: 	oldContextDoc = xpctxt->doc;
; 11854:         oldcs = xpctxt->contextSize;
; 11855:         oldpp = xpctxt->proximityPosition;
; 11856: 	/*
; 11857: 	* Get the expression of this predicate.
; 11858: 	*/
; 11859: 	exprOp = &ctxt->comp->steps[op->ch2];

	lea	ecx, DWORD PTR [ecx+ecx*4]
	xor	ebx, ebx
	mov	DWORD PTR _pos$1$[ebp], 0

; 11860: 	for (i = 0; i < set->nodeNr; i++) {

	xor	edi, edi
	mov	DWORD PTR _newContextSize$1$[ebp], 0
	mov	DWORD PTR _contextPos$1$[ebp], 0
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldContextNode$1$[ebp], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _oldContextDoc$1$[ebp], eax
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _oldcs$1$[ebp], eax
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _oldpp$1$[ebp], eax
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _xpctxt$1$[ebp], edx
	mov	DWORD PTR _i$1$[ebp], edi
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _exprOp$1$[ebp], eax
	mov	eax, DWORD PTR _set$[ebp]
	cmp	DWORD PTR [eax], ebx
	jle	$LN31@xmlXPathCo
	npad	4
$LL4@xmlXPathCo:

; 11861:             xmlXPathObjectPtr tmp;
; 11862: 
; 11863: 	    if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv653[ebp], ecx
	mov	edi, DWORD PTR [ecx+eax]
	test	edi, edi
	je	$LN2@xmlXPathCo

; 11864: 		continue;
; 11865: 
; 11866: 	    contextNode = set->nodeTab[i];
; 11867: 	    xpctxt->node = contextNode;
; 11868: 	    xpctxt->contextSize = contextSize;

	mov	eax, DWORD PTR _contextSize$1$[ebp]
	mov	DWORD PTR [edx+68], eax

; 11869: 	    xpctxt->proximityPosition = ++contextPos;

	mov	eax, DWORD PTR _contextPos$1$[ebp]
	inc	eax
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+72], eax

; 11870: 
; 11871: 	    /*
; 11872: 	    * Initialize the new set.
; 11873: 	    * Also set the xpath document in case things like
; 11874: 	    * key() evaluation are attempted on the predicate
; 11875: 	    */
; 11876: 	    if ((contextNode->type != XML_NAMESPACE_DECL) &&

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	mov	DWORD PTR _contextPos$1$[ebp], eax
	je	SHORT $LN15@xmlXPathCo
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN15@xmlXPathCo

; 11877: 		(contextNode->doc != NULL))
; 11878: 		xpctxt->doc = contextNode->doc;

	mov	DWORD PTR [edx], eax
$LN15@xmlXPathCo:

; 11879: 	    /*
; 11880: 	    * Evaluate the predicate expression with 1 context node
; 11881: 	    * at a time; this node is packaged into a node set; this
; 11882: 	    * node set is handed over to the evaluation mechanism.
; 11883: 	    */
; 11884: 	    if (contextObj == NULL)

	push	edi
	test	ebx, ebx
	jne	SHORT $LN16@xmlXPathCo

; 11885: 		contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);

	push	edx
	call	_xmlXPathCacheNewNodeSet
	add	esp, 8
	mov	ebx, eax
	jmp	SHORT $LN18@xmlXPathCo
$LN16@xmlXPathCo:

; 11886: 	    else {
; 11887: 		if (xmlXPathNodeSetAddUnique(contextObj->nodesetval,
; 11888: 		    contextNode) < 0) {

	push	DWORD PTR [ebx+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	$LN59@xmlXPathCo
$LN18@xmlXPathCo:

; 11890: 		    goto evaluation_exit;
; 11891: 		}
; 11892: 	    }
; 11893: 
; 11894: 	    valuePush(ctxt, contextObj);

	push	ebx
	push	esi
	call	_valuePush

; 2788 :     ret = ctxt->valueFrame;

	mov	eax, DWORD PTR [esi+44]

; 11895:             frame = xmlXPathSetFrame(ctxt);
; 11896: 	    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);

	push	1
	push	DWORD PTR _exprOp$1$[ebp]

; 2788 :     ret = ctxt->valueFrame;

	mov	DWORD PTR _ret$1$[ebp], eax

; 2789 :     ctxt->valueFrame = ctxt->valueNr;

	mov	eax, DWORD PTR [esi+20]

; 11895:             frame = xmlXPathSetFrame(ctxt);
; 11896: 	    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);

	push	esi

; 2789 :     ctxt->valueFrame = ctxt->valueNr;

	mov	DWORD PTR [esi+44], eax

; 11895:             frame = xmlXPathSetFrame(ctxt);
; 11896: 	    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);

	call	_xmlXPathCompOpEvalToBoolean

; 2804 :     if (ctxt->valueNr < ctxt->valueFrame) {

	mov	ecx, DWORD PTR [esi+20]

; 11895:             frame = xmlXPathSetFrame(ctxt);
; 11896: 	    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);

	add	esp, 20					; 00000014H
	mov	DWORD PTR _res$1$[ebp], eax

; 2804 :     if (ctxt->valueNr < ctxt->valueFrame) {

	cmp	ecx, DWORD PTR [esi+44]
	jge	SHORT $LN44@xmlXPathCo

; 747  :     xmlXPathErr(ctxt, no);

	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN44@xmlXPathCo:

; 2807 :     ctxt->valueFrame = frame;

	mov	eax, DWORD PTR _ret$1$[ebp]

; 11897:             xmlXPathPopFrame(ctxt, frame);
; 11898:             tmp = valuePop(ctxt);

	push	esi

; 2807 :     ctxt->valueFrame = frame;

	mov	DWORD PTR [esi+44], eax

; 11897:             xmlXPathPopFrame(ctxt, frame);
; 11898:             tmp = valuePop(ctxt);

	call	_valuePop
	add	esp, 4
	mov	edx, eax

; 11899: 
; 11900: 	    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {

	cmp	DWORD PTR [esi+8], 0
	jne	$LN58@xmlXPathCo
	cmp	DWORD PTR _res$1$[ebp], -1
	je	$LN58@xmlXPathCo

; 11907:                     tmp = valuePop(ctxt);
; 11908:                 }
; 11909: 		goto evaluation_error;
; 11910: 	    }
; 11911:             /* push the result back onto the stack */
; 11912:             valuePush(ctxt, tmp);

	push	edx
	push	esi
	call	_valuePush
	add	esp, 8

; 11913: 
; 11914: 	    if (res)

	cmp	DWORD PTR _res$1$[ebp], 0
	je	SHORT $LN22@xmlXPathCo

; 11915: 		pos++;

	mov	eax, DWORD PTR _pos$1$[ebp]

; 11916: 
; 11917: 	    if (res && (pos >= minPos) && (pos <= maxPos)) {

	mov	edx, DWORD PTR _minPos$[ebp]
	inc	eax
	mov	DWORD PTR _pos$1$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN22@xmlXPathCo
	mov	ecx, DWORD PTR _maxPos$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN22@xmlXPathCo

; 11918: 		/*
; 11919: 		* Fits in the requested range.
; 11920: 		*/
; 11921: 		newContextSize++;

	inc	DWORD PTR _newContextSize$1$[ebp]

; 11922: 		if (minPos == maxPos) {

	cmp	edx, ecx
	je	SHORT $LN61@xmlXPathCo

; 11937: 		}
; 11938: 		if (pos == maxPos) {

	cmp	eax, ecx
	jne	SHORT $LN27@xmlXPathCo

; 11939: 		    /*
; 11940: 		    * We are done.
; 11941: 		    */
; 11942: 		    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR _set$[ebp]
	inc	eax
	push	eax
	push	ecx
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 12					; 0000000cH

; 11943: 		    goto evaluation_exit;

	jmp	$LN72@xmlXPathCo
$LN22@xmlXPathCo:

; 11944: 		}
; 11945: 	    } else {
; 11946: 		/*
; 11947: 		* Remove the entry from the initial node set.
; 11948: 		*/
; 11949: 		set->nodeTab[i] = NULL;

	mov	ecx, DWORD PTR _set$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR tv653[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 11950: 		if (contextNode->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN27@xmlXPathCo

; 11951: 		    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);

	push	edi
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN27@xmlXPathCo:

; 11952: 	    }
; 11953: 	    if (exprRes != NULL) {
; 11954: 		xmlXPathReleaseObject(ctxt->context, exprRes);
; 11955: 		exprRes = NULL;
; 11956: 	    }
; 11957: 	    if (ctxt->value == contextObj) {

	cmp	DWORD PTR [esi+16], ebx
	jne	SHORT $LN29@xmlXPathCo

; 11958: 		/*
; 11959: 		* Don't free the temporary XPath object holding the
; 11960: 		* context node, in order to avoid massive recreation
; 11961: 		* inside this loop.
; 11962: 		*/
; 11963: 		valuePop(ctxt);

	push	esi
	call	_valuePop

; 11964: 		xmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	push	DWORD PTR [ebx+4]
	call	_xmlXPathNodeSetClear
	add	esp, 12					; 0000000cH

; 11965: 	    } else {

	jmp	SHORT $LN77@xmlXPathCo
$LN29@xmlXPathCo:

; 11966: 		/*
; 11967: 		* The object was lost in the evaluation machinery.
; 11968: 		* Can this happen? Maybe in case of internal-errors.
; 11969: 		*/
; 11970: 		contextObj = NULL;

	xor	ebx, ebx
$LN77@xmlXPathCo:

; 11860: 	for (i = 0; i < set->nodeNr; i++) {

	mov	edx, DWORD PTR _xpctxt$1$[ebp]
$LN2@xmlXPathCo:
	mov	edi, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _set$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [eax]
	jl	$LL4@xmlXPathCo
	jmp	$LN72@xmlXPathCo
$LN61@xmlXPathCo:

; 11923: 		    /*
; 11924: 		    * Only 1 node was requested.
; 11925: 		    */
; 11926: 		    if (contextNode->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	mov	ecx, DWORD PTR _set$[ebp]
	jne	SHORT $LN25@xmlXPathCo

; 11927: 			/*
; 11928: 			* As always: take care of those nasty
; 11929: 			* namespace nodes.
; 11930: 			*/
; 11931: 			set->nodeTab[i] = NULL;

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$LN25@xmlXPathCo:

; 11932: 		    }
; 11933: 		    xmlXPathNodeSetClear(set, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	push	ecx
	call	_xmlXPathNodeSetClear

; 11934: 		    set->nodeNr = 1;

	mov	eax, DWORD PTR _set$[ebp]
	add	esp, 8
	mov	DWORD PTR [eax], 1

; 11935: 		    set->nodeTab[0] = contextNode;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], edi

; 11936: 		    goto evaluation_exit;

	jmp	$LN72@xmlXPathCo
$LN58@xmlXPathCo:

; 11901:                 while (tmp != contextObj) {

	mov	edi, DWORD PTR _xpctxt$1$[ebp]
	cmp	edx, ebx
	je	SHORT $evaluation_error$79
$LL5@xmlXPathCo:

; 11902:                     /*
; 11903:                      * Free up the result
; 11904:                      * then pop off contextObj, which will be freed later
; 11905:                      */
; 11906:                     xmlXPathReleaseObject(xpctxt, tmp);

	push	edx
	push	edi
	call	_xmlXPathReleaseObject

; 2823 :     if ((ctxt == NULL) || (ctxt->valueNr <= 0))

	mov	eax, DWORD PTR [esi+20]

; 11902:                     /*
; 11903:                      * Free up the result
; 11904:                      * then pop off contextObj, which will be freed later
; 11905:                      */
; 11906:                     xmlXPathReleaseObject(xpctxt, tmp);

	add	esp, 8

; 2823 :     if ((ctxt == NULL) || (ctxt->valueNr <= 0))

	test	eax, eax
	jle	SHORT $LN48@xmlXPathCo

; 2824 :         return (NULL);
; 2825 : 
; 2826 :     if (ctxt->valueNr <= ctxt->valueFrame) {

	cmp	eax, DWORD PTR [esi+44]
	jg	SHORT $LN49@xmlXPathCo

; 747  :     xmlXPathErr(ctxt, no);

	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN48@xmlXPathCo:

; 11901:                 while (tmp != contextObj) {

	xor	edx, edx
$LN46@xmlXPathCo:
	cmp	edx, ebx
	jne	SHORT $LL5@xmlXPathCo
$evaluation_error$79:

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	mov	ecx, DWORD PTR _set$[ebp]
	push	0
	push	ecx
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 12					; 0000000cH

; 11971: 	    }
; 11972: 	}
; 11973: 	goto evaluation_exit;
; 11974: 
; 11975: evaluation_error:
; 11976: 	xmlXPathNodeSetClear(set, hasNsNodes);
; 11977: 	newContextSize = 0;

	mov	DWORD PTR _newContextSize$1$[ebp], 0
	jmp	SHORT $evaluation_exit$80
$LN49@xmlXPathCo:

; 2831 :     ctxt->valueNr--;

	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+20], ecx

; 2832 :     if (ctxt->valueNr > 0)

	test	ecx, ecx
	jle	SHORT $LN50@xmlXPathCo

; 2833 :         ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN51@xmlXPathCo
$LN50@xmlXPathCo:

; 2834 :     else
; 2835 :         ctxt->value = NULL;

	xor	eax, eax
$LN51@xmlXPathCo:

; 2836 :     ret = ctxt->valueTab[ctxt->valueNr];

	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [eax+ecx*4]

; 2837 :     ctxt->valueTab[ctxt->valueNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 2838 :     return (ret);

	jmp	SHORT $LN46@xmlXPathCo
$LN59@xmlXPathCo:

; 11889: 		    ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH
$LN72@xmlXPathCo:

; 11978: 
; 11979: evaluation_exit:
; 11980: 	if (contextObj != NULL) {

	mov	edi, DWORD PTR _xpctxt$1$[ebp]
$evaluation_exit$80:
	test	ebx, ebx
	je	SHORT $LN74@xmlXPathCo

; 11981: 	    if (ctxt->value == contextObj)

	cmp	DWORD PTR [esi+16], ebx
	jne	SHORT $LN32@xmlXPathCo

; 11982: 		valuePop(ctxt);

	push	esi
	call	_valuePop
	add	esp, 4
$LN32@xmlXPathCo:

; 11983: 	    xmlXPathReleaseObject(xpctxt, contextObj);

	push	ebx
	push	edi
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN74@xmlXPathCo:

; 11984: 	}
; 11985: 	if (exprRes != NULL)
; 11986: 	    xmlXPathReleaseObject(ctxt->context, exprRes);
; 11987: 	/*
; 11988: 	* Reset/invalidate the context.
; 11989: 	*/
; 11990: 	xpctxt->node = oldContextNode;

	mov	edx, DWORD PTR _xpctxt$1$[ebp]
$LN31@xmlXPathCo:
	mov	eax, DWORD PTR _oldContextNode$1$[ebp]
	mov	DWORD PTR [edx+4], eax

; 11991: 	xpctxt->doc = oldContextDoc;

	mov	eax, DWORD PTR _oldContextDoc$1$[ebp]
	mov	DWORD PTR [edx], eax

; 11992: 	xpctxt->contextSize = oldcs;

	mov	eax, DWORD PTR _oldcs$1$[ebp]
	mov	DWORD PTR [edx+68], eax

; 11993: 	xpctxt->proximityPosition = oldpp;

	mov	eax, DWORD PTR _oldpp$1$[ebp]
	mov	DWORD PTR [edx+72], eax

; 11994: 	return(newContextSize);

	mov	eax, DWORD PTR _newContextSize$1$[ebp]
$LN1@xmlXPathCo:

; 11995:     }
; 11996:     return(contextSize);
; 11997: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompOpEvalPositionalPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalPredicate
_TEXT	SEGMENT
_oldpp$1$ = -40						; size = 4
_oldcs$1$ = -36						; size = 4
_oldContextDoc$1$ = -32					; size = 4
_oldContextNode$1$ = -28				; size = 4
tv418 = -24						; size = 4
_exprOp$1$ = -20					; size = 4
_i$1$ = -16						; size = 4
_contextPos$1$ = -12					; size = 4
_contextSize$1$ = -8					; size = 4
_newContextSize$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xpctxt$1$ = 12						; size = 4
_op$ = 12						; size = 4
_set$ = 16						; size = 4
_contextSize$ = 20					; size = 4
_hasNsNodes$ = 24					; size = 4
_xmlXPathCompOpEvalPredicate PROC			; COMDAT

; 11643: {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _op$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, -1
	je	SHORT $LN40@xmlXPathCo

; 11645: 	xmlXPathCompExprPtr comp = ctxt->comp;
; 11646: 	/*
; 11647: 	* Process inner predicates first.
; 11648: 	*/
; 11649: 	if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {
; 11650: 	    /*
; 11651: 	    * TODO: raise an internal error.
; 11652: 	    */
; 11653: 	}
; 11654: 	contextSize = xmlXPathCompOpEvalPredicate(ctxt,

	mov	eax, DWORD PTR [ebx+32]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	DWORD PTR _hasNsNodes$[ebp]
	mov	edx, DWORD PTR _set$[ebp]
	push	DWORD PTR _contextSize$[ebp]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEvalPredicate
	add	esp, 20					; 00000014H
	mov	DWORD PTR _contextSize$1$[ebp], eax

; 11655: 	    &comp->steps[op->ch1], set, contextSize, hasNsNodes);
; 11656: 	CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	SHORT $LN38@xmlXPathCo

; 11657: 	if (contextSize <= 0)

	test	eax, eax
	jg	SHORT $LN37@xmlXPathCo
$LN38@xmlXPathCo:
	pop	esi

; 11658: 	    return(0);

	xor	eax, eax

; 11792:     }
; 11793:     return(contextSize);
; 11794: }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlXPathCo:

; 11644:     if (op->ch1 != -1) {

	mov	eax, DWORD PTR _contextSize$[ebp]
	mov	DWORD PTR _contextSize$1$[ebp], eax
$LN37@xmlXPathCo:

; 11659:     }
; 11660:     if (op->ch2 != -1) {

	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, -1
	je	$LN1@xmlXPathCo

; 11661: 	xmlXPathContextPtr xpctxt = ctxt->context;

	mov	edx, DWORD PTR [ebx+12]

; 11662: 	xmlNodePtr contextNode, oldContextNode;
; 11663: 	xmlDocPtr oldContextDoc;
; 11664:         int oldcs, oldpp;
; 11665: 	int i, res, contextPos = 0, newContextSize;
; 11666: 	xmlXPathStepOpPtr exprOp;
; 11667: 	xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;
; 11668: 
; 11669: #ifdef LIBXML_XPTR_ENABLED
; 11670: 	/*
; 11671: 	* URGENT TODO: Check the following:
; 11672: 	*  We don't expect location sets if evaluating prediates, right?
; 11673: 	*  Only filters should expect location sets, right?
; 11674: 	*/
; 11675: #endif
; 11676: 	/*
; 11677: 	* SPEC XPath 1.0:
; 11678: 	*  "For each node in the node-set to be filtered, the
; 11679: 	*  PredicateExpr is evaluated with that node as the
; 11680: 	*  context node, with the number of nodes in the
; 11681: 	*  node-set as the context size, and with the proximity
; 11682: 	*  position of the node in the node-set with respect to
; 11683: 	*  the axis as the context position;"
; 11684: 	* @oldset is the node-set" to be filtered.
; 11685: 	*
; 11686: 	* SPEC XPath 1.0:
; 11687: 	*  "only predicates change the context position and
; 11688: 	*  context size (see [2.4 Predicates])."
; 11689: 	* Example:
; 11690: 	*   node-set  context pos
; 11691: 	*    nA         1
; 11692: 	*    nB         2
; 11693: 	*    nC         3
; 11694: 	*   After applying predicate [position() > 1] :
; 11695: 	*   node-set  context pos
; 11696: 	*    nB         1
; 11697: 	*    nC         2
; 11698: 	*/
; 11699: 	oldContextNode = xpctxt->node;
; 11700: 	oldContextDoc = xpctxt->doc;
; 11701:         oldcs = xpctxt->contextSize;
; 11702:         oldpp = xpctxt->proximityPosition;
; 11703: 	/*
; 11704: 	* Get the expression of this predicate.
; 11705: 	*/
; 11706: 	exprOp = &ctxt->comp->steps[op->ch2];

	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	edi

; 11707: 	newContextSize = 0;
; 11708: 	for (i = 0; i < set->nodeNr; i++) {

	xor	esi, esi
	mov	DWORD PTR _xpctxt$1$[ebp], edx
	xor	edi, edi
	mov	DWORD PTR _contextPos$1$[ebp], 0
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldContextNode$1$[ebp], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _oldContextDoc$1$[ebp], eax
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _oldcs$1$[ebp], eax
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _oldpp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR _i$1$[ebp], esi
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	xor	ecx, ecx
	mov	DWORD PTR _exprOp$1$[ebp], eax
	mov	eax, DWORD PTR _set$[ebp]
	mov	DWORD PTR _newContextSize$1$[ebp], ecx
	cmp	DWORD PTR [eax], ecx
	jle	$LN42@xmlXPathCo
$LL4@xmlXPathCo:

; 11709: 	    if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR tv418[ebp], ecx
	mov	esi, DWORD PTR [ecx+eax]
	test	esi, esi
	je	$LN2@xmlXPathCo

; 11710: 		continue;
; 11711: 
; 11712: 	    contextNode = set->nodeTab[i];
; 11713: 	    xpctxt->node = contextNode;
; 11714: 	    xpctxt->contextSize = contextSize;

	mov	eax, DWORD PTR _contextSize$1$[ebp]
	mov	DWORD PTR [edx+68], eax

; 11715: 	    xpctxt->proximityPosition = ++contextPos;

	mov	eax, DWORD PTR _contextPos$1$[ebp]
	inc	eax
	mov	DWORD PTR [edx+4], esi
	mov	DWORD PTR [edx+72], eax

; 11716: 
; 11717: 	    /*
; 11718: 	    * Also set the xpath document in case things like
; 11719: 	    * key() are evaluated in the predicate.
; 11720: 	    */
; 11721: 	    if ((contextNode->type != XML_NAMESPACE_DECL) &&

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	mov	DWORD PTR _contextPos$1$[ebp], eax
	je	SHORT $LN11@xmlXPathCo
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN11@xmlXPathCo

; 11722: 		(contextNode->doc != NULL))
; 11723: 		xpctxt->doc = contextNode->doc;

	mov	DWORD PTR [edx], eax
$LN11@xmlXPathCo:

; 11724: 	    /*
; 11725: 	    * Evaluate the predicate expression with 1 context node
; 11726: 	    * at a time; this node is packaged into a node set; this
; 11727: 	    * node set is handed over to the evaluation mechanism.
; 11728: 	    */
; 11729: 	    if (contextObj == NULL)

	push	esi
	test	edi, edi
	jne	SHORT $LN12@xmlXPathCo

; 11730: 		contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);

	push	edx
	call	_xmlXPathCacheNewNodeSet
	add	esp, 8
	mov	edi, eax
	jmp	SHORT $LN14@xmlXPathCo
$LN12@xmlXPathCo:

; 11731: 	    else {
; 11732: 		if (xmlXPathNodeSetAddUnique(contextObj->nodesetval,
; 11733: 		    contextNode) < 0) {

	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	$LN31@xmlXPathCo
$LN14@xmlXPathCo:

; 11735: 		    goto evaluation_exit;
; 11736: 		}
; 11737: 	    }
; 11738: 
; 11739: 	    valuePush(ctxt, contextObj);

	push	edi
	push	ebx
	call	_valuePush

; 11740: 
; 11741: 	    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);

	push	1
	push	DWORD PTR _exprOp$1$[ebp]
	push	ebx
	call	_xmlXPathCompOpEvalToBoolean
	add	esp, 20					; 00000014H

; 11742: 
; 11743: 	    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN32@xmlXPathCo
	cmp	eax, -1
	je	$LN32@xmlXPathCo

; 11747: 	    }
; 11748: 
; 11749: 	    if (res != 0) {

	test	eax, eax
	je	SHORT $LN17@xmlXPathCo

; 11750: 		newContextSize++;

	inc	DWORD PTR _newContextSize$1$[ebp]

; 11751: 	    } else {

	jmp	SHORT $LN19@xmlXPathCo
$LN17@xmlXPathCo:

; 11752: 		/*
; 11753: 		* Remove the entry from the initial node set.
; 11754: 		*/
; 11755: 		set->nodeTab[i] = NULL;

	mov	edx, DWORD PTR _set$[ebp]
	mov	ecx, DWORD PTR tv418[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+eax], 0

; 11756: 		if (contextNode->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	jne	SHORT $LN19@xmlXPathCo

; 11757: 		    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);

	push	esi
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN19@xmlXPathCo:

; 11758: 	    }
; 11759: 	    if (ctxt->value == contextObj) {

	cmp	DWORD PTR [ebx+16], edi
	jne	SHORT $LN20@xmlXPathCo

; 11760: 		/*
; 11761: 		* Don't free the temporary XPath object holding the
; 11762: 		* context node, in order to avoid massive recreation
; 11763: 		* inside this loop.
; 11764: 		*/
; 11765: 		valuePop(ctxt);

	push	ebx
	call	_valuePop

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	push	0
	push	DWORD PTR [edi+4]
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 16					; 00000010H

; 11766: 		xmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);
; 11767: 	    } else {

	jmp	SHORT $LN43@xmlXPathCo
$LN20@xmlXPathCo:

; 11768: 		/*
; 11769: 		* TODO: The object was lost in the evaluation machinery.
; 11770: 		*  Can this happen? Maybe in internal-error cases.
; 11771: 		*/
; 11772: 		contextObj = NULL;

	xor	edi, edi
$LN43@xmlXPathCo:

; 11707: 	newContextSize = 0;
; 11708: 	for (i = 0; i < set->nodeNr; i++) {

	mov	edx, DWORD PTR _xpctxt$1$[ebp]
$LN2@xmlXPathCo:
	mov	esi, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _set$[ebp]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax]
	jl	$LL4@xmlXPathCo

; 11773: 	    }
; 11774: 	}
; 11775: 
; 11776: 	if (contextObj != NULL) {

	test	edi, edi
	je	SHORT $LN41@xmlXPathCo

; 11777: 	    if (ctxt->value == contextObj)

	cmp	DWORD PTR [ebx+16], edi
	jne	SHORT $LN23@xmlXPathCo

; 11778: 		valuePop(ctxt);

	push	ebx
	call	_valuePop
	add	esp, 4
$LN23@xmlXPathCo:

; 11779: 	    xmlXPathReleaseObject(xpctxt, contextObj);

	mov	esi, DWORD PTR _xpctxt$1$[ebp]
	push	edi
	push	esi
	call	_xmlXPathReleaseObject
	mov	ecx, DWORD PTR _newContextSize$1$[ebp]
	add	esp, 8
	jmp	SHORT $LN24@xmlXPathCo
$LN32@xmlXPathCo:

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);

	push	DWORD PTR _hasNsNodes$[ebp]
	mov	edx, DWORD PTR _set$[ebp]
	push	0
	push	edx
	call	_xmlXPathNodeSetClearFromPos

; 11746: 		goto evaluation_exit;

	mov	esi, DWORD PTR _xpctxt$1$[ebp]

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);

	add	esp, 12					; 0000000cH

; 11744: 		xmlXPathNodeSetClear(set, hasNsNodes);
; 11745: 		newContextSize = 0;

	xor	ecx, ecx

; 11746: 		goto evaluation_exit;

	jmp	SHORT $LN24@xmlXPathCo
$LN31@xmlXPathCo:

; 11734: 		    ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [ebx+8], 15			; 0000000fH
$LN41@xmlXPathCo:

; 11780: 	}
; 11781: evaluation_exit:
; 11782: 	if (exprRes != NULL)
; 11783: 	    xmlXPathReleaseObject(ctxt->context, exprRes);
; 11784: 	/*
; 11785: 	* Reset/invalidate the context.
; 11786: 	*/
; 11787: 	xpctxt->node = oldContextNode;

	mov	esi, DWORD PTR _xpctxt$1$[ebp]
	mov	ecx, DWORD PTR _newContextSize$1$[ebp]
	jmp	SHORT $LN24@xmlXPathCo
$LN42@xmlXPathCo:

; 11707: 	newContextSize = 0;
; 11708: 	for (i = 0; i < set->nodeNr; i++) {

	mov	esi, edx
$LN24@xmlXPathCo:

; 11780: 	}
; 11781: evaluation_exit:
; 11782: 	if (exprRes != NULL)
; 11783: 	    xmlXPathReleaseObject(ctxt->context, exprRes);
; 11784: 	/*
; 11785: 	* Reset/invalidate the context.
; 11786: 	*/
; 11787: 	xpctxt->node = oldContextNode;

	mov	eax, DWORD PTR _oldContextNode$1$[ebp]
	mov	DWORD PTR [esi+4], eax

; 11788: 	xpctxt->doc = oldContextDoc;

	mov	eax, DWORD PTR _oldContextDoc$1$[ebp]
	mov	DWORD PTR [esi], eax

; 11789: 	xpctxt->contextSize = oldcs;

	mov	eax, DWORD PTR _oldcs$1$[ebp]
	mov	DWORD PTR [esi+68], eax

; 11790: 	xpctxt->proximityPosition = oldpp;

	mov	eax, DWORD PTR _oldpp$1$[ebp]
	mov	DWORD PTR [esi+72], eax

; 11791: 	return(newContextSize);

	mov	eax, ecx
	pop	edi
$LN1@xmlXPathCo:

; 11792:     }
; 11793:     return(contextSize);
; 11794: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompOpEvalPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEval
_TEXT	SEGMENT
_oldpp$1$ = -52						; size = 4
_oldcs$1$ = -48						; size = 4
_rloc$1$ = -44						; size = 4
_res$3$ = -44						; size = 4
_oldpp$2$ = -44						; size = 4
_res$1$ = -40						; size = 4
_tmp$2$ = -40						; size = 4
_res$3$ = -40						; size = 4
_oldpp$1$ = -40						; size = 4
_tmp$1$ = -36						; size = 4
_oldcs$1$ = -36						; size = 4
_obj$2$ = -36						; size = 4
_oldnode$1$ = -32					; size = 4
_oldnode$2$ = -32					; size = 4
_oldnode$1$ = -32					; size = 4
_obj$1$ = -28						; size = 4
_oldDoc$1$ = -28					; size = 4
tv3326 = -28						; size = 4
tv3261 = -28						; size = 4
tv3257 = -28						; size = 4
_res$1$ = -24						; size = 4
_oldcs$2$ = -24						; size = 4
tv3250 = -24						; size = 4
_oldset$1$ = -20					; size = 4
_i$1$ = -20						; size = 4
_tmp$1$ = -20						; size = 4
_newset$1$ = -20					; size = 4
_oldlocset$1$ = -16					; size = 4
_i$1$ = -16						; size = 4
_func$1$ = -16						; size = 4
tv3256 = -16						; size = 4
_oldset$1$ = -12					; size = 4
_newlocset$1$ = -12					; size = 4
_total$11$ = -12					; size = 4
_newlocset$1$ = -8					; size = 4
_i$2$ = -8						; size = 4
_obj$1$ = -8						; size = 4
_frame$1$ = -8						; size = 4
_comp$1$ = -4						; size = 4
_i$2$ = 8						; size = 4
_tmp$2$ = 8						; size = 4
_oldlocset$1$ = 8					; size = 4
_arg2$2$ = 8						; size = 4
_arg2$1$ = 8						; size = 4
_total$7$ = 8						; size = 4
_last$1 = 8						; size = 4
_first$2 = 8						; size = 4
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_xmlXPathCompOpEval PROC				; COMDAT

; 13213: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	mov	DWORD PTR _total$11$[ebp], edi
	cmp	DWORD PTR [ebx+8], edi
	jne	$LN214@xmlXPathCo

; 13214:     int total = 0;
; 13215:     int equal, ret;
; 13216:     xmlXPathCompExprPtr comp;
; 13217:     xmlXPathObjectPtr arg1, arg2;
; 13218: 
; 13219:     CHECK_ERROR0;
; 13220:     comp = ctxt->comp;

	mov	esi, DWORD PTR _op$[ebp]
	mov	edx, DWORD PTR [ebx+32]
	mov	DWORD PTR _comp$1$[ebp], edx

; 13221:     switch (op->op) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 18					; 00000012H
	ja	$LN2@xmlXPathCo
	jmp	DWORD PTR $LN235@xmlXPathCo[eax*4]
$LN24@xmlXPathCo:

; 13222:         case XPATH_OP_END:
; 13223:             return (0);
; 13224:         case XPATH_OP_AND:
; 13225:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13226: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13227:             xmlXPathBooleanFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathBooleanFunction

; 13228:             if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN27@xmlXPathCo

; 13229:                 return (total);
; 13230:             arg2 = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	DWORD PTR _arg2$1$[ebp], eax

; 13231:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 12					; 0000000cH
	add	edi, eax

; 13232: 	    if (ctxt->error) {

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN28@xmlXPathCo
$LN233@xmlXPathCo:

; 13974:     return (total);
; 13975: }

	mov	edx, DWORD PTR _arg2$1$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlXPathCo:

; 13233: 		xmlXPathFreeObject(arg2);
; 13234: 		return(0);
; 13235: 	    }
; 13236:             xmlXPathBooleanFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathBooleanFunction

; 13237:             if (ctxt->value != NULL)

	mov	ecx, DWORD PTR [ebx+16]
	add	esp, 8
	mov	edx, DWORD PTR _arg2$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN29@xmlXPathCo

; 13238:                 ctxt->value->boolval &= arg2->boolval;

	mov	eax, DWORD PTR [edx+8]
	and	DWORD PTR [ecx+8], eax
$LN29@xmlXPathCo:

; 13239: 	    xmlXPathReleaseObject(ctxt->context, arg2);

	push	edx
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN27@xmlXPathCo:

; 13974:     return (total);
; 13975: }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlXPathCo:

; 13240:             return (total);
; 13241:         case XPATH_OP_OR:
; 13242:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13243: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13244:             xmlXPathBooleanFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathBooleanFunction

; 13245:             if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))

	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo
	cmp	DWORD PTR [eax+8], 1
	je	SHORT $LN27@xmlXPathCo

; 13246:                 return (total);
; 13247:             arg2 = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	DWORD PTR _arg2$2$[ebp], eax

; 13248:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 12					; 0000000cH
	add	edi, eax

; 13249: 	    if (ctxt->error) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN233@xmlXPathCo

; 13250: 		xmlXPathFreeObject(arg2);
; 13251: 		return(0);
; 13252: 	    }
; 13253:             xmlXPathBooleanFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathBooleanFunction

; 13254:             if (ctxt->value != NULL)

	mov	ecx, DWORD PTR [ebx+16]
	add	esp, 8
	mov	edx, DWORD PTR _arg2$2$[ebp]
	test	ecx, ecx
	je	SHORT $LN35@xmlXPathCo

; 13255:                 ctxt->value->boolval |= arg2->boolval;

	mov	eax, DWORD PTR [edx+8]
	or	DWORD PTR [ecx+8], eax
$LN35@xmlXPathCo:

; 13256: 	    xmlXPathReleaseObject(ctxt->context, arg2);

	push	edx
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 13257:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlXPathCo:

; 13258:         case XPATH_OP_EQUAL:
; 13259:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13260: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13261:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13262: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13263: 	    if (op->value)

	cmp	DWORD PTR [esi+12], 0
	push	ebx
	je	SHORT $LN39@xmlXPathCo

; 13264: 		equal = xmlXPathEqualValues(ctxt);

	call	_xmlXPathEqualValues
	jmp	SHORT $LN227@xmlXPathCo
$LN39@xmlXPathCo:

; 13265: 	    else
; 13266: 		equal = xmlXPathNotEqualValues(ctxt);

	call	_xmlXPathNotEqualValues
$LN227@xmlXPathCo:

; 13267: 	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));

	add	esp, 4
	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheNewBoolean
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 16					; 00000010H

; 13268:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlXPathCo:

; 13269:         case XPATH_OP_CMP:
; 13270:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13271: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13272:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13273: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13274:             ret = xmlXPathCompareValues(ctxt, op->value, op->value2);

	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlXPathCompareValues

; 13275: 	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheNewBoolean
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 28					; 0000001cH

; 13276:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlXPathCo:

; 13277:         case XPATH_OP_PLUS:
; 13278:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13279: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13280:             if (op->ch2 != -1) {

	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, -1
	je	SHORT $LN47@xmlXPathCo

; 13281:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR _comp$1$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13282: 	    }
; 13283: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo
$LN47@xmlXPathCo:

; 13284:             if (op->value == 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN48@xmlXPathCo

; 13285:                 xmlXPathSubValues(ctxt);

	push	ebx
	call	_xmlXPathSubValues
	add	esp, 4

; 13974:     return (total);
; 13975: }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlXPathCo:

; 13286:             else if (op->value == 1)

	cmp	eax, 1
	jne	SHORT $LN50@xmlXPathCo

; 13287:                 xmlXPathAddValues(ctxt);

	push	ebx
	call	_xmlXPathAddValues
	add	esp, 4

; 13974:     return (total);
; 13975: }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlXPathCo:

; 13288:             else if (op->value == 2)

	cmp	eax, 2
	jne	SHORT $LN52@xmlXPathCo

; 13289:                 xmlXPathValueFlipSign(ctxt);

	push	ebx
	call	_xmlXPathValueFlipSign
	add	esp, 4

; 13974:     return (total);
; 13975: }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@xmlXPathCo:

; 13290:             else if (op->value == 3) {

	cmp	eax, 3
	jne	$LN27@xmlXPathCo

; 13291:                 CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN55@xmlXPathCo
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN55@xmlXPathCo
	push	1
	push	ebx
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
$LN55@xmlXPathCo:

; 13292:                 CHECK_TYPE0(XPATH_NUMBER);

	test	eax, eax
	je	$LN169@xmlXPathCo
	cmp	DWORD PTR [eax], 3
	jne	$LN169@xmlXPathCo

; 13293:             }
; 13294:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@xmlXPathCo:

; 13295:         case XPATH_OP_MULT:
; 13296:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13297: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13298:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13299: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13300:             if (op->value == 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN61@xmlXPathCo

; 13301:                 xmlXPathMultValues(ctxt);

	push	ebx
	call	_xmlXPathMultValues

; 13306:             return (total);

	add	esp, 4
	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@xmlXPathCo:

; 13302:             else if (op->value == 1)

	cmp	eax, 1
	jne	SHORT $LN63@xmlXPathCo

; 13303:                 xmlXPathDivValues(ctxt);

	push	ebx
	call	_xmlXPathDivValues

; 13306:             return (total);

	add	esp, 4
	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@xmlXPathCo:

; 13304:             else if (op->value == 2)

	cmp	eax, 2
	jne	SHORT $LN65@xmlXPathCo

; 13305:                 xmlXPathModValues(ctxt);

	push	ebx
	call	_xmlXPathModValues

; 13306:             return (total);

	add	esp, 4
$LN65@xmlXPathCo:
	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@xmlXPathCo:

; 13307:         case XPATH_OP_UNION:
; 13308:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13309: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13310:             total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	edi, eax
	add	esp, 8

; 13311: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	mov	DWORD PTR _total$7$[ebp], edi
	jne	$LN214@xmlXPathCo

; 13312: 
; 13313:             arg2 = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13314:             arg1 = valuePop(ctxt);

	push	ebx
	mov	esi, eax
	call	_valuePop
	mov	edi, eax
	add	esp, 8

; 13315:             if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||
; 13316:                 (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {

	test	edi, edi
	je	SHORT $LN70@xmlXPathCo
	cmp	DWORD PTR [edi], 1
	jne	SHORT $LN70@xmlXPathCo
	test	esi, esi
	je	SHORT $LN70@xmlXPathCo
	cmp	DWORD PTR [esi], 1
	jne	SHORT $LN70@xmlXPathCo

; 13320:             }
; 13321: 
; 13322: 	    if ((arg1->nodesetval == NULL) ||

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN211@xmlXPathCo
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN71@xmlXPathCo
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN71@xmlXPathCo
$LN211@xmlXPathCo:

; 13323: 		((arg2->nodesetval != NULL) &&
; 13324: 		 (arg2->nodesetval->nodeNr != 0)))
; 13325: 	    {
; 13326: 		arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,

	push	DWORD PTR [esi+4]
	push	ecx
	call	_xmlXPathNodeSetMerge
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
$LN71@xmlXPathCo:

; 13327: 							arg2->nodesetval);
; 13328: 	    }
; 13329: 
; 13330:             valuePush(ctxt, arg1);

	push	edi
	push	ebx
	call	_valuePush

; 13331: 	    xmlXPathReleaseObject(ctxt->context, arg2);

	push	esi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13332:             return (total);

	mov	eax, DWORD PTR _total$7$[ebp]
	add	esp, 16					; 00000010H
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlXPathCo:

; 13317: 	        xmlXPathReleaseObject(ctxt->context, arg1);

	push	edi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13318: 	        xmlXPathReleaseObject(ctxt->context, arg2);

	push	esi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13319:                 XP_ERROR0(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	ebx
	call	_xmlXPathErr
	add	esp, 24					; 00000018H

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@xmlXPathCo:

; 13333:         case XPATH_OP_ROOT:
; 13334:             xmlXPathRoot(ctxt);

	push	ebx
	call	_xmlXPathRoot
	add	esp, 4

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@xmlXPathCo:

; 13335:             return (total);
; 13336:         case XPATH_OP_NODE:
; 13337:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN76@xmlXPathCo

; 13338:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13339: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo
	mov	edx, DWORD PTR _comp$1$[ebp]
$LN76@xmlXPathCo:

; 13340:             if (op->ch2 != -1)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, -1
	je	SHORT $LN78@xmlXPathCo

; 13341:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13342: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo
$LN78@xmlXPathCo:

; 13343: 	    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 16					; 00000010H

; 13344: 		ctxt->context->node));
; 13345:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@xmlXPathCo:

; 13346:         case XPATH_OP_COLLECT:{
; 13347:                 if (op->ch1 == -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	$LN214@xmlXPathCo

; 13348:                     return (total);
; 13349: 
; 13350:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13351: 		CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13352: 
; 13353:                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);

	push	0
	push	0
	push	0
	push	esi
	push	ebx
	call	_xmlXPathNodeCollectAndTest
	add	esp, 20					; 00000014H
	add	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@xmlXPathCo:

; 13354:                 return (total);
; 13355:             }
; 13356:         case XPATH_OP_VALUE:
; 13357:             valuePush(ctxt,

	push	DWORD PTR [esi+24]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 16					; 00000010H

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@xmlXPathCo:

; 13358:                       xmlXPathCacheObjectCopy(ctxt->context,
; 13359: 			(xmlXPathObjectPtr) op->value4));
; 13360:             return (total);
; 13361:         case XPATH_OP_VARIABLE:{
; 13362: 		xmlXPathObjectPtr val;
; 13363: 
; 13364:                 if (op->ch1 != -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN84@xmlXPathCo

; 13365:                     total +=

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	DWORD PTR _total$11$[ebp], eax
	mov	edi, eax
$LN84@xmlXPathCo:

; 13366:                         xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
; 13367:                 if (op->value5 == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	jne	SHORT $LN85@xmlXPathCo

; 13368: 		    val = xmlXPathVariableLookup(ctxt->context, op->value4);

	push	DWORD PTR [esi+24]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathVariableLookup
	add	esp, 8
	jmp	SHORT $LN230@xmlXPathCo
$LN85@xmlXPathCo:

; 13369: 		    if (val == NULL)
; 13370: 			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
; 13371:                     valuePush(ctxt, val);
; 13372: 		} else {
; 13373:                     const xmlChar *URI;
; 13374: 
; 13375:                     URI = xmlXPathNsLookup(ctxt->context, op->value5);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathNsLookup
	add	esp, 8

; 13376:                     if (URI == NULL) {

	test	eax, eax
	jne	SHORT $LN88@xmlXPathCo

; 13377:                         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edx, DWORD PTR _op$[ebp]
	mov	ebx, eax
	mov	esi, DWORD PTR [esi+28]
	mov	edi, DWORD PTR [edx+24]
	call	___xmlGenericErrorContext
	push	esi
	push	edi
	push	OFFSET ??_C@_0DO@IDAPNIMJ@xmlXPathCompOpEval?3?5variable?5?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax

; 13378:             "xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n",
; 13379:                                     (char *) op->value4, (char *)op->value5);
; 13380:                         ctxt->error = XPATH_UNDEF_PREFIX_ERROR;

	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 16					; 00000010H

; 13381:                         return (total);

	mov	eax, DWORD PTR _total$11$[ebp]
	pop	edi
	mov	DWORD PTR [esi+8], 19			; 00000013H

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@xmlXPathCo:

; 13382:                     }
; 13383: 		    val = xmlXPathVariableLookupNS(ctxt->context,

	push	eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathVariableLookupNS
	add	esp, 12					; 0000000cH
$LN230@xmlXPathCo:

; 13384:                                                        op->value4, URI);
; 13385: 		    if (val == NULL)
; 13386: 			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);

	test	eax, eax
	jne	SHORT $LN89@xmlXPathCo
	push	5
	push	ebx
	call	_xmlXPathErr
	add	esp, 8

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@xmlXPathCo:

; 13387:                     valuePush(ctxt, val);
; 13388:                 }
; 13389:                 return (total);

	push	eax
	push	ebx
	call	_valuePush
	add	esp, 8
	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@xmlXPathCo:

; 13390:             }
; 13391:         case XPATH_OP_FUNCTION:{
; 13392:                 xmlXPathFunction func;
; 13393:                 const xmlChar *oldFunc, *oldFuncURI;
; 13394: 		int i;
; 13395:                 int frame;
; 13396: 
; 13397:                 frame = xmlXPathSetFrame(ctxt);

	push	ebx
	call	_xmlXPathSetFrame
	mov	DWORD PTR _frame$1$[ebp], eax
	add	esp, 4

; 13398:                 if (op->ch1 != -1) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN92@xmlXPathCo

; 13399:                     total +=

	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	ecx, DWORD PTR [ecx+edx*8]
	push	ecx
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13400:                         xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
; 13401:                     if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	mov	DWORD PTR _total$11$[ebp], edi
	je	SHORT $LN92@xmlXPathCo

; 13402:                         xmlXPathPopFrame(ctxt, frame);

	push	DWORD PTR _frame$1$[ebp]
	push	ebx
	call	_xmlXPathPopFrame
	add	esp, 8

; 13403:                         return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@xmlXPathCo:

; 13404:                     }
; 13405:                 }
; 13406: 		if (ctxt->valueNr < ctxt->valueFrame + op->value) {

	mov	eax, DWORD PTR [ebx+44]
	mov	edx, DWORD PTR [esi+12]
	add	eax, edx
	cmp	DWORD PTR [ebx+20], eax
	jge	SHORT $LN93@xmlXPathCo
$LN183@xmlXPathCo:

; 13974:     return (total);
; 13975: }

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CF@LMIGLEJC@xmlXPathCompOpEval?3?5parameter?5e@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	push	DWORD PTR _frame$1$[ebp]
	mov	DWORD PTR [ebx+8], 10			; 0000000aH
	push	ebx
	call	_xmlXPathPopFrame
	add	esp, 16					; 00000010H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@xmlXPathCo:

; 13407: 		    xmlGenericError(xmlGenericErrorContext,
; 13408: 			    "xmlXPathCompOpEval: parameter error\n");
; 13409: 		    ctxt->error = XPATH_INVALID_OPERAND;
; 13410:                     xmlXPathPopFrame(ctxt, frame);
; 13411: 		    return (total);
; 13412: 		}
; 13413: 		for (i = 0; i < op->value; i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@xmlXPathCo

; 13414: 		    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {

	mov	eax, DWORD PTR [ebx+28]
	mov	ebx, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	add	eax, -4					; fffffffcH
	npad	7
$LL6@xmlXPathCo:
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN183@xmlXPathCo

; 13407: 		    xmlGenericError(xmlGenericErrorContext,
; 13408: 			    "xmlXPathCompOpEval: parameter error\n");
; 13409: 		    ctxt->error = XPATH_INVALID_OPERAND;
; 13410:                     xmlXPathPopFrame(ctxt, frame);
; 13411: 		    return (total);
; 13412: 		}
; 13413: 		for (i = 0; i < op->value; i++) {

	inc	ecx
	sub	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL6@xmlXPathCo
$LN5@xmlXPathCo:

; 13415: 			xmlGenericError(xmlGenericErrorContext,
; 13416: 				"xmlXPathCompOpEval: parameter error\n");
; 13417: 			ctxt->error = XPATH_INVALID_OPERAND;
; 13418:                         xmlXPathPopFrame(ctxt, frame);
; 13419: 			return (total);
; 13420: 		    }
; 13421:                 }
; 13422:                 if (op->cache != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _func$1$[ebp], eax
	test	eax, eax
	jne	$LN96@xmlXPathCo

; 13423:                     func = op->cache;
; 13424:                 else {
; 13425:                     const xmlChar *URI = NULL;
; 13426: 
; 13427:                     if (op->value5 == NULL)

	mov	eax, DWORD PTR [esi+28]
	xor	edi, edi
	test	eax, eax
	jne	SHORT $LN97@xmlXPathCo

; 13428:                         func =

	push	DWORD PTR [esi+24]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathFunctionLookup
	add	esp, 8
	jmp	SHORT $LN231@xmlXPathCo
$LN97@xmlXPathCo:

; 13429:                             xmlXPathFunctionLookup(ctxt->context,
; 13430:                                                    op->value4);
; 13431:                     else {
; 13432:                         URI = xmlXPathNsLookup(ctxt->context, op->value5);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathNsLookup
	mov	edi, eax
	add	esp, 8

; 13433:                         if (URI == NULL) {

	test	edi, edi
	jne	SHORT $LN99@xmlXPathCo

; 13434:                             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edx, DWORD PTR _op$[ebp]
	mov	ebx, eax
	mov	esi, DWORD PTR [esi+28]
	mov	edi, DWORD PTR [edx+24]
	call	___xmlGenericErrorContext
	push	esi
	push	edi
	push	OFFSET ??_C@_0DO@MGJDMDIG@xmlXPathCompOpEval?3?5function?5?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx]
	call	eax

; 13435:             "xmlXPathCompOpEval: function %s bound to undefined prefix %s\n",
; 13436:                                     (char *)op->value4, (char *)op->value5);
; 13437:                             xmlXPathPopFrame(ctxt, frame);

	push	DWORD PTR _frame$1$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathPopFrame

; 13438:                             ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
; 13439:                             return (total);

	mov	eax, DWORD PTR _total$11$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], 19			; 00000013H
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@xmlXPathCo:

; 13440:                         }
; 13441:                         func = xmlXPathFunctionLookupNS(ctxt->context,

	push	edi
	push	DWORD PTR [esi+24]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathFunctionLookupNS
	add	esp, 12					; 0000000cH
$LN231@xmlXPathCo:

; 13442:                                                         op->value4, URI);
; 13443:                     }
; 13444:                     if (func == NULL) {

	mov	DWORD PTR _func$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN100@xmlXPathCo

; 13445:                         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [esi+24]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0CL@KAMILNDJ@xmlXPathCompOpEval?3?5function?5?$CFs@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax

; 13446:                                 "xmlXPathCompOpEval: function %s not found\n",
; 13447:                                         (char *)op->value4);
; 13448:                         XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);

	push	9
	push	ebx
	call	_xmlXPathErr
	add	esp, 20					; 00000014H

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@xmlXPathCo:

; 13449:                     }
; 13450:                     op->cache = func;

	mov	DWORD PTR [esi+32], eax

; 13451:                     op->cacheURI = (void *) URI;

	mov	DWORD PTR [esi+36], edi
$LN96@xmlXPathCo:

; 13452:                 }
; 13453:                 oldFunc = ctxt->context->function;

	mov	ecx, DWORD PTR [ebx+12]

; 13454:                 oldFuncURI = ctxt->context->functionURI;
; 13455:                 ctxt->context->function = op->value4;

	mov	edx, DWORD PTR _op$[ebp]
	mov	esi, DWORD PTR [ecx+104]
	mov	edi, DWORD PTR [ecx+108]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+104], eax

; 13456:                 ctxt->context->functionURI = op->cacheURI;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+108], eax

; 13457:                 func(ctxt, op->value);

	push	DWORD PTR [edx+12]
	push	ebx
	call	DWORD PTR _func$1$[ebp]

; 13458:                 ctxt->context->function = oldFunc;

	mov	eax, DWORD PTR [ebx+12]

; 13459:                 ctxt->context->functionURI = oldFuncURI;
; 13460:                 xmlXPathPopFrame(ctxt, frame);

	push	DWORD PTR _frame$1$[ebp]
	push	ebx
	mov	DWORD PTR [eax+104], esi
	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+108], edi
	call	_xmlXPathPopFrame

; 13461:                 return (total);

	mov	eax, DWORD PTR _total$11$[ebp]
	add	esp, 16					; 00000010H
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@xmlXPathCo:

; 13462:             }
; 13463:         case XPATH_OP_ARG:
; 13464:             if (op->ch1 != -1) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN103@xmlXPathCo

; 13465:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13466: 	        CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo
	mov	edx, DWORD PTR _comp$1$[ebp]
$LN103@xmlXPathCo:

; 13467:             }
; 13468:             if (op->ch2 != -1) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, -1
	je	$LN27@xmlXPathCo

; 13469:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax

; 13470: 	        CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13471: 	    }
; 13472:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@xmlXPathCo:

; 13473:         case XPATH_OP_PREDICATE:
; 13474:         case XPATH_OP_FILTER:{
; 13475:                 xmlXPathObjectPtr res;
; 13476:                 xmlXPathObjectPtr obj, tmp;
; 13477:                 xmlNodeSetPtr newset = NULL;
; 13478:                 xmlNodeSetPtr oldset;
; 13479:                 xmlNodePtr oldnode;
; 13480: 		xmlDocPtr oldDoc;
; 13481:                 int oldcs, oldpp;
; 13482:                 int i;
; 13483: 
; 13484:                 /*
; 13485:                  * Optimization for ()[1] selection i.e. the first elem
; 13486:                  */
; 13487:                 if ((op->ch1 != -1) && (op->ch2 != -1) &&
; 13488: #ifdef XP_OPTIMIZED_FILTER_FIRST
; 13489: 		    /*
; 13490: 		    * FILTER TODO: Can we assume that the inner processing
; 13491: 		    *  will result in an ordered list if we have an
; 13492: 		    *  XPATH_OP_FILTER?
; 13493: 		    *  What about an additional field or flag on
; 13494: 		    *  xmlXPathObject like @sorted ? This way we wouln'd need
; 13495: 		    *  to assume anything, so it would be more robust and
; 13496: 		    *  easier to optimize.
; 13497: 		    */
; 13498:                     ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */
; 13499: 		     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	$LN113@xmlXPathCo
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, -1
	je	$LN113@xmlXPathCo
	mov	ebx, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR tv3326[ebp], eax
	mov	eax, DWORD PTR [eax]
	cmp	eax, 17					; 00000011H
	je	SHORT $LN108@xmlXPathCo
	cmp	eax, 16					; 00000010H
	jne	$LN222@xmlXPathCo
$LN108@xmlXPathCo:
	mov	eax, DWORD PTR [edx+8]
	lea	edi, DWORD PTR [ecx+ecx*4]
	cmp	DWORD PTR [eax+edi*8], 11		; 0000000bH
	mov	edi, 0
	jne	SHORT $LN222@xmlXPathCo

; 13500: #else
; 13501: 		    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&
; 13502: #endif
; 13503:                     (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */
; 13504:                     xmlXPathObjectPtr val;
; 13505: 
; 13506:                     val = comp->steps[op->ch2].value4;

	lea	ebx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+ebx*8+24]

; 13507:                     if ((val != NULL) && (val->type == XPATH_NUMBER) &&

	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN222@xmlXPathCo
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN222@xmlXPathCo
	movsd	xmm0, QWORD PTR [eax+16]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN222@xmlXPathCo

; 13508:                         (val->floatval == 1.0)) {
; 13509:                         xmlNodePtr first = NULL;
; 13510: 
; 13511:                         total +=

	lea	eax, DWORD PTR _first$2[ebp]
	mov	DWORD PTR _first$2[ebp], edi
	push	eax
	push	DWORD PTR tv3326[ebp]
	push	ebx
	call	_xmlXPathCompOpEvalFirst
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 13512:                             xmlXPathCompOpEvalFirst(ctxt,
; 13513:                                                     &comp->steps[op->ch1],
; 13514:                                                     &first);
; 13515: 			CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], edi
	jne	$LN214@xmlXPathCo

; 13516:                         /*
; 13517:                          * The nodeset should be in document order,
; 13518:                          * Keep only the first value
; 13519:                          */
; 13520:                         if ((ctxt->value != NULL) &&
; 13521:                             (ctxt->value->type == XPATH_NODESET) &&
; 13522:                             (ctxt->value->nodesetval != NULL) &&

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN111@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN111@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN111@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	SHORT $LN111@xmlXPathCo

; 13523:                             (ctxt->value->nodesetval->nodeNr > 1))
; 13524:                             xmlXPathNodeSetClearFromPos(ctxt->value->nodesetval,

	push	1
	push	1
	push	eax
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 12					; 0000000cH
$LN111@xmlXPathCo:

; 13525:                                                         1, 1);
; 13526:                         return (total);

	pop	edi
	mov	eax, esi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN222@xmlXPathCo:

; 13527:                     }
; 13528:                 }
; 13529:                 /*
; 13530:                  * Optimization for ()[last()] selection i.e. the last elem
; 13531:                  */
; 13532:                 if ((op->ch1 != -1) && (op->ch2 != -1) &&
; 13533:                     (comp->steps[op->ch1].op == XPATH_OP_SORT) &&

	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, -1
	je	$LN113@xmlXPathCo
	mov	ecx, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [ecx+eax*8], 17		; 00000011H
	jne	$LN113@xmlXPathCo
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [ecx+eax*8], 17		; 00000011H
	jne	$LN113@xmlXPathCo

; 13534:                     (comp->steps[op->ch2].op == XPATH_OP_SORT)) {
; 13535:                     int f = comp->steps[op->ch2].ch1;

	mov	eax, DWORD PTR [ecx+eax*8+4]

; 13536: 
; 13537:                     if ((f != -1) &&
; 13538:                         (comp->steps[f].op == XPATH_OP_FUNCTION) &&
; 13539:                         (comp->steps[f].value5 == NULL) &&
; 13540:                         (comp->steps[f].value == 0) &&
; 13541:                         (comp->steps[f].value4 != NULL) &&

	cmp	eax, -1
	je	$LN113@xmlXPathCo
	lea	eax, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [ecx+eax*8], 13		; 0000000dH
	jne	$LN113@xmlXPathCo
	cmp	DWORD PTR [ecx+eax*8+28], 0
	jne	$LN113@xmlXPathCo
	cmp	DWORD PTR [ecx+eax*8+12], 0
	jne	SHORT $LN113@xmlXPathCo
	mov	eax, DWORD PTR [ecx+eax*8+24]
	test	eax, eax
	je	SHORT $LN113@xmlXPathCo
	push	OFFSET ??_C@_04PLGBGIDD@last@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN217@xmlXPathCo

; 13542:                         (xmlStrEqual
; 13543:                          (comp->steps[f].value4, BAD_CAST "last"))) {
; 13544:                         xmlNodePtr last = NULL;
; 13545: 
; 13546:                         total +=

	lea	eax, DWORD PTR _last$1[ebp]
	mov	DWORD PTR _last$1[ebp], 0
	push	eax
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEvalLast
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 13547:                             xmlXPathCompOpEvalLast(ctxt,
; 13548:                                                    &comp->steps[op->ch1],
; 13549:                                                    &last);
; 13550: 			CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13551:                         /*
; 13552:                          * The nodeset should be in document order,
; 13553:                          * Keep only the last value
; 13554:                          */
; 13555:                         if ((ctxt->value != NULL) &&
; 13556:                             (ctxt->value->type == XPATH_NODESET) &&
; 13557:                             (ctxt->value->nodesetval != NULL) &&
; 13558:                             (ctxt->value->nodesetval->nodeTab != NULL) &&

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN115@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN115@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN115@xmlXPathCo
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN115@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	SHORT $LN115@xmlXPathCo

; 13559:                             (ctxt->value->nodesetval->nodeNr > 1))
; 13560:                             xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);

	push	eax
	call	_xmlXPathNodeSetKeepLast
	add	esp, 4
$LN115@xmlXPathCo:

; 13561:                         return (total);

	pop	edi
	mov	eax, esi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN217@xmlXPathCo:

; 13536: 
; 13537:                     if ((f != -1) &&
; 13538:                         (comp->steps[f].op == XPATH_OP_FUNCTION) &&
; 13539:                         (comp->steps[f].value5 == NULL) &&
; 13540:                         (comp->steps[f].value == 0) &&
; 13541:                         (comp->steps[f].value4 != NULL) &&

	mov	edx, DWORD PTR _comp$1$[ebp]
$LN113@xmlXPathCo:

; 13562:                     }
; 13563:                 }
; 13564: 		/*
; 13565: 		* Process inner predicates first.
; 13566: 		* Example "index[parent::book][1]":
; 13567: 		* ...
; 13568: 		*   PREDICATE   <-- we are here "[1]"
; 13569: 		*     PREDICATE <-- process "[parent::book]" first
; 13570: 		*       SORT
; 13571: 		*         COLLECT  'parent' 'name' 'node' book
; 13572: 		*           NODE
; 13573: 		*     ELEM Object is a number : 1
; 13574: 		*/
; 13575:                 if (op->ch1 != -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN116@xmlXPathCo

; 13576:                     total +=

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax
$LN116@xmlXPathCo:

; 13577:                         xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
; 13578: 		CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo

; 13579:                 if (op->ch2 == -1)

	cmp	DWORD PTR [esi+8], -1
	je	$LN27@xmlXPathCo

; 13580:                     return (total);
; 13581:                 if (ctxt->value == NULL)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN27@xmlXPathCo

; 13582:                     return (total);
; 13583: 
; 13584: #ifdef LIBXML_XPTR_ENABLED
; 13585:                 /*
; 13586:                  * Hum are we filtering the result of an XPointer expression
; 13587:                  */
; 13588:                 if (ctxt->value->type == XPATH_LOCATIONSET) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 7
	jne	$LN120@xmlXPathCo

; 13589:                     xmlLocationSetPtr newlocset = NULL;
; 13590:                     xmlLocationSetPtr oldlocset;
; 13591: 
; 13592:                     /*
; 13593:                      * Extract the old locset, and then evaluate the result of the
; 13594:                      * expression for all the element in the locset. use it to grow
; 13595:                      * up a new locset.
; 13596:                      */
; 13597:                     CHECK_TYPE0(XPATH_LOCATIONSET);
; 13598: 
; 13599:                     if ((ctxt->value->user == NULL) ||

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	$LN27@xmlXPathCo
	cmp	DWORD PTR [eax], 0
	je	$LN27@xmlXPathCo

; 13600:                         (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))
; 13601:                         return (total);
; 13602: 
; 13603:                     obj = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	DWORD PTR _obj$1$[ebp], eax

; 13604:                     oldlocset = obj->user;
; 13605:                     oldnode = ctxt->context->node;
; 13606:                     oldcs = ctxt->context->contextSize;
; 13607:                     oldpp = ctxt->context->proximityPosition;
; 13608: 
; 13609:                     newlocset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _oldlocset$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldnode$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _oldcs$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _oldpp$1$[ebp], eax
	call	_xmlXPtrLocationSetCreate

; 13610: 
; 13611:                     for (i = 0; i < oldlocset->locNr; i++) {

	mov	edx, DWORD PTR _oldlocset$1$[ebp]
	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR _newlocset$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [edx], ecx
	jle	$LN8@xmlXPathCo
$LL9@xmlXPathCo:

; 13612:                         /*
; 13613:                          * Run the evaluation with a node list made of a
; 13614:                          * single item in the nodelocset.
; 13615:                          */
; 13616:                         ctxt->context->node = oldlocset->locTab[i]->user;

	mov	eax, DWORD PTR [edx+8]
	shl	ecx, 2
	mov	DWORD PTR tv3257[ebp], ecx
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+4], eax

; 13617:                         ctxt->context->contextSize = oldlocset->locNr;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+68], eax

; 13618:                         ctxt->context->proximityPosition = i + 1;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR [eax+72], ecx

; 13619: 			tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet

; 13620: 			    ctxt->context->node);
; 13621:                         valuePush(ctxt, tmp);

	push	eax
	push	ebx
	mov	DWORD PTR _tmp$1$[ebp], eax
	call	_valuePush

; 13622: 
; 13623:                         if (op->ch2 != -1)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	cmp	ecx, -1
	je	SHORT $LN125@xmlXPathCo

; 13624:                             total +=

	mov	eax, DWORD PTR _comp$1$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax
$LN125@xmlXPathCo:

; 13625:                                 xmlXPathCompOpEval(ctxt,
; 13626:                                                    &comp->steps[op->ch2]);
; 13627: 			if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN184@xmlXPathCo

; 13630: 			}
; 13631: 
; 13632:                         /*
; 13633:                          * The result of the evaluation need to be tested to
; 13634:                          * decided whether the filter succeeded or not
; 13635:                          */
; 13636:                         res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13637:                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	push	eax
	push	ebx
	mov	DWORD PTR _res$1$[ebp], eax
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN127@xmlXPathCo

; 13638:                             xmlXPtrLocationSetAdd(newlocset,

	mov	ecx, DWORD PTR _oldlocset$1$[ebp]
	mov	eax, DWORD PTR tv3257[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+eax]
	call	_xmlXPathObjectCopy
	push	eax
	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 12					; 0000000cH
$LN127@xmlXPathCo:

; 13639:                                                   xmlXPathObjectCopy
; 13640:                                                   (oldlocset->locTab[i]));
; 13641:                         }
; 13642: 
; 13643:                         /*
; 13644:                          * Cleanup
; 13645:                          */
; 13646:                         if (res != NULL) {

	mov	eax, DWORD PTR _res$1$[ebp]
	test	eax, eax
	je	SHORT $LN128@xmlXPathCo

; 13647: 			    xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN128@xmlXPathCo:

; 13648: 			}
; 13649:                         if (ctxt->value == tmp) {

	mov	eax, DWORD PTR _tmp$1$[ebp]
	cmp	DWORD PTR [ebx+16], eax
	jne	SHORT $LN7@xmlXPathCo

; 13650:                             res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13651: 			    xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH
$LN7@xmlXPathCo:

; 13610: 
; 13611:                     for (i = 0; i < oldlocset->locNr; i++) {

	mov	edx, DWORD PTR _oldlocset$1$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jl	$LL9@xmlXPathCo

; 13929:                                     xmlXPathCompOpEval(ctxt,
; 13930:                                                    &comp->steps[op->ch2]);
; 13931: 			    if (ctxt->error != XPATH_EXPRESSION_OK) {

	mov	eax, DWORD PTR _newlocset$1$[ebp]
$LN8@xmlXPathCo:

; 13652:                         }
; 13653:                     }
; 13654: 
; 13655:                     /*
; 13656:                      * The result is used as the new evaluation locset.
; 13657:                      */
; 13658:                     valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));

	push	eax
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 12					; 0000000cH
$filter_xptr_error$236:

; 13659: filter_xptr_error:
; 13660: 		    xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13661:                     ctxt->context->node = oldnode;

	mov	eax, DWORD PTR [ebx+12]
	add	esp, 8
	mov	ecx, DWORD PTR _oldnode$1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13662:                     ctxt->context->contextSize = oldcs;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldcs$1$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 13663:                     ctxt->context->proximityPosition = oldpp;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldpp$1$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 13664:                     return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@xmlXPathCo:

; 13628:                             xmlXPtrFreeLocationSet(newlocset);

	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrFreeLocationSet
	add	esp, 4

; 13629:                             goto filter_xptr_error;

	jmp	SHORT $filter_xptr_error$236
$LN120@xmlXPathCo:

; 13665:                 }
; 13666: #endif /* LIBXML_XPTR_ENABLED */
; 13667: 
; 13668:                 /*
; 13669:                  * Extract the old set, and then evaluate the result of the
; 13670:                  * expression for all the element in the set. use it to grow
; 13671:                  * up a new set.
; 13672:                  */
; 13673:                 CHECK_TYPE0(XPATH_NODESET);

	cmp	ecx, 1
	jne	$LN169@xmlXPathCo

; 13674: 
; 13675:                 if ((ctxt->value->nodesetval != NULL) &&

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN132@xmlXPathCo
	cmp	DWORD PTR [eax], 0
	je	$LN132@xmlXPathCo

; 13676:                     (ctxt->value->nodesetval->nodeNr != 0)) {
; 13677:                     obj = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13678:                     oldset = obj->nodesetval;
; 13679:                     oldnode = ctxt->context->node;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _obj$2$[ebp], eax

; 13680:                     oldDoc = ctxt->context->doc;
; 13681:                     oldcs = ctxt->context->contextSize;
; 13682:                     oldpp = ctxt->context->proximityPosition;
; 13683: 		    tmp = NULL;
; 13684:                     /*
; 13685:                      * Initialize the new set.
; 13686: 		     * Also set the xpath document in case things like
; 13687: 		     * key() evaluation are attempted on the predicate
; 13688:                      */
; 13689:                     newset = xmlXPathNodeSetCreate(NULL);

	push	0
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _oldset$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldnode$2$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _oldDoc$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR _oldcs$2$[ebp], eax
	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR _oldpp$2$[ebp], eax
	mov	DWORD PTR _tmp$2$[ebp], 0
	call	_xmlXPathNodeSetCreate

; 13690: 		    /*
; 13691: 		    * SPEC XPath 1.0:
; 13692: 		    *  "For each node in the node-set to be filtered, the
; 13693: 		    *  PredicateExpr is evaluated with that node as the
; 13694: 		    *  context node, with the number of nodes in the
; 13695: 		    *  node-set as the context size, and with the proximity
; 13696: 		    *  position of the node in the node-set with respect to
; 13697: 		    *  the axis as the context position;"
; 13698: 		    * @oldset is the node-set" to be filtered.
; 13699: 		    *
; 13700: 		    * SPEC XPath 1.0:
; 13701: 		    *  "only predicates change the context position and
; 13702: 		    *  context size (see [2.4 Predicates])."
; 13703: 		    * Example:
; 13704: 		    *   node-set  context pos
; 13705: 		    *    nA         1
; 13706: 		    *    nB         2
; 13707: 		    *    nC         3
; 13708: 		    *   After applying predicate [position() > 1] :
; 13709: 		    *   node-set  context pos
; 13710: 		    *    nB         1
; 13711: 		    *    nC         2
; 13712: 		    *
; 13713: 		    * removed the first node in the node-set, then
; 13714: 		    * the context position of the
; 13715: 		    */
; 13716:                     for (i = 0; i < oldset->nodeNr; i++) {

	mov	edx, DWORD PTR _oldset$1$[ebp]
	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR _newset$1$[ebp], eax
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	DWORD PTR [edx], ecx
	jle	$LN144@xmlXPathCo
	npad	8
$LL12@xmlXPathCo:

; 13717:                         /*
; 13718:                          * Run the evaluation with a node list made of
; 13719:                          * a single item in the nodeset.
; 13720:                          */
; 13721:                         ctxt->context->node = oldset->nodeTab[i];

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv3256[ebp], eax
	mov	esi, eax
	mov	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+4], eax

; 13722: 			if ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&

	mov	ecx, esi
	mov	eax, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _op$[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN133@xmlXPathCo
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	je	SHORT $LN133@xmlXPathCo

; 13723: 			    (oldset->nodeTab[i]->doc != NULL))
; 13724: 		            ctxt->context->doc = oldset->nodeTab[i]->doc;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax], ecx
$LN133@xmlXPathCo:

; 13725: 			if (tmp == NULL) {

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR _tmp$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	test	eax, eax
	jne	SHORT $LN134@xmlXPathCo

; 13726: 			    tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	push	ecx
	call	_xmlXPathCacheNewNodeSet
	add	esp, 8
	mov	DWORD PTR _tmp$2$[ebp], eax

; 13727: 				ctxt->context->node);
; 13728: 			} else {

	jmp	SHORT $LN136@xmlXPathCo
$LN134@xmlXPathCo:

; 13729: 			    if (xmlXPathNodeSetAddUnique(tmp->nodesetval,
; 13730: 				               ctxt->context->node) < 0) {

	push	DWORD PTR [eax+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _tmp$2$[ebp]
	jns	SHORT $LN136@xmlXPathCo

; 13731: 				ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [ebx+8], 15			; 0000000fH
$LN136@xmlXPathCo:

; 13732: 			    }
; 13733: 			}
; 13734:                         valuePush(ctxt, tmp);

	push	eax
	push	ebx
	call	_valuePush

; 13735:                         ctxt->context->contextSize = oldset->nodeNr;

	mov	ecx, DWORD PTR [ebx+12]
	add	esp, 8
	mov	eax, DWORD PTR _oldset$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+68], eax

; 13736:                         ctxt->context->proximityPosition = i + 1;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _i$2$[ebp]
	inc	ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	mov	DWORD PTR [eax+72], ecx

; 13737: 			/*
; 13738: 			* Evaluate the predicate against the context node.
; 13739: 			* Can/should we optimize position() predicates
; 13740: 			* here (e.g. "[1]")?
; 13741: 			*/
; 13742:                         if (op->ch2 != -1)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, -1
	je	SHORT $LN137@xmlXPathCo

; 13743:                             total +=

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax
$LN137@xmlXPathCo:

; 13744:                                 xmlXPathCompOpEval(ctxt,
; 13745:                                                    &comp->steps[op->ch2]);
; 13746: 			if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN185@xmlXPathCo

; 13749: 			}
; 13750: 
; 13751:                         /*
; 13752:                          * The result of the evaluation needs to be tested to
; 13753:                          * decide whether the filter succeeded or not
; 13754:                          */
; 13755: 			/*
; 13756: 			* OPTIMIZE TODO: Can we use
; 13757: 			* xmlXPathNodeSetAdd*Unique()* instead?
; 13758: 			*/
; 13759:                         res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13760:                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	push	eax
	push	ebx
	mov	DWORD PTR _res$3$[ebp], eax
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN140@xmlXPathCo

; 13761:                             if (xmlXPathNodeSetAdd(newset, oldset->nodeTab[i])
; 13762: 			        < 0)

	mov	eax, DWORD PTR _oldset$1$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv3256[ebp]
	push	DWORD PTR [eax+ecx]
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPathNodeSetAdd
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN140@xmlXPathCo

; 13763: 				ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [ebx+8], 15			; 0000000fH
$LN140@xmlXPathCo:

; 13764:                         }
; 13765: 
; 13766:                         /*
; 13767:                          * Cleanup
; 13768:                          */
; 13769:                         if (res != NULL) {

	mov	eax, DWORD PTR _res$3$[ebp]
	test	eax, eax
	je	SHORT $LN141@xmlXPathCo

; 13770: 			    xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN141@xmlXPathCo:

; 13771: 			}
; 13772:                         if (ctxt->value == tmp) {

	mov	eax, DWORD PTR _tmp$2$[ebp]
	cmp	DWORD PTR [ebx+16], eax
	jne	SHORT $LN142@xmlXPathCo

; 13773:                             valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13774: 			    xmlXPathNodeSetClear(tmp->nodesetval, 1);

	mov	eax, DWORD PTR _tmp$2$[ebp]
	push	1
	push	DWORD PTR [eax+4]
	call	_xmlXPathNodeSetClear

; 13775: 			    /*
; 13776: 			    * Don't free the temporary nodeset
; 13777: 			    * in order to avoid massive recreation inside this
; 13778: 			    * loop.
; 13779: 			    */
; 13780:                         } else

	mov	eax, DWORD PTR _tmp$2$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@xmlXPathCo
$LN142@xmlXPathCo:

; 13781: 			    tmp = NULL;

	xor	eax, eax
	mov	DWORD PTR _tmp$2$[ebp], eax
$LN10@xmlXPathCo:

; 13690: 		    /*
; 13691: 		    * SPEC XPath 1.0:
; 13692: 		    *  "For each node in the node-set to be filtered, the
; 13693: 		    *  PredicateExpr is evaluated with that node as the
; 13694: 		    *  context node, with the number of nodes in the
; 13695: 		    *  node-set as the context size, and with the proximity
; 13696: 		    *  position of the node in the node-set with respect to
; 13697: 		    *  the axis as the context position;"
; 13698: 		    * @oldset is the node-set" to be filtered.
; 13699: 		    *
; 13700: 		    * SPEC XPath 1.0:
; 13701: 		    *  "only predicates change the context position and
; 13702: 		    *  context size (see [2.4 Predicates])."
; 13703: 		    * Example:
; 13704: 		    *   node-set  context pos
; 13705: 		    *    nA         1
; 13706: 		    *    nB         2
; 13707: 		    *    nC         3
; 13708: 		    *   After applying predicate [position() > 1] :
; 13709: 		    *   node-set  context pos
; 13710: 		    *    nB         1
; 13711: 		    *    nC         2
; 13712: 		    *
; 13713: 		    * removed the first node in the node-set, then
; 13714: 		    * the context position of the
; 13715: 		    */
; 13716:                     for (i = 0; i < oldset->nodeNr; i++) {

	mov	edx, DWORD PTR _oldset$1$[ebp]
	mov	ecx, DWORD PTR _i$2$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jl	$LL12@xmlXPathCo

; 13782:                     }
; 13783: 		    if (tmp != NULL)

	test	eax, eax
	je	SHORT $LN144@xmlXPathCo

; 13784: 			xmlXPathReleaseObject(ctxt->context, tmp);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN144@xmlXPathCo:

; 13785:                     /*
; 13786:                      * The result is used as the new evaluation set.
; 13787:                      */
; 13788: 		    valuePush(ctxt,

	push	DWORD PTR _newset$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 16					; 00000010H
$filter_error$237:

; 13789: 			xmlXPathCacheWrapNodeSet(ctxt->context, newset));
; 13790: filter_error:
; 13791: 		    xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$2$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13792: 		    ctxt->context->node = oldnode;

	mov	eax, DWORD PTR [ebx+12]
	add	esp, 8
	mov	ecx, DWORD PTR _oldnode$2$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13793: 		    ctxt->context->doc = oldDoc;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldDoc$1$[ebp]
	mov	DWORD PTR [eax], ecx

; 13794:                     ctxt->context->contextSize = oldcs;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldcs$2$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 13795:                     ctxt->context->proximityPosition = oldpp;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldpp$2$[ebp]
	mov	DWORD PTR [eax+72], ecx
$LN132@xmlXPathCo:

; 13796:                 }
; 13797:                 return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN185@xmlXPathCo:

; 13747: 			    xmlXPathFreeNodeSet(newset);

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPathFreeNodeSet
	add	esp, 4

; 13748:                             goto filter_error;

	jmp	SHORT $filter_error$237
$LN145@xmlXPathCo:

; 13798:             }
; 13799:         case XPATH_OP_SORT:
; 13800:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN147@xmlXPathCo

; 13801:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13802: 	    CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN214@xmlXPathCo
$LN147@xmlXPathCo:

; 13803:             if ((ctxt->value != NULL) &&
; 13804:                 (ctxt->value->type == XPATH_NODESET) &&
; 13805:                 (ctxt->value->nodesetval != NULL) &&

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN65@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	$LN65@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN65@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	$LN65@xmlXPathCo

; 13806: 		(ctxt->value->nodesetval->nodeNr > 1))
; 13807: 	    {
; 13808:                 xmlXPathNodeSetSort(ctxt->value->nodesetval);

	push	eax
	call	_xmlXPathNodeSetSort
	add	esp, 4

; 13809: 	    }
; 13810:             return (total);

	mov	eax, edi
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN149@xmlXPathCo:

; 13811: #ifdef LIBXML_XPTR_ENABLED
; 13812:         case XPATH_OP_RANGETO:{
; 13813:                 xmlXPathObjectPtr range;
; 13814:                 xmlXPathObjectPtr res, obj;
; 13815:                 xmlXPathObjectPtr tmp;
; 13816:                 xmlLocationSetPtr newlocset = NULL;
; 13817: 		    xmlLocationSetPtr oldlocset;
; 13818:                 xmlNodeSetPtr oldset;
; 13819:                 xmlNodePtr oldnode = ctxt->context->node;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnode$1$[ebp], ecx

; 13820:                 int oldcs = ctxt->context->contextSize;

	mov	ecx, DWORD PTR [eax+68]

; 13821:                 int oldpp = ctxt->context->proximityPosition;

	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR _oldpp$1$[ebp], eax

; 13822:                 int i, j;
; 13823: 
; 13824:                 if (op->ch1 != -1) {

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _oldcs$1$[ebp], ecx
	cmp	eax, -1
	je	SHORT $LN212@xmlXPathCo

; 13825:                     total +=

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	edi, eax

; 13826:                         xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
; 13827:                     CHECK_ERROR0;

	cmp	DWORD PTR [ebx+8], 0
	mov	DWORD PTR _total$11$[ebp], edi
	jne	$LN214@xmlXPathCo
$LN212@xmlXPathCo:

; 13828:                 }
; 13829:                 if (ctxt->value == NULL) {

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	jne	SHORT $LN152@xmlXPathCo

; 13830:                     XP_ERROR0(XPATH_INVALID_OPERAND);

	push	10					; 0000000aH
	push	ebx
	call	_xmlXPathErr
	add	esp, 8

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN152@xmlXPathCo:

; 13831:                 }
; 13832:                 if (op->ch2 == -1)

	cmp	DWORD PTR [esi+8], -1
	je	$LN27@xmlXPathCo

; 13833:                     return (total);
; 13834: 
; 13835:                 if (ctxt->value->type == XPATH_LOCATIONSET) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 7
	jne	$LN154@xmlXPathCo

; 13836:                     /*
; 13837:                      * Extract the old locset, and then evaluate the result of the
; 13838:                      * expression for all the element in the locset. use it to grow
; 13839:                      * up a new locset.
; 13840:                      */
; 13841:                     CHECK_TYPE0(XPATH_LOCATIONSET);
; 13842: 
; 13843:                     if ((ctxt->value->user == NULL) ||

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	$LN27@xmlXPathCo
	cmp	DWORD PTR [eax], 0
	je	$LN27@xmlXPathCo

; 13844:                         (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))
; 13845:                         return (total);
; 13846: 
; 13847:                     obj = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	DWORD PTR _obj$1$[ebp], eax

; 13848:                     oldlocset = obj->user;
; 13849: 
; 13850:                     newlocset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _oldlocset$1$[ebp], eax
	call	_xmlXPtrLocationSetCreate

; 13851: 
; 13852:                     for (i = 0; i < oldlocset->locNr; i++) {

	mov	edx, DWORD PTR _oldlocset$1$[ebp]
	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR _newlocset$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [edx], ecx
	jle	$LN20@xmlXPathCo
$LL15@xmlXPathCo:

; 13853:                         /*
; 13854:                          * Run the evaluation with a node list made of a
; 13855:                          * single item in the nodelocset.
; 13856:                          */
; 13857:                         ctxt->context->node = oldlocset->locTab[i]->user;

	mov	eax, DWORD PTR [edx+8]
	shl	ecx, 2
	mov	DWORD PTR tv3250[ebp], ecx
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+4], eax

; 13858:                         ctxt->context->contextSize = oldlocset->locNr;

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+68], eax

; 13859:                         ctxt->context->proximityPosition = i + 1;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR [eax+72], ecx

; 13860: 			tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet

; 13861: 			    ctxt->context->node);
; 13862:                         valuePush(ctxt, tmp);

	push	eax
	push	ebx
	mov	DWORD PTR _tmp$1$[ebp], eax
	call	_valuePush

; 13863: 
; 13864:                         if (op->ch2 != -1)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	cmp	ecx, -1
	je	SHORT $LN160@xmlXPathCo

; 13865:                             total +=

	mov	eax, DWORD PTR _comp$1$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax
	mov	DWORD PTR _total$11$[ebp], edi
$LN160@xmlXPathCo:

; 13866:                                 xmlXPathCompOpEval(ctxt,
; 13867:                                                    &comp->steps[op->ch2]);
; 13868: 			if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN186@xmlXPathCo

; 13869:                             xmlXPtrFreeLocationSet(newlocset);
; 13870:                             goto rangeto_error;
; 13871: 			}
; 13872: 
; 13873:                         res = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _res$1$[ebp], ecx

; 13874: 			if (res->type == XPATH_LOCATIONSET) {

	cmp	DWORD PTR [ecx], 7
	jne	SHORT $LN162@xmlXPathCo

; 13875: 			    xmlLocationSetPtr rloc =

	mov	ecx, DWORD PTR [ecx+28]

; 13876: 			        (xmlLocationSetPtr)res->user;
; 13877: 			    for (j=0; j<rloc->locNr; j++) {

	xor	edi, edi
	mov	DWORD PTR _rloc$1$[ebp], ecx
	cmp	DWORD PTR [ecx], edi
	jle	SHORT $LN165@xmlXPathCo
	mov	ebx, DWORD PTR _newlocset$1$[ebp]
	mov	esi, ecx
	npad	8
$LL18@xmlXPathCo:

; 13878: 			        range = xmlXPtrNewRange(

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR tv3250[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _oldlocset$1$[ebp]
	push	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax]
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax+28]
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H

; 13879: 				  oldlocset->locTab[i]->user,
; 13880: 				  oldlocset->locTab[i]->index,
; 13881: 				  rloc->locTab[j]->user2,
; 13882: 				  rloc->locTab[j]->index2);
; 13883: 				if (range != NULL) {

	test	eax, eax
	je	SHORT $LN16@xmlXPathCo

; 13884: 				    xmlXPtrLocationSetAdd(newlocset, range);

	push	eax
	push	ebx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN16@xmlXPathCo:

; 13876: 			        (xmlLocationSetPtr)res->user;
; 13877: 			    for (j=0; j<rloc->locNr; j++) {

	inc	edi
	cmp	edi, DWORD PTR [esi]
	jl	SHORT $LL18@xmlXPathCo
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _op$[ebp]
	jmp	SHORT $LN165@xmlXPathCo
$LN162@xmlXPathCo:

; 13885: 				}
; 13886: 			    }
; 13887: 			} else {
; 13888: 			    range = xmlXPtrNewRangeNodeObject(

	mov	eax, DWORD PTR _oldlocset$1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv3250[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+28]
	call	_xmlXPtrNewRangeNodeObject
	add	esp, 8

; 13889: 				(xmlNodePtr)oldlocset->locTab[i]->user, res);
; 13890:                             if (range != NULL) {

	test	eax, eax
	je	SHORT $LN165@xmlXPathCo

; 13891:                                 xmlXPtrLocationSetAdd(newlocset,range);

	push	eax
	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN165@xmlXPathCo:

; 13892: 			    }
; 13893:                         }
; 13894: 
; 13895:                         /*
; 13896:                          * Cleanup
; 13897:                          */
; 13898:                         if (res != NULL) {
; 13899: 			    xmlXPathReleaseObject(ctxt->context, res);

	push	DWORD PTR _res$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13900: 			}
; 13901:                         if (ctxt->value == tmp) {

	mov	eax, DWORD PTR _tmp$1$[ebp]
	add	esp, 8
	cmp	DWORD PTR [ebx+16], eax
	jne	SHORT $LN13@xmlXPathCo

; 13902:                             res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13903: 			    xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH
$LN13@xmlXPathCo:

; 13851: 
; 13852:                     for (i = 0; i < oldlocset->locNr; i++) {

	mov	edx, DWORD PTR _oldlocset$1$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edi, DWORD PTR _total$11$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jl	$LL15@xmlXPathCo

; 13929:                                     xmlXPathCompOpEval(ctxt,
; 13930:                                                    &comp->steps[op->ch2]);
; 13931: 			    if (ctxt->error != XPATH_EXPRESSION_OK) {

	jmp	$LN224@xmlXPathCo
$LN186@xmlXPathCo:

; 13962: rangeto_error:
; 13963: 		xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrFreeLocationSet
	add	esp, 4
	jmp	$rangeto_error$238
$LN154@xmlXPathCo:

; 13904:                         }
; 13905:                     }
; 13906: 		} else {	/* Not a location set */
; 13907:                     CHECK_TYPE0(XPATH_NODESET);

	cmp	ecx, 1
	jne	$LN169@xmlXPathCo

; 13908:                     obj = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13909:                     oldset = obj->nodesetval;
; 13910: 
; 13911:                     newlocset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	DWORD PTR _obj$1$[ebp], eax
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldset$1$[ebp], ecx
	call	_xmlXPtrLocationSetCreate
	mov	DWORD PTR _newlocset$1$[ebp], eax
	add	esp, 8

; 13912: 
; 13913:                     if (oldset != NULL) {

	mov	eax, DWORD PTR _oldset$1$[ebp]
	test	eax, eax
	je	$LN224@xmlXPathCo

; 13914:                         for (i = 0; i < oldset->nodeNr; i++) {

	xor	edx, edx
	mov	DWORD PTR _i$2$[ebp], edx
	cmp	DWORD PTR [eax], edx
	jle	$LN224@xmlXPathCo
$LL21@xmlXPathCo:

; 13915:                             /*
; 13916:                              * Run the evaluation with a node list made of a single item
; 13917:                              * in the nodeset.
; 13918:                              */
; 13919:                             ctxt->context->node = oldset->nodeTab[i];

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+4], eax

; 13920: 			    /*
; 13921: 			    * OPTIMIZE TODO: Avoid recreation for every iteration.
; 13922: 			    */
; 13923: 			    tmp = xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [ebx+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet

; 13924: 				ctxt->context->node);
; 13925:                             valuePush(ctxt, tmp);

	push	eax
	push	ebx
	mov	DWORD PTR _tmp$2$[ebp], eax
	call	_valuePush

; 13926: 
; 13927:                             if (op->ch2 != -1)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	cmp	ecx, -1
	je	SHORT $LN171@xmlXPathCo

; 13928:                                 total +=

	mov	eax, DWORD PTR _comp$1$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	edi, eax
	mov	DWORD PTR _total$11$[ebp], edi
$LN171@xmlXPathCo:

; 13929:                                     xmlXPathCompOpEval(ctxt,
; 13930:                                                    &comp->steps[op->ch2]);
; 13931: 			    if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	jne	$LN186@xmlXPathCo

; 13932:                                 xmlXPtrFreeLocationSet(newlocset);
; 13933:                                 goto rangeto_error;
; 13934: 			    }
; 13935: 
; 13936:                             res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13937:                             range =

	mov	ecx, DWORD PTR _oldset$1$[ebp]
	mov	edx, DWORD PTR _i$2$[ebp]
	push	eax
	mov	DWORD PTR _res$3$[ebp], eax
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+edx*4]
	call	_xmlXPtrNewRangeNodeObject
	add	esp, 12					; 0000000cH

; 13938:                                 xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],
; 13939:                                                       res);
; 13940:                             if (range != NULL) {

	test	eax, eax
	je	SHORT $LN173@xmlXPathCo

; 13941:                                 xmlXPtrLocationSetAdd(newlocset, range);

	push	eax
	push	DWORD PTR _newlocset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN173@xmlXPathCo:

; 13942:                             }
; 13943: 
; 13944:                             /*
; 13945:                              * Cleanup
; 13946:                              */
; 13947:                             if (res != NULL) {

	mov	eax, DWORD PTR _res$3$[ebp]
	test	eax, eax
	je	SHORT $LN174@xmlXPathCo

; 13948: 				xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
$LN174@xmlXPathCo:

; 13949: 			    }
; 13950:                             if (ctxt->value == tmp) {

	mov	eax, DWORD PTR _tmp$2$[ebp]
	cmp	DWORD PTR [ebx+16], eax
	jne	SHORT $LN19@xmlXPathCo

; 13951:                                 res = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 13952: 				xmlXPathReleaseObject(ctxt->context, res);

	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH
$LN19@xmlXPathCo:

; 13914:                         for (i = 0; i < oldset->nodeNr; i++) {

	mov	edx, DWORD PTR _i$2$[ebp]
	mov	eax, DWORD PTR _oldset$1$[ebp]
	inc	edx
	mov	DWORD PTR _i$2$[ebp], edx
	cmp	edx, DWORD PTR [eax]
	jl	$LL21@xmlXPathCo
$LN224@xmlXPathCo:

; 13953:                             }
; 13954:                         }
; 13955:                     }
; 13956:                 }
; 13957: 
; 13958:                 /*
; 13959:                  * The result is used as the new evaluation set.
; 13960:                  */
; 13961:                 valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));

	mov	eax, DWORD PTR _newlocset$1$[ebp]
$LN20@xmlXPathCo:
	push	eax
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	ebx
	call	_valuePush
	add	esp, 12					; 0000000cH
$rangeto_error$238:

; 13962: rangeto_error:
; 13963: 		xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 13964:                 ctxt->context->node = oldnode;

	mov	eax, DWORD PTR [ebx+12]
	add	esp, 8
	mov	ecx, DWORD PTR _oldnode$1$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13965:                 ctxt->context->contextSize = oldcs;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldcs$1$[ebp]
	pop	edi

; 13974:     return (total);
; 13975: }

	pop	esi
	mov	DWORD PTR [eax+68], ecx
	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _oldpp$1$[ebp]
	pop	ebx
	mov	DWORD PTR [eax+72], ecx
	mov	eax, DWORD PTR _total$11$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN169@xmlXPathCo:

; 13904:                         }
; 13905:                     }
; 13906: 		} else {	/* Not a location set */
; 13907:                     CHECK_TYPE0(XPATH_NODESET);

	push	11					; 0000000bH
	push	ebx
	call	_xmlXPathErr
	add	esp, 8

; 13974:     return (total);
; 13975: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathCo:

; 13966:                 ctxt->context->proximityPosition = oldpp;
; 13967:                 return (total);
; 13968:             }
; 13969: #endif /* LIBXML_XPTR_ENABLED */
; 13970:     }
; 13971:     xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [esi]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0CJ@OFCEKGJC@XPath?3?5unknown?5precompiled?5oper@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH

; 13972:                     "XPath: unknown precompiled operation %d\n", op->op);
; 13973:     ctxt->error = XPATH_INVALID_OPERAND;

	mov	DWORD PTR [ebx+8], 10			; 0000000aH
$LN214@xmlXPathCo:

; 13974:     return (total);
; 13975: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN235@xmlXPathCo:
	DD	$LN214@xmlXPathCo
	DD	$LN24@xmlXPathCo
	DD	$LN30@xmlXPathCo
	DD	$LN36@xmlXPathCo
	DD	$LN41@xmlXPathCo
	DD	$LN44@xmlXPathCo
	DD	$LN58@xmlXPathCo
	DD	$LN66@xmlXPathCo
	DD	$LN73@xmlXPathCo
	DD	$LN74@xmlXPathCo
	DD	$LN79@xmlXPathCo
	DD	$LN82@xmlXPathCo
	DD	$LN83@xmlXPathCo
	DD	$LN90@xmlXPathCo
	DD	$LN101@xmlXPathCo
	DD	$LN106@xmlXPathCo
	DD	$LN106@xmlXPathCo
	DD	$LN145@xmlXPathCo
	DD	$LN149@xmlXPathCo
_xmlXPathCompOpEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompStep
_TEXT	SEGMENT
_op1$1$ = -20						; size = 4
_type$1 = -16						; size = 4
_op2$1$ = -12						; size = 4
_rangeto$1$ = -8					; size = 4
_test$2 = -4						; size = 4
_prefix$3 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathCompStep PROC					; COMDAT

; 11308: xmlXPathCompStep(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _rangeto$1$[ebp], 0
	mov	DWORD PTR _op2$1$[ebp], -1
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 11309: #ifdef LIBXML_XPTR_ENABLED
; 11310:     int rangeto = 0;
; 11311:     int op2 = -1;
; 11312: #endif
; 11313: 
; 11314:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN20@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN21@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN20@xmlXPathCo
$LN21@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN20@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 11315:     if ((CUR == '.') && (NXT(1) == '.')) {

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN26@xmlXPathCo
	cmp	BYTE PTR [ecx+1], 46			; 0000002eH
	lea	eax, DWORD PTR [ecx+1]
	jne	SHORT $LN177@xmlXPathCo

; 11316: 	SKIP(2);

	lea	eax, DWORD PTR [ecx+2]
$LN198@xmlXPathCo:

; 11317: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], eax
$LL4@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN24@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN25@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN24@xmlXPathCo
$LN25@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN24@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL4@xmlXPathCo
	inc	eax
	jmp	SHORT $LN198@xmlXPathCo
$LN5@xmlXPathCo:

; 11318: 	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	1
	push	10					; 0000000aH
	push	10					; 0000000aH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
	pop	esi

; 11436: 			   test, type, (void *)prefix, (void *)name);
; 11437: 
; 11438:     }
; 11439: #ifdef DEBUG_STEP
; 11440:     xmlGenericError(xmlGenericErrorContext, "Step : ");
; 11441:     if (ctxt->value == NULL)
; 11442: 	xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11443:     else if (ctxt->value->nodesetval == NULL)
; 11444: 	xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11445:     else
; 11446: 	xmlGenericErrorContextNodeSet(xmlGenericErrorContext,
; 11447: 		ctxt->value->nodesetval);
; 11448: #endif
; 11449: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN177@xmlXPathCo:

; 11319: 		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
; 11320:     } else if (CUR == '.') {
; 11321: 	NEXT;
; 11322: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], eax
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN28@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN29@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN28@xmlXPathCo
$LN29@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	$LN61@xmlXPathCo
$LN28@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL6@xmlXPathCo
	inc	eax
	jmp	SHORT $LN177@xmlXPathCo
$LN26@xmlXPathCo:
	push	ebx

; 11323:     } else {
; 11324: 	xmlChar *name = NULL;

	xor	ebx, ebx
	push	edi

; 11325: 	const xmlChar *prefix = NULL;
; 11326: 	xmlXPathTestVal test = (xmlXPathTestVal) 0;
; 11327: 	xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;

	xor	edi, edi
	mov	DWORD PTR _prefix$3[ebp], ebx
	mov	DWORD PTR _test$2[ebp], ebx

; 11328: 	xmlXPathTypeVal type = (xmlXPathTypeVal) 0;

	mov	DWORD PTR _type$1[ebp], ebx

; 11329: 	int op1;
; 11330: 
; 11331: 	/*
; 11332: 	 * The modification needed for XPointer change to the production
; 11333: 	 */
; 11334: #ifdef LIBXML_XPTR_ENABLED
; 11335: 	if (ctxt->xptr) {

	cmp	DWORD PTR [esi+36], ebx
	je	$LN31@xmlXPathCo

; 11336: 	    name = xmlXPathParseNCName(ctxt);

	push	esi
	call	_xmlXPathParseNCName
	mov	ebx, eax
	add	esp, 4

; 11337: 	    if ((name != NULL) && (xmlStrEqual(name, BAD_CAST "range-to"))) {

	test	ebx, ebx
	je	$LN31@xmlXPathCo
	push	OFFSET ??_C@_08KHINJAEH@range?9to@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN31@xmlXPathCo

; 11338:                 op2 = ctxt->comp->last;

	mov	eax, DWORD PTR [esi+32]

; 11339: 		xmlFree(name);

	push	ebx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _op2$1$[ebp], eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	npad	7
$LL8@xmlXPathCo:

; 11340: 		SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN32@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN33@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN32@xmlXPathCo
$LN33@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN32@xmlXPathCo:
	test	al, al
	je	SHORT $LL8@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL8@xmlXPathCo
$LN9@xmlXPathCo:

; 11341: 		if (CUR != '(') {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN191@xmlXPathCo
$LN199@xmlXPathCo:

; 11342: 		    XP_ERROR(XPATH_EXPR_ERROR);
; 11343: 		}
; 11344: 		NEXT;
; 11345: 		SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL10@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN35@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN36@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN35@xmlXPathCo
$LN36@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN11@xmlXPathCo
$LN35@xmlXPathCo:
	test	al, al
	je	SHORT $LL10@xmlXPathCo
	jmp	SHORT $LN199@xmlXPathCo
$LN11@xmlXPathCo:

; 11346: 
; 11347: 		xmlXPathCompileExpr(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompileExpr
	add	esp, 8

; 11348: 		/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); */
; 11349: 		CHECK_ERROR;

	cmp	DWORD PTR [esi+8], edi
	jne	$LN196@xmlXPathCo
	mov	ecx, DWORD PTR [esi]
$LL12@xmlXPathCo:

; 11350: 
; 11351: 		SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN38@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN39@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN38@xmlXPathCo
$LN39@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN13@xmlXPathCo
$LN38@xmlXPathCo:
	test	al, al
	je	SHORT $LL12@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL12@xmlXPathCo
$LN13@xmlXPathCo:

; 11352: 		if (CUR != ')') {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN191@xmlXPathCo

; 11354: 		}
; 11355: 		NEXT;

	lea	eax, DWORD PTR [ecx+1]

; 11356: 		rangeto = 1;

	mov	DWORD PTR _rangeto$1$[ebp], 1
	mov	DWORD PTR [esi], eax

; 11357: 		goto eval_predicates;

	jmp	$eval_predicates$204
$LN191@xmlXPathCo:

; 11353: 		    XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 11436: 			   test, type, (void *)prefix, (void *)name);
; 11437: 
; 11438:     }
; 11439: #ifdef DEBUG_STEP
; 11440:     xmlGenericError(xmlGenericErrorContext, "Step : ");
; 11441:     if (ctxt->value == NULL)
; 11442: 	xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11443:     else if (ctxt->value->nodesetval == NULL)
; 11444: 	xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11445:     else
; 11446: 	xmlGenericErrorContextNodeSet(xmlGenericErrorContext,
; 11447: 		ctxt->value->nodesetval);
; 11448: #endif
; 11449: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlXPathCo:

; 11358: 	    }
; 11359: 	}
; 11360: #endif
; 11361: 	if (CUR == '*') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 42			; 0000002aH
	je	$LN46@xmlXPathCo

; 11362: 	    axis = AXIS_CHILD;
; 11363: 	} else {
; 11364: 	    if (name == NULL)

	test	ebx, ebx
	jne	SHORT $LN187@xmlXPathCo

; 11365: 		name = xmlXPathParseNCName(ctxt);

	push	esi
	call	_xmlXPathParseNCName
	mov	ebx, eax
	add	esp, 4

; 11366: 	    if (name != NULL) {

	test	ebx, ebx
	jne	SHORT $LN187@xmlXPathCo

; 11375: 			/* an element name can conflict with an axis one :-\ */
; 11376: 			axis = AXIS_CHILD;
; 11377: 		    }
; 11378: 		} else {
; 11379: 		    axis = AXIS_CHILD;
; 11380: 		}
; 11381: 	    } else if (CUR == '@') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 64			; 00000040H
	jne	$LN46@xmlXPathCo

; 11382: 		NEXT;

	inc	eax

; 11383: 		axis = AXIS_ATTRIBUTE;

	lea	edi, DWORD PTR [ebx+3]
	mov	DWORD PTR [esi], eax

; 11384: 	    } else {
; 11385: 		axis = AXIS_CHILD;

	jmp	$LN53@xmlXPathCo
$LN187@xmlXPathCo:

; 11230:     switch (name[0]) {

	movzx	eax, BYTE PTR [ebx]
	xor	edi, edi
	add	eax, -97				; ffffff9fH
	cmp	eax, 18					; 00000012H
	ja	$LN134@xmlXPathCo
	movzx	eax, BYTE PTR $LN193@xmlXPathCo[eax]
	jmp	DWORD PTR $LN203@xmlXPathCo[eax*4]
$LN115@xmlXPathCo:

; 11231: 	case 'a':
; 11232: 	    if (xmlStrEqual(name, BAD_CAST "ancestor"))

	push	OFFSET ??_C@_08HBEFDOBD@ancestor@
	push	ebx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 1

; 11233: 		ret = AXIS_ANCESTOR;
; 11234: 	    if (xmlStrEqual(name, BAD_CAST "ancestor-or-self"))

	push	OFFSET ??_C@_0BB@OLBPNJCF@ancestor?9or?9self@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 2

; 11235: 		ret = AXIS_ANCESTOR_OR_SELF;
; 11236: 	    if (xmlStrEqual(name, BAD_CAST "attribute"))

	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN134@xmlXPathCo

; 11237: 		ret = AXIS_ATTRIBUTE;

	mov	edi, 3

; 11238: 	    break;

	jmp	$LN134@xmlXPathCo
$LN119@xmlXPathCo:

; 11239: 	case 'c':
; 11240: 	    if (xmlStrEqual(name, BAD_CAST "child"))

	push	OFFSET ??_C@_05GPGNDLEK@child@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN134@xmlXPathCo

; 11241: 		ret = AXIS_CHILD;

	mov	edi, 4

; 11242: 	    break;

	jmp	$LN134@xmlXPathCo
$LN121@xmlXPathCo:

; 11243: 	case 'd':
; 11244: 	    if (xmlStrEqual(name, BAD_CAST "descendant"))

	push	OFFSET ??_C@_0L@NJLDCKIO@descendant@
	push	ebx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 5

; 11245: 		ret = AXIS_DESCENDANT;
; 11246: 	    if (xmlStrEqual(name, BAD_CAST "descendant-or-self"))

	push	OFFSET ??_C@_0BD@EPJHOOIL@descendant?9or?9self@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN134@xmlXPathCo

; 11247: 		ret = AXIS_DESCENDANT_OR_SELF;

	mov	edi, 6

; 11248: 	    break;

	jmp	$LN134@xmlXPathCo
$LN124@xmlXPathCo:

; 11249: 	case 'f':
; 11250: 	    if (xmlStrEqual(name, BAD_CAST "following"))

	push	OFFSET ??_C@_09BEIPBMDN@following@
	push	ebx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 7

; 11251: 		ret = AXIS_FOLLOWING;
; 11252: 	    if (xmlStrEqual(name, BAD_CAST "following-sibling"))

	push	OFFSET ??_C@_0BC@LMFKEKDG@following?9sibling@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN134@xmlXPathCo

; 11253: 		ret = AXIS_FOLLOWING_SIBLING;

	mov	edi, 8

; 11254: 	    break;

	jmp	SHORT $LN134@xmlXPathCo
$LN127@xmlXPathCo:

; 11255: 	case 'n':
; 11256: 	    if (xmlStrEqual(name, BAD_CAST "namespace"))

	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN134@xmlXPathCo

; 11257: 		ret = AXIS_NAMESPACE;

	mov	edi, 9

; 11258: 	    break;

	jmp	SHORT $LN134@xmlXPathCo
$LN129@xmlXPathCo:

; 11259: 	case 'p':
; 11260: 	    if (xmlStrEqual(name, BAD_CAST "parent"))

	push	OFFSET ??_C@_06MLKDMCBD@parent@
	push	ebx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 10					; 0000000aH

; 11261: 		ret = AXIS_PARENT;
; 11262: 	    if (xmlStrEqual(name, BAD_CAST "preceding"))

	push	OFFSET ??_C@_09MGMONEC@preceding@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 11					; 0000000bH

; 11263: 		ret = AXIS_PRECEDING;
; 11264: 	    if (xmlStrEqual(name, BAD_CAST "preceding-sibling"))

	push	OFFSET ??_C@_0BC@MLGDENAI@preceding?9sibling@
	push	ebx
	cmovne	edi, ecx
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN134@xmlXPathCo

; 11265: 		ret = AXIS_PRECEDING_SIBLING;

	mov	edi, 12					; 0000000cH

; 11266: 	    break;

	jmp	SHORT $LN134@xmlXPathCo
$LN133@xmlXPathCo:

; 11267: 	case 's':
; 11268: 	    if (xmlStrEqual(name, BAD_CAST "self"))

	push	OFFSET ??_C@_04PJDNGLKJ@self@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	mov	ecx, 13					; 0000000dH
	test	eax, eax
	cmovne	edi, ecx
$LN134@xmlXPathCo:

; 11367: 		axis = xmlXPathIsAxisName(name);
; 11368: 		if (axis != 0) {

	test	edi, edi
	je	SHORT $LN46@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	npad	4
$LL14@xmlXPathCo:

; 11369: 		    SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN48@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN49@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN48@xmlXPathCo
$LN49@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN15@xmlXPathCo
$LN48@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL14@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL14@xmlXPathCo
$LN15@xmlXPathCo:

; 11370: 		    if ((CUR == ':') && (NXT(1) == ':')) {

	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN46@xmlXPathCo
	cmp	BYTE PTR [eax+1], cl
	jne	SHORT $LN46@xmlXPathCo

; 11371: 			SKIP(2);

	add	eax, 2

; 11372: 			xmlFree(name);

	push	ebx
	mov	DWORD PTR [esi], eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 11373: 			name = NULL;

	xor	ebx, ebx

; 11374: 		    } else {

	jmp	SHORT $LN53@xmlXPathCo
$LN46@xmlXPathCo:

; 11386: 	    }
; 11387: 	}
; 11388: 
; 11389:         if (ctxt->error != XPATH_EXPRESSION_OK) {

	mov	edi, 4
$LN53@xmlXPathCo:
	cmp	DWORD PTR [esi+8], 0
	push	ebx
	je	SHORT $LN54@xmlXPathCo

; 11390:             xmlFree(name);

	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	ebx
	pop	esi

; 11436: 			   test, type, (void *)prefix, (void *)name);
; 11437: 
; 11438:     }
; 11439: #ifdef DEBUG_STEP
; 11440:     xmlGenericError(xmlGenericErrorContext, "Step : ");
; 11441:     if (ctxt->value == NULL)
; 11442: 	xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11443:     else if (ctxt->value->nodesetval == NULL)
; 11444: 	xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11445:     else
; 11446: 	xmlGenericErrorContextNodeSet(xmlGenericErrorContext,
; 11447: 		ctxt->value->nodesetval);
; 11448: #endif
; 11449: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@xmlXPathCo:

; 11391:             return;
; 11392:         }
; 11393: 
; 11394: 	name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);

	lea	eax, DWORD PTR _prefix$3[ebp]
	push	eax
	lea	eax, DWORD PTR _type$1[ebp]
	push	eax
	lea	eax, DWORD PTR _test$2[ebp]
	push	eax
	push	esi
	call	_xmlXPathCompNodeTest
	add	esp, 20					; 00000014H
	mov	ebx, eax

; 11395: 	if (test == 0)

	cmp	DWORD PTR _test$2[ebp], 0
	je	$LN196@xmlXPathCo

; 11396: 	    return;
; 11397: 
; 11398:         if ((prefix != NULL) && (ctxt->context != NULL) &&

	mov	ecx, DWORD PTR _prefix$3[ebp]
	test	ecx, ecx
	je	SHORT $eval_predicates$204
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $eval_predicates$204
	test	BYTE PTR [eax+196], 1
	je	SHORT $eval_predicates$204

; 11399: 	    (ctxt->context->flags & XML_XPATH_CHECKNS)) {
; 11400: 	    if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {

	push	ecx
	push	eax
	call	_xmlXPathNsLookup
	add	esp, 8
	test	eax, eax
	jne	SHORT $eval_predicates$204

; 11401: 		xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);

	push	19					; 00000013H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$eval_predicates$204:

; 11402: 	    }
; 11403: 	}
; 11404: #ifdef DEBUG_STEP
; 11405: 	xmlGenericError(xmlGenericErrorContext,
; 11406: 		"Basis : computing new set\n");
; 11407: #endif
; 11408: 
; 11409: #ifdef DEBUG_STEP
; 11410: 	xmlGenericError(xmlGenericErrorContext, "Basis : ");
; 11411: 	if (ctxt->value == NULL)
; 11412: 	    xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11413: 	else if (ctxt->value->nodesetval == NULL)
; 11414: 	    xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11415: 	else
; 11416: 	    xmlGenericErrorContextNodeSet(stdout, ctxt->value->nodesetval);
; 11417: #endif
; 11418: 
; 11419: #ifdef LIBXML_XPTR_ENABLED
; 11420: eval_predicates:
; 11421: #endif
; 11422: 	op1 = ctxt->comp->last;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+12]

; 11423: 	ctxt->comp->last = -1;

	mov	DWORD PTR [eax+12], -1
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _op1$1$[ebp], edx
	npad	5
$LL16@xmlXPathCo:

; 11424: 
; 11425: 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN58@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN59@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN58@xmlXPathCo
$LN59@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN145@xmlXPathCo
$LN58@xmlXPathCo:
	test	al, al
	je	SHORT $LL16@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL16@xmlXPathCo
$LN145@xmlXPathCo:

; 11426: 	while (CUR == '[') {

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN19@xmlXPathCo
	npad	1
$LL18@xmlXPathCo:

; 11427: 	    xmlXPathCompPredicate(ctxt, 0);

	push	0
	push	esi
	call	_xmlXPathCompPredicate
	mov	eax, DWORD PTR [esi]
	add	esp, 8
	cmp	BYTE PTR [eax], 91			; 0000005bH
	je	SHORT $LL18@xmlXPathCo
	mov	edx, DWORD PTR _op1$1$[ebp]
$LN19@xmlXPathCo:

; 11428: 	}
; 11429: 
; 11430: #ifdef LIBXML_XPTR_ENABLED
; 11431: 	if (rangeto) {

	cmp	DWORD PTR _rangeto$1$[ebp], 0
	mov	eax, DWORD PTR [esi+32]
	je	SHORT $LN60@xmlXPathCo

; 11432: 	    PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	18					; 00000012H
	push	edx
	push	DWORD PTR _op2$1$[ebp]

; 11433: 	} else
; 11434: #endif
; 11435: 	    PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,

	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
	pop	edi
	pop	ebx
	pop	esi

; 11436: 			   test, type, (void *)prefix, (void *)name);
; 11437: 
; 11438:     }
; 11439: #ifdef DEBUG_STEP
; 11440:     xmlGenericError(xmlGenericErrorContext, "Step : ");
; 11441:     if (ctxt->value == NULL)
; 11442: 	xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11443:     else if (ctxt->value->nodesetval == NULL)
; 11444: 	xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11445:     else
; 11446: 	xmlGenericErrorContextNodeSet(xmlGenericErrorContext,
; 11447: 		ctxt->value->nodesetval);
; 11448: #endif
; 11449: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@xmlXPathCo:

; 11433: 	} else
; 11434: #endif
; 11435: 	    PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,

	push	ebx
	push	DWORD PTR _prefix$3[ebp]
	push	DWORD PTR _type$1[ebp]
	push	DWORD PTR _test$2[ebp]
	push	edi
	push	10					; 0000000aH
	push	DWORD PTR [eax+12]
	push	edx
	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
$LN196@xmlXPathCo:
	pop	edi
	pop	ebx
$LN61@xmlXPathCo:
	pop	esi

; 11436: 			   test, type, (void *)prefix, (void *)name);
; 11437: 
; 11438:     }
; 11439: #ifdef DEBUG_STEP
; 11440:     xmlGenericError(xmlGenericErrorContext, "Step : ");
; 11441:     if (ctxt->value == NULL)
; 11442: 	xmlGenericError(xmlGenericErrorContext, "no value\n");
; 11443:     else if (ctxt->value->nodesetval == NULL)
; 11444: 	xmlGenericError(xmlGenericErrorContext, "Empty\n");
; 11445:     else
; 11446: 	xmlGenericErrorContextNodeSet(xmlGenericErrorContext,
; 11447: 		ctxt->value->nodesetval);
; 11448: #endif
; 11449: }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN203@xmlXPathCo:
	DD	$LN115@xmlXPathCo
	DD	$LN119@xmlXPathCo
	DD	$LN121@xmlXPathCo
	DD	$LN124@xmlXPathCo
	DD	$LN127@xmlXPathCo
	DD	$LN129@xmlXPathCo
	DD	$LN133@xmlXPathCo
	DD	$LN134@xmlXPathCo
$LN193@xmlXPathCo:
	DB	0
	DB	7
	DB	1
	DB	2
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	5
	DB	7
	DB	7
	DB	6
_xmlXPathCompStep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsAxisName
_TEXT	SEGMENT
_name$ = 8						; size = 4
_xmlXPathIsAxisName PROC				; COMDAT

; 11228: xmlXPathIsAxisName(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	xor	esi, esi
	movzx	eax, BYTE PTR [edi]
	add	eax, -97				; ffffff9fH
	cmp	eax, 18					; 00000012H
	ja	$LN23@xmlXPathIs

; 11229:     xmlXPathAxisVal ret = (xmlXPathAxisVal) 0;
; 11230:     switch (name[0]) {

	movzx	eax, BYTE PTR $LN25@xmlXPathIs[eax]
	jmp	DWORD PTR $LN27@xmlXPathIs[eax*4]
$LN4@xmlXPathIs:

; 11231: 	case 'a':
; 11232: 	    if (xmlStrEqual(name, BAD_CAST "ancestor"))

	push	OFFSET ??_C@_08HBEFDOBD@ancestor@
	push	edi
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 1

; 11233: 		ret = AXIS_ANCESTOR;
; 11234: 	    if (xmlStrEqual(name, BAD_CAST "ancestor-or-self"))

	push	OFFSET ??_C@_0BB@OLBPNJCF@ancestor?9or?9self@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 2

; 11235: 		ret = AXIS_ANCESTOR_OR_SELF;
; 11236: 	    if (xmlStrEqual(name, BAD_CAST "attribute"))

	push	OFFSET ??_C@_09HGIEBAJ@attribute@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN23@xmlXPathIs

; 11237: 		ret = AXIS_ATTRIBUTE;

	mov	esi, 3

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN8@xmlXPathIs:

; 11238: 	    break;
; 11239: 	case 'c':
; 11240: 	    if (xmlStrEqual(name, BAD_CAST "child"))

	push	OFFSET ??_C@_05GPGNDLEK@child@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN23@xmlXPathIs

; 11241: 		ret = AXIS_CHILD;

	mov	esi, 4

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN10@xmlXPathIs:

; 11242: 	    break;
; 11243: 	case 'd':
; 11244: 	    if (xmlStrEqual(name, BAD_CAST "descendant"))

	push	OFFSET ??_C@_0L@NJLDCKIO@descendant@
	push	edi
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 5

; 11245: 		ret = AXIS_DESCENDANT;
; 11246: 	    if (xmlStrEqual(name, BAD_CAST "descendant-or-self"))

	push	OFFSET ??_C@_0BD@EPJHOOIL@descendant?9or?9self@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN23@xmlXPathIs

; 11247: 		ret = AXIS_DESCENDANT_OR_SELF;

	mov	esi, 6

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN13@xmlXPathIs:

; 11248: 	    break;
; 11249: 	case 'f':
; 11250: 	    if (xmlStrEqual(name, BAD_CAST "following"))

	push	OFFSET ??_C@_09BEIPBMDN@following@
	push	edi
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 7

; 11251: 		ret = AXIS_FOLLOWING;
; 11252: 	    if (xmlStrEqual(name, BAD_CAST "following-sibling"))

	push	OFFSET ??_C@_0BC@LMFKEKDG@following?9sibling@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN23@xmlXPathIs

; 11253: 		ret = AXIS_FOLLOWING_SIBLING;

	mov	esi, 8

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN16@xmlXPathIs:

; 11254: 	    break;
; 11255: 	case 'n':
; 11256: 	    if (xmlStrEqual(name, BAD_CAST "namespace"))

	push	OFFSET ??_C@_09KPMGAFNI@namespace@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlXPathIs

; 11257: 		ret = AXIS_NAMESPACE;

	mov	esi, 9

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN18@xmlXPathIs:

; 11258: 	    break;
; 11259: 	case 'p':
; 11260: 	    if (xmlStrEqual(name, BAD_CAST "parent"))

	push	OFFSET ??_C@_06MLKDMCBD@parent@
	push	edi
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 10					; 0000000aH

; 11261: 		ret = AXIS_PARENT;
; 11262: 	    if (xmlStrEqual(name, BAD_CAST "preceding"))

	push	OFFSET ??_C@_09MGMONEC@preceding@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	test	eax, eax
	mov	ecx, 11					; 0000000bH

; 11263: 		ret = AXIS_PRECEDING;
; 11264: 	    if (xmlStrEqual(name, BAD_CAST "preceding-sibling"))

	push	OFFSET ??_C@_0BC@MLGDENAI@preceding?9sibling@
	push	edi
	cmovne	esi, ecx
	call	_xmlStrEqual
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN23@xmlXPathIs

; 11265: 		ret = AXIS_PRECEDING_SIBLING;

	mov	esi, 12					; 0000000cH

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
$LN22@xmlXPathIs:

; 11266: 	    break;
; 11267: 	case 's':
; 11268: 	    if (xmlStrEqual(name, BAD_CAST "self"))

	push	OFFSET ??_C@_04PJDNGLKJ@self@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	mov	ecx, 13					; 0000000dH
	test	eax, eax
	cmovne	esi, ecx
$LN23@xmlXPathIs:

; 11269: 		ret = AXIS_SELF;
; 11270: 	    break;
; 11271:     }
; 11272:     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 11273: }

	pop	ebp
	ret	0
	npad	1
$LN27@xmlXPathIs:
	DD	$LN4@xmlXPathIs
	DD	$LN8@xmlXPathIs
	DD	$LN10@xmlXPathIs
	DD	$LN13@xmlXPathIs
	DD	$LN16@xmlXPathIs
	DD	$LN18@xmlXPathIs
	DD	$LN22@xmlXPathIs
	DD	$LN23@xmlXPathIs
$LN25@xmlXPathIs:
	DB	0
	DB	7
	DB	1
	DB	2
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	5
	DB	7
	DB	7
	DB	6
_xmlXPathIsAxisName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompNodeTest
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_test$ = 12						; size = 4
_type$ = 16						; size = 4
_prefix$ = 20						; size = 4
_name$ = 24						; size = 4
_xmlXPathCompNodeTest PROC				; COMDAT

; 11095: 		     xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _test$[ebp]
	test	edx, edx
	je	$LN11@xmlXPathCo

; 11096:     int blanks;
; 11097: 
; 11098:     if ((test == NULL) || (type == NULL) || (prefix == NULL)) {

	mov	eax, DWORD PTR _type$[ebp]
	test	eax, eax
	je	$LN11@xmlXPathCo
	mov	ecx, DWORD PTR _prefix$[ebp]
	test	ecx, ecx
	je	$LN11@xmlXPathCo

; 11101:     }
; 11102:     *type = (xmlXPathTypeVal) 0;
; 11103:     *test = (xmlXPathTestVal) 0;
; 11104:     *prefix = NULL;

	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 11105:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN12@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN13@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN12@xmlXPathCo
$LN13@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN12@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:
	push	ebx
	push	edi

; 11106: 
; 11107:     if ((name == NULL) && (CUR == '*')) {

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	jne	SHORT $LN16@xmlXPathCo
	cmp	cl, 42					; 0000002aH
	jne	SHORT $LN82@xmlXPathCo

; 11108: 	/*
; 11109: 	 * All elements
; 11110: 	 */
; 11111: 	NEXT;

	pop	edi
	inc	eax
	mov	DWORD PTR [esi], eax

; 11195: 	    *test = NODE_TEST_ALL;
; 11196: 	    return(NULL);

	xor	eax, eax
	pop	ebx
	mov	DWORD PTR [edx], 3
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN82@xmlXPathCo:

; 11112: 	*test = NODE_TEST_ALL;
; 11113: 	return(NULL);
; 11114:     }
; 11115: 
; 11116:     if (name == NULL)
; 11117: 	name = xmlXPathParseNCName(ctxt);

	push	esi
	call	_xmlXPathParseNCName
	mov	edi, eax
	add	esp, 4

; 11118:     if (name == NULL) {

	test	edi, edi
	je	$LN87@xmlXPathCo
$LN16@xmlXPathCo:

; 11119: 	XP_ERRORNULL(XPATH_EXPR_ERROR);
; 11120:     }
; 11121: 
; 11122:     blanks = IS_BLANK_CH(CUR);

	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN48@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN47@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN48@xmlXPathCo
$LN47@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN48@xmlXPathCo
	xor	ebx, ebx
	jmp	SHORT $LL4@xmlXPathCo
$LN48@xmlXPathCo:
	mov	ebx, 1
$LL4@xmlXPathCo:

; 11123:     SKIP_BLANKS;

	cmp	cl, 32					; 00000020H
	je	SHORT $LN17@xmlXPathCo
	mov	al, cl
	cmp	cl, 9
	jb	SHORT $LN18@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN17@xmlXPathCo
$LN18@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN17@xmlXPathCo:
	mov	eax, edx
	test	cl, cl
	je	SHORT $LN86@xmlXPathCo
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi], eax
$LN86@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	mov	edx, eax
	jmp	SHORT $LL4@xmlXPathCo
$LN5@xmlXPathCo:

; 11124:     if (CUR == '(') {

	cmp	al, 40					; 00000028H
	jne	$LN19@xmlXPathCo

; 11125: 	NEXT;

	lea	eax, DWORD PTR [edx+1]

; 11126: 	/*
; 11127: 	 * NodeType or PI search
; 11128: 	 */
; 11129: 	if (xmlStrEqual(name, BAD_CAST "comment"))

	push	OFFSET ??_C@_07GJGNEJFD@comment@
	push	edi
	mov	DWORD PTR [esi], eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@xmlXPathCo

; 11130: 	    *type = NODE_TYPE_COMMENT;

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], 8
	jmp	SHORT $LN27@xmlXPathCo
$LN20@xmlXPathCo:

; 11131: 	else if (xmlStrEqual(name, BAD_CAST "node"))

	push	OFFSET ??_C@_04CLMONKIF@node@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlXPathCo

; 11132: 	    *type = NODE_TYPE_NODE;

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN27@xmlXPathCo
$LN22@xmlXPathCo:

; 11133: 	else if (xmlStrEqual(name, BAD_CAST "processing-instruction"))

	push	OFFSET ??_C@_0BH@NNLCFMHO@processing?9instruction@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlXPathCo

; 11134: 	    *type = NODE_TYPE_PI;

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], 7
	jmp	SHORT $LN27@xmlXPathCo
$LN24@xmlXPathCo:

; 11135: 	else if (xmlStrEqual(name, BAD_CAST "text"))

	push	OFFSET ??_C@_04CIMGMMMG@text@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN26@xmlXPathCo

; 11136: 	    *type = NODE_TYPE_TEXT;

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], 3
$LN27@xmlXPathCo:

; 11140: 	    XP_ERRORNULL(XPATH_EXPR_ERROR);
; 11141: 	}
; 11142: 
; 11143: 	*test = NODE_TEST_TYPE;

	mov	ebx, DWORD PTR _test$[ebp]
	mov	DWORD PTR [ebx], 1
	mov	eax, DWORD PTR [esi]
	npad	4
$LL6@xmlXPathCo:

; 11144: 
; 11145: 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN29@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN30@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN29@xmlXPathCo
$LN30@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN29@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL6@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL6@xmlXPathCo
$LN7@xmlXPathCo:

; 11146: 	if (*type == NODE_TYPE_PI) {

	cmp	DWORD PTR [edx], 7
	jne	SHORT $LN88@xmlXPathCo

; 11147: 	    /*
; 11148: 	     * Specific case: search a PI by name.
; 11149: 	     */
; 11150: 	    if (name != NULL)

	test	edi, edi
	je	SHORT $LN85@xmlXPathCo

; 11151: 		xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [esi]
	add	esp, 4
	mov	cl, BYTE PTR [eax]
$LN85@xmlXPathCo:

; 11152: 	    name = NULL;

	xor	edi, edi

; 11153: 	    if (CUR != ')') {

	cmp	cl, 41					; 00000029H
	je	SHORT $LN37@xmlXPathCo

; 11154: 		name = xmlXPathParseLiteral(ctxt);

	push	esi
	call	_xmlXPathParseLiteral
	add	esp, 4
	mov	edi, eax

; 11155: 		CHECK_ERROR NULL;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN95@xmlXPathCo

; 11156: 		*test = NODE_TEST_PI;

	mov	DWORD PTR [ebx], 2
	mov	eax, DWORD PTR [esi]
$LL8@xmlXPathCo:

; 11157: 		SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN35@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN36@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN35@xmlXPathCo
$LN36@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN88@xmlXPathCo
$LN35@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN88@xmlXPathCo:

; 11158: 	    }
; 11159: 	}
; 11160: 	if (CUR != ')') {

	cmp	cl, 41					; 00000029H
	je	SHORT $LN37@xmlXPathCo

; 11161: 	    if (name != NULL)

	test	edi, edi
	je	SHORT $LN38@xmlXPathCo

; 11162: 		xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN38@xmlXPathCo:

; 11163: 	    XP_ERRORNULL(XPATH_UNCLOSED_ERROR);

	push	8

; 11195: 	    *test = NODE_TEST_ALL;
; 11196: 	    return(NULL);

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN95@xmlXPathCo:
	pop	edi
	pop	ebx
	xor	eax, eax
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN37@xmlXPathCo:

; 11164: 	}
; 11165: 	NEXT;

	inc	eax
	mov	DWORD PTR [esi], eax
$LN41@xmlXPathCo:

; 11166: 	return(name);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN26@xmlXPathCo:

; 11137: 	else {
; 11138: 	    if (name != NULL)

	test	edi, edi
	je	SHORT $LN87@xmlXPathCo

; 11139: 		xmlFree(name);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 11201: 	    XP_ERRORNULL(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN19@xmlXPathCo:

; 11167:     }
; 11168:     *test = NODE_TEST_NAME;

	mov	ecx, DWORD PTR _test$[ebp]
	mov	DWORD PTR [ecx], 5

; 11169:     if ((!blanks) && (CUR == ':')) {

	test	ebx, ebx
	jne	SHORT $LN41@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN41@xmlXPathCo

; 11170: 	NEXT;

	inc	eax
	mov	DWORD PTR [esi], eax

; 11171: 
; 11172: 	/*
; 11173: 	 * Since currently the parser context don't have a
; 11174: 	 * namespace list associated:
; 11175: 	 * The namespace name for this prefix can be computed
; 11176: 	 * only at evaluation time. The compilation is done
; 11177: 	 * outside of any context.
; 11178: 	 */
; 11179: #if 0
; 11180: 	*prefix = xmlXPathNsLookup(ctxt->context, name);
; 11181: 	if (name != NULL)
; 11182: 	    xmlFree(name);
; 11183: 	if (*prefix == NULL) {
; 11184: 	    XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
; 11185: 	}
; 11186: #else
; 11187: 	*prefix = name;

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [eax], edi

; 11188: #endif
; 11189: 
; 11190: 	if (CUR == '*') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 42			; 0000002aH
	jne	SHORT $LN40@xmlXPathCo

; 11191: 	    /*
; 11192: 	     * All elements
; 11193: 	     */
; 11194: 	    NEXT;

	pop	edi
	inc	eax
	mov	DWORD PTR [esi], eax

; 11195: 	    *test = NODE_TEST_ALL;
; 11196: 	    return(NULL);

	xor	eax, eax
	pop	ebx
	mov	DWORD PTR [ecx], 3
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN40@xmlXPathCo:

; 11197: 	}
; 11198: 
; 11199: 	name = xmlXPathParseNCName(ctxt);

	push	esi
	call	_xmlXPathParseNCName
	mov	edi, eax
	add	esp, 4

; 11200: 	if (name == NULL) {

	test	edi, edi
	jne	SHORT $LN41@xmlXPathCo
$LN87@xmlXPathCo:

; 11201: 	    XP_ERRORNULL(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
$LN11@xmlXPathCo:

; 11099: 	STRANGE;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	11099					; 00002b5bH
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 11100: 	return(NULL);

	xor	eax, eax
	pop	esi

; 11202: 	}
; 11203:     }
; 11204:     return(name);
; 11205: }

	pop	ebp
	ret	0
_xmlXPathCompNodeTest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompAndExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompAndExpr PROC				; COMDAT

; 10971: xmlXPathCompAndExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompEqualityExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN47@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10972:     xmlXPathCompEqualityExpr(ctxt);
; 10973:     CHECK_ERROR;
; 10974:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN27@xmlXPathCo
$LN11@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN27@xmlXPathCo:

; 10975:     while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {

	cmp	cl, 97					; 00000061H
	jne	$LN47@xmlXPathCo
	push	edi
	npad	1
$LL4@xmlXPathCo:
	cmp	BYTE PTR [eax+1], 110			; 0000006eH
	jne	$LN48@xmlXPathCo
	cmp	BYTE PTR [eax+2], 100			; 00000064H
	jne	SHORT $LN48@xmlXPathCo

; 10976: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [ecx+12]

; 10977:         SKIP(3);

	lea	ecx, DWORD PTR [eax+3]
$LN49@xmlXPathCo:

; 10978: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
	npad	5
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN14@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlXPathCo
$LN14@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN13@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN49@xmlXPathCo
$LN7@xmlXPathCo:

; 10979:         xmlXPathCompEqualityExpr(ctxt);

	push	esi
	call	_xmlXPathCompEqualityExpr
	add	esp, 4

; 10980: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN48@xmlXPathCo

; 10981: 	PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
$LL8@xmlXPathCo:

; 10982: 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN16@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN9@xmlXPathCo:

; 10975:     while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {

	cmp	cl, 97					; 00000061H
	je	$LL4@xmlXPathCo
$LN48@xmlXPathCo:
	pop	edi
$LN47@xmlXPathCo:
	pop	esi

; 10983:     }
; 10984: }

	pop	ebp
	ret	0
_xmlXPathCompAndExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompEqualityExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompEqualityExpr PROC				; COMDAT

; 10940: xmlXPathCompEqualityExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompRelationalExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN63@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10941:     xmlXPathCompRelationalExpr(ctxt);
; 10942:     CHECK_ERROR;
; 10943:     SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN64@xmlXPathCo
$LN11@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN64@xmlXPathCo:
	push	ebx
	push	edi
$LL4@xmlXPathCo:

; 10944:     while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {

	cmp	dl, 61					; 0000003dH
	je	SHORT $LN53@xmlXPathCo
	cmp	dl, 33					; 00000021H
	jne	$LN67@xmlXPathCo
	cmp	BYTE PTR [eax+1], 61			; 0000003dH
	jne	$LN67@xmlXPathCo
$LN53@xmlXPathCo:

; 10945: 	int eq;
; 10946: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]

; 10947: 
; 10948:         if (CUR == '=') eq = 1;
; 10949: 	else eq = 0;
; 10950: 	NEXT;

	xor	ebx, ebx
	cmp	dl, 61					; 0000003dH
	sete	bl
	cmp	BYTE PTR [eax], 0
	mov	edi, DWORD PTR [ecx+12]
	je	SHORT $LN58@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
$LN58@xmlXPathCo:

; 10951: 	if (!eq) NEXT;

	mov	ecx, eax
	cmp	dl, 61					; 0000003dH
	je	SHORT $LL6@xmlXPathCo
	cmp	BYTE PTR [eax], 0
	je	SHORT $LL6@xmlXPathCo
	lea	ecx, DWORD PTR [eax+1]
$LN69@xmlXPathCo:

; 10952: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN17@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN18@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN17@xmlXPathCo
$LN18@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN17@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN69@xmlXPathCo
$LN7@xmlXPathCo:

; 10953:         xmlXPathCompRelationalExpr(ctxt);

	push	esi
	call	_xmlXPathCompRelationalExpr
	add	esp, 4

; 10954: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN67@xmlXPathCo

; 10955: 	PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	3
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	npad	5
$LL8@xmlXPathCo:

; 10956: 	SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN20@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN21@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN20@xmlXPathCo
$LN21@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	$LL4@xmlXPathCo
$LN20@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN67@xmlXPathCo:
	pop	edi
	pop	ebx
$LN63@xmlXPathCo:
	pop	esi

; 10957:     }
; 10958: }

	pop	ebp
	ret	0
_xmlXPathCompEqualityExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompRelationalExpr
_TEXT	SEGMENT
tv815 = -4						; size = 4
tv816 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathCompRelationalExpr PROC			; COMDAT

; 10898: xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompAdditiveExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN67@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10899:     xmlXPathCompAdditiveExpr(ctxt);
; 10900:     CHECK_ERROR;
; 10901:     SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN68@xmlXPathCo
$LN11@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN68@xmlXPathCo:
	push	ebx
	push	edi
$LL4@xmlXPathCo:

; 10902:     while ((CUR == '<') ||
; 10903:            (CUR == '>') ||
; 10904:            ((CUR == '<') && (NXT(1) == '=')) ||

	cmp	dl, 60					; 0000003cH
	je	SHORT $LN13@xmlXPathCo
	cmp	dl, 62					; 0000003eH
	jne	$LN71@xmlXPathCo
$LN13@xmlXPathCo:

; 10905:            ((CUR == '>') && (NXT(1) == '='))) {
; 10906: 	int inf, strict;
; 10907: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]

; 10908: 
; 10909:         if (CUR == '<') inf = 1;
; 10910: 	else inf = 0;
; 10911: 	if (NXT(1) == '=') strict = 0;

	xor	ebx, ebx
	cmp	dl, 60					; 0000003cH
	mov	dl, BYTE PTR [eax+1]
	sete	bl
	mov	edi, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR tv816[ebp], ebx

; 10912: 	else strict = 1;
; 10913: 	NEXT;

	xor	ebx, ebx
	cmp	dl, 61					; 0000003dH
	setne	bl
	cmp	BYTE PTR [eax], 0
	mov	DWORD PTR tv815[ebp], ebx
	mov	ebx, DWORD PTR tv816[ebp]
	je	SHORT $LN62@xmlXPathCo
	mov	DWORD PTR [esi], ecx
	mov	eax, ecx
$LN62@xmlXPathCo:

; 10914: 	if (!strict) NEXT;

	mov	ecx, eax
	cmp	dl, 61					; 0000003dH
	jne	SHORT $LL6@xmlXPathCo
	cmp	BYTE PTR [eax], 0
	je	SHORT $LL6@xmlXPathCo
	lea	ecx, DWORD PTR [eax+1]
$LN73@xmlXPathCo:

; 10915: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN20@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN21@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN20@xmlXPathCo
$LN21@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN20@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN73@xmlXPathCo
$LN7@xmlXPathCo:

; 10916:         xmlXPathCompAdditiveExpr(ctxt);

	push	esi
	call	_xmlXPathCompAdditiveExpr
	add	esp, 4

; 10917: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN71@xmlXPathCo

; 10918: 	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	DWORD PTR tv815[ebp]
	push	ebx
	push	4
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	npad	5
$LL8@xmlXPathCo:

; 10919: 	SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN23@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN24@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlXPathCo
$LN24@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	$LL4@xmlXPathCo
$LN23@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN71@xmlXPathCo:
	pop	edi
	pop	ebx
$LN67@xmlXPathCo:
	pop	esi

; 10920:     }
; 10921: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompRelationalExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompAdditiveExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompAdditiveExpr PROC				; COMDAT

; 10859: xmlXPathCompAdditiveExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompMultiplicativeExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN59@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10860: 
; 10861:     xmlXPathCompMultiplicativeExpr(ctxt);
; 10862:     CHECK_ERROR;
; 10863:     SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN60@xmlXPathCo
$LN11@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN60@xmlXPathCo:
	push	ebx
	push	edi
$LL4@xmlXPathCo:

; 10864:     while ((CUR == '+') || (CUR == '-')) {

	cmp	dl, 43					; 0000002bH
	je	SHORT $LN13@xmlXPathCo
	cmp	dl, 45					; 0000002dH
	jne	$LN63@xmlXPathCo
$LN13@xmlXPathCo:

; 10865: 	int plus;
; 10866: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]

; 10867: 
; 10868:         if (CUR == '+') plus = 1;
; 10869: 	else plus = 0;
; 10870: 	NEXT;

	xor	ebx, ebx
	cmp	dl, 43					; 0000002bH
	sete	bl
	cmp	BYTE PTR [eax], 0
	mov	edi, DWORD PTR [ecx+12]
$LN65@xmlXPathCo:

; 10871: 	SKIP_BLANKS;

	je	SHORT $LL6@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	npad	5
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN16@xmlXPathCo:
	test	cl, cl
	jmp	SHORT $LN65@xmlXPathCo
$LN7@xmlXPathCo:

; 10872:         xmlXPathCompMultiplicativeExpr(ctxt);

	push	esi
	call	_xmlXPathCompMultiplicativeExpr
	add	esp, 4

; 10873: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN63@xmlXPathCo

; 10874: 	PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	ebx
	push	5
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
$LL8@xmlXPathCo:

; 10875: 	SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN19@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN20@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN19@xmlXPathCo
$LN20@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	$LL4@xmlXPathCo
$LN19@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN63@xmlXPathCo:
	pop	edi
	pop	ebx
$LN59@xmlXPathCo:
	pop	esi

; 10876:     }
; 10877: }

	pop	ebp
	ret	0
_xmlXPathCompAdditiveExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompMultiplicativeExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompMultiplicativeExpr PROC			; COMDAT

; 10819: xmlXPathCompMultiplicativeExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompUnaryExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN62@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10820:     xmlXPathCompUnaryExpr(ctxt);
; 10821:     CHECK_ERROR;
; 10822:     SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN63@xmlXPathCo
$LN11@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN63@xmlXPathCo:
	push	ebx
	push	edi
$LL4@xmlXPathCo:

; 10823:     while ((CUR == '*') ||
; 10824:            ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||

	cmp	dl, 42					; 0000002aH
	je	SHORT $LN13@xmlXPathCo
	cmp	dl, 100					; 00000064H
	jne	SHORT $LN14@xmlXPathCo
	cmp	BYTE PTR [eax+1], 105			; 00000069H
	jne	SHORT $LN14@xmlXPathCo
	cmp	BYTE PTR [eax+2], 118			; 00000076H
	je	SHORT $LN13@xmlXPathCo
$LN14@xmlXPathCo:
	cmp	dl, 109					; 0000006dH
	jne	$LN66@xmlXPathCo
	cmp	BYTE PTR [eax+1], 111			; 0000006fH
	jne	$LN66@xmlXPathCo
	cmp	BYTE PTR [eax+2], 100			; 00000064H
	jne	$LN66@xmlXPathCo
$LN13@xmlXPathCo:

; 10825:            ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
; 10826: 	int op = -1;
; 10827: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]
	or	edi, -1
	mov	ebx, DWORD PTR [ecx+12]

; 10828: 
; 10829:         if (CUR == '*') {

	cmp	dl, 42					; 0000002aH
	jne	SHORT $LN15@xmlXPathCo

; 10830: 	    op = 0;

	xor	edi, edi

; 10831: 	    NEXT;

	inc	eax

; 10832: 	} else if (CUR == 'd') {

	jmp	SHORT $LN68@xmlXPathCo
$LN15@xmlXPathCo:
	cmp	dl, 100					; 00000064H
	jne	SHORT $LN17@xmlXPathCo

; 10833: 	    op = 1;

	mov	edi, 1

; 10834: 	    SKIP(3);

	jmp	SHORT $LN69@xmlXPathCo
$LN17@xmlXPathCo:

; 10835: 	} else if (CUR == 'm') {

	cmp	dl, 109					; 0000006dH
	jne	SHORT $LL6@xmlXPathCo

; 10836: 	    op = 2;

	mov	edi, 2
$LN69@xmlXPathCo:

; 10837: 	    SKIP(3);
; 10838: 	}
; 10839: 	SKIP_BLANKS;

	add	eax, 3
$LN68@xmlXPathCo:
	mov	DWORD PTR [esi], eax
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN20@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN21@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN20@xmlXPathCo
$LN21@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN20@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL6@xmlXPathCo
	inc	eax
	jmp	SHORT $LN68@xmlXPathCo
$LN7@xmlXPathCo:

; 10840:         xmlXPathCompUnaryExpr(ctxt);

	push	esi
	call	_xmlXPathCompUnaryExpr
	add	esp, 4

; 10841: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN66@xmlXPathCo

; 10842: 	PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	edi
	push	6
	push	DWORD PTR [eax+12]
	push	ebx
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
$LL8@xmlXPathCo:

; 10843: 	SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN23@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN24@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN23@xmlXPathCo
$LN24@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	$LL4@xmlXPathCo
$LN23@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN66@xmlXPathCo:
	pop	edi
	pop	ebx
$LN62@xmlXPathCo:
	pop	esi

; 10844:     }
; 10845: }

	pop	ebp
	ret	0
_xmlXPathCompMultiplicativeExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompUnaryExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompUnaryExpr PROC				; COMDAT

; 10783: xmlXPathCompUnaryExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	xor	ebx, ebx
	mov	eax, DWORD PTR [esi]
	npad	7
$LL2@xmlXPathCo:

; 10784:     int minus = 0;
; 10785:     int found = 0;
; 10786: 
; 10787:     SKIP_BLANKS;

	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN8@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN9@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN8@xmlXPathCo
$LN9@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN25@xmlXPathCo
$LN8@xmlXPathCo:
	test	dl, dl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN25@xmlXPathCo:

; 10788:     while (CUR == '-') {

	cmp	dl, 45					; 0000002dH
	jne	SHORT $LN44@xmlXPathCo

; 10790: 	found = 1;

	mov	ebx, 1
	npad	7
$LL4@xmlXPathCo:

; 10789:         minus = 1 - minus;

	mov	ecx, ebx
	sub	ecx, edi
	mov	edi, ecx
$LN10@xmlXPathCo:

; 10791: 	NEXT;
; 10792: 	SKIP_BLANKS;

	test	dl, dl
	je	SHORT $LL30@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	npad	3
$LL30@xmlXPathCo:
	mov	dl, BYTE PTR [eax]
	cmp	dl, 32					; 00000020H
	je	SHORT $LN10@xmlXPathCo
	cmp	dl, 9
	jb	SHORT $LN11@xmlXPathCo
	cmp	dl, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathCo
$LN11@xmlXPathCo:
	cmp	dl, 13					; 0000000dH
	je	SHORT $LN10@xmlXPathCo

; 10788:     while (CUR == '-') {

	cmp	dl, 45					; 0000002dH
	je	SHORT $LL4@xmlXPathCo
$LN44@xmlXPathCo:

; 10793:     }
; 10794: 
; 10795:     xmlXPathCompUnionExpr(ctxt);

	push	esi
	call	_xmlXPathCompUnionExpr
	add	esp, 4

; 10796:     CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN15@xmlXPathCo

; 10797:     if (found) {

	test	ebx, ebx
	je	SHORT $LN15@xmlXPathCo

; 10798: 	if (minus)

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR [eax+12]
	push	0
	test	edi, edi
	je	SHORT $LN14@xmlXPathCo

; 10799: 	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);

	push	2

; 10802:     }
; 10803: }

	push	5
	push	-1
	push	ecx
	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN14@xmlXPathCo:

; 10800: 	else
; 10801: 	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);

	push	3

; 10802:     }
; 10803: }

	push	5
	push	-1
	push	ecx
	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
$LN15@xmlXPathCo:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathCompUnaryExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompUnionExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompUnionExpr PROC				; COMDAT

; 10754: xmlXPathCompUnionExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompPathExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN54@xmlXPathCo
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10755:     xmlXPathCompPathExpr(ctxt);
; 10756:     CHECK_ERROR;
; 10757:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN28@xmlXPathCo
$LN11@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN28@xmlXPathCo:

; 10758:     while (CUR == '|') {

	cmp	al, 124					; 0000007cH
	jne	$LN54@xmlXPathCo
	push	edi
	npad	6
$LL4@xmlXPathCo:

; 10759: 	int op1 = ctxt->comp->last;

	mov	eax, DWORD PTR [esi+32]

; 10760: 	PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);

	push	0
	push	0
	push	0
	mov	edi, DWORD PTR [eax+12]
	push	0
	push	0
	push	9
	push	-1
	push	-1
	push	eax
	call	_xmlXPathCompExprAdd

; 10761: 
; 10762: 	NEXT;

	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	cmp	BYTE PTR [eax], 0
$LN57@xmlXPathCo:

; 10763: 	SKIP_BLANKS;

	je	SHORT $LL6@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	npad	7
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN13@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN14@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN13@xmlXPathCo
$LN14@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN13@xmlXPathCo:
	test	cl, cl
	jmp	SHORT $LN57@xmlXPathCo
$LN7@xmlXPathCo:

; 10764: 	xmlXPathCompPathExpr(ctxt);

	push	esi
	call	_xmlXPathCompPathExpr

; 10765: 
; 10766: 	PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	7
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	ecx, DWORD PTR [esi]
	add	esp, 40					; 00000028H
	npad	2
$LL8@xmlXPathCo:

; 10767: 
; 10768: 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN16@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPathCo
$LN16@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN15@xmlXPathCo:
	test	al, al
	je	SHORT $LL8@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL8@xmlXPathCo
$LN9@xmlXPathCo:

; 10758:     while (CUR == '|') {

	cmp	al, 124					; 0000007cH
	je	$LL4@xmlXPathCo
	pop	edi
$LN54@xmlXPathCo:
	pop	esi

; 10769:     }
; 10770: }

	pop	ebp
	ret	0
_xmlXPathCompUnionExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompPathExpr
_TEXT	SEGMENT
_lc$2$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathCompPathExpr PROC				; COMDAT

; 10598: xmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10599:     int lc = 1;           /* Should we branch to LocationPath ?         */
; 10600:     xmlChar *name = NULL; /* we may have to preparse a name to find out */
; 10601: 
; 10602:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN12@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN13@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN12@xmlXPathCo
$LN13@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN12@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 10603:     if ((CUR == '$') || (CUR == '(') ||
; 10604: 	(IS_ASCII_DIGIT(CUR)) ||
; 10605:         (CUR == '\'') || (CUR == '"') ||

	cmp	cl, 36					; 00000024H
	je	$LN52@xmlXPathCo
	cmp	cl, 40					; 00000028H
	je	$LN52@xmlXPathCo
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN17@xmlXPathCo
	cmp	cl, 57					; 00000039H
	jbe	$LN52@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	cl, 39					; 00000027H
	je	$LN52@xmlXPathCo
	cmp	cl, 34					; 00000022H
	je	$LN52@xmlXPathCo
	cmp	cl, 46					; 0000002eH
	jne	SHORT $LN14@xmlXPathCo
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, 48					; 00000030H
	jb	SHORT $LN14@xmlXPathCo
	cmp	dl, 57					; 00000039H
	jbe	$LN52@xmlXPathCo
$LN14@xmlXPathCo:

; 10606: 	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
; 10607: 	lc = 0;
; 10608:     } else if (CUR == '*') {

	cmp	cl, 42					; 0000002aH
	je	SHORT $LN139@xmlXPathCo

; 10609: 	/* relative or absolute location path */
; 10610: 	lc = 1;
; 10611:     } else if (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	je	SHORT $LN139@xmlXPathCo

; 10612: 	/* relative or absolute location path */
; 10613: 	lc = 1;
; 10614:     } else if (CUR == '@') {

	cmp	cl, 64					; 00000040H
	je	SHORT $LN139@xmlXPathCo

; 10615: 	/* relative abbreviated attribute location path */
; 10616: 	lc = 1;
; 10617:     } else if (CUR == '.') {

	cmp	cl, 46					; 0000002eH
	je	SHORT $LN139@xmlXPathCo
	npad	1
$LL4@xmlXPathCo:

; 10618: 	/* relative abbreviated attribute location path */
; 10619: 	lc = 1;
; 10620:     } else {
; 10621: 	/*
; 10622: 	 * Problem is finding if we have a name here whether it's:
; 10623: 	 *   - a nodetype
; 10624: 	 *   - a function call in which case it's followed by '('
; 10625: 	 *   - an axis in which case it's followed by ':'
; 10626: 	 *   - a element name
; 10627: 	 * We do an a priori analysis here rather than having to
; 10628: 	 * maintain parsed token content through the recursive function
; 10629: 	 * calls. This looks uglier but makes the code easier to
; 10630: 	 * read/write/debug.
; 10631: 	 */
; 10632: 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN26@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN27@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN26@xmlXPathCo
$LN27@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN26@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL4@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL4@xmlXPathCo
$LN5@xmlXPathCo:

; 10633: 	name = xmlXPathScanName(ctxt);

	push	esi
	call	_xmlXPathScanName
	mov	ebx, eax
	add	esp, 4

; 10634: 	if ((name != NULL) && (xmlStrstr(name, (xmlChar *) "::") != NULL)) {

	test	ebx, ebx
	je	$LN30@xmlXPathCo
	push	OFFSET ??_C@_02MOLJINC@?3?3@
	push	ebx
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlXPathCo

; 10635: #ifdef DEBUG_STEP
; 10636: 	    xmlGenericError(xmlGenericErrorContext,
; 10637: 		    "PathExpr: Axis\n");
; 10638: #endif
; 10639: 	    lc = 1;
; 10640: 	    xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN139@xmlXPathCo:

; 10719: 	if (CUR == '/') {

	mov	eax, DWORD PTR [esi]

; 10720: 	    PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);
; 10721: 	} else {
; 10722: 	    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
; 10723: 	}
; 10724: 	xmlXPathCompLocationPath(ctxt);

	xor	ecx, ecx
	push	0
	push	0
	push	0
	cmp	BYTE PTR [eax], 47			; 0000002fH
	mov	eax, DWORD PTR [esi+32]
	push	0
	setne	cl
	push	0
	add	ecx, 8
	push	ecx
	push	-1
	push	-1
	push	eax
	call	_xmlXPathCompExprAdd
	push	esi
	call	_xmlXPathCompLocationPath
	add	esp, 40					; 00000028H

; 10725:     } else {

	jmp	$LN122@xmlXPathCo
$LN28@xmlXPathCo:
	push	edi

; 10641: 	} else if (name != NULL) {
; 10642: 	    int len =xmlStrlen(name);

	push	ebx
	call	_xmlStrlen

; 10643: 
; 10644: 
; 10645: 	    while (NXT(len) != 0) {

	mov	edx, DWORD PTR [esi]
	mov	edi, eax
	lea	ecx, DWORD PTR [edx+edi]
	add	esp, 4
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN155@xmlXPathCo
$LL6@xmlXPathCo:

; 10646: 		if (NXT(len) == '/') {

	mov	al, BYTE PTR [ecx]
	cmp	al, 47					; 0000002fH
	je	SHORT $LN155@xmlXPathCo

; 10647: 		    /* element name */
; 10648: #ifdef DEBUG_STEP
; 10649: 		    xmlGenericError(xmlGenericErrorContext,
; 10650: 			    "PathExpr: AbbrRelLocation\n");
; 10651: #endif
; 10652: 		    lc = 1;
; 10653: 		    break;
; 10654: 		} else if (IS_BLANK_CH(NXT(len))) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN36@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN37@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN36@xmlXPathCo
$LN37@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN34@xmlXPathCo
$LN36@xmlXPathCo:

; 10685: 		} else if ((NXT(len) == '[')) {
; 10686: 		    /* element name */
; 10687: #ifdef DEBUG_STEP
; 10688: 		    xmlGenericError(xmlGenericErrorContext,
; 10689: 			    "PathExpr: AbbrRelLocation\n");
; 10690: #endif
; 10691: 		    lc = 1;
; 10692: 		    break;
; 10693: 		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
; 10694: 			   (NXT(len) == '=')) {
; 10695: 		    lc = 1;
; 10696: 		    break;
; 10697: 		} else {
; 10698: 		    lc = 1;
; 10699: 		    break;
; 10700: 		}
; 10701: 		len++;

	inc	ecx
	inc	edi
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL6@xmlXPathCo
$LN155@xmlXPathCo:

; 10702: 	    }
; 10703: 	    if (NXT(len) == 0) {

	mov	eax, 1
$LN7@xmlXPathCo:
	cmp	BYTE PTR [edx+edi], 0
	mov	ecx, 1

; 10704: #ifdef DEBUG_STEP
; 10705: 		xmlGenericError(xmlGenericErrorContext,
; 10706: 			"PathExpr: AbbrRelLocation\n");
; 10707: #endif
; 10708: 		/* element name */
; 10709: 		lc = 1;
; 10710: 	    }
; 10711: 	    xmlFree(name);

	push	ebx
	cmove	eax, ecx
	mov	DWORD PTR _lc$2$[ebp], eax
	call	DWORD PTR _xmlFree

; 10715: 	}
; 10716:     }
; 10717: 
; 10718:     if (lc) {

	mov	eax, DWORD PTR _lc$2$[ebp]
	add	esp, 4
	pop	edi
	test	eax, eax
	jne	$LN139@xmlXPathCo
$LN52@xmlXPathCo:

; 10519:     xmlXPathCompPrimaryExpr(ctxt);

	push	esi
	call	_xmlXPathCompPrimaryExpr
	add	esp, 4

; 10520:     CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN154@xmlXPathCo
	mov	ecx, DWORD PTR [esi]
	npad	1
$LL74@xmlXPathCo:

; 10521:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN81@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN82@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN81@xmlXPathCo
$LN82@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN95@xmlXPathCo
$LN81@xmlXPathCo:
	test	al, al
	je	SHORT $LL74@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL74@xmlXPathCo
$LN34@xmlXPathCo:

; 10655: 		    /* ignore blanks */
; 10656: 		    ;
; 10657: 		} else if (NXT(len) == ':') {

	mov	al, BYTE PTR [edx+edi]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN155@xmlXPathCo

; 10658: #ifdef DEBUG_STEP
; 10659: 		    xmlGenericError(xmlGenericErrorContext,
; 10660: 			    "PathExpr: AbbrRelLocation\n");
; 10661: #endif
; 10662: 		    lc = 1;
; 10663: 		    break;
; 10664: 		} else if ((NXT(len) == '(')) {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN155@xmlXPathCo

; 10665: 		    /* Node Type or Function */
; 10666: 		    if (xmlXPathIsNodeType(name)) {

	push	ebx
	call	_xmlXPathIsNodeType
	add	esp, 4
	test	eax, eax
	je	SHORT $LN42@xmlXPathCo

; 10674:                                xmlStrEqual(name, BAD_CAST "range-to")) {
; 10675:                         lc = 1;
; 10676: #endif
; 10677: 		    } else {
; 10678: #ifdef DEBUG_STEP
; 10679: 		        xmlGenericError(xmlGenericErrorContext,
; 10680: 				"PathExpr: function call\n");
; 10681: #endif
; 10682: 			lc = 0;
; 10683: 		    }
; 10684:                     break;

	mov	edx, DWORD PTR [esi]
	mov	eax, 1
	jmp	SHORT $LN7@xmlXPathCo
$LN42@xmlXPathCo:

; 10667: #ifdef DEBUG_STEP
; 10668: 		        xmlGenericError(xmlGenericErrorContext,
; 10669: 				"PathExpr: Type search\n");
; 10670: #endif
; 10671: 			lc = 1;
; 10672: #ifdef LIBXML_XPTR_ENABLED
; 10673:                     } else if (ctxt->xptr &&

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN44@xmlXPathCo
	push	OFFSET ??_C@_08KHINJAEH@range?9to@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@xmlXPathCo

; 10674:                                xmlStrEqual(name, BAD_CAST "range-to")) {
; 10675:                         lc = 1;
; 10676: #endif
; 10677: 		    } else {
; 10678: #ifdef DEBUG_STEP
; 10679: 		        xmlGenericError(xmlGenericErrorContext,
; 10680: 				"PathExpr: function call\n");
; 10681: #endif
; 10682: 			lc = 0;
; 10683: 		    }
; 10684:                     break;

	mov	edx, DWORD PTR [esi]
	mov	eax, 1
	jmp	$LN7@xmlXPathCo
$LN44@xmlXPathCo:
	mov	edx, DWORD PTR [esi]
	xor	eax, eax
	jmp	$LN7@xmlXPathCo
$LN30@xmlXPathCo:

; 10712: 	} else {
; 10713: 	    /* make sure all cases are covered explicitly */
; 10714: 	    XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN154@xmlXPathCo:

; 10741: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN95@xmlXPathCo:

; 10523:     while (CUR == '[') {

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN153@xmlXPathCo
	npad	4
$LL76@xmlXPathCo:

; 10524: 	xmlXPathCompPredicate(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompPredicate
	mov	ecx, DWORD PTR [esi]
	add	esp, 8
	npad	3
$LL78@xmlXPathCo:

; 10525: 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN83@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN84@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN83@xmlXPathCo
$LN84@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN79@xmlXPathCo
$LN83@xmlXPathCo:
	test	al, al
	je	SHORT $LL78@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL78@xmlXPathCo
$LN79@xmlXPathCo:

; 10522: 
; 10523:     while (CUR == '[') {

	cmp	al, 91					; 0000005bH
	je	SHORT $LL76@xmlXPathCo
$LN153@xmlXPathCo:

; 10726: 	xmlXPathCompFilterExpr(ctxt);
; 10727: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN154@xmlXPathCo

; 10728: 	if ((CUR == '/') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN122@xmlXPathCo
	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	jne	SHORT $LN57@xmlXPathCo

; 10729: 	    SKIP(2);

	add	eax, 2
$LN158@xmlXPathCo:

; 10730: 	    SKIP_BLANKS;

	mov	DWORD PTR [esi], eax
$LL8@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN59@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN60@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN59@xmlXPathCo
$LN60@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN59@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	jmp	SHORT $LN158@xmlXPathCo
$LN9@xmlXPathCo:

; 10731: 
; 10732: 	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	1
	push	6
	push	10					; 0000000aH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd

; 10733: 		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
; 10734: 
; 10735: 	    xmlXPathCompRelativeLocationPath(ctxt);

	push	esi
	call	_xmlXPathCompRelativeLocationPath
	add	esp, 40					; 00000028H
	jmp	SHORT $LN122@xmlXPathCo
$LN57@xmlXPathCo:

; 10736: 	} else if (CUR == '/') {
; 10737: 	    xmlXPathCompRelativeLocationPath(ctxt);

	push	esi
	call	_xmlXPathCompRelativeLocationPath
	add	esp, 4
$LN122@xmlXPathCo:
	mov	ecx, DWORD PTR [esi]
$LL10@xmlXPathCo:

; 10738: 	}
; 10739:     }
; 10740:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN62@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN63@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN62@xmlXPathCo
$LN63@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	$LN154@xmlXPathCo
$LN62@xmlXPathCo:
	test	al, al
	je	SHORT $LL10@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL10@xmlXPathCo
_xmlXPathCompPathExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathScanName
_TEXT	SEGMENT
_l$ = 8							; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathScanName PROC					; COMDAT

; 10549: xmlXPathScanName(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	mov	ebx, DWORD PTR [edi]
	call	_xmlXPathCurrentChar
	mov	esi, eax
	add	esp, 8
	cmp	esi, 32					; 00000020H
	je	$LN5@xmlXPathSc

; 10550:     int len = 0, l;
; 10551:     int c;
; 10552:     const xmlChar *cur;
; 10553:     xmlChar *ret;
; 10554: 
; 10555:     cur = ctxt->cur;
; 10556: 
; 10557:     c = CUR_CHAR(l);
; 10558:     if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	esi, 62					; 0000003eH
	je	$LN5@xmlXPathSc
	cmp	esi, 47					; 0000002fH
	je	$LN5@xmlXPathSc
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN14@xmlXPathSc
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN8@xmlXPathSc
	cmp	esi, 90					; 0000005aH
	jle	$LL2@xmlXPathSc
$LN8@xmlXPathSc:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN9@xmlXPathSc
	cmp	esi, 122				; 0000007aH
	jle	$LL2@xmlXPathSc
$LN9@xmlXPathSc:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN11@xmlXPathSc
	cmp	esi, 214				; 000000d6H
	jle	SHORT $LL2@xmlXPathSc
$LN11@xmlXPathSc:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN12@xmlXPathSc
	cmp	esi, 246				; 000000f6H
	jle	SHORT $LL2@xmlXPathSc
$LN12@xmlXPathSc:
	cmp	esi, 248				; 000000f8H
	jge	SHORT $LL2@xmlXPathSc
	jmp	SHORT $LN48@xmlXPathSc
$LN14@xmlXPathSc:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlXPathSc
$LN48@xmlXPathSc:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN53@xmlXPathSc
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN16@xmlXPathSc
	cmp	esi, 40869				; 00009fa5H
	jle	SHORT $LL2@xmlXPathSc
$LN16@xmlXPathSc:
	cmp	esi, 12295				; 00003007H
	je	SHORT $LL2@xmlXPathSc
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN53@xmlXPathSc
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LL2@xmlXPathSc
$LN53@xmlXPathSc:
	cmp	esi, 95					; 0000005fH
	je	SHORT $LL2@xmlXPathSc
	cmp	esi, 58					; 0000003aH
	jne	$LN5@xmlXPathSc
	npad	3
$LL2@xmlXPathSc:

; 10559: 	(!IS_LETTER(c) && (c != '_') &&
; 10560:          (c != ':'))) {
; 10561: 	return(NULL);
; 10562:     }
; 10563: 
; 10564:     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	esi, 62					; 0000003eH
	je	$LN3@xmlXPathSc
	cmp	esi, 47					; 0000002fH
	je	$LN3@xmlXPathSc
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN28@xmlXPathSc
	cmp	esi, 65					; 00000041H
	jl	SHORT $LN22@xmlXPathSc
	cmp	esi, 90					; 0000005aH
	jle	$LN6@xmlXPathSc
$LN22@xmlXPathSc:
	cmp	esi, 97					; 00000061H
	jl	SHORT $LN23@xmlXPathSc
	cmp	esi, 122				; 0000007aH
	jle	$LN6@xmlXPathSc
$LN23@xmlXPathSc:
	cmp	esi, 192				; 000000c0H
	jl	SHORT $LN25@xmlXPathSc
	cmp	esi, 214				; 000000d6H
	jle	$LN6@xmlXPathSc
$LN25@xmlXPathSc:
	cmp	esi, 216				; 000000d8H
	jl	SHORT $LN26@xmlXPathSc
	cmp	esi, 246				; 000000f6H
	jle	$LN6@xmlXPathSc
$LN26@xmlXPathSc:
	cmp	esi, 248				; 000000f8H
	jge	$LN6@xmlXPathSc
	jmp	SHORT $LN49@xmlXPathSc
$LN28@xmlXPathSc:
	push	OFFSET _xmlIsBaseCharGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN6@xmlXPathSc
$LN49@xmlXPathSc:
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN64@xmlXPathSc
	cmp	esi, 19968				; 00004e00H
	jl	SHORT $LN30@xmlXPathSc
	cmp	esi, 40869				; 00009fa5H
	jle	$LN6@xmlXPathSc
$LN30@xmlXPathSc:
	cmp	esi, 12295				; 00003007H
	je	$LN6@xmlXPathSc
	cmp	esi, 12321				; 00003021H
	jl	SHORT $LN54@xmlXPathSc
	cmp	esi, 12329				; 00003029H
	jle	SHORT $LN6@xmlXPathSc
$LN54@xmlXPathSc:
	cmp	esi, 256				; 00000100H
	jge	SHORT $LN38@xmlXPathSc
$LN64@xmlXPathSc:
	lea	eax, DWORD PTR [esi-48]
	cmp	eax, 9
	ja	SHORT $LN50@xmlXPathSc
	jmp	SHORT $LN6@xmlXPathSc
$LN38@xmlXPathSc:
	push	OFFSET _xmlIsDigitGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlXPathSc
$LN50@xmlXPathSc:
	cmp	esi, 46					; 0000002eH
	je	SHORT $LN6@xmlXPathSc
	cmp	esi, 45					; 0000002dH
	je	SHORT $LN6@xmlXPathSc
	cmp	esi, 95					; 0000005fH
	je	SHORT $LN6@xmlXPathSc
	cmp	esi, 58					; 0000003aH
	je	SHORT $LN6@xmlXPathSc
	cmp	esi, 256				; 00000100H
	jl	SHORT $LN55@xmlXPathSc
	push	OFFSET _xmlIsCombiningGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlXPathSc
	push	OFFSET _xmlIsExtenderGroup
	push	esi
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN43@xmlXPathSc
$LN55@xmlXPathSc:
	xor	eax, eax
	cmp	esi, 183				; 000000b7H
	sete	al
$LN43@xmlXPathSc:
	test	eax, eax
	je	SHORT $LN3@xmlXPathSc
$LN6@xmlXPathSc:

; 10565: 	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 10566:             (c == '.') || (c == '-') ||
; 10567: 	    (c == '_') || (c == ':') ||
; 10568: 	    (IS_COMBINING(c)) ||
; 10569: 	    (IS_EXTENDER(c)))) {
; 10570: 	len += l;
; 10571: 	NEXTL(l);

	mov	eax, DWORD PTR _l$[ebp]
	add	DWORD PTR [edi], eax

; 10572: 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	push	edi
	call	_xmlXPathCurrentChar
	mov	esi, eax
	add	esp, 8
	cmp	esi, 32					; 00000020H
	jne	$LL2@xmlXPathSc
$LN3@xmlXPathSc:

; 10573:     }
; 10574:     ret = xmlStrndup(cur, ctxt->cur - cur);

	mov	eax, DWORD PTR [edi]
	sub	eax, ebx
	push	eax
	push	ebx
	call	_xmlStrndup
	add	esp, 8

; 10575:     ctxt->cur = cur;

	mov	DWORD PTR [edi], ebx
	pop	edi

; 10576:     return(ret);
; 10577: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlXPathSc:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathScanName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompFilterExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompFilterExpr PROC				; COMDAT

; 10518: xmlXPathCompFilterExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompPrimaryExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN36@xmlXPathCo
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10519:     xmlXPathCompPrimaryExpr(ctxt);
; 10520:     CHECK_ERROR;
; 10521:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN9@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN10@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN9@xmlXPathCo
$LN10@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN20@xmlXPathCo
$LN9@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN20@xmlXPathCo:

; 10522: 
; 10523:     while (CUR == '[') {

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN36@xmlXPathCo
$LL4@xmlXPathCo:

; 10524: 	xmlXPathCompPredicate(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompPredicate
	mov	ecx, DWORD PTR [esi]
	add	esp, 8
	npad	2
$LL6@xmlXPathCo:

; 10525: 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN11@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL6@xmlXPathCo
$LN7@xmlXPathCo:

; 10522: 
; 10523:     while (CUR == '[') {

	cmp	al, 91					; 0000005bH
	je	SHORT $LL4@xmlXPathCo
$LN36@xmlXPathCo:
	pop	esi

; 10526:     }
; 10527: 
; 10528: 
; 10529: }

	pop	ebp
	ret	0
_xmlXPathCompFilterExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompPrimaryExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompPrimaryExpr PROC				; COMDAT

; 10479: xmlXPathCompPrimaryExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10480:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN10@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN11@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathCo
$LN11@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN10@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 10481:     if (CUR == '$') xmlXPathCompVariableReference(ctxt);

	cmp	al, 36					; 00000024H
	jne	$LN12@xmlXPathCo
$LL45@xmlXPathCo:

; 10341:     SKIP_BLANKS;

	cmp	al, 32					; 00000020H
	je	SHORT $LN49@xmlXPathCo
	mov	dl, al
	cmp	al, 9
	jb	SHORT $LN50@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN49@xmlXPathCo
$LN50@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN46@xmlXPathCo
$LN49@xmlXPathCo:
	mov	edx, ecx
	test	al, al
	je	SHORT $LN122@xmlXPathCo
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], edx
$LN122@xmlXPathCo:
	mov	al, BYTE PTR [edx]
	mov	ecx, edx
	jmp	SHORT $LL45@xmlXPathCo
$LN46@xmlXPathCo:

; 10342:     if (CUR != '$') {

	cmp	dl, 36					; 00000024H
	je	SHORT $LN51@xmlXPathCo

; 10343: 	XP_ERROR(XPATH_VARIABLE_REF_ERROR);

	push	4
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN108@xmlXPathCo
$LN51@xmlXPathCo:

; 10344:     }
; 10345:     NEXT;

	lea	eax, DWORD PTR [ecx+1]

; 9894 :     *prefix = NULL;

	xor	edi, edi

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	push	esi

; 10345:     NEXT;

	mov	DWORD PTR [esi], eax

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	call	_xmlXPathParseNCName
	mov	ecx, eax
	add	esp, 4

; 9896 :     if (ret && CUR == ':') {

	test	ecx, ecx
	je	$LN121@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN64@xmlXPathCo

; 9897 :         *prefix = ret;
; 9898 : 	NEXT;

	inc	eax
	mov	edi, ecx

; 9899 : 	ret = xmlXPathParseNCName(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlXPathParseNCName
	add	esp, 4
	mov	ecx, eax
$LN64@xmlXPathCo:

; 10347:     if (name == NULL) {

	test	ecx, ecx
	je	SHORT $LN121@xmlXPathCo

; 10350:     }
; 10351:     ctxt->comp->last = -1;

	mov	eax, DWORD PTR [esi+32]

; 10352:     PUSH_LONG_EXPR(XPATH_OP_VARIABLE, 0, 0, 0,

	push	edi
	push	ecx
	push	0
	push	0
	push	0
	mov	DWORD PTR [eax+12], -1
	mov	eax, DWORD PTR [esi+32]
	push	12					; 0000000cH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd
	mov	ecx, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	npad	5
$LL47@xmlXPathCo:

; 10353: 	           name, prefix);
; 10354:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN53@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN54@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN53@xmlXPathCo
$LN54@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN48@xmlXPathCo
$LN53@xmlXPathCo:
	test	al, al
	je	SHORT $LL47@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL47@xmlXPathCo
$LN48@xmlXPathCo:

; 10355:     if ((ctxt->context != NULL) && (ctxt->context->flags & XML_XPATH_NOVAR)) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN108@xmlXPathCo
	test	BYTE PTR [eax+196], 2
	je	$LN108@xmlXPathCo

; 10356: 	XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);

	push	24					; 00000018H
	push	esi
	call	_xmlXPathErr
	add	esp, 8

; 10481:     if (CUR == '$') xmlXPathCompVariableReference(ctxt);

	jmp	$LN108@xmlXPathCo
$LN121@xmlXPathCo:

; 10348:         xmlFree(prefix);

	push	edi
	call	DWORD PTR _xmlFree

; 10349: 	XP_ERROR(XPATH_VARIABLE_REF_ERROR);

	push	4
	push	esi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	jmp	$LN108@xmlXPathCo
$LN12@xmlXPathCo:

; 10482:     else if (CUR == '(') {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN14@xmlXPathCo
$LN127@xmlXPathCo:

; 10483: 	NEXT;
; 10484: 	SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL4@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN16@xmlXPathCo:
	test	al, al
	je	SHORT $LL4@xmlXPathCo
	jmp	SHORT $LN127@xmlXPathCo
$LN5@xmlXPathCo:

; 10485: 	xmlXPathCompileExpr(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompileExpr
	add	esp, 8

; 10486: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN126@xmlXPathCo

; 10487: 	if (CUR != ')') {

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], 41			; 00000029H
	je	SHORT $LN19@xmlXPathCo

; 10488: 	    XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN126@xmlXPathCo:

; 10500: }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN19@xmlXPathCo:

; 10489: 	}
; 10490: 	NEXT;
; 10491: 	SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN20@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN21@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN20@xmlXPathCo
$LN21@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN108@xmlXPathCo
$LN20@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	jmp	SHORT $LN19@xmlXPathCo
$LN14@xmlXPathCo:

; 10492:     } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LN25@xmlXPathCo
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN24@xmlXPathCo
$LN25@xmlXPathCo:
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN22@xmlXPathCo
	mov	cl, BYTE PTR [ecx+1]
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN22@xmlXPathCo
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN22@xmlXPathCo
$LN24@xmlXPathCo:

; 10493: 	xmlXPathCompNumber(ctxt);

	push	esi
	call	_xmlXPathCompNumber
	jmp	SHORT $LN128@xmlXPathCo
$LN22@xmlXPathCo:

; 10494:     } else if ((CUR == '\'') || (CUR == '"')) {

	cmp	al, 39					; 00000027H
	je	SHORT $LN28@xmlXPathCo
	cmp	al, 34					; 00000022H
	je	SHORT $LN28@xmlXPathCo

; 10496:     } else {
; 10497: 	xmlXPathCompFunctionCall(ctxt);

	push	esi
	call	_xmlXPathCompFunctionCall
	jmp	SHORT $LN128@xmlXPathCo
$LN28@xmlXPathCo:

; 10495: 	xmlXPathCompLiteral(ctxt);

	push	esi
	call	_xmlXPathCompLiteral
$LN128@xmlXPathCo:
	add	esp, 4
$LN108@xmlXPathCo:
	mov	ecx, DWORD PTR [esi]
$LL8@xmlXPathCo:

; 10498:     }
; 10499:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN29@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN30@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN29@xmlXPathCo
$LN30@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN126@xmlXPathCo
$LN29@xmlXPathCo:
	test	al, al
	je	SHORT $LL8@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL8@xmlXPathCo
_xmlXPathCompPrimaryExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompFunctionCall
_TEXT	SEGMENT
_sort$1$ = -12						; size = 4
_nbargs$1$ = -8						; size = 4
_prefix$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathCompFunctionCall PROC				; COMDAT

; 10400: xmlXPathCompFunctionCall(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	edi, edi
	push	esi

; 10401:     xmlChar *name;
; 10402:     xmlChar *prefix;
; 10403:     int nbargs = 0;

	mov	DWORD PTR _nbargs$1$[ebp], 0

; 10404:     int sort = 1;

	mov	DWORD PTR _sort$1$[ebp], 1

; 9894 :     *prefix = NULL;

	mov	DWORD PTR _prefix$1$[ebp], edi

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	call	_xmlXPathParseNCName
	mov	ebx, eax
	add	esp, 4

; 9896 :     if (ret && CUR == ':') {

	test	ebx, ebx
	je	$LN107@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN43@xmlXPathCo

; 9897 :         *prefix = ret;
; 9898 : 	NEXT;

	inc	eax
	mov	edi, ebx

; 9899 : 	ret = xmlXPathParseNCName(ctxt);

	push	esi
	mov	DWORD PTR _prefix$1$[ebp], edi
	mov	DWORD PTR [esi], eax
	call	_xmlXPathParseNCName
	add	esp, 4
	mov	ebx, eax
$LN43@xmlXPathCo:

; 10405: 
; 10406:     name = xmlXPathParseQName(ctxt, &prefix);
; 10407:     if (name == NULL) {

	test	ebx, ebx
	je	$LN107@xmlXPathCo
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10410:     }
; 10411:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN14@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlXPathCo
$LN14@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN13@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 10412: #ifdef DEBUG_EXPR
; 10413:     if (prefix == NULL)
; 10414: 	xmlGenericError(xmlGenericErrorContext, "Calling function %s\n",
; 10415: 			name);
; 10416:     else
; 10417: 	xmlGenericError(xmlGenericErrorContext, "Calling function %s:%s\n",
; 10418: 			prefix, name);
; 10419: #endif
; 10420: 
; 10421:     if (CUR != '(') {

	cmp	al, 40					; 00000028H
	jne	$LN81@xmlXPathCo
$LN120@xmlXPathCo:

; 10422: 	xmlFree(name);
; 10423: 	xmlFree(prefix);
; 10424: 	XP_ERROR(XPATH_EXPR_ERROR);
; 10425:     }
; 10426:     NEXT;
; 10427:     SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL4@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN16@xmlXPathCo:
	test	al, al
	je	SHORT $LL4@xmlXPathCo
	jmp	SHORT $LN120@xmlXPathCo
$LN5@xmlXPathCo:

; 10428: 
; 10429:     /*
; 10430:     * Optimization for count(): we don't need the node-set to be sorted.
; 10431:     */
; 10432:     if ((prefix == NULL) && (name[0] == 'c') &&

	test	edi, edi
	jne	SHORT $LN118@xmlXPathCo
	cmp	BYTE PTR [ebx], 99			; 00000063H
	jne	SHORT $LN118@xmlXPathCo
	push	OFFSET ??_C@_05IOMEMJEC@count@
	push	ebx
	call	_xmlStrEqual
	xor	edx, edx
	add	esp, 8
	test	eax, eax
	mov	ecx, 1
	cmovne	ecx, edx
	mov	DWORD PTR _sort$1$[ebp], ecx
	jmp	SHORT $LN18@xmlXPathCo
$LN118@xmlXPathCo:

; 10433: 	xmlStrEqual(name, BAD_CAST "count"))
; 10434:     {
; 10435: 	sort = 0;
; 10436:     }
; 10437:     ctxt->comp->last = -1;

	mov	ecx, 1
$LN18@xmlXPathCo:
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax+12], -1

; 10438:     if (CUR != ')') {

	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [eax]
	cmp	al, 41					; 00000029H
	je	$LN7@xmlXPathCo

; 10439: 	while (CUR != 0) {

	test	al, al
	je	SHORT $LN7@xmlXPathCo
$LL6@xmlXPathCo:

; 10440: 	    int op1 = ctxt->comp->last;

	mov	eax, DWORD PTR [esi+32]

; 10441: 	    ctxt->comp->last = -1;
; 10442: 	    xmlXPathCompileExpr(ctxt, sort);

	push	ecx
	push	esi
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], -1
	call	_xmlXPathCompileExpr
	add	esp, 8

; 10443: 	    if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [esi+8], 0
	jne	$LN79@xmlXPathCo

; 10446: 		return;
; 10447: 	    }
; 10448: 	    PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	14					; 0000000eH
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd

; 10449: 	    nbargs++;
; 10450: 	    if (CUR == ')') break;

	mov	ecx, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	inc	DWORD PTR _nbargs$1$[ebp]
	mov	al, BYTE PTR [ecx]
	cmp	al, 41					; 00000029H
	je	SHORT $LN116@xmlXPathCo

; 10451: 	    if (CUR != ',') {

	cmp	al, 44					; 0000002cH
	jne	$LN81@xmlXPathCo
$LN121@xmlXPathCo:

; 10455: 	    }
; 10456: 	    NEXT;
; 10457: 	    SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL8@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN23@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN24@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN23@xmlXPathCo
$LN24@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN23@xmlXPathCo:
	test	al, al
	je	SHORT $LL8@xmlXPathCo
	jmp	SHORT $LN121@xmlXPathCo
$LN9@xmlXPathCo:

; 10439: 	while (CUR != 0) {

	mov	ecx, DWORD PTR _sort$1$[ebp]
	test	al, al
	jne	SHORT $LL6@xmlXPathCo
$LN116@xmlXPathCo:

; 10458: 	}
; 10459:     }
; 10460:     PUSH_LONG_EXPR(XPATH_OP_FUNCTION, nbargs, 0, 0,

	mov	edi, DWORD PTR _prefix$1$[ebp]
$LN7@xmlXPathCo:
	mov	eax, DWORD PTR [esi+32]
	push	edi
	push	ebx
	push	0
	push	0
	push	DWORD PTR _nbargs$1$[ebp]
	push	13					; 0000000dH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd

; 10461: 	           name, prefix);
; 10462:     NEXT;

	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	cmp	BYTE PTR [eax], 0
$LN122@xmlXPathCo:

; 10463:     SKIP_BLANKS;

	je	SHORT $LL10@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
$LL10@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN25@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN26@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN25@xmlXPathCo
$LN26@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN11@xmlXPathCo
$LN25@xmlXPathCo:
	test	cl, cl
	jmp	SHORT $LN122@xmlXPathCo
$LN79@xmlXPathCo:

; 10444: 		xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 10445: 		xmlFree(prefix);

	push	DWORD PTR _prefix$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	edi

; 10464: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@xmlXPathCo:

; 10452: 		xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 10453: 		xmlFree(prefix);

	push	DWORD PTR _prefix$1$[ebp]
	call	DWORD PTR _xmlFree

; 10454: 		XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	pop	edi

; 10464: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@xmlXPathCo:

; 10408: 	xmlFree(prefix);

	push	edi
	call	DWORD PTR _xmlFree

; 10409: 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
$LN11@xmlXPathCo:

; 10464: }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompFunctionCall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompVariableReference
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompVariableReference PROC			; COMDAT

; 10337: xmlXPathCompVariableReference(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10338:     xmlChar *name;
; 10339:     xmlChar *prefix;
; 10340: 
; 10341:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN6@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN7@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN6@xmlXPathCo
$LN7@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN6@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 10342:     if (CUR != '$') {

	cmp	cl, 36					; 00000024H
	je	SHORT $LN8@xmlXPathCo

; 10343: 	XP_ERROR(XPATH_VARIABLE_REF_ERROR);

	push	4
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 10357:     }
; 10358: }

	pop	ebp
	ret	0
$LN8@xmlXPathCo:
	push	edi

; 10344:     }
; 10345:     NEXT;

	inc	eax

; 9894 :     *prefix = NULL;

	xor	edi, edi

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	push	esi

; 10344:     }
; 10345:     NEXT;

	mov	DWORD PTR [esi], eax

; 9895 :     ret = xmlXPathParseNCName(ctxt);

	call	_xmlXPathParseNCName
	mov	ecx, eax
	add	esp, 4

; 9896 :     if (ret && CUR == ':') {

	test	ecx, ecx
	je	$LN32@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN21@xmlXPathCo

; 9897 :         *prefix = ret;
; 9898 : 	NEXT;

	inc	eax
	mov	edi, ecx

; 9899 : 	ret = xmlXPathParseNCName(ctxt);

	push	esi
	mov	DWORD PTR [esi], eax
	call	_xmlXPathParseNCName
	add	esp, 4
	mov	ecx, eax
$LN21@xmlXPathCo:

; 10346:     name = xmlXPathParseQName(ctxt, &prefix);
; 10347:     if (name == NULL) {

	test	ecx, ecx
	je	SHORT $LN32@xmlXPathCo

; 10350:     }
; 10351:     ctxt->comp->last = -1;

	mov	eax, DWORD PTR [esi+32]

; 10352:     PUSH_LONG_EXPR(XPATH_OP_VARIABLE, 0, 0, 0,

	push	edi
	push	ecx
	push	0
	push	0
	push	0
	mov	DWORD PTR [eax+12], -1
	mov	eax, DWORD PTR [esi+32]
	push	12					; 0000000cH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd
	mov	ecx, DWORD PTR [esi]
	add	esp, 36					; 00000024H
$LL4@xmlXPathCo:

; 10353: 	           name, prefix);
; 10354:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN10@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN11@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathCo
$LN11@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN10@xmlXPathCo:
	test	al, al
	je	SHORT $LL4@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL4@xmlXPathCo
$LN5@xmlXPathCo:

; 10355:     if ((ctxt->context != NULL) && (ctxt->context->flags & XML_XPATH_NOVAR)) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN36@xmlXPathCo
	test	BYTE PTR [eax+196], 2
	je	SHORT $LN36@xmlXPathCo

; 10356: 	XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);

	push	24					; 00000018H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi

; 10357:     }
; 10358: }

	pop	ebp
	ret	0
$LN32@xmlXPathCo:

; 10348:         xmlFree(prefix);

	push	edi
	call	DWORD PTR _xmlFree

; 10349: 	XP_ERROR(XPATH_VARIABLE_REF_ERROR);

	push	4
	push	esi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
$LN36@xmlXPathCo:
	pop	edi
	pop	esi

; 10357:     }
; 10358: }

	pop	ebp
	ret	0
_xmlXPathCompVariableReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompLiteral
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompLiteral PROC				; COMDAT

; 10284: xmlXPathCompLiteral(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 34					; 00000022H
	jne	SHORT $LN6@xmlXPathCo

; 10285:     const xmlChar *q;
; 10286:     xmlChar *ret = NULL;
; 10287: 
; 10288:     if (CUR == '"') {
; 10289:         NEXT;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi], edx

; 10290: 	q = CUR_PTR;

	mov	ecx, edx
$LL2@xmlXPathCo:

; 10291: 	while ((IS_CHAR_CH(CUR)) && (CUR != '"'))

	mov	al, BYTE PTR [ecx]
	cmp	al, 9
	jb	SHORT $LN9@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlXPathCo
$LN9@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN8@xmlXPathCo
	cmp	al, 32					; 00000020H
	jb	SHORT $LN3@xmlXPathCo
$LN8@xmlXPathCo:
	cmp	al, 34					; 00000022H
	je	SHORT $LN3@xmlXPathCo

; 10292: 	    NEXT;

	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [edi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 10293: 	if (!IS_CHAR_CH(CUR)) {

	cmp	al, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN10@xmlXPathCo
	cmp	al, 32					; 00000020H
	jb	SHORT $LN42@xmlXPathCo
$LN10@xmlXPathCo:

; 10294: 	    XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);
; 10295: 	} else {
; 10296: 	    ret = xmlStrndup(q, CUR_PTR - q);

	sub	ecx, edx
	push	ecx
	push	edx
	call	_xmlStrndup

; 10297: 	    NEXT;

	mov	ecx, DWORD PTR [edi]
	add	esp, 8
	mov	ebx, eax
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN32@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [edi], ecx

; 10298:         }

	jmp	SHORT $LN32@xmlXPathCo
$LN6@xmlXPathCo:

; 10299:     } else if (CUR == '\'') {

	cmp	cl, 39					; 00000027H
	jne	$LN13@xmlXPathCo

; 10300:         NEXT;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi], edx

; 10301: 	q = CUR_PTR;

	mov	ecx, edx
	npad	5
$LL4@xmlXPathCo:

; 10302: 	while ((IS_CHAR_CH(CUR)) && (CUR != '\''))

	mov	al, BYTE PTR [ecx]
	cmp	al, 9
	jb	SHORT $LN16@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPathCo
$LN16@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@xmlXPathCo
	cmp	al, 32					; 00000020H
	jb	SHORT $LN5@xmlXPathCo
$LN15@xmlXPathCo:
	cmp	al, 39					; 00000027H
	je	SHORT $LN5@xmlXPathCo

; 10303: 	    NEXT;

	test	al, al
	je	SHORT $LL4@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [edi], ecx
	jmp	SHORT $LL4@xmlXPathCo
$LN5@xmlXPathCo:

; 10304: 	if (!IS_CHAR_CH(CUR)) {

	cmp	al, 9
	jb	SHORT $LN19@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN17@xmlXPathCo
$LN19@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN17@xmlXPathCo
	cmp	al, 32					; 00000020H
	jae	SHORT $LN17@xmlXPathCo
$LN42@xmlXPathCo:

; 10305: 	    XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);

	push	2

; 10317: }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlXPathCo:

; 10306: 	} else {
; 10307: 	    ret = xmlStrndup(q, CUR_PTR - q);

	sub	ecx, edx
	push	ecx
	push	edx
	call	_xmlStrndup
	mov	ebx, eax
	add	esp, 8

; 10308: 	    NEXT;

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN32@xmlXPathCo
	inc	eax
	mov	DWORD PTR [edi], eax
$LN32@xmlXPathCo:

; 10312:     }
; 10313:     if (ret == NULL) return;

	test	ebx, ebx
	je	SHORT $LN1@xmlXPathCo

; 10314:     PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_STRING, 0, 0,

	push	esi
	mov	esi, DWORD PTR [edi+32]
	push	0
	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewString
	add	esp, 8
	push	eax
	push	0
	push	0
	push	4
	push	11					; 0000000bH
	push	-1
	push	DWORD PTR [esi+12]
	push	esi
	call	_xmlXPathCompExprAdd

; 10315: 	           xmlXPathCacheNewString(ctxt->context, ret), NULL);
; 10316:     xmlFree(ret);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 40					; 00000028H
	pop	esi
	pop	edi

; 10317: }

	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlXPathCo:

; 10309:         }
; 10310:     } else {
; 10311: 	XP_ERROR(XPATH_START_LITERAL_ERROR);

	push	3

; 10317: }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathCo:
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathCompLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathParseLiteral
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathParseLiteral PROC				; COMDAT

; 10240: xmlXPathParseLiteral(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 34					; 00000022H
	jne	SHORT $LN6@xmlXPathPa

; 10241:     const xmlChar *q;
; 10242:     xmlChar *ret = NULL;
; 10243: 
; 10244:     if (CUR == '"') {
; 10245:         NEXT;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi], edx

; 10246: 	q = CUR_PTR;

	mov	ecx, edx
$LL2@xmlXPathPa:

; 10247: 	while ((IS_CHAR_CH(CUR)) && (CUR != '"'))

	mov	al, BYTE PTR [ecx]
	cmp	al, 9
	jb	SHORT $LN9@xmlXPathPa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlXPathPa
$LN9@xmlXPathPa:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN8@xmlXPathPa
	cmp	al, 32					; 00000020H
	jb	SHORT $LN3@xmlXPathPa
$LN8@xmlXPathPa:
	cmp	al, 34					; 00000022H
	je	SHORT $LN3@xmlXPathPa

; 10248: 	    NEXT;

	test	al, al
	je	SHORT $LL2@xmlXPathPa
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathPa
$LN3@xmlXPathPa:

; 10249: 	if (!IS_CHAR_CH(CUR)) {

	cmp	al, 9
	jb	SHORT $LN12@xmlXPathPa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathPa
$LN12@xmlXPathPa:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN10@xmlXPathPa
	cmp	al, 32					; 00000020H
	jb	SHORT $LN41@xmlXPathPa
$LN10@xmlXPathPa:

; 10250: 	    XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);
; 10251: 	} else {
; 10252: 	    ret = xmlStrndup(q, CUR_PTR - q);

	sub	ecx, edx
	push	ecx
	push	edx
	call	_xmlStrndup

; 10253: 	    NEXT;

	mov	ecx, DWORD PTR [esi]
	add	esp, 8
	mov	edx, eax
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN31@xmlXPathPa
	inc	ecx
	mov	DWORD PTR [esi], ecx
	pop	esi

; 10270: }

	pop	ebp
	ret	0
$LN6@xmlXPathPa:

; 10254:         }
; 10255:     } else if (CUR == '\'') {

	cmp	cl, 39					; 00000027H
	jne	SHORT $LN13@xmlXPathPa

; 10256:         NEXT;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi], edx

; 10257: 	q = CUR_PTR;

	mov	ecx, edx
$LL4@xmlXPathPa:

; 10258: 	while ((IS_CHAR_CH(CUR)) && (CUR != '\''))

	mov	al, BYTE PTR [ecx]
	cmp	al, 9
	jb	SHORT $LN16@xmlXPathPa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPathPa
$LN16@xmlXPathPa:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 32					; 00000020H
	jb	SHORT $LN5@xmlXPathPa
$LN15@xmlXPathPa:
	cmp	al, 39					; 00000027H
	je	SHORT $LN5@xmlXPathPa

; 10259: 	    NEXT;

	test	al, al
	je	SHORT $LL4@xmlXPathPa
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL4@xmlXPathPa
$LN5@xmlXPathPa:

; 10260: 	if (!IS_CHAR_CH(CUR)) {

	cmp	al, 9
	jb	SHORT $LN19@xmlXPathPa
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN17@xmlXPathPa
$LN19@xmlXPathPa:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN17@xmlXPathPa
	cmp	al, 32					; 00000020H
	jae	SHORT $LN17@xmlXPathPa
$LN41@xmlXPathPa:

; 10261: 	    XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);

	push	2

; 10270: }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN17@xmlXPathPa:

; 10262: 	} else {
; 10263: 	    ret = xmlStrndup(q, CUR_PTR - q);

	sub	ecx, edx
	push	ecx
	push	edx
	call	_xmlStrndup
	mov	edx, eax
	add	esp, 8

; 10264: 	    NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN31@xmlXPathPa
	inc	eax
	mov	DWORD PTR [esi], eax
$LN31@xmlXPathPa:

; 10268:     }
; 10269:     return(ret);

	mov	eax, edx
	pop	esi

; 10270: }

	pop	ebp
	ret	0
$LN13@xmlXPathPa:

; 10265:         }
; 10266:     } else {
; 10267: 	XP_ERRORNULL(XPATH_START_LITERAL_ERROR);

	push	3

; 10270: }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlXPathParseLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompNumber
_TEXT	SEGMENT
_fraction$1$ = -24					; size = 8
_ret$1$ = -16						; size = 8
_max$1$ = -8						; size = 4
_exponent$1$ = -4					; size = 4
_frac$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathCompNumber PROC				; COMDAT

; 10147: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	edx, edx
	mov	DWORD PTR _exponent$1$[ebp], edx
	cmp	DWORD PTR [edi+8], edx
	jne	$LN1@xmlXPathCo

; 10148:     double ret = 0.0;
; 10149:     int ok = 0;
; 10150:     int exponent = 0;
; 10151:     int is_exponent_negative = 0;
; 10152: #ifdef __GNUC__
; 10153:     unsigned long tmp = 0;
; 10154:     double temp;
; 10155: #endif
; 10156: 
; 10157:     CHECK_ERROR;
; 10158:     if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edi]
	mov	bl, BYTE PTR [esi]
	cmp	bl, 46					; 0000002eH
	je	SHORT $LN13@xmlXPathCo
	cmp	bl, 48					; 00000030H
	jb	SHORT $LN59@xmlXPathCo
	cmp	bl, 57					; 00000039H
	ja	SHORT $LN59@xmlXPathCo
$LN13@xmlXPathCo:
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2

; 10159:         XP_ERROR(XPATH_NUMBER_ERROR);
; 10160:     }
; 10161: #ifdef __GNUC__
; 10162:     /*
; 10163:      * tmp/temp is a workaround against a gcc compiler bug
; 10164:      * http://veillard.com/gcc.bug
; 10165:      */
; 10166:     ret = 0;
; 10167:     while ((CUR >= '0') && (CUR <= '9')) {
; 10168: 	ret = ret * 10;
; 10169: 	tmp = (CUR - '0');
; 10170:         ok = 1;
; 10171:         NEXT;
; 10172: 	temp = (double) tmp;
; 10173: 	ret = ret + temp;
; 10174:     }
; 10175: #else
; 10176:     ret = 0;

	movsd	QWORD PTR _fraction$1$[ebp], xmm1
	movsd	QWORD PTR _ret$1$[ebp], xmm2

; 10177:     while ((CUR >= '0') && (CUR <= '9')) {

	cmp	bl, 48					; 00000030H
	jb	SHORT $LN3@xmlXPathCo
	mov	ecx, esi
	npad	2
$LL2@xmlXPathCo:
	mov	esi, ecx
	cmp	bl, 57					; 00000039H
	ja	SHORT $LN60@xmlXPathCo

; 10178: 	ret = ret * 10 + (CUR - '0');

	mulsd	xmm2, QWORD PTR __real@4024000000000000

; 10179: 	ok = 1;

	mov	edx, 1
	movzx	eax, bl
	sub	eax, 48					; 00000030H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	addsd	xmm2, xmm0

; 10180: 	NEXT;

	test	bl, bl
	je	SHORT $LN26@xmlXPathCo
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], esi
	mov	bl, BYTE PTR [esi]
$LN26@xmlXPathCo:

; 10177:     while ((CUR >= '0') && (CUR <= '9')) {

	mov	ecx, esi
	cmp	bl, 48					; 00000030H
	jae	SHORT $LL2@xmlXPathCo
$LN60@xmlXPathCo:
	movsd	QWORD PTR _ret$1$[ebp], xmm2
$LN3@xmlXPathCo:

; 10181:     }
; 10182: #endif
; 10183:     if (CUR == '.') {

	cmp	bl, 46					; 0000002eH
	jne	$LN62@xmlXPathCo

; 10184: 	int v, frac = 0, max;
; 10185: 	double fraction = 0;
; 10186: 
; 10187:         NEXT;

	inc	esi
	xor	eax, eax
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR _frac$1$[ebp], eax

; 10188:         if (((CUR < '0') || (CUR > '9')) && (!ok)) {

	mov	bl, BYTE PTR [esi]
	cmp	bl, 48					; 00000030H
	jb	SHORT $LN17@xmlXPathCo
	cmp	bl, 57					; 00000039H
	jbe	SHORT $LN45@xmlXPathCo
$LN17@xmlXPathCo:
	test	edx, edx
	jne	SHORT $LN45@xmlXPathCo
$LN59@xmlXPathCo:

; 10189:             XP_ERROR(XPATH_NUMBER_ERROR);

	push	1
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 10225:                    xmlXPathCacheNewFloat(ctxt->context, ret), NULL);
; 10226: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlXPathCo:

; 10190:         }
; 10191:         while (CUR == '0') {

	cmp	bl, 48					; 00000030H
	jne	SHORT $LN5@xmlXPathCo
	mov	ecx, esi
$LL4@xmlXPathCo:

; 10192:             frac = frac + 1;

	inc	eax

; 10193:             NEXT;

	mov	esi, ecx
	test	bl, bl
	je	SHORT $LN30@xmlXPathCo
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], esi
	mov	bl, BYTE PTR [esi]
$LN30@xmlXPathCo:

; 10190:         }
; 10191:         while (CUR == '0') {

	mov	ecx, esi
	cmp	bl, 48					; 00000030H
	je	SHORT $LL4@xmlXPathCo
	mov	DWORD PTR _frac$1$[ebp], eax
$LN5@xmlXPathCo:

; 10194:         }
; 10195:         max = frac + MAX_FRAC;
; 10196:         while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {

	movsd	xmm2, QWORD PTR __real@4024000000000000
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _max$1$[ebp], ecx
	cmp	bl, 48					; 00000030H
	jb	SHORT $LN7@xmlXPathCo
	mov	edx, esi
$LL6@xmlXPathCo:
	mov	cl, bl
	mov	esi, edx
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN61@xmlXPathCo
	cmp	eax, DWORD PTR _max$1$[ebp]
	jge	SHORT $LN61@xmlXPathCo

; 10197: 	    v = (CUR - '0');

	movzx	eax, cl
	sub	eax, 48					; 00000030H

; 10198: 	    fraction = fraction * 10 + v;

	mulsd	xmm1, xmm2
	movd	xmm0, eax

; 10199: 	    frac = frac + 1;

	mov	eax, DWORD PTR _frac$1$[ebp]
	cvtdq2pd xmm0, xmm0
	inc	eax
	mov	DWORD PTR _frac$1$[ebp], eax
	addsd	xmm1, xmm0

; 10200:             NEXT;

	test	cl, cl
	je	SHORT $LN32@xmlXPathCo
	lea	esi, DWORD PTR [edx+1]
	mov	DWORD PTR [edi], esi
	mov	bl, BYTE PTR [esi]
$LN32@xmlXPathCo:

; 10194:         }
; 10195:         max = frac + MAX_FRAC;
; 10196:         while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {

	mov	edx, esi
	cmp	bl, 48					; 00000030H
	jae	SHORT $LL6@xmlXPathCo
$LN61@xmlXPathCo:
	movsd	QWORD PTR _fraction$1$[ebp], xmm1
$LN7@xmlXPathCo:
	movd	xmm1, eax

; 10201:         }
; 10202:         fraction /= pow(10.0, frac);

	movaps	xmm0, xmm2
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	movsd	xmm2, QWORD PTR _fraction$1$[ebp]
	divsd	xmm2, xmm0

; 10203:         ret = ret + fraction;

	addsd	xmm2, QWORD PTR _ret$1$[ebp]
	movsd	QWORD PTR _ret$1$[ebp], xmm2

; 10204:         while ((CUR >= '0') && (CUR <= '9'))

	cmp	bl, 48					; 00000030H
	jb	SHORT $LN62@xmlXPathCo
	mov	eax, esi
$LL8@xmlXPathCo:
	mov	esi, eax
	cmp	bl, 57					; 00000039H
	ja	SHORT $LN62@xmlXPathCo

; 10205:             NEXT;

	test	bl, bl
	je	SHORT $LN34@xmlXPathCo
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR [edi], esi
	mov	bl, BYTE PTR [esi]
$LN34@xmlXPathCo:

; 10204:         while ((CUR >= '0') && (CUR <= '9'))

	mov	eax, esi
	cmp	bl, 48					; 00000030H
	jae	SHORT $LL8@xmlXPathCo
$LN62@xmlXPathCo:

; 10206:     }
; 10207:     if ((CUR == 'e') || (CUR == 'E')) {

	mov	al, bl
	cmp	bl, 101					; 00000065H
	je	SHORT $LN19@xmlXPathCo
	cmp	bl, 69					; 00000045H
	jne	$LN18@xmlXPathCo
$LN19@xmlXPathCo:

; 10208:         NEXT;

	test	bl, bl
	je	SHORT $LN36@xmlXPathCo
	inc	esi
	mov	DWORD PTR [edi], esi
	mov	al, BYTE PTR [esi]
$LN36@xmlXPathCo:

; 10209:         if (CUR == '-') {

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN20@xmlXPathCo

; 10210:             is_exponent_negative = 1;
; 10211:             NEXT;

	inc	esi
	mov	ebx, 1
	mov	DWORD PTR [edi], esi

; 10212:         } else if (CUR == '+') {

	mov	al, BYTE PTR [esi]
	jmp	SHORT $LN40@xmlXPathCo
$LN20@xmlXPathCo:
	cmp	al, 43					; 0000002bH
	jne	SHORT $LN64@xmlXPathCo

; 10213: 	    NEXT;

	inc	esi
	mov	DWORD PTR [edi], esi
	mov	al, BYTE PTR [esi]
$LN64@xmlXPathCo:

; 10214: 	}
; 10215:         while ((CUR >= '0') && (CUR <= '9')) {

	xor	ebx, ebx
$LN40@xmlXPathCo:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN63@xmlXPathCo
$LL10@xmlXPathCo:
	mov	dl, al
	cmp	dl, 57					; 00000039H
	ja	SHORT $LN63@xmlXPathCo

; 10216:             if (exponent < 1000000)

	mov	ecx, DWORD PTR _exponent$1$[ebp]
	cmp	ecx, 1000000				; 000f4240H
	jge	SHORT $LN23@xmlXPathCo

; 10217:                 exponent = exponent * 10 + (CUR - '0');

	movzx	eax, dl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -48				; ffffffd0H
	mov	DWORD PTR _exponent$1$[ebp], eax
	mov	al, dl
$LN23@xmlXPathCo:

; 10218:             NEXT;

	test	dl, dl
	je	SHORT $LN42@xmlXPathCo
	inc	esi
	mov	DWORD PTR [edi], esi
	mov	al, BYTE PTR [esi]
$LN42@xmlXPathCo:

; 10214: 	}
; 10215:         while ((CUR >= '0') && (CUR <= '9')) {

	cmp	al, 48					; 00000030H
	jae	SHORT $LL10@xmlXPathCo
$LN63@xmlXPathCo:

; 10219:         }
; 10220:         if (is_exponent_negative)
; 10221:             exponent = -exponent;
; 10222:         ret *= pow(10.0, (double) exponent);

	mov	eax, DWORD PTR _exponent$1$[ebp]
	movsd	xmm0, QWORD PTR __real@4024000000000000
	neg	eax
	test	ebx, ebx
	cmove	eax, DWORD PTR _exponent$1$[ebp]
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR _ret$1$[ebp]
	movaps	xmm2, xmm0
$LN18@xmlXPathCo:

; 10223:     }
; 10224:     PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_NUMBER, 0, 0,

	mov	esi, DWORD PTR [edi+32]
	push	0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewFloat
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	push	0
	push	3
	push	11					; 0000000bH
	push	-1
	push	DWORD PTR [esi+12]
	push	esi
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
	pop	esi
	pop	ebx
$LN1@xmlXPathCo:
	pop	edi

; 10225:                    xmlXPathCacheNewFloat(ctxt->context, ret), NULL);
; 10226: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathParseQName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlXPathParseQName PROC				; COMDAT

; 9891 : xmlXPathParseQName(xmlXPathParserContextPtr ctxt, xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _prefix$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	mov	DWORD PTR [edi], 0
	call	_xmlXPathParseNCName
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@xmlXPathPa

; 9892 :     xmlChar *ret = NULL;
; 9893 : 
; 9894 :     *prefix = NULL;
; 9895 :     ret = xmlXPathParseNCName(ctxt);
; 9896 :     if (ret && CUR == ':') {

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx], 58			; 0000003aH
	jne	SHORT $LN2@xmlXPathPa

; 9897 :         *prefix = ret;

	mov	DWORD PTR [edi], eax

; 9898 : 	NEXT;

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN4@xmlXPathPa
	inc	eax
	mov	DWORD PTR [esi], eax
$LN4@xmlXPathPa:

; 9899 : 	ret = xmlXPathParseNCName(ctxt);

	push	esi
	call	_xmlXPathParseNCName
	add	esp, 4
$LN2@xmlXPathPa:

; 9900 :     }
; 9901 :     return(ret);
; 9902 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathParseQName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCurrentChar
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlXPathCurrentChar PROC				; COMDAT

; 9751 : xmlXPathCurrentChar(xmlXPathParserContextPtr ctxt, int *len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN27@xmlXPathCu

; 9752 :     unsigned char c;
; 9753 :     unsigned int val;
; 9754 :     const xmlChar *cur;
; 9755 : 
; 9756 :     if (ctxt == NULL)
; 9757 : 	return(0);
; 9758 :     cur = ctxt->cur;
; 9759 : 
; 9760 :     /*
; 9761 :      * We are supposed to handle UTF8, check it's valid
; 9762 :      * From rfc2044: encoding of the Unicode values on UTF-8:
; 9763 :      *
; 9764 :      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 9765 :      * 0000 0000-0000 007F   0xxxxxxx
; 9766 :      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 9767 :      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 9768 :      *
; 9769 :      * Check for the 0x110000 limit too
; 9770 :      */
; 9771 :     c = *cur;

	mov	edx, DWORD PTR [esi]
	mov	cl, BYTE PTR [edx]

; 9772 :     if (c & 0x80) {

	test	cl, cl
	jns	$LN3@xmlXPathCu

; 9773 : 	if ((cur[1] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+1]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$29

; 9774 : 	    goto encoding_error;
; 9775 : 	if ((c & 0xe0) == 0xe0) {

	mov	al, cl
	and	al, 224					; 000000e0H
	cmp	al, 224					; 000000e0H
	jne	SHORT $LN6@xmlXPathCu

; 9776 : 
; 9777 : 	    if ((cur[2] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+2]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$29

; 9778 : 		goto encoding_error;
; 9779 : 	    if ((c & 0xf0) == 0xf0) {

	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN9@xmlXPathCu

; 9780 : 		if (((c & 0xf8) != 0xf0) ||

	and	cl, 248					; 000000f8H
	cmp	cl, al
	jne	$encoding_error$29
	mov	al, BYTE PTR [edx+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$encoding_error$29

; 9781 : 		    ((cur[3] & 0xc0) != 0x80))
; 9782 : 		    goto encoding_error;
; 9783 : 		/* 4-byte code */
; 9784 : 		*len = 4;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 4

; 9785 : 		val = (cur[0] & 0x7) << 18;
; 9786 : 		val |= (cur[1] & 0x3f) << 12;
; 9787 : 		val |= (cur[2] & 0x3f) << 6;
; 9788 : 		val |= cur[3] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 7
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+3]

; 9789 : 	    } else {

	jmp	SHORT $LN26@xmlXPathCu
$LN9@xmlXPathCu:

; 9790 : 	      /* 3-byte code */
; 9791 : 		*len = 3;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 3

; 9792 : 		val = (cur[0] & 0xf) << 12;
; 9793 : 		val |= (cur[1] & 0x3f) << 6;
; 9794 : 		val |= cur[2] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]

; 9795 : 	    }
; 9796 : 	} else {

	jmp	SHORT $LN26@xmlXPathCu
$LN6@xmlXPathCu:

; 9797 : 	  /* 2-byte code */
; 9798 : 	    *len = 2;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 2

; 9799 : 	    val = (cur[0] & 0x1f) << 6;
; 9800 : 	    val |= cur[1] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 31					; 0000001fH
$LN26@xmlXPathCu:

; 9801 : 	}
; 9802 : 	if (!IS_CHAR(val)) {

	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN23@xmlXPathCu
	cmp	ecx, 9
	jb	SHORT $LN15@xmlXPathCu
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN13@xmlXPathCu
$LN15@xmlXPathCu:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN13@xmlXPathCu
	cmp	ecx, 32					; 00000020H
	jb	SHORT $LN20@xmlXPathCu
$LN13@xmlXPathCu:

; 9804 : 	}
; 9805 : 	return(val);

	mov	eax, ecx
	pop	esi

; 9821 : }

	pop	ebp
	ret	0
$LN23@xmlXPathCu:

; 9801 : 	}
; 9802 : 	if (!IS_CHAR(val)) {

	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN13@xmlXPathCu
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN18@xmlXPathCu
	cmp	ecx, 65533				; 0000fffdH
	jbe	SHORT $LN13@xmlXPathCu
$LN18@xmlXPathCu:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	jbe	SHORT $LN13@xmlXPathCu
$LN20@xmlXPathCu:

; 9803 : 	    XP_ERROR0(XPATH_INVALID_CHAR_ERROR);

	push	21					; 00000015H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN27@xmlXPathCu:

; 9821 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$encoding_error$29:

; 9810 :     }
; 9811 : encoding_error:
; 9812 :     /*
; 9813 :      * If we detect an UTF8 error that probably means that the
; 9814 :      * input encoding didn't get properly advertised in the
; 9815 :      * declaration header. Report the error and switch the encoding
; 9816 :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 9817 :      * encoding !)
; 9818 :      */
; 9819 :     *len = 0;

	mov	eax, DWORD PTR _len$[ebp]

; 9820 :     XP_ERROR0(XPATH_ENCODING_ERROR);

	push	20					; 00000014H
	push	esi
	mov	DWORD PTR [eax], 0
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	esi

; 9821 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCu:

; 9806 :     } else {
; 9807 : 	/* 1-byte code */
; 9808 : 	*len = 1;

	mov	eax, DWORD PTR _len$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1

; 9809 : 	return((int) *cur);

	movzx	eax, BYTE PTR [edx]

; 9821 : }

	pop	ebp
	ret	0
_xmlXPathCurrentChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathParseNameComplex
_TEXT	SEGMENT
_buf$ = -120						; size = 105
_max$1$ = -12						; size = 4
_buffer$1$ = -8						; size = 4
_l$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_qualified$ = 12					; size = 4
_xmlXPathParseNameComplex PROC				; COMDAT

; 9954 : xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR _l$[ebp]
	xor	esi, esi
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathCurrentChar
	mov	ebx, eax
	add	esp, 8
	cmp	ebx, 32					; 00000020H
	je	$LN8@xmlXPathPa

; 9955 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 9956 :     int len = 0, l;
; 9957 :     int c;
; 9958 : 
; 9959 :     /*
; 9960 :      * Handler for more complex cases
; 9961 :      */
; 9962 :     c = CUR_CHAR(l);
; 9963 :     if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
; 9964 :         (c == '[') || (c == ']') || (c == '@') || /* accelerators */
; 9965 :         (c == '*') || /* accelerators */

	cmp	ebx, 62					; 0000003eH
	je	$LN8@xmlXPathPa
	cmp	ebx, 47					; 0000002fH
	je	$LN8@xmlXPathPa
	cmp	ebx, 91					; 0000005bH
	je	$LN8@xmlXPathPa
	cmp	ebx, 93					; 0000005dH
	je	$LN8@xmlXPathPa
	cmp	ebx, 64					; 00000040H
	je	$LN8@xmlXPathPa
	cmp	ebx, 42					; 0000002aH
	je	$LN8@xmlXPathPa
	mov	edi, DWORD PTR _qualified$[ebp]
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN31@xmlXPathPa
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN25@xmlXPathPa
	cmp	ebx, 90					; 0000005aH
	jle	$LL2@xmlXPathPa
$LN25@xmlXPathPa:
	cmp	ebx, 97					; 00000061H
	jl	SHORT $LN26@xmlXPathPa
	cmp	ebx, 122				; 0000007aH
	jle	$LL2@xmlXPathPa
$LN26@xmlXPathPa:
	cmp	ebx, 192				; 000000c0H
	jl	SHORT $LN28@xmlXPathPa
	cmp	ebx, 214				; 000000d6H
	jle	SHORT $LL2@xmlXPathPa
$LN28@xmlXPathPa:
	cmp	ebx, 216				; 000000d8H
	jl	SHORT $LN29@xmlXPathPa
	cmp	ebx, 246				; 000000f6H
	jle	SHORT $LL2@xmlXPathPa
$LN29@xmlXPathPa:
	cmp	ebx, 248				; 000000f8H
	jge	SHORT $LL2@xmlXPathPa
	jmp	SHORT $LN92@xmlXPathPa
$LN31@xmlXPathPa:
	push	OFFSET _xmlIsBaseCharGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@xmlXPathPa
$LN92@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN99@xmlXPathPa
	cmp	ebx, 19968				; 00004e00H
	jl	SHORT $LN33@xmlXPathPa
	cmp	ebx, 40869				; 00009fa5H
	jle	SHORT $LL2@xmlXPathPa
$LN33@xmlXPathPa:
	cmp	ebx, 12295				; 00003007H
	je	SHORT $LL2@xmlXPathPa
	cmp	ebx, 12321				; 00003021H
	jl	SHORT $LN99@xmlXPathPa
	cmp	ebx, 12329				; 00003029H
	jle	SHORT $LL2@xmlXPathPa
$LN99@xmlXPathPa:
	cmp	ebx, 95					; 0000005fH
	je	SHORT $LL2@xmlXPathPa
	test	edi, edi
	je	$LN8@xmlXPathPa
	cmp	ebx, 58					; 0000003aH
	jne	$LN8@xmlXPathPa
	npad	2
$LL2@xmlXPathPa:

; 9966 : 	(!IS_LETTER(c) && (c != '_') &&
; 9967 :          ((!qualified) || (c != ':')))) {
; 9968 : 	return(NULL);
; 9969 :     }
; 9970 : 
; 9971 :     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	ebx, 62					; 0000003eH
	je	$LN3@xmlXPathPa
	cmp	ebx, 47					; 0000002fH
	je	$LN3@xmlXPathPa
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN45@xmlXPathPa
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN39@xmlXPathPa
	cmp	ebx, 90					; 0000005aH
	jle	$LN9@xmlXPathPa
$LN39@xmlXPathPa:
	cmp	ebx, 97					; 00000061H
	jl	SHORT $LN40@xmlXPathPa
	cmp	ebx, 122				; 0000007aH
	jle	$LN9@xmlXPathPa
$LN40@xmlXPathPa:
	cmp	ebx, 192				; 000000c0H
	jl	SHORT $LN42@xmlXPathPa
	cmp	ebx, 214				; 000000d6H
	jle	$LN9@xmlXPathPa
$LN42@xmlXPathPa:
	cmp	ebx, 216				; 000000d8H
	jl	SHORT $LN43@xmlXPathPa
	cmp	ebx, 246				; 000000f6H
	jle	$LN9@xmlXPathPa
$LN43@xmlXPathPa:
	cmp	ebx, 248				; 000000f8H
	jge	$LN9@xmlXPathPa
	jmp	SHORT $LN93@xmlXPathPa
$LN45@xmlXPathPa:
	push	OFFSET _xmlIsBaseCharGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN9@xmlXPathPa
$LN93@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN120@xmlXPathPa
	cmp	ebx, 19968				; 00004e00H
	jl	SHORT $LN47@xmlXPathPa
	cmp	ebx, 40869				; 00009fa5H
	jle	$LN9@xmlXPathPa
$LN47@xmlXPathPa:
	cmp	ebx, 12295				; 00003007H
	je	$LN9@xmlXPathPa
	cmp	ebx, 12321				; 00003021H
	jl	SHORT $LN100@xmlXPathPa
	cmp	ebx, 12329				; 00003029H
	jle	SHORT $LN9@xmlXPathPa
$LN100@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN55@xmlXPathPa
$LN120@xmlXPathPa:
	lea	eax, DWORD PTR [ebx-48]
	cmp	eax, 9
	ja	SHORT $LN94@xmlXPathPa
	jmp	SHORT $LN9@xmlXPathPa
$LN55@xmlXPathPa:
	push	OFFSET _xmlIsDigitGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlXPathPa
$LN94@xmlXPathPa:
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN9@xmlXPathPa
	cmp	ebx, 45					; 0000002dH
	je	SHORT $LN9@xmlXPathPa
	cmp	ebx, 95					; 0000005fH
	je	SHORT $LN9@xmlXPathPa
	test	edi, edi
	je	SHORT $LN10@xmlXPathPa
	cmp	ebx, 58					; 0000003aH
	je	SHORT $LN9@xmlXPathPa
$LN10@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN101@xmlXPathPa
	push	OFFSET _xmlIsCombiningGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlXPathPa
	push	OFFSET _xmlIsExtenderGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN60@xmlXPathPa
$LN101@xmlXPathPa:
	xor	eax, eax
	cmp	ebx, 183				; 000000b7H
	sete	al
$LN60@xmlXPathPa:
	test	eax, eax
	je	SHORT $LN3@xmlXPathPa
$LN9@xmlXPathPa:

; 9972 : 	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 9973 :             (c == '.') || (c == '-') ||
; 9974 : 	    (c == '_') || ((qualified) && (c == ':')) ||
; 9975 : 	    (IS_COMBINING(c)) ||
; 9976 : 	    (IS_EXTENDER(c)))) {
; 9977 : 	COPY_BUF(l,buf,len,c);

	mov	edi, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR _buf$[ebp]
	add	eax, esi
	cmp	edi, 1
	jne	SHORT $LN11@xmlXPathPa
	mov	BYTE PTR [eax], bl
	inc	esi
	jmp	SHORT $LN12@xmlXPathPa
$LN11@xmlXPathPa:
	push	ebx
	push	eax
	push	edi
	call	_xmlCopyChar
	add	esp, 12					; 0000000cH
	add	esi, eax
$LN12@xmlXPathPa:

; 9978 : 	NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]

; 9979 : 	c = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	add	DWORD PTR [eax], edi
	call	_xmlXPathCurrentChar
	add	esp, 8
	mov	ebx, eax

; 9980 : 	if (len >= XML_MAX_NAMELEN) {

	cmp	esi, 100				; 00000064H
	jge	SHORT $LN85@xmlXPathPa

; 9966 : 	(!IS_LETTER(c) && (c != '_') &&
; 9967 :          ((!qualified) || (c != ':')))) {
; 9968 : 	return(NULL);
; 9969 :     }
; 9970 : 
; 9971 :     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	mov	edi, DWORD PTR _qualified$[ebp]
	cmp	ebx, 32					; 00000020H
	jne	$LL2@xmlXPathPa
$LN3@xmlXPathPa:

; 10017: 	    return(buffer);
; 10018: 	}
; 10019:     }
; 10020:     if (len == 0)

	test	esi, esi
	je	$LN8@xmlXPathPa

; 10021: 	return(NULL);
; 10022:     return(xmlStrndup(buf, len));

	lea	eax, DWORD PTR _buf$[ebp]
	push	esi
	push	eax
	call	_xmlStrndup
	add	esp, 8
	pop	edi

; 10023: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@xmlXPathPa:

; 9981 : 	    /*
; 9982 : 	     * Okay someone managed to make a huge name, so he's ready to pay
; 9983 : 	     * for the processing speed.
; 9984 : 	     */
; 9985 : 	    xmlChar *buffer;
; 9986 : 	    int max = len * 2;

	lea	edi, DWORD PTR [esi+esi]
	mov	DWORD PTR _max$1$[ebp], edi

; 9987 : 
; 9988 :             if (len > XML_MAX_NAME_LENGTH) {

	cmp	esi, 50000				; 0000c350H
	jg	$LN86@xmlXPathPa

; 9989 :                 XP_ERRORNULL(XPATH_EXPR_ERROR);
; 9990 :             }
; 9991 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	push	edi
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	mov	DWORD PTR _buffer$1$[ebp], eax

; 9992 : 	    if (buffer == NULL) {

	test	eax, eax
	je	$LN87@xmlXPathPa

; 9993 : 		XP_ERRORNULL(XPATH_MEMORY_ERROR);
; 9994 : 	    }
; 9995 : 	    memcpy(buffer, buf, len);

	push	esi
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LL4@xmlXPathPa:

; 9996 : 	    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
; 9997 : 		   (c == '.') || (c == '-') ||
; 9998 : 		   (c == '_') || ((qualified) && (c == ':')) ||
; 9999 : 		   (IS_COMBINING(c)) ||

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN67@xmlXPathPa
	cmp	ebx, 65					; 00000041H
	jl	SHORT $LN61@xmlXPathPa
	cmp	ebx, 90					; 0000005aH
	jle	$LN16@xmlXPathPa
$LN61@xmlXPathPa:
	cmp	ebx, 97					; 00000061H
	jl	SHORT $LN62@xmlXPathPa
	cmp	ebx, 122				; 0000007aH
	jle	$LN16@xmlXPathPa
$LN62@xmlXPathPa:
	cmp	ebx, 192				; 000000c0H
	jl	SHORT $LN64@xmlXPathPa
	cmp	ebx, 214				; 000000d6H
	jle	$LN16@xmlXPathPa
$LN64@xmlXPathPa:
	cmp	ebx, 216				; 000000d8H
	jl	SHORT $LN65@xmlXPathPa
	cmp	ebx, 246				; 000000f6H
	jle	$LN16@xmlXPathPa
$LN65@xmlXPathPa:
	cmp	ebx, 248				; 000000f8H
	jge	$LN16@xmlXPathPa
	jmp	SHORT $LN96@xmlXPathPa
$LN67@xmlXPathPa:
	push	OFFSET _xmlIsBaseCharGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	$LN16@xmlXPathPa
$LN96@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN122@xmlXPathPa
	cmp	ebx, 19968				; 00004e00H
	jl	SHORT $LN69@xmlXPathPa
	cmp	ebx, 40869				; 00009fa5H
	jle	$LN16@xmlXPathPa
$LN69@xmlXPathPa:
	cmp	ebx, 12295				; 00003007H
	je	$LN16@xmlXPathPa
	cmp	ebx, 12321				; 00003021H
	jl	SHORT $LN102@xmlXPathPa
	cmp	ebx, 12329				; 00003029H
	jle	SHORT $LN16@xmlXPathPa
$LN102@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN77@xmlXPathPa
$LN122@xmlXPathPa:
	lea	eax, DWORD PTR [ebx-48]
	cmp	eax, 9
	ja	SHORT $LN97@xmlXPathPa
	jmp	SHORT $LN16@xmlXPathPa
$LN77@xmlXPathPa:
	push	OFFSET _xmlIsDigitGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlXPathPa
$LN97@xmlXPathPa:
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN16@xmlXPathPa
	cmp	ebx, 45					; 0000002dH
	je	SHORT $LN16@xmlXPathPa
	cmp	ebx, 95					; 0000005fH
	je	SHORT $LN16@xmlXPathPa
	cmp	DWORD PTR _qualified$[ebp], 0
	je	SHORT $LN17@xmlXPathPa
	cmp	ebx, 58					; 0000003aH
	je	SHORT $LN16@xmlXPathPa
$LN17@xmlXPathPa:
	cmp	ebx, 256				; 00000100H
	jl	SHORT $LN103@xmlXPathPa
	push	OFFSET _xmlIsCombiningGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@xmlXPathPa
	push	OFFSET _xmlIsExtenderGroup
	push	ebx
	call	_xmlCharInRange
	add	esp, 8
	jmp	SHORT $LN82@xmlXPathPa
$LN103@xmlXPathPa:
	xor	eax, eax
	cmp	ebx, 183				; 000000b7H
	sete	al
$LN82@xmlXPathPa:
	test	eax, eax
	je	SHORT $LN5@xmlXPathPa
$LN16@xmlXPathPa:

; 10000: 		   (IS_EXTENDER(c))) {
; 10001: 		if (len + 10 > max) {

	lea	eax, DWORD PTR [esi+10]
	cmp	eax, edi
	jle	SHORT $LN116@xmlXPathPa

; 10002:                     if (max > XML_MAX_NAME_LENGTH) {

	cmp	edi, 50000				; 0000c350H
	jg	SHORT $LN86@xmlXPathPa

; 10004:                     }
; 10005: 		    max *= 2;
; 10006: 		    buffer = (xmlChar *) xmlRealloc(buffer,

	mov	eax, DWORD PTR _buffer$1$[ebp]
	add	edi, edi
	push	edi
	push	eax
	mov	DWORD PTR _max$1$[ebp], edi
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	mov	DWORD PTR _buffer$1$[ebp], eax

; 10007: 			                            max * sizeof(xmlChar));
; 10008: 		    if (buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlXPathPa
$LN87@xmlXPathPa:

; 10009: 			XP_ERRORNULL(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH

; 10023: }

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErr
	add	esp, 8
$LN8@xmlXPathPa:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN116@xmlXPathPa:

; 10000: 		   (IS_EXTENDER(c))) {
; 10001: 		if (len + 10 > max) {

	mov	eax, DWORD PTR _buffer$1$[ebp]
$LN20@xmlXPathPa:

; 10010: 		    }
; 10011: 		}
; 10012: 		COPY_BUF(l,buffer,len,c);

	mov	edi, DWORD PTR _l$[ebp]
	add	eax, esi
	cmp	edi, 1
	jne	SHORT $LN21@xmlXPathPa
	mov	BYTE PTR [eax], bl
	inc	esi
	jmp	SHORT $LN22@xmlXPathPa
$LN21@xmlXPathPa:
	push	ebx
	push	eax
	push	edi
	call	_xmlCopyChar
	add	esp, 12					; 0000000cH
	add	esi, eax
$LN22@xmlXPathPa:

; 10013: 		NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]

; 10014: 		c = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	eax
	add	DWORD PTR [eax], edi
	call	_xmlXPathCurrentChar

; 10015: 	    }

	mov	edi, DWORD PTR _max$1$[ebp]
	add	esp, 8
	mov	ebx, eax
	jmp	$LL4@xmlXPathPa
$LN5@xmlXPathPa:

; 10016: 	    buffer[len] = 0;

	mov	eax, DWORD PTR _buffer$1$[ebp]
	pop	edi
	mov	BYTE PTR [eax+esi], 0

; 10023: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@xmlXPathPa:

; 10003:                         XP_ERRORNULL(XPATH_EXPR_ERROR);

	push	7

; 10023: }

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathParseNameComplex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompRelativeLocationPath
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompRelativeLocationPath PROC			; COMDAT

; 11464: (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 11465:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN18@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN19@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN18@xmlXPathCo
$LN19@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN18@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 11466:     if ((CUR == '/') && (NXT(1) == '/')) {

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN115@xmlXPathCo
	cmp	BYTE PTR [ecx+1], 47			; 0000002fH
	lea	eax, DWORD PTR [ecx+1]
	jne	SHORT $LN94@xmlXPathCo

; 11467: 	SKIP(2);

	add	ecx, 2
$LN116@xmlXPathCo:

; 11468: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL4@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN22@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN23@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN22@xmlXPathCo
$LN23@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN22@xmlXPathCo:
	test	al, al
	je	SHORT $LL4@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN116@xmlXPathCo
$LN5@xmlXPathCo:

; 11469: 	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	1
	push	6
	push	10					; 0000000aH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
$LN115@xmlXPathCo:

; 11474:     }
; 11475:     xmlXPathCompStep(ctxt);

	push	esi
	call	_xmlXPathCompStep
	add	esp, 4

; 11476:     CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN114@xmlXPathCo
	mov	eax, DWORD PTR [esi]
	npad	5
$LL8@xmlXPathCo:

; 11477:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN28@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN29@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN28@xmlXPathCo
$LN29@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN63@xmlXPathCo
$LN28@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN94@xmlXPathCo:

; 11470: 		         NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
; 11471:     } else if (CUR == '/') {
; 11472: 	    NEXT;
; 11473: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], eax
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN25@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN26@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN25@xmlXPathCo
$LN26@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN115@xmlXPathCo
$LN25@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL6@xmlXPathCo
	inc	eax
	jmp	SHORT $LN94@xmlXPathCo
$LN63@xmlXPathCo:

; 11478:     while (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	jne	$LN114@xmlXPathCo
$LN119@xmlXPathCo:

; 11479: 	if ((CUR == '/') && (NXT(1) == '/')) {

	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	lea	ecx, DWORD PTR [eax+1]
	jne	SHORT $LN95@xmlXPathCo

; 11480: 	    SKIP(2);

	lea	ecx, DWORD PTR [eax+2]
$LN117@xmlXPathCo:

; 11481: 	    SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL12@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN32@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN33@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN32@xmlXPathCo
$LN33@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN13@xmlXPathCo
$LN32@xmlXPathCo:
	test	al, al
	je	SHORT $LL12@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN117@xmlXPathCo
$LN13@xmlXPathCo:

; 11482: 	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	1
	push	6
	push	10					; 0000000aH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd

; 11483: 			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
; 11484: 	    xmlXPathCompStep(ctxt);

	push	esi
	call	_xmlXPathCompStep
	add	esp, 40					; 00000028H
	jmp	SHORT $LN85@xmlXPathCo
$LN95@xmlXPathCo:

; 11485: 	} else if (CUR == '/') {
; 11486: 	    NEXT;
; 11487: 	    SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL14@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN35@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN36@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN35@xmlXPathCo
$LN36@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN15@xmlXPathCo
$LN35@xmlXPathCo:
	test	al, al
	je	SHORT $LL14@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN95@xmlXPathCo
$LN15@xmlXPathCo:

; 11488: 	    xmlXPathCompStep(ctxt);

	push	esi
	call	_xmlXPathCompStep
	add	esp, 4
$LN85@xmlXPathCo:
	mov	eax, DWORD PTR [esi]
	npad	7
$LL16@xmlXPathCo:

; 11489: 	}
; 11490: 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN37@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN38@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN37@xmlXPathCo
$LN38@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN17@xmlXPathCo
$LN37@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL16@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL16@xmlXPathCo
$LN17@xmlXPathCo:

; 11478:     while (CUR == '/') {

	cmp	cl, 47					; 0000002fH
	je	$LN119@xmlXPathCo
$LN114@xmlXPathCo:
	pop	esi

; 11491:     }
; 11492: }

	pop	ebp
	ret	0
_xmlXPathCompRelativeLocationPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompLocationPath
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathCompLocationPath PROC				; COMDAT

; 11516: xmlXPathCompLocationPath(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 11517:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN10@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN11@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN10@xmlXPathCo
$LN11@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN10@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 11518:     if (CUR != '/') {

	cmp	cl, 47					; 0000002fH
	je	SHORT $LN62@xmlXPathCo

; 11519:         xmlXPathCompRelativeLocationPath(ctxt);

	push	esi
	call	_xmlXPathCompRelativeLocationPath
	add	esp, 4
	pop	esi

; 11537: 	}
; 11538:     }
; 11539: }

	pop	ebp
	ret	0
$LN62@xmlXPathCo:

; 11522: 	    if ((CUR == '/') && (NXT(1) == '/')) {

	cmp	BYTE PTR [eax+1], 47			; 0000002fH
	lea	ecx, DWORD PTR [eax+1]
	jne	SHORT $LN48@xmlXPathCo

; 11523: 		SKIP(2);

	lea	ecx, DWORD PTR [eax+2]
$LN63@xmlXPathCo:

; 11524: 		SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN16@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN63@xmlXPathCo
$LN7@xmlXPathCo:

; 11525: 		PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	1
	push	6
	push	10					; 0000000aH
	push	-1
	push	DWORD PTR [eax+12]
	push	eax
	call	_xmlXPathCompExprAdd

; 11526: 			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
; 11527: 		xmlXPathCompRelativeLocationPath(ctxt);

	push	esi
	call	_xmlXPathCompRelativeLocationPath
	add	esp, 40					; 00000028H
	jmp	SHORT $LN21@xmlXPathCo
$LN48@xmlXPathCo:

; 11528: 	    } else if (CUR == '/') {
; 11529: 		NEXT;
; 11530: 		SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL8@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN19@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN20@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN19@xmlXPathCo
$LN20@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN19@xmlXPathCo:
	test	al, al
	je	SHORT $LL8@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN48@xmlXPathCo
$LN9@xmlXPathCo:

; 11531: 		if ((CUR != 0 ) &&

	test	al, al
	je	SHORT $LN21@xmlXPathCo
	cmp	al, 65					; 00000041H
	jb	SHORT $LN23@xmlXPathCo
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN22@xmlXPathCo
$LN23@xmlXPathCo:
	cmp	al, 97					; 00000061H
	jb	SHORT $LN24@xmlXPathCo
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN22@xmlXPathCo
$LN24@xmlXPathCo:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN22@xmlXPathCo
	cmp	al, 46					; 0000002eH
	je	SHORT $LN22@xmlXPathCo
	cmp	al, 64					; 00000040H
	je	SHORT $LN22@xmlXPathCo
	cmp	al, 42					; 0000002aH
	jne	SHORT $LN21@xmlXPathCo
$LN22@xmlXPathCo:

; 11532: 		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
; 11533: 		     (CUR == '@') || (CUR == '*')))
; 11534: 		    xmlXPathCompRelativeLocationPath(ctxt);

	push	esi
	call	_xmlXPathCompRelativeLocationPath
	add	esp, 4
$LN21@xmlXPathCo:

; 11535: 	    }
; 11536: 	    CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN57@xmlXPathCo

; 11520:     } else {
; 11521: 	while (CUR == '/') {

	mov	eax, DWORD PTR [esi]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 47					; 0000002fH
	je	$LN62@xmlXPathCo
$LN57@xmlXPathCo:
	pop	esi

; 11537: 	}
; 11538:     }
; 11539: }

	pop	ebp
	ret	0
_xmlXPathCompLocationPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompPredicate
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_filter$ = 12						; size = 4
_xmlXPathCompPredicate PROC				; COMDAT

; 11032: xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	npad	6
$LL2@xmlXPathCo:

; 11033:     int op1 = ctxt->comp->last;
; 11034: 
; 11035:     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN9@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlXPathCo
$LN9@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathCo
$LN8@xmlXPathCo:
	test	al, al
	je	SHORT $LL2@xmlXPathCo
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 11036:     if (CUR != '[') {

	cmp	al, 91					; 0000005bH
	jne	$LN99@xmlXPathCo
$LN103@xmlXPathCo:

; 11037: 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
; 11038:     }
; 11039:     NEXT;
; 11040:     SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [esi], ecx
$LL4@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPathCo
$LN11@xmlXPathCo:
	test	al, al
	je	SHORT $LL4@xmlXPathCo
	jmp	SHORT $LN103@xmlXPathCo
$LN5@xmlXPathCo:

; 11041: 
; 11042:     ctxt->comp->last = -1;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax+12], -1

; 11043:     /*
; 11044:     * This call to xmlXPathCompileExpr() will deactivate sorting
; 11045:     * of the predicate result.
; 11046:     * TODO: Sorting is still activated for filters, since I'm not
; 11047:     *  sure if needed. Normally sorting should not be needed, since
; 11048:     *  a filter can only diminish the number of items in a sequence,
; 11049:     *  but won't change its order; so if the initial sequence is sorted,
; 11050:     *  subsequent sorting is not needed.
; 11051:     */
; 11052:     if (! filter)
; 11053: 	xmlXPathCompileExpr(ctxt, 0);
; 11054:     else
; 11055: 	xmlXPathCompileExpr(ctxt, 1);
; 11056:     CHECK_ERROR;

	xor	eax, eax
	cmp	DWORD PTR _filter$[ebp], eax
	setne	al
	push	eax
	push	esi
	call	_xmlXPathCompileExpr
	add	esp, 8
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN7@xmlXPathCo

; 11057: 
; 11058:     if (CUR != ']') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN99@xmlXPathCo

; 11060:     }
; 11061: 
; 11062:     if (filter)

	mov	ecx, DWORD PTR [esi+32]

; 11063: 	PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);
; 11064:     else
; 11065: 	PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);
; 11066: 
; 11067:     NEXT;

	xor	eax, eax
	cmp	DWORD PTR _filter$[ebp], eax
	push	0
	push	0
	push	0
	push	0
	setne	al
	push	0
	add	eax, 15					; 0000000fH
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	push	eax
	push	ebx
	push	ecx
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	cmp	BYTE PTR [eax], 0
$LN104@xmlXPathCo:

; 11068:     SKIP_BLANKS;

	je	SHORT $LL6@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
$LL6@xmlXPathCo:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN19@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN20@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN19@xmlXPathCo
$LN20@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN19@xmlXPathCo:
	test	cl, cl
	jmp	SHORT $LN104@xmlXPathCo
$LN99@xmlXPathCo:

; 11059: 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);

	push	6
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN7@xmlXPathCo:

; 11069: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathCompPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompileExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_sort$ = 12						; size = 4
_xmlXPathCompileExpr PROC				; COMDAT

; 10997: xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_xmlXPathCompAndExpr
	add	esp, 4
	cmp	DWORD PTR [esi+8], 0
	jne	$LN18@xmlXPathCo
	mov	eax, DWORD PTR [esi]
$LL2@xmlXPathCo:

; 10998:     xmlXPathCompAndExpr(ctxt);
; 10999:     CHECK_ERROR;
; 11000:     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN11@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN12@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN28@xmlXPathCo
$LN11@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL2@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPathCo
$LN28@xmlXPathCo:
	push	edi

; 11001:     while ((CUR == 'o') && (NXT(1) == 'r')) {

	cmp	cl, 111					; 0000006fH
	jne	$LN47@xmlXPathCo
	npad	1
$LL4@xmlXPathCo:
	cmp	BYTE PTR [eax+1], 114			; 00000072H
	jne	SHORT $LN47@xmlXPathCo

; 11002: 	int op1 = ctxt->comp->last;

	mov	ecx, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [ecx+12]

; 11003:         SKIP(2);

	lea	ecx, DWORD PTR [eax+2]
$LN49@xmlXPathCo:

; 11004: 	SKIP_BLANKS;

	mov	DWORD PTR [esi], ecx
$LL6@xmlXPathCo:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN13@xmlXPathCo
	cmp	al, 9
	jb	SHORT $LN14@xmlXPathCo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN13@xmlXPathCo
$LN14@xmlXPathCo:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPathCo
$LN13@xmlXPathCo:
	test	al, al
	je	SHORT $LL6@xmlXPathCo
	inc	ecx
	jmp	SHORT $LN49@xmlXPathCo
$LN7@xmlXPathCo:

; 11005:         xmlXPathCompAndExpr(ctxt);

	push	esi
	call	_xmlXPathCompAndExpr
	add	esp, 4

; 11006: 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN48@xmlXPathCo

; 11007: 	PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);

	mov	eax, DWORD PTR [esi+32]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	_xmlXPathCompExprAdd
	mov	eax, DWORD PTR [esi]
	add	esp, 36					; 00000024H
$LL8@xmlXPathCo:

; 11008: 	SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN16@xmlXPathCo
	cmp	cl, 9
	jb	SHORT $LN17@xmlXPathCo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN16@xmlXPathCo
$LN17@xmlXPathCo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathCo
$LN16@xmlXPathCo:
	test	cl, cl
	je	SHORT $LL8@xmlXPathCo
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL8@xmlXPathCo
$LN9@xmlXPathCo:

; 11001:     while ((CUR == 'o') && (NXT(1) == 'r')) {

	cmp	cl, 111					; 0000006fH
	je	SHORT $LL4@xmlXPathCo
$LN47@xmlXPathCo:

; 11009:     }
; 11010:     if ((sort) && (ctxt->comp->steps[ctxt->comp->last].op != XPATH_OP_VALUE)) {

	cmp	DWORD PTR _sort$[ebp], 0
	je	SHORT $LN48@xmlXPathCo
	mov	edx, DWORD PTR [esi+32]
	mov	esi, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [esi+esi*4]
	cmp	DWORD PTR [eax+ecx*8], 11		; 0000000bH
	je	SHORT $LN48@xmlXPathCo

; 11011: 	/* more ops could be optimized too */
; 11012: 	/*
; 11013: 	* This is the main place to eliminate sorting for
; 11014: 	* operations which don't require a sorted node-set.
; 11015: 	* E.g. count().
; 11016: 	*/
; 11017: 	PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	17					; 00000011H
	push	-1
	push	esi
	push	edx
	call	_xmlXPathCompExprAdd
	add	esp, 36					; 00000024H
$LN48@xmlXPathCo:
	pop	edi
$LN18@xmlXPathCo:
	pop	esi

; 11018:     }
; 11019: }

	pop	ebp
	ret	0
_xmlXPathCompileExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNameFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathNameFunction PROC				; COMDAT

; 8841 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _nargs$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN4@xmlXPathNa

; 8842 :     xmlXPathObjectPtr cur;
; 8843 : 
; 8844 :     if (nargs == 0) {
; 8845 : 	valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 8846 : 	    ctxt->context->node));
; 8847 :         nargs = 1;

	mov	eax, 1
$LN4@xmlXPathNa:

; 8848 :     }
; 8849 : 
; 8850 :     CHECK_ARITY(1);

	test	esi, esi
	je	$LN1@xmlXPathNa
	cmp	eax, 1
	je	SHORT $LN6@xmlXPathNa
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN6@xmlXPathNa:

; 8848 :     }
; 8849 : 
; 8850 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN7@xmlXPathNa
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN7@xmlXPathNa:

; 8851 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN9@xmlXPathNa
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPathNa
	cmp	eax, 9
	jne	$LN9@xmlXPathNa
$LN8@xmlXPathNa:
	push	edi

; 8855 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 8856 : 
; 8857 :     if ((cur->nodesetval == NULL) || (cur->nodesetval->nodeNr == 0)) {

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	$LN12@xmlXPathNa
	cmp	DWORD PTR [ecx], 0
	je	$LN12@xmlXPathNa

; 8859 :     } else {
; 8860 :         int i = 0;              /* Should be first in document order !!!!! */
; 8861 : 
; 8862 :         switch (cur->nodesetval->nodeTab[i]->type) {

	mov	ecx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 1
	ja	$LN21@xmlXPathNa

; 8863 :             case XML_ELEMENT_NODE:
; 8864 :             case XML_ATTRIBUTE_NODE:
; 8865 : 		if (cur->nodesetval->nodeTab[i]->name[0] == ' ')

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	SHORT $LN14@xmlXPathNa

; 8866 : 		    valuePush(ctxt,

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewCString

; 8885 : 			ctxt->context, fullname));
; 8886 :                 }
; 8887 :                 break;

	add	esp, 8
	push	eax
	push	esi
	call	_valuePush
	add	esp, 8

; 8892 :         }
; 8893 :     }
; 8894 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	edi
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN14@xmlXPathNa:

; 8867 : 			xmlXPathCacheNewCString(ctxt->context, ""));
; 8868 : 		else if ((cur->nodesetval->nodeTab[i]->ns == NULL) ||

	mov	ecx, DWORD PTR [ecx+36]
	test	ecx, ecx
	je	SHORT $LN18@xmlXPathNa
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN18@xmlXPathNa

; 8871 : 		        xmlXPathCacheNewString(ctxt->context,
; 8872 : 			    cur->nodesetval->nodeTab[i]->name));
; 8873 : 		} else {
; 8874 : 		    xmlChar *fullname;
; 8875 : 
; 8876 : 		    fullname = xmlBuildQName(cur->nodesetval->nodeTab[i]->name,

	push	0
	push	0
	push	ecx
	push	eax
	call	_xmlBuildQName

; 8877 : 				     cur->nodesetval->nodeTab[i]->ns->prefix,
; 8878 : 				     NULL, 0);
; 8879 : 		    if (fullname == cur->nodesetval->nodeTab[i]->name)

	mov	ecx, DWORD PTR [edi+4]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	eax, ecx
	jne	SHORT $LN19@xmlXPathNa

; 8880 : 			fullname = xmlStrdup(cur->nodesetval->nodeTab[i]->name);

	push	ecx
	call	_xmlStrdup
	add	esp, 4
$LN19@xmlXPathNa:

; 8881 : 		    if (fullname == NULL) {

	test	eax, eax
	jne	SHORT $LN20@xmlXPathNa

; 8882 : 			XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
$LN1@xmlXPathNa:
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN20@xmlXPathNa:

; 8883 : 		    }
; 8884 : 		    valuePush(ctxt, xmlXPathCacheWrapString(

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheWrapString

; 8885 : 			ctxt->context, fullname));
; 8886 :                 }
; 8887 :                 break;

	add	esp, 8
	push	eax
	push	esi
	call	_valuePush
	add	esp, 8

; 8892 :         }
; 8893 :     }
; 8894 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	edi
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN18@xmlXPathNa:

; 8869 :                          (cur->nodesetval->nodeTab[i]->ns->prefix == NULL)) {
; 8870 : 		    valuePush(ctxt,

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewString

; 8885 : 			ctxt->context, fullname));
; 8886 :                 }
; 8887 :                 break;

	add	esp, 8
	push	eax
	push	esi
	call	_valuePush
	add	esp, 8

; 8892 :         }
; 8893 :     }
; 8894 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	edi
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN21@xmlXPathNa:

; 8888 :             default:
; 8889 : 		valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	push	ecx
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush

; 8890 : 		    cur->nodesetval->nodeTab[i]));
; 8891 :                 xmlXPathLocalNameFunction(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathLocalNameFunction
	add	esp, 24					; 00000018H

; 8892 :         }
; 8893 :     }
; 8894 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	edi
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN12@xmlXPathNa:

; 8858 :         valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewCString
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 8892 :         }
; 8893 :     }
; 8894 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	edi
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
$LN9@xmlXPathNa:

; 8852 :         ((ctxt->value->type != XPATH_NODESET) &&
; 8853 :          (ctxt->value->type != XPATH_XSLT_TREE)))
; 8854 :         XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8895 : }

	pop	ebp
	ret	0
_xmlXPathNameFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathGetElementsByIds
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_ids$ = 12						; size = 4
_xmlXPathGetElementsByIds PROC				; COMDAT

; 8600 : xmlXPathGetElementsByIds (xmlDocPtr doc, const xmlChar *ids) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ids$[ebp]
	mov	esi, edi
	test	edi, edi
	je	SHORT $LN73@xmlXPathGe

; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 3531 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN26@xmlXPathGe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN73@xmlXPathGe:
	pop	edi

; 8643 :     }
; 8644 :     return(ret);
; 8645 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlXPathGe:
	xorps	xmm0, xmm0

; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));

	movq	QWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+8], 0
$LL2@xmlXPathGe:

; 8601 :     xmlNodeSetPtr ret;
; 8602 :     const xmlChar *cur = ids;
; 8603 :     xmlChar *ID;
; 8604 :     xmlAttrPtr attr;
; 8605 :     xmlNodePtr elem = NULL;
; 8606 : 
; 8607 :     if (ids == NULL) return(NULL);
; 8608 : 
; 8609 :     ret = xmlXPathNodeSetCreate(NULL);
; 8610 :     if (ret == NULL)
; 8611 :         return(ret);
; 8612 : 
; 8613 :     while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN12@xmlXPathGe
	cmp	al, 9
	jb	SHORT $LN13@xmlXPathGe
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN12@xmlXPathGe
$LN13@xmlXPathGe:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN52@xmlXPathGe
$LN12@xmlXPathGe:
	inc	esi
	jmp	SHORT $LL2@xmlXPathGe
$LN52@xmlXPathGe:

; 8614 :     while (*cur != 0) {

	test	al, al
	je	$LN94@xmlXPathGe
$LL4@xmlXPathGe:

; 8615 : 	while ((!IS_BLANK_CH(*cur)) && (*cur != 0))

	cmp	al, 32					; 00000020H
	je	SHORT $LN95@xmlXPathGe
$LL6@xmlXPathGe:
	cmp	al, 9
	jb	SHORT $LN14@xmlXPathGe
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN95@xmlXPathGe
$LN14@xmlXPathGe:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN95@xmlXPathGe
	test	al, al
	je	SHORT $LN95@xmlXPathGe
	mov	al, BYTE PTR [esi+1]

; 8616 : 	    cur++;

	inc	esi
	cmp	al, 32					; 00000020H
	jne	SHORT $LL6@xmlXPathGe
$LN95@xmlXPathGe:

; 8617 : 
; 8618 :         ID = xmlStrndup(ids, cur - ids);

	mov	eax, esi
	sub	eax, edi
	push	eax
	push	edi
	call	_xmlStrndup
	mov	edi, eax
	add	esp, 8

; 8619 : 	if (ID != NULL) {

	test	edi, edi
	je	SHORT $LL8@xmlXPathGe

; 8620 : 	    /*
; 8621 : 	     * We used to check the fact that the value passed
; 8622 : 	     * was an NCName, but this generated much troubles for
; 8623 : 	     * me and Aleksey Sanin, people blatantly violated that
; 8624 : 	     * constaint, like Visa3D spec.
; 8625 : 	     * if (xmlValidateNCName(ID, 1) == 0)
; 8626 : 	     */
; 8627 : 	    attr = xmlGetID(doc, ID);

	push	edi
	push	DWORD PTR _doc$[ebp]
	call	_xmlGetID
	add	esp, 8

; 8628 : 	    if (attr != NULL) {

	test	eax, eax
	je	SHORT $LN21@xmlXPathGe

; 8629 : 		if (attr->type == XML_ATTRIBUTE_NODE)

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	jne	SHORT $LN17@xmlXPathGe

; 8630 : 		    elem = attr->parent;

	mov	eax, DWORD PTR [eax+20]
	jmp	SHORT $LN20@xmlXPathGe
$LN17@xmlXPathGe:

; 8631 : 		else if (attr->type == XML_ELEMENT_NODE)

	cmp	ecx, 1
	jne	SHORT $LN21@xmlXPathGe
$LN20@xmlXPathGe:

; 8632 : 		    elem = (xmlNodePtr) attr;
; 8633 : 		else
; 8634 : 		    elem = NULL;
; 8635 : 		if (elem != NULL)

	test	eax, eax
	je	SHORT $LN21@xmlXPathGe

; 8636 : 		    xmlXPathNodeSetAdd(ret, elem);

	push	eax
	push	ebx
	call	_xmlXPathNodeSetAdd
	add	esp, 8
$LN21@xmlXPathGe:

; 8637 : 	    }
; 8638 : 	    xmlFree(ID);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	npad	2
$LL8@xmlXPathGe:

; 8639 : 	}
; 8640 : 
; 8641 : 	while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN22@xmlXPathGe
	cmp	al, 9
	jb	SHORT $LN23@xmlXPathGe
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN22@xmlXPathGe
$LN23@xmlXPathGe:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN9@xmlXPathGe
$LN22@xmlXPathGe:
	inc	esi
	jmp	SHORT $LL8@xmlXPathGe
$LN9@xmlXPathGe:

; 8642 : 	ids = cur;

	mov	edi, esi
	test	al, al
	jne	$LL4@xmlXPathGe
$LN94@xmlXPathGe:
	pop	edi

; 8643 :     }
; 8644 :     return(ret);
; 8645 : }

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathGetElementsByIds ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextPrecedingInternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextPrecedingInternal PROC			; COMDAT

; 8351 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	$LN7@xmlXPathNe

; 8352 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	esi, DWORD PTR [edx+12]
	test	esi, esi
	je	$LN7@xmlXPathNe

; 8353 :     if (cur == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN33@xmlXPathNe

; 8354 :         cur = ctxt->context->node;

	mov	eax, DWORD PTR [esi+4]

; 8355 :         if (cur == NULL)

	test	eax, eax
	je	SHORT $LN7@xmlXPathNe

; 8356 :             return (NULL);
; 8357 :         if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	jne	SHORT $LN10@xmlXPathNe

; 8358 :             cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	jmp	SHORT $LN12@xmlXPathNe
$LN10@xmlXPathNe:

; 8359 :         } else if (cur->type == XML_NAMESPACE_DECL) {

	cmp	ecx, 18					; 00000012H
	jne	SHORT $LN12@xmlXPathNe

; 8360 :             xmlNsPtr ns = (xmlNsPtr) cur;
; 8361 : 
; 8362 :             if ((ns->next == NULL) ||

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN7@xmlXPathNe
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN7@xmlXPathNe
$LN12@xmlXPathNe:

; 8363 :                 (ns->next->type == XML_NAMESPACE_DECL))
; 8364 :                 return (NULL);
; 8365 :             cur = (xmlNodePtr) ns->next;
; 8366 :         }
; 8367 :         ctxt->ancestor = cur->parent;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+40], ecx
$LN33@xmlXPathNe:

; 8368 :     }
; 8369 :     if (cur->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN7@xmlXPathNe

; 8370 :         return(NULL);
; 8371 :     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN21@xmlXPathNe
	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	cmove	eax, ecx
$LN21@xmlXPathNe:

; 8372 : 	cur = cur->prev;
; 8373 :     while (cur->prev == NULL) {

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN3@xmlXPathNe
	npad	1
$LL2@xmlXPathNe:

; 8374 :         cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 8375 :         if (cur == NULL)

	test	eax, eax
	je	SHORT $LN7@xmlXPathNe

; 8376 :             return (NULL);
; 8377 :         if (cur == ctxt->context->doc->children)

	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx+12]
	je	SHORT $LN7@xmlXPathNe

; 8378 :             return (NULL);
; 8379 :         if (cur != ctxt->ancestor)

	cmp	eax, DWORD PTR [edx+40]
	jne	SHORT $LN1@xmlXPathNe

; 8380 :             return (cur);
; 8381 :         ctxt->ancestor = cur->parent;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+40], ecx
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LL2@xmlXPathNe
$LN3@xmlXPathNe:

; 8382 :     }
; 8383 :     cur = cur->prev;

	mov	ecx, DWORD PTR [eax+28]

; 8384 :     while (cur->last != NULL)

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN5@xmlXPathNe
	npad	7
$LL4@xmlXPathNe:

; 8385 :         cur = cur->last;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	jne	SHORT $LL4@xmlXPathNe
$LN5@xmlXPathNe:

; 8386 :     return (cur);

	mov	eax, ecx
	pop	esi

; 8387 : }

	pop	ebp
	ret	0
$LN7@xmlXPathNe:

; 8352 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:
	pop	esi

; 8387 : }

	pop	ebp
	ret	0
_xmlXPathNextPrecedingInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsAncestor
_TEXT	SEGMENT
_ancestor$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXPathIsAncestor PROC				; COMDAT

; 8265 : xmlXPathIsAncestor(xmlNodePtr ancestor, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ancestor$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathIs

; 8266 :     if ((ancestor == NULL) || (node == NULL)) return(0);

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathIs

; 8267 :     if (node->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN5@xmlXPathIs

; 8268 :         return(0);
; 8269 :     if (ancestor->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN5@xmlXPathIs

; 8270 :         return(0);
; 8271 :     /* nodes need to be in the same document */
; 8272 :     if (ancestor->doc != node->doc) return(0);

	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [eax+32]
	jne	SHORT $LN5@xmlXPathIs

; 8273 :     /* avoid searching if ancestor or node is the root node */
; 8274 :     if (ancestor == (xmlNodePtr) node->doc) return(1);

	cmp	ecx, DWORD PTR [eax+32]
	je	SHORT $LN14@xmlXPathIs

; 8275 :     if (node == (xmlNodePtr) ancestor->doc) return(0);

	cmp	eax, edx
	je	SHORT $LN5@xmlXPathIs

; 8276 :     while (node->parent != NULL) {

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN5@xmlXPathIs
	npad	1
$LL2@xmlXPathIs:

; 8277 :         if (node->parent == ancestor)

	cmp	eax, ecx
	je	SHORT $LN14@xmlXPathIs

; 8276 :     while (node->parent != NULL) {

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL2@xmlXPathIs
$LN5@xmlXPathIs:

; 8266 :     if ((ancestor == NULL) || (node == NULL)) return(0);

	xor	eax, eax

; 8279 : 	node = node->parent;
; 8280 :     }
; 8281 :     return(0);
; 8282 : }

	pop	ebp
	ret	0
$LN14@xmlXPathIs:

; 8278 :             return(1);

	mov	eax, 1

; 8279 : 	node = node->parent;
; 8280 :     }
; 8281 :     return(0);
; 8282 : }

	pop	ebp
	ret	0
_xmlXPathIsAncestor ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextChildElement
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextChildElement PROC				; COMDAT

; 7709 : xmlXPathNextChildElement(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	$LN13@xmlXPathNe

; 7710 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	$LN13@xmlXPathNe

; 7711 :     if (cur == NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	jne	SHORT $LN14@xmlXPathNe

; 7712 : 	cur = ctxt->context->node;

	mov	ecx, DWORD PTR [eax+4]

; 7713 : 	if (cur == NULL) return(NULL);

	test	ecx, ecx
	je	SHORT $LN13@xmlXPathNe

; 7714 : 	/*
; 7715 : 	* Get the first element child.
; 7716 : 	*/
; 7717 : 	switch (cur->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN13@xmlXPathNe
	movzx	eax, BYTE PTR $LN42@xmlXPathNe[eax]
	jmp	DWORD PTR $LN51@xmlXPathNe[eax*4]
$LN16@xmlXPathNe:

; 7718 :             case XML_ELEMENT_NODE:
; 7719 : 	    case XML_DOCUMENT_FRAG_NODE:
; 7720 : 	    case XML_ENTITY_REF_NODE: /* URGENT TODO: entify-refs as well? */
; 7721 :             case XML_ENTITY_NODE:
; 7722 : 		cur = cur->children;

	mov	eax, DWORD PTR [ecx+12]

; 7723 : 		if (cur != NULL) {

	test	eax, eax
	je	SHORT $LN13@xmlXPathNe

; 7724 : 		    if (cur->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlXPathNe
$LL6@xmlXPathNe:

; 7725 : 			return(cur);
; 7726 : 		    do {
; 7727 : 			cur = cur->next;

	mov	eax, DWORD PTR [eax+24]

; 7728 : 		    } while ((cur != NULL) &&

	test	eax, eax
	je	SHORT $LN1@xmlXPathNe
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LL6@xmlXPathNe

; 7768 : 	return(cur);
; 7769 :     }
; 7770 :     return(NULL);
; 7771 : }

	pop	ebp
	ret	0
$LN20@xmlXPathNe:

; 7729 : 			(cur->type != XML_ELEMENT_NODE));
; 7730 : 		    return(cur);
; 7731 : 		}
; 7732 : 		return(NULL);
; 7733 :             case XML_DOCUMENT_NODE:
; 7734 :             case XML_HTML_DOCUMENT_NODE:
; 7735 : #ifdef LIBXML_DOCB_ENABLED
; 7736 : 	    case XML_DOCB_DOCUMENT_NODE:
; 7737 : #endif
; 7738 : 		return(xmlDocGetRootElement((xmlDocPtr) cur));

	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4

; 7768 : 	return(cur);
; 7769 :     }
; 7770 :     return(NULL);
; 7771 : }

	pop	ebp
	ret	0
$LN14@xmlXPathNe:

; 7739 : 	    default:
; 7740 : 		return(NULL);
; 7741 : 	}
; 7742 : 	return(NULL);
; 7743 :     }
; 7744 :     /*
; 7745 :     * Get the next sibling element node.
; 7746 :     */
; 7747 :     switch (cur->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN13@xmlXPathNe
	movzx	eax, BYTE PTR $LN43@xmlXPathNe[eax]
	jmp	DWORD PTR $LN52@xmlXPathNe[eax*4]
$LN22@xmlXPathNe:

; 7748 : 	case XML_ELEMENT_NODE:
; 7749 : 	case XML_TEXT_NODE:
; 7750 : 	case XML_ENTITY_REF_NODE:
; 7751 : 	case XML_ENTITY_NODE:
; 7752 : 	case XML_CDATA_SECTION_NODE:
; 7753 : 	case XML_PI_NODE:
; 7754 : 	case XML_COMMENT_NODE:
; 7755 : 	case XML_XINCLUDE_END:
; 7756 : 	    break;
; 7757 : 	/* case XML_DTD_NODE: */ /* URGENT TODO: DTD-node as well? */
; 7758 : 	default:
; 7759 : 	    return(NULL);
; 7760 :     }
; 7761 :     if (cur->next != NULL) {

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN13@xmlXPathNe

; 7762 : 	if (cur->next->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN1@xmlXPathNe
$LL11@xmlXPathNe:

; 7763 : 	    return(cur->next);
; 7764 : 	cur = cur->next;
; 7765 : 	do {
; 7766 : 	    cur = cur->next;

	mov	eax, DWORD PTR [eax+24]

; 7767 : 	} while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));

	test	eax, eax
	je	SHORT $LN1@xmlXPathNe
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LL11@xmlXPathNe

; 7768 : 	return(cur);
; 7769 :     }
; 7770 :     return(NULL);
; 7771 : }

	pop	ebp
	ret	0
$LN13@xmlXPathNe:

; 7710 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:

; 7768 : 	return(cur);
; 7769 :     }
; 7770 :     return(NULL);
; 7771 : }

	pop	ebp
	ret	0
	npad	2
$LN51@xmlXPathNe:
	DD	$LN16@xmlXPathNe
	DD	$LN20@xmlXPathNe
	DD	$LN13@xmlXPathNe
$LN42@xmlXPathNe:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	2
	DB	2
	DB	1
	DB	2
	DB	0
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	npad	3
$LN52@xmlXPathNe:
	DD	$LN22@xmlXPathNe
	DD	$LN13@xmlXPathNe
$LN43@xmlXPathNe:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlXPathNextChildElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEqualValuesCommon
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg1$ = 12						; size = 4
_arg2$ = 16						; size = 4
_xmlXPathEqualValuesCommon PROC				; COMDAT

; 6971 :   xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _arg1$[ebp]
	xor	ebx, ebx
	mov	eax, DWORD PTR [eax]
	add	eax, -2					; fffffffeH
	cmp	eax, 6
	ja	$LN83@xmlXPathEq

; 6972 :     int ret = 0;
; 6973 :     /*
; 6974 :      *At this point we are assured neither arg1 nor arg2
; 6975 :      *is a nodeset, so we can just pick the appropriate routine.
; 6976 :      */
; 6977 :     switch (arg1->type) {

	jmp	DWORD PTR $LN97@xmlXPathEq[eax*4]
$LN11@xmlXPathEq:

; 6978 :         case XPATH_UNDEFINED:
; 6979 : #ifdef DEBUG_EXPR
; 6980 : 	    xmlGenericError(xmlGenericErrorContext,
; 6981 : 		    "Equal: undefined\n");
; 6982 : #endif
; 6983 : 	    break;
; 6984 :         case XPATH_BOOLEAN:
; 6985 : 	    switch (arg2->type) {

	mov	edi, DWORD PTR _arg2$[ebp]
	mov	eax, DWORD PTR [edi]
	add	eax, -2					; fffffffeH
	cmp	eax, 6
	ja	$LN89@xmlXPathEq
	jmp	DWORD PTR $LN98@xmlXPathEq[eax*4]
$LN13@xmlXPathEq:

; 6986 : 	        case XPATH_UNDEFINED:
; 6987 : #ifdef DEBUG_EXPR
; 6988 : 		    xmlGenericError(xmlGenericErrorContext,
; 6989 : 			    "Equal: undefined\n");
; 6990 : #endif
; 6991 : 		    break;
; 6992 : 		case XPATH_BOOLEAN:
; 6993 : #ifdef DEBUG_EXPR
; 6994 : 		    xmlGenericError(xmlGenericErrorContext,
; 6995 : 			    "Equal: %d boolean %d \n",
; 6996 : 			    arg1->boolval, arg2->boolval);
; 6997 : #endif
; 6998 : 		    ret = (arg1->boolval == arg2->boolval);

	mov	eax, DWORD PTR _arg1$[ebp]
	xor	ebx, ebx
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [edi+8]
	sete	bl

; 6999 : 		    break;

	jmp	$LN89@xmlXPathEq
$LN14@xmlXPathEq:

; 7000 : 		case XPATH_NUMBER:
; 7001 : 		    ret = (arg1->boolval ==

	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToBoolean
	mov	ecx, DWORD PTR _arg1$[ebp]
	xor	ebx, ebx
	add	esp, 8
	cmp	DWORD PTR [ecx+8], eax
	sete	bl

; 7002 : 			   xmlXPathCastNumberToBoolean(arg2->floatval));
; 7003 : 		    break;

	jmp	$LN77@xmlXPathEq
$LN15@xmlXPathEq:

; 7004 : 		case XPATH_STRING:
; 7005 : 		    if ((arg2->stringval == NULL) ||

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN18@xmlXPathEq
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN18@xmlXPathEq

; 7006 : 			(arg2->stringval[0] == 0)) ret = 0;
; 7007 : 		    else
; 7008 : 			ret = 1;
; 7009 : 		    ret = (arg1->boolval == ret);

	mov	ecx, DWORD PTR _arg1$[ebp]
	mov	eax, 1
	xor	ebx, ebx
	cmp	DWORD PTR [ecx+8], eax
	sete	bl

; 7010 : 		    break;

	jmp	$LN77@xmlXPathEq
$LN18@xmlXPathEq:

; 7006 : 			(arg2->stringval[0] == 0)) ret = 0;
; 7007 : 		    else
; 7008 : 			ret = 1;
; 7009 : 		    ret = (arg1->boolval == ret);

	mov	ecx, DWORD PTR _arg1$[ebp]
	xor	eax, eax
	xor	ebx, ebx
	cmp	DWORD PTR [ecx+8], eax
	sete	bl

; 7010 : 		    break;

	jmp	$LN77@xmlXPathEq
$LN19@xmlXPathEq:

; 7011 : 		case XPATH_USERS:
; 7012 : 		case XPATH_POINT:
; 7013 : 		case XPATH_RANGE:
; 7014 : 		case XPATH_LOCATIONSET:
; 7015 : 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7015					; 00001b67H
$LN90@xmlXPathEq:

; 7145 : 	    break;
; 7146 : 	case XPATH_NODESET:
; 7147 : 	case XPATH_XSLT_TREE:
; 7148 : 	    break;
; 7149 :     }
; 7150 :     xmlXPathReleaseObject(ctxt->context, arg1);

	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	jmp	$LN89@xmlXPathEq
$LN21@xmlXPathEq:

; 7016 : 		    break;
; 7017 : 		case XPATH_NODESET:
; 7018 : 		case XPATH_XSLT_TREE:
; 7019 : 		    break;
; 7020 : 	    }
; 7021 : 	    break;
; 7022 :         case XPATH_NUMBER:
; 7023 : 	    switch (arg2->type) {

	mov	edi, DWORD PTR _arg2$[ebp]
	mov	eax, DWORD PTR [edi]
	add	eax, -2					; fffffffeH
	cmp	eax, 6
	ja	$LN89@xmlXPathEq
	jmp	DWORD PTR $LN99@xmlXPathEq[eax*4]
$LN23@xmlXPathEq:

; 7024 : 	        case XPATH_UNDEFINED:
; 7025 : #ifdef DEBUG_EXPR
; 7026 : 		    xmlGenericError(xmlGenericErrorContext,
; 7027 : 			    "Equal: undefined\n");
; 7028 : #endif
; 7029 : 		    break;
; 7030 : 		case XPATH_BOOLEAN:
; 7031 : 		    ret = (arg2->boolval==

	mov	eax, DWORD PTR _arg1$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToBoolean
	xor	ebx, ebx
	add	esp, 8
	cmp	DWORD PTR [edi+8], eax
	sete	bl

; 7032 : 			   xmlXPathCastNumberToBoolean(arg1->floatval));
; 7033 : 		    break;

	jmp	$LN89@xmlXPathEq
$LN24@xmlXPathEq:

; 7034 : 		case XPATH_STRING:
; 7035 : 		    valuePush(ctxt, arg2);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi
	push	ebx
	call	_valuePush

; 7036 : 		    xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathNumberFunction

; 7037 : 		    arg2 = valuePop(ctxt);

	push	ebx
	call	_valuePop
	add	esp, 20					; 00000014H
	mov	edi, eax
$LN25@xmlXPathEq:

; 7038 :                     /* Falls through. */
; 7039 : 		case XPATH_NUMBER:
; 7040 : 		    /* Hand check NaN and Infinity equalities */
; 7041 : 		    if (xmlXPathIsNaN(arg1->floatval) ||

	mov	ebx, DWORD PTR _arg1$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ebx+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlXPathEq
	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlXPathEq

; 7042 : 			    xmlXPathIsNaN(arg2->floatval)) {
; 7043 : 		        ret = 0;
; 7044 : 		    } else if (xmlXPathIsInf(arg1->floatval) == 1) {

	movsd	xmm0, QWORD PTR [ebx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	sub	esp, 8
	cmp	eax, 1
	jne	SHORT $LN29@xmlXPathEq
$LN91@xmlXPathEq:

; 7145 : 	    break;
; 7146 : 	case XPATH_NODESET:
; 7147 : 	case XPATH_XSLT_TREE:
; 7148 : 	    break;
; 7149 :     }
; 7150 :     xmlXPathReleaseObject(ctxt->context, arg1);

	movsd	xmm0, QWORD PTR [edi+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	lea	ebx, DWORD PTR [eax-1]
	neg	ebx
	sbb	ebx, ebx
	inc	ebx
	jmp	$LN89@xmlXPathEq
$LN29@xmlXPathEq:

; 7045 : 		        if (xmlXPathIsInf(arg2->floatval) == 1)
; 7046 : 			    ret = 1;
; 7047 : 			else
; 7048 : 			    ret = 0;
; 7049 : 		    } else if (xmlXPathIsInf(arg1->floatval) == -1) {

	movsd	xmm0, QWORD PTR [ebx+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	movsd	xmm0, QWORD PTR [edi+16]
	mov	esi, eax
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	cmp	esi, -1
	je	SHORT $LN92@xmlXPathEq

; 7050 : 			if (xmlXPathIsInf(arg2->floatval) == -1)
; 7051 : 			    ret = 1;
; 7052 : 			else
; 7053 : 			    ret = 0;
; 7054 : 		    } else if (xmlXPathIsInf(arg2->floatval) == 1) {

	sub	esp, 8
	cmp	eax, 1
	jne	SHORT $LN37@xmlXPathEq
$LN93@xmlXPathEq:

; 7145 : 	    break;
; 7146 : 	case XPATH_NODESET:
; 7147 : 	case XPATH_XSLT_TREE:
; 7148 : 	    break;
; 7149 :     }
; 7150 :     xmlXPathReleaseObject(ctxt->context, arg1);

	movsd	xmm0, QWORD PTR [ebx+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	lea	ebx, DWORD PTR [eax-1]
	neg	ebx
	sbb	ebx, ebx
	inc	ebx
	jmp	$LN89@xmlXPathEq
$LN37@xmlXPathEq:
	movsd	xmm0, QWORD PTR [edi+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	movsd	xmm0, QWORD PTR [ebx+16]
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN41@xmlXPathEq
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
$LN92@xmlXPathEq:
	xor	ebx, ebx
	cmp	eax, -1
	sete	bl
	jmp	$LN89@xmlXPathEq
$LN41@xmlXPathEq:
	ucomisd	xmm0, QWORD PTR [edi+16]
	mov	ecx, DWORD PTR _arg1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN79@xmlXPathEq
	mov	ebx, 1
	jmp	$LN77@xmlXPathEq
$LN79@xmlXPathEq:
	xor	ebx, ebx
	jmp	$LN77@xmlXPathEq
$LN28@xmlXPathEq:
	xor	ebx, ebx
	jmp	$LN89@xmlXPathEq
$LN45@xmlXPathEq:

; 7055 : 			if (xmlXPathIsInf(arg1->floatval) == 1)
; 7056 : 			    ret = 1;
; 7057 : 			else
; 7058 : 			    ret = 0;
; 7059 : 		    } else if (xmlXPathIsInf(arg2->floatval) == -1) {
; 7060 : 			if (xmlXPathIsInf(arg1->floatval) == -1)
; 7061 : 			    ret = 1;
; 7062 : 			else
; 7063 : 			    ret = 0;
; 7064 : 		    } else {
; 7065 : 		        ret = (arg1->floatval == arg2->floatval);
; 7066 : 		    }
; 7067 : 		    break;
; 7068 : 		case XPATH_USERS:
; 7069 : 		case XPATH_POINT:
; 7070 : 		case XPATH_RANGE:
; 7071 : 		case XPATH_LOCATIONSET:
; 7072 : 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7072					; 00001ba0H

; 7073 : 		    break;
; 7074 : 		case XPATH_NODESET:
; 7075 : 		case XPATH_XSLT_TREE:
; 7076 : 		    break;
; 7077 : 	    }
; 7078 : 	    break;

	jmp	$LN90@xmlXPathEq
$LN47@xmlXPathEq:

; 7079 :         case XPATH_STRING:
; 7080 : 	    switch (arg2->type) {

	mov	edi, DWORD PTR _arg2$[ebp]
	mov	eax, DWORD PTR [edi]
	add	eax, -2					; fffffffeH
	cmp	eax, 6
	ja	$LN89@xmlXPathEq
	jmp	DWORD PTR $LN100@xmlXPathEq[eax*4]
$LN49@xmlXPathEq:

; 7081 : 	        case XPATH_UNDEFINED:
; 7082 : #ifdef DEBUG_EXPR
; 7083 : 		    xmlGenericError(xmlGenericErrorContext,
; 7084 : 			    "Equal: undefined\n");
; 7085 : #endif
; 7086 : 		    break;
; 7087 : 		case XPATH_BOOLEAN:
; 7088 : 		    if ((arg1->stringval == NULL) ||

	mov	ecx, DWORD PTR _arg1$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN52@xmlXPathEq
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN52@xmlXPathEq

; 7090 : 		    else
; 7091 : 			ret = 1;

	mov	eax, 1

; 7092 : 		    ret = (arg2->boolval == ret);

	xor	ebx, ebx
	cmp	DWORD PTR [edi+8], eax
	sete	bl

; 7093 : 		    break;

	jmp	$LN77@xmlXPathEq
$LN52@xmlXPathEq:

; 7089 : 			(arg1->stringval[0] == 0)) ret = 0;

	xor	eax, eax

; 7092 : 		    ret = (arg2->boolval == ret);

	xor	ebx, ebx
	cmp	DWORD PTR [edi+8], eax
	sete	bl

; 7093 : 		    break;

	jmp	$LN77@xmlXPathEq
$LN53@xmlXPathEq:

; 7094 : 		case XPATH_STRING:
; 7095 : 		    ret = xmlStrEqual(arg1->stringval, arg2->stringval);

	mov	eax, DWORD PTR _arg1$[ebp]
	push	DWORD PTR [edi+24]
	push	DWORD PTR [eax+24]
	call	_xmlStrEqual
	add	esp, 8
	mov	ebx, eax

; 7096 : 		    break;

	jmp	$LN89@xmlXPathEq
$LN54@xmlXPathEq:

; 7097 : 		case XPATH_NUMBER:
; 7098 : 		    valuePush(ctxt, arg1);

	push	DWORD PTR _arg1$[ebp]
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	ebx
	call	_valuePush

; 7099 : 		    xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathNumberFunction

; 7100 : 		    arg1 = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	ebx, eax

; 7101 : 		    /* Hand check NaN and Infinity equalities */
; 7102 : 		    if (xmlXPathIsNaN(arg1->floatval) ||

	add	esp, 12					; 0000000cH
	mov	DWORD PTR _arg1$[ebp], ebx
	movsd	xmm0, QWORD PTR [ebx+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlXPathEq
	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN28@xmlXPathEq

; 7103 : 			    xmlXPathIsNaN(arg2->floatval)) {
; 7104 : 		        ret = 0;
; 7105 : 		    } else if (xmlXPathIsInf(arg1->floatval) == 1) {

	movsd	xmm0, QWORD PTR [ebx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	sub	esp, 8
	cmp	eax, 1
	je	$LN91@xmlXPathEq

; 7106 : 			if (xmlXPathIsInf(arg2->floatval) == 1)
; 7107 : 			    ret = 1;
; 7108 : 			else
; 7109 : 			    ret = 0;
; 7110 : 		    } else if (xmlXPathIsInf(arg1->floatval) == -1) {

	movsd	xmm0, QWORD PTR [ebx+16]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	movsd	xmm0, QWORD PTR [edi+16]
	mov	esi, eax
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	cmp	esi, -1
	je	$LN92@xmlXPathEq

; 7111 : 			if (xmlXPathIsInf(arg2->floatval) == -1)
; 7112 : 			    ret = 1;
; 7113 : 			else
; 7114 : 			    ret = 0;
; 7115 : 		    } else if (xmlXPathIsInf(arg2->floatval) == 1) {

	sub	esp, 8
	cmp	eax, 1
	je	$LN93@xmlXPathEq

; 7116 : 			if (xmlXPathIsInf(arg1->floatval) == 1)
; 7117 : 			    ret = 1;
; 7118 : 			else
; 7119 : 			    ret = 0;
; 7120 : 		    } else if (xmlXPathIsInf(arg2->floatval) == -1) {
; 7121 : 			if (xmlXPathIsInf(arg1->floatval) == -1)
; 7122 : 			    ret = 1;
; 7123 : 			else
; 7124 : 			    ret = 0;
; 7125 : 		    } else {

	jmp	$LN37@xmlXPathEq
$LN74@xmlXPathEq:

; 7126 : 		        ret = (arg1->floatval == arg2->floatval);
; 7127 : 		    }
; 7128 : 		    break;
; 7129 : 		case XPATH_USERS:
; 7130 : 		case XPATH_POINT:
; 7131 : 		case XPATH_RANGE:
; 7132 : 		case XPATH_LOCATIONSET:
; 7133 : 		    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7133					; 00001bddH

; 7134 : 		    break;
; 7135 : 		case XPATH_NODESET:
; 7136 : 		case XPATH_XSLT_TREE:
; 7137 : 		    break;
; 7138 : 	    }
; 7139 : 	    break;

	jmp	$LN90@xmlXPathEq
$LN76@xmlXPathEq:

; 7140 :         case XPATH_USERS:
; 7141 : 	case XPATH_POINT:
; 7142 : 	case XPATH_RANGE:
; 7143 : 	case XPATH_LOCATIONSET:
; 7144 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7144					; 00001be8H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN83@xmlXPathEq:

; 7145 : 	    break;
; 7146 : 	case XPATH_NODESET:
; 7147 : 	case XPATH_XSLT_TREE:
; 7148 : 	    break;
; 7149 :     }
; 7150 :     xmlXPathReleaseObject(ctxt->context, arg1);

	mov	edi, DWORD PTR _arg2$[ebp]
$LN89@xmlXPathEq:
	mov	ecx, DWORD PTR _arg1$[ebp]
$LN77@xmlXPathEq:
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7151 :     xmlXPathReleaseObject(ctxt->context, arg2);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 7152 :     return(ret);

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 7153 : }

	pop	ebp
	ret	0
	npad	3
$LN97@xmlXPathEq:
	DD	$LN11@xmlXPathEq
	DD	$LN21@xmlXPathEq
	DD	$LN47@xmlXPathEq
	DD	$LN76@xmlXPathEq
	DD	$LN76@xmlXPathEq
	DD	$LN76@xmlXPathEq
	DD	$LN76@xmlXPathEq
$LN98@xmlXPathEq:
	DD	$LN13@xmlXPathEq
	DD	$LN14@xmlXPathEq
	DD	$LN15@xmlXPathEq
	DD	$LN19@xmlXPathEq
	DD	$LN19@xmlXPathEq
	DD	$LN19@xmlXPathEq
	DD	$LN19@xmlXPathEq
$LN99@xmlXPathEq:
	DD	$LN23@xmlXPathEq
	DD	$LN25@xmlXPathEq
	DD	$LN24@xmlXPathEq
	DD	$LN45@xmlXPathEq
	DD	$LN45@xmlXPathEq
	DD	$LN45@xmlXPathEq
	DD	$LN45@xmlXPathEq
$LN100@xmlXPathEq:
	DD	$LN49@xmlXPathEq
	DD	$LN54@xmlXPathEq
	DD	$LN53@xmlXPathEq
	DD	$LN74@xmlXPathEq
	DD	$LN74@xmlXPathEq
	DD	$LN74@xmlXPathEq
	DD	$LN74@xmlXPathEq
_xmlXPathEqualValuesCommon ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEqualNodeSets
_TEXT	SEGMENT
_ns2$1$ = -32						; size = 4
_hashs2$1$ = -28					; size = 4
tv828 = -24						; size = 4
_hashs1$1$ = -20					; size = 4
_values2$1$ = -16					; size = 4
_values1$1$ = -12					; size = 4
_ns1$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
$T1 = 8							; size = 4
_i$2$ = 8						; size = 4
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
_neq$ = 16						; size = 4
_xmlXPathEqualNodeSets PROC				; COMDAT

; 6870 : xmlXPathEqualNodeSets(xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2, int neq) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _arg1$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	eax, eax
	je	$LN21@xmlXPathEq

; 6871 :     int i, j;
; 6872 :     unsigned int *hashs1;
; 6873 :     unsigned int *hashs2;
; 6874 :     xmlChar **values1;
; 6875 :     xmlChar **values2;
; 6876 :     int ret = 0;
; 6877 :     xmlNodeSetPtr ns1;
; 6878 :     xmlNodeSetPtr ns2;
; 6879 : 
; 6880 :     if ((arg1 == NULL) ||

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN20@xmlXPathEq
	cmp	ecx, 9
	jne	$LN21@xmlXPathEq
$LN20@xmlXPathEq:

; 6883 :     if ((arg2 == NULL) ||

	mov	ebx, DWORD PTR _arg2$[ebp]
	test	ebx, ebx
	je	$LN21@xmlXPathEq
	mov	ecx, DWORD PTR [ebx]
	cmp	ecx, 1
	je	SHORT $LN22@xmlXPathEq
	cmp	ecx, 9
	jne	$LN21@xmlXPathEq
$LN22@xmlXPathEq:

; 6884 : 	((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE)))
; 6885 :         return(0);
; 6886 : 
; 6887 :     ns1 = arg1->nodesetval;

	mov	esi, DWORD PTR [eax+4]

; 6888 :     ns2 = arg2->nodesetval;

	mov	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR _ns1$1$[ebp], esi
	mov	DWORD PTR _ns2$1$[ebp], ebx

; 6889 : 
; 6890 :     if ((ns1 == NULL) || (ns1->nodeNr <= 0))

	test	esi, esi
	je	$LN21@xmlXPathEq
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	jle	$LN21@xmlXPathEq

; 6891 : 	return(0);
; 6892 :     if ((ns2 == NULL) || (ns2->nodeNr <= 0))

	test	ebx, ebx
	je	$LN21@xmlXPathEq
	mov	edx, DWORD PTR [ebx]
	test	edx, edx
	jle	$LN21@xmlXPathEq

; 6893 : 	return(0);
; 6894 : 
; 6895 :     /*
; 6896 :      * for equal, check if there is a node pertaining to both sets
; 6897 :      */
; 6898 :     if (neq == 0)

	cmp	DWORD PTR _neq$[ebp], 0
	push	edi
	jne	SHORT $LN112@xmlXPathEq

; 6899 : 	for (i = 0;i < ns1->nodeNr;i++)

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN112@xmlXPathEq
	npad	1
$LL4@xmlXPathEq:

; 6900 : 	    for (j = 0;j < ns2->nodeNr;j++)

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN2@xmlXPathEq

; 6901 : 		if (ns1->nodeTab[i] == ns2->nodeTab[j])

	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ebx+8]
	npad	1
$LL7@xmlXPathEq:
	cmp	esi, DWORD PTR [eax]
	je	SHORT $LN87@xmlXPathEq

; 6900 : 	    for (j = 0;j < ns2->nodeNr;j++)

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL7@xmlXPathEq
	mov	eax, DWORD PTR $T1[ebp]
	mov	esi, DWORD PTR _ns1$1$[ebp]
$LN2@xmlXPathEq:

; 6899 : 	for (i = 0;i < ns1->nodeNr;i++)

	inc	edi
	cmp	edi, eax
	jl	SHORT $LL4@xmlXPathEq
$LN112@xmlXPathEq:

; 6903 : 
; 6904 :     values1 = (xmlChar **) xmlMalloc(ns1->nodeNr * sizeof(xmlChar *));

	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _values1$1$[ebp], edi

; 6905 :     if (values1 == NULL) {

	test	edi, edi
	jne	SHORT $LN30@xmlXPathEq

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6921 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@xmlXPathEq:
	pop	edi
	pop	esi

; 6902 : 		    return(1);

	mov	eax, 1

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlXPathEq:

; 6906 :         xmlXPathErrMemory(NULL, "comparing nodesets\n");
; 6907 : 	return(0);
; 6908 :     }
; 6909 :     hashs1 = (unsigned int *) xmlMalloc(ns1->nodeNr * sizeof(unsigned int));

	mov	eax, DWORD PTR [esi]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _hashs1$1$[ebp], eax

; 6910 :     if (hashs1 == NULL) {

	test	eax, eax
	jne	SHORT $LN31@xmlXPathEq

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 6911 :         xmlXPathErrMemory(NULL, "comparing nodesets\n");
; 6912 : 	xmlFree(values1);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 6921 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlXPathEq:

; 6913 : 	return(0);
; 6914 :     }
; 6915 :     memset(values1, 0, ns1->nodeNr * sizeof(xmlChar *));

	mov	eax, DWORD PTR [esi]
	shl	eax, 2
	push	eax
	push	0
	push	edi
	call	_memset

; 6916 :     values2 = (xmlChar **) xmlMalloc(ns2->nodeNr * sizeof(xmlChar *));

	mov	eax, DWORD PTR [ebx]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _values2$1$[ebp], eax

; 6917 :     if (values2 == NULL) {

	test	eax, eax
	jne	SHORT $LN32@xmlXPathEq

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 6918 :         xmlXPathErrMemory(NULL, "comparing nodesets\n");
; 6919 : 	xmlFree(hashs1);

	push	DWORD PTR _hashs1$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 6920 : 	xmlFree(values1);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 6921 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlXPathEq:

; 6922 :     }
; 6923 :     hashs2 = (unsigned int *) xmlMalloc(ns2->nodeNr * sizeof(unsigned int));

	mov	eax, DWORD PTR [ebx]
	shl	eax, 2
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _hashs2$1$[ebp], eax

; 6924 :     if (hashs2 == NULL) {

	test	eax, eax
	jne	SHORT $LN33@xmlXPathEq

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 6925 :         xmlXPathErrMemory(NULL, "comparing nodesets\n");
; 6926 : 	xmlFree(hashs1);

	push	DWORD PTR _hashs1$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 6927 : 	xmlFree(values1);

	push	edi
	call	DWORD PTR _xmlFree

; 6928 : 	xmlFree(values2);

	push	DWORD PTR _values2$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
	xor	eax, eax
	pop	edi
	pop	esi

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlXPathEq:

; 6929 : 	return(0);
; 6930 :     }
; 6931 :     memset(values2, 0, ns2->nodeNr * sizeof(xmlChar *));

	mov	eax, DWORD PTR [ebx]
	shl	eax, 2
	push	eax
	push	0
	push	DWORD PTR _values2$1$[ebp]
	call	_memset

; 6932 :     for (i = 0;i < ns1->nodeNr;i++) {

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	DWORD PTR [esi], ecx
	jle	$LN119@xmlXPathEq
$LL10@xmlXPathEq:

; 6933 : 	hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);

	mov	eax, DWORD PTR _hashs1$1$[ebp]
	lea	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+ecx*4]
	call	_xmlXPathNodeValHash
	mov	DWORD PTR [edi], eax
	add	esp, 4

; 6934 : 	for (j = 0;j < ns2->nodeNr;j++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	$LN111@xmlXPathEq

; 6933 : 	hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);

	mov	eax, DWORD PTR _hashs2$1$[ebp]
	mov	esi, DWORD PTR _values2$1$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv828[ebp], eax
	npad	2
$LL13@xmlXPathEq:

; 6935 : 	    if (i == 0)

	mov	edx, DWORD PTR _i$2$[ebp]
	test	edx, edx
	jne	SHORT $LN116@xmlXPathEq

; 6936 : 		hashs2[j] = xmlXPathNodeValHash(ns2->nodeTab[j]);

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+edi*4]
	call	_xmlXPathNodeValHash
	mov	ecx, DWORD PTR tv828[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _i$2$[ebp]
	mov	DWORD PTR [ecx+esi], eax
	jmp	SHORT $LN34@xmlXPathEq
$LN116@xmlXPathEq:

; 6935 : 	    if (i == 0)

	mov	ecx, DWORD PTR tv828[ebp]
$LN34@xmlXPathEq:

; 6937 : 	    if (hashs1[i] != hashs2[j]) {

	mov	eax, DWORD PTR _hashs1$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	cmp	eax, DWORD PTR [ecx+esi]
	je	SHORT $LN35@xmlXPathEq

; 6938 : 		if (neq) {

	cmp	DWORD PTR _neq$[ebp], 0
	jne	$LN88@xmlXPathEq

; 6940 : 		    break;
; 6941 : 		}
; 6942 : 	    }

	mov	ecx, DWORD PTR _ret$1$[ebp]
	jmp	SHORT $LN11@xmlXPathEq
$LN35@xmlXPathEq:

; 6943 : 	    else {
; 6944 : 		if (values1[i] == NULL)

	mov	eax, DWORD PTR _values1$1$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN38@xmlXPathEq

; 6945 : 		    values1[i] = xmlNodeGetContent(ns1->nodeTab[i]);

	mov	eax, DWORD PTR _ns1$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+edx*4]
	call	_xmlNodeGetContent
	mov	ecx, DWORD PTR _i$2$[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _values1$1$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN38@xmlXPathEq:

; 6946 : 		if (values2[j] == NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN103@xmlXPathEq

; 6947 : 		    values2[j] = xmlNodeGetContent(ns2->nodeTab[j]);

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+edi*4]
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR [esi], eax
$LN103@xmlXPathEq:

; 6948 : 		ret = xmlStrEqual(values1[i], values2[j]) ^ neq;

	mov	ecx, DWORD PTR _values1$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _i$2$[ebp]
	push	DWORD PTR [ecx+eax*4]
	call	_xmlStrEqual
	mov	ecx, eax
	add	esp, 8
	xor	ecx, DWORD PTR _neq$[ebp]
	mov	DWORD PTR _ret$1$[ebp], ecx

; 6949 : 		if (ret)

	jne	SHORT $LN120@xmlXPathEq
$LN11@xmlXPathEq:

; 6934 : 	for (j = 0;j < ns2->nodeNr;j++) {

	inc	edi
	add	esi, 4
	cmp	edi, DWORD PTR [ebx]
	jl	$LL13@xmlXPathEq

; 6950 : 		    break;
; 6951 : 	    }
; 6952 : 	}
; 6953 : 	if (ret)

	test	ecx, ecx
	jne	SHORT $LN120@xmlXPathEq
	mov	esi, DWORD PTR _ns1$1$[ebp]
$LN111@xmlXPathEq:

; 6932 :     for (i = 0;i < ns1->nodeNr;i++) {

	mov	ecx, DWORD PTR _i$2$[ebp]
	inc	ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	ecx, DWORD PTR [esi]
	jl	$LL10@xmlXPathEq
$LN120@xmlXPathEq:

; 6954 : 	    break;
; 6955 :     }
; 6956 :     for (i = 0;i < ns1->nodeNr;i++)

	mov	edi, DWORD PTR _ret$1$[ebp]
$LN90@xmlXPathEq:
	mov	eax, DWORD PTR _ns1$1$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN15@xmlXPathEq
	mov	ebx, DWORD PTR _values1$1$[ebp]
	mov	edi, eax
$LL16@xmlXPathEq:

; 6957 : 	if (values1[i] != NULL)

	mov	eax, DWORD PTR [ebx+esi*4]
	test	eax, eax
	je	SHORT $LN14@xmlXPathEq

; 6958 : 	    xmlFree(values1[i]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlXPathEq:

; 6954 : 	    break;
; 6955 :     }
; 6956 :     for (i = 0;i < ns1->nodeNr;i++)

	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL16@xmlXPathEq
	mov	ebx, DWORD PTR _ns2$1$[ebp]
	mov	edi, DWORD PTR _ret$1$[ebp]
$LN15@xmlXPathEq:

; 6959 :     for (j = 0;j < ns2->nodeNr;j++)

	xor	esi, esi
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN18@xmlXPathEq
	mov	edi, DWORD PTR _values2$1$[ebp]
	npad	6
$LL19@xmlXPathEq:

; 6960 : 	if (values2[j] != NULL)

	mov	eax, DWORD PTR [edi+esi*4]
	test	eax, eax
	je	SHORT $LN17@xmlXPathEq

; 6961 : 	    xmlFree(values2[j]);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlXPathEq:

; 6959 :     for (j = 0;j < ns2->nodeNr;j++)

	inc	esi
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL19@xmlXPathEq
	mov	edi, DWORD PTR _ret$1$[ebp]
$LN18@xmlXPathEq:

; 6962 :     xmlFree(values1);

	push	DWORD PTR _values1$1$[ebp]
	call	DWORD PTR _xmlFree

; 6963 :     xmlFree(values2);

	push	DWORD PTR _values2$1$[ebp]
	call	DWORD PTR _xmlFree

; 6964 :     xmlFree(hashs1);

	push	DWORD PTR _hashs1$1$[ebp]
	call	DWORD PTR _xmlFree

; 6965 :     xmlFree(hashs2);

	push	DWORD PTR _hashs2$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 6966 :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@xmlXPathEq:

; 6939 : 		    ret = 1;

	mov	edi, 1
	mov	DWORD PTR _ret$1$[ebp], edi
	jmp	$LN90@xmlXPathEq
$LN119@xmlXPathEq:

; 6932 :     for (i = 0;i < ns1->nodeNr;i++) {

	xor	edi, edi

; 6954 : 	    break;
; 6955 :     }
; 6956 :     for (i = 0;i < ns1->nodeNr;i++)

	jmp	$LN90@xmlXPathEq
$LN21@xmlXPathEq:
	pop	esi

; 6881 : 	((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)))
; 6882 :         return(0);

	xor	eax, eax

; 6967 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathEqualNodeSets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEqualNodeSetFloat
_TEXT	SEGMENT
_v$1$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_ns$1$ = 12						; size = 4
_arg$ = 12						; size = 4
_f$ = 16						; size = 8
_neq$ = 24						; size = 4
_xmlXPathEqualNodeSetFloat PROC				; COMDAT

; 6810 :     xmlXPathObjectPtr arg, double f, int neq) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _arg$[ebp]
	xor	esi, esi
	test	eax, eax
	je	$LN6@xmlXPathEq

; 6811 :   int i, ret=0;
; 6812 :   xmlNodeSetPtr ns;
; 6813 :   xmlChar *str2;
; 6814 :   xmlXPathObjectPtr val;
; 6815 :   double v;
; 6816 : 
; 6817 :     if ((arg == NULL) ||

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN5@xmlXPathEq
	cmp	ecx, 9
	jne	$LN6@xmlXPathEq
$LN5@xmlXPathEq:

; 6820 : 
; 6821 :     ns = arg->nodesetval;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ns$1$[ebp], eax

; 6822 :     if (ns != NULL) {

	test	eax, eax
	je	$LN29@xmlXPathEq

; 6823 : 	for (i=0;i<ns->nodeNr;i++) {

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [eax], ebx
	jle	$LN30@xmlXPathEq
	push	edi
	npad	8
$LL4@xmlXPathEq:

; 6824 : 	    str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);

	mov	eax, DWORD PTR [eax+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+ebx*4]
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN28@xmlXPathEq

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	edi, eax
	add	esp, 4

; 6825 : 	    if (str2 != NULL) {

	test	edi, edi
	je	$LN2@xmlXPathEq
$LN28@xmlXPathEq:

; 6826 : 		valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, str2));

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	DWORD PTR [eax+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_valuePush

; 6827 : 		xmlFree(str2);

	push	edi
	call	DWORD PTR _xmlFree

; 6828 : 		xmlXPathNumberFunction(ctxt, 1);

	mov	edi, DWORD PTR _ctxt$[ebp]
	push	1
	push	edi
	call	_xmlXPathNumberFunction

; 6829 : 		val = valuePop(ctxt);

	push	edi
	call	_valuePop

; 6830 : 		v = val->floatval;
; 6831 : 		xmlXPathReleaseObject(ctxt->context, val);

	push	eax
	push	DWORD PTR [edi+12]
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR _v$1$[ebp], xmm0
	call	_xmlXPathReleaseObject

; 513  :     return isnan(val);

	movsd	xmm0, QWORD PTR _v$1$[ebp]
	add	esp, 32					; 00000020H
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	add	esp, 8
	cmp	ax, 2

; 6832 : 		if (!xmlXPathIsNaN(v)) {

	je	SHORT $LN9@xmlXPathEq

; 6833 : 		    if ((!neq) && (v==f)) {

	cmp	DWORD PTR _neq$[ebp], 0
	movsd	xmm0, QWORD PTR _v$1$[ebp]
	jne	SHORT $LN27@xmlXPathEq
	ucomisd	xmm0, QWORD PTR _f$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@xmlXPathEq
$LN23@xmlXPathEq:

; 6837 : 			ret = 1;

	mov	esi, 1
	pop	edi
$LN30@xmlXPathEq:
	pop	ebx
$LN29@xmlXPathEq:

; 6842 : 			ret = 1;
; 6843 : 		}
; 6844 : 	    }
; 6845 : 	}
; 6846 :     }
; 6847 : 
; 6848 :     return(ret);

	mov	eax, esi
	pop	esi

; 6849 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXPathEq:

; 6834 : 			ret = 1;
; 6835 : 			break;
; 6836 : 		    } else if ((neq) && (v!=f)) {

	ucomisd	xmm0, QWORD PTR _f$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@xmlXPathEq

; 6838 : 			break;
; 6839 : 		    }
; 6840 : 		} else {	/* NaN is unequal to any value */

	jmp	SHORT $LN2@xmlXPathEq
$LN9@xmlXPathEq:

; 6841 : 		    if (neq)

	cmp	DWORD PTR _neq$[ebp], 0
	mov	eax, 1
	cmovne	esi, eax
$LN2@xmlXPathEq:

; 6823 : 	for (i=0;i<ns->nodeNr;i++) {

	mov	eax, DWORD PTR _ns$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [eax]
	jl	$LL4@xmlXPathEq

; 6842 : 			ret = 1;
; 6843 : 		}
; 6844 : 	    }
; 6845 : 	}
; 6846 :     }
; 6847 : 
; 6848 :     return(ret);

	pop	edi
	pop	ebx
	mov	eax, esi
	pop	esi

; 6849 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathEq:

; 6818 : 	((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))
; 6819 :         return(0);

	xor	eax, eax
	pop	esi

; 6849 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathEqualNodeSetFloat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEqualNodeSetString
_TEXT	SEGMENT
_ns$1$ = -8						; size = 4
_hash$1$ = -4						; size = 4
_arg$ = 8						; size = 4
_str$ = 12						; size = 4
_neq$ = 16						; size = 4
_xmlXPathEqualNodeSetString PROC			; COMDAT

; 6751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _str$[ebp]
	test	ecx, ecx
	je	$LN6@xmlXPathEq

; 6752 :     int i;
; 6753 :     xmlNodeSetPtr ns;
; 6754 :     xmlChar *str2;
; 6755 :     unsigned int hash;
; 6756 : 
; 6757 :     if ((str == NULL) || (arg == NULL) ||

	mov	eax, DWORD PTR _arg$[ebp]
	test	eax, eax
	je	$LN6@xmlXPathEq
	mov	edx, DWORD PTR [eax]
	cmp	edx, 1
	je	SHORT $LN5@xmlXPathEq
	cmp	edx, 9
	jne	$LN6@xmlXPathEq
$LN5@xmlXPathEq:

; 6758 :         ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))
; 6759 :         return (0);
; 6760 :     ns = arg->nodesetval;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _ns$1$[ebp], eax

; 6761 :     /*
; 6762 :      * A NULL nodeset compared with a string is always false
; 6763 :      * (since there is no node equal, and no node not equal)
; 6764 :      */
; 6765 :     if ((ns == NULL) || (ns->nodeNr <= 0) )

	test	eax, eax
	je	SHORT $LN6@xmlXPathEq
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	jle	SHORT $LN6@xmlXPathEq

; 6464 :     if (string[0] == 0)

	mov	bl, BYTE PTR [ecx]
	test	bl, bl
	jne	SHORT $LN24@xmlXPathEq

; 6465 : 	return(0);

	xor	esi, esi
	jmp	SHORT $LN35@xmlXPathEq
$LN24@xmlXPathEq:

; 6466 :     return(((unsigned int) string[0]) +

	movzx	esi, BYTE PTR [ecx+1]
	movzx	eax, bl
	shl	esi, 8
	add	esi, eax
	mov	eax, DWORD PTR _ns$1$[ebp]
$LN35@xmlXPathEq:

; 6766 :         return (0);
; 6767 :     hash = xmlXPathStringHash(str);
; 6768 :     for (i = 0; i < ns->nodeNr; i++) {

	xor	ebx, ebx
	mov	DWORD PTR _hash$1$[ebp], esi
	test	edx, edx
	jle	SHORT $LN6@xmlXPathEq
	mov	edi, DWORD PTR _neq$[ebp]
	npad	2
$LL4@xmlXPathEq:

; 6769 :         if (xmlXPathNodeValHash(ns->nodeTab[i]) == hash) {

	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+ebx*4]
	call	_xmlXPathNodeValHash
	add	esp, 4
	cmp	eax, esi
	jne	SHORT $LN9@xmlXPathEq

; 6770 :             str2 = xmlNodeGetContent(ns->nodeTab[i]);

	mov	eax, DWORD PTR _ns$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+ebx*4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4

; 6771 :             if ((str2 != NULL) && (xmlStrEqual(str, str2))) {

	test	esi, esi
	je	SHORT $LN32@xmlXPathEq
	push	esi
	push	DWORD PTR _str$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlXPathEq

; 6772 :                 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN36@xmlXPathEq:

; 6766 :         return (0);
; 6767 :     hash = xmlXPathStringHash(str);
; 6768 :     for (i = 0; i < ns->nodeNr; i++) {

	test	edi, edi
	je	SHORT $LN28@xmlXPathEq
$LN34@xmlXPathEq:
	mov	esi, DWORD PTR _hash$1$[ebp]
$LN2@xmlXPathEq:
	mov	eax, DWORD PTR _ns$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL4@xmlXPathEq
$LN6@xmlXPathEq:
	pop	edi

; 6788 : 	    return (1);
; 6789 :     }
; 6790 :     return (0);
; 6791 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlXPathEq:

; 6773 : 		if (neq)
; 6774 : 		    continue;
; 6775 :                 return (1);
; 6776 : 	    } else if ((str2 == NULL) && (xmlStrEqual(str, BAD_CAST ""))) {

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR _str$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlXPathEq
$LN14@xmlXPathEq:

; 6777 : 		if (neq)
; 6778 : 		    continue;
; 6779 :                 return (1);
; 6780 :             } else if (neq) {

	test	edi, edi
	jne	SHORT $LN27@xmlXPathEq

; 6783 : 		return (1);
; 6784 : 	    }
; 6785 :             if (str2 != NULL)

	test	esi, esi
	je	SHORT $LN34@xmlXPathEq

; 6786 :                 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 6787 :         } else if (neq)

	jmp	SHORT $LN34@xmlXPathEq
$LN9@xmlXPathEq:
	test	edi, edi
	jne	SHORT $LN28@xmlXPathEq

; 6783 : 		return (1);
; 6784 : 	    }
; 6785 :             if (str2 != NULL)

	jmp	SHORT $LN2@xmlXPathEq
$LN27@xmlXPathEq:

; 6781 : 		if (str2 != NULL)

	test	esi, esi
	je	SHORT $LN28@xmlXPathEq

; 6782 : 		    xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN28@xmlXPathEq:

; 6788 : 	    return (1);
; 6789 :     }
; 6790 :     return (0);
; 6791 : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathEqualNodeSetString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompareNodeSetValue
_TEXT	SEGMENT
_ns$1$ = -8						; size = 4
$T1 = -4						; size = 4
$T2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_inf$ = 12						; size = 4
_strict$ = 16						; size = 4
_arg$ = 20						; size = 4
_val$ = 24						; size = 4
_xmlXPathCompareNodeSetValue PROC			; COMDAT

; 6705 : 	                    xmlXPathObjectPtr arg, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	$LN5@xmlXPathCo

; 6706 :     if ((val == NULL) || (arg == NULL) ||

	mov	edx, DWORD PTR _arg$[ebp]
	test	edx, edx
	je	$LN5@xmlXPathCo
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 1
	je	SHORT $LN4@xmlXPathCo
	cmp	ecx, 9
	jne	$LN5@xmlXPathCo
$LN4@xmlXPathCo:

; 6709 : 
; 6710 :     switch(val->type) {

	mov	eax, DWORD PTR [ebx]
	dec	eax
	push	esi
	push	edi
	cmp	eax, 8
	ja	$LN10@xmlXPathCo
	jmp	DWORD PTR $LN122@xmlXPathCo[eax*4]
$LN6@xmlXPathCo:

; 6495 :     int i, ret = 0;

	xor	edi, edi
	mov	DWORD PTR $T2[ebp], edi

; 6496 :     xmlNodeSetPtr ns;
; 6497 :     xmlChar *str2;
; 6498 : 
; 6499 :     if ((f == NULL) || (arg == NULL) ||

	cmp	ecx, 1
	je	SHORT $LN16@xmlXPathCo
	cmp	ecx, 9
	jne	$LN120@xmlXPathCo
$LN16@xmlXPathCo:

; 6500 : 	((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {
; 6501 : 	xmlXPathReleaseObject(ctxt->context, arg);
; 6502 : 	xmlXPathReleaseObject(ctxt->context, f);
; 6503 :         return(0);
; 6504 :     }
; 6505 :     ns = arg->nodesetval;

	mov	eax, DWORD PTR [edx+4]

; 6506 :     if (ns != NULL) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ns$1$[ebp], eax
	test	eax, eax
	je	$LN101@xmlXPathCo

; 6507 : 	for (i = 0;i < ns->nodeNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	$LN113@xmlXPathCo
	npad	6
$LL15@xmlXPathCo:

; 6508 : 	     str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);

	mov	eax, DWORD PTR [eax+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+edi*4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN109@xmlXPathCo

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 6509 : 	     if (str2 != NULL) {

	test	esi, esi
	je	SHORT $LN13@xmlXPathCo
$LN109@xmlXPathCo:

; 6510 : 		 valuePush(ctxt,

	push	esi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	ebx
	call	_valuePush

; 6511 : 			   xmlXPathCacheNewString(ctxt->context, str2));
; 6512 : 		 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree

; 6513 : 		 xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathNumberFunction

; 6514 : 		 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, f));

	push	DWORD PTR _val$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	ebx
	call	_valuePush

; 6515 : 		 ret = xmlXPathCompareValues(ctxt, inf, strict);

	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	ebx
	call	_xmlXPathCompareValues
	add	esp, 56					; 00000038H
	mov	DWORD PTR $T2[ebp], eax

; 6516 : 		 if (ret)

	test	eax, eax
	jne	SHORT $LN111@xmlXPathCo
$LN13@xmlXPathCo:

; 6507 : 	for (i = 0;i < ns->nodeNr;i++) {

	mov	eax, DWORD PTR _ns$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL15@xmlXPathCo
$LN111@xmlXPathCo:
	mov	edx, DWORD PTR _arg$[ebp]

; 6517 : 		     break;
; 6518 : 	     }
; 6519 : 	}
; 6520 :     }
; 6521 :     xmlXPathReleaseObject(ctxt->context, arg);

	lea	esi, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR $T2[ebp]

; 6711 :         case XPATH_NUMBER:
; 6712 : 	    return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));

	jmp	$LN119@xmlXPathCo
$LN113@xmlXPathCo:

; 6507 : 	for (i = 0;i < ns->nodeNr;i++) {

	xor	edi, edi
$LN101@xmlXPathCo:

; 6517 : 		     break;
; 6518 : 	     }
; 6519 : 	}
; 6520 :     }
; 6521 :     xmlXPathReleaseObject(ctxt->context, arg);

	lea	esi, DWORD PTR [ebx+12]

; 6711 :         case XPATH_NUMBER:
; 6712 : 	    return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));

	jmp	$LN119@xmlXPathCo
$LN7@xmlXPathCo:

; 6713 :         case XPATH_NODESET:
; 6714 :         case XPATH_XSLT_TREE:
; 6715 : 	    return(xmlXPathCompareNodeSets(inf, strict, arg, val));

	push	ebx
	push	edx
	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	call	_xmlXPathCompareNodeSets
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 6731 :     }
; 6732 :     return(0);
; 6733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathCo:

; 6550 :     int i, ret = 0;

	xor	edi, edi
	mov	DWORD PTR $T1[ebp], edi

; 6551 :     xmlNodeSetPtr ns;
; 6552 :     xmlChar *str2;
; 6553 : 
; 6554 :     if ((s == NULL) || (arg == NULL) ||

	cmp	ecx, 1
	je	SHORT $LN29@xmlXPathCo
	cmp	ecx, 9
	je	SHORT $LN29@xmlXPathCo
$LN120@xmlXPathCo:

; 6716 :         case XPATH_STRING:
; 6717 : 	    return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));

	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esi, 12					; 0000000cH
	xor	edi, edi
	jmp	$LN118@xmlXPathCo
$LN29@xmlXPathCo:

; 6560 :     ns = arg->nodesetval;

	mov	ebx, DWORD PTR [edx+4]

; 6561 :     if (ns != NULL) {

	test	ebx, ebx
	je	$LN102@xmlXPathCo

; 6562 : 	for (i = 0;i < ns->nodeNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN114@xmlXPathCo
$LL28@xmlXPathCo:

; 6563 : 	     str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);

	mov	eax, DWORD PTR [ebx+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+edi*4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN110@xmlXPathCo

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 6564 : 	     if (str2 != NULL) {

	test	esi, esi
	je	SHORT $LN26@xmlXPathCo
$LN110@xmlXPathCo:

; 6565 : 		 valuePush(ctxt,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	DWORD PTR [eax+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_valuePush

; 6566 : 			   xmlXPathCacheNewString(ctxt->context, str2));
; 6567 : 		 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree

; 6568 : 		 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, s));

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _val$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	esi
	call	_valuePush

; 6569 : 		 ret = xmlXPathCompareValues(ctxt, inf, strict);

	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	esi
	call	_xmlXPathCompareValues
	add	esp, 48					; 00000030H
	mov	DWORD PTR $T1[ebp], eax

; 6570 : 		 if (ret)

	test	eax, eax
	jne	SHORT $LN112@xmlXPathCo
$LN26@xmlXPathCo:

; 6562 : 	for (i = 0;i < ns->nodeNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL28@xmlXPathCo
$LN112@xmlXPathCo:
	mov	edx, DWORD PTR _arg$[ebp]
	mov	edi, DWORD PTR $T1[ebp]
	jmp	SHORT $LN102@xmlXPathCo
$LN114@xmlXPathCo:
	xor	edi, edi
$LN102@xmlXPathCo:

; 6571 : 		     break;
; 6572 : 	     }
; 6573 : 	}
; 6574 :     }
; 6575 :     xmlXPathReleaseObject(ctxt->context, arg);

	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esi, 12					; 0000000cH
$LN119@xmlXPathCo:
	mov	ebx, DWORD PTR _val$[ebp]
$LN118@xmlXPathCo:

; 6716 :         case XPATH_STRING:
; 6717 : 	    return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));

	mov	ecx, esi
	push	edx
	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	_xmlXPathReleaseObject
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	ecx
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 6731 :     }
; 6732 :     return(0);
; 6733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathCo:

; 6718 :         case XPATH_BOOLEAN:
; 6719 : 	    valuePush(ctxt, arg);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edx
	push	esi
	call	_valuePush

; 6720 : 	    xmlXPathBooleanFunction(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathBooleanFunction

; 6721 : 	    valuePush(ctxt, val);

	push	ebx
	push	esi
	call	_valuePush

; 6722 : 	    return(xmlXPathCompareValues(ctxt, inf, strict));

	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	esi
	call	_xmlXPathCompareValues
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 6731 :     }
; 6732 :     return(0);
; 6733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathCo:

; 6723 : 	default:
; 6724 :             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0EL@MECKCKJO@xmlXPathCompareNodeSetValue?3?5Ca@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax

; 6725 :                     "xmlXPathCompareNodeSetValue: Can't compare node set "
; 6726 :                     "and object of type %d\n",
; 6727 :                     val->type);
; 6728 :             xmlXPathReleaseObject(ctxt->context, arg);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _arg$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 6729 :             xmlXPathReleaseObject(ctxt->context, val);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 6730 :             XP_ERROR0(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 36					; 00000024H
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 6731 :     }
; 6732 :     return(0);
; 6733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathCo:

; 6707 : 	((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))
; 6708 :         return(0);

	xor	eax, eax
	pop	ebx

; 6731 :     }
; 6732 :     return(0);
; 6733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN122@xmlXPathCo:
	DD	$LN7@xmlXPathCo
	DD	$LN9@xmlXPathCo
	DD	$LN6@xmlXPathCo
	DD	$LN8@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN7@xmlXPathCo
_xmlXPathCompareNodeSetValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompareNodeSets
_TEXT	SEGMENT
_val1$ = -24						; size = 8
_ns1$1$ = -16						; size = 4
_i$1$ = -12						; size = 4
_init$1$ = -8						; size = 4
_ns2$1$ = -4						; size = 4
_inf$ = 8						; size = 4
_strict$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_xmlXPathCompareNodeSets PROC				; COMDAT

; 6610 : 	                xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _arg1$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _init$1$[ebp], 0
	test	ecx, ecx
	je	$LN9@xmlXPathCo

; 6611 :     int i, j, init = 0;
; 6612 :     double val1;
; 6613 :     double *values2;
; 6614 :     int ret = 0;
; 6615 :     xmlNodeSetPtr ns1;
; 6616 :     xmlNodeSetPtr ns2;
; 6617 : 
; 6618 :     if ((arg1 == NULL) ||

	mov	eax, DWORD PTR [ecx]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPathCo
	cmp	eax, 9
	jne	$LN9@xmlXPathCo
$LN8@xmlXPathCo:
	push	esi
	push	edi

; 6622 :     }
; 6623 :     if ((arg2 == NULL) ||

	mov	edi, DWORD PTR _arg2$[ebp]
	test	edi, edi
	je	$LN11@xmlXPathCo
	mov	eax, DWORD PTR [edi]
	cmp	eax, 1
	je	SHORT $LN10@xmlXPathCo
	cmp	eax, 9
	jne	$LN11@xmlXPathCo
$LN10@xmlXPathCo:

; 6627 :         return(0);
; 6628 :     }
; 6629 : 
; 6630 :     ns1 = arg1->nodesetval;

	mov	esi, DWORD PTR [ecx+4]

; 6631 :     ns2 = arg2->nodesetval;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _ns1$1$[ebp], esi
	mov	DWORD PTR _ns2$1$[ebp], eax

; 6632 : 
; 6633 :     if ((ns1 == NULL) || (ns1->nodeNr <= 0)) {

	test	esi, esi
	je	$LN11@xmlXPathCo
	cmp	DWORD PTR [esi], ebx
	jle	$LN11@xmlXPathCo

; 6634 : 	xmlXPathFreeObject(arg1);
; 6635 : 	xmlXPathFreeObject(arg2);
; 6636 : 	return(0);
; 6637 :     }
; 6638 :     if ((ns2 == NULL) || (ns2->nodeNr <= 0)) {

	test	eax, eax
	je	$LN11@xmlXPathCo
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jle	$LN11@xmlXPathCo

; 6639 : 	xmlXPathFreeObject(arg1);
; 6640 : 	xmlXPathFreeObject(arg2);
; 6641 : 	return(0);
; 6642 :     }
; 6643 : 
; 6644 :     values2 = (double *) xmlMalloc(ns2->nodeNr * sizeof(double));

	shl	eax, 3
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 6645 :     if (values2 == NULL) {

	test	edi, edi
	jne	SHORT $LN16@xmlXPathCo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BE@EIMBPOMM@comparing?5nodesets?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 6646 :         xmlXPathErrMemory(NULL, "comparing nodesets\n");
; 6647 : 	xmlXPathFreeObject(arg1);

	push	DWORD PTR _arg1$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 72					; 00000048H

; 6648 : 	xmlXPathFreeObject(arg2);

	push	DWORD PTR _arg2$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4

; 6649 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 6680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXPathCo:

; 6650 :     }
; 6651 :     for (i = 0;i < ns1->nodeNr;i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [esi], ecx
	jle	$LN54@xmlXPathCo
$LL4@xmlXPathCo:

; 6652 : 	val1 = xmlXPathCastNodeToNumber(ns1->nodeTab[i]);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+ecx*4]
	call	_xmlXPathCastNodeToNumber
	fstp	QWORD PTR _val1$[ebp]

; 6653 : 	if (xmlXPathIsNaN(val1))

	movsd	xmm0, QWORD PTR _val1$[ebp]
	push	ecx
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN2@xmlXPathCo

; 6654 : 	    continue;
; 6655 : 	for (j = 0;j < ns2->nodeNr;j++) {

	mov	eax, DWORD PTR _ns2$1$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN50@xmlXPathCo
$LL7@xmlXPathCo:

; 6656 : 	    if (init == 0) {

	cmp	DWORD PTR _init$1$[ebp], 0
	jne	SHORT $LN18@xmlXPathCo

; 6657 : 		values2[j] = xmlXPathCastNodeToNumber(ns2->nodeTab[j]);

	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR [eax+esi*4]
	call	_xmlXPathCastNodeToNumber
	fstp	QWORD PTR [edi+esi*8]
	add	esp, 4
$LN18@xmlXPathCo:

; 6658 : 	    }
; 6659 : 	    if (xmlXPathIsNaN(values2[j]))

	movsd	xmm0, QWORD PTR [edi+esi*8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlXPathCo

; 6660 : 		continue;
; 6661 : 	    if (inf && strict)

	movsd	xmm0, QWORD PTR [edi+esi*8]
	xor	ebx, ebx
	cmp	DWORD PTR _inf$[ebp], ebx
	je	SHORT $LN49@xmlXPathCo
	cmp	DWORD PTR _strict$[ebp], ebx
	je	SHORT $LN20@xmlXPathCo

; 6662 : 		ret = (val1 < values2[j]);

	comisd	xmm0, QWORD PTR _val1$[ebp]
	seta	bl
	jmp	SHORT $LN26@xmlXPathCo
$LN20@xmlXPathCo:

; 6663 : 	    else if (inf && !strict)
; 6664 : 		ret = (val1 <= values2[j]);

	comisd	xmm0, QWORD PTR _val1$[ebp]
	jmp	SHORT $LN57@xmlXPathCo
$LN49@xmlXPathCo:

; 6665 : 	    else if (!inf && strict)

	cmp	DWORD PTR _strict$[ebp], 0
	movsd	xmm1, QWORD PTR _val1$[ebp]
	je	SHORT $LN24@xmlXPathCo

; 6666 : 		ret = (val1 > values2[j]);

	comisd	xmm1, xmm0
	seta	bl
	jmp	SHORT $LN26@xmlXPathCo
$LN24@xmlXPathCo:

; 6667 : 	    else if (!inf && !strict)
; 6668 : 		ret = (val1 >= values2[j]);

	comisd	xmm1, xmm0
$LN57@xmlXPathCo:

; 6669 : 	    if (ret)

	setae	bl
$LN26@xmlXPathCo:
	test	ebx, ebx
	jne	SHORT $LN54@xmlXPathCo
$LN5@xmlXPathCo:

; 6654 : 	    continue;
; 6655 : 	for (j = 0;j < ns2->nodeNr;j++) {

	mov	eax, DWORD PTR _ns2$1$[ebp]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL7@xmlXPathCo

; 6670 : 		break;
; 6671 : 	}
; 6672 : 	if (ret)

	test	ebx, ebx
	jne	SHORT $LN54@xmlXPathCo
$LN50@xmlXPathCo:
	mov	esi, DWORD PTR _ns1$1$[ebp]

; 6673 : 	    break;
; 6674 : 	init = 1;

	mov	DWORD PTR _init$1$[ebp], 1
$LN2@xmlXPathCo:

; 6650 :     }
; 6651 :     for (i = 0;i < ns1->nodeNr;i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [esi]
	jl	$LL4@xmlXPathCo
$LN54@xmlXPathCo:

; 6675 :     }
; 6676 :     xmlFree(values2);

	push	edi
	call	DWORD PTR _xmlFree

; 6677 :     xmlXPathFreeObject(arg1);

	push	DWORD PTR _arg1$[ebp]
	call	_xmlXPathFreeObject

; 6678 :     xmlXPathFreeObject(arg2);

	push	DWORD PTR _arg2$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 12					; 0000000cH

; 6679 :     return(ret);

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 6680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPathCo:

; 6624 : 	((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE))) {
; 6625 : 	xmlXPathFreeObject(arg1);

	push	ecx
	call	_xmlXPathFreeObject

; 6626 : 	xmlXPathFreeObject(arg2);

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 8

; 6649 : 	return(0);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 6680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathCo:

; 6619 : 	((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE))) {
; 6620 : 	xmlXPathFreeObject(arg2);

	push	DWORD PTR _arg2$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4

; 6621 :         return(0);

	xor	eax, eax
	pop	ebx

; 6680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompareNodeSets ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompareNodeSetString
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inf$ = 12						; size = 4
_strict$ = 16						; size = 4
_arg$ = 20						; size = 4
_s$ = 24						; size = 4
_xmlXPathCompareNodeSetString PROC			; COMDAT

; 6549 : 	                    xmlXPathObjectPtr arg, xmlXPathObjectPtr s) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _s$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _ret$1$[ebp], esi
	test	ebx, ebx
	je	$LN6@xmlXPathCo

; 6550 :     int i, ret = 0;
; 6551 :     xmlNodeSetPtr ns;
; 6552 :     xmlChar *str2;
; 6553 : 
; 6554 :     if ((s == NULL) || (arg == NULL) ||

	test	eax, eax
	je	$LN6@xmlXPathCo
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN5@xmlXPathCo
	cmp	ecx, 9
	jne	$LN6@xmlXPathCo
$LN5@xmlXPathCo:

; 6559 :     }
; 6560 :     ns = arg->nodesetval;

	mov	ebx, DWORD PTR [eax+4]

; 6561 :     if (ns != NULL) {

	test	ebx, ebx
	je	$LN89@xmlXPathCo

; 6562 : 	for (i = 0;i < ns->nodeNr;i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [ebx], esi
	jle	$LN97@xmlXPathCo
$LL4@xmlXPathCo:

; 6563 : 	     str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);

	mov	eax, DWORD PTR [ebx+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+edi*4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN93@xmlXPathCo

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 6564 : 	     if (str2 != NULL) {

	test	esi, esi
	je	SHORT $LN96@xmlXPathCo
$LN93@xmlXPathCo:

; 6565 : 		 valuePush(ctxt,

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	DWORD PTR [eax+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_valuePush

; 6566 : 			   xmlXPathCacheNewString(ctxt->context, str2));
; 6567 : 		 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree

; 6568 : 		 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, s));

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _s$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	esi
	call	_valuePush

; 6569 : 		 ret = xmlXPathCompareValues(ctxt, inf, strict);

	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	esi
	call	_xmlXPathCompareValues
	mov	esi, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR _ret$1$[ebp], esi

; 6570 : 		 if (ret)

	test	esi, esi
	jne	SHORT $LN94@xmlXPathCo

; 6564 : 	     if (str2 != NULL) {

	jmp	SHORT $LN2@xmlXPathCo
$LN96@xmlXPathCo:
	mov	esi, DWORD PTR _ret$1$[ebp]
$LN2@xmlXPathCo:

; 6562 : 	for (i = 0;i < ns->nodeNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL4@xmlXPathCo
$LN94@xmlXPathCo:
	mov	eax, DWORD PTR _arg$[ebp]
$LN97@xmlXPathCo:
	pop	edi
$LN89@xmlXPathCo:

; 6571 : 		     break;
; 6572 : 	     }
; 6573 : 	}
; 6574 :     }
; 6575 :     xmlXPathReleaseObject(ctxt->context, arg);

	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 6576 :     xmlXPathReleaseObject(ctxt->context, s);

	push	DWORD PTR _s$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 6577 :     return(ret);

	mov	eax, esi
	pop	esi

; 6578 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathCo:

; 6555 : 	((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {
; 6556 : 	xmlXPathReleaseObject(ctxt->context, arg);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 6557 : 	xmlXPathReleaseObject(ctxt->context, s);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 6558 :         return(0);

	xor	eax, eax
	pop	esi

; 6578 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompareNodeSetString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompareNodeSetFloat
_TEXT	SEGMENT
_ns$1$ = -8						; size = 4
_ret$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inf$ = 12						; size = 4
_strict$ = 16						; size = 4
_arg$ = 20						; size = 4
_f$ = 24						; size = 4
_xmlXPathCompareNodeSetFloat PROC			; COMDAT

; 6494 : 	                    xmlXPathObjectPtr arg, xmlXPathObjectPtr f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _f$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _ret$1$[ebp], esi
	test	ebx, ebx
	je	$LN6@xmlXPathCo

; 6495 :     int i, ret = 0;
; 6496 :     xmlNodeSetPtr ns;
; 6497 :     xmlChar *str2;
; 6498 : 
; 6499 :     if ((f == NULL) || (arg == NULL) ||

	test	eax, eax
	je	$LN6@xmlXPathCo
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN5@xmlXPathCo
	cmp	ecx, 9
	jne	$LN6@xmlXPathCo
$LN5@xmlXPathCo:

; 6504 :     }
; 6505 :     ns = arg->nodesetval;

	mov	eax, DWORD PTR [eax+4]

; 6506 :     if (ns != NULL) {

	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ns$1$[ebp], eax
	test	eax, eax
	je	$LN85@xmlXPathCo

; 6507 : 	for (i = 0;i < ns->nodeNr;i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN88@xmlXPathCo
$LL4@xmlXPathCo:

; 6508 : 	     str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);

	mov	eax, DWORD PTR [eax+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+edi*4]
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN84@xmlXPathCo

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 6509 : 	     if (str2 != NULL) {

	test	esi, esi
	je	SHORT $LN87@xmlXPathCo
$LN84@xmlXPathCo:

; 6510 : 		 valuePush(ctxt,

	push	esi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	ebx
	call	_valuePush

; 6511 : 			   xmlXPathCacheNewString(ctxt->context, str2));
; 6512 : 		 xmlFree(str2);

	push	esi
	call	DWORD PTR _xmlFree

; 6513 : 		 xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	ebx
	call	_xmlXPathNumberFunction

; 6514 : 		 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, f));

	push	DWORD PTR _f$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	ebx
	call	_valuePush

; 6515 : 		 ret = xmlXPathCompareValues(ctxt, inf, strict);

	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	ebx
	call	_xmlXPathCompareValues
	mov	esi, eax
	add	esp, 56					; 00000038H
	mov	DWORD PTR _ret$1$[ebp], esi

; 6516 : 		 if (ret)

	test	esi, esi
	jne	SHORT $LN88@xmlXPathCo

; 6509 : 	     if (str2 != NULL) {

	jmp	SHORT $LN2@xmlXPathCo
$LN87@xmlXPathCo:
	mov	esi, DWORD PTR _ret$1$[ebp]
$LN2@xmlXPathCo:

; 6507 : 	for (i = 0;i < ns->nodeNr;i++) {

	mov	eax, DWORD PTR _ns$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL4@xmlXPathCo
$LN88@xmlXPathCo:
	pop	edi
$LN85@xmlXPathCo:

; 6517 : 		     break;
; 6518 : 	     }
; 6519 : 	}
; 6520 :     }
; 6521 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	DWORD PTR _arg$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 6522 :     xmlXPathReleaseObject(ctxt->context, f);

	push	DWORD PTR _f$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 6523 :     return(ret);

	mov	eax, esi
	pop	esi

; 6524 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathCo:

; 6500 : 	((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {
; 6501 : 	xmlXPathReleaseObject(ctxt->context, arg);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 6502 : 	xmlXPathReleaseObject(ctxt->context, f);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 6503 :         return(0);

	xor	eax, eax
	pop	esi

; 6524 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompareNodeSetFloat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathStringHash
_TEXT	SEGMENT
_string$ = 8						; size = 4
_xmlXPathStringHash PROC				; COMDAT

; 6461 : xmlXPathStringHash(const xmlChar * string) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _string$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathSt

; 6462 :     if (string == NULL)
; 6463 : 	return((unsigned int) 0);
; 6464 :     if (string[0] == 0)

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN5@xmlXPathSt

; 6466 :     return(((unsigned int) string[0]) +

	movzx	eax, BYTE PTR [eax+1]
	shl	eax, 8
	movzx	ecx, cl
	add	eax, ecx

; 6467 : 	   (((unsigned int) string[1]) << 8));
; 6468 : }

	pop	ebp
	ret	0
$LN5@xmlXPathSt:

; 6465 : 	return(0);

	xor	eax, eax

; 6467 : 	   (((unsigned int) string[1]) << 8));
; 6468 : }

	pop	ebp
	ret	0
_xmlXPathStringHash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeValHash
_TEXT	SEGMENT
_len$1$ = -4						; size = 4
_node$ = 8						; size = 4
_xmlXPathNodeValHash PROC				; COMDAT

; 6346 : xmlXPathNodeValHash(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _len$1$[ebp], 2
	test	esi, esi
	je	$LN24@xmlXPathNo

; 6347 :     int len = 2;
; 6348 :     const xmlChar * string = NULL;
; 6349 :     xmlNodePtr tmp = NULL;
; 6350 :     unsigned int ret = 0;
; 6351 : 
; 6352 :     if (node == NULL)
; 6353 : 	return(0);
; 6354 : 
; 6355 :     if (node->type == XML_DOCUMENT_NODE) {

	cmp	DWORD PTR [esi+4], 9
	jne	SHORT $LN15@xmlXPathNo

; 6356 : 	tmp = xmlDocGetRootElement((xmlDocPtr) node);

	push	esi
	call	_xmlDocGetRootElement
	add	esp, 4

; 6357 : 	if (tmp == NULL)

	test	eax, eax
	jne	SHORT $LN13@xmlXPathNo

; 6358 : 	    node = node->children;

	mov	esi, DWORD PTR [esi+12]
	jmp	SHORT $LN14@xmlXPathNo
$LN13@xmlXPathNo:

; 6359 : 	else
; 6360 : 	    node = tmp;

	mov	esi, eax
$LN14@xmlXPathNo:

; 6361 : 
; 6362 : 	if (node == NULL)

	test	esi, esi
	je	$LN24@xmlXPathNo
$LN15@xmlXPathNo:

; 6363 : 	    return(0);
; 6364 :     }
; 6365 : 
; 6366 :     switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	$LN24@xmlXPathNo
	movzx	eax, BYTE PTR $LN59@xmlXPathNo[eax]
	jmp	DWORD PTR $LN70@xmlXPathNo[eax*4]
$LN16@xmlXPathNo:

; 6367 : 	case XML_COMMENT_NODE:
; 6368 : 	case XML_PI_NODE:
; 6369 : 	case XML_CDATA_SECTION_NODE:
; 6370 : 	case XML_TEXT_NODE:
; 6371 : 	    string = node->content;

	mov	eax, DWORD PTR [esi+40]
$LN68@xmlXPathNo:

; 6449 : }

	test	eax, eax
	je	$LN24@xmlXPathNo
	mov	dl, BYTE PTR [eax]
	test	dl, dl
	je	$LN24@xmlXPathNo
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 8
	movzx	eax, dl
	pop	esi
	add	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXPathNo:

; 6372 : 	    if (string == NULL)
; 6373 : 		return(0);
; 6374 : 	    if (string[0] == 0)
; 6375 : 		return(0);
; 6376 : 	    return(((unsigned int) string[0]) +
; 6377 : 		   (((unsigned int) string[1]) << 8));
; 6378 : 	case XML_NAMESPACE_DECL:
; 6379 : 	    string = ((xmlNsPtr)node)->href;

	mov	eax, DWORD PTR [esi+8]

; 6380 : 	    if (string == NULL)
; 6381 : 		return(0);
; 6382 : 	    if (string[0] == 0)
; 6383 : 		return(0);
; 6384 : 	    return(((unsigned int) string[0]) +

	jmp	SHORT $LN68@xmlXPathNo
$LN22@xmlXPathNo:

; 6394 :     }
; 6395 :     while (tmp != NULL) {

	mov	eax, DWORD PTR [esi+12]
	push	edi
	test	eax, eax
	je	SHORT $LN47@xmlXPathNo
$LL4@xmlXPathNo:

; 6396 : 	switch (tmp->type) {

	mov	edi, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [edi-3]
	cmp	ecx, 1
	ja	SHORT $LN30@xmlXPathNo

; 6397 : 	    case XML_CDATA_SECTION_NODE:
; 6398 : 	    case XML_TEXT_NODE:
; 6399 : 		string = tmp->content;

	mov	ecx, DWORD PTR [eax+40]

; 6400 : 		break;
; 6401 : 	    default:
; 6402 :                 string = NULL;
; 6403 : 		break;
; 6404 : 	}
; 6405 : 	if ((string != NULL) && (string[0] != 0)) {

	test	ecx, ecx
	je	SHORT $LN30@xmlXPathNo
	mov	dl, BYTE PTR [ecx]
	test	dl, dl
	je	SHORT $LN30@xmlXPathNo

; 6406 : 	    if (len == 1) {

	cmp	DWORD PTR _len$1$[ebp], 1
	movzx	edx, dl
	je	SHORT $LN46@xmlXPathNo

; 6408 : 	    }
; 6409 : 	    if (string[1] == 0) {

	mov	cl, BYTE PTR [ecx+1]
	mov	ebx, edx
	test	cl, cl
	jne	SHORT $LN29@xmlXPathNo

; 6410 : 		len = 1;

	mov	DWORD PTR _len$1$[ebp], 1
$LN30@xmlXPathNo:

; 6414 : 		       (((unsigned int) string[1]) << 8));
; 6415 : 	    }
; 6416 : 	}
; 6417 : 	/*
; 6418 : 	 * Skip to next node
; 6419 : 	 */
; 6420 : 	if ((tmp->children != NULL) && (tmp->type != XML_DTD_NODE)) {

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN32@xmlXPathNo
	cmp	edi, 14					; 0000000eH
	je	SHORT $LN32@xmlXPathNo

; 6421 : 	    if (tmp->children->type != XML_ENTITY_DECL) {

	cmp	DWORD PTR [ecx+4], 17			; 00000011H
	jne	SHORT $LN65@xmlXPathNo

; 6422 : 		tmp = tmp->children;
; 6423 : 		continue;
; 6424 : 	    }
; 6425 : 	}
; 6426 : 	if (tmp == node)
; 6427 : 	    break;
; 6428 : 
; 6429 : 	if (tmp->next != NULL) {
; 6430 : 	    tmp = tmp->next;
; 6431 : 	    continue;

	jmp	SHORT $LN32@xmlXPathNo
	npad	6
$LL10@xmlXPathNo:

; 6432 : 	}
; 6433 : 
; 6434 : 	do {
; 6435 : 	    tmp = tmp->parent;

	mov	eax, DWORD PTR [eax+20]

; 6436 : 	    if (tmp == NULL)

	test	eax, eax
	je	SHORT $LN47@xmlXPathNo
$LN32@xmlXPathNo:

; 6394 :     }
; 6395 :     while (tmp != NULL) {

	cmp	eax, esi
	je	SHORT $LN47@xmlXPathNo
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL10@xmlXPathNo
$LN65@xmlXPathNo:
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL4@xmlXPathNo
$LN47@xmlXPathNo:
	pop	edi
	pop	esi

; 6437 : 		break;
; 6438 : 	    if (tmp == node) {
; 6439 : 		tmp = NULL;
; 6440 : 		break;
; 6441 : 	    }
; 6442 : 	    if (tmp->next != NULL) {
; 6443 : 		tmp = tmp->next;
; 6444 : 		break;
; 6445 : 	    }
; 6446 : 	} while (tmp != NULL);
; 6447 :     }
; 6448 :     return(ret);

	mov	eax, ebx

; 6449 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlXPathNo:

; 6411 : 		ret = (unsigned int) string[0];
; 6412 : 	    } else {
; 6413 : 		return(((unsigned int) string[0]) +

	movzx	eax, cl
	pop	edi
	shl	eax, 8
	pop	esi
	add	eax, ebx

; 6449 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlXPathNo:

; 6407 : 		return(ret + (((unsigned int) string[0]) << 8));

	shl	edx, 8
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ebx+edx]

; 6449 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlXPathNo:
	pop	esi

; 6385 : 		   (((unsigned int) string[1]) << 8));
; 6386 : 	case XML_ATTRIBUTE_NODE:
; 6387 : 	    tmp = ((xmlAttrPtr) node)->children;
; 6388 : 	    break;
; 6389 : 	case XML_ELEMENT_NODE:
; 6390 : 	    tmp = node->children;
; 6391 : 	    break;
; 6392 : 	default:
; 6393 : 	    return(0);

	xor	eax, eax

; 6449 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN70@xmlXPathNo:
	DD	$LN22@xmlXPathNo
	DD	$LN16@xmlXPathNo
	DD	$LN19@xmlXPathNo
	DD	$LN24@xmlXPathNo
$LN59@xmlXPathNo:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_xmlXPathNodeValHash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompParserContext
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlXPathCompParserContext PROC				; COMDAT

; 6270 : xmlXPathCompParserContext(xmlXPathCompExprPtr comp, xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathCo

; 6271 :     xmlXPathParserContextPtr ret;
; 6272 : 
; 6273 :     ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));
; 6274 :     if (ret == NULL) {
; 6275 :         xmlXPathErrMemory(ctxt, "creating evaluation context\n");

	push	OFFSET ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErrMemory
	add	esp, 8

; 6276 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6297 : }

	pop	ebp
	ret	0
$LN2@xmlXPathCo:

; 6277 :     }
; 6278 :     memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 6279 : 
; 6280 :     /* Allocate the value stack */
; 6281 :     ret->valueTab = (xmlXPathObjectPtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+28], eax

; 6282 :                      xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
; 6283 :     if (ret->valueTab == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlXPathCo

; 6284 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree

; 6285 : 	xmlXPathErrMemory(ctxt, "creating evaluation context\n");

	push	OFFSET ??_C@_0BN@DLELJOPA@creating?5evaluation?5context?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErrMemory
	add	esp, 12					; 0000000cH

; 6286 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6297 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 6287 :     }
; 6288 :     ret->valueNr = 0;
; 6289 :     ret->valueMax = 10;
; 6290 :     ret->value = NULL;
; 6291 :     ret->valueFrame = 0;
; 6292 : 
; 6293 :     ret->context = ctxt;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+12], eax

; 6294 :     ret->comp = comp;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	DWORD PTR [esi+32], eax

; 6295 : 
; 6296 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 10			; 0000000aH
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+44], 0
	pop	esi

; 6297 : }

	pop	ebp
	ret	0
_xmlXPathCompParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetKeepLast
_TEXT	SEGMENT
_set$ = 8						; size = 4
_xmlXPathNodeSetKeepLast PROC				; COMDAT

; 4243 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _set$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlXPathNo

; 4244 :     int i;
; 4245 :     xmlNodePtr node;
; 4246 : 
; 4247 :     if ((set == NULL) || (set->nodeNr <= 1))

	mov	edx, DWORD PTR [edi]
	cmp	edx, 1
	jle	SHORT $LN6@xmlXPathNo

; 4248 : 	return;
; 4249 :     for (i = 0; i < set->nodeNr - 1; i++) {

	push	esi
	lea	eax, DWORD PTR [edx-1]
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN3@xmlXPathNo
$LL4@xmlXPathNo:

; 4250 :         node = set->nodeTab[i];

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 4251 :         if ((node != NULL) &&

	test	eax, eax
	je	SHORT $LN2@xmlXPathNo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPathNo

; 4252 :             (node->type == XML_NAMESPACE_DECL))
; 4253 :             xmlXPathNodeSetFreeNs((xmlNsPtr) node);

	push	eax
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN2@xmlXPathNo:

; 4248 : 	return;
; 4249 :     for (i = 0; i < set->nodeNr - 1; i++) {

	mov	edx, DWORD PTR [edi]
	inc	esi
	lea	eax, DWORD PTR [edx-1]
	cmp	esi, eax
	jl	SHORT $LL4@xmlXPathNo
$LN3@xmlXPathNo:

; 4254 :     }
; 4255 :     set->nodeTab[0] = set->nodeTab[set->nodeNr-1];

	mov	ecx, DWORD PTR [edi+8]

; 4256 :     set->nodeNr = 1;

	pop	esi
	mov	eax, DWORD PTR [ecx+edx*4-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edi], 1
$LN6@xmlXPathNo:
	pop	edi

; 4257 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetKeepLast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetClear
_TEXT	SEGMENT
_set$ = 8						; size = 4
_hasNsNodes$ = 12					; size = 4
_xmlXPathNodeSetClear PROC				; COMDAT

; 4229 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _hasNsNodes$[ebp]
	push	0
	push	DWORD PTR _set$[ebp]
	call	_xmlXPathNodeSetClearFromPos
	add	esp, 12					; 0000000cH

; 4230 :     xmlXPathNodeSetClearFromPos(set, 0, hasNsNodes);
; 4231 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetClear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetClearFromPos
_TEXT	SEGMENT
_set$ = 8						; size = 4
_pos$ = 12						; size = 4
_hasNsNodes$ = 16					; size = 4
_xmlXPathNodeSetClearFromPos PROC			; COMDAT

; 4202 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _set$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlXPathNo

; 4203 :     if ((set == NULL) || (pos >= set->nodeNr))

	push	ebx
	mov	ebx, DWORD PTR _pos$[ebp]
	cmp	ebx, DWORD PTR [edi]
	jge	SHORT $LN15@xmlXPathNo

; 4204 : 	return;
; 4205 :     else if ((hasNsNodes)) {

	cmp	DWORD PTR _hasNsNodes$[ebp], 0
	je	SHORT $LN3@xmlXPathNo

; 4206 : 	int i;
; 4207 : 	xmlNodePtr node;
; 4208 : 
; 4209 : 	for (i = pos; i < set->nodeNr; i++) {

	push	esi
	mov	esi, ebx
$LL4@xmlXPathNo:

; 4210 : 	    node = set->nodeTab[i];

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 4211 : 	    if ((node != NULL) &&

	test	eax, eax
	je	SHORT $LN2@xmlXPathNo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPathNo

; 4212 : 		(node->type == XML_NAMESPACE_DECL))
; 4213 : 		xmlXPathNodeSetFreeNs((xmlNsPtr) node);

	push	eax
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN2@xmlXPathNo:

; 4206 : 	int i;
; 4207 : 	xmlNodePtr node;
; 4208 : 
; 4209 : 	for (i = pos; i < set->nodeNr; i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@xmlXPathNo
	pop	esi
$LN3@xmlXPathNo:

; 4214 : 	}
; 4215 :     }
; 4216 :     set->nodeNr = pos;

	mov	DWORD PTR [edi], ebx
$LN15@xmlXPathNo:
	pop	ebx
$LN7@xmlXPathNo:
	pop	edi

; 4217 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetClearFromPos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetMergeAndClearNoDupls
_TEXT	SEGMENT
_set1$ = 8						; size = 4
_n2$1$ = 12						; size = 4
_set2$ = 12						; size = 4
_hasNullEntries$ = 16					; size = 4
_xmlXPathNodeSetMergeAndClearNoDupls PROC		; COMDAT

; 4047 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _set2$[ebp]
	test	ebx, ebx
	jne	SHORT $LN5@xmlXPathNo

; 4048 :     if (set2 == NULL)
; 4049 : 	return(set1);

	mov	eax, DWORD PTR _set1$[ebp]
	pop	ebx

; 4110 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNo:
	push	esi

; 4050 :     if ((set1 == NULL) && (hasNullEntries == 0)) {

	mov	esi, DWORD PTR _set1$[ebp]
	push	edi
	test	esi, esi
	jne	SHORT $LN11@xmlXPathNo
	cmp	DWORD PTR _hasNullEntries$[ebp], esi
	jne	SHORT $LN54@xmlXPathNo

; 4051 : 	/*
; 4052 : 	* Note that doing a memcpy of the list, namespace nodes are
; 4053 : 	* just assigned to set1, since set2 is cleared anyway.
; 4054 : 	*/
; 4055 : 	set1 = xmlXPathNodeSetCreateSize(set2->nodeNr);

	push	DWORD PTR [ebx]
	call	_xmlXPathNodeSetCreateSize
	mov	esi, eax
	add	esp, 4

; 4056 : 	if (set1 == NULL)

	test	esi, esi
	je	$LN55@xmlXPathNo

; 4057 : 	    return(NULL);
; 4058 : 	if (set2->nodeNr != 0) {

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN56@xmlXPathNo

; 4059 : 	    memcpy(set1->nodeTab, set2->nodeTab,

	shl	eax, 2
	push	eax
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [esi+8]
	call	_memcpy

; 4060 : 		set2->nodeNr * sizeof(xmlNodePtr));
; 4061 : 	    set1->nodeNr = set2->nodeNr;

	mov	eax, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
$LN56@xmlXPathNo:

; 4106 : 	}
; 4107 :     }
; 4108 :     set2->nodeNr = 0;
; 4109 :     return(set1);

	pop	edi
	mov	eax, esi
	mov	DWORD PTR [ebx], 0
	pop	esi
	pop	ebx

; 4110 : }

	pop	ebp
	ret	0
$LN54@xmlXPathNo:

; 4062 : 	}
; 4063 :     } else {
; 4064 : 	int i;
; 4065 : 	xmlNodePtr n2;
; 4066 : 
; 4067 : 	if (set1 == NULL)
; 4068 : 	    set1 = xmlXPathNodeSetCreate(NULL);

	push	0
	call	_xmlXPathNodeSetCreate
	mov	esi, eax
	add	esp, 4

; 4069 :         if (set1 == NULL)

	test	esi, esi
	je	$LN55@xmlXPathNo
$LN11@xmlXPathNo:

; 4070 :             return (NULL);
; 4071 : 
; 4072 : 	for (i = 0;i < set2->nodeNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN56@xmlXPathNo
$LL4@xmlXPathNo:

; 4073 : 	    n2 = set2->nodeTab[i];

	mov	eax, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _n2$1$[ebp], eax

; 4074 : 	    /*
; 4075 : 	    * Skip NULLed entries.
; 4076 : 	    */
; 4077 : 	    if (n2 == NULL)

	test	eax, eax
	je	SHORT $LN2@xmlXPathNo

; 4078 : 		continue;
; 4079 : 	    if (set1->nodeMax == 0) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN13@xmlXPathNo

; 4080 : 		set1->nodeTab = (xmlNodePtr *) xmlMalloc(

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 4081 : 		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
; 4082 : 		if (set1->nodeTab == NULL) {

	test	eax, eax
	je	SHORT $LN50@xmlXPathNo

; 4083 : 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
; 4084 : 		    return(NULL);
; 4085 : 		}
; 4086 : 		memset(set1->nodeTab, 0,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 4087 : 		    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 4088 : 		set1->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	SHORT $LN16@xmlXPathNo
$LN13@xmlXPathNo:

; 4089 : 	    } else if (set1->nodeNr >= set1->nodeMax) {

	cmp	DWORD PTR [esi], eax
	jl	SHORT $LN16@xmlXPathNo

; 4090 : 		xmlNodePtr *temp;
; 4091 : 
; 4092 :                 if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jge	$LN49@xmlXPathNo

; 4095 :                 }
; 4096 : 		temp = (xmlNodePtr *) xmlRealloc(

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4097 : 		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
; 4098 : 		if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN50@xmlXPathNo

; 4101 : 		}
; 4102 : 		set1->nodeTab = temp;

	mov	DWORD PTR [esi+8], eax

; 4103 : 		set1->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	DWORD PTR [esi+4], eax
$LN16@xmlXPathNo:

; 4104 : 	    }
; 4105 : 	    set1->nodeTab[set1->nodeNr++] = n2;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _n2$1$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	inc	DWORD PTR [esi]
$LN2@xmlXPathNo:

; 4070 :             return (NULL);
; 4071 : 
; 4072 : 	for (i = 0;i < set2->nodeNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL4@xmlXPathNo

; 4106 : 	}
; 4107 :     }
; 4108 :     set2->nodeNr = 0;
; 4109 :     return(set1);

	pop	edi
	mov	eax, esi
	mov	DWORD PTR [ebx], 0
	pop	esi
	pop	ebx

; 4110 : }

	pop	ebp
	ret	0
$LN50@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4099 : 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
; 4100 : 		    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 4110 : }

	pop	ebp
	ret	0
$LN49@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN55@xmlXPathNo:
	pop	edi
	pop	esi

; 4093 :                     xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
; 4094 :                     return(NULL);

	xor	eax, eax
	pop	ebx

; 4110 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetMergeAndClearNoDupls ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetMergeAndClear
_TEXT	SEGMENT
tv656 = -8						; size = 4
_i$1$ = -4						; size = 4
_initNbSet1$1$ = 8					; size = 4
_set1$ = 8						; size = 4
_set2$ = 12						; size = 4
_hasNullEntries$ = 16					; size = 4
_xmlXPathNodeSetMergeAndClear PROC			; COMDAT

; 3940 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _set1$[ebp]
	test	esi, esi
	jne	$LN13@xmlXPathNo

; 3941 :     if ((set1 == NULL) && (hasNullEntries == 0)) {

	cmp	DWORD PTR _hasNullEntries$[ebp], esi
	jne	SHORT $LN91@xmlXPathNo

; 3942 : 	/*
; 3943 : 	* Note that doing a memcpy of the list, namespace nodes are
; 3944 : 	* just assigned to set1, since set2 is cleared anyway.
; 3945 : 	*/
; 3946 : 	set1 = xmlXPathNodeSetCreateSize(set2->nodeNr);

	mov	eax, DWORD PTR _set2$[ebp]
	push	DWORD PTR [eax]
	call	_xmlXPathNodeSetCreateSize
	mov	esi, eax
	add	esp, 4

; 3947 : 	if (set1 == NULL)

	test	esi, esi
	je	SHORT $LN92@xmlXPathNo

; 3948 : 	    return(NULL);
; 3949 : 	if (set2->nodeNr != 0) {

	mov	edx, DWORD PTR _set2$[ebp]
	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN94@xmlXPathNo

; 3950 : 	    memcpy(set1->nodeTab, set2->nodeTab,

	shl	ecx, 2
	push	ecx
	push	DWORD PTR [edx+8]
	push	DWORD PTR [esi+8]
	call	_memcpy

; 3951 : 		set2->nodeNr * sizeof(xmlNodePtr));
; 3952 : 	    set1->nodeNr = set2->nodeNr;

	mov	edx, DWORD PTR _set2$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
$LN94@xmlXPathNo:

; 4024 : skip_node:
; 4025 : 	    {}
; 4026 : 	}
; 4027 :     }
; 4028 :     set2->nodeNr = 0;
; 4029 :     return(set1);

	pop	edi
	mov	eax, esi
	mov	DWORD PTR [edx], 0

; 4030 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@xmlXPathNo:

; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3531 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN27@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN92@xmlXPathNo:
	pop	edi

; 4030 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXPathNo:
	xorps	xmm0, xmm0

; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));

	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0
$LN13@xmlXPathNo:

; 3953 : 	}
; 3954 :     } else {
; 3955 : 	int i, j, initNbSet1;
; 3956 : 	xmlNodePtr n1, n2;
; 3957 : 
; 3958 : 	if (set1 == NULL)
; 3959 :             set1 = xmlXPathNodeSetCreate(NULL);
; 3960 :         if (set1 == NULL)
; 3961 :             return (NULL);
; 3962 : 
; 3963 : 	initNbSet1 = set1->nodeNr;
; 3964 : 	for (i = 0;i < set2->nodeNr;i++) {

	mov	edx, DWORD PTR _set2$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _initNbSet1$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [edx], eax
	jle	SHORT $LN94@xmlXPathNo
	npad	8
$LL4@xmlXPathNo:

; 3965 : 	    n2 = set2->nodeTab[i];

	lea	ebx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv656[ebp], ebx
	mov	edi, DWORD PTR [ebx+eax]

; 3966 : 	    /*
; 3967 : 	    * Skip NULLed entries.
; 3968 : 	    */
; 3969 : 	    if (n2 == NULL)

	test	edi, edi
	je	$LN2@xmlXPathNo

; 3970 : 		continue;
; 3971 : 	    /*
; 3972 : 	    * Skip duplicates.
; 3973 : 	    */
; 3974 : 	    for (j = 0; j < initNbSet1; j++) {

	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN93@xmlXPathNo
	npad	2
$LL7@xmlXPathNo:

; 3975 : 		n1 = set1->nodeTab[j];

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 3976 : 		if (n1 == n2) {

	cmp	ecx, edi
	je	$skip_node$96

; 3977 : 		    goto skip_node;
; 3978 : 		} else if ((n1->type == XML_NAMESPACE_DECL) &&

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPathNo
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPathNo

; 3979 : 		    (n2->type == XML_NAMESPACE_DECL))
; 3980 : 		{
; 3981 : 		    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN5@xmlXPathNo
	push	DWORD PTR [edi+12]
	push	DWORD PTR [ecx+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN81@xmlXPathNo
$LN5@xmlXPathNo:

; 3970 : 		continue;
; 3971 : 	    /*
; 3972 : 	    * Skip duplicates.
; 3973 : 	    */
; 3974 : 	    for (j = 0; j < initNbSet1; j++) {

	inc	ebx
	cmp	ebx, DWORD PTR _initNbSet1$1$[ebp]
	jl	SHORT $LL7@xmlXPathNo
$LN93@xmlXPathNo:

; 3991 : 		    }
; 3992 : 		}
; 3993 : 	    }
; 3994 : 	    /*
; 3995 : 	    * grow the nodeTab if needed
; 3996 : 	    */
; 3997 : 	    if (set1->nodeMax == 0) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN19@xmlXPathNo

; 3998 : 		set1->nodeTab = (xmlNodePtr *) xmlMalloc(

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3999 : 		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
; 4000 : 		if (set1->nodeTab == NULL) {

	test	eax, eax
	je	$LN84@xmlXPathNo

; 4001 : 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
; 4002 : 		    return(NULL);
; 4003 : 		}
; 4004 : 		memset(set1->nodeTab, 0,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 4005 : 		    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 4006 : 		set1->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	SHORT $LN22@xmlXPathNo
$LN81@xmlXPathNo:

; 3982 : 			(xmlStrEqual(((xmlNsPtr) n1)->prefix,
; 3983 : 			((xmlNsPtr) n2)->prefix)))
; 3984 : 		    {
; 3985 : 			/*
; 3986 : 			* Free the namespace node.
; 3987 : 			*/
; 3988 : 			set2->nodeTab[i] = NULL;

	mov	eax, DWORD PTR _set2$[ebp]
	mov	ecx, DWORD PTR tv656[ebp]

; 3989 : 			xmlXPathNodeSetFreeNs((xmlNsPtr) n2);

	push	edi
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+eax], 0
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4

; 3990 : 			goto skip_node;

	jmp	SHORT $skip_node$96
$LN19@xmlXPathNo:

; 4007 : 	    } else if (set1->nodeNr >= set1->nodeMax) {

	cmp	DWORD PTR [esi], eax
	jl	SHORT $LN22@xmlXPathNo

; 4008 : 		xmlNodePtr *temp;
; 4009 : 
; 4010 :                 if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jge	$LN83@xmlXPathNo

; 4013 :                 }
; 4014 : 		temp = (xmlNodePtr *) xmlRealloc(

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 4015 : 		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
; 4016 : 		if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN84@xmlXPathNo

; 4019 : 		}
; 4020 : 		set1->nodeTab = temp;

	mov	DWORD PTR [esi+8], eax

; 4021 : 		set1->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	DWORD PTR [esi+4], eax
$LN22@xmlXPathNo:

; 4022 : 	    }
; 4023 : 	    set1->nodeTab[set1->nodeNr++] = n2;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi]
$skip_node$96:
	mov	edx, DWORD PTR _set2$[ebp]
	mov	ecx, DWORD PTR _initNbSet1$1$[ebp]
$LN2@xmlXPathNo:

; 3953 : 	}
; 3954 :     } else {
; 3955 : 	int i, j, initNbSet1;
; 3956 : 	xmlNodePtr n1, n2;
; 3957 : 
; 3958 : 	if (set1 == NULL)
; 3959 :             set1 = xmlXPathNodeSetCreate(NULL);
; 3960 :         if (set1 == NULL)
; 3961 :             return (NULL);
; 3962 : 
; 3963 : 	initNbSet1 = set1->nodeNr;
; 3964 : 	for (i = 0;i < set2->nodeNr;i++) {

	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jl	$LL4@xmlXPathNo

; 4024 : skip_node:
; 4025 : 	    {}
; 4026 : 	}
; 4027 :     }
; 4028 :     set2->nodeNr = 0;
; 4029 :     return(set1);

	pop	edi
	mov	eax, esi
	mov	DWORD PTR [edx], 0

; 4030 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN84@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4017 : 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
; 4018 : 		    return(NULL);

	xor	eax, eax
	pop	edi

; 4030 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4011 :                     xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
; 4012 :                     return(NULL);

	xor	eax, eax
	pop	edi

; 4030 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathNodeSetMergeAndClear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetCreateSize
_TEXT	SEGMENT
_size$ = 8						; size = 4
_xmlXPathNodeSetCreateSize PROC				; COMDAT

; 3567 : xmlXPathNodeSetCreateSize(int size) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3568 :     xmlNodeSetPtr ret;
; 3569 : 
; 3570 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
; 3571 :     if (ret == NULL) {
; 3572 :         xmlXPathErrMemory(NULL, "creating nodeset\n");
; 3573 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 3587 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNo:
	push	ebx
	push	edi

; 3574 :     }
; 3575 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
; 3576 :     if (size < XML_NODESET_DEFAULT)
; 3577 : 	size = XML_NODESET_DEFAULT;
; 3578 :     ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));

	mov	edi, 10					; 0000000aH
	xorps	xmm0, xmm0
	cmp	DWORD PTR _size$[ebp], edi
	movq	QWORD PTR [esi], xmm0
	cmovge	edi, DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi+8], 0
	lea	ebx, DWORD PTR [edi*4]
	push	ebx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3579 :     if (ret->nodeTab == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 3580 : 	xmlXPathErrMemory(NULL, "creating nodeset\n");
; 3581 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 3582 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 3587 : }

	pop	ebp
	ret	0
$LN4@xmlXPathNo:

; 3583 :     }
; 3584 :     memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));

	push	ebx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3585 :     ret->nodeMax = size;

	mov	DWORD PTR [esi+4], edi

; 3586 :     return(ret);

	mov	eax, esi
	pop	edi
	pop	ebx
	pop	esi

; 3587 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetCreateSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetDupNs
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlXPathNodeSetDupNs PROC				; COMDAT

; 3470 : xmlXPathNodeSetDupNs(xmlNodePtr node, xmlNsPtr ns) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ns$[ebp]
	test	edi, edi
	je	$LN3@xmlXPathNo

; 3471 :     xmlNsPtr cur;
; 3472 : 
; 3473 :     if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL))

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	$LN3@xmlXPathNo

; 3475 :     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))

	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN5@xmlXPathNo
	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN5@xmlXPathNo

; 3477 : 
; 3478 :     /*
; 3479 :      * Allocate a new Namespace and fill the fields.
; 3480 :      */
; 3481 :     cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));

	push	esi
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 3482 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BH@EHGBBAJH@duplicating?5namespace?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@EHGBBAJH@duplicating?5namespace?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3483 :         xmlXPathErrMemory(NULL, "duplicating namespace\n");
; 3484 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 3494 : }

	pop	ebp
	ret	0
$LN6@xmlXPathNo:
	xorps	xmm0, xmm0

; 3485 :     }
; 3486 :     memset(cur, 0, sizeof(xmlNs));

	movups	XMMWORD PTR [esi], xmm0
	movq	QWORD PTR [esi+16], xmm0

; 3487 :     cur->type = XML_NAMESPACE_DECL;

	mov	DWORD PTR [esi+4], 18			; 00000012H

; 3488 :     if (ns->href != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN7@xmlXPathNo

; 3489 : 	cur->href = xmlStrdup(ns->href);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
$LN7@xmlXPathNo:

; 3490 :     if (ns->prefix != NULL)

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN8@xmlXPathNo

; 3491 : 	cur->prefix = xmlStrdup(ns->prefix);

	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
$LN8@xmlXPathNo:

; 3492 :     cur->next = (xmlNsPtr) node;

	mov	DWORD PTR [esi], ebx

; 3493 :     return((xmlNodePtr) cur);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 3494 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNo:
	pop	ebx

; 3476 : 	return((xmlNodePtr) ns);

	mov	eax, edi
	pop	edi

; 3494 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNo:

; 3474 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 3494 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetDupNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFormatNumber
_TEXT	SEGMENT
_work$1 = -36						; size = 28
_work$2 = -36						; size = 30
_after_fraction$1$ = -4					; size = 4
_number$ = 8						; size = 8
_buffer$ = 16						; size = 4
_buffersize$ = 20					; size = 4
_xmlXPathFormatNumber PROC				; COMDAT

; 3089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4

; 528  :     return isinf(val) ? (val > 0 ? 1 : -1) : 0;

	movsd	xmm0, QWORD PTR _number$[ebp]
	sub	esp, 8
	mov	esi, DWORD PTR __imp___dclass
	movsd	QWORD PTR [esp], xmm0
	call	esi
	movsd	xmm0, QWORD PTR _number$[ebp]
	add	esp, 8
	cmp	ax, 1
	jne	SHORT $LN76@xmlXPathFo
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@0000000000000000
	seta	al
	lea	eax, DWORD PTR [eax*2-1]

; 3090 :     switch (xmlXPathIsInf(number)) {

	cmp	eax, -1
	je	SHORT $LN19@xmlXPathFo
	cmp	eax, 1
	jne	SHORT $LN76@xmlXPathFo

; 3091 :     case 1:
; 3092 : 	if (buffersize > (int)sizeof("Infinity"))

	mov	eax, DWORD PTR _buffersize$[ebp]
	cmp	eax, 9
	jle	$LN20@xmlXPathFo

; 3093 : 	    snprintf(buffer, buffersize, "Infinity");

	push	OFFSET ??_C@_08KEBCLIFP@Infinity@
	push	eax
	push	DWORD PTR _buffer$[ebp]
	call	_snprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXPathFo:

; 3094 : 	break;
; 3095 :     case -1:
; 3096 : 	if (buffersize > (int)sizeof("-Infinity"))

	mov	eax, DWORD PTR _buffersize$[ebp]
	cmp	eax, 10					; 0000000aH
	jle	$LN20@xmlXPathFo

; 3097 : 	    snprintf(buffer, buffersize, "-Infinity");

	push	OFFSET ??_C@_09BLDCEMOH@?9Infinity@
	push	eax
	push	DWORD PTR _buffer$[ebp]
	call	_snprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@xmlXPathFo:

; 513  :     return isnan(val);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	esi
	add	esp, 8
	cmp	ax, 2

; 3098 : 	break;
; 3099 :     default:
; 3100 : 	if (xmlXPathIsNaN(number)) {

	jne	SHORT $LN22@xmlXPathFo

; 3101 : 	    if (buffersize > (int)sizeof("NaN"))

	mov	eax, DWORD PTR _buffersize$[ebp]
	cmp	eax, 4
	jle	$LN20@xmlXPathFo

; 3102 : 		snprintf(buffer, buffersize, "NaN");

	push	OFFSET ??_C@_03ICJPMMHB@NaN@
	push	eax
	push	DWORD PTR _buffer$[ebp]
	call	_snprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlXPathFo:

; 3103 : 	} else if (number == 0) {

	movsd	xmm1, QWORD PTR _number$[ebp]
	xorps	xmm3, xmm3
	ucomisd	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@xmlXPathFo

; 3104 :             /* Omit sign for negative zero. */
; 3105 : 	    snprintf(buffer, buffersize, "0");

	push	OFFSET ??_C@_01GBGANLPD@0@
	push	DWORD PTR _buffersize$[ebp]
	push	DWORD PTR _buffer$[ebp]
	call	_snprintf
	add	esp, 12					; 0000000cH
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlXPathFo:

; 3106 : 	} else if ((number > INT_MIN) && (number < INT_MAX) &&

	comisd	xmm1, QWORD PTR __real@c1e0000000000000
	jbe	$LN27@xmlXPathFo
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, xmm1
	jbe	$LN27@xmlXPathFo
	cvttsd2si ecx, xmm1
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@xmlXPathFo

; 3107 :                    (number == (int) number)) {
; 3108 : 	    char work[30];
; 3109 : 	    char *ptr, *cur;
; 3110 : 	    int value = (int) number;
; 3111 : 
; 3112 :             ptr = &buffer[0];

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	esi, eax
	push	edi

; 3113 : 	    if (value == 0) {

	mov	edi, DWORD PTR _buffersize$[ebp]
	test	ecx, ecx
	jne	SHORT $LN29@xmlXPathFo

; 3114 : 		*ptr++ = '0';

	mov	BYTE PTR [eax], 48			; 00000030H
	lea	esi, DWORD PTR [eax+1]

; 3115 : 	    } else {

	jmp	SHORT $LN78@xmlXPathFo
$LN29@xmlXPathFo:

; 3116 : 		snprintf(work, 29, "%d", value);

	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	lea	eax, DWORD PTR _work$2[ebp]
	push	29					; 0000001dH
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 3117 : 		cur = &work[0];
; 3118 : 		while ((*cur) && (ptr - buffer < buffersize)) {

	cmp	BYTE PTR _work$2[ebp], 0
	je	SHORT $LN78@xmlXPathFo

; 3116 : 		snprintf(work, 29, "%d", value);

	lea	edx, DWORD PTR _work$2[ebp]
	xor	ecx, ecx
	sub	edx, esi
$LL4@xmlXPathFo:

; 3117 : 		cur = &work[0];
; 3118 : 		while ((*cur) && (ptr - buffer < buffersize)) {

	cmp	ecx, edi
	jge	SHORT $LN78@xmlXPathFo

; 3119 : 		    *ptr++ = *cur++;

	mov	al, BYTE PTR [edx+esi]
	inc	ecx
	mov	BYTE PTR [esi], al
	inc	esi
	cmp	BYTE PTR [edx+esi], 0
	jne	SHORT $LL4@xmlXPathFo
$LN78@xmlXPathFo:

; 3120 : 		}
; 3121 : 	    }
; 3122 : 	    if (ptr - buffer < buffersize) {

	mov	eax, esi
	sub	eax, DWORD PTR _buffer$[ebp]
	cmp	eax, edi
	jge	SHORT $LN31@xmlXPathFo

; 3123 : 		*ptr = 0;

	mov	BYTE PTR [esi], 0
$LN80@xmlXPathFo:
	pop	edi
$LN20@xmlXPathFo:
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlXPathFo:

; 3124 : 	    } else if (buffersize > 0) {

	test	edi, edi
	jle	SHORT $LN80@xmlXPathFo

; 3125 : 		ptr--;
; 3126 : 		*ptr = 0;

	pop	edi
	mov	BYTE PTR [esi-1], 0
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXPathFo:

; 3127 : 	    }
; 3128 : 	} else {
; 3129 : 	    /*
; 3130 : 	      For the dimension of work,
; 3131 : 	          DBL_DIG is number of significant digits
; 3132 : 		  EXPONENT is only needed for "scientific notation"
; 3133 : 	          3 is sign, decimal point, and terminating zero
; 3134 : 		  LOWER_DOUBLE_EXP is max number of leading zeroes in fraction
; 3135 : 	      Note that this dimension is slightly (a few characters)
; 3136 : 	      larger than actually necessary.
; 3137 : 	    */
; 3138 : 	    char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];
; 3139 : 	    int integer_place, fraction_place;
; 3140 : 	    char *ptr;
; 3141 : 	    char *after_fraction;
; 3142 : 	    double absolute_value;
; 3143 : 	    int size;
; 3144 : 
; 3145 : 	    absolute_value = fabs(number);

	movaps	xmm2, xmm1
	andps	xmm2, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff

; 3146 : 
; 3147 : 	    /*
; 3148 : 	     * First choose format - scientific or regular floating point.
; 3149 : 	     * In either case, result is in work, and after_fraction points
; 3150 : 	     * just past the fractional part.
; 3151 : 	    */
; 3152 : 	    if ( ((absolute_value > UPPER_DOUBLE) ||
; 3153 : 		  (absolute_value < LOWER_DOUBLE)) &&

	comisd	xmm2, QWORD PTR __real@41cdcd6500000000
	ja	SHORT $LN36@xmlXPathFo
	movsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	comisd	xmm0, xmm2
	jbe	SHORT $LN34@xmlXPathFo
$LN36@xmlXPathFo:
	ucomisd	xmm2, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN34@xmlXPathFo

; 3154 : 		 (absolute_value != 0.0) ) {
; 3155 : 		/* Use scientific notation */
; 3156 : 		integer_place = DBL_DIG + EXPONENT_DIGITS + 1;
; 3157 : 		fraction_place = DBL_DIG - 1;
; 3158 : 		size = snprintf(work, sizeof(work),"%*.*e",

	sub	esp, 8
	lea	eax, DWORD PTR _work$1[ebp]
	movsd	QWORD PTR [esp], xmm1
	push	14					; 0000000eH
	push	21					; 00000015H
	push	OFFSET ??_C@_05PPJAHJKF@?$CF?$CK?4?$CKe@
	push	28					; 0000001cH
	push	eax
	call	_snprintf
	mov	edx, eax
	add	esp, 28					; 0000001cH

; 3159 : 			 integer_place, fraction_place, number);
; 3160 : 		while ((size > 0) && (work[size] != 'e')) size--;

	test	edx, edx
	jle	SHORT $LN52@xmlXPathFo
$LL6@xmlXPathFo:
	cmp	BYTE PTR _work$1[ebp+edx], 101		; 00000065H
	je	SHORT $LN52@xmlXPathFo
	dec	edx
	test	edx, edx
	jg	SHORT $LL6@xmlXPathFo

; 3161 : 
; 3162 : 	    }

	jmp	SHORT $LN52@xmlXPathFo
$LN34@xmlXPathFo:

; 3163 : 	    else {
; 3164 : 		/* Use regular notation */
; 3165 : 		if (absolute_value > 0.0) {

	comisd	xmm2, xmm3
	jbe	SHORT $LN37@xmlXPathFo

; 3166 : 		    integer_place = (int)log10(absolute_value);

	movaps	xmm0, xmm2
	call	__libm_sse2_log10_precise

; 3167 : 		    if (integer_place > 0)
; 3168 : 		        fraction_place = DBL_DIG - integer_place - 1;
; 3169 : 		    else
; 3170 : 		        fraction_place = DBL_DIG - integer_place;
; 3171 : 		} else {

	movsd	xmm1, QWORD PTR _number$[ebp]
	mov	eax, 15					; 0000000fH
	cvttsd2si ecx, xmm0
	mov	edx, 14					; 0000000eH
	sub	eax, ecx
	sub	edx, ecx
	test	ecx, ecx
	cmovle	edx, eax
	jmp	SHORT $LN38@xmlXPathFo
$LN37@xmlXPathFo:

; 3172 : 		    fraction_place = 1;

	mov	edx, 1
$LN38@xmlXPathFo:

; 3173 : 		}
; 3174 : 		size = snprintf(work, sizeof(work), "%0.*f",

	sub	esp, 8
	lea	eax, DWORD PTR _work$1[ebp]
	movsd	QWORD PTR [esp], xmm1
	push	edx
	push	OFFSET ??_C@_05POONKFEF@?$CF0?4?$CKf@
	push	28					; 0000001cH
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H
	mov	edx, eax
$LN52@xmlXPathFo:

; 3175 : 				fraction_place, number);
; 3176 : 	    }
; 3177 : 
; 3178 : 	    /* Remove leading spaces sometimes inserted by snprintf */
; 3179 : 	    while (work[0] == ' ') {

	cmp	BYTE PTR _work$1[ebp], 32		; 00000020H
	jne	SHORT $LN9@xmlXPathFo
	mov	ah, BYTE PTR _work$1[ebp+1]
	npad	7
$LL8@xmlXPathFo:

; 3180 : 	        for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);

	lea	ecx, DWORD PTR _work$1[ebp]
	mov	al, ah
	mov	BYTE PTR _work$1[ebp], al
	test	ah, ah
	je	SHORT $LN11@xmlXPathFo
	npad	4
$LL12@xmlXPathFo:
	mov	al, BYTE PTR [ecx+2]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [ecx], al
	test	al, al
	jne	SHORT $LL12@xmlXPathFo
	mov	ah, BYTE PTR _work$1[ebp+1]
	mov	al, BYTE PTR _work$1[ebp]
$LN11@xmlXPathFo:

; 3181 : 		size--;

	dec	edx
	cmp	al, 32					; 00000020H
	je	SHORT $LL8@xmlXPathFo
$LN9@xmlXPathFo:

; 3182 : 	    }
; 3183 : 
; 3184 : 	    /* Remove fractional trailing zeroes */
; 3185 : 	    after_fraction = work + size;

	lea	eax, DWORD PTR _work$1[ebp]
	add	edx, eax
	mov	DWORD PTR _after_fraction$1$[ebp], edx

; 3186 : 	    ptr = after_fraction;

	mov	eax, edx
$LL13@xmlXPathFo:

; 3187 : 	    while (*(--ptr) == '0')

	mov	dl, BYTE PTR [eax-1]
	mov	ecx, eax
	dec	eax
	cmp	dl, 48					; 00000030H
	je	SHORT $LL13@xmlXPathFo
	cmp	dl, 46					; 0000002eH
	mov	edx, DWORD PTR _after_fraction$1$[ebp]
	cmove	ecx, eax
$LL15@xmlXPathFo:

; 3188 : 		;
; 3189 : 	    if (*ptr != '.')
; 3190 : 	        ptr++;
; 3191 : 	    while ((*ptr++ = *after_fraction++) != 0);

	mov	al, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [ecx-1], al
	lea	edx, DWORD PTR [edx+1]
	test	al, al
	jne	SHORT $LL15@xmlXPathFo

; 3192 : 
; 3193 : 	    /* Finally copy result back to caller */
; 3194 : 	    size = strlen(work) + 1;

	lea	ecx, DWORD PTR _work$1[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL77@xmlXPathFo:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL77@xmlXPathFo

; 3195 : 	    if (size > buffersize) {

	mov	eax, DWORD PTR _buffersize$[ebp]
	sub	ecx, edx
	inc	ecx
	cmp	ecx, eax
	jle	SHORT $LN42@xmlXPathFo

; 3196 : 		work[buffersize - 1] = 0;

	mov	BYTE PTR _work$1[ebp+eax-1], 0

; 3197 : 		size = buffersize;

	mov	ecx, eax
$LN42@xmlXPathFo:

; 3198 : 	    }
; 3199 : 	    memmove(buffer, work, size);

	push	ecx
	lea	eax, DWORD PTR _work$1[ebp]
	push	eax
	push	DWORD PTR _buffer$[ebp]
	call	_memmove
	add	esp, 12					; 0000000cH
	pop	esi

; 3200 : 	}
; 3201 : 	break;
; 3202 :     }
; 3203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathFormatNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopFrame
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_frame$ = 12						; size = 4
_xmlXPathPopFrame PROC					; COMDAT

; 2801 : xmlXPathPopFrame(xmlXPathParserContextPtr ctxt, int frame) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathPo

; 2802 :     if (ctxt == NULL)
; 2803 :         return;
; 2804 :     if (ctxt->valueNr < ctxt->valueFrame) {

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+44]
	jge	SHORT $LN5@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN5@xmlXPathPo:

; 2805 :         xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);
; 2806 :     }
; 2807 :     ctxt->valueFrame = frame;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [esi+44], eax
$LN1@xmlXPathPo:
	pop	esi

; 2808 : }

	pop	ebp
	ret	0
_xmlXPathPopFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSetFrame
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathSetFrame PROC					; COMDAT

; 2783 : xmlXPathSetFrame(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	jne	SHORT $LN2@xmlXPathSe

; 2784 :     int ret;
; 2785 : 
; 2786 :     if (ctxt == NULL)
; 2787 :         return(0);

	xor	eax, eax

; 2790 :     return(ret);
; 2791 : }

	pop	ebp
	ret	0
$LN2@xmlXPathSe:

; 2788 :     ret = ctxt->valueFrame;

	mov	eax, DWORD PTR [edx+44]

; 2789 :     ctxt->valueFrame = ctxt->valueNr;

	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR [edx+44], ecx

; 2790 :     return(ret);
; 2791 : }

	pop	ebp
	ret	0
_xmlXPathSetFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheConvertNumber
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheConvertNumber PROC			; COMDAT

; 2756 : xmlXPathCacheConvertNumber(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	jne	SHORT $LN2@xmlXPathCa

; 2757 :     xmlXPathObjectPtr ret;
; 2758 : 
; 2759 :     if (val == NULL)
; 2760 : 	return(xmlXPathCacheNewFloat(ctxt, 0.0));

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathCacheNewFloat
	add	esp, 12					; 0000000cH
	pop	ebx

; 2766 : }

	pop	ebp
	ret	0
$LN2@xmlXPathCa:

; 2761 :     if (val->type == XPATH_NUMBER)

	cmp	DWORD PTR [ebx], 3
	jne	SHORT $LN3@xmlXPathCa

; 2762 : 	return(val);

	mov	eax, ebx
	pop	ebx

; 2766 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:
	push	esi

; 2763 :     ret = xmlXPathCacheNewFloat(ctxt, xmlXPathCastToNumber(val));

	push	ebx
	call	_xmlXPathCastToNumber
	push	ecx
	fstp	QWORD PTR [esp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathCacheNewFloat

; 2764 :     xmlXPathReleaseObject(ctxt, val);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlXPathReleaseObject
	add	esp, 20					; 00000014H

; 2765 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2766 : }

	pop	ebp
	ret	0
_xmlXPathCacheConvertNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheConvertBoolean
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheConvertBoolean PROC			; COMDAT

; 2732 : xmlXPathCacheConvertBoolean(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	jne	$LN2@xmlXPathCa

; 2553 :     if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN9@xmlXPathCa
	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN9@xmlXPathCa

; 2554 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2555 : 
; 2556 : 	if ((cache->booleanObjs != NULL) &&

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN7@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPathCa

; 2557 : 	    (cache->booleanObjs->number != 0))
; 2558 : 	{
; 2559 : 	    xmlXPathObjectPtr ret;
; 2560 : 
; 2561 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2741 :     return(ret);
; 2742 : }

	mov	eax, esi

; 2564 : 	    ret->boolval = (val != 0);

	mov	DWORD PTR [esi+8], ebx

; 2733 :     xmlXPathObjectPtr ret;
; 2734 : 
; 2735 :     if (val == NULL)
; 2736 : 	return(xmlXPathCacheNewBoolean(ctxt, 0));

	mov	DWORD PTR [esi], 2
	pop	esi

; 2741 :     return(ret);
; 2742 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 2569 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN9@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN9@xmlXPathCa

; 2570 : 	    (cache->miscObjs->number != 0))
; 2571 : 	{
; 2572 : 	    xmlXPathObjectPtr ret;
; 2573 : 
; 2574 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2741 :     return(ret);
; 2742 : }

	mov	eax, esi

; 2578 : 	    ret->boolval = (val != 0);

	mov	DWORD PTR [esi+8], 0

; 2733 :     xmlXPathObjectPtr ret;
; 2734 : 
; 2735 :     if (val == NULL)
; 2736 : 	return(xmlXPathCacheNewBoolean(ctxt, 0));

	mov	DWORD PTR [esi], 2
	pop	esi

; 2741 :     return(ret);
; 2742 : }

	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 5259 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5260 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN12@xmlXPathCa

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2741 :     return(ret);
; 2742 : }

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlXPathCa:

; 5264 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 2733 :     xmlXPathObjectPtr ret;
; 2734 : 
; 2735 :     if (val == NULL)
; 2736 : 	return(xmlXPathCacheNewBoolean(ctxt, 0));

	mov	DWORD PTR [esi], 2

; 2741 :     return(ret);
; 2742 : }

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN2@xmlXPathCa:

; 2737 :     if (val->type == XPATH_BOOLEAN)

	cmp	DWORD PTR [ebx], 2
	jne	SHORT $LN3@xmlXPathCa

; 2738 : 	return(val);

	pop	esi
	mov	eax, ebx

; 2741 :     return(ret);
; 2742 : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2739 :     ret = xmlXPathCacheNewBoolean(ctxt, xmlXPathCastToBoolean(val));

	push	ebx
	call	_xmlXPathCastToBoolean
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathCacheNewBoolean

; 2740 :     xmlXPathReleaseObject(ctxt, val);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	mov	esi, eax
	call	_xmlXPathReleaseObject
	add	esp, 20					; 00000014H

; 2741 :     return(ret);
; 2742 : }

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathCacheConvertBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheObjectCopy
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheObjectCopy PROC				; COMDAT

; 2698 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _val$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlXPathCa

; 2699 :     if (val == NULL)
; 2700 : 	return(NULL);

	xor	eax, eax

; 2718 : }

	pop	ebp
	ret	0
$LN4@xmlXPathCa:
	push	esi

; 2701 : 
; 2702 :     if (XP_HAS_CACHE(ctxt)) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN10@xmlXPathCa
	cmp	DWORD PTR [esi+200], 0
	je	SHORT $LN10@xmlXPathCa

; 2703 : 	switch (val->type) {

	mov	eax, DWORD PTR [ecx]
	dec	eax
	cmp	eax, 3
	ja	SHORT $LN10@xmlXPathCa
	jmp	DWORD PTR $LN14@xmlXPathCa[eax*4]
$LN6@xmlXPathCa:

; 2704 : 	    case XPATH_NODESET:
; 2705 : 		return(xmlXPathCacheWrapNodeSet(ctxt,

	push	DWORD PTR [ecx+4]
	push	0
	call	_xmlXPathNodeSetMerge
	push	eax
	push	esi
	call	_xmlXPathCacheWrapNodeSet
	add	esp, 16					; 00000010H
	pop	esi

; 2718 : }

	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 2706 : 		    xmlXPathNodeSetMerge(NULL, val->nodesetval)));
; 2707 : 	    case XPATH_STRING:
; 2708 : 		return(xmlXPathCacheNewString(ctxt, val->stringval));

	push	DWORD PTR [ecx+24]
	push	esi
	call	_xmlXPathCacheNewString
	add	esp, 8
	pop	esi

; 2718 : }

	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 2709 : 	    case XPATH_BOOLEAN:
; 2710 : 		return(xmlXPathCacheNewBoolean(ctxt, val->boolval));

	push	DWORD PTR [ecx+8]
	push	esi
	call	_xmlXPathCacheNewBoolean
	add	esp, 8
	pop	esi

; 2718 : }

	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 2711 : 	    case XPATH_NUMBER:
; 2712 : 		return(xmlXPathCacheNewFloat(ctxt, val->floatval));

	movsd	xmm0, QWORD PTR [ecx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	esi
	call	_xmlXPathCacheNewFloat
	add	esp, 12					; 0000000cH
	pop	esi

; 2718 : }

	pop	ebp
	ret	0
$LN10@xmlXPathCa:

; 2713 : 	    default:
; 2714 : 		break;
; 2715 : 	}
; 2716 :     }
; 2717 :     return(xmlXPathObjectCopy(val));

	push	ecx
	call	_xmlXPathObjectCopy
	add	esp, 4
	pop	esi

; 2718 : }

	pop	ebp
	ret	0
	npad	2
$LN14@xmlXPathCa:
	DD	$LN6@xmlXPathCa
	DD	$LN8@xmlXPathCa
	DD	$LN9@xmlXPathCa
	DD	$LN7@xmlXPathCa
_xmlXPathCacheObjectCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheConvertString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheConvertString PROC			; COMDAT

; 2649 : xmlXPathCacheConvertString(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	xor	ebx, ebx
	test	edi, edi
	jne	SHORT $LN4@xmlXPathCa

; 2684 : }

	pop	edi
	pop	ebx

; 2650 :     xmlChar *res = NULL;
; 2651 : 
; 2652 :     if (val == NULL)
; 2653 : 	return(xmlXPathCacheNewCString(ctxt, ""));

	mov	DWORD PTR _val$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 2684 : }

	pop	ebp

; 2650 :     xmlChar *res = NULL;
; 2651 : 
; 2652 :     if (val == NULL)
; 2653 : 	return(xmlXPathCacheNewCString(ctxt, ""));

	jmp	_xmlXPathCacheNewCString
$LN4@xmlXPathCa:

; 2654 : 
; 2655 :     switch (val->type) {

	mov	eax, DWORD PTR [edi]
	dec	eax
	push	esi
	cmp	eax, 8
	ja	SHORT $LN2@xmlXPathCa
	jmp	DWORD PTR $LN18@xmlXPathCa[eax*4]
$LN6@xmlXPathCa:

; 2656 :     case XPATH_UNDEFINED:
; 2657 : #ifdef DEBUG_EXPR
; 2658 : 	xmlGenericError(xmlGenericErrorContext, "STRING: undefined\n");
; 2659 : #endif
; 2660 : 	break;
; 2661 :     case XPATH_NODESET:
; 2662 :     case XPATH_XSLT_TREE:
; 2663 : 	res = xmlXPathCastNodeSetToString(val->nodesetval);

	push	DWORD PTR [edi+4]
	call	_xmlXPathCastNodeSetToString
	add	esp, 4
	mov	ebx, eax

; 2664 : 	break;

	jmp	SHORT $LN2@xmlXPathCa
$LN7@xmlXPathCa:
	pop	esi

; 2665 :     case XPATH_STRING:
; 2666 : 	return(val);

	mov	eax, edi
	pop	edi

; 2684 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 2667 :     case XPATH_BOOLEAN:
; 2668 : 	res = xmlXPathCastBooleanToString(val->boolval);

	push	DWORD PTR [edi+8]
	call	_xmlXPathCastBooleanToString
	add	esp, 4
	mov	ebx, eax

; 2669 : 	break;

	jmp	SHORT $LN2@xmlXPathCa
$LN9@xmlXPathCa:

; 2670 :     case XPATH_NUMBER:
; 2671 : 	res = xmlXPathCastNumberToString(val->floatval);

	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToString
	add	esp, 8
	mov	ebx, eax

; 2672 : 	break;

	jmp	SHORT $LN2@xmlXPathCa
$LN10@xmlXPathCa:

; 2673 :     case XPATH_USERS:
; 2674 :     case XPATH_POINT:
; 2675 :     case XPATH_RANGE:
; 2676 :     case XPATH_LOCATIONSET:
; 2677 : 	TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2677					; 00000a75H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN2@xmlXPathCa:

; 2678 : 	break;
; 2679 :     }
; 2680 :     xmlXPathReleaseObject(ctxt, val);

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	push	esi
	call	_xmlXPathReleaseObject
	add	esp, 8

; 2681 :     if (res == NULL)

	test	ebx, ebx
	jne	SHORT $LN11@xmlXPathCa

; 2682 : 	return(xmlXPathCacheNewCString(ctxt, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	esi
	call	_xmlXPathCacheNewCString

; 2684 : }

	add	esp, 8
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlXPathCa:

; 2683 :     return(xmlXPathCacheWrapString(ctxt, res));

	push	ebx
	push	esi
	call	_xmlXPathCacheWrapString

; 2684 : }

	add	esp, 8
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret	0
$LN18@xmlXPathCa:
	DD	$LN6@xmlXPathCa
	DD	$LN8@xmlXPathCa
	DD	$LN9@xmlXPathCa
	DD	$LN7@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN6@xmlXPathCa
_xmlXPathCacheConvertString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheNewFloat
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 8
_xmlXPathCacheNewFloat PROC				; COMDAT

; 2600 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2601 :      if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2602 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2603 : 
; 2604 : 	if ((cache->numberObjs != NULL) &&

	mov	edx, DWORD PTR [eax+12]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2605 : 	    (cache->numberObjs->number != 0))
; 2606 : 	{
; 2607 : 	    xmlXPathObjectPtr ret;
; 2608 : 
; 2609 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+12]
$LN7@xmlXPathCa:

; 2634 : }

	mov	eax, DWORD PTR [eax]
	movsd	xmm0, QWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax], 3
	movsd	QWORD PTR [eax+16], xmm0
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2610 : 		cache->numberObjs->items[--cache->numberObjs->number];
; 2611 : 	    ret->type = XPATH_NUMBER;
; 2612 : 	    ret->floatval = val;
; 2613 : #ifdef XP_DEBUG_OBJ_USAGE
; 2614 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);
; 2615 : #endif
; 2616 : 	    return(ret);
; 2617 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN5@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCa

; 2618 : 	    (cache->miscObjs->number != 0))
; 2619 : 	{
; 2620 : 	    xmlXPathObjectPtr ret;
; 2621 : 
; 2622 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]

; 2623 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2624 : 
; 2625 : 	    ret->type = XPATH_NUMBER;
; 2626 : 	    ret->floatval = val;
; 2627 : #ifdef XP_DEBUG_OBJ_USAGE
; 2628 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);
; 2629 : #endif
; 2630 : 	    return(ret);

	jmp	SHORT $LN7@xmlXPathCa
$LN5@xmlXPathCa:

; 2631 : 	}
; 2632 :     }
; 2633 :     return(xmlXPathNewFloat(val));

	movsd	xmm0, QWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathNewFloat
	add	esp, 8

; 2634 : }

	pop	ebp
	ret	0
_xmlXPathCacheNewFloat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheNewBoolean
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheNewBoolean PROC				; COMDAT

; 2552 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2553 :     if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2554 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2555 : 
; 2556 : 	if ((cache->booleanObjs != NULL) &&

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2557 : 	    (cache->booleanObjs->number != 0))
; 2558 : 	{
; 2559 : 	    xmlXPathObjectPtr ret;
; 2560 : 
; 2561 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
$LN7@xmlXPathCa:

; 2586 : }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]
	xor	ecx, ecx
	cmp	DWORD PTR _val$[ebp], ecx
	setne	cl
	mov	DWORD PTR [eax], 2
	mov	DWORD PTR [eax+8], ecx
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2562 : 		cache->booleanObjs->items[--cache->booleanObjs->number];
; 2563 : 	    ret->type = XPATH_BOOLEAN;
; 2564 : 	    ret->boolval = (val != 0);
; 2565 : #ifdef XP_DEBUG_OBJ_USAGE
; 2566 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);
; 2567 : #endif
; 2568 : 	    return(ret);
; 2569 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN5@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCa

; 2570 : 	    (cache->miscObjs->number != 0))
; 2571 : 	{
; 2572 : 	    xmlXPathObjectPtr ret;
; 2573 : 
; 2574 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]

; 2575 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2576 : 
; 2577 : 	    ret->type = XPATH_BOOLEAN;
; 2578 : 	    ret->boolval = (val != 0);
; 2579 : #ifdef XP_DEBUG_OBJ_USAGE
; 2580 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);
; 2581 : #endif
; 2582 : 	    return(ret);

	jmp	SHORT $LN7@xmlXPathCa
$LN5@xmlXPathCa:

; 2583 : 	}
; 2584 :     }
; 2585 :     return(xmlXPathNewBoolean(val));

	push	DWORD PTR _val$[ebp]
	call	_xmlXPathNewBoolean
	add	esp, 4

; 2586 : }

	pop	ebp
	ret	0
_xmlXPathCacheNewBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheNewString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheNewString PROC				; COMDAT

; 2498 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR _val$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlXPathCa

; 2499 :     if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN7@xmlXPathCa

; 2500 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2501 : 
; 2502 : 	if ((cache->stringObjs != NULL) &&

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2503 : 	    (cache->stringObjs->number != 0))
; 2504 : 	{
; 2505 : 	    xmlXPathObjectPtr ret;
; 2506 : 
; 2507 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+4]
$LN12@xmlXPathCa:

; 2538 : }

	mov	eax, DWORD PTR [eax]
	test	edi, edi
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@@
	cmovne	ecx, edi
	push	ecx
	mov	DWORD PTR [esi], 4
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2508 : 		cache->stringObjs->items[--cache->stringObjs->number];
; 2509 : 	    ret->type = XPATH_STRING;
; 2510 : 	    if (val != NULL)
; 2511 : 		ret->stringval = xmlStrdup(val);
; 2512 : 	    else
; 2513 : 		ret->stringval = xmlStrdup((const xmlChar *)"");
; 2514 : #ifdef XP_DEBUG_OBJ_USAGE
; 2515 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2516 : #endif
; 2517 : 	    return(ret);
; 2518 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN7@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPathCa

; 2519 : 	    (cache->miscObjs->number != 0))
; 2520 : 	{
; 2521 : 	    xmlXPathObjectPtr ret;
; 2522 : 
; 2523 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]

; 2524 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2525 : 
; 2526 : 	    ret->type = XPATH_STRING;
; 2527 : 	    if (val != NULL)
; 2528 : 		ret->stringval = xmlStrdup(val);
; 2529 : 	    else
; 2530 : 		ret->stringval = xmlStrdup((const xmlChar *)"");
; 2531 : #ifdef XP_DEBUG_OBJ_USAGE
; 2532 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2533 : #endif
; 2534 : 	    return(ret);

	jmp	SHORT $LN12@xmlXPathCa
$LN7@xmlXPathCa:

; 2535 : 	}
; 2536 :     }
; 2537 :     return(xmlXPathNewString(val));

	push	edi
	call	_xmlXPathNewString

; 2538 : }

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathCacheNewString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheNewCString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheNewCString PROC				; COMDAT

; 2449 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2450 :     if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2451 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2452 : 
; 2453 : 	if ((cache->stringObjs != NULL) &&

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2454 : 	    (cache->stringObjs->number != 0))
; 2455 : 	{
; 2456 : 	    xmlXPathObjectPtr ret;
; 2457 : 
; 2458 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+4]
$LN8@xmlXPathCa:

; 2484 : }

	mov	eax, DWORD PTR [eax]
	push	DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi], 4
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2459 : 		cache->stringObjs->items[--cache->stringObjs->number];
; 2460 : 
; 2461 : 	    ret->type = XPATH_STRING;
; 2462 : 	    ret->stringval = xmlStrdup(BAD_CAST val);
; 2463 : #ifdef XP_DEBUG_OBJ_USAGE
; 2464 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2465 : #endif
; 2466 : 	    return(ret);
; 2467 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN5@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCa

; 2468 : 	    (cache->miscObjs->number != 0))
; 2469 : 	{
; 2470 : 	    xmlXPathObjectPtr ret;
; 2471 : 
; 2472 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]

; 2473 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2474 : 
; 2475 : 	    ret->type = XPATH_STRING;
; 2476 : 	    ret->stringval = xmlStrdup(BAD_CAST val);
; 2477 : #ifdef XP_DEBUG_OBJ_USAGE
; 2478 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2479 : #endif
; 2480 : 	    return(ret);

	jmp	SHORT $LN8@xmlXPathCa
$LN5@xmlXPathCa:

; 2481 : 	}
; 2482 :     }
; 2483 :     return(xmlXPathNewCString(val));

	push	DWORD PTR _val$[ebp]
	call	_xmlXPathNewCString

; 2484 : }

	add	esp, 4
	pop	esi
	pop	ebp
	ret	0
_xmlXPathCacheNewCString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheNewNodeSet
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheNewNodeSet PROC				; COMDAT

; 2380 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN9@xmlXPathCa

; 2381 :     if ((ctxt != NULL) && (ctxt->cache)) {

	mov	eax, DWORD PTR [esi+200]
	test	eax, eax
	je	$LN9@xmlXPathCa

; 2382 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2383 : 
; 2384 : 	if ((cache->nodesetObjs != NULL) &&

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2385 : 	    (cache->nodesetObjs->number != 0))
; 2386 : 	{
; 2387 : 	    xmlXPathObjectPtr ret;
; 2388 : 	    /*
; 2389 : 	    * Use the nodset-cache.
; 2390 : 	    */
; 2391 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2392 : 		cache->nodesetObjs->items[--cache->nodesetObjs->number];
; 2393 : 	    ret->type = XPATH_NODESET;
; 2394 : 	    ret->boolval = 0;
; 2395 : 	    if (val) {

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+8], 0
	test	ecx, ecx
	je	SHORT $LN7@xmlXPathCa

; 2396 : 		if ((ret->nodesetval->nodeMax == 0) ||

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@xmlXPathCa
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPathCa

; 2400 : 		} else {
; 2401 : 		    ret->nodesetval->nodeTab[0] = val;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ecx

; 2402 : 		    ret->nodesetval->nodeNr = 1;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], 1

; 2403 : 		}
; 2404 : 	    }
; 2405 : #ifdef XP_DEBUG_OBJ_USAGE
; 2406 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
; 2407 : #endif
; 2408 : 	    return(ret);

	mov	eax, esi
	pop	esi

; 2435 : }

	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 2397 : 		    (val->type == XML_NAMESPACE_DECL))
; 2398 : 		{
; 2399 : 		    xmlXPathNodeSetAddUnique(ret->nodesetval, val);

	push	ecx
	push	eax
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
$LN7@xmlXPathCa:

; 2403 : 		}
; 2404 : 	    }
; 2405 : #ifdef XP_DEBUG_OBJ_USAGE
; 2406 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
; 2407 : #endif
; 2408 : 	    return(ret);

	mov	eax, esi
	pop	esi

; 2435 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2409 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN9@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN9@xmlXPathCa

; 2410 : 	    (cache->miscObjs->number != 0))
; 2411 : 	{
; 2412 : 	    xmlXPathObjectPtr ret;
; 2413 : 	    /*
; 2414 : 	    * Fallback to misc-cache.
; 2415 : 	    */
; 2416 : 
; 2417 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]
	push	edi

; 2418 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2419 : 
; 2420 : 	    ret->type = XPATH_NODESET;
; 2421 : 	    ret->boolval = 0;
; 2422 : 	    ret->nodesetval = xmlXPathNodeSetCreate(val);

	push	DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+8], 0
	call	_xmlXPathNodeSetCreate
	add	esp, 4
	mov	DWORD PTR [edi+4], eax

; 2423 : 	    if (ret->nodesetval == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlXPathCa

; 2424 : 		ctxt->lastError.domain = XML_FROM_XPATH;

	pop	edi
	mov	DWORD PTR [esi+136], 12			; 0000000cH

; 2425 : 		ctxt->lastError.code = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [esi+140], 2
	pop	esi

; 2435 : }

	pop	ebp
	ret	0
$LN10@xmlXPathCa:

; 2426 : 		return(NULL);
; 2427 : 	    }
; 2428 : #ifdef XP_DEBUG_OBJ_USAGE
; 2429 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
; 2430 : #endif
; 2431 : 	    return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 2435 : }

	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 2432 : 	}
; 2433 :     }
; 2434 :     return(xmlXPathNewNodeSet(val));

	push	DWORD PTR _val$[ebp]
	call	_xmlXPathNewNodeSet
	add	esp, 4
	pop	esi

; 2435 : }

	pop	ebp
	ret	0
_xmlXPathCacheNewNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheWrapString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheWrapString PROC				; COMDAT

; 2328 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2329 :     if ((ctxt != NULL) && (ctxt->cache != NULL)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN5@xmlXPathCa

; 2330 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2331 : 
; 2332 : 	if ((cache->stringObjs != NULL) &&

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2333 : 	    (cache->stringObjs->number != 0))
; 2334 : 	{
; 2335 : 
; 2336 : 	    xmlXPathObjectPtr ret;
; 2337 : 
; 2338 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+4]

; 2365 : }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+24], ecx
	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2339 : 		cache->stringObjs->items[--cache->stringObjs->number];
; 2340 : 	    ret->type = XPATH_STRING;
; 2341 : 	    ret->stringval = val;
; 2342 : #ifdef XP_DEBUG_OBJ_USAGE
; 2343 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2344 : #endif
; 2345 : 	    return(ret);
; 2346 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN5@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCa

; 2347 : 	    (cache->miscObjs->number != 0))
; 2348 : 	{
; 2349 : 	    xmlXPathObjectPtr ret;
; 2350 : 	    /*
; 2351 : 	    * Fallback to misc-cache.
; 2352 : 	    */
; 2353 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]

; 2365 : }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+24], ecx
	pop	ebp
	ret	0
$LN5@xmlXPathCa:

; 2354 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2355 : 
; 2356 : 	    ret->type = XPATH_STRING;
; 2357 : 	    ret->stringval = val;
; 2358 : #ifdef XP_DEBUG_OBJ_USAGE
; 2359 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);
; 2360 : #endif
; 2361 : 	    return(ret);
; 2362 : 	}
; 2363 :     }
; 2364 :     return(xmlXPathWrapString(val));

	push	DWORD PTR _val$[ebp]
	call	_xmlXPathWrapString
	add	esp, 4

; 2365 : }

	pop	ebp
	ret	0
_xmlXPathCacheWrapString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheWrapNodeSet
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathCacheWrapNodeSet PROC				; COMDAT

; 2291 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 2292 :     if ((ctxt != NULL) && (ctxt->cache != NULL)) {

	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 2293 : 	xmlXPathContextCachePtr cache =
; 2294 : 	    (xmlXPathContextCachePtr) ctxt->cache;
; 2295 : 
; 2296 : 	if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN3@xmlXPathCa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa

; 2297 : 	    (cache->miscObjs->number != 0))
; 2298 : 	{
; 2299 : 	    xmlXPathObjectPtr ret;
; 2300 : 
; 2301 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2302 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2303 : 	    ret->type = XPATH_NODESET;
; 2304 : 	    ret->nodesetval = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], ecx

; 2313 : 
; 2314 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 2305 : #ifdef XP_DEBUG_OBJ_USAGE
; 2306 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
; 2307 : #endif
; 2308 : 	    return(ret);
; 2309 : 	}
; 2310 :     }
; 2311 : 
; 2312 :     return(xmlXPathWrapNodeSet(val));

	push	DWORD PTR _val$[ebp]
	call	_xmlXPathWrapNodeSet
	add	esp, 4

; 2313 : 
; 2314 : }

	pop	ebp
	ret	0
_xmlXPathCacheWrapNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeCache
_TEXT	SEGMENT
_cache$ = 8						; size = 4
_xmlXPathFreeCache PROC					; COMDAT

; 2208 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cache$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathFr

; 2209 :     if (cache == NULL)
; 2210 : 	return;
; 2211 :     if (cache->nodesetObjs)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlXPathFr

; 2212 : 	xmlXPathCacheFreeObjectList(cache->nodesetObjs);

	push	eax
	call	_xmlXPathCacheFreeObjectList
	add	esp, 4
$LN3@xmlXPathFr:

; 2213 :     if (cache->stringObjs)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@xmlXPathFr

; 2214 : 	xmlXPathCacheFreeObjectList(cache->stringObjs);

	push	eax
	call	_xmlXPathCacheFreeObjectList
	add	esp, 4
$LN4@xmlXPathFr:

; 2215 :     if (cache->booleanObjs)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@xmlXPathFr

; 2216 : 	xmlXPathCacheFreeObjectList(cache->booleanObjs);

	push	eax
	call	_xmlXPathCacheFreeObjectList
	add	esp, 4
$LN5@xmlXPathFr:

; 2217 :     if (cache->numberObjs)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@xmlXPathFr

; 2218 : 	xmlXPathCacheFreeObjectList(cache->numberObjs);

	push	eax
	call	_xmlXPathCacheFreeObjectList
	add	esp, 4
$LN6@xmlXPathFr:

; 2219 :     if (cache->miscObjs)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN7@xmlXPathFr

; 2220 : 	xmlXPathCacheFreeObjectList(cache->miscObjs);

	push	eax
	call	_xmlXPathCacheFreeObjectList
	add	esp, 4
$LN7@xmlXPathFr:

; 2221 :     xmlFree(cache);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPathFr:
	pop	esi

; 2222 : }

	pop	ebp
	ret	0
_xmlXPathFreeCache ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCacheFreeObjectList
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlXPathCacheFreeObjectList PROC			; COMDAT

; 2180 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _list$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlXPathCa

; 2181 :     int i;
; 2182 :     xmlXPathObjectPtr obj;
; 2183 : 
; 2184 :     if (list == NULL)
; 2185 : 	return;
; 2186 : 
; 2187 :     for (i = 0; i < list->number; i++) {

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [edi+4], esi
	jle	SHORT $LN3@xmlXPathCa
	push	ebx
	npad	2
$LL4@xmlXPathCa:

; 2188 : 	obj = list->items[i];

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+esi*4]

; 2189 : 	/*
; 2190 : 	* Note that it is already assured that we don't need to
; 2191 : 	* look out for namespace nodes in the node-set.
; 2192 : 	*/
; 2193 : 	if (obj->nodesetval != NULL) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN6@xmlXPathCa

; 2194 : 	    if (obj->nodesetval->nodeTab != NULL)

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN17@xmlXPathCa

; 2195 : 		xmlFree(obj->nodesetval->nodeTab);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 4
$LN17@xmlXPathCa:

; 2196 : 	    xmlFree(obj->nodesetval);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlXPathCa:

; 2197 : 	}
; 2198 : 	xmlFree(obj);

	push	ebx
	call	DWORD PTR _xmlFree
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL4@xmlXPathCa
	pop	ebx
$LN3@xmlXPathCa:

; 845  :     if (list->items != NULL)

	mov	eax, DWORD PTR [edi]
	pop	esi
	test	eax, eax
	je	SHORT $LN11@xmlXPathCa

; 846  : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN11@xmlXPathCa:

; 847  :     xmlFree(list);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN9@xmlXPathCa:
	pop	edi

; 2199 : #ifdef XP_DEBUG_OBJ_USAGE
; 2200 : 	xmlXPathDebugObjCounterAll--;
; 2201 : #endif
; 2202 :     }
; 2203 :     xmlPointerListFree(list);
; 2204 : }

	pop	ebp
	ret	0
_xmlXPathCacheFreeObjectList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewCache
_TEXT	SEGMENT
_xmlXPathNewCache PROC					; COMDAT
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2162 :     xmlXPathContextCachePtr ret;
; 2163 : 
; 2164 :     ret = (xmlXPathContextCachePtr) xmlMalloc(sizeof(xmlXPathContextCache));
; 2165 :     if (ret == NULL) {
; 2166 :         xmlXPathErrMemory(NULL, "creating object cache\n");
; 2167 : 	return(NULL);

	xor	eax, eax

; 2175 :     return(ret);
; 2176 : }

	ret	0
$LN2@xmlXPathNe:

; 2168 :     }
; 2169 :     memset(ret, 0 , (size_t) sizeof(xmlXPathContextCache));

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0

; 2170 :     ret->maxNodeset = 100;

	mov	DWORD PTR [eax+20], 100			; 00000064H

; 2171 :     ret->maxString = 100;

	mov	DWORD PTR [eax+24], 100			; 00000064H

; 2172 :     ret->maxBoolean = 100;

	mov	DWORD PTR [eax+28], 100			; 00000064H

; 2173 :     ret->maxNumber = 100;

	mov	DWORD PTR [eax+32], 100			; 00000064H

; 2174 :     ret->maxMisc = 100;

	mov	DWORD PTR [eax+36], 100			; 00000064H

; 2175 :     return(ret);
; 2176 : }

	ret	0
_xmlXPathNewCache ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpStepOp
_TEXT	SEGMENT
_shift$ = -112						; size = 100
_name$1$ = -12						; size = 4
_prefix$1$ = -8						; size = 4
_type$1$ = -4						; size = 4
_output$ = 8						; size = 4
_comp$ = 12						; size = 4
_test$1$ = 16						; size = 4
_op$ = 16						; size = 4
tv755 = 20						; size = 4
_depth$ = 20						; size = 4
_xmlXPathDebugDumpStepOp PROC				; COMDAT

; 1470 : 	                     xmlXPathStepOpPtr op, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN87@xmlXPathDe
	npad	7
$LL4@xmlXPathDe:

; 1471 :     int i;
; 1472 :     char shift[100];
; 1473 : 
; 1474 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	eax, 25					; 00000019H
	jge	SHORT $LN87@xmlXPathDe

; 1475 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL4@xmlXPathDe
$LN87@xmlXPathDe:
	push	ebx
	push	edi

; 1476 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 1477 : 
; 1478 :     fprintf(output, "%s", shift);

	mov	edi, DWORD PTR _output$[ebp]
	mov	WORD PTR _shift$[ebp+eax*2], 0
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1479 :     if (op == NULL) {

	mov	ebx, DWORD PTR _op$[ebp]
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	jne	SHORT $LN13@xmlXPathDe

; 1480 : 	fprintf(output, "Step is NULL\n");

	push	OFFSET ??_C@_0O@IEEDPMEL@Step?5is?5NULL?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	edi

; 1641 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathDe:

; 1481 : 	return;
; 1482 :     }
; 1483 :     switch (op->op) {

	mov	eax, DWORD PTR [ebx]
	push	esi
	cmp	eax, 18					; 00000012H
	ja	$LN78@xmlXPathDe
	jmp	DWORD PTR $LN94@xmlXPathDe[eax*4]
$LN14@xmlXPathDe:

; 1484 :         case XPATH_OP_END:
; 1485 : 	    fprintf(output, "END"); break;

	push	OFFSET ??_C@_03JMGAKCCH@END@
	jmp	$LN89@xmlXPathDe
$LN15@xmlXPathDe:

; 1486 :         case XPATH_OP_AND:
; 1487 : 	    fprintf(output, "AND"); break;

	push	OFFSET ??_C@_03BDACDFHA@AND@
	jmp	$LN89@xmlXPathDe
$LN16@xmlXPathDe:

; 1488 :         case XPATH_OP_OR:
; 1489 : 	    fprintf(output, "OR"); break;

	push	OFFSET ??_C@_02PDPFNDMG@OR@
	jmp	$LN89@xmlXPathDe
$LN17@xmlXPathDe:

; 1490 :         case XPATH_OP_EQUAL:
; 1491 : 	     if (op->value)
; 1492 : 		 fprintf(output, "EQUAL =");
; 1493 : 	     else
; 1494 : 		 fprintf(output, "EQUAL !=");
; 1495 : 	     break;

	cmp	DWORD PTR [ebx+12], 0
	mov	eax, OFFSET ??_C@_08MPMADPIH@EQUAL?5?$CB?$DN@
	mov	ecx, OFFSET ??_C@_07MELFAPHK@EQUAL?5?$DN@
	cmovne	eax, ecx
	push	eax
	jmp	$LN89@xmlXPathDe
$LN20@xmlXPathDe:

; 1496 :         case XPATH_OP_CMP:
; 1497 : 	     if (op->value)
; 1498 : 		 fprintf(output, "CMP <");
; 1499 : 	     else
; 1500 : 		 fprintf(output, "CMP >");
; 1501 : 	     if (!op->value2)

	cmp	DWORD PTR [ebx+12], 0
	mov	ecx, OFFSET ??_C@_05OHCBIKNL@CMP?5?$DM@
	mov	eax, OFFSET ??_C@_05NFBHOIFJ@CMP?5?$DO@
	cmovne	eax, ecx
	push	eax
	push	edi
	call	_fprintf
	add	esp, 8
	cmp	DWORD PTR [ebx+16], 0
	jne	$LN5@xmlXPathDe

; 1502 : 		 fprintf(output, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@

; 1503 : 	     break;

	jmp	$LN89@xmlXPathDe
$LN24@xmlXPathDe:

; 1504 :         case XPATH_OP_PLUS:
; 1505 : 	     if (op->value == 0)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	jne	SHORT $LN25@xmlXPathDe

; 1506 : 		 fprintf(output, "PLUS -");

	push	OFFSET ??_C@_06IPAPPNJ@PLUS?5?9@
	jmp	$LN89@xmlXPathDe
$LN25@xmlXPathDe:

; 1507 : 	     else if (op->value == 1)

	cmp	eax, 1
	jne	SHORT $LN27@xmlXPathDe

; 1508 : 		 fprintf(output, "PLUS +");

	push	OFFSET ??_C@_06FOKKFIFP@PLUS?5?$CL@
	jmp	$LN89@xmlXPathDe
$LN27@xmlXPathDe:

; 1509 : 	     else if (op->value == 2)

	cmp	eax, 2
	jne	SHORT $LN29@xmlXPathDe

; 1510 : 		 fprintf(output, "PLUS unary -");

	push	OFFSET ??_C@_0N@GEIAIOPG@PLUS?5unary?5?9@
	jmp	$LN89@xmlXPathDe
$LN29@xmlXPathDe:

; 1511 : 	     else if (op->value == 3)

	cmp	eax, 3
	jne	$LN5@xmlXPathDe

; 1512 : 		 fprintf(output, "PLUS unary - -");

	push	OFFSET ??_C@_0P@FAIBJAJD@PLUS?5unary?5?9?5?9@

; 1513 : 	     break;

	jmp	$LN89@xmlXPathDe
$LN32@xmlXPathDe:

; 1514 :         case XPATH_OP_MULT:
; 1515 : 	     if (op->value == 0)

	mov	ecx, DWORD PTR [ebx+12]
	test	ecx, ecx
	jne	SHORT $LN33@xmlXPathDe

; 1516 : 		 fprintf(output, "MULT *");

	mov	eax, OFFSET ??_C@_06JFEGAKAJ@MULT?5?$CK@

; 1518 : 		 fprintf(output, "MULT div");
; 1519 : 	     else
; 1520 : 		 fprintf(output, "MULT mod");
; 1521 : 	     break;

	push	eax
	jmp	$LN89@xmlXPathDe
$LN33@xmlXPathDe:

; 1517 : 	     else if (op->value == 1)

	cmp	ecx, 1
	mov	eax, OFFSET ??_C@_08HELPMGMA@MULT?5div@
	mov	edx, OFFSET ??_C@_08HFMOIFCL@MULT?5mod@
	cmovne	eax, edx

; 1518 : 		 fprintf(output, "MULT div");
; 1519 : 	     else
; 1520 : 		 fprintf(output, "MULT mod");
; 1521 : 	     break;

	push	eax
	jmp	$LN89@xmlXPathDe
$LN37@xmlXPathDe:

; 1522 :         case XPATH_OP_UNION:
; 1523 : 	     fprintf(output, "UNION"); break;

	push	OFFSET ??_C@_05GJNJOPB@UNION@
	jmp	$LN89@xmlXPathDe
$LN38@xmlXPathDe:

; 1524 :         case XPATH_OP_ROOT:
; 1525 : 	     fprintf(output, "ROOT"); break;

	push	OFFSET ??_C@_04BNGIIOIP@ROOT@
	jmp	$LN89@xmlXPathDe
$LN39@xmlXPathDe:

; 1526 :         case XPATH_OP_NODE:
; 1527 : 	     fprintf(output, "NODE"); break;

	push	OFFSET ??_C@_04OHPEDIPN@NODE@
	jmp	$LN89@xmlXPathDe
$LN40@xmlXPathDe:

; 1528 :         case XPATH_OP_SORT:
; 1529 : 	     fprintf(output, "SORT"); break;

	push	OFFSET ??_C@_04DEPGJHBM@SORT@
	jmp	$LN89@xmlXPathDe
$LN41@xmlXPathDe:

; 1530 :         case XPATH_OP_COLLECT: {
; 1531 : 	    xmlXPathAxisVal axis = (xmlXPathAxisVal)op->value;
; 1532 : 	    xmlXPathTestVal test = (xmlXPathTestVal)op->value2;

	mov	eax, DWORD PTR [ebx+16]
	mov	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR _test$1$[ebp], eax

; 1533 : 	    xmlXPathTypeVal type = (xmlXPathTypeVal)op->value3;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR _type$1$[ebp], eax

; 1534 : 	    const xmlChar *prefix = op->value4;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _prefix$1$[ebp], eax

; 1535 : 	    const xmlChar *name = op->value5;

	mov	eax, DWORD PTR [ebx+28]

; 1536 : 
; 1537 : 	    fprintf(output, "COLLECT ");

	push	OFFSET ??_C@_08BCOGFDOM@COLLECT?5@
	push	edi
	mov	DWORD PTR _name$1$[ebp], eax
	call	_fprintf

; 1538 : 	    switch (axis) {

	dec	esi
	add	esp, 8
	cmp	esi, 12					; 0000000cH
	ja	SHORT $LN7@xmlXPathDe
	jmp	DWORD PTR $LN95@xmlXPathDe[esi*4]
$LN42@xmlXPathDe:

; 1539 : 		case AXIS_ANCESTOR:
; 1540 : 		    fprintf(output, " 'ancestors' "); break;

	push	OFFSET ??_C@_0O@CBBIECFC@?5?8ancestors?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN43@xmlXPathDe:

; 1541 : 		case AXIS_ANCESTOR_OR_SELF:
; 1542 : 		    fprintf(output, " 'ancestors-or-self' "); break;

	push	OFFSET ??_C@_0BG@IJDLJMNP@?5?8ancestors?9or?9self?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN44@xmlXPathDe:

; 1543 : 		case AXIS_ATTRIBUTE:
; 1544 : 		    fprintf(output, " 'attributes' "); break;

	push	OFFSET ??_C@_0P@IMBNHOPA@?5?8attributes?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN45@xmlXPathDe:

; 1545 : 		case AXIS_CHILD:
; 1546 : 		    fprintf(output, " 'child' "); break;

	push	OFFSET ??_C@_09DMHOAOKE@?5?8child?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN46@xmlXPathDe:

; 1547 : 		case AXIS_DESCENDANT:
; 1548 : 		    fprintf(output, " 'descendant' "); break;

	push	OFFSET ??_C@_0P@COPGHIIE@?5?8descendant?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN47@xmlXPathDe:

; 1549 : 		case AXIS_DESCENDANT_OR_SELF:
; 1550 : 		    fprintf(output, " 'descendant-or-self' "); break;

	push	OFFSET ??_C@_0BH@OLEEPEHL@?5?8descendant?9or?9self?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN48@xmlXPathDe:

; 1551 : 		case AXIS_FOLLOWING:
; 1552 : 		    fprintf(output, " 'following' "); break;

	push	OFFSET ??_C@_0O@HPGIPOGE@?5?8following?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN49@xmlXPathDe:

; 1553 : 		case AXIS_FOLLOWING_SIBLING:
; 1554 : 		    fprintf(output, " 'following-siblings' "); break;

	push	OFFSET ??_C@_0BH@KMMFLMJK@?5?8following?9siblings?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN50@xmlXPathDe:

; 1555 : 		case AXIS_NAMESPACE:
; 1556 : 		    fprintf(output, " 'namespace' "); break;

	push	OFFSET ??_C@_0O@DIAKOKEE@?5?8namespace?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN51@xmlXPathDe:

; 1557 : 		case AXIS_PARENT:
; 1558 : 		    fprintf(output, " 'parent' "); break;

	push	OFFSET ??_C@_0L@BKJAGPFG@?5?8parent?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN52@xmlXPathDe:

; 1559 : 		case AXIS_PRECEDING:
; 1560 : 		    fprintf(output, " 'preceding' "); break;

	push	OFFSET ??_C@_0O@BNHFEBDE@?5?8preceding?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN53@xmlXPathDe:

; 1561 : 		case AXIS_PRECEDING_SIBLING:
; 1562 : 		    fprintf(output, " 'preceding-sibling' "); break;

	push	OFFSET ??_C@_0BG@LJHOBDKP@?5?8preceding?9sibling?8?5@
	jmp	SHORT $LN90@xmlXPathDe
$LN54@xmlXPathDe:

; 1563 : 		case AXIS_SELF:
; 1564 : 		    fprintf(output, " 'self' "); break;

	push	OFFSET ??_C@_08HAEBALG@?5?8self?8?5@
$LN90@xmlXPathDe:

; 1565 : 	    }
; 1566 : 	    switch (test) {

	push	edi
	call	_fprintf
	add	esp, 8
$LN7@xmlXPathDe:
	mov	eax, DWORD PTR _test$1$[ebp]
	cmp	eax, 5
	ja	SHORT $LN9@xmlXPathDe
	jmp	DWORD PTR $LN96@xmlXPathDe[eax*4]
$LN55@xmlXPathDe:

; 1567 :                 case NODE_TEST_NONE:
; 1568 : 		    fprintf(output, "'none' "); break;

	push	OFFSET ??_C@_07MJDJHLDE@?8none?8?5@
	jmp	SHORT $LN91@xmlXPathDe
$LN56@xmlXPathDe:

; 1569 :                 case NODE_TEST_TYPE:
; 1570 : 		    fprintf(output, "'type' "); break;

	push	OFFSET ??_C@_07MIHANB@?8type?8?5@
	jmp	SHORT $LN91@xmlXPathDe
$LN57@xmlXPathDe:

; 1571 :                 case NODE_TEST_PI:
; 1572 : 		    fprintf(output, "'PI' "); break;

	push	OFFSET ??_C@_05CCBNMHGJ@?8PI?8?5@
	jmp	SHORT $LN91@xmlXPathDe
$LN58@xmlXPathDe:

; 1573 :                 case NODE_TEST_ALL:
; 1574 : 		    fprintf(output, "'all' "); break;

	push	OFFSET ??_C@_06COJFFNFM@?8all?8?5@
	jmp	SHORT $LN91@xmlXPathDe
$LN59@xmlXPathDe:

; 1575 :                 case NODE_TEST_NS:
; 1576 : 		    fprintf(output, "'namespace' "); break;

	push	OFFSET ??_C@_0N@CLKBKNNJ@?8namespace?8?5@
	jmp	SHORT $LN91@xmlXPathDe
$LN60@xmlXPathDe:

; 1577 :                 case NODE_TEST_NAME:
; 1578 : 		    fprintf(output, "'name' "); break;

	push	OFFSET ??_C@_07LEJDGAJE@?8name?8?5@
$LN91@xmlXPathDe:

; 1579 : 	    }
; 1580 : 	    switch (type) {

	push	edi
	call	_fprintf
	add	esp, 8
$LN9@xmlXPathDe:
	mov	eax, DWORD PTR _type$1$[ebp]
	cmp	eax, 8
	ja	SHORT $LN11@xmlXPathDe
	jmp	DWORD PTR $LN97@xmlXPathDe[eax*4]
$LN61@xmlXPathDe:

; 1581 :                 case NODE_TYPE_NODE:
; 1582 : 		    fprintf(output, "'node' "); break;

	push	OFFSET ??_C@_07IDIJGDJF@?8node?8?5@
	jmp	SHORT $LN92@xmlXPathDe
$LN62@xmlXPathDe:

; 1583 :                 case NODE_TYPE_COMMENT:
; 1584 : 		    fprintf(output, "'comment' "); break;

	push	OFFSET ??_C@_0L@BBLKKJMH@?8comment?8?5@
	jmp	SHORT $LN92@xmlXPathDe
$LN63@xmlXPathDe:

; 1585 :                 case NODE_TYPE_TEXT:
; 1586 : 		    fprintf(output, "'text' "); break;

	push	OFFSET ??_C@_07KMAJMJAK@?8text?8?5@
	jmp	SHORT $LN92@xmlXPathDe
$LN64@xmlXPathDe:

; 1587 :                 case NODE_TYPE_PI:
; 1588 : 		    fprintf(output, "'PI' "); break;

	push	OFFSET ??_C@_05CCBNMHGJ@?8PI?8?5@
$LN92@xmlXPathDe:

; 1589 : 	    }
; 1590 : 	    if (prefix != NULL)

	push	edi
	call	_fprintf
	add	esp, 8
$LN11@xmlXPathDe:
	mov	eax, DWORD PTR _prefix$1$[ebp]
	test	eax, eax
	je	SHORT $LN65@xmlXPathDe

; 1591 : 		fprintf(output, "%s:", prefix);

	push	eax
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN65@xmlXPathDe:

; 1592 : 	    if (name != NULL)

	mov	eax, DWORD PTR _name$1$[ebp]
	test	eax, eax
	je	$LN5@xmlXPathDe

; 1593 : 		fprintf(output, "%s", (const char *) name);

	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1594 : 	    break;

	jmp	$LN5@xmlXPathDe
$LN67@xmlXPathDe:

; 1595 : 
; 1596 :         }
; 1597 : 	case XPATH_OP_VALUE: {
; 1598 : 	    xmlXPathObjectPtr object = (xmlXPathObjectPtr) op->value4;

	mov	esi, DWORD PTR [ebx+24]

; 1599 : 
; 1600 : 	    fprintf(output, "ELEM ");

	push	OFFSET ??_C@_05MNKHOCPF@ELEM?5@
	push	edi
	call	_fprintf

; 1601 : 	    xmlXPathDebugDumpObject(output, object, 0);

	push	0
	push	esi
	push	edi
	call	_xmlXPathDebugDumpObject
	add	esp, 20					; 00000014H

; 1602 : 	    goto finish;

	jmp	$finish$98
$LN68@xmlXPathDe:

; 1603 : 	}
; 1604 : 	case XPATH_OP_VARIABLE: {
; 1605 : 	    const xmlChar *prefix = op->value5;

	mov	ecx, DWORD PTR [ebx+28]

; 1606 : 	    const xmlChar *name = op->value4;

	mov	eax, DWORD PTR [ebx+24]

; 1607 : 
; 1608 : 	    if (prefix != NULL)

	push	eax
	test	ecx, ecx
	je	SHORT $LN69@xmlXPathDe

; 1609 : 		fprintf(output, "VARIABLE %s:%s", prefix, name);

	push	ecx
	push	OFFSET ??_C@_0P@MLBLHJNB@VARIABLE?5?$CFs?3?$CFs@
	push	edi
	call	_fprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@xmlXPathDe
$LN69@xmlXPathDe:

; 1610 : 	    else
; 1611 : 		fprintf(output, "VARIABLE %s", name);

	push	OFFSET ??_C@_0M@MLPGFJHH@VARIABLE?5?$CFs@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1612 : 	    break;

	jmp	SHORT $LN5@xmlXPathDe
$LN71@xmlXPathDe:

; 1613 : 	}
; 1614 : 	case XPATH_OP_FUNCTION: {
; 1615 : 	    int nbargs = op->value;

	mov	eax, DWORD PTR [ebx+12]

; 1616 : 	    const xmlChar *prefix = op->value5;

	mov	edx, DWORD PTR [ebx+28]

; 1617 : 	    const xmlChar *name = op->value4;

	mov	ecx, DWORD PTR [ebx+24]

; 1618 : 
; 1619 : 	    if (prefix != NULL)

	push	eax
	push	ecx
	test	edx, edx
	je	SHORT $LN72@xmlXPathDe

; 1620 : 		fprintf(output, "FUNCTION %s:%s(%d args)",

	push	edx
	push	OFFSET ??_C@_0BI@JIAOIFFJ@FUNCTION?5?$CFs?3?$CFs?$CI?$CFd?5args?$CJ@
	push	edi
	call	_fprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@xmlXPathDe
$LN72@xmlXPathDe:

; 1621 : 			prefix, name, nbargs);
; 1622 : 	    else
; 1623 : 		fprintf(output, "FUNCTION %s(%d args)", name, nbargs);

	push	OFFSET ??_C@_0BF@LKMAOONC@FUNCTION?5?$CFs?$CI?$CFd?5args?$CJ@
	push	edi
	call	_fprintf
	add	esp, 16					; 00000010H

; 1624 : 	    break;

	jmp	SHORT $LN5@xmlXPathDe
$LN74@xmlXPathDe:

; 1625 : 	}
; 1626 :         case XPATH_OP_ARG: fprintf(output, "ARG"); break;

	push	OFFSET ??_C@_03CNBDDMKH@ARG@
	jmp	SHORT $LN89@xmlXPathDe
$LN75@xmlXPathDe:

; 1627 :         case XPATH_OP_PREDICATE: fprintf(output, "PREDICATE"); break;

	push	OFFSET ??_C@_09NKOLJOJL@PREDICATE@
	jmp	SHORT $LN89@xmlXPathDe
$LN76@xmlXPathDe:

; 1628 :         case XPATH_OP_FILTER: fprintf(output, "FILTER"); break;

	push	OFFSET ??_C@_06EKKPGGCG@FILTER@
	jmp	SHORT $LN89@xmlXPathDe
$LN77@xmlXPathDe:

; 1629 : #ifdef LIBXML_XPTR_ENABLED
; 1630 :         case XPATH_OP_RANGETO: fprintf(output, "RANGETO"); break;

	push	OFFSET ??_C@_07LNDIAM@RANGETO@
$LN89@xmlXPathDe:

; 1634 :     }
; 1635 :     fprintf(output, "\n");

	push	edi
	call	_fprintf
	add	esp, 8
$LN5@xmlXPathDe:
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 8
$finish$98:

; 1636 : finish:
; 1637 :     if (op->ch1 >= 0)

	mov	ecx, DWORD PTR _depth$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	inc	ecx
	mov	esi, DWORD PTR _comp$[ebp]
	mov	DWORD PTR tv755[ebp], ecx
	test	eax, eax
	js	SHORT $LN85@xmlXPathDe

; 1638 : 	xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch1], depth + 1);

	push	ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	push	edi
	call	_xmlXPathDebugDumpStepOp
	mov	ecx, DWORD PTR tv755[ebp]
	add	esp, 16					; 00000010H
$LN85@xmlXPathDe:

; 1639 :     if (op->ch2 >= 0)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	js	SHORT $LN88@xmlXPathDe

; 1640 : 	xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch2], depth + 1);

	push	ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	push	edi
	call	_xmlXPathDebugDumpStepOp
	add	esp, 16					; 00000010H
	pop	esi
	pop	edi

; 1641 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@xmlXPathDe:

; 1631 : #endif
; 1632 : 	default:
; 1633 :         fprintf(output, "UNKNOWN %d\n", op->op); return;

	push	eax
	push	OFFSET ??_C@_0M@BEEHJFLN@UNKNOWN?5?$CFd?6@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN88@xmlXPathDe:

; 1641 : }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@xmlXPathDe:
	DD	$LN14@xmlXPathDe
	DD	$LN15@xmlXPathDe
	DD	$LN16@xmlXPathDe
	DD	$LN17@xmlXPathDe
	DD	$LN20@xmlXPathDe
	DD	$LN24@xmlXPathDe
	DD	$LN32@xmlXPathDe
	DD	$LN37@xmlXPathDe
	DD	$LN38@xmlXPathDe
	DD	$LN39@xmlXPathDe
	DD	$LN41@xmlXPathDe
	DD	$LN67@xmlXPathDe
	DD	$LN68@xmlXPathDe
	DD	$LN71@xmlXPathDe
	DD	$LN74@xmlXPathDe
	DD	$LN75@xmlXPathDe
	DD	$LN76@xmlXPathDe
	DD	$LN40@xmlXPathDe
	DD	$LN77@xmlXPathDe
$LN95@xmlXPathDe:
	DD	$LN42@xmlXPathDe
	DD	$LN43@xmlXPathDe
	DD	$LN44@xmlXPathDe
	DD	$LN45@xmlXPathDe
	DD	$LN46@xmlXPathDe
	DD	$LN47@xmlXPathDe
	DD	$LN48@xmlXPathDe
	DD	$LN49@xmlXPathDe
	DD	$LN50@xmlXPathDe
	DD	$LN51@xmlXPathDe
	DD	$LN52@xmlXPathDe
	DD	$LN53@xmlXPathDe
	DD	$LN54@xmlXPathDe
$LN96@xmlXPathDe:
	DD	$LN55@xmlXPathDe
	DD	$LN56@xmlXPathDe
	DD	$LN57@xmlXPathDe
	DD	$LN58@xmlXPathDe
	DD	$LN59@xmlXPathDe
	DD	$LN60@xmlXPathDe
$LN97@xmlXPathDe:
	DD	$LN61@xmlXPathDe
	DD	$LN11@xmlXPathDe
	DD	$LN11@xmlXPathDe
	DD	$LN63@xmlXPathDe
	DD	$LN11@xmlXPathDe
	DD	$LN11@xmlXPathDe
	DD	$LN11@xmlXPathDe
	DD	$LN64@xmlXPathDe
	DD	$LN62@xmlXPathDe
_xmlXPathDebugDumpStepOp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpLocationSet
_TEXT	SEGMENT
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
tv455 = 16						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpLocationSet PROC			; COMDAT

; 1331 : xmlXPathDebugDumpLocationSet(FILE *output, xmlLocationSetPtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN77@xmlXPathDe
	npad	7
$LL4@xmlXPathDe:

; 1332 :     int i;
; 1333 :     char shift[100];
; 1334 : 
; 1335 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	eax, 25					; 00000019H
	jge	SHORT $LN77@xmlXPathDe

; 1336 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL4@xmlXPathDe
$LN77@xmlXPathDe:
	push	ebx

; 1337 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 1338 : 
; 1339 :     if (cur == NULL) {

	mov	ebx, DWORD PTR _cur$[ebp]
	mov	WORD PTR _shift$[ebp+eax*2], 0
	push	esi
	test	ebx, ebx
	jne	SHORT $LN8@xmlXPathDe

; 1340 : 	fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1341 : 	fprintf(output, "LocationSet is NULL !\n");

	push	OFFSET ??_C@_0BH@OMGEHPOG@LocationSet?5is?5NULL?5?$CB?6@
	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi

; 1350 :     }
; 1351 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathDe:
	push	edi

; 1342 : 	return;
; 1343 : 
; 1344 :     }
; 1345 : 
; 1346 :     for (i = 0;i < cur->locNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN78@xmlXPathDe
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv455[ebp], eax
$LL7@xmlXPathDe:

; 1347 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	DWORD PTR _output$[ebp]
	call	_fprintf

; 1348 :         fprintf(output, "%d : ", i + 1);

	lea	esi, DWORD PTR [edi+1]
	push	esi
	push	OFFSET ??_C@_05GJKEPAIO@?$CFd?5?3?5@
	push	DWORD PTR _output$[ebp]
	call	_fprintf

; 1349 : 	xmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR tv455[ebp]
	push	DWORD PTR [eax+edi*4]
	push	DWORD PTR _output$[ebp]
	call	_xmlXPathDebugDumpObject
	mov	edi, esi
	add	esp, 36					; 00000024H
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL7@xmlXPathDe
$LN78@xmlXPathDe:
	pop	edi
	pop	esi

; 1350 :     }
; 1351 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpLocationSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpValueTree
_TEXT	SEGMENT
_shift$1 = -200						; size = 100
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpValueTree PROC			; COMDAT

; 1310 : xmlXPathDebugDumpValueTree(FILE *output, xmlNodeSetPtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _depth$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN34@xmlXPathDe
	npad	2
$LL4@xmlXPathDe:

; 1311 :     int i;
; 1312 :     char shift[100];
; 1313 : 
; 1314 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	esi, 25					; 00000019H
	jge	SHORT $LN34@xmlXPathDe

; 1315 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+esi*2], 8224	; 00002020H
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@xmlXPathDe
$LN34@xmlXPathDe:

; 1316 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 1317 : 
; 1318 :     if ((cur == NULL) || (cur->nodeNr == 0) || (cur->nodeTab[0] == NULL)) {

	mov	eax, DWORD PTR _cur$[ebp]
	mov	WORD PTR _shift$[ebp+esi*2], 0
	test	eax, eax
	je	$LN6@xmlXPathDe
	cmp	DWORD PTR [eax], 0
	je	$LN6@xmlXPathDe
	mov	eax, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax], 0
	je	$LN6@xmlXPathDe

; 1321 : 	return;
; 1322 : 
; 1323 :     }
; 1324 : 
; 1325 :     fprintf(output, "%s", shift);

	push	ebx
	mov	ebx, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	ebx
	call	_fprintf

; 1326 :     fprintf(output, "%d", i + 1);

	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	push	ebx
	call	_fprintf

; 1327 :     xmlXPathDebugDumpNodeList(output, cur->nodeTab[0]->children, depth + 1);

	mov	eax, DWORD PTR _cur$[ebp]
	inc	edi
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+12]

; 1266 :     for (i = 0;((i < depth) && (i < 25));i++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN35@xmlXPathDe
	npad	3
$LL11@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN35@xmlXPathDe

; 1267 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$1[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL11@xmlXPathDe
$LN35@xmlXPathDe:

; 1268 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$1[ebp+eax*2], 0

; 1269 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LL12@xmlXPathDe

; 1270 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$1[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	ebx
	call	_fprintf

; 1271 : 	fprintf(output, "Node is NULL !\n");

	push	OFFSET ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@
	push	ebx
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 1328 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	7
$LL12@xmlXPathDe:

; 1277 : 	tmp = cur;

	mov	eax, esi

; 1278 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1279 : 	xmlDebugDumpOneNode(output, tmp, depth);

	push	edi
	push	eax
	push	ebx
	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL12@xmlXPathDe

; 1328 : }

	pop	ebx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathDe:

; 1319 : 	fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1320 : 	fprintf(output, "Value Tree is NULL !\n");

	push	OFFSET ??_C@_0BG@ODIPEGMA@Value?5Tree?5is?5NULL?5?$CB?6@
	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	edi

; 1328 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpValueTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpNodeSet
_TEXT	SEGMENT
_shift$1 = -200						; size = 100
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
tv366 = 16						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpNodeSet PROC				; COMDAT

; 1284 : xmlXPathDebugDumpNodeSet(FILE *output, xmlNodeSetPtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN34@xmlXPathDe
	npad	2
$LL4@xmlXPathDe:

; 1285 :     int i;
; 1286 :     char shift[100];
; 1287 : 
; 1288 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	eax, 25					; 00000019H
	jge	SHORT $LN34@xmlXPathDe

; 1289 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL4@xmlXPathDe
$LN34@xmlXPathDe:

; 1290 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 1291 : 
; 1292 :     if (cur == NULL) {

	mov	esi, DWORD PTR _output$[ebp]
	mov	WORD PTR _shift$[ebp+eax*2], 0
	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN8@xmlXPathDe

; 1293 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1294 : 	fprintf(output, "NodeSet is NULL !\n");

	push	OFFSET ??_C@_0BD@CEACDENF@NodeSet?5is?5NULL?5?$CB?6@
	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	edi

; 1305 : 	}
; 1306 :     }
; 1307 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathDe:
	push	ebx

; 1295 : 	return;
; 1296 : 
; 1297 :     }
; 1298 : 
; 1299 :     if (cur != NULL) {
; 1300 : 	fprintf(output, "Set contains %d nodes:\n", cur->nodeNr);

	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BI@CGJHGOLK@Set?5contains?5?$CFd?5nodes?3?6@
	push	esi
	call	_fprintf

; 1301 : 	for (i = 0;i < cur->nodeNr;i++) {

	mov	eax, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax], ebx
	jle	$LN36@xmlXPathDe
	inc	edi
$LL7@xmlXPathDe:

; 1302 : 	    fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1303 : 	    fprintf(output, "%d", i + 1);

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	push	esi
	mov	DWORD PTR tv366[ebp], eax
	call	_fprintf

; 1304 : 	    xmlXPathDebugDumpNode(output, cur->nodeTab[i], depth + 1);

	mov	eax, DWORD PTR _cur$[ebp]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 1241 :     for (i = 0;((i < depth) && (i < 25));i++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN35@xmlXPathDe
$LL14@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN35@xmlXPathDe

; 1242 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$1[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL14@xmlXPathDe
$LN35@xmlXPathDe:

; 1243 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$1[ebp+eax*2], 0

; 1244 :     if (cur == NULL) {

	test	ecx, ecx
	jne	SHORT $LN15@xmlXPathDe

; 1245 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$1[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1246 : 	fprintf(output, "Node is NULL !\n");

	push	OFFSET ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@

; 1247 : 	return;

	jmp	SHORT $LN37@xmlXPathDe
$LN15@xmlXPathDe:

; 1248 : 
; 1249 :     }
; 1250 : 
; 1251 :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 9
	je	SHORT $LN18@xmlXPathDe
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN18@xmlXPathDe

; 1255 :     } else if (cur->type == XML_ATTRIBUTE_NODE)

	push	edi
	push	ecx
	push	esi
	cmp	eax, 2
	jne	SHORT $LN19@xmlXPathDe

; 1256 : 	xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);

	call	_xmlDebugDumpAttr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlXPathDe
$LN19@xmlXPathDe:

; 1257 :     else
; 1258 : 	xmlDebugDumpOneNode(output, cur, depth);

	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@xmlXPathDe
$LN18@xmlXPathDe:

; 1252 : 	     (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 1253 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$1[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1254 : 	fprintf(output, " /\n");

	push	OFFSET ??_C@_03LHHHGGIK@?5?1?6@
$LN37@xmlXPathDe:

; 1301 : 	for (i = 0;i < cur->nodeNr;i++) {

	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
$LN5@xmlXPathDe:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ebx, DWORD PTR tv366[ebp]
	cmp	ebx, DWORD PTR [eax]
	jl	$LL7@xmlXPathDe
$LN36@xmlXPathDe:
	pop	ebx
	pop	edi

; 1305 : 	}
; 1306 :     }
; 1307 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpNodeList
_TEXT	SEGMENT
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpNodeList PROC				; COMDAT

; 1261 : xmlXPathDebugDumpNodeList(FILE *output, xmlNodePtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN22@xmlXPathDe
	npad	5
$LL4@xmlXPathDe:

; 1262 :     xmlNodePtr tmp;
; 1263 :     int i;
; 1264 :     char shift[100];
; 1265 : 
; 1266 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	eax, 25					; 00000019H
	jge	SHORT $LN22@xmlXPathDe

; 1267 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL4@xmlXPathDe
$LN22@xmlXPathDe:

; 1268 :     shift[2 * i] = shift[2 * i + 1] = 0;
; 1269 :     if (cur == NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	mov	WORD PTR _shift$[ebp+eax*2], 0
	test	esi, esi
	jne	SHORT $LN21@xmlXPathDe

; 1270 : 	fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1271 : 	fprintf(output, "Node is NULL !\n");

	push	OFFSET ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@
	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	edi

; 1280 :     }
; 1281 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXPathDe:
	push	ebx
	mov	ebx, DWORD PTR _output$[ebp]
	npad	7
$LL5@xmlXPathDe:

; 1272 : 	return;
; 1273 : 
; 1274 :     }
; 1275 : 
; 1276 :     while (cur != NULL) {
; 1277 : 	tmp = cur;

	mov	eax, esi

; 1278 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1279 : 	xmlDebugDumpOneNode(output, tmp, depth);

	push	edi
	push	eax
	push	ebx
	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL5@xmlXPathDe

; 1280 :     }
; 1281 : }

	pop	ebx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpNode
_TEXT	SEGMENT
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpNode PROC				; COMDAT

; 1237 : xmlXPathDebugDumpNode(FILE *output, xmlNodePtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN16@xmlXPathDe
	npad	7
$LL4@xmlXPathDe:

; 1238 :     int i;
; 1239 :     char shift[100];
; 1240 : 
; 1241 :     for (i = 0;((i < depth) && (i < 25));i++)

	cmp	eax, 25					; 00000019H
	jge	SHORT $LN16@xmlXPathDe

; 1242 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL4@xmlXPathDe
$LN16@xmlXPathDe:

; 1243 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$[ebp+eax*2], 0

; 1244 :     if (cur == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	push	esi
	test	eax, eax
	jne	SHORT $LN5@xmlXPathDe

; 1245 : 	fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1246 : 	fprintf(output, "Node is NULL !\n");

	push	OFFSET ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@

; 1259 : }

	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathDe:

; 1247 : 	return;
; 1248 : 
; 1249 :     }
; 1250 : 
; 1251 :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 9
	je	SHORT $LN8@xmlXPathDe
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN8@xmlXPathDe

; 1255 :     } else if (cur->type == XML_ATTRIBUTE_NODE)

	push	ecx
	push	eax
	push	DWORD PTR _output$[ebp]
	cmp	edx, 2
	jne	SHORT $LN9@xmlXPathDe

; 1256 : 	xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);

	call	_xmlDebugDumpAttr
	add	esp, 12					; 0000000cH
	pop	esi

; 1259 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathDe:

; 1257 :     else
; 1258 : 	xmlDebugDumpOneNode(output, cur, depth);

	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
	pop	esi

; 1259 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathDe:

; 1252 : 	     (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 1253 : 	fprintf(output, "%s", shift);

	mov	esi, DWORD PTR _output$[ebp]
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	esi
	call	_fprintf

; 1254 : 	fprintf(output, " /\n");

	push	OFFSET ??_C@_03LHHHGGIK@?5?1?6@

; 1259 : }

	push	esi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompSwap
_TEXT	SEGMENT
_op$ = 8						; size = 4
_xmlXPathCompSwap PROC					; COMDAT

; 1137 : xmlXPathCompSwap(xmlXPathStepOpPtr op) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _op$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [edx+8], ecx

; 1138 :     int tmp;
; 1139 : 
; 1140 : #ifndef LIBXML_THREAD_ENABLED
; 1141 :     /*
; 1142 :      * Since this manipulates possibly shared variables, this is
; 1143 :      * disabled if one detects that the library is used in a multithreaded
; 1144 :      * application
; 1145 :      */
; 1146 :     if (xmlXPathDisableOptimizer)
; 1147 : 	return;
; 1148 : #endif
; 1149 : 
; 1150 :     tmp = op->ch1;
; 1151 :     op->ch1 = op->ch2;
; 1152 :     op->ch2 = tmp;
; 1153 : }

	pop	ebp
	ret	0
_xmlXPathCompSwap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompExprAdd
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_ch1$ = 12						; size = 4
_ch2$ = 16						; size = 4
_op$ = 20						; size = 4
_value$ = 24						; size = 4
_value2$ = 28						; size = 4
_value3$ = 32						; size = 4
_value4$ = 36						; size = 4
_value5$ = 40						; size = 4
_xmlXPathCompExprAdd PROC				; COMDAT

; 1081 :    int value2, int value3, void *value4, void *value5) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	jl	SHORT $LN32@xmlXPathCo

; 1082 :     if (comp->nbStep >= comp->maxStep) {
; 1083 : 	xmlXPathStepOp *real;
; 1084 : 
; 1085 :         if (comp->maxStep >= XPATH_MAX_STEPS) {

	cmp	eax, 1000000				; 000f4240H
	jge	SHORT $LN33@xmlXPathCo

; 1086 : 	    xmlXPathErrMemory(NULL, "adding step\n");
; 1087 : 	    return(-1);
; 1088 :         }
; 1089 : 	comp->maxStep *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+4], eax

; 1090 : 	real = (xmlXPathStepOp *) xmlRealloc(comp->steps,

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1091 : 		                      comp->maxStep * sizeof(xmlXPathStepOp));
; 1092 : 	if (real == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPathCo

; 1093 : 	    comp->maxStep /= 2;

	mov	eax, DWORD PTR [esi+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN33@xmlXPathCo:

; 1127 : }

	push	OFFSET ??_C@_0N@GHHFFDFC@adding?5step?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0N@GHHFFDFC@adding?5step?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathCo:

; 1094 : 	    xmlXPathErrMemory(NULL, "adding step\n");
; 1095 : 	    return(-1);
; 1096 : 	}
; 1097 : 	comp->steps = real;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+8], eax
$LN32@xmlXPathCo:

; 1098 :     }
; 1099 :     comp->last = comp->nbStep;
; 1100 :     comp->steps[comp->nbStep].ch1 = ch1;

	mov	eax, DWORD PTR _ch1$[ebp]
	lea	edx, DWORD PTR [ecx+ecx*4]
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [esi+8]
	push	edi

; 1101 :     comp->steps[comp->nbStep].ch2 = ch2;
; 1102 :     comp->steps[comp->nbStep].op = op;

	mov	edi, DWORD PTR _op$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _ch2$[ebp]
	mov	DWORD PTR [ecx+edx*8+8], eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*8], edi

; 1103 :     comp->steps[comp->nbStep].value = value;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*8+12], eax

; 1104 :     comp->steps[comp->nbStep].value2 = value2;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _value2$[ebp]
	mov	DWORD PTR [ecx+edx*8+16], eax

; 1105 :     comp->steps[comp->nbStep].value3 = value3;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _value3$[ebp]
	mov	DWORD PTR [ecx+edx*8+20], eax

; 1106 :     if ((comp->dict != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	$LN5@xmlXPathCo
	cmp	edi, 13					; 0000000dH
	je	SHORT $LN7@xmlXPathCo
	cmp	edi, 12					; 0000000cH
	je	SHORT $LN7@xmlXPathCo
	cmp	edi, 10					; 0000000aH
	jne	SHORT $LN5@xmlXPathCo
$LN7@xmlXPathCo:

; 1107 :         ((op == XPATH_OP_FUNCTION) || (op == XPATH_OP_VARIABLE) ||
; 1108 : 	 (op == XPATH_OP_COLLECT))) {
; 1109 :         if (value4 != NULL) {

	mov	edi, DWORD PTR _value4$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlXPathCo

; 1110 : 	    comp->steps[comp->nbStep].value4 = (xmlChar *)

	push	-1
	push	edi
	push	eax
	call	_xmlDictLookup
	mov	ecx, DWORD PTR [esi]

; 1111 : 	        (void *)xmlDictLookup(comp->dict, value4, -1);
; 1112 : 	    xmlFree(value4);

	push	edi
	lea	edx, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+edx*8+24], eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 1113 : 	} else

	jmp	SHORT $LN9@xmlXPathCo
$LN8@xmlXPathCo:

; 1114 : 	    comp->steps[comp->nbStep].value4 = NULL;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*8+24], 0
$LN9@xmlXPathCo:

; 1115 :         if (value5 != NULL) {

	mov	edi, DWORD PTR _value5$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlXPathCo

; 1116 : 	    comp->steps[comp->nbStep].value5 = (xmlChar *)

	push	-1
	push	edi
	push	DWORD PTR [esi+20]
	call	_xmlDictLookup
	mov	ecx, DWORD PTR [esi]

; 1117 : 	        (void *)xmlDictLookup(comp->dict, value5, -1);
; 1118 : 	    xmlFree(value5);

	push	edi
	lea	edx, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+edx*8+28], eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 1119 : 	} else

	jmp	SHORT $LN6@xmlXPathCo
$LN10@xmlXPathCo:

; 1120 : 	    comp->steps[comp->nbStep].value5 = NULL;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*8+28], 0

; 1121 :     } else {

	jmp	SHORT $LN6@xmlXPathCo
$LN5@xmlXPathCo:

; 1122 : 	comp->steps[comp->nbStep].value4 = value4;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _value4$[ebp]
	mov	DWORD PTR [ecx+edx*8+24], eax

; 1123 : 	comp->steps[comp->nbStep].value5 = value5;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _value5$[ebp]
	mov	DWORD PTR [ecx+edx*8+28], eax
$LN6@xmlXPathCo:

; 1124 :     }
; 1125 :     comp->steps[comp->nbStep].cache = NULL;

	mov	eax, DWORD PTR [esi]

; 1126 :     return(comp->nbStep++);

	pop	edi
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*8+32], 0
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi], ecx
	pop	esi

; 1127 : }

	pop	ebp
	ret	0
_xmlXPathCompExprAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewCompExpr
_TEXT	SEGMENT
_xmlXPathNewCompExpr PROC				; COMDAT

; 980  : xmlXPathNewCompExpr(void) {

	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BG@OMFEJMIL@allocating?5component?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BG@OMFEJMIL@allocating?5component?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 981  :     xmlXPathCompExprPtr cur;
; 982  : 
; 983  :     cur = (xmlXPathCompExprPtr) xmlMalloc(sizeof(xmlXPathCompExpr));
; 984  :     if (cur == NULL) {
; 985  :         xmlXPathErrMemory(NULL, "allocating component\n");
; 986  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1004 : }

	ret	0
$LN2@xmlXPathNe:

; 987  :     }
; 988  :     memset(cur, 0, sizeof(xmlXPathCompExpr));

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0

; 989  :     cur->maxStep = 10;
; 990  :     cur->nbStep = 0;
; 991  :     cur->steps = (xmlXPathStepOp *) xmlMalloc(cur->maxStep *

	push	400					; 00000190H
	mov	DWORD PTR [esi+4], 10			; 0000000aH
	mov	DWORD PTR [esi], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 992  : 	                                   sizeof(xmlXPathStepOp));
; 993  :     if (cur->steps == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@EIFELMJ@allocating?5steps?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@EIFELMJ@allocating?5steps?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 994  :         xmlXPathErrMemory(NULL, "allocating steps\n");
; 995  : 	xmlFree(cur);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 996  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1004 : }

	ret	0
$LN3@xmlXPathNe:

; 997  :     }
; 998  :     memset(cur->steps, 0, cur->maxStep * sizeof(xmlXPathStepOp));

	mov	ecx, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 999  :     cur->last = -1;

	mov	DWORD PTR [esi+12], -1

; 1000 : #ifdef DEBUG_EVAL_COUNTS
; 1001 :     cur->nb = 0;
; 1002 : #endif
; 1003 :     return(cur);

	mov	eax, esi
	pop	esi

; 1004 : }

	ret	0
_xmlXPathNewCompExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeObjectEntry
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPathFreeObjectEntry PROC				; COMDAT

; 5524 : xmlXPathFreeObjectEntry(void *obj, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _obj$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4

; 5525 :     xmlXPathFreeObject((xmlXPathObjectPtr) obj);
; 5526 : }

	pop	ebp
	ret	0
_xmlXPathFreeObjectEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalToBoolean
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_isPredicate$ = 16					; size = 4
_xmlXPathCompOpEvalToBoolean PROC			; COMDAT

; 13989: {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _op$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi]
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN14@xmlXPathCo
	npad	4
$start$34:

; 13990:     xmlXPathObjectPtr resObj = NULL;
; 13991: 
; 13992: start:
; 13993:     /* comp = ctxt->comp; */
; 13994:     switch (op->op) {

	movzx	eax, BYTE PTR $LN30@xmlXPathCo[eax]
	jmp	DWORD PTR $LN33@xmlXPathCo[eax*4]
$LN7@xmlXPathCo:

; 14002: 	case XPATH_OP_SORT:
; 14003: 	    /*
; 14004: 	    * We don't need sorting for boolean results. Skip this one.
; 14005: 	    */
; 14006:             if (op->ch1 != -1) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, -1
	je	$LN29@xmlXPathCo

; 14007: 		op = &ctxt->comp->steps[op->ch1];

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	edi, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [edi]
	cmp	eax, 17					; 00000011H
	jbe	SHORT $start$34
$LN14@xmlXPathCo:

; 14025: 		return(-1);
; 14026: 	    break;
; 14027: 	default:
; 14028: 	    /*
; 14029: 	    * Fallback to call xmlXPathCompOpEval().
; 14030: 	    */
; 14031: 	    xmlXPathCompOpEval(ctxt, op);

	push	edi
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8

; 14032: 	    if (ctxt->error != XPATH_EXPRESSION_OK)

	cmp	DWORD PTR [esi+8], 0
	jne	$LN28@xmlXPathCo

; 14033: 		return(-1);
; 14034: 
; 14035: 	    resObj = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 14036: 	    if (resObj == NULL)

	test	edi, edi
	je	$LN28@xmlXPathCo
$LN27@xmlXPathCo:

; 14038: 	    break;
; 14039:     }
; 14040: 
; 14041:     if (resObj) {
; 14042: 	int res;
; 14043: 
; 14044: 	if (resObj->type == XPATH_BOOLEAN) {

	cmp	DWORD PTR [edi], 2
	push	ebx
	jne	$LN18@xmlXPathCo

; 14045: 	    res = resObj->boolval;

	mov	ebx, DWORD PTR [edi+8]

; 14058: 	}
; 14059: 	xmlXPathReleaseObject(ctxt->context, resObj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 14060: 	return(res);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPathCo:

; 13995:         case XPATH_OP_END:
; 13996:             return (0);
; 13997: 	case XPATH_OP_VALUE:
; 13998: 	    resObj = (xmlXPathObjectPtr) op->value4;
; 13999: 	    if (isPredicate)

	cmp	DWORD PTR _isPredicate$[ebp], 0
	mov	eax, DWORD PTR [edi+24]
	push	eax
	je	SHORT $LN6@xmlXPathCo

; 14000: 		return(xmlXPathEvaluatePredicateResult(ctxt, resObj));

	push	esi
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 8
	pop	edi

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathCo:

; 14001: 	    return(xmlXPathCastToBoolean(resObj));

	call	_xmlXPathCastToBoolean
	add	esp, 4
	pop	edi

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlXPathCo:

; 14008: 		goto start;
; 14009: 	    }
; 14010: 	    return(0);
; 14011: 	case XPATH_OP_COLLECT:
; 14012: 	    if (op->ch1 == -1)

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, -1
	je	SHORT $LN29@xmlXPathCo

; 14014: 
; 14015:             xmlXPathCompOpEval(ctxt, &ctxt->comp->steps[op->ch1]);

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8

; 14016: 	    if (ctxt->error != XPATH_EXPRESSION_OK)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN28@xmlXPathCo

; 14017: 		return(-1);
; 14018: 
; 14019:             xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 1);

	push	1
	push	0
	push	0
	push	edi
	push	esi
	call	_xmlXPathNodeCollectAndTest
	add	esp, 20					; 00000014H

; 14020: 	    if (ctxt->error != XPATH_EXPRESSION_OK)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN28@xmlXPathCo

; 14021: 		return(-1);
; 14022: 
; 14023: 	    resObj = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 14024: 	    if (resObj == NULL)

	test	edi, edi
	jne	$LN27@xmlXPathCo
$LN28@xmlXPathCo:
	pop	edi

; 14037: 		return(-1);

	or	eax, -1

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN29@xmlXPathCo:
	pop	edi

; 14013: 		return(0);

	xor	eax, eax

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN18@xmlXPathCo:

; 14046: 	} else if (isPredicate) {

	cmp	DWORD PTR _isPredicate$[ebp], 0
	push	edi
	je	SHORT $LN20@xmlXPathCo

; 14047: 	    /*
; 14048: 	    * For predicates a result of type "number" is handled
; 14049: 	    * differently:
; 14050: 	    * SPEC XPath 1.0:
; 14051: 	    * "If the result is a number, the result will be converted
; 14052: 	    *  to true if the number is equal to the context position
; 14053: 	    *  and will be converted to false otherwise;"
; 14054: 	    */
; 14055: 	    res = xmlXPathEvaluatePredicateResult(ctxt, resObj);

	push	esi
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 8

; 14056: 	} else {

	jmp	SHORT $LN31@xmlXPathCo
$LN20@xmlXPathCo:

; 14057: 	    res = xmlXPathCastToBoolean(resObj);

	call	_xmlXPathCastToBoolean
	add	esp, 4
$LN31@xmlXPathCo:

; 14058: 	}
; 14059: 	xmlXPathReleaseObject(ctxt->context, resObj);

	push	edi
	push	DWORD PTR [esi+12]
	mov	ebx, eax
	call	_xmlXPathReleaseObject
	add	esp, 8

; 14060: 	return(res);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 14061:     }
; 14062: 
; 14063:     return(0);
; 14064: }

	pop	esi
	pop	ebp
	ret	0
$LN33@xmlXPathCo:
	DD	$LN29@xmlXPathCo
	DD	$LN9@xmlXPathCo
	DD	$LN5@xmlXPathCo
	DD	$LN7@xmlXPathCo
	DD	$LN14@xmlXPathCo
$LN30@xmlXPathCo:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_xmlXPathCompOpEvalToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompOpEvalFirst
_TEXT	SEGMENT
_total$1$ = -8						; size = 4
_cur$1$ = -4						; size = 4
_arg2$1$ = 8						; size = 4
_comp$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_op$ = 12						; size = 4
_first$ = 16						; size = 4
_xmlXPathCompOpEvalFirst PROC				; COMDAT

; 12715: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jne	$LN31@xmlXPathCo

; 12716:     int total = 0, cur;
; 12717:     xmlXPathCompExprPtr comp;
; 12718:     xmlXPathObjectPtr arg1, arg2;
; 12719: 
; 12720:     CHECK_ERROR0;
; 12721:     comp = ctxt->comp;

	mov	edi, DWORD PTR _op$[ebp]
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR _comp$1$[ebp], edx

; 12722:     switch (op->op) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 17					; 00000011H
	ja	$LN29@xmlXPathCo
	movzx	eax, BYTE PTR $LN32@xmlXPathCo[eax]
	jmp	DWORD PTR $LN34@xmlXPathCo[eax*4]
$LN6@xmlXPathCo:

; 12723:         case XPATH_OP_END:
; 12724:             return (0);
; 12725:         case XPATH_OP_UNION:
; 12726:             total =

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _first$[ebp]
	push	ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalFirst
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _total$1$[ebp], eax

; 12727:                 xmlXPathCompOpEvalFirst(ctxt, &comp->steps[op->ch1],
; 12728:                                         first);
; 12729: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12730:             if ((ctxt->value != NULL)
; 12731:                 && (ctxt->value->type == XPATH_NODESET)
; 12732:                 && (ctxt->value->nodesetval != NULL)
; 12733:                 && (ctxt->value->nodesetval->nodeNr >= 1)) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN8@xmlXPathCo
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathCo
	cmp	DWORD PTR [ecx], 1
	jl	SHORT $LN8@xmlXPathCo

; 12734:                 /*
; 12735:                  * limit tree traversing to first node in the result
; 12736:                  */
; 12737: 		/*
; 12738: 		* OPTIMIZE TODO: This implicitely sorts
; 12739: 		*  the result, even if not needed. E.g. if the argument
; 12740: 		*  of the count() function, no sorting is needed.
; 12741: 		* OPTIMIZE TODO: How do we know if the node-list wasn't
; 12742: 		*  aready sorted?
; 12743: 		*/
; 12744: 		if (ctxt->value->nodesetval->nodeNr > 1)

	jle	SHORT $LN9@xmlXPathCo

; 12745: 		    xmlXPathNodeSetSort(ctxt->value->nodesetval);

	push	ecx
	call	_xmlXPathNodeSetSort
	mov	eax, DWORD PTR [esi+16]
	add	esp, 4
$LN9@xmlXPathCo:

; 12746:                 *first = ctxt->value->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx], eax
$LN8@xmlXPathCo:

; 12747:             }
; 12748:             cur =

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalFirst
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$1$[ebp], eax

; 12749:                 xmlXPathCompOpEvalFirst(ctxt, &comp->steps[op->ch2],
; 12750:                                         first);
; 12751: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12752: 
; 12753:             arg2 = valuePop(ctxt);

	push	esi
	call	_valuePop

; 12754:             arg1 = valuePop(ctxt);

	push	esi
	mov	DWORD PTR _arg2$1$[ebp], eax
	call	_valuePop
	mov	ebx, eax
	add	esp, 8

; 12755:             if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||
; 12756:                 (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {

	test	ebx, ebx
	je	SHORT $LN12@xmlXPathCo
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN12@xmlXPathCo
	mov	eax, DWORD PTR _arg2$1$[ebp]
	test	eax, eax
	je	SHORT $LN12@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlXPathCo

; 12760:             }
; 12761: 
; 12762:             arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,

	push	DWORD PTR [eax+4]
	push	DWORD PTR [ebx+4]
	call	_xmlXPathNodeSetMerge

; 12763:                                                     arg2->nodesetval);
; 12764:             valuePush(ctxt, arg1);

	push	ebx
	push	esi
	mov	DWORD PTR [ebx+4], eax
	call	_valuePush

; 12765: 	    xmlXPathReleaseObject(ctxt->context, arg2);

	push	DWORD PTR _arg2$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12766:             /* optimizer */
; 12767: 	    if (total > cur)

	mov	esi, DWORD PTR _cur$1$[ebp]
	add	esp, 24					; 00000018H
	mov	ebx, DWORD PTR _total$1$[ebp]
	cmp	ebx, esi
	jle	SHORT $LN13@xmlXPathCo

; 12768: 		xmlXPathCompSwap(op);

	push	edi
	call	_xmlXPathCompSwap
	add	esp, 4
$LN13@xmlXPathCo:

; 12769:             return (total + cur);

	pop	edi
	lea	eax, DWORD PTR [esi+ebx]

; 12817:     }
; 12818: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathCo:

; 12757: 	        xmlXPathReleaseObject(ctxt->context, arg1);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12758: 	        xmlXPathReleaseObject(ctxt->context, arg2);

	push	DWORD PTR _arg2$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 12759:                 XP_ERROR0(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
$LN31@xmlXPathCo:

; 12817:     }
; 12818: }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlXPathCo:

; 12770:         case XPATH_OP_ROOT:
; 12771:             xmlXPathRoot(ctxt);

	push	esi
	call	_xmlXPathRoot
	add	esp, 4

; 12817:     }
; 12818: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlXPathCo:

; 12772:             return (0);
; 12773:         case XPATH_OP_NODE:
; 12774:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN17@xmlXPathCo

; 12775:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	ebx, eax

; 12776: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN31@xmlXPathCo
	mov	edx, DWORD PTR _comp$1$[ebp]
$LN17@xmlXPathCo:

; 12777:             if (op->ch2 != -1)

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, -1
	je	SHORT $LN19@xmlXPathCo

; 12778:                 total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);

	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	add	ebx, eax

; 12779: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN31@xmlXPathCo
$LN19@xmlXPathCo:

; 12780: 	    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 12781: 		ctxt->context->node));
; 12782:             return (total);

	mov	eax, ebx
	pop	edi

; 12817:     }
; 12818: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlXPathCo:

; 12783:         case XPATH_OP_COLLECT:{
; 12784:                 if (op->ch1 == -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	$LN31@xmlXPathCo

; 12785:                     return (total);
; 12786: 
; 12787:                 total = xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	mov	ebx, eax

; 12788: 		CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo

; 12789: 
; 12790:                 total += xmlXPathNodeCollectAndTest(ctxt, op, first, NULL, 0);

	push	0
	push	0
	push	DWORD PTR _first$[ebp]
	push	edi
	push	esi
	call	_xmlXPathNodeCollectAndTest
	add	esp, 20					; 00000014H
	add	eax, ebx
	pop	edi

; 12817:     }
; 12818: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlXPathCo:

; 12791:                 return (total);
; 12792:             }
; 12793:         case XPATH_OP_VALUE:
; 12794:             valuePush(ctxt,

	push	DWORD PTR [edi+24]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheObjectCopy
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 12817:     }
; 12818: }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlXPathCo:

; 12795:                       xmlXPathCacheObjectCopy(ctxt->context,
; 12796: 			(xmlXPathObjectPtr) op->value4));
; 12797:             return (0);
; 12798:         case XPATH_OP_SORT:
; 12799:             if (op->ch1 != -1)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN26@xmlXPathCo

; 12800:                 total +=

	push	DWORD PTR _first$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	esi
	call	_xmlXPathCompOpEvalFirst
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 12801:                     xmlXPathCompOpEvalFirst(ctxt, &comp->steps[op->ch1],
; 12802:                                             first);
; 12803: 	    CHECK_ERROR0;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN31@xmlXPathCo
$LN26@xmlXPathCo:

; 12804:             if ((ctxt->value != NULL)
; 12805:                 && (ctxt->value->type == XPATH_NODESET)
; 12806:                 && (ctxt->value->nodesetval != NULL)
; 12807: 		&& (ctxt->value->nodesetval->nodeNr > 1))

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN27@xmlXPathCo
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo
	cmp	DWORD PTR [eax], 1
	jle	SHORT $LN27@xmlXPathCo

; 12808:                 xmlXPathNodeSetSort(ctxt->value->nodesetval);

	push	eax
	call	_xmlXPathNodeSetSort
	add	esp, 4
$LN27@xmlXPathCo:

; 12817:     }
; 12818: }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlXPathCo:

; 12809:             return (total);
; 12810: #ifdef XP_OPTIMIZED_FILTER_FIRST
; 12811: 	case XPATH_OP_FILTER:
; 12812:                 total += xmlXPathCompOpEvalFilterFirst(ctxt, op, first);

	push	DWORD PTR _first$[ebp]
	push	edi
	push	esi
	call	_xmlXPathCompOpEvalFilterFirst
	add	esp, 12					; 0000000cH
	pop	edi

; 12817:     }
; 12818: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlXPathCo:

; 12813:             return (total);
; 12814: #endif
; 12815:         default:
; 12816:             return (xmlXPathCompOpEval(ctxt, op));

	push	edi
	push	esi
	call	_xmlXPathCompOpEval
	add	esp, 8
	pop	edi

; 12817:     }
; 12818: }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlXPathCo:
	DD	$LN31@xmlXPathCo
	DD	$LN6@xmlXPathCo
	DD	$LN14@xmlXPathCo
	DD	$LN15@xmlXPathCo
	DD	$LN20@xmlXPathCo
	DD	$LN23@xmlXPathCo
	DD	$LN28@xmlXPathCo
	DD	$LN24@xmlXPathCo
	DD	$LN29@xmlXPathCo
$LN32@xmlXPathCo:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	7
_xmlXPathCompOpEvalFirst ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathReleaseObject
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_obj$ = 12						; size = 4
_xmlXPathReleaseObject PROC				; COMDAT

; 5537 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _obj$[ebp]
	test	esi, esi
	je	$LN9@xmlXPathRe

; 5538 : #define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
; 5539 : 	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
; 5540 :     if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
; 5541 : 
; 5542 : #define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
; 5543 : 
; 5544 :     if (obj == NULL)
; 5545 : 	return;
; 5546 :     if ((ctxt == NULL) || (ctxt->cache == NULL)) {

	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN10@xmlXPathRe
	mov	edi, DWORD PTR [edi+200]
	test	edi, edi
	je	$LN10@xmlXPathRe

; 5548 :     } else {
; 5549 : 	xmlXPathContextCachePtr cache =
; 5550 : 	    (xmlXPathContextCachePtr) ctxt->cache;
; 5551 : 
; 5552 : 	switch (obj->type) {

	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	eax, 8
	ja	$free_obj$79
	jmp	DWORD PTR $LN78@xmlXPathRe[eax*4]
$LN11@xmlXPathRe:

; 5553 : 	    case XPATH_NODESET:
; 5554 : 	    case XPATH_XSLT_TREE:
; 5555 : 		if (obj->nodesetval != NULL) {

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	$LN35@xmlXPathRe

; 5556 : 		    if (obj->boolval) {

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN13@xmlXPathRe

; 5557 : 			/*
; 5558 : 			* It looks like the @boolval is used for
; 5559 : 			* evaluation if this an XSLT Result Tree Fragment.
; 5560 : 			* TODO: Check if this assumption is correct.
; 5561 : 			*/
; 5562 : 			obj->type = XPATH_XSLT_TREE; /* just for debugging */
; 5563 : 			xmlXPathFreeValueTree(obj->nodesetval);

	push	edx
	mov	DWORD PTR [esi], 9
	call	_xmlXPathFreeValueTree
	add	esp, 4

; 5564 : 			obj->nodesetval = NULL;

	mov	DWORD PTR [esi+4], 0
	jmp	$LN35@xmlXPathRe
$LN13@xmlXPathRe:

; 5565 : 		    } else if ((obj->nodesetval->nodeMax <= 40) &&

	cmp	DWORD PTR [edx+4], 40			; 00000028H
	jg	SHORT $LN15@xmlXPathRe
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN65@xmlXPathRe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edi+20]
	jge	SHORT $LN15@xmlXPathRe

; 5566 : 			(XP_CACHE_WANTS(cache->nodesetObjs,
; 5567 : 					cache->maxNodeset)))
; 5568 : 		    {
; 5569 : 			XP_CACHE_ADD(cache->nodesetObjs, obj);

	test	ecx, ecx
	jne	$LN38@xmlXPathRe
$LN65@xmlXPathRe:
	push	10					; 0000000aH
	call	_xmlPointerListCreate
	mov	ecx, eax
	mov	DWORD PTR [edi], ecx

; 5570 : 			goto obj_cached;

	jmp	$LN68@xmlXPathRe
$LN15@xmlXPathRe:

; 5571 : 		    } else {
; 5572 : 			xmlXPathFreeNodeSet(obj->nodesetval);

	push	edx
	call	_xmlXPathFreeNodeSet
	add	esp, 4

; 5573 : 			obj->nodesetval = NULL;

	mov	DWORD PTR [esi+4], 0

; 5574 : 		    }
; 5575 : 		}
; 5576 : 		break;

	jmp	SHORT $LN35@xmlXPathRe
$LN21@xmlXPathRe:

; 5577 : 	    case XPATH_STRING:
; 5578 : 		if (obj->stringval != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN22@xmlXPathRe

; 5579 : 		    xmlFree(obj->stringval);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN22@xmlXPathRe:

; 5580 : 
; 5581 : 		if (XP_CACHE_WANTS(cache->stringObjs, cache->maxString)) {

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN70@xmlXPathRe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edi+24]
	jge	SHORT $LN35@xmlXPathRe

; 5582 : 		    XP_CACHE_ADD(cache->stringObjs, obj);

	test	ecx, ecx
	jne	SHORT $LN38@xmlXPathRe
$LN70@xmlXPathRe:
	push	10					; 0000000aH
	call	_xmlPointerListCreate
	mov	ecx, eax
	mov	DWORD PTR [edi+4], ecx

; 5583 : 		    goto obj_cached;

	jmp	SHORT $LN68@xmlXPathRe
$LN28@xmlXPathRe:

; 5584 : 		}
; 5585 : 		break;
; 5586 : 	    case XPATH_BOOLEAN:
; 5587 : 		if (XP_CACHE_WANTS(cache->booleanObjs, cache->maxBoolean)) {

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN72@xmlXPathRe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edi+28]
	jge	SHORT $LN35@xmlXPathRe

; 5588 : 		    XP_CACHE_ADD(cache->booleanObjs, obj);

	test	ecx, ecx
	jne	SHORT $LN38@xmlXPathRe
$LN72@xmlXPathRe:
	push	10					; 0000000aH
	call	_xmlPointerListCreate
	mov	ecx, eax
	mov	DWORD PTR [edi+8], ecx

; 5589 : 		    goto obj_cached;

	jmp	SHORT $LN68@xmlXPathRe
$LN34@xmlXPathRe:

; 5590 : 		}
; 5591 : 		break;
; 5592 : 	    case XPATH_NUMBER:
; 5593 : 		if (XP_CACHE_WANTS(cache->numberObjs, cache->maxNumber)) {

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN74@xmlXPathRe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edi+32]
	jl	SHORT $LN36@xmlXPathRe
$LN35@xmlXPathRe:

; 5602 : 		}
; 5603 : 		goto free_obj;
; 5604 : #endif
; 5605 : 	    default:
; 5606 : 		goto free_obj;
; 5607 : 	}
; 5608 : 
; 5609 : 	/*
; 5610 : 	* Fallback to adding to the misc-objects slot.
; 5611 : 	*/
; 5612 : 	if (XP_CACHE_WANTS(cache->miscObjs, cache->maxMisc)) {

	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	je	SHORT $LN76@xmlXPathRe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edi+36]
	jge	$free_obj$79

; 5613 : 	    XP_CACHE_ADD(cache->miscObjs, obj);

	test	ecx, ecx
	jne	SHORT $LN38@xmlXPathRe
$LN76@xmlXPathRe:
	push	10					; 0000000aH
	call	_xmlPointerListCreate
	mov	ecx, eax
	mov	DWORD PTR [edi+16], ecx

; 5614 : 	} else

	jmp	SHORT $LN68@xmlXPathRe
$LN36@xmlXPathRe:

; 5594 : 		    XP_CACHE_ADD(cache->numberObjs, obj);

	test	ecx, ecx
	jne	SHORT $LN38@xmlXPathRe
$LN74@xmlXPathRe:
	push	10					; 0000000aH
	call	_xmlPointerListCreate
	mov	ecx, eax
	mov	DWORD PTR [edi+12], ecx
$LN68@xmlXPathRe:

; 5615 : 	    goto free_obj;
; 5616 : 
; 5617 : obj_cached:
; 5618 : 
; 5619 : #ifdef XP_DEBUG_OBJ_USAGE
; 5620 : 	xmlXPathDebugObjUsageReleased(ctxt, obj->type);
; 5621 : #endif
; 5622 : 
; 5623 : 	if (obj->nodesetval != NULL) {

	add	esp, 4
	test	ecx, ecx
	je	$free_obj$79
$LN38@xmlXPathRe:
	push	0
	push	esi
	push	ecx
	call	_xmlPointerListAddSize
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	$free_obj$79
$obj_cached$80:
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	test	ebx, ebx
	je	SHORT $LN49@xmlXPathRe

; 5624 : 	    xmlNodeSetPtr tmpset = obj->nodesetval;
; 5625 : 
; 5626 : 	    /*
; 5627 : 	    * TODO: Due to those nasty ns-nodes, we need to traverse
; 5628 : 	    *  the list and free the ns-nodes.
; 5629 : 	    * URGENT TODO: Check if it's actually slowing things down.
; 5630 : 	    *  Maybe we shouldn't try to preserve the list.
; 5631 : 	    */
; 5632 : 	    if (tmpset->nodeNr > 1) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	jle	SHORT $LN51@xmlXPathRe

; 5633 : 		int i;
; 5634 : 		xmlNodePtr node;
; 5635 : 
; 5636 : 		for (i = 0; i < tmpset->nodeNr; i++) {

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN55@xmlXPathRe
	npad	4
$LL6@xmlXPathRe:

; 5637 : 		    node = tmpset->nodeTab[i];

	mov	eax, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax+edi*4]

; 5638 : 		    if ((node != NULL) &&

	test	eax, eax
	je	SHORT $LN4@xmlXPathRe
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN4@xmlXPathRe

; 5639 : 			(node->type == XML_NAMESPACE_DECL))
; 5640 : 		    {
; 5641 : 			xmlXPathNodeSetFreeNs((xmlNsPtr) node);

	push	eax
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN4@xmlXPathRe:

; 5633 : 		int i;
; 5634 : 		xmlNodePtr node;
; 5635 : 
; 5636 : 		for (i = 0; i < tmpset->nodeNr; i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL6@xmlXPathRe

; 5642 : 		    }
; 5643 : 		}
; 5644 : 	    } else if (tmpset->nodeNr == 1) {

	jmp	SHORT $LN55@xmlXPathRe
$LN51@xmlXPathRe:
	jne	SHORT $LN55@xmlXPathRe

; 5645 : 		if ((tmpset->nodeTab[0] != NULL) &&

	mov	eax, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN55@xmlXPathRe
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN55@xmlXPathRe

; 5646 : 		    (tmpset->nodeTab[0]->type == XML_NAMESPACE_DECL))
; 5647 : 		    xmlXPathNodeSetFreeNs((xmlNsPtr) tmpset->nodeTab[0]);

	push	eax
	call	_xmlXPathNodeSetFreeNs
	add	esp, 4
$LN55@xmlXPathRe:

; 5648 : 	    }
; 5649 : 	    tmpset->nodeNr = 0;
; 5650 : 	    memset(obj, 0, sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	mov	DWORD PTR [ebx], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 5651 : 	    obj->nodesetval = tmpset;

	mov	DWORD PTR [esi+4], ebx
	pop	ebx
	pop	edi
$LN9@xmlXPathRe:
	pop	esi

; 5667 :     }
; 5668 :     return;
; 5669 : }

	pop	ebp
	ret	0
$LN49@xmlXPathRe:

; 5652 : 	} else
; 5653 : 	    memset(obj, 0, sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 5667 :     }
; 5668 :     return;
; 5669 : }

	pop	ebp
	ret	0
$LN40@xmlXPathRe:

; 5595 : 		    goto obj_cached;
; 5596 : 		}
; 5597 : 		break;
; 5598 : #ifdef LIBXML_XPTR_ENABLED
; 5599 : 	    case XPATH_LOCATIONSET:
; 5600 : 		if (obj->user != NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $free_obj$79

; 5601 : 		    xmlXPtrFreeLocationSet(obj->user);

	push	eax
	call	_xmlXPtrFreeLocationSet
	add	esp, 4
$free_obj$79:

; 5654 : 
; 5655 : 	return;
; 5656 : 
; 5657 : free_obj:
; 5658 : 	/*
; 5659 : 	* Cache is full; free the object.
; 5660 : 	*/
; 5661 : 	if (obj->nodesetval != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN56@xmlXPathRe

; 5662 : 	    xmlXPathFreeNodeSet(obj->nodesetval);

	push	eax
	call	_xmlXPathFreeNodeSet
	add	esp, 4
$LN56@xmlXPathRe:

; 5663 : #ifdef XP_DEBUG_OBJ_USAGE
; 5664 : 	xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 5665 : #endif
; 5666 : 	xmlFree(obj);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 5667 :     }
; 5668 :     return;
; 5669 : }

	pop	ebp
	ret	0
$LN10@xmlXPathRe:

; 5547 : 	 xmlXPathFreeObject(obj);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4
	pop	edi
	pop	esi

; 5667 :     }
; 5668 :     return;
; 5669 : }

	pop	ebp
	ret	0
	npad	2
$LN78@xmlXPathRe:
	DD	$LN11@xmlXPathRe
	DD	$LN28@xmlXPathRe
	DD	$LN34@xmlXPathRe
	DD	$LN21@xmlXPathRe
	DD	$free_obj$79
	DD	$free_obj$79
	DD	$LN40@xmlXPathRe
	DD	$free_obj$79
	DD	$LN11@xmlXPathRe
_xmlXPathReleaseObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeValueTree
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_xmlXPathFreeValueTree PROC				; COMDAT

; 4267 : xmlXPathFreeValueTree(xmlNodeSetPtr obj) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _obj$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlXPathFr

; 4268 :     int i;
; 4269 : 
; 4270 :     if (obj == NULL) return;
; 4271 : 
; 4272 :     if (obj->nodeTab != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlXPathFr

; 4273 : 	for (i = 0;i < obj->nodeNr;i++) {

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN3@xmlXPathFr
$LL4@xmlXPathFr:

; 4274 : 	    if (obj->nodeTab[i] != NULL) {

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN2@xmlXPathFr

; 4275 : 		if (obj->nodeTab[i]->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	push	eax
	jne	SHORT $LN8@xmlXPathFr

; 4276 : 		    xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);

	call	_xmlXPathNodeSetFreeNs

; 4277 : 		} else {

	jmp	SHORT $LN15@xmlXPathFr
$LN8@xmlXPathFr:

; 4278 : 		    xmlFreeNodeList(obj->nodeTab[i]);

	call	_xmlFreeNodeList
$LN15@xmlXPathFr:

; 4273 : 	for (i = 0;i < obj->nodeNr;i++) {

	add	esp, 4
$LN2@xmlXPathFr:
	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@xmlXPathFr
	mov	eax, DWORD PTR [edi+8]
$LN3@xmlXPathFr:

; 4279 : 		}
; 4280 : 	    }
; 4281 : 	}
; 4282 : 	xmlFree(obj->nodeTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN6@xmlXPathFr:

; 4283 :     }
; 4284 :     xmlFree(obj);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPathFr:
	pop	edi

; 4285 : }

	pop	ebp
	ret	0
_xmlXPathFreeValueTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlPointerListFree
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlPointerListFree PROC				; COMDAT

; 842  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlPointer

; 843  :     if (list == NULL)
; 844  : 	return;
; 845  :     if (list->items != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlPointer

; 846  : 	xmlFree(list->items);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlPointer:

; 847  :     xmlFree(list);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlPointer:
	pop	esi

; 848  : }

	pop	ebp
	ret	0
_xmlPointerListFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlPointerListCreate
_TEXT	SEGMENT
_initialSize$ = 8					; size = 4
_xmlPointerListCreate PROC				; COMDAT

; 817  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlPointer

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 818  :     xmlPointerListPtr ret;
; 819  : 
; 820  :     ret = xmlMalloc(sizeof(xmlPointerList));
; 821  :     if (ret == NULL) {
; 822  : 	xmlXPathErrMemory(NULL,
; 823  : 	    "xmlPointerListCreate: allocating item\n");
; 824  : 	return (NULL);

	xor	eax, eax
	pop	esi

; 832  : }

	pop	ebp
	ret	0
$LN2@xmlPointer:

; 825  :     }
; 826  :     memset(ret, 0, sizeof(xmlPointerList));
; 827  :     if (initialSize > 0) {

	mov	eax, DWORD PTR _initialSize$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0
	test	eax, eax
	jle	SHORT $LN3@xmlPointer

; 828  : 	xmlPointerListAddSize(ret, NULL, initialSize);

	push	eax
	push	0
	push	esi
	call	_xmlPointerListAddSize
	add	esp, 12					; 0000000cH

; 829  : 	ret->number = 0;

	mov	DWORD PTR [esi+4], 0
$LN3@xmlPointer:

; 830  :     }
; 831  :     return (ret);

	mov	eax, esi
	pop	esi

; 832  : }

	pop	ebp
	ret	0
_xmlPointerListCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlPointerListAddSize
_TEXT	SEGMENT
_list$ = 8						; size = 4
_item$ = 12						; size = 4
_initialSize$ = 16					; size = 4
_xmlPointerListAddSize PROC				; COMDAT

; 776  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN2@xmlPointer

; 777  :     if (list->items == NULL) {
; 778  : 	if (initialSize <= 0)
; 779  : 	    initialSize = 1;
; 780  : 	list->items = (void **) xmlMalloc(initialSize * sizeof(void *));

	mov	eax, DWORD PTR _initialSize$[ebp]
	mov	edi, 1
	test	eax, eax
	cmovg	edi, eax
	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [esi], edx

; 781  : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN5@xmlPointer

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CH@GLHDGMAA@xmlPointerListCreate?3?5allocatin@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 782  : 	    xmlXPathErrMemory(NULL,
; 783  : 		"xmlPointerListCreate: allocating item\n");
; 784  : 	    return(-1);

	or	eax, -1
	pop	edi

; 806  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlPointer:

; 785  : 	}
; 786  : 	list->number = 0;

	mov	DWORD PTR [esi+4], 0

; 787  : 	list->size = initialSize;

	mov	DWORD PTR [esi+8], edi
$LN8@xmlPointer:

; 802  : 	}
; 803  :     }
; 804  :     list->items[list->number++] = item;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _item$[ebp]
	pop	edi
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [esi+4]

; 805  :     return(0);

	xor	eax, eax

; 806  : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlPointer:

; 788  :     } else if (list->size <= list->number) {

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [esi+4]
	jg	SHORT $LN8@xmlPointer

; 789  :         if (list->size > 50000000) {

	cmp	eax, 50000000				; 02faf080H
	jle	SHORT $LN7@xmlPointer

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 790  : 	    xmlXPathErrMemory(NULL,
; 791  : 		"xmlPointerListAddSize: re-allocating item\n");
; 792  :             return(-1);

	or	eax, -1
	pop	edi

; 806  : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlPointer:

; 793  :         }
; 794  : 	list->size *= 2;

	add	eax, eax
	mov	DWORD PTR [esi+8], eax

; 795  : 	list->items = (void **) xmlRealloc(list->items,

	shl	eax, 2
	push	eax
	push	edx
	call	DWORD PTR _xmlRealloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [esi], edx

; 796  : 	    list->size * sizeof(void *));
; 797  : 	if (list->items == NULL) {

	test	edx, edx
	jne	SHORT $LN8@xmlPointer

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0CL@LEBBNDKO@xmlPointerListAddSize?3?5re?9alloc@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 798  : 	    xmlXPathErrMemory(NULL,
; 799  : 		"xmlPointerListAddSize: re-allocating item\n");
; 800  : 	    list->size = 0;

	mov	DWORD PTR [esi+8], 0

; 801  : 	    return(-1);

	or	eax, -1
	pop	edi

; 806  : }

	pop	esi
	pop	ebp
	ret	0
_xmlPointerListAddSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlXPathPErrMemory PROC				; COMDAT

; 668  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlXPathPE

; 674  :     }
; 675  : }

	mov	DWORD PTR _ctxt$[ebp], eax
	pop	ebp
	jmp	_xmlXPathErrMemory
$LN2@xmlXPathPE:

; 669  :     if (ctxt == NULL)
; 670  : 	xmlXPathErrMemory(NULL, extra);
; 671  :     else {
; 672  : 	ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [eax+8], 15			; 0000000fH

; 673  : 	xmlXPathErrMemory(ctxt->context, extra);

	mov	eax, DWORD PTR [eax+12]

; 674  :     }
; 675  : }

	mov	DWORD PTR _ctxt$[ebp], eax
	pop	ebp
	jmp	_xmlXPathErrMemory
_xmlXPathPErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathErrMemory
_TEXT	SEGMENT
_buf$1 = -200						; size = 200
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlXPathErrMemory PROC					; COMDAT

; 626  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _extra$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlXPathEr

; 627  :     if (ctxt != NULL) {
; 628  :         if (extra) {

	test	eax, eax
	je	SHORT $LN4@xmlXPathEr

; 629  :             xmlChar buf[200];
; 630  : 
; 631  :             xmlStrPrintf(buf, 200,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	200					; 000000c8H
	push	eax
	call	_xmlStrPrintf

; 632  :                          "Memory allocation failed : %s\n",
; 633  :                          extra);
; 634  :             ctxt->lastError.message = (char *) xmlStrdup(buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 20					; 00000014H

; 635  :         } else {

	jmp	SHORT $LN5@xmlXPathEr
$LN4@xmlXPathEr:

; 636  :             ctxt->lastError.message = (char *)

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	call	_xmlStrdup
	add	esp, 4
$LN5@xmlXPathEr:

; 637  : 	       xmlStrdup(BAD_CAST "Memory allocation failed\n");
; 638  :         }
; 639  :         ctxt->lastError.domain = XML_FROM_XPATH;

	mov	DWORD PTR [esi+144], eax
	lea	eax, DWORD PTR [esi+136]

; 640  :         ctxt->lastError.code = XML_ERR_NO_MEMORY;
; 641  : 	if (ctxt->error != NULL)

	mov	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [eax], 12			; 0000000cH
	mov	DWORD PTR [esi+140], 2
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathEr

; 642  : 	    ctxt->error(ctxt->userData, &ctxt->lastError);

	push	eax
	push	DWORD PTR [esi+128]
	call	ecx
	add	esp, 8
	pop	esi

; 652  :                             NULL, NULL, XML_FROM_XPATH,
; 653  :                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 654  :                             NULL, NULL, NULL, 0, 0,
; 655  :                             "Memory allocation failed\n");
; 656  :     }
; 657  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathEr:

; 643  :     } else {
; 644  :         if (extra)

	test	eax, eax
	je	SHORT $LN7@xmlXPathEr

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 652  :                             NULL, NULL, XML_FROM_XPATH,
; 653  :                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 654  :                             NULL, NULL, NULL, 0, 0,
; 655  :                             "Memory allocation failed\n");
; 656  :     }
; 657  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathEr:

; 646  :                             NULL, NULL, XML_FROM_XPATH,
; 647  :                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 648  :                             extra, NULL, NULL, 0, 0,
; 649  :                             "Memory allocation failed : %s\n", extra);
; 650  :         else
; 651  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
$LN8@xmlXPathEr:
	pop	esi

; 652  :                             NULL, NULL, XML_FROM_XPATH,
; 653  :                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 654  :                             NULL, NULL, NULL, 0, 0,
; 655  :                             "Memory allocation failed\n");
; 656  :     }
; 657  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _PUSH_NEXT
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_size$ = 12						; size = 4
_store$ = 16						; size = 4
_minrun$ = 20						; size = 4
_run_stack$ = 24					; size = 4
_stack_curr$ = 28					; size = 4
_curr$ = 32						; size = 4
_PUSH_NEXT PROC						; COMDAT

; 493  :                               size_t *curr) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _curr$[ebp]
	push	DWORD PTR _size$[ebp]
	mov	ebx, DWORD PTR _dst$[ebp]
	push	DWORD PTR [esi]
	push	ebx
	call	_libxml_domnode_count_run
	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, eax
	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	mov	edi, DWORD PTR _minrun$[ebp]
	sub	ecx, eax
	cmp	edi, ecx
	cmova	edi, ecx
	cmp	edi, edx
	jbe	SHORT $LN13@PUSH_NEXT

; 502  :     BINARY_INSERTION_SORT_START(&dst[*curr], len, run);

	push	edi
	push	edx
	lea	eax, DWORD PTR [ebx+eax*4]
	push	eax
	call	_libxml_domnode_binary_insertion_sort_start

; 503  :     len = run;

	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	mov	edx, edi
	jmp	SHORT $LN5@PUSH_NEXT
$LN13@PUSH_NEXT:

; 494  :   size_t len = COUNT_RUN(dst, *curr, size);
; 495  :   size_t run = minrun;
; 496  : 
; 497  :   if (run > size - *curr) {
; 498  :     run = size - *curr;
; 499  :   }
; 500  : 
; 501  :   if (run > len) {

	mov	ecx, eax
$LN5@PUSH_NEXT:

; 504  :   }
; 505  : 
; 506  :   run_stack[*stack_curr].start = *curr;

	mov	esi, DWORD PTR _stack_curr$[ebp]
	mov	edi, DWORD PTR _run_stack$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+eax*8], ecx

; 507  :   run_stack[*stack_curr].length = len;

	mov	eax, DWORD PTR [esi]

; 508  :   (*stack_curr)++;
; 509  :   *curr += len;
; 510  : 
; 511  :   if (*curr == size) {

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edi+eax*8+4], edx
	mov	eax, DWORD PTR _curr$[ebp]
	inc	DWORD PTR [esi]
	add	DWORD PTR [eax], edx
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN6@PUSH_NEXT

; 512  :     /* finish up */
; 513  :     while (*stack_curr > 1) {

	cmp	DWORD PTR [esi], 1
	mov	ebx, DWORD PTR _store$[ebp]
	jbe	SHORT $LN3@PUSH_NEXT
$LL2@PUSH_NEXT:

; 514  :       TIM_SORT_MERGE(dst, run_stack, *stack_curr, store);

	push	ebx
	push	DWORD PTR [esi]
	push	edi
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_tim_sort_merge

; 515  :       run_stack[*stack_curr - 2].length += run_stack[*stack_curr - 1].length;

	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR [ecx-4]
	add	DWORD PTR [ecx-12], eax

; 516  :       (*stack_curr)--;

	dec	DWORD PTR [esi]
	cmp	DWORD PTR [esi], 1
	ja	SHORT $LL2@PUSH_NEXT
$LN3@PUSH_NEXT:

; 517  :     }
; 518  : 
; 519  :     if (store->storage != NULL) {

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN7@PUSH_NEXT

; 520  :       free(store->storage);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 521  :       store->storage = NULL;

	mov	DWORD PTR [ebx+4], 0
$LN7@PUSH_NEXT:

; 522  :     }
; 523  : 
; 524  :     return 0;
; 525  :   }
; 526  : 
; 527  :   return 1;
; 528  : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN6@PUSH_NEXT:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_PUSH_NEXT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_tim_sort_collapse
_TEXT	SEGMENT
_ABC$1$ = -20						; size = 4
tv622 = -16						; size = 4
tv627 = -12						; size = 4
tv612 = -8						; size = 4
tv624 = -4						; size = 4
_dst$ = 8						; size = 4
_stack$ = 12						; size = 4
tv614 = 16						; size = 4
_stack_curr$ = 16					; size = 4
_store$ = 20						; size = 4
_size$ = 24						; size = 4
_libxml_domnode_tim_sort_collapse PROC			; COMDAT

; 424  :                              TEMP_STORAGE_T *store, const size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __C4BA4707_timsort@h
	push	esi
	mov	esi, DWORD PTR _stack_curr$[ebp]
	push	edi
	mov	edi, DWORD PTR _stack$[ebp]
	call	@__CheckForDebuggerJustMyCode@4
	cmp	esi, 1
	jle	$LN34@libxml_dom
	lea	eax, DWORD PTR [esi-2]
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv627[ebp], eax
	lea	edx, DWORD PTR [esi*8-4]
	lea	eax, DWORD PTR [esi-1]
	add	edx, edi
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv612[ebp], edx
	push	ebx
	mov	DWORD PTR tv614[ebp], eax
	lea	ebx, DWORD PTR [esi*8-12]
	lea	ecx, DWORD PTR [esi*8-20]
	add	ebx, edi
	add	ecx, edi
	lea	eax, DWORD PTR [esi*8-28]
	add	eax, edi
	mov	DWORD PTR tv624[ebp], ecx
	mov	DWORD PTR tv622[ebp], eax
$LL2@libxml_dom:

; 431  :       break;
; 432  :     }
; 433  : 
; 434  :     /* if this is the last merge, just do it */
; 435  :     if ((stack_curr == 2) && (stack[0].length + stack[1].length == size)) {

	cmp	esi, 2
	je	$LN31@libxml_dom

; 443  :       TIM_SORT_MERGE(dst, stack, stack_curr, store);
; 444  :       stack[0].length += stack[1].length;
; 445  :       stack_curr--;
; 446  :       break;
; 447  :     } else if (stack_curr == 2) {
; 448  :       break;
; 449  :     }
; 450  : 
; 451  :     B = stack[stack_curr - 3].length;

	mov	eax, DWORD PTR [ecx]

; 452  :     C = stack[stack_curr - 2].length;

	mov	ecx, DWORD PTR [ebx]

; 453  :     D = stack[stack_curr - 1].length;

	mov	edx, DWORD PTR [edx]

; 454  : 
; 455  :     if (stack_curr >= 4) {

	cmp	esi, 4
	jl	SHORT $LN10@libxml_dom

; 456  :       A = stack[stack_curr - 4].length;
; 457  :       ABC = (A <= B + C);

	mov	edi, DWORD PTR tv622[ebp]
	add	eax, ecx
	cmp	eax, DWORD PTR [edi]
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR _ABC$1$[ebp], eax

; 458  :     } else {

	jmp	SHORT $LN11@libxml_dom
$LN10@libxml_dom:

; 459  :       ABC = 0;

	mov	DWORD PTR _ABC$1$[ebp], 0
$LN11@libxml_dom:

; 460  :     }
; 461  : 
; 462  :     BCD = (B <= C + D) || ABC;

	mov	edi, DWORD PTR tv624[ebp]
	lea	eax, DWORD PTR [edx+ecx]
	cmp	DWORD PTR [edi], eax
	mov	edi, DWORD PTR _stack$[ebp]
	jbe	SHORT $LN28@libxml_dom
	cmp	DWORD PTR _ABC$1$[ebp], 0
	jne	SHORT $LN28@libxml_dom

; 463  :     CD = (C <= D);
; 464  : 
; 465  :     /* Both invariants are good */
; 466  :     if (!BCD && !CD) {

	cmp	ecx, edx
	ja	$LN36@libxml_dom
$LN13@libxml_dom:

; 477  :       /* right merge */
; 478  :       TIM_SORT_MERGE(dst, stack, stack_curr, store);

	push	DWORD PTR _store$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_tim_sort_merge

; 479  :       stack[stack_curr - 2].length += stack[stack_curr - 1].length;

	mov	edx, DWORD PTR tv612[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR tv624[ebp]
	mov	eax, DWORD PTR [edx]
	add	DWORD PTR [ebx], eax

; 480  :       stack_curr--;

	dec	esi
$LN14@libxml_dom:

; 425  :   while (1) {
; 426  :     size_t A, B, C, D;
; 427  :     int ABC, BCD, CD;
; 428  : 
; 429  :     /* if the stack only has one thing on it, we are done with the collapse */
; 430  :     if (stack_curr <= 1) {

	add	DWORD PTR tv627[ebp], -8		; fffffff8H
	add	edx, -8					; fffffff8H
	add	DWORD PTR tv614[ebp], -8		; fffffff8H
	add	ecx, -8					; fffffff8H
	add	DWORD PTR tv622[ebp], -8		; fffffff8H
	add	ebx, -8					; fffffff8H
	mov	DWORD PTR tv612[ebp], edx
	mov	DWORD PTR tv624[ebp], ecx
	cmp	esi, 1
	jg	SHORT $LL2@libxml_dom

; 481  :     }
; 482  :   }
; 483  : 
; 484  :   return stack_curr;

	pop	ebx
	pop	edi
	mov	eax, esi

; 485  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@libxml_dom:

; 467  :       break;
; 468  :     }
; 469  : 
; 470  :     /* left merge */
; 471  :     if (BCD && !CD) {

	cmp	ecx, edx
	jbe	SHORT $LN13@libxml_dom

; 472  :       TIM_SORT_MERGE(dst, stack, stack_curr - 1, store);

	push	DWORD PTR _store$[ebp]
	dec	esi
	push	esi
	push	edi
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_tim_sort_merge

; 473  :       stack[stack_curr - 3].length += stack[stack_curr - 2].length;

	mov	ecx, DWORD PTR tv624[ebp]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [ebx]

; 474  :       stack[stack_curr - 2] = stack[stack_curr - 1];

	mov	edx, DWORD PTR tv627[ebp]
	add	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR tv614[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR tv614[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], eax

; 475  :       stack_curr--;
; 476  :     } else {

	mov	edx, DWORD PTR tv612[ebp]
	jmp	SHORT $LN14@libxml_dom
$LN31@libxml_dom:

; 431  :       break;
; 432  :     }
; 433  : 
; 434  :     /* if this is the last merge, just do it */
; 435  :     if ((stack_curr == 2) && (stack[0].length + stack[1].length == size)) {

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [edx+ecx]
	cmp	eax, DWORD PTR _size$[ebp]
	je	SHORT $LN21@libxml_dom

; 438  :       stack_curr--;
; 439  :       break;
; 440  :     }
; 441  :     /* check if the invariant is off for a stack of 2 elements */
; 442  :     else if ((stack_curr == 2) && (stack[0].length <= stack[1].length)) {

	cmp	edx, ecx
	jbe	SHORT $LN21@libxml_dom
$LN36@libxml_dom:
	pop	ebx
	pop	edi

; 481  :     }
; 482  :   }
; 483  : 
; 484  :   return stack_curr;

	mov	eax, esi

; 485  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@libxml_dom:

; 436  :       TIM_SORT_MERGE(dst, stack, stack_curr, store);

	push	DWORD PTR _store$[ebp]
	push	2
	push	edi
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_tim_sort_merge

; 437  :       stack[0].length += stack[1].length;

	mov	eax, DWORD PTR [edi+12]
	add	esp, 16					; 00000010H
	add	DWORD PTR [edi+4], eax

; 481  :     }
; 482  :   }
; 483  : 
; 484  :   return stack_curr;

	mov	eax, 1
	pop	ebx
	pop	edi

; 485  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@libxml_dom:
	pop	edi

; 481  :     }
; 482  :   }
; 483  : 
; 484  :   return stack_curr;

	mov	eax, esi

; 485  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_libxml_domnode_tim_sort_collapse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_tim_sort_merge
_TEXT	SEGMENT
tv793 = -8						; size = 4
_A$1$ = -4						; size = 4
_dst$ = 8						; size = 4
tv785 = 12						; size = 4
_i$1$ = 12						; size = 4
_stack$ = 12						; size = 4
_new_size$1$ = 16					; size = 4
_k$2$ = 16						; size = 4
tv783 = 16						; size = 4
_stack_curr$ = 16					; size = 4
_storage$1$ = 20					; size = 4
_store$ = 20						; size = 4
_libxml_domnode_tim_sort_merge PROC			; COMDAT

; 372  :                            TEMP_STORAGE_T *store) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _stack_curr$[ebp]
	mov	ecx, DWORD PTR _stack$[ebp]

; 357  :   if (store->alloc < new_size) {

	mov	edi, DWORD PTR _store$[ebp]

; 373  :   const size_t A = stack[stack_curr - 2].length;

	mov	edx, DWORD PTR [ecx+eax*8-12]

; 374  :   const size_t B = stack[stack_curr - 1].length;

	mov	esi, DWORD PTR [ecx+eax*8-4]

; 375  :   const size_t curr = stack[stack_curr - 2].start;
; 376  :   SORT_TYPE *storage;
; 377  :   size_t i, j, k;
; 378  :   TIM_SORT_RESIZE(store, MIN(A, B));

	cmp	edx, esi
	mov	ebx, DWORD PTR [ecx+eax*8-16]
	mov	eax, esi
	cmovb	eax, edx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _new_size$1$[ebp], eax

; 357  :   if (store->alloc < new_size) {

	cmp	DWORD PTR [edi], eax
	jae	SHORT $LN45@libxml_dom

; 358  :     SORT_TYPE *tempstore = (SORT_TYPE *)realloc(store->storage, new_size * sizeof(SORT_TYPE));

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+4]
	mov	DWORD PTR tv785[ebp], eax
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 359  : 
; 360  :     if (tempstore == NULL) {

	test	eax, eax
	jne	SHORT $LN24@libxml_dom

; 361  :       fprintf(stderr, "Error allocating temporary storage for tim sort: need %lu bytes",

	push	DWORD PTR tv785[ebp]
	push	OFFSET ??_C@_0EA@JENGBCEE@Error?5allocating?5temporary?5stor@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 362  :               (unsigned long)(sizeof(SORT_TYPE) * new_size));
; 363  :       exit(1);

	push	1
	call	DWORD PTR __imp__exit
$LN24@libxml_dom:
	mov	edx, DWORD PTR _A$1$[ebp]

; 364  :     }
; 365  : 
; 366  :     store->storage = tempstore;

	mov	DWORD PTR [edi+4], eax

; 367  :     store->alloc = new_size;

	mov	eax, DWORD PTR _new_size$1$[ebp]
	mov	DWORD PTR [edi], eax
$LN45@libxml_dom:

; 379  :   storage = store->storage;

	mov	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [ebx+esi]
	add	eax, edx
	mov	DWORD PTR _storage$1$[ebp], ecx
	mov	DWORD PTR _k$2$[ebp], eax
	lea	edi, DWORD PTR [ebx+edx]

; 380  : 
; 381  :   /* left merge */
; 382  :   if (A < B) {

	cmp	edx, esi
	jae	$LN7@libxml_dom

; 383  :     memcpy(storage, &dst[curr], A * sizeof(SORT_TYPE));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	mov	eax, DWORD PTR _dst$[ebp]
	lea	eax, DWORD PTR [eax+ebx*4]
	push	eax
	push	ecx
	call	_memcpy

; 384  :     i = 0;
; 385  :     j = curr + A;
; 386  : 
; 387  :     for (k = curr; k < curr + A + B; k++) {

	mov	esi, DWORD PTR _k$2$[ebp]
	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	ebx, esi
	jae	$LN46@libxml_dom
	mov	edx, DWORD PTR _dst$[ebp]
$LL4@libxml_dom:

; 388  :       if ((i < A) && (j < curr + A + B)) {

	cmp	eax, DWORD PTR _A$1$[ebp]
	jae	$LN46@libxml_dom
	mov	ecx, DWORD PTR _storage$1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv793[ebp], ecx
	cmp	edi, esi
	jae	SHORT $LN9@libxml_dom

; 389  :         if (SORT_CMP(storage[i], dst[j]) <= 0) {

	mov	eax, DWORD PTR _dst$[ebp]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [eax+edi*4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 389  :         if (SORT_CMP(storage[i], dst[j]) <= 0) {

	lea	eax, DWORD PTR [eax+edi*4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [ecx]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 389  :         if (SORT_CMP(storage[i], dst[j]) <= 0) {

	mov	DWORD PTR tv783[ebp], eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN44@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 389  :         if (SORT_CMP(storage[i], dst[j]) <= 0) {

	test	eax, eax
	jle	SHORT $LN44@libxml_dom

; 391  :         } else {
; 392  :           dst[k] = dst[j++];

	mov	ecx, DWORD PTR tv783[ebp]
	inc	edi
	mov	eax, DWORD PTR _i$1$[ebp]

; 393  :         }

	mov	edx, DWORD PTR _dst$[ebp]
	jmp	SHORT $LN49@libxml_dom
$LN44@libxml_dom:

; 390  :           dst[k] = storage[i++];

	mov	eax, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR tv793[ebp]
	inc	eax

; 393  :         }

	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _i$1$[ebp], eax
	jmp	SHORT $LN49@libxml_dom
$LN9@libxml_dom:

; 394  :       } else if (i < A) {
; 395  :         dst[k] = storage[i++];

	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
$LN49@libxml_dom:

; 384  :     i = 0;
; 385  :     j = curr + A;
; 386  : 
; 387  :     for (k = curr; k < curr + A + B; k++) {

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ebx*4], ecx
	inc	ebx
	cmp	ebx, esi
	jb	SHORT $LL4@libxml_dom

; 416  :       } else {
; 417  :         break;
; 418  :       }
; 419  :     }
; 420  :   }
; 421  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@libxml_dom:

; 396  :       } else {
; 397  :         break;
; 398  :       }
; 399  :     }
; 400  :   } else {
; 401  :     /* right merge */
; 402  :     memcpy(storage, &dst[curr + A], B * sizeof(SORT_TYPE));

	lea	eax, DWORD PTR [esi*4]
	push	eax
	mov	eax, DWORD PTR _dst$[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	push	eax
	push	ecx
	call	_memcpy

; 403  :     i = B;
; 404  :     j = curr + A;
; 405  :     k = curr + A + B;
; 406  : 
; 407  :     while (k-- > curr) {

	mov	eax, DWORD PTR _k$2$[ebp]
	add	esp, 12					; 0000000cH
	cmp	eax, ebx
	jbe	SHORT $LN46@libxml_dom
	mov	edx, DWORD PTR _dst$[ebp]
	npad	4
$LL5@libxml_dom:
	dec	eax
	mov	DWORD PTR _k$2$[ebp], eax

; 408  :       if ((i > 0) && (j > curr)) {

	test	esi, esi
	je	SHORT $LN46@libxml_dom
	cmp	edi, ebx
	jbe	SHORT $LN15@libxml_dom
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _storage$1$[ebp]
	push	DWORD PTR [eax+esi*4-4]
	mov	eax, DWORD PTR _dst$[ebp]
	push	DWORD PTR [eax+edi*4-4]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN17@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 409  :         if (SORT_CMP(dst[j - 1], storage[i - 1]) > 0) {

	test	eax, eax
	jle	SHORT $LN17@libxml_dom

; 410  :           dst[k] = dst[--j];

	mov	eax, DWORD PTR _dst$[ebp]
	dec	edi

; 413  :         }

	mov	edx, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _k$2$[ebp]
	jmp	SHORT $LN20@libxml_dom
$LN17@libxml_dom:

; 411  :         } else {
; 412  :           dst[k] = storage[--i];

	mov	eax, DWORD PTR _storage$1$[ebp]
	dec	esi

; 413  :         }

	mov	edx, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _k$2$[ebp]
	jmp	SHORT $LN20@libxml_dom
$LN15@libxml_dom:

; 414  :       } else if (i > 0) {
; 415  :         dst[k] = storage[--i];

	mov	ecx, DWORD PTR _storage$1$[ebp]
	dec	esi
	mov	ecx, DWORD PTR [ecx+esi*4]
$LN20@libxml_dom:

; 403  :     i = B;
; 404  :     j = curr + A;
; 405  :     k = curr + A + B;
; 406  : 
; 407  :     while (k-- > curr) {

	mov	DWORD PTR [edx+eax*4], ecx
	cmp	eax, ebx
	ja	SHORT $LL5@libxml_dom
$LN46@libxml_dom:
	pop	edi

; 416  :       } else {
; 417  :         break;
; 418  :       }
; 419  :     }
; 420  :   }
; 421  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@libxml_dom:
_libxml_domnode_tim_sort_merge ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_tim_sort_resize
_TEXT	SEGMENT
_store$ = 8						; size = 4
_new_size$ = 12						; size = 4
_libxml_domnode_tim_sort_resize PROC			; COMDAT

; 356  : static void TIM_SORT_RESIZE(TEMP_STORAGE_T *store, const size_t new_size) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _store$[ebp]
	mov	edi, DWORD PTR _new_size$[ebp]
	cmp	DWORD PTR [esi], edi
	jae	SHORT $LN2@libxml_dom

; 357  :   if (store->alloc < new_size) {
; 358  :     SORT_TYPE *tempstore = (SORT_TYPE *)realloc(store->storage, new_size * sizeof(SORT_TYPE));

	push	ebx
	lea	ebx, DWORD PTR [edi*4]
	push	ebx
	push	DWORD PTR [esi+4]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 359  : 
; 360  :     if (tempstore == NULL) {

	test	eax, eax
	jne	SHORT $LN3@libxml_dom

; 361  :       fprintf(stderr, "Error allocating temporary storage for tim sort: need %lu bytes",

	push	ebx
	push	OFFSET ??_C@_0EA@JENGBCEE@Error?5allocating?5temporary?5stor@
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 362  :               (unsigned long)(sizeof(SORT_TYPE) * new_size));
; 363  :       exit(1);

	push	1
	call	DWORD PTR __imp__exit
$LN3@libxml_dom:

; 364  :     }
; 365  : 
; 366  :     store->storage = tempstore;

	mov	DWORD PTR [esi+4], eax

; 367  :     store->alloc = new_size;

	mov	DWORD PTR [esi], edi
	pop	ebx
$LN2@libxml_dom:

; 368  :   }
; 369  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN5@libxml_dom:
_libxml_domnode_tim_sort_resize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_check_invariant
_TEXT	SEGMENT
_stack$ = 8						; size = 4
_stack_curr$ = 12					; size = 4
_libxml_domnode_check_invariant PROC			; COMDAT

; 322  : static int CHECK_INVARIANT(TIM_SORT_RUN_T *stack, const int stack_curr) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _stack_curr$[ebp]
	cmp	ecx, 2
	jl	SHORT $LN4@libxml_dom

; 323  :   size_t A, B, C;
; 324  : 
; 325  :   if (stack_curr < 2) {
; 326  :     return 1;
; 327  :   }
; 328  : 
; 329  :   if (stack_curr == 2) {

	mov	eax, DWORD PTR _stack$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8-12]
	lea	edi, DWORD PTR [eax+ecx*8]
	mov	esi, DWORD PTR [edi-4]
	jne	SHORT $LN3@libxml_dom

; 330  :     const size_t A1 = stack[stack_curr - 2].length;
; 331  :     const size_t B1 = stack[stack_curr - 1].length;
; 332  : 
; 333  :     if (A1 <= B1) {

	cmp	edx, esi
	jbe	SHORT $LN6@libxml_dom
$LN4@libxml_dom:
	pop	edi

; 346  :   }
; 347  : 
; 348  :   return 1;
; 349  : }

	mov	eax, 1
	pop	esi
	pop	ebp
	ret	0
$LN3@libxml_dom:

; 334  :       return 0;
; 335  :     }
; 336  : 
; 337  :     return 1;
; 338  :   }
; 339  : 
; 340  :   A = stack[stack_curr - 3].length;
; 341  :   B = stack[stack_curr - 2].length;
; 342  :   C = stack[stack_curr - 1].length;
; 343  : 
; 344  :   if ((A <= B + C) || (B <= C)) {

	lea	eax, DWORD PTR [esi+edx]
	cmp	DWORD PTR [edi-20], eax
	jbe	SHORT $LN6@libxml_dom
	cmp	edx, esi
	ja	SHORT $LN4@libxml_dom
$LN6@libxml_dom:
	pop	edi

; 345  :     return 0;

	xor	eax, eax

; 346  :   }
; 347  : 
; 348  :   return 1;
; 349  : }

	pop	esi
	pop	ebp
	ret	0
_libxml_domnode_check_invariant ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_count_run
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_start$ = 12						; size = 4
_size$ = 16						; size = 4
_libxml_domnode_count_run PROC				; COMDAT

; 270  : static size_t COUNT_RUN(SORT_TYPE *dst, const size_t start, const size_t size) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _size$[ebp]
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, 1
	jne	SHORT $LN6@libxml_dom
	pop	ebx

; 319  :   }
; 320  : }

	pop	ebp
	ret	0
$LN6@libxml_dom:

; 271  :   size_t curr;
; 272  : 
; 273  :   if (size - start == 1) {
; 274  :     return 1;
; 275  :   }
; 276  : 
; 277  :   if (start >= size - 2) {

	lea	eax, DWORD PTR [ebx-2]
	push	esi
	push	edi
	cmp	ecx, eax
	jb	SHORT $LN7@libxml_dom

; 278  :     if (SORT_CMP(dst[size - 2], dst[size - 1]) > 0) {

	mov	eax, DWORD PTR _dst$[ebp]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [eax+ebx*4-4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 278  :     if (SORT_CMP(dst[size - 2], dst[size - 1]) > 0) {

	lea	esi, DWORD PTR [eax+ebx*4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [eax+ebx*4-8]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 278  :     if (SORT_CMP(dst[size - 2], dst[size - 1]) > 0) {

	lea	edi, DWORD PTR [eax+ebx*4]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN8@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 278  :     if (SORT_CMP(dst[size - 2], dst[size - 1]) > 0) {

	test	eax, eax
	jle	SHORT $LN8@libxml_dom

; 279  :       SORT_SWAP(dst[size - 2], dst[size - 1]);

	mov	ecx, DWORD PTR [edi-8]
	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi-8], eax
	mov	DWORD PTR [esi-4], ecx
$LN8@libxml_dom:

; 280  :     }
; 281  : 
; 282  :     return 2;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 319  :   }
; 320  : }

	pop	ebp
	ret	0
$LN7@libxml_dom:

; 287  :   if (SORT_CMP(dst[start], dst[start + 1]) <= 0) {

	mov	edi, DWORD PTR _dst$[ebp]
	lea	esi, DWORD PTR [ecx+2]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [edi+ecx*4+4]
	push	DWORD PTR [edi+ecx*4]
	call	_xmlXPathCmpNodesExt
	add	esp, 8
	dec	ebx

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN55@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 287  :   if (SORT_CMP(dst[start], dst[start + 1]) <= 0) {

	test	eax, eax
	jle	SHORT $LN55@libxml_dom

; 302  :   } else {
; 303  :     /* decreasing run */
; 304  :     while (1) {
; 305  :       if (curr == size - 1) {

	cmp	esi, ebx
	je	SHORT $LN58@libxml_dom
	npad	8
$LL4@libxml_dom:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [edi+esi*4]
	push	DWORD PTR [edi+esi*4-4]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN58@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 309  :       if (SORT_CMP(dst[curr - 1], dst[curr]) <= 0) {

	test	eax, eax
	jle	SHORT $LN58@libxml_dom

; 310  :         break;
; 311  :       }
; 312  : 
; 313  :       curr++;

	inc	esi
	cmp	esi, ebx
	jne	SHORT $LL4@libxml_dom
$LN58@libxml_dom:

; 314  :     }
; 315  : 
; 316  :     /* reverse in-place */
; 317  :     REVERSE_ELEMENTS(dst, start, curr - 1);

	mov	eax, DWORD PTR _start$[ebp]
	lea	edx, DWORD PTR [esi-1]
	mov	ebx, eax

; 260  :     if (start >= end) {

	cmp	eax, edx
	jae	SHORT $LN45@libxml_dom
	npad	5
$LL33@libxml_dom:

; 261  :       return;
; 262  :     }
; 263  : 
; 264  :     SORT_SWAP(dst[start], dst[end]);

	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edi+ebx*4], eax

; 265  :     start++;

	inc	ebx
	mov	DWORD PTR [edi+edx*4], ecx

; 266  :     end--;

	dec	edx
	cmp	ebx, edx
	jb	SHORT $LL33@libxml_dom
	mov	eax, DWORD PTR _start$[ebp]
$LN45@libxml_dom:

; 318  :     return curr - start;

	sub	esi, eax
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 319  :   }
; 320  : }

	pop	ebp
	ret	0
$LN55@libxml_dom:

; 288  :     /* increasing run */
; 289  :     while (1) {
; 290  :       if (curr == size - 1) {

	cmp	esi, ebx
	je	SHORT $LN59@libxml_dom
$LL2@libxml_dom:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [edi+esi*4]
	push	DWORD PTR [edi+esi*4-4]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN56@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 294  :       if (SORT_CMP(dst[curr - 1], dst[curr]) > 0) {

	test	eax, eax
	jg	SHORT $LN59@libxml_dom
$LN56@libxml_dom:

; 295  :         break;
; 296  :       }
; 297  : 
; 298  :       curr++;

	inc	esi
	cmp	esi, ebx
	jne	SHORT $LL2@libxml_dom
$LN59@libxml_dom:

; 299  :     }
; 300  : 
; 301  :     return curr - start;

	sub	esi, DWORD PTR _start$[ebp]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 319  :   }
; 320  : }

	pop	ebp
	ret	0
_libxml_domnode_count_run ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_reverse_elements
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_libxml_domnode_reverse_elements PROC			; COMDAT

; 258  : static __inline void REVERSE_ELEMENTS(SORT_TYPE *dst, size_t start, size_t end) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR _end$[ebp]
	cmp	esi, eax
	jae	SHORT $LN8@libxml_dom
	push	edi
	mov	edi, DWORD PTR _dst$[ebp]
	npad	4
$LL2@libxml_dom:

; 259  :   while (1) {
; 260  :     if (start >= end) {
; 261  :       return;
; 262  :     }
; 263  : 
; 264  :     SORT_SWAP(dst[start], dst[end]);

	mov	edx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [edi+esi*4], ecx

; 265  :     start++;

	inc	esi
	mov	DWORD PTR [edi+eax*4], edx

; 266  :     end--;

	dec	eax
	cmp	esi, eax
	jb	SHORT $LL2@libxml_dom
	pop	edi
$LN8@libxml_dom:
	pop	esi

; 267  :   }
; 268  : }

	pop	ebp
	ret	0
_libxml_domnode_reverse_elements ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_binary_insertion_sort_start
_TEXT	SEGMENT
tv165 = -12						; size = 4
tv467 = -8						; size = 4
_x$1$ = -4						; size = 4
_dst$ = 8						; size = 4
tv470 = 12						; size = 4
_start$ = 12						; size = 4
_size$ = 16						; size = 4
_libxml_domnode_binary_insertion_sort_start PROC	; COMDAT

; 217  : static void BINARY_INSERTION_SORT_START(SORT_TYPE *dst, const size_t start, const size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __C4BA4707_timsort@h
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edi, DWORD PTR _size$[ebp]
	cmp	ecx, edi
	jae	$LN3@libxml_dom
	mov	eax, DWORD PTR _dst$[ebp]
	sub	edi, ecx
	push	ebx
	push	esi
	lea	esi, DWORD PTR [ecx-1]
	mov	DWORD PTR _size$[ebp], edi
	lea	ebx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv470[ebp], esi
	mov	DWORD PTR tv467[ebp], ebx
$LL4@libxml_dom:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [ebx]
	push	DWORD PTR [ebx-4]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	$LN2@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 226  :     if (SORT_CMP(dst[i - 1], dst[i]) <= 0) {

	test	eax, eax
	jle	$LN2@libxml_dom
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _dst$[ebp]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 181  :   l = 0;

	xor	edi, edi

; 227  :       continue;
; 228  :     }
; 229  : 
; 230  :     /* Else we need to find the right place, shift everything over, and squeeze in */
; 231  :     x = dst[i];

	mov	ecx, DWORD PTR [ebx]

; 182  :   r = size - 1;

	mov	ebx, esi

; 227  :       continue;
; 228  :     }
; 229  : 
; 230  :     /* Else we need to find the right place, shift everything over, and squeeze in */
; 231  :     x = dst[i];

	mov	DWORD PTR _x$1$[ebp], ecx

; 183  :   c = r >> 1;

	shr	esi, 1
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [eax]
	push	ecx
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	$LN52@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 186  :   if (SORT_CMP(x, dst[0]) < 0) {

	js	$LN52@libxml_dom
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR tv467[ebp]
	push	DWORD PTR [eax-4]
	push	DWORD PTR _x$1$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN20@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 188  :   } else if (SORT_CMP(x, dst[r]) > 0) {

	test	eax, eax
	jle	SHORT $LN20@libxml_dom

; 189  :     return r;

	mov	ecx, DWORD PTR tv470[ebp]
	mov	esi, ecx
	jmp	SHORT $LN54@libxml_dom
$LN20@libxml_dom:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	push	DWORD PTR _x$1$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN53@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 197  :     if (val < 0) {

	js	SHORT $LN53@libxml_dom

; 203  :     } else { /* allow = for stability. The binary search favors the right. */
; 204  :       if (r - c <= 1) {

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jbe	SHORT $LN43@libxml_dom

; 206  :       }
; 207  : 
; 208  :       l = c;

	mov	edi, esi

; 209  :     }
; 210  : 
; 211  :     c = l + ((r - l) >> 1);

	mov	esi, ebx
	sub	esi, edi
	shr	esi, 1
	add	esi, edi

; 212  :     cx = dst[c];
; 213  :   }

	jmp	SHORT $LN20@libxml_dom
$LN53@libxml_dom:

; 198  :       if (c - l <= 1) {

	mov	eax, esi
	sub	eax, edi
	cmp	eax, 1
	jbe	SHORT $LN42@libxml_dom

; 199  :         return c;
; 200  :       }
; 201  : 
; 202  :       r = c;

	mov	ebx, esi

; 209  :     }
; 210  : 
; 211  :     c = l + ((r - l) >> 1);

	sub	esi, edi
	shr	esi, 1
	add	esi, edi

; 212  :     cx = dst[c];
; 213  :   }

	jmp	SHORT $LN20@libxml_dom
$LN43@libxml_dom:

; 205  :         return c + 1;

	inc	esi
$LN42@libxml_dom:

; 232  :     location = BINARY_INSERTION_FIND(dst, x, i);
; 233  : 
; 234  :     for (j = i - 1; j >= location; j--) {

	mov	ecx, DWORD PTR tv470[ebp]
	cmp	ecx, esi
	jae	SHORT $LN54@libxml_dom
	mov	edx, DWORD PTR _dst$[ebp]
$LN44@libxml_dom:

; 238  :         break;
; 239  :       }
; 240  :     }
; 241  : 
; 242  :     dst[location] = x;

	mov	eax, DWORD PTR _x$1$[ebp]
	mov	ebx, DWORD PTR tv467[ebp]
	mov	edi, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+esi*4], eax
	mov	esi, DWORD PTR tv470[ebp]
$LN2@libxml_dom:

; 218  :   size_t i;
; 219  : 
; 220  :   for (i = start; i < size; i++) {

	add	ebx, 4
	inc	esi
	sub	edi, 1
	mov	DWORD PTR tv467[ebp], ebx
	mov	DWORD PTR tv470[ebp], esi
	mov	DWORD PTR _size$[ebp], edi
	jne	$LL4@libxml_dom
	pop	esi
	pop	ebx
$LN3@libxml_dom:
	pop	edi

; 243  :   }
; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@libxml_dom:
	mov	ecx, DWORD PTR tv470[ebp]

; 187  :     return 0;

	xor	esi, esi
$LN54@libxml_dom:
	mov	edx, DWORD PTR _dst$[ebp]
$LL7@libxml_dom:

; 235  :       dst[j + 1] = dst[j];

	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 236  : 
; 237  :       if (j == 0) { /* check edge case because j is unsigned */

	test	ecx, ecx
	je	SHORT $LN44@libxml_dom

; 232  :     location = BINARY_INSERTION_FIND(dst, x, i);
; 233  : 
; 234  :     for (j = i - 1; j >= location; j--) {

	dec	ecx
	cmp	ecx, esi
	jae	SHORT $LL7@libxml_dom
	jmp	SHORT $LN44@libxml_dom
_libxml_domnode_binary_insertion_sort_start ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_binary_insertion_find
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_x$ = 12						; size = 4
tv133 = 16						; size = 4
_size$ = 16						; size = 4
_libxml_domnode_binary_insertion_find PROC		; COMDAT

; 178  :     const size_t size) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _dst$[ebp]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 181  :   l = 0;

	xor	edi, edi

; 182  :   r = size - 1;

	mov	ebx, DWORD PTR _size$[ebp]
	dec	ebx

; 183  :   c = r >> 1;

	mov	esi, ebx
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR [eax]
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 183  :   c = r >> 1;

	shr	esi, 1
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	push	DWORD PTR _x$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN30@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 186  :   if (SORT_CMP(x, dst[0]) < 0) {

	js	SHORT $LN30@libxml_dom
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _dst$[ebp]
	push	DWORD PTR [eax+ebx*4]
	push	DWORD PTR _x$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN6@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 188  :   } else if (SORT_CMP(x, dst[r]) > 0) {

	test	eax, eax
	jle	SHORT $LN6@libxml_dom

; 214  : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN6@libxml_dom:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c

; 458  :         int res = xmlXPathCmpNodesExt(x, y);

	mov	eax, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	push	DWORD PTR _x$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8

; 459  :         return res == -2 ? res : -res;

	cmp	eax, -2					; fffffffeH
	je	SHORT $LN31@libxml_dom
	neg	eax
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h

; 197  :     if (val < 0) {

	js	SHORT $LN31@libxml_dom

; 203  :     } else { /* allow = for stability. The binary search favors the right. */
; 204  :       if (r - c <= 1) {

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jbe	SHORT $LN27@libxml_dom

; 206  :       }
; 207  : 
; 208  :       l = c;

	mov	edi, esi

; 209  :     }
; 210  : 
; 211  :     c = l + ((r - l) >> 1);

	mov	esi, ebx
	sub	esi, edi
	shr	esi, 1
	add	esi, edi

; 212  :     cx = dst[c];
; 213  :   }

	jmp	SHORT $LN6@libxml_dom
$LN31@libxml_dom:

; 198  :       if (c - l <= 1) {

	mov	eax, esi
	sub	eax, edi
	cmp	eax, 1
	jbe	SHORT $LN26@libxml_dom

; 200  :       }
; 201  : 
; 202  :       r = c;

	mov	ebx, esi

; 209  :     }
; 210  : 
; 211  :     c = l + ((r - l) >> 1);

	sub	esi, edi
	shr	esi, 1
	add	esi, edi

; 212  :     cx = dst[c];
; 213  :   }

	jmp	SHORT $LN6@libxml_dom
$LN27@libxml_dom:
	pop	edi

; 205  :         return c + 1;

	lea	eax, DWORD PTR [esi+1]

; 214  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN26@libxml_dom:
	pop	edi

; 199  :         return c;

	mov	eax, esi

; 214  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN30@libxml_dom:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_libxml_domnode_binary_insertion_find ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_tim_sort
_TEXT	SEGMENT
_run_stack$ = -1040					; size = 1024
_size$ = -16						; size = 8
__store$ = -16						; size = 8
_curr$ = -8						; size = 4
_stack_curr$ = -4					; size = 4
_dst$ = 8						; size = 4
$T1 = 12						; size = 4
_size$ = 12						; size = 4
_libxml_domnode_tim_sort PROC				; COMDAT

; 530  : void TIM_SORT(SORT_TYPE *dst, const size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1040				; 00000410H
	push	esi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _size$[ebp]
	mov	DWORD PTR _stack_curr$[ebp], 0
	mov	DWORD PTR _curr$[ebp], 0
	cmp	esi, 1
	jbe	$LN49@libxml_dom

; 531  :   size_t minrun;
; 532  :   TEMP_STORAGE_T _store, *store;
; 533  :   TIM_SORT_RUN_T run_stack[TIM_SORT_STACK_SIZE];
; 534  :   size_t stack_curr = 0;
; 535  :   size_t curr = 0;
; 536  : 
; 537  :   /* don't bother sorting an array of size 1 */
; 538  :   if (size <= 1) {
; 539  :     return;
; 540  :   }
; 541  : 
; 542  :   if (size < 64) {

	cmp	esi, 64					; 00000040H
	jae	SHORT $LN5@libxml_dom

; 253  :   BINARY_INSERTION_SORT_START(dst, 1, size);

	push	esi
	push	1
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_binary_insertion_sort_start
	add	esp, 12					; 0000000cH
	pop	esi

; 570  :     }
; 571  : 
; 572  :     if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
; 573  :       return;
; 574  :     }
; 575  :   }
; 576  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@libxml_dom:

; 87   :   if (x == 0) {

	mov	eax, esi

; 543  :     BINARY_INSERTION_SORT(dst, size);
; 544  :     return;
; 545  :   }
; 546  : 
; 547  :   /* compute the minimum run length */
; 548  :   minrun = compute_minrun(size);

	mov	DWORD PTR _size$[ebp], esi

; 87   :   if (x == 0) {

	or	eax, 0

; 543  :     BINARY_INSERTION_SORT(dst, size);
; 544  :     return;
; 545  :   }
; 546  : 
; 547  :   /* compute the minimum run length */
; 548  :   minrun = compute_minrun(size);

	mov	DWORD PTR _size$[ebp+4], 0

; 87   :   if (x == 0) {

	jne	SHORT $LN19@libxml_dom

; 88   :     return 64;

	lea	edx, DWORD PTR [eax+64]
	jmp	SHORT $LN25@libxml_dom
$LN19@libxml_dom:

; 89   :   }
; 90   : 
; 91   :   n = 0;
; 92   : 
; 93   :   if (x <= 0x00000000FFFFFFFFL) {
; 94   :     n = n + 32;
; 95   :     x = x << 32;

	mov	ecx, esi
	xor	eax, eax
	mov	edx, 32					; 00000020H

; 96   :   }
; 97   : 
; 98   :   if (x <= 0x0000FFFFFFFFFFFFL) {

	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN21@libxml_dom

; 99   :     n = n + 16;

	lea	edx, DWORD PTR [eax+48]

; 100  :     x = x << 16;

	shld	ecx, eax, 16
	shl	eax, 16					; 00000010H
$LN21@libxml_dom:

; 101  :   }
; 102  : 
; 103  :   if (x <= 0x00FFFFFFFFFFFFFFL) {

	cmp	ecx, 16777215				; 00ffffffH
	ja	SHORT $LN22@libxml_dom
	jb	SHORT $LN42@libxml_dom
	cmp	eax, -1
	ja	SHORT $LN22@libxml_dom
$LN42@libxml_dom:

; 104  :     n = n + 8;
; 105  :     x = x << 8;

	shld	ecx, eax, 8
	add	edx, 8
	shl	eax, 8
$LN22@libxml_dom:

; 106  :   }
; 107  : 
; 108  :   if (x <= 0x0FFFFFFFFFFFFFFFL) {

	cmp	ecx, 268435455				; 0fffffffH
	ja	SHORT $LN23@libxml_dom
	jb	SHORT $LN43@libxml_dom
	cmp	eax, -1
	ja	SHORT $LN23@libxml_dom
$LN43@libxml_dom:

; 109  :     n = n + 4;
; 110  :     x = x << 4;

	shld	ecx, eax, 4
	add	edx, 4
	shl	eax, 4
$LN23@libxml_dom:

; 111  :   }
; 112  : 
; 113  :   if (x <= 0x3FFFFFFFFFFFFFFFL) {

	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN24@libxml_dom
	jb	SHORT $LN44@libxml_dom
	cmp	eax, -1
	ja	SHORT $LN24@libxml_dom
$LN44@libxml_dom:

; 114  :     n = n + 2;
; 115  :     x = x << 2;

	shld	ecx, eax, 2
	add	edx, 2
	shl	eax, 2
$LN24@libxml_dom:

; 116  :   }
; 117  : 
; 118  :   if (x <= 0x7FFFFFFFFFFFFFFFL) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	SHORT $LN25@libxml_dom
	jb	SHORT $LN45@libxml_dom
	cmp	eax, -1
	ja	SHORT $LN25@libxml_dom
$LN45@libxml_dom:

; 119  :     n = n + 1;

	inc	edx
$LN25@libxml_dom:

; 132  :   const int minrun = size >> shift;

	movq	xmm1, QWORD PTR _size$[ebp]
	mov	eax, 64					; 00000040H
	sub	eax, edx
	mov	edx, 6
	cmp	eax, edx
	push	edi

; 120  :   }
; 121  : 
; 122  :   return n;
; 123  : }
; 124  : 
; 125  : #define CLZ clzll
; 126  : #endif
; 127  : #endif
; 128  : 
; 129  : static __inline int compute_minrun(const uint64_t size) {
; 130  :   const int top_bit = 64 - CLZ(size);
; 131  :   const int shift = MAX(top_bit, 6) - 6;

	cmovg	edx, eax

; 133  :   const uint64_t mask = (1ULL << shift) - 1;

	xor	ecx, ecx
	sub	edx, 6
	xor	eax, eax
	bts	ecx, edx
	cmp	edx, 32					; 00000020H
	cmovae	eax, ecx
	xor	ecx, eax
	movd	xmm0, edx
	psrlq	xmm1, xmm0
	add	ecx, -1

; 134  : 
; 135  :   if (mask & size) {

	xor	eax, eax
	movd	edi, xmm1
	and	ecx, esi
	or	ecx, eax
	mov	DWORD PTR $T1[ebp], edi
	je	SHORT $LN16@libxml_dom

; 136  :     return minrun + 1;

	inc	edi
	mov	DWORD PTR $T1[ebp], edi
$LN16@libxml_dom:
	push	ebx

; 549  :   /* temporary storage for merges */
; 550  :   store = &_store;
; 551  :   store->alloc = 0;
; 552  :   store->storage = NULL;
; 553  : 
; 554  :   if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {

	mov	ebx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR __store$[ebp], eax
	mov	DWORD PTR __store$[ebp+4], eax
	lea	eax, DWORD PTR _curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _stack_curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _run_stack$[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR __store$[ebp]
	push	eax
	push	esi
	push	ebx
	call	_PUSH_NEXT
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$LN53@libxml_dom

; 555  :     return;
; 556  :   }
; 557  : 
; 558  :   if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {

	lea	eax, DWORD PTR _curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _stack_curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _run_stack$[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR __store$[ebp]
	push	eax
	push	esi
	push	ebx
	call	_PUSH_NEXT
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN53@libxml_dom
$LN9@libxml_dom:

; 325  :   if (stack_curr < 2) {

	lea	eax, DWORD PTR _curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _stack_curr$[ebp]
	push	eax
	lea	eax, DWORD PTR _run_stack$[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR __store$[ebp]
	push	eax
	push	esi
	push	ebx
	call	_PUSH_NEXT
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN53@libxml_dom
	mov	ecx, DWORD PTR _stack_curr$[ebp]
$LL2@libxml_dom:
	cmp	ecx, 2
	jl	SHORT $LN9@libxml_dom

; 326  :     return 1;
; 327  :   }
; 328  : 
; 329  :   if (stack_curr == 2) {

	jne	SHORT $LN29@libxml_dom

; 330  :     const size_t A1 = stack[stack_curr - 2].length;
; 331  :     const size_t B1 = stack[stack_curr - 1].length;
; 332  : 
; 333  :     if (A1 <= B1) {

	mov	eax, DWORD PTR _run_stack$[ebp+4]
	cmp	eax, DWORD PTR _run_stack$[ebp+12]
	ja	SHORT $LN9@libxml_dom

; 334  :       return 0;

	jmp	SHORT $LN32@libxml_dom
$LN29@libxml_dom:

; 335  :     }
; 336  : 
; 337  :     return 1;
; 338  :   }
; 339  : 
; 340  :   A = stack[stack_curr - 3].length;
; 341  :   B = stack[stack_curr - 2].length;

	mov	edx, DWORD PTR _run_stack$[ebp+ecx*8-12]

; 342  :   C = stack[stack_curr - 1].length;

	mov	edi, DWORD PTR _run_stack$[ebp+ecx*8-4]

; 343  : 
; 344  :   if ((A <= B + C) || (B <= C)) {

	lea	eax, DWORD PTR [edi+edx]
	cmp	DWORD PTR _run_stack$[ebp+ecx*8-20], eax
	jbe	SHORT $LN51@libxml_dom
	cmp	edx, edi
	mov	edi, DWORD PTR $T1[ebp]
	ja	SHORT $LN9@libxml_dom
	jmp	SHORT $LN32@libxml_dom
$LN51@libxml_dom:
	mov	edi, DWORD PTR $T1[ebp]
$LN32@libxml_dom:

; 559  :     return;
; 560  :   }
; 561  : 
; 562  :   if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
; 563  :     return;
; 564  :   }
; 565  : 
; 566  :   while (1) {
; 567  :     if (!CHECK_INVARIANT(run_stack, stack_curr)) {
; 568  :       stack_curr = TIM_SORT_COLLAPSE(dst, run_stack, stack_curr, store, size);

	push	esi
	lea	eax, DWORD PTR __store$[ebp]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _run_stack$[ebp]
	push	eax
	push	ebx
	call	_libxml_domnode_tim_sort_collapse
	mov	ecx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _stack_curr$[ebp], ecx

; 569  :       continue;

	jmp	SHORT $LL2@libxml_dom
$LN53@libxml_dom:
	pop	ebx
	pop	edi
$LN49@libxml_dom:
	pop	esi

; 570  :     }
; 571  : 
; 572  :     if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
; 573  :       return;
; 574  :     }
; 575  :   }
; 576  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_libxml_domnode_tim_sort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _libxml_domnode_binary_insertion_sort
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_size$ = 12						; size = 4
_libxml_domnode_binary_insertion_sort PROC		; COMDAT

; 247  : void BINARY_INSERTION_SORT(SORT_TYPE *dst, const size_t size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, 1
	jbe	SHORT $LN1@libxml_dom

; 248  :   /* don't bother sorting an array of size <= 1 */
; 249  :   if (size <= 1) {
; 250  :     return;
; 251  :   }
; 252  : 
; 253  :   BINARY_INSERTION_SORT_START(dst, 1, size);

	push	eax
	push	1
	push	DWORD PTR _dst$[ebp]
	call	_libxml_domnode_binary_insertion_sort_start
	add	esp, 12					; 0000000cH
$LN1@libxml_dom:

; 254  : }

	pop	ebp
	ret	0
_libxml_domnode_binary_insertion_sort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _clzll
_TEXT	SEGMENT
_x$ = 8							; size = 8
_clzll	PROC						; COMDAT

; 84   : static int clzll(uint64_t x) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _x$[ebp]
	mov	eax, ecx
	mov	edx, DWORD PTR _x$[ebp+4]
	or	eax, edx
	jne	SHORT $LN2@clzll

; 85   :   int n;
; 86   : 
; 87   :   if (x == 0) {
; 88   :     return 64;

	mov	eax, 64					; 00000040H

; 120  :   }
; 121  : 
; 122  :   return n;
; 123  : }

	pop	ebp
	ret	0
$LN2@clzll:

; 89   :   }
; 90   : 
; 91   :   n = 0;

	xor	eax, eax

; 92   : 
; 93   :   if (x <= 0x00000000FFFFFFFFL) {

	test	edx, edx
	ja	SHORT $LN3@clzll
	jb	SHORT $LN10@clzll
	cmp	ecx, -1
	ja	SHORT $LN3@clzll
$LN10@clzll:

; 94   :     n = n + 32;
; 95   :     x = x << 32;

	mov	edx, ecx
	mov	eax, 32					; 00000020H
	xor	ecx, ecx
$LN3@clzll:

; 96   :   }
; 97   : 
; 98   :   if (x <= 0x0000FFFFFFFFFFFFL) {

	cmp	edx, 65535				; 0000ffffH
	ja	SHORT $LN4@clzll
	jb	SHORT $LN11@clzll
	cmp	ecx, -1
	ja	SHORT $LN4@clzll
$LN11@clzll:

; 99   :     n = n + 16;
; 100  :     x = x << 16;

	shld	edx, ecx, 16
	add	eax, 16					; 00000010H
	shl	ecx, 16					; 00000010H
$LN4@clzll:

; 101  :   }
; 102  : 
; 103  :   if (x <= 0x00FFFFFFFFFFFFFFL) {

	cmp	edx, 16777215				; 00ffffffH
	ja	SHORT $LN5@clzll
	jb	SHORT $LN12@clzll
	cmp	ecx, -1
	ja	SHORT $LN5@clzll
$LN12@clzll:

; 104  :     n = n + 8;
; 105  :     x = x << 8;

	shld	edx, ecx, 8
	add	eax, 8
	shl	ecx, 8
$LN5@clzll:

; 106  :   }
; 107  : 
; 108  :   if (x <= 0x0FFFFFFFFFFFFFFFL) {

	cmp	edx, 268435455				; 0fffffffH
	ja	SHORT $LN6@clzll
	jb	SHORT $LN13@clzll
	cmp	ecx, -1
	ja	SHORT $LN6@clzll
$LN13@clzll:

; 109  :     n = n + 4;
; 110  :     x = x << 4;

	shld	edx, ecx, 4
	add	eax, 4
	shl	ecx, 4
$LN6@clzll:

; 111  :   }
; 112  : 
; 113  :   if (x <= 0x3FFFFFFFFFFFFFFFL) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN7@clzll
	jb	SHORT $LN14@clzll
	cmp	ecx, -1
	ja	SHORT $LN7@clzll
$LN14@clzll:

; 114  :     n = n + 2;
; 115  :     x = x << 2;

	shld	edx, ecx, 2
	add	eax, 2
	shl	ecx, 2
$LN7@clzll:

; 116  :   }
; 117  : 
; 118  :   if (x <= 0x7FFFFFFFFFFFFFFFL) {

	cmp	edx, 2147483647				; 7fffffffH
	ja	SHORT $LN1@clzll
	jb	SHORT $LN15@clzll
	cmp	ecx, -1
	ja	SHORT $LN1@clzll
$LN15@clzll:

; 119  :     n = n + 1;

	inc	eax
$LN1@clzll:

; 120  :   }
; 121  : 
; 122  :   return n;
; 123  : }

	pop	ebp
	ret	0
_clzll	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\timsort.h
;	COMDAT _compute_minrun
_TEXT	SEGMENT
_size$ = 8						; size = 8
_compute_minrun PROC					; COMDAT

; 129  : static __inline int compute_minrun(const uint64_t size) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C4BA4707_timsort@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _size$[ebp]
	mov	ecx, edi
	mov	ebx, DWORD PTR _size$[ebp+4]

; 87   :   if (x == 0) {

	mov	eax, edi
	or	eax, ebx

; 130  :   const int top_bit = 64 - CLZ(size);

	mov	edx, ebx

; 87   :   if (x == 0) {

	jne	SHORT $LN5@compute_mi

; 88   :     return 64;

	lea	esi, DWORD PTR [eax+64]
	jmp	$LN11@compute_mi
$LN5@compute_mi:

; 89   :   }
; 90   : 
; 91   :   n = 0;

	xor	esi, esi

; 92   : 
; 93   :   if (x <= 0x00000000FFFFFFFFL) {

	test	ebx, ebx
	ja	SHORT $LN6@compute_mi
	jb	SHORT $LN13@compute_mi
	cmp	edi, -1
	ja	SHORT $LN6@compute_mi
$LN13@compute_mi:

; 94   :     n = n + 32;

	mov	esi, 32					; 00000020H

; 95   :     x = x << 32;

	mov	edx, edi
	xor	ecx, ecx
$LN6@compute_mi:

; 96   :   }
; 97   : 
; 98   :   if (x <= 0x0000FFFFFFFFFFFFL) {

	cmp	edx, 65535				; 0000ffffH
	ja	SHORT $LN7@compute_mi
	jb	SHORT $LN14@compute_mi
	cmp	ecx, -1
	ja	SHORT $LN7@compute_mi
$LN14@compute_mi:

; 99   :     n = n + 16;
; 100  :     x = x << 16;

	shld	edx, ecx, 16
	add	esi, 16					; 00000010H
	shl	ecx, 16					; 00000010H
$LN7@compute_mi:

; 101  :   }
; 102  : 
; 103  :   if (x <= 0x00FFFFFFFFFFFFFFL) {

	cmp	edx, 16777215				; 00ffffffH
	ja	SHORT $LN8@compute_mi
	jb	SHORT $LN15@compute_mi
	cmp	ecx, -1
	ja	SHORT $LN8@compute_mi
$LN15@compute_mi:

; 104  :     n = n + 8;
; 105  :     x = x << 8;

	shld	edx, ecx, 8
	add	esi, 8
	shl	ecx, 8
$LN8@compute_mi:

; 106  :   }
; 107  : 
; 108  :   if (x <= 0x0FFFFFFFFFFFFFFFL) {

	cmp	edx, 268435455				; 0fffffffH
	ja	SHORT $LN9@compute_mi
	jb	SHORT $LN16@compute_mi
	cmp	ecx, -1
	ja	SHORT $LN9@compute_mi
$LN16@compute_mi:

; 109  :     n = n + 4;
; 110  :     x = x << 4;

	shld	edx, ecx, 4
	add	esi, 4
	shl	ecx, 4
$LN9@compute_mi:

; 111  :   }
; 112  : 
; 113  :   if (x <= 0x3FFFFFFFFFFFFFFFL) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN10@compute_mi
	jb	SHORT $LN17@compute_mi
	cmp	ecx, -1
	ja	SHORT $LN10@compute_mi
$LN17@compute_mi:

; 114  :     n = n + 2;
; 115  :     x = x << 2;

	shld	edx, ecx, 2
	add	esi, 2
	shl	ecx, 2
$LN10@compute_mi:

; 116  :   }
; 117  : 
; 118  :   if (x <= 0x7FFFFFFFFFFFFFFFL) {

	cmp	edx, 2147483647				; 7fffffffH
	ja	SHORT $LN11@compute_mi
	jb	SHORT $LN18@compute_mi
	cmp	ecx, -1
	ja	SHORT $LN11@compute_mi
$LN18@compute_mi:

; 119  :     n = n + 1;

	inc	esi
$LN11@compute_mi:

; 131  :   const int shift = MAX(top_bit, 6) - 6;
; 132  :   const int minrun = size >> shift;

	movq	xmm1, QWORD PTR _size$[ebp]
	mov	eax, 64					; 00000040H
	sub	eax, esi
	mov	edx, 6
	cmp	eax, edx
	cmovg	edx, eax

; 133  :   const uint64_t mask = (1ULL << shift) - 1;

	xor	ecx, ecx
	xor	eax, eax
	sub	edx, 6
	bts	ecx, edx
	cmp	edx, 32					; 00000020H
	cmovae	eax, ecx
	xor	ecx, eax
	movd	xmm0, edx
	cmp	edx, 64					; 00000040H
	psrlq	xmm1, xmm0
	cmovae	eax, ecx
	add	ecx, -1
	movd	esi, xmm1
	adc	eax, -1

; 134  : 
; 135  :   if (mask & size) {

	and	ecx, edi
	and	eax, ebx
	or	ecx, eax

; 136  :     return minrun + 1;

	lea	eax, DWORD PTR [esi+1]
	jne	SHORT $LN1@compute_mi

; 137  :   }
; 138  : 
; 139  :   return minrun;

	mov	eax, esi
$LN1@compute_mi:
	pop	edi

; 140  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_compute_minrun ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _wrap_cmp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap_cmp PROC						; COMDAT

; 457  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _y$[ebp]
	push	DWORD PTR _x$[ebp]
	call	_xmlXPathCmpNodesExt
	add	esp, 8
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN3@wrap_cmp

; 460  :     }

	pop	ebp
	ret	0
$LN3@wrap_cmp:

; 458  :         int res = xmlXPathCmpNodesExt(x, y);
; 459  :         return res == -2 ? res : -res;

	neg	eax

; 460  :     }

	pop	ebp
	ret	0
_wrap_cmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCmpNodesExt
_TEXT	SEGMENT
tv789 = -12						; size = 4
_cur$5$ = -8						; size = 4
_miscNode2$1$ = -8					; size = 4
_misc$1$ = -4						; size = 4
_depth2$1$ = 8						; size = 4
_node1$ = 8						; size = 4
_node2$ = 12						; size = 4
_xmlXPathCmpNodesExt PROC				; COMDAT

; 158  : xmlXPathCmpNodesExt(xmlNodePtr node1, xmlNodePtr node2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR _node2$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node1$[ebp]
	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _misc$1$[ebp], 0
	xor	ebx, ebx
	mov	DWORD PTR _miscNode2$1$[ebp], eax
	test	ecx, ecx
	je	$LN34@xmlXPathCm

; 159  :     int depth1, depth2;
; 160  :     int misc = 0, precedence1 = 0, precedence2 = 0;
; 161  :     xmlNodePtr miscNode1 = NULL, miscNode2 = NULL;
; 162  :     xmlNodePtr cur, root;
; 163  :     ptrdiff_t l1, l2;
; 164  : 
; 165  :     if ((node1 == NULL) || (node2 == NULL))

	test	esi, esi
	je	$LN34@xmlXPathCm

; 166  : 	return(-2);
; 167  : 
; 168  :     if (node1 == node2)

	cmp	ecx, esi
	jne	SHORT $LN35@xmlXPathCm

; 432  : 	    return(1);
; 433  :     return(-1); /* assume there is no sibling list corruption */
; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlXPathCm:

; 169  : 	return(0);
; 170  : 
; 171  :     /*
; 172  :      * a couple of optimizations which will avoid computations in most cases
; 173  :      */
; 174  :     switch (node1->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	$LN52@xmlXPathCm
	movzx	eax, BYTE PTR $LN149@xmlXPathCm[eax]
	jmp	DWORD PTR $LN154@xmlXPathCm[eax*4]
$LN36@xmlXPathCm:

; 175  : 	case XML_ELEMENT_NODE:
; 176  : 	    if (node2->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [esi+4], 1
	jne	$LN52@xmlXPathCm

; 177  : 		if ((0 > (ptrdiff_t) node1->content) &&
; 178  : 		    (0 > (ptrdiff_t) node2->content) &&

	mov	edx, DWORD PTR [ecx+40]
	test	edx, edx
	jns	$turtle_comparison$156
	cmp	DWORD PTR [esi+40], ebx
	jge	$turtle_comparison$156
	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	$turtle_comparison$156

; 179  : 		    (node1->doc == node2->doc))
; 180  : 		{
; 181  : 		    l1 = -((ptrdiff_t) node1->content);
; 182  : 		    l2 = -((ptrdiff_t) node2->content);

	mov	eax, DWORD PTR [esi+40]
	neg	edx
	neg	eax

; 183  : 		    if (l1 < l2)

	cmp	edx, eax
	jl	$LN116@xmlXPathCm

; 184  : 			return(1);
; 185  : 		    if (l1 > l2)

	jle	SHORT $LN52@xmlXPathCm

; 432  : 	    return(1);
; 433  :     return(-1); /* assume there is no sibling list corruption */
; 434  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlXPathCm:

; 186  : 			return(-1);
; 187  : 		} else
; 188  : 		    goto turtle_comparison;
; 189  : 	    }
; 190  : 	    break;
; 191  : 	case XML_ATTRIBUTE_NODE:
; 192  : 	    precedence1 = 1; /* element is owner */

	mov	edi, 1

; 193  : 	    miscNode1 = node1;

	mov	ebx, ecx

; 194  : 	    node1 = node1->parent;

	mov	ecx, DWORD PTR [ecx+20]

; 195  : 	    misc = 1;

	mov	DWORD PTR _misc$1$[ebp], edi

; 196  : 	    break;

	jmp	SHORT $LN52@xmlXPathCm
$LN43@xmlXPathCm:

; 197  : 	case XML_TEXT_NODE:
; 198  : 	case XML_CDATA_SECTION_NODE:
; 199  : 	case XML_COMMENT_NODE:
; 200  : 	case XML_PI_NODE: {
; 201  : 	    miscNode1 = node1;
; 202  : 	    /*
; 203  : 	    * Find nearest element node.
; 204  : 	    */
; 205  : 	    if (node1->prev != NULL) {

	mov	eax, DWORD PTR [ecx+28]
	mov	ebx, ecx
	test	eax, eax
	je	SHORT $LN44@xmlXPathCm

; 206  : 		do {
; 207  : 		    node1 = node1->prev;

	mov	ecx, eax

; 208  : 		    if (node1->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN105@xmlXPathCm
$LL6@xmlXPathCm:

; 211  : 		    }
; 212  : 		    if (node1->prev == NULL) {

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN44@xmlXPathCm

; 208  : 		    if (node1->type == XML_ELEMENT_NODE) {

	mov	ecx, eax
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LL6@xmlXPathCm
$LN105@xmlXPathCm:

; 209  : 			precedence1 = 3; /* element in prev-sibl axis */

	mov	edi, 3

; 210  : 			break;

	jmp	SHORT $LN45@xmlXPathCm
$LN44@xmlXPathCm:

; 213  : 			precedence1 = 2; /* element is parent */
; 214  : 			/*
; 215  : 			* URGENT TODO: Are there any cases, where the
; 216  : 			* parent of such a node is not an element node?
; 217  : 			*/
; 218  : 			node1 = node1->parent;
; 219  : 			break;
; 220  : 		    }
; 221  : 		} while (1);
; 222  : 	    } else {
; 223  : 		precedence1 = 2; /* element is parent */
; 224  : 		node1 = node1->parent;
; 225  : 	    }
; 226  : 	    if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||

	mov	ecx, DWORD PTR [ecx+20]
	mov	edi, 2
$LN45@xmlXPathCm:
	test	ecx, ecx
	je	SHORT $LN50@xmlXPathCm
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN50@xmlXPathCm
	cmp	DWORD PTR [ecx+40], 0
	jge	SHORT $LN50@xmlXPathCm

; 233  : 	    } else
; 234  : 		misc = 1;

	mov	DWORD PTR _misc$1$[ebp], 1
	jmp	SHORT $LN52@xmlXPathCm
$LN50@xmlXPathCm:

; 227  : 		(0 <= (ptrdiff_t) node1->content)) {
; 228  : 		/*
; 229  : 		* Fallback for whatever case.
; 230  : 		*/
; 231  : 		node1 = miscNode1;

	mov	ecx, ebx

; 232  : 		precedence1 = 0;

	xor	edi, edi
$LN52@xmlXPathCm:

; 235  : 	}
; 236  : 	    break;
; 237  : 	case XML_NAMESPACE_DECL:
; 238  : 	    /*
; 239  : 	    * TODO: why do we return 1 for namespace nodes?
; 240  : 	    */
; 241  : 	    return(1);
; 242  : 	default:
; 243  : 	    break;
; 244  :     }
; 245  :     switch (node2->type) {

	mov	eax, DWORD PTR [esi+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	SHORT $LN64@xmlXPathCm
	movzx	eax, BYTE PTR $LN150@xmlXPathCm[eax]
	jmp	DWORD PTR $LN155@xmlXPathCm[eax*4]
$LN54@xmlXPathCm:

; 246  : 	case XML_ELEMENT_NODE:
; 247  : 	    break;
; 248  : 	case XML_ATTRIBUTE_NODE:
; 249  : 	    precedence2 = 1; /* element is owner */
; 250  : 	    miscNode2 = node2;

	mov	eax, esi
	mov	edx, 1

; 251  : 	    node2 = node2->parent;

	mov	esi, DWORD PTR [esi+20]

; 252  : 	    misc = 1;
; 253  : 	    break;

	jmp	SHORT $LN147@xmlXPathCm
$LN55@xmlXPathCm:

; 254  : 	case XML_TEXT_NODE:
; 255  : 	case XML_CDATA_SECTION_NODE:
; 256  : 	case XML_COMMENT_NODE:
; 257  : 	case XML_PI_NODE: {
; 258  : 	    miscNode2 = node2;
; 259  : 	    if (node2->prev != NULL) {

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _miscNode2$1$[ebp], esi
	test	eax, eax
	je	SHORT $LN56@xmlXPathCm

; 260  : 		do {
; 261  : 		    node2 = node2->prev;

	mov	esi, eax

; 262  : 		    if (node2->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN107@xmlXPathCm
$LL11@xmlXPathCm:

; 265  : 		    }
; 266  : 		    if (node2->prev == NULL) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN56@xmlXPathCm

; 262  : 		    if (node2->type == XML_ELEMENT_NODE) {

	mov	esi, eax
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LL11@xmlXPathCm
$LN107@xmlXPathCm:

; 263  : 			precedence2 = 3; /* element in prev-sibl axis */

	mov	edx, 3

; 264  : 			break;

	jmp	SHORT $LN57@xmlXPathCm
$LN56@xmlXPathCm:

; 267  : 			precedence2 = 2; /* element is parent */
; 268  : 			node2 = node2->parent;
; 269  : 			break;
; 270  : 		    }
; 271  : 		} while (1);
; 272  : 	    } else {
; 273  : 		precedence2 = 2; /* element is parent */
; 274  : 		node2 = node2->parent;
; 275  : 	    }
; 276  : 	    if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||

	mov	esi, DWORD PTR [esi+20]
	mov	edx, 2
$LN57@xmlXPathCm:
	test	esi, esi
	je	SHORT $LN64@xmlXPathCm
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN64@xmlXPathCm
	cmp	DWORD PTR [esi+40], 0
	jl	SHORT $LN151@xmlXPathCm
$LN64@xmlXPathCm:

; 277  : 		(0 <= (ptrdiff_t) node2->content))
; 278  : 	    {
; 279  : 		node2 = miscNode2;
; 280  : 		precedence2 = 0;
; 281  : 	    } else
; 282  : 		misc = 1;
; 283  : 	}
; 284  : 	    break;
; 285  : 	case XML_NAMESPACE_DECL:
; 286  : 	    return(1);
; 287  : 	default:
; 288  : 	    break;
; 289  :     }
; 290  :     if (misc) {

	mov	esi, DWORD PTR _node2$[ebp]
	xor	edx, edx
	cmp	DWORD PTR _misc$1$[ebp], edx
	je	$LN17@xmlXPathCm
$LN151@xmlXPathCm:

; 291  : 	if (node1 == node2) {

	mov	eax, DWORD PTR _miscNode2$1$[ebp]
$LN147@xmlXPathCm:
	cmp	ecx, esi
	jne	SHORT $LN72@xmlXPathCm

; 292  : 	    if (precedence1 == precedence2) {

	cmp	edi, edx
	jne	SHORT $LN67@xmlXPathCm

; 293  : 		/*
; 294  : 		* The ugly case; but normally there aren't many
; 295  : 		* adjacent non-element nodes around.
; 296  : 		*/
; 297  : 		cur = miscNode2->prev;

	mov	eax, DWORD PTR [eax+28]

; 298  : 		while (cur != NULL) {

	test	eax, eax
	je	$LN31@xmlXPathCm
$LL12@xmlXPathCm:

; 299  : 		    if (cur == miscNode1)

	cmp	eax, ebx
	je	SHORT $LN116@xmlXPathCm

; 300  : 			return(1);
; 301  : 		    if (cur->type == XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	je	$LN31@xmlXPathCm

; 302  : 			return(-1);
; 303  : 		    cur = cur->prev;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL12@xmlXPathCm

; 432  : 	    return(1);
; 433  :     return(-1); /* assume there is no sibling list corruption */
; 434  : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlXPathCm:

; 304  : 		}
; 305  : 		return (-1);
; 306  : 	    } else {
; 307  : 		/*
; 308  : 		* Evaluate based on higher precedence wrt to the element.
; 309  : 		* TODO: This assumes attributes are sorted before content.
; 310  : 		*   Is this 100% correct?
; 311  : 		*/
; 312  : 		if (precedence1 < precedence2)

	jae	$LN31@xmlXPathCm
$LN116@xmlXPathCm:
	pop	edi

; 432  : 	    return(1);
; 433  :     return(-1); /* assume there is no sibling list corruption */
; 434  : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlXPathCm:

; 313  : 		    return(1);
; 314  : 		else
; 315  : 		    return(-1);
; 316  : 	    }
; 317  : 	}
; 318  : 	/*
; 319  : 	* Special case: One of the helper-elements is contained by the other.
; 320  : 	* <foo>
; 321  : 	*   <node2>
; 322  : 	*     <node1>Text-1(precedence1 == 2)</node1>
; 323  : 	*   </node2>
; 324  : 	*   Text-6(precedence2 == 3)
; 325  : 	* </foo>
; 326  : 	*/
; 327  : 	if ((precedence2 == 3) && (precedence1 > 1)) {

	cmp	edx, 3
	jne	SHORT $LN15@xmlXPathCm
	cmp	edi, 1
	jbe	SHORT $LN15@xmlXPathCm

; 328  : 	    cur = node1->parent;

	mov	eax, DWORD PTR [ecx+20]

; 329  : 	    while (cur) {

	test	eax, eax
	je	SHORT $LN15@xmlXPathCm
	npad	6
$LL14@xmlXPathCm:

; 330  : 		if (cur == node2)

	cmp	eax, esi
	je	SHORT $LN116@xmlXPathCm

; 331  : 		    return(1);
; 332  : 		cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL14@xmlXPathCm
$LN15@xmlXPathCm:

; 333  : 	    }
; 334  : 	}
; 335  : 	if ((precedence1 == 3) && (precedence2 > 1)) {

	cmp	edi, 3
	jne	SHORT $LN17@xmlXPathCm
	cmp	edx, 1
	jbe	SHORT $LN17@xmlXPathCm

; 336  : 	    cur = node2->parent;

	mov	eax, DWORD PTR [esi+20]

; 337  : 	    while (cur) {

	test	eax, eax
	je	SHORT $LN17@xmlXPathCm
	npad	4
$LL16@xmlXPathCm:

; 338  : 		if (cur == node1)

	cmp	eax, ecx
	je	$LN31@xmlXPathCm

; 339  : 		    return(-1);
; 340  : 		cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL16@xmlXPathCm
$LN17@xmlXPathCm:

; 341  : 	    }
; 342  : 	}
; 343  :     }
; 344  : 
; 345  :     /*
; 346  :      * Speedup using document order if availble.
; 347  :      */
; 348  :     if ((node1->type == XML_ELEMENT_NODE) &&
; 349  : 	(node2->type == XML_ELEMENT_NODE) &&
; 350  : 	(0 > (ptrdiff_t) node1->content) &&
; 351  : 	(0 > (ptrdiff_t) node2->content) &&

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $turtle_comparison$156
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $turtle_comparison$156
	mov	edx, DWORD PTR [ecx+40]
	test	edx, edx
	jns	SHORT $turtle_comparison$156
	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	jns	SHORT $turtle_comparison$156
	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $turtle_comparison$156

; 352  : 	(node1->doc == node2->doc)) {
; 353  : 
; 354  : 	l1 = -((ptrdiff_t) node1->content);

	neg	edx

; 355  : 	l2 = -((ptrdiff_t) node2->content);

	neg	edi

; 356  : 	if (l1 < l2)

	cmp	edx, edi
	jl	SHORT $LN116@xmlXPathCm

; 357  : 	    return(1);
; 358  : 	if (l1 > l2)

	jg	$LN31@xmlXPathCm
$turtle_comparison$156:

; 359  : 	    return(-1);
; 360  :     }
; 361  : 
; 362  : turtle_comparison:
; 363  : 
; 364  :     if (node1 == node2->prev)

	cmp	ecx, DWORD PTR [esi+28]
	je	$LN116@xmlXPathCm

; 365  : 	return(1);
; 366  :     if (node1 == node2->next)

	cmp	ecx, DWORD PTR [esi+24]
	je	$LN31@xmlXPathCm

; 367  : 	return(-1);
; 368  :     /*
; 369  :      * compute depth to root
; 370  :      */
; 371  :     for (depth2 = 0, cur = node2; cur->parent != NULL; cur = cur->parent) {

	mov	edx, DWORD PTR [esi+20]
	xor	eax, eax
	mov	DWORD PTR _depth2$1$[ebp], eax
	mov	ebx, esi
	test	edx, edx
	je	SHORT $LN19@xmlXPathCm
	npad	1
$LL20@xmlXPathCm:

; 372  : 	if (cur->parent == node1)

	cmp	edx, ecx
	je	$LN116@xmlXPathCm

; 373  : 	    return(1);
; 374  : 	depth2++;

	mov	ebx, edx
	inc	eax
	mov	DWORD PTR _depth2$1$[ebp], eax
	mov	edx, DWORD PTR [ebx+20]
	test	edx, edx
	jne	SHORT $LL20@xmlXPathCm
$LN19@xmlXPathCm:

; 375  :     }
; 376  :     root = cur;
; 377  :     for (depth1 = 0, cur = node1; cur->parent != NULL; cur = cur->parent) {

	mov	edx, DWORD PTR [ecx+20]
	xor	edi, edi
	mov	DWORD PTR _cur$5$[ebp], ecx
	test	edx, edx
	je	SHORT $LN22@xmlXPathCm
$LL23@xmlXPathCm:

; 378  : 	if (cur->parent == node2)

	cmp	edx, esi
	je	$LN31@xmlXPathCm

; 379  : 	    return(-1);
; 380  : 	depth1++;

	mov	eax, edx
	inc	edi
	mov	DWORD PTR _cur$5$[ebp], eax
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _depth2$1$[ebp]
	test	edx, edx
	jne	SHORT $LL23@xmlXPathCm
$LN22@xmlXPathCm:

; 381  :     }
; 382  :     /*
; 383  :      * Distinct document (or distinct entities :-( ) case.
; 384  :      */
; 385  :     if (root != cur) {

	cmp	ebx, DWORD PTR _cur$5$[ebp]
	jne	$LN34@xmlXPathCm

; 386  : 	return(-2);
; 387  :     }
; 388  :     /*
; 389  :      * get the nearest common ancestor.
; 390  :      */
; 391  :     while (depth1 > depth2) {

	cmp	eax, edi
	jge	SHORT $LN152@xmlXPathCm
	sub	edi, eax
	mov	edx, edi
	mov	edi, eax
	npad	4
$LL24@xmlXPathCm:

; 392  : 	depth1--;
; 393  : 	node1 = node1->parent;

	mov	ecx, DWORD PTR [ecx+20]
	sub	edx, 1
	jne	SHORT $LL24@xmlXPathCm

; 394  :     }
; 395  :     while (depth2 > depth1) {

	cmp	eax, edi
$LN152@xmlXPathCm:
	jle	SHORT $LN103@xmlXPathCm
	sub	eax, edi
	npad	2
$LL26@xmlXPathCm:

; 396  : 	depth2--;
; 397  : 	node2 = node2->parent;

	mov	esi, DWORD PTR [esi+20]
	sub	eax, 1
	jne	SHORT $LL26@xmlXPathCm
$LN103@xmlXPathCm:

; 398  :     }
; 399  :     while (node1->parent != node2->parent) {

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [esi+20]
	cmp	eax, edx
	je	SHORT $LN29@xmlXPathCm
$LL28@xmlXPathCm:

; 400  : 	node1 = node1->parent;

	mov	ecx, eax

; 401  : 	node2 = node2->parent;

	mov	esi, edx

; 402  : 	/* should not happen but just in case ... */
; 403  : 	if ((node1 == NULL) || (node2 == NULL))

	test	ecx, ecx
	je	SHORT $LN34@xmlXPathCm
	test	esi, esi
	je	SHORT $LN34@xmlXPathCm

; 398  :     }
; 399  :     while (node1->parent != node2->parent) {

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [esi+20]
	cmp	eax, edx
	jne	SHORT $LL28@xmlXPathCm
$LN29@xmlXPathCm:

; 404  : 	    return(-2);
; 405  :     }
; 406  :     /*
; 407  :      * Find who's first.
; 408  :      */
; 409  :     if (node1 == node2->prev)

	cmp	ecx, DWORD PTR [esi+28]
	je	$LN116@xmlXPathCm

; 410  : 	return(1);
; 411  :     if (node1 == node2->next)

	cmp	ecx, DWORD PTR [esi+24]
	je	SHORT $LN31@xmlXPathCm

; 412  : 	return(-1);
; 413  :     /*
; 414  :      * Speedup using document order if availble.
; 415  :      */
; 416  :     if ((node1->type == XML_ELEMENT_NODE) &&
; 417  : 	(node2->type == XML_ELEMENT_NODE) &&
; 418  : 	(0 > (ptrdiff_t) node1->content) &&
; 419  : 	(0 > (ptrdiff_t) node2->content) &&

	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN91@xmlXPathCm
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN91@xmlXPathCm
	mov	edx, DWORD PTR [ecx+40]
	test	edx, edx
	jns	SHORT $LN91@xmlXPathCm
	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	jns	SHORT $LN91@xmlXPathCm
	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN91@xmlXPathCm

; 420  : 	(node1->doc == node2->doc)) {
; 421  : 
; 422  : 	l1 = -((ptrdiff_t) node1->content);

	neg	edx

; 423  : 	l2 = -((ptrdiff_t) node2->content);

	neg	edi

; 424  : 	if (l1 < l2)

	cmp	edx, edi
	jl	$LN116@xmlXPathCm

; 425  : 	    return(1);
; 426  : 	if (l1 > l2)

	jg	SHORT $LN31@xmlXPathCm
$LN91@xmlXPathCm:

; 427  : 	    return(-1);
; 428  :     }
; 429  : 
; 430  :     for (cur = node1->next;cur != NULL;cur = cur->next)

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN31@xmlXPathCm
	npad	3
$LL32@xmlXPathCm:

; 431  : 	if (cur == node2)

	cmp	eax, esi
	je	$LN116@xmlXPathCm

; 427  : 	    return(-1);
; 428  :     }
; 429  : 
; 430  :     for (cur = node1->next;cur != NULL;cur = cur->next)

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL32@xmlXPathCm
$LN31@xmlXPathCm:
	pop	edi

; 432  : 	    return(1);
; 433  :     return(-1); /* assume there is no sibling list corruption */
; 434  : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlXPathCm:
	pop	edi
	pop	esi
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN154@xmlXPathCm:
	DD	$LN36@xmlXPathCm
	DD	$LN42@xmlXPathCm
	DD	$LN43@xmlXPathCm
	DD	$LN116@xmlXPathCm
	DD	$LN52@xmlXPathCm
$LN149@xmlXPathCm:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	npad	2
$LN155@xmlXPathCm:
	DD	$LN54@xmlXPathCm
	DD	$LN55@xmlXPathCm
	DD	$LN116@xmlXPathCm
	DD	$LN64@xmlXPathCm
$LN150@xmlXPathCm:
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_xmlXPathCmpNodesExt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetFreeNs
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_xmlXPathNodeSetFreeNs PROC				; COMDAT

; 3505 : xmlXPathNodeSetFreeNs(xmlNsPtr ns) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ns$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathNo

; 3506 :     if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	jne	SHORT $LN3@xmlXPathNo

; 3507 : 	return;
; 3508 : 
; 3509 :     if ((ns->next != NULL) && (ns->next->type != XML_NAMESPACE_DECL)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN3@xmlXPathNo

; 3510 : 	if (ns->href != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@xmlXPathNo

; 3511 : 	    xmlFree((xmlChar *)ns->href);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN5@xmlXPathNo:

; 3512 : 	if (ns->prefix != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@xmlXPathNo

; 3513 : 	    xmlFree((xmlChar *)ns->prefix);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlXPathNo:

; 3514 : 	xmlFree(ns);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlXPathNo:
	pop	esi

; 3515 :     }
; 3516 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetFreeNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathBooleanFunction
_TEXT	SEGMENT
_ctxt$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathBooleanFunction PROC				; COMDAT

; 9480 : xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlXPathBo

; 9481 :     xmlXPathObjectPtr cur;
; 9482 : 
; 9483 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN3@xmlXPathBo
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9488 : }

	pop	ebp
	ret	0
$LN3@xmlXPathBo:

; 9481 :     xmlXPathObjectPtr cur;
; 9482 : 
; 9483 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN4@xmlXPathBo
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9488 : }

	pop	ebp
	ret	0
$LN4@xmlXPathBo:
	push	ebx

; 9484 :     cur = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 9485 :     if (cur == NULL) XP_ERROR(XPATH_INVALID_OPERAND);

	test	ebx, ebx
	jne	SHORT $LN5@xmlXPathBo
	push	10					; 0000000aH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	ebx
	pop	edi

; 9488 : }

	pop	ebp
	ret	0
$LN5@xmlXPathBo:

; 2737 :     if (val->type == XPATH_BOOLEAN)

	cmp	DWORD PTR [ebx], 2
	push	esi

; 9486 :     cur = xmlXPathCacheConvertBoolean(ctxt->context, cur);

	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR _ctxt$1$[ebp], esi

; 2737 :     if (val->type == XPATH_BOOLEAN)

	je	SHORT $LN7@xmlXPathBo

; 2738 : 	return(val);
; 2739 :     ret = xmlXPathCacheNewBoolean(ctxt, xmlXPathCastToBoolean(val));

	push	ebx
	call	_xmlXPathCastToBoolean
	push	eax
	push	esi
	call	_xmlXPathCacheNewBoolean

; 2740 :     xmlXPathReleaseObject(ctxt, val);

	push	ebx
	push	DWORD PTR _ctxt$1$[ebp]
	mov	esi, eax
	call	_xmlXPathReleaseObject
	add	esp, 20					; 00000014H

; 2741 :     return(ret);

	mov	ebx, esi
$LN7@xmlXPathBo:

; 9487 :     valuePush(ctxt, cur);

	push	ebx
	push	edi
	call	_valuePush
	add	esp, 8
	pop	esi
	pop	ebx
$LN1@xmlXPathBo:
	pop	edi

; 9488 : }

	pop	ebp
	ret	0
_xmlXPathBooleanFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRoundFunction
_TEXT	SEGMENT
_f$1$ = -16						; size = 8
_rounded$1 = -8						; size = 8
_f$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathRoundFunction PROC				; COMDAT

; 9700 : xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN9@xmlXPathRo

; 9701 :     double f;
; 9702 : 
; 9703 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN3@xmlXPathRo
	push	12					; 0000000cH

; 9718 :     }
; 9719 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlXPathRo:

; 9701 :     double f;
; 9702 : 
; 9703 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathRo
	push	23					; 00000017H

; 9718 :     }
; 9719 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlXPathRo:

; 9704 :     CAST_TO_NUMBER;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	test	eax, eax
	je	SHORT $LN5@xmlXPathRo
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN5@xmlXPathRo
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	edi, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathRo:

; 9705 :     CHECK_TYPE(XPATH_NUMBER);

	test	edi, edi
	je	$LN7@xmlXPathRo
	cmp	DWORD PTR [edi], 3
	jne	$LN7@xmlXPathRo

; 9706 : 
; 9707 :     f = ctxt->value->floatval;

	movsd	xmm0, QWORD PTR [edi+16]

; 9708 : 
; 9709 :     if ((f >= -0.5) && (f < 0.5)) {

	comisd	xmm0, QWORD PTR __real@bfe0000000000000
	movsd	QWORD PTR _f$1$[ebp], xmm0
	movsd	QWORD PTR _f$[ebp], xmm0
	jb	SHORT $LN8@xmlXPathRo
	movsd	xmm1, QWORD PTR __real@3fe0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@xmlXPathRo

; 9710 :         /* Handles negative zero. */
; 9711 :         ctxt->value->floatval *= 0.0;

	mulsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edi+16], xmm0

; 9718 :     }
; 9719 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathRo:

; 9712 :     }
; 9713 :     else {
; 9714 :         double rounded = floor(f);

	mov	ecx, DWORD PTR _f$[ebp]
	sub	esp, 8
	mov	edx, DWORD PTR _f$[ebp+4]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_floor

; 9715 :         if (f - rounded >= 0.5)

	movsd	xmm0, QWORD PTR _f$1$[ebp]
	add	esp, 8
	fstp	QWORD PTR _rounded$1[ebp]
	movsd	xmm1, QWORD PTR _rounded$1[ebp]
	subsd	xmm0, xmm1
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jb	SHORT $LN10@xmlXPathRo

; 9716 :             rounded += 1.0;

	addsd	xmm1, QWORD PTR __real@3ff0000000000000
$LN10@xmlXPathRo:

; 9717 :         ctxt->value->floatval = rounded;

	movsd	QWORD PTR [edi+16], xmm1

; 9718 :     }
; 9719 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathRo:

; 9705 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 9718 :     }
; 9719 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN9@xmlXPathRo:
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathRoundFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCeilingFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathCeilingFunction PROC				; COMDAT

; 9680 : xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathCe

; 9681 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN3@xmlXPathCe
	push	12					; 0000000cH

; 9686 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathCe:

; 9681 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathCe
	push	23					; 00000017H

; 9686 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathCe:

; 9682 :     CAST_TO_NUMBER;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	test	eax, eax
	je	SHORT $LN5@xmlXPathCe
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN5@xmlXPathCe
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	edi, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathCe:

; 9683 :     CHECK_TYPE(XPATH_NUMBER);

	test	edi, edi
	je	SHORT $LN7@xmlXPathCe
	cmp	DWORD PTR [edi], 3
	jne	SHORT $LN7@xmlXPathCe

; 9684 : 
; 9685 :     ctxt->value->floatval = ceil(ctxt->value->floatval);

	mov	ecx, DWORD PTR [edi+16]
	sub	esp, 8
	mov	edx, DWORD PTR [edi+20]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_ceil
	fstp	QWORD PTR [edi+16]

; 9686 : }

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlXPathCe:

; 9683 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 9686 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathCe:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathCeilingFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFloorFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathFloorFunction PROC				; COMDAT

; 9661 : xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathFl

; 9662 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN3@xmlXPathFl
	push	12					; 0000000cH

; 9667 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathFl:

; 9662 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathFl
	push	23					; 00000017H

; 9667 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathFl:

; 9663 :     CAST_TO_NUMBER;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	test	eax, eax
	je	SHORT $LN5@xmlXPathFl
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN5@xmlXPathFl
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	edi, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathFl:

; 9664 :     CHECK_TYPE(XPATH_NUMBER);

	test	edi, edi
	je	SHORT $LN7@xmlXPathFl
	cmp	DWORD PTR [edi], 3
	jne	SHORT $LN7@xmlXPathFl

; 9665 : 
; 9666 :     ctxt->value->floatval = floor(ctxt->value->floatval);

	mov	ecx, DWORD PTR [edi+16]
	sub	esp, 8
	mov	edx, DWORD PTR [edi+20]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_floor
	fstp	QWORD PTR [edi+16]

; 9667 : }

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN7@xmlXPathFl:

; 9664 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 9667 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathFl:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathFloorFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSumFunction
_TEXT	SEGMENT
_res$1$ = -16						; size = 8
_res$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathSumFunction PROC				; COMDAT

; 9629 : xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR _res$[ebp], xmm0
	test	esi, esi
	je	$LN1@xmlXPathSu

; 9630 :     xmlXPathObjectPtr cur;
; 9631 :     int i;
; 9632 :     double res = 0.0;
; 9633 : 
; 9634 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPathSu
	push	12					; 0000000cH

; 9648 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathSu:

; 9630 :     xmlXPathObjectPtr cur;
; 9631 :     int i;
; 9632 :     double res = 0.0;
; 9633 : 
; 9634 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN7@xmlXPathSu
	push	23					; 00000017H

; 9648 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathSu:

; 9635 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN9@xmlXPathSu
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPathSu
	cmp	eax, 9
	jne	$LN9@xmlXPathSu
$LN8@xmlXPathSu:
	push	ebx

; 9639 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 9640 : 
; 9641 :     if ((cur->nodesetval != NULL) && (cur->nodesetval->nodeNr != 0)) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN16@xmlXPathSu
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN16@xmlXPathSu

; 9642 : 	for (i = 0; i < cur->nodesetval->nodeNr; i++) {

	push	edi
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN18@xmlXPathSu
	fld	QWORD PTR _res$[ebp]
	fstp	QWORD PTR _res$1$[ebp]
$LL4@xmlXPathSu:

; 9643 : 	    res += xmlXPathCastNodeToNumber(cur->nodesetval->nodeTab[i]);

	mov	eax, DWORD PTR [ecx+8]
	push	DWORD PTR [eax+edi*4]
	call	_xmlXPathCastNodeToNumber
	fadd	QWORD PTR _res$1$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	inc	edi
	add	esp, 4
	fst	QWORD PTR _res$1$[ebp]
	fstp	QWORD PTR _res$[ebp]
	cmp	edi, DWORD PTR [ecx]
	jl	SHORT $LL4@xmlXPathSu

; 9640 : 
; 9641 :     if ((cur->nodesetval != NULL) && (cur->nodesetval->nodeNr != 0)) {

	movsd	xmm0, QWORD PTR _res$[ebp]
	jmp	SHORT $LN19@xmlXPathSu
$LN16@xmlXPathSu:

; 9644 : 	}
; 9645 :     }
; 9646 :     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));

	xorps	xmm0, xmm0
	jmp	SHORT $LN3@xmlXPathSu
$LN18@xmlXPathSu:
	xorps	xmm0, xmm0
$LN19@xmlXPathSu:
	pop	edi
$LN3@xmlXPathSu:
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewFloat
	push	eax
	push	esi
	call	_valuePush

; 9647 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 28					; 0000001cH
	pop	ebx
	pop	esi

; 9648 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathSu:

; 9636 : 	((ctxt->value->type != XPATH_NODESET) &&
; 9637 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 9638 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH

; 9648 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathSu:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathSumFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNumberFunction
_TEXT	SEGMENT
_res$ = -8						; size = 8
_ctxt$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathNumberFunction PROC				; COMDAT

; 9595 : xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathNu

; 9596 :     xmlXPathObjectPtr cur;
; 9597 :     double res;
; 9598 : 
; 9599 :     if (ctxt == NULL) return;
; 9600 :     if (nargs == 0) {

	mov	eax, DWORD PTR _nargs$[ebp]
	push	esi
	test	eax, eax
	jne	SHORT $LN3@xmlXPathNu

; 9601 : 	if (ctxt->context->node == NULL) {

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN4@xmlXPathNu

; 9602 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0.0));

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	call	_xmlXPathCacheNewFloat
	push	eax
	push	edi
	call	_valuePush
	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlXPathNu:

; 9603 : 	} else {
; 9604 : 	    xmlChar* content = xmlNodeGetContent(ctxt->context->node);

	push	ecx
	call	_xmlNodeGetContent
	mov	esi, eax

; 9605 : 
; 9606 : 	    res = xmlXPathStringEvalNumber(content);

	push	esi
	call	_xmlXPathStringEvalNumber
	fstp	QWORD PTR _res$[ebp]

; 9607 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));

	movsd	xmm0, QWORD PTR _res$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewFloat
	push	eax
	push	edi
	call	_valuePush

; 9608 : 	    xmlFree(content);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H
	pop	esi
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlXPathNu:

; 9609 : 	}
; 9610 : 	return;
; 9611 :     }
; 9612 : 
; 9613 :     CHECK_ARITY(1);

	cmp	eax, 1
	je	SHORT $LN7@xmlXPathNu
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathNu:

; 9609 : 	}
; 9610 : 	return;
; 9611 :     }
; 9612 : 
; 9613 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN8@xmlXPathNu
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathNu:
	push	ebx

; 9614 :     cur = valuePop(ctxt);

	push	edi
	call	_valuePop

; 9615 :     valuePush(ctxt, xmlXPathCacheConvertNumber(ctxt->context, cur));

	mov	esi, DWORD PTR [edi+12]
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _ctxt$1$[ebp], esi

; 2759 :     if (val == NULL)

	test	ebx, ebx
	jne	SHORT $LN11@xmlXPathNu

; 2760 : 	return(xmlXPathCacheNewFloat(ctxt, 0.0));

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	esi
	call	_xmlXPathCacheNewFloat
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 9615 :     valuePush(ctxt, xmlXPathCacheConvertNumber(ctxt->context, cur));

	push	ebx
	push	edi
	call	_valuePush
	add	esp, 8
	pop	ebx
	pop	esi
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPathNu:

; 2761 :     if (val->type == XPATH_NUMBER)

	cmp	DWORD PTR [ebx], 3
	je	SHORT $LN10@xmlXPathNu

; 2762 : 	return(val);
; 2763 :     ret = xmlXPathCacheNewFloat(ctxt, xmlXPathCastToNumber(val));

	push	ebx
	call	_xmlXPathCastToNumber
	push	ecx
	fstp	QWORD PTR [esp]
	push	esi
	call	_xmlXPathCacheNewFloat

; 2764 :     xmlXPathReleaseObject(ctxt, val);

	push	ebx
	push	DWORD PTR _ctxt$1$[ebp]
	mov	esi, eax
	call	_xmlXPathReleaseObject
	add	esp, 20					; 00000014H

; 2765 :     return(ret);

	mov	ebx, esi
$LN10@xmlXPathNu:

; 9615 :     valuePush(ctxt, xmlXPathCacheConvertNumber(ctxt->context, cur));

	push	ebx
	push	edi
	call	_valuePush
	add	esp, 8
	pop	ebx
	pop	esi
$LN1@xmlXPathNu:
	pop	edi

; 9616 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathNumberFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathLangFunction
_TEXT	SEGMENT
_val$1$ = -16						; size = 4
tv334 = -12						; size = 4
_theLang$1$ = -8					; size = 4
_i$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
$T1 = 11						; size = 1
_nargs$ = 12						; size = 4
_xmlXPathLangFunction PROC				; COMDAT

; 9558 : xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	xor	esi, esi
	test	edi, edi
	je	$LN1@xmlXPathLa

; 9559 :     xmlXPathObjectPtr val = NULL;
; 9560 :     const xmlChar *theLang = NULL;
; 9561 :     const xmlChar *lang;
; 9562 :     int ret = 0;
; 9563 :     int i;
; 9564 : 
; 9565 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPathLa
	push	12					; 0000000cH

; 9584 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathLa:

; 9559 :     xmlXPathObjectPtr val = NULL;
; 9560 :     const xmlChar *theLang = NULL;
; 9561 :     const xmlChar *lang;
; 9562 :     int ret = 0;
; 9563 :     int i;
; 9564 : 
; 9565 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN7@xmlXPathLa
	push	23					; 00000017H

; 9584 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathLa:

; 9566 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathLa
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN8@xmlXPathLa
	push	1
	push	edi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [edi+16]
	add	esp, 8
$LN8@xmlXPathLa:

; 9567 :     CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	$LN10@xmlXPathLa
	cmp	DWORD PTR [eax], 4
	jne	$LN10@xmlXPathLa

; 9568 :     val = valuePop(ctxt);

	push	ebx
	push	edi
	call	_valuePop

; 9569 :     lang = val->stringval;
; 9570 :     theLang = xmlNodeGetLang(ctxt->context->node);

	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR _val$1$[ebp], eax
	mov	ebx, DWORD PTR [eax+24]
	push	DWORD PTR [ecx+4]
	call	_xmlNodeGetLang
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _theLang$1$[ebp], edx

; 9571 :     if ((theLang != NULL) && (lang != NULL)) {

	test	edx, edx
	je	SHORT $LN15@xmlXPathLa
	test	ebx, ebx
	je	SHORT $not_equal$25

; 9572 :         for (i = 0;lang[i] != 0;i++)

	mov	al, BYTE PTR [ebx]
	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	BYTE PTR $T1[ebp], al
	test	al, al
	je	SHORT $LN3@xmlXPathLa
	mov	eax, edx
	sub	eax, ebx
	mov	DWORD PTR tv334[ebp], eax
	npad	6
$LL4@xmlXPathLa:

; 9573 : 	    if (toupper(lang[i]) != toupper(theLang[i]))

	movzx	eax, BYTE PTR [eax+ebx]
	push	eax
	call	DWORD PTR __imp__toupper
	movzx	ecx, BYTE PTR $T1[ebp]
	mov	esi, eax
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN22@xmlXPathLa

; 9572 :         for (i = 0;lang[i] != 0;i++)

	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ebx
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	al, BYTE PTR [ebx]
	mov	BYTE PTR $T1[ebp], al
	test	al, al
	mov	eax, DWORD PTR tv334[ebp]
	jne	SHORT $LL4@xmlXPathLa
	mov	edx, DWORD PTR _theLang$1$[ebp]
	xor	esi, esi
$LN3@xmlXPathLa:

; 9574 : 	        goto not_equal;
; 9575 : 	if ((theLang[i] == 0) || (theLang[i] == '-'))

	mov	al, BYTE PTR [ecx+edx]
	test	al, al
	je	SHORT $LN14@xmlXPathLa
	cmp	al, 45					; 0000002dH
	jne	SHORT $not_equal$25
$LN14@xmlXPathLa:

; 9576 : 	    ret = 1;

	mov	esi, 1
	jmp	SHORT $not_equal$25
$LN22@xmlXPathLa:

; 9573 : 	    if (toupper(lang[i]) != toupper(theLang[i]))

	mov	edx, DWORD PTR _theLang$1$[ebp]
	xor	esi, esi
$not_equal$25:

; 9577 :     }
; 9578 : not_equal:
; 9579 :     if (theLang != NULL)
; 9580 : 	xmlFree((void *)theLang);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlXPathLa:

; 9581 : 
; 9582 :     xmlXPathReleaseObject(ctxt->context, val);

	push	DWORD PTR _val$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject

; 9583 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));

	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewBoolean
	push	eax
	push	edi
	call	_valuePush
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi

; 9584 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathLa:

; 9567 :     CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH

; 9584 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathLa:
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathLangFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFalseFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathFalseFunction PROC				; COMDAT

; 9531 : xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathFa

; 9532 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPathFa
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
$LN3@xmlXPathFa:

; 9532 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edi+44]
	jge	SHORT $LN4@xmlXPathFa
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
$LN4@xmlXPathFa:

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	mov	eax, DWORD PTR [edi+12]
	push	esi

; 2553 :     if ((ctxt != NULL) && (ctxt->cache)) {

	test	eax, eax
	je	SHORT $LN10@xmlXPathFa
	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN10@xmlXPathFa

; 2554 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2555 : 
; 2556 : 	if ((cache->booleanObjs != NULL) &&

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN8@xmlXPathFa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathFa

; 2557 : 	    (cache->booleanObjs->number != 0))
; 2558 : 	{
; 2559 : 	    xmlXPathObjectPtr ret;
; 2560 : 
; 2561 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	push	esi
	push	edi

; 2564 : 	    ret->boolval = (val != 0);

	mov	DWORD PTR [esi+8], 0

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	mov	DWORD PTR [esi], 2
	call	_valuePush
	add	esp, 8
	pop	esi
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
$LN8@xmlXPathFa:

; 2569 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN10@xmlXPathFa
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN10@xmlXPathFa

; 2570 : 	    (cache->miscObjs->number != 0))
; 2571 : 	{
; 2572 : 	    xmlXPathObjectPtr ret;
; 2573 : 
; 2574 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	push	esi
	push	edi

; 2578 : 	    ret->boolval = (val != 0);

	mov	DWORD PTR [esi+8], 0

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	mov	DWORD PTR [esi], 2
	call	_valuePush
	add	esp, 8
	pop	esi
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
$LN10@xmlXPathFa:

; 5259 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5260 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN13@xmlXPathFa

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	push	esi
	push	edi
	call	_valuePush
	add	esp, 8
	pop	esi
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
$LN13@xmlXPathFa:

; 5264 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 9533 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));

	mov	DWORD PTR [esi], 2
	push	esi
	push	edi
	call	_valuePush
	add	esp, 8
	pop	esi
$LN1@xmlXPathFa:
	pop	edi

; 9534 : }

	pop	ebp
	ret	0
_xmlXPathFalseFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathTrueFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathTrueFunction PROC				; COMDAT

; 9517 : xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathTr

; 9518 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPathTr
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9520 : }

	pop	ebp
	ret	0
$LN3@xmlXPathTr:

; 9518 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edi+44]
	jge	SHORT $LN4@xmlXPathTr
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9520 : }

	pop	ebp
	ret	0
$LN4@xmlXPathTr:

; 9519 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));

	mov	eax, DWORD PTR [edi+12]
	push	esi

; 2553 :     if ((ctxt != NULL) && (ctxt->cache)) {

	test	eax, eax
	je	SHORT $LN10@xmlXPathTr
	mov	eax, DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $LN10@xmlXPathTr

; 2554 : 	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2555 : 
; 2556 : 	if ((cache->booleanObjs != NULL) &&

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN8@xmlXPathTr
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathTr

; 2557 : 	    (cache->booleanObjs->number != 0))
; 2558 : 	{
; 2559 : 	    xmlXPathObjectPtr ret;
; 2560 : 
; 2561 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2562 : 		cache->booleanObjs->items[--cache->booleanObjs->number];
; 2563 : 	    ret->type = XPATH_BOOLEAN;
; 2564 : 	    ret->boolval = (val != 0);
; 2565 : #ifdef XP_DEBUG_OBJ_USAGE
; 2566 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);
; 2567 : #endif
; 2568 : 	    return(ret);

	jmp	SHORT $LN24@xmlXPathTr
$LN8@xmlXPathTr:

; 2569 : 	} else if ((cache->miscObjs != NULL) &&

	mov	edx, DWORD PTR [eax+16]
	test	edx, edx
	je	SHORT $LN10@xmlXPathTr
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN10@xmlXPathTr

; 2570 : 	    (cache->miscObjs->number != 0))
; 2571 : 	{
; 2572 : 	    xmlXPathObjectPtr ret;
; 2573 : 
; 2574 : 	    ret = (xmlXPathObjectPtr)

	dec	ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+ecx*4]

; 2575 : 		cache->miscObjs->items[--cache->miscObjs->number];
; 2576 : 
; 2577 : 	    ret->type = XPATH_BOOLEAN;
; 2578 : 	    ret->boolval = (val != 0);
; 2579 : #ifdef XP_DEBUG_OBJ_USAGE
; 2580 : 	    xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);
; 2581 : #endif
; 2582 : 	    return(ret);

	jmp	SHORT $LN24@xmlXPathTr
$LN10@xmlXPathTr:

; 5259 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5260 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN13@xmlXPathTr

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 9519 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));

	push	esi
	push	edi
	call	_valuePush
	add	esp, 8
	pop	esi
	pop	edi

; 9520 : }

	pop	ebp
	ret	0
$LN13@xmlXPathTr:

; 5264 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
$LN24@xmlXPathTr:

; 9519 :     valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));

	push	esi
	mov	DWORD PTR [esi+8], 1
	push	edi
	mov	DWORD PTR [esi], 2
	call	_valuePush
	add	esp, 8
	pop	esi
$LN1@xmlXPathTr:
	pop	edi

; 9520 : }

	pop	ebp
	ret	0
_xmlXPathTrueFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNotFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathNotFunction PROC				; COMDAT

; 9501 : xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathNo

; 9502 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN3@xmlXPathNo
	push	12					; 0000000cH

; 9506 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathNo:

; 9502 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathNo
	push	23					; 00000017H

; 9506 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathNo:

; 9503 :     CAST_TO_BOOLEAN;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, eax
	test	eax, eax
	je	SHORT $LN5@xmlXPathNo
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN5@xmlXPathNo
	push	1
	push	esi
	call	_xmlXPathBooleanFunction
	mov	ecx, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathNo:

; 9504 :     CHECK_TYPE(XPATH_BOOLEAN);

	test	ecx, ecx
	je	SHORT $LN7@xmlXPathNo
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN7@xmlXPathNo

; 9505 :     ctxt->value->boolval = ! ctxt->value->boolval;

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	pop	esi
	sete	al
	mov	DWORD PTR [ecx+8], eax

; 9506 : }

	pop	ebp
	ret	0
$LN7@xmlXPathNo:

; 9504 :     CHECK_TYPE(XPATH_BOOLEAN);

	push	11					; 0000000bH

; 9506 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathNo:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathNotFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathTranslateFunction
_TEXT	SEGMENT
_max$1$ = -20						; size = 4
_from$1$ = -16						; size = 4
_str$1$ = -12						; size = 4
_to$1$ = -8						; size = 4
_target$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathTranslateFunction PROC				; COMDAT

; 9402 : xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathTr

; 9403 :     xmlXPathObjectPtr str;
; 9404 :     xmlXPathObjectPtr from;
; 9405 :     xmlXPathObjectPtr to;
; 9406 :     xmlBufPtr target;
; 9407 :     int offset, max;
; 9408 :     xmlChar ch;
; 9409 :     const xmlChar *point;
; 9410 :     xmlChar *cptr;
; 9411 : 
; 9412 :     CHECK_ARITY(3);

	cmp	DWORD PTR _nargs$[ebp], 3
	je	SHORT $LN8@xmlXPathTr
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9464 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathTr:

; 9403 :     xmlXPathObjectPtr str;
; 9404 :     xmlXPathObjectPtr from;
; 9405 :     xmlXPathObjectPtr to;
; 9406 :     xmlBufPtr target;
; 9407 :     int offset, max;
; 9408 :     xmlChar ch;
; 9409 :     const xmlChar *point;
; 9410 :     xmlChar *cptr;
; 9411 : 
; 9412 :     CHECK_ARITY(3);

	mov	eax, DWORD PTR [edi+44]
	add	eax, 3
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN9@xmlXPathTr
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9464 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathTr:

; 9413 : 
; 9414 :     CAST_TO_STRING;

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN10@xmlXPathTr
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN10@xmlXPathTr
	push	1
	push	edi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN10@xmlXPathTr:

; 9415 :     to = valuePop(ctxt);

	push	edi
	call	_valuePop

; 9416 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	add	esp, 4
	mov	DWORD PTR _to$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN11@xmlXPathTr
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN11@xmlXPathTr
	push	1
	push	edi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN11@xmlXPathTr:

; 9417 :     from = valuePop(ctxt);

	push	edi
	call	_valuePop

; 9418 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	add	esp, 4
	mov	DWORD PTR _from$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN12@xmlXPathTr
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN12@xmlXPathTr
	push	1
	push	edi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN12@xmlXPathTr:

; 9419 :     str = valuePop(ctxt);

	push	edi
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _str$1$[ebp], eax

; 9420 : 
; 9421 :     target = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR _target$1$[ebp], eax

; 9422 :     if (target) {

	test	eax, eax
	je	$LN32@xmlXPathTr

; 9423 : 	max = xmlUTF8Strlen(to->stringval);

	mov	eax, DWORD PTR _to$1$[ebp]
	push	ebx
	push	esi
	push	DWORD PTR [eax+24]
	call	_xmlUTF8Strlen

; 9424 : 	for (cptr = str->stringval; (ch=*cptr); ) {

	mov	esi, DWORD PTR _str$1$[ebp]
	add	esp, 4
	mov	DWORD PTR _max$1$[ebp], eax
	mov	esi, DWORD PTR [esi+24]
	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	$LN35@xmlXPathTr
	npad	7
$LL2@xmlXPathTr:

; 9425 : 	    offset = xmlUTF8Strloc(from->stringval, cptr);

	mov	eax, DWORD PTR _from$1$[ebp]
	push	esi
	push	DWORD PTR [eax+24]
	call	_xmlUTF8Strloc
	add	esp, 8

; 9426 : 	    if (offset >= 0) {

	test	eax, eax
	js	SHORT $LN14@xmlXPathTr

; 9427 : 		if (offset < max) {

	cmp	eax, DWORD PTR _max$1$[ebp]
	jge	SHORT $LN15@xmlXPathTr

; 9428 : 		    point = xmlUTF8Strpos(to->stringval, offset);

	push	eax
	mov	eax, DWORD PTR _to$1$[ebp]
	push	DWORD PTR [eax+24]
	call	_xmlUTF8Strpos
	mov	edi, eax
	add	esp, 8

; 9429 : 		    if (point)

	test	edi, edi
	je	SHORT $LN15@xmlXPathTr

; 9430 : 			xmlBufAdd(target, point, xmlUTF8Strsize(point, 1));

	push	1
	push	edi
	call	_xmlUTF8Strsize
	push	eax
	push	edi

; 9431 : 		}
; 9432 : 	    } else

	jmp	SHORT $LN38@xmlXPathTr
$LN14@xmlXPathTr:

; 9433 : 		xmlBufAdd(target, cptr, xmlUTF8Strsize(cptr, 1));

	push	1
	push	esi
	call	_xmlUTF8Strsize
	push	eax
	push	esi
$LN38@xmlXPathTr:

; 9434 : 
; 9435 : 	    /* Step to next character in input */
; 9436 : 	    cptr++;

	push	DWORD PTR _target$1$[ebp]
	call	_xmlBufAdd
	add	esp, 20					; 00000014H
$LN15@xmlXPathTr:
	inc	esi

; 9437 : 	    if ( ch & 0x80 ) {

	test	bl, bl
	jns	SHORT $LN21@xmlXPathTr

; 9438 : 		/* if not simple ascii, verify proper format */
; 9439 : 		if ( (ch & 0xc0) != 0xc0 ) {

	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN26@xmlXPathTr

; 9441 : 			"xmlXPathTranslateFunction: Invalid UTF8 string\n");
; 9442 :                     /* not asserting an XPath error is probably better */
; 9443 : 		    break;
; 9444 : 		}
; 9445 : 		/* then skip over remaining bytes for this char */
; 9446 : 		while ( (ch <<= 1) & 0x80 )

	add	bl, bl
	jns	SHORT $LN21@xmlXPathTr
	npad	1
$LL5@xmlXPathTr:

; 9447 : 		    if ( (*cptr++ & 0xc0) != 0x80 ) {

	mov	al, BYTE PTR [esi]
	inc	esi
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN25@xmlXPathTr

; 9441 : 			"xmlXPathTranslateFunction: Invalid UTF8 string\n");
; 9442 :                     /* not asserting an XPath error is probably better */
; 9443 : 		    break;
; 9444 : 		}
; 9445 : 		/* then skip over remaining bytes for this char */
; 9446 : 		while ( (ch <<= 1) & 0x80 )

	add	bl, bl
	js	SHORT $LL5@xmlXPathTr

; 9449 : 			    "xmlXPathTranslateFunction: Invalid UTF8 string\n");
; 9450 :                         /* not asserting an XPath error is probably better */
; 9451 : 			break;
; 9452 : 		    }
; 9453 : 		if (ch & 0x80) /* must have had error encountered */

	jmp	SHORT $LN21@xmlXPathTr
$LN25@xmlXPathTr:

; 9448 : 			xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0DA@NKGEEAEF@xmlXPathTranslateFunction?3?5Inva@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8

; 9449 : 			    "xmlXPathTranslateFunction: Invalid UTF8 string\n");
; 9450 :                         /* not asserting an XPath error is probably better */
; 9451 : 			break;
; 9452 : 		    }
; 9453 : 		if (ch & 0x80) /* must have had error encountered */

	test	bl, bl
	js	SHORT $LN34@xmlXPathTr
$LN21@xmlXPathTr:

; 9424 : 	for (cptr = str->stringval; (ch=*cptr); ) {

	mov	bl, BYTE PTR [esi]
	test	bl, bl
	jne	$LL2@xmlXPathTr
	jmp	SHORT $LN34@xmlXPathTr
$LN26@xmlXPathTr:

; 9440 : 		    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0DA@NKGEEAEF@xmlXPathTranslateFunction?3?5Inva@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 8
$LN34@xmlXPathTr:

; 9424 : 	for (cptr = str->stringval; (ch=*cptr); ) {

	mov	edi, DWORD PTR _ctxt$[ebp]
$LN35@xmlXPathTr:
	mov	eax, DWORD PTR _target$1$[ebp]
	pop	esi
	pop	ebx
$LN32@xmlXPathTr:

; 9454 : 		    break;
; 9455 : 	    }
; 9456 : 	}
; 9457 :     }
; 9458 :     valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	eax
	call	_xmlBufContent
	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	edi
	call	_valuePush

; 9459 : 	xmlBufContent(target)));
; 9460 :     xmlBufFree(target);

	push	DWORD PTR _target$1$[ebp]
	call	_xmlBufFree

; 9461 :     xmlXPathReleaseObject(ctxt->context, str);

	push	DWORD PTR _str$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject

; 9462 :     xmlXPathReleaseObject(ctxt->context, from);

	push	DWORD PTR _from$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject

; 9463 :     xmlXPathReleaseObject(ctxt->context, to);

	push	DWORD PTR _to$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 48					; 00000030H
$LN1@xmlXPathTr:
	pop	edi

; 9464 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathTranslateFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNormalizeFunction
_TEXT	SEGMENT
_blank$ = -1						; size = 1
_obj$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathNormalizeFunction PROC				; COMDAT

; 9331 : xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathNo

; 9332 :   xmlXPathObjectPtr obj = NULL;
; 9333 :   xmlChar *source = NULL;
; 9334 :   xmlBufPtr target;
; 9335 :   xmlChar blank;
; 9336 : 
; 9337 :   if (ctxt == NULL) return;
; 9338 :   if (nargs == 0) {

	mov	eax, DWORD PTR _nargs$[ebp]
	test	eax, eax
	jne	SHORT $LN7@xmlXPathNo

; 9339 :     /* Use current context node */
; 9340 :       valuePush(ctxt,

	mov	eax, DWORD PTR [edi+12]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+4]
	call	_xmlNodeGetContent
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@xmlXPathNo

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
$LN24@xmlXPathNo:

; 9339 :     /* Use current context node */
; 9340 :       valuePush(ctxt,

	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheWrapString
	push	eax
	push	edi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN9@xmlXPathNo:

; 9341 : 	  xmlXPathCacheWrapString(ctxt->context,
; 9342 : 	    xmlXPathCastNodeToString(ctxt->context->node)));
; 9343 :     nargs = 1;
; 9344 :   }
; 9345 : 
; 9346 :   CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN10@xmlXPathNo
	push	23					; 00000017H

; 9378 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathNo:

; 9341 : 	  xmlXPathCacheWrapString(ctxt->context,
; 9342 : 	    xmlXPathCastNodeToString(ctxt->context->node)));
; 9343 :     nargs = 1;
; 9344 :   }
; 9345 : 
; 9346 :   CHECK_ARITY(1);

	cmp	eax, 1
	je	SHORT $LN9@xmlXPathNo
	push	12					; 0000000cH

; 9378 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathNo:

; 9347 :   CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN11@xmlXPathNo
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN11@xmlXPathNo
	push	1
	push	edi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [edi+16]
	add	esp, 8
$LN11@xmlXPathNo:

; 9348 :   CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	$LN13@xmlXPathNo
	cmp	DWORD PTR [eax], 4
	jne	$LN13@xmlXPathNo

; 9349 :   obj = valuePop(ctxt);

	push	ebx
	push	esi
	push	edi
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$1$[ebp], eax

; 9350 :   source = obj->stringval;

	mov	esi, DWORD PTR [eax+24]

; 9351 : 
; 9352 :   target = xmlBufCreate();

	call	_xmlBufCreate
	mov	ebx, eax

; 9353 :   if (target && source) {

	test	ebx, ebx
	je	$LN14@xmlXPathNo
	test	esi, esi
	je	$LN14@xmlXPathNo
$LL2@xmlXPathNo:

; 9354 : 
; 9355 :     /* Skip leading whitespaces */
; 9356 :     while (IS_BLANK_CH(*source))

	mov	cl, BYTE PTR [esi]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN15@xmlXPathNo
	cmp	cl, 9
	jb	SHORT $LN16@xmlXPathNo
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPathNo
$LN16@xmlXPathNo:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathNo
$LN15@xmlXPathNo:

; 9357 :       source++;

	inc	esi
	jmp	SHORT $LL2@xmlXPathNo
$LN3@xmlXPathNo:

; 9358 : 
; 9359 :     /* Collapse intermediate whitespaces, and skip trailing whitespaces */
; 9360 :     blank = 0;

	xor	cl, cl
	mov	BYTE PTR _blank$[ebp], cl

; 9361 :     while (*source) {

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN5@xmlXPathNo
	npad	6
$LL4@xmlXPathNo:

; 9362 :       if (IS_BLANK_CH(*source)) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN19@xmlXPathNo
	cmp	al, 9
	jb	SHORT $LN20@xmlXPathNo
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN19@xmlXPathNo
$LN20@xmlXPathNo:
	cmp	al, 13					; 0000000dH
	je	SHORT $LN19@xmlXPathNo

; 9364 :       } else {
; 9365 : 	if (blank) {

	test	cl, cl
	je	SHORT $LN21@xmlXPathNo

; 9366 : 	  xmlBufAdd(target, &blank, 1);

	push	1
	lea	eax, DWORD PTR _blank$[ebp]
	push	eax
	push	ebx
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 9367 : 	  blank = 0;

	mov	BYTE PTR _blank$[ebp], 0
$LN21@xmlXPathNo:

; 9368 : 	}
; 9369 : 	xmlBufAdd(target, source, 1);

	push	1
	push	esi
	push	ebx
	call	_xmlBufAdd
	mov	cl, BYTE PTR _blank$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@xmlXPathNo
$LN19@xmlXPathNo:

; 9363 : 	blank = 0x20;

	mov	cl, 32					; 00000020H
	mov	BYTE PTR _blank$[ebp], cl
$LN18@xmlXPathNo:

; 9370 :       }
; 9371 :       source++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL4@xmlXPathNo
$LN5@xmlXPathNo:

; 9372 :     }
; 9373 :     valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	ebx
	call	_xmlBufContent
	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	edi
	call	_valuePush

; 9374 : 	xmlBufContent(target)));
; 9375 :     xmlBufFree(target);

	push	ebx
	call	_xmlBufFree
	add	esp, 24					; 00000018H
$LN14@xmlXPathNo:

; 9376 :   }
; 9377 :   xmlXPathReleaseObject(ctxt->context, obj);

	push	DWORD PTR _obj$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 9378 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathNo:

; 9348 :   CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH

; 9378 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathNo:
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathNormalizeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSubstringAfterFunction
_TEXT	SEGMENT
_target$1$ = -12					; size = 4
_point$1$ = -8						; size = 4
_str$1$ = -4						; size = 4
_find$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathSubstringAfterFunction PROC			; COMDAT

; 9287 : xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN1@xmlXPathSu

; 9288 :   xmlXPathObjectPtr str;
; 9289 :   xmlXPathObjectPtr find;
; 9290 :   xmlBufPtr target;
; 9291 :   const xmlChar *point;
; 9292 :   int offset;
; 9293 : 
; 9294 :   CHECK_ARITY(2);

	cmp	DWORD PTR _nargs$[ebp], 2
	je	SHORT $LN3@xmlXPathSu
	push	12					; 0000000cH
	push	ebx
	call	_xmlXPathErr
	add	esp, 8
	pop	ebx

; 9314 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlXPathSu:

; 9288 :   xmlXPathObjectPtr str;
; 9289 :   xmlXPathObjectPtr find;
; 9290 :   xmlBufPtr target;
; 9291 :   const xmlChar *point;
; 9292 :   int offset;
; 9293 : 
; 9294 :   CHECK_ARITY(2);

	mov	eax, DWORD PTR [ebx+44]
	add	eax, 2
	cmp	DWORD PTR [ebx+20], eax
	jge	SHORT $LN4@xmlXPathSu
	push	23					; 00000017H
	push	ebx
	call	_xmlXPathErr
	add	esp, 8
	pop	ebx

; 9314 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlXPathSu:

; 9295 :   CAST_TO_STRING;

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN5@xmlXPathSu
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN5@xmlXPathSu
	push	1
	push	ebx
	call	_xmlXPathStringFunction
	add	esp, 8
$LN5@xmlXPathSu:

; 9296 :   find = valuePop(ctxt);

	push	ebx
	call	_valuePop

; 9297 :   CAST_TO_STRING;

	mov	ecx, DWORD PTR [ebx+16]
	add	esp, 4
	mov	DWORD PTR _find$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN6@xmlXPathSu
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN6@xmlXPathSu
	push	1
	push	ebx
	call	_xmlXPathStringFunction
	add	esp, 8
$LN6@xmlXPathSu:

; 9298 :   str = valuePop(ctxt);

	push	esi
	push	edi
	push	ebx
	call	_valuePop
	add	esp, 4
	mov	edi, eax
	mov	DWORD PTR _str$1$[ebp], edi

; 9299 : 
; 9300 :   target = xmlBufCreate();

	call	_xmlBufCreate
	mov	esi, eax
	mov	DWORD PTR _target$1$[ebp], esi

; 9301 :   if (target) {

	test	esi, esi
	je	SHORT $LN7@xmlXPathSu

; 9302 :     point = xmlStrstr(str->stringval, find->stringval);

	mov	eax, DWORD PTR _find$1$[ebp]
	push	DWORD PTR [eax+24]
	push	DWORD PTR [edi+24]
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _point$1$[ebp], eax

; 9303 :     if (point) {

	test	eax, eax
	je	SHORT $LN8@xmlXPathSu

; 9304 :       offset = (int)(point - str->stringval) + xmlStrlen(find->stringval);

	mov	eax, DWORD PTR _find$1$[ebp]
	mov	esi, DWORD PTR [edi+24]
	push	DWORD PTR [eax+24]
	call	_xmlStrlen
	mov	edi, eax
	mov	eax, DWORD PTR _point$1$[ebp]
	sub	eax, esi

; 9305 :       xmlBufAdd(target, &str->stringval[offset],

	push	esi
	add	edi, eax
	call	_xmlStrlen
	mov	esi, DWORD PTR _target$1$[ebp]
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR _str$1$[ebp]
	mov	eax, DWORD PTR [eax+24]
	add	eax, edi
	push	eax
	push	esi
	call	_xmlBufAdd
	mov	edi, DWORD PTR _str$1$[ebp]
	add	esp, 20					; 00000014H
$LN8@xmlXPathSu:

; 9306 : 		   xmlStrlen(str->stringval) - offset);
; 9307 :     }
; 9308 :     valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	esi
	call	_xmlBufContent
	push	eax
	push	DWORD PTR [ebx+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	ebx
	call	_valuePush

; 9309 : 	xmlBufContent(target)));
; 9310 :     xmlBufFree(target);

	push	esi
	call	_xmlBufFree
	add	esp, 24					; 00000018H
$LN7@xmlXPathSu:

; 9311 :   }
; 9312 :   xmlXPathReleaseObject(ctxt->context, str);

	push	edi
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject

; 9313 :   xmlXPathReleaseObject(ctxt->context, find);

	push	DWORD PTR _find$1$[ebp]
	push	DWORD PTR [ebx+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
$LN1@xmlXPathSu:
	pop	ebx

; 9314 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathSubstringAfterFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSubstringBeforeFunction
_TEXT	SEGMENT
_find$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathSubstringBeforeFunction PROC			; COMDAT

; 9244 : xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathSu

; 9245 :   xmlXPathObjectPtr str;
; 9246 :   xmlXPathObjectPtr find;
; 9247 :   xmlBufPtr target;
; 9248 :   const xmlChar *point;
; 9249 :   int offset;
; 9250 : 
; 9251 :   CHECK_ARITY(2);

	cmp	DWORD PTR _nargs$[ebp], 2
	je	SHORT $LN3@xmlXPathSu
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9270 : }

	pop	ebp
	ret	0
$LN3@xmlXPathSu:

; 9245 :   xmlXPathObjectPtr str;
; 9246 :   xmlXPathObjectPtr find;
; 9247 :   xmlBufPtr target;
; 9248 :   const xmlChar *point;
; 9249 :   int offset;
; 9250 : 
; 9251 :   CHECK_ARITY(2);

	mov	eax, DWORD PTR [esi+44]
	add	eax, 2
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathSu
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9270 : }

	pop	ebp
	ret	0
$LN4@xmlXPathSu:

; 9252 :   CAST_TO_STRING;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@xmlXPathSu
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN5@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN5@xmlXPathSu:

; 9253 :   find = valuePop(ctxt);

	push	esi
	call	_valuePop

; 9254 :   CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 4
	mov	DWORD PTR _find$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN6@xmlXPathSu
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN6@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN6@xmlXPathSu:

; 9255 :   str = valuePop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_valuePop
	add	esp, 4
	mov	ebx, eax

; 9256 : 
; 9257 :   target = xmlBufCreate();

	call	_xmlBufCreate
	mov	edi, eax

; 9258 :   if (target) {

	test	edi, edi
	je	SHORT $LN7@xmlXPathSu

; 9259 :     point = xmlStrstr(str->stringval, find->stringval);

	mov	eax, DWORD PTR _find$1$[ebp]
	push	DWORD PTR [eax+24]
	push	DWORD PTR [ebx+24]
	call	_xmlStrstr
	add	esp, 8

; 9260 :     if (point) {

	test	eax, eax
	je	SHORT $LN8@xmlXPathSu

; 9261 :       offset = (int)(point - str->stringval);

	mov	ecx, DWORD PTR [ebx+24]
	sub	eax, ecx

; 9262 :       xmlBufAdd(target, str->stringval, offset);

	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN8@xmlXPathSu:

; 9263 :     }
; 9264 :     valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	edi
	call	_xmlBufContent
	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewString
	push	eax
	push	esi
	call	_valuePush

; 9265 : 	xmlBufContent(target)));
; 9266 :     xmlBufFree(target);

	push	edi
	call	_xmlBufFree
	add	esp, 24					; 00000018H
$LN7@xmlXPathSu:

; 9267 :   }
; 9268 :   xmlXPathReleaseObject(ctxt->context, str);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9269 :   xmlXPathReleaseObject(ctxt->context, find);

	push	DWORD PTR _find$1$[ebp]
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
$LN1@xmlXPathSu:
	pop	esi

; 9270 : }

	pop	ebp
	ret	0
_xmlXPathSubstringBeforeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSubstringFunction
_TEXT	SEGMENT
_in$1$ = -16						; size = 8
_le$1$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_str$1$ = 12						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathSubstringFunction PROC				; COMDAT

; 9135 : xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _nargs$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR _le$1$[ebp], xmm0
	cmp	edi, 2
	jl	SHORT $LN42@xmlXPathSu

; 9136 :     xmlXPathObjectPtr str, start, len;
; 9137 :     double le=0, in;
; 9138 :     int i, l, m;
; 9139 :     xmlChar *ret;
; 9140 : 
; 9141 :     if (nargs < 2) {
; 9142 : 	CHECK_ARITY(2);
; 9143 :     }
; 9144 :     if (nargs > 3) {

	cmp	edi, 3
	jle	SHORT $LN9@xmlXPathSu
$LN42@xmlXPathSu:

; 9145 : 	CHECK_ARITY(3);

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	$LN1@xmlXPathSu
	push	12					; 0000000cH
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 9228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathSu:
	push	esi

; 9146 :     }
; 9147 :     /*
; 9148 :      * take care of possible last (position) argument
; 9149 :     */
; 9150 :     if (nargs == 3) {

	mov	esi, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN10@xmlXPathSu

; 9151 : 	CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN11@xmlXPathSu
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN11@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN11@xmlXPathSu:

; 9152 : 	CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	$LN16@xmlXPathSu
	cmp	DWORD PTR [eax], 3
	jne	$LN16@xmlXPathSu

; 9153 : 	len = valuePop(ctxt);

	push	esi
	call	_valuePop

; 9154 : 	le = len->floatval;
; 9155 : 	xmlXPathReleaseObject(ctxt->context, len);

	push	eax
	push	DWORD PTR [esi+12]
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR _le$1$[ebp], xmm0
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH
$LN10@xmlXPathSu:

; 9156 :     }
; 9157 : 
; 9158 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN14@xmlXPathSu
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN14@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN14@xmlXPathSu:

; 9159 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	$LN16@xmlXPathSu
	cmp	DWORD PTR [eax], 3
	jne	$LN16@xmlXPathSu

; 9160 :     start = valuePop(ctxt);

	push	esi
	call	_valuePop

; 9161 :     in = start->floatval;
; 9162 :     xmlXPathReleaseObject(ctxt->context, start);

	push	eax
	push	DWORD PTR [esi+12]
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR _in$1$[ebp], xmm0
	call	_xmlXPathReleaseObject

; 9163 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN17@xmlXPathSu
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN17@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN17@xmlXPathSu:

; 9164 :     CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	$LN16@xmlXPathSu
	cmp	DWORD PTR [eax], 4
	jne	$LN16@xmlXPathSu

; 9165 :     str = valuePop(ctxt);

	push	ebx
	push	esi
	call	_valuePop
	mov	DWORD PTR _str$1$[ebp], eax

; 9166 :     m = xmlUTF8Strlen((const unsigned char *)str->stringval);

	push	DWORD PTR [eax+24]
	call	_xmlUTF8Strlen
	add	esp, 8
	mov	ebx, eax

; 9167 : 
; 9168 :     /*
; 9169 :      * If last pos not present, calculate last position
; 9170 :     */
; 9171 :     if (nargs != 3) {

	cmp	edi, 3
	je	SHORT $LN39@xmlXPathSu

; 9172 : 	le = (double)m;

	movd	xmm0, ebx
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR _le$1$[ebp], xmm0

; 9173 : 	if (in < 1.0)

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	maxsd	xmm0, QWORD PTR _in$1$[ebp]

; 9174 : 	    in = 1.0;

	movsd	QWORD PTR _in$1$[ebp], xmm0
	jmp	SHORT $LN21@xmlXPathSu
$LN39@xmlXPathSu:

; 9167 : 
; 9168 :     /*
; 9169 :      * If last pos not present, calculate last position
; 9170 :     */
; 9171 :     if (nargs != 3) {

	movsd	xmm0, QWORD PTR _in$1$[ebp]
$LN21@xmlXPathSu:

; 9175 :     }
; 9176 : 
; 9177 :     /* Need to check for the special cases where either
; 9178 :      * the index is NaN, the length is NaN, or both
; 9179 :      * arguments are infinity (relying on Inf + -Inf = NaN)
; 9180 :      */
; 9181 :     if (!xmlXPathIsInf(in) && !xmlXPathIsNaN(in + le)) {

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	test	eax, eax
	jne	$LN22@xmlXPathSu
	movsd	xmm0, QWORD PTR _in$1$[ebp]
	sub	esp, 8
	addsd	xmm0, QWORD PTR _le$1$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN22@xmlXPathSu

; 9182 :         /*
; 9183 :          * To meet the requirements of the spec, the arguments
; 9184 : 	 * must be converted to integer format before
; 9185 : 	 * initial index calculations are done
; 9186 :          *
; 9187 :          * First we go to integer form, rounding up
; 9188 : 	 * and checking for special cases
; 9189 :          */
; 9190 :         i = (int) in;

	movsd	xmm1, QWORD PTR _in$1$[ebp]
	cvttsd2si edi, xmm1
	movd	xmm0, edi

; 9191 :         if (((double)i)+0.5 <= in) i++;

	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN24@xmlXPathSu
	inc	edi
$LN24@xmlXPathSu:

; 9192 : 
; 9193 : 	if (xmlXPathIsInf(le) == 1) {

	movsd	xmm0, QWORD PTR _le$1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN25@xmlXPathSu

; 9194 : 	    l = m;

	mov	ecx, ebx

; 9195 : 	    if (i < 1)

	cmp	edi, eax
	jge	SHORT $LN31@xmlXPathSu

; 9196 : 		i = 1;

	mov	edi, eax

; 9197 : 	}

	jmp	SHORT $LN31@xmlXPathSu
$LN25@xmlXPathSu:

; 9198 : 	else if (xmlXPathIsInf(le) == -1 || le < 0.0)

	movsd	xmm0, QWORD PTR _le$1$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN30@xmlXPathSu
	movsd	xmm1, QWORD PTR _le$1$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	ja	SHORT $LN30@xmlXPathSu

; 9200 : 	else {
; 9201 : 	    l = (int) le;

	cvttsd2si ecx, xmm1
	movd	xmm0, ecx

; 9202 : 	    if (((double)l)+0.5 <= le) l++;

	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	comisd	xmm1, xmm0
	jb	SHORT $LN31@xmlXPathSu
	inc	ecx
	jmp	SHORT $LN31@xmlXPathSu
$LN30@xmlXPathSu:

; 9199 : 	    l = 0;

	xor	ecx, ecx
$LN31@xmlXPathSu:

; 9203 : 	}
; 9204 : 
; 9205 : 	/* Now we normalize inidices */
; 9206 :         i -= 1;

	lea	eax, DWORD PTR [edi-1]

; 9207 :         l += i;

	lea	edx, DWORD PTR [edi-1]
	add	edx, ecx

; 9208 :         if (i < 0)
; 9209 :             i = 0;
; 9210 :         if (l > m)

	xor	ecx, ecx
	test	eax, eax
	cmovns	ecx, eax
	cmp	edx, ebx
	cmovg	edx, ebx

; 9211 :             l = m;
; 9212 : 
; 9213 :         /* number of chars to copy */
; 9214 :         l -= i;
; 9215 : 
; 9216 :         ret = xmlUTF8Strsub(str->stringval, i, l);

	mov	ebx, DWORD PTR _str$1$[ebp]
	sub	edx, ecx
	push	edx
	push	ecx
	push	DWORD PTR [ebx+24]
	call	_xmlUTF8Strsub
	add	esp, 12					; 0000000cH
	mov	edi, eax

; 9217 :     }

	jmp	SHORT $LN23@xmlXPathSu
$LN22@xmlXPathSu:
	mov	ebx, DWORD PTR _str$1$[ebp]

; 9218 :     else {
; 9219 :         ret = NULL;

	xor	edi, edi
$LN23@xmlXPathSu:

; 9220 :     }
; 9221 :     if (ret == NULL)

	mov	eax, DWORD PTR [esi+12]
	test	edi, edi
	jne	SHORT $LN34@xmlXPathSu

; 9222 : 	valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	eax
	call	_xmlXPathCacheNewCString
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 9226 :     }
; 9227 :     xmlXPathReleaseObject(ctxt->context, str);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	ebx
	pop	esi
	pop	edi

; 9228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlXPathSu:

; 9223 :     else {
; 9224 : 	valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, ret));

	push	edi
	push	eax
	call	_xmlXPathCacheNewString
	push	eax
	push	esi
	call	_valuePush

; 9225 : 	xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 9226 :     }
; 9227 :     xmlXPathReleaseObject(ctxt->context, str);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	ebx
	pop	esi
	pop	edi

; 9228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXPathSu:

; 9159 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
$LN1@xmlXPathSu:
	pop	edi

; 9228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathSubstringFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathStartsWithFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathStartsWithFunction PROC			; COMDAT

; 9081 : xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathSt

; 9082 :     xmlXPathObjectPtr hay, needle;
; 9083 :     int n;
; 9084 : 
; 9085 :     CHECK_ARITY(2);

	cmp	DWORD PTR _nargs$[ebp], 2
	je	SHORT $LN3@xmlXPathSt
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9104 : }

	pop	ebp
	ret	0
$LN3@xmlXPathSt:

; 9082 :     xmlXPathObjectPtr hay, needle;
; 9083 :     int n;
; 9084 : 
; 9085 :     CHECK_ARITY(2);

	mov	eax, DWORD PTR [esi+44]
	add	eax, 2
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathSt
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9104 : }

	pop	ebp
	ret	0
$LN4@xmlXPathSt:

; 9086 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathSt
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN5@xmlXPathSt
	push	1
	push	esi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathSt:

; 9087 :     CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	$LN7@xmlXPathSt
	cmp	DWORD PTR [eax], 4
	jne	$LN7@xmlXPathSt

; 9088 :     needle = valuePop(ctxt);

	push	ebx
	push	esi
	call	_valuePop

; 9089 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 4
	mov	ebx, eax
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathSt
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN8@xmlXPathSt
	push	1
	push	esi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN8@xmlXPathSt:

; 9090 :     hay = valuePop(ctxt);

	push	edi
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 9091 : 
; 9092 :     if ((hay == NULL) || (hay->type != XPATH_STRING)) {

	test	edi, edi
	je	SHORT $LN10@xmlXPathSt
	cmp	DWORD PTR [edi], 4
	jne	SHORT $LN10@xmlXPathSt

; 9096 :     }
; 9097 :     n = xmlStrlen(needle->stringval);

	push	DWORD PTR [ebx+24]
	call	_xmlStrlen

; 9098 :     if (xmlStrncmp(hay->stringval, needle->stringval, n))

	push	eax
	push	DWORD PTR [ebx+24]
	push	DWORD PTR [edi+24]
	call	_xmlStrncmp
	xor	ecx, ecx
	test	eax, eax
	sete	cl

; 9099 :         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));
; 9100 :     else
; 9101 :         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));
; 9102 :     xmlXPathReleaseObject(ctxt->context, hay);

	push	ecx
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewBoolean
	push	eax
	push	esi
	call	_valuePush
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9103 :     xmlXPathReleaseObject(ctxt->context, needle);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebx
$LN1@xmlXPathSt:
	pop	esi

; 9104 : }

	pop	ebp
	ret	0
$LN10@xmlXPathSt:

; 9093 : 	xmlXPathReleaseObject(ctxt->context, hay);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9094 : 	xmlXPathReleaseObject(ctxt->context, needle);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9095 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	pop	esi

; 9104 : }

	pop	ebp
	ret	0
$LN7@xmlXPathSt:

; 9087 :     CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9104 : }

	pop	ebp
	ret	0
_xmlXPathStartsWithFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathContainsFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathContainsFunction PROC				; COMDAT

; 9047 : xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathCo

; 9048 :     xmlXPathObjectPtr hay, needle;
; 9049 : 
; 9050 :     CHECK_ARITY(2);

	cmp	DWORD PTR _nargs$[ebp], 2
	je	SHORT $LN3@xmlXPathCo
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9068 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 9048 :     xmlXPathObjectPtr hay, needle;
; 9049 : 
; 9050 :     CHECK_ARITY(2);

	mov	eax, DWORD PTR [esi+44]
	add	eax, 2
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN4@xmlXPathCo
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9068 : }

	pop	ebp
	ret	0
$LN4@xmlXPathCo:

; 9051 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCo
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN5@xmlXPathCo
	push	1
	push	esi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN5@xmlXPathCo:

; 9052 :     CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	$LN7@xmlXPathCo
	cmp	DWORD PTR [eax], 4
	jne	$LN7@xmlXPathCo

; 9053 :     needle = valuePop(ctxt);

	push	ebx
	push	esi
	call	_valuePop

; 9054 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 4
	mov	ebx, eax
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathCo
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN8@xmlXPathCo
	push	1
	push	esi
	call	_xmlXPathStringFunction
	add	esp, 8
$LN8@xmlXPathCo:

; 9055 :     hay = valuePop(ctxt);

	push	edi
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 9056 : 
; 9057 :     if ((hay == NULL) || (hay->type != XPATH_STRING)) {

	test	edi, edi
	je	SHORT $LN10@xmlXPathCo
	cmp	DWORD PTR [edi], 4
	jne	SHORT $LN10@xmlXPathCo

; 9061 :     }
; 9062 :     if (xmlStrstr(hay->stringval, needle->stringval))

	push	DWORD PTR [ebx+24]
	push	DWORD PTR [edi+24]
	call	_xmlStrstr
	xor	ecx, ecx
	test	eax, eax
	setne	cl

; 9063 : 	valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));
; 9064 :     else
; 9065 : 	valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));
; 9066 :     xmlXPathReleaseObject(ctxt->context, hay);

	push	ecx
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewBoolean
	push	eax
	push	esi
	call	_valuePush
	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9067 :     xmlXPathReleaseObject(ctxt->context, needle);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 40					; 00000028H
	pop	edi
	pop	ebx
$LN1@xmlXPathCo:
	pop	esi

; 9068 : }

	pop	ebp
	ret	0
$LN10@xmlXPathCo:

; 9058 : 	xmlXPathReleaseObject(ctxt->context, hay);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9059 : 	xmlXPathReleaseObject(ctxt->context, needle);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9060 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	pop	esi

; 9068 : }

	pop	ebp
	ret	0
$LN7@xmlXPathCo:

; 9052 :     CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 9068 : }

	pop	ebp
	ret	0
_xmlXPathContainsFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathConcatFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathConcatFunction PROC				; COMDAT

; 9002 : xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathCo

; 9003 :     xmlXPathObjectPtr cur, newobj;
; 9004 :     xmlChar *tmp;
; 9005 : 
; 9006 :     if (ctxt == NULL) return;
; 9007 :     if (nargs < 2) {

	push	edi
	mov	edi, DWORD PTR _nargs$[ebp]
	cmp	edi, 2
	jge	SHORT $LN42@xmlXPathCo

; 9008 : 	CHECK_ARITY(2);

	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi

; 9034 : }

	pop	ebp
	ret	0
$LN42@xmlXPathCo:

; 9009 :     }
; 9010 : 
; 9011 :     CAST_TO_STRING;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN16@xmlXPathCo
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN16@xmlXPathCo

; 8946 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN21@xmlXPathCo
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN16@xmlXPathCo
$LN21@xmlXPathCo:

; 8947 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	add	esp, 4

; 8948 :     if (cur == NULL) XP_ERROR(XPATH_INVALID_OPERAND);

	test	eax, eax
	jne	SHORT $LN22@xmlXPathCo
	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN16@xmlXPathCo
$LN22@xmlXPathCo:

; 8949 :     valuePush(ctxt, xmlXPathCacheConvertString(ctxt->context, cur));

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheConvertString
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN16@xmlXPathCo:
	push	ebx

; 9012 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 9013 :     if ((cur == NULL) || (cur->type != XPATH_STRING)) {

	test	ebx, ebx
	je	$LN11@xmlXPathCo
	cmp	DWORD PTR [ebx], 4
	jne	$LN11@xmlXPathCo

; 9015 : 	return;
; 9016 :     }
; 9017 :     nargs--;

	dec	edi
	mov	DWORD PTR _nargs$[ebp], edi

; 9018 : 
; 9019 :     while (nargs > 0) {

	test	edi, edi
	jle	$LN3@xmlXPathCo
	npad	7
$LL2@xmlXPathCo:

; 9020 : 	CAST_TO_STRING;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN27@xmlXPathCo
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN27@xmlXPathCo

; 8946 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN32@xmlXPathCo
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN27@xmlXPathCo
$LN32@xmlXPathCo:

; 8947 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	add	esp, 4

; 8948 :     if (cur == NULL) XP_ERROR(XPATH_INVALID_OPERAND);

	test	eax, eax
	jne	SHORT $LN33@xmlXPathCo
	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN27@xmlXPathCo
$LN33@xmlXPathCo:

; 8949 :     valuePush(ctxt, xmlXPathCacheConvertString(ctxt->context, cur));

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheConvertString
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN27@xmlXPathCo:

; 9021 : 	newobj = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 9022 : 	if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {

	test	edi, edi
	je	SHORT $LN39@xmlXPathCo
	cmp	DWORD PTR [edi], 4
	jne	SHORT $LN39@xmlXPathCo

; 9026 : 	}
; 9027 : 	tmp = xmlStrcat(newobj->stringval, cur->stringval);

	push	DWORD PTR [ebx+24]
	push	DWORD PTR [edi+24]
	call	_xmlStrcat

; 9028 : 	newobj->stringval = cur->stringval;

	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR [edi+24], ecx

; 9029 : 	cur->stringval = tmp;

	mov	DWORD PTR [ebx+24], eax

; 9030 : 	xmlXPathReleaseObject(ctxt->context, newobj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9031 : 	nargs--;

	mov	edi, DWORD PTR _nargs$[ebp]
	add	esp, 16					; 00000010H
	dec	edi
	mov	DWORD PTR _nargs$[ebp], edi
	test	edi, edi
	jg	$LL2@xmlXPathCo
$LN3@xmlXPathCo:

; 9032 :     }
; 9033 :     valuePush(ctxt, cur);

	push	ebx
	push	esi
	call	_valuePush
	add	esp, 8
	pop	ebx
	pop	edi
	pop	esi

; 9034 : }

	pop	ebp
	ret	0
$LN39@xmlXPathCo:

; 9023 : 	    xmlXPathReleaseObject(ctxt->context, newobj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9024 : 	    xmlXPathReleaseObject(ctxt->context, cur);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 9025 : 	    XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi
	pop	esi

; 9034 : }

	pop	ebp
	ret	0
$LN11@xmlXPathCo:

; 9014 : 	xmlXPathReleaseObject(ctxt->context, cur);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8
	pop	ebx
	pop	edi
$LN1@xmlXPathCo:
	pop	esi

; 9034 : }

	pop	ebp
	ret	0
_xmlXPathConcatFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathStringLengthFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathStringLengthFunction PROC			; COMDAT

; 8965 : xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _nargs$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathSt

; 8966 :     xmlXPathObjectPtr cur;
; 8967 : 
; 8968 :     if (nargs == 0) {

	test	esi, esi
	jne	SHORT $LN2@xmlXPathSt

; 8969 :         if ((ctxt == NULL) || (ctxt->context == NULL))

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	$LN1@xmlXPathSt

; 8970 : 	    return;
; 8971 : 	if (ctxt->context->node == NULL) {

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN5@xmlXPathSt

; 8972 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0));

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	call	_xmlXPathCacheNewFloat
	push	eax
	push	edi
	call	_valuePush
	add	esp, 20					; 00000014H
	pop	edi

; 8990 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPathSt:

; 8973 : 	} else {
; 8974 : 	    xmlChar *content;
; 8975 : 
; 8976 : 	    content = xmlXPathCastNodeToString(ctxt->context->node);

	push	ecx
	call	_xmlXPathCastNodeToString
	mov	esi, eax

; 8977 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,

	push	esi
	call	_xmlUTF8Strlen
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewFloat
	push	eax
	push	edi
	call	_valuePush

; 8978 : 		xmlUTF8Strlen(content)));
; 8979 : 	    xmlFree(content);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 24					; 00000018H
	pop	edi

; 8990 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlXPathSt:

; 8980 : 	}
; 8981 : 	return;
; 8982 :     }
; 8983 :     CHECK_ARITY(1);

	cmp	esi, 1
	je	SHORT $LN8@xmlXPathSt
	push	12					; 0000000cH

; 8990 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathSt:

; 8980 : 	}
; 8981 : 	return;
; 8982 :     }
; 8983 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN9@xmlXPathSt
	push	23					; 00000017H

; 8990 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN9@xmlXPathSt:

; 8984 :     CAST_TO_STRING;

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN10@xmlXPathSt
	cmp	DWORD PTR [ecx], 4
	je	SHORT $LN10@xmlXPathSt
	push	1
	push	edi
	call	_xmlXPathStringFunction
	mov	eax, DWORD PTR [edi+16]
	add	esp, 8
$LN10@xmlXPathSt:

; 8985 :     CHECK_TYPE(XPATH_STRING);

	test	eax, eax
	je	SHORT $LN12@xmlXPathSt
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN12@xmlXPathSt

; 8986 :     cur = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	esi, eax

; 8987 :     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,

	push	DWORD PTR [esi+24]
	call	_xmlUTF8Strlen
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheNewFloat
	push	eax
	push	edi
	call	_valuePush

; 8988 : 	xmlUTF8Strlen(cur->stringval)));
; 8989 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 28					; 0000001cH
	pop	edi

; 8990 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlXPathSt:

; 8985 :     CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH

; 8990 : }

	push	edi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathSt:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathStringLengthFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathStringFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathStringFunction PROC				; COMDAT

; 8935 : xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathSt

; 8936 :     xmlXPathObjectPtr cur;
; 8937 : 
; 8938 :     if (ctxt == NULL) return;
; 8939 :     if (nargs == 0) {

	mov	eax, DWORD PTR _nargs$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlXPathSt

; 8940 :     valuePush(ctxt,

	mov	eax, DWORD PTR [esi+12]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+4]
	call	_xmlNodeGetContent
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@xmlXPathSt

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
$LN10@xmlXPathSt:

; 8940 :     valuePush(ctxt,

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheWrapString

; 8950 : }

	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathSt:

; 8941 : 	xmlXPathCacheWrapString(ctxt->context,
; 8942 : 	    xmlXPathCastNodeToString(ctxt->context->node)));
; 8943 : 	return;
; 8944 :     }
; 8945 : 
; 8946 :     CHECK_ARITY(1);

	cmp	eax, 1
	je	SHORT $LN5@xmlXPathSt
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8950 : }

	pop	ebp
	ret	0
$LN5@xmlXPathSt:

; 8941 : 	xmlXPathCacheWrapString(ctxt->context,
; 8942 : 	    xmlXPathCastNodeToString(ctxt->context->node)));
; 8943 : 	return;
; 8944 :     }
; 8945 : 
; 8946 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN6@xmlXPathSt
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8950 : }

	pop	ebp
	ret	0
$LN6@xmlXPathSt:

; 8947 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	add	esp, 4

; 8948 :     if (cur == NULL) XP_ERROR(XPATH_INVALID_OPERAND);

	test	eax, eax
	jne	SHORT $LN7@xmlXPathSt
	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 8950 : }

	pop	ebp
	ret	0
$LN7@xmlXPathSt:

; 8949 :     valuePush(ctxt, xmlXPathCacheConvertString(ctxt->context, cur));

	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheConvertString

; 8950 : }

	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN1@xmlXPathSt:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathStringFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNamespaceURIFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathNamespaceURIFunction PROC			; COMDAT

; 8780 : xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN1@xmlXPathNa

; 8781 :     xmlXPathObjectPtr cur;
; 8782 : 
; 8783 :     if (ctxt == NULL) return;
; 8784 : 
; 8785 :     if (nargs == 0) {

	mov	eax, DWORD PTR _nargs$[ebp]
	test	eax, eax
	jne	SHORT $LN5@xmlXPathNa

; 8786 : 	valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN7@xmlXPathNa:

; 8787 : 	    ctxt->context->node));
; 8788 : 	nargs = 1;
; 8789 :     }
; 8790 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN8@xmlXPathNa
	push	23					; 00000017H

; 8815 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPathNa:

; 8787 : 	    ctxt->context->node));
; 8788 : 	nargs = 1;
; 8789 :     }
; 8790 :     CHECK_ARITY(1);

	cmp	eax, 1
	je	SHORT $LN7@xmlXPathNa
	push	12					; 0000000cH

; 8815 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathNa:

; 8791 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN10@xmlXPathNa
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN9@xmlXPathNa
	cmp	eax, 9
	jne	SHORT $LN10@xmlXPathNa
$LN9@xmlXPathNa:
	push	ebx
	push	edi

; 8795 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 8796 : 
; 8797 :     if ((cur->nodesetval == NULL) || (cur->nodesetval->nodeNr == 0)) {

	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN13@xmlXPathNa
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN13@xmlXPathNa

; 8799 :     } else {
; 8800 : 	int i = 0; /* Should be first in document order !!!!! */
; 8801 : 	switch (cur->nodesetval->nodeTab[i]->type) {

	mov	ecx, DWORD PTR [ecx+8]
	lea	edi, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 1
	ja	SHORT $LN20@xmlXPathNa

; 8802 : 	case XML_ELEMENT_NODE:
; 8803 : 	case XML_ATTRIBUTE_NODE:
; 8804 : 	    if (cur->nodesetval->nodeTab[i]->ns == NULL)

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN20@xmlXPathNa

; 8805 : 		valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));
; 8806 : 	    else
; 8807 : 		valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	DWORD PTR [eax+8]
	push	DWORD PTR [edi]
	call	_xmlXPathCacheNewString

; 8808 : 			  cur->nodesetval->nodeTab[i]->ns->href));
; 8809 : 	    break;

	jmp	SHORT $LN21@xmlXPathNa
$LN13@xmlXPathNa:

; 8798 : 	valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	lea	edi, DWORD PTR [esi+12]
$LN20@xmlXPathNa:

; 8810 : 	default:
; 8811 : 	    valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));
; 8812 : 	}
; 8813 :     }
; 8814 :     xmlXPathReleaseObject(ctxt->context, cur);

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [edi]
	call	_xmlXPathCacheNewCString
$LN21@xmlXPathNa:
	add	esp, 8
	push	eax
	push	esi
	call	_valuePush
	push	ebx
	push	DWORD PTR [edi]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 8815 : }

	pop	ebp
	ret	0
$LN10@xmlXPathNa:

; 8792 : 	((ctxt->value->type != XPATH_NODESET) &&
; 8793 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 8794 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH

; 8815 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathNa:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathNamespaceURIFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathLocalNameFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathLocalNameFunction PROC				; COMDAT

; 8721 : xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	test	esi, esi
	je	$LN1@xmlXPathLo

; 8722 :     xmlXPathObjectPtr cur;
; 8723 : 
; 8724 :     if (ctxt == NULL) return;
; 8725 : 
; 8726 :     if (nargs == 0) {

	mov	eax, DWORD PTR _nargs$[ebp]
	push	edi
	test	eax, eax
	jne	SHORT $LN5@xmlXPathLo

; 8727 : 	valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H

; 8728 : 	    ctxt->context->node));
; 8729 : 	nargs = 1;
; 8730 :     }
; 8731 : 
; 8732 :     CHECK_ARITY(1);

	jmp	SHORT $LN7@xmlXPathLo
$LN5@xmlXPathLo:
	cmp	eax, 1
	je	SHORT $LN20@xmlXPathLo
	push	12					; 0000000cH

; 8734 : 	((ctxt->value->type != XPATH_NODESET) &&
; 8735 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 8736 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi

; 8763 : }

	pop	ebp
	ret	0
$LN20@xmlXPathLo:
	lea	edi, DWORD PTR [esi+12]
$LN7@xmlXPathLo:

; 8728 : 	    ctxt->context->node));
; 8729 : 	nargs = 1;
; 8730 :     }
; 8731 : 
; 8732 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN8@xmlXPathLo
	push	23					; 00000017H

; 8734 : 	((ctxt->value->type != XPATH_NODESET) &&
; 8735 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 8736 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi

; 8763 : }

	pop	ebp
	ret	0
$LN8@xmlXPathLo:

; 8733 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN10@xmlXPathLo
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN9@xmlXPathLo
	cmp	eax, 9
	jne	$LN10@xmlXPathLo
$LN9@xmlXPathLo:
	push	ebx

; 8737 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 8738 : 
; 8739 :     if ((cur->nodesetval == NULL) || (cur->nodesetval->nodeNr == 0)) {

	mov	ecx, edi
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN13@xmlXPathLo
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN13@xmlXPathLo

; 8741 :     } else {
; 8742 : 	int i = 0; /* Should be first in document order !!!!! */
; 8743 : 	switch (cur->nodesetval->nodeTab[i]->type) {

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN18@xmlXPathLo
	movzx	eax, BYTE PTR $LN21@xmlXPathLo[eax]
	jmp	DWORD PTR $LN27@xmlXPathLo[eax*4]
$LN14@xmlXPathLo:

; 8744 : 	case XML_ELEMENT_NODE:
; 8745 : 	case XML_ATTRIBUTE_NODE:
; 8746 : 	case XML_PI_NODE:
; 8747 : 	    if (cur->nodesetval->nodeTab[i]->name[0] == ' ')

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	SHORT $LN15@xmlXPathLo

; 8748 : 		valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	ecx
	jmp	SHORT $LN24@xmlXPathLo
$LN15@xmlXPathLo:

; 8749 : 	    else
; 8750 : 		valuePush(ctxt,

	push	eax
	push	ecx
	call	_xmlXPathCacheNewString

; 8751 : 		      xmlXPathCacheNewString(ctxt->context,
; 8752 : 			cur->nodesetval->nodeTab[i]->name));
; 8753 : 	    break;

	jmp	SHORT $LN25@xmlXPathLo
$LN17@xmlXPathLo:

; 8754 : 	case XML_NAMESPACE_DECL:
; 8755 : 	    valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,

	push	DWORD PTR [ecx+12]
	push	DWORD PTR [esi+12]
	call	_xmlXPathCacheNewString

; 8756 : 			((xmlNsPtr)cur->nodesetval->nodeTab[i])->prefix));
; 8757 : 	    break;

	jmp	SHORT $LN25@xmlXPathLo
$LN18@xmlXPathLo:

; 8758 : 	default:
; 8759 : 	    valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [esi+12]
	jmp	SHORT $LN24@xmlXPathLo
$LN13@xmlXPathLo:

; 8740 : 	valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	DWORD PTR [ecx]
$LN24@xmlXPathLo:

; 8760 : 	}
; 8761 :     }
; 8762 :     xmlXPathReleaseObject(ctxt->context, cur);

	call	_xmlXPathCacheNewCString
$LN25@xmlXPathLo:
	add	esp, 8
	push	eax
	push	esi
	call	_valuePush
	push	ebx
	push	DWORD PTR [edi]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H
	pop	ebx
	pop	edi
	pop	esi

; 8763 : }

	pop	ebp
	ret	0
$LN10@xmlXPathLo:

; 8734 : 	((ctxt->value->type != XPATH_NODESET) &&
; 8735 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 8736 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
$LN1@xmlXPathLo:
	pop	esi

; 8763 : }

	pop	ebp
	ret	0
$LN27@xmlXPathLo:
	DD	$LN14@xmlXPathLo
	DD	$LN17@xmlXPathLo
	DD	$LN18@xmlXPathLo
$LN21@xmlXPathLo:
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_xmlXPathLocalNameFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIdFunction
_TEXT	SEGMENT
_obj$2$ = -8						; size = 4
_i$1$ = -4						; size = 4
_ret$2$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathIdFunction PROC				; COMDAT

; 8666 : xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPathId

; 8667 :     xmlChar *tokens;
; 8668 :     xmlNodeSetPtr ret;
; 8669 :     xmlXPathObjectPtr obj;
; 8670 : 
; 8671 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPathId
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 8704 :     return;
; 8705 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathId:

; 8667 :     xmlChar *tokens;
; 8668 :     xmlNodeSetPtr ret;
; 8669 :     xmlXPathObjectPtr obj;
; 8670 : 
; 8671 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN7@xmlXPathId
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 8704 :     return;
; 8705 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathId:
	push	ebx

; 8672 :     obj = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _obj$2$[ebp], ebx

; 8673 :     if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);

	test	ebx, ebx
	jne	SHORT $LN8@xmlXPathId
	push	10					; 0000000aH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	ebx
	pop	edi

; 8704 :     return;
; 8705 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathId:

; 8674 :     if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [ebx]
	push	esi
	cmp	eax, 1
	je	SHORT $LN10@xmlXPathId
	cmp	eax, 9
	je	SHORT $LN10@xmlXPathId

; 8698 : 	return;
; 8699 :     }
; 8700 :     obj = xmlXPathCacheConvertString(ctxt->context, obj);

	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheConvertString

; 8701 :     ret = xmlXPathGetElementsByIds(ctxt->context->doc, obj->stringval);

	mov	ecx, DWORD PTR [edi+12]
	mov	esi, eax
	push	DWORD PTR [esi+24]
	push	DWORD PTR [ecx]
	call	_xmlXPathGetElementsByIds

; 8702 :     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));

	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	edi
	call	_valuePush

; 8703 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	esi
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 40					; 00000028H
	pop	esi
	pop	ebx
	pop	edi

; 8704 :     return;
; 8705 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathId:

; 8675 : 	xmlNodeSetPtr ns;
; 8676 : 	int i;
; 8677 : 
; 8678 : 	ret = xmlXPathNodeSetCreate(NULL);

	push	0
	call	_xmlXPathNodeSetCreate

; 8679 :         /*
; 8680 :          * FIXME -- in an out-of-memory condition this will behave badly.
; 8681 :          * The solution is not clear -- we already popped an item from
; 8682 :          * ctxt, so the object is in a corrupt state.
; 8683 :          */
; 8684 : 
; 8685 : 	if (obj->nodesetval != NULL) {

	mov	edx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR _ret$2$[ebp], eax
	test	edx, edx
	je	SHORT $LN3@xmlXPathId

; 8686 : 	    for (i = 0; i < obj->nodesetval->nodeNr; i++) {

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [edx], ecx
	jle	SHORT $LN3@xmlXPathId
$LL4@xmlXPathId:

; 8687 : 		tokens =

	mov	eax, DWORD PTR [edx+8]

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax+ecx*4]
	call	_xmlNodeGetContent
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LN15@xmlXPathId

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ebx, eax
$LN15@xmlXPathId:

; 8688 : 		    xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);
; 8689 : 		ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);

	mov	eax, DWORD PTR [edi+12]
	push	ebx
	push	DWORD PTR [eax]
	call	_xmlXPathGetElementsByIds
	mov	esi, eax

; 8690 : 		ret = xmlXPathNodeSetMerge(ret, ns);

	push	esi
	push	DWORD PTR _ret$2$[ebp]
	call	_xmlXPathNodeSetMerge

; 8691 : 		xmlXPathFreeNodeSet(ns);

	push	esi
	mov	DWORD PTR _ret$2$[ebp], eax
	call	_xmlXPathFreeNodeSet
	add	esp, 20					; 00000014H

; 8692 : 		if (tokens != NULL)

	test	ebx, ebx
	je	SHORT $LN2@xmlXPathId

; 8693 : 		    xmlFree(tokens);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlXPathId:

; 8686 : 	    for (i = 0; i < obj->nodesetval->nodeNr; i++) {

	mov	ebx, DWORD PTR _obj$2$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	edx, DWORD PTR [ebx+4]
	cmp	ecx, DWORD PTR [edx]
	jl	SHORT $LL4@xmlXPathId
$LN3@xmlXPathId:

; 8694 : 	    }
; 8695 : 	}
; 8696 : 	xmlXPathReleaseObject(ctxt->context, obj);

	push	ebx
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject

; 8697 : 	valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));

	push	DWORD PTR _ret$2$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathCacheWrapNodeSet
	push	eax
	push	edi
	call	_valuePush
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebx
$LN1@xmlXPathId:
	pop	edi

; 8704 :     return;
; 8705 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathIdFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCountFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathCountFunction PROC				; COMDAT

; 8553 : xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathCo

; 8554 :     xmlXPathObjectPtr cur;
; 8555 : 
; 8556 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN5@xmlXPathCo
	push	12					; 0000000cH

; 8588 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPathCo:

; 8554 :     xmlXPathObjectPtr cur;
; 8555 : 
; 8556 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN6@xmlXPathCo
	push	23					; 00000017H

; 8588 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathCo:

; 8557 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN8@xmlXPathCo
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN7@xmlXPathCo
	cmp	eax, 9
	jne	$LN8@xmlXPathCo
$LN7@xmlXPathCo:
	push	ebx
	push	edi

; 8561 :     cur = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 8562 : 
; 8563 :     if ((cur == NULL) || (cur->nodesetval == NULL))

	test	ebx, ebx
	je	SHORT $LN11@xmlXPathCo
	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN11@xmlXPathCo

; 8564 : 	valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, (double) 0));
; 8565 :     else if ((cur->type == XPATH_NODESET) || (cur->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	SHORT $LN14@xmlXPathCo
	cmp	eax, 9
	je	SHORT $LN14@xmlXPathCo

; 8569 : 	if ((cur->nodesetval->nodeNr != 1) ||

	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN11@xmlXPathCo
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN11@xmlXPathCo

; 8570 : 	    (cur->nodesetval->nodeTab == NULL)) {
; 8571 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, (double) 0));
; 8572 : 	} else {
; 8573 : 	    xmlNodePtr tmp;
; 8574 : 	    int i = 0;
; 8575 : 
; 8576 : 	    tmp = cur->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR [eax]
	xor	ecx, ecx

; 8577 : 	    if ((tmp != NULL) && (tmp->type != XML_NAMESPACE_DECL)) {

	test	eax, eax
	je	SHORT $LN3@xmlXPathCo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN3@xmlXPathCo

; 8578 : 		tmp = tmp->children;

	mov	eax, DWORD PTR [eax+12]

; 8579 : 		while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlXPathCo
$LL2@xmlXPathCo:

; 8580 : 		    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]

; 8581 : 		    i++;

	inc	ecx
	test	eax, eax
	jne	SHORT $LL2@xmlXPathCo
$LN3@xmlXPathCo:
	movd	xmm0, ecx

; 8582 : 		}
; 8583 : 	    }
; 8584 : 	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, (double) i));

	cvtdq2pd xmm0, xmm0
	jmp	SHORT $LN25@xmlXPathCo
$LN14@xmlXPathCo:
	movd	xmm0, DWORD PTR [ecx]

; 8566 : 	valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,

	cvtdq2pd xmm0, xmm0

; 8567 : 	    (double) cur->nodesetval->nodeNr));
; 8568 :     } else {

	jmp	SHORT $LN25@xmlXPathCo
$LN11@xmlXPathCo:

; 8585 : 	}
; 8586 :     }
; 8587 :     xmlXPathReleaseObject(ctxt->context, cur);

	xorps	xmm0, xmm0
$LN25@xmlXPathCo:
	lea	edi, DWORD PTR [esi+12]
	sub	esp, 8
	mov	eax, edi
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR [eax]
	push	eax
	call	_xmlXPathCacheNewFloat
	push	eax
	push	esi
	call	_valuePush
	push	ebx
	push	DWORD PTR [edi]
	call	_xmlXPathReleaseObject
	add	esp, 28					; 0000001cH
	pop	edi
	pop	ebx
	pop	esi

; 8588 : }

	pop	ebp
	ret	0
$LN8@xmlXPathCo:

; 8558 : 	((ctxt->value->type != XPATH_NODESET) &&
; 8559 : 	 (ctxt->value->type != XPATH_XSLT_TREE)))
; 8560 : 	XP_ERROR(XPATH_INVALID_TYPE);

	push	11					; 0000000bH

; 8588 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPathCo:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathCountFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPositionFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathPositionFunction PROC				; COMDAT

; 8529 : xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlXPathPo

; 8530 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPathPo
	push	12					; 0000000cH

; 8541 :     }
; 8542 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathPo:

; 8530 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+44]
	jge	SHORT $LN4@xmlXPathPo
	push	23					; 00000017H

; 8541 :     }
; 8542 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathPo:

; 8531 :     if (ctxt->context->proximityPosition >= 0) {

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+72]
	test	ecx, ecx
	js	SHORT $LN5@xmlXPathPo

; 8532 : 	valuePush(ctxt,

	movd	xmm0, ecx
	sub	esp, 8
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	call	_xmlXPathCacheNewFloat
	push	eax
	push	esi
	call	_valuePush
	add	esp, 20					; 00000014H
	pop	esi

; 8541 :     }
; 8542 : }

	pop	ebp
	ret	0
$LN5@xmlXPathPo:

; 8533 : 	      xmlXPathCacheNewFloat(ctxt->context,
; 8534 : 		(double) ctxt->context->proximityPosition));
; 8535 : #ifdef DEBUG_EXPR
; 8536 : 	xmlGenericError(xmlGenericErrorContext, "position() : %d\n",
; 8537 : 		ctxt->context->proximityPosition);
; 8538 : #endif
; 8539 :     } else {
; 8540 : 	XP_ERROR(XPATH_INVALID_CTXT_POSITION);

	push	14					; 0000000eH

; 8541 :     }
; 8542 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN6@xmlXPathPo:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathPositionFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathLastFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPathLastFunction PROC				; COMDAT

; 8502 : xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlXPathLa

; 8503 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPathLa
	push	12					; 0000000cH

; 8514 :     }
; 8515 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathLa:

; 8503 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+44]
	jge	SHORT $LN4@xmlXPathLa
	push	23					; 00000017H

; 8514 :     }
; 8515 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathLa:

; 8504 :     if (ctxt->context->contextSize >= 0) {

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+68]
	test	ecx, ecx
	js	SHORT $LN5@xmlXPathLa

; 8505 : 	valuePush(ctxt,

	movd	xmm0, ecx
	sub	esp, 8
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	call	_xmlXPathCacheNewFloat
	push	eax
	push	esi
	call	_valuePush
	add	esp, 20					; 00000014H
	pop	esi

; 8514 :     }
; 8515 : }

	pop	ebp
	ret	0
$LN5@xmlXPathLa:

; 8506 : 	    xmlXPathCacheNewFloat(ctxt->context,
; 8507 : 		(double) ctxt->context->contextSize));
; 8508 : #ifdef DEBUG_EXPR
; 8509 : 	xmlGenericError(xmlGenericErrorContext,
; 8510 : 		"last() : %d\n", ctxt->context->contextSize);
; 8511 : #endif
; 8512 :     } else {
; 8513 : 	XP_ERROR(XPATH_INVALID_CTXT_SIZE);

	push	13					; 0000000dH

; 8514 :     }
; 8515 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN6@xmlXPathLa:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathLastFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextPrecedingSibling
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextPrecedingSibling PROC			; COMDAT

; 8194 : xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8195 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8196 :     if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, 2
	je	SHORT $LN3@xmlXPathNe
	cmp	eax, 18					; 00000012H
	je	SHORT $LN3@xmlXPathNe

; 8197 : 	(ctxt->context->node->type == XML_NAMESPACE_DECL))
; 8198 : 	return(NULL);
; 8199 :     if (cur == (xmlNodePtr) ctxt->context->doc)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN3@xmlXPathNe

; 8200 :         return(NULL);
; 8201 :     if (cur == NULL)

	test	eax, eax
	je	SHORT $LN11@xmlXPathNe

; 8202 :         return(ctxt->context->node->prev);
; 8203 :     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE)) {

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN9@xmlXPathNe
	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	jne	SHORT $LN9@xmlXPathNe

; 8204 : 	cur = cur->prev;

	mov	eax, ecx

; 8205 : 	if (cur == NULL)

	test	eax, eax
	je	SHORT $LN11@xmlXPathNe
$LN9@xmlXPathNe:

; 8207 :     }
; 8208 :     return(cur->prev);

	mov	eax, DWORD PTR [eax+28]

; 8209 : }

	pop	ebp
	ret	0
$LN11@xmlXPathNe:

; 8206 : 	    return(ctxt->context->node->prev);

	mov	eax, DWORD PTR [edx+28]

; 8209 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNe:

; 8195 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 8209 : }

	pop	ebp
	ret	0
_xmlXPathNextPrecedingSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextAncestor
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextAncestor PROC				; COMDAT

; 8026 : xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	je	$LN7@xmlXPathNe

; 8027 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	je	$LN7@xmlXPathNe

; 8028 :     /*
; 8029 :      * the parent of an attribute or namespace node is the element
; 8030 :      * to which the attribute or namespace node is attached
; 8031 :      * !!!!!!!!!!!!!
; 8032 :      */
; 8033 :     if (cur == NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	$LN8@xmlXPathNe

; 8034 : 	if (ctxt->context->node == NULL) return(NULL);

	mov	edx, DWORD PTR [edi+4]
	test	edx, edx
	je	$LN7@xmlXPathNe

; 8035 : 	switch (ctxt->context->node->type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	$LN7@xmlXPathNe
	movzx	ecx, BYTE PTR $LN33@xmlXPathNe[eax]
	jmp	DWORD PTR $LN36@xmlXPathNe[ecx*4]
$LN10@xmlXPathNe:

; 8036 :             case XML_ELEMENT_NODE:
; 8037 :             case XML_TEXT_NODE:
; 8038 :             case XML_CDATA_SECTION_NODE:
; 8039 :             case XML_ENTITY_REF_NODE:
; 8040 :             case XML_ENTITY_NODE:
; 8041 :             case XML_PI_NODE:
; 8042 :             case XML_COMMENT_NODE:
; 8043 : 	    case XML_DTD_NODE:
; 8044 : 	    case XML_ELEMENT_DECL:
; 8045 : 	    case XML_ATTRIBUTE_DECL:
; 8046 : 	    case XML_ENTITY_DECL:
; 8047 :             case XML_NOTATION_NODE:
; 8048 : 	    case XML_XINCLUDE_START:
; 8049 : 	    case XML_XINCLUDE_END:
; 8050 : 		if (ctxt->context->node->parent == NULL)

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	jne	SHORT $LN11@xmlXPathNe

; 8051 : 		    return((xmlNodePtr) ctxt->context->doc);

	mov	eax, DWORD PTR [edi]
	pop	edi

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlXPathNe:

; 8052 : 		if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN31@xmlXPathNe
	mov	eax, DWORD PTR [eax+8]
	cmp	BYTE PTR [eax], 32			; 00000020H
	je	$LN7@xmlXPathNe
	push	OFFSET ??_C@_0BC@MHFGEIED@fake?5node?5libxslt@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN7@xmlXPathNe
$LN31@xmlXPathNe:

; 8053 : 		    ((ctxt->context->node->parent->name[0] == ' ') ||
; 8054 : 		     (xmlStrEqual(ctxt->context->node->parent->name,
; 8055 : 				 BAD_CAST "fake node libxslt"))))
; 8056 : 		    return(NULL);
; 8057 : 		return(ctxt->context->node->parent);

	mov	eax, DWORD PTR [ebx+12]
	pop	edi

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+20]
	pop	ebp
	ret	0
$LN14@xmlXPathNe:

; 8058 :             case XML_ATTRIBUTE_NODE: {
; 8059 : 		xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;
; 8060 : 
; 8061 : 		return(tmp->parent);

	mov	eax, DWORD PTR [edx+20]
	pop	edi

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN16@xmlXPathNe:

; 8062 : 	    }
; 8063 :             case XML_DOCUMENT_NODE:
; 8064 :             case XML_DOCUMENT_TYPE_NODE:
; 8065 :             case XML_DOCUMENT_FRAG_NODE:
; 8066 :             case XML_HTML_DOCUMENT_NODE:
; 8067 : #ifdef LIBXML_DOCB_ENABLED
; 8068 : 	    case XML_DOCB_DOCUMENT_NODE:
; 8069 : #endif
; 8070 :                 return(NULL);
; 8071 : 	    case XML_NAMESPACE_DECL: {
; 8072 : 		xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;
; 8073 : 
; 8074 : 		if ((ns->next != NULL) &&

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN7@xmlXPathNe
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN7@xmlXPathNe

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlXPathNe:

; 8075 : 		    (ns->next->type != XML_NAMESPACE_DECL))
; 8076 : 		    return((xmlNodePtr) ns->next);
; 8077 : 		/* Bad, how did that namespace end up here ? */
; 8078 :                 return(NULL);
; 8079 : 	    }
; 8080 : 	}
; 8081 : 	return(NULL);
; 8082 :     }
; 8083 :     if (cur == ctxt->context->doc->children)

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+12]
	je	SHORT $LN1@xmlXPathNe

; 8084 : 	return((xmlNodePtr) ctxt->context->doc);
; 8085 :     if (cur == (xmlNodePtr) ctxt->context->doc)

	cmp	esi, eax
	je	SHORT $LN7@xmlXPathNe

; 8086 : 	return(NULL);
; 8087 :     switch (cur->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN7@xmlXPathNe
	movzx	eax, BYTE PTR $LN34@xmlXPathNe[eax]
	jmp	DWORD PTR $LN37@xmlXPathNe[eax*4]
$LN20@xmlXPathNe:

; 8088 : 	case XML_ELEMENT_NODE:
; 8089 : 	case XML_TEXT_NODE:
; 8090 : 	case XML_CDATA_SECTION_NODE:
; 8091 : 	case XML_ENTITY_REF_NODE:
; 8092 : 	case XML_ENTITY_NODE:
; 8093 : 	case XML_PI_NODE:
; 8094 : 	case XML_COMMENT_NODE:
; 8095 : 	case XML_NOTATION_NODE:
; 8096 : 	case XML_DTD_NODE:
; 8097 :         case XML_ELEMENT_DECL:
; 8098 :         case XML_ATTRIBUTE_DECL:
; 8099 :         case XML_ENTITY_DECL:
; 8100 : 	case XML_XINCLUDE_START:
; 8101 : 	case XML_XINCLUDE_END:
; 8102 : 	    if (cur->parent == NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN7@xmlXPathNe

; 8103 : 		return(NULL);
; 8104 : 	    if ((cur->parent->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN32@xmlXPathNe
	mov	eax, DWORD PTR [eax+8]
	cmp	BYTE PTR [eax], 32			; 00000020H
	je	SHORT $LN7@xmlXPathNe
	push	OFFSET ??_C@_0BC@MHFGEIED@fake?5node?5libxslt@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlXPathNe
$LN32@xmlXPathNe:

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN25@xmlXPathNe:

; 8105 : 		((cur->parent->name[0] == ' ') ||
; 8106 : 		 (xmlStrEqual(cur->parent->name,
; 8107 : 			      BAD_CAST "fake node libxslt"))))
; 8108 : 		return(NULL);
; 8109 : 	    return(cur->parent);
; 8110 : 	case XML_ATTRIBUTE_NODE: {
; 8111 : 	    xmlAttrPtr att = (xmlAttrPtr) cur;
; 8112 : 
; 8113 : 	    return(att->parent);
; 8114 : 	}
; 8115 : 	case XML_NAMESPACE_DECL: {
; 8116 : 	    xmlNsPtr ns = (xmlNsPtr) cur;
; 8117 : 
; 8118 : 	    if ((ns->next != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@xmlXPathNe
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN1@xmlXPathNe
$LN7@xmlXPathNe:

; 8027 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:
	pop	edi

; 8119 : 	        (ns->next->type != XML_NAMESPACE_DECL))
; 8120 : 	        return((xmlNodePtr) ns->next);
; 8121 : 	    /* Bad, how did that namespace end up here ? */
; 8122 :             return(NULL);
; 8123 : 	}
; 8124 : 	case XML_DOCUMENT_NODE:
; 8125 : 	case XML_DOCUMENT_TYPE_NODE:
; 8126 : 	case XML_DOCUMENT_FRAG_NODE:
; 8127 : 	case XML_HTML_DOCUMENT_NODE:
; 8128 : #ifdef LIBXML_DOCB_ENABLED
; 8129 : 	case XML_DOCB_DOCUMENT_NODE:
; 8130 : #endif
; 8131 : 	    return(NULL);
; 8132 :     }
; 8133 :     return(NULL);
; 8134 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN36@xmlXPathNe:
	DD	$LN10@xmlXPathNe
	DD	$LN14@xmlXPathNe
	DD	$LN7@xmlXPathNe
	DD	$LN16@xmlXPathNe
$LN33@xmlXPathNe:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	0
	DB	0
	DB	2
	npad	3
$LN37@xmlXPathNe:
	DD	$LN20@xmlXPathNe
	DD	$LN32@xmlXPathNe
	DD	$LN7@xmlXPathNe
	DD	$LN25@xmlXPathNe
$LN34@xmlXPathNe:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	0
	DB	0
	DB	2
_xmlXPathNextAncestor ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextPreceding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextPreceding PROC				; COMDAT

; 8299 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN9@xmlXPathNe

; 8300 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	je	$LN9@xmlXPathNe

; 8301 :     if (cur == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN54@xmlXPathNe

; 8302 :         cur = ctxt->context->node;

	mov	eax, DWORD PTR [edi+4]

; 8303 :         if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	jne	SHORT $LN11@xmlXPathNe

; 8304 :             cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]
	jmp	SHORT $LN13@xmlXPathNe
$LN11@xmlXPathNe:

; 8305 :         } else if (cur->type == XML_NAMESPACE_DECL) {

	cmp	ecx, 18					; 00000012H
	jne	SHORT $LN13@xmlXPathNe

; 8306 :             xmlNsPtr ns = (xmlNsPtr) cur;
; 8307 : 
; 8308 :             if ((ns->next == NULL) ||

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$LN9@xmlXPathNe
	cmp	DWORD PTR [eax+4], ecx
	je	$LN9@xmlXPathNe
$LN13@xmlXPathNe:

; 8309 :                 (ns->next->type == XML_NAMESPACE_DECL))
; 8310 :                 return (NULL);
; 8311 :             cur = (xmlNodePtr) ns->next;
; 8312 :         }
; 8313 :     }
; 8314 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	test	eax, eax
	je	SHORT $LN9@xmlXPathNe
$LN54@xmlXPathNe:
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN9@xmlXPathNe

; 8315 : 	return (NULL);
; 8316 :     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LL4@xmlXPathNe
	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	cmove	eax, ecx
	npad	4
$LL4@xmlXPathNe:

; 8317 : 	cur = cur->prev;
; 8318 :     do {
; 8319 :         if (cur->prev != NULL) {

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	jne	SHORT $LN39@xmlXPathNe

; 8322 :         }
; 8323 : 
; 8324 :         cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 8325 :         if (cur == NULL)

	test	eax, eax
	je	SHORT $LN9@xmlXPathNe

; 8326 :             return (NULL);
; 8327 :         if (cur == ctxt->context->doc->children)

	mov	ecx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+12]
	je	SHORT $LN9@xmlXPathNe

; 8328 :             return (NULL);
; 8329 :     } while (xmlXPathIsAncestor(cur, ctxt->context->node));

	mov	ecx, DWORD PTR [edi+4]

; 8266 :     if ((ancestor == NULL) || (node == NULL)) return(0);

	test	ecx, ecx
	je	SHORT $LN1@xmlXPathNe

; 8267 :     if (node->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN1@xmlXPathNe

; 8268 :         return(0);
; 8269 :     if (ancestor->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN1@xmlXPathNe

; 8270 :         return(0);
; 8271 :     /* nodes need to be in the same document */
; 8272 :     if (ancestor->doc != node->doc) return(0);

	mov	edx, DWORD PTR [eax+32]
	mov	esi, DWORD PTR [ecx+32]
	cmp	edx, esi
	jne	SHORT $LN1@xmlXPathNe

; 8273 :     /* avoid searching if ancestor or node is the root node */
; 8274 :     if (ancestor == (xmlNodePtr) node->doc) return(1);

	cmp	eax, esi
	je	SHORT $LL4@xmlXPathNe

; 8275 :     if (node == (xmlNodePtr) ancestor->doc) return(0);

	cmp	ecx, edx
	je	SHORT $LN1@xmlXPathNe

; 8276 :     while (node->parent != NULL) {

	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	je	SHORT $LN1@xmlXPathNe
$LL24@xmlXPathNe:

; 8277 :         if (node->parent == ancestor)

	cmp	ecx, eax
	je	SHORT $LL4@xmlXPathNe

; 8276 :     while (node->parent != NULL) {

	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	jne	SHORT $LL24@xmlXPathNe

; 8330 :     return (cur);
; 8331 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN39@xmlXPathNe:

; 8320 :             for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $LN6@xmlXPathNe
$LL7@xmlXPathNe:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	jne	SHORT $LL7@xmlXPathNe
$LN6@xmlXPathNe:
	pop	edi

; 8321 :             return (cur);

	mov	eax, ecx

; 8330 :     return (cur);
; 8331 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlXPathNe:

; 8300 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:
	pop	edi

; 8330 :     return (cur);
; 8331 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathNextPreceding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextAttribute
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextAttribute PROC				; COMDAT

; 8441 : xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8442 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8443 :     if (ctxt->context->node == NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 8444 : 	return(NULL);
; 8445 :     if (ctxt->context->node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN3@xmlXPathNe

; 8446 : 	return(NULL);
; 8447 :     if (cur == NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	test	edx, edx
	jne	SHORT $LN6@xmlXPathNe

; 8448 :         if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)

	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN3@xmlXPathNe

; 8449 : 	    return(NULL);
; 8450 :         return((xmlNodePtr)ctxt->context->node->properties);

	mov	eax, DWORD PTR [eax+44]

; 8453 : }

	pop	ebp
	ret	0
$LN6@xmlXPathNe:

; 8451 :     }
; 8452 :     return((xmlNodePtr)cur->next);

	mov	eax, DWORD PTR [edx+24]

; 8453 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNe:

; 8442 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 8453 : }

	pop	ebp
	ret	0
_xmlXPathNextAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextNamespace
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextNamespace PROC				; COMDAT

; 8404 : xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN5@xmlXPathNe

; 8405 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	$LN5@xmlXPathNe

; 8406 :     if (ctxt->context->node->type != XML_ELEMENT_NODE) return(NULL);

	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN5@xmlXPathNe

; 8407 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@xmlXPathNe

; 8408 :         if (ctxt->context->tmpNsList != NULL)

	mov	eax, DWORD PTR [ecx+120]
	test	eax, eax
	je	SHORT $LN8@xmlXPathNe

; 8409 : 	    xmlFree(ctxt->context->tmpNsList);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 4
$LN8@xmlXPathNe:

; 8410 : 	ctxt->context->tmpNsList =

	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	call	_xmlGetNsList
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 8
	mov	DWORD PTR [ecx+120], eax

; 8411 : 	    xmlGetNsList(ctxt->context->doc, ctxt->context->node);
; 8412 : 	ctxt->context->tmpNsNr = 0;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+124], 0

; 8413 : 	if (ctxt->context->tmpNsList != NULL) {

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+120]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8414 : 	    while (ctxt->context->tmpNsList[ctxt->context->tmpNsNr] != NULL) {

	mov	eax, DWORD PTR [eax+124]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN3@xmlXPathNe
	npad	5
$LL2@xmlXPathNe:

; 8415 : 		ctxt->context->tmpNsNr++;

	mov	eax, DWORD PTR [esi+12]
	inc	DWORD PTR [eax+124]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+124]
	mov	eax, DWORD PTR [eax+120]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LL2@xmlXPathNe
$LN3@xmlXPathNe:

; 8416 : 	    }
; 8417 : 	}
; 8418 : 	return((xmlNodePtr) xmlXPathXMLNamespace);

	mov	eax, DWORD PTR _xmlXPathXMLNamespace
	pop	esi

; 8426 : 	return(NULL);
; 8427 :     }
; 8428 : }

	pop	ebp
	ret	0
$LN7@xmlXPathNe:

; 8419 :     }
; 8420 :     if (ctxt->context->tmpNsNr > 0) {

	mov	edx, DWORD PTR [ecx+124]
	test	edx, edx
	jle	SHORT $LN10@xmlXPathNe

; 8421 : 	return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];

	dec	edx
	mov	DWORD PTR [ecx+124], edx
	mov	ecx, DWORD PTR [esi+12]
	pop	esi
	mov	eax, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR [eax+edx*4]

; 8426 : 	return(NULL);
; 8427 :     }
; 8428 : }

	pop	ebp
	ret	0
$LN10@xmlXPathNe:

; 8422 :     } else {
; 8423 : 	if (ctxt->context->tmpNsList != NULL)

	mov	eax, DWORD PTR [ecx+120]
	test	eax, eax
	je	SHORT $LN12@xmlXPathNe

; 8424 : 	    xmlFree(ctxt->context->tmpNsList);

	push	eax
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 4
$LN12@xmlXPathNe:

; 8425 : 	ctxt->context->tmpNsList = NULL;

	mov	DWORD PTR [ecx+120], 0
$LN5@xmlXPathNe:

; 8426 : 	return(NULL);
; 8427 :     }
; 8428 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlXPathNextNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextFollowing
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextFollowing PROC				; COMDAT

; 8225 : xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN6@xmlXPathNe

; 8226 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	je	SHORT $LN6@xmlXPathNe

; 8227 :     if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&
; 8228 :         (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))

	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	je	SHORT $LN27@xmlXPathNe
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 2
	je	SHORT $LN14@xmlXPathNe
	cmp	eax, 18					; 00000012H
	je	SHORT $LN14@xmlXPathNe
	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN14@xmlXPathNe

; 8251 :     } while (cur != NULL);
; 8252 :     return(cur);
; 8253 : }

	pop	ebp
	ret	0
$LN27@xmlXPathNe:

; 8229 :         return(cur->children);
; 8230 : 
; 8231 :     if (cur == NULL) {
; 8232 :         cur = ctxt->context->node;

	mov	ecx, DWORD PTR [edx+4]

; 8233 :         if (cur->type == XML_ATTRIBUTE_NODE) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 2
	jne	SHORT $LN9@xmlXPathNe

; 8234 :             cur = cur->parent;

	mov	ecx, DWORD PTR [ecx+20]
	jmp	SHORT $LN11@xmlXPathNe
$LN9@xmlXPathNe:

; 8235 :         } else if (cur->type == XML_NAMESPACE_DECL) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN11@xmlXPathNe

; 8236 :             xmlNsPtr ns = (xmlNsPtr) cur;
; 8237 : 
; 8238 :             if ((ns->next == NULL) ||

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPathNe
	cmp	DWORD PTR [ecx+4], eax
	je	SHORT $LN6@xmlXPathNe
$LN11@xmlXPathNe:

; 8239 :                 (ns->next->type == XML_NAMESPACE_DECL))
; 8240 :                 return (NULL);
; 8241 :             cur = (xmlNodePtr) ns->next;
; 8242 :         }
; 8243 :     }
; 8244 :     if (cur == NULL) return(NULL) ; /* ERROR */

	test	ecx, ecx
	je	SHORT $LN6@xmlXPathNe
$LN14@xmlXPathNe:

; 8245 :     if (cur->next != NULL) return(cur->next) ;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN1@xmlXPathNe
$LL4@xmlXPathNe:

; 8246 :     do {
; 8247 :         cur = cur->parent;

	mov	ecx, DWORD PTR [ecx+20]

; 8248 :         if (cur == NULL) break;

	test	ecx, ecx
	je	SHORT $LN6@xmlXPathNe

; 8249 :         if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);

	cmp	ecx, DWORD PTR [edx]
	je	SHORT $LN6@xmlXPathNe

; 8250 :         if (cur->next != NULL) return(cur->next);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LL4@xmlXPathNe

; 8251 :     } while (cur != NULL);
; 8252 :     return(cur);
; 8253 : }

	pop	ebp
	ret	0
$LN6@xmlXPathNe:

; 8226 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:

; 8251 :     } while (cur != NULL);
; 8252 :     return(cur);
; 8253 : }

	pop	ebp
	ret	0
_xmlXPathNextFollowing ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextFollowingSibling
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextFollowingSibling PROC			; COMDAT

; 8169 : xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8170 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8171 :     if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, 2
	je	SHORT $LN3@xmlXPathNe
	cmp	eax, 18					; 00000012H
	je	SHORT $LN3@xmlXPathNe

; 8172 : 	(ctxt->context->node->type == XML_NAMESPACE_DECL))
; 8173 : 	return(NULL);
; 8174 :     if (cur == (xmlNodePtr) ctxt->context->doc)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN3@xmlXPathNe

; 8175 :         return(NULL);
; 8176 :     if (cur == NULL)

	test	eax, eax
	jne	SHORT $LN7@xmlXPathNe

; 8177 :         return(ctxt->context->node->next);

	mov	eax, DWORD PTR [edx+24]

; 8179 : }

	pop	ebp
	ret	0
$LN7@xmlXPathNe:

; 8178 :     return(cur->next);

	mov	eax, DWORD PTR [eax+24]

; 8179 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNe:

; 8170 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 8179 : }

	pop	ebp
	ret	0
_xmlXPathNextFollowingSibling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextAncestorOrSelf
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextAncestorOrSelf PROC			; COMDAT

; 8150 : xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 8151 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 8152 :     if (cur == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	test	edx, edx
	jne	SHORT $LN4@xmlXPathNe

; 8153 :         return(ctxt->context->node);

	mov	eax, DWORD PTR [eax+4]

; 8155 : }

	pop	ebp
	ret	0
$LN4@xmlXPathNe:

; 8154 :     return(xmlXPathNextAncestor(ctxt, cur));

	mov	DWORD PTR _cur$[ebp], edx
	mov	DWORD PTR _ctxt$[ebp], ecx

; 8155 : }

	pop	ebp

; 8154 :     return(xmlXPathNextAncestor(ctxt, cur));

	jmp	_xmlXPathNextAncestor
$LN3@xmlXPathNe:

; 8151 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 8155 : }

	pop	ebp
	ret	0
_xmlXPathNextAncestorOrSelf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextParent
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextParent PROC				; COMDAT

; 7953 : xmlXPathNextParent(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlXPathNe

; 7954 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	esi, DWORD PTR [edi+12]
	test	esi, esi
	je	SHORT $LN5@xmlXPathNe

; 7955 :     /*
; 7956 :      * the parent of an attribute or namespace node is the element
; 7957 :      * to which the attribute or namespace node is attached
; 7958 :      * Namespace handling !!!
; 7959 :      */
; 7960 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN5@xmlXPathNe

; 7961 : 	if (ctxt->context->node == NULL) return(NULL);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN5@xmlXPathNe

; 7962 : 	switch (ctxt->context->node->type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN5@xmlXPathNe
	movzx	ecx, BYTE PTR $LN19@xmlXPathNe[eax]
	jmp	DWORD PTR $LN21@xmlXPathNe[ecx*4]
$LN8@xmlXPathNe:

; 7963 :             case XML_ELEMENT_NODE:
; 7964 :             case XML_TEXT_NODE:
; 7965 :             case XML_CDATA_SECTION_NODE:
; 7966 :             case XML_ENTITY_REF_NODE:
; 7967 :             case XML_ENTITY_NODE:
; 7968 :             case XML_PI_NODE:
; 7969 :             case XML_COMMENT_NODE:
; 7970 :             case XML_NOTATION_NODE:
; 7971 :             case XML_DTD_NODE:
; 7972 : 	    case XML_ELEMENT_DECL:
; 7973 : 	    case XML_ATTRIBUTE_DECL:
; 7974 : 	    case XML_XINCLUDE_START:
; 7975 : 	    case XML_XINCLUDE_END:
; 7976 : 	    case XML_ENTITY_DECL:
; 7977 : 		if (ctxt->context->node->parent == NULL)

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	jne	SHORT $LN9@xmlXPathNe

; 7978 : 		    return((xmlNodePtr) ctxt->context->doc);

	mov	eax, DWORD PTR [esi]
	pop	edi

; 8002 : 		    (ns->next->type != XML_NAMESPACE_DECL))
; 8003 : 		    return((xmlNodePtr) ns->next);
; 8004 :                 return(NULL);
; 8005 : 	    }
; 8006 : 	}
; 8007 :     }
; 8008 :     return(NULL);
; 8009 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlXPathNe:

; 7979 : 		if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN18@xmlXPathNe
	mov	eax, DWORD PTR [eax+8]
	cmp	BYTE PTR [eax], 32			; 00000020H
	je	SHORT $LN5@xmlXPathNe
	push	OFFSET ??_C@_0BC@MHFGEIED@fake?5node?5libxslt@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@xmlXPathNe
$LN18@xmlXPathNe:

; 7980 : 		    ((ctxt->context->node->parent->name[0] == ' ') ||
; 7981 : 		     (xmlStrEqual(ctxt->context->node->parent->name,
; 7982 : 				 BAD_CAST "fake node libxslt"))))
; 7983 : 		    return(NULL);
; 7984 : 		return(ctxt->context->node->parent);

	mov	eax, DWORD PTR [edi+12]
	pop	edi

; 8002 : 		    (ns->next->type != XML_NAMESPACE_DECL))
; 8003 : 		    return((xmlNodePtr) ns->next);
; 8004 :                 return(NULL);
; 8005 : 	    }
; 8006 : 	}
; 8007 :     }
; 8008 :     return(NULL);
; 8009 : }

	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+20]
	pop	ebp
	ret	0
$LN12@xmlXPathNe:

; 7985 :             case XML_ATTRIBUTE_NODE: {
; 7986 : 		xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;
; 7987 : 
; 7988 : 		return(att->parent);

	mov	eax, DWORD PTR [edx+20]
	pop	edi

; 8002 : 		    (ns->next->type != XML_NAMESPACE_DECL))
; 8003 : 		    return((xmlNodePtr) ns->next);
; 8004 :                 return(NULL);
; 8005 : 	    }
; 8006 : 	}
; 8007 :     }
; 8008 :     return(NULL);
; 8009 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlXPathNe:

; 7989 : 	    }
; 7990 :             case XML_DOCUMENT_NODE:
; 7991 :             case XML_DOCUMENT_TYPE_NODE:
; 7992 :             case XML_DOCUMENT_FRAG_NODE:
; 7993 :             case XML_HTML_DOCUMENT_NODE:
; 7994 : #ifdef LIBXML_DOCB_ENABLED
; 7995 : 	    case XML_DOCB_DOCUMENT_NODE:
; 7996 : #endif
; 7997 :                 return(NULL);
; 7998 : 	    case XML_NAMESPACE_DECL: {
; 7999 : 		xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;
; 8000 : 
; 8001 : 		if ((ns->next != NULL) &&

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN5@xmlXPathNe
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN1@xmlXPathNe
$LN5@xmlXPathNe:

; 7954 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:
	pop	edi

; 8002 : 		    (ns->next->type != XML_NAMESPACE_DECL))
; 8003 : 		    return((xmlNodePtr) ns->next);
; 8004 :                 return(NULL);
; 8005 : 	    }
; 8006 : 	}
; 8007 :     }
; 8008 :     return(NULL);
; 8009 : }

	pop	esi
	pop	ebp
	ret	0
$LN21@xmlXPathNe:
	DD	$LN8@xmlXPathNe
	DD	$LN12@xmlXPathNe
	DD	$LN5@xmlXPathNe
	DD	$LN14@xmlXPathNe
$LN19@xmlXPathNe:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	0
	DB	0
	DB	2
_xmlXPathNextParent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextDescendantOrSelf
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextDescendantOrSelf PROC			; COMDAT

; 7928 : xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathNe

; 7929 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 7930 :     if (cur == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax+4]
	test	edx, edx
	je	SHORT $LN1@xmlXPathNe

; 7931 :         return(ctxt->context->node);
; 7932 : 
; 7933 :     if (ctxt->context->node == NULL)

	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 7934 :         return(NULL);
; 7935 :     if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||

	mov	eax, DWORD PTR [eax+4]
	cmp	eax, 2
	je	SHORT $LN3@xmlXPathNe
	cmp	eax, 18					; 00000012H
	je	SHORT $LN3@xmlXPathNe

; 7936 :         (ctxt->context->node->type == XML_NAMESPACE_DECL))
; 7937 :         return(NULL);
; 7938 : 
; 7939 :     return(xmlXPathNextDescendant(ctxt, cur));

	mov	DWORD PTR _cur$[ebp], edx
	mov	DWORD PTR _ctxt$[ebp], ecx

; 7940 : }

	pop	ebp

; 7936 :         (ctxt->context->node->type == XML_NAMESPACE_DECL))
; 7937 :         return(NULL);
; 7938 : 
; 7939 :     return(xmlXPathNextDescendant(ctxt, cur));

	jmp	_xmlXPathNextDescendant
$LN3@xmlXPathNe:

; 7929 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:

; 7940 : }

	pop	ebp
	ret	0
_xmlXPathNextDescendantOrSelf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextDescendant
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextDescendant PROC				; COMDAT

; 7863 : xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	$LN8@xmlXPathNe

; 7864 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	je	$LN8@xmlXPathNe

; 7865 :     if (cur == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN9@xmlXPathNe

; 7866 : 	if (ctxt->context->node == NULL)

	mov	eax, DWORD PTR [edx+4]
	test	eax, eax
	je	SHORT $LN8@xmlXPathNe

; 7867 : 	    return(NULL);
; 7868 : 	if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 2
	je	SHORT $LN8@xmlXPathNe
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN8@xmlXPathNe

; 7869 : 	    (ctxt->context->node->type == XML_NAMESPACE_DECL))
; 7870 : 	    return(NULL);
; 7871 : 
; 7872 :         if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN13@xmlXPathNe

; 7873 : 	    return(ctxt->context->doc->children);

	mov	eax, DWORD PTR [ecx+12]

; 7909 : 	}
; 7910 :     } while (cur != NULL);
; 7911 :     return(cur);
; 7912 : }

	pop	ebp
	ret	0
$LN13@xmlXPathNe:

; 7874 :         return(ctxt->context->node->children);

	mov	eax, DWORD PTR [eax+12]

; 7909 : 	}
; 7910 :     } while (cur != NULL);
; 7911 :     return(cur);
; 7912 : }

	pop	ebp
	ret	0
$LN9@xmlXPathNe:

; 7875 :     }
; 7876 : 
; 7877 :     if (cur->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPathNe

; 7878 :         return(NULL);
; 7879 :     if (cur->children != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN17@xmlXPathNe

; 7880 : 	/*
; 7881 : 	 * Do not descend on entities declarations
; 7882 : 	 */
; 7883 : 	if (cur->children->type != XML_ENTITY_DECL) {

	cmp	DWORD PTR [ecx+4], 17			; 00000011H
	je	SHORT $LN17@xmlXPathNe

; 7884 : 	    cur = cur->children;
; 7885 : 	    /*
; 7886 : 	     * Skip DTDs
; 7887 : 	     */
; 7888 : 	    if (cur->type != XML_DTD_NODE)

	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	mov	eax, ecx
	jne	SHORT $LN1@xmlXPathNe
$LN17@xmlXPathNe:

; 7889 : 		return(cur);
; 7890 : 	}
; 7891 :     }
; 7892 : 
; 7893 :     if (cur == ctxt->context->node) return(NULL);

	mov	edx, DWORD PTR [edx+4]
	cmp	eax, edx
	je	SHORT $LN8@xmlXPathNe

; 7894 : 
; 7895 :     while (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlXPathNe
$LL2@xmlXPathNe:

; 7896 : 	cur = cur->next;

	mov	eax, ecx

; 7897 : 	if ((cur->type != XML_ENTITY_DECL) &&

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN33@xmlXPathNe
	cmp	ecx, 14					; 0000000eH
	jne	SHORT $LN1@xmlXPathNe
$LN33@xmlXPathNe:

; 7894 : 
; 7895 :     while (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LL2@xmlXPathNe
	npad	3
$LL6@xmlXPathNe:

; 7898 : 	    (cur->type != XML_DTD_NODE))
; 7899 : 	    return(cur);
; 7900 :     }
; 7901 : 
; 7902 :     do {
; 7903 :         cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 7904 : 	if (cur == NULL) break;

	test	eax, eax
	je	SHORT $LN8@xmlXPathNe

; 7905 : 	if (cur == ctxt->context->node) return(NULL);

	cmp	eax, edx
	je	SHORT $LN8@xmlXPathNe

; 7906 : 	if (cur->next != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlXPathNe

; 7907 : 	    cur = cur->next;
; 7908 : 	    return(cur);

	mov	eax, ecx

; 7909 : 	}
; 7910 :     } while (cur != NULL);
; 7911 :     return(cur);
; 7912 : }

	pop	ebp
	ret	0
$LN8@xmlXPathNe:

; 7864 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax
$LN1@xmlXPathNe:

; 7909 : 	}
; 7910 :     } while (cur != NULL);
; 7911 :     return(cur);
; 7912 : }

	pop	ebp
	ret	0
_xmlXPathNextDescendant ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextChild
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextChild PROC					; COMDAT

; 7658 : xmlXPathNextChild(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPathNe

; 7659 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathNe

; 7660 :     if (cur == NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	jne	SHORT $LN6@xmlXPathNe

; 7661 : 	if (ctxt->context->node == NULL) return(NULL);

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathNe

; 7662 : 	switch (ctxt->context->node->type) {

	mov	eax, DWORD PTR [ecx+4]
	dec	eax
	cmp	eax, 20					; 00000014H
	ja	SHORT $LN5@xmlXPathNe
	movzx	eax, BYTE PTR $LN14@xmlXPathNe[eax]
	jmp	DWORD PTR $LN16@xmlXPathNe[eax*4]
$LN9@xmlXPathNe:

; 7663 :             case XML_ELEMENT_NODE:
; 7664 :             case XML_TEXT_NODE:
; 7665 :             case XML_CDATA_SECTION_NODE:
; 7666 :             case XML_ENTITY_REF_NODE:
; 7667 :             case XML_ENTITY_NODE:
; 7668 :             case XML_PI_NODE:
; 7669 :             case XML_COMMENT_NODE:
; 7670 :             case XML_NOTATION_NODE:
; 7671 :             case XML_DTD_NODE:
; 7672 : 		return(ctxt->context->node->children);
; 7673 :             case XML_DOCUMENT_NODE:
; 7674 :             case XML_DOCUMENT_TYPE_NODE:
; 7675 :             case XML_DOCUMENT_FRAG_NODE:
; 7676 :             case XML_HTML_DOCUMENT_NODE:
; 7677 : #ifdef LIBXML_DOCB_ENABLED
; 7678 : 	    case XML_DOCB_DOCUMENT_NODE:
; 7679 : #endif
; 7680 : 		return(((xmlDocPtr) ctxt->context->node)->children);

	mov	eax, DWORD PTR [ecx+12]

; 7696 : }

	pop	ebp
	ret	0
$LN6@xmlXPathNe:

; 7681 : 	    case XML_ELEMENT_DECL:
; 7682 : 	    case XML_ATTRIBUTE_DECL:
; 7683 : 	    case XML_ENTITY_DECL:
; 7684 :             case XML_ATTRIBUTE_NODE:
; 7685 : 	    case XML_NAMESPACE_DECL:
; 7686 : 	    case XML_XINCLUDE_START:
; 7687 : 	    case XML_XINCLUDE_END:
; 7688 : 		return(NULL);
; 7689 : 	}
; 7690 : 	return(NULL);
; 7691 :     }
; 7692 :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 9
	je	SHORT $LN5@xmlXPathNe
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN5@xmlXPathNe

; 7693 :         (cur->type == XML_HTML_DOCUMENT_NODE))
; 7694 : 	return(NULL);
; 7695 :     return(cur->next);

	mov	eax, DWORD PTR [eax+24]

; 7696 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNe:

; 7659 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 7696 : }

	pop	ebp
	ret	0
	npad	1
$LN16@xmlXPathNe:
	DD	$LN9@xmlXPathNe
	DD	$LN5@xmlXPathNe
$LN14@xmlXPathNe:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlXPathNextChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNextSelf
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlXPathNextSelf PROC					; COMDAT

; 7640 : xmlXPathNextSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 7641 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN3@xmlXPathNe

; 7642 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN3@xmlXPathNe

; 7643 :         return(ctxt->context->node);

	mov	eax, DWORD PTR [eax+4]

; 7644 :     return(NULL);
; 7645 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNe:

; 7641 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);

	xor	eax, eax

; 7644 :     return(NULL);
; 7645 : }

	pop	ebp
	ret	0
_xmlXPathNextSelf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsNodeType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_xmlXPathIsNodeType PROC				; COMDAT

; 10374: xmlXPathIsNodeType(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlXPathIs

; 10375:     if (name == NULL)
; 10376: 	return(0);
; 10377: 
; 10378:     if (xmlStrEqual(name, BAD_CAST "node"))

	push	OFFSET ??_C@_04CLMONKIF@node@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlXPathIs

; 10379: 	return(1);
; 10380:     if (xmlStrEqual(name, BAD_CAST "text"))

	push	OFFSET ??_C@_04CIMGMMMG@text@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlXPathIs

; 10381: 	return(1);
; 10382:     if (xmlStrEqual(name, BAD_CAST "comment"))

	push	OFFSET ??_C@_07GJGNEJFD@comment@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlXPathIs

; 10383: 	return(1);
; 10384:     if (xmlStrEqual(name, BAD_CAST "processing-instruction"))

	push	OFFSET ??_C@_0BH@NNLCFMHO@processing?9instruction@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlXPathIs
$LN8@xmlXPathIs:

; 10385: 	return(1);

	mov	eax, 1
	pop	esi

; 10387: }

	pop	ebp
	ret	0
$LN6@xmlXPathIs:

; 10386:     return(0);

	xor	eax, eax
	pop	esi

; 10387: }

	pop	ebp
	ret	0
_xmlXPathIsNodeType ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathModValues
_TEXT	SEGMENT
_arg1$ = -24						; size = 8
_arg2$1$ = -16						; size = 8
_arg2$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathModValues PROC					; COMDAT

; 7578 : xmlXPathModValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathMo

; 7594 :     }
; 7595 : }

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathMo:

; 7579 :     xmlXPathObjectPtr arg;
; 7580 :     double arg1, arg2;
; 7581 : 
; 7582 :     arg = valuePop(ctxt);
; 7583 :     if (arg == NULL)
; 7584 : 	XP_ERROR(XPATH_INVALID_OPERAND);
; 7585 :     arg2 = xmlXPathCastToNumber(arg);

	push	edi
	call	_xmlXPathCastToNumber

; 7586 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	edi
	push	DWORD PTR [esi+12]
	fst	QWORD PTR _arg2$1$[ebp]
	fstp	QWORD PTR _arg2$[ebp]
	call	_xmlXPathReleaseObject

; 7587 :     CAST_TO_NUMBER;

	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	edi, eax
	test	eax, eax
	je	SHORT $LN3@xmlXPathMo
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN3@xmlXPathMo
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	edi, DWORD PTR [esi+16]
	add	esp, 8
$LN3@xmlXPathMo:

; 7588 :     CHECK_TYPE(XPATH_NUMBER);

	test	edi, edi
	je	SHORT $LN5@xmlXPathMo
	cmp	DWORD PTR [edi], 3
	jne	SHORT $LN5@xmlXPathMo

; 7589 :     arg1 = ctxt->value->floatval;

	movsd	xmm0, QWORD PTR [edi+16]
	movsd	QWORD PTR _arg1$[ebp], xmm0

; 7590 :     if (arg2 == 0)

	movsd	xmm0, QWORD PTR _arg2$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@xmlXPathMo

; 7591 : 	ctxt->value->floatval = NAN;

	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR [edi+16], xmm0
	pop	edi

; 7594 :     }
; 7595 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathMo:

; 7592 :     else {
; 7593 : 	ctxt->value->floatval = fmod(arg1, arg2);

	fld	QWORD PTR _arg1$[ebp]
	fld	QWORD PTR _arg2$1$[ebp]
	call	__CIfmod
	fstp	QWORD PTR [edi+16]
	pop	edi

; 7594 :     }
; 7595 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathMo:

; 7588 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 7594 :     }
; 7595 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathModValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDivValues
_TEXT	SEGMENT
_val$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathDivValues PROC					; COMDAT

; 7555 : xmlXPathDivValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathDi

; 7567 : }

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathDi:

; 7556 :     xmlXPathObjectPtr arg;
; 7557 :     double val;
; 7558 : 
; 7559 :     arg = valuePop(ctxt);
; 7560 :     if (arg == NULL)
; 7561 : 	XP_ERROR(XPATH_INVALID_OPERAND);
; 7562 :     val = xmlXPathCastToNumber(arg);

	push	edi
	call	_xmlXPathCastToNumber

; 7563 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	edi
	push	DWORD PTR [esi+12]
	fstp	QWORD PTR _val$[ebp]
	call	_xmlXPathReleaseObject

; 7564 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathDi
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN3@xmlXPathDi
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN3@xmlXPathDi:

; 7565 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	SHORT $LN5@xmlXPathDi
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN5@xmlXPathDi

; 7566 :     ctxt->value->floatval /= val;

	movsd	xmm0, QWORD PTR [eax+16]
	divsd	xmm0, QWORD PTR _val$[ebp]
	pop	edi

; 7567 : }

	pop	esi
	movsd	QWORD PTR [eax+16], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathDi:

; 7565 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 7567 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDivValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathMultValues
_TEXT	SEGMENT
_val$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathMultValues PROC				; COMDAT

; 7532 : xmlXPathMultValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathMu

; 7544 : }

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathMu:

; 7533 :     xmlXPathObjectPtr arg;
; 7534 :     double val;
; 7535 : 
; 7536 :     arg = valuePop(ctxt);
; 7537 :     if (arg == NULL)
; 7538 : 	XP_ERROR(XPATH_INVALID_OPERAND);
; 7539 :     val = xmlXPathCastToNumber(arg);

	push	edi
	call	_xmlXPathCastToNumber

; 7540 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	edi
	push	DWORD PTR [esi+12]
	fstp	QWORD PTR _val$[ebp]
	call	_xmlXPathReleaseObject

; 7541 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathMu
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN3@xmlXPathMu
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN3@xmlXPathMu:

; 7542 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	SHORT $LN5@xmlXPathMu
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN5@xmlXPathMu

; 7543 :     ctxt->value->floatval *= val;

	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR [eax+16]
	pop	edi

; 7544 : }

	pop	esi
	movsd	QWORD PTR [eax+16], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathMu:

; 7542 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 7544 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathMultValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSubValues
_TEXT	SEGMENT
_val$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathSubValues PROC					; COMDAT

; 7509 : xmlXPathSubValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathSu

; 7521 : }

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathSu:

; 7510 :     xmlXPathObjectPtr arg;
; 7511 :     double val;
; 7512 : 
; 7513 :     arg = valuePop(ctxt);
; 7514 :     if (arg == NULL)
; 7515 : 	XP_ERROR(XPATH_INVALID_OPERAND);
; 7516 :     val = xmlXPathCastToNumber(arg);

	push	edi
	call	_xmlXPathCastToNumber

; 7517 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	edi
	push	DWORD PTR [esi+12]
	fstp	QWORD PTR _val$[ebp]
	call	_xmlXPathReleaseObject

; 7518 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathSu
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN3@xmlXPathSu
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN3@xmlXPathSu:

; 7519 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	SHORT $LN5@xmlXPathSu
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN5@xmlXPathSu

; 7520 :     ctxt->value->floatval -= val;

	movsd	xmm0, QWORD PTR [eax+16]
	subsd	xmm0, QWORD PTR _val$[ebp]
	pop	edi

; 7521 : }

	pop	esi
	movsd	QWORD PTR [eax+16], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathSu:

; 7519 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 7521 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathSubValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathAddValues
_TEXT	SEGMENT
_val$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathAddValues PROC					; COMDAT

; 7486 : xmlXPathAddValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathAd

; 7498 : }

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathAd:

; 7487 :     xmlXPathObjectPtr arg;
; 7488 :     double val;
; 7489 : 
; 7490 :     arg = valuePop(ctxt);
; 7491 :     if (arg == NULL)
; 7492 : 	XP_ERROR(XPATH_INVALID_OPERAND);
; 7493 :     val = xmlXPathCastToNumber(arg);

	push	edi
	call	_xmlXPathCastToNumber

; 7494 :     xmlXPathReleaseObject(ctxt->context, arg);

	push	edi
	push	DWORD PTR [esi+12]
	fstp	QWORD PTR _val$[ebp]
	call	_xmlXPathReleaseObject

; 7495 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathAd
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN3@xmlXPathAd
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN3@xmlXPathAd:

; 7496 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	SHORT $LN5@xmlXPathAd
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN5@xmlXPathAd

; 7497 :     ctxt->value->floatval += val;

	movsd	xmm0, QWORD PTR _val$[ebp]
	addsd	xmm0, QWORD PTR [eax+16]
	pop	edi

; 7498 : }

	pop	esi
	movsd	QWORD PTR [eax+16], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathAd:

; 7496 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH

; 7498 : }

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathAddValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathValueFlipSign
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathValueFlipSign PROC				; COMDAT

; 7470 : xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathVa

; 7471 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return;

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN3@xmlXPathVa

; 7472 :     CAST_TO_NUMBER;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	test	ecx, ecx
	je	SHORT $LN4@xmlXPathVa
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN4@xmlXPathVa
	push	1
	push	esi
	call	_xmlXPathNumberFunction
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN4@xmlXPathVa:

; 7473 :     CHECK_TYPE(XPATH_NUMBER);

	test	eax, eax
	je	SHORT $LN6@xmlXPathVa
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN6@xmlXPathVa

; 7474 :     ctxt->value->floatval = -ctxt->value->floatval;

	movsd	xmm0, QWORD PTR [eax+16]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR [eax+16], xmm0
	pop	esi

; 7475 : }

	pop	ebp
	ret	0
$LN6@xmlXPathVa:

; 7473 :     CHECK_TYPE(XPATH_NUMBER);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN3@xmlXPathVa:
	pop	esi

; 7475 : }

	pop	ebp
	ret	0
_xmlXPathValueFlipSign ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompareValues
_TEXT	SEGMENT
_arg1i$1$ = -4						; size = 4
_arg1$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_inf$ = 12						; size = 4
_strict$ = 16						; size = 4
_xmlXPathCompareValues PROC				; COMDAT

; 7350 : xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@xmlXPathCo

; 7351 :     int ret = 0, arg1i = 0, arg2i = 0;
; 7352 :     xmlXPathObjectPtr arg1, arg2;
; 7353 : 
; 7354 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	cmp	DWORD PTR [esi+12], 0
	je	$LN3@xmlXPathCo

; 7355 :     arg2 = valuePop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_valuePop

; 7356 :     arg1 = valuePop(ctxt);

	push	esi
	mov	edi, eax
	call	_valuePop
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _arg1$1$[ebp], ebx

; 7357 :     if ((arg1 == NULL) || (arg2 == NULL)) {

	test	ebx, ebx
	je	$LN61@xmlXPathCo
	test	edi, edi
	je	$LN5@xmlXPathCo

; 7363 :     }
; 7364 : 
; 7365 :     if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
; 7366 :       (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 1
	je	$LN12@xmlXPathCo
	cmp	eax, 9
	je	$LN12@xmlXPathCo
	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	$LN16@xmlXPathCo
	cmp	eax, 9
	je	$LN54@xmlXPathCo

; 7381 : 			                          arg2, arg1);
; 7382 : 	    }
; 7383 : 	}
; 7384 : 	return(ret);
; 7385 :     }
; 7386 : 
; 7387 :     if (arg1->type != XPATH_NUMBER) {

	cmp	eax, 3
	je	SHORT $LN18@xmlXPathCo

; 7388 : 	valuePush(ctxt, arg1);

	push	ebx
	push	esi
	call	_valuePush

; 7389 : 	xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathNumberFunction

; 7390 : 	arg1 = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _arg1$1$[ebp], ebx
	mov	eax, DWORD PTR [ebx]

; 7391 :     }
; 7392 :     if (arg1->type != XPATH_NUMBER) {

	cmp	eax, 3
	je	SHORT $LN18@xmlXPathCo

; 7393 : 	xmlXPathFreeObject(arg1);

	push	ebx
	call	_xmlXPathFreeObject

; 7394 : 	xmlXPathFreeObject(arg2);

	push	edi
	call	_xmlXPathFreeObject

; 7405 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlXPathCo:

; 7395 : 	XP_ERROR0(XPATH_INVALID_OPERAND);
; 7396 :     }
; 7397 :     if (arg2->type != XPATH_NUMBER) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 3
	je	SHORT $LN20@xmlXPathCo

; 7398 : 	valuePush(ctxt, arg2);

	push	edi
	push	esi
	call	_valuePush

; 7399 : 	xmlXPathNumberFunction(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathNumberFunction

; 7400 : 	arg2 = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR [edi]

; 7401 :     }
; 7402 :     if (arg2->type != XPATH_NUMBER) {

	cmp	eax, 3
	je	SHORT $LN20@xmlXPathCo

; 7403 : 	xmlXPathReleaseObject(ctxt->context, arg1);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7404 : 	xmlXPathReleaseObject(ctxt->context, arg2);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7405 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 24					; 00000018H
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlXPathCo:

; 7406 :     }
; 7407 :     /*
; 7408 :      * Add tests for infinity and nan
; 7409 :      * => feedback on 3.4 for Inf and NaN
; 7410 :      */
; 7411 :     /* Hand check NaN and Infinity comparisons */
; 7412 :     if (xmlXPathIsNaN(arg1->floatval) || xmlXPathIsNaN(arg2->floatval)) {

	movsd	xmm0, QWORD PTR [ebx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN23@xmlXPathCo
	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	jne	$LN23@xmlXPathCo

; 7413 : 	ret=0;
; 7414 :     } else {
; 7415 : 	arg1i=xmlXPathIsInf(arg1->floatval);

	movsd	xmm0, QWORD PTR [ebx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf

; 7416 : 	arg2i=xmlXPathIsInf(arg2->floatval);

	movsd	xmm0, QWORD PTR [edi+16]
	mov	DWORD PTR _arg1i$1$[ebp], eax
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf

; 7417 : 	if (inf && strict) {

	mov	ecx, DWORD PTR _arg1i$1$[ebp]
	add	esp, 8
	cmp	DWORD PTR _inf$[ebp], 0
	je	SHORT $LN55@xmlXPathCo
	cmp	DWORD PTR _strict$[ebp], 0
	je	SHORT $LN24@xmlXPathCo

; 7418 : 	    if ((arg1i == -1 && arg2i != -1) ||

	cmp	ecx, -1
	jne	SHORT $LN29@xmlXPathCo
	cmp	eax, ecx
	jne	SHORT $LN28@xmlXPathCo
$LN29@xmlXPathCo:
	cmp	eax, 1
	jne	SHORT $LN26@xmlXPathCo
	cmp	ecx, eax
	je	SHORT $LN26@xmlXPathCo
$LN28@xmlXPathCo:

; 7452 : 		ret = 0;
; 7453 : 	    }
; 7454 : 	}
; 7455 :     }
; 7456 :     xmlXPathReleaseObject(ctxt->context, arg1);

	mov	ebx, 1
	jmp	$LN65@xmlXPathCo
$LN26@xmlXPathCo:

; 7419 : 		(arg2i == 1 && arg1i != 1)) {
; 7420 : 		ret = 1;
; 7421 : 	    } else if (arg1i == 0 && arg2i == 0) {

	test	ecx, ecx
	jne	$LN23@xmlXPathCo
	test	eax, eax
	jne	$LN23@xmlXPathCo

; 7422 : 		ret = (arg1->floatval < arg2->floatval);

	mov	eax, DWORD PTR _arg1$1$[ebp]
	xor	ebx, ebx
	movsd	xmm0, QWORD PTR [edi+16]
	comisd	xmm0, QWORD PTR [eax+16]
	seta	bl

; 7423 : 	    } else {
; 7424 : 		ret = 0;
; 7425 : 	    }
; 7426 : 	}

	jmp	$LN52@xmlXPathCo
$LN24@xmlXPathCo:

; 7427 : 	else if (inf && !strict) {
; 7428 : 	    if (arg1i == -1 || arg2i == 1) {

	cmp	ecx, -1
	je	SHORT $LN28@xmlXPathCo
	cmp	eax, 1
	je	SHORT $LN28@xmlXPathCo

; 7429 : 		ret = 1;
; 7430 : 	    } else if (arg1i == 0 && arg2i == 0) {

	test	ecx, ecx
	jne	SHORT $LN23@xmlXPathCo
	test	eax, eax
	jne	SHORT $LN23@xmlXPathCo

; 7431 : 		ret = (arg1->floatval <= arg2->floatval);

	mov	eax, DWORD PTR _arg1$1$[ebp]
	xor	ebx, ebx
	movsd	xmm0, QWORD PTR [edi+16]
	comisd	xmm0, QWORD PTR [eax+16]
	setae	bl

; 7432 : 	    } else {
; 7433 : 		ret = 0;

	jmp	SHORT $LN52@xmlXPathCo
$LN55@xmlXPathCo:

; 7434 : 	    }
; 7435 : 	}
; 7436 : 	else if (!inf && strict) {

	cmp	DWORD PTR _strict$[ebp], 0
	je	SHORT $LN58@xmlXPathCo

; 7437 : 	    if ((arg1i == 1 && arg2i != 1) ||

	cmp	ecx, 1
	jne	SHORT $LN44@xmlXPathCo
	cmp	eax, ecx
	jne	SHORT $LN28@xmlXPathCo
$LN44@xmlXPathCo:
	cmp	eax, -1
	jne	SHORT $LN41@xmlXPathCo
	cmp	ecx, eax
	jne	SHORT $LN28@xmlXPathCo
$LN41@xmlXPathCo:

; 7438 : 		(arg2i == -1 && arg1i != -1)) {
; 7439 : 		ret = 1;
; 7440 : 	    } else if (arg1i == 0 && arg2i == 0) {

	test	ecx, ecx
	jne	SHORT $LN23@xmlXPathCo
	test	eax, eax
	jne	SHORT $LN23@xmlXPathCo

; 7441 : 		ret = (arg1->floatval > arg2->floatval);

	movsd	xmm0, QWORD PTR [ebx+16]
	xor	ebx, ebx
	comisd	xmm0, QWORD PTR [edi+16]
	seta	bl

; 7442 : 	    } else {

	jmp	SHORT $LN65@xmlXPathCo
$LN58@xmlXPathCo:

; 7443 : 		ret = 0;
; 7444 : 	    }
; 7445 : 	}
; 7446 : 	else if (!inf && !strict) {
; 7447 : 	    if (arg1i == 1 || arg2i == -1) {

	cmp	ecx, 1
	je	$LN28@xmlXPathCo
	cmp	eax, -1
	je	$LN28@xmlXPathCo

; 7448 : 		ret = 1;
; 7449 : 	    } else if (arg1i == 0 && arg2i == 0) {

	test	ecx, ecx
	jne	SHORT $LN23@xmlXPathCo
	test	eax, eax
	jne	SHORT $LN23@xmlXPathCo

; 7450 : 		ret = (arg1->floatval >= arg2->floatval);

	movsd	xmm0, QWORD PTR [ebx+16]
	xor	ebx, ebx
	comisd	xmm0, QWORD PTR [edi+16]
	setae	bl

; 7451 : 	    } else {

	jmp	SHORT $LN65@xmlXPathCo
$LN23@xmlXPathCo:

; 7452 : 		ret = 0;
; 7453 : 	    }
; 7454 : 	}
; 7455 :     }
; 7456 :     xmlXPathReleaseObject(ctxt->context, arg1);

	xor	ebx, ebx
$LN65@xmlXPathCo:
	mov	eax, DWORD PTR _arg1$1$[ebp]
$LN52@xmlXPathCo:
	push	eax
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7457 :     xmlXPathReleaseObject(ctxt->context, arg2);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 16					; 00000010H

; 7458 :     return(ret);

	mov	eax, ebx
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathCo:

; 7367 : 	/*
; 7368 : 	 * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments
; 7369 : 	 * are not freed from within this routine; they will be freed from the
; 7370 : 	 * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue
; 7371 : 	 */
; 7372 : 	if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	SHORT $LN13@xmlXPathCo
	cmp	eax, 9
	je	SHORT $LN13@xmlXPathCo
$LN54@xmlXPathCo:

; 7375 : 	} else {
; 7376 : 	    if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {

	cmp	eax, 1
	je	SHORT $LN16@xmlXPathCo
	cmp	eax, 9
	je	SHORT $LN16@xmlXPathCo

; 7378 : 			                          arg1, arg2);
; 7379 : 	    } else {
; 7380 : 		ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,

	push	ebx
	xor	eax, eax
	cmp	DWORD PTR _inf$[ebp], eax
	push	edi
	push	DWORD PTR _strict$[ebp]
	sete	al
	push	eax
	push	esi
	call	_xmlXPathCompareNodeSetValue
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlXPathCo:

; 7377 : 		ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,

	push	edi
	push	ebx
	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	push	esi
	call	_xmlXPathCompareNodeSetValue
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathCo:

; 7373 : 	  ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){
; 7374 : 	    ret = xmlXPathCompareNodeSets(inf, strict, arg1, arg2);

	push	edi
	push	ebx
	push	DWORD PTR _strict$[ebp]
	push	DWORD PTR _inf$[ebp]
	call	_xmlXPathCompareNodeSets
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathCo:

; 7358 : 	if (arg1 != NULL)

	test	ebx, ebx
$LN61@xmlXPathCo:

; 7359 : 	    xmlXPathReleaseObject(ctxt->context, arg1);
; 7360 : 	else
; 7361 : 	    xmlXPathReleaseObject(ctxt->context, arg2);
; 7362 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	mov	eax, DWORD PTR [esi+12]
	cmovne	edi, ebx
	push	edi
	push	eax
	call	_xmlXPathReleaseObject

; 7405 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 7351 :     int ret = 0, arg1i = 0, arg2i = 0;
; 7352 :     xmlXPathObjectPtr arg1, arg2;
; 7353 : 
; 7354 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	xor	eax, eax
	pop	esi

; 7459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompareValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNotEqualValues
_TEXT	SEGMENT
_ret$2$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathNotEqualValues PROC				; COMDAT

; 7249 : xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ret$2$[ebp], 0
	test	esi, esi
	je	$LN5@xmlXPathNo

; 7250 :     xmlXPathObjectPtr arg1, arg2, argtmp;
; 7251 :     int ret = 0;
; 7252 : 
; 7253 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	cmp	DWORD PTR [esi+12], 0
	je	$LN5@xmlXPathNo

; 7254 :     arg2 = valuePop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_valuePop

; 7255 :     arg1 = valuePop(ctxt);

	push	esi
	mov	ebx, eax
	call	_valuePop
	mov	edi, eax
	add	esp, 8

; 7256 :     if ((arg1 == NULL) || (arg2 == NULL)) {

	test	edi, edi
	je	$LN26@xmlXPathNo
	test	ebx, ebx
	je	$LN7@xmlXPathNo

; 7262 :     }
; 7263 : 
; 7264 :     if (arg1 == arg2) {

	cmp	edi, ebx
	jne	SHORT $LN10@xmlXPathNo

; 7265 : #ifdef DEBUG_EXPR
; 7266 :         xmlGenericError(xmlGenericErrorContext,
; 7267 : 		"NotEqual: by pointer\n");
; 7268 : #endif
; 7269 : 	xmlXPathReleaseObject(ctxt->context, arg1);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 7270 :         return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathNo:

; 7271 :     }
; 7272 : 
; 7273 :     /*
; 7274 :      *If either argument is a nodeset, it's a 'special case'
; 7275 :      */
; 7276 :     if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
; 7277 :       (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	SHORT $LN12@xmlXPathNo
	cmp	eax, 9
	je	SHORT $LN12@xmlXPathNo
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, 1
	je	SHORT $LN12@xmlXPathNo
	cmp	ecx, 9
	je	SHORT $LN12@xmlXPathNo

; 7320 :     }
; 7321 : 
; 7322 :     return (!xmlXPathEqualValuesCommon(ctxt, arg1, arg2));

	push	ebx
	push	edi
	push	esi
	call	_xmlXPathEqualValuesCommon
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	ebx
	pop	esi

; 7323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathNo:

; 7278 : 	/*
; 7279 : 	 *Hack it to assure arg1 is the nodeset
; 7280 : 	 */
; 7281 : 	if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, 1
	je	SHORT $LN13@xmlXPathNo
	cmp	ecx, 9
	je	SHORT $LN13@xmlXPathNo

; 7282 : 		argtmp = arg2;

	mov	eax, ebx

; 7283 : 		arg2 = arg1;

	mov	ebx, edi

; 7284 : 		arg1 = argtmp;

	mov	edi, eax
	mov	eax, ecx
$LN13@xmlXPathNo:

; 7285 : 	}
; 7286 : 	switch (arg2->type) {

	dec	eax
	cmp	eax, 8
	ja	$LN2@xmlXPathNo
	jmp	DWORD PTR $LN29@xmlXPathNo[eax*4]
$LN15@xmlXPathNo:

; 7287 : 	    case XPATH_UNDEFINED:
; 7288 : #ifdef DEBUG_EXPR
; 7289 : 		xmlGenericError(xmlGenericErrorContext,
; 7290 : 			"NotEqual: undefined\n");
; 7291 : #endif
; 7292 : 		break;
; 7293 : 	    case XPATH_NODESET:
; 7294 : 	    case XPATH_XSLT_TREE:
; 7295 : 		ret = xmlXPathEqualNodeSets(arg1, arg2, 1);

	push	1
	push	ebx
	push	edi
	call	_xmlXPathEqualNodeSets
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], eax

; 7296 : 		break;

	jmp	$LN2@xmlXPathNo
$LN16@xmlXPathNo:

; 7297 : 	    case XPATH_BOOLEAN:
; 7298 : 		if ((arg1->nodesetval == NULL) ||

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN19@xmlXPathNo
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN19@xmlXPathNo

; 7299 : 		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
; 7300 : 		else
; 7301 : 		    ret = 1;
; 7302 : 		ret = (ret != arg2->boolval);

	xor	eax, eax
	mov	ecx, 1
	cmp	ecx, DWORD PTR [ebx+8]
	setne	al
	mov	DWORD PTR _ret$2$[ebp], eax

; 7303 : 		break;

	jmp	SHORT $LN2@xmlXPathNo
$LN19@xmlXPathNo:

; 7299 : 		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
; 7300 : 		else
; 7301 : 		    ret = 1;
; 7302 : 		ret = (ret != arg2->boolval);

	xor	eax, eax
	xor	ecx, ecx
	cmp	ecx, DWORD PTR [ebx+8]
	setne	al
	mov	DWORD PTR _ret$2$[ebp], eax

; 7303 : 		break;

	jmp	SHORT $LN2@xmlXPathNo
$LN20@xmlXPathNo:

; 7304 : 	    case XPATH_NUMBER:
; 7305 : 		ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);

	movsd	xmm0, QWORD PTR [ebx+16]
	push	1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	esi
	call	_xmlXPathEqualNodeSetFloat
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$2$[ebp], eax

; 7306 : 		break;

	jmp	SHORT $LN2@xmlXPathNo
$LN21@xmlXPathNo:

; 7307 : 	    case XPATH_STRING:
; 7308 : 		ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval,1);

	push	1
	push	DWORD PTR [ebx+24]
	push	edi
	call	_xmlXPathEqualNodeSetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], eax

; 7309 : 		break;

	jmp	SHORT $LN2@xmlXPathNo
$LN22@xmlXPathNo:

; 7310 : 	    case XPATH_USERS:
; 7311 : 	    case XPATH_POINT:
; 7312 : 	    case XPATH_RANGE:
; 7313 : 	    case XPATH_LOCATIONSET:
; 7314 : 		TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7314					; 00001c92H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 16					; 00000010H
$LN2@xmlXPathNo:

; 7315 : 		break;
; 7316 : 	}
; 7317 : 	xmlXPathReleaseObject(ctxt->context, arg1);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7318 : 	xmlXPathReleaseObject(ctxt->context, arg2);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7319 : 	return(ret);

	mov	eax, DWORD PTR _ret$2$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 7323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathNo:

; 7257 : 	if (arg1 != NULL)

	test	edi, edi
$LN26@xmlXPathNo:

; 7258 : 	    xmlXPathReleaseObject(ctxt->context, arg1);
; 7259 : 	else
; 7260 : 	    xmlXPathReleaseObject(ctxt->context, arg2);
; 7261 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	mov	eax, DWORD PTR [esi+12]
	cmovne	ebx, edi
	push	ebx
	push	eax
	call	_xmlXPathReleaseObject
	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H

; 7270 :         return(0);

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathNo:

; 7250 :     xmlXPathObjectPtr arg1, arg2, argtmp;
; 7251 :     int ret = 0;
; 7252 : 
; 7253 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	xor	eax, eax
	pop	esi

; 7323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN29@xmlXPathNo:
	DD	$LN15@xmlXPathNo
	DD	$LN16@xmlXPathNo
	DD	$LN20@xmlXPathNo
	DD	$LN21@xmlXPathNo
	DD	$LN22@xmlXPathNo
	DD	$LN22@xmlXPathNo
	DD	$LN22@xmlXPathNo
	DD	$LN22@xmlXPathNo
	DD	$LN15@xmlXPathNo
_xmlXPathNotEqualValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEqualValues
_TEXT	SEGMENT
_ret$2$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPathEqualValues PROC				; COMDAT

; 7164 : xmlXPathEqualValues(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR _ret$2$[ebp], 0
	test	esi, esi
	je	$LN5@xmlXPathEq

; 7165 :     xmlXPathObjectPtr arg1, arg2, argtmp;
; 7166 :     int ret = 0;
; 7167 : 
; 7168 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	cmp	DWORD PTR [esi+12], 0
	je	$LN5@xmlXPathEq

; 7169 :     arg2 = valuePop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_valuePop

; 7170 :     arg1 = valuePop(ctxt);

	push	esi
	mov	ebx, eax
	call	_valuePop
	mov	edi, eax
	add	esp, 8

; 7171 :     if ((arg1 == NULL) || (arg2 == NULL)) {

	test	edi, edi
	je	$LN26@xmlXPathEq
	test	ebx, ebx
	je	$LN7@xmlXPathEq

; 7177 :     }
; 7178 : 
; 7179 :     if (arg1 == arg2) {

	cmp	edi, ebx
	jne	SHORT $LN10@xmlXPathEq

; 7180 : #ifdef DEBUG_EXPR
; 7181 :         xmlGenericError(xmlGenericErrorContext,
; 7182 : 		"Equal: by pointer\n");
; 7183 : #endif
; 7184 : 	xmlXPathFreeObject(arg1);

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4

; 7185 :         return(1);

	mov	eax, 1
	pop	edi
	pop	ebx
	pop	esi

; 7238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathEq:

; 7186 :     }
; 7187 : 
; 7188 :     /*
; 7189 :      *If either argument is a nodeset, it's a 'special case'
; 7190 :      */
; 7191 :     if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
; 7192 :       (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1
	je	SHORT $LN12@xmlXPathEq
	cmp	eax, 9
	je	SHORT $LN12@xmlXPathEq
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, 1
	je	SHORT $LN12@xmlXPathEq
	cmp	ecx, 9
	je	SHORT $LN12@xmlXPathEq

; 7235 :     }
; 7236 : 
; 7237 :     return (xmlXPathEqualValuesCommon(ctxt, arg1, arg2));

	push	ebx
	push	edi
	push	esi
	call	_xmlXPathEqualValuesCommon
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 7238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathEq:

; 7193 : 	/*
; 7194 : 	 *Hack it to assure arg1 is the nodeset
; 7195 : 	 */
; 7196 : 	if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, 1
	je	SHORT $LN13@xmlXPathEq
	cmp	ecx, 9
	je	SHORT $LN13@xmlXPathEq

; 7197 : 		argtmp = arg2;

	mov	eax, ebx

; 7198 : 		arg2 = arg1;

	mov	ebx, edi

; 7199 : 		arg1 = argtmp;

	mov	edi, eax
	mov	eax, ecx
$LN13@xmlXPathEq:

; 7200 : 	}
; 7201 : 	switch (arg2->type) {

	dec	eax
	cmp	eax, 8
	ja	$LN2@xmlXPathEq
	jmp	DWORD PTR $LN28@xmlXPathEq[eax*4]
$LN15@xmlXPathEq:

; 7202 : 	    case XPATH_UNDEFINED:
; 7203 : #ifdef DEBUG_EXPR
; 7204 : 		xmlGenericError(xmlGenericErrorContext,
; 7205 : 			"Equal: undefined\n");
; 7206 : #endif
; 7207 : 		break;
; 7208 : 	    case XPATH_NODESET:
; 7209 : 	    case XPATH_XSLT_TREE:
; 7210 : 		ret = xmlXPathEqualNodeSets(arg1, arg2, 0);

	push	0
	push	ebx
	push	edi
	call	_xmlXPathEqualNodeSets
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], eax

; 7211 : 		break;

	jmp	$LN2@xmlXPathEq
$LN16@xmlXPathEq:

; 7212 : 	    case XPATH_BOOLEAN:
; 7213 : 		if ((arg1->nodesetval == NULL) ||

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN19@xmlXPathEq
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN19@xmlXPathEq

; 7214 : 		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
; 7215 : 		else
; 7216 : 		    ret = 1;
; 7217 : 		ret = (ret == arg2->boolval);

	xor	eax, eax
	mov	ecx, 1
	cmp	ecx, DWORD PTR [ebx+8]
	sete	al
	mov	DWORD PTR _ret$2$[ebp], eax

; 7218 : 		break;

	jmp	SHORT $LN2@xmlXPathEq
$LN19@xmlXPathEq:

; 7214 : 		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
; 7215 : 		else
; 7216 : 		    ret = 1;
; 7217 : 		ret = (ret == arg2->boolval);

	xor	eax, eax
	xor	ecx, ecx
	cmp	ecx, DWORD PTR [ebx+8]
	sete	al
	mov	DWORD PTR _ret$2$[ebp], eax

; 7218 : 		break;

	jmp	SHORT $LN2@xmlXPathEq
$LN20@xmlXPathEq:

; 7219 : 	    case XPATH_NUMBER:
; 7220 : 		ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);

	movsd	xmm0, QWORD PTR [ebx+16]
	push	0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	esi
	call	_xmlXPathEqualNodeSetFloat
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$2$[ebp], eax

; 7221 : 		break;

	jmp	SHORT $LN2@xmlXPathEq
$LN21@xmlXPathEq:

; 7222 : 	    case XPATH_STRING:
; 7223 : 		ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval, 0);

	push	0
	push	DWORD PTR [ebx+24]
	push	edi
	call	_xmlXPathEqualNodeSetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$2$[ebp], eax

; 7224 : 		break;

	jmp	SHORT $LN2@xmlXPathEq
$LN22@xmlXPathEq:

; 7225 : 	    case XPATH_USERS:
; 7226 : 	    case XPATH_POINT:
; 7227 : 	    case XPATH_RANGE:
; 7228 : 	    case XPATH_LOCATIONSET:
; 7229 : 		TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	7229					; 00001c3dH
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _ctxt$[ebp]
	add	esp, 16					; 00000010H
$LN2@xmlXPathEq:

; 7230 : 		break;
; 7231 : 	}
; 7232 : 	xmlXPathReleaseObject(ctxt->context, arg1);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7233 : 	xmlXPathReleaseObject(ctxt->context, arg2);

	push	ebx
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject

; 7234 : 	return(ret);

	mov	eax, DWORD PTR _ret$2$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 7238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathEq:

; 7172 : 	if (arg1 != NULL)

	test	edi, edi
$LN26@xmlXPathEq:

; 7173 : 	    xmlXPathReleaseObject(ctxt->context, arg1);
; 7174 : 	else
; 7175 : 	    xmlXPathReleaseObject(ctxt->context, arg2);
; 7176 : 	XP_ERROR0(XPATH_INVALID_OPERAND);

	mov	eax, DWORD PTR [esi+12]
	cmovne	ebx, edi
	push	ebx
	push	eax
	call	_xmlXPathReleaseObject
	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 7238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathEq:

; 7165 :     xmlXPathObjectPtr arg1, arg2, argtmp;
; 7166 :     int ret = 0;
; 7167 : 
; 7168 :     if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);

	xor	eax, eax
	pop	esi

; 7238 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN28@xmlXPathEq:
	DD	$LN15@xmlXPathEq
	DD	$LN16@xmlXPathEq
	DD	$LN20@xmlXPathEq
	DD	$LN21@xmlXPathEq
	DD	$LN22@xmlXPathEq
	DD	$LN22@xmlXPathEq
	DD	$LN22@xmlXPathEq
	DD	$LN22@xmlXPathEq
	DD	$LN15@xmlXPathEq
_xmlXPathEqualValues ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathWrapExternal
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathWrapExternal PROC				; COMDAT

; 5376 : xmlXPathWrapExternal (void *val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlXPathWr

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BG@ENIHPAML@creating?5user?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BG@ENIHPAML@creating?5user?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5377 :     xmlXPathObjectPtr ret;
; 5378 : 
; 5379 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5380 :     if (ret == NULL) {
; 5381 :         xmlXPathErrMemory(NULL, "creating user object\n");
; 5382 : 	return(NULL);

	xor	eax, eax

; 5387 : #ifdef XP_DEBUG_OBJ_USAGE
; 5388 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_USERS);
; 5389 : #endif
; 5390 :     return(ret);
; 5391 : }

	pop	ebp
	ret	0
$LN2@xmlXPathWr:

; 5383 :     }
; 5384 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
; 5385 :     ret->type = XPATH_USERS;
; 5386 :     ret->user = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax], 8
	mov	DWORD PTR [eax+28], ecx

; 5387 : #ifdef XP_DEBUG_OBJ_USAGE
; 5388 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_USERS);
; 5389 : #endif
; 5390 :     return(ret);
; 5391 : }

	pop	ebp
	ret	0
_xmlXPathWrapExternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathWrapNodeSet
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathWrapNodeSet PROC				; COMDAT

; 4427 : xmlXPathWrapNodeSet(xmlNodeSetPtr val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlXPathWr

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BK@DGDFHNNJ@creating?5node?5set?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BK@DGDFHNNJ@creating?5node?5set?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4428 :     xmlXPathObjectPtr ret;
; 4429 : 
; 4430 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 4431 :     if (ret == NULL) {
; 4432 :         xmlXPathErrMemory(NULL, "creating node set object\n");
; 4433 : 	return(NULL);

	xor	eax, eax

; 4438 : #ifdef XP_DEBUG_OBJ_USAGE
; 4439 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
; 4440 : #endif
; 4441 :     return(ret);
; 4442 : }

	pop	ebp
	ret	0
$LN2@xmlXPathWr:

; 4434 :     }
; 4435 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
; 4436 :     ret->type = XPATH_NODESET;
; 4437 :     ret->nodesetval = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+4], ecx

; 4438 : #ifdef XP_DEBUG_OBJ_USAGE
; 4439 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
; 4440 : #endif
; 4441 :     return(ret);
; 4442 : }

	pop	ebp
	ret	0
_xmlXPathWrapNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewNodeSetList
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewNodeSetList PROC				; COMDAT

; 4397 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	jne	SHORT $LN5@xmlXPathNe

; 4411 : 	    }
; 4412 : 	}
; 4413 :     }
; 4414 : 
; 4415 :     return (ret);

	xor	eax, eax
	pop	edi

; 4416 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNe:

; 4398 :     xmlXPathObjectPtr ret;
; 4399 :     int i;
; 4400 : 
; 4401 :     if (val == NULL)
; 4402 :         ret = NULL;
; 4403 :     else if (val->nodeTab == NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN7@xmlXPathNe
	pop	edi

; 4404 :         ret = xmlXPathNewNodeSet(NULL);

	mov	DWORD PTR _val$[ebp], eax

; 4416 : }

	pop	ebp

; 4404 :         ret = xmlXPathNewNodeSet(NULL);

	jmp	_xmlXPathNewNodeSet
$LN7@xmlXPathNe:
	push	ebx

; 4405 :     else {
; 4406 :         ret = xmlXPathNewNodeSet(val->nodeTab[0]);

	push	DWORD PTR [eax]
	call	_xmlXPathNewNodeSet
	mov	ebx, eax
	add	esp, 4

; 4407 :         if (ret) {

	test	ebx, ebx
	je	SHORT $LN20@xmlXPathNe

; 4408 :             for (i = 1; i < val->nodeNr; ++i) {

	push	esi
	mov	esi, 1
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN21@xmlXPathNe
$LL4@xmlXPathNe:

; 4409 :                 if (xmlXPathNodeSetAddUnique(ret->nodesetval, val->nodeTab[i])
; 4410 : 		    < 0) break;

	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [eax+esi*4]
	push	DWORD PTR [ebx+4]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	SHORT $LN17@xmlXPathNe

; 4408 :             for (i = 1; i < val->nodeNr; ++i) {

	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@xmlXPathNe
$LN17@xmlXPathNe:

; 4411 : 	    }
; 4412 : 	}
; 4413 :     }
; 4414 : 
; 4415 :     return (ret);

	mov	eax, ebx
$LN21@xmlXPathNe:
	pop	esi
$LN20@xmlXPathNe:
	pop	ebx
	pop	edi

; 4416 : }

	pop	ebp
	ret	0
_xmlXPathNewNodeSetList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetRemove
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathNodeSetRemove PROC				; COMDAT

; 4157 : xmlXPathNodeSetRemove(xmlNodeSetPtr cur, int val) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlXPathNo

; 4158 :     if (cur == NULL) return;
; 4159 :     if (val >= cur->nodeNr) return;

	mov	eax, DWORD PTR [edi]
	push	esi
	mov	esi, DWORD PTR _val$[ebp]
	cmp	esi, eax
	jge	SHORT $LN13@xmlXPathNo

; 4160 :     if ((cur->nodeTab[val] != NULL) &&

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [ecx+esi*4]
	test	edx, edx
	je	SHORT $LN7@xmlXPathNo
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN7@xmlXPathNo

; 4161 : 	(cur->nodeTab[val]->type == XML_NAMESPACE_DECL))
; 4162 : 	xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[val]);

	push	edx
	call	_xmlXPathNodeSetFreeNs
	mov	eax, DWORD PTR [edi]
	add	esp, 4
	mov	ecx, DWORD PTR [edi+8]
$LN7@xmlXPathNo:

; 4163 :     cur->nodeNr--;

	dec	eax
	mov	DWORD PTR [edi], eax

; 4164 :     for (;val < cur->nodeNr;val++)

	cmp	esi, eax
	jge	SHORT $LN3@xmlXPathNo
$LL4@xmlXPathNo:

; 4165 :         cur->nodeTab[val] = cur->nodeTab[val + 1];

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax+esi*4]
	inc	esi
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi]
	cmp	esi, eax
	jl	SHORT $LL4@xmlXPathNo
	mov	ecx, DWORD PTR [edi+8]
$LN3@xmlXPathNo:

; 4166 :     cur->nodeTab[cur->nodeNr] = NULL;

	mov	DWORD PTR [ecx+eax*4], 0
$LN13@xmlXPathNo:
	pop	esi
$LN1@xmlXPathNo:
	pop	edi

; 4167 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetRemove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetDel
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathNodeSetDel PROC				; COMDAT

; 4120 : xmlXPathNodeSetDel(xmlNodeSetPtr cur, xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlXPathNo

; 4121 :     int i;
; 4122 : 
; 4123 :     if (cur == NULL) return;
; 4124 :     if (val == NULL) return;

	push	ebx
	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	SHORT $LN23@xmlXPathNo

; 4125 : 
; 4126 :     /*
; 4127 :      * find node in nodeTab
; 4128 :      */
; 4129 :     for (i = 0;i < cur->nodeNr;i++)

	mov	ecx, DWORD PTR [edi]
	push	esi
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN24@xmlXPathNo

; 4130 :         if (cur->nodeTab[i] == val) break;

	mov	edx, DWORD PTR [edi+8]
	mov	eax, edx
	npad	5
$LL4@xmlXPathNo:
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN16@xmlXPathNo

; 4125 : 
; 4126 :     /*
; 4127 :      * find node in nodeTab
; 4128 :      */
; 4129 :     for (i = 0;i < cur->nodeNr;i++)

	inc	esi
	add	eax, 4
	cmp	esi, ecx
	jl	SHORT $LL4@xmlXPathNo
	pop	esi
	pop	ebx
	pop	edi

; 4147 : }

	pop	ebp
	ret	0
$LN16@xmlXPathNo:

; 4131 : 
; 4132 :     if (i >= cur->nodeNr) {	/* not found */

	cmp	esi, ecx
	jge	SHORT $LN24@xmlXPathNo

; 4133 : #ifdef DEBUG
; 4134 :         xmlGenericError(xmlGenericErrorContext,
; 4135 : 	        "xmlXPathNodeSetDel: Node %s wasn't found in NodeList\n",
; 4136 : 		val->name);
; 4137 : #endif
; 4138 :         return;
; 4139 :     }
; 4140 :     if ((cur->nodeTab[i] != NULL) &&

	mov	eax, DWORD PTR [edx+esi*4]
	test	eax, eax
	je	SHORT $LN12@xmlXPathNo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN12@xmlXPathNo

; 4141 : 	(cur->nodeTab[i]->type == XML_NAMESPACE_DECL))
; 4142 : 	xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[i]);

	push	eax
	call	_xmlXPathNodeSetFreeNs
	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	edx, DWORD PTR [edi+8]
$LN12@xmlXPathNo:

; 4143 :     cur->nodeNr--;

	dec	ecx
	mov	DWORD PTR [edi], ecx

; 4144 :     for (;i < cur->nodeNr;i++)

	cmp	esi, ecx
	jge	SHORT $LN6@xmlXPathNo
$LL7@xmlXPathNo:

; 4145 :         cur->nodeTab[i] = cur->nodeTab[i + 1];

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax+esi*4]
	inc	esi
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ecx
	jl	SHORT $LL7@xmlXPathNo
	mov	edx, DWORD PTR [edi+8]
$LN6@xmlXPathNo:

; 4146 :     cur->nodeTab[cur->nodeNr] = NULL;

	mov	DWORD PTR [edx+ecx*4], 0
$LN24@xmlXPathNo:
	pop	esi
$LN23@xmlXPathNo:
	pop	ebx
$LN1@xmlXPathNo:
	pop	edi

; 4147 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetDel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetMerge
_TEXT	SEGMENT
_initNr$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_val1$ = 8						; size = 4
_val2$ = 12						; size = 4
_xmlXPathNodeSetMerge PROC				; COMDAT

; 3817 : xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val2$[ebp]
	test	edi, edi
	jne	SHORT $LN8@xmlXPathNo

; 3818 :     int i, j, initNr, skip;
; 3819 :     xmlNodePtr n1, n2;
; 3820 : 
; 3821 :     if (val2 == NULL) return(val1);

	mov	eax, DWORD PTR _val1$[ebp]
	pop	edi

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathNo:
	push	esi

; 3822 :     if (val1 == NULL) {

	mov	esi, DWORD PTR _val1$[ebp]
	test	esi, esi
	jne	SHORT $LN10@xmlXPathNo

; 3823 : 	val1 = xmlXPathNodeSetCreate(NULL);

	push	esi
	call	_xmlXPathNodeSetCreate
	mov	esi, eax
	add	esp, 4

; 3824 :     if (val1 == NULL)

	test	esi, esi
	jne	SHORT $LN10@xmlXPathNo
	pop	esi
	pop	edi

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathNo:

; 3825 :         return (NULL);
; 3826 : #if 0
; 3827 : 	/*
; 3828 : 	* TODO: The optimization won't work in every case, since
; 3829 : 	*  those nasty namespace nodes need to be added with
; 3830 : 	*  xmlXPathNodeSetDupNs() to the set; thus a pure
; 3831 : 	*  memcpy is not possible.
; 3832 : 	*  If there was a flag on the nodesetval, indicating that
; 3833 : 	*  some temporary nodes are in, that would be helpfull.
; 3834 : 	*/
; 3835 : 	/*
; 3836 : 	* Optimization: Create an equally sized node-set
; 3837 : 	* and memcpy the content.
; 3838 : 	*/
; 3839 : 	val1 = xmlXPathNodeSetCreateSize(val2->nodeNr);
; 3840 : 	if (val1 == NULL)
; 3841 : 	    return(NULL);
; 3842 : 	if (val2->nodeNr != 0) {
; 3843 : 	    if (val2->nodeNr == 1)
; 3844 : 		*(val1->nodeTab) = *(val2->nodeTab);
; 3845 : 	    else {
; 3846 : 		memcpy(val1->nodeTab, val2->nodeTab,
; 3847 : 		    val2->nodeNr * sizeof(xmlNodePtr));
; 3848 : 	    }
; 3849 : 	    val1->nodeNr = val2->nodeNr;
; 3850 : 	}
; 3851 : 	return(val1);
; 3852 : #endif
; 3853 :     }
; 3854 : 
; 3855 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3856 :     initNr = val1->nodeNr;

	mov	ecx, DWORD PTR [esi]
	push	ebx

; 3857 : 
; 3858 :     for (i = 0;i < val2->nodeNr;i++) {

	xor	ebx, ebx
	mov	DWORD PTR _initNr$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	DWORD PTR [edi], ebx
	jle	$LN66@xmlXPathNo
$LL4@xmlXPathNo:

; 3859 : 	n2 = val2->nodeTab[i];

	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR [eax+ebx*4]

; 3860 : 	/*
; 3861 : 	 * check against duplicates
; 3862 : 	 */
; 3863 : 	skip = 0;
; 3864 : 	for (j = 0; j < initNr; j++) {

	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN65@xmlXPathNo
	npad	4
$LL7@xmlXPathNo:

; 3865 : 	    n1 = val1->nodeTab[j];

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 3866 : 	    if (n1 == n2) {

	cmp	ecx, edi
	je	$LN2@xmlXPathNo

; 3867 : 		skip = 1;
; 3868 : 		break;
; 3869 : 	    } else if ((n1->type == XML_NAMESPACE_DECL) &&

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPathNo
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPathNo

; 3870 : 		       (n2->type == XML_NAMESPACE_DECL)) {
; 3871 : 		if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN5@xmlXPathNo
	push	DWORD PTR [edi+12]
	push	DWORD PTR [ecx+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN2@xmlXPathNo
$LN5@xmlXPathNo:

; 3860 : 	/*
; 3861 : 	 * check against duplicates
; 3862 : 	 */
; 3863 : 	skip = 0;
; 3864 : 	for (j = 0; j < initNr; j++) {

	inc	ebx
	cmp	ebx, DWORD PTR _initNr$1$[ebp]
	jl	SHORT $LL7@xmlXPathNo
$LN65@xmlXPathNo:

; 3872 : 		    (xmlStrEqual(((xmlNsPtr) n1)->prefix,
; 3873 : 			((xmlNsPtr) n2)->prefix)))
; 3874 : 		{
; 3875 : 		    skip = 1;
; 3876 : 		    break;
; 3877 : 		}
; 3878 : 	    }
; 3879 : 	}
; 3880 : 	if (skip)
; 3881 : 	    continue;
; 3882 : 
; 3883 : 	/*
; 3884 : 	 * grow the nodeTab if needed
; 3885 : 	 */
; 3886 : 	if (val1->nodeMax == 0) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN16@xmlXPathNo

; 3887 : 	    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3888 : 						    sizeof(xmlNodePtr));
; 3889 : 	    if (val1->nodeTab == NULL) {

	test	eax, eax
	je	$LN58@xmlXPathNo

; 3890 : 	        xmlXPathErrMemory(NULL, "merging nodeset\n");
; 3891 : 		return(NULL);
; 3892 : 	    }
; 3893 : 	    memset(val1->nodeTab, 0 ,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3894 : 		   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 3895 : 	    val1->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	SHORT $LN19@xmlXPathNo
$LN16@xmlXPathNo:

; 3896 : 	} else if (val1->nodeNr == val1->nodeMax) {

	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN19@xmlXPathNo

; 3897 : 	    xmlNodePtr *temp;
; 3898 : 
; 3899 :             if (val1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jge	$LN57@xmlXPathNo

; 3902 :             }
; 3903 : 	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3904 : 					     sizeof(xmlNodePtr));
; 3905 : 	    if (temp == NULL) {

	test	eax, eax
	je	SHORT $LN58@xmlXPathNo

; 3908 : 	    }
; 3909 : 	    val1->nodeTab = temp;

	mov	DWORD PTR [esi+8], eax

; 3910 : 	    val1->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	DWORD PTR [esi+4], eax
$LN19@xmlXPathNo:

; 3911 : 	}
; 3912 : 	if (n2->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN22@xmlXPathNo

; 3913 : 	    xmlNsPtr ns = (xmlNsPtr) n2;
; 3914 : 
; 3915 : 	    val1->nodeTab[val1->nodeNr++] =

	push	edi
	push	DWORD PTR [edi]
	call	_xmlXPathNodeSetDupNs
	mov	edx, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+edx*4], eax

; 3916 : 		xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
; 3917 : 	} else

	jmp	SHORT $LN69@xmlXPathNo
$LN22@xmlXPathNo:

; 3918 : 	    val1->nodeTab[val1->nodeNr++] = n2;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi
$LN69@xmlXPathNo:

; 3857 : 
; 3858 :     for (i = 0;i < val2->nodeNr;i++) {

	inc	DWORD PTR [esi]
$LN2@xmlXPathNo:
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	edi, DWORD PTR _val2$[ebp]
	inc	ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, DWORD PTR [edi]
	jge	$LN66@xmlXPathNo
	mov	ecx, DWORD PTR _initNr$1$[ebp]
	jmp	$LL4@xmlXPathNo
$LN58@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@IMBJKAMG@merging?5nodeset?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3906 : 	        xmlXPathErrMemory(NULL, "merging nodeset\n");
; 3907 : 		return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@DBOLJGCN@merging?5nodeset?5hit?5limit?6@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3900 :                 xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
; 3901 :                 return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi
	pop	edi

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@xmlXPathNo:
	pop	ebx

; 3919 :     }
; 3920 : 
; 3921 :     return(val1);

	mov	eax, esi
	pop	esi
	pop	edi

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathNodeSetMerge ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterAllFunctions
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathRegisterAllFunctions PROC			; COMDAT

; 15069: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 4870 :     if (ctxt == NULL)

	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN246@xmlXPathRe

; 4871 : 	return(-1);
; 4872 :     if (name == NULL)
; 4873 : 	return(-1);
; 4874 : 
; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN254@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN5@xmlXPathRe
$LN254@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathBooleanFunction
	push	0
	push	OFFSET ??_C@_07GOBOHMJA@boolean@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN5@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN256@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN14@xmlXPathRe
$LN256@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathCeilingFunction
	push	0
	push	OFFSET ??_C@_07EANFIDJB@ceiling@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN14@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN258@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN23@xmlXPathRe
$LN258@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathCountFunction
	push	0
	push	OFFSET ??_C@_05IOMEMJEC@count@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN23@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN260@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN32@xmlXPathRe
$LN260@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathConcatFunction
	push	0
	push	OFFSET ??_C@_06CMLIEHFC@concat@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN32@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN262@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN41@xmlXPathRe
$LN262@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathContainsFunction
	push	0
	push	OFFSET ??_C@_08JKMOLGCD@contains@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN41@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN264@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN50@xmlXPathRe
$LN264@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathIdFunction
	push	0
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN50@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN266@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN59@xmlXPathRe
$LN266@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathFalseFunction
	push	0
	push	OFFSET ??_C@_05LAPONLG@false@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN59@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN268@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN68@xmlXPathRe
$LN268@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathFloorFunction
	push	0
	push	OFFSET ??_C@_05PBJFFIGL@floor@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN68@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN270@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN77@xmlXPathRe
$LN270@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathLastFunction
	push	0
	push	OFFSET ??_C@_04PLGBGIDD@last@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN77@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN272@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN86@xmlXPathRe
$LN272@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathLangFunction
	push	0
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN86@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN274@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN95@xmlXPathRe
$LN274@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathLocalNameFunction
	push	0
	push	OFFSET ??_C@_0L@JNMMKGPH@local?9name@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN95@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN276@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN104@xmlXPathRe
$LN276@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathNotFunction
	push	0
	push	OFFSET ??_C@_03NJKJADM@not@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN104@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN278@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN113@xmlXPathRe
$LN278@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathNameFunction
	push	0
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN113@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN280@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN122@xmlXPathRe
$LN280@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathNamespaceURIFunction
	push	0
	push	OFFSET ??_C@_0O@LIBIEKOH@namespace?9uri@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN122@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN282@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN131@xmlXPathRe
$LN282@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathNormalizeFunction
	push	0
	push	OFFSET ??_C@_0BA@GMCNNFIH@normalize?9space@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN131@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN284@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN140@xmlXPathRe
$LN284@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathNumberFunction
	push	0
	push	OFFSET ??_C@_06EBGNBFIA@number@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN140@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN286@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN149@xmlXPathRe
$LN286@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathPositionFunction
	push	0
	push	OFFSET ??_C@_08OAGMDKAF@position@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN149@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN288@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN158@xmlXPathRe
$LN288@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathRoundFunction
	push	0
	push	OFFSET ??_C@_05MIMAKCN@round@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN158@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN290@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN167@xmlXPathRe
$LN290@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathStringFunction
	push	0
	push	OFFSET ??_C@_06ICGJLFIM@string@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN167@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN292@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN176@xmlXPathRe
$LN292@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathStringLengthFunction
	push	0
	push	OFFSET ??_C@_0O@NOLAIBIG@string?9length@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN176@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN294@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN185@xmlXPathRe
$LN294@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathStartsWithFunction
	push	0
	push	OFFSET ??_C@_0M@MENNCJLJ@starts?9with@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN185@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN296@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN194@xmlXPathRe
$LN296@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathSubstringFunction
	push	0
	push	OFFSET ??_C@_09MJALBNED@substring@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN194@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN298@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN203@xmlXPathRe
$LN298@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathSubstringBeforeFunction
	push	0
	push	OFFSET ??_C@_0BB@KKJFBMPK@substring?9before@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN203@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN300@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN212@xmlXPathRe
$LN300@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathSubstringAfterFunction
	push	0
	push	OFFSET ??_C@_0BA@JEDLCCAF@substring?9after@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN212@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN302@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN221@xmlXPathRe
$LN302@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathSumFunction
	push	0
	push	OFFSET ??_C@_03CFFIJAMA@sum@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN221@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN304@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN230@xmlXPathRe
$LN304@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathTrueFunction
	push	0
	push	OFFSET ??_C@_04LOAJBDKD@true@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN230@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN306@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN239@xmlXPathRe
$LN306@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathTranslateFunction
	push	0
	push	OFFSET ??_C@_09ODNGOEIO@translate@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN239@xmlXPathRe:

; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN308@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN246@xmlXPathRe
$LN308@xmlXPathRe:

; 4878 : 	return(-1);
; 4879 :     if (f == NULL)
; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	OFFSET _xmlXPathEscapeUriFunction
	push	OFFSET ??_C@_0CL@DABLMGPH@http?3?1?1www?4w3?4org?12002?108?1xquer@
	push	OFFSET ??_C@_0L@ODIBMOLP@escape?9uri@
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
$LN246@xmlXPathRe:
	pop	esi

; 15070:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"boolean",
; 15071:                          xmlXPathBooleanFunction);
; 15072:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"ceiling",
; 15073:                          xmlXPathCeilingFunction);
; 15074:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"count",
; 15075:                          xmlXPathCountFunction);
; 15076:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"concat",
; 15077:                          xmlXPathConcatFunction);
; 15078:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"contains",
; 15079:                          xmlXPathContainsFunction);
; 15080:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"id",
; 15081:                          xmlXPathIdFunction);
; 15082:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"false",
; 15083:                          xmlXPathFalseFunction);
; 15084:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"floor",
; 15085:                          xmlXPathFloorFunction);
; 15086:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"last",
; 15087:                          xmlXPathLastFunction);
; 15088:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"lang",
; 15089:                          xmlXPathLangFunction);
; 15090:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"local-name",
; 15091:                          xmlXPathLocalNameFunction);
; 15092:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"not",
; 15093:                          xmlXPathNotFunction);
; 15094:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"name",
; 15095:                          xmlXPathNameFunction);
; 15096:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"namespace-uri",
; 15097:                          xmlXPathNamespaceURIFunction);
; 15098:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"normalize-space",
; 15099:                          xmlXPathNormalizeFunction);
; 15100:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"number",
; 15101:                          xmlXPathNumberFunction);
; 15102:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"position",
; 15103:                          xmlXPathPositionFunction);
; 15104:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"round",
; 15105:                          xmlXPathRoundFunction);
; 15106:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string",
; 15107:                          xmlXPathStringFunction);
; 15108:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string-length",
; 15109:                          xmlXPathStringLengthFunction);
; 15110:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"starts-with",
; 15111:                          xmlXPathStartsWithFunction);
; 15112:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring",
; 15113:                          xmlXPathSubstringFunction);
; 15114:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-before",
; 15115:                          xmlXPathSubstringBeforeFunction);
; 15116:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-after",
; 15117:                          xmlXPathSubstringAfterFunction);
; 15118:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"sum",
; 15119:                          xmlXPathSumFunction);
; 15120:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"true",
; 15121:                          xmlXPathTrueFunction);
; 15122:     xmlXPathRegisterFunc(ctxt, (const xmlChar *)"translate",
; 15123:                          xmlXPathTranslateFunction);
; 15124: 
; 15125:     xmlXPathRegisterFuncNS(ctxt, (const xmlChar *)"escape-uri",
; 15126: 	 (const xmlChar *)"http://www.w3.org/2002/08/xquery-functions",
; 15127:                          xmlXPathEscapeUriFunction);
; 15128: }

	pop	ebp
	ret	0
_xmlXPathRegisterAllFunctions ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEvaluatePredicateResult
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_res$ = 12						; size = 4
_xmlXPathEvaluatePredicateResult PROC			; COMDAT

; 14439:                                 xmlXPathObjectPtr res) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	$LN5@xmlXPathEv

; 14440:     if ((ctxt == NULL) || (res == NULL)) return(0);

	mov	edx, DWORD PTR _res$[ebp]
	test	edx, edx
	je	$LN5@xmlXPathEv

; 14441:     switch (res->type) {

	mov	ecx, DWORD PTR [edx]
	dec	ecx
	cmp	ecx, 8
	ja	SHORT $LN13@xmlXPathEv
	jmp	DWORD PTR $LN21@xmlXPathEv[ecx*4]
$LN6@xmlXPathEv:

; 14442:         case XPATH_BOOLEAN:
; 14443: 	    return(res->boolval);

	mov	eax, DWORD PTR [edx+8]

; 14470: }

	pop	ebp
	ret	0
$LN7@xmlXPathEv:

; 14444:         case XPATH_NUMBER:
; 14445: #if defined(__BORLANDC__) || (defined(_MSC_VER) && (_MSC_VER == 1200))
; 14446: 	    return((res->floatval == ctxt->context->proximityPosition) &&
; 14447: 	           (!xmlXPathIsNaN(res->floatval))); /* MSC pbm Mark Vakoc !*/
; 14448: #else
; 14449: 	    return(res->floatval == ctxt->context->proximityPosition);

	mov	eax, DWORD PTR [eax+12]
	movsd	xmm0, QWORD PTR [edx+16]
	movd	xmm1, DWORD PTR [eax+72]
	cvtdq2pd xmm1, xmm1
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@xmlXPathEv
	mov	eax, 1

; 14470: }

	pop	ebp
	ret	0
$LN8@xmlXPathEv:

; 14450: #endif
; 14451:         case XPATH_NODESET:
; 14452:         case XPATH_XSLT_TREE:
; 14453: 	    if (res->nodesetval == NULL)

	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathEv

; 14454: 		return(0);
; 14455: 	    return(res->nodesetval->nodeNr != 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 14470: }

	pop	ebp
	ret	0
$LN10@xmlXPathEv:

; 14456:         case XPATH_STRING:
; 14457: 	    return((res->stringval != NULL) && (res->stringval[0] != 0));

	mov	eax, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN5@xmlXPathEv
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@xmlXPathEv
	mov	eax, 1

; 14470: }

	pop	ebp
	ret	0
$LN11@xmlXPathEv:

; 14458: #ifdef LIBXML_XPTR_ENABLED
; 14459: 	case XPATH_LOCATIONSET:{
; 14460: 	    xmlLocationSetPtr ptr = res->user;

	mov	ecx, DWORD PTR [edx+28]

; 14461: 	    if (ptr == NULL)

	test	ecx, ecx
	je	SHORT $LN5@xmlXPathEv

; 14462: 	        return(0);
; 14463: 	    return (ptr->locNr != 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 14470: }

	pop	ebp
	ret	0
$LN13@xmlXPathEv:
	push	esi

; 14464: 	    }
; 14465: #endif
; 14466:         default:
; 14467: 	    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	14467					; 00003883H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 14468:     }
; 14469:     return(0);

	pop	esi
$LN5@xmlXPathEv:

; 14470: }

	xor	eax, eax
	pop	ebp
	ret	0
	npad	2
$LN21@xmlXPathEv:
	DD	$LN8@xmlXPathEv
	DD	$LN6@xmlXPathEv
	DD	$LN7@xmlXPathEv
	DD	$LN10@xmlXPathEv
	DD	$LN13@xmlXPathEv
	DD	$LN13@xmlXPathEv
	DD	$LN11@xmlXPathEv
	DD	$LN13@xmlXPathEv
	DD	$LN8@xmlXPathEv
_xmlXPathEvaluatePredicateResult ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathStringEvalNumber
_TEXT	SEGMENT
tv733 = -28						; size = 8
_fraction$1$ = -28					; size = 8
_ret$1$ = -20						; size = 8
_is_exponent_negative$1$ = -12				; size = 4
_isneg$1$ = -8						; size = 4
_max$1$ = -4						; size = 4
_ok$1$ = -4						; size = 4
_str$ = 8						; size = 4
$T1 = 11						; size = 1
_xmlXPathStringEvalNumber PROC				; COMDAT

; 10044: xmlXPathStringEvalNumber(const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _str$[ebp]
	xor	edi, edi
	mov	DWORD PTR _ok$1$[ebp], 0
	mov	DWORD PTR _isneg$1$[ebp], 0
	mov	DWORD PTR _is_exponent_negative$1$[ebp], edi
	test	edx, edx
	jne	SHORT $LL2@xmlXPathSt

; 10045:     const xmlChar *cur = str;
; 10046:     double ret;
; 10047:     int ok = 0;
; 10048:     int isneg = 0;
; 10049:     int exponent = 0;
; 10050:     int is_exponent_negative = 0;
; 10051: #ifdef __GNUC__
; 10052:     unsigned long tmp = 0;
; 10053:     double temp;
; 10054: #endif
; 10055:     if (cur == NULL) return(0);

	fldz
	pop	edi

; 10132: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LL2@xmlXPathSt:

; 10056:     while (IS_BLANK_CH(*cur)) cur++;

	mov	cl, BYTE PTR [edx]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN17@xmlXPathSt
	cmp	cl, 9
	jb	SHORT $LN18@xmlXPathSt
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN17@xmlXPathSt
$LN18@xmlXPathSt:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPathSt
$LN17@xmlXPathSt:
	inc	edx
	jmp	SHORT $LL2@xmlXPathSt
$LN3@xmlXPathSt:
	push	esi

; 10057:     if ((*cur != '.') && ((*cur < '0') || (*cur > '9')) && (*cur != '-')) {

	cmp	cl, 46					; 0000002eH
	je	SHORT $LN19@xmlXPathSt
	cmp	cl, 48					; 00000030H
	jb	SHORT $LN20@xmlXPathSt
	cmp	cl, 57					; 00000039H
	jbe	SHORT $LN19@xmlXPathSt
$LN20@xmlXPathSt:
	cmp	cl, 45					; 0000002dH
	jne	$LN86@xmlXPathSt
$LN19@xmlXPathSt:

; 10058:         return(NAN);
; 10059:     }
; 10060:     if (*cur == '-') {

	mov	al, cl
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN21@xmlXPathSt

; 10061: 	isneg = 1;
; 10062: 	cur++;

	mov	al, BYTE PTR [edx+1]
	mov	DWORD PTR _isneg$1$[ebp], 1
$LN21@xmlXPathSt:

; 10063:     }
; 10064: 
; 10065: #ifdef __GNUC__
; 10066:     /*
; 10067:      * tmp/temp is a workaround against a gcc compiler bug
; 10068:      * http://veillard.com/gcc.bug
; 10069:      */
; 10070:     ret = 0;
; 10071:     while ((*cur >= '0') && (*cur <= '9')) {
; 10072: 	ret = ret * 10;
; 10073: 	tmp = (*cur - '0');
; 10074: 	ok = 1;
; 10075: 	cur++;
; 10076: 	temp = (double) tmp;
; 10077: 	ret = ret + temp;
; 10078:     }
; 10079: #else
; 10080:     ret = 0;

	lea	esi, DWORD PTR [edx+1]
	xorps	xmm2, xmm2
	cmovne	esi, edx
	movsd	QWORD PTR _fraction$1$[ebp], xmm2
	xorps	xmm1, xmm1
	movsd	QWORD PTR _ret$1$[ebp], xmm1

; 10081:     while ((*cur >= '0') && (*cur <= '9')) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LN5@xmlXPathSt
	mov	cl, al
$LL4@xmlXPathSt:
	mov	al, cl
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN124@xmlXPathSt

; 10082: 	ret = ret * 10 + (*cur - '0');

	mulsd	xmm1, QWORD PTR __real@4024000000000000

; 10083: 	ok = 1;
; 10084: 	cur++;

	inc	esi
	movzx	eax, cl
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _ok$1$[ebp], 1
	movd	xmm0, eax
	mov	al, BYTE PTR [esi]
	mov	cl, al
	cvtdq2pd xmm0, xmm0
	addsd	xmm1, xmm0
	cmp	al, 48					; 00000030H
	jae	SHORT $LL4@xmlXPathSt
$LN124@xmlXPathSt:
	movsd	QWORD PTR _ret$1$[ebp], xmm1
$LN5@xmlXPathSt:

; 10085:     }
; 10086: #endif
; 10087: 
; 10088:     if (*cur == '.') {

	cmp	al, 46					; 0000002eH
	jne	$LN126@xmlXPathSt

; 10089: 	int v, frac = 0, max;
; 10090: 	double fraction = 0;
; 10091: 
; 10092:         cur++;
; 10093: 	if (((*cur < '0') || (*cur > '9')) && (!ok)) {

	mov	al, BYTE PTR [esi+1]
	inc	esi
	xor	ecx, ecx
	mov	BYTE PTR $T1[ebp], al
	cmp	al, 48					; 00000030H
	jb	SHORT $LN24@xmlXPathSt
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN40@xmlXPathSt
$LN24@xmlXPathSt:
	cmp	DWORD PTR _ok$1$[ebp], ecx
	je	$LN86@xmlXPathSt
$LN40@xmlXPathSt:

; 10094: 	    return(NAN);
; 10095: 	}
; 10096:         while (*cur == '0') {

	cmp	al, 48					; 00000030H
	jne	SHORT $LN7@xmlXPathSt
	npad	3
$LL6@xmlXPathSt:
	mov	al, BYTE PTR [esi+1]

; 10097: 	    frac = frac + 1;
; 10098: 	    cur++;

	inc	esi
	inc	ecx
	mov	BYTE PTR $T1[ebp], al
	cmp	al, 48					; 00000030H
	je	SHORT $LL6@xmlXPathSt
$LN7@xmlXPathSt:

; 10099:         }
; 10100:         max = frac + MAX_FRAC;
; 10101: 	while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {

	movsd	xmm1, QWORD PTR __real@4024000000000000
	lea	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _max$1$[ebp], edx
	cmp	al, 48					; 00000030H
	jb	SHORT $LN9@xmlXPathSt
	mov	edi, DWORD PTR _max$1$[ebp]
	mov	dl, al
$LL8@xmlXPathSt:
	mov	al, dl
	mov	BYTE PTR $T1[ebp], al
	cmp	dl, 57					; 00000039H
	ja	SHORT $LN125@xmlXPathSt
	mov	BYTE PTR $T1[ebp], al
	cmp	ecx, edi
	jge	SHORT $LN125@xmlXPathSt

; 10102: 	    v = (*cur - '0');

	movzx	eax, dl

; 10103: 	    fraction = fraction * 10 + v;
; 10104: 	    frac = frac + 1;
; 10105: 	    cur++;

	inc	esi
	sub	eax, 48					; 00000030H
	mulsd	xmm2, xmm1
	inc	ecx
	movd	xmm0, eax
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR $T1[ebp], al
	mov	dl, al
	cvtdq2pd xmm0, xmm0
	addsd	xmm2, xmm0
	cmp	al, 48					; 00000030H
	jae	SHORT $LL8@xmlXPathSt
$LN125@xmlXPathSt:
	movsd	QWORD PTR _fraction$1$[ebp], xmm2
	xor	edi, edi
$LN9@xmlXPathSt:

; 10106: 	}
; 10107: 	fraction /= pow(10.0, frac);

	movaps	xmm0, xmm1
	movd	xmm1, ecx
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR _fraction$1$[ebp]
	divsd	xmm1, xmm0

; 10108: 	ret = ret + fraction;
; 10109: 	while ((*cur >= '0') && (*cur <= '9'))

	mov	al, BYTE PTR $T1[ebp]
	addsd	xmm1, QWORD PTR _ret$1$[ebp]
	movsd	QWORD PTR _ret$1$[ebp], xmm1
	cmp	al, 48					; 00000030H
	jb	SHORT $LN126@xmlXPathSt
	mov	cl, al
	npad	6
$LL10@xmlXPathSt:
	mov	al, cl
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN126@xmlXPathSt
	mov	al, BYTE PTR [esi+1]

; 10110: 	    cur++;

	inc	esi
	mov	cl, al
	cmp	al, 48					; 00000030H
	jae	SHORT $LL10@xmlXPathSt
$LN126@xmlXPathSt:

; 10111:     }
; 10112:     if ((*cur == 'e') || (*cur == 'E')) {

	cmp	al, 101					; 00000065H
	je	SHORT $LN26@xmlXPathSt
	cmp	al, 69					; 00000045H
	jne	SHORT $LL14@xmlXPathSt
$LN26@xmlXPathSt:

; 10113:       cur++;
; 10114:       if (*cur == '-') {

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN27@xmlXPathSt

; 10115: 	is_exponent_negative = 1;

	mov	DWORD PTR _is_exponent_negative$1$[ebp], 1

; 10116: 	cur++;

	jmp	SHORT $LN136@xmlXPathSt
$LN27@xmlXPathSt:

; 10117:       } else if (*cur == '+') {

	cmp	al, 43					; 0000002bH
	jne	SHORT $LN43@xmlXPathSt
$LN136@xmlXPathSt:

; 10118:         cur++;
; 10119:       }
; 10120:       while ((*cur >= '0') && (*cur <= '9')) {

	mov	al, BYTE PTR [esi+1]
	inc	esi
$LN43@xmlXPathSt:
	cmp	al, 48					; 00000030H
	jb	SHORT $LL14@xmlXPathSt
$LL12@xmlXPathSt:
	cmp	al, 57					; 00000039H
	ja	SHORT $LL14@xmlXPathSt

; 10121:         if (exponent < 1000000)

	cmp	edi, 1000000				; 000f4240H
	jge	SHORT $LN78@xmlXPathSt

; 10122: 	  exponent = exponent * 10 + (*cur - '0');

	lea	edi, DWORD PTR [edi+edi*4]
	movzx	eax, al
	lea	edi, DWORD PTR [edi-24]
	lea	edi, DWORD PTR [eax+edi*2]
$LN78@xmlXPathSt:

; 10123: 	cur++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 48					; 00000030H
	jae	SHORT $LL12@xmlXPathSt
$LL14@xmlXPathSt:

; 10124:       }
; 10125:     }
; 10126:     while (IS_BLANK_CH(*cur)) cur++;

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN31@xmlXPathSt
	cmp	al, 9
	jb	SHORT $LN32@xmlXPathSt
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN31@xmlXPathSt
$LN32@xmlXPathSt:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN15@xmlXPathSt
$LN31@xmlXPathSt:
	inc	esi
	jmp	SHORT $LL14@xmlXPathSt
$LN15@xmlXPathSt:

; 10127:     if (*cur != 0) return(NAN);

	test	al, al
	je	SHORT $LN33@xmlXPathSt
$LN86@xmlXPathSt:
	fld	QWORD PTR __real@fff8000000000000
	pop	esi
	pop	edi

; 10132: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlXPathSt:

; 10128:     if (isneg) ret = -ret;

	cmp	DWORD PTR _isneg$1$[ebp], 0
	je	SHORT $LN34@xmlXPathSt
	xorps	xmm1, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _ret$1$[ebp], xmm1
$LN34@xmlXPathSt:

; 10129:     if (is_exponent_negative) exponent = -exponent;
; 10130:     ret *= pow(10.0, (double)exponent);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	mov	eax, edi
	neg	eax
	cmp	DWORD PTR _is_exponent_negative$1$[ebp], 0
	cmove	eax, edi
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR _ret$1$[ebp]
	pop	esi
	pop	edi

; 10131:     return(ret);

	movsd	QWORD PTR tv733[ebp], xmm0
	fld	QWORD PTR tv733[ebp]

; 10132: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathStringEvalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathParseNCName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathParseNCName PROC				; COMDAT

; 9838 : xmlXPathParseNCName(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlXPathPa

; 9839 :     const xmlChar *in;
; 9840 :     xmlChar *ret;
; 9841 :     int count = 0;
; 9842 : 
; 9843 :     if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	$LN5@xmlXPathPa

; 9844 :     /*
; 9845 :      * Accelerator for simple ASCII names
; 9846 :      */
; 9847 :     in = ctxt->cur;

	mov	esi, ecx

; 9848 :     if (((*in >= 0x61) && (*in <= 0x7A)) ||
; 9849 : 	((*in >= 0x41) && (*in <= 0x5A)) ||

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jb	SHORT $LN8@xmlXPathPa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN7@xmlXPathPa
$LN8@xmlXPathPa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN9@xmlXPathPa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN7@xmlXPathPa
$LN9@xmlXPathPa:
	cmp	al, 95					; 0000005fH
	jne	SHORT $LN14@xmlXPathPa
$LN7@xmlXPathPa:

; 9850 : 	(*in == '_')) {
; 9851 : 	in++;
; 9852 : 	while (((*in >= 0x61) && (*in <= 0x7A)) ||
; 9853 : 	       ((*in >= 0x41) && (*in <= 0x5A)) ||
; 9854 : 	       ((*in >= 0x30) && (*in <= 0x39)) ||
; 9855 : 	       (*in == '_') || (*in == '.') ||

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN11@xmlXPathPa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN7@xmlXPathPa
$LN11@xmlXPathPa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN12@xmlXPathPa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN7@xmlXPathPa
$LN12@xmlXPathPa:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN13@xmlXPathPa
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN7@xmlXPathPa
$LN13@xmlXPathPa:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 46					; 0000002eH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 45					; 0000002dH
	je	SHORT $LN7@xmlXPathPa

; 9856 : 	       (*in == '-'))
; 9857 : 	    in++;
; 9858 : 	if ((*in == ' ') || (*in == '>') || (*in == '/') ||
; 9859 :             (*in == '[') || (*in == ']') || (*in == ':') ||
; 9860 :             (*in == '@') || (*in == '*')) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 62					; 0000003eH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 47					; 0000002fH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 91					; 0000005bH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 93					; 0000005dH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 58					; 0000003aH
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 64					; 00000040H
	je	SHORT $LN15@xmlXPathPa
	cmp	al, 42					; 0000002aH
	jne	SHORT $LN14@xmlXPathPa
$LN15@xmlXPathPa:

; 9861 : 	    count = in - ctxt->cur;

	mov	eax, esi
	sub	eax, ecx

; 9862 : 	    if (count == 0)

	je	SHORT $LN5@xmlXPathPa

; 9863 : 		return(NULL);
; 9864 : 	    ret = xmlStrndup(ctxt->cur, count);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 9865 : 	    ctxt->cur = in;

	mov	DWORD PTR [edi], esi
	pop	edi

; 9870 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@xmlXPathPa:

; 9866 : 	    return(ret);
; 9867 : 	}
; 9868 :     }
; 9869 :     return(xmlXPathParseNameComplex(ctxt, 0));

	push	0
	push	edi
	call	_xmlXPathParseNameComplex
	add	esp, 8
	pop	edi

; 9870 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPathPa:
	pop	edi

; 9839 :     const xmlChar *in;
; 9840 :     xmlChar *ret;
; 9841 :     int count = 0;
; 9842 : 
; 9843 :     if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);

	xor	eax, eax

; 9870 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathParseNCName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathParseName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathParseName PROC					; COMDAT

; 9919 : xmlXPathParseName(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN5@xmlXPathPa

; 9920 :     const xmlChar *in;
; 9921 :     xmlChar *ret;
; 9922 :     size_t count = 0;
; 9923 : 
; 9924 :     if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	$LN5@xmlXPathPa

; 9925 :     /*
; 9926 :      * Accelerator for simple ASCII names
; 9927 :      */
; 9928 :     in = ctxt->cur;

	push	esi
	mov	esi, ecx

; 9929 :     if (((*in >= 0x61) && (*in <= 0x7A)) ||
; 9930 : 	((*in >= 0x41) && (*in <= 0x5A)) ||
; 9931 : 	(*in == '_') || (*in == ':')) {

	mov	al, BYTE PTR [esi]
	cmp	al, 97					; 00000061H
	jb	SHORT $LN8@xmlXPathPa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN7@xmlXPathPa
$LN8@xmlXPathPa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN9@xmlXPathPa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN7@xmlXPathPa
$LN9@xmlXPathPa:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN14@xmlXPathPa
$LN7@xmlXPathPa:

; 9932 : 	in++;
; 9933 : 	while (((*in >= 0x61) && (*in <= 0x7A)) ||
; 9934 : 	       ((*in >= 0x41) && (*in <= 0x5A)) ||
; 9935 : 	       ((*in >= 0x30) && (*in <= 0x39)) ||
; 9936 : 	       (*in == '_') || (*in == '-') ||
; 9937 : 	       (*in == ':') || (*in == '.'))

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 97					; 00000061H
	jb	SHORT $LN11@xmlXPathPa
	cmp	al, 122					; 0000007aH
	jbe	SHORT $LN7@xmlXPathPa
$LN11@xmlXPathPa:
	cmp	al, 65					; 00000041H
	jb	SHORT $LN12@xmlXPathPa
	cmp	al, 90					; 0000005aH
	jbe	SHORT $LN7@xmlXPathPa
$LN12@xmlXPathPa:
	cmp	al, 48					; 00000030H
	jb	SHORT $LN13@xmlXPathPa
	cmp	al, 57					; 00000039H
	jbe	SHORT $LN7@xmlXPathPa
$LN13@xmlXPathPa:
	cmp	al, 95					; 0000005fH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 45					; 0000002dH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 58					; 0000003aH
	je	SHORT $LN7@xmlXPathPa
	cmp	al, 46					; 0000002eH
	je	SHORT $LN7@xmlXPathPa

; 9938 : 	    in++;
; 9939 : 	if ((*in > 0) && (*in < 0x80)) {

	dec	al
	cmp	al, 126					; 0000007eH
	ja	SHORT $LN14@xmlXPathPa

; 9940 : 	    count = in - ctxt->cur;

	mov	eax, esi
	sub	eax, ecx

; 9941 :             if (count > XML_MAX_NAME_LENGTH) {

	cmp	eax, 50000				; 0000c350H
	jbe	SHORT $LN15@xmlXPathPa

; 9942 :                 ctxt->cur = in;
; 9943 :                 XP_ERRORNULL(XPATH_EXPR_ERROR);

	push	7
	push	edi
	mov	DWORD PTR [edi], esi
	call	_xmlXPathErr
	add	esp, 8
	xor	eax, eax
	pop	esi
	pop	edi

; 9951 : }

	pop	ebp
	ret	0
$LN15@xmlXPathPa:

; 9944 :             }
; 9945 : 	    ret = xmlStrndup(ctxt->cur, count);

	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 9946 : 	    ctxt->cur = in;

	mov	DWORD PTR [edi], esi
	pop	esi
	pop	edi

; 9951 : }

	pop	ebp
	ret	0
$LN14@xmlXPathPa:

; 9947 : 	    return(ret);
; 9948 : 	}
; 9949 :     }
; 9950 :     return(xmlXPathParseNameComplex(ctxt, 1));

	push	1
	push	edi
	call	_xmlXPathParseNameComplex
	add	esp, 8
	pop	esi
	pop	edi

; 9951 : }

	pop	ebp
	ret	0
$LN5@xmlXPathPa:

; 9920 :     const xmlChar *in;
; 9921 :     xmlChar *ret;
; 9922 :     size_t count = 0;
; 9923 : 
; 9924 :     if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);

	xor	eax, eax
	pop	edi

; 9951 : }

	pop	ebp
	ret	0
_xmlXPathParseName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEvalExpr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathEvalExpr PROC					; COMDAT

; 14816: xmlXPathEvalExpr(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathEv

; 14817: #ifdef XPATH_STREAMING
; 14818:     xmlXPathCompExprPtr comp;
; 14819: #endif
; 14820: 
; 14821:     if (ctxt == NULL) return;
; 14822: 
; 14823: #ifdef XPATH_STREAMING
; 14824:     comp = xmlXPathTryStreamCompile(ctxt->context, ctxt->base);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+12]
	call	_xmlXPathTryStreamCompile
	mov	edi, eax
	add	esp, 8

; 14825:     if (comp != NULL) {

	test	edi, edi
	je	SHORT $LN3@xmlXPathEv

; 14826:         if (ctxt->comp != NULL)

	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathEv

; 14827: 	    xmlXPathFreeCompExpr(ctxt->comp);

	push	ecx
	call	_xmlXPathFreeCompExpr
	add	esp, 4
$LN5@xmlXPathEv:

; 14841: 		&ctxt->comp->steps[ctxt->comp->last]);
; 14842:     }
; 14843: 
; 14844:     xmlXPathRunEval(ctxt, 0);

	push	0
	push	esi
	mov	DWORD PTR [esi+32], edi
	call	_xmlXPathRunEval
	add	esp, 8
	pop	edi
	pop	esi

; 14845: }

	pop	ebp
	ret	0
$LN3@xmlXPathEv:

; 14828:         ctxt->comp = comp;
; 14829:     } else
; 14830: #endif
; 14831:     {
; 14832: 	xmlXPathCompileExpr(ctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompileExpr
	add	esp, 8

; 14833:         CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN10@xmlXPathEv

; 14834: 
; 14835:         /* Check for trailing characters. */
; 14836:         if (*ctxt->cur != 0)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN7@xmlXPathEv

; 14837:             XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr

; 14841: 		&ctxt->comp->steps[ctxt->comp->last]);
; 14842:     }
; 14843: 
; 14844:     xmlXPathRunEval(ctxt, 0);

	add	esp, 8
	pop	edi
	pop	esi

; 14845: }

	pop	ebp
	ret	0
$LN7@xmlXPathEv:

; 14838: 
; 14839: 	if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0))

	mov	edx, DWORD PTR [esi+32]
	cmp	DWORD PTR [edx], 1
	jle	SHORT $LN8@xmlXPathEv
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	js	SHORT $LN8@xmlXPathEv

; 14840: 	    xmlXPathOptimizeExpression(ctxt->comp,

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	edx
	call	_xmlXPathOptimizeExpression
	add	esp, 8
$LN8@xmlXPathEv:

; 14841: 		&ctxt->comp->steps[ctxt->comp->last]);
; 14842:     }
; 14843: 
; 14844:     xmlXPathRunEval(ctxt, 0);

	push	0
	push	esi
	call	_xmlXPathRunEval
	add	esp, 8
$LN10@xmlXPathEv:
	pop	edi
$LN1@xmlXPathEv:
	pop	esi

; 14845: }

	pop	ebp
	ret	0
_xmlXPathEvalExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRoot
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathRoot PROC					; COMDAT

; 8477 : xmlXPathRoot(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathRo

; 8478 :     if ((ctxt == NULL) || (ctxt->context == NULL))

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN3@xmlXPathRo

; 8479 : 	return;
; 8480 :     valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,

	push	DWORD PTR [eax]
	push	eax
	call	_xmlXPathCacheNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN3@xmlXPathRo:
	pop	esi

; 8481 : 	(xmlNodePtr) ctxt->context->doc));
; 8482 : }

	pop	ebp
	ret	0
_xmlXPathRoot ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetSort
_TEXT	SEGMENT
_set$ = 8						; size = 4
_xmlXPathNodeSetSort PROC				; COMDAT

; 3416 : xmlXPathNodeSetSort(xmlNodeSetPtr set) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _set$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlXPathNo

; 3417 : #ifndef WITH_TIM_SORT
; 3418 :     int i, j, incr, len;
; 3419 :     xmlNodePtr tmp;
; 3420 : #endif
; 3421 : 
; 3422 :     if (set == NULL)
; 3423 : 	return;
; 3424 : 
; 3425 : #ifndef WITH_TIM_SORT
; 3426 :     /*
; 3427 :      * Use the old Shell's sort implementation to sort the node-set
; 3428 :      * Timsort ought to be quite faster
; 3429 :      */
; 3430 :     len = set->nodeNr;
; 3431 :     for (incr = len / 2; incr > 0; incr /= 2) {
; 3432 : 	for (i = incr; i < len; i++) {
; 3433 : 	    j = i - incr;
; 3434 : 	    while (j >= 0) {
; 3435 : #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
; 3436 : 		if (xmlXPathCmpNodesExt(set->nodeTab[j],
; 3437 : 			set->nodeTab[j + incr]) == -1)
; 3438 : #else
; 3439 : 		if (xmlXPathCmpNodes(set->nodeTab[j],
; 3440 : 			set->nodeTab[j + incr]) == -1)
; 3441 : #endif
; 3442 : 		{
; 3443 : 		    tmp = set->nodeTab[j];
; 3444 : 		    set->nodeTab[j] = set->nodeTab[j + incr];
; 3445 : 		    set->nodeTab[j + incr] = tmp;
; 3446 : 		    j -= incr;
; 3447 : 		} else
; 3448 : 		    break;
; 3449 : 	    }
; 3450 : 	}
; 3451 :     }
; 3452 : #else /* WITH_TIM_SORT */
; 3453 :     libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);

	push	DWORD PTR [eax]
	push	DWORD PTR [eax+8]
	call	_libxml_domnode_tim_sort
	add	esp, 8
$LN1@xmlXPathNo:

; 3454 : #endif /* WITH_TIM_SORT */
; 3455 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetSort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetAddNs
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_node$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlXPathNodeSetAddNs PROC				; COMDAT

; 3637 : xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN6@xmlXPathNo

; 3638 :     int i;
; 3639 : 
; 3640 : 
; 3641 :     if ((cur == NULL) || (ns == NULL) || (node == NULL) ||
; 3642 :         (ns->type != XML_NAMESPACE_DECL) ||

	mov	ecx, DWORD PTR _ns$[ebp]
	test	ecx, ecx
	je	$LN6@xmlXPathNo
	mov	ebx, DWORD PTR _node$[ebp]
	test	ebx, ebx
	je	$LN6@xmlXPathNo
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	$LN6@xmlXPathNo
	cmp	DWORD PTR [ebx+4], 1
	jne	$LN6@xmlXPathNo

; 3645 : 
; 3646 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3647 :     /*
; 3648 :      * prevent duplicates
; 3649 :      */
; 3650 :     for (i = 0;i < cur->nodeNr;i++) {

	mov	eax, DWORD PTR [esi]
	push	edi
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN48@xmlXPathNo
	npad	3
$LL4@xmlXPathNo:

; 3651 :         if ((cur->nodeTab[i] != NULL) &&
; 3652 : 	    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&
; 3653 : 	    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN2@xmlXPathNo
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPathNo
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN2@xmlXPathNo
	push	DWORD PTR [eax+12]
	push	DWORD PTR [ecx+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN43@xmlXPathNo
	mov	ecx, DWORD PTR _ns$[ebp]
$LN2@xmlXPathNo:

; 3645 : 
; 3646 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3647 :     /*
; 3648 :      * prevent duplicates
; 3649 :      */
; 3650 :     for (i = 0;i < cur->nodeNr;i++) {

	mov	eax, DWORD PTR [esi]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL4@xmlXPathNo
$LN48@xmlXPathNo:

; 3654 : 	    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))
; 3655 : 	    return(0);
; 3656 :     }
; 3657 : 
; 3658 :     /*
; 3659 :      * grow the nodeTab if needed
; 3660 :      */
; 3661 :     if (cur->nodeMax == 0) {

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN8@xmlXPathNo

; 3662 :         cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3663 : 					     sizeof(xmlNodePtr));
; 3664 : 	if (cur->nodeTab == NULL) {

	test	eax, eax
	je	$LN47@xmlXPathNo

; 3665 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3666 : 	    return(-1);
; 3667 : 	}
; 3668 : 	memset(cur->nodeTab, 0 ,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3669 : 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 3670 :         cur->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	$LN11@xmlXPathNo
$LN8@xmlXPathNo:

; 3671 :     } else if (cur->nodeNr == cur->nodeMax) {

	cmp	eax, ecx
	jne	$LN11@xmlXPathNo

; 3672 :         xmlNodePtr *temp;
; 3673 : 
; 3674 :         if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	ecx, 10000000				; 00989680H
	jl	SHORT $LN12@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
$LN50@xmlXPathNo:
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3675 :             xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
; 3676 :             return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 3689 : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlXPathNo:

; 3677 :         }
; 3678 : 	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *

	lea	eax, DWORD PTR [ecx*8]
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 3679 : 				      sizeof(xmlNodePtr));
; 3680 : 	if (temp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN13@xmlXPathNo
$LN47@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@

; 3681 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3682 : 	    return(-1);

	jmp	SHORT $LN50@xmlXPathNo
$LN13@xmlXPathNo:

; 3683 : 	}
; 3684 :         cur->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax

; 3685 : 	cur->nodeTab = temp;

	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+4], eax
$LN11@xmlXPathNo:

; 3686 :     }
; 3687 :     cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);

	push	DWORD PTR _ns$[ebp]
	push	ebx
	call	_xmlXPathNodeSetDupNs
	mov	edx, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
$LN43@xmlXPathNo:

; 3688 :     return(0);

	pop	edi
	pop	esi
	xor	eax, eax

; 3689 : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlXPathNo:
	pop	esi

; 3643 : 	(node->type != XML_ELEMENT_NODE))
; 3644 : 	return(-1);

	or	eax, -1

; 3689 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlXPathNodeSetAddNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetAddUnique
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathNodeSetAddUnique PROC				; COMDAT

; 3763 : xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathNo

; 3764 :     if ((cur == NULL) || (val == NULL)) return(-1);

	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlXPathNo

; 3765 : 
; 3766 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3767 :     /*
; 3768 :      * grow the nodeTab if needed
; 3769 :      */
; 3770 :     if (cur->nodeMax == 0) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN4@xmlXPathNo

; 3771 :         cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3772 : 					     sizeof(xmlNodePtr));
; 3773 : 	if (cur->nodeTab == NULL) {

	test	eax, eax
	je	SHORT $LN40@xmlXPathNo

; 3774 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3775 : 	    return(-1);
; 3776 : 	}
; 3777 : 	memset(cur->nodeTab, 0 ,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3778 : 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 3779 :         cur->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	SHORT $LN7@xmlXPathNo
$LN4@xmlXPathNo:

; 3780 :     } else if (cur->nodeNr == cur->nodeMax) {

	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN7@xmlXPathNo

; 3781 :         xmlNodePtr *temp;
; 3782 : 
; 3783 :         if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jl	SHORT $LN8@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
$LN42@xmlXPathNo:

; 3804 : }

	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN3@xmlXPathNo:
	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathNo:

; 3784 :             xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
; 3785 :             return(-1);
; 3786 :         }
; 3787 : 	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 3788 : 				      sizeof(xmlNodePtr));
; 3789 : 	if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN9@xmlXPathNo
$LN40@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@

; 3790 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3791 : 	    return(-1);

	jmp	SHORT $LN42@xmlXPathNo
$LN9@xmlXPathNo:

; 3792 : 	}
; 3793 : 	cur->nodeTab = temp;

	mov	DWORD PTR [esi+8], eax

; 3794 :         cur->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	DWORD PTR [esi+4], eax
$LN7@xmlXPathNo:

; 3795 :     }
; 3796 :     if (val->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN10@xmlXPathNo

; 3797 : 	xmlNsPtr ns = (xmlNsPtr) val;
; 3798 : 
; 3799 : 	cur->nodeTab[cur->nodeNr++] =

	push	edi
	push	DWORD PTR [edi]
	call	_xmlXPathNodeSetDupNs
	mov	edx, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [ecx+edx*4], eax

; 3803 :     return(0);

	inc	DWORD PTR [esi]
	xor	eax, eax

; 3804 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlXPathNo:

; 3800 : 	    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
; 3801 :     } else
; 3802 : 	cur->nodeTab[cur->nodeNr++] = val;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi

; 3803 :     return(0);

	inc	DWORD PTR [esi]
	xor	eax, eax
	pop	edi

; 3804 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathNodeSetAddUnique ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetAdd
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathNodeSetAdd PROC				; COMDAT

; 3701 : xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN6@xmlXPathNo

; 3702 :     int i;
; 3703 : 
; 3704 :     if ((cur == NULL) || (val == NULL)) return(-1);

	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	$LN6@xmlXPathNo

; 3705 : 
; 3706 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3707 :     /*
; 3708 :      * prevent duplicates
; 3709 :      */
; 3710 :     for (i = 0;i < cur->nodeNr;i++)

	mov	edx, DWORD PTR [esi]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN3@xmlXPathNo

; 3711 :         if (cur->nodeTab[i] == val) return(0);

	mov	eax, DWORD PTR [esi+8]
$LL4@xmlXPathNo:
	cmp	DWORD PTR [eax], edi
	je	$LN45@xmlXPathNo

; 3705 : 
; 3706 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 3707 :     /*
; 3708 :      * prevent duplicates
; 3709 :      */
; 3710 :     for (i = 0;i < cur->nodeNr;i++)

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL4@xmlXPathNo
$LN3@xmlXPathNo:

; 3712 : 
; 3713 :     /*
; 3714 :      * grow the nodeTab if needed
; 3715 :      */
; 3716 :     if (cur->nodeMax == 0) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN8@xmlXPathNo

; 3717 :         cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3718 : 					     sizeof(xmlNodePtr));
; 3719 : 	if (cur->nodeTab == NULL) {

	test	eax, eax
	je	SHORT $LN49@xmlXPathNo

; 3720 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3721 : 	    return(-1);
; 3722 : 	}
; 3723 : 	memset(cur->nodeTab, 0 ,

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3724 : 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 3725 :         cur->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH
	jmp	SHORT $LN11@xmlXPathNo
$LN8@xmlXPathNo:

; 3726 :     } else if (cur->nodeNr == cur->nodeMax) {

	cmp	edx, eax
	jne	SHORT $LN11@xmlXPathNo

; 3727 :         xmlNodePtr *temp;
; 3728 : 
; 3729 :         if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {

	cmp	eax, 10000000				; 00989680H
	jl	SHORT $LN12@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BL@JKBEHGK@growing?5nodeset?5hit?5limit?6@
$LN51@xmlXPathNo:

; 3750 : }

	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN6@xmlXPathNo:
	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN12@xmlXPathNo:

; 3730 :             xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
; 3731 :             return(-1);
; 3732 :         }
; 3733 : 	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 3734 : 				      sizeof(xmlNodePtr));
; 3735 : 	if (temp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN13@xmlXPathNo
$LN49@xmlXPathNo:

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BB@HLDFGIFL@growing?5nodeset?6@

; 3736 : 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
; 3737 : 	    return(-1);

	jmp	SHORT $LN51@xmlXPathNo
$LN13@xmlXPathNo:

; 3738 : 	}
; 3739 :         cur->nodeMax *= 2;

	mov	eax, DWORD PTR [esi+4]
	add	eax, eax

; 3740 : 	cur->nodeTab = temp;

	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+4], eax
$LN11@xmlXPathNo:

; 3741 :     }
; 3742 :     if (val->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN14@xmlXPathNo

; 3743 : 	xmlNsPtr ns = (xmlNsPtr) val;
; 3744 : 
; 3745 : 	cur->nodeTab[cur->nodeNr++] =

	push	edi
	push	DWORD PTR [edi]
	call	_xmlXPathNodeSetDupNs
	mov	edx, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [ecx+edx*4], eax

; 3749 :     return(0);

	inc	DWORD PTR [esi]

; 3750 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN14@xmlXPathNo:

; 3746 : 	    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
; 3747 :     } else
; 3748 : 	cur->nodeTab[cur->nodeNr++] = val;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi

; 3749 :     return(0);

	inc	DWORD PTR [esi]
$LN45@xmlXPathNo:

; 3750 : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlXPathNodeSetAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewValueTree
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewValueTree PROC				; COMDAT

; 4367 : xmlXPathNewValueTree(xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BM@FFJIGPKH@creating?5result?5value?5tree?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BM@FFJIGPKH@creating?5result?5value?5tree?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4368 :     xmlXPathObjectPtr ret;
; 4369 : 
; 4370 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 4371 :     if (ret == NULL) {
; 4372 :         xmlXPathErrMemory(NULL, "creating result value tree\n");
; 4373 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 4384 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 4374 :     }
; 4375 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
; 4376 :     ret->type = XPATH_XSLT_TREE;
; 4377 :     ret->boolval = 1;
; 4378 :     ret->user = (void *) val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 4379 :     ret->nodesetval = xmlXPathNodeSetCreate(val);

	push	ecx
	mov	DWORD PTR [esi], 9
	mov	DWORD PTR [esi+8], 1
	mov	DWORD PTR [esi+28], ecx
	call	_xmlXPathNodeSetCreate
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 4380 : #ifdef XP_DEBUG_OBJ_USAGE
; 4381 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_XSLT_TREE);
; 4382 : #endif
; 4383 :     return(ret);

	mov	eax, esi
	pop	esi

; 4384 : }

	pop	ebp
	ret	0
_xmlXPathNewValueTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewNodeSet
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewNodeSet PROC				; COMDAT

; 4338 : xmlXPathNewNodeSet(xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4339 :     xmlXPathObjectPtr ret;
; 4340 : 
; 4341 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 4342 :     if (ret == NULL) {
; 4343 :         xmlXPathErrMemory(NULL, "creating nodeset\n");
; 4344 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 4355 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 4345 :     }
; 4346 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 4347 :     ret->type = XPATH_NODESET;
; 4348 :     ret->boolval = 0;
; 4349 :     ret->nodesetval = xmlXPathNodeSetCreate(val);

	push	DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi], 1
	call	_xmlXPathNodeSetCreate
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+4], eax

; 4350 :     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 4351 : #ifdef XP_DEBUG_OBJ_USAGE
; 4352 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
; 4353 : #endif
; 4354 :     return(ret);

	mov	eax, esi
	pop	esi

; 4355 : }

	pop	ebp
	ret	0
_xmlXPathNewNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewBoolean PROC				; COMDAT

; 5256 : xmlXPathNewBoolean(int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5257 :     xmlXPathObjectPtr ret;
; 5258 : 
; 5259 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5260 :     if (ret == NULL) {
; 5261 :         xmlXPathErrMemory(NULL, "creating boolean object\n");
; 5262 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 5271 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 5263 :     }
; 5264 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 5265 :     ret->type = XPATH_BOOLEAN;
; 5266 :     ret->boolval = (val != 0);

	xor	eax, eax
	mov	DWORD PTR [esi], 2
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _val$[ebp], eax
	setne	al
	mov	DWORD PTR [esi+8], eax

; 5267 : #ifdef XP_DEBUG_OBJ_USAGE
; 5268 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_BOOLEAN);
; 5269 : #endif
; 5270 :     return(ret);

	mov	eax, esi
	pop	esi

; 5271 : }

	pop	ebp
	ret	0
_xmlXPathNewBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewFloat
_TEXT	SEGMENT
_val$ = 8						; size = 8
_xmlXPathNewFloat PROC					; COMDAT

; 5230 : xmlXPathNewFloat(double val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BH@FGBKIIOK@creating?5float?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@FGBKIIOK@creating?5float?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5231 :     xmlXPathObjectPtr ret;
; 5232 : 
; 5233 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5234 :     if (ret == NULL) {
; 5235 :         xmlXPathErrMemory(NULL, "creating float object\n");
; 5236 : 	return(NULL);

	xor	eax, eax

; 5241 : #ifdef XP_DEBUG_OBJ_USAGE
; 5242 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_NUMBER);
; 5243 : #endif
; 5244 :     return(ret);
; 5245 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 5237 :     }
; 5238 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
; 5239 :     ret->type = XPATH_NUMBER;
; 5240 :     ret->floatval = val;

	movsd	xmm0, QWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax], 3
	movsd	QWORD PTR [eax+16], xmm0

; 5241 : #ifdef XP_DEBUG_OBJ_USAGE
; 5242 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_NUMBER);
; 5243 : #endif
; 5244 :     return(ret);
; 5245 : }

	pop	ebp
	ret	0
_xmlXPathNewFloat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathWrapCString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathWrapCString PROC				; COMDAT

; 5363 : xmlXPathWrapCString (char * val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 5365 : }

	pop	ebp

; 5364 :     return(xmlXPathWrapString((xmlChar *)(val)));

	jmp	_xmlXPathWrapString
_xmlXPathWrapCString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathWrapString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathWrapString PROC				; COMDAT

; 5311 : xmlXPathWrapString (xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathWr

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5312 :     xmlXPathObjectPtr ret;
; 5313 : 
; 5314 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5315 :     if (ret == NULL) {
; 5316 :         xmlXPathErrMemory(NULL, "creating string object\n");
; 5317 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 5326 : }

	pop	ebp
	ret	0
$LN2@xmlXPathWr:

; 5318 :     }
; 5319 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 5320 :     ret->type = XPATH_STRING;
; 5321 :     ret->stringval = val;

	mov	eax, DWORD PTR _val$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], eax

; 5322 : #ifdef XP_DEBUG_OBJ_USAGE
; 5323 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);
; 5324 : #endif
; 5325 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi], 4
	pop	esi

; 5326 : }

	pop	ebp
	ret	0
_xmlXPathWrapString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewCString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewCString PROC				; COMDAT

; 5337 : xmlXPathNewCString(const char *val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5338 :     xmlXPathObjectPtr ret;
; 5339 : 
; 5340 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5341 :     if (ret == NULL) {
; 5342 :         xmlXPathErrMemory(NULL, "creating string object\n");
; 5343 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 5352 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 5344 :     }
; 5345 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 5346 :     ret->type = XPATH_STRING;
; 5347 :     ret->stringval = xmlStrdup(BAD_CAST val);

	push	DWORD PTR _val$[ebp]
	mov	DWORD PTR [esi], 4
	call	_xmlStrdup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax

; 5348 : #ifdef XP_DEBUG_OBJ_USAGE
; 5349 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);
; 5350 : #endif
; 5351 :     return(ret);

	mov	eax, esi
	pop	esi

; 5352 : }

	pop	ebp
	ret	0
_xmlXPathNewCString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNewString PROC					; COMDAT

; 5282 : xmlXPathNewString(const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BI@BJAGDAFP@creating?5string?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5283 :     xmlXPathObjectPtr ret;
; 5284 : 
; 5285 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 5286 :     if (ret == NULL) {
; 5287 :         xmlXPathErrMemory(NULL, "creating string object\n");
; 5288 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 5300 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 5289 :     }
; 5290 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 5291 :     ret->type = XPATH_STRING;
; 5292 :     if (val != NULL)
; 5293 : 	ret->stringval = xmlStrdup(val);
; 5294 :     else
; 5295 : 	ret->stringval = xmlStrdup((const xmlChar *)"");
; 5296 : #ifdef XP_DEBUG_OBJ_USAGE
; 5297 :     xmlXPathDebugObjUsageRequested(NULL, XPATH_STRING);
; 5298 : #endif
; 5299 :     return(ret);

	cmp	DWORD PTR _val$[ebp], 0
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	mov	DWORD PTR [esi], 4
	cmovne	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax
	mov	eax, esi
	pop	esi

; 5300 : }

	pop	ebp
	ret	0
_xmlXPathNewString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _valuePush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_valuePush PROC						; COMDAT

; 2851 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN3@valuePush

; 2852 :     if ((ctxt == NULL) || (value == NULL)) return(-1);

	mov	edi, DWORD PTR _value$[ebp]
	test	edi, edi
	je	$LN3@valuePush

; 2853 :     if (ctxt->valueNr >= ctxt->valueMax) {

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+24]
	cmp	ecx, eax
	jl	$LN27@valuePush

; 2854 :         xmlXPathObjectPtr *tmp;
; 2855 : 
; 2856 :         if (ctxt->valueMax >= XPATH_MAX_STACK_DEPTH) {

	cmp	eax, 1000000				; 000f4240H
	jl	SHORT $LN5@valuePush

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0CB@EAFHACKN@XPath?5stack?5depth?5limit?5reached@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CB@EAFHACKN@XPath?5stack?5depth?5limit?5reached@
	push	0
	push	0
	push	3
	push	2
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2857 :             xmlXPathErrMemory(NULL, "XPath stack depth limit reached\n");
; 2858 :             ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH

; 2859 :             return (0);

	xor	eax, eax
	pop	edi

; 2875 : }

	pop	esi
	pop	ebp
	ret	0
$LN5@valuePush:

; 2860 :         }
; 2861 :         tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt->valueTab,

	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8

; 2862 :                                              2 * ctxt->valueMax *
; 2863 :                                              sizeof(ctxt->valueTab[0]));
; 2864 :         if (tmp == NULL) {

	test	ecx, ecx
	jne	SHORT $LN6@valuePush

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0P@LENPPBCI@pushing?5value?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0P@LENPPBCI@pushing?5value?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2865 :             xmlXPathErrMemory(NULL, "pushing value\n");
; 2866 :             ctxt->error = XPATH_MEMORY_ERROR;

	mov	DWORD PTR [esi+8], 15			; 0000000fH

; 2867 :             return (0);

	xor	eax, eax
	pop	edi

; 2875 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@valuePush:

; 2868 :         }
; 2869 :         ctxt->valueMax *= 2;

	mov	eax, DWORD PTR [esi+24]
	add	eax, eax

; 2870 : 	ctxt->valueTab = tmp;

	mov	DWORD PTR [esi+28], ecx
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax
$LN27@valuePush:

; 2871 :     }
; 2872 :     ctxt->valueTab[ctxt->valueNr] = value;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+ecx*4], edi

; 2873 :     ctxt->value = value;
; 2874 :     return (ctxt->valueNr++);

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+16], edi
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+20], ecx

; 2875 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@valuePush:
	pop	edi

; 2852 :     if ((ctxt == NULL) || (value == NULL)) return(-1);

	or	eax, -1

; 2875 : }

	pop	esi
	pop	ebp
	ret	0
_valuePush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _valuePop
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_valuePop PROC						; COMDAT

; 2820 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	SHORT $LN3@valuePop

; 2821 :     xmlXPathObjectPtr ret;
; 2822 : 
; 2823 :     if ((ctxt == NULL) || (ctxt->valueNr <= 0))

	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	jle	SHORT $LN3@valuePop

; 2824 :         return (NULL);
; 2825 : 
; 2826 :     if (ctxt->valueNr <= ctxt->valueFrame) {

	cmp	eax, DWORD PTR [edx+44]
	jg	SHORT $LN4@valuePop

; 747  :     xmlXPathErr(ctxt, no);

	push	23					; 00000017H
	push	edx
	call	_xmlXPathErr
	add	esp, 8
$LN3@valuePop:

; 2839 : }

	xor	eax, eax
	pop	ebp
	ret	0
$LN4@valuePop:

; 2827 :         xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);
; 2828 :         return (NULL);
; 2829 :     }
; 2830 : 
; 2831 :     ctxt->valueNr--;

	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [edx+20], ecx

; 2832 :     if (ctxt->valueNr > 0)

	test	ecx, ecx
	jle	SHORT $LN5@valuePop

; 2833 :         ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];

	mov	eax, DWORD PTR [edx+28]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN6@valuePop
$LN5@valuePop:

; 2834 :     else
; 2835 :         ctxt->value = NULL;

	xor	eax, eax
$LN6@valuePop:

; 2836 :     ret = ctxt->valueTab[ctxt->valueNr];

	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [eax+ecx*4]

; 2837 :     ctxt->valueTab[ctxt->valueNr] = NULL;

	mov	DWORD PTR [eax+ecx*4], 0

; 2838 :     return (ret);

	mov	eax, edx

; 2839 : }

	pop	ebp
	ret	0
_valuePop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeParserContext
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathFreeParserContext PROC				; COMDAT

; 6306 : xmlXPathFreeParserContext(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN5@xmlXPathFr

; 6307 :     int i;
; 6308 : 
; 6309 :     if (ctxt->valueTab != NULL) {
; 6310 :         for (i = 0; i < ctxt->valueNr; i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN3@xmlXPathFr
$LL4@xmlXPathFr:

; 6311 :             if (ctxt->context)

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+edi*4]
	push	eax
	test	ecx, ecx
	je	SHORT $LN6@xmlXPathFr

; 6312 :                 xmlXPathReleaseObject(ctxt->context, ctxt->valueTab[i]);

	push	ecx
	call	_xmlXPathReleaseObject
	add	esp, 8
	jmp	SHORT $LN2@xmlXPathFr
$LN6@xmlXPathFr:

; 6313 :             else
; 6314 :                 xmlXPathFreeObject(ctxt->valueTab[i]);

	call	_xmlXPathFreeObject
	add	esp, 4
$LN2@xmlXPathFr:

; 6307 :     int i;
; 6308 : 
; 6309 :     if (ctxt->valueTab != NULL) {
; 6310 :         for (i = 0; i < ctxt->valueNr; i++) {

	inc	edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL4@xmlXPathFr
	mov	eax, DWORD PTR [esi+28]
$LN3@xmlXPathFr:

; 6315 :         }
; 6316 :         xmlFree(ctxt->valueTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN5@xmlXPathFr:

; 6317 :     }
; 6318 :     if (ctxt->comp != NULL) {

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN8@xmlXPathFr

; 6319 : #ifdef XPATH_STREAMING
; 6320 : 	if (ctxt->comp->stream != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN9@xmlXPathFr

; 6321 : 	    xmlFreePatternList(ctxt->comp->stream);

	push	ecx
	call	_xmlFreePatternList

; 6322 : 	    ctxt->comp->stream = NULL;

	mov	eax, DWORD PTR [esi+32]
	add	esp, 4
	mov	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR [esi+32]
$LN9@xmlXPathFr:

; 6323 : 	}
; 6324 : #endif
; 6325 : 	xmlXPathFreeCompExpr(ctxt->comp);

	push	eax
	call	_xmlXPathFreeCompExpr
	add	esp, 4
$LN8@xmlXPathFr:

; 6326 :     }
; 6327 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 6328 : }

	pop	ebp
	ret	0
_xmlXPathFreeParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewParserContext
_TEXT	SEGMENT
_str$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlXPathNewParserContext PROC				; COMDAT

; 6234 : xmlXPathNewParserContext(const xmlChar *str, xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 6235 :     xmlXPathParserContextPtr ret;
; 6236 : 
; 6237 :     ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));
; 6238 :     if (ret == NULL) {
; 6239 :         xmlXPathErrMemory(ctxt, "creating parser context\n");

	push	OFFSET ??_C@_0BJ@KFGJCHDI@creating?5parser?5context?6@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErrMemory
	add	esp, 8

; 6240 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6258 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 6241 :     }
; 6242 :     memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));
; 6243 :     ret->cur = ret->base = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	push	edi

; 6244 :     ret->context = ctxt;

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+12], edi

; 6245 : 
; 6246 :     ret->comp = xmlXPathNewCompExpr();

	call	_xmlXPathNewCompExpr
	mov	DWORD PTR [esi+32], eax

; 6247 :     if (ret->comp == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlXPathNe

; 6248 : 	xmlFree(ret->valueTab);

	push	DWORD PTR [esi+28]
	call	DWORD PTR _xmlFree

; 6249 : 	xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 6250 : 	return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 6258 : }

	pop	ebp
	ret	0
$LN3@xmlXPathNe:

; 6251 :     }
; 6252 :     if ((ctxt != NULL) && (ctxt->dict != NULL)) {

	test	edi, edi
	je	SHORT $LN4@xmlXPathNe
	mov	ecx, DWORD PTR [edi+192]
	test	ecx, ecx
	je	SHORT $LN4@xmlXPathNe

; 6253 :         ret->comp->dict = ctxt->dict;

	mov	DWORD PTR [eax+20], ecx

; 6254 : 	xmlDictReference(ret->comp->dict);

	mov	ecx, DWORD PTR [esi+32]
	push	DWORD PTR [ecx+20]
	call	_xmlDictReference
	add	esp, 4
$LN4@xmlXPathNe:

; 6255 :     }
; 6256 : 
; 6257 :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 6258 : }

	pop	ebp
	ret	0
_xmlXPathNewParserContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisteredVariablesCleanup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathRegisteredVariablesCleanup PROC		; COMDAT

; 5123 : xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathRe

; 5124 :     if (ctxt == NULL)
; 5125 : 	return;
; 5126 : 
; 5127 :     xmlHashFree(ctxt->varHash, xmlXPathFreeObjectEntry);

	push	OFFSET _xmlXPathFreeObjectEntry
	push	DWORD PTR [esi+16]
	call	_xmlHashFree
	add	esp, 8

; 5128 :     ctxt->varHash = NULL;

	mov	DWORD PTR [esi+16], 0
$LN1@xmlXPathRe:
	pop	esi

; 5129 : }

	pop	ebp
	ret	0
_xmlXPathRegisteredVariablesCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathVariableLookupNS
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_ns_uri$ = 16						; size = 4
_xmlXPathVariableLookupNS PROC				; COMDAT

; 5095 : 			 const xmlChar *ns_uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlXPathVa

; 5096 :     if (ctxt == NULL)
; 5097 : 	return(NULL);
; 5098 : 
; 5099 :     if (ctxt->varLookupFunc != NULL) {

	mov	eax, DWORD PTR [esi+92]
	mov	edi, DWORD PTR _name$[ebp]
	test	eax, eax
	je	SHORT $LN4@xmlXPathVa

; 5100 : 	xmlXPathObjectPtr ret;
; 5101 : 
; 5102 : 	ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)

	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	DWORD PTR [esi+96]
	call	eax
	add	esp, 12					; 0000000cH

; 5103 : 	        (ctxt->varLookupData, name, ns_uri);
; 5104 : 	if (ret != NULL) return(ret);

	test	eax, eax
	jne	SHORT $LN1@xmlXPathVa
$LN4@xmlXPathVa:

; 5105 :     }
; 5106 : 
; 5107 :     if (ctxt->varHash == NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@xmlXPathVa

; 5108 : 	return(NULL);
; 5109 :     if (name == NULL)

	test	edi, edi
	je	SHORT $LN8@xmlXPathVa

; 5111 : 
; 5112 :     return(xmlXPathCacheObjectCopy(ctxt, (xmlXPathObjectPtr)

	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashLookup2
	push	eax
	push	esi
	call	_xmlXPathCacheObjectCopy
	add	esp, 20					; 00000014H
	pop	edi

; 5113 : 		xmlHashLookup2(ctxt->varHash, name, ns_uri)));
; 5114 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathVa:

; 5110 : 	return(NULL);

	xor	eax, eax
$LN1@xmlXPathVa:
	pop	edi

; 5113 : 		xmlHashLookup2(ctxt->varHash, name, ns_uri)));
; 5114 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathVariableLookupNS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathVariableLookup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPathVariableLookup PROC				; COMDAT

; 5068 : xmlXPathVariableLookup(xmlXPathContextPtr ctxt, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlXPathVa

; 5080 : }

	pop	ebp
	ret	0
$LN2@xmlXPathVa:

; 5069 :     if (ctxt == NULL)
; 5070 : 	return(NULL);
; 5071 : 
; 5072 :     if (ctxt->varLookupFunc != NULL) {

	mov	ecx, DWORD PTR [eax+92]
	push	0
	push	DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathVa

; 5073 : 	xmlXPathObjectPtr ret;
; 5074 : 
; 5075 : 	ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)

	push	DWORD PTR [eax+96]
	call	ecx

; 5080 : }

	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
$LN3@xmlXPathVa:

; 5076 : 	        (ctxt->varLookupData, name, NULL);
; 5077 : 	return(ret);
; 5078 :     }
; 5079 :     return(xmlXPathVariableLookupNS(ctxt, name, NULL));

	push	eax
	call	_xmlXPathVariableLookupNS

; 5080 : }

	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
_xmlXPathVariableLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisteredFuncsCleanup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathRegisteredFuncsCleanup PROC			; COMDAT

; 4977 : xmlXPathRegisteredFuncsCleanup(xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathRe

; 4978 :     if (ctxt == NULL)
; 4979 : 	return;
; 4980 : 
; 4981 :     xmlHashFree(ctxt->funcHash, NULL);

	push	0
	push	DWORD PTR [esi+40]
	call	_xmlHashFree
	add	esp, 8

; 4982 :     ctxt->funcHash = NULL;

	mov	DWORD PTR [esi+40], 0
$LN1@xmlXPathRe:
	pop	esi

; 4983 : }

	pop	ebp
	ret	0
_xmlXPathRegisteredFuncsCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFunctionLookupNS
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_ns_uri$ = 16						; size = 4
_xmlXPathFunctionLookupNS PROC				; COMDAT

; 4944 : 			 const xmlChar *ns_uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlXPathFu

; 4945 :     xmlXPathFunction ret;
; 4946 : 
; 4947 :     if (ctxt == NULL)
; 4948 : 	return(NULL);
; 4949 :     if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlXPathFu

; 4950 : 	return(NULL);
; 4951 : 
; 4952 :     if (ctxt->funcLookupFunc != NULL) {

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN5@xmlXPathFu

; 4953 : 	xmlXPathFuncLookupFunc f;
; 4954 : 
; 4955 : 	f = ctxt->funcLookupFunc;
; 4956 : 	ret = f(ctxt->funcLookupData, name, ns_uri);

	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	DWORD PTR [esi+116]
	call	eax
	add	esp, 12					; 0000000cH

; 4957 : 	if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlXPathFu
$LN5@xmlXPathFu:

; 4958 : 	    return(ret);
; 4959 :     }
; 4960 : 
; 4961 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN8@xmlXPathFu

; 4963 : 
; 4964 : XML_IGNORE_PEDANTIC_WARNINGS
; 4965 :     ret = (xmlXPathFunction) xmlHashLookup2(ctxt->funcHash, name, ns_uri);

	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	pop	edi

; 4966 : XML_POP_WARNINGS
; 4967 :     return(ret);
; 4968 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathFu:

; 4962 : 	return(NULL);

	xor	eax, eax
$LN1@xmlXPathFu:
	pop	edi

; 4966 : XML_POP_WARNINGS
; 4967 :     return(ret);
; 4968 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathFunctionLookupNS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFunctionLookup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPathFunctionLookup PROC				; COMDAT

; 4915 : xmlXPathFunctionLookup(xmlXPathContextPtr ctxt, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlXPathFu

; 4916 :     if (ctxt == NULL)
; 4917 : 	return (NULL);

	xor	eax, eax
	pop	esi

; 4929 : }

	pop	ebp
	ret	0
$LN2@xmlXPathFu:

; 4918 : 
; 4919 :     if (ctxt->funcLookupFunc != NULL) {

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN4@xmlXPathFu

; 4920 : 	xmlXPathFunction ret;
; 4921 : 	xmlXPathFuncLookupFunc f;
; 4922 : 
; 4923 : 	f = ctxt->funcLookupFunc;
; 4924 : 	ret = f(ctxt->funcLookupData, name, NULL);

	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+116]
	call	eax
	add	esp, 12					; 0000000cH

; 4925 : 	if (ret != NULL)

	test	eax, eax
	jne	SHORT $LN1@xmlXPathFu
$LN4@xmlXPathFu:

; 4926 : 	    return(ret);
; 4927 :     }
; 4928 :     return(xmlXPathFunctionLookupNS(ctxt, name, NULL));

	push	0
	push	DWORD PTR _name$[ebp]
	push	esi
	call	_xmlXPathFunctionLookupNS
	add	esp, 12					; 0000000cH
$LN1@xmlXPathFu:
	pop	esi

; 4929 : }

	pop	ebp
	ret	0
_xmlXPathFunctionLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterVariableNS
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_ns_uri$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlXPathRegisterVariableNS PROC			; COMDAT

; 5023 : 			   xmlXPathObjectPtr value) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlXPathRe

; 5024 :     if (ctxt == NULL)
; 5025 : 	return(-1);
; 5026 :     if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlXPathRe

; 5027 : 	return(-1);
; 5028 : 
; 5029 :     if (ctxt->varHash == NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jne	SHORT $LN10@xmlXPathRe

; 5030 : 	ctxt->varHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 5031 :     if (ctxt->varHash == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlXPathRe
$LN10@xmlXPathRe:

; 5033 :     if (value == NULL)

	mov	ecx, DWORD PTR _value$[ebp]
	push	OFFSET _xmlXPathFreeObjectEntry
	test	ecx, ecx
	jne	SHORT $LN6@xmlXPathRe

; 5034 :         return(xmlHashRemoveEntry2(ctxt->varHash, name, ns_uri,

	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashRemoveEntry2
	add	esp, 16					; 00000010H
	pop	edi

; 5037 : 			       (void *) value, xmlXPathFreeObjectEntry));
; 5038 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathRe:

; 5035 : 	                           xmlXPathFreeObjectEntry));
; 5036 :     return(xmlHashUpdateEntry2(ctxt->varHash, name, ns_uri,

	push	ecx
	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashUpdateEntry2
	add	esp, 20					; 00000014H
	pop	edi

; 5037 : 			       (void *) value, xmlXPathFreeObjectEntry));
; 5038 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathRe:
	pop	edi

; 5032 : 	return(-1);

	or	eax, -1

; 5037 : 			       (void *) value, xmlXPathFreeObjectEntry));
; 5038 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathRegisterVariableNS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterVariable
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_xmlXPathRegisterVariable PROC				; COMDAT

; 5004 : 			 xmlXPathObjectPtr value) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _value$[ebp]
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathRegisterVariableNS
	add	esp, 16					; 00000010H

; 5005 :     return(xmlXPathRegisterVariableNS(ctxt, name, NULL, value));
; 5006 : }

	pop	ebp
	ret	0
_xmlXPathRegisterVariable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterFuncNS
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_ns_uri$ = 16						; size = 4
_f$ = 20						; size = 4
_xmlXPathRegisterFuncNS PROC				; COMDAT

; 4869 : 		       const xmlChar *ns_uri, xmlXPathFunction f) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlXPathRe

; 4870 :     if (ctxt == NULL)
; 4871 : 	return(-1);
; 4872 :     if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	SHORT $LN8@xmlXPathRe

; 4873 : 	return(-1);
; 4874 : 
; 4875 :     if (ctxt->funcHash == NULL)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN10@xmlXPathRe

; 4876 : 	ctxt->funcHash = xmlHashCreate(0);

	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+40], eax

; 4877 :     if (ctxt->funcHash == NULL)

	test	eax, eax
	je	SHORT $LN8@xmlXPathRe
$LN10@xmlXPathRe:

; 4879 :     if (f == NULL)

	mov	ecx, DWORD PTR _f$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@xmlXPathRe

; 4880 :         return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));

	push	ecx
	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashRemoveEntry2
	add	esp, 16					; 00000010H
	pop	edi

; 4883 : XML_POP_WARNINGS
; 4884 : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathRe:

; 4881 : XML_IGNORE_PEDANTIC_WARNINGS
; 4882 :     return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));

	push	ecx
	push	DWORD PTR _ns_uri$[ebp]
	push	edi
	push	eax
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H
	pop	edi

; 4883 : XML_POP_WARNINGS
; 4884 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@xmlXPathRe:
	pop	edi

; 4878 : 	return(-1);

	or	eax, -1

; 4883 : XML_POP_WARNINGS
; 4884 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathRegisterFuncNS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterFunc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_f$ = 16						; size = 4
_xmlXPathRegisterFunc PROC				; COMDAT

; 4852 : 		     xmlXPathFunction f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _f$[ebp]
	push	0
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathRegisterFuncNS
	add	esp, 16					; 00000010H

; 4853 :     return(xmlXPathRegisterFuncNS(ctxt, name, NULL, f));
; 4854 : }

	pop	ebp
	ret	0
_xmlXPathRegisterFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisteredNsCleanup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathRegisteredNsCleanup PROC			; COMDAT

; 5205 : xmlXPathRegisteredNsCleanup(xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathRe

; 5206 :     if (ctxt == NULL)
; 5207 : 	return;
; 5208 : 
; 5209 :     xmlHashFree(ctxt->nsHash, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	push	DWORD PTR [esi+88]
	call	_xmlHashFree
	add	esp, 8

; 5210 :     ctxt->nsHash = NULL;

	mov	DWORD PTR [esi+88], 0
$LN1@xmlXPathRe:
	pop	esi

; 5211 : }

	pop	ebp
	ret	0
_xmlXPathRegisteredNsCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNsLookup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlXPathNsLookup PROC					; COMDAT

; 5174 : xmlXPathNsLookup(xmlXPathContextPtr ctxt, const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN16@xmlXPathNs

; 5175 :     if (ctxt == NULL)
; 5176 : 	return(NULL);
; 5177 :     if (prefix == NULL)

	mov	ebx, DWORD PTR _prefix$[ebp]
	test	ebx, ebx
	je	SHORT $LN16@xmlXPathNs

; 5179 : 
; 5180 : #ifdef XML_XML_NAMESPACE
; 5181 :     if (xmlStrEqual(prefix, (const xmlChar *) "xml"))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlXPathNs

; 5182 : 	return(XML_XML_NAMESPACE);

	pop	edi
	mov	eax, OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@

; 5196 : }

	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlXPathNs:

; 5183 : #endif
; 5184 : 
; 5185 :     if (ctxt->namespaces != NULL) {

	cmp	DWORD PTR [edi+56], 0
	push	esi
	je	SHORT $LN17@xmlXPathNs

; 5186 : 	int i;
; 5187 : 
; 5188 : 	for (i = 0;i < ctxt->nsNr;i++) {

	xor	esi, esi
	cmp	DWORD PTR [edi+60], esi
	jle	SHORT $LN17@xmlXPathNs
$LL4@xmlXPathNs:

; 5189 : 	    if ((ctxt->namespaces[i] != NULL) &&

	mov	eax, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN2@xmlXPathNs
	push	ebx
	push	DWORD PTR [eax+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlXPathNs
$LN2@xmlXPathNs:

; 5186 : 	int i;
; 5187 : 
; 5188 : 	for (i = 0;i < ctxt->nsNr;i++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+60]
	jl	SHORT $LL4@xmlXPathNs
$LN17@xmlXPathNs:

; 5192 : 	}
; 5193 :     }
; 5194 : 
; 5195 :     return((const xmlChar *) xmlHashLookup(ctxt->nsHash, prefix));

	push	ebx
	push	DWORD PTR [edi+88]
	call	_xmlHashLookup
	add	esp, 8
	pop	esi
	pop	edi

; 5196 : }

	pop	ebx
	pop	ebp
	ret	0
$LN12@xmlXPathNs:

; 5190 : 		(xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))
; 5191 : 		return(ctxt->namespaces[i]->href);

	mov	eax, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi
	pop	edi

; 5196 : }

	pop	ebx
	mov	eax, DWORD PTR [eax+8]
	pop	ebp
	ret	0
$LN16@xmlXPathNs:
	pop	edi

; 5178 : 	return(NULL);

	xor	eax, eax

; 5196 : }

	pop	ebx
	pop	ebp
	ret	0
_xmlXPathNsLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterNs
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_ns_uri$ = 16						; size = 4
_xmlXPathRegisterNs PROC				; COMDAT

; 5144 : 			   const xmlChar *ns_uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN9@xmlXPathRe

; 5145 :     if (ctxt == NULL)
; 5146 : 	return(-1);
; 5147 :     if (prefix == NULL)

	mov	edi, DWORD PTR _prefix$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlXPathRe

; 5148 : 	return(-1);
; 5149 :     if (prefix[0] == 0)

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN9@xmlXPathRe

; 5150 : 	return(-1);
; 5151 : 
; 5152 :     if (ctxt->nsHash == NULL)

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	jne	SHORT $LN11@xmlXPathRe

; 5153 : 	ctxt->nsHash = xmlHashCreate(10);

	push	10					; 0000000aH
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR [esi+88], eax

; 5154 :     if (ctxt->nsHash == NULL)

	test	eax, eax
	je	SHORT $LN9@xmlXPathRe
$LN11@xmlXPathRe:

; 5156 :     if (ns_uri == NULL)

	mov	ecx, DWORD PTR _ns_uri$[ebp]
	push	OFFSET _xmlHashDefaultDeallocator
	test	ecx, ecx
	jne	SHORT $LN7@xmlXPathRe

; 5157 :         return(xmlHashRemoveEntry(ctxt->nsHash, prefix,

	push	edi
	push	eax
	call	_xmlHashRemoveEntry
	add	esp, 12					; 0000000cH
	pop	edi

; 5160 : 			      xmlHashDefaultDeallocator));
; 5161 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlXPathRe:

; 5158 : 	                          xmlHashDefaultDeallocator));
; 5159 :     return(xmlHashUpdateEntry(ctxt->nsHash, prefix, (void *) xmlStrdup(ns_uri),

	mov	esi, DWORD PTR [esi+88]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	push	eax
	push	edi
	push	esi
	call	_xmlHashUpdateEntry
	add	esp, 16					; 00000010H
	pop	edi

; 5160 : 			      xmlHashDefaultDeallocator));
; 5161 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlXPathRe:
	pop	edi

; 5155 : 	return(-1);

	or	eax, -1

; 5160 : 			      xmlHashDefaultDeallocator));
; 5161 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathRegisterNs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathTrailing
_TEXT	SEGMENT
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathTrailing PROC					; COMDAT

; 4823 : xmlXPathTrailing (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nodes2$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathTr

; 4824 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@xmlXPathTr
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN3@xmlXPathTr

; 4826 :     if (xmlXPathNodeSetIsEmpty(nodes1))

	push	edi
	mov	edi, DWORD PTR _nodes1$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlXPathTr
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN5@xmlXPathTr
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN5@xmlXPathTr

; 4828 :     xmlXPathNodeSetSort(nodes1);

	push	edi
	call	_xmlXPathNodeSetSort

; 4829 :     xmlXPathNodeSetSort(nodes2);

	push	esi
	call	_xmlXPathNodeSetSort
	add	esp, 8

; 4830 :     return(xmlXPathNodeTrailingSorted(nodes1,

	cmp	DWORD PTR [esi], 0
	jle	SHORT $LN7@xmlXPathTr
	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax]
	push	eax
	push	edi
	call	_xmlXPathNodeTrailingSorted
	add	esp, 8
	pop	edi
	pop	esi

; 4831 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4832 : }

	pop	ebp
	ret	0
$LN7@xmlXPathTr:

; 4830 :     return(xmlXPathNodeTrailingSorted(nodes1,

	xor	eax, eax
	push	eax
	push	edi
	call	_xmlXPathNodeTrailingSorted
	add	esp, 8
	pop	edi
	pop	esi

; 4831 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4832 : }

	pop	ebp
	ret	0
$LN5@xmlXPathTr:

; 4827 : 	return(xmlXPathNodeSetCreate(NULL));

	push	0
	call	_xmlXPathNodeSetCreate
	add	esp, 4
	pop	edi
	pop	esi

; 4831 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4832 : }

	pop	ebp
	ret	0
$LN3@xmlXPathTr:

; 4825 : 	return(nodes1);

	mov	eax, DWORD PTR _nodes1$[ebp]
	pop	esi

; 4831 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4832 : }

	pop	ebp
	ret	0
_xmlXPathTrailing ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeTrailing
_TEXT	SEGMENT
_nodes$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXPathNodeTrailing PROC				; COMDAT

; 4783 : xmlXPathNodeTrailing (xmlNodeSetPtr nodes, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 3422 :     if (set == NULL)

	mov	esi, DWORD PTR _nodes$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathNo

; 3423 : 	return;
; 3424 : 
; 3425 : #ifndef WITH_TIM_SORT
; 3426 :     /*
; 3427 :      * Use the old Shell's sort implementation to sort the node-set
; 3428 :      * Timsort ought to be quite faster
; 3429 :      */
; 3430 :     len = set->nodeNr;
; 3431 :     for (incr = len / 2; incr > 0; incr /= 2) {
; 3432 : 	for (i = incr; i < len; i++) {
; 3433 : 	    j = i - incr;
; 3434 : 	    while (j >= 0) {
; 3435 : #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
; 3436 : 		if (xmlXPathCmpNodesExt(set->nodeTab[j],
; 3437 : 			set->nodeTab[j + incr]) == -1)
; 3438 : #else
; 3439 : 		if (xmlXPathCmpNodes(set->nodeTab[j],
; 3440 : 			set->nodeTab[j + incr]) == -1)
; 3441 : #endif
; 3442 : 		{
; 3443 : 		    tmp = set->nodeTab[j];
; 3444 : 		    set->nodeTab[j] = set->nodeTab[j + incr];
; 3445 : 		    set->nodeTab[j + incr] = tmp;
; 3446 : 		    j -= incr;
; 3447 : 		} else
; 3448 : 		    break;
; 3449 : 	    }
; 3450 : 	}
; 3451 :     }
; 3452 : #else /* WITH_TIM_SORT */
; 3453 :     libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);

	push	DWORD PTR [esi]
	push	DWORD PTR [esi+8]
	call	_libxml_domnode_tim_sort
	add	esp, 8
$LN3@xmlXPathNo:

; 4784 :     xmlXPathNodeSetSort(nodes);
; 4785 :     return(xmlXPathNodeTrailingSorted(nodes, node));

	push	DWORD PTR _node$[ebp]
	push	esi
	call	_xmlXPathNodeTrailingSorted
	add	esp, 8
	pop	esi

; 4786 : }

	pop	ebp
	ret	0
_xmlXPathNodeTrailing ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathTrailingSorted
_TEXT	SEGMENT
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathTrailingSorted PROC				; COMDAT

; 4801 : xmlXPathTrailingSorted (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _nodes2$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathTr

; 4802 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathTr
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN3@xmlXPathTr

; 4804 :     return(xmlXPathNodeTrailingSorted(nodes1,

	test	ecx, ecx
	jle	SHORT $LN5@xmlXPathTr
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _nodes2$[ebp], eax

; 4805 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4806 : }

	pop	ebp

; 4804 :     return(xmlXPathNodeTrailingSorted(nodes1,

	jmp	_xmlXPathNodeTrailingSorted
$LN5@xmlXPathTr:
	xor	eax, eax
	mov	DWORD PTR _nodes2$[ebp], eax

; 4805 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4806 : }

	pop	ebp

; 4804 :     return(xmlXPathNodeTrailingSorted(nodes1,

	jmp	_xmlXPathNodeTrailingSorted
$LN3@xmlXPathTr:

; 4803 : 	return(nodes1);

	mov	eax, DWORD PTR _nodes1$[ebp]

; 4805 : 				      xmlXPathNodeSetItem(nodes2, 0)));
; 4806 : }

	pop	ebp
	ret	0
_xmlXPathTrailingSorted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeTrailingSorted
_TEXT	SEGMENT
_nodes$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXPathNodeTrailingSorted PROC			; COMDAT

; 4741 : xmlXPathNodeTrailingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlXPathNo

; 4742 :     int i, l;
; 4743 :     xmlNodePtr cur;
; 4744 :     xmlNodeSetPtr ret;
; 4745 : 
; 4746 :     if (node == NULL)
; 4747 : 	return(nodes);

	mov	eax, DWORD PTR _nodes$[ebp]
	pop	esi

; 4762 : 	    break;
; 4763 :     }
; 4764 :     xmlXPathNodeSetSort(ret);	/* bug 413451 */
; 4765 :     return(ret);
; 4766 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNo:
	push	ebx

; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 3531 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN17@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4748 : 
; 4749 :     ret = xmlXPathNodeSetCreate(NULL);
; 4750 :     if (ret == NULL)
; 4751 :         return(ret);

	xor	eax, eax
	pop	ebx
	pop	esi

; 4762 : 	    break;
; 4763 :     }
; 4764 :     xmlXPathNodeSetSort(ret);	/* bug 413451 */
; 4765 :     return(ret);
; 4766 : }

	pop	ebp
	ret	0
$LN17@xmlXPathNo:
	push	edi

; 4752 :     if (xmlXPathNodeSetIsEmpty(nodes) ||

	mov	edi, DWORD PTR _nodes$[ebp]
	xorps	xmm0, xmm0

; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));

	movq	QWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+8], 0

; 4752 :     if (xmlXPathNodeSetIsEmpty(nodes) ||

	test	edi, edi
	je	SHORT $LN8@xmlXPathNo
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN8@xmlXPathNo
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN8@xmlXPathNo
	push	esi
	push	edi
	call	_xmlXPathNodeSetContains
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlXPathNo

; 4755 : 
; 4756 :     l = xmlXPathNodeSetGetLength(nodes);

	mov	esi, DWORD PTR [edi]

; 4757 :     for (i = l - 1; i >= 0; i--) {

	sub	esi, 1
	js	SHORT $LN51@xmlXPathNo
$LL4@xmlXPathNo:

; 4758 : 	cur = xmlXPathNodeSetItem(nodes, i);

	test	esi, esi
	js	SHORT $LN14@xmlXPathNo
	cmp	esi, DWORD PTR [edi]
	jge	SHORT $LN14@xmlXPathNo
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN15@xmlXPathNo
$LN14@xmlXPathNo:
	xor	eax, eax
$LN15@xmlXPathNo:

; 4759 : 	if (cur == node)

	cmp	eax, DWORD PTR _node$[ebp]
	je	SHORT $LN51@xmlXPathNo

; 4760 : 	    break;
; 4761 : 	if (xmlXPathNodeSetAddUnique(ret, cur) < 0)

	push	eax
	push	ebx
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	SHORT $LN51@xmlXPathNo

; 4757 :     for (i = l - 1; i >= 0; i--) {

	sub	esi, 1
	jns	SHORT $LL4@xmlXPathNo
$LN51@xmlXPathNo:

; 3453 :     libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);

	push	DWORD PTR [ebx]
	push	DWORD PTR [ebx+8]
	call	_libxml_domnode_tim_sort
	add	esp, 8
$LN8@xmlXPathNo:
	pop	edi

; 4753 : 	(!xmlXPathNodeSetContains(nodes, node)))
; 4754 : 	return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 4762 : 	    break;
; 4763 :     }
; 4764 :     xmlXPathNodeSetSort(ret);	/* bug 413451 */
; 4765 :     return(ret);
; 4766 : }

	pop	ebp
	ret	0
_xmlXPathNodeTrailingSorted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathLeading
_TEXT	SEGMENT
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathLeading PROC					; COMDAT

; 4717 : xmlXPathLeading (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nodes2$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathLe

; 4718 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@xmlXPathLe
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN3@xmlXPathLe

; 4720 :     if (xmlXPathNodeSetIsEmpty(nodes1))

	push	edi
	mov	edi, DWORD PTR _nodes1$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlXPathLe
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN5@xmlXPathLe
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN5@xmlXPathLe

; 4722 :     xmlXPathNodeSetSort(nodes1);

	push	edi
	call	_xmlXPathNodeSetSort

; 4723 :     xmlXPathNodeSetSort(nodes2);

	push	esi
	call	_xmlXPathNodeSetSort
	add	esp, 8

; 4724 :     return(xmlXPathNodeLeadingSorted(nodes1,

	cmp	DWORD PTR [esi], 1
	jle	SHORT $LN7@xmlXPathLe
	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edi
	call	_xmlXPathNodeLeadingSorted
	add	esp, 8
	pop	edi
	pop	esi

; 4725 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4726 : }

	pop	ebp
	ret	0
$LN7@xmlXPathLe:

; 4724 :     return(xmlXPathNodeLeadingSorted(nodes1,

	xor	eax, eax
	push	eax
	push	edi
	call	_xmlXPathNodeLeadingSorted
	add	esp, 8
	pop	edi
	pop	esi

; 4725 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4726 : }

	pop	ebp
	ret	0
$LN5@xmlXPathLe:

; 4721 : 	return(xmlXPathNodeSetCreate(NULL));

	push	0
	call	_xmlXPathNodeSetCreate
	add	esp, 4
	pop	edi
	pop	esi

; 4725 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4726 : }

	pop	ebp
	ret	0
$LN3@xmlXPathLe:

; 4719 : 	return(nodes1);

	mov	eax, DWORD PTR _nodes1$[ebp]
	pop	esi

; 4725 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4726 : }

	pop	ebp
	ret	0
_xmlXPathLeading ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeLeading
_TEXT	SEGMENT
_nodes$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXPathNodeLeading PROC				; COMDAT

; 4677 : xmlXPathNodeLeading (xmlNodeSetPtr nodes, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 3422 :     if (set == NULL)

	mov	esi, DWORD PTR _nodes$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathNo

; 3423 : 	return;
; 3424 : 
; 3425 : #ifndef WITH_TIM_SORT
; 3426 :     /*
; 3427 :      * Use the old Shell's sort implementation to sort the node-set
; 3428 :      * Timsort ought to be quite faster
; 3429 :      */
; 3430 :     len = set->nodeNr;
; 3431 :     for (incr = len / 2; incr > 0; incr /= 2) {
; 3432 : 	for (i = incr; i < len; i++) {
; 3433 : 	    j = i - incr;
; 3434 : 	    while (j >= 0) {
; 3435 : #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
; 3436 : 		if (xmlXPathCmpNodesExt(set->nodeTab[j],
; 3437 : 			set->nodeTab[j + incr]) == -1)
; 3438 : #else
; 3439 : 		if (xmlXPathCmpNodes(set->nodeTab[j],
; 3440 : 			set->nodeTab[j + incr]) == -1)
; 3441 : #endif
; 3442 : 		{
; 3443 : 		    tmp = set->nodeTab[j];
; 3444 : 		    set->nodeTab[j] = set->nodeTab[j + incr];
; 3445 : 		    set->nodeTab[j + incr] = tmp;
; 3446 : 		    j -= incr;
; 3447 : 		} else
; 3448 : 		    break;
; 3449 : 	    }
; 3450 : 	}
; 3451 :     }
; 3452 : #else /* WITH_TIM_SORT */
; 3453 :     libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);

	push	DWORD PTR [esi]
	push	DWORD PTR [esi+8]
	call	_libxml_domnode_tim_sort
	add	esp, 8
$LN3@xmlXPathNo:

; 4678 :     xmlXPathNodeSetSort(nodes);
; 4679 :     return(xmlXPathNodeLeadingSorted(nodes, node));

	push	DWORD PTR _node$[ebp]
	push	esi
	call	_xmlXPathNodeLeadingSorted
	add	esp, 8
	pop	esi

; 4680 : }

	pop	ebp
	ret	0
_xmlXPathNodeLeading ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathLeadingSorted
_TEXT	SEGMENT
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathLeadingSorted PROC				; COMDAT

; 4695 : xmlXPathLeadingSorted (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _nodes2$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathLe

; 4696 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathLe
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN3@xmlXPathLe

; 4698 :     return(xmlXPathNodeLeadingSorted(nodes1,

	cmp	ecx, 1
	jle	SHORT $LN5@xmlXPathLe
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _nodes2$[ebp], eax

; 4699 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4700 : }

	pop	ebp

; 4698 :     return(xmlXPathNodeLeadingSorted(nodes1,

	jmp	_xmlXPathNodeLeadingSorted
$LN5@xmlXPathLe:
	xor	eax, eax
	mov	DWORD PTR _nodes2$[ebp], eax

; 4699 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4700 : }

	pop	ebp

; 4698 :     return(xmlXPathNodeLeadingSorted(nodes1,

	jmp	_xmlXPathNodeLeadingSorted
$LN3@xmlXPathLe:

; 4697 : 	return(nodes1);

	mov	eax, DWORD PTR _nodes1$[ebp]

; 4699 : 				     xmlXPathNodeSetItem(nodes2, 1)));
; 4700 : }

	pop	ebp
	ret	0
_xmlXPathLeadingSorted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeLeadingSorted
_TEXT	SEGMENT
_l$1$ = -4						; size = 4
_nodes$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlXPathNodeLeadingSorted PROC				; COMDAT

; 4636 : xmlXPathNodeLeadingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlXPathNo

; 4637 :     int i, l;
; 4638 :     xmlNodePtr cur;
; 4639 :     xmlNodeSetPtr ret;
; 4640 : 
; 4641 :     if (node == NULL)
; 4642 : 	return(nodes);

	mov	eax, DWORD PTR _nodes$[ebp]
	pop	esi

; 4657 : 	    break;
; 4658 :     }
; 4659 :     return(ret);
; 4660 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathNo:
	push	ebx

; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 3531 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN17@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4643 : 
; 4644 :     ret = xmlXPathNodeSetCreate(NULL);
; 4645 :     if (ret == NULL)
; 4646 :         return(ret);

	xor	eax, eax
	pop	ebx
	pop	esi

; 4657 : 	    break;
; 4658 :     }
; 4659 :     return(ret);
; 4660 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXPathNo:
	push	edi

; 4647 :     if (xmlXPathNodeSetIsEmpty(nodes) ||

	mov	edi, DWORD PTR _nodes$[ebp]
	xorps	xmm0, xmm0

; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));

	movq	QWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+8], 0

; 4647 :     if (xmlXPathNodeSetIsEmpty(nodes) ||

	test	edi, edi
	je	SHORT $LN48@xmlXPathNo
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN48@xmlXPathNo
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN48@xmlXPathNo
	push	esi
	push	edi
	call	_xmlXPathNodeSetContains
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@xmlXPathNo

; 4650 : 
; 4651 :     l = xmlXPathNodeSetGetLength(nodes);

	mov	eax, DWORD PTR [edi]

; 4652 :     for (i = 0; i < l; i++) {

	xor	esi, esi
	mov	DWORD PTR _l$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN48@xmlXPathNo
	npad	6
$LL4@xmlXPathNo:

; 4653 : 	cur = xmlXPathNodeSetItem(nodes, i);

	test	esi, esi
	js	SHORT $LN14@xmlXPathNo
	cmp	esi, DWORD PTR [edi]
	jge	SHORT $LN14@xmlXPathNo
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN15@xmlXPathNo
$LN14@xmlXPathNo:
	xor	eax, eax
$LN15@xmlXPathNo:

; 4654 : 	if (cur == node)

	cmp	eax, DWORD PTR _node$[ebp]
	je	SHORT $LN48@xmlXPathNo

; 4655 : 	    break;
; 4656 : 	if (xmlXPathNodeSetAddUnique(ret, cur) < 0)

	push	eax
	push	ebx
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	SHORT $LN48@xmlXPathNo

; 4652 :     for (i = 0; i < l; i++) {

	inc	esi
	cmp	esi, DWORD PTR _l$1$[ebp]
	jl	SHORT $LL4@xmlXPathNo
$LN48@xmlXPathNo:

; 4648 : 	(!xmlXPathNodeSetContains(nodes, node)))
; 4649 : 	return(ret);

	pop	edi
	mov	eax, ebx
	pop	ebx
	pop	esi

; 4657 : 	    break;
; 4658 :     }
; 4659 :     return(ret);
; 4660 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathNodeLeadingSorted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathHasSameNodes
_TEXT	SEGMENT
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathHasSameNodes PROC				; COMDAT

; 4606 : xmlXPathHasSameNodes (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _nodes1$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlXPathHa

; 4607 :     int i, l;
; 4608 :     xmlNodePtr cur;
; 4609 : 
; 4610 :     if (xmlXPathNodeSetIsEmpty(nodes1) ||

	mov	ebx, DWORD PTR [edi]
	test	ebx, ebx
	je	SHORT $LN7@xmlXPathHa
	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN7@xmlXPathHa
	mov	ecx, DWORD PTR _nodes2$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPathHa
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@xmlXPathHa
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN7@xmlXPathHa

; 4611 : 	xmlXPathNodeSetIsEmpty(nodes2))
; 4612 : 	return(0);
; 4613 : 
; 4614 :     l = xmlXPathNodeSetGetLength(nodes1);
; 4615 :     for (i = 0; i < l; i++) {

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN7@xmlXPathHa
	npad	5
$LL4@xmlXPathHa:

; 4616 : 	cur = xmlXPathNodeSetItem(nodes1, i);

	test	esi, esi
	js	SHORT $LN12@xmlXPathHa
	cmp	esi, DWORD PTR [edi]
	jge	SHORT $LN12@xmlXPathHa
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN13@xmlXPathHa
$LN12@xmlXPathHa:
	xor	eax, eax
$LN13@xmlXPathHa:

; 4617 : 	if (xmlXPathNodeSetContains(nodes2, cur))

	push	eax
	push	ecx
	call	_xmlXPathNodeSetContains
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlXPathHa

; 4611 : 	xmlXPathNodeSetIsEmpty(nodes2))
; 4612 : 	return(0);
; 4613 : 
; 4614 :     l = xmlXPathNodeSetGetLength(nodes1);
; 4615 :     for (i = 0; i < l; i++) {

	mov	ecx, DWORD PTR _nodes2$[ebp]
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL4@xmlXPathHa
$LN7@xmlXPathHa:
	pop	edi

; 4618 : 	    return(1);
; 4619 :     }
; 4620 :     return(0);
; 4621 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN15@xmlXPathHa:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathHasSameNodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDistinct
_TEXT	SEGMENT
_nodes$ = 8						; size = 4
_xmlXPathDistinct PROC					; COMDAT

; 4586 : xmlXPathDistinct (xmlNodeSetPtr nodes) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nodes$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathDi

; 4587 :     if (xmlXPathNodeSetIsEmpty(nodes))

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@xmlXPathDi
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathDi

; 3453 :     libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);

	push	eax
	push	ecx
	call	_libxml_domnode_tim_sort

; 4589 : 
; 4590 :     xmlXPathNodeSetSort(nodes);
; 4591 :     return(xmlXPathDistinctSorted(nodes));

	push	esi
	call	_xmlXPathDistinctSorted
	add	esp, 12					; 0000000cH
	pop	esi

; 4592 : }

	pop	ebp
	ret	0
$LN3@xmlXPathDi:

; 4588 : 	return(nodes);

	mov	eax, esi
	pop	esi

; 4592 : }

	pop	ebp
	ret	0
_xmlXPathDistinct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDistinctSorted
_TEXT	SEGMENT
_l$1$ = -12						; size = 4
_ret$1$ = -8						; size = 4
_cur$1$ = -4						; size = 4
_hash$1$ = 8						; size = 4
_nodes$ = 8						; size = 4
_xmlXPathDistinctSorted PROC				; COMDAT

; 4543 : xmlXPathDistinctSorted (xmlNodeSetPtr nodes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _nodes$[ebp]
	test	ebx, ebx
	je	$LN6@xmlXPathDi

; 4544 :     xmlNodeSetPtr ret;
; 4545 :     xmlHashTablePtr hash;
; 4546 :     int i, l;
; 4547 :     xmlChar * strval;
; 4548 :     xmlNodePtr cur;
; 4549 : 
; 4550 :     if (xmlXPathNodeSetIsEmpty(nodes))

	cmp	DWORD PTR [ebx], 0
	je	$LN6@xmlXPathDi
	cmp	DWORD PTR [ebx+8], 0
	je	$LN6@xmlXPathDi

; 4552 : 
; 4553 :     ret = xmlXPathNodeSetCreate(NULL);

	push	0
	call	_xmlXPathNodeSetCreate
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 4554 :     if (ret == NULL)

	test	eax, eax
	jne	SHORT $LN7@xmlXPathDi
	pop	ebx

; 4571 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathDi:
	push	esi
	push	edi

; 4555 :         return(ret);
; 4556 :     l = xmlXPathNodeSetGetLength(nodes);

	mov	edi, DWORD PTR [ebx]

; 4557 :     hash = xmlHashCreate (l);

	push	edi
	mov	DWORD PTR _l$1$[ebp], edi
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _hash$1$[ebp], eax

; 4558 :     for (i = 0; i < l; i++) {

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN20@xmlXPathDi
	npad	2
$LL4@xmlXPathDi:

; 4559 : 	cur = xmlXPathNodeSetItem(nodes, i);

	test	esi, esi
	js	SHORT $LN14@xmlXPathDi
	cmp	esi, DWORD PTR [ebx]
	jge	SHORT $LN14@xmlXPathDi
	mov	eax, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN25@xmlXPathDi
$LN14@xmlXPathDi:
	xor	eax, eax
$LN25@xmlXPathDi:

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	eax
	mov	DWORD PTR _cur$1$[ebp], eax
	call	_xmlNodeGetContent
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN17@xmlXPathDi

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	edi, eax
$LN17@xmlXPathDi:

; 4560 : 	strval = xmlXPathCastNodeToString(cur);
; 4561 : 	if (xmlHashLookup(hash, strval) == NULL) {

	push	edi
	push	DWORD PTR _hash$1$[ebp]
	call	_xmlHashLookup
	add	esp, 8
	push	edi
	test	eax, eax
	jne	SHORT $LN8@xmlXPathDi

; 4562 : 	    xmlHashAddEntry(hash, strval, strval);

	push	edi
	push	DWORD PTR _hash$1$[ebp]
	call	_xmlHashAddEntry

; 4563 : 	    if (xmlXPathNodeSetAddUnique(ret, cur) < 0)

	push	DWORD PTR _cur$1$[ebp]
	push	DWORD PTR _ret$1$[ebp]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 20					; 00000014H
	test	eax, eax
	js	SHORT $LN24@xmlXPathDi

; 4564 : 	        break;
; 4565 : 	} else {

	jmp	SHORT $LN2@xmlXPathDi
$LN8@xmlXPathDi:

; 4566 : 	    xmlFree(strval);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlXPathDi:

; 4558 :     for (i = 0; i < l; i++) {

	inc	esi
	cmp	esi, DWORD PTR _l$1$[ebp]
	jl	SHORT $LL4@xmlXPathDi
$LN24@xmlXPathDi:
	mov	eax, DWORD PTR _hash$1$[ebp]
$LN20@xmlXPathDi:

; 4567 : 	}
; 4568 :     }
; 4569 :     xmlHashFree(hash, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	push	eax
	call	_xmlHashFree

; 4570 :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 4571 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathDi:

; 4551 : 	return(nodes);

	mov	eax, ebx
	pop	ebx

; 4571 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDistinctSorted ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIntersection
_TEXT	SEGMENT
tv367 = -8						; size = 4
_ret$1$ = -4						; size = 4
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathIntersection PROC				; COMDAT

; 4508 : xmlXPathIntersection (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 3531 :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN18@xmlXPathIn

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 4509 :     xmlNodeSetPtr ret = xmlXPathNodeSetCreate(NULL);
; 4510 :     int i, l1;
; 4511 :     xmlNodePtr cur;
; 4512 : 
; 4513 :     if (ret == NULL)
; 4514 :         return(ret);

	xor	eax, eax

; 4526 : 	        break;
; 4527 : 	}
; 4528 :     }
; 4529 :     return(ret);
; 4530 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlXPathIn:
	push	ebx

; 4515 :     if (xmlXPathNodeSetIsEmpty(nodes1))

	mov	ebx, DWORD PTR _nodes1$[ebp]
	xorps	xmm0, xmm0

; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));

	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0

; 4515 :     if (xmlXPathNodeSetIsEmpty(nodes1))

	test	ebx, ebx
	je	SHORT $LN7@xmlXPathIn
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR tv367[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN7@xmlXPathIn
	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN7@xmlXPathIn

; 4517 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	mov	edx, DWORD PTR _nodes2$[ebp]
	test	edx, edx
	je	SHORT $LN7@xmlXPathIn
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@xmlXPathIn
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN7@xmlXPathIn

; 4518 : 	return(ret);
; 4519 : 
; 4520 :     l1 = xmlXPathNodeSetGetLength(nodes1);
; 4521 : 
; 4522 :     for (i = 0; i < l1; i++) {

	push	esi
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN49@xmlXPathIn
	push	edi
	npad	1
$LL4@xmlXPathIn:

; 4523 : 	cur = xmlXPathNodeSetItem(nodes1, i);

	test	esi, esi
	js	SHORT $LN15@xmlXPathIn
	cmp	esi, DWORD PTR [ebx]
	jge	SHORT $LN15@xmlXPathIn
	mov	eax, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN16@xmlXPathIn
$LN15@xmlXPathIn:
	xor	edi, edi
$LN16@xmlXPathIn:

; 4524 : 	if (xmlXPathNodeSetContains(nodes2, cur)) {

	push	edi
	push	edx
	call	_xmlXPathNodeSetContains
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlXPathIn

; 4525 : 	    if (xmlXPathNodeSetAddUnique(ret, cur) < 0)

	push	edi
	push	DWORD PTR _ret$1$[ebp]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	SHORT $LN48@xmlXPathIn
$LN2@xmlXPathIn:

; 4518 : 	return(ret);
; 4519 : 
; 4520 :     l1 = xmlXPathNodeSetGetLength(nodes1);
; 4521 : 
; 4522 :     for (i = 0; i < l1; i++) {

	mov	edx, DWORD PTR _nodes2$[ebp]
	inc	esi
	cmp	esi, DWORD PTR tv367[ebp]
	jl	SHORT $LL4@xmlXPathIn
$LN48@xmlXPathIn:
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi
$LN49@xmlXPathIn:
	pop	esi
$LN7@xmlXPathIn:

; 4516 : 	return(ret);

	pop	ebx

; 4526 : 	        break;
; 4527 : 	}
; 4528 :     }
; 4529 :     return(ret);
; 4530 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathIntersection ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDifference
_TEXT	SEGMENT
tv229 = -8						; size = 4
_ret$1$ = -4						; size = 4
_nodes1$ = 8						; size = 4
_nodes2$ = 12						; size = 4
_xmlXPathDifference PROC				; COMDAT

; 4472 : xmlXPathDifference (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _nodes2$[ebp]
	test	eax, eax
	je	$LN6@xmlXPathDi

; 4473 :     xmlNodeSetPtr ret;
; 4474 :     int i, l1;
; 4475 :     xmlNodePtr cur;
; 4476 : 
; 4477 :     if (xmlXPathNodeSetIsEmpty(nodes2))

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@xmlXPathDi
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@xmlXPathDi

; 4479 : 
; 4480 :     ret = xmlXPathNodeSetCreate(NULL);

	push	ebx
	push	0
	call	_xmlXPathNodeSetCreate

; 4481 :     if (xmlXPathNodeSetIsEmpty(nodes1))

	mov	ebx, DWORD PTR _nodes1$[ebp]
	add	esp, 4
	mov	ecx, eax
	mov	DWORD PTR _ret$1$[ebp], ecx
	test	ebx, ebx
	je	SHORT $LN8@xmlXPathDi
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR tv229[ebp], eax
	test	eax, eax
	je	SHORT $LN8@xmlXPathDi
	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN8@xmlXPathDi

; 4483 : 
; 4484 :     l1 = xmlXPathNodeSetGetLength(nodes1);
; 4485 : 
; 4486 :     for (i = 0; i < l1; i++) {

	push	esi
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN17@xmlXPathDi
	push	edi
$LL4@xmlXPathDi:

; 4487 : 	cur = xmlXPathNodeSetItem(nodes1, i);

	test	esi, esi
	js	SHORT $LN14@xmlXPathDi
	cmp	esi, DWORD PTR [ebx]
	jge	SHORT $LN14@xmlXPathDi
	mov	eax, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN15@xmlXPathDi
$LN14@xmlXPathDi:
	xor	edi, edi
$LN15@xmlXPathDi:

; 4488 : 	if (!xmlXPathNodeSetContains(nodes2, cur)) {

	push	edi
	push	DWORD PTR _nodes2$[ebp]
	call	_xmlXPathNodeSetContains
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlXPathDi

; 4489 : 	    if (xmlXPathNodeSetAddUnique(ret, cur) < 0)

	push	edi
	push	DWORD PTR _ret$1$[ebp]
	call	_xmlXPathNodeSetAddUnique
	add	esp, 8
	test	eax, eax
	js	SHORT $LN21@xmlXPathDi
$LN2@xmlXPathDi:

; 4483 : 
; 4484 :     l1 = xmlXPathNodeSetGetLength(nodes1);
; 4485 : 
; 4486 :     for (i = 0; i < l1; i++) {

	inc	esi
	cmp	esi, DWORD PTR tv229[ebp]
	jl	SHORT $LL4@xmlXPathDi
$LN21@xmlXPathDi:
	mov	ecx, DWORD PTR _ret$1$[ebp]
	pop	edi
$LN17@xmlXPathDi:

; 4490 : 	        break;
; 4491 : 	}
; 4492 :     }
; 4493 :     return(ret);

	pop	esi
	mov	eax, ecx
	pop	ebx

; 4494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathDi:

; 4482 : 	return(ret);

	mov	eax, ecx
	pop	ebx

; 4494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPathDi:

; 4478 : 	return(nodes1);

	mov	eax, DWORD PTR _nodes1$[ebp]

; 4494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDifference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetContains
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPathNodeSetContains PROC				; COMDAT

; 3599 : xmlXPathNodeSetContains (xmlNodeSetPtr cur, xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	test	ebx, ebx
	je	SHORT $LN9@xmlXPathNo

; 3600 :     int i;
; 3601 : 
; 3602 :     if ((cur == NULL) || (val == NULL)) return(0);

	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	SHORT $LN9@xmlXPathNo

; 3603 :     if (val->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	mov	edx, DWORD PTR [ebx]
	jne	SHORT $LN10@xmlXPathNo

; 3604 : 	for (i = 0; i < cur->nodeNr; i++) {

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN9@xmlXPathNo
	npad	4
$LL4@xmlXPathNo:

; 3605 : 	    if (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [eax+esi*4]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPathNo

; 3606 : 		xmlNsPtr ns1, ns2;
; 3607 : 
; 3608 : 		ns1 = (xmlNsPtr) val;
; 3609 : 		ns2 = (xmlNsPtr) cur->nodeTab[i];
; 3610 : 		if (ns1 == ns2)

	cmp	edi, eax
	je	SHORT $LN21@xmlXPathNo

; 3611 : 		    return(1);
; 3612 : 		if ((ns1->next != NULL) && (ns2->next == ns1->next) &&

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN2@xmlXPathNo
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN2@xmlXPathNo
	push	DWORD PTR [eax+12]
	push	DWORD PTR [edi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@xmlXPathNo
$LN2@xmlXPathNo:

; 3604 : 	for (i = 0; i < cur->nodeNr; i++) {

	inc	esi
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL4@xmlXPathNo
$LN9@xmlXPathNo:
	pop	edi

; 3620 : 		return(1);
; 3621 : 	}
; 3622 :     }
; 3623 :     return(0);
; 3624 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlXPathNo:

; 3613 : 	            (xmlStrEqual(ns1->prefix, ns2->prefix)))
; 3614 : 		    return(1);
; 3615 : 	    }
; 3616 : 	}
; 3617 :     } else {
; 3618 : 	for (i = 0; i < cur->nodeNr; i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN9@xmlXPathNo

; 3619 : 	    if (cur->nodeTab[i] == val)

	mov	eax, DWORD PTR [ebx+8]
$LL7@xmlXPathNo:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN21@xmlXPathNo

; 3613 : 	            (xmlStrEqual(ns1->prefix, ns2->prefix)))
; 3614 : 		    return(1);
; 3615 : 	    }
; 3616 : 	}
; 3617 :     } else {
; 3618 : 	for (i = 0; i < cur->nodeNr; i++) {

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL7@xmlXPathNo

; 3620 : 		return(1);
; 3621 : 	}
; 3622 :     }
; 3623 :     return(0);
; 3624 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN21@xmlXPathNo:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathNodeSetContains ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpCompExpr
_TEXT	SEGMENT
_shift$ = -100						; size = 100
_output$ = 8						; size = 4
_comp$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpCompExpr PROC				; COMDAT

; 1653 : 	                  int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _output$[ebp]
	test	edi, edi
	je	$LN6@xmlXPathDe

; 1654 :     int i;
; 1655 :     char shift[100];
; 1656 : 
; 1657 :     if ((output == NULL) || (comp == NULL)) return;

	push	ebx
	mov	ebx, DWORD PTR _comp$[ebp]
	test	ebx, ebx
	je	SHORT $LN15@xmlXPathDe

; 1658 : 
; 1659 :     for (i = 0;((i < depth) && (i < 25));i++)

	push	esi
	mov	esi, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN14@xmlXPathDe
	npad	2
$LL4@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN14@xmlXPathDe

; 1660 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL4@xmlXPathDe
$LN14@xmlXPathDe:

; 1661 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$[ebp+eax*2], 0

; 1662 : 
; 1663 :     fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1664 : 
; 1665 : #ifdef XPATH_STREAMING
; 1666 :     if (comp->stream) {

	cmp	DWORD PTR [ebx+24], 0
	je	SHORT $LN7@xmlXPathDe

; 1667 :         fprintf(output, "Streaming Expression\n");

	push	OFFSET ??_C@_0BG@FMDDAOLJ@Streaming?5Expression?6@
	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1675 :     }
; 1676 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathDe:

; 1668 :     } else
; 1669 : #endif
; 1670 :     {
; 1671 :         fprintf(output, "Compiled Expression : %d elements\n",

	push	DWORD PTR [ebx]
	push	OFFSET ??_C@_0CD@DHBDACDN@Compiled?5Expression?5?3?5?$CFd?5elemen@
	push	edi
	call	_fprintf

; 1672 :                 comp->nbStep);
; 1673 :         i = comp->last;
; 1674 :         xmlXPathDebugDumpStepOp(output, comp, &comp->steps[i], depth + 1);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	push	eax
	push	ebx
	push	edi
	call	_xmlXPathDebugDumpStepOp
	add	esp, 28					; 0000001cH
	pop	esi
$LN15@xmlXPathDe:
	pop	ebx
$LN6@xmlXPathDe:
	pop	edi

; 1675 :     }
; 1676 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathDebugDumpCompExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathDebugDumpObject
_TEXT	SEGMENT
_shift$1 = -308						; size = 100
_shift$ = -208						; size = 100
_shift$2 = -108						; size = 100
_shift$3 = -108						; size = 100
tv738 = -8						; size = 4
_i$2$ = 8						; size = 4
_cur$1$ = 8						; size = 4
_output$ = 8						; size = 4
_cur$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlXPathDebugDumpObject PROC				; COMDAT

; 1363 : xmlXPathDebugDumpObject(FILE *output, xmlXPathObjectPtr cur, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _output$[ebp]
	test	edi, edi
	je	$LN5@xmlXPathDe

; 1364 :     int i;
; 1365 :     char shift[100];
; 1366 : 
; 1367 :     if (output == NULL) return;
; 1368 : 
; 1369 :     for (i = 0;((i < depth) && (i < 25));i++)

	push	ebx
	mov	ebx, DWORD PTR _depth$[ebp]
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN107@xmlXPathDe
	npad	7
$LL4@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN107@xmlXPathDe

; 1370 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL4@xmlXPathDe
$LN107@xmlXPathDe:
	push	esi

; 1371 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$[ebp+eax*2], 0

; 1372 : 
; 1373 : 
; 1374 :     fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1375 : 
; 1376 :     if (cur == NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LN10@xmlXPathDe

; 1377 :         fprintf(output, "Object is empty (NULL)\n");

	push	OFFSET ??_C@_0BI@CIBIAOEE@Object?5is?5empty?5?$CINULL?$CJ?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathDe:

; 1378 : 	return;
; 1379 :     }
; 1380 :     switch(cur->type) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 9
	ja	$LN115@xmlXPathDe
	jmp	DWORD PTR $LN118@xmlXPathDe[eax*4]
$LN11@xmlXPathDe:

; 1381 :         case XPATH_UNDEFINED:
; 1382 : 	    fprintf(output, "Object is uninitialized\n");

	push	OFFSET ??_C@_0BJ@EGAONLPM@Object?5is?5uninitialized?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPathDe:

; 1383 : 	    break;
; 1384 :         case XPATH_NODESET:
; 1385 : 	    fprintf(output, "Object is a Node Set :\n");

	push	OFFSET ??_C@_0BI@NCNINNMM@Object?5is?5a?5Node?5Set?5?3?6@
	push	edi
	call	_fprintf

; 1386 : 	    xmlXPathDebugDumpNodeSet(output, cur->nodesetval, depth);

	push	ebx
	push	DWORD PTR [esi+4]
	push	edi
	call	_xmlXPathDebugDumpNodeSet
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPathDe:

; 1387 : 	    break;
; 1388 : 	case XPATH_XSLT_TREE:
; 1389 : 	    fprintf(output, "Object is an XSLT value tree :\n");

	push	OFFSET ??_C@_0CA@NNPHAPO@Object?5is?5an?5XSLT?5value?5tree?5?3?6@
	push	edi
	call	_fprintf

; 1390 : 	    xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);

	mov	eax, DWORD PTR [esi+4]
	add	esp, 8

; 1314 :     for (i = 0;((i < depth) && (i < 25));i++)

	xor	esi, esi

; 1390 : 	    xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);

	mov	DWORD PTR _cur$1$[ebp], eax

; 1314 :     for (i = 0;((i < depth) && (i < 25));i++)

	test	ebx, ebx
	jle	SHORT $LN108@xmlXPathDe
$LL40@xmlXPathDe:
	cmp	esi, 25					; 00000019H
	jge	SHORT $LN108@xmlXPathDe

; 1315 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$3[ebp+esi*2], 8224	; 00002020H
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL40@xmlXPathDe
$LN108@xmlXPathDe:

; 1316 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$3[ebp+esi*2], 0

; 1317 : 
; 1318 :     if ((cur == NULL) || (cur->nodeNr == 0) || (cur->nodeTab[0] == NULL)) {

	test	eax, eax
	je	$LN42@xmlXPathDe
	cmp	DWORD PTR [eax], 0
	je	$LN42@xmlXPathDe
	mov	eax, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax], 0
	je	$LN42@xmlXPathDe

; 1321 : 	return;
; 1322 : 
; 1323 :     }
; 1324 : 
; 1325 :     fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$3[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1326 :     fprintf(output, "%d", i + 1);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	push	edi
	call	_fprintf

; 1327 :     xmlXPathDebugDumpNodeList(output, cur->nodeTab[0]->children, depth + 1);

	mov	eax, DWORD PTR _cur$1$[ebp]
	inc	ebx
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+12]

; 1266 :     for (i = 0;((i < depth) && (i < 25));i++)

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN109@xmlXPathDe
$LL47@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN109@xmlXPathDe

; 1267 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$1[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL47@xmlXPathDe
$LN109@xmlXPathDe:

; 1268 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$1[ebp+eax*2], 0

; 1269 :     if (cur == NULL) {

	test	esi, esi
	jne	SHORT $LL48@xmlXPathDe

; 1270 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$1[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1271 : 	fprintf(output, "Node is NULL !\n");

	push	OFFSET ??_C@_0BA@OKLFJGHE@Node?5is?5NULL?5?$CB?6@
	push	edi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LL48@xmlXPathDe:

; 1277 : 	tmp = cur;

	mov	eax, esi

; 1278 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]

; 1279 : 	xmlDebugDumpOneNode(output, tmp, depth);

	push	ebx
	push	eax
	push	edi
	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL48@xmlXPathDe
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlXPathDe:

; 1319 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$3[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1320 : 	fprintf(output, "Value Tree is NULL !\n");

	push	OFFSET ??_C@_0BG@ODIPEGMA@Value?5Tree?5is?5NULL?5?$CB?6@
	push	edi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlXPathDe:

; 1391 : 	    break;
; 1392 :         case XPATH_BOOLEAN:
; 1393 : 	    fprintf(output, "Object is a Boolean : ");

	push	OFFSET ??_C@_0BH@GPCPEGOI@Object?5is?5a?5Boolean?5?3?5@
	push	edi
	call	_fprintf

; 1394 : 	    if (cur->boolval) fprintf(output, "true\n");
; 1395 : 	    else fprintf(output, "false\n");
; 1396 : 	    break;

	cmp	DWORD PTR [esi+8], 0
	mov	ecx, OFFSET ??_C@_05LFIOBDML@true?6@
	mov	eax, OFFSET ??_C@_06NIOGPBNO@false?6@
	cmovne	eax, ecx
	push	eax
	push	edi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXPathDe:

; 1397 :         case XPATH_NUMBER:
; 1398 : 	    switch (xmlXPathIsInf(cur->floatval)) {

	movsd	xmm0, QWORD PTR [esi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsInf
	add	esp, 8
	cmp	eax, -1
	je	$LN19@xmlXPathDe
	cmp	eax, 1
	je	SHORT $LN18@xmlXPathDe

; 1404 : 		break;
; 1405 : 	    default:
; 1406 : 		if (xmlXPathIsNaN(cur->floatval)) {

	movsd	xmm0, QWORD PTR [esi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlXPathDe

; 1407 : 		    fprintf(output, "Object is a number : NaN\n");

	push	OFFSET ??_C@_0BK@JAENJFCB@Object?5is?5a?5number?5?3?5NaN?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXPathDe:

; 1408 : 		} else if (cur->floatval == 0) {

	movsd	xmm0, QWORD PTR [esi+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@xmlXPathDe

; 1409 :                     /* Omit sign for negative zero. */
; 1410 : 		    fprintf(output, "Object is a number : 0\n");

	push	OFFSET ??_C@_0BI@KDLCNKPI@Object?5is?5a?5number?5?3?50?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlXPathDe:

; 1411 : 		} else {
; 1412 : 		    fprintf(output, "Object is a number : %0g\n", cur->floatval);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BK@DKICMGNF@Object?5is?5a?5number?5?3?5?$CF0g?6@
	push	edi
	call	_fprintf
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlXPathDe:

; 1399 : 	    case 1:
; 1400 : 		fprintf(output, "Object is a number : Infinity\n");

	push	OFFSET ??_C@_0BP@DBNKIPBA@Object?5is?5a?5number?5?3?5Infinity?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXPathDe:

; 1401 : 		break;
; 1402 : 	    case -1:
; 1403 : 		fprintf(output, "Object is a number : -Infinity\n");

	push	OFFSET ??_C@_0CA@CMBCDMBH@Object?5is?5a?5number?5?3?5?9Infinity?6@

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	edi
	call	_fprintf
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlXPathDe:

; 1413 : 		}
; 1414 : 	    }
; 1415 : 	    break;
; 1416 :         case XPATH_STRING:
; 1417 : 	    fprintf(output, "Object is a string : ");

	push	OFFSET ??_C@_0BG@IHKNOBPJ@Object?5is?5a?5string?5?3?5@
	push	edi
	call	_fprintf

; 1418 : 	    xmlDebugDumpString(output, cur->stringval);

	push	DWORD PTR [esi+24]
	push	edi
	call	_xmlDebugDumpString

; 1419 : 	    fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlXPathDe:

; 1420 : 	    break;
; 1421 : 	case XPATH_POINT:
; 1422 : 	    fprintf(output, "Object is a point : index %d in node", cur->index);

	push	DWORD PTR [esi+32]
	push	OFFSET ??_C@_0CF@IDHPHOMH@Object?5is?5a?5point?5?3?5index?5?$CFd?5in@
	push	edi
	call	_fprintf

; 1423 : 	    xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user, depth + 1);

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	DWORD PTR [esi+28]
	push	edi
	call	_xmlXPathDebugDumpNode

; 1424 : 	    fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 32					; 00000020H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlXPathDe:

; 1425 : 	    break;
; 1426 : 	case XPATH_RANGE:
; 1427 : 	    if ((cur->user2 == NULL) ||

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	$LN91@xmlXPathDe
	cmp	eax, DWORD PTR [esi+28]
	jne	SHORT $LN90@xmlXPathDe
	mov	eax, DWORD PTR [esi+32]
	cmp	eax, DWORD PTR [esi+40]
	je	$LN91@xmlXPathDe
$LN90@xmlXPathDe:

; 1435 : 			              depth + 1);
; 1436 : 	    } else  {
; 1437 : 		fprintf(output, "Object is a range :\n");

	push	OFFSET ??_C@_0BF@JIJMPGFP@Object?5is?5a?5range?5?3?6@
	push	edi
	call	_fprintf

; 1438 : 		fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1439 : 		fprintf(output, "From ");

	push	OFFSET ??_C@_05KCOAJPAG@From?5@
	push	edi
	call	_fprintf

; 1440 : 		if (cur->index >= 0)

	mov	eax, DWORD PTR [esi+32]
	add	esp, 28					; 0000001cH
	test	eax, eax
	js	SHORT $LN32@xmlXPathDe

; 1441 : 		    fprintf(output, "index %d in ", cur->index);

	push	eax
	push	OFFSET ??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN32@xmlXPathDe:

; 1442 : 		fprintf(output, "node\n");

	push	OFFSET ??_C@_05GHBGFBPP@node?6@
	push	edi
	call	_fprintf

; 1443 : 		xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,

	inc	ebx
	push	ebx
	push	DWORD PTR [esi+28]
	push	edi
	call	_xmlXPathDebugDumpNode

; 1444 : 			              depth + 1);
; 1445 : 		fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1446 : 		fprintf(output, "To ");

	push	OFFSET ??_C@_03EMNLBAKJ@To?5@
	push	edi
	call	_fprintf

; 1447 : 		if (cur->index2 >= 0)

	mov	eax, DWORD PTR [esi+40]
	add	esp, 40					; 00000028H
	test	eax, eax
	js	SHORT $LN33@xmlXPathDe

; 1448 : 		    fprintf(output, "index %d in ", cur->index2);

	push	eax
	push	OFFSET ??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN33@xmlXPathDe:

; 1449 : 		fprintf(output, "node\n");

	push	OFFSET ??_C@_05GHBGFBPP@node?6@
	push	edi
	call	_fprintf

; 1450 : 		xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user2,

	push	ebx
	push	DWORD PTR [esi+36]
	push	edi
	call	_xmlXPathDebugDumpNode

; 1451 : 			              depth + 1);
; 1452 : 		fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	edi
	call	_fprintf
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@xmlXPathDe:

; 1428 : 		((cur->user2 == cur->user) && (cur->index == cur->index2))) {
; 1429 : 		fprintf(output, "Object is a collapsed range :\n");

	push	OFFSET ??_C@_0BP@BGPHFANM@Object?5is?5a?5collapsed?5range?5?3?6@
	push	edi
	call	_fprintf

; 1430 : 		fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1431 : 		if (cur->index >= 0)

	mov	eax, DWORD PTR [esi+32]
	add	esp, 20					; 00000014H
	test	eax, eax
	js	SHORT $LN31@xmlXPathDe

; 1432 : 		    fprintf(output, "index %d in ", cur->index);

	push	eax
	push	OFFSET ??_C@_0N@IDICPBLK@index?5?$CFd?5in?5@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN31@xmlXPathDe:

; 1433 : 		fprintf(output, "node\n");

	push	OFFSET ??_C@_05GHBGFBPP@node?6@
	push	edi
	call	_fprintf

; 1434 : 		xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	DWORD PTR [esi+28]
	push	edi
	call	_xmlXPathDebugDumpNode
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlXPathDe:

; 1453 : 	    }
; 1454 : 	    break;
; 1455 : 	case XPATH_LOCATIONSET:
; 1456 : #if defined(LIBXML_XPTR_ENABLED)
; 1457 : 	    fprintf(output, "Object is a Location Set:\n");

	push	OFFSET ??_C@_0BL@DOOMBINH@Object?5is?5a?5Location?5Set?3?6@
	push	edi
	call	_fprintf

; 1458 : 	    xmlXPathDebugDumpLocationSet(output,

	mov	ecx, DWORD PTR [esi+28]
	add	esp, 8

; 1335 :     for (i = 0;((i < depth) && (i < 25));i++)

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN110@xmlXPathDe
$LL112@xmlXPathDe:
	cmp	eax, 25					; 00000019H
	jge	SHORT $LN110@xmlXPathDe

; 1336 :         shift[2 * i] = shift[2 * i + 1] = ' ';

	mov	WORD PTR _shift$2[ebp+eax*2], 8224	; 00002020H
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL112@xmlXPathDe
$LN110@xmlXPathDe:

; 1337 :     shift[2 * i] = shift[2 * i + 1] = 0;

	mov	WORD PTR _shift$2[ebp+eax*2], 0

; 1338 : 
; 1339 :     if (cur == NULL) {

	test	ecx, ecx
	jne	SHORT $LN59@xmlXPathDe

; 1340 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$2[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1341 : 	fprintf(output, "LocationSet is NULL !\n");

	push	OFFSET ??_C@_0BH@OMGEHPOG@LocationSet?5is?5NULL?5?$CB?6@
	push	edi
	call	_fprintf
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlXPathDe:

; 1346 :     for (i = 0;i < cur->locNr;i++) {

	xor	esi, esi
	mov	DWORD PTR _i$2$[ebp], esi
	cmp	DWORD PTR [ecx], esi
	jle	SHORT $LN115@xmlXPathDe
	lea	eax, DWORD PTR [ebx+1]
	mov	ebx, ecx
	mov	DWORD PTR tv738[ebp], eax
	npad	7
$LL113@xmlXPathDe:

; 1347 : 	fprintf(output, "%s", shift);

	lea	eax, DWORD PTR _shift$2[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	call	_fprintf

; 1348 :         fprintf(output, "%d : ", i + 1);

	inc	esi
	push	esi
	push	OFFSET ??_C@_05GJKEPAIO@?$CFd?5?3?5@
	push	edi
	call	_fprintf

; 1349 : 	xmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _i$2$[ebp]
	push	DWORD PTR tv738[ebp]
	push	DWORD PTR [eax+ecx*4]
	push	edi
	call	_xmlXPathDebugDumpObject
	add	esp, 36					; 00000024H
	mov	DWORD PTR _i$2$[ebp], esi
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL113@xmlXPathDe
	pop	esi
	pop	ebx
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@xmlXPathDe:

; 1459 : 		    (xmlLocationSetPtr) cur->user, depth);
; 1460 : #endif
; 1461 : 	    break;
; 1462 : 	case XPATH_USERS:
; 1463 : 	    fprintf(output, "Object is user defined\n");

	push	OFFSET ??_C@_0BI@JJDBNCDG@Object?5is?5user?5defined?6@
	push	edi
	call	_fprintf
	add	esp, 8
$LN115@xmlXPathDe:
	pop	esi
	pop	ebx
$LN5@xmlXPathDe:
	pop	edi

; 1464 : 	    break;
; 1465 :     }
; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@xmlXPathDe:
	DD	$LN11@xmlXPathDe
	DD	$LN12@xmlXPathDe
	DD	$LN14@xmlXPathDe
	DD	$LN17@xmlXPathDe
	DD	$LN25@xmlXPathDe
	DD	$LN26@xmlXPathDe
	DD	$LN27@xmlXPathDe
	DD	$LN34@xmlXPathDe
	DD	$LN35@xmlXPathDe
	DD	$LN13@xmlXPathDe
_xmlXPathDebugDumpObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_xmlXPathErr PROC					; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _error$[ebp]
	test	esi, esi
	js	SHORT $LN3@xmlXPathEr

; 687  :     if ((error < 0) || (error > MAXERRNO))

	cmp	esi, 25					; 00000019H
	jle	SHORT $LN2@xmlXPathEr
$LN3@xmlXPathEr:

; 688  : 	error = MAXERRNO;

	mov	esi, 25					; 00000019H
$LN2@xmlXPathEr:

; 689  :     if (ctxt == NULL) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	jne	SHORT $LN4@xmlXPathEr

; 690  : 	__xmlRaiseError(NULL, NULL, NULL,

	push	DWORD PTR _xmlXPathErrorMessages[esi*4]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
$LN10@xmlXPathEr:

; 725  : 			NULL, ctxt->context->debugNode, XML_FROM_XPATH,
; 726  : 			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
; 727  : 			XML_ERR_ERROR, NULL, 0,
; 728  : 			(const char *) ctxt->base, NULL, NULL,
; 729  : 			ctxt->cur - ctxt->base, 0,
; 730  : 			"%s", xmlXPathErrorMessages[error]);
; 731  :     }
; 732  : 
; 733  : }

	push	0
	push	0
	push	2
	lea	eax, DWORD PTR [esi+1200]
	push	eax
	push	12					; 0000000cH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathEr:

; 691  : 			NULL, NULL, XML_FROM_XPATH,
; 692  : 			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
; 693  : 			XML_ERR_ERROR, NULL, 0,
; 694  : 			NULL, NULL, NULL, 0, 0,
; 695  : 			"%s", xmlXPathErrorMessages[error]);
; 696  : 	return;
; 697  :     }
; 698  :     ctxt->error = error;
; 699  :     if (ctxt->context == NULL) {

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [edi+8], esi
	test	eax, eax
	jne	SHORT $LN5@xmlXPathEr

; 700  : 	__xmlRaiseError(NULL, NULL, NULL,

	push	DWORD PTR _xmlXPathErrorMessages[esi*4]
	mov	ecx, DWORD PTR [edi+4]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	eax
	mov	eax, DWORD PTR [edi]
	sub	eax, ecx
	push	eax
	push	0
	push	0
	push	ecx

; 701  : 			NULL, NULL, XML_FROM_XPATH,
; 702  : 			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
; 703  : 			XML_ERR_ERROR, NULL, 0,
; 704  : 			(const char *) ctxt->base, NULL, NULL,
; 705  : 			ctxt->cur - ctxt->base, 0,
; 706  : 			"%s", xmlXPathErrorMessages[error]);
; 707  : 	return;

	jmp	SHORT $LN10@xmlXPathEr
$LN5@xmlXPathEr:

; 708  :     }
; 709  : 
; 710  :     /* cleanup current last error */
; 711  :     xmlResetError(&ctxt->context->lastError);

	add	eax, 136				; 00000088H
	push	ebx
	push	eax
	call	_xmlResetError

; 712  : 
; 713  :     ctxt->context->lastError.domain = XML_FROM_XPATH;

	mov	eax, DWORD PTR [edi+12]

; 714  :     ctxt->context->lastError.code = error + XML_XPATH_EXPRESSION_OK -

	lea	ebx, DWORD PTR [esi+1200]
	mov	DWORD PTR [eax+136], 12			; 0000000cH
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+140], ebx

; 715  :                            XPATH_EXPRESSION_OK;
; 716  :     ctxt->context->lastError.level = XML_ERR_ERROR;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+148], 2

; 717  :     ctxt->context->lastError.str1 = (char *) xmlStrdup(ctxt->base);

	push	DWORD PTR [edi+4]
	call	_xmlStrdup
	mov	ecx, DWORD PTR [edi+12]
	add	esp, 8
	mov	DWORD PTR [ecx+160], eax

; 718  :     ctxt->context->lastError.int1 = ctxt->cur - ctxt->base;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi]
	sub	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+172], ecx

; 719  :     ctxt->context->lastError.node = ctxt->context->debugNode;

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [ecx+188]
	mov	DWORD PTR [ecx+184], eax

; 720  :     if (ctxt->context->error != NULL) {

	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edx+132]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPathEr

; 721  : 	ctxt->context->error(ctxt->context->userData,

	lea	eax, DWORD PTR [edx+136]
	push	eax
	push	DWORD PTR [edx+128]
	call	ecx
	add	esp, 8
	pop	ebx
	pop	edi

; 725  : 			NULL, ctxt->context->debugNode, XML_FROM_XPATH,
; 726  : 			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
; 727  : 			XML_ERR_ERROR, NULL, 0,
; 728  : 			(const char *) ctxt->base, NULL, NULL,
; 729  : 			ctxt->cur - ctxt->base, 0,
; 730  : 			"%s", xmlXPathErrorMessages[error]);
; 731  :     }
; 732  : 
; 733  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathEr:

; 722  : 	                     &ctxt->context->lastError);
; 723  :     } else {
; 724  : 	__xmlRaiseError(NULL, NULL, NULL,

	push	DWORD PTR _xmlXPathErrorMessages[esi*4]
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	sub	eax, ecx
	push	eax
	push	0
	push	0
	push	ecx
	push	0
	push	0
	push	2
	push	ebx
	push	12					; 0000000cH
	push	DWORD PTR [edx+188]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	ebx
	pop	edi

; 725  : 			NULL, ctxt->context->debugNode, XML_FROM_XPATH,
; 726  : 			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
; 727  : 			XML_ERR_ERROR, NULL, 0,
; 728  : 			(const char *) ctxt->base, NULL, NULL,
; 729  : 			ctxt->cur - ctxt->base, 0,
; 730  : 			"%s", xmlXPathErrorMessages[error]);
; 731  :     }
; 732  : 
; 733  : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPatherror
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_file$ = 12						; size = 4
_line$ = 16						; size = 4
_no$ = 20						; size = 4
_xmlXPatherror PROC					; COMDAT

; 746  :               int line ATTRIBUTE_UNUSED, int no) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _no$[ebp]
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErr
	add	esp, 8

; 747  :     xmlXPathErr(ctxt, no);
; 748  : }

	pop	ebp
	ret	0
_xmlXPatherror ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterFuncLookup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_f$ = 12						; size = 4
_funcCtxt$ = 16						; size = 4
_xmlXPathRegisterFuncLookup PROC			; COMDAT

; 4897 : 			    void *funcCtxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlXPathRe

; 4898 :     if (ctxt == NULL)
; 4899 : 	return;
; 4900 :     ctxt->funcLookupFunc = f;

	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 4901 :     ctxt->funcLookupData = funcCtxt;

	mov	eax, DWORD PTR _funcCtxt$[ebp]
	mov	DWORD PTR [ecx+116], eax
$LN1@xmlXPathRe:

; 4902 : }

	pop	ebp
	ret	0
_xmlXPathRegisterFuncLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathRegisterVariableLookup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_f$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlXPathRegisterVariableLookup PROC			; COMDAT

; 5050 : 	 xmlXPathVariableLookupFunc f, void *data) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@xmlXPathRe

; 5051 :     if (ctxt == NULL)
; 5052 : 	return;
; 5053 :     ctxt->varLookupFunc = f;

	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 5054 :     ctxt->varLookupData = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+96], eax
$LN1@xmlXPathRe:

; 5055 : }

	pop	ebp
	ret	0
_xmlXPathRegisterVariableLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopExternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathPopExternal PROC				; COMDAT

; 3003 : xmlXPathPopExternal (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlXPathPo

; 3004 :     xmlXPathObjectPtr obj;
; 3005 :     void * ret;
; 3006 : 
; 3007 :     if ((ctxt == NULL) || (ctxt->value == NULL)) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN3@xmlXPathPo

; 3009 : 	return(NULL);
; 3010 :     }
; 3011 :     if (ctxt->value->type != XPATH_USERS) {

	cmp	DWORD PTR [eax], 8
	je	SHORT $LN5@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	11					; 0000000bH
	push	edi
	call	_xmlXPathErr
	add	esp, 8

; 3012 : 	xmlXPathSetTypeError(ctxt);

	mov	DWORD PTR [edi+8], 11			; 0000000bH

; 3020 : }

	xor	eax, eax
	pop	edi
	pop	ebp
	ret	0
$LN5@xmlXPathPo:
	push	esi

; 3013 : 	return(NULL);
; 3014 :     }
; 3015 :     obj = valuePop(ctxt);

	push	edi
	call	_valuePop

; 3016 :     ret = obj->user;
; 3017 :     obj->user = NULL;
; 3018 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	eax
	mov	esi, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+28], 0
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH

; 3019 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 3020 : }

	pop	ebp
	ret	0
$LN3@xmlXPathPo:

; 747  :     xmlXPathErr(ctxt, no);

	push	10					; 0000000aH
	push	edi
	call	_xmlXPathErr
	add	esp, 8

; 3008 : 	xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);

	test	edi, edi
	je	SHORT $LN4@xmlXPathPo
	mov	DWORD PTR [edi+8], 10			; 0000000aH
$LN4@xmlXPathPo:

; 3020 : }

	xor	eax, eax
	pop	edi
	pop	ebp
	ret	0
_xmlXPathPopExternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopNodeSet
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathPopNodeSet PROC				; COMDAT

; 2968 : xmlXPathPopNodeSet (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	SHORT $LN13@xmlXPathPo

; 2969 :     xmlXPathObjectPtr obj;
; 2970 :     xmlNodeSetPtr ret;
; 2971 : 
; 2972 :     if (ctxt == NULL) return(NULL);
; 2973 :     if (ctxt->value == NULL) {

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	SHORT $LN3@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	10					; 0000000aH
	push	edi
	call	_xmlXPathErr
	add	esp, 8

; 2974 : 	xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);

	mov	DWORD PTR [edi+8], 10			; 0000000aH
$LN13@xmlXPathPo:

; 2991 : }

	xor	eax, eax
	pop	edi
	pop	ebp
	ret	0
$LN3@xmlXPathPo:

; 2975 : 	return(NULL);
; 2976 :     }
; 2977 :     if (!xmlXPathStackIsNodeSet(ctxt)) {

	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN5@xmlXPathPo
	cmp	eax, 9
	je	SHORT $LN5@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	11					; 0000000bH
	push	edi
	call	_xmlXPathErr
	add	esp, 8

; 2978 : 	xmlXPathSetTypeError(ctxt);

	mov	DWORD PTR [edi+8], 11			; 0000000bH

; 2979 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 2991 : }

	pop	ebp
	ret	0
$LN5@xmlXPathPo:
	push	esi

; 2980 :     }
; 2981 :     obj = valuePop(ctxt);

	push	edi
	call	_valuePop

; 2982 :     ret = obj->nodesetval;
; 2983 : #if 0
; 2984 :     /* to fix memory leak of not clearing obj->user */
; 2985 :     if (obj->boolval && obj->user != NULL)
; 2986 :         xmlFreeNodeList((xmlNodePtr) obj->user);
; 2987 : #endif
; 2988 :     obj->nodesetval = NULL;
; 2989 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	eax
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], 0
	push	DWORD PTR [edi+12]
	call	_xmlXPathReleaseObject
	add	esp, 12					; 0000000cH

; 2990 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 2991 : }

	pop	ebp
	ret	0
_xmlXPathPopNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathPopString PROC					; COMDAT

; 2941 : xmlXPathPopString (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8

; 2942 :     xmlXPathObjectPtr obj;
; 2943 :     xmlChar * ret;
; 2944 : 
; 2945 :     obj = valuePop(ctxt);
; 2946 :     if (obj == NULL) {
; 2947 : 	xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);

	test	esi, esi
	je	SHORT $LN3@xmlXPathPo
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN3@xmlXPathPo:
	pop	edi

; 2948 : 	return(NULL);

	xor	eax, eax

; 2956 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlXPathPo:
	push	ebx

; 2949 :     }
; 2950 :     ret = xmlXPathCastToString(obj);	/* this does required strdup */

	push	edi
	call	_xmlXPathCastToString
	mov	ebx, eax
	add	esp, 4

; 2951 :     /* TODO: needs refactoring somewhere else */
; 2952 :     if (obj->stringval == ret)

	cmp	DWORD PTR [edi+24], ebx
	jne	SHORT $LN4@xmlXPathPo

; 2953 : 	obj->stringval = NULL;

	mov	DWORD PTR [edi+24], 0
$LN4@xmlXPathPo:

; 2954 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 2955 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 2956 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathPopString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopNumber
_TEXT	SEGMENT
_ret$1$ = -8						; size = 8
_ret$ = -8						; size = 8
_ctxt$ = 8						; size = 4
_xmlXPathPopNumber PROC					; COMDAT

; 2914 : xmlXPathPopNumber (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8

; 2915 :     xmlXPathObjectPtr obj;
; 2916 :     double ret;
; 2917 : 
; 2918 :     obj = valuePop(ctxt);
; 2919 :     if (obj == NULL) {
; 2920 : 	xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);

	test	esi, esi
	je	SHORT $LN3@xmlXPathPo
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN3@xmlXPathPo:

; 2921 : 	return(0);

	fldz
	pop	edi

; 2929 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathPo:

; 2922 :     }
; 2923 :     if (obj->type != XPATH_NUMBER)

	cmp	DWORD PTR [edi], 3
	je	SHORT $LN4@xmlXPathPo

; 2924 : 	ret = xmlXPathCastToNumber(obj);

	push	edi
	call	_xmlXPathCastToNumber
	add	esp, 4
	jmp	SHORT $LN9@xmlXPathPo
$LN4@xmlXPathPo:

; 2925 :     else
; 2926 :         ret = obj->floatval;

	movsd	xmm0, QWORD PTR [edi+16]
	movsd	QWORD PTR _ret$[ebp], xmm0
	fld	QWORD PTR _ret$[ebp]
$LN9@xmlXPathPo:

; 2927 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	edi
	push	DWORD PTR [esi+12]
	fstp	QWORD PTR _ret$1$[ebp]
	call	_xmlXPathReleaseObject

; 2928 :     return(ret);

	fld	QWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	edi

; 2929 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathPopNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathPopBoolean
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathPopBoolean PROC				; COMDAT

; 2887 : xmlXPathPopBoolean (xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN2@xmlXPathPo

; 747  :     xmlXPathErr(ctxt, no);

	push	10					; 0000000aH
	push	esi
	call	_xmlXPathErr
	add	esp, 8

; 2888 :     xmlXPathObjectPtr obj;
; 2889 :     int ret;
; 2890 : 
; 2891 :     obj = valuePop(ctxt);
; 2892 :     if (obj == NULL) {
; 2893 : 	xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);

	test	esi, esi
	je	SHORT $LN3@xmlXPathPo
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN3@xmlXPathPo:
	pop	edi

; 2894 : 	return(0);

	xor	eax, eax

; 2902 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlXPathPo:

; 2895 :     }
; 2896 :     if (obj->type != XPATH_BOOLEAN)

	cmp	DWORD PTR [edi], 2
	push	ebx
	je	SHORT $LN4@xmlXPathPo

; 2897 : 	ret = xmlXPathCastToBoolean(obj);

	push	edi
	call	_xmlXPathCastToBoolean
	add	esp, 4
	mov	ebx, eax

; 2900 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 2901 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 2902 : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPathPo:

; 2898 :     else
; 2899 :         ret = obj->boolval;

	mov	ebx, DWORD PTR [edi+8]

; 2900 :     xmlXPathReleaseObject(ctxt->context, obj);

	push	edi
	push	DWORD PTR [esi+12]
	call	_xmlXPathReleaseObject
	add	esp, 8

; 2901 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 2902 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPathPopBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsInf
_TEXT	SEGMENT
_val$ = 8						; size = 8
_xmlXPathIsInf PROC					; COMDAT

; 526  : xmlXPathIsInf(double val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	movsd	xmm0, QWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	add	esp, 8
	cmp	ax, 1
	jne	SHORT $LN3@xmlXPathIs

; 527  : #ifdef isinf
; 528  :     return isinf(val) ? (val > 0 ? 1 : -1) : 0;

	movsd	xmm0, QWORD PTR _val$[ebp]
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@0000000000000000
	seta	al
	lea	eax, DWORD PTR [eax*2-1]

; 529  : #else
; 530  :     if (val >= INFINITY)
; 531  :         return 1;
; 532  :     if (val <= -INFINITY)
; 533  :         return -1;
; 534  :     return 0;
; 535  : #endif
; 536  : }

	pop	ebp
	ret	0
$LN3@xmlXPathIs:

; 527  : #ifdef isinf
; 528  :     return isinf(val) ? (val > 0 ? 1 : -1) : 0;

	xor	eax, eax

; 529  : #else
; 530  :     if (val >= INFINITY)
; 531  :         return 1;
; 532  :     if (val <= -INFINITY)
; 533  :         return -1;
; 534  :     return 0;
; 535  : #endif
; 536  : }

	pop	ebp
	ret	0
_xmlXPathIsInf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathIsNaN
_TEXT	SEGMENT
_val$ = 8						; size = 8
_xmlXPathIsNaN PROC					; COMDAT

; 511  : xmlXPathIsNaN(double val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	movsd	xmm0, QWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	xor	ecx, ecx
	add	esp, 8
	cmp	ax, 2
	sete	cl
	mov	eax, ecx

; 512  : #ifdef isnan
; 513  :     return isnan(val);
; 514  : #else
; 515  :     return !(val == val);
; 516  : #endif
; 517  : }

	pop	ebp
	ret	0
_xmlXPathIsNaN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathInit
_TEXT	SEGMENT
_xmlXPathInit PROC					; COMDAT
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR _xmlXPathNAN, xmm0
	movsd	xmm0, QWORD PTR __real@7ff0000000000000
	movsd	QWORD PTR _xmlXPathPINF, xmm0
	movsd	xmm0, QWORD PTR __real@fff0000000000000
	movsd	QWORD PTR _xmlXPathNINF, xmm0
	ret	0
_xmlXPathInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeCompExpr
_TEXT	SEGMENT
tv341 = 8						; size = 4
_comp$ = 8						; size = 4
_xmlXPathFreeCompExpr PROC				; COMDAT

; 1014 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _comp$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathFr

; 1015 :     xmlXPathStepOpPtr op;
; 1016 :     int i;
; 1017 : 
; 1018 :     if (comp == NULL)
; 1019 :         return;
; 1020 :     if (comp->dict == NULL) {

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	edi
	test	eax, eax
	jne	SHORT $LN9@xmlXPathFr

; 1021 : 	for (i = 0; i < comp->nbStep; i++) {

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN10@xmlXPathFr
	mov	DWORD PTR tv341[ebp], eax
$LL4@xmlXPathFr:

; 1022 : 	    op = &comp->steps[i];

	mov	edi, DWORD PTR [esi+8]
	add	edi, eax

; 1023 : 	    if (op->value4 != NULL) {

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN13@xmlXPathFr

; 1024 : 		if (op->op == XPATH_OP_VALUE)

	cmp	DWORD PTR [edi], 11			; 0000000bH
	push	eax
	jne	SHORT $LN12@xmlXPathFr

; 1025 : 		    xmlXPathFreeObject(op->value4);

	call	_xmlXPathFreeObject
	jmp	SHORT $LN29@xmlXPathFr
$LN12@xmlXPathFr:

; 1026 : 		else
; 1027 : 		    xmlFree(op->value4);

	call	DWORD PTR _xmlFree
$LN29@xmlXPathFr:

; 1028 : 	    }
; 1029 : 	    if (op->value5 != NULL)

	add	esp, 4
$LN13@xmlXPathFr:
	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN2@xmlXPathFr

; 1030 : 		xmlFree(op->value5);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlXPathFr:

; 1021 : 	for (i = 0; i < comp->nbStep; i++) {

	mov	eax, DWORD PTR tv341[ebp]
	inc	ebx
	add	eax, 40					; 00000028H
	mov	DWORD PTR tv341[ebp], eax
	cmp	ebx, DWORD PTR [esi]
	jl	SHORT $LL4@xmlXPathFr

; 1031 : 	}
; 1032 :     } else {

	jmp	SHORT $LN10@xmlXPathFr
$LN9@xmlXPathFr:

; 1033 : 	for (i = 0; i < comp->nbStep; i++) {

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN6@xmlXPathFr
	xor	ebx, ebx
	npad	4
$LL7@xmlXPathFr:

; 1034 : 	    op = &comp->steps[i];

	mov	eax, DWORD PTR [esi+8]

; 1035 : 	    if (op->value4 != NULL) {

	mov	ecx, DWORD PTR [eax+ebx+24]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathFr

; 1036 : 		if (op->op == XPATH_OP_VALUE)

	cmp	DWORD PTR [eax+ebx], 11			; 0000000bH
	jne	SHORT $LN5@xmlXPathFr

; 1037 : 		    xmlXPathFreeObject(op->value4);

	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4
$LN5@xmlXPathFr:

; 1033 : 	for (i = 0; i < comp->nbStep; i++) {

	inc	edi
	add	ebx, 40					; 00000028H
	cmp	edi, DWORD PTR [esi]
	jl	SHORT $LL7@xmlXPathFr
	mov	eax, DWORD PTR [esi+20]
$LN6@xmlXPathFr:

; 1038 : 	    }
; 1039 : 	}
; 1040 :         xmlDictFree(comp->dict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN10@xmlXPathFr:

; 1041 :     }
; 1042 :     if (comp->steps != NULL) {

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN17@xmlXPathFr

; 1043 :         xmlFree(comp->steps);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN17@xmlXPathFr:

; 1044 :     }
; 1045 : #ifdef DEBUG_EVAL_COUNTS
; 1046 :     if (comp->string != NULL) {
; 1047 :         xmlFree(comp->string);
; 1048 :     }
; 1049 : #endif
; 1050 : #ifdef XPATH_STREAMING
; 1051 :     if (comp->stream != NULL) {

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN18@xmlXPathFr

; 1052 :         xmlFreePatternList(comp->stream);

	push	eax
	call	_xmlFreePatternList
	add	esp, 4
$LN18@xmlXPathFr:

; 1053 :     }
; 1054 : #endif
; 1055 :     if (comp->expr != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN19@xmlXPathFr

; 1056 :         xmlFree(comp->expr);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN19@xmlXPathFr:

; 1057 :     }
; 1058 : 
; 1059 :     xmlFree(comp);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPathFr:
	pop	esi

; 1060 : }

	pop	ebp
	ret	0
_xmlXPathFreeCompExpr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompiledEvalToBoolean
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlXPathCompiledEvalToBoolean PROC			; COMDAT

; 14804: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	1
	push	0
	push	DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _comp$[ebp]
	call	_xmlXPathCompiledEvalInternal
	add	esp, 16					; 00000010H

; 14805:     return(xmlXPathCompiledEvalInternal(comp, ctxt, NULL, 1));
; 14806: }

	pop	ebp
	ret	0
_xmlXPathCompiledEvalToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompiledEval
_TEXT	SEGMENT
_res$ = -4						; size = 4
_comp$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlXPathCompiledEval PROC				; COMDAT

; 14783: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	lea	eax, DWORD PTR _res$[ebp]
	mov	DWORD PTR _res$[ebp], 0
	push	eax
	push	DWORD PTR _ctx$[ebp]
	push	DWORD PTR _comp$[ebp]
	call	_xmlXPathCompiledEvalInternal
	mov	eax, DWORD PTR _res$[ebp]
	add	esp, 16					; 00000010H

; 14784:     xmlXPathObjectPtr res = NULL;
; 14785: 
; 14786:     xmlXPathCompiledEvalInternal(comp, ctx, &res, 0);
; 14787:     return(res);
; 14788: }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCompiledEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCtxtCompile
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlXPathCtxtCompile PROC				; COMDAT

; 14629: xmlXPathCtxtCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _str$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	push	ebx
	push	esi
	call	_xmlXPathTryStreamCompile
	add	esp, 8
	test	eax, eax
	jne	$LN1@xmlXPathCt

; 499  :     xmlXPathNAN = NAN;

	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR _xmlXPathNAN, xmm0

; 500  :     xmlXPathPINF = INFINITY;

	movsd	xmm0, QWORD PTR __real@7ff0000000000000
	movsd	QWORD PTR _xmlXPathPINF, xmm0

; 501  :     xmlXPathNINF = -INFINITY;

	movsd	xmm0, QWORD PTR __real@fff0000000000000

; 14630:     xmlXPathParserContextPtr pctxt;
; 14631:     xmlXPathCompExprPtr comp;
; 14632: 
; 14633: #ifdef XPATH_STREAMING
; 14634:     comp = xmlXPathTryStreamCompile(ctxt, str);
; 14635:     if (comp != NULL)
; 14636:         return(comp);
; 14637: #endif
; 14638: 
; 14639:     xmlXPathInit();
; 14640: 
; 14641:     pctxt = xmlXPathNewParserContext(str, ctxt);

	push	esi
	push	ebx

; 501  :     xmlXPathNINF = -INFINITY;

	movsd	QWORD PTR _xmlXPathNINF, xmm0

; 14630:     xmlXPathParserContextPtr pctxt;
; 14631:     xmlXPathCompExprPtr comp;
; 14632: 
; 14633: #ifdef XPATH_STREAMING
; 14634:     comp = xmlXPathTryStreamCompile(ctxt, str);
; 14635:     if (comp != NULL)
; 14636:         return(comp);
; 14637: #endif
; 14638: 
; 14639:     xmlXPathInit();
; 14640: 
; 14641:     pctxt = xmlXPathNewParserContext(str, ctxt);

	call	_xmlXPathNewParserContext
	mov	esi, eax
	add	esp, 8

; 14642:     if (pctxt == NULL)

	test	esi, esi
	je	SHORT $LN14@xmlXPathCt

; 14643:         return NULL;
; 14644:     xmlXPathCompileExpr(pctxt, 1);

	push	1
	push	esi
	call	_xmlXPathCompileExpr
	add	esp, 8

; 14645: 
; 14646:     if( pctxt->error != XPATH_EXPRESSION_OK )

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN4@xmlXPathCt

; 14647:     {
; 14648:         xmlXPathFreeParserContext(pctxt);

	push	esi
	call	_xmlXPathFreeParserContext
	add	esp, 4
$LN14@xmlXPathCt:

; 14678: }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlXPathCt:

; 14649:         return(NULL);
; 14650:     }
; 14651: 
; 14652:     if (*pctxt->cur != 0) {

	mov	eax, DWORD PTR [esi]
	push	edi
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN5@xmlXPathCt

; 747  :     xmlXPathErr(ctxt, no);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8

; 14653: 	/*
; 14654: 	 * aleksey: in some cases this line prints *second* error message
; 14655: 	 * (see bug #78858) and probably this should be fixed.
; 14656: 	 * However, we are not sure that all error messages are printed
; 14657: 	 * out in other places. It's not critical so we leave it as-is for now
; 14658: 	 */
; 14659: 	xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);
; 14660: 	comp = NULL;

	xor	edi, edi

; 14661:     } else {

	jmp	SHORT $LN6@xmlXPathCt
$LN5@xmlXPathCt:

; 14662: 	comp = pctxt->comp;

	mov	edi, DWORD PTR [esi+32]

; 14663: 	pctxt->comp = NULL;

	mov	DWORD PTR [esi+32], 0
$LN6@xmlXPathCt:

; 14664:     }
; 14665:     xmlXPathFreeParserContext(pctxt);

	push	esi
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 14666: 
; 14667:     if (comp != NULL) {

	test	edi, edi
	je	SHORT $LN8@xmlXPathCt

; 14668: 	comp->expr = xmlStrdup(str);

	push	ebx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+16], eax

; 14669: #ifdef DEBUG_EVAL_COUNTS
; 14670: 	comp->string = xmlStrdup(str);
; 14671: 	comp->nb = 0;
; 14672: #endif
; 14673: 	if ((comp->nbStep > 1) && (comp->last >= 0)) {

	cmp	DWORD PTR [edi], 1
	jle	SHORT $LN8@xmlXPathCt
	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	js	SHORT $LN8@xmlXPathCt

; 14674: 	    xmlXPathOptimizeExpression(comp, &comp->steps[comp->last]);

	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ecx+edx*8]
	push	ecx
	push	edi
	call	_xmlXPathOptimizeExpression
	add	esp, 8
$LN8@xmlXPathCt:

; 14675: 	}
; 14676:     }
; 14677:     return(comp);

	mov	eax, edi
	pop	edi
$LN1@xmlXPathCt:

; 14678: }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPathCtxtCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCompile
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlXPathCompile PROC					; COMDAT

; 14690: xmlXPathCompile(const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _str$[ebp]
	push	0
	call	_xmlXPathCtxtCompile
	add	esp, 8

; 14691:     return(xmlXPathCtxtCompile(NULL, str));
; 14692: }

	pop	ebp
	ret	0
_xmlXPathCompile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEvalPredicate
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_res$ = 12						; size = 4
_xmlXPathEvalPredicate PROC				; COMDAT

; 14400: xmlXPathEvalPredicate(xmlXPathContextPtr ctxt, xmlXPathObjectPtr res) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _ctxt$[ebp]
	test	edx, edx
	je	$LN5@xmlXPathEv

; 14401:     if ((ctxt == NULL) || (res == NULL)) return(0);

	mov	eax, DWORD PTR _res$[ebp]
	test	eax, eax
	je	$LN5@xmlXPathEv

; 14402:     switch (res->type) {

	mov	ecx, DWORD PTR [eax]
	dec	ecx
	cmp	ecx, 8
	ja	SHORT $LN11@xmlXPathEv
	jmp	DWORD PTR $LN19@xmlXPathEv[ecx*4]
$LN6@xmlXPathEv:

; 14403:         case XPATH_BOOLEAN:
; 14404: 	    return(res->boolval);

	mov	eax, DWORD PTR [eax+8]

; 14419: }

	pop	ebp
	ret	0
$LN7@xmlXPathEv:
	movd	xmm1, DWORD PTR [edx+72]

; 14405:         case XPATH_NUMBER:
; 14406: 	    return(res->floatval == ctxt->proximityPosition);

	movsd	xmm0, QWORD PTR [eax+16]
	cvtdq2pd xmm1, xmm1
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@xmlXPathEv
	mov	eax, 1

; 14419: }

	pop	ebp
	ret	0
$LN8@xmlXPathEv:

; 14407:         case XPATH_NODESET:
; 14408:         case XPATH_XSLT_TREE:
; 14409: 	    if (res->nodesetval == NULL)

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathEv

; 14410: 		return(0);
; 14411: 	    return(res->nodesetval->nodeNr != 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 14419: }

	pop	ebp
	ret	0
$LN10@xmlXPathEv:

; 14412:         case XPATH_STRING:
; 14413: 	    return((res->stringval != NULL) &&

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN5@xmlXPathEv
	push	eax
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlXPathEv
	mov	eax, 1

; 14419: }

	pop	ebp
	ret	0
$LN11@xmlXPathEv:
	push	esi

; 14414: 	           (xmlStrlen(res->stringval) != 0));
; 14415:         default:
; 14416: 	    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	14416					; 00003850H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 14417:     }
; 14418:     return(0);

	pop	esi
$LN5@xmlXPathEv:

; 14419: }

	xor	eax, eax
	pop	ebp
	ret	0
	npad	1
$LN19@xmlXPathEv:
	DD	$LN8@xmlXPathEv
	DD	$LN6@xmlXPathEv
	DD	$LN7@xmlXPathEv
	DD	$LN10@xmlXPathEv
	DD	$LN11@xmlXPathEv
	DD	$LN11@xmlXPathEv
	DD	$LN11@xmlXPathEv
	DD	$LN11@xmlXPathEv
	DD	$LN8@xmlXPathEv
_xmlXPathEvalPredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEvalExpression
_TEXT	SEGMENT
_str$ = 8						; size = 4
_ctxt$ = 12						; size = 4
_xmlXPathEvalExpression PROC				; COMDAT

; 14943: xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 14945: }

	pop	ebp

; 14944:     return(xmlXPathEval(str, ctxt));

	jmp	_xmlXPathEval
_xmlXPathEvalExpression ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathEval
_TEXT	SEGMENT
_str$ = 8						; size = 4
_res$1$ = 12						; size = 4
_ctx$ = 12						; size = 4
_xmlXPathEval PROC					; COMDAT

; 14858: xmlXPathEval(const xmlChar *str, xmlXPathContextPtr ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctx$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlXPathEv

; 14859:     xmlXPathParserContextPtr ctxt;
; 14860:     xmlXPathObjectPtr res;
; 14861: 
; 14862:     CHECK_CTXT(ctx)

	push	OFFSET ??_C@_0BG@PBKLCIKP@NULL?5context?5pointer?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	push	14862					; 00003a0eH
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	3
	push	1
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
	xor	eax, eax

; 14887: }

	pop	ebp
	ret	0
$LN2@xmlXPathEv:

; 499  :     xmlXPathNAN = NAN;

	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR _xmlXPathNAN, xmm0

; 500  :     xmlXPathPINF = INFINITY;

	movsd	xmm0, QWORD PTR __real@7ff0000000000000
	push	ebx

; 14863: 
; 14864:     xmlXPathInit();
; 14865: 
; 14866:     ctxt = xmlXPathNewParserContext(str, ctx);

	push	eax
	push	DWORD PTR _str$[ebp]

; 500  :     xmlXPathPINF = INFINITY;

	movsd	QWORD PTR _xmlXPathPINF, xmm0

; 501  :     xmlXPathNINF = -INFINITY;

	movsd	xmm0, QWORD PTR __real@fff0000000000000
	movsd	QWORD PTR _xmlXPathNINF, xmm0

; 14863: 
; 14864:     xmlXPathInit();
; 14865: 
; 14866:     ctxt = xmlXPathNewParserContext(str, ctx);

	call	_xmlXPathNewParserContext
	mov	ebx, eax
	add	esp, 8

; 14867:     if (ctxt == NULL)

	test	ebx, ebx
	jne	SHORT $LN3@xmlXPathEv
	pop	ebx

; 14887: }

	pop	ebp
	ret	0
$LN3@xmlXPathEv:
	push	esi

; 14868:         return NULL;
; 14869:     xmlXPathEvalExpr(ctxt);

	push	ebx
	call	_xmlXPathEvalExpr
	add	esp, 4

; 14870: 
; 14871:     if (ctxt->error != XPATH_EXPRESSION_OK) {

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN4@xmlXPathEv

; 14880:                 "xmlXPathCompiledEval: %d object(s) left on the stack.\n",
; 14881:                 ctxt->valueNr);
; 14882:         }
; 14883:     }
; 14884: 
; 14885:     xmlXPathFreeParserContext(ctxt);

	push	ebx
	xor	esi, esi
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 14886:     return(res);

	mov	eax, esi
	pop	esi
	pop	ebx

; 14887: }

	pop	ebp
	ret	0
$LN4@xmlXPathEv:

; 14872: 	res = NULL;
; 14873:     } else {
; 14874: 	res = valuePop(ctxt);

	push	ebx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _res$1$[ebp], eax

; 14875:         if (res == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlXPathEv

; 14876:             xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CP@KKKCDCLL@xmlXPathCompiledEval?3?5No?5result@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	mov	esi, DWORD PTR _res$1$[ebp]
	add	esp, 8

; 14880:                 "xmlXPathCompiledEval: %d object(s) left on the stack.\n",
; 14881:                 ctxt->valueNr);
; 14882:         }
; 14883:     }
; 14884: 
; 14885:     xmlXPathFreeParserContext(ctxt);

	push	ebx
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 14886:     return(res);

	mov	eax, esi
	pop	esi
	pop	ebx

; 14887: }

	pop	ebp
	ret	0
$LN6@xmlXPathEv:

; 14877:                 "xmlXPathCompiledEval: No result on the stack.\n");
; 14878:         } else if (ctxt->valueNr > 0) {

	cmp	DWORD PTR [ebx+20], 0
	jle	SHORT $LN12@xmlXPathEv

; 14879:             xmlGenericError(xmlGenericErrorContext,

	push	edi
	call	___xmlGenericError
	mov	esi, DWORD PTR [ebx+20]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0DH@OEPEKFKA@xmlXPathCompiledEval?3?5?$CFd?5object@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	mov	esi, DWORD PTR _res$1$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi

; 14880:                 "xmlXPathCompiledEval: %d object(s) left on the stack.\n",
; 14881:                 ctxt->valueNr);
; 14882:         }
; 14883:     }
; 14884: 
; 14885:     xmlXPathFreeParserContext(ctxt);

	push	ebx
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 14886:     return(res);

	mov	eax, esi
	pop	esi
	pop	ebx

; 14887: }

	pop	ebp
	ret	0
$LN12@xmlXPathEv:

; 14880:                 "xmlXPathCompiledEval: %d object(s) left on the stack.\n",
; 14881:                 ctxt->valueNr);
; 14882:         }
; 14883:     }
; 14884: 
; 14885:     xmlXPathFreeParserContext(ctxt);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 14886:     return(res);

	mov	eax, esi
	pop	esi
	pop	ebx

; 14887: }

	pop	ebp
	ret	0
_xmlXPathEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeEval
_TEXT	SEGMENT
_node$ = 8						; size = 4
_str$ = 12						; size = 4
_ctx$ = 16						; size = 4
_xmlXPathNodeEval PROC					; COMDAT

; 14924: xmlXPathNodeEval(xmlNodePtr node, const xmlChar *str, xmlXPathContextPtr ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN8@xmlXPathNo

; 14901:     if ((node == NULL) || (ctx == NULL))

	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	SHORT $LN8@xmlXPathNo
	mov	ecx, DWORD PTR _ctx$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathNo

; 14902:         return(-1);
; 14903: 
; 14904:     if (node->doc == ctx->doc) {

	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN8@xmlXPathNo

; 14929:     return(xmlXPathEval(str, ctx));

	push	ecx
	push	DWORD PTR _str$[ebp]

; 14905:         ctx->node = node;

	mov	DWORD PTR [ecx+4], edx

; 14929:     return(xmlXPathEval(str, ctx));

	call	_xmlXPathEval
	add	esp, 8

; 14930: }

	pop	ebp
	ret	0
$LN8@xmlXPathNo:

; 14925:     if (str == NULL)
; 14926:         return(NULL);
; 14927:     if (xmlXPathSetContextNode(node, ctx) < 0)
; 14928:         return(NULL);

	xor	eax, eax

; 14930: }

	pop	ebp
	ret	0
_xmlXPathNodeEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathSetContextNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlXPathSetContextNode PROC				; COMDAT

; 14900: xmlXPathSetContextNode(xmlNodePtr node, xmlXPathContextPtr ctx) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlXPathSe

; 14901:     if ((node == NULL) || (ctx == NULL))

	mov	ecx, DWORD PTR _ctx$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathSe

; 14903: 
; 14904:     if (node->doc == ctx->doc) {

	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@xmlXPathSe

; 14905:         ctx->node = node;

	mov	DWORD PTR [ecx+4], edx

; 14906: 	return(0);

	xor	eax, eax

; 14907:     }
; 14908:     return(-1);
; 14909: }

	pop	ebp
	ret	0
$LN3@xmlXPathSe:

; 14902:         return(-1);

	or	eax, -1

; 14907:     }
; 14908:     return(-1);
; 14909: }

	pop	ebp
	ret	0
_xmlXPathSetContextNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathOrderDocElems
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlXPathOrderDocElems PROC				; COMDAT

; 3226 : xmlXPathOrderDocElems(xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _doc$[ebp]
	xor	edi, edi
	test	edx, edx
	jne	SHORT $LN7@xmlXPathOr

; 3227 :     ptrdiff_t count = 0;
; 3228 :     xmlNodePtr cur;
; 3229 : 
; 3230 :     if (doc == NULL)
; 3231 : 	return(-1);

	or	eax, -1
	pop	edi

; 3260 : }

	pop	ebp
	ret	0
$LN7@xmlXPathOr:

; 3232 :     cur = doc->children;

	mov	eax, DWORD PTR [edx+12]

; 3233 :     while (cur != NULL) {

	test	eax, eax
	je	SHORT $LN36@xmlXPathOr

; 3232 :     cur = doc->children;

	push	esi
	xor	esi, esi
$LL2@xmlXPathOr:

; 3234 : 	if (cur->type == XML_ELEMENT_NODE) {

	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN9@xmlXPathOr

; 3235 : 	    cur->content = (void *) (-(++count));
; 3236 : 	    if (cur->children != NULL) {

	mov	ecx, DWORD PTR [eax+12]
	dec	esi
	inc	edi
	mov	DWORD PTR [eax+40], esi
	test	ecx, ecx
	jne	SHORT $LN39@xmlXPathOr

; 3237 : 		cur = cur->children;
; 3238 : 		continue;
; 3239 : 	    }
; 3240 : 	}
; 3241 : 	if (cur->next != NULL) {
; 3242 : 	    cur = cur->next;
; 3243 : 	    continue;

	jmp	SHORT $LN9@xmlXPathOr
	npad	5
$LL6@xmlXPathOr:

; 3244 : 	}
; 3245 : 	do {
; 3246 : 	    cur = cur->parent;

	mov	eax, DWORD PTR [eax+20]

; 3247 : 	    if (cur == NULL)

	test	eax, eax
	je	SHORT $LN38@xmlXPathOr

; 3248 : 		break;
; 3249 : 	    if (cur == (xmlNodePtr) doc) {

	cmp	eax, edx
	je	SHORT $LN38@xmlXPathOr
$LN9@xmlXPathOr:

; 3233 :     while (cur != NULL) {

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LL6@xmlXPathOr
$LN39@xmlXPathOr:
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LL2@xmlXPathOr
$LN38@xmlXPathOr:
	pop	esi
$LN36@xmlXPathOr:

; 3250 : 		cur = NULL;
; 3251 : 		break;
; 3252 : 	    }
; 3253 : 	    if (cur->next != NULL) {
; 3254 : 		cur = cur->next;
; 3255 : 		break;
; 3256 : 	    }
; 3257 : 	} while (cur != NULL);
; 3258 :     }
; 3259 :     return((long) count);

	mov	eax, edi
	pop	edi

; 3260 : }

	pop	ebp
	ret	0
_xmlXPathOrderDocElems ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathContextSetCache
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_active$ = 12						; size = 4
_value$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlXPathContextSetCache PROC				; COMDAT

; 2251 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN24@xmlXPathCo

; 2252 :     if (ctxt == NULL)
; 2253 : 	return(-1);
; 2254 :     if (active) {

	cmp	DWORD PTR _active$[ebp], 0
	mov	edx, DWORD PTR [esi+200]
	je	$LN3@xmlXPathCo

; 2255 : 	xmlXPathContextCachePtr cache;
; 2256 : 
; 2257 : 	if (ctxt->cache == NULL) {

	test	edx, edx
	jne	$LN23@xmlXPathCo

; 2164 :     ret = (xmlXPathContextCachePtr) xmlMalloc(sizeof(xmlXPathContextCache));

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	mov	edx, eax
	add	esp, 4

; 2165 :     if (ret == NULL) {

	test	edx, edx
	jne	SHORT $LN12@xmlXPathCo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@LJLEGFLD@creating?5object?5cache?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 2167 : 	return(NULL);

	xor	edx, edx
	jmp	SHORT $LN11@xmlXPathCo
$LN12@xmlXPathCo:

; 2168 :     }
; 2169 :     memset(ret, 0 , (size_t) sizeof(xmlXPathContextCache));

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0

; 2170 :     ret->maxNodeset = 100;

	mov	DWORD PTR [edx+20], 100			; 00000064H

; 2171 :     ret->maxString = 100;

	mov	DWORD PTR [edx+24], 100			; 00000064H

; 2172 :     ret->maxBoolean = 100;

	mov	DWORD PTR [edx+28], 100			; 00000064H

; 2173 :     ret->maxNumber = 100;

	mov	DWORD PTR [edx+32], 100			; 00000064H

; 2174 :     ret->maxMisc = 100;

	mov	DWORD PTR [edx+36], 100			; 00000064H
$LN11@xmlXPathCo:

; 2258 : 	    ctxt->cache = xmlXPathNewCache();

	mov	DWORD PTR [esi+200], edx

; 2259 : 	    if (ctxt->cache == NULL)

	test	edx, edx
	je	SHORT $LN24@xmlXPathCo
$LN23@xmlXPathCo:

; 2261 : 	}
; 2262 : 	cache = (xmlXPathContextCachePtr) ctxt->cache;
; 2263 : 	if (options == 0) {

	cmp	DWORD PTR _options$[ebp], 0
	jne	SHORT $LN9@xmlXPathCo

; 2264 : 	    if (value < 0)
; 2265 : 		value = 100;
; 2266 : 	    cache->maxNodeset = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, 100				; 00000064H
	test	eax, eax
	pop	esi
	cmovns	ecx, eax

; 2275 :     }
; 2276 :     return(0);

	xor	eax, eax
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR [edx+24], ecx
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR [edx+28], ecx
	mov	DWORD PTR [edx+36], ecx

; 2277 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 2267 : 	    cache->maxString = value;
; 2268 : 	    cache->maxNumber = value;
; 2269 : 	    cache->maxBoolean = value;
; 2270 : 	    cache->maxMisc = value;
; 2271 : 	}
; 2272 :     } else if (ctxt->cache != NULL) {

	test	edx, edx
	je	SHORT $LN9@xmlXPathCo

; 2273 : 	xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);

	push	edx
	call	_xmlXPathFreeCache
	add	esp, 4

; 2274 : 	ctxt->cache = NULL;

	mov	DWORD PTR [esi+200], 0
$LN9@xmlXPathCo:

; 2275 :     }
; 2276 :     return(0);

	xor	eax, eax
	pop	esi

; 2277 : }

	pop	ebp
	ret	0
$LN24@xmlXPathCo:

; 2260 : 		return(-1);

	or	eax, -1
	pop	esi

; 2277 : }

	pop	ebp
	ret	0
_xmlXPathContextSetCache ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeContext
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPathFreeContext PROC				; COMDAT

; 6175 : xmlXPathFreeContext(xmlXPathContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPathFr

; 6176 :     if (ctxt == NULL) return;
; 6177 : 
; 6178 :     if (ctxt->cache != NULL)

	mov	eax, DWORD PTR [esi+200]
	test	eax, eax
	je	SHORT $LN3@xmlXPathFr

; 6179 : 	xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);

	push	eax
	call	_xmlXPathFreeCache
	add	esp, 4
$LN3@xmlXPathFr:

; 5209 :     xmlHashFree(ctxt->nsHash, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	push	DWORD PTR [esi+88]
	call	_xmlHashFree

; 4981 :     xmlHashFree(ctxt->funcHash, NULL);

	push	0
	push	DWORD PTR [esi+40]

; 5210 :     ctxt->nsHash = NULL;

	mov	DWORD PTR [esi+88], 0

; 4981 :     xmlHashFree(ctxt->funcHash, NULL);

	call	_xmlHashFree

; 5127 :     xmlHashFree(ctxt->varHash, xmlXPathFreeObjectEntry);

	push	OFFSET _xmlXPathFreeObjectEntry
	push	DWORD PTR [esi+16]

; 4982 :     ctxt->funcHash = NULL;

	mov	DWORD PTR [esi+40], 0

; 5127 :     xmlHashFree(ctxt->varHash, xmlXPathFreeObjectEntry);

	call	_xmlHashFree

; 6180 :     xmlXPathRegisteredNsCleanup(ctxt);
; 6181 :     xmlXPathRegisteredFuncsCleanup(ctxt);
; 6182 :     xmlXPathRegisteredVariablesCleanup(ctxt);
; 6183 :     xmlResetError(&ctxt->lastError);

	lea	eax, DWORD PTR [esi+136]

; 5128 :     ctxt->varHash = NULL;

	mov	DWORD PTR [esi+16], 0

; 6180 :     xmlXPathRegisteredNsCleanup(ctxt);
; 6181 :     xmlXPathRegisteredFuncsCleanup(ctxt);
; 6182 :     xmlXPathRegisteredVariablesCleanup(ctxt);
; 6183 :     xmlResetError(&ctxt->lastError);

	push	eax
	call	_xmlResetError

; 6184 :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 32					; 00000020H
$LN1@xmlXPathFr:
	pop	esi

; 6185 : }

	pop	ebp
	ret	0
_xmlXPathFreeContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNewContext
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_xmlXPathNewContext PROC				; COMDAT

; 6126 : xmlXPathNewContext(xmlDocPtr doc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	204					; 000000ccH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNe

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@GBNJEJGK@creating?5context?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@GBNJEJGK@creating?5context?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6127 :     xmlXPathContextPtr ret;
; 6128 : 
; 6129 :     ret = (xmlXPathContextPtr) xmlMalloc(sizeof(xmlXPathContext));
; 6130 :     if (ret == NULL) {
; 6131 :         xmlXPathErrMemory(NULL, "creating context\n");
; 6132 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 6166 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNe:

; 6133 :     }
; 6134 :     memset(ret, 0 , (size_t) sizeof(xmlXPathContext));

	push	172					; 000000acH
	lea	eax, DWORD PTR [esi+32]
	xorps	xmm0, xmm0
	push	0
	push	eax
	movq	QWORD PTR [esi+8], xmm0
	call	_memset

; 6135 :     ret->doc = doc;

	mov	eax, DWORD PTR _doc$[ebp]

; 6136 :     ret->node = NULL;
; 6137 : 
; 6138 :     ret->varHash = NULL;
; 6139 : 
; 6140 :     ret->nb_types = 0;
; 6141 :     ret->max_types = 0;
; 6142 :     ret->types = NULL;
; 6143 : 
; 6144 :     ret->funcHash = xmlHashCreate(0);

	push	0
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	call	_xmlHashCreate

; 6145 : 
; 6146 :     ret->nb_axis = 0;
; 6147 :     ret->max_axis = 0;
; 6148 :     ret->axis = NULL;
; 6149 : 
; 6150 :     ret->nsHash = NULL;
; 6151 :     ret->user = NULL;
; 6152 : 
; 6153 :     ret->contextSize = -1;
; 6154 :     ret->proximityPosition = -1;
; 6155 : 
; 6156 : #ifdef XP_DEFAULT_CACHE_ON
; 6157 :     if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
; 6158 : 	xmlXPathFreeContext(ret);
; 6159 : 	return(NULL);
; 6160 :     }
; 6161 : #endif
; 6162 : 
; 6163 :     xmlXPathRegisterAllFunctions(ret);

	push	esi
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], -1
	mov	DWORD PTR [esi+72], -1
	call	_xmlXPathRegisterAllFunctions
	add	esp, 20					; 00000014H

; 6164 : 
; 6165 :     return(ret);

	mov	eax, esi
	pop	esi

; 6166 : }

	pop	ebp
	ret	0
_xmlXPathNewContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathConvertString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathConvertString PROC				; COMDAT

; 5821 : xmlXPathConvertString(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	xor	ebx, ebx
	test	edi, edi
	jne	SHORT $LN4@xmlXPathCo

; 5856 : }

	pop	edi
	pop	ebx

; 5822 :     xmlChar *res = NULL;
; 5823 : 
; 5824 :     if (val == NULL)
; 5825 : 	return(xmlXPathNewCString(""));

	mov	DWORD PTR _val$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 5856 : }

	pop	ebp

; 5822 :     xmlChar *res = NULL;
; 5823 : 
; 5824 :     if (val == NULL)
; 5825 : 	return(xmlXPathNewCString(""));

	jmp	_xmlXPathNewCString
$LN4@xmlXPathCo:

; 5826 : 
; 5827 :     switch (val->type) {

	mov	eax, DWORD PTR [edi]
	dec	eax
	cmp	eax, 8
	ja	SHORT $LN2@xmlXPathCo
	jmp	DWORD PTR $LN16@xmlXPathCo[eax*4]
$LN6@xmlXPathCo:

; 5828 :     case XPATH_UNDEFINED:
; 5829 : #ifdef DEBUG_EXPR
; 5830 : 	xmlGenericError(xmlGenericErrorContext, "STRING: undefined\n");
; 5831 : #endif
; 5832 : 	break;
; 5833 :     case XPATH_NODESET:
; 5834 :     case XPATH_XSLT_TREE:
; 5835 : 	res = xmlXPathCastNodeSetToString(val->nodesetval);

	push	DWORD PTR [edi+4]
	call	_xmlXPathCastNodeSetToString
	add	esp, 4
	mov	ebx, eax

; 5836 : 	break;

	jmp	SHORT $LN2@xmlXPathCo
$LN7@xmlXPathCo:

; 5837 :     case XPATH_STRING:
; 5838 : 	return(val);

	mov	eax, edi
	pop	edi

; 5856 : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@xmlXPathCo:

; 5839 :     case XPATH_BOOLEAN:
; 5840 : 	res = xmlXPathCastBooleanToString(val->boolval);

	push	DWORD PTR [edi+8]
	call	_xmlXPathCastBooleanToString
	add	esp, 4
	mov	ebx, eax

; 5841 : 	break;

	jmp	SHORT $LN2@xmlXPathCo
$LN9@xmlXPathCo:

; 5842 :     case XPATH_NUMBER:
; 5843 : 	res = xmlXPathCastNumberToString(val->floatval);

	movsd	xmm0, QWORD PTR [edi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToString
	add	esp, 8
	mov	ebx, eax

; 5844 : 	break;

	jmp	SHORT $LN2@xmlXPathCo
$LN10@xmlXPathCo:
	push	esi

; 5845 :     case XPATH_USERS:
; 5846 :     case XPATH_POINT:
; 5847 :     case XPATH_RANGE:
; 5848 :     case XPATH_LOCATIONSET:
; 5849 : 	TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5849					; 000016d9H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN2@xmlXPathCo:

; 5850 : 	break;
; 5851 :     }
; 5852 :     xmlXPathFreeObject(val);

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4

; 5853 :     if (res == NULL)

	test	ebx, ebx
	jne	SHORT $LN11@xmlXPathCo

; 5856 : }

	pop	edi
	pop	ebx

; 5854 : 	return(xmlXPathNewCString(""));

	mov	DWORD PTR _val$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 5856 : }

	pop	ebp

; 5854 : 	return(xmlXPathNewCString(""));

	jmp	_xmlXPathNewCString
$LN11@xmlXPathCo:

; 5855 :     return(xmlXPathWrapString(res));

	push	ebx
	call	_xmlXPathWrapString
	add	esp, 4
	pop	edi

; 5856 : }

	pop	ebx
	pop	ebp
	ret	0
	npad	2
$LN16@xmlXPathCo:
	DD	$LN6@xmlXPathCo
	DD	$LN8@xmlXPathCo
	DD	$LN9@xmlXPathCo
	DD	$LN7@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN10@xmlXPathCo
	DD	$LN6@xmlXPathCo
_xmlXPathConvertString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathConvertNumber
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathConvertNumber PROC				; COMDAT

; 5986 : xmlXPathConvertNumber(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlXPathCo

; 5987 :     xmlXPathObjectPtr ret;
; 5988 : 
; 5989 :     if (val == NULL)
; 5990 : 	return(xmlXPathNewFloat(0.0));

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathNewFloat
	add	esp, 8
	pop	edi

; 5996 : }

	pop	ebp
	ret	0
$LN2@xmlXPathCo:

; 5991 :     if (val->type == XPATH_NUMBER)

	cmp	DWORD PTR [edi], 3
	jne	SHORT $LN3@xmlXPathCo

; 5992 : 	return(val);

	mov	eax, edi
	pop	edi

; 5996 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCo:
	push	esi

; 5993 :     ret = xmlXPathNewFloat(xmlXPathCastToNumber(val));

	push	edi
	call	_xmlXPathCastToNumber
	push	ecx
	fstp	QWORD PTR [esp]
	call	_xmlXPathNewFloat

; 5994 :     xmlXPathFreeObject(val);

	push	edi
	mov	esi, eax
	call	_xmlXPathFreeObject
	add	esp, 12					; 0000000cH

; 5995 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 5996 : }

	pop	ebp
	ret	0
_xmlXPathConvertNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathConvertBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathConvertBoolean PROC				; COMDAT

; 6099 : xmlXPathConvertBoolean(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlXPathCo

; 5259 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 5260 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN6@xmlXPathCo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BJ@ECLOGIHC@creating?5boolean?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 6108 :     return(ret);
; 6109 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlXPathCo:

; 5264 :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 6108 :     return(ret);
; 6109 : }

	add	esp, 12					; 0000000cH

; 5265 :     ret->type = XPATH_BOOLEAN;

	mov	DWORD PTR [esi], 2

; 6108 :     return(ret);
; 6109 : }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlXPathCo:

; 6100 :     xmlXPathObjectPtr ret;
; 6101 : 
; 6102 :     if (val == NULL)
; 6103 : 	return(xmlXPathNewBoolean(0));
; 6104 :     if (val->type == XPATH_BOOLEAN)

	cmp	DWORD PTR [edi], 2
	jne	SHORT $LN3@xmlXPathCo

; 6105 : 	return(val);

	mov	eax, edi
	pop	edi

; 6108 :     return(ret);
; 6109 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlXPathCo:

; 6106 :     ret = xmlXPathNewBoolean(xmlXPathCastToBoolean(val));

	push	edi
	call	_xmlXPathCastToBoolean
	push	eax
	call	_xmlXPathNewBoolean

; 6107 :     xmlXPathFreeObject(val);

	push	edi
	mov	esi, eax
	call	_xmlXPathFreeObject

; 6108 :     return(ret);
; 6109 : }

	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXPathConvertBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastToString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastToString PROC				; COMDAT

; 5775 : xmlXPathCastToString(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	xor	ecx, ecx
	test	eax, eax
	jne	SHORT $LN4@xmlXPathCa

; 5776 :     xmlChar *ret = NULL;
; 5777 : 
; 5778 :     if (val == NULL)
; 5779 : 	return(xmlStrdup((const xmlChar *) ""));

	mov	DWORD PTR _val$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 5809 : }

	pop	ebp

; 5776 :     xmlChar *ret = NULL;
; 5777 : 
; 5778 :     if (val == NULL)
; 5779 : 	return(xmlStrdup((const xmlChar *) ""));

	jmp	_xmlStrdup
$LN4@xmlXPathCa:

; 5780 :     switch (val->type) {

	mov	edx, DWORD PTR [eax]
	cmp	edx, 9
	ja	$LN2@xmlXPathCa
	jmp	DWORD PTR $LN16@xmlXPathCa[edx*4]
$LN5@xmlXPathCa:

; 5781 : 	case XPATH_UNDEFINED:
; 5782 : #ifdef DEBUG_EXPR
; 5783 : 	    xmlGenericError(xmlGenericErrorContext, "String: undefined\n");
; 5784 : #endif
; 5785 : 	    ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4

; 5806 : 	    break;
; 5807 :     }
; 5808 :     return(ret);

	mov	ecx, eax

; 5809 : }

	pop	ebp
	ret	0
$LN6@xmlXPathCa:

; 5786 : 	    break;
; 5787 :         case XPATH_NODESET:
; 5788 :         case XPATH_XSLT_TREE:
; 5789 : 	    ret = xmlXPathCastNodeSetToString(val->nodesetval);

	push	DWORD PTR [eax+4]
	call	_xmlXPathCastNodeSetToString
	add	esp, 4

; 5806 : 	    break;
; 5807 :     }
; 5808 :     return(ret);

	mov	ecx, eax

; 5809 : }

	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 5790 : 	    break;
; 5791 : 	case XPATH_STRING:
; 5792 : 	    return(xmlStrdup(val->stringval));

	push	DWORD PTR [eax+24]
	call	_xmlStrdup
	add	esp, 4

; 5809 : }

	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 5793 :         case XPATH_BOOLEAN:
; 5794 : 	    ret = xmlXPathCastBooleanToString(val->boolval);

	push	DWORD PTR [eax+8]
	call	_xmlXPathCastBooleanToString
	add	esp, 4

; 5806 : 	    break;
; 5807 :     }
; 5808 :     return(ret);

	mov	ecx, eax

; 5809 : }

	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 5795 : 	    break;
; 5796 : 	case XPATH_NUMBER: {
; 5797 : 	    ret = xmlXPathCastNumberToString(val->floatval);

	movsd	xmm0, QWORD PTR [eax+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToString
	add	esp, 8

; 5806 : 	    break;
; 5807 :     }
; 5808 :     return(ret);

	mov	ecx, eax

; 5809 : }

	pop	ebp
	ret	0
$LN10@xmlXPathCa:
	push	esi

; 5798 : 	    break;
; 5799 : 	}
; 5800 : 	case XPATH_USERS:
; 5801 : 	case XPATH_POINT:
; 5802 : 	case XPATH_RANGE:
; 5803 : 	case XPATH_LOCATIONSET:
; 5804 : 	    TODO

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5804					; 000016acH
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 5805 : 	    ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 20					; 00000014H

; 5806 : 	    break;
; 5807 :     }
; 5808 :     return(ret);

	mov	ecx, eax
	pop	esi
$LN2@xmlXPathCa:
	mov	eax, ecx

; 5809 : }

	pop	ebp
	ret	0
$LN16@xmlXPathCa:
	DD	$LN5@xmlXPathCa
	DD	$LN6@xmlXPathCa
	DD	$LN8@xmlXPathCa
	DD	$LN9@xmlXPathCa
	DD	$LN7@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN6@xmlXPathCa
_xmlXPathCastToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNodeSetToString
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_xmlXPathCastNodeSetToString PROC			; COMDAT

; 5756 : xmlXPathCastNodeSetToString (xmlNodeSetPtr ns) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ns$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlXPathCa

; 5757 :     if ((ns == NULL) || (ns->nodeNr == 0) || (ns->nodeTab == NULL))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPathCa
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 5758 : 	return(xmlStrdup((const xmlChar *) ""));
; 5759 : 
; 5760 :     if (ns->nodeNr > 1)

	cmp	ecx, 1
	jle	SHORT $LN4@xmlXPathCa

; 5761 : 	xmlXPathNodeSetSort(ns);

	push	esi
	call	_xmlXPathNodeSetSort
	mov	eax, DWORD PTR [esi+8]
	add	esp, 4
$LN4@xmlXPathCa:

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	DWORD PTR [eax]
	call	_xmlNodeGetContent
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@xmlXPathCa
$LN3@xmlXPathCa:

; 5762 :     return(xmlXPathCastNodeToString(ns->nodeTab[0]));
; 5763 : }

	pop	esi
	mov	DWORD PTR _ns$[ebp], OFFSET ??_C@_00CNPNBAHC@@
	pop	ebp
	jmp	_xmlStrdup
$LN1@xmlXPathCa:
	pop	esi
	pop	ebp
	ret	0
_xmlXPathCastNodeSetToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNodeToString
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlXPathCastNodeToString PROC				; COMDAT

; 5740 : xmlXPathCastNodeToString (xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _node$[ebp]
	call	_xmlNodeGetContent
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@xmlXPathCa

; 5741 : xmlChar *ret;
; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)
; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	mov	DWORD PTR _node$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 5744 :     return(ret);
; 5745 : }

	pop	ebp

; 5741 : xmlChar *ret;
; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)
; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	jmp	_xmlStrdup
$LN4@xmlXPathCa:

; 5744 :     return(ret);
; 5745 : }

	pop	ebp
	ret	0
_xmlXPathCastNodeToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNumberToString
_TEXT	SEGMENT
_buf$1 = -100						; size = 100
_val$ = 8						; size = 8
_xmlXPathCastNumberToString PROC			; COMDAT

; 5705 : xmlXPathCastNumberToString (double val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 528  :     return isinf(val) ? (val > 0 ? 1 : -1) : 0;

	movsd	xmm0, QWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	movsd	xmm0, QWORD PTR _val$[ebp]
	add	esp, 8
	cmp	ax, 1
	jne	SHORT $LN19@xmlXPathCa
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@0000000000000000
	seta	al
	lea	eax, DWORD PTR [eax*2-1]

; 5706 :     xmlChar *ret;
; 5707 :     switch (xmlXPathIsInf(val)) {

	cmp	eax, -1
	je	SHORT $LN5@xmlXPathCa
	cmp	eax, 1
	jne	SHORT $LN19@xmlXPathCa

; 5708 :     case 1:
; 5709 : 	ret = xmlStrdup((const xmlChar *) "Infinity");

	push	OFFSET ??_C@_08KEBCLIFP@Infinity@
	call	_xmlStrdup
	add	esp, 4

; 5726 : 	}
; 5727 :     }
; 5728 :     return(ret);
; 5729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPathCa:

; 5710 : 	break;
; 5711 :     case -1:
; 5712 : 	ret = xmlStrdup((const xmlChar *) "-Infinity");

	push	OFFSET ??_C@_09BLDCEMOH@?9Infinity@
	call	_xmlStrdup
	add	esp, 4

; 5726 : 	}
; 5727 :     }
; 5728 :     return(ret);
; 5729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXPathCa:

; 513  :     return isnan(val);

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	add	esp, 8
	cmp	ax, 2

; 5713 : 	break;
; 5714 :     default:
; 5715 : 	if (xmlXPathIsNaN(val)) {

	jne	SHORT $LN7@xmlXPathCa

; 5716 : 	    ret = xmlStrdup((const xmlChar *) "NaN");

	push	OFFSET ??_C@_03ICJPMMHB@NaN@
	call	_xmlStrdup
	add	esp, 4

; 5726 : 	}
; 5727 :     }
; 5728 :     return(ret);
; 5729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 5717 : 	} else if (val == 0) {

	movsd	xmm0, QWORD PTR _val$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@xmlXPathCa

; 5718 :             /* Omit sign for negative zero. */
; 5719 : 	    ret = xmlStrdup((const xmlChar *) "0");

	push	OFFSET ??_C@_01GBGANLPD@0@
	call	_xmlStrdup
	add	esp, 4

; 5726 : 	}
; 5727 :     }
; 5728 :     return(ret);
; 5729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 5720 : 	} else {
; 5721 : 	    /* could be improved */
; 5722 : 	    char buf[100];
; 5723 : 	    xmlXPathFormatNumber(val, buf, 99);

	push	99					; 00000063H
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathFormatNumber

; 5724 : 	    buf[99] = 0;
; 5725 : 	    ret = xmlStrdup((const xmlChar *) buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+99], 0
	push	eax
	call	_xmlStrdup
	add	esp, 20					; 00000014H

; 5726 : 	}
; 5727 :     }
; 5728 :     return(ret);
; 5729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCastNumberToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastBooleanToString
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastBooleanToString PROC			; COMDAT

; 5687 : xmlXPathCastBooleanToString (int val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _val$[ebp], 0
	mov	eax, OFFSET ??_C@_05LAPONLG@false@
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true@
	cmovne	eax, ecx

; 5688 :     xmlChar *ret;
; 5689 :     if (val)
; 5690 : 	ret = xmlStrdup((const xmlChar *) "true");
; 5691 :     else
; 5692 : 	ret = xmlStrdup((const xmlChar *) "false");
; 5693 :     return(ret);

	mov	DWORD PTR _val$[ebp], eax

; 5694 : }

	pop	ebp

; 5688 :     xmlChar *ret;
; 5689 :     if (val)
; 5690 : 	ret = xmlStrdup((const xmlChar *) "true");
; 5691 :     else
; 5692 : 	ret = xmlStrdup((const xmlChar *) "false");
; 5693 :     return(ret);

	jmp	_xmlStrdup
_xmlXPathCastBooleanToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastToNumber
_TEXT	SEGMENT
_ret$ = -8						; size = 8
_val$ = 8						; size = 4
_xmlXPathCastToNumber PROC				; COMDAT

; 5940 : xmlXPathCastToNumber(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR _ret$[ebp], xmm0
	test	eax, eax
	jne	SHORT $LN4@xmlXPathCa

; 5941 :     double ret = 0.0;
; 5942 : 
; 5943 :     if (val == NULL)
; 5944 : 	return(NAN);

	fld	QWORD PTR __real@fff8000000000000

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlXPathCa:

; 5945 :     switch (val->type) {

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 9
	ja	SHORT $LN14@xmlXPathCa
	jmp	DWORD PTR $LN18@xmlXPathCa[ecx*4]
$LN6@xmlXPathCa:

; 5946 :     case XPATH_UNDEFINED:
; 5947 : #ifdef DEGUB_EXPR
; 5948 : 	xmlGenericError(xmlGenericErrorContext, "NUMBER: undefined\n");
; 5949 : #endif
; 5950 : 	ret = NAN;
; 5951 : 	break;
; 5952 :     case XPATH_NODESET:
; 5953 :     case XPATH_XSLT_TREE:
; 5954 : 	ret = xmlXPathCastNodeSetToNumber(val->nodesetval);

	push	DWORD PTR [eax+4]
	call	_xmlXPathCastNodeSetToNumber
	add	esp, 4

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 5883 :     return(xmlXPathStringEvalNumber(val));

	push	DWORD PTR [eax+24]
	call	_xmlXPathStringEvalNumber
	add	esp, 4

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 5955 : 	break;
; 5956 :     case XPATH_STRING:
; 5957 : 	ret = xmlXPathCastStringToNumber(val->stringval);
; 5958 : 	break;
; 5959 :     case XPATH_NUMBER:
; 5960 : 	ret = val->floatval;

	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR _ret$[ebp], xmm0
	fld	QWORD PTR _ret$[ebp]

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 5961 : 	break;
; 5962 :     case XPATH_BOOLEAN:
; 5963 : 	ret = xmlXPathCastBooleanToNumber(val->boolval);

	push	DWORD PTR [eax+8]
	call	_xmlXPathCastBooleanToNumber
	add	esp, 4

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathCa:
	push	esi

; 5964 : 	break;
; 5965 :     case XPATH_USERS:
; 5966 :     case XPATH_POINT:
; 5967 :     case XPATH_RANGE:
; 5968 :     case XPATH_LOCATIONSET:
; 5969 : 	TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	5969					; 00001751H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
	pop	esi
$LN5@xmlXPathCa:

; 5945 :     switch (val->type) {

	movsd	xmm0, QWORD PTR __real@fff8000000000000
	movsd	QWORD PTR _ret$[ebp], xmm0
$LN14@xmlXPathCa:
	fld	QWORD PTR _ret$[ebp]

; 5970 : 	ret = NAN;
; 5971 : 	break;
; 5972 :     }
; 5973 :     return(ret);
; 5974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@xmlXPathCa:
	DD	$LN5@xmlXPathCa
	DD	$LN6@xmlXPathCa
	DD	$LN9@xmlXPathCa
	DD	$LN8@xmlXPathCa
	DD	$LN7@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN6@xmlXPathCa
_xmlXPathCastToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNodeSetToNumber
_TEXT	SEGMENT
_ret$1$ = -8						; size = 8
_ns$ = 8						; size = 4
_xmlXPathCastNodeSetToNumber PROC			; COMDAT

; 5919 : xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlXPathCa

; 5920 :     xmlChar *str;
; 5921 :     double ret;
; 5922 : 
; 5923 :     if (ns == NULL)
; 5924 : 	return(NAN);

	fld	QWORD PTR __real@fff8000000000000

; 5929 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlXPathCa:
	push	esi

; 5925 :     str = xmlXPathCastNodeSetToString(ns);

	push	eax
	call	_xmlXPathCastNodeSetToString
	mov	esi, eax

; 5883 :     return(xmlXPathStringEvalNumber(val));

	push	esi
	call	_xmlXPathStringEvalNumber

; 5926 :     ret = xmlXPathCastStringToNumber(str);
; 5927 :     xmlFree(str);

	push	esi

; 5883 :     return(xmlXPathStringEvalNumber(val));

	fstp	QWORD PTR _ret$1$[ebp]

; 5926 :     ret = xmlXPathCastStringToNumber(str);
; 5927 :     xmlFree(str);

	call	DWORD PTR _xmlFree

; 5928 :     return(ret);

	fld	QWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH
	pop	esi

; 5929 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCastNodeSetToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNodeToNumber
_TEXT	SEGMENT
_ret$1$ = -8						; size = 8
_node$ = 8						; size = 4
_xmlXPathCastNodeToNumber PROC				; COMDAT

; 5895 : xmlXPathCastNodeToNumber (xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlXPathCa

; 5742 :     if ((ret = xmlNodeGetContent(node)) == NULL)

	push	eax
	call	_xmlNodeGetContent
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN3@xmlXPathCa

; 5743 : 	ret = xmlStrdup((const xmlChar *) "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 5896 :     xmlChar *strval;
; 5897 :     double ret;
; 5898 : 
; 5899 :     if (node == NULL)
; 5900 : 	return(NAN);
; 5901 :     strval = xmlXPathCastNodeToString(node);
; 5902 :     if (strval == NULL)

	test	esi, esi
	je	SHORT $LN10@xmlXPathCa
$LN3@xmlXPathCa:

; 5883 :     return(xmlXPathStringEvalNumber(val));

	push	esi
	call	_xmlXPathStringEvalNumber

; 5904 :     ret = xmlXPathCastStringToNumber(strval);
; 5905 :     xmlFree(strval);

	push	esi

; 5883 :     return(xmlXPathStringEvalNumber(val));

	fstp	QWORD PTR _ret$1$[ebp]

; 5904 :     ret = xmlXPathCastStringToNumber(strval);
; 5905 :     xmlFree(strval);

	call	DWORD PTR _xmlFree

; 5906 : 
; 5907 :     return(ret);

	fld	QWORD PTR _ret$1$[ebp]
	add	esp, 8
	pop	esi

; 5908 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPathCa:

; 5903 : 	return(NAN);

	fld	QWORD PTR __real@fff8000000000000
	pop	esi

; 5908 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCastNodeToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastStringToNumber
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastStringToNumber PROC			; COMDAT

; 5882 : xmlXPathCastStringToNumber(const xmlChar * val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 5884 : }

	pop	ebp

; 5883 :     return(xmlXPathStringEvalNumber(val));

	jmp	_xmlXPathStringEvalNumber
_xmlXPathCastStringToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastBooleanToNumber
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastBooleanToNumber PROC			; COMDAT

; 5867 : xmlXPathCastBooleanToNumber(int val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN2@xmlXPathCa

; 5868 :     if (val)
; 5869 : 	return(1.0);

	fld1

; 5871 : }

	pop	ebp
	ret	0
$LN2@xmlXPathCa:

; 5870 :     return(0.0);

	fldz

; 5871 : }

	pop	ebp
	ret	0
_xmlXPathCastBooleanToNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastToBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastToBoolean PROC				; COMDAT

; 6052 : xmlXPathCastToBoolean (xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _val$[ebp]
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN12@xmlXPathCa

; 6053 :     int ret = 0;
; 6054 : 
; 6055 :     if (val == NULL)
; 6056 : 	return(0);
; 6057 :     switch (val->type) {

	mov	edx, DWORD PTR [ecx]
	cmp	edx, 9
	ja	SHORT $LN1@xmlXPathCa
	jmp	DWORD PTR $LN14@xmlXPathCa[edx*4]
$LN6@xmlXPathCa:

; 6058 :     case XPATH_UNDEFINED:
; 6059 : #ifdef DEBUG_EXPR
; 6060 : 	xmlGenericError(xmlGenericErrorContext, "BOOLEAN: undefined\n");
; 6061 : #endif
; 6062 : 	ret = 0;
; 6063 : 	break;
; 6064 :     case XPATH_NODESET:
; 6065 :     case XPATH_XSLT_TREE:
; 6066 : 	ret = xmlXPathCastNodeSetToBoolean(val->nodesetval);

	push	DWORD PTR [ecx+4]
	call	_xmlXPathCastNodeSetToBoolean
	add	esp, 4

; 6083 : 	break;
; 6084 :     }
; 6085 :     return(ret);
; 6086 : }

	pop	ebp
	ret	0
$LN7@xmlXPathCa:

; 6067 : 	break;
; 6068 :     case XPATH_STRING:
; 6069 : 	ret = xmlXPathCastStringToBoolean(val->stringval);

	push	DWORD PTR [ecx+24]
	call	_xmlXPathCastStringToBoolean
	add	esp, 4

; 6083 : 	break;
; 6084 :     }
; 6085 :     return(ret);
; 6086 : }

	pop	ebp
	ret	0
$LN8@xmlXPathCa:

; 6070 : 	break;
; 6071 :     case XPATH_NUMBER:
; 6072 : 	ret = xmlXPathCastNumberToBoolean(val->floatval);

	movsd	xmm0, QWORD PTR [ecx+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathCastNumberToBoolean
	add	esp, 8

; 6083 : 	break;
; 6084 :     }
; 6085 :     return(ret);
; 6086 : }

	pop	ebp
	ret	0
$LN9@xmlXPathCa:

; 6073 : 	break;
; 6074 :     case XPATH_BOOLEAN:
; 6075 : 	ret = val->boolval;

	mov	eax, DWORD PTR [ecx+8]

; 6083 : 	break;
; 6084 :     }
; 6085 :     return(ret);
; 6086 : }

	pop	ebp
	ret	0
$LN10@xmlXPathCa:
	push	esi

; 6076 : 	break;
; 6077 :     case XPATH_USERS:
; 6078 :     case XPATH_POINT:
; 6079 :     case XPATH_RANGE:
; 6080 :     case XPATH_LOCATIONSET:
; 6081 : 	TODO;

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	6081					; 000017c1H
	push	OFFSET ??_C@_0GH@HIGHEHKE@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 6082 : 	ret = 0;

	pop	esi
$LN12@xmlXPathCa:

; 6083 : 	break;
; 6084 :     }
; 6085 :     return(ret);
; 6086 : }

	xor	eax, eax
$LN1@xmlXPathCa:
	pop	ebp
	ret	0
$LN14@xmlXPathCa:
	DD	$LN12@xmlXPathCa
	DD	$LN6@xmlXPathCa
	DD	$LN9@xmlXPathCa
	DD	$LN8@xmlXPathCa
	DD	$LN7@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN10@xmlXPathCa
	DD	$LN6@xmlXPathCa
_xmlXPathCastToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNodeSetToBoolean
_TEXT	SEGMENT
_ns$ = 8						; size = 4
_xmlXPathCastNodeSetToBoolean PROC			; COMDAT

; 6037 : xmlXPathCastNodeSetToBoolean (xmlNodeSetPtr ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ns$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 6038 :     if ((ns == NULL) || (ns->nodeNr == 0))

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlXPathCa

; 6040 :     return(1);

	mov	eax, 1

; 6041 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 6039 : 	return(0);

	xor	eax, eax

; 6041 : }

	pop	ebp
	ret	0
_xmlXPathCastNodeSetToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastStringToBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathCastStringToBoolean PROC			; COMDAT

; 6022 : xmlXPathCastStringToBoolean (const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 6023 :     if ((val == NULL) || (xmlStrlen(val) == 0))

	push	eax
	call	_xmlStrlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@xmlXPathCa

; 6025 :     return(1);

	mov	eax, 1

; 6026 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 6024 : 	return(0);

	xor	eax, eax

; 6026 : }

	pop	ebp
	ret	0
_xmlXPathCastStringToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCastNumberToBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 8
_xmlXPathCastNumberToBoolean PROC			; COMDAT

; 6007 : xmlXPathCastNumberToBoolean (double val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4

; 513  :     return isnan(val);

	movsd	xmm0, QWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___dclass
	add	esp, 8
	cmp	ax, 2

; 6008 :      if (xmlXPathIsNaN(val) || (val == 0.0))

	je	SHORT $LN3@xmlXPathCa
	movsd	xmm0, QWORD PTR _val$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@xmlXPathCa

; 6010 :      return(1);

	mov	eax, 1

; 6011 : }

	pop	ebp
	ret	0
$LN3@xmlXPathCa:

; 6009 : 	 return(0);

	xor	eax, eax

; 6011 : }

	pop	ebp
	ret	0
_xmlXPathCastNumberToBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathCmpNodes
_TEXT	SEGMENT
tv558 = -4						; size = 4
tv609 = 8						; size = 4
_cur$3$ = 8						; size = 4
_node1$ = 8						; size = 4
_node2$ = 12						; size = 4
_xmlXPathCmpNodes PROC					; COMDAT

; 3273 : xmlXPathCmpNodes(xmlNodePtr node1, xmlNodePtr node2) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _node2$[ebp]
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	push	edi
	mov	edi, DWORD PTR _node1$[ebp]
	mov	ebx, edi
	mov	DWORD PTR tv558[ebp], esi
	call	@__CheckForDebuggerJustMyCode@4
	test	edi, edi
	je	$LN20@xmlXPathCm

; 3274 :     int depth1, depth2;
; 3275 :     int attr1 = 0, attr2 = 0;
; 3276 :     xmlNodePtr attrNode1 = NULL, attrNode2 = NULL;
; 3277 :     xmlNodePtr cur, root;
; 3278 : 
; 3279 :     if ((node1 == NULL) || (node2 == NULL))

	test	esi, esi
	je	$LN20@xmlXPathCm

; 3280 : 	return(-2);
; 3281 :     /*
; 3282 :      * a couple of optimizations which will avoid computations in most cases
; 3283 :      */
; 3284 :     if (node1 == node2)		/* trivial case */

	cmp	edi, esi
	je	$LN26@xmlXPathCm

; 3285 : 	return(0);
; 3286 :     if (node1->type == XML_ATTRIBUTE_NODE) {

	mov	edx, DWORD PTR [edi+4]
	cmp	edx, 2
	jne	SHORT $LN22@xmlXPathCm

; 3287 : 	attr1 = 1;
; 3288 : 	attrNode1 = node1;
; 3289 : 	node1 = node1->parent;

	mov	edi, DWORD PTR [edi+20]
$LN22@xmlXPathCm:

; 3290 :     }
; 3291 :     if (node2->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	edx, 2
	cmovne	ebx, eax
	cmp	edx, 2
	sete	al
	mov	DWORD PTR tv609[ebp], eax
	cmp	ecx, 2
	jne	SHORT $LN23@xmlXPathCm

; 3292 : 	attr2 = 1;
; 3293 : 	attrNode2 = node2;
; 3294 : 	node2 = node2->parent;

	mov	esi, DWORD PTR [esi+20]
	mov	DWORD PTR _node2$[ebp], esi
$LN23@xmlXPathCm:

; 3295 :     }
; 3296 :     if (node1 == node2) {

	cmp	edi, esi
	jne	SHORT $LN24@xmlXPathCm
	xor	eax, eax
	cmp	ecx, 2
	sete	al

; 3297 : 	if (attr1 == attr2) {

	cmp	DWORD PTR tv609[ebp], eax
	jne	SHORT $LN25@xmlXPathCm

; 3298 : 	    /* not required, but we keep attributes in order */
; 3299 : 	    if (attr1 != 0) {

	cmp	edx, 2
	jne	$LN26@xmlXPathCm

; 3295 :     }
; 3296 :     if (node1 == node2) {

	mov	eax, DWORD PTR tv558[ebp]
	xor	edx, edx
	cmp	ecx, 2
	cmovne	eax, edx

; 3300 : 	        cur = attrNode2->prev;

	mov	eax, DWORD PTR [eax+28]

; 3301 : 		while (cur != NULL) {

	test	eax, eax
	je	$LN17@xmlXPathCm
	npad	2
$LL2@xmlXPathCm:

; 3302 : 		    if (cur == attrNode1)

	cmp	eax, ebx
	je	SHORT $LN30@xmlXPathCm

; 3303 : 		        return (1);
; 3304 : 		    cur = cur->prev;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL2@xmlXPathCm

; 3405 : 	    return(1);
; 3406 :     return(-1); /* assume there is no sibling list corruption */
; 3407 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlXPathCm:

; 3305 : 		}
; 3306 : 		return (-1);
; 3307 : 	    }
; 3308 : 	    return(0);
; 3309 : 	}
; 3310 : 	if (attr2 == 1)

	cmp	ecx, 2
	jne	$LN17@xmlXPathCm
$LN30@xmlXPathCm:
	pop	edi

; 3405 : 	    return(1);
; 3406 :     return(-1); /* assume there is no sibling list corruption */
; 3407 : }

	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlXPathCm:

; 3311 : 	    return(1);
; 3312 : 	return(-1);
; 3313 :     }
; 3314 :     if ((node1->type == XML_NAMESPACE_DECL) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	je	SHORT $LN30@xmlXPathCm
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN30@xmlXPathCm

; 3315 :         (node2->type == XML_NAMESPACE_DECL))
; 3316 : 	return(1);
; 3317 :     if (node1 == node2->prev)

	cmp	edi, DWORD PTR [esi+28]
	je	SHORT $LN30@xmlXPathCm

; 3318 : 	return(1);
; 3319 :     if (node1 == node2->next)

	cmp	edi, DWORD PTR [esi+24]
	je	$LN17@xmlXPathCm

; 3320 : 	return(-1);
; 3321 : 
; 3322 :     /*
; 3323 :      * Speedup using document order if availble.
; 3324 :      */
; 3325 :     if ((node1->type == XML_ELEMENT_NODE) &&
; 3326 : 	(node2->type == XML_ELEMENT_NODE) &&
; 3327 : 	(0 > (ptrdiff_t) node1->content) &&
; 3328 : 	(0 > (ptrdiff_t) node2->content) &&

	cmp	eax, 1
	jne	SHORT $LN35@xmlXPathCm
	cmp	ecx, eax
	jne	SHORT $LN35@xmlXPathCm
	mov	ecx, DWORD PTR [edi+40]
	test	ecx, ecx
	jns	SHORT $LN35@xmlXPathCm
	mov	edx, DWORD PTR [esi+40]
	test	edx, edx
	jns	SHORT $LN35@xmlXPathCm
	mov	eax, DWORD PTR [edi+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN35@xmlXPathCm

; 3329 : 	(node1->doc == node2->doc)) {
; 3330 : 	ptrdiff_t l1, l2;
; 3331 : 
; 3332 : 	l1 = -((ptrdiff_t) node1->content);

	neg	ecx

; 3333 : 	l2 = -((ptrdiff_t) node2->content);

	neg	edx

; 3334 : 	if (l1 < l2)

	cmp	ecx, edx
	jl	SHORT $LN30@xmlXPathCm

; 3335 : 	    return(1);
; 3336 : 	if (l1 > l2)

	jg	$LN17@xmlXPathCm
$LN35@xmlXPathCm:

; 3337 : 	    return(-1);
; 3338 :     }
; 3339 : 
; 3340 :     /*
; 3341 :      * compute depth to root
; 3342 :      */
; 3343 :     for (depth2 = 0, cur = node2;cur->parent != NULL;cur = cur->parent) {

	mov	ecx, DWORD PTR [esi+20]
	xor	eax, eax
	mov	ebx, esi
	test	ecx, ecx
	je	SHORT $LN5@xmlXPathCm
$LL6@xmlXPathCm:

; 3344 : 	if (cur->parent == node1)

	cmp	ecx, edi
	je	SHORT $LN30@xmlXPathCm

; 3345 : 	    return(1);
; 3346 : 	depth2++;

	mov	ebx, ecx
	inc	eax
	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	jne	SHORT $LL6@xmlXPathCm
$LN5@xmlXPathCm:

; 3347 :     }
; 3348 :     root = cur;
; 3349 :     for (depth1 = 0, cur = node1;cur->parent != NULL;cur = cur->parent) {

	mov	ecx, DWORD PTR [edi+20]
	xor	edx, edx
	mov	DWORD PTR _cur$3$[ebp], edi
	test	ecx, ecx
	je	SHORT $LN8@xmlXPathCm
	npad	6
$LL9@xmlXPathCm:

; 3350 : 	if (cur->parent == node2)

	cmp	ecx, esi
	je	$LN17@xmlXPathCm

; 3351 : 	    return(-1);
; 3352 : 	depth1++;

	mov	esi, ecx
	inc	edx
	mov	DWORD PTR _cur$3$[ebp], esi
	mov	ecx, DWORD PTR [esi+20]
	mov	esi, DWORD PTR _node2$[ebp]
	test	ecx, ecx
	jne	SHORT $LL9@xmlXPathCm
$LN8@xmlXPathCm:

; 3353 :     }
; 3354 :     /*
; 3355 :      * Distinct document (or distinct entities :-( ) case.
; 3356 :      */
; 3357 :     if (root != cur) {

	cmp	ebx, DWORD PTR _cur$3$[ebp]
	jne	$LN20@xmlXPathCm

; 3358 : 	return(-2);
; 3359 :     }
; 3360 :     /*
; 3361 :      * get the nearest common ancestor.
; 3362 :      */
; 3363 :     while (depth1 > depth2) {

	cmp	eax, edx
	jge	SHORT $LN81@xmlXPathCm
	sub	edx, eax
	mov	ecx, edx
	mov	edx, eax
	npad	5
$LL10@xmlXPathCm:

; 3364 : 	depth1--;
; 3365 : 	node1 = node1->parent;

	mov	edi, DWORD PTR [edi+20]
	sub	ecx, 1
	jne	SHORT $LL10@xmlXPathCm

; 3366 :     }
; 3367 :     while (depth2 > depth1) {

	cmp	eax, edx
$LN81@xmlXPathCm:
	jle	SHORT $LN53@xmlXPathCm
	sub	eax, edx
	npad	2
$LL12@xmlXPathCm:

; 3368 : 	depth2--;
; 3369 : 	node2 = node2->parent;

	mov	esi, DWORD PTR [esi+20]
	sub	eax, 1
	jne	SHORT $LL12@xmlXPathCm
$LN53@xmlXPathCm:

; 3370 :     }
; 3371 :     while (node1->parent != node2->parent) {

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	je	SHORT $LN15@xmlXPathCm
$LL14@xmlXPathCm:

; 3372 : 	node1 = node1->parent;

	mov	edi, eax

; 3373 : 	node2 = node2->parent;

	mov	esi, ecx

; 3374 : 	/* should not happen but just in case ... */
; 3375 : 	if ((node1 == NULL) || (node2 == NULL))

	test	edi, edi
	je	SHORT $LN20@xmlXPathCm
	test	esi, esi
	je	SHORT $LN20@xmlXPathCm

; 3370 :     }
; 3371 :     while (node1->parent != node2->parent) {

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jne	SHORT $LL14@xmlXPathCm
$LN15@xmlXPathCm:

; 3376 : 	    return(-2);
; 3377 :     }
; 3378 :     /*
; 3379 :      * Find who's first.
; 3380 :      */
; 3381 :     if (node1 == node2->prev)

	cmp	edi, DWORD PTR [esi+28]
	je	$LN30@xmlXPathCm

; 3382 : 	return(1);
; 3383 :     if (node1 == node2->next)

	cmp	edi, DWORD PTR [esi+24]
	je	SHORT $LN17@xmlXPathCm

; 3384 : 	return(-1);
; 3385 :     /*
; 3386 :      * Speedup using document order if availble.
; 3387 :      */
; 3388 :     if ((node1->type == XML_ELEMENT_NODE) &&
; 3389 : 	(node2->type == XML_ELEMENT_NODE) &&
; 3390 : 	(0 > (ptrdiff_t) node1->content) &&
; 3391 : 	(0 > (ptrdiff_t) node2->content) &&

	cmp	DWORD PTR [edi+4], 1
	jne	SHORT $LN45@xmlXPathCm
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN45@xmlXPathCm
	mov	ecx, DWORD PTR [edi+40]
	test	ecx, ecx
	jns	SHORT $LN45@xmlXPathCm
	mov	edx, DWORD PTR [esi+40]
	test	edx, edx
	jns	SHORT $LN45@xmlXPathCm
	mov	eax, DWORD PTR [edi+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN45@xmlXPathCm

; 3392 : 	(node1->doc == node2->doc)) {
; 3393 : 	ptrdiff_t l1, l2;
; 3394 : 
; 3395 : 	l1 = -((ptrdiff_t) node1->content);

	neg	ecx

; 3396 : 	l2 = -((ptrdiff_t) node2->content);

	neg	edx

; 3397 : 	if (l1 < l2)

	cmp	ecx, edx
	jl	$LN30@xmlXPathCm

; 3398 : 	    return(1);
; 3399 : 	if (l1 > l2)

	jg	SHORT $LN17@xmlXPathCm
$LN45@xmlXPathCm:

; 3400 : 	    return(-1);
; 3401 :     }
; 3402 : 
; 3403 :     for (cur = node1->next;cur != NULL;cur = cur->next)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN17@xmlXPathCm
	npad	3
$LL18@xmlXPathCm:

; 3404 : 	if (cur == node2)

	cmp	eax, esi
	je	$LN30@xmlXPathCm

; 3400 : 	    return(-1);
; 3401 :     }
; 3402 : 
; 3403 :     for (cur = node1->next;cur != NULL;cur = cur->next)

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL18@xmlXPathCm
$LN17@xmlXPathCm:
	pop	edi

; 3405 : 	    return(1);
; 3406 :     return(-1); /* assume there is no sibling list corruption */
; 3407 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlXPathCm:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlXPathCm:
	pop	edi
	pop	esi
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPathCmpNodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathObjectCopy
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathObjectCopy PROC				; COMDAT

; 5402 : xmlXPathObjectCopy(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _val$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlXPathOb

; 5403 :     xmlXPathObjectPtr ret;
; 5404 : 
; 5405 :     if (val == NULL)
; 5406 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN4@xmlXPathOb:
	push	ebx

; 5407 : 
; 5408 :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 5409 :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN5@xmlXPathOb

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BA@KJDNPDLE@copying?5object?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BA@KJDNPDLE@copying?5object?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 5410 :         xmlXPathErrMemory(NULL, "copying object\n");
; 5411 : 	return(NULL);

	xor	eax, eax
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN5@xmlXPathOb:

; 5412 :     }
; 5413 :     memcpy(ret, val , (size_t) sizeof(xmlXPathObject));

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR [ebx], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [ebx+16], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	movups	XMMWORD PTR [ebx+32], xmm0

; 5414 : #ifdef XP_DEBUG_OBJ_USAGE
; 5415 :     xmlXPathDebugObjUsageRequested(NULL, val->type);
; 5416 : #endif
; 5417 :     switch (val->type) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 9
	ja	SHORT $LN2@xmlXPathOb
	jmp	DWORD PTR $LN24@xmlXPathOb[eax*4]
$LN7@xmlXPathOb:

; 5418 : 	case XPATH_BOOLEAN:
; 5419 : 	case XPATH_NUMBER:
; 5420 : 	case XPATH_POINT:
; 5421 : 	case XPATH_RANGE:
; 5422 : 	    break;
; 5423 : 	case XPATH_STRING:
; 5424 : 	    ret->stringval = xmlStrdup(val->stringval);

	push	DWORD PTR [esi+24]
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [ebx+24], eax

; 5477 : 		    "xmlXPathObjectCopy: unsupported type %d\n",
; 5478 : 		    val->type);
; 5479 : 	    break;
; 5480 :     }
; 5481 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN8@xmlXPathOb:

; 5425 : 	    break;
; 5426 : 	case XPATH_XSLT_TREE:
; 5427 : #if 0
; 5428 : /*
; 5429 :   Removed 11 July 2004 - the current handling of xslt tmpRVT nodes means that
; 5430 :   this previous handling is no longer correct, and can cause some serious
; 5431 :   problems (ref. bug 145547)
; 5432 : */
; 5433 : 	    if ((val->nodesetval != NULL) &&
; 5434 : 		(val->nodesetval->nodeTab != NULL)) {
; 5435 : 		xmlNodePtr cur, tmp;
; 5436 : 		xmlDocPtr top;
; 5437 : 
; 5438 : 		ret->boolval = 1;
; 5439 : 		top =  xmlNewDoc(NULL);
; 5440 : 		top->name = (char *)
; 5441 : 		    xmlStrdup(val->nodesetval->nodeTab[0]->name);
; 5442 : 		ret->user = top;
; 5443 : 		if (top != NULL) {
; 5444 : 		    top->doc = top;
; 5445 : 		    cur = val->nodesetval->nodeTab[0]->children;
; 5446 : 		    while (cur != NULL) {
; 5447 : 			tmp = xmlDocCopyNode(cur, top, 1);
; 5448 : 			xmlAddChild((xmlNodePtr) top, tmp);
; 5449 : 			cur = cur->next;
; 5450 : 		    }
; 5451 : 		}
; 5452 : 
; 5453 : 		ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);
; 5454 : 	    } else
; 5455 : 		ret->nodesetval = xmlXPathNodeSetCreate(NULL);
; 5456 : 	    /* Deallocate the copied tree value */
; 5457 : 	    break;
; 5458 : #endif
; 5459 : 	case XPATH_NODESET:
; 5460 : 	    ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);

	push	DWORD PTR [esi+4]
	push	0
	call	_xmlXPathNodeSetMerge
	add	esp, 8
	mov	DWORD PTR [ebx+4], eax

; 5461 : 	    /* Do not deallocate the copied tree value */
; 5462 : 	    ret->boolval = 0;

	mov	DWORD PTR [ebx+8], 0

; 5477 : 		    "xmlXPathObjectCopy: unsupported type %d\n",
; 5478 : 		    val->type);
; 5479 : 	    break;
; 5480 :     }
; 5481 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN9@xmlXPathOb:

; 5463 : 	    break;
; 5464 : 	case XPATH_LOCATIONSET:
; 5465 : #ifdef LIBXML_XPTR_ENABLED
; 5466 : 	{
; 5467 : 	    xmlLocationSetPtr loc = val->user;
; 5468 : 	    ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc);

	push	DWORD PTR [esi+28]
	push	0
	call	_xmlXPtrLocationSetMerge
	add	esp, 8
	mov	DWORD PTR [ebx+28], eax

; 5477 : 		    "xmlXPathObjectCopy: unsupported type %d\n",
; 5478 : 		    val->type);
; 5479 : 	    break;
; 5480 :     }
; 5481 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN10@xmlXPathOb:

; 5469 : 	    break;
; 5470 : 	}
; 5471 : #endif
; 5472 :         case XPATH_USERS:
; 5473 : 	    ret->user = val->user;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ebx+28], eax

; 5477 : 		    "xmlXPathObjectCopy: unsupported type %d\n",
; 5478 : 		    val->type);
; 5479 : 	    break;
; 5480 :     }
; 5481 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
$LN11@xmlXPathOb:
	push	edi

; 5474 : 	    break;
; 5475 :         case XPATH_UNDEFINED:
; 5476 : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, DWORD PTR [esi]
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	esi
	push	OFFSET ??_C@_0CJ@OPCFGEGG@xmlXPathObjectCopy?3?5unsupported@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
$LN2@xmlXPathOb:

; 5477 : 		    "xmlXPathObjectCopy: unsupported type %d\n",
; 5478 : 		    val->type);
; 5479 : 	    break;
; 5480 :     }
; 5481 :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	esi

; 5482 : }

	pop	ebp
	ret	0
	npad	2
$LN24@xmlXPathOb:
	DD	$LN11@xmlXPathOb
	DD	$LN8@xmlXPathOb
	DD	$LN2@xmlXPathOb
	DD	$LN2@xmlXPathOb
	DD	$LN7@xmlXPathOb
	DD	$LN2@xmlXPathOb
	DD	$LN2@xmlXPathOb
	DD	$LN9@xmlXPathOb
	DD	$LN10@xmlXPathOb
	DD	$LN8@xmlXPathOb
_xmlXPathObjectCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeNodeSet
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_xmlXPathFreeNodeSet PROC				; COMDAT

; 4176 : xmlXPathFreeNodeSet(xmlNodeSetPtr obj) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _obj$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlXPathFr

; 4177 :     if (obj == NULL) return;
; 4178 :     if (obj->nodeTab != NULL) {

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN6@xmlXPathFr

; 4179 : 	int i;
; 4180 : 
; 4181 : 	/* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 4182 : 	for (i = 0;i < obj->nodeNr;i++)

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN3@xmlXPathFr

; 4183 : 	    if ((obj->nodeTab[i] != NULL) &&

	mov	edx, eax
$LL4@xmlXPathFr:
	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	SHORT $LN2@xmlXPathFr
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPathFr

; 4184 : 		(obj->nodeTab[i]->type == XML_NAMESPACE_DECL))
; 4185 : 		xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);

	push	ecx
	call	_xmlXPathNodeSetFreeNs
	mov	eax, DWORD PTR [edi+8]
	add	esp, 4
	mov	edx, eax
$LN2@xmlXPathFr:

; 4179 : 	int i;
; 4180 : 
; 4181 : 	/* @@ with_ns to check whether namespace nodes should be looked at @@ */
; 4182 : 	for (i = 0;i < obj->nodeNr;i++)

	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@xmlXPathFr
	mov	eax, edx
$LN3@xmlXPathFr:

; 4186 : 	xmlFree(obj->nodeTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN6@xmlXPathFr:

; 4187 :     }
; 4188 :     xmlFree(obj);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPathFr:
	pop	edi

; 4189 : }

	pop	ebp
	ret	0
_xmlXPathFreeNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeNodeSetList
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_xmlXPathFreeNodeSetList PROC				; COMDAT

; 4452 : xmlXPathFreeNodeSetList(xmlXPathObjectPtr obj) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _obj$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlXPathFr

; 4453 :     if (obj == NULL) return;
; 4454 : #ifdef XP_DEBUG_OBJ_USAGE
; 4455 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 4456 : #endif
; 4457 :     xmlFree(obj);

	mov	DWORD PTR _obj$[ebp], eax

; 4458 : }

	pop	ebp

; 4453 :     if (obj == NULL) return;
; 4454 : #ifdef XP_DEBUG_OBJ_USAGE
; 4455 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 4456 : #endif
; 4457 :     xmlFree(obj);

	jmp	DWORD PTR _xmlFree
$LN1@xmlXPathFr:

; 4458 : }

	pop	ebp
	ret	0
_xmlXPathFreeNodeSetList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathNodeSetCreate
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPathNodeSetCreate PROC				; COMDAT

; 3527 : xmlXPathNodeSetCreate(xmlNodePtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 3528 :     xmlNodeSetPtr ret;
; 3529 : 
; 3530 :     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
; 3531 :     if (ret == NULL) {
; 3532 :         xmlXPathErrMemory(NULL, "creating nodeset\n");
; 3533 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 3556 : }

	pop	ebp
	ret	0
$LN2@xmlXPathNo:
	push	edi

; 3534 :     }
; 3535 :     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
; 3536 :     if (val != NULL) {

	mov	edi, DWORD PTR _val$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	je	$LN6@xmlXPathNo

; 3537 :         ret->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 3538 : 					     sizeof(xmlNodePtr));
; 3539 : 	if (ret->nodeTab == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPathNo

; 645  :             __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@LBLPMNCN@creating?5nodeset?6@
	push	eax
	push	eax
	push	3
	push	2
	push	12					; 0000000cH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError

; 3540 : 	    xmlXPathErrMemory(NULL, "creating nodeset\n");
; 3541 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 72					; 00000048H

; 3542 : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 3556 : }

	pop	ebp
	ret	0
$LN4@xmlXPathNo:
	xorps	xmm0, xmm0

; 3543 : 	}
; 3544 : 	memset(ret->nodeTab, 0 ,

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 3545 : 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
; 3546 :         ret->nodeMax = XML_NODESET_DEFAULT;

	mov	DWORD PTR [esi+4], 10			; 0000000aH

; 3547 : 	if (val->type == XML_NAMESPACE_DECL) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPathNo

; 3548 : 	    xmlNsPtr ns = (xmlNsPtr) val;
; 3549 : 
; 3550 : 	    ret->nodeTab[ret->nodeNr++] =

	push	edi
	push	DWORD PTR [edi]
	call	_xmlXPathNodeSetDupNs
	mov	edx, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [ecx+edx*4], eax

; 3554 :     }
; 3555 :     return(ret);

	mov	eax, esi
	inc	DWORD PTR [esi]
	pop	esi

; 3556 : }

	pop	ebp
	ret	0
$LN5@xmlXPathNo:

; 3551 : 		xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
; 3552 : 	} else
; 3553 : 	    ret->nodeTab[ret->nodeNr++] = val;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], edi

; 3554 :     }
; 3555 :     return(ret);

	inc	DWORD PTR [esi]
$LN6@xmlXPathNo:
	pop	edi
	mov	eax, esi
	pop	esi

; 3556 : }

	pop	ebp
	ret	0
_xmlXPathNodeSetCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpath.c
;	COMDAT _xmlXPathFreeObject
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_xmlXPathFreeObject PROC				; COMDAT

; 5491 : xmlXPathFreeObject(xmlXPathObjectPtr obj) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __9DBA2A81_xpath@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _obj$[ebp]
	test	esi, esi
	je	$LN1@xmlXPathFr

; 5492 :     if (obj == NULL) return;
; 5493 :     if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {

	mov	eax, DWORD PTR [esi]
	cmp	eax, 1
	je	SHORT $LN5@xmlXPathFr
	cmp	eax, 9
	je	SHORT $LN5@xmlXPathFr

; 5507 : 	}
; 5508 : #ifdef LIBXML_XPTR_ENABLED
; 5509 :     } else if (obj->type == XPATH_LOCATIONSET) {

	cmp	eax, 7
	jne	SHORT $LN10@xmlXPathFr

; 5510 : 	if (obj->user != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN9@xmlXPathFr

; 5511 : 	    xmlXPtrFreeLocationSet(obj->user);

	push	eax
	call	_xmlXPtrFreeLocationSet

; 5516 :     }
; 5517 : #ifdef XP_DEBUG_OBJ_USAGE
; 5518 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 5519 : #endif
; 5520 :     xmlFree(obj);

	add	esp, 4
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 5521 : }

	pop	ebp
	ret	0
$LN10@xmlXPathFr:

; 5512 : #endif
; 5513 :     } else if (obj->type == XPATH_STRING) {

	cmp	eax, 4
	jne	SHORT $LN9@xmlXPathFr

; 5514 : 	if (obj->stringval != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN9@xmlXPathFr

; 5515 : 	    xmlFree(obj->stringval);

	push	eax
	call	DWORD PTR _xmlFree

; 5516 :     }
; 5517 : #ifdef XP_DEBUG_OBJ_USAGE
; 5518 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 5519 : #endif
; 5520 :     xmlFree(obj);

	add	esp, 4
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 5521 : }

	pop	ebp
	ret	0
$LN5@xmlXPathFr:

; 5494 : 	if (obj->boolval) {

	cmp	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [esi+4]
	je	SHORT $LN6@xmlXPathFr

; 5495 : #if 0
; 5496 : 	    if (obj->user != NULL) {
; 5497 :                 xmlXPathFreeNodeSet(obj->nodesetval);
; 5498 : 		xmlFreeNodeList((xmlNodePtr) obj->user);
; 5499 : 	    } else
; 5500 : #endif
; 5501 : 	    obj->type = XPATH_XSLT_TREE; /* TODO: Just for debugging. */

	mov	DWORD PTR [esi], 9

; 5502 : 	    if (obj->nodesetval != NULL)

	test	eax, eax
	je	SHORT $LN9@xmlXPathFr

; 5503 : 		xmlXPathFreeValueTree(obj->nodesetval);

	push	eax
	call	_xmlXPathFreeValueTree

; 5516 :     }
; 5517 : #ifdef XP_DEBUG_OBJ_USAGE
; 5518 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 5519 : #endif
; 5520 :     xmlFree(obj);

	add	esp, 4
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi

; 5521 : }

	pop	ebp
	ret	0
$LN6@xmlXPathFr:

; 5504 : 	} else {
; 5505 : 	    if (obj->nodesetval != NULL)

	test	eax, eax
	je	SHORT $LN9@xmlXPathFr

; 5506 : 		xmlXPathFreeNodeSet(obj->nodesetval);

	push	eax
	call	_xmlXPathFreeNodeSet

; 5516 :     }
; 5517 : #ifdef XP_DEBUG_OBJ_USAGE
; 5518 :     xmlXPathDebugObjUsageReleased(NULL, obj->type);
; 5519 : #endif
; 5520 :     xmlFree(obj);

	add	esp, 4
$LN9@xmlXPathFr:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPathFr:
	pop	esi

; 5521 : }

	pop	ebp
	ret	0
_xmlXPathFreeObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;

	pop	esi

; 842  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
