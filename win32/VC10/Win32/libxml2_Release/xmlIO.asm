; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlIO.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@HHOGALJI@Unknown?5IO?5error@		; `string'
PUBLIC	??_C@_0BC@HFNFNKAI@Permission?5denied@		; `string'
PUBLIC	??_C@_0CB@EPFKGNAK@Resource?5temporarily?5unavailabl@ ; `string'
PUBLIC	??_C@_0BE@NFGDDCEF@Bad?5file?5descriptor@	; `string'
PUBLIC	??_C@_0M@OEPJJONH@Bad?5message@			; `string'
PUBLIC	??_C@_0O@DCCPNFCJ@Resource?5busy@		; `string'
PUBLIC	??_C@_0BD@OIDFIKFE@Operation?5canceled@		; `string'
PUBLIC	??_C@_0BD@LOHELEP@No?5child?5processes@		; `string'
PUBLIC	??_C@_0BK@JAEBMJJM@Resource?5deadlock?5avoided@	; `string'
PUBLIC	??_C@_0N@MMJPGLJK@Domain?5error@		; `string'
PUBLIC	??_C@_0M@NAAJNNGH@File?5exists@			; `string'
PUBLIC	??_C@_0M@LOEHLCJD@Bad?5address@			; `string'
PUBLIC	??_C@_0P@LFMMIPAE@File?5too?5large@		; `string'
PUBLIC	??_C@_0BG@CLDIHNON@Operation?5in?5progress@	; `string'
PUBLIC	??_C@_0BK@FJBOAFDK@Interrupted?5function?5call@	; `string'
PUBLIC	??_C@_0BB@HMGGCEBG@Invalid?5argument@		; `string'
PUBLIC	??_C@_0BD@KKNFOBBD@Input?1output?5error@	; `string'
PUBLIC	??_C@_0P@NDHGCGKE@Is?5a?5directory@		; `string'
PUBLIC	??_C@_0BE@INBJMKGG@Too?5many?5open?5files@	; `string'
PUBLIC	??_C@_0P@PKCJJLLM@Too?5many?5links@		; `string'
PUBLIC	??_C@_0CE@CBLGIDGK@Inappropriate?5message?5buffer?5le@ ; `string'
PUBLIC	??_C@_0BC@BEDIHIDK@Filename?5too?5long@		; `string'
PUBLIC	??_C@_0BO@IIFBODJE@Too?5many?5open?5files?5in?5system@ ; `string'
PUBLIC	??_C@_0P@NLEIANHE@No?5such?5device@		; `string'
PUBLIC	??_C@_0BK@FMDHKPNF@No?5such?5file?5or?5directory@ ; `string'
PUBLIC	??_C@_0BC@HKPNECK@Exec?5format?5error@		; `string'
PUBLIC	??_C@_0BD@CLHBCGPB@No?5locks?5available@	; `string'
PUBLIC	??_C@_0BB@IMDKMPFB@Not?5enough?5space@		; `string'
PUBLIC	??_C@_0BI@FEALHKLD@No?5space?5left?5on?5device@	; `string'
PUBLIC	??_C@_0BJ@IHEHINLI@Function?5not?5implemented@	; `string'
PUBLIC	??_C@_0BA@CJBACOOL@Not?5a?5directory@		; `string'
PUBLIC	??_C@_0BE@ICMCHPHH@Directory?5not?5empty@	; `string'
PUBLIC	??_C@_0O@BKCHHJEH@Not?5supported@		; `string'
PUBLIC	??_C@_0CE@ONOKNLPF@Inappropriate?5I?1O?5control?5opera@ ; `string'
PUBLIC	??_C@_0BK@DPKMCKJ@No?5such?5device?5or?5address@ ; `string'
PUBLIC	??_C@_0BI@BJFCGOHL@Operation?5not?5permitted@	; `string'
PUBLIC	??_C@_0M@LHEPIIOM@Broken?5pipe@			; `string'
PUBLIC	??_C@_0BB@FCBJFCAJ@Result?5too?5large@		; `string'
PUBLIC	??_C@_0BG@DDBFNKBH@Read?9only?5file?5system@	; `string'
PUBLIC	??_C@_0N@FEHLOILP@Invalid?5seek@		; `string'
PUBLIC	??_C@_0BA@FKIAIBGA@No?5such?5process@		; `string'
PUBLIC	??_C@_0BE@JAEOFJAL@Operation?5timed?5out@	; `string'
PUBLIC	??_C@_0O@OAMDNOCP@Improper?5link@		; `string'
PUBLIC	??_C@_0CC@NMGOOKKB@Attempt?5to?5load?5network?5entity?5@ ; `string'
PUBLIC	??_C@_0O@OFGAHADM@encoder?5error@		; `string'
PUBLIC	??_C@_0M@EIOJBFOB@flush?5error@			; `string'
PUBLIC	??_C@_0M@OBCCECMB@write?5error@			; `string'
PUBLIC	??_C@_08DAIOBLIH@no?5input@			; `string'
PUBLIC	??_C@_0M@BKPABHOI@buffer?5full@			; `string'
PUBLIC	??_C@_0O@BKEKGFAA@loading?5error@		; `string'
PUBLIC	??_C@_0N@POEIPGGF@not?5a?5socket@		; `string'
PUBLIC	??_C@_0BC@DFIBIBIL@already?5connected@		; `string'
PUBLIC	??_C@_0BD@PJLIIJEL@connection?5refused@		; `string'
PUBLIC	??_C@_0BE@FGOAHGMF@unreachable?5network@	; `string'
PUBLIC	??_C@_0BA@CMANOPFH@adddress?5in?5use@		; `string'
PUBLIC	??_C@_0P@MHFAFLH@already?5in?5use@		; `string'
PUBLIC	??_C@_0BI@LHMDLEDC@unknown?5address?5familly@	; `string'
_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__A40A425D_stat@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__194286D1_winsock2@h DB 01H
__7D5E66B2_xmlio@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BI@LHMDLEDC@unknown?5address?5familly@
CONST	SEGMENT
??_C@_0BI@LHMDLEDC@unknown?5address?5familly@ DB 'unknown address familly'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHFAFLH@already?5in?5use@
CONST	SEGMENT
??_C@_0P@MHFAFLH@already?5in?5use@ DB 'already in use', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CMANOPFH@adddress?5in?5use@
CONST	SEGMENT
??_C@_0BA@CMANOPFH@adddress?5in?5use@ DB 'adddress in use', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGOAHGMF@unreachable?5network@
CONST	SEGMENT
??_C@_0BE@FGOAHGMF@unreachable?5network@ DB 'unreachable network', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJLIIJEL@connection?5refused@
CONST	SEGMENT
??_C@_0BD@PJLIIJEL@connection?5refused@ DB 'connection refused', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFIBIBIL@already?5connected@
CONST	SEGMENT
??_C@_0BC@DFIBIBIL@already?5connected@ DB 'already connected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POEIPGGF@not?5a?5socket@
CONST	SEGMENT
??_C@_0N@POEIPGGF@not?5a?5socket@ DB 'not a socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKEKGFAA@loading?5error@
CONST	SEGMENT
??_C@_0O@BKEKGFAA@loading?5error@ DB 'loading error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BKPABHOI@buffer?5full@
CONST	SEGMENT
??_C@_0M@BKPABHOI@buffer?5full@ DB 'buffer full', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAIOBLIH@no?5input@
CONST	SEGMENT
??_C@_08DAIOBLIH@no?5input@ DB 'no input', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBCCECMB@write?5error@
CONST	SEGMENT
??_C@_0M@OBCCECMB@write?5error@ DB 'write error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIOJBFOB@flush?5error@
CONST	SEGMENT
??_C@_0M@EIOJBFOB@flush?5error@ DB 'flush error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFGAHADM@encoder?5error@
CONST	SEGMENT
??_C@_0O@OFGAHADM@encoder?5error@ DB 'encoder error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NMGOOKKB@Attempt?5to?5load?5network?5entity?5@
CONST	SEGMENT
??_C@_0CC@NMGOOKKB@Attempt?5to?5load?5network?5entity?5@ DB 'Attempt to l'
	DB	'oad network entity %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OAMDNOCP@Improper?5link@
CONST	SEGMENT
??_C@_0O@OAMDNOCP@Improper?5link@ DB 'Improper link', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JAEOFJAL@Operation?5timed?5out@
CONST	SEGMENT
??_C@_0BE@JAEOFJAL@Operation?5timed?5out@ DB 'Operation timed out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FKIAIBGA@No?5such?5process@
CONST	SEGMENT
??_C@_0BA@FKIAIBGA@No?5such?5process@ DB 'No such process', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEHLOILP@Invalid?5seek@
CONST	SEGMENT
??_C@_0N@FEHLOILP@Invalid?5seek@ DB 'Invalid seek', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DDBFNKBH@Read?9only?5file?5system@
CONST	SEGMENT
??_C@_0BG@DDBFNKBH@Read?9only?5file?5system@ DB 'Read-only file system', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCBJFCAJ@Result?5too?5large@
CONST	SEGMENT
??_C@_0BB@FCBJFCAJ@Result?5too?5large@ DB 'Result too large', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHEPIIOM@Broken?5pipe@
CONST	SEGMENT
??_C@_0M@LHEPIIOM@Broken?5pipe@ DB 'Broken pipe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BJFCGOHL@Operation?5not?5permitted@
CONST	SEGMENT
??_C@_0BI@BJFCGOHL@Operation?5not?5permitted@ DB 'Operation not permitted'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DPKMCKJ@No?5such?5device?5or?5address@
CONST	SEGMENT
??_C@_0BK@DPKMCKJ@No?5such?5device?5or?5address@ DB 'No such device or ad'
	DB	'dress', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ONOKNLPF@Inappropriate?5I?1O?5control?5opera@
CONST	SEGMENT
??_C@_0CE@ONOKNLPF@Inappropriate?5I?1O?5control?5opera@ DB 'Inappropriate'
	DB	' I/O control operation', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKCHHJEH@Not?5supported@
CONST	SEGMENT
??_C@_0O@BKCHHJEH@Not?5supported@ DB 'Not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICMCHPHH@Directory?5not?5empty@
CONST	SEGMENT
??_C@_0BE@ICMCHPHH@Directory?5not?5empty@ DB 'Directory not empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJBACOOL@Not?5a?5directory@
CONST	SEGMENT
??_C@_0BA@CJBACOOL@Not?5a?5directory@ DB 'Not a directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IHEHINLI@Function?5not?5implemented@
CONST	SEGMENT
??_C@_0BJ@IHEHINLI@Function?5not?5implemented@ DB 'Function not implement'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FEALHKLD@No?5space?5left?5on?5device@
CONST	SEGMENT
??_C@_0BI@FEALHKLD@No?5space?5left?5on?5device@ DB 'No space left on devi'
	DB	'ce', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMDKMPFB@Not?5enough?5space@
CONST	SEGMENT
??_C@_0BB@IMDKMPFB@Not?5enough?5space@ DB 'Not enough space', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CLHBCGPB@No?5locks?5available@
CONST	SEGMENT
??_C@_0BD@CLHBCGPB@No?5locks?5available@ DB 'No locks available', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HKPNECK@Exec?5format?5error@
CONST	SEGMENT
??_C@_0BC@HKPNECK@Exec?5format?5error@ DB 'Exec format error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FMDHKPNF@No?5such?5file?5or?5directory@
CONST	SEGMENT
??_C@_0BK@FMDHKPNF@No?5such?5file?5or?5directory@ DB 'No such file or dir'
	DB	'ectory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NLEIANHE@No?5such?5device@
CONST	SEGMENT
??_C@_0P@NLEIANHE@No?5such?5device@ DB 'No such device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIFBODJE@Too?5many?5open?5files?5in?5system@
CONST	SEGMENT
??_C@_0BO@IIFBODJE@Too?5many?5open?5files?5in?5system@ DB 'Too many open '
	DB	'files in system', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BEDIHIDK@Filename?5too?5long@
CONST	SEGMENT
??_C@_0BC@BEDIHIDK@Filename?5too?5long@ DB 'Filename too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CBLGIDGK@Inappropriate?5message?5buffer?5le@
CONST	SEGMENT
??_C@_0CE@CBLGIDGK@Inappropriate?5message?5buffer?5le@ DB 'Inappropriate '
	DB	'message buffer length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKCJJLLM@Too?5many?5links@
CONST	SEGMENT
??_C@_0P@PKCJJLLM@Too?5many?5links@ DB 'Too many links', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@INBJMKGG@Too?5many?5open?5files@
CONST	SEGMENT
??_C@_0BE@INBJMKGG@Too?5many?5open?5files@ DB 'Too many open files', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDHGCGKE@Is?5a?5directory@
CONST	SEGMENT
??_C@_0P@NDHGCGKE@Is?5a?5directory@ DB 'Is a directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KKNFOBBD@Input?1output?5error@
CONST	SEGMENT
??_C@_0BD@KKNFOBBD@Input?1output?5error@ DB 'Input/output error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMGGCEBG@Invalid?5argument@
CONST	SEGMENT
??_C@_0BB@HMGGCEBG@Invalid?5argument@ DB 'Invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FJBOAFDK@Interrupted?5function?5call@
CONST	SEGMENT
??_C@_0BK@FJBOAFDK@Interrupted?5function?5call@ DB 'Interrupted function '
	DB	'call', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CLDIHNON@Operation?5in?5progress@
CONST	SEGMENT
??_C@_0BG@CLDIHNON@Operation?5in?5progress@ DB 'Operation in progress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LFMMIPAE@File?5too?5large@
CONST	SEGMENT
??_C@_0P@LFMMIPAE@File?5too?5large@ DB 'File too large', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOEHLCJD@Bad?5address@
CONST	SEGMENT
??_C@_0M@LOEHLCJD@Bad?5address@ DB 'Bad address', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAAJNNGH@File?5exists@
CONST	SEGMENT
??_C@_0M@NAAJNNGH@File?5exists@ DB 'File exists', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MMJPGLJK@Domain?5error@
CONST	SEGMENT
??_C@_0N@MMJPGLJK@Domain?5error@ DB 'Domain error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JAEBMJJM@Resource?5deadlock?5avoided@
CONST	SEGMENT
??_C@_0BK@JAEBMJJM@Resource?5deadlock?5avoided@ DB 'Resource deadlock avo'
	DB	'ided', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LOHELEP@No?5child?5processes@
CONST	SEGMENT
??_C@_0BD@LOHELEP@No?5child?5processes@ DB 'No child processes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OIDFIKFE@Operation?5canceled@
CONST	SEGMENT
??_C@_0BD@OIDFIKFE@Operation?5canceled@ DB 'Operation canceled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DCCPNFCJ@Resource?5busy@
CONST	SEGMENT
??_C@_0O@DCCPNFCJ@Resource?5busy@ DB 'Resource busy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEPJJONH@Bad?5message@
CONST	SEGMENT
??_C@_0M@OEPJJONH@Bad?5message@ DB 'Bad message', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NFGDDCEF@Bad?5file?5descriptor@
CONST	SEGMENT
??_C@_0BE@NFGDDCEF@Bad?5file?5descriptor@ DB 'Bad file descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EPFKGNAK@Resource?5temporarily?5unavailabl@
CONST	SEGMENT
??_C@_0CB@EPFKGNAK@Resource?5temporarily?5unavailabl@ DB 'Resource tempor'
	DB	'arily unavailable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HFNFNKAI@Permission?5denied@
CONST	SEGMENT
??_C@_0BC@HFNFNKAI@Permission?5denied@ DB 'Permission denied', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HHOGALJI@Unknown?5IO?5error@
CONST	SEGMENT
??_C@_0BB@HHOGALJI@Unknown?5IO?5error@ DB 'Unknown IO error', 00H ; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	___xmlIOErr
PUBLIC	___xmlLoaderErr
PUBLIC	_xmlInputReadCallbackNop
PUBLIC	_xmlCleanupInputCallbacks
PUBLIC	_xmlPopInputCallbacks
PUBLIC	_xmlRegisterDefaultInputCallbacks
PUBLIC	_xmlAllocParserInputBuffer
PUBLIC	_xmlParserInputBufferCreateFilename
PUBLIC	_xmlParserInputBufferCreateFile
PUBLIC	_xmlParserInputBufferCreateFd
PUBLIC	_xmlParserInputBufferCreateMem
PUBLIC	_xmlParserInputBufferCreateStatic
PUBLIC	_xmlParserInputBufferCreateIO
PUBLIC	_xmlParserInputBufferRead
PUBLIC	_xmlParserInputBufferGrow
PUBLIC	_xmlParserInputBufferPush
PUBLIC	_xmlFreeParserInputBuffer
PUBLIC	_xmlParserGetDirectory
PUBLIC	_xmlRegisterInputCallbacks
PUBLIC	___xmlParserInputBufferCreateFilename
PUBLIC	_xmlCleanupOutputCallbacks
PUBLIC	_xmlRegisterDefaultOutputCallbacks
PUBLIC	_xmlAllocOutputBuffer
PUBLIC	_xmlOutputBufferCreateFilename
PUBLIC	_xmlOutputBufferCreateFile
PUBLIC	_xmlOutputBufferCreateBuffer
PUBLIC	_xmlOutputBufferCreateFd
PUBLIC	_xmlOutputBufferCreateIO
PUBLIC	_xmlOutputBufferGetContent
PUBLIC	_xmlOutputBufferGetSize
PUBLIC	_xmlOutputBufferWrite
PUBLIC	_xmlOutputBufferWriteString
PUBLIC	_xmlOutputBufferWriteEscape
PUBLIC	_xmlOutputBufferFlush
PUBLIC	_xmlOutputBufferClose
PUBLIC	_xmlRegisterOutputCallbacks
PUBLIC	___xmlOutputBufferCreateFilename
PUBLIC	_xmlRegisterHTTPPostCallbacks
PUBLIC	_xmlCheckHTTPInput
PUBLIC	_xmlNoNetExternalEntityLoader
PUBLIC	_xmlNormalizeWindowsPath
PUBLIC	_xmlCheckFilename
PUBLIC	_xmlFileMatch
PUBLIC	_xmlFileOpen
PUBLIC	_xmlFileRead
PUBLIC	_xmlFileClose
PUBLIC	_xmlIOHTTPMatch
PUBLIC	_xmlIOHTTPOpen
PUBLIC	_xmlIOHTTPOpenW
PUBLIC	_xmlIOHTTPRead
PUBLIC	_xmlIOHTTPClose
PUBLIC	_xmlIOFTPMatch
PUBLIC	_xmlIOFTPOpen
PUBLIC	_xmlIOFTPRead
PUBLIC	_xmlIOFTPClose
PUBLIC	_xmlSetExternalEntityLoader
PUBLIC	_xmlGetExternalEntityLoader
PUBLIC	_xmlLoadExternalEntity
PUBLIC	_xmlParserInputBufferCreateFilenameDefault
PUBLIC	_xmlOutputBufferCreateFilenameDefault
PUBLIC	_xmlAllocOutputBufferInternal
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_15MJDFFMKN@?$AAw?$AAb@			; `string'
PUBLIC	??_C@_15JJPIMNBO@?$AAr?$AAb@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_01OJONOECF@b@				; `string'
PUBLIC	??_C@_06CDFDMJHA@read?$CI?$CJ@			; `string'
PUBLIC	??_C@_07BKPGOOAC@write?$CI?$CJ@			; `string'
PUBLIC	??_C@_07LBJPAJEN@close?$CI?$CJ@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@	; `string'
PUBLIC	??_C@_08NPMJDGGI@file?3?1?1?1@			; `string'
PUBLIC	??_C@_06MONEMCJK@file?3?1@			; `string'
PUBLIC	??_C@_07MNJJGAFL@fread?$CI?$CJ@			; `string'
PUBLIC	??_C@_08LGKENNOL@fwrite?$CI?$CJ@		; `string'
PUBLIC	??_C@_08FAKMNOA@fflush?$CI?$CJ@			; `string'
PUBLIC	??_C@_08BNMNDKKE@fclose?$CI?$CJ@		; `string'
PUBLIC	??_C@_04NMBHCBBN@wb?$CFd@			; `string'
PUBLIC	??_C@_08FNKEGDJF@gzread?$CI?$CJ@		; `string'
PUBLIC	??_C@_09MKOIAPFP@gzwrite?$CI?$CJ@		; `string'
PUBLIC	??_C@_09GBIBOIBA@gzclose?$CI?$CJ@		; `string'
PUBLIC	??_C@_08CONNOODF@xzread?$CI?$CJ@		; `string'
PUBLIC	??_C@_09LHCEDCHF@xzclose?$CI?$CJ@		; `string'
PUBLIC	??_C@_0BI@PALIHBDA@creating?5buffer?5context@	; `string'
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
PUBLIC	??_C@_0DF@HJICNPOB@Error?5initializing?5compression?5@ ; `string'
PUBLIC	??_C@_0BL@GHKILDDP@xmlCreateZMemBuff?3?5?5?$CFs?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc@ ; `string'
PUBLIC	??_C@_0CO@MDLOIDCC@Allocation?5failure?5extending?5ou@ ; `string'
PUBLIC	??_C@_0CD@GHKILCIJ@xmlZMemBuffExtend?3?5?5?$CFs?5?$CFlu?5byte@ ; `string'
PUBLIC	??_C@_0BN@LMICBFOE@bytes?5to?5buffer?4?5?5ZLIB?5error@ ; `string'
PUBLIC	??_C@_0CC@EIPKGAGC@Compression?5error?5while?5appendi@ ; `string'
PUBLIC	??_C@_0CC@EMHPFLHJ@xmlZMemBuffAppend?3?5?5?$CFs?5?$CFd?5?$CFs?5?9?5@ ; `string'
PUBLIC	??_C@_0CJ@BEAAAJBE@Error?5flushing?5zlib?5buffers?4?5?5E@ ; `string'
PUBLIC	??_C@_0CB@PEPDONBH@xmlZMemBuffGetContent?3?5?5?$CFs?5?9?5?$CFd@ ; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1@			; `string'
PUBLIC	??_C@_0BN@HPAPFPOH@creating?5HTTP?5output?5context@ ; `string'
PUBLIC	??_C@_0M@MAMOHIEM@copying?5URI@			; `string'
PUBLIC	??_C@_0BO@GKIAAEMO@Error?5sending?5document?5to?5URI@ ; `string'
PUBLIC	??_C@_0CE@EMEBAPHK@Error?5appending?5to?5internal?5buf@ ; `string'
PUBLIC	??_C@_0BO@FAAFNDKK@xmlIOHTTPWrite?3?5?5?$CFs?6?$CFs?5?8?$CFs?8?4?6@ ; `string'
PUBLIC	??_C@_08HNLEKLC@text?1xml@			; `string'
PUBLIC	??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@	; `string'
PUBLIC	??_C@_0M@OBPMGCPN@data?5to?5URI@		; `string'
PUBLIC	??_C@_0CE@LJFLEKEA@Error?5retrieving?5content?4?6Unabl@ ; `string'
PUBLIC	??_C@_0CI@GBILCNOK@xmlIOHTTPCloseWrite?3?5?5?$CFs?5?8?$CFs?8?5?$CF@ ; `string'
PUBLIC	??_C@_0BL@JBOHJFIO@failed?4?5?5HTTP?5return?5code?3@ ; `string'
PUBLIC	??_C@_0N@PMLOIJLP@bytes?5to?5URI@		; `string'
PUBLIC	??_C@_0DE@NBPIPMNL@xmlIOHTTPCloseWrite?3?5HTTP?5?8?$CFs?8?5@ ; `string'
PUBLIC	??_C@_03KBBGFLEK@PUT@				; `string'
PUBLIC	??_C@_04HCJEIHPL@POST@				; `string'
PUBLIC	??_C@_06FNAPNHDD@ftp?3?1?1@			; `string'
PUBLIC	??_C@_0BG@GLAPLACG@creating?5input?5buffer@	; `string'
PUBLIC	??_C@_0BH@JBBBCCHB@creating?5output?5buffer@	; `string'
PUBLIC	??_C@_04DAMGJPCA@file@				; `string'
PUBLIC	??_C@_0BF@EADFILIC@growing?5input?5buffer@	; `string'
PUBLIC	??_C@_0CD@MCCOMMMF@failed?5to?5load?5HTTP?5resource?5?$CC?$CF@ ; `string'
PUBLIC	??_C@_0BO@FMFGBFHH@failed?5to?5load?5HTTP?5resource?6@ ; `string'
PUBLIC	??_C@_04FNIAEEJM@?1xml@				; `string'
PUBLIC	??_C@_04KIAAOCFM@?$CLxml@			; `string'
PUBLIC	??_C@_0BE@MFOALNCF@Unknown?5encoding?5?$CFs@	; `string'
PUBLIC	??_C@_04HIBGFPH@NULL@				; `string'
PUBLIC	??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ ; `string'
PUBLIC	??_C@_0BJ@CJFKOCMN@building?5canonical?5path?6@	; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrncasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrPrintf:PROC
EXTRN	__imp___wopen:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__dup:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp__getcwd:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp___wfopen:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__ferror:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__fileno:PROC
EXTRN	__imp___errno:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	__imp___wstat64i32:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_deflate@8:PROC
EXTRN	_deflateEnd@4:PROC
EXTRN	_gzdopen@8:PROC
EXTRN	_gzread@12:PROC
EXTRN	_gzwrite@12:PROC
EXTRN	_gzdirect@4:PROC
EXTRN	_gzclose@4:PROC
EXTRN	_crc32@12:PROC
EXTRN	_deflateInit2_@32:PROC
EXTRN	_gzopen@8:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufEnd:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlGetCharEncodingHandler:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	___xmlDefaultBufferSize:PROC
EXTRN	___xmlParserInputBufferCreateFilenameValue:PROC
EXTRN	___xmlOutputBufferCreateFilenameValue:PROC
EXTRN	_xmlSwitchInputEncoding:PROC
EXTRN	___xmlErrEncoding:PROC
EXTRN	_xmlFreeInputStream:PROC
EXTRN	_xmlNewInputFromFile:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlURIUnescapeString:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlNanoHTTPMethod:PROC
EXTRN	_xmlNanoHTTPOpen:PROC
EXTRN	_xmlNanoHTTPReturnCode:PROC
EXTRN	_xmlNanoHTTPRedir:PROC
EXTRN	_xmlNanoHTTPEncoding:PROC
EXTRN	_xmlNanoHTTPMimeType:PROC
EXTRN	_xmlNanoHTTPRead:PROC
EXTRN	_xmlNanoHTTPClose:PROC
EXTRN	_xmlNanoFTPOpen:PROC
EXTRN	_xmlNanoFTPClose:PROC
EXTRN	_xmlNanoFTPRead:PROC
EXTRN	_xmlCatalogResolve:PROC
EXTRN	_xmlCatalogResolveURI:PROC
EXTRN	_xmlCatalogLocalResolve:PROC
EXTRN	_xmlCatalogLocalResolveURI:PROC
EXTRN	_xmlCatalogGetDefaults:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufCreateSize:PROC
EXTRN	_xmlBufCreateStatic:PROC
EXTRN	_xmlBufSetAllocationScheme:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufGrow:PROC
EXTRN	_xmlBufAdd:PROC
EXTRN	_xmlBufAvail:PROC
EXTRN	_xmlBufAddLen:PROC
EXTRN	_xmlCharEncInput:PROC
EXTRN	_xmlCharEncOutput:PROC
EXTRN	___libxml2_xzopen:PROC
EXTRN	___libxml2_xzdopen:PROC
EXTRN	___libxml2_xzread:PROC
EXTRN	___libxml2_xzclose:PROC
EXTRN	___libxml2_xzcompressed:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlInputCallbackTable DB 0f0H DUP (?)
_xmlInputCallbackNr DD 01H DUP (?)
_xmlInputCallbackInitialized DD 01H DUP (?)
_xmlOutputCallbackTable DB 0f0H DUP (?)
_xmlOutputCallbackNr DD 01H DUP (?)
_xmlOutputCallbackInitialized DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@CJFKOCMN@building?5canonical?5path?6@
CONST	SEGMENT
??_C@_0BJ@CJFKOCMN@building?5canonical?5path?6@ DB 'building canonical pa'
	DB	'th', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
CONST	SEGMENT
??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ DB 'failed to lo'
	DB	'ad external entity "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MFOALNCF@Unknown?5encoding?5?$CFs@
CONST	SEGMENT
??_C@_0BE@MFOALNCF@Unknown?5encoding?5?$CFs@ DB 'Unknown encoding %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIAAOCFM@?$CLxml@
CONST	SEGMENT
??_C@_04KIAAOCFM@?$CLxml@ DB '+xml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNIAEEJM@?1xml@
CONST	SEGMENT
??_C@_04FNIAEEJM@?1xml@ DB '/xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FMFGBFHH@failed?5to?5load?5HTTP?5resource?6@
CONST	SEGMENT
??_C@_0BO@FMFGBFHH@failed?5to?5load?5HTTP?5resource?6@ DB 'failed to load'
	DB	' HTTP resource', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MCCOMMMF@failed?5to?5load?5HTTP?5resource?5?$CC?$CF@
CONST	SEGMENT
??_C@_0CD@MCCOMMMF@failed?5to?5load?5HTTP?5resource?5?$CC?$CF@ DB 'failed'
	DB	' to load HTTP resource "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EADFILIC@growing?5input?5buffer@
CONST	SEGMENT
??_C@_0BF@EADFILIC@growing?5input?5buffer@ DB 'growing input buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file@
CONST	SEGMENT
??_C@_04DAMGJPCA@file@ DB 'file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
CONST	SEGMENT
??_C@_0BH@JBBBCCHB@creating?5output?5buffer@ DB 'creating output buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GLAPLACG@creating?5input?5buffer@
CONST	SEGMENT
??_C@_0BG@GLAPLACG@creating?5input?5buffer@ DB 'creating input buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNAPNHDD@ftp?3?1?1@
CONST	SEGMENT
??_C@_06FNAPNHDD@ftp?3?1?1@ DB 'ftp://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCJEIHPL@POST@
CONST	SEGMENT
??_C@_04HCJEIHPL@POST@ DB 'POST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBBGFLEK@PUT@
CONST	SEGMENT
??_C@_03KBBGFLEK@PUT@ DB 'PUT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NBPIPMNL@xmlIOHTTPCloseWrite?3?5HTTP?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_0DE@NBPIPMNL@xmlIOHTTPCloseWrite?3?5HTTP?5?8?$CFs?8?5@ DB 'xmlIOHTT'
	DB	'PCloseWrite: HTTP ''%s'' of %d %s', 0aH, '''%s'' %s %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PMLOIJLP@bytes?5to?5URI@
CONST	SEGMENT
??_C@_0N@PMLOIJLP@bytes?5to?5URI@ DB 'bytes to URI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JBOHJFIO@failed?4?5?5HTTP?5return?5code?3@
CONST	SEGMENT
??_C@_0BL@JBOHJFIO@failed?4?5?5HTTP?5return?5code?3@ DB 'failed.  HTTP re'
	DB	'turn code:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GBILCNOK@xmlIOHTTPCloseWrite?3?5?5?$CFs?5?8?$CFs?8?5?$CF@
CONST	SEGMENT
??_C@_0CI@GBILCNOK@xmlIOHTTPCloseWrite?3?5?5?$CFs?5?8?$CFs?8?5?$CF@ DB 'x'
	DB	'mlIOHTTPCloseWrite:  %s ''%s'' %s ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LJFLEKEA@Error?5retrieving?5content?4?6Unabl@
CONST	SEGMENT
??_C@_0CE@LJFLEKEA@Error?5retrieving?5content?4?6Unabl@ DB 'Error retriev'
	DB	'ing content.', 0aH, 'Unable to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBPMGCPN@data?5to?5URI@
CONST	SEGMENT
??_C@_0M@OBPMGCPN@data?5to?5URI@ DB 'data to URI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@
CONST	SEGMENT
??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@ DB 'Content-Encoding: gzip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNLEKLC@text?1xml@
CONST	SEGMENT
??_C@_08HNLEKLC@text?1xml@ DB 'text/xml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FAAFNDKK@xmlIOHTTPWrite?3?5?5?$CFs?6?$CFs?5?8?$CFs?8?4?6@
CONST	SEGMENT
??_C@_0BO@FAAFNDKK@xmlIOHTTPWrite?3?5?5?$CFs?6?$CFs?5?8?$CFs?8?4?6@ DB 'x'
	DB	'mlIOHTTPWrite:  %s', 0aH, '%s ''%s''.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EMEBAPHK@Error?5appending?5to?5internal?5buf@
CONST	SEGMENT
??_C@_0CE@EMEBAPHK@Error?5appending?5to?5internal?5buf@ DB 'Error appendi'
	DB	'ng to internal buffer.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GKIAAEMO@Error?5sending?5document?5to?5URI@
CONST	SEGMENT
??_C@_0BO@GKIAAEMO@Error?5sending?5document?5to?5URI@ DB 'Error sending d'
	DB	'ocument to URI', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MAMOHIEM@copying?5URI@
CONST	SEGMENT
??_C@_0M@MAMOHIEM@copying?5URI@ DB 'copying URI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HPAPFPOH@creating?5HTTP?5output?5context@
CONST	SEGMENT
??_C@_0BN@HPAPFPOH@creating?5HTTP?5output?5context@ DB 'creating HTTP out'
	DB	'put context', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1@ DB 'http://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PEPDONBH@xmlZMemBuffGetContent?3?5?5?$CFs?5?9?5?$CFd@
CONST	SEGMENT
??_C@_0CB@PEPDONBH@xmlZMemBuffGetContent?3?5?5?$CFs?5?9?5?$CFd@ DB 'xmlZM'
	DB	'emBuffGetContent:  %s - %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BEAAAJBE@Error?5flushing?5zlib?5buffers?4?5?5E@
CONST	SEGMENT
??_C@_0CJ@BEAAAJBE@Error?5flushing?5zlib?5buffers?4?5?5E@ DB 'Error flush'
	DB	'ing zlib buffers.  Error code', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EMHPFLHJ@xmlZMemBuffAppend?3?5?5?$CFs?5?$CFd?5?$CFs?5?9?5@
CONST	SEGMENT
??_C@_0CC@EMHPFLHJ@xmlZMemBuffAppend?3?5?5?$CFs?5?$CFd?5?$CFs?5?9?5@ DB 'x'
	DB	'mlZMemBuffAppend:  %s %d %s - %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EIPKGAGC@Compression?5error?5while?5appendi@
CONST	SEGMENT
??_C@_0CC@EIPKGAGC@Compression?5error?5while?5appendi@ DB 'Compression er'
	DB	'ror while appending', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LMICBFOE@bytes?5to?5buffer?4?5?5ZLIB?5error@
CONST	SEGMENT
??_C@_0BN@LMICBFOE@bytes?5to?5buffer?4?5?5ZLIB?5error@ DB 'bytes to buffe'
	DB	'r.  ZLIB error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GHKILCIJ@xmlZMemBuffExtend?3?5?5?$CFs?5?$CFlu?5byte@
CONST	SEGMENT
??_C@_0CD@GHKILCIJ@xmlZMemBuffExtend?3?5?5?$CFs?5?$CFlu?5byte@ DB 'xmlZMe'
	DB	'mBuffExtend:  %s %lu bytes.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MDLOIDCC@Allocation?5failure?5extending?5ou@
CONST	SEGMENT
??_C@_0CO@MDLOIDCC@Allocation?5failure?5extending?5ou@ DB 'Allocation fai'
	DB	'lure extending output buffer to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc@
CONST	SEGMENT
??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc@ DB '%'
	DB	'c%c%c%c%c%c%c%c%c%c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GHKILDDP@xmlCreateZMemBuff?3?5?5?$CFs?5?$CFd?6@
CONST	SEGMENT
??_C@_0BL@GHKILDDP@xmlCreateZMemBuff?3?5?5?$CFs?5?$CFd?6@ DB 'xmlCreateZM'
	DB	'emBuff:  %s %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HJICNPOB@Error?5initializing?5compression?5@
CONST	SEGMENT
??_C@_0DF@HJICNPOB@Error?5initializing?5compression?5@ DB 'Error initiali'
	DB	'zing compression context.  ZLIB error:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PALIHBDA@creating?5buffer?5context@
CONST	SEGMENT
??_C@_0BI@PALIHBDA@creating?5buffer?5context@ DB 'creating buffer context'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09LHCEDCHF@xzclose?$CI?$CJ@
CONST	SEGMENT
??_C@_09LHCEDCHF@xzclose?$CI?$CJ@ DB 'xzclose()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CONNOODF@xzread?$CI?$CJ@
CONST	SEGMENT
??_C@_08CONNOODF@xzread?$CI?$CJ@ DB 'xzread()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBIBOIBA@gzclose?$CI?$CJ@
CONST	SEGMENT
??_C@_09GBIBOIBA@gzclose?$CI?$CJ@ DB 'gzclose()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MKOIAPFP@gzwrite?$CI?$CJ@
CONST	SEGMENT
??_C@_09MKOIAPFP@gzwrite?$CI?$CJ@ DB 'gzwrite()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNKEGDJF@gzread?$CI?$CJ@
CONST	SEGMENT
??_C@_08FNKEGDJF@gzread?$CI?$CJ@ DB 'gzread()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NMBHCBBN@wb?$CFd@
CONST	SEGMENT
??_C@_04NMBHCBBN@wb?$CFd@ DB 'wb%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNMNDKKE@fclose?$CI?$CJ@
CONST	SEGMENT
??_C@_08BNMNDKKE@fclose?$CI?$CJ@ DB 'fclose()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FAKMNOA@fflush?$CI?$CJ@
CONST	SEGMENT
??_C@_08FAKMNOA@fflush?$CI?$CJ@ DB 'fflush()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGKENNOL@fwrite?$CI?$CJ@
CONST	SEGMENT
??_C@_08LGKENNOL@fwrite?$CI?$CJ@ DB 'fwrite()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNJJGAFL@fread?$CI?$CJ@
CONST	SEGMENT
??_C@_07MNJJGAFL@fread?$CI?$CJ@ DB 'fread()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MONEMCJK@file?3?1@
CONST	SEGMENT
??_C@_06MONEMCJK@file?3?1@ DB 'file:/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPMJDGGI@file?3?1?1?1@
CONST	SEGMENT
??_C@_08NPMJDGGI@file?3?1?1?1@ DB 'file:///', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
CONST	SEGMENT
??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@ DB 'file://localhost/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBJPAJEN@close?$CI?$CJ@
CONST	SEGMENT
??_C@_07LBJPAJEN@close?$CI?$CJ@ DB 'close()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BKPGOOAC@write?$CI?$CJ@
CONST	SEGMENT
??_C@_07BKPGOOAC@write?$CI?$CJ@ DB 'write()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDFDMJHA@read?$CI?$CJ@
CONST	SEGMENT
??_C@_06CDFDMJHA@read?$CI?$CJ@ DB 'read()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b@
CONST	SEGMENT
??_C@_01OJONOECF@b@ DB 'b', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15JJPIMNBO@?$AAr?$AAb@
CONST	SEGMENT
??_C@_15JJPIMNBO@?$AAr?$AAb@ DB 'r', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MJDFFMKN@?$AAw?$AAb@
CONST	SEGMENT
??_C@_15MJDFFMKN@?$AAw?$AAb@ DB 'w', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_IOerr	DD	FLAT:??_C@_0BB@HHOGALJI@Unknown?5IO?5error@
	DD	FLAT:??_C@_0BC@HFNFNKAI@Permission?5denied@
	DD	FLAT:??_C@_0CB@EPFKGNAK@Resource?5temporarily?5unavailabl@
	DD	FLAT:??_C@_0BE@NFGDDCEF@Bad?5file?5descriptor@
	DD	FLAT:??_C@_0M@OEPJJONH@Bad?5message@
	DD	FLAT:??_C@_0O@DCCPNFCJ@Resource?5busy@
	DD	FLAT:??_C@_0BD@OIDFIKFE@Operation?5canceled@
	DD	FLAT:??_C@_0BD@LOHELEP@No?5child?5processes@
	DD	FLAT:??_C@_0BK@JAEBMJJM@Resource?5deadlock?5avoided@
	DD	FLAT:??_C@_0N@MMJPGLJK@Domain?5error@
	DD	FLAT:??_C@_0M@NAAJNNGH@File?5exists@
	DD	FLAT:??_C@_0M@LOEHLCJD@Bad?5address@
	DD	FLAT:??_C@_0P@LFMMIPAE@File?5too?5large@
	DD	FLAT:??_C@_0BG@CLDIHNON@Operation?5in?5progress@
	DD	FLAT:??_C@_0BK@FJBOAFDK@Interrupted?5function?5call@
	DD	FLAT:??_C@_0BB@HMGGCEBG@Invalid?5argument@
	DD	FLAT:??_C@_0BD@KKNFOBBD@Input?1output?5error@
	DD	FLAT:??_C@_0P@NDHGCGKE@Is?5a?5directory@
	DD	FLAT:??_C@_0BE@INBJMKGG@Too?5many?5open?5files@
	DD	FLAT:??_C@_0P@PKCJJLLM@Too?5many?5links@
	DD	FLAT:??_C@_0CE@CBLGIDGK@Inappropriate?5message?5buffer?5le@
	DD	FLAT:??_C@_0BC@BEDIHIDK@Filename?5too?5long@
	DD	FLAT:??_C@_0BO@IIFBODJE@Too?5many?5open?5files?5in?5system@
	DD	FLAT:??_C@_0P@NLEIANHE@No?5such?5device@
	DD	FLAT:??_C@_0BK@FMDHKPNF@No?5such?5file?5or?5directory@
	DD	FLAT:??_C@_0BC@HKPNECK@Exec?5format?5error@
	DD	FLAT:??_C@_0BD@CLHBCGPB@No?5locks?5available@
	DD	FLAT:??_C@_0BB@IMDKMPFB@Not?5enough?5space@
	DD	FLAT:??_C@_0BI@FEALHKLD@No?5space?5left?5on?5device@
	DD	FLAT:??_C@_0BJ@IHEHINLI@Function?5not?5implemented@
	DD	FLAT:??_C@_0BA@CJBACOOL@Not?5a?5directory@
	DD	FLAT:??_C@_0BE@ICMCHPHH@Directory?5not?5empty@
	DD	FLAT:??_C@_0O@BKCHHJEH@Not?5supported@
	DD	FLAT:??_C@_0CE@ONOKNLPF@Inappropriate?5I?1O?5control?5opera@
	DD	FLAT:??_C@_0BK@DPKMCKJ@No?5such?5device?5or?5address@
	DD	FLAT:??_C@_0BI@BJFCGOHL@Operation?5not?5permitted@
	DD	FLAT:??_C@_0M@LHEPIIOM@Broken?5pipe@
	DD	FLAT:??_C@_0BB@FCBJFCAJ@Result?5too?5large@
	DD	FLAT:??_C@_0BG@DDBFNKBH@Read?9only?5file?5system@
	DD	FLAT:??_C@_0N@FEHLOILP@Invalid?5seek@
	DD	FLAT:??_C@_0BA@FKIAIBGA@No?5such?5process@
	DD	FLAT:??_C@_0BE@JAEOFJAL@Operation?5timed?5out@
	DD	FLAT:??_C@_0O@OAMDNOCP@Improper?5link@
	DD	FLAT:??_C@_0CC@NMGOOKKB@Attempt?5to?5load?5network?5entity?5@
	DD	FLAT:??_C@_0O@OFGAHADM@encoder?5error@
	DD	FLAT:??_C@_0M@EIOJBFOB@flush?5error@
	DD	FLAT:??_C@_0M@OBCCECMB@write?5error@
	DD	FLAT:??_C@_08DAIOBLIH@no?5input@
	DD	FLAT:??_C@_0M@BKPABHOI@buffer?5full@
	DD	FLAT:??_C@_0O@BKEKGFAA@loading?5error@
	DD	FLAT:??_C@_0N@POEIPGGF@not?5a?5socket@
	DD	FLAT:??_C@_0BC@DFIBIBIL@already?5connected@
	DD	FLAT:??_C@_0BD@PJLIIJEL@connection?5refused@
	DD	FLAT:??_C@_0BE@FGOAHGMF@unreachable?5network@
	DD	FLAT:??_C@_0BA@CMANOPFH@adddress?5in?5use@
	DD	FLAT:??_C@_0P@MHFAFLH@already?5in?5use@
	DD	FLAT:??_C@_0BI@LHMDLEDC@unknown?5address?5familly@
_xmlCurrentExternalEntityLoader DD FLAT:_xmlDefaultExternalEntityLoader
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlDefaultExternalEntityLoader
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlDefaultExternalEntityLoader PROC			; COMDAT

; 3947 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlDefault

; 3948 :     xmlParserInputPtr ret = NULL;
; 3949 :     xmlChar *resource = NULL;
; 3950 : 
; 3951 : #ifdef DEBUG_EXTERNAL_ENTITIES
; 3952 :     xmlGenericError(xmlGenericErrorContext,
; 3953 :                     "xmlDefaultExternalEntityLoader(%s, xxx)\n", URL);
; 3954 : #endif
; 3955 :     if ((ctxt != NULL) && (ctxt->options & XML_PARSE_NONET)) {

	mov	edi, DWORD PTR [esi+360]
	test	edi, 2048				; 00000800H
	je	SHORT $LN2@xmlDefault

; 3956 :         int options = ctxt->options;
; 3957 : 
; 3958 : 	ctxt->options -= XML_PARSE_NONET;
; 3959 :         ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);

	push	esi
	push	DWORD PTR _ID$[ebp]
	lea	eax, DWORD PTR [edi-2048]
	push	DWORD PTR _URL$[ebp]
	mov	DWORD PTR [esi+360], eax
	call	_xmlNoNetExternalEntityLoader
	add	esp, 12					; 0000000cH

; 3960 : 	ctxt->options = options;

	mov	DWORD PTR [esi+360], edi
	pop	edi

; 3980 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlDefault:
	push	ebx

; 3961 : 	return(ret);
; 3962 :     }
; 3963 : #ifdef LIBXML_CATALOG_ENABLED
; 3964 :     resource = xmlResolveResourceFromCatalog(URL, ID, ctxt);

	mov	ebx, DWORD PTR _URL$[ebp]
	push	esi
	push	DWORD PTR _ID$[ebp]
	push	ebx
	call	_xmlResolveResourceFromCatalog
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3965 : #endif
; 3966 : 
; 3967 :     if (resource == NULL)

	test	edi, edi
	jne	SHORT $LN4@xmlDefault

; 3968 :         resource = (xmlChar *) URL;

	mov	edi, ebx

; 3969 : 
; 3970 :     if (resource == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlDefault

; 3971 :         if (ID == NULL)
; 3972 :             ID = "NULL";
; 3973 :         __xmlLoaderErr(ctxt, "failed to load external entity \"%s\"\n", ID);

	mov	ecx, DWORD PTR _ID$[ebp]
	mov	eax, OFFSET ??_C@_04HIBGFPH@NULL@
	test	ecx, ecx
	cmovne	eax, ecx
	push	eax
	push	OFFSET ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
	push	esi
	call	___xmlLoaderErr
	add	esp, 12					; 0000000cH

; 3974 :         return (NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 3980 : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlDefault:

; 3975 :     }
; 3976 :     ret = xmlNewInputFromFile(ctxt, (const char *) resource);

	push	edi
	push	esi
	call	_xmlNewInputFromFile
	add	esp, 8
	mov	esi, eax

; 3977 :     if ((resource != NULL) && (resource != (xmlChar *) URL))

	cmp	edi, ebx
	je	SHORT $LN6@xmlDefault

; 3978 :         xmlFree(resource);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlDefault:

; 3979 :     return (ret);

	pop	ebx
	pop	edi
	mov	eax, esi

; 3980 : }

	pop	esi
	pop	ebp
	ret	0
_xmlDefaultExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlResolveResourceFromCatalog
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlResolveResourceFromCatalog PROC			; COMDAT

; 3872 :                               xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	call	_xmlCatalogGetDefaults
	mov	edi, eax
	test	edi, edi
	je	$LN23@xmlResolve

; 3873 :     xmlChar *resource = NULL;
; 3874 :     xmlCatalogAllow pref;
; 3875 : 
; 3876 :     /*
; 3877 :      * If the resource doesn't exists as a file,
; 3878 :      * try to load it from the resource pointed in the catalogs
; 3879 :      */
; 3880 :     pref = xmlCatalogGetDefaults();
; 3881 : 
; 3882 :     if ((pref != XML_CATA_ALLOW_NONE) && (!xmlNoNetExists(URL))) {

	push	ebx
	mov	ebx, DWORD PTR _URL$[ebp]
	push	ebx
	call	_xmlNoNetExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@xmlResolve

; 3883 : 	/*
; 3884 : 	 * Do a local lookup
; 3885 : 	 */
; 3886 : 	if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	test	eax, eax
	je	SHORT $LN17@xmlResolve
	mov	eax, DWORD PTR [eax+284]
	test	eax, eax
	je	SHORT $LN17@xmlResolve
	cmp	edi, 3
	je	SHORT $LN4@xmlResolve
	cmp	edi, 2
	jne	SHORT $LN17@xmlResolve
$LN4@xmlResolve:

; 3887 : 	    ((pref == XML_CATA_ALLOW_ALL) ||
; 3888 : 	     (pref == XML_CATA_ALLOW_DOCUMENT))) {
; 3889 : 	    resource = xmlCatalogLocalResolve(ctxt->catalogs,

	push	ebx
	push	ecx
	push	eax
	call	_xmlCatalogLocalResolve
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3890 : 					      (const xmlChar *)ID,
; 3891 : 					      (const xmlChar *)URL);
; 3892 :         }
; 3893 : 	/*
; 3894 : 	 * Try a global lookup
; 3895 : 	 */
; 3896 : 	if ((resource == NULL) &&

	test	esi, esi
	jne	SHORT $LN16@xmlResolve
	mov	ecx, DWORD PTR _ID$[ebp]
$LN17@xmlResolve:
	cmp	edi, 3
	je	SHORT $LN6@xmlResolve
	cmp	edi, 1
	jne	SHORT $LN18@xmlResolve
$LN6@xmlResolve:

; 3897 : 	    ((pref == XML_CATA_ALLOW_ALL) ||
; 3898 : 	     (pref == XML_CATA_ALLOW_GLOBAL))) {
; 3899 : 	    resource = xmlCatalogResolve((const xmlChar *)ID,

	push	ebx
	push	ecx
	call	_xmlCatalogResolve
	mov	esi, eax
	add	esp, 8

; 3900 : 					 (const xmlChar *)URL);
; 3901 : 	}
; 3902 : 	if ((resource == NULL) && (URL != NULL))

	test	esi, esi
	jne	SHORT $LN16@xmlResolve
$LN18@xmlResolve:
	test	ebx, ebx
	je	SHORT $LN20@xmlResolve

; 3903 : 	    resource = xmlStrdup((const xmlChar *) URL);

	push	ebx
	call	_xmlStrdup
	mov	esi, eax
	add	esp, 4

; 3904 : 
; 3905 : 	/*
; 3906 : 	 * TODO: do an URI lookup on the reference
; 3907 : 	 */
; 3908 : 	if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {

	test	esi, esi
	jne	SHORT $LN16@xmlResolve
$LN20@xmlResolve:
	pop	ebx
	pop	edi

; 3924 : 		resource = tmp;
; 3925 : 	    }
; 3926 : 	}
; 3927 :     }
; 3928 : 
; 3929 :     return resource;

	mov	eax, esi

; 3930 : }

	pop	esi
	pop	ebp
	ret	0
$LN16@xmlResolve:

; 3904 : 
; 3905 : 	/*
; 3906 : 	 * TODO: do an URI lookup on the reference
; 3907 : 	 */
; 3908 : 	if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {

	push	esi
	call	_xmlNoNetExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@xmlResolve

; 3909 : 	    xmlChar *tmp = NULL;
; 3910 : 
; 3911 : 	    if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN19@xmlResolve
	mov	eax, DWORD PTR [eax+284]
	test	eax, eax
	je	SHORT $LN19@xmlResolve
	cmp	edi, 3
	je	SHORT $LN10@xmlResolve
	cmp	edi, 2
	jne	SHORT $LN19@xmlResolve
$LN10@xmlResolve:

; 3912 : 		((pref == XML_CATA_ALLOW_ALL) ||
; 3913 : 		 (pref == XML_CATA_ALLOW_DOCUMENT))) {
; 3914 : 		tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);

	push	esi
	push	eax
	call	_xmlCatalogLocalResolveURI
	mov	ebx, eax
	add	esp, 8

; 3915 : 	    }
; 3916 : 	    if ((tmp == NULL) &&

	test	ebx, ebx
	jne	SHORT $LN15@xmlResolve
$LN19@xmlResolve:
	cmp	edi, 3
	je	SHORT $LN12@xmlResolve
	cmp	edi, 1
	jne	SHORT $LN20@xmlResolve
$LN12@xmlResolve:

; 3917 : 		((pref == XML_CATA_ALLOW_ALL) ||
; 3918 : 	         (pref == XML_CATA_ALLOW_GLOBAL))) {
; 3919 : 		tmp = xmlCatalogResolveURI(resource);

	push	esi
	call	_xmlCatalogResolveURI
	mov	ebx, eax
	add	esp, 4

; 3920 : 	    }
; 3921 : 
; 3922 : 	    if (tmp != NULL) {

	test	ebx, ebx
	je	SHORT $LN20@xmlResolve
$LN15@xmlResolve:

; 3923 : 		xmlFree(resource);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3924 : 		resource = tmp;
; 3925 : 	    }
; 3926 : 	}
; 3927 :     }
; 3928 : 
; 3929 :     return resource;

	mov	eax, ebx
	pop	ebx
	pop	edi

; 3930 : }

	pop	esi
	pop	ebp
	ret	0
$LN23@xmlResolve:
	pop	edi

; 3924 : 		resource = tmp;
; 3925 : 	    }
; 3926 : 	}
; 3927 :     }
; 3928 : 
; 3929 :     return resource;

	mov	eax, esi

; 3930 : }

	pop	esi
	pop	ebp
	ret	0
_xmlResolveResourceFromCatalog ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlNoNetExists
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_xmlNoNetExists PROC					; COMDAT

; 3832 : static int xmlNoNetExists(const char *URL) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _URL$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlNoNetEx

; 3833 :     const char *path;
; 3834 : 
; 3835 :     if (URL == NULL)
; 3836 : 	return(0);

	xor	eax, eax
	pop	esi

; 3854 : }

	pop	ebp
	ret	0
$LN2@xmlNoNetEx:

; 3837 : 
; 3838 :     if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@xmlNoNetEx

; 3839 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 3840 : 	path = &URL[17];

	add	esi, 17					; 00000011H

; 3847 : #else
; 3848 : 	path = &URL[7];
; 3849 : #endif
; 3850 :     } else
; 3851 : 	path = URL;
; 3852 : 
; 3853 :     return xmlCheckFilename(path);

	push	esi
	call	_xmlCheckFilename
	add	esp, 4
	pop	esi

; 3854 : }

	pop	ebp
	ret	0
$LN3@xmlNoNetEx:

; 3841 : #else
; 3842 : 	path = &URL[16];
; 3843 : #endif
; 3844 :     else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@xmlNoNetEx

; 3845 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 3846 : 	path = &URL[8];

	add	esi, 8
$LN5@xmlNoNetEx:

; 3847 : #else
; 3848 : 	path = &URL[7];
; 3849 : #endif
; 3850 :     } else
; 3851 : 	path = URL;
; 3852 : 
; 3853 :     return xmlCheckFilename(path);

	push	esi
	call	_xmlCheckFilename
	add	esp, 4
	pop	esi

; 3854 : }

	pop	ebp
	ret	0
_xmlNoNetExists ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlEscapeContent
_TEXT	SEGMENT
_outstart$1$ = 8					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_base$1$ = 16						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_xmlEscapeContent PROC					; COMDAT

; 3436 :                  const xmlChar* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	edi, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edi]
	add	edi, esi
	mov	DWORD PTR _outstart$1$[ebp], eax
	mov	DWORD PTR _base$1$[ebp], esi
	lea	ebx, DWORD PTR [ecx+eax]
	cmp	esi, edi
	jae	$LN18@xmlEscapeC
$LL2@xmlEscapeC:

; 3437 :     unsigned char* outstart = out;
; 3438 :     const unsigned char* base = in;
; 3439 :     unsigned char* outend = out + *outlen;
; 3440 :     const unsigned char* inend;
; 3441 : 
; 3442 :     inend = in + (*inlen);
; 3443 : 
; 3444 :     while ((in < inend) && (out < outend)) {

	cmp	eax, ebx
	jae	$LN25@xmlEscapeC

; 3445 : 	if (*in == '<') {

	mov	dl, BYTE PTR [esi]
	cmp	dl, 60					; 0000003cH
	jne	SHORT $LN4@xmlEscapeC

; 3446 : 	    if (outend - out < 4) break;

	cmp	ecx, 4
	jl	SHORT $LN25@xmlEscapeC

; 3447 : 	    *out++ = '&';

	mov	WORD PTR [eax], 27686			; 00006c26H

; 3448 : 	    *out++ = 'l';
; 3449 : 	    *out++ = 't';

	mov	BYTE PTR [eax+2], 116			; 00000074H
	add	eax, 3
	add	ecx, -3					; fffffffdH

; 3450 : 	    *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN14@xmlEscapeC
$LN4@xmlEscapeC:

; 3451 : 	} else if (*in == '>') {

	cmp	dl, 62					; 0000003eH
	jne	SHORT $LN7@xmlEscapeC

; 3452 : 	    if (outend - out < 4) break;

	cmp	ecx, 4
	jl	SHORT $LN25@xmlEscapeC

; 3453 : 	    *out++ = '&';

	mov	WORD PTR [eax], 26406			; 00006726H

; 3454 : 	    *out++ = 'g';
; 3455 : 	    *out++ = 't';

	mov	BYTE PTR [eax+2], 116			; 00000074H
	add	eax, 3
	add	ecx, -3					; fffffffdH

; 3456 : 	    *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN14@xmlEscapeC
$LN7@xmlEscapeC:

; 3457 : 	} else if (*in == '&') {

	cmp	dl, 38					; 00000026H
	jne	SHORT $LN10@xmlEscapeC

; 3458 : 	    if (outend - out < 5) break;

	cmp	ecx, 5
	jl	SHORT $LN25@xmlEscapeC

; 3459 : 	    *out++ = '&';

	mov	DWORD PTR [eax], 1886216486		; 706d6126H

; 3460 : 	    *out++ = 'a';
; 3461 : 	    *out++ = 'm';
; 3462 : 	    *out++ = 'p';

	add	eax, 4
	add	ecx, -4					; fffffffcH

; 3463 : 	    *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH
	jmp	SHORT $LN14@xmlEscapeC
$LN10@xmlEscapeC:

; 3464 : 	} else if (*in == '\r') {

	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN13@xmlEscapeC

; 3465 : 	    if (outend - out < 5) break;

	cmp	ecx, 5
	jl	SHORT $LN25@xmlEscapeC

; 3466 : 	    *out++ = '&';

	mov	DWORD PTR [eax], 858858278		; 33312326H

; 3467 : 	    *out++ = '#';
; 3468 : 	    *out++ = '1';
; 3469 : 	    *out++ = '3';

	add	eax, 4
	add	ecx, -4					; fffffffcH

; 3470 : 	    *out++ = ';';

	mov	BYTE PTR [eax], 59			; 0000003bH

; 3471 : 	} else {

	jmp	SHORT $LN14@xmlEscapeC
$LN13@xmlEscapeC:

; 3472 : 	    *out++ = (unsigned char) *in;

	mov	BYTE PTR [eax], dl
$LN14@xmlEscapeC:

; 3473 : 	}
; 3474 : 	++in;

	inc	esi
	inc	eax
	dec	ecx
	cmp	esi, edi
	jb	$LL2@xmlEscapeC
$LN25@xmlEscapeC:
	mov	edx, DWORD PTR _outlen$[ebp]
$LN18@xmlEscapeC:

; 3475 :     }
; 3476 :     *outlen = out - outstart;

	sub	eax, DWORD PTR _outstart$1$[ebp]

; 3477 :     *inlen = in - base;

	sub	esi, DWORD PTR _base$1$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _inlen$[ebp]

; 3478 :     return(0);

	pop	edi
	mov	DWORD PTR [eax], esi
	xor	eax, eax
	pop	esi
	pop	ebx

; 3479 : }

	pop	ebp
	ret	0
_xmlEscapeContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _endOfInput
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_endOfInput PROC					; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	ret	0
_endOfInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPClosePost
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlIOHTTPClosePost PROC				; COMDAT

; 2094 : xmlIOHTTPClosePost( void * ctxt ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_04HCJEIHPL@POST@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlIOHTTPCloseWrite
	add	esp, 8

; 2095 :     return ( xmlIOHTTPCloseWrite( ctxt, "POST" ) );
; 2096 : }

	pop	ebp
	ret	0
_xmlIOHTTPClosePost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPClosePut
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlIOHTTPClosePut PROC					; COMDAT

; 2080 : xmlIOHTTPClosePut( void * ctxt ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	OFFSET ??_C@_03KBBGFLEK@PUT@
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlIOHTTPCloseWrite
	add	esp, 8

; 2081 :     return ( xmlIOHTTPCloseWrite( ctxt, "PUT" ) );
; 2082 : }

	pop	ebp
	ret	0
_xmlIOHTTPClosePut ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPCloseWrite
_TEXT	SEGMENT
_msg$1 = -512						; size = 500
_msg$2 = -512						; size = 500
_msg$3 = -512						; size = 500
_close_rc$1$ = -12					; size = 4
_content_type$ = -8					; size = 4
_http_content$1$ = -4					; size = 4
_context$ = 8						; size = 4
_http_mthd$ = 12					; size = 4
_xmlIOHTTPCloseWrite PROC				; COMDAT

; 1944 : xmlIOHTTPCloseWrite( void * context, const char * http_mthd ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 512				; 00000200H
	push	ebx
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _context$[ebp]
	xor	eax, eax
	mov	DWORD PTR _close_rc$1$[ebp], -1
	mov	DWORD PTR _http_content$1$[ebp], eax
	mov	DWORD PTR _content_type$[ebp], OFFSET ??_C@_08HNLEKLC@text?1xml@
	test	ebx, ebx
	je	$LN3@xmlIOHTTPC

; 1945 : 
; 1946 :     int				close_rc = -1;
; 1947 :     int				http_rtn = 0;
; 1948 :     int				content_lgth = 0;
; 1949 :     xmlIOHTTPWriteCtxtPtr	ctxt = context;
; 1950 : 
; 1951 :     char *			http_content = NULL;
; 1952 :     char *			content_encoding = NULL;
; 1953 :     char *			content_type = (char *) "text/xml";
; 1954 :     void *			http_ctxt = NULL;
; 1955 : 
; 1956 :     if ( ( ctxt == NULL ) || ( http_mthd == NULL ) )

	cmp	DWORD PTR _http_mthd$[ebp], eax
	je	$LN3@xmlIOHTTPC

; 1958 : 
; 1959 :     /*  Retrieve the content from the appropriate buffer  */
; 1960 : 
; 1961 : #ifdef LIBXML_ZLIB_ENABLED
; 1962 : 
; 1963 :     if ( ctxt->compression > 0 ) {

	push	esi
	mov	esi, DWORD PTR [ebx+8]
	push	edi
	cmp	DWORD PTR [ebx], eax
	jle	$LN4@xmlIOHTTPC

; 1657 :     int		zlgth = -1;

	or	edi, -1

; 1658 :     int		z_err;
; 1659 : 
; 1660 :     if ( ( buff == NULL ) || ( data_ref == NULL ) )

	test	esi, esi
	je	SHORT $LN17@xmlIOHTTPC
	lea	eax, DWORD PTR [esi+12]
$LL15@xmlIOHTTPC:

; 1661 : 	return ( -1 );
; 1662 : 
; 1663 :     /*  Need to loop until compression output buffers are flushed  */
; 1664 : 
; 1665 :     do
; 1666 :     {
; 1667 : 	z_err = deflate( &buff->zctrl, Z_FINISH );

	push	4
	push	eax
	call	_deflate@8

; 1668 : 	if ( z_err == Z_OK ) {

	test	eax, eax
	jne	SHORT $LN360@xmlIOHTTPC

; 1669 : 	    /*  In this case Z_OK means more buffer space needed  */
; 1670 : 
; 1671 : 	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )

	push	DWORD PTR [esi]
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	lea	eax, DWORD PTR [esi+12]
	jne	SHORT $LL15@xmlIOHTTPC
$LN17@xmlIOHTTPC:

; 1964 : 	content_lgth = xmlZMemBuffGetContent( ctxt->doc_buff, &http_content );
; 1965 : 	content_encoding = (char *) "Content-Encoding: gzip";

	or	edi, -1
	mov	ecx, OFFSET ??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@

; 1966 :     }

	jmp	$LN5@xmlIOHTTPC
$LN360@xmlIOHTTPC:

; 1679 :     if ( z_err == Z_STREAM_END ) {

	cmp	eax, 1
	jne	SHORT $LN20@xmlIOHTTPC

; 1680 : 
; 1681 : 	/*  Need to append the gzip data trailer  */
; 1682 : 
; 1683 : 	if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {

	cmp	DWORD PTR [esi+28], 8
	jae	SHORT $LN23@xmlIOHTTPC

; 1684 : 	    if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )

	push	8
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN17@xmlIOHTTPC
$LN23@xmlIOHTTPC:

; 1685 : 		return ( -1 );
; 1686 : 	}
; 1687 : 
; 1688 : 	/*
; 1689 : 	**  For whatever reason, the CRC and length data are pushed out
; 1690 : 	**  in reverse byte order.  So a memcpy can't be used here.
; 1691 : 	*/
; 1692 : 
; 1693 : 	append_reverse_ulong( buff, buff->crc );

	push	DWORD PTR [esi+4]
	push	esi
	call	_append_reverse_ulong

; 1694 : 	append_reverse_ulong( buff, buff->zctrl.total_in );

	push	DWORD PTR [esi+20]
	push	esi
	call	_append_reverse_ulong

; 1695 : 
; 1696 : 	zlgth = buff->zctrl.next_out - buff->zbuff;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	edi, DWORD PTR [esi+24]

; 1964 : 	content_lgth = xmlZMemBuffGetContent( ctxt->doc_buff, &http_content );
; 1965 : 	content_encoding = (char *) "Content-Encoding: gzip";

	mov	ecx, OFFSET ??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@

; 1696 : 	zlgth = buff->zctrl.next_out - buff->zbuff;

	mov	DWORD PTR _http_content$1$[ebp], eax
	sub	edi, eax

; 1966 :     }

	jmp	SHORT $LN5@xmlIOHTTPC
$LN20@xmlIOHTTPC:

; 1702 : 	xmlStrPrintf(msg, 500,

	push	eax
	push	OFFSET ??_C@_0CJ@BEAAAJBE@Error?5flushing?5zlib?5buffers?4?5?5E@
	push	OFFSET ??_C@_0CB@PEPDONBH@xmlZMemBuffGetContent?3?5?5?$CFs?5?9?5?$CFd@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 40					; 00000028H

; 1964 : 	content_lgth = xmlZMemBuffGetContent( ctxt->doc_buff, &http_content );
; 1965 : 	content_encoding = (char *) "Content-Encoding: gzip";

	mov	ecx, OFFSET ??_C@_0BH@GLHIGFDJ@Content?9Encoding?3?5gzip@

; 1966 :     }

	jmp	SHORT $LN5@xmlIOHTTPC
$LN4@xmlIOHTTPC:

; 1967 :     else
; 1968 : #endif
; 1969 :     {
; 1970 : 	/*  Pull the data out of the memory output buffer  */
; 1971 : 
; 1972 : 	xmlOutputBufferPtr	dctxt = ctxt->doc_buff;
; 1973 : 	http_content = (char *) xmlBufContent(dctxt->buffer);

	push	DWORD PTR [esi+16]
	call	_xmlBufContent

; 1974 : 	content_lgth = xmlBufUse(dctxt->buffer);

	push	DWORD PTR [esi+16]
	mov	DWORD PTR _http_content$1$[ebp], eax
	call	_xmlBufUse
	add	esp, 8
	mov	edi, eax
	xor	ecx, ecx
$LN5@xmlIOHTTPC:

; 1975 :     }
; 1976 : 
; 1977 :     if ( http_content == NULL ) {

	mov	eax, DWORD PTR _http_content$1$[ebp]
	mov	edx, DWORD PTR [ebx+4]
	test	eax, eax
	jne	SHORT $LN6@xmlIOHTTPC

; 1978 : 	xmlChar msg[500];
; 1979 : 	xmlStrPrintf(msg, 500,

	mov	eax, DWORD PTR _http_mthd$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@OBPMGCPN@data?5to?5URI@
	push	eax
	push	OFFSET ??_C@_0CE@LJFLEKEA@Error?5retrieving?5content?4?6Unabl@
	push	OFFSET ??_C@_0CI@GBILCNOK@xmlIOHTTPCloseWrite?3?5?5?$CFs?5?8?$CFs?8?5?$CF@
	lea	eax, DWORD PTR _msg$3[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$3[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 48					; 00000030H

; 2061 : 	}
; 2062 :     }
; 2063 : 
; 2064 :     /*  Final cleanups  */
; 2065 : 
; 2066 :     xmlFreeHTTPWriteCtxt( ctxt );

	push	ebx
	call	_xmlFreeHTTPWriteCtxt

; 2067 : 
; 2068 :     return ( close_rc );

	mov	eax, DWORD PTR _close_rc$1$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2069 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlIOHTTPC:

; 1980 : 		     "xmlIOHTTPCloseWrite:  %s '%s' %s '%s'.\n",
; 1981 : 		     "Error retrieving content.\nUnable to",
; 1982 : 		     http_mthd, "data to URI", ctxt->uri );
; 1983 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1984 :     }
; 1985 : 
; 1986 :     else {
; 1987 : 
; 1988 : 	http_ctxt = xmlNanoHTTPMethod( ctxt->uri, http_mthd, http_content,

	push	edi
	push	ecx
	lea	ecx, DWORD PTR _content_type$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _http_mthd$[ebp]
	push	eax
	push	edx
	call	_xmlNanoHTTPMethod
	mov	esi, eax
	add	esp, 24					; 00000018H

; 1989 : 					&content_type, content_encoding,
; 1990 : 					content_lgth );
; 1991 : 
; 1992 : 	if ( http_ctxt != NULL ) {

	test	esi, esi
	je	SHORT $LN8@xmlIOHTTPC

; 1993 : #ifdef DEBUG_HTTP
; 1994 : 	    /*  If testing/debugging - dump reply with request content  */
; 1995 : 
; 1996 : 	    FILE *	tst_file = NULL;
; 1997 : 	    char	buffer[ 4096 ];
; 1998 : 	    char *	dump_name = NULL;
; 1999 : 	    int		avail;
; 2000 : 
; 2001 : 	    xmlGenericError( xmlGenericErrorContext,
; 2002 : 			"xmlNanoHTTPCloseWrite:  HTTP %s to\n%s returned %d.\n",
; 2003 : 			http_mthd, ctxt->uri,
; 2004 : 			xmlNanoHTTPReturnCode( http_ctxt ) );
; 2005 : 
; 2006 : 	    /*
; 2007 : 	    **  Since either content or reply may be gzipped,
; 2008 : 	    **  dump them to separate files instead of the
; 2009 : 	    **  standard error context.
; 2010 : 	    */
; 2011 : 
; 2012 : 	    dump_name = tempnam( NULL, "lxml" );
; 2013 : 	    if ( dump_name != NULL ) {
; 2014 : 		(void)snprintf( buffer, sizeof(buffer), "%s.content", dump_name );
; 2015 : 
; 2016 : 		tst_file = fopen( buffer, "wb" );
; 2017 : 		if ( tst_file != NULL ) {
; 2018 : 		    xmlGenericError( xmlGenericErrorContext,
; 2019 : 			"Transmitted content saved in file:  %s\n", buffer );
; 2020 : 
; 2021 : 		    fwrite( http_content, sizeof( char ),
; 2022 : 					content_lgth, tst_file );
; 2023 : 		    fclose( tst_file );
; 2024 : 		}
; 2025 : 
; 2026 : 		(void)snprintf( buffer, sizeof(buffer), "%s.reply", dump_name );
; 2027 : 		tst_file = fopen( buffer, "wb" );
; 2028 : 		if ( tst_file != NULL ) {
; 2029 : 		    xmlGenericError( xmlGenericErrorContext,
; 2030 : 			"Reply content saved in file:  %s\n", buffer );
; 2031 : 
; 2032 : 
; 2033 : 		    while ( (avail = xmlNanoHTTPRead( http_ctxt,
; 2034 : 					buffer, sizeof( buffer ) )) > 0 ) {
; 2035 : 
; 2036 : 			fwrite( buffer, sizeof( char ), avail, tst_file );
; 2037 : 		    }
; 2038 : 
; 2039 : 		    fclose( tst_file );
; 2040 : 		}
; 2041 : 
; 2042 : 		free( dump_name );
; 2043 : 	    }
; 2044 : #endif  /*  DEBUG_HTTP  */
; 2045 : 
; 2046 : 	    http_rtn = xmlNanoHTTPReturnCode( http_ctxt );

	push	esi
	call	_xmlNanoHTTPReturnCode
	mov	ecx, eax
	add	esp, 4

; 2047 : 	    if ( ( http_rtn >= 200 ) && ( http_rtn < 300 ) )

	lea	eax, DWORD PTR [ecx-200]
	cmp	eax, 99					; 00000063H
	ja	SHORT $LN9@xmlIOHTTPC

; 2048 : 		close_rc = 0;

	mov	DWORD PTR _close_rc$1$[ebp], 0
	jmp	SHORT $LN249@xmlIOHTTPC
$LN9@xmlIOHTTPC:

; 2049 : 	    else {
; 2050 :                 xmlChar msg[500];
; 2051 :                 xmlStrPrintf(msg, 500,

	push	ecx
	push	OFFSET ??_C@_0BL@JBOHJFIO@failed?4?5?5HTTP?5return?5code?3@
	push	DWORD PTR [ebx+4]
	lea	eax, DWORD PTR _msg$2[ebp]
	push	OFFSET ??_C@_0N@PMLOIJLP@bytes?5to?5URI@
	push	edi
	push	DWORD PTR _http_mthd$[ebp]
	push	OFFSET ??_C@_0DE@NBPIPMNL@xmlIOHTTPCloseWrite?3?5HTTP?5?8?$CFs?8?5@
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$2[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 56					; 00000038H
$LN249@xmlIOHTTPC:

; 2052 :                       "xmlIOHTTPCloseWrite: HTTP '%s' of %d %s\n'%s' %s %d\n",
; 2053 : 			    http_mthd, content_lgth,
; 2054 : 			    "bytes to URI", ctxt->uri,
; 2055 : 			    "failed.  HTTP return code:", http_rtn );
; 2056 : 		xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 2057 :             }
; 2058 : 
; 2059 : 	    xmlNanoHTTPClose( http_ctxt );

	push	esi
	call	_xmlNanoHTTPClose

; 2060 : 	    xmlFree( content_type );

	push	DWORD PTR _content_type$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN8@xmlIOHTTPC:

; 2061 : 	}
; 2062 :     }
; 2063 : 
; 2064 :     /*  Final cleanups  */
; 2065 : 
; 2066 :     xmlFreeHTTPWriteCtxt( ctxt );

	push	ebx
	call	_xmlFreeHTTPWriteCtxt

; 2067 : 
; 2068 :     return ( close_rc );

	mov	eax, DWORD PTR _close_rc$1$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2069 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlIOHTTPC:

; 1957 : 	return ( -1 );

	or	eax, -1
	pop	ebx

; 2069 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIOHTTPCloseWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPWrite
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_msg$2 = -500						; size = 500
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlIOHTTPWrite PROC					; COMDAT

; 1886 : xmlIOHTTPWrite( void * context, const char * buffer, int len ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _context$[ebp]
	test	ebx, ebx
	je	$LN3@xmlIOHTTPW

; 1887 : 
; 1888 :     xmlIOHTTPWriteCtxtPtr	ctxt = context;
; 1889 : 
; 1890 :     if ( ( ctxt == NULL ) || ( ctxt->doc_buff == NULL ) || ( buffer == NULL ) )

	mov	esi, DWORD PTR [ebx+8]
	test	esi, esi
	je	$LN3@xmlIOHTTPW
	mov	eax, DWORD PTR _buffer$[ebp]
	test	eax, eax
	je	$LN3@xmlIOHTTPW

; 1892 : 
; 1893 :     if ( len > 0 ) {

	push	edi
	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jle	$LN7@xmlIOHTTPW

; 1894 : 
; 1895 : 	/*  Use gzwrite or fwrite as previously setup in the open call  */
; 1896 : 
; 1897 : #ifdef LIBXML_ZLIB_ENABLED
; 1898 : 	if ( ctxt->compression > 0 )

	cmp	DWORD PTR [ebx], 0
	jle	$LN5@xmlIOHTTPW

; 1613 :     buff->zctrl.avail_in = len;

	mov	DWORD PTR [esi+16], edi

; 1614 :     buff->zctrl.next_in  = (unsigned char *)src;

	mov	DWORD PTR [esi+12], eax

; 1615 :     while ( buff->zctrl.avail_in > 0 ) {

	test	edi, edi
	je	SHORT $LN11@xmlIOHTTPW
	mov	ecx, edi
	npad	9
$LL10@xmlIOHTTPW:

; 1616 : 	/*
; 1617 : 	**  Extend the buffer prior to deflate call if a reasonable amount
; 1618 : 	**  of output buffer space is not available.
; 1619 : 	*/
; 1620 : 	min_accept = buff->zctrl.avail_in / DFLT_ZLIB_RATIO;

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 2

; 1621 : 	if ( buff->zctrl.avail_out <= min_accept ) {

	cmp	DWORD PTR [esi+28], edx
	ja	SHORT $LN15@xmlIOHTTPW

; 1622 : 	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )

	push	DWORD PTR [esi]
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN130@xmlIOHTTPW
$LN15@xmlIOHTTPW:

; 1623 : 		return ( -1 );
; 1624 : 	}
; 1625 : 
; 1626 : 	z_err = deflate( &buff->zctrl, Z_NO_FLUSH );

	push	0
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	_deflate@8

; 1627 : 	if ( z_err != Z_OK ) {

	test	eax, eax
	jne	SHORT $LN131@xmlIOHTTPW

; 1615 :     while ( buff->zctrl.avail_in > 0 ) {

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jne	SHORT $LL10@xmlIOHTTPW

; 1627 : 	if ( z_err != Z_OK ) {

	mov	eax, DWORD PTR _buffer$[ebp]
$LN11@xmlIOHTTPW:

; 1630 : 			"xmlZMemBuffAppend:  %s %d %s - %d",
; 1631 : 			"Compression error while appending",
; 1632 : 			len, "bytes to buffer.  ZLIB error", z_err );
; 1633 : 	    xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1634 : 	    return ( -1 );
; 1635 : 	}
; 1636 :     }
; 1637 : 
; 1638 :     buff->crc = crc32( buff->crc, (unsigned char *)src, len );

	push	edi
	push	eax
	push	DWORD PTR [esi+4]
	call	_crc32@12
	mov	DWORD PTR [esi+4], eax

; 1899 : 	    len = xmlZMemBuffAppend( ctxt->doc_buff, buffer, len );

	jmp	SHORT $LN6@xmlIOHTTPW
$LN131@xmlIOHTTPW:

; 1629 : 	    xmlStrPrintf(msg, 500,

	push	eax
	push	OFFSET ??_C@_0BN@LMICBFOE@bytes?5to?5buffer?4?5?5ZLIB?5error@
	push	edi
	push	OFFSET ??_C@_0CC@EIPKGAGC@Compression?5error?5while?5appendi@
	push	OFFSET ??_C@_0CC@EMHPFLHJ@xmlZMemBuffAppend?3?5?5?$CFs?5?$CFd?5?$CFs?5?9?5@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 48					; 00000030H
$LN130@xmlIOHTTPW:

; 1906 : 	    xmlChar msg[500];
; 1907 : 	    xmlStrPrintf(msg, 500,

	or	edi, -1
	jmp	SHORT $LN134@xmlIOHTTPW
$LN5@xmlIOHTTPW:

; 1900 : 
; 1901 : 	else
; 1902 : #endif
; 1903 : 	    len = xmlOutputBufferWrite( ctxt->doc_buff, len, buffer );

	push	eax
	push	edi
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	mov	edi, eax
$LN6@xmlIOHTTPW:

; 1904 : 
; 1905 : 	if ( len < 0 ) {

	test	edi, edi
	jns	SHORT $LN7@xmlIOHTTPW
$LN134@xmlIOHTTPW:

; 1906 : 	    xmlChar msg[500];
; 1907 : 	    xmlStrPrintf(msg, 500,

	push	DWORD PTR [ebx+4]
	lea	eax, DWORD PTR _msg$2[ebp]
	push	OFFSET ??_C@_0BO@GKIAAEMO@Error?5sending?5document?5to?5URI@
	push	OFFSET ??_C@_0CE@EMEBAPHK@Error?5appending?5to?5internal?5buf@
	push	OFFSET ??_C@_0BO@FAAFNDKK@xmlIOHTTPWrite?3?5?5?$CFs?6?$CFs?5?8?$CFs?8?4?6@
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 1908 : 			"xmlIOHTTPWrite:  %s\n%s '%s'.\n",
; 1909 : 			"Error appending to internal buffer.",
; 1910 : 			"Error sending document to URI",
; 1911 : 			ctxt->uri );
; 1912 : 	    xmlIOErr(XML_IO_WRITE, (const char *) msg);

	lea	eax, DWORD PTR _msg$2[ebp]
	push	eax
	push	1546					; 0000060aH
	call	_xmlIOErr
	add	esp, 32					; 00000020H
$LN7@xmlIOHTTPW:

; 1913 : 	}
; 1914 :     }
; 1915 : 
; 1916 :     return ( len );

	mov	eax, edi
	pop	edi
	pop	esi

; 1917 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlIOHTTPW:
	pop	esi

; 1891 : 	return ( -1 );

	or	eax, -1

; 1917 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIOHTTPWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPDfltOpenW
_TEXT	SEGMENT
_post_uri$ = 8						; size = 4
_xmlIOHTTPDfltOpenW PROC				; COMDAT

; 1851 : xmlIOHTTPDfltOpenW( const char * post_uri ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _post_uri$[ebp]
	call	_xmlIOHTTPOpenW
	add	esp, 8

; 1852 :     return ( xmlIOHTTPOpenW( post_uri, 0 ) );
; 1853 : }

	pop	ebp
	ret	0
_xmlIOHTTPDfltOpenW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFreeHTTPWriteCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreeHTTPWriteCtxt PROC				; COMDAT

; 1724 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@xmlFreeHTT

; 1725 :     if ( ctxt->uri != NULL )
; 1726 : 	xmlFree( ctxt->uri );

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN2@xmlFreeHTT:

; 1727 : 
; 1728 :     if ( ctxt->doc_buff != NULL ) {

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@xmlFreeHTT

; 1729 : 
; 1730 : #ifdef LIBXML_ZLIB_ENABLED
; 1731 : 	if ( ctxt->compression > 0 ) {

	cmp	DWORD PTR [esi], 0
	jle	SHORT $LN4@xmlFreeHTT

; 1457 :     xmlFree( buff->zbuff );

	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1458 : #ifdef DEBUG_HTTP
; 1459 :     z_err = deflateEnd( &buff->zctrl );
; 1460 :     if ( z_err != Z_OK )
; 1461 : 	xmlGenericError( xmlGenericErrorContext,
; 1462 : 			"xmlFreeZMemBuff:  Error releasing zlib context:  %d\n",
; 1463 : 			z_err );
; 1464 : #else
; 1465 :     deflateEnd( &buff->zctrl );

	lea	eax, DWORD PTR [edi+12]
	push	eax
	call	_deflateEnd@4

; 1466 : #endif
; 1467 : 
; 1468 :     xmlFree( buff );

	push	edi
	call	DWORD PTR _xmlFree

; 1738 : 	}
; 1739 :     }
; 1740 : 
; 1741 :     xmlFree( ctxt );

	add	esp, 4
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 1742 :     return;
; 1743 : }

	pop	ebp
	ret	0
$LN4@xmlFreeHTT:

; 1732 : 	    xmlFreeZMemBuff( ctxt->doc_buff );
; 1733 : 	}
; 1734 : 	else
; 1735 : #endif
; 1736 : 	{
; 1737 : 	    xmlOutputBufferClose( ctxt->doc_buff );

	push	edi
	call	_xmlOutputBufferClose

; 1738 : 	}
; 1739 :     }
; 1740 : 
; 1741 :     xmlFree( ctxt );

	add	esp, 4
$LN5@xmlFreeHTT:
	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
	pop	esi

; 1742 :     return;
; 1743 : }

	pop	ebp
	ret	0
_xmlFreeHTTPWriteCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlZMemBuffGetContent
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_buff$ = 8						; size = 4
_data_ref$ = 12						; size = 4
_xmlZMemBuffGetContent PROC				; COMDAT

; 1655 : xmlZMemBuffGetContent( xmlZMemBuffPtr buff, char ** data_ref ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buff$[ebp]
	or	ebx, -1
	test	esi, esi
	je	SHORT $LN6@xmlZMemBuf

; 1656 : 
; 1657 :     int		zlgth = -1;
; 1658 :     int		z_err;
; 1659 : 
; 1660 :     if ( ( buff == NULL ) || ( data_ref == NULL ) )

	cmp	DWORD PTR _data_ref$[ebp], 0
	je	SHORT $LN6@xmlZMemBuf
	lea	edi, DWORD PTR [esi+12]
	npad	7
$LL4@xmlZMemBuf:

; 1661 : 	return ( -1 );
; 1662 : 
; 1663 :     /*  Need to loop until compression output buffers are flushed  */
; 1664 : 
; 1665 :     do
; 1666 :     {
; 1667 : 	z_err = deflate( &buff->zctrl, Z_FINISH );

	push	4
	push	edi
	call	_deflate@8

; 1668 : 	if ( z_err == Z_OK ) {

	test	eax, eax
	jne	SHORT $LN127@xmlZMemBuf

; 1669 : 	    /*  In this case Z_OK means more buffer space needed  */
; 1670 : 
; 1671 : 	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )

	push	DWORD PTR [esi]
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LL4@xmlZMemBuf
$LN6@xmlZMemBuf:
	pop	edi

; 1709 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN127@xmlZMemBuf:

; 1672 : 		return ( -1 );
; 1673 : 	}
; 1674 :     }
; 1675 :     while ( z_err == Z_OK );
; 1676 : 
; 1677 :     /*  If the compression state is not Z_STREAM_END, some error occurred  */
; 1678 : 
; 1679 :     if ( z_err == Z_STREAM_END ) {

	cmp	eax, 1
	jne	SHORT $LN9@xmlZMemBuf

; 1680 : 
; 1681 : 	/*  Need to append the gzip data trailer  */
; 1682 : 
; 1683 : 	if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {

	cmp	DWORD PTR [esi+28], 8
	jae	SHORT $LN12@xmlZMemBuf

; 1684 : 	    if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )

	push	8
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN6@xmlZMemBuf
$LN12@xmlZMemBuf:

; 1685 : 		return ( -1 );
; 1686 : 	}
; 1687 : 
; 1688 : 	/*
; 1689 : 	**  For whatever reason, the CRC and length data are pushed out
; 1690 : 	**  in reverse byte order.  So a memcpy can't be used here.
; 1691 : 	*/
; 1692 : 
; 1693 : 	append_reverse_ulong( buff, buff->crc );

	push	DWORD PTR [esi+4]
	push	esi
	call	_append_reverse_ulong

; 1694 : 	append_reverse_ulong( buff, buff->zctrl.total_in );

	push	DWORD PTR [esi+20]
	push	esi
	call	_append_reverse_ulong

; 1695 : 
; 1696 : 	zlgth = buff->zctrl.next_out - buff->zbuff;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR [esi+24]

; 1697 : 	*data_ref = (char *)buff->zbuff;

	mov	ecx, DWORD PTR _data_ref$[ebp]
	sub	ebx, eax
	pop	edi

; 1709 : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlZMemBuf:

; 1698 :     }
; 1699 : 
; 1700 :     else {
; 1701 : 	xmlChar msg[500];
; 1702 : 	xmlStrPrintf(msg, 500,

	push	eax
	push	OFFSET ??_C@_0CJ@BEAAAJBE@Error?5flushing?5zlib?5buffers?4?5?5E@
	push	OFFSET ??_C@_0CB@PEPDONBH@xmlZMemBuffGetContent?3?5?5?$CFs?5?9?5?$CFd@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 40					; 00000028H

; 1703 : 		    "xmlZMemBuffGetContent:  %s - %d\n",
; 1704 : 		    "Error flushing zlib buffers.  Error code", z_err );
; 1705 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1706 :     }
; 1707 : 
; 1708 :     return ( zlgth );

	mov	eax, ebx
	pop	edi

; 1709 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlZMemBuffGetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlZMemBuffAppend
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_buff$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlZMemBuffAppend PROC					; COMDAT

; 1605 : xmlZMemBuffAppend( xmlZMemBuffPtr buff, const char * src, int len ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buff$[ebp]
	test	esi, esi
	je	$LN5@xmlZMemBuf

; 1606 : 
; 1607 :     int		z_err;
; 1608 :     size_t	min_accept;
; 1609 : 
; 1610 :     if ( ( buff == NULL ) || ( src == NULL ) )

	mov	eax, DWORD PTR _src$[ebp]
	test	eax, eax
	je	$LN5@xmlZMemBuf

; 1611 : 	return ( -1 );
; 1612 : 
; 1613 :     buff->zctrl.avail_in = len;

	mov	edi, DWORD PTR _len$[ebp]

; 1614 :     buff->zctrl.next_in  = (unsigned char *)src;

	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [ebx], eax

; 1615 :     while ( buff->zctrl.avail_in > 0 ) {

	test	edi, edi
	je	SHORT $LN3@xmlZMemBuf
	mov	ecx, edi
	npad	3
$LL2@xmlZMemBuf:

; 1616 : 	/*
; 1617 : 	**  Extend the buffer prior to deflate call if a reasonable amount
; 1618 : 	**  of output buffer space is not available.
; 1619 : 	*/
; 1620 : 	min_accept = buff->zctrl.avail_in / DFLT_ZLIB_RATIO;

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 2

; 1621 : 	if ( buff->zctrl.avail_out <= min_accept ) {

	cmp	DWORD PTR [esi+28], edx
	ja	SHORT $LN7@xmlZMemBuf

; 1622 : 	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )

	push	DWORD PTR [esi]
	push	esi
	call	_xmlZMemBuffExtend
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN5@xmlZMemBuf
$LN7@xmlZMemBuf:

; 1623 : 		return ( -1 );
; 1624 : 	}
; 1625 : 
; 1626 : 	z_err = deflate( &buff->zctrl, Z_NO_FLUSH );

	push	0
	push	ebx
	call	_deflate@8

; 1627 : 	if ( z_err != Z_OK ) {

	test	eax, eax
	jne	SHORT $LN123@xmlZMemBuf

; 1615 :     while ( buff->zctrl.avail_in > 0 ) {

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jne	SHORT $LL2@xmlZMemBuf

; 1627 : 	if ( z_err != Z_OK ) {

	mov	eax, DWORD PTR _src$[ebp]
$LN3@xmlZMemBuf:

; 1630 : 			"xmlZMemBuffAppend:  %s %d %s - %d",
; 1631 : 			"Compression error while appending",
; 1632 : 			len, "bytes to buffer.  ZLIB error", z_err );
; 1633 : 	    xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1634 : 	    return ( -1 );
; 1635 : 	}
; 1636 :     }
; 1637 : 
; 1638 :     buff->crc = crc32( buff->crc, (unsigned char *)src, len );

	push	edi
	push	eax
	push	DWORD PTR [esi+4]
	call	_crc32@12
	mov	DWORD PTR [esi+4], eax

; 1639 : 
; 1640 :     return ( len );

	mov	eax, edi
	pop	edi

; 1641 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN123@xmlZMemBuf:

; 1628 : 	    xmlChar msg[500];
; 1629 : 	    xmlStrPrintf(msg, 500,

	push	eax
	push	OFFSET ??_C@_0BN@LMICBFOE@bytes?5to?5buffer?4?5?5ZLIB?5error@
	push	edi
	push	OFFSET ??_C@_0CC@EIPKGAGC@Compression?5error?5while?5appendi@
	push	OFFSET ??_C@_0CC@EMHPFLHJ@xmlZMemBuffAppend?3?5?5?$CFs?5?$CFd?5?$CFs?5?9?5@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 48					; 00000030H
$LN5@xmlZMemBuf:
	pop	edi

; 1641 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlZMemBuffAppend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlZMemBuffExtend
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_cur_used$1$ = 8					; size = 4
_buff$ = 8						; size = 4
_ext_amt$ = 12						; size = 4
_xmlZMemBuffExtend PROC					; COMDAT

; 1547 : xmlZMemBuffExtend( xmlZMemBuffPtr buff, size_t ext_amt ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	ebx
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buff$[ebp]
	or	ebx, -1
	test	esi, esi
	jne	SHORT $LN2@xmlZMemBuf

; 1548 : 
; 1549 :     int			rc = -1;
; 1550 :     size_t		new_size;
; 1551 :     size_t		cur_used;
; 1552 : 
; 1553 :     unsigned char *	tmp_ptr = NULL;
; 1554 : 
; 1555 :     if ( buff == NULL )
; 1556 : 	return ( -1 );

	pop	esi
	or	eax, ebx

; 1591 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlZMemBuf:

; 1557 : 
; 1558 :     else if ( ext_amt == 0 )

	mov	ecx, DWORD PTR _ext_amt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlZMemBuf

; 1559 : 	return ( 0 );

	pop	esi
	xor	eax, eax

; 1591 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlZMemBuf:

; 1560 : 
; 1561 :     cur_used = buff->zctrl.next_out - buff->zbuff;

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+24]
	push	edi

; 1562 :     new_size = buff->size + ext_amt;

	mov	edi, DWORD PTR [esi]
	sub	edx, eax
	add	edi, ecx
	mov	DWORD PTR _cur_used$1$[ebp], edx

; 1563 : 
; 1564 : #ifdef DEBUG_HTTP
; 1565 :     if ( cur_used > new_size )
; 1566 : 	xmlGenericError( xmlGenericErrorContext,
; 1567 : 			"xmlZMemBuffExtend:  %s\n%s %d bytes.\n",
; 1568 : 			"Buffer overwrite detected during compressed memory",
; 1569 : 			"buffer extension.  Overflowed by",
; 1570 : 			(cur_used - new_size ) );
; 1571 : #endif
; 1572 : 
; 1573 :     tmp_ptr = xmlRealloc( buff->zbuff, new_size );

	push	edi
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 1574 :     if ( tmp_ptr != NULL ) {

	test	eax, eax
	je	SHORT $LN5@xmlZMemBuf

; 1575 : 	rc = 0;
; 1576 : 	buff->size  = new_size;
; 1577 : 	buff->zbuff = tmp_ptr;

	mov	DWORD PTR [esi+8], eax
	xor	ebx, ebx

; 1578 : 	buff->zctrl.next_out  = tmp_ptr + cur_used;

	add	eax, DWORD PTR _cur_used$1$[ebp]
	mov	DWORD PTR [esi], edi

; 1579 : 	buff->zctrl.avail_out = new_size - cur_used;

	sub	edi, DWORD PTR _cur_used$1$[ebp]
	mov	DWORD PTR [esi+28], edi

; 1584 : 		    "xmlZMemBuffExtend:  %s %lu bytes.\n",
; 1585 : 		    "Allocation failure extending output buffer to",
; 1586 : 		    (unsigned long) new_size );
; 1587 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1588 :     }
; 1589 : 
; 1590 :     return ( rc );

	pop	edi
	mov	DWORD PTR [esi+24], eax
	mov	eax, ebx
	pop	esi

; 1591 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlZMemBuf:

; 1580 :     }
; 1581 :     else {
; 1582 : 	xmlChar msg[500];
; 1583 : 	xmlStrPrintf(msg, 500,

	push	edi
	push	OFFSET ??_C@_0CO@MDLOIDCC@Allocation?5failure?5extending?5ou@
	push	OFFSET ??_C@_0CD@GHKILCIJ@xmlZMemBuffExtend?3?5?5?$CFs?5?$CFlu?5byte@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	DWORD PTR _IOerr+184
	push	0
	push	1546					; 0000060aH
	push	8
	call	___xmlSimpleError
	add	esp, 40					; 00000028H

; 1584 : 		    "xmlZMemBuffExtend:  %s %lu bytes.\n",
; 1585 : 		    "Allocation failure extending output buffer to",
; 1586 : 		    (unsigned long) new_size );
; 1587 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);
; 1588 :     }
; 1589 : 
; 1590 :     return ( rc );

	mov	eax, ebx
	pop	edi
	pop	esi

; 1591 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlZMemBuffExtend ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlCreateZMemBuff
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_compression$ = 8					; size = 4
_xmlCreateZMemBuff PROC					; COMDAT

; 1483 : xmlCreateZMemBuff( int compression ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _compression$[ebp]
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, 8
	ja	$LN3@xmlCreateZ

; 1491 : 
; 1492 :     /*  Create the control and data areas  */
; 1493 : 
; 1494 :     buff = xmlMalloc( sizeof( xmlZMemBuff ) );

	push	esi
	push	68					; 00000044H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1495 :     if ( buff == NULL ) {

	test	esi, esi
	jne	SHORT $LN4@xmlCreateZ

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@PALIHBDA@creating?5buffer?5context@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1505 : 	xmlIOErrMemory("creating buffer");
; 1506 : 	return ( NULL );

	xor	eax, eax
	pop	esi
	pop	edi

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCreateZ:

; 1496 : 	xmlIOErrMemory("creating buffer context");
; 1497 : 	return ( NULL );
; 1498 :     }
; 1499 : 
; 1500 :     (void)memset( buff, 0, sizeof( xmlZMemBuff ) );

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0

; 1501 :     buff->size = INIT_HTTP_BUFF_SIZE;
; 1502 :     buff->zbuff = xmlMalloc( buff->size );

	push	32768					; 00008000H
	mov	DWORD PTR [esi], 32768			; 00008000H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 1503 :     if ( buff->zbuff == NULL ) {

	test	eax, eax
	jne	SHORT $LN5@xmlCreateZ

; 1504 : 	xmlFreeZMemBuff( buff );

	push	esi
	call	_xmlFreeZMemBuff

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	push	0
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 24					; 00000018H

; 1505 : 	xmlIOErrMemory("creating buffer");
; 1506 : 	return ( NULL );

	xor	eax, eax
	pop	esi
	pop	edi

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCreateZ:

; 1507 :     }
; 1508 : 
; 1509 :     z_err = deflateInit2( &buff->zctrl, compression, Z_DEFLATED,

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	0
	push	8
	push	-15					; fffffff1H
	push	8
	push	edi
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	_deflateInit2_@32
	mov	edi, eax

; 1510 : 			    DFLT_WBITS, DFLT_MEM_LVL, Z_DEFAULT_STRATEGY );
; 1511 :     if ( z_err != Z_OK ) {

	test	edi, edi
	je	SHORT $LN6@xmlCreateZ

; 1512 : 	xmlChar msg[500];
; 1513 : 	xmlFreeZMemBuff( buff );

	push	esi
	call	_xmlFreeZMemBuff

; 1514 : 	buff = NULL;
; 1515 : 	xmlStrPrintf(msg, 500,

	push	edi
	push	OFFSET ??_C@_0DF@HJICNPOB@Error?5initializing?5compression?5@
	push	OFFSET ??_C@_0BL@GHKILDDP@xmlCreateZMemBuff?3?5?5?$CFs?5?$CFd?6@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 1516 : 		    "xmlCreateZMemBuff:  %s %d\n",
; 1517 : 		    "Error initializing compression context.  ZLIB error:",
; 1518 : 		    z_err );
; 1519 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	1546					; 0000060aH
	call	_xmlIOErr
	add	esp, 32					; 00000020H
	xor	eax, eax
	pop	esi
	pop	edi

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCreateZ:

; 1520 : 	return ( NULL );
; 1521 :     }
; 1522 : 
; 1523 :     /*  Set the header data.  The CRC will be needed for the trailer  */
; 1524 :     buff->crc = crc32( 0L, NULL, 0 );

	push	0
	push	0
	push	0
	call	_crc32@12

; 1525 :     hdr_lgth = snprintf( (char *)buff->zbuff, buff->size,

	push	3
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	8
	push	139					; 0000008bH
	push	31					; 0000001fH
	push	OFFSET ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc@
	push	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	push	DWORD PTR [esi+8]
	call	_snprintf

; 1526 : 			"%c%c%c%c%c%c%c%c%c%c",
; 1527 : 			GZ_MAGIC1, GZ_MAGIC2, Z_DEFLATED,
; 1528 : 			0, 0, 0, 0, 0, 0, LXML_ZLIB_OS_CODE );
; 1529 :     buff->zctrl.next_out  = buff->zbuff + hdr_lgth;

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 52					; 00000034H
	add	ecx, eax
	mov	DWORD PTR [esi+24], ecx

; 1530 :     buff->zctrl.avail_out = buff->size - hdr_lgth;

	mov	ecx, DWORD PTR [esi]
	sub	ecx, eax

; 1531 : 
; 1532 :     return ( buff );

	mov	eax, esi
	mov	DWORD PTR [esi+28], ecx
	pop	esi
	pop	edi

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlCreateZ:

; 1484 : 
; 1485 :     int			z_err;
; 1486 :     int			hdr_lgth;
; 1487 :     xmlZMemBuffPtr	buff = NULL;
; 1488 : 
; 1489 :     if ( ( compression < 1 ) || ( compression > 9 ) )
; 1490 : 	return ( NULL );

	xor	eax, eax
	pop	edi

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateZMemBuff ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFreeZMemBuff
_TEXT	SEGMENT
_buff$ = 8						; size = 4
_xmlFreeZMemBuff PROC					; COMDAT

; 1448 : xmlFreeZMemBuff( xmlZMemBuffPtr buff ) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buff$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeZMe

; 1449 : 
; 1450 : #ifdef DEBUG_HTTP
; 1451 :     int z_err;
; 1452 : #endif
; 1453 : 
; 1454 :     if ( buff == NULL )
; 1455 : 	return;
; 1456 : 
; 1457 :     xmlFree( buff->zbuff );

	push	DWORD PTR [esi+8]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1458 : #ifdef DEBUG_HTTP
; 1459 :     z_err = deflateEnd( &buff->zctrl );
; 1460 :     if ( z_err != Z_OK )
; 1461 : 	xmlGenericError( xmlGenericErrorContext,
; 1462 : 			"xmlFreeZMemBuff:  Error releasing zlib context:  %d\n",
; 1463 : 			z_err );
; 1464 : #else
; 1465 :     deflateEnd( &buff->zctrl );

	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	_deflateEnd@4

; 1466 : #endif
; 1467 : 
; 1468 :     xmlFree( buff );

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeZMe:
	pop	esi

; 1469 :     return;
; 1470 : }

	pop	ebp
	ret	0
_xmlFreeZMemBuff ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _append_reverse_ulong
_TEXT	SEGMENT
_buff$ = 8						; size = 4
_data$ = 12						; size = 4
_append_reverse_ulong PROC				; COMDAT

; 1417 : append_reverse_ulong( xmlZMemBuff * buff, unsigned long data ) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _buff$[ebp]
	test	edx, edx
	je	SHORT $LN10@append_rev

; 1418 : 
; 1419 :     int		idx;
; 1420 : 
; 1421 :     if ( buff == NULL )
; 1422 : 	return;
; 1423 : 
; 1424 :     /*
; 1425 :     **  This is plagiarized from putLong in gzio.c (zlib source) where
; 1426 :     **  the number "4" is hardcoded.  If zlib is ever patched to
; 1427 :     **  support 64 bit file sizes, this code would need to be patched
; 1428 :     **  as well.
; 1429 :     */
; 1430 : 
; 1431 :     for ( idx = 0; idx < 4; idx++ ) {
; 1432 : 	*buff->zctrl.next_out = ( data & 0xff );

	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	BYTE PTR [eax], cl

; 1433 : 	data >>= 8;
; 1434 : 	buff->zctrl.next_out++;

	inc	DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edx+24]
	shr	ecx, 8
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edx+24]
	shr	ecx, 8
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edx+24]
	shr	ecx, 8
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edx+24]
$LN10@append_rev:

; 1435 :     }
; 1436 : 
; 1437 :     return;
; 1438 : }

	pop	ebp
	ret	0
_append_reverse_ulong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlXzfileClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlXzfileClose PROC					; COMDAT

; 1356 : xmlXzfileClose (void * context) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _context$[ebp]
	call	___libxml2_xzclose
	add	esp, 4
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	test	eax, eax
	je	SHORT $LN6@xmlXzfileC

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_09LHCEDCHF@xzclose?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN6@xmlXzfileC:

; 1357 :     int ret;
; 1358 : 
; 1359 :     ret =  (__libxml2_xzclose((xzFile) context) == LZMA_OK ) ? 0 : -1;
; 1360 :     if (ret < 0) xmlIOErr(0, "xzclose()");
; 1361 :     return(ret);
; 1362 : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlXzfileClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlXzfileRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlXzfileRead PROC					; COMDAT

; 1341 : xmlXzfileRead (void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	___libxml2_xzread
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jns	SHORT $LN4@xmlXzfileR

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_08CONNOODF@xzread?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1342 :     int ret;
; 1343 : 
; 1344 :     ret = __libxml2_xzread((xzFile) context, &buffer[0], len);
; 1345 :     if (ret < 0) xmlIOErr(0, "xzread()");
; 1346 :     return(ret);

	mov	eax, esi
$LN4@xmlXzfileR:
	pop	esi

; 1347 : }

	pop	ebp
	ret	0
_xmlXzfileRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlXzfileOpen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlXzfileOpen PROC					; COMDAT

; 1314 : xmlXzfileOpen (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _filename$[ebp]
	push	edi
	call	_xmlXzfileOpen_real
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXzfileO

; 1315 :     char *unescaped;
; 1316 :     void *retval;
; 1317 : 
; 1318 :     retval = xmlXzfileOpen_real(filename);
; 1319 :     if (retval == NULL) {
; 1320 : 	unescaped = xmlURIUnescapeString(filename, 0, NULL);

	push	eax
	push	eax
	push	edi
	call	_xmlURIUnescapeString
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1321 : 	if (unescaped != NULL) {

	test	edi, edi
	je	SHORT $LN3@xmlXzfileO

; 1322 : 	    retval = xmlXzfileOpen_real(unescaped);

	push	edi
	call	_xmlXzfileOpen_real
	add	esp, 4
	mov	esi, eax
$LN3@xmlXzfileO:

; 1323 : 	}
; 1324 : 	xmlFree(unescaped);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1325 :     }
; 1326 : 
; 1327 :     return retval;

	mov	eax, esi
$LN2@xmlXzfileO:

; 1328 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlXzfileOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlXzfileOpen_real
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlXzfileOpen_real PROC				; COMDAT

; 1276 : xmlXzfileOpen_real (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, esi
$LL13@xmlXzfileO:

; 1277 :     const char *path = NULL;
; 1278 :     xzFile fd;
; 1279 : 
; 1280 :     if (!strcmp(filename, "-")) {

	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN14@xmlXzfileO
	test	dl, dl
	je	SHORT $LN15@xmlXzfileO
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN14@xmlXzfileO
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL13@xmlXzfileO
$LN15@xmlXzfileO:
	xor	eax, eax
	jmp	SHORT $LN16@xmlXzfileO
$LN14@xmlXzfileO:
	sbb	eax, eax
	or	eax, 1
$LN16@xmlXzfileO:
	test	eax, eax
	jne	SHORT $LN2@xmlXzfileO

; 1281 :         fd = __libxml2_xzdopen(dup(fileno(stdin)), "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	eax
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	call	DWORD PTR __imp__fileno
	push	eax
	call	DWORD PTR __imp__dup
	add	esp, 12					; 0000000cH
	push	eax
	call	___libxml2_xzdopen
	add	esp, 8
	pop	esi

; 1301 :     return((void *) fd);
; 1302 : }

	pop	ebp
	ret	0
$LN2@xmlXzfileO:

; 1282 : 	return((void *) fd);
; 1283 :     }
; 1284 : 
; 1285 :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file://localhost/", 17)) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@xmlXzfileO

; 1286 : 	path = &filename[16];

	add	esi, 16					; 00000010H
	jmp	SHORT $LN7@xmlXzfileO
$LN3@xmlXzfileO:

; 1287 :     } else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@xmlXzfileO

; 1288 : 	path = &filename[7];

	add	esi, 7
	jmp	SHORT $LN7@xmlXzfileO
$LN5@xmlXzfileO:

; 1289 :     } else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:/", 6)) {

	push	6
	push	OFFSET ??_C@_06MONEMCJK@file?3?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@xmlXzfileO

; 1290 :         /* lots of generators seems to lazy to read RFC 1738 */
; 1291 : 	path = &filename[5];

	add	esi, 5
$LN7@xmlXzfileO:

; 1292 :     } else
; 1293 : 	path = filename;
; 1294 : 
; 1295 :     if (path == NULL)

	test	esi, esi
	je	SHORT $LN12@xmlXzfileO

; 1296 : 	return(NULL);
; 1297 :     if (!xmlCheckFilename(path))

	push	esi
	call	_xmlCheckFilename
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@xmlXzfileO

; 1299 : 
; 1300 :     fd = __libxml2_xzopen(path, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	esi
	call	___libxml2_xzopen
	add	esp, 8
	pop	esi

; 1301 :     return((void *) fd);
; 1302 : }

	pop	ebp
	ret	0
$LN12@xmlXzfileO:

; 1298 :         return(NULL);

	xor	eax, eax
	pop	esi

; 1301 :     return((void *) fd);
; 1302 : }

	pop	ebp
	ret	0
_xmlXzfileOpen_real ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlXzfileMatch
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlXzfileMatch PROC					; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, 1
	ret	0
_xmlXzfileMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlGzfileClose PROC					; COMDAT

; 1237 : xmlGzfileClose (void * context) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _context$[ebp]
	call	_gzclose@4
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	test	eax, eax
	je	SHORT $LN6@xmlGzfileC

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_09GBIBOIBA@gzclose?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN6@xmlGzfileC:

; 1238 :     int ret;
; 1239 : 
; 1240 :     ret =  (gzclose((gzFile) context) == Z_OK ) ? 0 : -1;
; 1241 :     if (ret < 0) xmlIOErr(0, "gzclose()");
; 1242 :     return(ret);
; 1243 : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlGzfileClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileWrite
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlGzfileWrite PROC					; COMDAT

; 1221 : xmlGzfileWrite (void * context, const char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	_gzwrite@12
	mov	esi, eax
	test	esi, esi
	jns	SHORT $LN4@xmlGzfileW

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_09MKOIAPFP@gzwrite?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1222 :     int ret;
; 1223 : 
; 1224 :     ret = gzwrite((gzFile) context, (char *) &buffer[0], len);
; 1225 :     if (ret < 0) xmlIOErr(0, "gzwrite()");
; 1226 :     return(ret);

	mov	eax, esi
$LN4@xmlGzfileW:
	pop	esi

; 1227 : }

	pop	ebp
	ret	0
_xmlGzfileWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlGzfileRead PROC					; COMDAT

; 1201 : xmlGzfileRead (void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	_gzread@12
	mov	esi, eax
	test	esi, esi
	jns	SHORT $LN4@xmlGzfileR

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_08FNKEGDJF@gzread?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 1202 :     int ret;
; 1203 : 
; 1204 :     ret = gzread((gzFile) context, &buffer[0], len);
; 1205 :     if (ret < 0) xmlIOErr(0, "gzread()");
; 1206 :     return(ret);

	mov	eax, esi
$LN4@xmlGzfileR:
	pop	esi

; 1207 : }

	pop	ebp
	ret	0
_xmlGzfileRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileOpenW
_TEXT	SEGMENT
_mode$ = -16						; size = 15
_filename$ = 8						; size = 4
_compression$ = 12					; size = 4
_xmlGzfileOpenW PROC					; COMDAT

; 1147 : xmlGzfileOpenW (const char *filename, int compression) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _compression$[ebp]
	lea	eax, DWORD PTR _mode$[ebp]
	push	OFFSET ??_C@_04NMBHCBBN@wb?$CFd@
	push	15					; 0000000fH
	push	eax
	call	_snprintf
	mov	esi, DWORD PTR _filename$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, esi
$LL10@xmlGzfileO:

; 1148 :     const char *path = NULL;
; 1149 :     char mode[15];
; 1150 :     gzFile fd;
; 1151 : 
; 1152 :     snprintf(mode, sizeof(mode), "wb%d", compression);
; 1153 :     if (!strcmp(filename, "-")) {

	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN11@xmlGzfileO
	test	dl, dl
	je	SHORT $LN12@xmlGzfileO
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN11@xmlGzfileO
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL10@xmlGzfileO
$LN12@xmlGzfileO:
	xor	eax, eax
	jmp	SHORT $LN13@xmlGzfileO
$LN11@xmlGzfileO:
	sbb	eax, eax
	or	eax, 1
$LN13@xmlGzfileO:
	test	eax, eax
	jne	SHORT $LN2@xmlGzfileO

; 1154 :         int duped_fd = dup(fileno(stdout));

	push	edi
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	call	DWORD PTR __imp__fileno
	push	eax
	call	DWORD PTR __imp__dup
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 1155 :         fd = gzdopen(duped_fd, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	esi
	call	_gzdopen@8
	mov	edi, eax

; 1156 :         if (fd == Z_NULL && duped_fd >= 0) {

	test	edi, edi
	jne	SHORT $LN3@xmlGzfileO
	test	esi, esi
	js	SHORT $LN3@xmlGzfileO

; 1157 :             close(duped_fd);  /* gzdOpen() does not close on failure */

	push	esi
	call	DWORD PTR __imp__close
	add	esp, 4
$LN3@xmlGzfileO:

; 1158 :         }
; 1159 : 
; 1160 : 	return((void *) fd);

	mov	eax, edi
	pop	edi
	pop	esi

; 1183 : #else
; 1184 :     fd = gzopen(path, mode);
; 1185 : #endif
; 1186 :     return((void *) fd);
; 1187 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlGzfileO:

; 1161 :     }
; 1162 : 
; 1163 :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file://localhost/", 17))

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@xmlGzfileO

; 1164 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 1165 : 	path = &filename[17];

	add	esi, 17					; 00000011H
	jmp	SHORT $LN6@xmlGzfileO
$LN4@xmlGzfileO:

; 1166 : #else
; 1167 : 	path = &filename[16];
; 1168 : #endif
; 1169 :     else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@xmlGzfileO

; 1170 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 1171 : 	path = &filename[8];

	add	esi, 8
$LN6@xmlGzfileO:

; 1172 : #else
; 1173 : 	path = &filename[7];
; 1174 : #endif
; 1175 :     } else
; 1176 : 	path = filename;
; 1177 : 
; 1178 :     if (path == NULL)

	test	esi, esi
	jne	SHORT $LN8@xmlGzfileO

; 1179 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 1183 : #else
; 1184 :     fd = gzopen(path, mode);
; 1185 : #endif
; 1186 :     return((void *) fd);
; 1187 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlGzfileO:

; 1180 : 
; 1181 : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 1182 :     fd = xmlWrapGzOpenUtf8(path, mode);

	lea	eax, DWORD PTR _mode$[ebp]
	push	eax
	push	esi
	call	_xmlWrapGzOpenUtf8
	add	esp, 8
	pop	esi

; 1183 : #else
; 1184 :     fd = gzopen(path, mode);
; 1185 : #endif
; 1186 :     return((void *) fd);
; 1187 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGzfileOpenW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileOpen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlGzfileOpen PROC					; COMDAT

; 1120 : xmlGzfileOpen (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _filename$[ebp]
	push	edi
	call	_xmlGzfileOpen_real
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlGzfileO

; 1121 :     char *unescaped;
; 1122 :     void *retval;
; 1123 : 
; 1124 :     retval = xmlGzfileOpen_real(filename);
; 1125 :     if (retval == NULL) {
; 1126 : 	unescaped = xmlURIUnescapeString(filename, 0, NULL);

	push	eax
	push	eax
	push	edi
	call	_xmlURIUnescapeString
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1127 : 	if (unescaped != NULL) {

	test	edi, edi
	je	SHORT $LN3@xmlGzfileO

; 1128 : 	    retval = xmlGzfileOpen_real(unescaped);

	push	edi
	call	_xmlGzfileOpen_real
	add	esp, 4
	mov	esi, eax
$LN3@xmlGzfileO:

; 1129 : 	}
; 1130 : 	xmlFree(unescaped);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1131 :     }
; 1132 :     return retval;

	mov	eax, esi
$LN2@xmlGzfileO:

; 1133 : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlGzfileOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileOpen_real
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlGzfileOpen_real PROC				; COMDAT

; 1070 : xmlGzfileOpen_real (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	ecx, esi
$LL12@xmlGzfileO:

; 1071 :     const char *path = NULL;
; 1072 :     gzFile fd;
; 1073 : 
; 1074 :     if (!strcmp(filename, "-")) {

	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN13@xmlGzfileO
	test	dl, dl
	je	SHORT $LN14@xmlGzfileO
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN13@xmlGzfileO
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL12@xmlGzfileO
$LN14@xmlGzfileO:
	xor	eax, eax
	jmp	SHORT $LN15@xmlGzfileO
$LN13@xmlGzfileO:
	sbb	eax, eax
	or	eax, 1
$LN15@xmlGzfileO:
	test	eax, eax
	jne	SHORT $LN2@xmlGzfileO

; 1075 :         int duped_fd = dup(fileno(stdin));

	push	edi
	push	eax
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	call	DWORD PTR __imp__fileno
	push	eax
	call	DWORD PTR __imp__dup
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 1076 :         fd = gzdopen(duped_fd, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	esi
	call	_gzdopen@8
	mov	edi, eax

; 1077 :         if (fd == Z_NULL && duped_fd >= 0) {

	test	edi, edi
	jne	SHORT $LN3@xmlGzfileO
	test	esi, esi
	js	SHORT $LN3@xmlGzfileO

; 1078 :             close(duped_fd);  /* gzdOpen() does not close on failure */

	push	esi
	call	DWORD PTR __imp__close
	add	esp, 4
$LN3@xmlGzfileO:

; 1079 :         }
; 1080 : 
; 1081 : 	return((void *) fd);

	mov	eax, edi
	pop	edi
	pop	esi

; 1106 : #else
; 1107 :     fd = gzopen(path, "rb");
; 1108 : #endif
; 1109 :     return((void *) fd);
; 1110 : }

	pop	ebp
	ret	0
$LN2@xmlGzfileO:

; 1082 :     }
; 1083 : 
; 1084 :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file://localhost/", 17))

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@xmlGzfileO

; 1085 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 1086 : 	path = &filename[17];

	add	esi, 17					; 00000011H
	jmp	SHORT $LN6@xmlGzfileO
$LN4@xmlGzfileO:

; 1087 : #else
; 1088 : 	path = &filename[16];
; 1089 : #endif
; 1090 :     else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@xmlGzfileO

; 1091 : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 1092 : 	path = &filename[8];

	add	esi, 8
$LN6@xmlGzfileO:

; 1093 : #else
; 1094 : 	path = &filename[7];
; 1095 : #endif
; 1096 :     } else
; 1097 : 	path = filename;
; 1098 : 
; 1099 :     if (path == NULL)

	test	esi, esi
	je	SHORT $LN11@xmlGzfileO

; 1100 : 	return(NULL);
; 1101 :     if (!xmlCheckFilename(path))

	push	esi
	call	_xmlCheckFilename
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@xmlGzfileO

; 1103 : 
; 1104 : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 1105 :     fd = xmlWrapGzOpenUtf8(path, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	esi
	call	_xmlWrapGzOpenUtf8
	add	esp, 8
	pop	esi

; 1106 : #else
; 1107 :     fd = gzopen(path, "rb");
; 1108 : #endif
; 1109 :     return((void *) fd);
; 1110 : }

	pop	ebp
	ret	0
$LN11@xmlGzfileO:

; 1102 :         return(NULL);

	xor	eax, eax
	pop	esi

; 1106 : #else
; 1107 :     fd = gzopen(path, "rb");
; 1108 : #endif
; 1109 :     return((void *) fd);
; 1110 : }

	pop	ebp
	ret	0
_xmlGzfileOpen_real ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGzfileMatch
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlGzfileMatch PROC					; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, 1
	ret	0
_xmlGzfileMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlBufferWrite
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlBufferWrite PROC					; COMDAT

; 1031 : xmlBufferWrite (void * context, const char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _len$[ebp]
	push	esi
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
	or	ecx, -1
	test	eax, eax
	cmovne	esi, ecx
	mov	eax, esi
	pop	esi

; 1032 :     int ret;
; 1033 : 
; 1034 :     ret = xmlBufferAdd((xmlBufferPtr) context, (const xmlChar *) buffer, len);
; 1035 :     if (ret != 0)
; 1036 :         return(-1);
; 1037 :     return(len);
; 1038 : }

	pop	ebp
	ret	0
_xmlBufferWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileFlush
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlFileFlush PROC					; COMDAT

; 1008 : xmlFileFlush (void * context) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _context$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlFileFlu

; 1009 :     int ret;
; 1010 : 
; 1011 :     if (context == NULL)
; 1012 :         return(-1);

	or	eax, -1

; 1017 : }

	pop	ebp
	ret	0
$LN2@xmlFileFlu:
	push	ebx

; 1013 :     ret = ( fflush((FILE *) context) == EOF ) ? -1 : 0;

	push	eax
	call	DWORD PTR __imp__fflush
	xor	ebx, ebx
	add	esp, 4
	cmp	eax, -1
	setne	bl

; 1014 :     if (ret < 0)

	jne	SHORT $LN5@xmlFileFlu

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_08FAKMNOA@fflush?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN5@xmlFileFlu:

; 1015 :         xmlIOErr(0, "fflush()");
; 1016 :     return(ret);

	lea	eax, DWORD PTR [ebx-1]
	pop	ebx

; 1017 : }

	pop	ebp
	ret	0
_xmlFileFlush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileWrite
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlFileWrite PROC					; COMDAT

; 957  : xmlFileWrite (void * context, const char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _context$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlFileWri

; 958  :     int items;
; 959  : 
; 960  :     if ((context == NULL) || (buffer == NULL))

	mov	eax, DWORD PTR _buffer$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlFileWri

; 962  :     items = fwrite(&buffer[0], len, 1, (FILE *) context);

	push	edi
	push	esi
	push	1
	push	DWORD PTR _len$[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	mov	edi, eax
	add	esp, 16					; 00000010H

; 963  :     if ((items == 0) && (ferror((FILE *) context))) {

	test	edi, edi
	jne	SHORT $LN4@xmlFileWri
	push	esi
	call	DWORD PTR __imp__ferror
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@xmlFileWri

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_08LGKENNOL@fwrite?$CI?$CJ@
	push	edi
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 964  :         xmlIOErr(0, "fwrite()");
; 965  : 	return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 968  : }

	pop	ebp
	ret	0
$LN4@xmlFileWri:

; 966  :     }
; 967  :     return(items * len);

	imul	edi, DWORD PTR _len$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi

; 968  : }

	pop	ebp
	ret	0
$LN3@xmlFileWri:

; 961  :         return(-1);

	or	eax, -1
	pop	esi

; 968  : }

	pop	ebp
	ret	0
_xmlFileWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileOpenW
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlFileOpenW PROC					; COMDAT

; 885  : xmlFileOpenW (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	ecx, esi
$LL17@xmlFileOpe:

; 886  :     const char *path = NULL;
; 887  :     FILE *fd;
; 888  : 
; 889  :     if (!strcmp(filename, "-")) {

	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN18@xmlFileOpe
	test	dl, dl
	je	SHORT $LN19@xmlFileOpe
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN18@xmlFileOpe
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL17@xmlFileOpe
$LN19@xmlFileOpe:
	xor	eax, eax
	jmp	SHORT $LN20@xmlFileOpe
$LN18@xmlFileOpe:
	sbb	eax, eax
	or	eax, 1
$LN20@xmlFileOpe:
	test	eax, eax
	jne	SHORT $LN2@xmlFileOpe
	pop	esi

; 890  : 	fd = stdout;

	mov	DWORD PTR _filename$[ebp], 1

; 922  : }

	pop	ebp

; 890  : 	fd = stdout;

	jmp	DWORD PTR __imp____acrt_iob_func
$LN2@xmlFileOpe:

; 891  : 	return((void *) fd);
; 892  :     }
; 893  : 
; 894  :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file://localhost/", 17))

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@xmlFileOpe

; 895  : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 896  : 	path = &filename[17];

	add	esi, 17					; 00000011H
	jmp	SHORT $LN5@xmlFileOpe
$LN3@xmlFileOpe:

; 897  : #else
; 898  : 	path = &filename[16];
; 899  : #endif
; 900  :     else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@xmlFileOpe

; 901  : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 902  : 	path = &filename[8];

	add	esi, 8
$LN5@xmlFileOpe:

; 903  : #else
; 904  : 	path = &filename[7];
; 905  : #endif
; 906  :     } else
; 907  : 	path = filename;
; 908  : 
; 909  :     if (path == NULL)

	test	esi, esi
	jne	SHORT $LN7@xmlFileOpe

; 910  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 922  : }

	pop	ebp
	ret	0
$LN7@xmlFileOpe:
	push	ebx
	push	edi

; 587  :     wPath = __xmlIOWin32UTF8ToWChar(path);

	push	esi
	call	___xmlIOWin32UTF8ToWChar
	mov	ebx, eax
	add	esp, 4

; 588  :     if(wPath)

	test	ebx, ebx
	je	SHORT $LN16@xmlFileOpe

; 589  :     {
; 590  :        fd = _wfopen(wPath, mode ? L"wb" : L"rb");

	push	OFFSET ??_C@_15MJDFFMKN@?$AAw?$AAb@
	push	ebx
	call	DWORD PTR __imp___wfopen

; 591  :        xmlFree(wPath);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 592  :     }
; 593  :     /* maybe path in native encoding */
; 594  :     if(fd == NULL)

	test	edi, edi
	jne	SHORT $LN14@xmlFileOpe
$LN16@xmlFileOpe:

; 595  :        fd = fopen(path, mode ? "wb" : "rb");

	push	OFFSET ??_C@_02GMLFBBN@wb@
	push	esi
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 8

; 911  : 
; 912  : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 913  :     fd = xmlWrapOpenUtf8(path, 1);
; 914  : #elif(__MVS__)
; 915  :     fd = fopen(path, "w");
; 916  : #else
; 917  :     fd = fopen(path, "wb");
; 918  : #endif /* WIN32 */
; 919  : 
; 920  :     if (fd == NULL) xmlIOErr(0, path);

	test	edi, edi
	jne	SHORT $LN14@xmlFileOpe

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	esi
	push	eax
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN14@xmlFileOpe:

; 921  :     return((void *) fd);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 922  : }

	pop	ebp
	ret	0
_xmlFileOpenW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileOpen_real
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlFileOpen_real PROC					; COMDAT

; 800  : xmlFileOpen_real (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _filename$[ebp]
	test	esi, esi
	je	$LN19@xmlFileOpe

; 801  :     const char *path = filename;
; 802  :     FILE *fd;
; 803  : 
; 804  :     if (filename == NULL)
; 805  :         return(NULL);
; 806  : 
; 807  :     if (!strcmp(filename, "-")) {

	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, esi
$LL20@xmlFileOpe:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN21@xmlFileOpe
	test	dl, dl
	je	SHORT $LN22@xmlFileOpe
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN21@xmlFileOpe
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL20@xmlFileOpe
$LN22@xmlFileOpe:
	xor	eax, eax
	jmp	SHORT $LN23@xmlFileOpe
$LN21@xmlFileOpe:
	sbb	eax, eax
	or	eax, 1
$LN23@xmlFileOpe:
	test	eax, eax
	jne	SHORT $LN3@xmlFileOpe
	pop	esi

; 808  : 	fd = stdin;

	mov	DWORD PTR _filename$[ebp], eax

; 846  : }

	pop	ebp

; 808  : 	fd = stdin;

	jmp	DWORD PTR __imp____acrt_iob_func
$LN3@xmlFileOpe:

; 809  : 	return((void *) fd);
; 810  :     }
; 811  : 
; 812  :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file://localhost/", 17)) {

	push	17					; 00000011H
	push	OFFSET ??_C@_0BC@IDKAIMBK@file?3?1?1localhost?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@xmlFileOpe

; 813  : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 814  : 	path = &filename[17];

	add	esi, 17					; 00000011H
	jmp	SHORT $LN8@xmlFileOpe
$LN4@xmlFileOpe:

; 815  : #else
; 816  : 	path = &filename[16];
; 817  : #endif
; 818  :     } else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:///", 8)) {

	push	8
	push	OFFSET ??_C@_08NPMJDGGI@file?3?1?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@xmlFileOpe

; 819  : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 820  : 	path = &filename[8];

	add	esi, 8
	jmp	SHORT $LN8@xmlFileOpe
$LN6@xmlFileOpe:

; 821  : #else
; 822  : 	path = &filename[7];
; 823  : #endif
; 824  :     } else if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "file:/", 6)) {

	push	6
	push	OFFSET ??_C@_06MONEMCJK@file?3?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@xmlFileOpe

; 825  :         /* lots of generators seems to lazy to read RFC 1738 */
; 826  : #if defined (_WIN32) || defined (__DJGPP__) && !defined(__CYGWIN__)
; 827  : 	path = &filename[6];

	add	esi, 6
$LN8@xmlFileOpe:

; 828  : #else
; 829  : 	path = &filename[5];
; 830  : #endif
; 831  :     }
; 832  : 
; 833  :     /* Do not check DDNAME on zOS ! */
; 834  : #if !defined(__MVS__)
; 835  :     if (!xmlCheckFilename(path))

	push	esi
	call	_xmlCheckFilename
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@xmlFileOpe

; 587  :     wPath = __xmlIOWin32UTF8ToWChar(path);

	push	ebx
	push	edi
	push	esi
	call	___xmlIOWin32UTF8ToWChar
	mov	ebx, eax
	add	esp, 4

; 588  :     if(wPath)

	test	ebx, ebx
	je	SHORT $LN18@xmlFileOpe

; 589  :     {
; 590  :        fd = _wfopen(wPath, mode ? L"wb" : L"rb");

	push	OFFSET ??_C@_15JJPIMNBO@?$AAr?$AAb@
	push	ebx
	call	DWORD PTR __imp___wfopen

; 591  :        xmlFree(wPath);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 592  :     }
; 593  :     /* maybe path in native encoding */
; 594  :     if(fd == NULL)

	test	edi, edi
	jne	SHORT $LN16@xmlFileOpe
$LN18@xmlFileOpe:

; 595  :        fd = fopen(path, mode ? "wb" : "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	push	esi
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 8

; 837  : #endif
; 838  : 
; 839  : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 840  :     fd = xmlWrapOpenUtf8(path, 0);
; 841  : #else
; 842  :     fd = fopen(path, "r");
; 843  : #endif /* WIN32 */
; 844  :     if (fd == NULL) xmlIOErr(0, path);

	test	edi, edi
	jne	SHORT $LN16@xmlFileOpe

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	esi
	push	eax
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN16@xmlFileOpe:

; 845  :     return((void *) fd);

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 846  : }

	pop	ebp
	ret	0
$LN19@xmlFileOpe:

; 836  :         return(NULL);

	xor	eax, eax
	pop	esi

; 846  : }

	pop	ebp
	ret	0
_xmlFileOpen_real ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFdClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlFdClose PROC					; COMDAT

; 770  : xmlFdClose (void * context) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _context$[ebp]
	call	DWORD PTR __imp__close
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jns	SHORT $LN4@xmlFdClose

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_07LBJPAJEN@close?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 771  :     int ret;
; 772  :     ret = close((int) (ptrdiff_t) context);
; 773  :     if (ret < 0) xmlIOErr(0, "close()");
; 774  :     return(ret);

	mov	eax, esi
$LN4@xmlFdClose:
	pop	esi

; 775  : }

	pop	ebp
	ret	0
_xmlFdClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFdWrite
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlFdWrite PROC					; COMDAT

; 750  : xmlFdWrite (void * context, const char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	jle	SHORT $LN8@xmlFdWrite

; 751  :     int ret = 0;
; 752  : 
; 753  :     if (len > 0) {
; 754  : 	ret = write((int) (ptrdiff_t) context, &buffer[0], len);

	push	esi
	push	eax
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	DWORD PTR __imp__write
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 755  : 	if (ret < 0) xmlIOErr(0, "write()");

	test	esi, esi
	jns	SHORT $LN9@xmlFdWrite

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_07BKPGOOAC@write?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 756  :     }
; 757  :     return(ret);

	mov	eax, esi
$LN9@xmlFdWrite:
	pop	esi

; 758  : }

	pop	ebp
	ret	0
$LN8@xmlFdWrite:

; 756  :     }
; 757  :     return(ret);

	xor	eax, eax

; 758  : }

	pop	ebp
	ret	0
_xmlFdWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFdRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlFdRead PROC						; COMDAT

; 730  : xmlFdRead (void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _context$[ebp]
	call	DWORD PTR __imp__read
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jns	SHORT $LN4@xmlFdRead

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_06CDFDMJHA@read?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 731  :     int ret;
; 732  : 
; 733  :     ret = read((int) (ptrdiff_t) context, &buffer[0], len);
; 734  :     if (ret < 0) xmlIOErr(0, "read()");
; 735  :     return(ret);

	mov	eax, esi
$LN4@xmlFdRead:
	pop	esi

; 736  : }

	pop	ebp
	ret	0
_xmlFdRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlWrapStatUtf8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_info$ = 12						; size = 4
_xmlWrapStatUtf8 PROC					; COMDAT

; 637  : xmlWrapStatUtf8(const char *path, struct _stat *info) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _path$[ebp]
	call	___xmlIOWin32UTF8ToWChar
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN5@xmlWrapSta

; 638  :     int retval = -1;
; 639  :     wchar_t *wPath;
; 640  : 
; 641  :     wPath = __xmlIOWin32UTF8ToWChar(path);
; 642  :     if (wPath) {
; 643  :        retval = _wstat(wPath, info);

	push	DWORD PTR _info$[ebp]
	push	esi
	call	DWORD PTR __imp___wstat64i32

; 644  :        xmlFree(wPath);

	push	esi
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 645  :     }
; 646  :     /* maybe path in native encoding */
; 647  :     if(retval < 0)

	test	edi, edi
	js	SHORT $LN5@xmlWrapSta

; 649  :     return retval;

	mov	eax, edi
	pop	edi

; 650  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlWrapSta:
	pop	edi
	pop	esi
	pop	ebp

; 648  :        retval = _stat(path, info);

	jmp	DWORD PTR __imp___stat64i32
_xmlWrapStatUtf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlWrapGzOpenUtf8
_TEXT	SEGMENT
_wPath$1$ = -4						; size = 4
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_xmlWrapGzOpenUtf8 PROC					; COMDAT

; 603  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _mode$[ebp]
	mov	esi, DWORD PTR _path$[ebp]
	push	ebx
	push	esi
	call	_gzopen@8
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN1@xmlWrapGzO

; 604  :     gzFile fd;
; 605  :     wchar_t *wPath;
; 606  : 
; 607  :     fd = gzopen (path, mode);
; 608  :     if (fd)
; 609  :         return fd;
; 610  : 
; 611  :     wPath = __xmlIOWin32UTF8ToWChar(path);

	push	esi
	call	___xmlIOWin32UTF8ToWChar
	add	esp, 4
	mov	DWORD PTR _wPath$1$[ebp], eax

; 612  :     if(wPath)

	test	eax, eax
	je	SHORT $LN3@xmlWrapGzO

; 613  :     {
; 614  : 	int d, m = (strstr(mode, "r") ? O_RDONLY : O_RDWR);

	push	OFFSET ??_C@_01KDCPPGHE@r@
	push	ebx
	call	_strstr
	neg	eax

; 615  : #ifdef _O_BINARY
; 616  :         m |= (strstr(mode, "b") ? _O_BINARY : 0);

	push	OFFSET ??_C@_01OJONOECF@b@
	sbb	esi, esi
	and	esi, -2					; fffffffeH
	push	ebx
	add	esi, 2
	call	_strstr
	neg	eax
	sbb	eax, eax
	and	eax, 32768				; 00008000H
	or	esi, eax

; 617  : #endif
; 618  : 	d = _wopen(wPath, m);

	push	esi
	mov	esi, DWORD PTR _wPath$1$[ebp]
	push	esi
	call	DWORD PTR __imp___wopen
	add	esp, 24					; 00000018H

; 619  : 	if (d >= 0)

	test	eax, eax
	js	SHORT $LN4@xmlWrapGzO

; 620  : 	    fd = gzdopen(d, mode);

	push	ebx
	push	eax
	call	_gzdopen@8
	mov	edi, eax
$LN4@xmlWrapGzO:

; 621  :         xmlFree(wPath);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlWrapGzO:

; 622  :     }
; 623  : 
; 624  :     return fd;

	mov	eax, edi
$LN1@xmlWrapGzO:
	pop	edi

; 625  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlWrapGzOpenUtf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlWrapOpenUtf8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_xmlWrapOpenUtf8 PROC					; COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _path$[ebp]
	call	___xmlIOWin32UTF8ToWChar
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN5@xmlWrapOpe

; 584  :     FILE *fd = NULL;
; 585  :     wchar_t *wPath;
; 586  : 
; 587  :     wPath = __xmlIOWin32UTF8ToWChar(path);
; 588  :     if(wPath)
; 589  :     {
; 590  :        fd = _wfopen(wPath, mode ? L"wb" : L"rb");

	cmp	DWORD PTR _mode$[ebp], 0
	mov	eax, OFFSET ??_C@_15JJPIMNBO@?$AAr?$AAb@
	mov	ecx, OFFSET ??_C@_15MJDFFMKN@?$AAw?$AAb@
	cmove	ecx, eax
	push	ecx
	push	esi
	call	DWORD PTR __imp___wfopen

; 591  :        xmlFree(wPath);

	push	esi
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 592  :     }
; 593  :     /* maybe path in native encoding */
; 594  :     if(fd == NULL)

	test	edi, edi
	je	SHORT $LN5@xmlWrapOpe

; 596  : 
; 597  :     return fd;

	mov	eax, edi
	pop	edi

; 598  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlWrapOpe:

; 595  :        fd = fopen(path, mode ? "wb" : "rb");

	cmp	DWORD PTR _mode$[ebp], 0
	mov	eax, OFFSET ??_C@_02GMLFBBN@wb@
	mov	ecx, OFFSET ??_C@_02JDPG@rb@
	cmove	eax, ecx
	pop	edi

; 598  : }

	pop	esi
	mov	DWORD PTR _mode$[ebp], eax
	pop	ebp

; 595  :        fd = fopen(path, mode ? "wb" : "rb");

	jmp	DWORD PTR __imp__fopen
_xmlWrapOpenUtf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOErr
_TEXT	SEGMENT
_code$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlIOErr PROC						; COMDAT

; 425  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	DWORD PTR _code$[ebp]
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);
; 427  : }

	pop	ebp
	ret	0
_xmlIOErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlIOErrMemory PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 235  : }

	pop	ebp
	ret	0
_xmlIOErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT ___xmlIOWin32UTF8ToWChar
_TEXT	SEGMENT
_u8String$ = 8						; size = 4
___xmlIOWin32UTF8ToWChar PROC				; COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _u8String$[ebp]
	test	edi, edi
	je	SHORT $LN10@xmlIOWin32

; 203  :     wchar_t *wString = NULL;
; 204  : 
; 205  :     if (u8String) {
; 206  :         int wLen =

	push	ebx
	push	0
	push	0
	push	-1
	push	edi
	push	8
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24
	mov	ebx, eax

; 207  :             MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, u8String,
; 208  :                                 -1, NULL, 0);
; 209  :         if (wLen) {

	test	ebx, ebx
	je	SHORT $LN9@xmlIOWin32

; 210  :             wString = xmlMalloc(wLen * sizeof(wchar_t));

	lea	eax, DWORD PTR [ebx+ebx]
	push	esi
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 211  :             if (wString) {

	test	esi, esi
	je	SHORT $LN12@xmlIOWin32

; 212  :                 if (MultiByteToWideChar
; 213  :                     (CP_UTF8, 0, u8String, -1, wString, wLen) == 0) {

	push	ebx
	push	esi
	push	-1
	push	edi
	push	0
	push	65001					; 0000fde9H
	call	DWORD PTR __imp__MultiByteToWideChar@24
	test	eax, eax
	jne	SHORT $LN7@xmlIOWin32

; 214  :                     xmlFree(wString);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 215  :                     wString = NULL;
; 216  :                 }
; 217  :             }
; 218  :         }
; 219  :     }
; 220  : 
; 221  :     return wString;

	xor	eax, eax
$LN12@xmlIOWin32:
	pop	esi
	pop	ebx
	pop	edi

; 222  : }

	pop	ebp
	ret	0
$LN7@xmlIOWin32:

; 215  :                     wString = NULL;
; 216  :                 }
; 217  :             }
; 218  :         }
; 219  :     }
; 220  : 
; 221  :     return wString;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 222  : }

	pop	ebp
	ret	0
$LN9@xmlIOWin32:
	pop	ebx

; 215  :                     wString = NULL;
; 216  :                 }
; 217  :             }
; 218  :         }
; 219  :     }
; 220  : 
; 221  :     return wString;

	xor	eax, eax
	pop	edi

; 222  : }

	pop	ebp
	ret	0
$LN10@xmlIOWin32:

; 215  :                     wString = NULL;
; 216  :                 }
; 217  :             }
; 218  :         }
; 219  :     }
; 220  : 
; 221  :     return wString;

	xor	eax, eax
	pop	edi

; 222  : }

	pop	ebp
	ret	0
___xmlIOWin32UTF8ToWChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlAllocOutputBufferInternal
_TEXT	SEGMENT
_encoder$ = 8						; size = 4
_xmlAllocOutputBufferInternal PROC			; COMDAT

; 2413 : xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlAllocOu

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2454 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlAllocOu:
	xorps	xmm0, xmm0

; 2414 :     xmlOutputBufferPtr ret;
; 2415 : 
; 2416 :     ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
; 2417 :     if (ret == NULL) {
; 2418 : 	xmlIOErrMemory("creating output buffer");
; 2419 : 	return(NULL);
; 2420 :     }
; 2421 :     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0

; 2422 :     ret->buffer = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+16], eax

; 2423 :     if (ret->buffer == NULL) {

	test	eax, eax
	je	SHORT $LN10@xmlAllocOu

; 2424 :         xmlFree(ret);
; 2425 : 	return(NULL);
; 2426 :     }
; 2427 : 
; 2428 : 
; 2429 :     /*
; 2430 :      * For conversion buffers we use the special IO handling
; 2431 :      */
; 2432 :     xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_IO);

	push	3
	push	eax
	call	_xmlBufSetAllocationScheme

; 2433 : 
; 2434 :     ret->encoder = encoder;

	mov	eax, DWORD PTR _encoder$[ebp]
	add	esp, 8
	mov	DWORD PTR [esi+12], eax

; 2435 :     if (encoder != NULL) {

	test	eax, eax
	je	SHORT $LN4@xmlAllocOu

; 2436 :         ret->conv = xmlBufCreateSize(4000);

	push	4000					; 00000fa0H
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 2437 : 	if (ret->conv == NULL) {

	test	eax, eax
	je	SHORT $LN10@xmlAllocOu

; 2439 : 	    return(NULL);
; 2440 : 	}
; 2441 : 
; 2442 : 	/*
; 2443 : 	 * This call is designed to initiate the encoder state
; 2444 : 	 */
; 2445 :         xmlCharEncOutput(ret, 1);

	push	1
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8

; 2446 :     } else

	jmp	SHORT $LN5@xmlAllocOu
$LN4@xmlAllocOu:

; 2447 :         ret->conv = NULL;

	mov	DWORD PTR [esi+20], 0
$LN5@xmlAllocOu:

; 2448 :     ret->writecallback = NULL;

	mov	DWORD PTR [esi+4], 0

; 2449 :     ret->closecallback = NULL;
; 2450 :     ret->context = NULL;
; 2451 :     ret->written = 0;
; 2452 : 
; 2453 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], 0
	pop	esi

; 2454 : }

	pop	ebp
	ret	0
$LN10@xmlAllocOu:

; 2438 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2454 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlAllocOutputBufferInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateFilenameDefault
_TEXT	SEGMENT
_func$ = 8						; size = 4
_xmlOutputBufferCreateFilenameDefault PROC		; COMDAT

; 3111 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlOutputBufferCreateFilenameValue
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	mov	eax, OFFSET ___xmlOutputBufferCreateFilename
	cmove	esi, eax
	call	___xmlOutputBufferCreateFilenameValue
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, esi
	pop	esi

; 3112 :     xmlOutputBufferCreateFilenameFunc old = xmlOutputBufferCreateFilenameValue;
; 3113 : #ifdef LIBXML_OUTPUT_ENABLED
; 3114 :     if (old == NULL) {
; 3115 : 		old = __xmlOutputBufferCreateFilename;
; 3116 : 	}
; 3117 : #endif
; 3118 :     xmlOutputBufferCreateFilenameValue = func;
; 3119 :     return(old);
; 3120 : }

	pop	ebp
	ret	0
_xmlOutputBufferCreateFilenameDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateFilenameDefault
_TEXT	SEGMENT
_func$ = 8						; size = 4
_xmlParserInputBufferCreateFilenameDefault PROC		; COMDAT

; 3091 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlParserInputBufferCreateFilenameValue
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	mov	eax, OFFSET ___xmlParserInputBufferCreateFilename
	cmove	esi, eax
	call	___xmlParserInputBufferCreateFilenameValue
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, esi
	pop	esi

; 3092 :     xmlParserInputBufferCreateFilenameFunc old = xmlParserInputBufferCreateFilenameValue;
; 3093 :     if (old == NULL) {
; 3094 : 		old = __xmlParserInputBufferCreateFilename;
; 3095 : 	}
; 3096 : 
; 3097 :     xmlParserInputBufferCreateFilenameValue = func;
; 3098 :     return(old);
; 3099 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateFilenameDefault ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlLoadExternalEntity
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlLoadExternalEntity PROC				; COMDAT

; 4021 :                       xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _URL$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlLoadExt

; 4022 :     if ((URL != NULL) && (xmlNoNetExists(URL) == 0)) {

	push	esi
	call	_xmlNoNetExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlLoadExt

; 4023 : 	char *canonicFilename;
; 4024 : 	xmlParserInputPtr ret;
; 4025 : 
; 4026 : 	canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);

	push	edi
	push	esi
	call	_xmlCanonicPath
	mov	edi, eax
	add	esp, 4

; 4027 : 	if (canonicFilename == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlLoadExt

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BJ@CJFKOCMN@building?5canonical?5path?6@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 4028 :             xmlIOErrMemory("building canonical path\n");
; 4029 : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 4037 : }

	pop	ebp
	ret	0
$LN3@xmlLoadExt:

; 4030 : 	}
; 4031 : 
; 4032 : 	ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);

	push	DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _ID$[ebp]
	push	edi
	call	DWORD PTR _xmlCurrentExternalEntityLoader

; 4033 : 	xmlFree(canonicFilename);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 16					; 00000010H

; 4034 : 	return(ret);

	mov	eax, esi
	pop	edi
	pop	esi

; 4037 : }

	pop	ebp
	ret	0
$LN2@xmlLoadExt:

; 4035 :     }
; 4036 :     return(xmlCurrentExternalEntityLoader(URL, ID, ctxt));

	push	DWORD PTR _ctxt$[ebp]
	push	DWORD PTR _ID$[ebp]
	push	esi
	call	DWORD PTR _xmlCurrentExternalEntityLoader
	add	esp, 12					; 0000000cH
	pop	esi

; 4037 : }

	pop	ebp
	ret	0
_xmlLoadExternalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlGetExternalEntityLoader
_TEXT	SEGMENT
_xmlGetExternalEntityLoader PROC			; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlCurrentExternalEntityLoader
	ret	0
_xmlGetExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlSetExternalEntityLoader
_TEXT	SEGMENT
_f$ = 8							; size = 4
_xmlSetExternalEntityLoader PROC			; COMDAT

; 3992 : xmlSetExternalEntityLoader(xmlExternalEntityLoader f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _xmlCurrentExternalEntityLoader, eax

; 3993 :     xmlCurrentExternalEntityLoader = f;
; 3994 : }

	pop	ebp
	ret	0
_xmlSetExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOFTPClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlIOFTPClose PROC					; COMDAT

; 2160 : xmlIOFTPClose (void * context) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4

; 2162 : }

	pop	ebp

; 2161 :     return ( xmlNanoFTPClose(context) );

	jmp	_xmlNanoFTPClose
_xmlIOFTPClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOFTPRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlIOFTPRead PROC					; COMDAT

; 2146 : xmlIOFTPRead(void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buffer$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlIOFTPRe

; 2147 :     if ((buffer == NULL) || (len < 0)) return(-1);

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	js	SHORT $LN3@xmlIOFTPRe

; 2148 :     return(xmlNanoFTPRead(context, &buffer[0], len));

	mov	DWORD PTR _len$[ebp], eax
	mov	DWORD PTR _buffer$[ebp], ecx

; 2149 : }

	pop	ebp

; 2148 :     return(xmlNanoFTPRead(context, &buffer[0], len));

	jmp	_xmlNanoFTPRead
$LN3@xmlIOFTPRe:

; 2147 :     if ((buffer == NULL) || (len < 0)) return(-1);

	or	eax, -1

; 2149 : }

	pop	ebp
	ret	0
_xmlIOFTPRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOFTPOpen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlIOFTPOpen PROC					; COMDAT

; 2131 : xmlIOFTPOpen (const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4

; 2133 : }

	pop	ebp

; 2132 :     return(xmlNanoFTPOpen(filename));

	jmp	_xmlNanoFTPOpen
_xmlIOFTPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOFTPMatch
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlIOFTPMatch PROC					; COMDAT

; 2116 : xmlIOFTPMatch (const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	6
	push	OFFSET ??_C@_06FNAPNHDD@ftp?3?1?1@
	push	DWORD PTR _filename$[ebp]
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax

; 2117 :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "ftp://", 6))
; 2118 : 	return(1);
; 2119 :     return(0);
; 2120 : }

	pop	ebp
	ret	0
_xmlIOFTPMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlIOHTTPClose PROC					; COMDAT

; 1930 : xmlIOHTTPClose (void * context) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _context$[ebp]
	call	_xmlNanoHTTPClose
	add	esp, 4
	xor	eax, eax

; 1931 :     xmlNanoHTTPClose(context);
; 1932 :     return 0;
; 1933 : }

	pop	ebp
	ret	0
_xmlIOHTTPClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlIOHTTPRead PROC					; COMDAT

; 1867 : xmlIOHTTPRead(void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _buffer$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlIOHTTPR

; 1868 :     if ((buffer == NULL) || (len < 0)) return(-1);

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	js	SHORT $LN3@xmlIOHTTPR

; 1869 :     return(xmlNanoHTTPRead(context, &buffer[0], len));

	mov	DWORD PTR _len$[ebp], eax
	mov	DWORD PTR _buffer$[ebp], ecx

; 1870 : }

	pop	ebp

; 1869 :     return(xmlNanoHTTPRead(context, &buffer[0], len));

	jmp	_xmlNanoHTTPRead
$LN3@xmlIOHTTPR:

; 1868 :     if ((buffer == NULL) || (len < 0)) return(-1);

	or	eax, -1

; 1870 : }

	pop	ebp
	ret	0
_xmlIOHTTPRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPOpenW
_TEXT	SEGMENT
_msg$1 = -500						; size = 500
_post_uri$ = 8						; size = 4
_compression$ = 12					; size = 4
_xmlIOHTTPOpenW PROC					; COMDAT

; 1789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _post_uri$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlIOHTTPO

; 1790 : 
; 1791 :     xmlIOHTTPWriteCtxtPtr ctxt = NULL;
; 1792 : 
; 1793 :     if (post_uri == NULL)
; 1794 :         return (NULL);

	xor	eax, eax
	pop	esi

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlIOHTTPO:
	push	edi

; 1795 : 
; 1796 :     ctxt = xmlMalloc(sizeof(xmlIOHTTPWriteCtxt));

	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	edi, eax
	add	esp, 4

; 1797 :     if (ctxt == NULL) {

	test	edi, edi
	jne	SHORT $LN3@xmlIOHTTPO

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BN@HPAPFPOH@creating?5HTTP?5output?5context@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1798 : 	xmlIOErrMemory("creating HTTP output context");
; 1799 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlIOHTTPO:
	xorps	xmm0, xmm0

; 1800 :     }
; 1801 : 
; 1802 :     (void) memset(ctxt, 0, sizeof(xmlIOHTTPWriteCtxt));

	movq	QWORD PTR [edi], xmm0

; 1803 : 
; 1804 :     ctxt->uri = (char *) xmlStrdup((const xmlChar *)post_uri);

	push	esi
	mov	DWORD PTR [edi+8], 0
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [edi+4], eax

; 1805 :     if (ctxt->uri == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlIOHTTPO

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0M@MAMOHIEM@copying?5URI@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError

; 1806 : 	xmlIOErrMemory("copying URI");
; 1807 :         xmlFreeHTTPWriteCtxt(ctxt);

	push	edi
	call	_xmlFreeHTTPWriteCtxt
	add	esp, 24					; 00000018H

; 1808 :         return (NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlIOHTTPO:
	push	ebx

; 1809 :     }
; 1810 : 
; 1811 :     /*
; 1812 :      * **  Since the document length is required for an HTTP post,
; 1813 :      * **  need to put the document into a buffer.  A memory buffer
; 1814 :      * **  is being used to avoid pushing the data to disk and back.
; 1815 :      */
; 1816 : 
; 1817 : #ifdef LIBXML_ZLIB_ENABLED
; 1818 :     if ((compression > 0) && (compression <= 9)) {

	mov	ebx, DWORD PTR _compression$[ebp]
	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, 8
	ja	$LN5@xmlIOHTTPO

; 1494 :     buff = xmlMalloc( sizeof( xmlZMemBuff ) );

	push	68					; 00000044H

; 1819 : 
; 1820 :         ctxt->compression = compression;

	mov	DWORD PTR [edi], ebx

; 1494 :     buff = xmlMalloc( sizeof( xmlZMemBuff ) );

	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1495 :     if ( buff == NULL ) {

	test	esi, esi
	jne	SHORT $LN16@xmlIOHTTPO

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@PALIHBDA@creating?5buffer?5context@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1497 : 	return ( NULL );

	jmp	$LN6@xmlIOHTTPO
$LN16@xmlIOHTTPO:

; 1498 :     }
; 1499 : 
; 1500 :     (void)memset( buff, 0, sizeof( xmlZMemBuff ) );

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0

; 1501 :     buff->size = INIT_HTTP_BUFF_SIZE;
; 1502 :     buff->zbuff = xmlMalloc( buff->size );

	push	32768					; 00008000H
	mov	DWORD PTR [esi], 32768			; 00008000H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 1503 :     if ( buff->zbuff == NULL ) {

	test	eax, eax
	jne	SHORT $LN17@xmlIOHTTPO

; 1504 : 	xmlFreeZMemBuff( buff );

	push	esi
	call	_xmlFreeZMemBuff

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	0
	push	0
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 24					; 00000018H

; 1506 : 	return ( NULL );

	xor	esi, esi
	jmp	$LN6@xmlIOHTTPO
$LN17@xmlIOHTTPO:

; 1507 :     }
; 1508 : 
; 1509 :     z_err = deflateInit2( &buff->zctrl, compression, Z_DEFLATED,

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	0
	push	8
	push	-15					; fffffff1H
	push	8
	push	ebx
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	_deflateInit2_@32
	mov	ebx, eax

; 1510 : 			    DFLT_WBITS, DFLT_MEM_LVL, Z_DEFAULT_STRATEGY );
; 1511 :     if ( z_err != Z_OK ) {

	test	ebx, ebx
	je	SHORT $LN18@xmlIOHTTPO

; 1512 : 	xmlChar msg[500];
; 1513 : 	xmlFreeZMemBuff( buff );

	push	esi
	call	_xmlFreeZMemBuff

; 1514 : 	buff = NULL;
; 1515 : 	xmlStrPrintf(msg, 500,

	push	ebx
	push	OFFSET ??_C@_0DF@HJICNPOB@Error?5initializing?5compression?5@
	push	OFFSET ??_C@_0BL@GHKILDDP@xmlCreateZMemBuff?3?5?5?$CFs?5?$CFd?6@
	lea	eax, DWORD PTR _msg$1[ebp]
	push	500					; 000001f4H
	push	eax
	call	_xmlStrPrintf

; 1516 : 		    "xmlCreateZMemBuff:  %s %d\n",
; 1517 : 		    "Error initializing compression context.  ZLIB error:",
; 1518 : 		    z_err );
; 1519 : 	xmlIOErr(XML_IO_WRITE, (const char *) msg);

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	1546					; 0000060aH
	call	_xmlIOErr
	add	esp, 32					; 00000020H

; 1520 : 	return ( NULL );

	xor	esi, esi
	jmp	SHORT $LN6@xmlIOHTTPO
$LN18@xmlIOHTTPO:

; 1521 :     }
; 1522 : 
; 1523 :     /*  Set the header data.  The CRC will be needed for the trailer  */
; 1524 :     buff->crc = crc32( 0L, NULL, 0 );

	push	0
	push	0
	push	0
	call	_crc32@12

; 1525 :     hdr_lgth = snprintf( (char *)buff->zbuff, buff->size,

	push	3
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	8
	push	139					; 0000008bH
	push	31					; 0000001fH
	push	OFFSET ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc@
	push	DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	push	DWORD PTR [esi+8]
	call	_snprintf

; 1526 : 			"%c%c%c%c%c%c%c%c%c%c",
; 1527 : 			GZ_MAGIC1, GZ_MAGIC2, Z_DEFLATED,
; 1528 : 			0, 0, 0, 0, 0, 0, LXML_ZLIB_OS_CODE );
; 1529 :     buff->zctrl.next_out  = buff->zbuff + hdr_lgth;

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 52					; 00000034H
	add	ecx, eax
	mov	DWORD PTR [esi+24], ecx

; 1530 :     buff->zctrl.avail_out = buff->size - hdr_lgth;

	mov	ecx, DWORD PTR [esi]
	sub	ecx, eax
	mov	DWORD PTR [esi+28], ecx

; 1821 :         ctxt->doc_buff = xmlCreateZMemBuff(compression);
; 1822 :     } else

	jmp	SHORT $LN6@xmlIOHTTPO
$LN5@xmlIOHTTPO:

; 1823 : #endif
; 1824 :     {
; 1825 :         /*  Any character conversions should have been done before this  */
; 1826 : 
; 1827 :         ctxt->doc_buff = xmlAllocOutputBufferInternal(NULL);

	push	0
	call	_xmlAllocOutputBufferInternal
	add	esp, 4
	mov	esi, eax
$LN6@xmlIOHTTPO:

; 1828 :     }
; 1829 : 
; 1830 :     if (ctxt->doc_buff == NULL) {

	mov	DWORD PTR [edi+8], esi
	pop	ebx
	test	esi, esi
	jne	SHORT $LN7@xmlIOHTTPO

; 1831 :         xmlFreeHTTPWriteCtxt(ctxt);

	push	edi
	call	_xmlFreeHTTPWriteCtxt
	add	esp, 4

; 1832 :         ctxt = NULL;

	xor	edi, edi
$LN7@xmlIOHTTPO:

; 1833 :     }
; 1834 : 
; 1835 :     return (ctxt);

	mov	eax, edi
	pop	edi
	pop	esi

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIOHTTPOpenW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPOpen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlIOHTTPOpen PROC					; COMDAT

; 1771 : xmlIOHTTPOpen (const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _filename$[ebp]
	call	_xmlNanoHTTPOpen
	add	esp, 8

; 1772 :     return(xmlNanoHTTPOpen(filename, NULL));
; 1773 : }

	pop	ebp
	ret	0
_xmlIOHTTPOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlIOHTTPMatch
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlIOHTTPMatch PROC					; COMDAT

; 1756 : xmlIOHTTPMatch (const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	7
	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	push	DWORD PTR _filename$[ebp]
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax

; 1757 :     if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST "http://", 7))
; 1758 : 	return(1);
; 1759 :     return(0);
; 1760 : }

	pop	ebp
	ret	0
_xmlIOHTTPMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileClose
_TEXT	SEGMENT
_context$ = 8						; size = 4
_xmlFileClose PROC					; COMDAT

; 980  : xmlFileClose (void * context) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _context$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlFileClo

; 981  :     FILE *fil;
; 982  :     int ret;
; 983  : 
; 984  :     if (context == NULL)
; 985  :         return(-1);

	or	eax, -1
	pop	esi

; 999  : }

	pop	ebp
	ret	0
$LN2@xmlFileClo:
	push	edi

; 986  :     fil = (FILE *) context;
; 987  :     if ((fil == stdout) || (fil == stderr)) {

	mov	edi, DWORD PTR __imp____acrt_iob_func
	push	1
	call	edi
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN4@xmlFileClo
	push	2
	call	edi
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN4@xmlFileClo

; 992  :     }
; 993  :     if (fil == stdin)

	push	0
	call	edi
	add	esp, 4
	cmp	esi, eax
	je	SHORT $LN9@xmlFileClo

; 994  : 	return(0);
; 995  :     ret = ( fclose((FILE *) context) == EOF ) ? -1 : 0;

	push	ebx
	push	esi
	call	DWORD PTR __imp__fclose
	xor	ebx, ebx
	add	esp, 4
	cmp	eax, -1
	setne	bl

; 996  :     if (ret < 0)

	jne	SHORT $LN7@xmlFileClo

; 997  :         xmlIOErr(0, "fclose()");

	push	OFFSET ??_C@_08BNMNDKKE@fclose?$CI?$CJ@
	push	0
	call	_xmlIOErr
	add	esp, 8
$LN7@xmlFileClo:

; 998  :     return(ret);

	lea	eax, DWORD PTR [ebx-1]
	pop	ebx
	pop	edi
	pop	esi

; 999  : }

	pop	ebp
	ret	0
$LN4@xmlFileClo:

; 988  :         ret = fflush(fil);

	push	esi
	call	DWORD PTR __imp__fflush
	add	esp, 4

; 989  : 	if (ret < 0)

	test	eax, eax
	jns	SHORT $LN9@xmlFileClo

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_08FAKMNOA@fflush?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN9@xmlFileClo:
	pop	edi

; 990  : 	    xmlIOErr(0, "fflush()");
; 991  : 	return(0);

	xor	eax, eax
	pop	esi

; 999  : }

	pop	ebp
	ret	0
_xmlFileClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileRead
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlFileRead PROC					; COMDAT

; 936  : xmlFileRead (void * context, char * buffer, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _context$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlFileRea

; 937  :     int ret;
; 938  :     if ((context == NULL) || (buffer == NULL))

	mov	eax, DWORD PTR _buffer$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlFileRea

; 940  :     ret = fread(&buffer[0], 1,  len, (FILE *) context);

	push	esi
	push	ecx
	push	DWORD PTR _len$[ebp]
	push	1
	push	eax
	call	DWORD PTR __imp__fread
	mov	esi, eax
	add	esp, 16					; 00000010H

; 941  :     if (ret < 0) xmlIOErr(0, "fread()");

	test	esi, esi
	jns	SHORT $LN6@xmlFileRea

; 426  :     __xmlIOErr(XML_FROM_IO, code, extra);

	push	OFFSET ??_C@_07MNJJGAFL@fread?$CI?$CJ@
	push	0
	push	8
	call	___xmlIOErr
	add	esp, 12					; 0000000cH
$LN6@xmlFileRea:

; 942  :     return(ret);

	mov	eax, esi
	pop	esi

; 943  : }

	pop	ebp
	ret	0
$LN3@xmlFileRea:

; 939  :         return(-1);

	or	eax, -1

; 943  : }

	pop	ebp
	ret	0
_xmlFileRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileOpen
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlFileOpen PROC					; COMDAT

; 858  : xmlFileOpen (const char *filename) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _filename$[ebp]
	push	edi
	call	_xmlFileOpen_real
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN3@xmlFileOpe

; 859  :     char *unescaped;
; 860  :     void *retval;
; 861  : 
; 862  :     retval = xmlFileOpen_real(filename);
; 863  :     if (retval == NULL) {
; 864  : 	unescaped = xmlURIUnescapeString(filename, 0, NULL);

	push	eax
	push	eax
	push	edi
	call	_xmlURIUnescapeString
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 865  : 	if (unescaped != NULL) {

	test	edi, edi
	je	SHORT $LN5@xmlFileOpe

; 866  : 	    retval = xmlFileOpen_real(unescaped);

	push	edi
	call	_xmlFileOpen_real

; 867  : 	    xmlFree(unescaped);

	push	edi
	mov	esi, eax
	call	DWORD PTR _xmlFree
	add	esp, 8
$LN5@xmlFileOpe:

; 868  : 	}
; 869  :     }
; 870  : 
; 871  :     return retval;
; 872  : }

	mov	eax, esi
$LN3@xmlFileOpe:
	pop	edi
	pop	esi
	pop	ebp
	ret	0
_xmlFileOpen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFileMatch
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlFileMatch PROC					; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, 1
	ret	0
_xmlFileMatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlCheckFilename
_TEXT	SEGMENT
_stat_buffer$ = -48					; size = 48
_path$ = 8						; size = 4
_xmlCheckFilename PROC					; COMDAT

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _path$[ebp]
	test	esi, esi
	je	SHORT $LN12@xmlCheckFi

; 671  : #ifdef HAVE_STAT
; 672  : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 673  :     struct _stat stat_buffer;
; 674  : #else
; 675  :     struct stat stat_buffer;
; 676  : #endif
; 677  : #endif
; 678  :     if (path == NULL)
; 679  : 	return(0);
; 680  : 
; 681  : #ifdef HAVE_STAT
; 682  : #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
; 683  :     /*
; 684  :      * On Windows stat and wstat do not work with long pathname,
; 685  :      * which start with '\\?\'
; 686  :      */
; 687  :     if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&

	cmp	BYTE PTR [esi], 92			; 0000005cH
	jne	SHORT $LN3@xmlCheckFi
	cmp	BYTE PTR [esi+1], 92			; 0000005cH
	jne	SHORT $LN3@xmlCheckFi
	cmp	BYTE PTR [esi+2], 63			; 0000003fH
	jne	SHORT $LN3@xmlCheckFi
	cmp	BYTE PTR [esi+3], 92			; 0000005cH
	je	SHORT $LN5@xmlCheckFi
$LN3@xmlCheckFi:
	push	ebx
	push	edi

; 641  :     wPath = __xmlIOWin32UTF8ToWChar(path);

	push	esi
	call	___xmlIOWin32UTF8ToWChar
	mov	ebx, eax
	add	esp, 4

; 642  :     if (wPath) {

	test	ebx, ebx
	je	SHORT $LN11@xmlCheckFi

; 643  :        retval = _wstat(wPath, info);

	lea	eax, DWORD PTR _stat_buffer$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR __imp___wstat64i32

; 644  :        xmlFree(wPath);

	push	ebx
	mov	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 12					; 0000000cH

; 645  :     }
; 646  :     /* maybe path in native encoding */
; 647  :     if(retval < 0)

	test	edi, edi
	jns	SHORT $LN9@xmlCheckFi
$LN11@xmlCheckFi:

; 648  :        retval = _stat(path, info);

	lea	eax, DWORD PTR _stat_buffer$[ebp]
	push	eax
	push	esi
	call	DWORD PTR __imp___stat64i32
	add	esp, 8
	mov	edi, eax
$LN9@xmlCheckFi:

; 688  : 	(path[3] == '\\') )
; 689  : 	    return 1;
; 690  : 
; 691  :     if (xmlWrapStatUtf8(path, &stat_buffer) == -1)

	cmp	edi, -1
	pop	edi
	pop	ebx
	je	SHORT $LN12@xmlCheckFi

; 693  : #else
; 694  :     if (stat(path, &stat_buffer) == -1)
; 695  :         return 0;
; 696  : #endif
; 697  : #ifdef S_ISDIR
; 698  :     if (S_ISDIR(stat_buffer.st_mode))

	mov	eax, DWORD PTR _stat_buffer$[ebp+6]
	and	eax, 61440				; 0000f000H
	cmp	eax, 16384				; 00004000H
	jne	SHORT $LN5@xmlCheckFi

; 699  :         return 2;

	mov	eax, 2
	pop	esi

; 703  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCheckFi:

; 700  : #endif
; 701  : #endif /* HAVE_STAT */
; 702  :     return 1;

	mov	eax, 1
	pop	esi

; 703  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlCheckFi:

; 692  :         return 0;

	xor	eax, eax
	pop	esi

; 703  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlNormalizeWindowsPath
_TEXT	SEGMENT
_path$ = 8						; size = 4
_xmlNormalizeWindowsPath PROC				; COMDAT

; 483  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4

; 485  : }

	pop	ebp

; 484  :     return xmlCanonicPath(path);

	jmp	_xmlCanonicPath
_xmlNormalizeWindowsPath ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlNoNetExternalEntityLoader
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlNoNetExternalEntityLoader PROC			; COMDAT

; 4058 :                              xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _URL$[ebp]
	push	ebx
	push	DWORD PTR _ID$[ebp]
	push	edi
	call	_xmlResolveResourceFromCatalog
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LN134@xmlNoNetEx

; 4059 :     xmlParserInputPtr input = NULL;
; 4060 :     xmlChar *resource = NULL;
; 4061 : 
; 4062 : #ifdef LIBXML_CATALOG_ENABLED
; 4063 :     resource = xmlResolveResourceFromCatalog(URL, ID, ctxt);
; 4064 : #endif
; 4065 : 
; 4066 :     if (resource == NULL)
; 4067 : 	resource = (xmlChar *) URL;
; 4068 : 
; 4069 :     if (resource != NULL) {

	mov	esi, edi
	test	edi, edi
	je	SHORT $LN4@xmlNoNetEx
$LN134@xmlNoNetEx:

; 4070 :         if ((!xmlStrncasecmp(BAD_CAST resource, BAD_CAST "ftp://", 6)) ||

	push	6
	push	OFFSET ??_C@_06FNAPNHDD@ftp?3?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@xmlNoNetEx
	push	7
	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@xmlNoNetEx
$LN4@xmlNoNetEx:

; 4075 : 	    return(NULL);
; 4076 : 	}
; 4077 :     }
; 4078 :     input = xmlDefaultExternalEntityLoader((const char *) resource, ID, ctxt);

	push	ebx
	push	DWORD PTR _ID$[ebp]
	push	esi
	call	_xmlDefaultExternalEntityLoader
	add	esp, 12					; 0000000cH
	mov	ebx, eax

; 4079 :     if (resource != (xmlChar *) URL)

	cmp	esi, edi
	je	SHORT $LN7@xmlNoNetEx

; 4080 : 	xmlFree(resource);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN7@xmlNoNetEx:

; 4081 :     return(input);
; 4082 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlNoNetEx:

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	push	esi
	push	DWORD PTR _IOerr+172
	push	0
	push	1543					; 00000607H
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 4071 :             (!xmlStrncasecmp(BAD_CAST resource, BAD_CAST "http://", 7))) {
; 4072 :             xmlIOErr(XML_IO_NETWORK_ATTEMPT, (const char *) resource);
; 4073 : 	    if (resource != (xmlChar *) URL)

	cmp	esi, edi
	je	SHORT $LN6@xmlNoNetEx

; 4074 : 		xmlFree(resource);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN6@xmlNoNetEx:

; 4081 :     return(input);
; 4082 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlNoNetExternalEntityLoader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlCheckHTTPInput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ret$ = 12						; size = 4
_xmlCheckHTTPInput PROC					; COMDAT

; 3771 : xmlCheckHTTPInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr ret) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ret$[ebp]
	test	esi, esi
	je	$LN19@xmlCheckHT

; 3772 : #ifdef LIBXML_HTTP_ENABLED
; 3773 :     if ((ret != NULL) && (ret->buf != NULL) &&
; 3774 :         (ret->buf->readcallback == xmlIOHTTPRead) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	$LN19@xmlCheckHT
	cmp	DWORD PTR [eax+4], OFFSET _xmlIOHTTPRead
	jne	$LN19@xmlCheckHT
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$LN19@xmlCheckHT

; 3775 :         (ret->buf->context != NULL)) {
; 3776 :         const char *encoding;
; 3777 :         const char *redir;
; 3778 :         const char *mime;
; 3779 :         int code;
; 3780 : 
; 3781 :         code = xmlNanoHTTPReturnCode(ret->buf->context);

	push	eax
	call	_xmlNanoHTTPReturnCode
	add	esp, 4

; 3782 :         if (code >= 400) {

	cmp	eax, 400				; 00000190H
	jl	SHORT $LN3@xmlCheckHT

; 3783 :             /* fatal error */
; 3784 : 	    if (ret->filename != NULL)

	mov	ecx, DWORD PTR [esi+4]

; 3785 : 		__xmlLoaderErr(ctxt, "failed to load HTTP resource \"%s\"\n",
; 3786 :                          (const char *) ret->filename);
; 3787 : 	    else
; 3788 : 		__xmlLoaderErr(ctxt, "failed to load HTTP resource\n", NULL);
; 3789 :             xmlFreeInputStream(ret);

	mov	edx, OFFSET ??_C@_0CD@MCCOMMMF@failed?5to?5load?5HTTP?5resource?5?$CC?$CF@
	test	ecx, ecx
	mov	eax, OFFSET ??_C@_0BO@FMFGBFHH@failed?5to?5load?5HTTP?5resource?6@
	push	ecx
	cmovne	eax, edx
	push	eax
	push	DWORD PTR _ctxt$[ebp]
	call	___xmlLoaderErr
	push	esi
	call	_xmlFreeInputStream
	add	esp, 16					; 00000010H

; 3824 :                     (char *) xmlStrdup((const xmlChar *) redir);
; 3825 :             }
; 3826 :         }
; 3827 :     }
; 3828 : #endif
; 3829 :     return(ret);

	xor	eax, eax
	pop	esi

; 3830 : }

	pop	ebp
	ret	0
$LN3@xmlCheckHT:

; 3790 :             ret = NULL;
; 3791 :         } else {
; 3792 : 
; 3793 :             mime = xmlNanoHTTPMimeType(ret->buf->context);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	DWORD PTR [eax]
	call	_xmlNanoHTTPMimeType
	mov	edi, eax

; 3794 :             if ((xmlStrstr(BAD_CAST mime, BAD_CAST "/xml")) ||

	push	OFFSET ??_C@_04FNIAEEJM@?1xml@
	push	edi
	call	_xmlStrstr
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@xmlCheckHT
	push	OFFSET ??_C@_04KIAAOCFM@?$CLxml@
	push	edi
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlCheckHT
$LN8@xmlCheckHT:

; 3795 :                 (xmlStrstr(BAD_CAST mime, BAD_CAST "+xml"))) {
; 3796 :                 encoding = xmlNanoHTTPEncoding(ret->buf->context);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax]
	call	_xmlNanoHTTPEncoding
	mov	edi, eax
	add	esp, 4

; 3797 :                 if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN12@xmlCheckHT

; 3798 :                     xmlCharEncodingHandlerPtr handler;
; 3799 : 
; 3800 :                     handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 3801 :                     if (handler != NULL) {

	test	eax, eax
	je	SHORT $LN10@xmlCheckHT

; 3802 :                         xmlSwitchInputEncoding(ctxt, ret, handler);

	push	eax
	push	esi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSwitchInputEncoding
	add	esp, 12					; 0000000cH

; 3803 :                     } else {

	jmp	SHORT $LN11@xmlCheckHT
$LN10@xmlCheckHT:

; 3804 :                         __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,

	push	0
	push	edi
	push	OFFSET ??_C@_0BE@MFOALNCF@Unknown?5encoding?5?$CFs@
	push	31					; 0000001fH
	push	DWORD PTR _ctxt$[ebp]
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H
$LN11@xmlCheckHT:

; 3805 :                                          "Unknown encoding %s",
; 3806 :                                          BAD_CAST encoding, NULL);
; 3807 :                     }
; 3808 :                     if (ret->encoding == NULL)

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN12@xmlCheckHT

; 3809 :                         ret->encoding = xmlStrdup(BAD_CAST encoding);

	push	edi
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+44], eax
$LN12@xmlCheckHT:

; 3810 :                 }
; 3811 : #if 0
; 3812 :             } else if (xmlStrstr(BAD_CAST mime, BAD_CAST "html")) {
; 3813 : #endif
; 3814 :             }
; 3815 :             redir = xmlNanoHTTPRedir(ret->buf->context);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax]
	call	_xmlNanoHTTPRedir
	mov	edi, eax
	add	esp, 4

; 3816 :             if (redir != NULL) {

	test	edi, edi
	je	SHORT $LN17@xmlCheckHT

; 3817 :                 if (ret->filename != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN14@xmlCheckHT

; 3818 :                     xmlFree((xmlChar *) ret->filename);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlCheckHT:

; 3819 :                 if (ret->directory != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN15@xmlCheckHT

; 3820 :                     xmlFree((xmlChar *) ret->directory);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 3821 :                     ret->directory = NULL;

	mov	DWORD PTR [esi+8], 0
$LN15@xmlCheckHT:

; 3822 :                 }
; 3823 :                 ret->filename =

	push	edi
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
$LN17@xmlCheckHT:

; 3824 :                     (char *) xmlStrdup((const xmlChar *) redir);
; 3825 :             }
; 3826 :         }
; 3827 :     }
; 3828 : #endif
; 3829 :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 3830 : }

	pop	ebp
	ret	0
$LN19@xmlCheckHT:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
_xmlCheckHTTPInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlRegisterHTTPPostCallbacks
_TEXT	SEGMENT
_xmlRegisterHTTPPostCallbacks PROC			; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlOutputCallbackInitialized, 0
	jne	SHORT $LN2@xmlRegiste

; 2302 : 
; 2303 :     /*  Register defaults if not done previously  */
; 2304 : 
; 2305 :     if ( xmlOutputCallbackInitialized == 0 )
; 2306 : 	xmlRegisterDefaultOutputCallbacks( );

	call	_xmlRegisterDefaultOutputCallbacks
$LN2@xmlRegiste:

; 2208 :     if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {

	mov	ecx, DWORD PTR _xmlOutputCallbackNr
	cmp	ecx, 15					; 0000000fH
	jge	SHORT $LN4@xmlRegiste

; 2209 : 	return(-1);
; 2210 :     }
; 2211 :     xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;

	mov	eax, ecx

; 2212 :     xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
; 2213 :     xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
; 2214 :     xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
; 2215 :     xmlOutputCallbackInitialized = 1;

	mov	DWORD PTR _xmlOutputCallbackInitialized, 1
	shl	eax, 4

; 2216 :     return(xmlOutputCallbackNr++);

	inc	ecx
	mov	DWORD PTR _xmlOutputCallbackNr, ecx
	mov	DWORD PTR _xmlOutputCallbackTable[eax], OFFSET _xmlIOHTTPMatch
	mov	DWORD PTR _xmlOutputCallbackTable[eax+4], OFFSET _xmlIOHTTPDfltOpenW
	mov	DWORD PTR _xmlOutputCallbackTable[eax+8], OFFSET _xmlIOHTTPWrite
	mov	DWORD PTR _xmlOutputCallbackTable[eax+12], OFFSET _xmlIOHTTPClosePost
$LN4@xmlRegiste:

; 2307 : 
; 2308 :     xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
; 2309 : 	                       xmlIOHTTPWrite, xmlIOHTTPClosePost);
; 2310 :     return;
; 2311 : }

	ret	0
_xmlRegisterHTTPPostCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT ___xmlOutputBufferCreateFilename
_TEXT	SEGMENT
_is_file_uri$1$ = -8					; size = 4
_unescaped$1$ = -4					; size = 4
_URI$ = 8						; size = 4
_encoder$ = 12						; size = 4
_compression$ = 16					; size = 4
___xmlOutputBufferCreateFilename PROC			; COMDAT

; 2625 :                               int compression ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	mov	DWORD PTR _is_file_uri$1$[ebp], 1
	mov	DWORD PTR _unescaped$1$[ebp], esi
	cmp	DWORD PTR _xmlOutputCallbackInitialized, esi
	jne	SHORT $LN8@xmlOutputB

; 2626 :     xmlOutputBufferPtr ret;
; 2627 :     xmlURIPtr puri;
; 2628 :     int i = 0;
; 2629 :     void *context = NULL;
; 2630 :     char *unescaped = NULL;
; 2631 : #ifdef LIBXML_ZLIB_ENABLED
; 2632 :     int is_file_uri = 1;
; 2633 : #endif
; 2634 : 
; 2635 :     if (xmlOutputCallbackInitialized == 0)
; 2636 : 	xmlRegisterDefaultOutputCallbacks();

	call	_xmlRegisterDefaultOutputCallbacks
$LN8@xmlOutputB:

; 2637 : 
; 2638 :     if (URI == NULL) return(NULL);

	mov	ebx, DWORD PTR _URI$[ebp]
	test	ebx, ebx
	je	$LN44@xmlOutputB

; 2639 : 
; 2640 :     puri = xmlParseURI(URI);

	push	ebx
	call	_xmlParseURI
	mov	edi, eax
	add	esp, 4

; 2641 :     if (puri != NULL) {

	test	edi, edi
	je	$LN43@xmlOutputB

; 2642 : #ifdef LIBXML_ZLIB_ENABLED
; 2643 :         if ((puri->scheme != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@xmlOutputB
	push	OFFSET ??_C@_04DAMGJPCA@file@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	neg	eax
	sbb	eax, eax
	and	eax, 1
	mov	DWORD PTR _is_file_uri$1$[ebp], eax

; 2644 : 	    (!xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST "file")))
; 2645 : 	    is_file_uri = 0;
; 2646 : #endif
; 2647 : 	/*
; 2648 : 	 * try to limit the damages of the URI unescaping code.
; 2649 : 	 */
; 2650 : 	if ((puri->scheme == NULL) ||

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@xmlOutputB
	push	OFFSET ??_C@_04DAMGJPCA@file@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlOutputB
$LN13@xmlOutputB:

; 2651 : 	    (xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST "file")))
; 2652 : 	    unescaped = xmlURIUnescapeString(URI, 0, NULL);

	push	0
	push	0
	push	ebx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _unescaped$1$[ebp], eax
$LN12@xmlOutputB:

; 2653 : 	xmlFreeURI(puri);

	push	edi
	call	_xmlFreeURI

; 2654 :     }
; 2655 : 
; 2656 :     /*
; 2657 :      * Try to find one of the output accept method accepting that scheme
; 2658 :      * Go in reverse to give precedence to user defined handlers.
; 2659 :      * try with an unescaped version of the URI
; 2660 :      */
; 2661 :     if (unescaped != NULL) {

	mov	ecx, DWORD PTR _unescaped$1$[ebp]
	add	esp, 4
	test	ecx, ecx
	je	$LN43@xmlOutputB

; 2662 : #ifdef LIBXML_ZLIB_ENABLED
; 2663 : 	if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {

	mov	edx, DWORD PTR _compression$[ebp]
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 8
	ja	SHORT $LN16@xmlOutputB
	cmp	DWORD PTR _is_file_uri$1$[ebp], 1
	jne	SHORT $LN16@xmlOutputB

; 2664 : 	    context = xmlGzfileOpenW(unescaped, compression);

	push	edx
	push	ecx
	call	_xmlGzfileOpenW
	mov	esi, eax
	add	esp, 8

; 2665 : 	    if (context != NULL) {

	test	esi, esi
	je	SHORT $LN47@xmlOutputB

; 2666 : 		ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	mov	edi, eax
	add	esp, 4

; 2667 : 		if (ret != NULL) {

	test	edi, edi
	je	SHORT $LN17@xmlOutputB

; 2668 : 		    ret->context = context;

	mov	DWORD PTR [edi], esi

; 2669 : 		    ret->writecallback = xmlGzfileWrite;

	mov	DWORD PTR [edi+4], OFFSET _xmlGzfileWrite

; 2670 : 		    ret->closecallback = xmlGzfileClose;

	mov	DWORD PTR [edi+8], OFFSET _xmlGzfileClose
$LN17@xmlOutputB:

; 2671 : 		}
; 2672 : 		xmlFree(unescaped);

	push	DWORD PTR _unescaped$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2673 : 		return(ret);

	mov	eax, edi
	pop	edi

; 2741 :     }
; 2742 :     return(ret);
; 2743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlOutputB:

; 2665 : 	    if (context != NULL) {

	mov	ecx, DWORD PTR _unescaped$1$[ebp]
$LN16@xmlOutputB:

; 2674 : 	    }
; 2675 : 	}
; 2676 : #endif
; 2677 : 	for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {

	mov	edi, DWORD PTR _xmlOutputCallbackNr
	sub	edi, 1
	js	SHORT $LN35@xmlOutputB
	mov	ebx, edi
	shl	ebx, 4
	add	ebx, OFFSET _xmlOutputCallbackTable
	jmp	SHORT $LN4@xmlOutputB
$LL46@xmlOutputB:
	mov	ecx, DWORD PTR _unescaped$1$[ebp]
$LN4@xmlOutputB:

; 2678 : 	    if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@xmlOutputB
	push	ecx
	call	eax
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@xmlOutputB

; 2679 : 		(xmlOutputCallbackTable[i].matchcallback(unescaped) != 0)) {
; 2680 : #if defined(LIBXML_HTTP_ENABLED) && defined(LIBXML_ZLIB_ENABLED)
; 2681 : 		/*  Need to pass compression parameter into HTTP open calls  */
; 2682 : 		if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)

	cmp	DWORD PTR [ebx], OFFSET _xmlIOHTTPMatch
	jne	SHORT $LN19@xmlOutputB

; 2683 : 		    context = xmlIOHTTPOpenW(unescaped, compression);

	push	DWORD PTR _compression$[ebp]
	push	DWORD PTR _unescaped$1$[ebp]
	call	_xmlIOHTTPOpenW
	add	esp, 8
	jmp	SHORT $LN48@xmlOutputB
$LN19@xmlOutputB:

; 2684 : 		else
; 2685 : #endif
; 2686 : 		    context = xmlOutputCallbackTable[i].opencallback(unescaped);

	push	DWORD PTR _unescaped$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	call	eax
	add	esp, 4
$LN48@xmlOutputB:

; 2687 : 		if (context != NULL)

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN45@xmlOutputB
$LN2@xmlOutputB:

; 2674 : 	    }
; 2675 : 	}
; 2676 : #endif
; 2677 : 	for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {

	sub	ebx, 16					; 00000010H
	sub	edi, 1
	jns	SHORT $LL46@xmlOutputB
$LN45@xmlOutputB:
	mov	ebx, DWORD PTR _URI$[ebp]
$LN35@xmlOutputB:

; 2688 : 		    break;
; 2689 : 	    }
; 2690 : 	}
; 2691 : 	xmlFree(unescaped);

	push	DWORD PTR _unescaped$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2692 :     }
; 2693 : 
; 2694 :     /*
; 2695 :      * If this failed try with a non-escaped URI this may be a strange
; 2696 :      * filename
; 2697 :      */
; 2698 :     if (context == NULL) {

	test	esi, esi
	jne	$LN30@xmlOutputB
$LN43@xmlOutputB:

; 2699 : #ifdef LIBXML_ZLIB_ENABLED
; 2700 : 	if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {

	mov	ecx, DWORD PTR _compression$[ebp]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 8
	ja	SHORT $LN24@xmlOutputB
	cmp	DWORD PTR _is_file_uri$1$[ebp], 1
	jne	SHORT $LN24@xmlOutputB

; 2701 : 	    context = xmlGzfileOpenW(URI, compression);

	push	ecx
	push	ebx
	call	_xmlGzfileOpenW
	mov	esi, eax
	add	esp, 8

; 2702 : 	    if (context != NULL) {

	test	esi, esi
	je	SHORT $LN24@xmlOutputB

; 2703 : 		ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	add	esp, 4

; 2704 : 		if (ret != NULL) {

	test	eax, eax
	je	$LN1@xmlOutputB

; 2705 : 		    ret->context = context;

	pop	edi
	mov	DWORD PTR [eax], esi

; 2741 :     }
; 2742 :     return(ret);
; 2743 : }

	pop	esi
	mov	DWORD PTR [eax+4], OFFSET _xmlGzfileWrite
	mov	DWORD PTR [eax+8], OFFSET _xmlGzfileClose
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlOutputB:

; 2706 : 		    ret->writecallback = xmlGzfileWrite;
; 2707 : 		    ret->closecallback = xmlGzfileClose;
; 2708 : 		}
; 2709 : 		return(ret);
; 2710 : 	    }
; 2711 : 	}
; 2712 : #endif
; 2713 : 	for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {

	mov	edi, DWORD PTR _xmlOutputCallbackNr
	sub	edi, 1
	js	SHORT $LN36@xmlOutputB
	mov	ebx, edi
	shl	ebx, 4
	add	ebx, OFFSET _xmlOutputCallbackTable
$LL7@xmlOutputB:

; 2714 : 	    if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN5@xmlOutputB
	push	DWORD PTR _URI$[ebp]
	call	eax
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@xmlOutputB

; 2715 : 		(xmlOutputCallbackTable[i].matchcallback(URI) != 0)) {
; 2716 : #if defined(LIBXML_HTTP_ENABLED) && defined(LIBXML_ZLIB_ENABLED)
; 2717 : 		/*  Need to pass compression parameter into HTTP open calls  */
; 2718 : 		if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)

	cmp	DWORD PTR [ebx], OFFSET _xmlIOHTTPMatch
	jne	SHORT $LN27@xmlOutputB

; 2719 : 		    context = xmlIOHTTPOpenW(URI, compression);

	push	DWORD PTR _compression$[ebp]
	push	DWORD PTR _URI$[ebp]
	call	_xmlIOHTTPOpenW
	add	esp, 8
	jmp	SHORT $LN49@xmlOutputB
$LN27@xmlOutputB:

; 2720 : 		else
; 2721 : #endif
; 2722 : 		    context = xmlOutputCallbackTable[i].opencallback(URI);

	push	DWORD PTR _URI$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	call	eax
	add	esp, 4
$LN49@xmlOutputB:

; 2723 : 		if (context != NULL)

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN30@xmlOutputB
$LN5@xmlOutputB:

; 2706 : 		    ret->writecallback = xmlGzfileWrite;
; 2707 : 		    ret->closecallback = xmlGzfileClose;
; 2708 : 		}
; 2709 : 		return(ret);
; 2710 : 	    }
; 2711 : 	}
; 2712 : #endif
; 2713 : 	for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {

	sub	ebx, 16					; 00000010H
	sub	edi, 1
	jns	SHORT $LL7@xmlOutputB
$LN36@xmlOutputB:

; 2724 : 		    break;
; 2725 : 	    }
; 2726 : 	}
; 2727 :     }
; 2728 : 
; 2729 :     if (context == NULL) {

	test	esi, esi
	je	SHORT $LN44@xmlOutputB
$LN30@xmlOutputB:

; 2731 :     }
; 2732 : 
; 2733 :     /*
; 2734 :      * Allocate the Output buffer front-end.
; 2735 :      */
; 2736 :     ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	mov	edx, eax
	add	esp, 4

; 2737 :     if (ret != NULL) {

	test	edx, edx
	je	SHORT $LN31@xmlOutputB

; 2738 : 	ret->context = context;
; 2739 : 	ret->writecallback = xmlOutputCallbackTable[i].writecallback;

	shl	edi, 4
	mov	DWORD PTR [edx], esi
	mov	ecx, DWORD PTR _xmlOutputCallbackTable[edi+8]
	mov	DWORD PTR [edx+4], ecx

; 2740 : 	ret->closecallback = xmlOutputCallbackTable[i].closecallback;

	mov	eax, DWORD PTR _xmlOutputCallbackTable[edi+12]
	mov	DWORD PTR [edx+8], eax
$LN31@xmlOutputB:

; 2741 :     }
; 2742 :     return(ret);
; 2743 : }

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlOutputB:

; 2730 : 	return(NULL);

	xor	eax, eax
$LN1@xmlOutputB:
	pop	edi

; 2741 :     }
; 2742 :     return(ret);
; 2743 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___xmlOutputBufferCreateFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlRegisterOutputCallbacks
_TEXT	SEGMENT
_matchFunc$ = 8						; size = 4
_openFunc$ = 12						; size = 4
_writeFunc$ = 16					; size = 4
_closeFunc$ = 20					; size = 4
_xmlRegisterOutputCallbacks PROC			; COMDAT

; 2207 : 	xmlOutputCloseCallback closeFunc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _xmlOutputCallbackNr
	cmp	esi, 15					; 0000000fH
	jl	SHORT $LN2@xmlRegiste

; 2208 :     if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
; 2209 : 	return(-1);

	or	eax, -1
	pop	esi

; 2217 : }

	pop	ebp
	ret	0
$LN2@xmlRegiste:

; 2210 :     }
; 2211 :     xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;

	mov	eax, DWORD PTR _matchFunc$[ebp]
	mov	edx, esi

; 2212 :     xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;

	mov	ecx, DWORD PTR _openFunc$[ebp]
	shl	edx, 4

; 2213 :     xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
; 2214 :     xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
; 2215 :     xmlOutputCallbackInitialized = 1;

	mov	DWORD PTR _xmlOutputCallbackInitialized, 1
	mov	DWORD PTR _xmlOutputCallbackTable[edx], eax

; 2216 :     return(xmlOutputCallbackNr++);

	mov	eax, esi
	mov	DWORD PTR _xmlOutputCallbackTable[edx+4], ecx
	mov	ecx, DWORD PTR _writeFunc$[ebp]
	mov	DWORD PTR _xmlOutputCallbackTable[edx+8], ecx
	mov	ecx, DWORD PTR _closeFunc$[ebp]
	mov	DWORD PTR _xmlOutputCallbackTable[edx+12], ecx
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR _xmlOutputCallbackNr, ecx
	pop	esi

; 2217 : }

	pop	ebp
	ret	0
_xmlRegisterOutputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferClose
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlOutputBufferClose PROC				; COMDAT

; 2498 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LN2@xmlOutputB

; 2499 :     int written;
; 2500 :     int err_rc = 0;
; 2501 : 
; 2502 :     if (out == NULL)
; 2503 :         return (-1);

	pop	edi
	or	eax, -1

; 2526 : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlOutputB:

; 2504 :     if (out->writecallback != NULL)

	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN3@xmlOutputB

; 2505 :         xmlOutputBufferFlush(out);

	push	esi
	call	_xmlOutputBufferFlush
	add	esp, 4
$LN3@xmlOutputB:

; 2506 :     if (out->closecallback != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@xmlOutputB

; 2507 :         err_rc = out->closecallback(out->context);

	push	DWORD PTR [esi]
	call	eax
	add	esp, 4
	mov	edi, eax
$LN4@xmlOutputB:

; 2508 :     }
; 2509 :     written = out->written;
; 2510 :     if (out->conv) {

	mov	eax, DWORD PTR [esi+20]
	push	ebx
	mov	ebx, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN5@xmlOutputB

; 2511 :         xmlBufFree(out->conv);

	push	eax
	call	_xmlBufFree
	add	esp, 4

; 2512 :         out->conv = NULL;

	mov	DWORD PTR [esi+20], 0
$LN5@xmlOutputB:

; 2513 :     }
; 2514 :     if (out->encoder != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@xmlOutputB

; 2515 :         xmlCharEncCloseFunc(out->encoder);

	push	eax
	call	_xmlCharEncCloseFunc
	add	esp, 4
$LN6@xmlOutputB:

; 2516 :     }
; 2517 :     if (out->buffer != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN7@xmlOutputB

; 2518 :         xmlBufFree(out->buffer);

	push	eax
	call	_xmlBufFree
	add	esp, 4

; 2519 :         out->buffer = NULL;

	mov	DWORD PTR [esi+16], 0
$LN7@xmlOutputB:

; 2520 :     }
; 2521 : 
; 2522 :     if (out->error)

	or	eax, -1
	cmp	DWORD PTR [esi+28], 0

; 2523 :         err_rc = -1;
; 2524 :     xmlFree(out);

	push	esi
	cmovne	edi, eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2525 :     return ((err_rc == 0) ? written : err_rc);

	test	edi, edi
	cmove	edi, ebx
	mov	eax, edi
	pop	ebx
	pop	edi

; 2526 : }

	pop	esi
	pop	ebp
	ret	0
_xmlOutputBufferClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferFlush
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlOutputBufferFlush PROC				; COMDAT

; 3649 : xmlOutputBufferFlush(xmlOutputBufferPtr out) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN6@xmlOutputB

; 3650 :     int nbchars = 0, ret = 0;
; 3651 : 
; 3652 :     if ((out == NULL) || (out->error)) return(-1);

	cmp	DWORD PTR [esi+28], edi
	jne	$LN6@xmlOutputB

; 3653 :     /*
; 3654 :      * first handle encoding stuff.
; 3655 :      */
; 3656 :     if ((out->conv != NULL) && (out->encoder != NULL)) {

	cmp	DWORD PTR [esi+20], edi
	je	SHORT $LN3@xmlOutputB
	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN3@xmlOutputB
	npad	1
$LL4@xmlOutputB:

; 3657 : 	/*
; 3658 : 	 * convert as much as possible to the parser output buffer.
; 3659 : 	 */
; 3660 : 	do {
; 3661 : 	    nbchars = xmlCharEncOutput(out, 0);

	push	0
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8

; 3662 : 	    if (nbchars < 0) {

	test	eax, eax
	js	SHORT $LN128@xmlOutputB

; 3665 : 		return(-1);
; 3666 : 	    }
; 3667 : 	} while (nbchars);

	jne	SHORT $LL4@xmlOutputB
$LN3@xmlOutputB:

; 3668 :     }
; 3669 : 
; 3670 :     /*
; 3671 :      * second flush the stuff to the I/O channel
; 3672 :      */
; 3673 :     if ((out->conv != NULL) && (out->encoder != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN9@xmlOutputB
	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN9@xmlOutputB
	cmp	DWORD PTR [esi+4], edi
	je	$LN14@xmlOutputB

; 3674 : 	(out->writecallback != NULL)) {
; 3675 : 	ret = out->writecallback(out->context,

	push	eax
	call	_xmlBufUse
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3676 :                                  (const char *)xmlBufContent(out->conv),
; 3677 :                                  xmlBufUse(out->conv));
; 3678 : 	if (ret >= 0)

	test	edi, edi
	js	SHORT $LN131@xmlOutputB

; 3679 : 	    xmlBufShrink(out->conv, ret);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, edi

; 3686 :     }
; 3687 :     if (ret < 0) {

	push	ecx
	push	eax
	call	_xmlBufShrink
	add	esp, 8

; 3693 : 
; 3694 : #ifdef DEBUG_INPUT
; 3695 :     xmlGenericError(xmlGenericErrorContext,
; 3696 : 	    "I/O: flushed %d chars\n", ret);
; 3697 : #endif
; 3698 :     return(ret);

	mov	eax, edi
	add	DWORD PTR [esi+24], edi
	pop	edi

; 3699 : }

	pop	esi
	pop	ebp
	ret	0
$LN128@xmlOutputB:

; 3663 : 		xmlIOErr(XML_IO_ENCODER, NULL);

	push	0
	push	1544					; 00000608H
	call	_xmlIOErr
	add	esp, 8

; 3664 : 		out->error = XML_IO_ENCODER;

	mov	DWORD PTR [esi+28], 1544		; 00000608H
$LN6@xmlOutputB:

; 3699 : }

	pop	edi
	or	eax, -1
	pop	esi
	pop	ebp
	ret	0
$LN9@xmlOutputB:

; 3680 :     } else if (out->writecallback != NULL) {

	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN14@xmlOutputB

; 3681 : 	ret = out->writecallback(out->context,

	push	DWORD PTR [esi+16]
	call	_xmlBufUse
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	ecx, edi

; 3682 :                                  (const char *)xmlBufContent(out->buffer),
; 3683 :                                  xmlBufUse(out->buffer));
; 3684 : 	if (ret >= 0)

	test	edi, edi
	js	SHORT $LN131@xmlOutputB

; 3685 : 	    xmlBufShrink(out->buffer, ret);

	mov	eax, DWORD PTR [esi+16]

; 3686 :     }
; 3687 :     if (ret < 0) {

	push	ecx
	push	eax
	call	_xmlBufShrink
	add	esp, 8
$LN14@xmlOutputB:

; 3691 :     }
; 3692 :     out->written += ret;

	add	DWORD PTR [esi+24], edi

; 3693 : 
; 3694 : #ifdef DEBUG_INPUT
; 3695 :     xmlGenericError(xmlGenericErrorContext,
; 3696 : 	    "I/O: flushed %d chars\n", ret);
; 3697 : #endif
; 3698 :     return(ret);

	mov	eax, edi
	pop	edi

; 3699 : }

	pop	esi
	pop	ebp
	ret	0
$LN131@xmlOutputB:

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	push	0
	push	DWORD PTR _IOerr+180
	push	0
	push	1545					; 00000609H
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3688 : 	xmlIOErr(XML_IO_FLUSH, NULL);
; 3689 : 	out->error = XML_IO_FLUSH;

	mov	DWORD PTR [esi+28], 1545		; 00000609H

; 3690 : 	return(ret);

	mov	eax, edi
	pop	edi

; 3699 : }

	pop	esi
	pop	ebp
	ret	0
_xmlOutputBufferFlush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferWriteEscape
_TEXT	SEGMENT
_oldwritten$1$ = -20					; size = 4
tv362 = -16						; size = 4
_written$1$ = -12					; size = 4
_cons$ = -8						; size = 4
_chunk$ = -4						; size = 4
tv351 = 8						; size = 4
_out$ = 8						; size = 4
_str$ = 12						; size = 4
_escaping$ = 16						; size = 4
_xmlOutputBufferWriteEscape PROC			; COMDAT

; 3498 :                            xmlCharEncodingOutputFunc escaping) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _written$1$[ebp], ebx
	test	esi, esi
	je	$LN6@xmlOutputB

; 3499 :     int nbchars = 0; /* number of chars to output to I/O */
; 3500 :     int ret;         /* return from function call */
; 3501 :     int written = 0; /* number of char written to I/O so far */
; 3502 :     int oldwritten=0;/* loop guard */
; 3503 :     int chunk;       /* number of byte currently processed from str */
; 3504 :     int len;         /* number of bytes in str */
; 3505 :     int cons;        /* byte from str consumed */
; 3506 : 
; 3507 :     if ((out == NULL) || (out->error) || (str == NULL) ||
; 3508 :         (out->buffer == NULL) ||

	cmp	DWORD PTR [esi+28], ebx
	jne	$LN6@xmlOutputB
	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	$LN6@xmlOutputB
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN6@xmlOutputB
	push	eax
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	cmp	eax, 2
	je	$LN6@xmlOutputB

; 3509 : 	(xmlBufGetAllocationScheme(out->buffer) == XML_BUFFER_ALLOC_IMMUTABLE))
; 3510 :         return(-1);
; 3511 :     len = strlen((const char *)str);

	lea	ecx, DWORD PTR [edi+1]
$LL44@xmlOutputB:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL44@xmlOutputB
	sub	edi, ecx

; 3512 :     if (len < 0) return(0);

	jns	SHORT $LN7@xmlOutputB

; 3604 : 
; 3605 : done:
; 3606 : #ifdef DEBUG_INPUT
; 3607 :     xmlGenericError(xmlGenericErrorContext,
; 3608 : 	    "I/O: wrote %d chars\n", written);
; 3609 : #endif
; 3610 :     return(written);
; 3611 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlOutputB:

; 3513 :     if (out->error) return(-1);

	cmp	DWORD PTR [esi+28], ebx
	jne	$LN6@xmlOutputB
	mov	eax, DWORD PTR _escaping$[ebp]
	mov	ecx, OFFSET _xmlEscapeContent
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR tv351[ebp], ecx
$LL4@xmlOutputB:

; 3514 :     if (escaping == NULL) escaping = xmlEscapeContent;
; 3515 : 
; 3516 :     do {
; 3517 :         oldwritten = written;
; 3518 : 
; 3519 :         /*
; 3520 : 	 * how many bytes to consume and how many bytes to store.
; 3521 : 	 */
; 3522 : 	cons = len;
; 3523 : 	chunk = xmlBufAvail(out->buffer) - 1;

	push	DWORD PTR [esi+16]
	mov	DWORD PTR _oldwritten$1$[ebp], ebx
	mov	DWORD PTR _cons$[ebp], edi
	call	_xmlBufAvail
	dec	eax
	add	esp, 4
	mov	DWORD PTR _chunk$[ebp], eax
	cmp	eax, 40					; 00000028H

; 3524 : 
; 3525 :         /*
; 3526 : 	 * make sure we have enough room to save first, if this is
; 3527 : 	 * not the case force a flush, but make sure we stay in the loop
; 3528 : 	 */
; 3529 : 	if (chunk < 40) {

	jge	SHORT $LN10@xmlOutputB

; 3530 : 	    if (xmlBufGrow(out->buffer, 100) < 0)

	push	100					; 00000064H
	push	DWORD PTR [esi+16]
	call	_xmlBufGrow
	add	esp, 8
	test	eax, eax
	js	$LN6@xmlOutputB

; 3531 : 	        return(-1);
; 3532 :             oldwritten = -1;

	or	eax, -1

; 3533 : 	    continue;

	jmp	$LN2@xmlOutputB
$LN10@xmlOutputB:

; 3534 : 	}
; 3535 : 
; 3536 : 	/*
; 3537 : 	 * first handle encoding stuff.
; 3538 : 	 */
; 3539 : 	if (out->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN12@xmlOutputB

; 3540 : 	    /*
; 3541 : 	     * Store the data in the incoming raw buffer
; 3542 : 	     */
; 3543 : 	    if (out->conv == NULL) {

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN14@xmlOutputB

; 3544 : 		out->conv = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+20], eax
$LN14@xmlOutputB:

; 3545 : 	    }
; 3546 : 	    ret = escaping(xmlBufEnd(out->buffer) ,

	lea	eax, DWORD PTR _cons$[ebp]
	push	eax
	push	DWORD PTR _str$[ebp]
	lea	eax, DWORD PTR _chunk$[ebp]
	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	call	DWORD PTR tv351[ebp]
	add	esp, 16					; 00000010H

; 3547 : 	                   &chunk, str, &cons);
; 3548 : 	    if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */

	test	eax, eax
	js	$LN6@xmlOutputB
	mov	eax, DWORD PTR _chunk$[ebp]
	test	eax, eax
	je	$LN6@xmlOutputB

; 3549 : 	        return(-1);
; 3550 :             xmlBufAddLen(out->buffer, chunk);

	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufAddLen

; 3551 : 
; 3552 : 	    if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))

	push	DWORD PTR [esi+16]
	call	_xmlBufUse
	add	esp, 12					; 0000000cH
	cmp	eax, 4000				; 00000fa0H
	jae	SHORT $LN17@xmlOutputB
	cmp	DWORD PTR _cons$[ebp], edi
	je	$done$46
$LN17@xmlOutputB:

; 3553 : 		goto done;
; 3554 : 
; 3555 : 	    /*
; 3556 : 	     * convert as much as possible to the output buffer.
; 3557 : 	     */
; 3558 : 	    ret = xmlCharEncOutput(out, 0);

	push	0
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8

; 3559 : 	    if ((ret < 0) && (ret != -3)) {

	test	eax, eax
	jns	SHORT $LN18@xmlOutputB
	cmp	eax, -3					; fffffffdH
	jne	$LN36@xmlOutputB
$LN18@xmlOutputB:

; 3562 : 		return(-1);
; 3563 : 	    }
; 3564 : 	    nbchars = xmlBufUse(out->conv);

	mov	eax, DWORD PTR [esi+20]

; 3565 : 	} else {

	jmp	SHORT $LN13@xmlOutputB
$LN12@xmlOutputB:

; 3566 : 	    ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);

	lea	eax, DWORD PTR _cons$[ebp]
	push	eax
	push	DWORD PTR _str$[ebp]
	lea	eax, DWORD PTR _chunk$[ebp]
	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	call	DWORD PTR tv351[ebp]
	add	esp, 16					; 00000010H

; 3567 : 	    if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */

	test	eax, eax
	js	$LN6@xmlOutputB
	mov	eax, DWORD PTR _chunk$[ebp]
	test	eax, eax
	je	$LN6@xmlOutputB

; 3568 : 	        return(-1);
; 3569 :             xmlBufAddLen(out->buffer, chunk);

	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufAddLen

; 3570 : 	    nbchars = xmlBufUse(out->buffer);

	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
$LN13@xmlOutputB:

; 3571 : 	}
; 3572 : 	str += cons;

	push	eax
	call	_xmlBufUse
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR _cons$[ebp]

; 3573 : 	len -= cons;

	sub	edi, eax
	add	DWORD PTR _str$[ebp], eax
	mov	DWORD PTR tv362[ebp], ecx

; 3574 : 
; 3575 : 	if ((nbchars < MINLEN) && (len <= 0))

	cmp	ecx, 4000				; 00000fa0H
	jge	SHORT $LN21@xmlOutputB
	test	edi, edi
	jle	$done$46
$LN21@xmlOutputB:

; 3576 : 	    goto done;
; 3577 : 
; 3578 : 	if (out->writecallback) {

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN22@xmlOutputB

; 3579 : 	    /*
; 3580 : 	     * second write the stuff to the I/O channel
; 3581 : 	     */
; 3582 : 	    if (out->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	push	ecx
	je	SHORT $LN24@xmlOutputB

; 3583 : 		ret = out->writecallback(out->context,

	push	DWORD PTR [esi+20]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 3584 :                            (const char *)xmlBufContent(out->conv), nbchars);
; 3585 : 		if (ret >= 0)

	test	ebx, ebx
	js	$LN39@xmlOutputB

; 3586 : 		    xmlBufShrink(out->conv, ret);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, ebx

; 3587 : 	    } else {

	jmp	SHORT $LN27@xmlOutputB
$LN24@xmlOutputB:

; 3588 : 		ret = out->writecallback(out->context,

	push	DWORD PTR [esi+16]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	ecx, ebx

; 3589 :                            (const char *)xmlBufContent(out->buffer), nbchars);
; 3590 : 		if (ret >= 0)

	test	ebx, ebx
	js	SHORT $LN39@xmlOutputB

; 3591 : 		    xmlBufShrink(out->buffer, ret);

	mov	eax, DWORD PTR [esi+16]
$LN27@xmlOutputB:

; 3596 : 		return(ret);
; 3597 : 	    }
; 3598 : 	    out->written += ret;

	push	ecx
	push	eax
	call	_xmlBufShrink
	add	esp, 8
	add	DWORD PTR [esi+24], ebx
	mov	ebx, DWORD PTR _written$1$[ebp]
	jmp	SHORT $LN29@xmlOutputB
$LN22@xmlOutputB:

; 3599 : 	} else if (xmlBufAvail(out->buffer) < MINLEN) {

	push	DWORD PTR [esi+16]
	call	_xmlBufAvail
	add	esp, 4
	cmp	eax, 4000				; 00000fa0H
	jae	SHORT $LN29@xmlOutputB

; 3600 : 	    xmlBufGrow(out->buffer, MINLEN);

	push	4000					; 00000fa0H
	push	DWORD PTR [esi+16]
	call	_xmlBufGrow
	add	esp, 8
$LN29@xmlOutputB:

; 3601 : 	}
; 3602 : 	written += nbchars;

	add	ebx, DWORD PTR tv362[ebp]
	mov	eax, DWORD PTR _oldwritten$1$[ebp]
	mov	DWORD PTR _written$1$[ebp], ebx
$LN2@xmlOutputB:

; 3603 :     } while ((len > 0) && (oldwritten != written));

	test	edi, edi
	jle	SHORT $done$46
	cmp	eax, ebx
	jne	$LL4@xmlOutputB

; 3604 : 
; 3605 : done:
; 3606 : #ifdef DEBUG_INPUT
; 3607 :     xmlGenericError(xmlGenericErrorContext,
; 3608 : 	    "I/O: wrote %d chars\n", written);
; 3609 : #endif
; 3610 :     return(written);
; 3611 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@xmlOutputB:

; 3560 : 		xmlIOErr(XML_IO_ENCODER, NULL);

	push	0
	push	1544					; 00000608H
	call	_xmlIOErr
	add	esp, 8

; 3561 : 		out->error = XML_IO_ENCODER;

	mov	DWORD PTR [esi+28], 1544		; 00000608H
$LN6@xmlOutputB:

; 3604 : 
; 3605 : done:
; 3606 : #ifdef DEBUG_INPUT
; 3607 :     xmlGenericError(xmlGenericErrorContext,
; 3608 : 	    "I/O: wrote %d chars\n", written);
; 3609 : #endif
; 3610 :     return(written);
; 3611 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlOutputB:

; 3592 : 	    }
; 3593 : 	    if (ret < 0) {
; 3594 : 		xmlIOErr(XML_IO_WRITE, NULL);

	push	0
	push	1546					; 0000060aH
	call	_xmlIOErr
	add	esp, 8

; 3595 : 		out->error = XML_IO_WRITE;

	mov	DWORD PTR [esi+28], 1546		; 0000060aH
$done$46:

; 3604 : 
; 3605 : done:
; 3606 : #ifdef DEBUG_INPUT
; 3607 :     xmlGenericError(xmlGenericErrorContext,
; 3608 : 	    "I/O: wrote %d chars\n", written);
; 3609 : #endif
; 3610 :     return(written);
; 3611 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlOutputBufferWriteEscape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferWriteString
_TEXT	SEGMENT
_out$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlOutputBufferWriteString PROC			; COMDAT

; 3627 : xmlOutputBufferWriteString(xmlOutputBufferPtr out, const char *str) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _out$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlOutputB

; 3628 :     int len;
; 3629 : 
; 3630 :     if ((out == NULL) || (out->error)) return(-1);

	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN3@xmlOutputB

; 3631 :     if (str == NULL)

	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlOutputB

; 3632 :         return(-1);
; 3633 :     len = strlen(str);

	mov	ecx, esi
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL7@xmlOutputB:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL7@xmlOutputB
	sub	ecx, edi
	pop	edi

; 3634 : 
; 3635 :     if (len > 0)

	test	ecx, ecx
	jle	SHORT $LN5@xmlOutputB

; 3636 : 	return(xmlOutputBufferWrite(out, len, str));

	push	esi
	push	ecx
	push	edx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	esi

; 3638 : }

	pop	ebp
	ret	0
$LN5@xmlOutputB:

; 3637 :     return(len);

	mov	eax, ecx
	pop	esi

; 3638 : }

	pop	ebp
	ret	0
$LN3@xmlOutputB:

; 3628 :     int len;
; 3629 : 
; 3630 :     if ((out == NULL) || (out->error)) return(-1);

	or	eax, -1
	pop	esi

; 3638 : }

	pop	ebp
	ret	0
_xmlOutputBufferWriteString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferWrite
_TEXT	SEGMENT
_written$1$ = -4					; size = 4
tv315 = 8						; size = 4
_out$ = 8						; size = 4
_len$ = 12						; size = 4
_buf$ = 16						; size = 4
_xmlOutputBufferWrite PROC				; COMDAT

; 3334 : xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _written$1$[ebp], 0
	test	esi, esi
	je	$LN6@xmlOutputB

; 3335 :     int nbchars = 0; /* number of chars to output to I/O */
; 3336 :     int ret;         /* return from function call */
; 3337 :     int written = 0; /* number of char written to I/O so far */
; 3338 :     int chunk;       /* number of byte curreent processed from buf */
; 3339 : 
; 3340 :     if ((out == NULL) || (out->error)) return(-1);

	cmp	DWORD PTR [esi+28], 0
	jne	$LN6@xmlOutputB

; 3341 :     if (len < 0) return(0);

	mov	eax, DWORD PTR _len$[ebp]
	test	eax, eax
	jns	SHORT $LN7@xmlOutputB

; 3419 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlOutputB:

; 3342 :     if (out->error) return(-1);
; 3343 : 
; 3344 :     do {
; 3345 : 	chunk = len;
; 3346 : 	if (chunk > 4 * MINLEN)

	mov	ecx, 16000				; 00003e80H
	mov	edi, eax
	cmp	eax, ecx
	cmovg	edi, ecx

; 3347 : 	    chunk = 4 * MINLEN;
; 3348 : 
; 3349 : 	/*
; 3350 : 	 * first handle encoding stuff.
; 3351 : 	 */
; 3352 : 	if (out->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN10@xmlOutputB

; 3353 : 	    /*
; 3354 : 	     * Store the data in the incoming raw buffer
; 3355 : 	     */
; 3356 : 	    if (out->conv == NULL) {

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN12@xmlOutputB

; 3357 : 		out->conv = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+20], eax
$LN12@xmlOutputB:

; 3358 : 	    }
; 3359 : 	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);

	push	edi
	push	DWORD PTR _buf$[ebp]
	lea	ebx, DWORD PTR [esi+16]
	push	DWORD PTR [ebx]
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 3360 : 	    if (ret != 0)

	test	eax, eax
	jne	$LN6@xmlOutputB

; 3361 : 	        return(-1);
; 3362 : 
; 3363 : 	    if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))

	push	DWORD PTR [ebx]
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 4000				; 00000fa0H
	jae	SHORT $LN14@xmlOutputB
	cmp	edi, DWORD PTR _len$[ebp]
	je	$LN39@xmlOutputB
$LN14@xmlOutputB:

; 3364 : 		goto done;
; 3365 : 
; 3366 : 	    /*
; 3367 : 	     * convert as much as possible to the parser reading buffer.
; 3368 : 	     */
; 3369 : 	    ret = xmlCharEncOutput(out, 0);

	push	0
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8

; 3370 : 	    if ((ret < 0) && (ret != -3)) {

	test	eax, eax
	jns	SHORT $LN15@xmlOutputB
	cmp	eax, -3					; fffffffdH
	jne	$LN28@xmlOutputB
$LN15@xmlOutputB:

; 3373 : 		return(-1);
; 3374 : 	    }
; 3375 : 	    nbchars = xmlBufUse(out->conv);

	mov	eax, DWORD PTR [esi+20]

; 3376 : 	} else {

	jmp	SHORT $LN11@xmlOutputB
$LN10@xmlOutputB:

; 3377 : 	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);

	push	edi
	push	DWORD PTR _buf$[ebp]
	lea	ebx, DWORD PTR [esi+16]
	push	DWORD PTR [ebx]
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 3378 : 	    if (ret != 0)

	test	eax, eax
	jne	$LN6@xmlOutputB

; 3379 : 	        return(-1);
; 3380 : 	    nbchars = xmlBufUse(out->buffer);

	mov	eax, DWORD PTR [ebx]
$LN11@xmlOutputB:

; 3381 : 	}
; 3382 : 	buf += chunk;

	push	eax
	call	_xmlBufUse
	add	DWORD PTR _buf$[ebp], edi
	mov	ecx, eax

; 3383 : 	len -= chunk;

	mov	eax, DWORD PTR _len$[ebp]
	add	esp, 4
	sub	eax, edi
	mov	DWORD PTR tv315[ebp], ecx
	mov	DWORD PTR _len$[ebp], eax

; 3384 : 
; 3385 : 	if ((nbchars < MINLEN) && (len <= 0))

	cmp	ecx, 4000				; 00000fa0H
	jge	SHORT $LN17@xmlOutputB
	test	eax, eax
	jle	$LN39@xmlOutputB
$LN17@xmlOutputB:

; 3386 : 	    goto done;
; 3387 : 
; 3388 : 	if (out->writecallback) {

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN18@xmlOutputB

; 3389 : 	    /*
; 3390 : 	     * second write the stuff to the I/O channel
; 3391 : 	     */
; 3392 : 	    if (out->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	push	ecx
	je	SHORT $LN19@xmlOutputB

; 3393 : 		ret = out->writecallback(out->context,

	push	DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [esi+20]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3394 :                            (const char *)xmlBufContent(out->conv), nbchars);
; 3395 : 		if (ret >= 0)

	test	edi, edi
	js	SHORT $LN31@xmlOutputB

; 3396 : 		    xmlBufShrink(out->conv, ret);
; 3397 : 	    } else {

	jmp	SHORT $LN22@xmlOutputB
$LN19@xmlOutputB:

; 3398 : 		ret = out->writecallback(out->context,

	push	DWORD PTR [ebx]
	call	_xmlBufContent
	add	esp, 4
	push	eax
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3399 :                            (const char *)xmlBufContent(out->buffer), nbchars);
; 3400 : 		if (ret >= 0)

	test	edi, edi
	js	SHORT $LN31@xmlOutputB
$LN22@xmlOutputB:

; 3407 : 	    }
; 3408 : 	    out->written += ret;

	push	eax
	mov	eax, DWORD PTR [ebx]
	push	eax
	call	_xmlBufShrink
	mov	eax, DWORD PTR _len$[ebp]
	add	esp, 8
	add	DWORD PTR [esi+24], edi
	mov	ecx, DWORD PTR tv315[ebp]
$LN18@xmlOutputB:

; 3409 : 	}
; 3410 : 	written += nbchars;

	mov	edx, DWORD PTR _written$1$[ebp]
	add	edx, ecx
	mov	DWORD PTR _written$1$[ebp], edx

; 3411 :     } while (len > 0);

	test	eax, eax
	jle	SHORT $done$41
	jmp	$LN7@xmlOutputB
$LN28@xmlOutputB:

; 3371 : 		xmlIOErr(XML_IO_ENCODER, NULL);

	push	0
	push	1544					; 00000608H
	call	_xmlIOErr
	add	esp, 8

; 3372 : 		out->error = XML_IO_ENCODER;

	mov	DWORD PTR [esi+28], 1544		; 00000608H
$LN6@xmlOutputB:

; 3419 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlOutputB:

; 3401 : 		    xmlBufShrink(out->buffer, ret);
; 3402 : 	    }
; 3403 : 	    if (ret < 0) {
; 3404 : 		xmlIOErr(XML_IO_WRITE, NULL);

	push	0
	push	1546					; 0000060aH
	call	_xmlIOErr
	add	esp, 8

; 3405 : 		out->error = XML_IO_WRITE;

	mov	DWORD PTR [esi+28], 1546		; 0000060aH

; 3406 : 		return(ret);

	mov	eax, edi
	pop	edi

; 3419 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@xmlOutputB:

; 3412 : 
; 3413 : done:
; 3414 : #ifdef DEBUG_INPUT
; 3415 :     xmlGenericError(xmlGenericErrorContext,
; 3416 : 	    "I/O: wrote %d chars\n", written);
; 3417 : #endif
; 3418 :     return(written);

	mov	edx, DWORD PTR _written$1$[ebp]
$done$41:
	pop	edi

; 3419 : }

	pop	esi
	mov	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlOutputBufferWrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferGetSize
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlOutputBufferGetSize PROC				; COMDAT

; 2877 : xmlOutputBufferGetSize(xmlOutputBufferPtr out) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _out$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlOutputB

; 2878 :     if ((out == NULL) || (out->buffer == NULL))

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@xmlOutputB

; 2880 : 
; 2881 :     return(xmlBufUse(out->buffer));

	mov	DWORD PTR _out$[ebp], eax

; 2882 : }

	pop	ebp

; 2880 : 
; 2881 :     return(xmlBufUse(out->buffer));

	jmp	_xmlBufUse
$LN3@xmlOutputB:

; 2879 :         return(0);

	xor	eax, eax

; 2882 : }

	pop	ebp
	ret	0
_xmlOutputBufferGetSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferGetContent
_TEXT	SEGMENT
_out$ = 8						; size = 4
_xmlOutputBufferGetContent PROC				; COMDAT

; 2861 : xmlOutputBufferGetContent(xmlOutputBufferPtr out) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _out$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlOutputB

; 2862 :     if ((out == NULL) || (out->buffer == NULL))

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@xmlOutputB

; 2864 : 
; 2865 :     return(xmlBufContent(out->buffer));

	mov	DWORD PTR _out$[ebp], eax

; 2866 : }

	pop	ebp

; 2864 : 
; 2865 :     return(xmlBufContent(out->buffer));

	jmp	_xmlBufContent
$LN3@xmlOutputB:

; 2863 :         return(NULL);

	xor	eax, eax

; 2866 : }

	pop	ebp
	ret	0
_xmlOutputBufferGetContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateIO
_TEXT	SEGMENT
_iowrite$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_encoder$ = 20						; size = 4
_xmlOutputBufferCreateIO PROC				; COMDAT

; 3065 : 	 xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _iowrite$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlOutputB

; 3066 :     xmlOutputBufferPtr ret;
; 3067 : 
; 3068 :     if (iowrite == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 3075 :     }
; 3076 : 
; 3077 :     return(ret);
; 3078 : }

	pop	ebp
	ret	0
$LN2@xmlOutputB:

; 3069 : 
; 3070 :     ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	add	esp, 4

; 3071 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlOutputB

; 3072 :         ret->context = (void *) ioctx;

	mov	ecx, DWORD PTR _ioctx$[ebp]
	mov	DWORD PTR [eax], ecx

; 3073 : 	ret->writecallback = iowrite;
; 3074 : 	ret->closecallback = ioclose;

	mov	ecx, DWORD PTR _ioclose$[ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx
$LN1@xmlOutputB:
	pop	esi

; 3075 :     }
; 3076 : 
; 3077 :     return(ret);
; 3078 : }

	pop	ebp
	ret	0
_xmlOutputBufferCreateIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateFd
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_encoder$ = 12						; size = 4
_xmlOutputBufferCreateFd PROC				; COMDAT

; 3004 : xmlOutputBufferCreateFd(int fd, xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fd$[ebp]
	test	esi, esi
	jns	SHORT $LN2@xmlOutputB

; 3005 :     xmlOutputBufferPtr ret;
; 3006 : 
; 3007 :     if (fd < 0) return(NULL);

	xor	eax, eax
	pop	esi

; 3014 :     }
; 3015 : 
; 3016 :     return(ret);
; 3017 : }

	pop	ebp
	ret	0
$LN2@xmlOutputB:

; 3008 : 
; 3009 :     ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	add	esp, 4

; 3010 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlOutputB

; 3011 :         ret->context = (void *) (ptrdiff_t) fd;

	mov	DWORD PTR [eax], esi

; 3012 : 	ret->writecallback = xmlFdWrite;

	mov	DWORD PTR [eax+4], OFFSET _xmlFdWrite

; 3013 : 	ret->closecallback = NULL;

	mov	DWORD PTR [eax+8], 0
$LN1@xmlOutputB:
	pop	esi

; 3014 :     }
; 3015 : 
; 3016 :     return(ret);
; 3017 : }

	pop	ebp
	ret	0
_xmlOutputBufferCreateFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateBuffer
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_encoder$ = 12						; size = 4
_xmlOutputBufferCreateBuffer PROC			; COMDAT

; 2841 :                             xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buffer$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlOutputB

; 2842 :     xmlOutputBufferPtr ret;
; 2843 : 
; 2844 :     if (buffer == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 2845 : 
; 2846 :     ret = xmlOutputBufferCreateIO(xmlBufferWrite, NULL, (void *) buffer,
; 2847 :                                   encoder);
; 2848 : 
; 2849 :     return(ret);
; 2850 : }

	pop	ebp
	ret	0
$LN2@xmlOutputB:

; 3070 :     ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	add	esp, 4

; 3071 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlOutputB

; 3072 :         ret->context = (void *) ioctx;

	mov	DWORD PTR [eax], esi

; 3073 : 	ret->writecallback = iowrite;

	mov	DWORD PTR [eax+4], OFFSET _xmlBufferWrite

; 3074 : 	ret->closecallback = ioclose;

	mov	DWORD PTR [eax+8], 0
$LN1@xmlOutputB:
	pop	esi

; 2845 : 
; 2846 :     ret = xmlOutputBufferCreateIO(xmlBufferWrite, NULL, (void *) buffer,
; 2847 :                                   encoder);
; 2848 : 
; 2849 :     return(ret);
; 2850 : }

	pop	ebp
	ret	0
_xmlOutputBufferCreateBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateFile
_TEXT	SEGMENT
_file$ = 8						; size = 4
_encoder$ = 12						; size = 4
_xmlOutputBufferCreateFile PROC				; COMDAT

; 2812 : xmlOutputBufferCreateFile(FILE *file, xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlOutputCallbackInitialized, 0
	jne	SHORT $LN2@xmlOutputB

; 2813 :     xmlOutputBufferPtr ret;
; 2814 : 
; 2815 :     if (xmlOutputCallbackInitialized == 0)
; 2816 : 	xmlRegisterDefaultOutputCallbacks();

	call	_xmlRegisterDefaultOutputCallbacks
$LN2@xmlOutputB:
	push	esi

; 2817 : 
; 2818 :     if (file == NULL) return(NULL);

	mov	esi, DWORD PTR _file$[ebp]
	test	esi, esi
	jne	SHORT $LN3@xmlOutputB
	xor	eax, eax
	pop	esi

; 2825 :     }
; 2826 : 
; 2827 :     return(ret);
; 2828 : }

	pop	ebp
	ret	0
$LN3@xmlOutputB:

; 2819 : 
; 2820 :     ret = xmlAllocOutputBufferInternal(encoder);

	push	DWORD PTR _encoder$[ebp]
	call	_xmlAllocOutputBufferInternal
	add	esp, 4

; 2821 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlOutputB

; 2822 :         ret->context = file;

	mov	DWORD PTR [eax], esi

; 2823 : 	ret->writecallback = xmlFileWrite;

	mov	DWORD PTR [eax+4], OFFSET _xmlFileWrite

; 2824 : 	ret->closecallback = xmlFileFlush;

	mov	DWORD PTR [eax+8], OFFSET _xmlFileFlush
$LN1@xmlOutputB:
	pop	esi

; 2825 :     }
; 2826 : 
; 2827 :     return(ret);
; 2828 : }

	pop	ebp
	ret	0
_xmlOutputBufferCreateFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlOutputBufferCreateFilename
_TEXT	SEGMENT
_URI$ = 8						; size = 4
_encoder$ = 12						; size = 4
_compression$ = 16					; size = 4
_xmlOutputBufferCreateFilename PROC			; COMDAT

; 2763 :                               int compression ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlOutputBufferCreateFilenameValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@xmlOutputB

; 2764 :     if ((xmlOutputBufferCreateFilenameValue)) {
; 2765 : 		return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);

	call	___xmlOutputBufferCreateFilenameValue
	mov	eax, DWORD PTR [eax]

; 2768 : }

	pop	ebp

; 2764 :     if ((xmlOutputBufferCreateFilenameValue)) {
; 2765 : 		return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);

	jmp	eax
$LN2@xmlOutputB:

; 2768 : }

	pop	ebp

; 2766 : 	}
; 2767 : 	return __xmlOutputBufferCreateFilename(URI, encoder, compression);

	jmp	___xmlOutputBufferCreateFilename
_xmlOutputBufferCreateFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlAllocOutputBuffer
_TEXT	SEGMENT
_encoder$ = 8						; size = 4
_xmlAllocOutputBuffer PROC				; COMDAT

; 2363 : xmlAllocOutputBuffer(xmlCharEncodingHandlerPtr encoder) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlAllocOu

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BH@JBBBCCHB@creating?5output?5buffer@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2402 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN2@xmlAllocOu:
	xorps	xmm0, xmm0

; 2364 :     xmlOutputBufferPtr ret;
; 2365 : 
; 2366 :     ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
; 2367 :     if (ret == NULL) {
; 2368 : 	xmlIOErrMemory("creating output buffer");
; 2369 : 	return(NULL);
; 2370 :     }
; 2371 :     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0

; 2372 :     ret->buffer = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+16], eax

; 2373 :     if (ret->buffer == NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlAllocOu

; 2374 :         xmlFree(ret);
; 2375 : 	return(NULL);
; 2376 :     }
; 2377 : 
; 2378 :     /* try to avoid a performance problem with Windows realloc() */
; 2379 :     if (xmlBufGetAllocationScheme(ret->buffer) == XML_BUFFER_ALLOC_EXACT)

	push	eax
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN4@xmlAllocOu

; 2380 :         xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);

	push	0
	push	DWORD PTR [esi+16]
	call	_xmlBufSetAllocationScheme
	add	esp, 8
$LN4@xmlAllocOu:

; 2381 : 
; 2382 :     ret->encoder = encoder;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [esi+12], eax

; 2383 :     if (encoder != NULL) {

	test	eax, eax
	je	SHORT $LN5@xmlAllocOu

; 2384 :         ret->conv = xmlBufCreateSize(4000);

	push	4000					; 00000fa0H
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 2385 : 	if (ret->conv == NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlAllocOu

; 2387 : 	    return(NULL);
; 2388 : 	}
; 2389 : 
; 2390 : 	/*
; 2391 : 	 * This call is designed to initiate the encoder state
; 2392 : 	 */
; 2393 : 	xmlCharEncOutput(ret, 1);

	push	1
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8

; 2394 :     } else

	jmp	SHORT $LN6@xmlAllocOu
$LN5@xmlAllocOu:

; 2395 :         ret->conv = NULL;

	mov	DWORD PTR [esi+20], 0
$LN6@xmlAllocOu:

; 2396 :     ret->writecallback = NULL;

	mov	DWORD PTR [esi+4], 0

; 2397 :     ret->closecallback = NULL;
; 2398 :     ret->context = NULL;
; 2399 :     ret->written = 0;
; 2400 : 
; 2401 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], 0
	pop	esi

; 2402 : }

	pop	ebp
	ret	0
$LN11@xmlAllocOu:

; 2386 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2402 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
_xmlAllocOutputBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlRegisterDefaultOutputCallbacks
_TEXT	SEGMENT
_xmlRegisterDefaultOutputCallbacks PROC			; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlOutputCallbackInitialized, 0
	jne	SHORT $LN1@xmlRegiste

; 2261 :     if (xmlOutputCallbackInitialized)
; 2262 : 	return;
; 2263 : 
; 2264 :     xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,

	push	OFFSET _xmlFileClose
	push	OFFSET _xmlFileWrite
	push	OFFSET _xmlFileOpenW
	push	OFFSET _xmlFileMatch
	call	_xmlRegisterOutputCallbacks

; 2265 : 	                      xmlFileWrite, xmlFileClose);
; 2266 : 
; 2267 : #ifdef LIBXML_HTTP_ENABLED
; 2268 :     xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,

	push	OFFSET _xmlIOHTTPClosePut
	push	OFFSET _xmlIOHTTPWrite
	push	OFFSET _xmlIOHTTPDfltOpenW
	push	OFFSET _xmlIOHTTPMatch
	call	_xmlRegisterOutputCallbacks
	add	esp, 32					; 00000020H

; 2269 : 	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
; 2270 : #endif
; 2271 : 
; 2272 : /*********************************
; 2273 :  No way a-priori to distinguish between gzipped files from
; 2274 :  uncompressed ones except opening if existing then closing
; 2275 :  and saving with same compression ratio ... a pain.
; 2276 : 
; 2277 : #ifdef LIBXML_ZLIB_ENABLED
; 2278 :     xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
; 2279 : 	                       xmlGzfileWrite, xmlGzfileClose);
; 2280 : #endif
; 2281 : 
; 2282 :  Nor FTP PUT ....
; 2283 : #ifdef LIBXML_FTP_ENABLED
; 2284 :     xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
; 2285 : 	                       xmlIOFTPWrite, xmlIOFTPClose);
; 2286 : #endif
; 2287 :  **********************************/
; 2288 :     xmlOutputCallbackInitialized = 1;

	mov	DWORD PTR _xmlOutputCallbackInitialized, 1
$LN1@xmlRegiste:

; 2289 : }

	ret	0
_xmlRegisterDefaultOutputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlCleanupOutputCallbacks
_TEXT	SEGMENT
_xmlCleanupOutputCallbacks PROC				; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlOutputCallbackInitialized, 0
	je	SHORT $LN1@xmlCleanup

; 548  :     int i;
; 549  : 
; 550  :     if (!xmlOutputCallbackInitialized)
; 551  :         return;
; 552  : 
; 553  :     for (i = xmlOutputCallbackNr - 1; i >= 0; i--) {

	mov	ecx, DWORD PTR _xmlOutputCallbackNr
	sub	ecx, 1
	js	SHORT $LN3@xmlCleanup
	mov	eax, ecx
	shl	eax, 4
	add	eax, OFFSET _xmlOutputCallbackTable+4
	npad	8
$LL4@xmlCleanup:
	sub	ecx, 1

; 554  :         xmlOutputCallbackTable[i].matchcallback = NULL;

	mov	DWORD PTR [eax-4], 0

; 555  :         xmlOutputCallbackTable[i].opencallback = NULL;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax-16]

; 556  :         xmlOutputCallbackTable[i].writecallback = NULL;

	mov	DWORD PTR [eax+20], 0

; 557  :         xmlOutputCallbackTable[i].closecallback = NULL;

	mov	DWORD PTR [eax+24], 0
	jns	SHORT $LL4@xmlCleanup
$LN3@xmlCleanup:

; 558  :     }
; 559  : 
; 560  :     xmlOutputCallbackNr = 0;

	mov	DWORD PTR _xmlOutputCallbackNr, 0

; 561  :     xmlOutputCallbackInitialized = 0;

	mov	DWORD PTR _xmlOutputCallbackInitialized, 0
$LN1@xmlCleanup:

; 562  : }

	ret	0
_xmlCleanupOutputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT ___xmlParserInputBufferCreateFilename
_TEXT	SEGMENT
_context$1$ = -4					; size = 4
_ret$1$ = 8						; size = 4
_URI$ = 8						; size = 4
_enc$ = 12						; size = 4
___xmlParserInputBufferCreateFilename PROC		; COMDAT

; 2530 : __xmlParserInputBufferCreateFilename(const char *URI, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	ecx, ecx
	mov	DWORD PTR _context$1$[ebp], ecx
	cmp	DWORD PTR _xmlInputCallbackInitialized, ecx
	jne	SHORT $LN5@xmlParserI

; 2531 :     xmlParserInputBufferPtr ret;
; 2532 :     int i = 0;
; 2533 :     void *context = NULL;
; 2534 : 
; 2535 :     if (xmlInputCallbackInitialized == 0)
; 2536 : 	xmlRegisterDefaultInputCallbacks();

	call	_xmlRegisterDefaultInputCallbacks
	xor	ecx, ecx
$LN5@xmlParserI:

; 2537 : 
; 2538 :     if (URI == NULL) return(NULL);

	push	ebx
	push	esi
	mov	esi, DWORD PTR _URI$[ebp]
	push	edi
	test	esi, esi
	je	$LN22@xmlParserI

; 2539 : 
; 2540 :     /*
; 2541 :      * Try to find one of the input accept method accepting that scheme
; 2542 :      * Go in reverse to give precedence to user defined handlers.
; 2543 :      */
; 2544 :     if (context == NULL) {
; 2545 : 	for (i = xmlInputCallbackNr - 1;i >= 0;i--) {

	mov	ebx, DWORD PTR _xmlInputCallbackNr
	sub	ebx, 1
	js	$LN22@xmlParserI
	mov	edi, ebx
	shl	edi, 4
	add	edi, OFFSET _xmlInputCallbackTable+4
	npad	6
$LL4@xmlParserI:

; 2546 : 	    if ((xmlInputCallbackTable[i].matchcallback != NULL) &&

	mov	eax, DWORD PTR [edi-4]
	test	eax, eax
	je	SHORT $LN2@xmlParserI
	push	esi
	call	eax
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@xmlParserI

; 2547 : 		(xmlInputCallbackTable[i].matchcallback(URI) != 0)) {
; 2548 : 		context = xmlInputCallbackTable[i].opencallback(URI);

	mov	eax, DWORD PTR [edi]
	push	esi
	call	eax
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _context$1$[ebp], ecx

; 2549 : 		if (context != NULL) {

	test	ecx, ecx
	jne	SHORT $LN10@xmlParserI

; 2546 : 	    if ((xmlInputCallbackTable[i].matchcallback != NULL) &&

	jmp	SHORT $LN2@xmlParserI
$LN31@xmlParserI:
	mov	ecx, DWORD PTR _context$1$[ebp]
$LN2@xmlParserI:

; 2539 : 
; 2540 :     /*
; 2541 :      * Try to find one of the input accept method accepting that scheme
; 2542 :      * Go in reverse to give precedence to user defined handlers.
; 2543 :      */
; 2544 :     if (context == NULL) {
; 2545 : 	for (i = xmlInputCallbackNr - 1;i >= 0;i--) {

	sub	edi, 16					; 00000010H
	sub	ebx, 1
	jns	SHORT $LL4@xmlParserI

; 2550 : 		    break;
; 2551 : 		}
; 2552 : 	    }
; 2553 : 	}
; 2554 :     }
; 2555 :     if (context == NULL) {

	test	ecx, ecx
	je	$LN22@xmlParserI
$LN10@xmlParserI:

; 2556 : 	return(NULL);
; 2557 :     }
; 2558 : 
; 2559 :     /*
; 2560 :      * Allocate the Input buffer front-end.
; 2561 :      */
; 2562 :     ret = xmlAllocParserInputBuffer(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlAllocParserInputBuffer

; 2563 :     if (ret != NULL) {

	mov	edi, DWORD PTR _context$1$[ebp]
	mov	ecx, eax
	add	esp, 4
	shl	ebx, 4
	mov	DWORD PTR _ret$1$[ebp], ecx
	test	ecx, ecx
	je	$LN11@xmlParserI

; 2564 : 	ret->context = context;

	mov	DWORD PTR [ecx], edi

; 2565 : 	ret->readcallback = xmlInputCallbackTable[i].readcallback;

	mov	eax, DWORD PTR _xmlInputCallbackTable[ebx+8]
	mov	DWORD PTR [ecx+4], eax

; 2566 : 	ret->closecallback = xmlInputCallbackTable[i].closecallback;

	mov	eax, DWORD PTR _xmlInputCallbackTable[ebx+12]
	mov	DWORD PTR [ecx+8], eax

; 2567 : #ifdef LIBXML_ZLIB_ENABLED
; 2568 : 	if ((xmlInputCallbackTable[i].opencallback == xmlGzfileOpen) &&

	mov	ecx, DWORD PTR _xmlInputCallbackTable[ebx+4]
	cmp	ecx, OFFSET _xmlGzfileOpen
	jne	SHORT $LN13@xmlParserI
	mov	ecx, OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, esi
	npad	2
$LL23@xmlParserI:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN24@xmlParserI
	test	dl, dl
	je	SHORT $LN25@xmlParserI
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN24@xmlParserI
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL23@xmlParserI
$LN25@xmlParserI:
	xor	eax, eax
	jmp	SHORT $LN26@xmlParserI
$LN24@xmlParserI:
	sbb	eax, eax
	or	eax, 1
$LN26@xmlParserI:
	mov	ecx, DWORD PTR _xmlInputCallbackTable[ebx+4]
	test	eax, eax
	je	SHORT $LN13@xmlParserI

; 2569 : 		(strcmp(URI, "-") != 0)) {
; 2570 : #if defined(ZLIB_VERNUM) && ZLIB_VERNUM >= 0x1230
; 2571 :             ret->compressed = !gzdirect(context);

	push	edi
	call	_gzdirect@4
	mov	ecx, DWORD PTR _ret$1$[ebp]
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _xmlInputCallbackTable[ebx+4]
$LN13@xmlParserI:

; 2572 : #else
; 2573 : 	    if (((z_stream *)context)->avail_in > 4) {
; 2574 : 	        char *cptr, buff4[4];
; 2575 : 		cptr = (char *) ((z_stream *)context)->next_in;
; 2576 : 		if (gzread(context, buff4, 4) == 4) {
; 2577 : 		    if (strncmp(buff4, cptr, 4) == 0)
; 2578 : 		        ret->compressed = 0;
; 2579 : 		    else
; 2580 : 		        ret->compressed = 1;
; 2581 : 		    gzrewind(context);
; 2582 : 		}
; 2583 : 	    }
; 2584 : #endif
; 2585 : 	}
; 2586 : #endif
; 2587 : #ifdef LIBXML_LZMA_ENABLED
; 2588 : 	if ((xmlInputCallbackTable[i].opencallback == xmlXzfileOpen) &&

	cmp	ecx, OFFSET _xmlXzfileOpen
	jne	SHORT $LN12@xmlParserI
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9@
$LL27@xmlParserI:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN28@xmlParserI
	test	cl, cl
	je	SHORT $LN29@xmlParserI
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN28@xmlParserI
	add	esi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL27@xmlParserI
$LN29@xmlParserI:
	xor	eax, eax
	jmp	SHORT $LN30@xmlParserI
$LN28@xmlParserI:
	sbb	eax, eax
	or	eax, 1
$LN30@xmlParserI:
	test	eax, eax
	je	SHORT $LN12@xmlParserI

; 2589 : 		(strcmp(URI, "-") != 0)) {
; 2590 :             ret->compressed = __libxml2_xzcompressed(context);

	push	edi
	call	___libxml2_xzcompressed
	mov	ecx, DWORD PTR _ret$1$[ebp]

; 2596 : 
; 2597 :     return(ret);

	add	esp, 4
	pop	edi

; 2598 : }

	pop	esi
	mov	DWORD PTR [ecx+24], eax
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlParserI:

; 2591 : 	}
; 2592 : #endif
; 2593 :     }
; 2594 :     else
; 2595 :       xmlInputCallbackTable[i].closecallback (context);

	mov	eax, DWORD PTR _xmlInputCallbackTable[ebx+12]
	push	edi
	call	eax

; 2596 : 
; 2597 :     return(ret);

	add	esp, 4
$LN12@xmlParserI:
	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 2598 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlParserI:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___xmlParserInputBufferCreateFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlRegisterInputCallbacks
_TEXT	SEGMENT
_matchFunc$ = 8						; size = 4
_openFunc$ = 12						; size = 4
_readFunc$ = 16						; size = 4
_closeFunc$ = 20					; size = 4
_xmlRegisterInputCallbacks PROC				; COMDAT

; 2180 : 	xmlInputCloseCallback closeFunc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _xmlInputCallbackNr
	cmp	esi, 15					; 0000000fH
	jl	SHORT $LN2@xmlRegiste

; 2181 :     if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
; 2182 : 	return(-1);

	or	eax, -1
	pop	esi

; 2190 : }

	pop	ebp
	ret	0
$LN2@xmlRegiste:

; 2183 :     }
; 2184 :     xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;

	mov	eax, DWORD PTR _matchFunc$[ebp]
	mov	edx, esi

; 2185 :     xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;

	mov	ecx, DWORD PTR _openFunc$[ebp]
	shl	edx, 4

; 2186 :     xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
; 2187 :     xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
; 2188 :     xmlInputCallbackInitialized = 1;

	mov	DWORD PTR _xmlInputCallbackInitialized, 1
	mov	DWORD PTR _xmlInputCallbackTable[edx], eax

; 2189 :     return(xmlInputCallbackNr++);

	mov	eax, esi
	mov	DWORD PTR _xmlInputCallbackTable[edx+4], ecx
	mov	ecx, DWORD PTR _readFunc$[ebp]
	mov	DWORD PTR _xmlInputCallbackTable[edx+8], ecx
	mov	ecx, DWORD PTR _closeFunc$[ebp]
	mov	DWORD PTR _xmlInputCallbackTable[edx+12], ecx
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR _xmlInputCallbackNr, ecx
	pop	esi

; 2190 : }

	pop	ebp
	ret	0
_xmlRegisterInputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserGetDirectory
_TEXT	SEGMENT
_dir$ = -1024						; size = 1024
_filename$ = 8						; size = 4
_xmlParserGetDirectory PROC				; COMDAT

; 3711 : xmlParserGetDirectory(const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	cmp	DWORD PTR _xmlInputCallbackInitialized, esi
	jne	SHORT $LN4@xmlParserG

; 3712 :     char *ret = NULL;
; 3713 :     char dir[1024];
; 3714 :     char *cur;
; 3715 : 
; 3716 : #ifdef _WIN32_WCE  /* easy way by now ... wince does not have dirs! */
; 3717 :     return NULL;
; 3718 : #endif
; 3719 : 
; 3720 :     if (xmlInputCallbackInitialized == 0)
; 3721 : 	xmlRegisterDefaultInputCallbacks();

	call	_xmlRegisterDefaultInputCallbacks
$LN4@xmlParserG:

; 3722 : 
; 3723 :     if (filename == NULL) return(NULL);

	mov	eax, DWORD PTR _filename$[ebp]
	test	eax, eax
	jne	SHORT $LN5@xmlParserG
	pop	esi

; 3749 : #undef IS_XMLPGD_SEP
; 3750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlParserG:

; 3724 : 
; 3725 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 3726 : #   define IS_XMLPGD_SEP(ch) ((ch=='/')||(ch=='\\'))
; 3727 : #else
; 3728 : #   define IS_XMLPGD_SEP(ch) (ch=='/')
; 3729 : #endif
; 3730 : 
; 3731 :     strncpy(dir, filename, 1023);

	push	1023					; 000003ffH
	push	eax
	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy

; 3732 :     dir[1023] = 0;
; 3733 :     cur = &dir[strlen(dir)];

	lea	ecx, DWORD PTR _dir$[ebp]
	mov	BYTE PTR _dir$[ebp+1023], 0
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [ecx+1]
$LL20@xmlParserG:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL20@xmlParserG
	sub	ecx, edx
	lea	eax, DWORD PTR _dir$[ebp]
	add	eax, ecx

; 3734 :     while (cur > dir) {

	lea	ecx, DWORD PTR _dir$[ebp]
	cmp	eax, ecx
	jbe	SHORT $LN16@xmlParserG
	npad	3
$LL2@xmlParserG:

; 3735 :          if (IS_XMLPGD_SEP(*cur)) break;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 47					; 0000002fH
	je	SHORT $LN10@xmlParserG
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN16@xmlParserG

; 3736 : 	 cur --;

	dec	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	cmp	eax, ecx
	ja	SHORT $LL2@xmlParserG
$LN16@xmlParserG:

; 3737 :     }
; 3738 :     if (IS_XMLPGD_SEP(*cur)) {

	mov	cl, BYTE PTR [eax]
	cmp	cl, 47					; 0000002fH
	je	SHORT $LN10@xmlParserG
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN10@xmlParserG

; 3741 : 	ret = xmlMemStrdup(dir);
; 3742 :     } else {
; 3743 :         if (getcwd(dir, 1024) != NULL) {

	lea	eax, DWORD PTR _dir$[ebp]
	push	1024					; 00000400H
	push	eax
	call	DWORD PTR __imp__getcwd
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlParserG

; 3744 : 	    dir[1023] = 0;

	mov	BYTE PTR _dir$[ebp+1023], 0

; 3745 : 	    ret = xmlMemStrdup(dir);

	jmp	SHORT $LN12@xmlParserG
$LN10@xmlParserG:

; 3739 :         if (cur == dir) dir[1] = 0;

	lea	ecx, DWORD PTR _dir$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN11@xmlParserG
	mov	BYTE PTR _dir$[ebp+1], 0
	jmp	SHORT $LN12@xmlParserG
$LN11@xmlParserG:

; 3740 : 	else *cur = 0;

	mov	BYTE PTR [eax], 0
$LN12@xmlParserG:

; 3746 : 	}
; 3747 :     }
; 3748 :     return(ret);

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	esi, eax
	add	esp, 4
$LN13@xmlParserG:
	mov	eax, esi
	pop	esi

; 3749 : #undef IS_XMLPGD_SEP
; 3750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserGetDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlFreeParserInputBuffer
_TEXT	SEGMENT
_in$ = 8						; size = 4
_xmlFreeParserInputBuffer PROC				; COMDAT

; 2465 : xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreePar

; 2466 :     if (in == NULL) return;
; 2467 : 
; 2468 :     if (in->raw) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@xmlFreePar

; 2469 :         xmlBufFree(in->raw);

	push	eax
	call	_xmlBufFree
	add	esp, 4

; 2470 : 	in->raw = NULL;

	mov	DWORD PTR [esi+20], 0
$LN3@xmlFreePar:

; 2471 :     }
; 2472 :     if (in->encoder != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@xmlFreePar

; 2473 :         xmlCharEncCloseFunc(in->encoder);

	push	eax
	call	_xmlCharEncCloseFunc
	add	esp, 4
$LN4@xmlFreePar:

; 2474 :     }
; 2475 :     if (in->closecallback != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@xmlFreePar

; 2476 : 	in->closecallback(in->context);

	push	DWORD PTR [esi]
	call	eax
	add	esp, 4
$LN5@xmlFreePar:

; 2477 :     }
; 2478 :     if (in->buffer != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN6@xmlFreePar

; 2479 :         xmlBufFree(in->buffer);

	push	eax
	call	_xmlBufFree
	add	esp, 4

; 2480 : 	in->buffer = NULL;

	mov	DWORD PTR [esi+16], 0
$LN6@xmlFreePar:

; 2481 :     }
; 2482 : 
; 2483 :     xmlFree(in);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreePar:
	pop	esi

; 2484 : }

	pop	ebp
	ret	0
_xmlFreeParserInputBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferPush
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_buf$ = 16						; size = 4
_xmlParserInputBufferPush PROC				; COMDAT

; 3137 : 	                 int len, const char *buf) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jns	SHORT $LN2@xmlParserI

; 3138 :     int nbchars = 0;
; 3139 :     int ret;
; 3140 : 
; 3141 :     if (len < 0) return(0);

	xor	eax, eax
	pop	edi

; 3179 : }

	pop	ebp
	ret	0
$LN2@xmlParserI:
	push	ebx
	push	esi

; 3142 :     if ((in == NULL) || (in->error)) return(-1);

	mov	esi, DWORD PTR _in$[ebp]
	test	esi, esi
	je	SHORT $LN4@xmlParserI
	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN4@xmlParserI

; 3143 :     if (in->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN5@xmlParserI

; 3144 :         unsigned int use;
; 3145 : 
; 3146 :         /*
; 3147 : 	 * Store the data in the incoming raw buffer
; 3148 : 	 */
; 3149 :         if (in->raw == NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN7@xmlParserI

; 3150 : 	    in->raw = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+20], eax
$LN7@xmlParserI:

; 3151 : 	}
; 3152 : 	ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);

	push	edi
	push	DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 3153 : 	if (ret != 0)

	test	eax, eax
	jne	SHORT $LN4@xmlParserI

; 3154 : 	    return(-1);
; 3155 : 
; 3156 : 	/*
; 3157 : 	 * convert as much as possible to the parser reading buffer.
; 3158 : 	 */
; 3159 : 	use = xmlBufUse(in->raw);

	push	DWORD PTR [esi+20]
	call	_xmlBufUse

; 3160 : 	nbchars = xmlCharEncInput(in, 1);

	push	1
	push	esi
	mov	ebx, eax
	call	_xmlCharEncInput
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3161 : 	if (nbchars < 0) {

	test	edi, edi
	jns	SHORT $LN9@xmlParserI

; 3162 : 	    xmlIOErr(XML_IO_ENCODER, NULL);

	push	0
	push	1544					; 00000608H
	call	_xmlIOErr
	add	esp, 8

; 3163 : 	    in->error = XML_IO_ENCODER;

	mov	DWORD PTR [esi+28], 1544		; 00000608H
$LN4@xmlParserI:

; 3142 :     if ((in == NULL) || (in->error)) return(-1);

	pop	esi
	pop	ebx
	or	eax, -1
	pop	edi

; 3179 : }

	pop	ebp
	ret	0
$LN9@xmlParserI:

; 3164 : 	    return(-1);
; 3165 : 	}
; 3166 : 	in->rawconsumed += (use - xmlBufUse(in->raw));

	push	DWORD PTR [esi+20]
	call	_xmlBufUse
	add	esp, 4
	sub	ebx, eax
	add	DWORD PTR [esi+32], ebx

; 3171 : 	    return(-1);
; 3172 :     }
; 3173 : #ifdef DEBUG_INPUT
; 3174 :     xmlGenericError(xmlGenericErrorContext,
; 3175 : 	    "I/O: pushed %d chars, buffer %d/%d\n",
; 3176 :             nbchars, xmlBufUse(in->buffer), xmlBufLength(in->buffer));
; 3177 : #endif
; 3178 :     return(nbchars);

	mov	eax, edi
	pop	esi
	pop	ebx
	pop	edi

; 3179 : }

	pop	ebp
	ret	0
$LN5@xmlParserI:

; 3167 :     } else {
; 3168 : 	nbchars = len;
; 3169 :         ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);

	push	edi
	push	DWORD PTR _buf$[ebp]
	push	DWORD PTR [esi+16]
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 3170 : 	if (ret != 0)

	test	eax, eax
	jne	SHORT $LN4@xmlParserI

; 3171 : 	    return(-1);
; 3172 :     }
; 3173 : #ifdef DEBUG_INPUT
; 3174 :     xmlGenericError(xmlGenericErrorContext,
; 3175 : 	    "I/O: pushed %d chars, buffer %d/%d\n",
; 3176 :             nbchars, xmlBufUse(in->buffer), xmlBufLength(in->buffer));
; 3177 : #endif
; 3178 :     return(nbchars);

	pop	esi
	pop	ebx
	mov	eax, edi
	pop	edi

; 3179 : }

	pop	ebp
	ret	0
_xmlParserInputBufferPush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferGrow
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputBufferGrow PROC				; COMDAT

; 3210 : xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	test	esi, esi
	je	$LN3@xmlParserI

; 3211 :     char *buffer = NULL;
; 3212 :     int res = 0;
; 3213 :     int nbchars = 0;
; 3214 : 
; 3215 :     if ((in == NULL) || (in->error)) return(-1);

	cmp	DWORD PTR [esi+28], 0
	jne	$LN3@xmlParserI

; 3216 :     if ((len <= MINLEN) && (len != 4))

	mov	edi, DWORD PTR _len$[ebp]
	cmp	edi, 4000				; 00000fa0H
	jg	SHORT $LN4@xmlParserI
	cmp	edi, 4
	mov	eax, 4000				; 00000fa0H
	cmovne	edi, eax
$LN4@xmlParserI:

; 3217 :         len = MINLEN;
; 3218 : 
; 3219 :     if (xmlBufAvail(in->buffer) <= 0) {

	push	DWORD PTR [esi+16]
	call	_xmlBufAvail
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@xmlParserI

; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	push	eax
	push	DWORD PTR _IOerr+192
	push	eax
	push	1548					; 0000060cH
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3220 : 	xmlIOErr(XML_IO_BUFFER_FULL, NULL);
; 3221 : 	in->error = XML_IO_BUFFER_FULL;

	mov	DWORD PTR [esi+28], 1548		; 0000060cH

; 3293 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlParserI:

; 3222 : 	return(-1);
; 3223 :     }
; 3224 : 
; 3225 :     if (xmlBufGrow(in->buffer, len + 1) < 0) {

	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	DWORD PTR [esi+16]
	call	_xmlBufGrow
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN6@xmlParserI

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BF@EADFILIC@growing?5input?5buffer@
	push	0
	push	0
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 3226 :         xmlIOErrMemory("growing input buffer");
; 3227 :         in->error = XML_ERR_NO_MEMORY;

	mov	DWORD PTR [esi+28], 2

; 3293 : }

	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlParserI:

; 3228 :         return(-1);
; 3229 :     }
; 3230 :     buffer = (char *)xmlBufEnd(in->buffer);

	push	DWORD PTR [esi+16]
	call	_xmlBufEnd

; 3231 : 
; 3232 :     /*
; 3233 :      * Call the read method for this I/O type.
; 3234 :      */
; 3235 :     if (in->readcallback != NULL) {

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 4
	mov	ebx, eax
	test	ecx, ecx
	je	$LN7@xmlParserI

; 3236 : 	res = in->readcallback(in->context, &buffer[0], len);

	push	edi
	push	ebx
	push	DWORD PTR [esi]
	call	ecx
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3237 : 	if (res <= 0)

	test	edi, edi
	jg	SHORT $LN134@xmlParserI

; 3238 : 	    in->readcallback = endOfInput;

	mov	DWORD PTR [esi+4], OFFSET _endOfInput
$LN134@xmlParserI:

; 3242 : 	return(-1);
; 3243 :     }
; 3244 :     if (res < 0) {

	js	$LN3@xmlParserI

; 3245 : 	return(-1);
; 3246 :     }
; 3247 : 
; 3248 :     /*
; 3249 :      * try to establish compressed status of input if not done already
; 3250 :      */
; 3251 :     if (in->compressed == -1) {

	cmp	DWORD PTR [esi+24], -1
	jne	SHORT $LN12@xmlParserI

; 3252 : #ifdef LIBXML_LZMA_ENABLED
; 3253 : 	if (in->readcallback == xmlXzfileRead)

	cmp	DWORD PTR [esi+4], OFFSET _xmlXzfileRead
	jne	SHORT $LN12@xmlParserI

; 3254 :             in->compressed = __libxml2_xzcompressed(in->context);

	push	DWORD PTR [esi]
	call	___libxml2_xzcompressed
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
$LN12@xmlParserI:

; 3255 : #endif
; 3256 :     }
; 3257 : 
; 3258 :     len = res;
; 3259 :     if (in->encoder != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN13@xmlParserI

; 3260 :         unsigned int use;
; 3261 : 
; 3262 :         /*
; 3263 : 	 * Store the data in the incoming raw buffer
; 3264 : 	 */
; 3265 :         if (in->raw == NULL) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN15@xmlParserI

; 3266 : 	    in->raw = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+20], eax
$LN15@xmlParserI:

; 3267 : 	}
; 3268 : 	res = xmlBufAdd(in->raw, (const xmlChar *) buffer, len);

	push	edi
	push	ebx
	push	eax
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 3269 : 	if (res != 0)

	test	eax, eax
	jne	SHORT $LN3@xmlParserI

; 3270 : 	    return(-1);
; 3271 : 
; 3272 : 	/*
; 3273 : 	 * convert as much as possible to the parser reading buffer.
; 3274 : 	 */
; 3275 : 	use = xmlBufUse(in->raw);

	push	DWORD PTR [esi+20]
	call	_xmlBufUse

; 3276 : 	nbchars = xmlCharEncInput(in, 1);

	push	1
	push	esi
	mov	ebx, eax
	call	_xmlCharEncInput
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 3277 : 	if (nbchars < 0) {

	test	edi, edi
	jns	SHORT $LN17@xmlParserI

; 3278 : 	    xmlIOErr(XML_IO_ENCODER, NULL);

	push	0
	push	1544					; 00000608H
	call	_xmlIOErr

; 3293 : }

	add	esp, 8
	mov	DWORD PTR [esi+28], 1544		; 00000608H
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlParserI:

; 3279 : 	    in->error = XML_IO_ENCODER;
; 3280 : 	    return(-1);
; 3281 : 	}
; 3282 : 	in->rawconsumed += (use - xmlBufUse(in->raw));

	push	DWORD PTR [esi+20]
	call	_xmlBufUse
	add	esp, 4
	sub	ebx, eax
	add	DWORD PTR [esi+32], ebx

; 3286 :     }
; 3287 : #ifdef DEBUG_INPUT
; 3288 :     xmlGenericError(xmlGenericErrorContext,
; 3289 : 	    "I/O: read %d chars, buffer %d\n",
; 3290 :             nbchars, xmlBufUse(in->buffer));
; 3291 : #endif
; 3292 :     return(nbchars);

	mov	eax, edi
	pop	edi

; 3293 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN13@xmlParserI:

; 3283 :     } else {
; 3284 : 	nbchars = len;
; 3285 :         xmlBufAddLen(in->buffer, nbchars);

	push	edi
	push	DWORD PTR [esi+16]
	call	_xmlBufAddLen
	add	esp, 8

; 3286 :     }
; 3287 : #ifdef DEBUG_INPUT
; 3288 :     xmlGenericError(xmlGenericErrorContext,
; 3289 : 	    "I/O: read %d chars, buffer %d\n",
; 3290 :             nbchars, xmlBufUse(in->buffer));
; 3291 : #endif
; 3292 :     return(nbchars);

	mov	eax, edi
	pop	edi

; 3293 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN7@xmlParserI:

; 3239 :     } else {
; 3240 : 	xmlIOErr(XML_IO_NO_INPUT, NULL);

	push	0
	push	1547					; 0000060bH
	call	_xmlIOErr

; 3241 : 	in->error = XML_IO_NO_INPUT;

	mov	DWORD PTR [esi+28], 1547		; 0000060bH

; 3293 : }

	add	esp, 8
$LN3@xmlParserI:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_xmlParserInputBufferGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferRead
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputBufferRead PROC				; COMDAT

; 3308 : xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _in$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlParserI

; 3309 :     if ((in == NULL) || (in->error)) return(-1);

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN3@xmlParserI

; 3310 :     if (in->readcallback != NULL)

	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@xmlParserI

; 3311 : 	return(xmlParserInputBufferGrow(in, len));

	mov	DWORD PTR _in$[ebp], eax

; 3314 :     else
; 3315 :         return(-1);
; 3316 : }

	pop	ebp

; 3311 : 	return(xmlParserInputBufferGrow(in, len));

	jmp	_xmlParserInputBufferGrow
$LN4@xmlParserI:

; 3312 :     else if (xmlBufGetAllocationScheme(in->buffer) == XML_BUFFER_ALLOC_IMMUTABLE)

	push	DWORD PTR [eax+16]
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN3@xmlParserI

; 3313 : 	return(0);

	xor	eax, eax

; 3314 :     else
; 3315 :         return(-1);
; 3316 : }

	pop	ebp
	ret	0
$LN3@xmlParserI:

; 3309 :     if ((in == NULL) || (in->error)) return(-1);

	or	eax, -1

; 3314 :     else
; 3315 :         return(-1);
; 3316 : }

	pop	ebp
	ret	0
_xmlParserInputBufferRead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateIO
_TEXT	SEGMENT
_ioread$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_enc$ = 20						; size = 4
_xmlParserInputBufferCreateIO PROC			; COMDAT

; 3034 : 	 xmlInputCloseCallback  ioclose, void *ioctx, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ioread$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlParserI

; 3035 :     xmlParserInputBufferPtr ret;
; 3036 : 
; 3037 :     if (ioread == NULL) return(NULL);

	xor	eax, eax
	pop	esi

; 3044 :     }
; 3045 : 
; 3046 :     return(ret);
; 3047 : }

	pop	ebp
	ret	0
$LN2@xmlParserI:

; 3038 : 
; 3039 :     ret = xmlAllocParserInputBuffer(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlAllocParserInputBuffer
	add	esp, 4

; 3040 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlParserI

; 3041 :         ret->context = (void *) ioctx;

	mov	ecx, DWORD PTR _ioctx$[ebp]
	mov	DWORD PTR [eax], ecx

; 3042 : 	ret->readcallback = ioread;
; 3043 : 	ret->closecallback = ioclose;

	mov	ecx, DWORD PTR _ioclose$[ebp]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx
$LN1@xmlParserI:
	pop	esi

; 3044 :     }
; 3045 : 
; 3046 :     return(ret);
; 3047 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateStatic
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlParserInputBufferCreateStatic PROC			; COMDAT

; 2962 :                                  xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _size$[ebp], 0
	jl	$LN11@xmlParserI

; 2963 :     xmlParserInputBufferPtr ret;
; 2964 : 
; 2965 :     if (size < 0) return(NULL);
; 2966 :     if (mem == NULL) return(NULL);

	mov	edi, DWORD PTR _mem$[ebp]
	test	edi, edi
	je	$LN11@xmlParserI

; 2967 : 
; 2968 :     ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));

	push	esi
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 2969 :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlParserI

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BG@GLAPLACG@creating?5input?5buffer@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2970 : 	xmlIOErrMemory("creating input buffer");
; 2971 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2990 : }

	pop	ebp
	ret	0
$LN4@xmlParserI:

; 2972 :     }
; 2973 :     memset(ret, 0, (size_t) sizeof(xmlParserInputBuffer));
; 2974 :     ret->buffer = xmlBufCreateStatic((void *)mem, (size_t) size);

	push	DWORD PTR _size$[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [esi], xmm0
	push	edi
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], 0
	call	_xmlBufCreateStatic
	add	esp, 8
	mov	DWORD PTR [esi+16], eax

; 2975 :     if (ret->buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN5@xmlParserI

; 2976 :         xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
	xor	eax, eax
	pop	esi
	pop	edi

; 2990 : }

	pop	ebp
	ret	0
$LN5@xmlParserI:

; 2977 : 	return(NULL);
; 2978 :     }
; 2979 :     ret->encoder = xmlGetCharEncodingHandler(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlGetCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 2980 :     if (ret->encoder != NULL)

	test	eax, eax
	je	SHORT $LN6@xmlParserI

; 2981 :         ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	add	eax, eax
	push	eax
	call	_xmlBufCreateSize
	add	esp, 4
	jmp	SHORT $LN7@xmlParserI
$LN6@xmlParserI:

; 2982 :     else
; 2983 :         ret->raw = NULL;

	xor	eax, eax
$LN7@xmlParserI:

; 2984 :     ret->compressed = -1;

	mov	DWORD PTR [esi+20], eax

; 2985 :     ret->context = (void *) mem;
; 2986 :     ret->readcallback = NULL;
; 2987 :     ret->closecallback = NULL;
; 2988 : 
; 2989 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+24], -1
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	pop	esi
	pop	edi

; 2990 : }

	pop	ebp
	ret	0
$LN11@xmlParserI:

; 2963 :     xmlParserInputBufferPtr ret;
; 2964 : 
; 2965 :     if (size < 0) return(NULL);
; 2966 :     if (mem == NULL) return(NULL);

	xor	eax, eax
	pop	edi

; 2990 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateStatic ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateMem
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlParserInputBufferCreateMem PROC			; COMDAT

; 2925 : xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _size$[ebp], 0
	jl	SHORT $LN7@xmlParserI

; 2926 :     xmlParserInputBufferPtr ret;
; 2927 :     int errcode;
; 2928 : 
; 2929 :     if (size < 0) return(NULL);
; 2930 :     if (mem == NULL) return(NULL);

	mov	edi, DWORD PTR _mem$[ebp]
	test	edi, edi
	je	SHORT $LN7@xmlParserI

; 2931 : 
; 2932 :     ret = xmlAllocParserInputBuffer(enc);

	push	esi
	push	DWORD PTR _enc$[ebp]
	call	_xmlAllocParserInputBuffer
	mov	esi, eax
	add	esp, 4

; 2933 :     if (ret != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlParserI

; 2934 :         ret->context = (void *) mem;
; 2935 : 	ret->readcallback = xmlInputReadCallbackNop;
; 2936 : 	ret->closecallback = NULL;
; 2937 : 	errcode = xmlBufAdd(ret->buffer, (const xmlChar *) mem, size);

	push	DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi], edi
	push	edi
	push	DWORD PTR [esi+16]
	mov	DWORD PTR [esi+4], OFFSET _xmlInputReadCallbackNop
	mov	DWORD PTR [esi+8], 0
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2938 : 	if (errcode != 0) {

	test	eax, eax
	je	SHORT $LN5@xmlParserI

; 2939 : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2940 : 	    return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 2945 : }

	pop	ebp
	ret	0
$LN5@xmlParserI:

; 2941 : 	}
; 2942 :     }
; 2943 : 
; 2944 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 2945 : }

	pop	ebp
	ret	0
$LN7@xmlParserI:

; 2926 :     xmlParserInputBufferPtr ret;
; 2927 :     int errcode;
; 2928 : 
; 2929 :     if (size < 0) return(NULL);
; 2930 :     if (mem == NULL) return(NULL);

	xor	eax, eax
	pop	edi

; 2945 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateMem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateFd
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_enc$ = 12						; size = 4
_xmlParserInputBufferCreateFd PROC			; COMDAT

; 2898 : xmlParserInputBufferCreateFd(int fd, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _fd$[ebp]
	test	esi, esi
	jns	SHORT $LN2@xmlParserI

; 2899 :     xmlParserInputBufferPtr ret;
; 2900 : 
; 2901 :     if (fd < 0) return(NULL);

	xor	eax, eax
	pop	esi

; 2908 :     }
; 2909 : 
; 2910 :     return(ret);
; 2911 : }

	pop	ebp
	ret	0
$LN2@xmlParserI:

; 2902 : 
; 2903 :     ret = xmlAllocParserInputBuffer(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlAllocParserInputBuffer
	add	esp, 4

; 2904 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlParserI

; 2905 :         ret->context = (void *) (ptrdiff_t) fd;

	mov	DWORD PTR [eax], esi

; 2906 : 	ret->readcallback = xmlFdRead;

	mov	DWORD PTR [eax+4], OFFSET _xmlFdRead

; 2907 : 	ret->closecallback = xmlFdClose;

	mov	DWORD PTR [eax+8], OFFSET _xmlFdClose
$LN1@xmlParserI:
	pop	esi

; 2908 :     }
; 2909 : 
; 2910 :     return(ret);
; 2911 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateFile
_TEXT	SEGMENT
_file$ = 8						; size = 4
_enc$ = 12						; size = 4
_xmlParserInputBufferCreateFile PROC			; COMDAT

; 2782 : xmlParserInputBufferCreateFile(FILE *file, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlInputCallbackInitialized, 0
	jne	SHORT $LN2@xmlParserI

; 2783 :     xmlParserInputBufferPtr ret;
; 2784 : 
; 2785 :     if (xmlInputCallbackInitialized == 0)
; 2786 : 	xmlRegisterDefaultInputCallbacks();

	call	_xmlRegisterDefaultInputCallbacks
$LN2@xmlParserI:
	push	esi

; 2787 : 
; 2788 :     if (file == NULL) return(NULL);

	mov	esi, DWORD PTR _file$[ebp]
	test	esi, esi
	jne	SHORT $LN3@xmlParserI
	xor	eax, eax
	pop	esi

; 2795 :     }
; 2796 : 
; 2797 :     return(ret);
; 2798 : }

	pop	ebp
	ret	0
$LN3@xmlParserI:

; 2789 : 
; 2790 :     ret = xmlAllocParserInputBuffer(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlAllocParserInputBuffer
	add	esp, 4

; 2791 :     if (ret != NULL) {

	test	eax, eax
	je	SHORT $LN1@xmlParserI

; 2792 :         ret->context = file;

	mov	DWORD PTR [eax], esi

; 2793 : 	ret->readcallback = xmlFileRead;

	mov	DWORD PTR [eax+4], OFFSET _xmlFileRead

; 2794 : 	ret->closecallback = xmlFileFlush;

	mov	DWORD PTR [eax+8], OFFSET _xmlFileFlush
$LN1@xmlParserI:
	pop	esi

; 2795 :     }
; 2796 : 
; 2797 :     return(ret);
; 2798 : }

	pop	ebp
	ret	0
_xmlParserInputBufferCreateFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlParserInputBufferCreateFilename
_TEXT	SEGMENT
_URI$ = 8						; size = 4
_enc$ = 12						; size = 4
_xmlParserInputBufferCreateFilename PROC		; COMDAT

; 2614 : xmlParserInputBufferCreateFilename(const char *URI, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	call	___xmlParserInputBufferCreateFilenameValue
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@xmlParserI

; 2615 :     if ((xmlParserInputBufferCreateFilenameValue)) {
; 2616 : 		return xmlParserInputBufferCreateFilenameValue(URI, enc);

	call	___xmlParserInputBufferCreateFilenameValue
	mov	eax, DWORD PTR [eax]

; 2619 : }

	pop	ebp

; 2615 :     if ((xmlParserInputBufferCreateFilenameValue)) {
; 2616 : 		return xmlParserInputBufferCreateFilenameValue(URI, enc);

	jmp	eax
$LN2@xmlParserI:

; 2619 : }

	pop	ebp

; 2617 : 	}
; 2618 : 	return __xmlParserInputBufferCreateFilename(URI, enc);

	jmp	___xmlParserInputBufferCreateFilename
_xmlParserInputBufferCreateFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlAllocParserInputBuffer
_TEXT	SEGMENT
_enc$ = 8						; size = 4
_xmlAllocParserInputBuffer PROC				; COMDAT

; 2324 : xmlAllocParserInputBuffer(xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	push	36					; 00000024H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlAllocPa

; 234  :     __xmlSimpleError(XML_FROM_IO, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BG@GLAPLACG@creating?5input?5buffer@
	push	eax
	push	eax
	push	2
	push	8
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2325 :     xmlParserInputBufferPtr ret;
; 2326 : 
; 2327 :     ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
; 2328 :     if (ret == NULL) {
; 2329 : 	xmlIOErrMemory("creating input buffer");
; 2330 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2351 : }

	pop	ebp
	ret	0
$LN2@xmlAllocPa:
	xorps	xmm0, xmm0

; 2331 :     }
; 2332 :     memset(ret, 0, (size_t) sizeof(xmlParserInputBuffer));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+32], 0

; 2333 :     ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	add	eax, eax
	push	eax
	call	_xmlBufCreateSize
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 2334 :     if (ret->buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlAllocPa

; 2335 :         xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2336 : 	return(NULL);

	xor	eax, eax
	pop	esi

; 2351 : }

	pop	ebp
	ret	0
$LN3@xmlAllocPa:

; 2337 :     }
; 2338 :     xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);

	push	0
	push	eax
	call	_xmlBufSetAllocationScheme

; 2339 :     ret->encoder = xmlGetCharEncodingHandler(enc);

	push	DWORD PTR _enc$[ebp]
	call	_xmlGetCharEncodingHandler
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+12], eax

; 2340 :     if (ret->encoder != NULL)

	test	eax, eax
	je	SHORT $LN4@xmlAllocPa

; 2341 :         ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);

	call	___xmlDefaultBufferSize
	mov	eax, DWORD PTR [eax]
	add	eax, eax
	push	eax
	call	_xmlBufCreateSize
	add	esp, 4
	jmp	SHORT $LN5@xmlAllocPa
$LN4@xmlAllocPa:

; 2342 :     else
; 2343 :         ret->raw = NULL;

	xor	eax, eax
$LN5@xmlAllocPa:

; 2344 :     ret->readcallback = NULL;

	mov	DWORD PTR [esi+20], eax

; 2345 :     ret->closecallback = NULL;
; 2346 :     ret->context = NULL;
; 2347 :     ret->compressed = -1;
; 2348 :     ret->rawconsumed = 0;
; 2349 : 
; 2350 :     return(ret);

	mov	eax, esi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], -1
	mov	DWORD PTR [esi+32], 0
	pop	esi

; 2351 : }

	pop	ebp
	ret	0
_xmlAllocParserInputBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlRegisterDefaultInputCallbacks
_TEXT	SEGMENT
_xmlRegisterDefaultInputCallbacks PROC			; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlInputCallbackInitialized, 0
	jne	$LN1@xmlRegiste

; 2227 :     if (xmlInputCallbackInitialized)
; 2228 : 	return;
; 2229 : 
; 2230 :     xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,

	push	OFFSET _xmlFileClose
	push	OFFSET _xmlFileRead
	push	OFFSET _xmlFileOpen
	push	OFFSET _xmlFileMatch
	call	_xmlRegisterInputCallbacks

; 2231 : 	                      xmlFileRead, xmlFileClose);
; 2232 : #ifdef LIBXML_ZLIB_ENABLED
; 2233 :     xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,

	push	OFFSET _xmlGzfileClose
	push	OFFSET _xmlGzfileRead
	push	OFFSET _xmlGzfileOpen
	push	OFFSET _xmlGzfileMatch
	call	_xmlRegisterInputCallbacks

; 2234 : 	                      xmlGzfileRead, xmlGzfileClose);
; 2235 : #endif /* LIBXML_ZLIB_ENABLED */
; 2236 : #ifdef LIBXML_LZMA_ENABLED
; 2237 :     xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,

	push	OFFSET _xmlXzfileClose
	push	OFFSET _xmlXzfileRead
	push	OFFSET _xmlXzfileOpen
	push	OFFSET _xmlXzfileMatch
	call	_xmlRegisterInputCallbacks

; 2238 : 	                      xmlXzfileRead, xmlXzfileClose);
; 2239 : #endif /* LIBXML_LZMA_ENABLED */
; 2240 : 
; 2241 : #ifdef LIBXML_HTTP_ENABLED
; 2242 :     xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,

	push	OFFSET _xmlIOHTTPClose
	push	OFFSET _xmlIOHTTPRead
	push	OFFSET _xmlIOHTTPOpen
	push	OFFSET _xmlIOHTTPMatch
	call	_xmlRegisterInputCallbacks
	add	esp, 64					; 00000040H

; 2243 : 	                      xmlIOHTTPRead, xmlIOHTTPClose);
; 2244 : #endif /* LIBXML_HTTP_ENABLED */
; 2245 : 
; 2246 : #ifdef LIBXML_FTP_ENABLED
; 2247 :     xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,

	push	OFFSET _xmlIOFTPClose
	push	OFFSET _xmlIOFTPRead
	push	OFFSET _xmlIOFTPOpen
	push	OFFSET _xmlIOFTPMatch
	call	_xmlRegisterInputCallbacks
	add	esp, 16					; 00000010H

; 2248 : 	                      xmlIOFTPRead, xmlIOFTPClose);
; 2249 : #endif /* LIBXML_FTP_ENABLED */
; 2250 :     xmlInputCallbackInitialized = 1;

	mov	DWORD PTR _xmlInputCallbackInitialized, 1
$LN1@xmlRegiste:

; 2251 : }

	ret	0
_xmlRegisterDefaultInputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlPopInputCallbacks
_TEXT	SEGMENT
_xmlPopInputCallbacks PROC				; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlInputCallbackInitialized, 0
	je	SHORT $LN5@xmlPopInpu

; 523  :     if (!xmlInputCallbackInitialized)
; 524  :         return(-1);
; 525  : 
; 526  :     if (xmlInputCallbackNr <= 0)

	mov	eax, DWORD PTR _xmlInputCallbackNr
	test	eax, eax
	jle	SHORT $LN5@xmlPopInpu

; 528  : 
; 529  :     xmlInputCallbackNr--;

	dec	eax

; 530  :     xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = NULL;

	mov	ecx, eax
	mov	DWORD PTR _xmlInputCallbackNr, eax
	shl	ecx, 4
	mov	DWORD PTR _xmlInputCallbackTable[ecx], 0

; 531  :     xmlInputCallbackTable[xmlInputCallbackNr].opencallback = NULL;

	mov	DWORD PTR _xmlInputCallbackTable[ecx+4], 0

; 532  :     xmlInputCallbackTable[xmlInputCallbackNr].readcallback = NULL;

	mov	DWORD PTR _xmlInputCallbackTable[ecx+8], 0

; 533  :     xmlInputCallbackTable[xmlInputCallbackNr].closecallback = NULL;

	mov	DWORD PTR _xmlInputCallbackTable[ecx+12], 0

; 534  : 
; 535  :     return(xmlInputCallbackNr);
; 536  : }

	ret	0
$LN5@xmlPopInpu:

; 527  :         return(-1);

	or	eax, -1

; 534  : 
; 535  :     return(xmlInputCallbackNr);
; 536  : }

	ret	0
_xmlPopInputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlCleanupInputCallbacks
_TEXT	SEGMENT
_xmlCleanupInputCallbacks PROC				; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlInputCallbackInitialized, 0
	je	SHORT $LN1@xmlCleanup

; 496  :     int i;
; 497  : 
; 498  :     if (!xmlInputCallbackInitialized)
; 499  :         return;
; 500  : 
; 501  :     for (i = xmlInputCallbackNr - 1; i >= 0; i--) {

	mov	ecx, DWORD PTR _xmlInputCallbackNr
	sub	ecx, 1
	js	SHORT $LN3@xmlCleanup
	mov	eax, ecx
	shl	eax, 4
	add	eax, OFFSET _xmlInputCallbackTable+4
	npad	8
$LL4@xmlCleanup:
	sub	ecx, 1

; 502  :         xmlInputCallbackTable[i].matchcallback = NULL;

	mov	DWORD PTR [eax-4], 0

; 503  :         xmlInputCallbackTable[i].opencallback = NULL;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax-16]

; 504  :         xmlInputCallbackTable[i].readcallback = NULL;

	mov	DWORD PTR [eax+20], 0

; 505  :         xmlInputCallbackTable[i].closecallback = NULL;

	mov	DWORD PTR [eax+24], 0
	jns	SHORT $LL4@xmlCleanup
$LN3@xmlCleanup:

; 506  :     }
; 507  : 
; 508  :     xmlInputCallbackNr = 0;

	mov	DWORD PTR _xmlInputCallbackNr, 0

; 509  :     xmlInputCallbackInitialized = 0;

	mov	DWORD PTR _xmlInputCallbackInitialized, 0
$LN1@xmlCleanup:

; 510  : }

	ret	0
_xmlCleanupInputCallbacks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT _xmlInputReadCallbackNop
_TEXT	SEGMENT
_context$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlInputReadCallbackNop PROC				; COMDAT
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	ret	0
_xmlInputReadCallbackNop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT ___xmlLoaderErr
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_msg$ = 12						; size = 4
_filename$ = 16						; size = 4
___xmlLoaderErr PROC					; COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctx$[ebp]
	xor	ebx, ebx
	xor	esi, esi
	xor	edi, edi
	lea	edx, DWORD PTR [ebx+2]
	test	ecx, ecx
	je	SHORT $LN3@xmlLoaderE

; 439  :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
; 440  :     xmlStructuredErrorFunc schannel = NULL;
; 441  :     xmlGenericErrorFunc channel = NULL;
; 442  :     void *data = NULL;
; 443  :     xmlErrorLevel level = XML_ERR_ERROR;
; 444  : 
; 445  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR [ecx+212], ebx
	je	SHORT $LN2@xmlLoaderE
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN1@xmlLoaderE
$LN2@xmlLoaderE:

; 446  :         (ctxt->instate == XML_PARSER_EOF))
; 447  : 	return;
; 448  :     if ((ctxt != NULL) && (ctxt->sax != NULL)) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@xmlLoaderE

; 449  :         if (ctxt->validate) {

	mov	edi, DWORD PTR [ecx+104]
	test	edi, edi
	je	SHORT $LN4@xmlLoaderE

; 450  : 	    channel = ctxt->sax->error;

	mov	esi, DWORD PTR [eax+88]

; 451  : 	    level = XML_ERR_ERROR;
; 452  : 	} else {

	jmp	SHORT $LN5@xmlLoaderE
$LN4@xmlLoaderE:

; 453  : 	    channel = ctxt->sax->warning;

	mov	esi, DWORD PTR [eax+84]
$LN5@xmlLoaderE:

; 454  : 	    level = XML_ERR_WARNING;
; 455  : 	}
; 456  : 	if (ctxt->sax->initialized == XML_SAX2_MAGIC)

	xor	edx, edx
	test	edi, edi
	setne	dl
	inc	edx
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN6@xmlLoaderE

; 457  : 	    schannel = ctxt->sax->serror;

	mov	ebx, DWORD PTR [eax+124]
$LN6@xmlLoaderE:

; 458  : 	data = ctxt->userData;

	mov	edi, DWORD PTR [ecx+4]
$LN3@xmlLoaderE:

; 459  :     }
; 460  :     __xmlRaiseError(schannel, channel, data, ctxt, NULL, XML_FROM_IO,

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	edx
	push	1549					; 0000060dH
	push	8
	push	0
	push	ecx
	push	edi
	push	esi
	push	ebx
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlLoaderE:

; 461  :                     XML_IO_LOAD_ERROR, level, NULL, 0,
; 462  : 		    filename, NULL, NULL, 0, 0,
; 463  : 		    msg, filename);
; 464  : 
; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
___xmlLoaderErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlio.c
;	COMDAT ___xmlIOErr
_TEXT	SEGMENT
_domain$ = 8						; size = 4
_code$ = 12						; size = 4
_extra$ = 16						; size = 4
___xmlIOErr PROC					; COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __7D5E66B2_xmlio@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _code$[ebp]
	test	edx, edx
	jne	$LN105@xmlIOErr

; 248  :     unsigned int idx;
; 249  : 
; 250  :     if (code == 0) {
; 251  : #ifdef HAVE_ERRNO_H
; 252  : 	if (errno == 0) code = 0;

	push	esi
	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@xmlIOErr
	xor	edx, edx
	jmp	$LN110@xmlIOErr
$LN3@xmlIOErr:

; 253  : #ifdef EACCES
; 254  :         else if (errno == EACCES) code = XML_IO_EACCES;

	call	esi
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN5@xmlIOErr
	mov	edx, 1501				; 000005ddH
	jmp	$LN110@xmlIOErr
$LN5@xmlIOErr:

; 255  : #endif
; 256  : #ifdef EAGAIN
; 257  :         else if (errno == EAGAIN) code = XML_IO_EAGAIN;

	call	esi
	cmp	DWORD PTR [eax], 11			; 0000000bH
	jne	SHORT $LN7@xmlIOErr
	mov	edx, 1502				; 000005deH
	jmp	$LN110@xmlIOErr
$LN7@xmlIOErr:

; 258  : #endif
; 259  : #ifdef EBADF
; 260  :         else if (errno == EBADF) code = XML_IO_EBADF;

	call	esi
	cmp	DWORD PTR [eax], 9
	jne	SHORT $LN9@xmlIOErr
	mov	edx, 1503				; 000005dfH
	jmp	$LN110@xmlIOErr
$LN9@xmlIOErr:

; 261  : #endif
; 262  : #ifdef EBADMSG
; 263  :         else if (errno == EBADMSG) code = XML_IO_EBADMSG;

	call	esi
	cmp	DWORD PTR [eax], 104			; 00000068H
	jne	SHORT $LN11@xmlIOErr
	mov	edx, 1504				; 000005e0H
	jmp	$LN110@xmlIOErr
$LN11@xmlIOErr:

; 264  : #endif
; 265  : #ifdef EBUSY
; 266  :         else if (errno == EBUSY) code = XML_IO_EBUSY;

	call	esi
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $LN13@xmlIOErr
	mov	edx, 1505				; 000005e1H
	jmp	$LN110@xmlIOErr
$LN13@xmlIOErr:

; 267  : #endif
; 268  : #ifdef ECANCELED
; 269  :         else if (errno == ECANCELED) code = XML_IO_ECANCELED;

	call	esi
	cmp	DWORD PTR [eax], 105			; 00000069H
	jne	SHORT $LN15@xmlIOErr
	mov	edx, 1506				; 000005e2H
	jmp	$LN110@xmlIOErr
$LN15@xmlIOErr:

; 270  : #endif
; 271  : #ifdef ECHILD
; 272  :         else if (errno == ECHILD) code = XML_IO_ECHILD;

	call	esi
	cmp	DWORD PTR [eax], 10			; 0000000aH
	jne	SHORT $LN17@xmlIOErr
	mov	edx, 1507				; 000005e3H
	jmp	$LN110@xmlIOErr
$LN17@xmlIOErr:

; 273  : #endif
; 274  : #ifdef EDEADLK
; 275  :         else if (errno == EDEADLK) code = XML_IO_EDEADLK;

	call	esi
	cmp	DWORD PTR [eax], 36			; 00000024H
	jne	SHORT $LN19@xmlIOErr
	mov	edx, 1508				; 000005e4H
	jmp	$LN110@xmlIOErr
$LN19@xmlIOErr:

; 276  : #endif
; 277  : #ifdef EDOM
; 278  :         else if (errno == EDOM) code = XML_IO_EDOM;

	call	esi
	cmp	DWORD PTR [eax], 33			; 00000021H
	jne	SHORT $LN21@xmlIOErr
	mov	edx, 1509				; 000005e5H
	jmp	$LN110@xmlIOErr
$LN21@xmlIOErr:

; 279  : #endif
; 280  : #ifdef EEXIST
; 281  :         else if (errno == EEXIST) code = XML_IO_EEXIST;

	call	esi
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN23@xmlIOErr
	mov	edx, 1510				; 000005e6H
	jmp	$LN110@xmlIOErr
$LN23@xmlIOErr:

; 282  : #endif
; 283  : #ifdef EFAULT
; 284  :         else if (errno == EFAULT) code = XML_IO_EFAULT;

	call	esi
	cmp	DWORD PTR [eax], 14			; 0000000eH
	jne	SHORT $LN25@xmlIOErr
	mov	edx, 1511				; 000005e7H
	jmp	$LN110@xmlIOErr
$LN25@xmlIOErr:

; 285  : #endif
; 286  : #ifdef EFBIG
; 287  :         else if (errno == EFBIG) code = XML_IO_EFBIG;

	call	esi
	cmp	DWORD PTR [eax], 27			; 0000001bH
	jne	SHORT $LN27@xmlIOErr
	mov	edx, 1512				; 000005e8H
	jmp	$LN110@xmlIOErr
$LN27@xmlIOErr:

; 288  : #endif
; 289  : #ifdef EINPROGRESS
; 290  :         else if (errno == EINPROGRESS) code = XML_IO_EINPROGRESS;

	call	esi
	cmp	DWORD PTR [eax], 112			; 00000070H
	je	$LN111@xmlIOErr

; 291  : #endif
; 292  : #ifdef EINTR
; 293  :         else if (errno == EINTR) code = XML_IO_EINTR;

	call	esi
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN31@xmlIOErr
	mov	edx, 1514				; 000005eaH
	jmp	$LN110@xmlIOErr
$LN31@xmlIOErr:

; 294  : #endif
; 295  : #ifdef EINVAL
; 296  :         else if (errno == EINVAL) code = XML_IO_EINVAL;

	call	esi
	cmp	DWORD PTR [eax], 22			; 00000016H
	jne	SHORT $LN33@xmlIOErr
	mov	edx, 1515				; 000005ebH
	jmp	$LN110@xmlIOErr
$LN33@xmlIOErr:

; 297  : #endif
; 298  : #ifdef EIO
; 299  :         else if (errno == EIO) code = XML_IO_EIO;

	call	esi
	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN35@xmlIOErr
	mov	edx, 1516				; 000005ecH
	jmp	$LN110@xmlIOErr
$LN35@xmlIOErr:

; 300  : #endif
; 301  : #ifdef EISDIR
; 302  :         else if (errno == EISDIR) code = XML_IO_EISDIR;

	call	esi
	cmp	DWORD PTR [eax], 21			; 00000015H
	jne	SHORT $LN37@xmlIOErr
	mov	edx, 1517				; 000005edH
	jmp	$LN110@xmlIOErr
$LN37@xmlIOErr:

; 303  : #endif
; 304  : #ifdef EMFILE
; 305  :         else if (errno == EMFILE) code = XML_IO_EMFILE;

	call	esi
	cmp	DWORD PTR [eax], 24			; 00000018H
	jne	SHORT $LN39@xmlIOErr
	mov	edx, 1518				; 000005eeH
	jmp	$LN110@xmlIOErr
$LN39@xmlIOErr:

; 306  : #endif
; 307  : #ifdef EMLINK
; 308  :         else if (errno == EMLINK) code = XML_IO_EMLINK;

	call	esi
	cmp	DWORD PTR [eax], 31			; 0000001fH
	jne	SHORT $LN41@xmlIOErr
	mov	edx, 1519				; 000005efH
	jmp	$LN110@xmlIOErr
$LN41@xmlIOErr:

; 309  : #endif
; 310  : #ifdef EMSGSIZE
; 311  :         else if (errno == EMSGSIZE) code = XML_IO_EMSGSIZE;

	call	esi
	cmp	DWORD PTR [eax], 115			; 00000073H
	jne	SHORT $LN43@xmlIOErr
	mov	edx, 1520				; 000005f0H
	jmp	$LN110@xmlIOErr
$LN43@xmlIOErr:

; 312  : #endif
; 313  : #ifdef ENAMETOOLONG
; 314  :         else if (errno == ENAMETOOLONG) code = XML_IO_ENAMETOOLONG;

	call	esi
	cmp	DWORD PTR [eax], 38			; 00000026H
	jne	SHORT $LN45@xmlIOErr
	mov	edx, 1521				; 000005f1H
	jmp	$LN110@xmlIOErr
$LN45@xmlIOErr:

; 315  : #endif
; 316  : #ifdef ENFILE
; 317  :         else if (errno == ENFILE) code = XML_IO_ENFILE;

	call	esi
	cmp	DWORD PTR [eax], 23			; 00000017H
	jne	SHORT $LN47@xmlIOErr
	mov	edx, 1522				; 000005f2H
	jmp	$LN110@xmlIOErr
$LN47@xmlIOErr:

; 318  : #endif
; 319  : #ifdef ENODEV
; 320  :         else if (errno == ENODEV) code = XML_IO_ENODEV;

	call	esi
	cmp	DWORD PTR [eax], 19			; 00000013H
	jne	SHORT $LN49@xmlIOErr
	mov	edx, 1523				; 000005f3H
	jmp	$LN110@xmlIOErr
$LN49@xmlIOErr:

; 321  : #endif
; 322  : #ifdef ENOENT
; 323  :         else if (errno == ENOENT) code = XML_IO_ENOENT;

	call	esi
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN51@xmlIOErr
	mov	edx, 1524				; 000005f4H
	jmp	$LN110@xmlIOErr
$LN51@xmlIOErr:

; 324  : #endif
; 325  : #ifdef ENOEXEC
; 326  :         else if (errno == ENOEXEC) code = XML_IO_ENOEXEC;

	call	esi
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN53@xmlIOErr
	mov	edx, 1525				; 000005f5H
	jmp	$LN110@xmlIOErr
$LN53@xmlIOErr:

; 327  : #endif
; 328  : #ifdef ENOLCK
; 329  :         else if (errno == ENOLCK) code = XML_IO_ENOLCK;

	call	esi
	cmp	DWORD PTR [eax], 39			; 00000027H
	jne	SHORT $LN55@xmlIOErr
	mov	edx, 1526				; 000005f6H
	jmp	$LN110@xmlIOErr
$LN55@xmlIOErr:

; 330  : #endif
; 331  : #ifdef ENOMEM
; 332  :         else if (errno == ENOMEM) code = XML_IO_ENOMEM;

	call	esi
	cmp	DWORD PTR [eax], 12			; 0000000cH
	jne	SHORT $LN57@xmlIOErr
	mov	edx, 1527				; 000005f7H
	jmp	$LN110@xmlIOErr
$LN57@xmlIOErr:

; 333  : #endif
; 334  : #ifdef ENOSPC
; 335  :         else if (errno == ENOSPC) code = XML_IO_ENOSPC;

	call	esi
	cmp	DWORD PTR [eax], 28			; 0000001cH
	jne	SHORT $LN59@xmlIOErr
	mov	edx, 1528				; 000005f8H
	jmp	$LN110@xmlIOErr
$LN59@xmlIOErr:

; 336  : #endif
; 337  : #ifdef ENOSYS
; 338  :         else if (errno == ENOSYS) code = XML_IO_ENOSYS;

	call	esi
	cmp	DWORD PTR [eax], 40			; 00000028H
	jne	SHORT $LN61@xmlIOErr
	mov	edx, 1529				; 000005f9H
	jmp	$LN110@xmlIOErr
$LN61@xmlIOErr:

; 339  : #endif
; 340  : #ifdef ENOTDIR
; 341  :         else if (errno == ENOTDIR) code = XML_IO_ENOTDIR;

	call	esi
	cmp	DWORD PTR [eax], 20			; 00000014H
	jne	SHORT $LN63@xmlIOErr
	mov	edx, 1530				; 000005faH
	jmp	$LN110@xmlIOErr
$LN63@xmlIOErr:

; 342  : #endif
; 343  : #ifdef ENOTEMPTY
; 344  :         else if (errno == ENOTEMPTY) code = XML_IO_ENOTEMPTY;

	call	esi
	cmp	DWORD PTR [eax], 41			; 00000029H
	jne	SHORT $LN65@xmlIOErr
	mov	edx, 1531				; 000005fbH
	jmp	$LN110@xmlIOErr
$LN65@xmlIOErr:

; 345  : #endif
; 346  : #ifdef ENOTSUP
; 347  :         else if (errno == ENOTSUP) code = XML_IO_ENOTSUP;

	call	esi
	cmp	DWORD PTR [eax], 129			; 00000081H
	jne	SHORT $LN67@xmlIOErr
	mov	edx, 1532				; 000005fcH
	jmp	$LN110@xmlIOErr
$LN67@xmlIOErr:

; 348  : #endif
; 349  : #ifdef ENOTTY
; 350  :         else if (errno == ENOTTY) code = XML_IO_ENOTTY;

	call	esi
	cmp	DWORD PTR [eax], 25			; 00000019H
	jne	SHORT $LN69@xmlIOErr
	mov	edx, 1533				; 000005fdH
	jmp	$LN110@xmlIOErr
$LN69@xmlIOErr:

; 351  : #endif
; 352  : #ifdef ENXIO
; 353  :         else if (errno == ENXIO) code = XML_IO_ENXIO;

	call	esi
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN71@xmlIOErr
	mov	edx, 1534				; 000005feH
	jmp	$LN110@xmlIOErr
$LN71@xmlIOErr:

; 354  : #endif
; 355  : #ifdef EPERM
; 356  :         else if (errno == EPERM) code = XML_IO_EPERM;

	call	esi
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN73@xmlIOErr
	mov	edx, 1535				; 000005ffH
	jmp	$LN110@xmlIOErr
$LN73@xmlIOErr:

; 357  : #endif
; 358  : #ifdef EPIPE
; 359  :         else if (errno == EPIPE) code = XML_IO_EPIPE;

	call	esi
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	SHORT $LN75@xmlIOErr
	mov	edx, 1536				; 00000600H
	jmp	$LN110@xmlIOErr
$LN75@xmlIOErr:

; 360  : #endif
; 361  : #ifdef ERANGE
; 362  :         else if (errno == ERANGE) code = XML_IO_ERANGE;

	call	esi
	cmp	DWORD PTR [eax], 34			; 00000022H
	jne	SHORT $LN77@xmlIOErr
	mov	edx, 1537				; 00000601H
	jmp	$LN110@xmlIOErr
$LN77@xmlIOErr:

; 363  : #endif
; 364  : #ifdef EROFS
; 365  :         else if (errno == EROFS) code = XML_IO_EROFS;

	call	esi
	cmp	DWORD PTR [eax], 30			; 0000001eH
	jne	SHORT $LN79@xmlIOErr
	mov	edx, 1538				; 00000602H
	jmp	$LN110@xmlIOErr
$LN79@xmlIOErr:

; 366  : #endif
; 367  : #ifdef ESPIPE
; 368  :         else if (errno == ESPIPE) code = XML_IO_ESPIPE;

	call	esi
	cmp	DWORD PTR [eax], 29			; 0000001dH
	jne	SHORT $LN81@xmlIOErr
	mov	edx, 1539				; 00000603H
	jmp	$LN110@xmlIOErr
$LN81@xmlIOErr:

; 369  : #endif
; 370  : #ifdef ESRCH
; 371  :         else if (errno == ESRCH) code = XML_IO_ESRCH;

	call	esi
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN83@xmlIOErr
	mov	edx, 1540				; 00000604H
	jmp	$LN110@xmlIOErr
$LN83@xmlIOErr:

; 372  : #endif
; 373  : #ifdef ETIMEDOUT
; 374  :         else if (errno == ETIMEDOUT) code = XML_IO_ETIMEDOUT;

	call	esi
	cmp	DWORD PTR [eax], 138			; 0000008aH
	je	SHORT $LN112@xmlIOErr

; 375  : #endif
; 376  : #ifdef EXDEV
; 377  :         else if (errno == EXDEV) code = XML_IO_EXDEV;

	call	esi
	cmp	DWORD PTR [eax], 18			; 00000012H
	jne	SHORT $LN87@xmlIOErr
	mov	edx, 1542				; 00000606H
	jmp	$LN110@xmlIOErr
$LN87@xmlIOErr:

; 378  : #endif
; 379  : #ifdef ENOTSOCK
; 380  :         else if (errno == ENOTSOCK) code = XML_IO_ENOTSOCK;

	call	esi
	cmp	DWORD PTR [eax], 128			; 00000080H
	jne	SHORT $LN89@xmlIOErr
	mov	edx, 1550				; 0000060eH
	jmp	SHORT $LN110@xmlIOErr
$LN89@xmlIOErr:

; 381  : #endif
; 382  : #ifdef EISCONN
; 383  :         else if (errno == EISCONN) code = XML_IO_EISCONN;

	call	esi
	cmp	DWORD PTR [eax], 113			; 00000071H
	jne	SHORT $LN91@xmlIOErr
	mov	edx, 1551				; 0000060fH
	jmp	SHORT $LN110@xmlIOErr
$LN91@xmlIOErr:

; 384  : #endif
; 385  : #ifdef ECONNREFUSED
; 386  :         else if (errno == ECONNREFUSED) code = XML_IO_ECONNREFUSED;

	call	esi
	cmp	DWORD PTR [eax], 107			; 0000006bH
	jne	SHORT $LN93@xmlIOErr
	mov	edx, 1552				; 00000610H
	jmp	SHORT $LN110@xmlIOErr
$LN93@xmlIOErr:

; 387  : #endif
; 388  : #ifdef ETIMEDOUT
; 389  :         else if (errno == ETIMEDOUT) code = XML_IO_ETIMEDOUT;

	call	esi
	cmp	DWORD PTR [eax], 138			; 0000008aH
	jne	SHORT $LN95@xmlIOErr
$LN112@xmlIOErr:
	mov	edx, 1541				; 00000605H
	jmp	SHORT $LN110@xmlIOErr
$LN95@xmlIOErr:

; 390  : #endif
; 391  : #ifdef ENETUNREACH
; 392  :         else if (errno == ENETUNREACH) code = XML_IO_ENETUNREACH;

	call	esi
	cmp	DWORD PTR [eax], 118			; 00000076H
	jne	SHORT $LN97@xmlIOErr
	mov	edx, 1553				; 00000611H
	jmp	SHORT $LN110@xmlIOErr
$LN97@xmlIOErr:

; 393  : #endif
; 394  : #ifdef EADDRINUSE
; 395  :         else if (errno == EADDRINUSE) code = XML_IO_EADDRINUSE;

	call	esi
	cmp	DWORD PTR [eax], 100			; 00000064H
	jne	SHORT $LN99@xmlIOErr
	mov	edx, 1554				; 00000612H
	jmp	SHORT $LN110@xmlIOErr
$LN99@xmlIOErr:

; 396  : #endif
; 397  : #ifdef EINPROGRESS
; 398  :         else if (errno == EINPROGRESS) code = XML_IO_EINPROGRESS;

	call	esi
	cmp	DWORD PTR [eax], 112			; 00000070H
	jne	SHORT $LN101@xmlIOErr
$LN111@xmlIOErr:
	mov	edx, 1513				; 000005e9H
	jmp	SHORT $LN110@xmlIOErr
$LN101@xmlIOErr:

; 399  : #endif
; 400  : #ifdef EALREADY
; 401  :         else if (errno == EALREADY) code = XML_IO_EALREADY;

	call	esi
	cmp	DWORD PTR [eax], 103			; 00000067H
	jne	SHORT $LN103@xmlIOErr
	mov	edx, 1555				; 00000613H
	jmp	SHORT $LN110@xmlIOErr
$LN103@xmlIOErr:

; 402  : #endif
; 403  : #ifdef EAFNOSUPPORT
; 404  :         else if (errno == EAFNOSUPPORT) code = XML_IO_EAFNOSUPPORT;

	call	esi
	mov	edx, 1500				; 000005dcH
	mov	ecx, 1556				; 00000614H
	cmp	DWORD PTR [eax], 102			; 00000066H
	cmove	edx, ecx
$LN110@xmlIOErr:
	pop	esi
$LN105@xmlIOErr:

; 405  : #endif
; 406  :         else code = XML_IO_UNKNOWN;
; 407  : #endif /* HAVE_ERRNO_H */
; 408  :     }
; 409  :     idx = 0;
; 410  :     if (code >= XML_IO_UNKNOWN) idx = code - XML_IO_UNKNOWN;
; 411  :     if (idx >= (sizeof(IOerr) / sizeof(IOerr[0]))) idx = 0;
; 412  : 
; 413  :     __xmlSimpleError(domain, code, NULL, IOerr[idx], extra);

	push	DWORD PTR _extra$[ebp]
	xor	eax, eax
	lea	ecx, DWORD PTR [edx-1500]
	cmp	edx, 1500				; 000005dcH
	cmovl	ecx, eax
	cmp	ecx, 57					; 00000039H
	sbb	eax, eax
	and	eax, ecx
	push	DWORD PTR _IOerr[eax*4]
	push	0
	push	edx
	push	DWORD PTR _domain$[ebp]
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 414  : }

	pop	ebp
	ret	0
___xmlIOErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
