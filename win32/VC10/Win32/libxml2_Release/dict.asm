; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\dict.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__75FE04D0_dict@c DB 01H
msvcjmc	ENDS
PUBLIC	___xmlInitializeDict
PUBLIC	_xmlInitializeDict
PUBLIC	_xmlDictCreate
PUBLIC	_xmlDictSetLimit
PUBLIC	_xmlDictGetUsage
PUBLIC	_xmlDictCreateSub
PUBLIC	_xmlDictReference
PUBLIC	_xmlDictFree
PUBLIC	_xmlDictLookup
PUBLIC	_xmlDictExists
PUBLIC	_xmlDictQLookup
PUBLIC	_xmlDictOwns
PUBLIC	_xmlDictSize
PUBLIC	_xmlDictCleanup
PUBLIC	__JustMyCode_Default
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrQEqual:PROC
EXTRN	_xmlNewRMutex:PROC
EXTRN	_xmlRMutexLock:PROC
EXTRN	_xmlRMutexUnlock:PROC
EXTRN	_xmlFreeRMutex:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_xmlDictMutex DD 01H DUP (?)
_xmlDictInitialized DD 01H DUP (?)
_BSS	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictGrow
_TEXT	SEGMENT
tv875 = -24						; size = 4
_ret$1$ = -20						; size = 4
tv892 = -16						; size = 4
tv886 = -16						; size = 4
_olddict$1$ = -12					; size = 4
tv894 = -8						; size = 4
tv872 = -8						; size = 4
_oldsize$1$ = -4					; size = 4
_dict$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlDictGrow PROC					; COMDAT

; 660  : xmlDictGrow(xmlDictPtr dict, size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	mov	DWORD PTR _ret$1$[ebp], 0
	test	edi, edi
	je	$LN44@xmlDictGro

; 661  :     unsigned long key, okey;
; 662  :     size_t oldsize, i;
; 663  :     xmlDictEntryPtr iter, next;
; 664  :     struct _xmlDictEntry *olddict;
; 665  : #ifdef DEBUG_GROW
; 666  :     unsigned long nbElem = 0;
; 667  : #endif
; 668  :     int ret = 0;
; 669  :     int keep_keys = 1;
; 670  : 
; 671  :     if (dict == NULL)
; 672  : 	return(-1);
; 673  :     if (size < 8)

	mov	esi, DWORD PTR _size$[ebp]
	cmp	esi, 8
	jb	$LN44@xmlDictGro

; 674  :         return(-1);
; 675  :     if (size > 8 * 2048)

	cmp	esi, 16384				; 00004000H
	ja	$LN44@xmlDictGro

; 676  : 	return(-1);
; 677  : 
; 678  : #ifdef DICT_DEBUG_PATTERNS
; 679  :     fprintf(stderr, "*");
; 680  : #endif
; 681  : 
; 682  :     oldsize = dict->size;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _oldsize$1$[ebp], eax

; 683  :     olddict = dict->dict;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _olddict$1$[ebp], eax

; 684  :     if (olddict == NULL)

	test	eax, eax
	je	$LN44@xmlDictGro

; 686  :     if (oldsize == MIN_DICT_SIZE)
; 687  :         keep_keys = 0;
; 688  : 
; 689  :     dict->dict = xmlMalloc(size * sizeof(xmlDictEntry));

	push	ebx
	lea	ebx, DWORD PTR [esi+esi*4]
	shl	ebx, 2
	push	ebx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+4], eax

; 690  :     if (dict->dict == NULL) {

	test	eax, eax
	jne	SHORT $LN15@xmlDictGro

; 691  : 	dict->dict = olddict;

	mov	esi, DWORD PTR _olddict$1$[ebp]

; 692  : 	return(-1);

	or	eax, -1
	pop	ebx
	mov	DWORD PTR [edi+4], esi
	pop	edi

; 783  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlDictGro:

; 693  :     }
; 694  :     memset(dict->dict, 0, size * sizeof(xmlDictEntry));

	push	ebx
	push	0
	push	eax
	call	_memset

; 695  :     dict->size = size;
; 696  : 
; 697  :     /*	If the two loops are merged, there would be situations where
; 698  : 	a new entry needs to allocated and data copied into it from
; 699  : 	the main dict. It is nicer to run through the array twice, first
; 700  : 	copying all the elements in the main array (less probability of
; 701  : 	allocate) and then the rest, so we only free in the second loop.
; 702  :     */
; 703  :     for (i = 0; i < oldsize; i++) {

	mov	ecx, DWORD PTR _oldsize$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+8], esi
	test	ecx, ecx
	je	$LN6@xmlDictGro

; 693  :     }
; 694  :     memset(dict->dict, 0, size * sizeof(xmlDictEntry));

	mov	esi, DWORD PTR _olddict$1$[ebp]
	mov	eax, ecx
	add	esi, 4
	mov	DWORD PTR tv894[ebp], ecx
	npad	3
$LL4@xmlDictGro:

; 704  : 	if (olddict[i].valid == 0)

	cmp	DWORD PTR [esi+8], 0
	je	$LN2@xmlDictGro

; 705  : 	    continue;
; 706  : 
; 707  : 	if (keep_keys)

	cmp	ecx, 128				; 00000080H
	je	SHORT $LN17@xmlDictGro

; 708  : 	    okey = olddict[i].okey;

	mov	ebx, DWORD PTR [esi+12]
	jmp	SHORT $LN29@xmlDictGro
$LN17@xmlDictGro:

; 709  : 	else
; 710  : 	    okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	jne	SHORT $LN28@xmlDictGro
	call	_xmlDictComputeFastKey
	jmp	SHORT $LN46@xmlDictGro
$LN28@xmlDictGro:
	call	_xmlDictComputeBigKey
$LN46@xmlDictGro:

; 711  : 	key = okey % dict->size;

	mov	ebx, eax
	add	esp, 12					; 0000000cH
$LN29@xmlDictGro:
	xor	edx, edx
	mov	eax, ebx
	div	DWORD PTR [edi+8]

; 712  : 
; 713  : 	if (dict->dict[key].valid == 0) {

	lea	ecx, DWORD PTR [edx+edx*4]
	mov	edx, DWORD PTR [edi+4]
	shl	ecx, 2
	mov	DWORD PTR tv886[ebp], ecx
	cmp	DWORD PTR [edx+ecx+12], 0
	jne	SHORT $LN19@xmlDictGro

; 714  : 	    memcpy(&(dict->dict[key]), &(olddict[i]), sizeof(xmlDictEntry));

	movups	xmm0, XMMWORD PTR [esi-4]
	movups	XMMWORD PTR [edx+ecx], xmm0
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edx+ecx+16], eax

; 715  : 	    dict->dict[key].next = NULL;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+eax], 0

; 716  : 	    dict->dict[key].okey = okey;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+eax+16], ebx

; 717  : 	} else {

	jmp	SHORT $LN47@xmlDictGro
$LN19@xmlDictGro:

; 718  : 	    xmlDictEntryPtr entry;
; 719  : 
; 720  : 	    entry = xmlMalloc(sizeof(xmlDictEntry));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 721  : 	    if (entry != NULL) {

	test	ecx, ecx
	je	SHORT $LN21@xmlDictGro

; 722  : 		entry->name = olddict[i].name;

	mov	eax, DWORD PTR [esi]

; 723  : 		entry->len = olddict[i].len;
; 724  : 		entry->okey = okey;
; 725  : 		entry->next = dict->dict[key].next;

	mov	edx, DWORD PTR tv886[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+16], ebx
	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], eax

; 726  : 		entry->valid = 1;

	mov	DWORD PTR [ecx+12], 1

; 727  : 		dict->dict[key].next = entry;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+eax], ecx

; 728  : 	    } else {

	jmp	SHORT $LN47@xmlDictGro
$LN21@xmlDictGro:

; 729  : 	        /*
; 730  : 		 * we don't have much ways to alert from herei
; 731  : 		 * result is losing an entry and unicity guarantee
; 732  : 		 */
; 733  : 	        ret = -1;

	mov	DWORD PTR _ret$1$[ebp], -1
$LN47@xmlDictGro:

; 695  :     dict->size = size;
; 696  : 
; 697  :     /*	If the two loops are merged, there would be situations where
; 698  : 	a new entry needs to allocated and data copied into it from
; 699  : 	the main dict. It is nicer to run through the array twice, first
; 700  : 	copying all the elements in the main array (less probability of
; 701  : 	allocate) and then the rest, so we only free in the second loop.
; 702  :     */
; 703  :     for (i = 0; i < oldsize; i++) {

	mov	eax, DWORD PTR tv894[ebp]
	mov	ecx, DWORD PTR _oldsize$1$[ebp]
$LN2@xmlDictGro:
	add	esi, 20					; 00000014H
	sub	eax, 1
	mov	DWORD PTR tv894[ebp], eax
	jne	$LL4@xmlDictGro

; 734  : 	    }
; 735  : 	}
; 736  : #ifdef DEBUG_GROW
; 737  : 	nbElem++;
; 738  : #endif
; 739  :     }
; 740  : 
; 741  :     for (i = 0; i < oldsize; i++) {

	mov	eax, DWORD PTR _olddict$1$[ebp]
	mov	edx, ecx
	mov	DWORD PTR tv872[ebp], eax
	mov	DWORD PTR tv892[ebp], ecx
	npad	8
$LL7@xmlDictGro:

; 742  : 	iter = olddict[i].next;

	mov	esi, DWORD PTR [eax]

; 743  : 	while (iter) {

	test	esi, esi
	je	$LN5@xmlDictGro
	npad	6
$LL8@xmlDictGro:

; 744  : 	    next = iter->next;

	mov	ebx, DWORD PTR [esi]

; 745  : 
; 746  : 	    /*
; 747  : 	     * put back the entry in the new dict
; 748  : 	     */
; 749  : 
; 750  : 	    if (keep_keys)

	cmp	ecx, 128				; 00000080H
	je	SHORT $LN23@xmlDictGro

; 751  : 		okey = iter->okey;

	mov	ecx, DWORD PTR [esi+16]
	jmp	SHORT $LN31@xmlDictGro
$LN23@xmlDictGro:

; 752  : 	    else
; 753  : 		okey = xmlDictComputeKey(dict, iter->name, iter->len);

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	push	edx
	jne	SHORT $LN30@xmlDictGro
	call	_xmlDictComputeFastKey
	jmp	SHORT $LN48@xmlDictGro
$LN30@xmlDictGro:
	call	_xmlDictComputeBigKey
$LN48@xmlDictGro:

; 754  : 	    key = okey % dict->size;

	mov	ecx, eax
	add	esp, 12					; 0000000cH
$LN31@xmlDictGro:
	xor	edx, edx
	mov	eax, ecx
	div	DWORD PTR [edi+8]

; 755  : 	    if (dict->dict[key].valid == 0) {

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	edx, 2
	add	eax, edx
	mov	DWORD PTR tv875[ebp], eax
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN25@xmlDictGro

; 756  : 		memcpy(&(dict->dict[key]), iter, sizeof(xmlDictEntry));

	movups	xmm0, XMMWORD PTR [esi]
	mov	edi, DWORD PTR tv875[ebp]

; 757  : 		dict->dict[key].next = NULL;
; 758  : 		dict->dict[key].valid = 1;
; 759  : 		dict->dict[key].okey = okey;
; 760  : 		xmlFree(iter);

	push	esi
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	edi, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+eax], 0
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+eax+12], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+eax+16], ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 761  : 	    } else {

	jmp	SHORT $LN26@xmlDictGro
$LN25@xmlDictGro:

; 762  : 		iter->next = dict->dict[key].next;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 763  : 		iter->okey = okey;

	mov	DWORD PTR [esi+16], ecx

; 764  : 		dict->dict[key].next = iter;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+eax], esi
$LN26@xmlDictGro:

; 765  : 	    }
; 766  : 
; 767  : #ifdef DEBUG_GROW
; 768  : 	    nbElem++;
; 769  : #endif
; 770  : 
; 771  : 	    iter = next;

	mov	ecx, DWORD PTR _oldsize$1$[ebp]
	mov	esi, ebx
	test	ebx, ebx
	jne	$LL8@xmlDictGro
	mov	eax, DWORD PTR tv872[ebp]
	mov	edx, DWORD PTR tv892[ebp]
$LN5@xmlDictGro:

; 734  : 	    }
; 735  : 	}
; 736  : #ifdef DEBUG_GROW
; 737  : 	nbElem++;
; 738  : #endif
; 739  :     }
; 740  : 
; 741  :     for (i = 0; i < oldsize; i++) {

	add	eax, 20					; 00000014H
	sub	edx, 1
	mov	DWORD PTR tv872[ebp], eax
	mov	DWORD PTR tv892[ebp], edx
	jne	$LL7@xmlDictGro
$LN6@xmlDictGro:

; 772  : 	}
; 773  :     }
; 774  : 
; 775  :     xmlFree(olddict);

	push	DWORD PTR _olddict$1$[ebp]
	call	DWORD PTR _xmlFree

; 776  : 
; 777  : #ifdef DEBUG_GROW
; 778  :     xmlGenericError(xmlGenericErrorContext,
; 779  : 	    "xmlDictGrow : from %lu to %lu, %u elems\n", oldsize, size, nbElem);
; 780  : #endif
; 781  : 
; 782  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 4
	pop	ebx
	pop	edi

; 783  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlDictGro:
	pop	edi

; 685  :         return(-1);

	or	eax, -1

; 783  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictGrow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeFastQKey
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_plen$ = 12						; size = 4
_name$ = 16						; size = 4
_len$ = 20						; size = 4
_seed$ = 24						; size = 4
_xmlDictComputeFastQKey PROC				; COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _plen$[ebp]
	mov	edi, DWORD PTR _prefix$[ebp]
	test	ebx, ebx
	jne	SHORT $LN6@xmlDictCom

; 490  :     unsigned long value = (unsigned long) seed;
; 491  : 
; 492  :     if (plen == 0)
; 493  : 	value += 30 * (unsigned long) ':';

	mov	ecx, 1740				; 000006ccH
	jmp	SHORT $LN7@xmlDictCom
$LN6@xmlDictCom:

; 494  :     else
; 495  : 	value += 30 * (*prefix);

	movzx	eax, BYTE PTR [edi]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	add	ecx, ecx
$LN7@xmlDictCom:

; 496  : 
; 497  :     if (len > 10) {

	mov	edx, DWORD PTR _seed$[ebp]
	mov	esi, DWORD PTR _name$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN10@xmlDictCom

; 498  :         int offset = len - (plen + 1 + 1);

	mov	eax, ecx

; 499  : 	if (offset < 0)
; 500  : 	    offset = len - (10 + 1);
; 501  : 	value += name[offset];

	add	ecx, -11				; fffffff5H
	sub	eax, ebx
	add	eax, -2					; fffffffeH
	cmovns	ecx, eax
	movzx	eax, BYTE PTR [ecx+esi]

; 502  :         len = 10;

	mov	ecx, 10					; 0000000aH
	add	edx, eax

; 503  : 	if (plen > 10)

	mov	eax, ecx
	cmp	ebx, eax
	cmovg	ebx, eax
$LN10@xmlDictCom:

; 504  : 	    plen = 10;
; 505  :     }
; 506  :     switch (plen) {

	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, 9
	ja	SHORT $LN21@xmlDictCom
	jmp	DWORD PTR $LN36@xmlDictCom[eax*4]
$LN11@xmlDictCom:

; 507  :         case 10: value += prefix[9];

	movzx	eax, BYTE PTR [edi+9]
	add	edx, eax
$LN12@xmlDictCom:

; 508  :         /* Falls through. */
; 509  :         case 9: value += prefix[8];

	movzx	eax, BYTE PTR [edi+8]
	add	edx, eax
$LN13@xmlDictCom:

; 510  :         /* Falls through. */
; 511  :         case 8: value += prefix[7];

	movzx	eax, BYTE PTR [edi+7]
	add	edx, eax
$LN14@xmlDictCom:

; 512  :         /* Falls through. */
; 513  :         case 7: value += prefix[6];

	movzx	eax, BYTE PTR [edi+6]
	add	edx, eax
$LN15@xmlDictCom:

; 514  :         /* Falls through. */
; 515  :         case 6: value += prefix[5];

	movzx	eax, BYTE PTR [edi+5]
	add	edx, eax
$LN16@xmlDictCom:

; 516  :         /* Falls through. */
; 517  :         case 5: value += prefix[4];

	movzx	eax, BYTE PTR [edi+4]
	add	edx, eax
$LN17@xmlDictCom:

; 518  :         /* Falls through. */
; 519  :         case 4: value += prefix[3];

	movzx	eax, BYTE PTR [edi+3]
	add	edx, eax
$LN18@xmlDictCom:

; 520  :         /* Falls through. */
; 521  :         case 3: value += prefix[2];

	movzx	eax, BYTE PTR [edi+2]
	add	edx, eax
$LN19@xmlDictCom:

; 522  :         /* Falls through. */
; 523  :         case 2: value += prefix[1];

	movzx	eax, BYTE PTR [edi+1]
	add	edx, eax
$LN20@xmlDictCom:

; 524  :         /* Falls through. */
; 525  :         case 1: value += prefix[0];

	movzx	eax, BYTE PTR [edi]
	add	edx, eax
$LN21@xmlDictCom:

; 526  :         /* Falls through. */
; 527  :         default: break;
; 528  :     }
; 529  :     len -= plen;

	sub	ecx, ebx

; 530  :     if (len > 0) {
; 531  :         value += (unsigned long) ':';
; 532  : 	len--;
; 533  :     }
; 534  :     switch (len) {

	lea	edi, DWORD PTR [edx+58]
	test	ecx, ecx
	cmovle	edi, edx
	lea	eax, DWORD PTR [ecx-1]
	mov	edx, edi
	cmovle	eax, ecx
	dec	eax
	cmp	eax, 9
	ja	SHORT $LN33@xmlDictCom
	jmp	DWORD PTR $LN37@xmlDictCom[eax*4]
$LN23@xmlDictCom:

; 535  :         case 10: value += name[9];

	movzx	edx, BYTE PTR [esi+9]
	add	edx, edi
$LN24@xmlDictCom:

; 536  :         /* Falls through. */
; 537  :         case 9: value += name[8];

	movzx	eax, BYTE PTR [esi+8]
	add	edx, eax
$LN25@xmlDictCom:

; 538  :         /* Falls through. */
; 539  :         case 8: value += name[7];

	movzx	eax, BYTE PTR [esi+7]
	add	edx, eax
$LN26@xmlDictCom:

; 540  :         /* Falls through. */
; 541  :         case 7: value += name[6];

	movzx	eax, BYTE PTR [esi+6]
	add	edx, eax
$LN27@xmlDictCom:

; 542  :         /* Falls through. */
; 543  :         case 6: value += name[5];

	movzx	eax, BYTE PTR [esi+5]
	add	edx, eax
$LN28@xmlDictCom:

; 544  :         /* Falls through. */
; 545  :         case 5: value += name[4];

	movzx	eax, BYTE PTR [esi+4]
	add	edx, eax
$LN29@xmlDictCom:

; 546  :         /* Falls through. */
; 547  :         case 4: value += name[3];

	movzx	eax, BYTE PTR [esi+3]
	add	edx, eax
$LN30@xmlDictCom:

; 548  :         /* Falls through. */
; 549  :         case 3: value += name[2];

	movzx	eax, BYTE PTR [esi+2]
	add	edx, eax
$LN31@xmlDictCom:

; 550  :         /* Falls through. */
; 551  :         case 2: value += name[1];

	movzx	ecx, BYTE PTR [esi+1]
	add	edx, ecx
$LN32@xmlDictCom:

; 552  :         /* Falls through. */
; 553  :         case 1: value += name[0];

	movzx	ecx, BYTE PTR [esi]
	add	edx, ecx
$LN33@xmlDictCom:

; 554  :         /* Falls through. */
; 555  :         default: break;
; 556  :     }
; 557  :     return(value);

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx

; 558  : }

	pop	ebp
	ret	0
	npad	1
$LN36@xmlDictCom:
	DD	$LN20@xmlDictCom
	DD	$LN19@xmlDictCom
	DD	$LN18@xmlDictCom
	DD	$LN17@xmlDictCom
	DD	$LN16@xmlDictCom
	DD	$LN15@xmlDictCom
	DD	$LN14@xmlDictCom
	DD	$LN13@xmlDictCom
	DD	$LN12@xmlDictCom
	DD	$LN11@xmlDictCom
$LN37@xmlDictCom:
	DD	$LN32@xmlDictCom
	DD	$LN31@xmlDictCom
	DD	$LN30@xmlDictCom
	DD	$LN29@xmlDictCom
	DD	$LN28@xmlDictCom
	DD	$LN27@xmlDictCom
	DD	$LN26@xmlDictCom
	DD	$LN25@xmlDictCom
	DD	$LN24@xmlDictCom
	DD	$LN23@xmlDictCom
_xmlDictComputeFastQKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeFastKey
_TEXT	SEGMENT
_name$ = 8						; size = 4
_namelen$ = 12						; size = 4
_seed$ = 16						; size = 4
_xmlDictComputeFastKey PROC				; COMDAT

; 444  : xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlDictCom

; 445  :     unsigned long value = seed;
; 446  : 
; 447  :     if (name == NULL) return(0);

	xor	eax, eax
	pop	esi

; 476  : }

	pop	ebp
	ret	0
$LN4@xmlDictCom:

; 448  :     value = *name;

	movzx	edx, BYTE PTR [esi]

; 449  :     value <<= 5;
; 450  :     if (namelen > 10) {

	mov	eax, DWORD PTR _namelen$[ebp]
	shl	edx, 5
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN5@xmlDictCom

; 451  :         value += name[namelen - 1];

	movzx	eax, BYTE PTR [esi+eax-1]
	add	edx, eax

; 452  :         namelen = 10;

	mov	eax, 10					; 0000000aH
$LN5@xmlDictCom:

; 453  :     }
; 454  :     switch (namelen) {

	add	eax, -2					; fffffffeH
	cmp	eax, 8
	ja	SHORT $LN15@xmlDictCom
	jmp	DWORD PTR $LN18@xmlDictCom[eax*4]
$LN6@xmlDictCom:

; 455  :         case 10: value += name[9];

	movzx	eax, BYTE PTR [esi+9]
	add	edx, eax
$LN7@xmlDictCom:

; 456  :         /* Falls through. */
; 457  :         case 9: value += name[8];

	movzx	eax, BYTE PTR [esi+8]
	add	edx, eax
$LN8@xmlDictCom:

; 458  :         /* Falls through. */
; 459  :         case 8: value += name[7];

	movzx	eax, BYTE PTR [esi+7]
	add	edx, eax
$LN9@xmlDictCom:

; 460  :         /* Falls through. */
; 461  :         case 7: value += name[6];

	movzx	eax, BYTE PTR [esi+6]
	add	edx, eax
$LN10@xmlDictCom:

; 462  :         /* Falls through. */
; 463  :         case 6: value += name[5];

	movzx	eax, BYTE PTR [esi+5]
	add	edx, eax
$LN11@xmlDictCom:

; 464  :         /* Falls through. */
; 465  :         case 5: value += name[4];

	movzx	eax, BYTE PTR [esi+4]
	add	edx, eax
$LN12@xmlDictCom:

; 466  :         /* Falls through. */
; 467  :         case 4: value += name[3];

	movzx	eax, BYTE PTR [esi+3]
	add	edx, eax
$LN13@xmlDictCom:

; 468  :         /* Falls through. */
; 469  :         case 3: value += name[2];

	movzx	ecx, BYTE PTR [esi+2]
	add	edx, ecx
$LN14@xmlDictCom:

; 470  :         /* Falls through. */
; 471  :         case 2: value += name[1];

	movzx	ecx, BYTE PTR [esi+1]
	add	edx, ecx
$LN15@xmlDictCom:

; 472  :         /* Falls through. */
; 473  :         default: break;
; 474  :     }
; 475  :     return(value);

	mov	eax, edx
	pop	esi

; 476  : }

	pop	ebp
	ret	0
	npad	2
$LN18@xmlDictCom:
	DD	$LN14@xmlDictCom
	DD	$LN13@xmlDictCom
	DD	$LN12@xmlDictCom
	DD	$LN11@xmlDictCom
	DD	$LN10@xmlDictCom
	DD	$LN9@xmlDictCom
	DD	$LN8@xmlDictCom
	DD	$LN7@xmlDictCom
	DD	$LN6@xmlDictCom
_xmlDictComputeFastKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeBigQKey
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_plen$ = 12						; size = 4
_name$ = 16						; size = 4
_len$ = 20						; size = 4
_seed$ = 24						; size = 4
_xmlDictComputeBigQKey PROC				; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _plen$[ebp]
	xor	edx, edx
	mov	ecx, DWORD PTR _seed$[ebp]
	test	esi, esi
	jle	SHORT $LN3@xmlDictCom
	mov	edi, DWORD PTR _prefix$[ebp]
	npad	2
$LL13@xmlDictCom:

; 410  :     uint32_t hash;
; 411  :     int i;
; 412  : 
; 413  :     hash = seed;
; 414  : 
; 415  :     for (i = 0;i < plen; i++) {
; 416  :         hash += prefix[i];

	movzx	eax, BYTE PTR [edx+edi]
	inc	edx

; 417  : 	hash += (hash << 10);

	add	eax, ecx
	imul	ecx, eax, 1025

; 418  : 	hash ^= (hash >> 6);

	mov	eax, ecx
	shr	eax, 6
	xor	ecx, eax
	cmp	edx, esi
	jl	SHORT $LL13@xmlDictCom
$LN3@xmlDictCom:

; 419  :     }
; 420  :     hash += ':';
; 421  :     hash += (hash << 10);
; 422  :     hash ^= (hash >> 6);
; 423  : 
; 424  :     for (i = 0;i < len; i++) {

	mov	esi, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR [ecx+58]
	imul	ecx, eax, 1025
	xor	edx, edx
	mov	eax, ecx
	shr	eax, 6
	xor	ecx, eax
	test	esi, esi
	jle	SHORT $LN6@xmlDictCom
	mov	edi, DWORD PTR _name$[ebp]
$LL15@xmlDictCom:

; 425  :         hash += name[i];

	movzx	eax, BYTE PTR [edx+edi]
	inc	edx

; 426  : 	hash += (hash << 10);

	add	eax, ecx
	imul	ecx, eax, 1025

; 427  : 	hash ^= (hash >> 6);

	mov	eax, ecx
	shr	eax, 6
	xor	ecx, eax
	cmp	edx, esi
	jl	SHORT $LL15@xmlDictCom
$LN6@xmlDictCom:

; 428  :     }
; 429  :     hash += (hash << 3);

	lea	ecx, DWORD PTR [ecx+ecx*8]

; 430  :     hash ^= (hash >> 11);

	mov	eax, ecx
	shr	eax, 11					; 0000000bH
	xor	eax, ecx

; 431  :     hash += (hash << 15);
; 432  : 
; 433  :     return hash;

	pop	edi
	imul	eax, eax, 32769
	pop	esi

; 434  : }

	pop	ebp
	ret	0
_xmlDictComputeBigQKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeBigKey
_TEXT	SEGMENT
_data$ = 8						; size = 4
_namelen$ = 12						; size = 4
_seed$ = 16						; size = 4
_xmlDictComputeBigKey PROC				; COMDAT

; 375  : xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _namelen$[ebp]
	test	esi, esi
	jle	SHORT $LN6@xmlDictCom

; 376  :     uint32_t hash;
; 377  :     int i;
; 378  : 
; 379  :     if (namelen <= 0 || data == NULL) return(0);

	mov	edi, DWORD PTR _data$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlDictCom

; 380  : 
; 381  :     hash = seed;

	mov	ecx, DWORD PTR _seed$[ebp]
	xor	edx, edx

; 382  : 
; 383  :     for (i = 0;i < namelen; i++) {

	test	esi, esi
	jle	SHORT $LN3@xmlDictCom
$LL10@xmlDictCom:

; 384  :         hash += data[i];

	movzx	eax, BYTE PTR [edx+edi]
	inc	edx

; 385  : 	hash += (hash << 10);

	add	eax, ecx
	imul	ecx, eax, 1025

; 386  : 	hash ^= (hash >> 6);

	mov	eax, ecx
	shr	eax, 6
	xor	ecx, eax
	cmp	edx, esi
	jl	SHORT $LL10@xmlDictCom
$LN3@xmlDictCom:

; 387  :     }
; 388  :     hash += (hash << 3);

	lea	ecx, DWORD PTR [ecx+ecx*8]

; 389  :     hash ^= (hash >> 11);

	mov	eax, ecx
	shr	eax, 11					; 0000000bH
	xor	eax, ecx
	pop	edi

; 390  :     hash += (hash << 15);

	imul	eax, eax, 32769

; 391  : 
; 392  :     return hash;
; 393  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlDictCom:
	pop	edi

; 376  :     uint32_t hash;
; 377  :     int i;
; 378  : 
; 379  :     if (namelen <= 0 || data == NULL) return(0);

	xor	eax, eax

; 391  : 
; 392  :     return hash;
; 393  : }

	pop	esi
	pop	ebp
	ret	0
_xmlDictComputeBigKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictAddQString
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_prefix$ = 12						; size = 4
_plen$ = 16						; size = 4
_name$ = 20						; size = 4
_namelen$ = 24						; size = 4
_xmlDictAddQString PROC					; COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	edx, edx
	xor	edi, edi
	cmp	DWORD PTR _prefix$[ebp], edx
	jne	SHORT $LN4@xmlDictAdd

; 308  :     xmlDictStringsPtr pool;
; 309  :     const xmlChar *ret;
; 310  :     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
; 311  :     size_t limit = 0;
; 312  : 
; 313  :     if (prefix == NULL) return(xmlDictAddString(dict, name, namelen));

	push	DWORD PTR _namelen$[ebp]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _dict$[ebp]
	call	_xmlDictAddString
	add	esp, 12					; 0000000cH
	pop	edi

; 361  : }

	pop	ebp
	ret	0
$LN4@xmlDictAdd:
	push	ebx

; 314  : 
; 315  : #ifdef DICT_DEBUG_PATTERNS
; 316  :     fprintf(stderr, "=");
; 317  : #endif
; 318  :     pool = dict->strings;

	mov	ebx, DWORD PTR _dict$[ebp]
	push	esi
	mov	esi, DWORD PTR [ebx+16]

; 319  :     while (pool != NULL) {

	test	esi, esi
	je	SHORT $LN19@xmlDictAdd
	mov	ebx, DWORD PTR _namelen$[ebp]
	inc	ebx
	add	ebx, DWORD PTR _plen$[ebp]
	npad	2
$LL2@xmlDictAdd:

; 320  : 	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	ja	SHORT $found_pool$24

; 321  : 	    goto found_pool;
; 322  : 	if (pool->size > size) size = pool->size;

	mov	ecx, DWORD PTR [esi+12]

; 323  :         limit += pool->size;

	cmp	ecx, edx

; 324  : 	pool = pool->next;

	mov	esi, DWORD PTR [esi]
	mov	eax, ecx
	cmovbe	eax, edx
	add	edi, ecx
	mov	edx, eax
	test	esi, esi
	jne	SHORT $LL2@xmlDictAdd
	mov	ebx, DWORD PTR _dict$[ebp]
$LN19@xmlDictAdd:

; 325  :     }
; 326  :     /*
; 327  :      * Not found, need to allocate
; 328  :      */
; 329  :     if (pool == NULL) {
; 330  :         if ((dict->limit > 0) && (limit > dict->limit)) {

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN8@xmlDictAdd
	cmp	edi, eax
	ja	SHORT $LN20@xmlDictAdd
$LN8@xmlDictAdd:

; 331  :             return(NULL);
; 332  :         }
; 333  : 
; 334  :         if (size == 0) size = 1000;

	test	edx, edx
	jne	SHORT $LN9@xmlDictAdd
	mov	edx, 1000				; 000003e8H
	jmp	SHORT $LN10@xmlDictAdd
$LN9@xmlDictAdd:

; 335  : 	else size *= 4; /* exponential growth */

	shl	edx, 2
$LN10@xmlDictAdd:

; 336  :         if (size < 4 * (namelen + plen + 1))

	mov	eax, DWORD PTR _namelen$[ebp]
	add	eax, DWORD PTR _plen$[ebp]
	lea	edi, DWORD PTR [eax*4+4]

; 337  : 	    size = 4 * (namelen + plen + 1); /* just in case ! */
; 338  : 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);

	cmp	edx, edi
	cmovae	edi, edx
	lea	eax, DWORD PTR [edi+24]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 339  : 	if (pool == NULL)

	test	esi, esi
	jne	SHORT $LN12@xmlDictAdd
$LN20@xmlDictAdd:
	pop	esi
	pop	ebx

; 340  : 	    return(NULL);

	xor	eax, eax
	pop	edi

; 361  : }

	pop	ebp
	ret	0
$LN12@xmlDictAdd:

; 341  : 	pool->size = size;
; 342  : 	pool->nbStrings = 0;
; 343  : 	pool->free = &pool->array[0];

	lea	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], eax

; 344  : 	pool->end = &pool->array[size];

	lea	eax, DWORD PTR [esi+20]
	add	eax, edi
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], eax

; 345  : 	pool->next = dict->strings;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [esi], eax

; 346  : 	dict->strings = pool;

	mov	DWORD PTR [ebx+16], esi
$found_pool$24:

; 347  : #ifdef DICT_DEBUG_PATTERNS
; 348  :         fprintf(stderr, "+");
; 349  : #endif
; 350  :     }
; 351  : found_pool:
; 352  :     ret = pool->free;
; 353  :     memcpy(pool->free, prefix, plen);

	mov	ebx, DWORD PTR _plen$[ebp]
	mov	edi, DWORD PTR [esi+4]
	push	ebx
	push	DWORD PTR _prefix$[ebp]
	push	edi
	call	_memcpy

; 354  :     pool->free += plen;

	add	DWORD PTR [esi+4], ebx
	mov	eax, DWORD PTR [esi+4]

; 355  :     *(pool->free++) = ':';
; 356  :     memcpy(pool->free, name, namelen);

	mov	ebx, DWORD PTR _namelen$[ebp]
	push	ebx
	push	DWORD PTR _name$[ebp]
	mov	BYTE PTR [eax], 58			; 0000003aH
	inc	DWORD PTR [esi+4]
	push	DWORD PTR [esi+4]
	call	_memcpy

; 357  :     pool->free += namelen;

	add	DWORD PTR [esi+4], ebx
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [esi+4]

; 358  :     *(pool->free++) = 0;
; 359  :     pool->nbStrings++;
; 360  :     return(ret);

	mov	eax, edi
	mov	BYTE PTR [ecx], 0
	inc	DWORD PTR [esi+4]
	inc	DWORD PTR [esi+16]
	pop	esi
	pop	ebx
	pop	edi

; 361  : }

	pop	ebp
	ret	0
_xmlDictAddQString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictAddString
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_namelen$ = 16						; size = 4
_xmlDictAddString PROC					; COMDAT

; 241  : xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _dict$[ebp]
	xor	edx, edx
	mov	ebx, DWORD PTR _namelen$[ebp]
	xor	edi, edi
	mov	esi, DWORD PTR [eax+16]
	test	esi, esi
	je	SHORT $LN18@xmlDictAdd
$LL2@xmlDictAdd:

; 242  :     xmlDictStringsPtr pool;
; 243  :     const xmlChar *ret;
; 244  :     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
; 245  :     size_t limit = 0;
; 246  : 
; 247  : #ifdef DICT_DEBUG_PATTERNS
; 248  :     fprintf(stderr, "-");
; 249  : #endif
; 250  :     pool = dict->strings;
; 251  :     while (pool != NULL) {
; 252  : 	if ((size_t)(pool->end - pool->free) > namelen)

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	ja	SHORT $found_pool$21

; 253  : 	    goto found_pool;
; 254  : 	if (pool->size > size) size = pool->size;

	mov	ecx, DWORD PTR [esi+12]

; 255  :         limit += pool->size;

	cmp	ecx, edx

; 256  : 	pool = pool->next;

	mov	esi, DWORD PTR [esi]
	mov	eax, ecx
	cmovbe	eax, edx
	add	edi, ecx
	mov	edx, eax
	test	esi, esi
	jne	SHORT $LL2@xmlDictAdd
	mov	eax, DWORD PTR _dict$[ebp]
$LN18@xmlDictAdd:

; 257  :     }
; 258  :     /*
; 259  :      * Not found, need to allocate
; 260  :      */
; 261  :     if (pool == NULL) {
; 262  :         if ((dict->limit > 0) && (limit > dict->limit)) {

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	je	SHORT $LN7@xmlDictAdd
	cmp	edi, eax
	ja	SHORT $LN19@xmlDictAdd
$LN7@xmlDictAdd:

; 263  :             return(NULL);
; 264  :         }
; 265  : 
; 266  :         if (size == 0) size = 1000;

	test	edx, edx
	jne	SHORT $LN8@xmlDictAdd
	mov	edx, 1000				; 000003e8H
	jmp	SHORT $LN9@xmlDictAdd
$LN8@xmlDictAdd:

; 267  : 	else size *= 4; /* exponential growth */

	shl	edx, 2
$LN9@xmlDictAdd:

; 268  :         if (size < 4 * namelen)

	lea	edi, DWORD PTR [ebx*4]

; 269  : 	    size = 4 * namelen; /* just in case ! */
; 270  : 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);

	cmp	edx, edi
	cmovae	edi, edx
	lea	eax, DWORD PTR [edi+24]
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 271  : 	if (pool == NULL)

	test	esi, esi
	jne	SHORT $LN11@xmlDictAdd
$LN19@xmlDictAdd:
	pop	edi

; 290  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlDictAdd:

; 272  : 	    return(NULL);
; 273  : 	pool->size = size;
; 274  : 	pool->nbStrings = 0;
; 275  : 	pool->free = &pool->array[0];
; 276  : 	pool->end = &pool->array[size];
; 277  : 	pool->next = dict->strings;

	mov	ecx, DWORD PTR _dict$[ebp]
	lea	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], eax
	lea	eax, DWORD PTR [esi+20]
	add	eax, edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi], eax

; 278  : 	dict->strings = pool;

	mov	DWORD PTR [ecx+16], esi
$found_pool$21:

; 279  : #ifdef DICT_DEBUG_PATTERNS
; 280  :         fprintf(stderr, "+");
; 281  : #endif
; 282  :     }
; 283  : found_pool:
; 284  :     ret = pool->free;

	mov	edi, DWORD PTR [esi+4]

; 285  :     memcpy(pool->free, name, namelen);

	push	ebx
	push	DWORD PTR _name$[ebp]
	push	edi
	call	_memcpy

; 286  :     pool->free += namelen;

	add	DWORD PTR [esi+4], ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+4]

; 287  :     *(pool->free++) = 0;
; 288  :     pool->nbStrings++;
; 289  :     return(ret);

	mov	eax, edi
	pop	edi
	mov	BYTE PTR [ecx], 0
	inc	DWORD PTR [esi+4]
	inc	DWORD PTR [esi+16]

; 290  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlDictAddString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCleanup
_TEXT	SEGMENT
_xmlDictCleanup PROC					; COMDAT
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlDictInitialized, 0
	je	SHORT $LN1@xmlDictCle

; 222  :     if (!xmlDictInitialized)
; 223  :         return;
; 224  : 
; 225  :     xmlFreeRMutex(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	call	_xmlFreeRMutex
	add	esp, 4

; 226  : 
; 227  :     xmlDictInitialized = 0;

	mov	DWORD PTR _xmlDictInitialized, 0
$LN1@xmlDictCle:

; 228  : }

	ret	0
_xmlDictCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictSize
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlDictSize PROC					; COMDAT

; 1237 : xmlDictSize(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _dict$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlDictSiz

; 1238 :     if (dict == NULL)
; 1239 : 	return(-1);

	or	eax, -1

; 1243 : }

	pop	ebp
	ret	0
$LN2@xmlDictSiz:

; 1240 :     if (dict->subdict)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN3@xmlDictSiz

; 1241 :         return(dict->nbElems + dict->subdict->nbElems);

	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR [ecx+12]

; 1243 : }

	pop	ebp
	ret	0
$LN3@xmlDictSiz:

; 1242 :     return(dict->nbElems);

	mov	eax, DWORD PTR [ecx+12]

; 1243 : }

	pop	ebp
	ret	0
_xmlDictSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictOwns
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlDictOwns PROC					; COMDAT

; 1211 : xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlDictOwn
	mov	esi, DWORD PTR _str$[ebp]
	npad	7
$LL9@xmlDictOwn:

; 1212 :     xmlDictStringsPtr pool;
; 1213 : 
; 1214 :     if ((dict == NULL) || (str == NULL))

	test	esi, esi
	je	SHORT $LN5@xmlDictOwn

; 1216 :     pool = dict->strings;

	mov	eax, DWORD PTR [edi+16]

; 1217 :     while (pool != NULL) {

	test	eax, eax
	je	SHORT $LN3@xmlDictOwn
	npad	5
$LL2@xmlDictOwn:

; 1218 :         if ((str >= &pool->array[0]) && (str <= pool->free))

	lea	ecx, DWORD PTR [eax+20]
	cmp	esi, ecx
	jb	SHORT $LN6@xmlDictOwn
	cmp	esi, DWORD PTR [eax+4]
	jbe	SHORT $LN12@xmlDictOwn
$LN6@xmlDictOwn:

; 1220 : 	pool = pool->next;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	jne	SHORT $LL2@xmlDictOwn
$LN3@xmlDictOwn:

; 1221 :     }
; 1222 :     if (dict->subdict)

	mov	edi, DWORD PTR [edi+20]
	test	edi, edi
	je	SHORT $LN7@xmlDictOwn
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	test	edi, edi
	jne	SHORT $LL9@xmlDictOwn
$LN5@xmlDictOwn:
	pop	edi

; 1215 : 	return(-1);

	or	eax, -1

; 1225 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlDictOwn:
	pop	edi

; 1219 : 	    return(1);

	mov	eax, 1

; 1225 : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlDictOwn:
	pop	edi

; 1223 :         return(xmlDictOwns(dict->subdict, str));
; 1224 :     return(0);

	xor	eax, eax

; 1225 : }

	pop	esi
	pop	ebp
	ret	0
_xmlDictOwns ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictQLookup
_TEXT	SEGMENT
tv932 = -28						; size = 4
_key$1$ = -28						; size = 4
_plen$1$ = -24						; size = 4
_limit$1$ = -20						; size = 4
_ret$1$ = -20						; size = 4
tv926 = -20						; size = 4
tv943 = -16						; size = 4
_size$1$ = -12						; size = 4
_skey$1$ = -12						; size = 4
_nbi$1$ = -8						; size = 4
_okey$1$ = -4						; size = 4
_dict$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDictQLookup PROC					; COMDAT

; 1106 : xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	mov	DWORD PTR _nbi$1$[ebp], 0
	test	edi, edi
	je	$LN9@xmlDictQLo

; 1107 :     unsigned long okey, key, nbi = 0;
; 1108 :     xmlDictEntryPtr entry;
; 1109 :     xmlDictEntryPtr insert;
; 1110 :     const xmlChar *ret;
; 1111 :     unsigned int len, plen, l;
; 1112 : 
; 1113 :     if ((dict == NULL) || (name == NULL))

	mov	ecx, DWORD PTR _name$[ebp]
	test	ecx, ecx
	je	$LN9@xmlDictQLo

; 1114 : 	return(NULL);
; 1115 :     if (prefix == NULL)

	mov	edx, DWORD PTR _prefix$[ebp]
	test	edx, edx
	jne	SHORT $LN10@xmlDictQLo

; 1116 :         return(xmlDictLookup(dict, name, -1));

	push	-1
	push	ecx
	push	edi
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	pop	edi

; 1198 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlDictQLo:

; 1117 : 
; 1118 :     l = len = strlen((const char *) name);

	mov	ebx, ecx
	lea	esi, DWORD PTR [ebx+1]
	npad	1
$LL77@xmlDictQLo:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL77@xmlDictQLo
	sub	ebx, esi

; 1119 :     plen = strlen((const char *) prefix);

	mov	esi, edx
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv932[ebp], eax
$LL78@xmlDictQLo:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL78@xmlDictQLo
	sub	esi, DWORD PTR tv932[ebp]

; 1120 :     len += 1 + plen;
; 1121 : 
; 1122 :     /*
; 1123 :      * Check for duplicate and insertion location.
; 1124 :      */
; 1125 :     okey = xmlDictComputeQKey(dict, prefix, plen, name, l);

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	DWORD PTR _plen$1$[ebp], esi
	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv943[ebp], eax
	mov	eax, DWORD PTR [edi+24]
	push	eax
	push	ebx
	push	ecx
	push	esi
	push	edx
	jne	SHORT $LN32@xmlDictQLo
	call	_xmlDictComputeFastQKey
	jmp	SHORT $LN80@xmlDictQLo
$LN32@xmlDictQLo:
	call	_xmlDictComputeBigQKey
$LN80@xmlDictQLo:

; 1126 :     key = okey % dict->size;

	mov	DWORD PTR _okey$1$[ebp], eax
	xor	edx, edx
	div	DWORD PTR [edi+8]
	add	esp, 20					; 00000014H
	mov	eax, edx
	mov	DWORD PTR _key$1$[ebp], eax

; 1127 :     if (dict->dict[key].valid == 0) {

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	lea	edi, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN11@xmlDictQLo

; 1128 : 	insert = NULL;

	xor	edi, edi

; 1129 :     } else {

	jmp	SHORT $LN14@xmlDictQLo
$LN11@xmlDictQLo:

; 1130 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN75@xmlDictQLo
	mov	ecx, DWORD PTR _okey$1$[ebp]
	xor	eax, eax
	npad	1
$LL4@xmlDictQLo:

; 1132 : 	    if ((insert->okey == okey) && (insert->len == len) &&

	cmp	DWORD PTR [edi+16], ecx
	jne	SHORT $LN13@xmlDictQLo
	lea	ecx, DWORD PTR [ebx+1]
	add	ecx, esi
	cmp	DWORD PTR [edi+8], ecx
	jne	SHORT $LN79@xmlDictQLo
	push	DWORD PTR [edi+4]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN58@xmlDictQLo
	mov	eax, DWORD PTR _nbi$1$[ebp]
$LN79@xmlDictQLo:

; 1133 : 	        (xmlStrQEqual(prefix, name, insert->name)))
; 1134 : 		return(insert->name);
; 1135 : 	    nbi++;

	mov	ecx, DWORD PTR _okey$1$[ebp]
$LN13@xmlDictQLo:

; 1131 : 	     insert = insert->next) {

	mov	edi, DWORD PTR [edi]

; 1133 : 	        (xmlStrQEqual(prefix, name, insert->name)))
; 1134 : 		return(insert->name);
; 1135 : 	    nbi++;

	inc	eax
	mov	DWORD PTR _nbi$1$[ebp], eax
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LL4@xmlDictQLo
$LN75@xmlDictQLo:

; 1136 : 	}
; 1137 : 	if ((insert->okey == okey) && (insert->len == len) &&

	mov	eax, DWORD PTR _okey$1$[ebp]
	cmp	DWORD PTR [edi+16], eax
	jne	SHORT $LN14@xmlDictQLo
	lea	eax, DWORD PTR [ebx+1]
	add	eax, esi
	cmp	DWORD PTR [edi+8], eax
	jne	SHORT $LN14@xmlDictQLo
	push	DWORD PTR [edi+4]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN58@xmlDictQLo
$LN14@xmlDictQLo:

; 1138 : 	    (xmlStrQEqual(prefix, name, insert->name)))
; 1139 : 	    return(insert->name);
; 1140 :     }
; 1141 : 
; 1142 :     if (dict->subdict) {

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	$LN74@xmlDictQLo

; 1143 :         unsigned long skey;
; 1144 : 
; 1145 :         /* we cannot always reuse the same okey for the subdict */
; 1146 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1147 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	DWORD PTR [edx+8], 128			; 00000080H
	mov	ecx, DWORD PTR [eax+8]
	jne	$LN72@xmlDictQLo
	cmp	ecx, 128				; 00000080H
	jne	$LN18@xmlDictQLo
$LN16@xmlDictQLo:

; 1151 : 	else
; 1152 : 	    skey = okey;

	mov	ecx, DWORD PTR _okey$1$[ebp]
	mov	esi, eax
	mov	DWORD PTR _skey$1$[ebp], ecx
$LN17@xmlDictQLo:

; 1153 : 
; 1154 : 	key = skey % dict->subdict->size;

	mov	eax, ecx
	xor	edx, edx
	div	DWORD PTR [esi+8]

; 1155 : 	if (dict->subdict->dict[key].valid != 0) {

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edx+edx*4]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	lea	esi, DWORD PTR [eax+ecx*4]
	je	SHORT $LN22@xmlDictQLo

; 1156 : 	    xmlDictEntryPtr tmp;
; 1157 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN76@xmlDictQLo
	mov	eax, DWORD PTR _skey$1$[ebp]
	mov	ecx, DWORD PTR _nbi$1$[ebp]
$LL7@xmlDictQLo:

; 1159 : 		if ((tmp->okey == skey) && (tmp->len == len) &&

	cmp	DWORD PTR [esi+16], eax
	jne	SHORT $LN21@xmlDictQLo
	mov	edx, DWORD PTR tv943[ebp]
	mov	ecx, DWORD PTR _nbi$1$[ebp]
	inc	edx
	cmp	DWORD PTR [esi+8], edx
	jne	SHORT $LN21@xmlDictQLo
	push	DWORD PTR [esi+4]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN59@xmlDictQLo
	mov	eax, DWORD PTR _skey$1$[ebp]
	mov	ecx, DWORD PTR _nbi$1$[ebp]
$LN21@xmlDictQLo:

; 1158 : 		 tmp = tmp->next) {

	mov	esi, DWORD PTR [esi]

; 1160 : 		    (xmlStrQEqual(prefix, name, tmp->name)))
; 1161 : 		    return(tmp->name);
; 1162 : 		nbi++;

	inc	ecx
	mov	DWORD PTR _nbi$1$[ebp], ecx
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL7@xmlDictQLo
$LN76@xmlDictQLo:

; 1163 : 	    }
; 1164 : 	    if ((tmp->okey == skey) && (tmp->len == len) &&

	mov	eax, DWORD PTR _skey$1$[ebp]
	cmp	DWORD PTR [esi+16], eax
	jne	SHORT $LN22@xmlDictQLo
	mov	eax, DWORD PTR tv943[ebp]
	inc	eax
	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN22@xmlDictQLo
	push	DWORD PTR [esi+4]
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR _prefix$[ebp]
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN59@xmlDictQLo
$LN22@xmlDictQLo:

; 1165 : 		(xmlStrQEqual(prefix, name, tmp->name)))
; 1166 : 		return(tmp->name);
; 1167 : 	}
; 1168 : 	key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _okey$1$[ebp]
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$1$[ebp], edx
	mov	edx, ecx
$LN74@xmlDictQLo:

; 318  :     pool = dict->strings;

	mov	esi, DWORD PTR [edx+16]
	xor	eax, eax
	xor	ecx, ecx
	mov	DWORD PTR _size$1$[ebp], eax
	mov	DWORD PTR _limit$1$[ebp], ecx

; 319  :     while (pool != NULL) {

	test	esi, esi
	je	SHORT $LN71@xmlDictQLo
	npad	2
$LL43@xmlDictQLo:

; 320  : 	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR tv943[ebp]
	sub	eax, DWORD PTR [esi+4]
	inc	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	cmp	eax, ecx
	ja	$found_pool$83

; 321  : 	    goto found_pool;
; 322  : 	if (pool->size > size) size = pool->size;

	mov	ecx, DWORD PTR [esi+12]

; 323  :         limit += pool->size;

	mov	eax, ecx
	cmp	ecx, DWORD PTR _size$1$[ebp]

; 324  : 	pool = pool->next;

	mov	esi, DWORD PTR [esi]
	cmovbe	eax, DWORD PTR _size$1$[ebp]
	add	DWORD PTR _limit$1$[ebp], ecx
	mov	DWORD PTR _size$1$[ebp], eax
	test	esi, esi
	jne	SHORT $LL43@xmlDictQLo
	mov	ecx, DWORD PTR _limit$1$[ebp]
$LN71@xmlDictQLo:

; 325  :     }
; 326  :     /*
; 327  :      * Not found, need to allocate
; 328  :      */
; 329  :     if (pool == NULL) {
; 330  :         if ((dict->limit > 0) && (limit > dict->limit)) {

	mov	edx, DWORD PTR [edx+28]
	test	edx, edx
	je	SHORT $LN49@xmlDictQLo
	cmp	ecx, edx
	ja	$LN9@xmlDictQLo
$LN49@xmlDictQLo:

; 331  :             return(NULL);
; 332  :         }
; 333  : 
; 334  :         if (size == 0) size = 1000;

	mov	ecx, 1000				; 000003e8H
	test	eax, eax
	je	SHORT $LN51@xmlDictQLo

; 335  : 	else size *= 4; /* exponential growth */

	lea	ecx, DWORD PTR [eax*4]
$LN51@xmlDictQLo:

; 336  :         if (size < 4 * (namelen + plen + 1))

	mov	eax, DWORD PTR tv943[ebp]
	lea	eax, DWORD PTR [eax*4+4]

; 337  : 	    size = 4 * (namelen + plen + 1); /* just in case ! */
; 338  : 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);

	cmp	ecx, eax
	cmovae	eax, ecx
	mov	DWORD PTR tv926[ebp], eax
	add	eax, 24					; 00000018H
	push	eax
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 339  : 	if (pool == NULL)

	test	esi, esi
	je	$LN9@xmlDictQLo

; 340  : 	    return(NULL);
; 341  : 	pool->size = size;

	mov	eax, DWORD PTR tv926[ebp]

; 342  : 	pool->nbStrings = 0;
; 343  : 	pool->free = &pool->array[0];

	lea	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], 0

; 344  : 	pool->end = &pool->array[size];

	lea	ecx, DWORD PTR [eax+20]
	add	ecx, esi
	mov	DWORD PTR [esi+8], ecx

; 345  : 	pool->next = dict->strings;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi], eax

; 346  : 	dict->strings = pool;

	mov	DWORD PTR [ecx+16], esi
$found_pool$83:

; 347  : #ifdef DICT_DEBUG_PATTERNS
; 348  :         fprintf(stderr, "+");
; 349  : #endif
; 350  :     }
; 351  : found_pool:
; 352  :     ret = pool->free;
; 353  :     memcpy(pool->free, prefix, plen);

	push	DWORD PTR _plen$1$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR _prefix$[ebp]
	mov	DWORD PTR _ret$1$[ebp], eax
	push	eax
	call	_memcpy

; 354  :     pool->free += plen;

	mov	eax, DWORD PTR _plen$1$[ebp]
	add	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi+4]

; 355  :     *(pool->free++) = ':';
; 356  :     memcpy(pool->free, name, namelen);

	push	ebx
	push	DWORD PTR _name$[ebp]
	mov	BYTE PTR [eax], 58			; 0000003aH
	inc	DWORD PTR [esi+4]
	push	DWORD PTR [esi+4]
	call	_memcpy

; 357  :     pool->free += namelen;

	add	DWORD PTR [esi+4], ebx
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR [esi+4]

; 358  :     *(pool->free++) = 0;

	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+4]

; 359  :     pool->nbStrings++;

	inc	DWORD PTR [esi+16]

; 1169 :     }
; 1170 : 
; 1171 :     ret = xmlDictAddQString(dict, prefix, plen, name, l);
; 1172 :     if (ret == NULL)

	mov	esi, DWORD PTR _ret$1$[ebp]
	test	esi, esi
	je	$LN9@xmlDictQLo

; 1173 :         return(NULL);
; 1174 :     if (insert == NULL) {

	test	edi, edi
	jne	SHORT $LN24@xmlDictQLo

; 1175 : 	entry = &(dict->dict[key]);

	mov	eax, DWORD PTR _key$1$[ebp]
	mov	edx, DWORD PTR _dict$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 1176 :     } else {

	jmp	SHORT $LN26@xmlDictQLo
$LN58@xmlDictQLo:

; 1198 : }

	mov	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@xmlDictQLo:

; 1143 :         unsigned long skey;
; 1144 : 
; 1145 :         /* we cannot always reuse the same okey for the subdict */
; 1146 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1147 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	ecx, 128				; 00000080H
	jne	$LN16@xmlDictQLo
$LN18@xmlDictQLo:

; 1148 :             ((dict->size != MIN_DICT_SIZE) &&
; 1149 : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 1150 : 	    skey = xmlDictComputeQKey(dict->subdict, prefix, plen, name, l);

	mov	eax, DWORD PTR [eax+24]
	push	eax
	push	ebx
	push	DWORD PTR _name$[ebp]
	push	esi
	push	DWORD PTR _prefix$[ebp]
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN38@xmlDictQLo
	call	_xmlDictComputeFastQKey
	mov	ecx, eax
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR _skey$1$[ebp], ecx
	mov	esi, DWORD PTR [eax+20]
	jmp	$LN17@xmlDictQLo
$LN38@xmlDictQLo:
	call	_xmlDictComputeBigQKey
	mov	ecx, eax
	mov	DWORD PTR _skey$1$[ebp], eax
	mov	eax, DWORD PTR _dict$[ebp]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR [eax+20]
	jmp	$LN17@xmlDictQLo
$LN59@xmlDictQLo:

; 1198 : }

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlDictQLo:

; 1177 : 	entry = xmlMalloc(sizeof(xmlDictEntry));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 1178 : 	if (entry == NULL)

	test	eax, eax
	je	SHORT $LN9@xmlDictQLo
	mov	edx, DWORD PTR _dict$[ebp]
$LN26@xmlDictQLo:

; 1179 : 	     return(NULL);
; 1180 :     }
; 1181 :     entry->name = ret;
; 1182 :     entry->len = len;

	mov	ecx, DWORD PTR tv943[ebp]
	inc	ecx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx

; 1183 :     entry->next = NULL;
; 1184 :     entry->valid = 1;
; 1185 :     entry->okey = okey;

	mov	ecx, DWORD PTR _okey$1$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+12], 1
	mov	DWORD PTR [eax+16], ecx

; 1186 : 
; 1187 :     if (insert != NULL)

	test	edi, edi
	je	SHORT $LN27@xmlDictQLo

; 1188 : 	insert->next = entry;

	mov	DWORD PTR [edi], eax
$LN27@xmlDictQLo:

; 1189 : 
; 1190 :     dict->nbElems++;

	inc	DWORD PTR [edx+12]

; 1191 : 
; 1192 :     if ((nbi > MAX_HASH_LEN) &&

	cmp	DWORD PTR _nbi$1$[ebp], 3
	jbe	SHORT $LN28@xmlDictQLo
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, 2730				; 00000aaaH
	ja	SHORT $LN28@xmlDictQLo

; 1193 :         (dict->size <= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN)))
; 1194 : 	xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size);

	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	push	ecx
	push	edx
	call	_xmlDictGrow
	add	esp, 8
$LN28@xmlDictQLo:

; 1195 :     /* Note that entry may have been freed at this point by xmlDictGrow */
; 1196 : 
; 1197 :     return(ret);

	pop	edi
	mov	eax, esi

; 1198 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlDictQLo:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictQLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictExists
_TEXT	SEGMENT
$T1 = 8							; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlDictExists PROC					; COMDAT

; 998  : xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	test	edi, edi
	je	$LN9@xmlDictExi

; 999  :     unsigned long key, okey, nbi = 0;
; 1000 :     xmlDictEntryPtr insert;
; 1001 :     unsigned int l;
; 1002 : 
; 1003 :     if ((dict == NULL) || (name == NULL))

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	je	$LN9@xmlDictExi

; 1004 : 	return(NULL);
; 1005 : 
; 1006 :     if (len < 0)

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	jns	SHORT $LN10@xmlDictExi

; 1007 :         l = strlen((const char *) name);

	mov	esi, eax
	lea	ecx, DWORD PTR [esi+1]
$LL45@xmlDictExi:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL45@xmlDictExi
	mov	eax, DWORD PTR _name$[ebp]
	sub	esi, ecx
$LN10@xmlDictExi:

; 1008 :     else
; 1009 :         l = len;
; 1010 :     if (((dict->limit > 0) && (l >= dict->limit)) ||

	mov	ecx, DWORD PTR [edi+28]
	test	ecx, ecx
	je	SHORT $LN14@xmlDictExi
	cmp	esi, ecx
	jae	$LN9@xmlDictExi
$LN14@xmlDictExi:
	cmp	esi, 1073741823				; 3fffffffH
	ja	$LN9@xmlDictExi

; 1011 :         (l > INT_MAX / 2))
; 1012 :         return(NULL);
; 1013 : 
; 1014 :     /*
; 1015 :      * Check for duplicate and insertion location.
; 1016 :      */
; 1017 :     okey = xmlDictComputeKey(dict, name, l);

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	ecx, DWORD PTR [edi+24]
	push	ecx
	push	esi
	push	eax
	jne	SHORT $LN28@xmlDictExi
	call	_xmlDictComputeFastKey
	jmp	SHORT $LN46@xmlDictExi
$LN28@xmlDictExi:
	call	_xmlDictComputeBigKey
$LN46@xmlDictExi:

; 1018 :     key = okey % dict->size;

	xor	edx, edx
	mov	ebx, eax
	div	DWORD PTR [edi+8]

; 1019 :     if (dict->dict[key].valid == 0) {

	mov	eax, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [edx+edx*4]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	lea	edi, DWORD PTR [eax+ecx*4]
	je	SHORT $LN18@xmlDictExi

; 1020 : 	insert = NULL;
; 1021 :     } else {
; 1022 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN43@xmlDictExi
$LL4@xmlDictExi:

; 1024 : #ifdef __GNUC__
; 1025 : 	    if ((insert->okey == okey) && (insert->len == l)) {
; 1026 : 		if (!memcmp(insert->name, name, l))
; 1027 : 		    return(insert->name);
; 1028 : 	    }
; 1029 : #else
; 1030 : 	    if ((insert->okey == okey) && (insert->len == l) &&

	cmp	DWORD PTR [edi+16], ebx
	jne	SHORT $LN17@xmlDictExi
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN17@xmlDictExi
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@xmlDictExi
$LN17@xmlDictExi:

; 1023 : 	     insert = insert->next) {

	mov	edi, DWORD PTR [edi]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LL4@xmlDictExi
$LN43@xmlDictExi:

; 1031 : 	        (!xmlStrncmp(insert->name, name, l)))
; 1032 : 		return(insert->name);
; 1033 : #endif
; 1034 : 	    nbi++;
; 1035 : 	}
; 1036 : #ifdef __GNUC__
; 1037 : 	if ((insert->okey == okey) && (insert->len == l)) {
; 1038 : 	    if (!memcmp(insert->name, name, l))
; 1039 : 		return(insert->name);
; 1040 : 	}
; 1041 : #else
; 1042 : 	if ((insert->okey == okey) && (insert->len == l) &&

	cmp	DWORD PTR [edi+16], ebx
	jne	SHORT $LN18@xmlDictExi
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN18@xmlDictExi
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@xmlDictExi
$LN18@xmlDictExi:

; 1043 : 	    (!xmlStrncmp(insert->name, name, l)))
; 1044 : 	    return(insert->name);
; 1045 : #endif
; 1046 :     }
; 1047 : 
; 1048 :     if (dict->subdict) {

	mov	edi, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	je	$LN9@xmlDictExi

; 1049 :         unsigned long skey;
; 1050 : 
; 1051 :         /* we cannot always reuse the same okey for the subdict */
; 1052 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1053 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN42@xmlDictExi
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN22@xmlDictExi
	jmp	SHORT $LN20@xmlDictExi
$LN34@xmlDictExi:

; 1085 : 		(!xmlStrncmp(tmp->name, name, l)))
; 1086 : 		return(tmp->name);
; 1087 : #endif
; 1088 : 	}
; 1089 :     }
; 1090 : 
; 1091 :     /* not found */
; 1092 :     return(NULL);
; 1093 : }

	mov	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN42@xmlDictExi:

; 1049 :         unsigned long skey;
; 1050 : 
; 1051 :         /* we cannot always reuse the same okey for the subdict */
; 1052 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1053 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN20@xmlDictExi
$LN22@xmlDictExi:

; 1054 :             ((dict->size != MIN_DICT_SIZE) &&
; 1055 : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 1056 : 	    skey = xmlDictComputeKey(dict->subdict, name, l);

	mov	ecx, DWORD PTR [ecx+24]
	push	ecx
	push	esi
	push	DWORD PTR _name$[ebp]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN30@xmlDictExi
	call	_xmlDictComputeFastKey
	jmp	SHORT $LN47@xmlDictExi
$LN30@xmlDictExi:
	call	_xmlDictComputeBigKey
$LN47@xmlDictExi:
	mov	ecx, DWORD PTR [edi+20]
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T1[ebp], ecx
$LN20@xmlDictExi:

; 1057 : 	else
; 1058 : 	    skey = okey;
; 1059 : 
; 1060 : 	key = skey % dict->subdict->size;

	xor	edx, edx
	mov	eax, ebx
	div	DWORD PTR [ecx+8]

; 1061 : 	if (dict->subdict->dict[key].valid != 0) {

	mov	eax, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [edx+edx*4]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	lea	edi, DWORD PTR [eax+ecx*4]
	je	SHORT $LN9@xmlDictExi

; 1062 : 	    xmlDictEntryPtr tmp;
; 1063 : 
; 1064 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN44@xmlDictExi
	npad	2
$LL7@xmlDictExi:

; 1066 : #ifdef __GNUC__
; 1067 : 		if ((tmp->okey == skey) && (tmp->len == l)) {
; 1068 : 		    if (!memcmp(tmp->name, name, l))
; 1069 : 			return(tmp->name);
; 1070 : 		}
; 1071 : #else
; 1072 : 		if ((tmp->okey == skey) && (tmp->len == l) &&

	cmp	DWORD PTR [edi+16], ebx
	jne	SHORT $LN25@xmlDictExi
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN25@xmlDictExi
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@xmlDictExi
$LN25@xmlDictExi:

; 1065 : 		 tmp = tmp->next) {

	mov	edi, DWORD PTR [edi]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LL7@xmlDictExi
$LN44@xmlDictExi:

; 1073 : 		    (!xmlStrncmp(tmp->name, name, l)))
; 1074 : 		    return(tmp->name);
; 1075 : #endif
; 1076 : 		nbi++;
; 1077 : 	    }
; 1078 : #ifdef __GNUC__
; 1079 : 	    if ((tmp->okey == skey) && (tmp->len == l)) {
; 1080 : 		if (!memcmp(tmp->name, name, l))
; 1081 : 		    return(tmp->name);
; 1082 : 	    }
; 1083 : #else
; 1084 : 	    if ((tmp->okey == skey) && (tmp->len == l) &&

	cmp	DWORD PTR [edi+16], ebx
	jne	SHORT $LN9@xmlDictExi
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN9@xmlDictExi
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN34@xmlDictExi
$LN9@xmlDictExi:
	pop	edi

; 1085 : 		(!xmlStrncmp(tmp->name, name, l)))
; 1086 : 		return(tmp->name);
; 1087 : #endif
; 1088 : 	}
; 1089 :     }
; 1090 : 
; 1091 :     /* not found */
; 1092 :     return(NULL);
; 1093 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlDictExists ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictLookup
_TEXT	SEGMENT
_ret$1$ = -12						; size = 4
_nbi$1$ = -12						; size = 4
_skey$1$ = -8						; size = 4
_key$1$ = -8						; size = 4
_okey$1$ = -4						; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlDictLookup PROC					; COMDAT

; 858  : xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _nbi$1$[ebp], ebx
	test	edi, edi
	je	$LN9@xmlDictLoo

; 859  :     unsigned long key, okey, nbi = 0;
; 860  :     xmlDictEntryPtr entry;
; 861  :     xmlDictEntryPtr insert;
; 862  :     const xmlChar *ret;
; 863  :     unsigned int l;
; 864  : 
; 865  :     if ((dict == NULL) || (name == NULL))

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	je	$LN9@xmlDictLoo

; 866  : 	return(NULL);
; 867  : 
; 868  :     if (len < 0)

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	jns	SHORT $LN10@xmlDictLoo

; 869  :         l = strlen((const char *) name);

	mov	esi, eax
	lea	ecx, DWORD PTR [esi+1]
	npad	6
$LL54@xmlDictLoo:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL54@xmlDictLoo
	mov	eax, DWORD PTR _name$[ebp]
	sub	esi, ecx
$LN10@xmlDictLoo:

; 870  :     else
; 871  :         l = len;
; 872  : 
; 873  :     if (((dict->limit > 0) && (l >= dict->limit)) ||

	mov	ecx, DWORD PTR [edi+28]
	test	ecx, ecx
	je	SHORT $LN14@xmlDictLoo
	cmp	esi, ecx
	jae	$LN9@xmlDictLoo
$LN14@xmlDictLoo:
	cmp	esi, 1073741823				; 3fffffffH
	ja	$LN9@xmlDictLoo

; 874  :         (l > INT_MAX / 2))
; 875  :         return(NULL);
; 876  : 
; 877  :     /*
; 878  :      * Check for duplicate and insertion location.
; 879  :      */
; 880  :     okey = xmlDictComputeKey(dict, name, l);

	cmp	DWORD PTR [edi+8], 128			; 00000080H
	mov	ecx, DWORD PTR [edi+24]
	push	ecx
	push	esi
	push	eax
	jne	SHORT $LN35@xmlDictLoo
	call	_xmlDictComputeFastKey
	jmp	SHORT $LN56@xmlDictLoo
$LN35@xmlDictLoo:
	call	_xmlDictComputeBigKey
$LN56@xmlDictLoo:

; 881  :     key = okey % dict->size;

	mov	DWORD PTR _okey$1$[ebp], eax
	xor	edx, edx
	div	DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	mov	eax, edx
	mov	DWORD PTR _key$1$[ebp], eax

; 882  :     if (dict->dict[key].valid == 0) {

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR [eax+ecx*4+12], ebx
	lea	edi, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN15@xmlDictLoo

; 883  : 	insert = NULL;

	xor	edi, edi

; 884  :     } else {

	jmp	SHORT $LN55@xmlDictLoo
$LN15@xmlDictLoo:

; 885  : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	cmp	DWORD PTR [edi], ebx
	je	SHORT $LN52@xmlDictLoo
	mov	eax, DWORD PTR _okey$1$[ebp]
	npad	4
$LL4@xmlDictLoo:

; 887  : #ifdef __GNUC__
; 888  : 	    if ((insert->okey == okey) && (insert->len == l)) {
; 889  : 		if (!memcmp(insert->name, name, l))
; 890  : 		    return(insert->name);
; 891  : 	    }
; 892  : #else
; 893  : 	    if ((insert->okey == okey) && (insert->len == l) &&

	cmp	DWORD PTR [edi+16], eax
	jne	SHORT $LN17@xmlDictLoo
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN17@xmlDictLoo
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN41@xmlDictLoo
	mov	eax, DWORD PTR _okey$1$[ebp]
$LN17@xmlDictLoo:

; 886  : 	     insert = insert->next) {

	mov	edi, DWORD PTR [edi]

; 894  : 	        (!xmlStrncmp(insert->name, name, l)))
; 895  : 		return(insert->name);
; 896  : #endif
; 897  : 	    nbi++;

	inc	ebx
	mov	DWORD PTR _nbi$1$[ebp], ebx
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LL4@xmlDictLoo
$LN52@xmlDictLoo:

; 898  : 	}
; 899  : #ifdef __GNUC__
; 900  : 	if ((insert->okey == okey) && (insert->len == l)) {
; 901  : 	    if (!memcmp(insert->name, name, l))
; 902  : 		return(insert->name);
; 903  : 	}
; 904  : #else
; 905  : 	if ((insert->okey == okey) && (insert->len == l) &&

	mov	ecx, DWORD PTR _okey$1$[ebp]
	cmp	DWORD PTR [edi+16], ecx
	jne	SHORT $LN18@xmlDictLoo
	cmp	DWORD PTR [edi+8], esi
	jne	SHORT $LN18@xmlDictLoo
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [edi+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN41@xmlDictLoo
$LN55@xmlDictLoo:

; 906  : 	    (!xmlStrncmp(insert->name, name, l)))
; 907  : 	    return(insert->name);
; 908  : #endif
; 909  :     }
; 910  : 
; 911  :     if (dict->subdict) {

	mov	ecx, DWORD PTR _okey$1$[ebp]
$LN18@xmlDictLoo:
	mov	eax, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [eax+20]
	test	edx, edx
	je	$LN51@xmlDictLoo

; 912  :         unsigned long skey;
; 913  : 
; 914  :         /* we cannot always reuse the same okey for the subdict */
; 915  :         if (((dict->size == MIN_DICT_SIZE) &&
; 916  : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	DWORD PTR [eax+8], 128			; 00000080H
	mov	ebx, DWORD PTR [edx+8]
	jne	$LN50@xmlDictLoo
	cmp	ebx, 128				; 00000080H
	jne	$LN22@xmlDictLoo
$LN20@xmlDictLoo:

; 920  : 	else
; 921  : 	    skey = okey;

	mov	DWORD PTR _skey$1$[ebp], ecx
	mov	ebx, edx
$LN21@xmlDictLoo:

; 922  : 
; 923  : 	key = skey % dict->subdict->size;

	mov	eax, ecx
	xor	edx, edx
	div	DWORD PTR [ebx+8]

; 924  : 	if (dict->subdict->dict[key].valid != 0) {

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [edx+edx*4]
	cmp	DWORD PTR [eax+ecx*4+12], 0
	lea	ebx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN26@xmlDictLoo

; 925  : 	    xmlDictEntryPtr tmp;
; 926  : 
; 927  : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN53@xmlDictLoo
	mov	eax, DWORD PTR _nbi$1$[ebp]
	mov	ecx, DWORD PTR _skey$1$[ebp]
$LL7@xmlDictLoo:

; 929  : #ifdef __GNUC__
; 930  : 		if ((tmp->okey == skey) && (tmp->len == l)) {
; 931  : 		    if (!memcmp(tmp->name, name, l))
; 932  : 			return(tmp->name);
; 933  : 		}
; 934  : #else
; 935  : 		if ((tmp->okey == skey) && (tmp->len == l) &&

	cmp	DWORD PTR [ebx+16], ecx
	jne	SHORT $LN25@xmlDictLoo
	cmp	DWORD PTR [ebx+8], esi
	jne	SHORT $LN25@xmlDictLoo
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [ebx+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN42@xmlDictLoo
	mov	eax, DWORD PTR _nbi$1$[ebp]
	mov	ecx, DWORD PTR _skey$1$[ebp]
$LN25@xmlDictLoo:

; 928  : 		 tmp = tmp->next) {

	mov	ebx, DWORD PTR [ebx]

; 936  : 		    (!xmlStrncmp(tmp->name, name, l)))
; 937  : 		    return(tmp->name);
; 938  : #endif
; 939  : 		nbi++;

	inc	eax
	mov	DWORD PTR _nbi$1$[ebp], eax
	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LL7@xmlDictLoo
$LN53@xmlDictLoo:

; 940  : 	    }
; 941  : #ifdef __GNUC__
; 942  : 	    if ((tmp->okey == skey) && (tmp->len == l)) {
; 943  : 		if (!memcmp(tmp->name, name, l))
; 944  : 		    return(tmp->name);
; 945  : 	    }
; 946  : #else
; 947  : 	    if ((tmp->okey == skey) && (tmp->len == l) &&

	mov	eax, DWORD PTR _skey$1$[ebp]
	cmp	DWORD PTR [ebx+16], eax
	jne	SHORT $LN26@xmlDictLoo
	cmp	DWORD PTR [ebx+8], esi
	jne	SHORT $LN26@xmlDictLoo
	push	esi
	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [ebx+4]
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN42@xmlDictLoo
$LN26@xmlDictLoo:

; 948  : 		(!xmlStrncmp(tmp->name, name, l)))
; 949  : 		return(tmp->name);
; 950  : #endif
; 951  : 	}
; 952  : 	key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _okey$1$[ebp]
	mov	ebx, DWORD PTR _nbi$1$[ebp]
	div	DWORD PTR [ecx+8]
	mov	eax, ecx
	mov	DWORD PTR _key$1$[ebp], edx
$LN51@xmlDictLoo:

; 953  :     }
; 954  : 
; 955  :     ret = xmlDictAddString(dict, name, l);

	push	esi
	push	DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictAddString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1$[ebp], eax

; 956  :     if (ret == NULL)

	test	eax, eax
	je	$LN9@xmlDictLoo

; 957  :         return(NULL);
; 958  :     if (insert == NULL) {

	test	edi, edi
	jne	SHORT $LN28@xmlDictLoo

; 959  : 	entry = &(dict->dict[key]);

	mov	eax, DWORD PTR _key$1$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [ecx+edx*4]

; 960  :     } else {

	jmp	SHORT $LN30@xmlDictLoo
$LN41@xmlDictLoo:

; 985  : }

	mov	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@xmlDictLoo:

; 912  :         unsigned long skey;
; 913  : 
; 914  :         /* we cannot always reuse the same okey for the subdict */
; 915  :         if (((dict->size == MIN_DICT_SIZE) &&
; 916  : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	cmp	ebx, 128				; 00000080H
	jne	$LN20@xmlDictLoo
$LN22@xmlDictLoo:

; 917  :             ((dict->size != MIN_DICT_SIZE) &&
; 918  : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 919  : 	    skey = xmlDictComputeKey(dict->subdict, name, l);

	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	esi
	push	DWORD PTR _name$[ebp]
	cmp	ebx, 128				; 00000080H
	jne	SHORT $LN37@xmlDictLoo
	call	_xmlDictComputeFastKey
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR _skey$1$[ebp], ecx
	mov	ebx, DWORD PTR [eax+20]
	jmp	$LN21@xmlDictLoo
$LN37@xmlDictLoo:
	call	_xmlDictComputeBigKey
	mov	ecx, eax
	mov	DWORD PTR _skey$1$[ebp], eax
	mov	eax, DWORD PTR _dict$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR [eax+20]
	jmp	$LN21@xmlDictLoo
$LN42@xmlDictLoo:

; 985  : }

	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlDictLoo:

; 961  : 	entry = xmlMalloc(sizeof(xmlDictEntry));

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4

; 962  : 	if (entry == NULL)

	test	ecx, ecx
	je	SHORT $LN9@xmlDictLoo
	mov	eax, DWORD PTR _dict$[ebp]
$LN30@xmlDictLoo:

; 963  : 	     return(NULL);
; 964  :     }
; 965  :     entry->name = ret;

	mov	edx, DWORD PTR _ret$1$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 966  :     entry->len = l;
; 967  :     entry->next = NULL;
; 968  :     entry->valid = 1;
; 969  :     entry->okey = okey;

	mov	edx, DWORD PTR _okey$1$[ebp]
	mov	DWORD PTR [ecx+8], esi
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], 1
	mov	DWORD PTR [ecx+16], edx

; 970  : 
; 971  : 
; 972  :     if (insert != NULL)

	test	edi, edi
	je	SHORT $LN31@xmlDictLoo

; 973  : 	insert->next = entry;

	mov	DWORD PTR [edi], ecx
$LN31@xmlDictLoo:

; 974  : 
; 975  :     dict->nbElems++;

	inc	DWORD PTR [eax+12]

; 976  : 
; 977  :     if ((nbi > MAX_HASH_LEN) &&

	cmp	ebx, 3
	jbe	SHORT $LN33@xmlDictLoo
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, 2730				; 00000aaaH
	ja	SHORT $LN33@xmlDictLoo

; 978  :         (dict->size <= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN))) {
; 979  : 	if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size) != 0)

	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	push	eax
	push	DWORD PTR _dict$[ebp]
	call	_xmlDictGrow
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlDictLoo
$LN33@xmlDictLoo:

; 980  : 	    return(NULL);
; 981  :     }
; 982  :     /* Note that entry may have been freed at this point by xmlDictGrow */
; 983  : 
; 984  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	pop	edi

; 985  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlDictLoo:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictLookup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictFree
_TEXT	SEGMENT
_i$1$ = 8						; size = 4
_dict$ = 8						; size = 4
_xmlDictFree PROC					; COMDAT

; 793  : xmlDictFree(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _dict$[ebp]
	test	edi, edi
	je	$LN1@xmlDictFre

; 794  :     size_t i;
; 795  :     xmlDictEntryPtr iter;
; 796  :     xmlDictEntryPtr next;
; 797  :     int inside_dict = 0;
; 798  :     xmlDictStringsPtr pool, nextp;
; 799  : 
; 800  :     if (dict == NULL)
; 801  : 	return;
; 802  : 
; 803  :     if (!xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN11@xmlDictFre

; 804  :         if (!__xmlInitializeDict())

	call	___xmlInitializeDict
	test	eax, eax
	je	$LN1@xmlDictFre
$LN11@xmlDictFre:

; 805  :             return;
; 806  : 
; 807  :     /* decrement the counter, it may be shared by a parser and docs */
; 808  :     xmlRMutexLock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	call	_xmlRMutexLock

; 809  :     dict->ref_counter--;

	dec	DWORD PTR [edi]
	add	esp, 4

; 810  :     if (dict->ref_counter > 0) {

	cmp	DWORD PTR [edi], 0
	push	DWORD PTR _xmlDictMutex
	jle	SHORT $LN12@xmlDictFre

; 811  :         xmlRMutexUnlock(xmlDictMutex);

	call	_xmlRMutexUnlock
	add	esp, 4
	pop	edi

; 845  : }

	pop	ebp
	ret	0
$LN12@xmlDictFre:

; 812  :         return;
; 813  :     }
; 814  : 
; 815  :     xmlRMutexUnlock(xmlDictMutex);

	call	_xmlRMutexUnlock

; 816  : 
; 817  :     if (dict->subdict != NULL) {

	mov	eax, DWORD PTR [edi+20]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@xmlDictFre

; 818  :         xmlDictFree(dict->subdict);

	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN13@xmlDictFre:

; 819  :     }
; 820  : 
; 821  :     if (dict->dict) {

	mov	ecx, DWORD PTR [edi+4]
	push	esi
	test	ecx, ecx
	je	SHORT $LN14@xmlDictFre

; 822  : 	for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {

	cmp	DWORD PTR [edi+8], 0
	mov	edx, ecx
	mov	DWORD PTR _i$1$[ebp], 0
	jbe	SHORT $LN31@xmlDictFre
	push	ebx
	xor	ebx, ebx
$LL4@xmlDictFre:
	cmp	DWORD PTR [edi+12], 0
	jbe	SHORT $LN32@xmlDictFre

; 823  : 	    iter = &(dict->dict[i]);
; 824  : 	    if (iter->valid == 0)

	cmp	DWORD PTR [ebx+ecx+12], 0
	lea	eax, DWORD PTR [ebx+ecx]
	mov	edx, ecx
	je	SHORT $LN2@xmlDictFre

; 825  : 		continue;
; 826  : 	    inside_dict = 1;

	mov	ecx, 1
	npad	2
$LL5@xmlDictFre:

; 827  : 	    while (iter) {
; 828  : 		next = iter->next;

	mov	esi, DWORD PTR [eax]

; 829  : 		if (!inside_dict)

	test	ecx, ecx
	jne	SHORT $LN16@xmlDictFre

; 830  : 		    xmlFree(iter);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlDictFre:

; 831  : 		dict->nbElems--;

	dec	DWORD PTR [edi+12]

; 832  : 		inside_dict = 0;

	xor	ecx, ecx

; 833  : 		iter = next;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL5@xmlDictFre
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, ecx
$LN2@xmlDictFre:

; 822  : 	for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {

	mov	eax, DWORD PTR _i$1$[ebp]
	add	ebx, 20					; 00000014H
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [edi+8]
	jb	SHORT $LL4@xmlDictFre
$LN32@xmlDictFre:
	pop	ebx
$LN31@xmlDictFre:

; 834  : 	    }
; 835  : 	}
; 836  : 	xmlFree(dict->dict);

	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN14@xmlDictFre:

; 837  :     }
; 838  :     pool = dict->strings;

	mov	eax, DWORD PTR [edi+16]

; 839  :     while (pool != NULL) {

	test	eax, eax
	je	SHORT $LN8@xmlDictFre
$LL7@xmlDictFre:

; 840  :         nextp = pool->next;

	mov	esi, DWORD PTR [eax]

; 841  : 	xmlFree(pool);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4

; 842  : 	pool = nextp;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL7@xmlDictFre
$LN8@xmlDictFre:

; 843  :     }
; 844  :     xmlFree(dict);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	esi
$LN1@xmlDictFre:
	pop	edi

; 845  : }

	pop	ebp
	ret	0
_xmlDictFree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictReference
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlDictReference PROC					; COMDAT

; 638  : xmlDictReference(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN3@xmlDictRef

; 179  :     if ((xmlDictMutex = xmlNewRMutex()) == NULL)

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlDictMutex, eax
	test	eax, eax
	je	SHORT $LN11@xmlDictRef

; 180  :         return(0);
; 181  :     xmlRMutexLock(xmlDictMutex);

	push	eax
	call	_xmlRMutexLock

; 182  : 
; 183  : #ifdef DICT_RANDOMIZATION
; 184  : #ifdef HAVE_RAND_R
; 185  :     rand_seed = time(NULL);
; 186  :     rand_r(& rand_seed);
; 187  : #else
; 188  :     srand(time(NULL));
; 189  : #endif
; 190  : #endif
; 191  :     xmlDictInitialized = 1;
; 192  :     xmlRMutexUnlock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	mov	DWORD PTR _xmlDictInitialized, 1
	call	_xmlRMutexUnlock
	add	esp, 8
$LN3@xmlDictRef:

; 639  :     if (!xmlDictInitialized)
; 640  :         if (!__xmlInitializeDict())
; 641  :             return(-1);
; 642  : 
; 643  :     if (dict == NULL) return -1;

	mov	esi, DWORD PTR _dict$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlDictRef
$LN11@xmlDictRef:
	or	eax, -1
	pop	esi

; 648  : }

	pop	ebp
	ret	0
$LN4@xmlDictRef:

; 644  :     xmlRMutexLock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	call	_xmlRMutexLock

; 645  :     dict->ref_counter++;
; 646  :     xmlRMutexUnlock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	inc	DWORD PTR [esi]
	call	_xmlRMutexUnlock
	add	esp, 8

; 647  :     return(0);

	xor	eax, eax
	pop	esi

; 648  : }

	pop	ebp
	ret	0
_xmlDictReference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCreateSub
_TEXT	SEGMENT
_sub$ = 8						; size = 4
_xmlDictCreateSub PROC					; COMDAT

; 615  : xmlDictCreateSub(xmlDictPtr sub) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlDictCreate
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN2@xmlDictCre

; 616  :     xmlDictPtr dict = xmlDictCreate();
; 617  : 
; 618  :     if ((dict != NULL) && (sub != NULL)) {

	mov	eax, DWORD PTR _sub$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlDictCre

; 619  : #ifdef DICT_DEBUG_PATTERNS
; 620  :         fprintf(stderr, "R");
; 621  : #endif
; 622  :         dict->seed = sub->seed;

	mov	ecx, DWORD PTR [eax+24]

; 623  :         dict->subdict = sub;
; 624  : 	xmlDictReference(dict->subdict);

	push	eax
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+20], eax
	call	_xmlDictReference
	add	esp, 4
$LN5@xmlDictCre:

; 625  :     }
; 626  :     return(dict);
; 627  : }

	mov	eax, esi
$LN2@xmlDictCre:
	pop	esi
	pop	ebp
	ret	0
_xmlDictCreateSub ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictGetUsage
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlDictGetUsage PROC					; COMDAT

; 1276 : xmlDictGetUsage(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _dict$[ebp]
	xor	eax, eax
	test	ecx, ecx
	jne	SHORT $LN4@xmlDictGet

; 1286 :     }
; 1287 :     return(limit);
; 1288 : }

	pop	ebp
	ret	0
$LN4@xmlDictGet:

; 1277 :     xmlDictStringsPtr pool;
; 1278 :     size_t limit = 0;
; 1279 : 
; 1280 :     if (dict == NULL)
; 1281 : 	return(0);
; 1282 :     pool = dict->strings;

	mov	ecx, DWORD PTR [ecx+16]

; 1283 :     while (pool != NULL) {

	test	ecx, ecx
	je	SHORT $LN1@xmlDictGet
	npad	1
$LL2@xmlDictGet:

; 1284 :         limit += pool->size;

	add	eax, DWORD PTR [ecx+12]

; 1285 : 	pool = pool->next;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LL2@xmlDictGet
$LN1@xmlDictGet:

; 1286 :     }
; 1287 :     return(limit);
; 1288 : }

	pop	ebp
	ret	0
_xmlDictGetUsage ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictSetLimit
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_limit$ = 12						; size = 4
_xmlDictSetLimit PROC					; COMDAT

; 1256 : xmlDictSetLimit(xmlDictPtr dict, size_t limit) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _dict$[ebp]
	test	edx, edx
	jne	SHORT $LN2@xmlDictSet

; 1257 :     size_t ret;
; 1258 : 
; 1259 :     if (dict == NULL)
; 1260 : 	return(0);

	xor	eax, eax

; 1263 :     return(ret);
; 1264 : }

	pop	ebp
	ret	0
$LN2@xmlDictSet:

; 1261 :     ret = dict->limit;

	mov	eax, DWORD PTR [edx+28]

; 1262 :     dict->limit = limit;

	mov	ecx, DWORD PTR _limit$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 1263 :     return(ret);
; 1264 : }

	pop	ebp
	ret	0
_xmlDictSetLimit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCreate
_TEXT	SEGMENT
_xmlDictCreate PROC					; COMDAT

; 568  : xmlDictCreate(void) {

	push	esi
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN3@xmlDictCre

; 179  :     if ((xmlDictMutex = xmlNewRMutex()) == NULL)

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlDictMutex, eax
	test	eax, eax
	je	$LN4@xmlDictCre

; 180  :         return(0);
; 181  :     xmlRMutexLock(xmlDictMutex);

	push	eax
	call	_xmlRMutexLock

; 182  : 
; 183  : #ifdef DICT_RANDOMIZATION
; 184  : #ifdef HAVE_RAND_R
; 185  :     rand_seed = time(NULL);
; 186  :     rand_r(& rand_seed);
; 187  : #else
; 188  :     srand(time(NULL));
; 189  : #endif
; 190  : #endif
; 191  :     xmlDictInitialized = 1;
; 192  :     xmlRMutexUnlock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	mov	DWORD PTR _xmlDictInitialized, 1
	call	_xmlRMutexUnlock
	add	esp, 8
$LN3@xmlDictCre:

; 569  :     xmlDictPtr dict;
; 570  : 
; 571  :     if (!xmlDictInitialized)
; 572  :         if (!__xmlInitializeDict())
; 573  :             return(NULL);
; 574  : 
; 575  : #ifdef DICT_DEBUG_PATTERNS
; 576  :     fprintf(stderr, "C");
; 577  : #endif
; 578  : 
; 579  :     dict = xmlMalloc(sizeof(xmlDict));

	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 580  :     if (dict) {

	test	esi, esi
	je	SHORT $LN4@xmlDictCre

; 581  :         dict->ref_counter = 1;
; 582  :         dict->limit = 0;
; 583  : 
; 584  :         dict->size = MIN_DICT_SIZE;
; 585  : 	dict->nbElems = 0;
; 586  :         dict->dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));

	push	2560					; 00000a00H
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+8], 128			; 00000080H
	mov	DWORD PTR [esi+12], 0
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 587  : 	dict->strings = NULL;

	mov	DWORD PTR [esi+16], 0

; 588  : 	dict->subdict = NULL;

	mov	DWORD PTR [esi+20], 0

; 589  :         if (dict->dict) {

	test	eax, eax
	je	SHORT $LN5@xmlDictCre

; 590  : 	    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));

	push	2560					; 00000a00H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 591  : #ifdef DICT_RANDOMIZATION
; 592  :             dict->seed = __xmlRandom();
; 593  : #else
; 594  :             dict->seed = 0;

	mov	DWORD PTR [esi+24], 0

; 595  : #endif
; 596  : 	    return(dict);

	mov	eax, esi
	pop	esi

; 601  : }

	ret	0
$LN5@xmlDictCre:

; 597  :         }
; 598  :         xmlFree(dict);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN4@xmlDictCre:

; 599  :     }
; 600  :     return(NULL);

	xor	eax, eax
	pop	esi

; 601  : }

	ret	0
_xmlDictCreate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlInitializeDict
_TEXT	SEGMENT
_xmlInitializeDict PROC					; COMDAT
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	ret	0
_xmlInitializeDict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT ___xmlInitializeDict
_TEXT	SEGMENT
___xmlInitializeDict PROC				; COMDAT
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN5@xmlInitial

; 176  :     if (xmlDictInitialized)
; 177  :         return(1);
; 178  : 
; 179  :     if ((xmlDictMutex = xmlNewRMutex()) == NULL)

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlDictMutex, eax
	test	eax, eax
	jne	SHORT $LN3@xmlInitial

; 193  :     return(1);
; 194  : }

	ret	0
$LN3@xmlInitial:

; 180  :         return(0);
; 181  :     xmlRMutexLock(xmlDictMutex);

	push	eax
	call	_xmlRMutexLock

; 182  : 
; 183  : #ifdef DICT_RANDOMIZATION
; 184  : #ifdef HAVE_RAND_R
; 185  :     rand_seed = time(NULL);
; 186  :     rand_r(& rand_seed);
; 187  : #else
; 188  :     srand(time(NULL));
; 189  : #endif
; 190  : #endif
; 191  :     xmlDictInitialized = 1;
; 192  :     xmlRMutexUnlock(xmlDictMutex);

	push	DWORD PTR _xmlDictMutex
	mov	DWORD PTR _xmlDictInitialized, 1
	call	_xmlRMutexUnlock
	add	esp, 8
$LN5@xmlInitial:

; 193  :     return(1);
; 194  : }

	mov	eax, 1
	ret	0
___xmlInitializeDict ENDP
_TEXT	ENDS
END
