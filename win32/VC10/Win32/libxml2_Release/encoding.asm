; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\encoding.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__C8D9C3F6_encoding@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlByteConsumed
PUBLIC	_xmlInitCharEncodingHandlers
PUBLIC	_xmlCleanupCharEncodingHandlers
PUBLIC	_xmlRegisterCharEncodingHandler
PUBLIC	_xmlGetCharEncodingHandler
PUBLIC	_xmlFindCharEncodingHandler
PUBLIC	_xmlNewCharEncodingHandler
PUBLIC	_xmlAddEncodingAlias
PUBLIC	_xmlDelEncodingAlias
PUBLIC	_xmlGetEncodingAlias
PUBLIC	_xmlCleanupEncodingAliases
PUBLIC	_xmlParseCharEncoding
PUBLIC	_xmlGetCharEncodingName
PUBLIC	_xmlDetectCharEncoding
PUBLIC	_xmlCharEncOutFunc
PUBLIC	_xmlCharEncInFunc
PUBLIC	_xmlCharEncFirstLine
PUBLIC	_xmlCharEncCloseFunc
PUBLIC	_UTF8Toisolat1
PUBLIC	_isolat1ToUTF8
PUBLIC	_xmlCharEncFirstLineInt
PUBLIC	_xmlCharEncFirstLineInput
PUBLIC	_xmlCharEncInput
PUBLIC	_xmlCharEncOutput
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04OOMJJNCF@UTF8@				; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_05MNCHLHCA@UTF16@				; `string'
PUBLIC	??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@		; `string'
PUBLIC	??_C@_05JHAMEAP@UCS?92@				; `string'
PUBLIC	??_C@_04MDAFHLBC@UCS2@				; `string'
PUBLIC	??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@		; `string'
PUBLIC	??_C@_05FPCKGDIJ@UCS?94@			; `string'
PUBLIC	??_C@_04JFFPNMJE@UCS4@				; `string'
PUBLIC	??_C@_0L@GJIJNDEK@ISO?98859?91@			; `string'
PUBLIC	??_C@_0M@HACBCLE@ISO?9LATIN?91@			; `string'
PUBLIC	??_C@_0M@POJFGGLA@ISO?5LATIN?51@		; `string'
PUBLIC	??_C@_0L@ECKEIAIJ@ISO?98859?92@			; `string'
PUBLIC	??_C@_0M@CMCPEBHH@ISO?9LATIN?92@		; `string'
PUBLIC	??_C@_0M@NFLIDFHD@ISO?5LATIN?52@		; `string'
PUBLIC	??_C@_0L@FLLPLBMI@ISO?98859?93@			; `string'
PUBLIC	??_C@_0L@BEPOCHAP@ISO?98859?94@			; `string'
PUBLIC	??_C@_0L@NOFBGEO@ISO?98859?95@			; `string'
PUBLIC	??_C@_0L@CGMIEFIN@ISO?98859?96@			; `string'
PUBLIC	??_C@_0L@DPNDHEMM@ISO?98859?97@			; `string'
PUBLIC	??_C@_0L@LIELGIAD@ISO?98859?98@			; `string'
PUBLIC	??_C@_0L@KBFAFJEC@ISO?98859?99@			; `string'
PUBLIC	??_C@_0M@LMIFKILO@ISO?92022?9JP@		; `string'
PUBLIC	??_C@_09NDNIACC@SHIFT_JIS@			; `string'
PUBLIC	??_C@_06KCFOODCD@EUC?9JP@			; `string'
PUBLIC	??_C@_06JJAKJGEC@EBCDIC@			; `string'
PUBLIC	??_C@_09DNLJOPNC@Shift?9JIS@			; `string'
PUBLIC	??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@ ; `string'
PUBLIC	??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@ ; `string'
PUBLIC	??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@ ; `string'
PUBLIC	??_C@_08NBDJLNFA@UTF?916LE@			; `string'
PUBLIC	??_C@_08NLKHJAFK@UTF?916BE@			; `string'
PUBLIC	??_C@_05CCNLIHFO@ASCII@				; `string'
PUBLIC	??_C@_08DIBGJKBD@US?9ASCII@			; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@ ; `string'
PUBLIC	??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@	; `string'
PUBLIC	??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@ ; `string'
PUBLIC	??_C@_06JNCBEIJA@ebcdic@			; `string'
PUBLIC	??_C@_09BNGJAIJK@EBCDIC?9US@			; `string'
PUBLIC	??_C@_07LDANGMFL@IBM?9037@			; `string'
PUBLIC	??_C@_09IOCPDDIN@SHIFT?9JIS@			; `string'
PUBLIC	??_C@_09LOKLFMHN@Shift_JIS@			; `string'
PUBLIC	??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@ ; `string'
PUBLIC	??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@ ; `string'
PUBLIC	??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@ ; `string'
PUBLIC	??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@ ; `string'
PUBLIC	??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@		; `string'
PUBLIC	??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@ ; `string'
EXTRN	_xmlGetUTF8Char:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__libiconv_open:PROC
EXTRN	__imp__libiconv:PROC
EXTRN	__imp__libiconv_close:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufEnd:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlBufferShrink:PROC
EXTRN	_xmlBufferGrow:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_UTF8ToHtml:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufGrow:PROC
EXTRN	_xmlBufAvail:PROC
EXTRN	_xmlBufAddLen:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlUTF16LEHandler DD 01H DUP (?)
_xmlUTF16BEHandler DD 01H DUP (?)
_xmlCharEncodingAliases DD 01H DUP (?)
_xmlCharEncodingAliasesNb DD 01H DUP (?)
_xmlCharEncodingAliasesMax DD 01H DUP (?)
_handlers DD	01H DUP (?)
_nbCharEncodingHandler DD 01H DUP (?)
_xmlDefaultCharEncodingHandler DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
CONST	SEGMENT
??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@ DB 'output convers'
	DB	'ion failed due to conv error, bytes %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
CONST	SEGMENT
??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@ DB '&#%d;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
CONST	SEGMENT
??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@ DB 'xmlCharEncOut'
	DB	'Func: no output function !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
CONST	SEGMENT
??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@ DB 'input conver'
	DB	'sion failed due to input error, bytes %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
CONST	SEGMENT
??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@ DB '0x%02X'
	DB	' 0x%02X 0x%02X 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@
CONST	SEGMENT
??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@ DB 'iconv : pro'
	DB	'blems with filters for ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOKLFMHN@Shift_JIS@
CONST	SEGMENT
??_C@_09LOKLFMHN@Shift_JIS@ DB 'Shift_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOCPDDIN@SHIFT?9JIS@
CONST	SEGMENT
??_C@_09IOCPDDIN@SHIFT?9JIS@ DB 'SHIFT-JIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDANGMFL@IBM?9037@
CONST	SEGMENT
??_C@_07LDANGMFL@IBM?9037@ DB 'IBM-037', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNGJAIJK@EBCDIC?9US@
CONST	SEGMENT
??_C@_09BNGJAIJK@EBCDIC?9US@ DB 'EBCDIC-US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNCBEIJA@ebcdic@
CONST	SEGMENT
??_C@_06JNCBEIJA@ebcdic@ DB 'ebcdic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@
CONST	SEGMENT
??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@ DB 'xmlRegisterCharE'
	DB	'ncodingHandler: Too many handler registered, see %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@
CONST	SEGMENT
??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@ DB 'MAX_ENCODING_HANDLERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@
CONST	SEGMENT
??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@ DB 'xmlRegisterCharE'
	DB	'ncodingHandler: NULL handler !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIBGJKBD@US?9ASCII@
CONST	SEGMENT
??_C@_08DIBGJKBD@US?9ASCII@ DB 'US-ASCII', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCNLIHFO@ASCII@
CONST	SEGMENT
??_C@_05CCNLIHFO@ASCII@ DB 'ASCII', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLKHJAFK@UTF?916BE@
CONST	SEGMENT
??_C@_08NLKHJAFK@UTF?916BE@ DB 'UTF-16BE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBDJLNFA@UTF?916LE@
CONST	SEGMENT
??_C@_08NBDJLNFA@UTF?916LE@ DB 'UTF-16LE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@
CONST	SEGMENT
??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@ DB 'xmlInitCharEnc'
	DB	'odingHandlers : out of memory !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
CONST	SEGMENT
??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@ DB 'xmlNewCharEnco'
	DB	'dingHandler : out of memory !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@
CONST	SEGMENT
??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@ DB 'xmlNewCharEnc'
	DB	'odingHandler : no name !', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DNLJOPNC@Shift?9JIS@
CONST	SEGMENT
??_C@_09DNLJOPNC@Shift?9JIS@ DB 'Shift-JIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJAKJGEC@EBCDIC@
CONST	SEGMENT
??_C@_06JJAKJGEC@EBCDIC@ DB 'EBCDIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFOODCD@EUC?9JP@
CONST	SEGMENT
??_C@_06KCFOODCD@EUC?9JP@ DB 'EUC-JP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NDNIACC@SHIFT_JIS@
CONST	SEGMENT
??_C@_09NDNIACC@SHIFT_JIS@ DB 'SHIFT_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMIFKILO@ISO?92022?9JP@
CONST	SEGMENT
??_C@_0M@LMIFKILO@ISO?92022?9JP@ DB 'ISO-2022-JP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBFAFJEC@ISO?98859?99@
CONST	SEGMENT
??_C@_0L@KBFAFJEC@ISO?98859?99@ DB 'ISO-8859-9', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIELGIAD@ISO?98859?98@
CONST	SEGMENT
??_C@_0L@LIELGIAD@ISO?98859?98@ DB 'ISO-8859-8', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPNDHEMM@ISO?98859?97@
CONST	SEGMENT
??_C@_0L@DPNDHEMM@ISO?98859?97@ DB 'ISO-8859-7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CGMIEFIN@ISO?98859?96@
CONST	SEGMENT
??_C@_0L@CGMIEFIN@ISO?98859?96@ DB 'ISO-8859-6', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NOFBGEO@ISO?98859?95@
CONST	SEGMENT
??_C@_0L@NOFBGEO@ISO?98859?95@ DB 'ISO-8859-5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEPOCHAP@ISO?98859?94@
CONST	SEGMENT
??_C@_0L@BEPOCHAP@ISO?98859?94@ DB 'ISO-8859-4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLLPLBMI@ISO?98859?93@
CONST	SEGMENT
??_C@_0L@FLLPLBMI@ISO?98859?93@ DB 'ISO-8859-3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFLIDFHD@ISO?5LATIN?52@
CONST	SEGMENT
??_C@_0M@NFLIDFHD@ISO?5LATIN?52@ DB 'ISO LATIN 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMCPEBHH@ISO?9LATIN?92@
CONST	SEGMENT
??_C@_0M@CMCPEBHH@ISO?9LATIN?92@ DB 'ISO-LATIN-2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECKEIAIJ@ISO?98859?92@
CONST	SEGMENT
??_C@_0L@ECKEIAIJ@ISO?98859?92@ DB 'ISO-8859-2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POJFGGLA@ISO?5LATIN?51@
CONST	SEGMENT
??_C@_0M@POJFGGLA@ISO?5LATIN?51@ DB 'ISO LATIN 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HACBCLE@ISO?9LATIN?91@
CONST	SEGMENT
??_C@_0M@HACBCLE@ISO?9LATIN?91@ DB 'ISO-LATIN-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91@
CONST	SEGMENT
??_C@_0L@GJIJNDEK@ISO?98859?91@ DB 'ISO-8859-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFPNMJE@UCS4@
CONST	SEGMENT
??_C@_04JFFPNMJE@UCS4@ DB 'UCS4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPCKGDIJ@UCS?94@
CONST	SEGMENT
??_C@_05FPCKGDIJ@UCS?94@ DB 'UCS-4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
CONST	SEGMENT
??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@ DB 'ISO-10646-UCS-4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDAFHLBC@UCS2@
CONST	SEGMENT
??_C@_04MDAFHLBC@UCS2@ DB 'UCS2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JHAMEAP@UCS?92@
CONST	SEGMENT
??_C@_05JHAMEAP@UCS?92@ DB 'UCS-2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
CONST	SEGMENT
??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@ DB 'ISO-10646-UCS-2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNCHLHCA@UTF16@
CONST	SEGMENT
??_C@_05MNCHLHCA@UTF16@ DB 'UTF16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOMJJNCF@UTF8@
CONST	SEGMENT
??_C@_04OOMJJNCF@UTF8@ DB 'UTF8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlLittleEndian DD 01H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncOutputChunk
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_xmlEncOutputChunk PROC					; COMDAT

; 1947 :                   int *outlen, const unsigned char *in, int *inlen) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN2@xmlEncOutp

; 1948 :     int ret;
; 1949 : 
; 1950 :     if (handler->output != NULL) {
; 1951 :         ret = handler->output(out, outlen, in, inlen);

	push	DWORD PTR _inlen$[ebp]
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _outlen$[ebp]
	push	DWORD PTR _out$[ebp]
	call	ecx
	add	esp, 16					; 00000010H

; 1971 : }

	pop	ebp
	ret	0
$LN2@xmlEncOutp:

; 1952 :     }
; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN4@xmlEncOutp

; 1955 :         ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);

	mov	DWORD PTR _handler$[ebp], eax

; 1971 : }

	pop	ebp

; 1955 :         ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);

	jmp	_xmlIconvWrapper
$LN4@xmlEncOutp:

; 1956 :     }
; 1957 : #endif /* LIBXML_ICONV_ENABLED */
; 1958 : #ifdef LIBXML_ICU_ENABLED
; 1959 :     else if (handler->uconv_out != NULL) {
; 1960 :         ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,
; 1961 :                               TRUE);
; 1962 :     }
; 1963 : #endif /* LIBXML_ICU_ENABLED */
; 1964 :     else {
; 1965 :         *outlen = 0;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1966 :         *inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1967 :         ret = -4;
; 1968 :     }
; 1969 : 
; 1970 :     return(ret);

	mov	eax, -4					; fffffffcH

; 1971 : }

	pop	ebp
	ret	0
_xmlEncOutputChunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncInputChunk
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_flush$ = 28						; size = 4
_xmlEncInputChunk PROC					; COMDAT

; 1917 :                  int *outlen, const unsigned char *in, int *inlen, int flush) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN2@xmlEncInpu

; 1918 :     int ret;
; 1919 :     (void)flush;
; 1920 : 
; 1921 :     if (handler->input != NULL) {
; 1922 :         ret = handler->input(out, outlen, in, inlen);

	push	DWORD PTR _inlen$[ebp]
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _outlen$[ebp]
	push	DWORD PTR _out$[ebp]
	call	ecx
	add	esp, 16					; 00000010H

; 1942 : }

	pop	ebp
	ret	0
$LN2@xmlEncInpu:

; 1923 :     }
; 1924 : #ifdef LIBXML_ICONV_ENABLED
; 1925 :     else if (handler->iconv_in != NULL) {

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN4@xmlEncInpu

; 1926 :         ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);

	push	DWORD PTR _inlen$[ebp]
	push	DWORD PTR _in$[ebp]
	push	DWORD PTR _outlen$[ebp]
	push	DWORD PTR _out$[ebp]
	push	eax
	call	_xmlIconvWrapper
	add	esp, 20					; 00000014H

; 1942 : }

	pop	ebp
	ret	0
$LN4@xmlEncInpu:

; 1927 :     }
; 1928 : #endif /* LIBXML_ICONV_ENABLED */
; 1929 : #ifdef LIBXML_ICU_ENABLED
; 1930 :     else if (handler->uconv_in != NULL) {
; 1931 :         ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen,
; 1932 :                               flush);
; 1933 :     }
; 1934 : #endif /* LIBXML_ICU_ENABLED */
; 1935 :     else {
; 1936 :         *outlen = 0;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1937 :         *inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1938 :         ret = -2;
; 1939 :     }
; 1940 : 
; 1941 :     return(ret);

	mov	eax, -2					; fffffffeH

; 1942 : }

	pop	ebp
	ret	0
_xmlEncInputChunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlIconvWrapper
_TEXT	SEGMENT
_icv_in$ = -16						; size = 4
_icv_out$ = -12						; size = 4
_icv_outlen$ = -8					; size = 4
_icv_inlen$ = -4					; size = 4
_cd$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_xmlIconvWrapper PROC					; COMDAT

; 1802 :                 const unsigned char *in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	esi, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR _icv_in$[ebp], ecx
	mov	DWORD PTR _icv_out$[ebp], eax
	test	eax, eax
	je	$LN3@xmlIconvWr

; 1803 :     size_t icv_inlen, icv_outlen;
; 1804 :     const char *icv_in = (const char *) in;
; 1805 :     char *icv_out = (char *) out;
; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	test	esi, esi
	je	$LN4@xmlIconvWr
	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlIconvWr
	test	ecx, ecx
	je	SHORT $LN3@xmlIconvWr

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _icv_inlen$[ebp], eax

; 1813 :     icv_outlen = *outlen;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _icv_outlen$[ebp], eax

; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	lea	eax, DWORD PTR _icv_outlen$[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_out$[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_inlen$[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_in$[ebp]
	push	eax
	push	DWORD PTR _cd$[ebp]
	call	DWORD PTR __imp__libiconv

; 1815 :     *inlen -= icv_inlen;

	mov	edx, DWORD PTR _icv_inlen$[ebp]
	add	esp, 20					; 00000014H
	sub	DWORD PTR [edi], edx

; 1816 :     *outlen -= icv_outlen;

	mov	ecx, DWORD PTR _icv_outlen$[ebp]
	sub	DWORD PTR [esi], ecx

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	test	edx, edx
	jne	SHORT $LN6@xmlIconvWr
	cmp	eax, -1
	je	SHORT $LN6@xmlIconvWr

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	pop	edi
	xor	eax, eax

; 1838 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlIconvWr:

; 1818 : #ifdef EILSEQ
; 1819 :         if (errno == EILSEQ) {

	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN7@xmlIconvWr

; 1820 :             return -2;

	pop	edi
	mov	eax, -2					; fffffffeH

; 1838 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlIconvWr:

; 1821 :         } else
; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	call	esi
	cmp	DWORD PTR [eax], 7
	je	SHORT $LN4@xmlIconvWr

; 1825 :             return -1;
; 1826 :         } else
; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	call	esi
	pop	edi

; 1830 :             return -3;
; 1831 :         } else
; 1832 : #endif
; 1833 :         {
; 1834 :             return -3;

	mov	eax, -3					; fffffffdH

; 1838 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlIconvWr:

; 1809 :         if (outlen != NULL) *outlen = 0;

	test	esi, esi
	je	SHORT $LN4@xmlIconvWr
	mov	DWORD PTR [esi], 0
$LN4@xmlIconvWr:
	pop	edi

; 1810 :         return(-1);

	or	eax, -1

; 1838 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIconvWrapper ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16BE
_TEXT	SEGMENT
_instart$1$ = -16					; size = 4
_inend$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
_outend$1$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_processed$1$ = 16					; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16BE PROC					; COMDAT

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	mov	ebx, esi
	mov	eax, DWORD PTR _outb$[ebp]
	mov	edi, eax
	mov	DWORD PTR _out$1$[ebp], eax
	mov	DWORD PTR _processed$1$[ebp], ebx
	mov	DWORD PTR _instart$1$[ebp], esi
	test	eax, eax
	je	$LN8@UTF8ToUTF1

; 824  :     unsigned short* out = (unsigned short*) outb;
; 825  :     const unsigned char* processed = in;
; 826  :     const unsigned char *const instart = in;
; 827  :     unsigned short* outstart= out;
; 828  :     unsigned short* outend;
; 829  :     const unsigned char* inend;
; 830  :     unsigned int c, d;
; 831  :     int trailing;
; 832  :     unsigned char *tmp;
; 833  :     unsigned short tmp1, tmp2;
; 834  : 
; 835  :     /* UTF-16BE has no BOM */
; 836  :     if ((outb == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	mov	edx, DWORD PTR _outlen$[ebp]
	test	edx, edx
	je	$LN8@UTF8ToUTF1
	mov	eax, DWORD PTR _inlen$[ebp]
	test	eax, eax
	je	$LN8@UTF8ToUTF1

; 837  :     if (in == NULL) {

	test	esi, esi
	jne	SHORT $LN9@UTF8ToUTF1

; 838  : 	*outlen = 0;

	mov	DWORD PTR [edx], esi
	pop	edi

; 839  : 	*inlen = 0;

	mov	DWORD PTR [eax], esi

; 840  : 	return(0);

	xor	eax, eax

; 911  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@UTF8ToUTF1:

; 841  :     }
; 842  :     inend= in + *inlen;

	mov	ecx, DWORD PTR [eax]

; 843  :     outend = out + (*outlen / 2);

	mov	eax, DWORD PTR [edx]
	add	ecx, esi
	cdq
	sub	eax, edx
	mov	DWORD PTR _inend$1$[ebp], ecx
	sar	eax, 1
	mov	edx, edi
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _outend$1$[ebp], eax

; 844  :     while (in < inend) {

	cmp	esi, ecx
	jae	$LN3@UTF8ToUTF1
	mov	edx, ebx
$LL2@UTF8ToUTF1:

; 845  :       d= *in++;

	movzx	eax, BYTE PTR [esi]
	inc	esi

; 846  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN10@UTF8ToUTF1
	xor	ebx, ebx
	jmp	SHORT $LN19@UTF8ToUTF1
$LN10@UTF8ToUTF1:

; 847  :       else if (d < 0xC0)  {

	cmp	eax, 192				; 000000c0H
	jb	$LN18@UTF8ToUTF1

; 848  :           /* trailing byte in leading position */
; 849  : 	  *outlen = out - outstart;
; 850  : 	  *inlen = processed - instart;
; 851  : 	  return(-2);
; 852  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	eax, 224				; 000000e0H
	jae	SHORT $LN14@UTF8ToUTF1
	and	eax, 31					; 0000001fH
	mov	ebx, 1
	jmp	SHORT $LN19@UTF8ToUTF1
$LN14@UTF8ToUTF1:

; 853  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	eax, 240				; 000000f0H
	jae	SHORT $LN16@UTF8ToUTF1
	and	eax, 15					; 0000000fH
	mov	ebx, 2
	jmp	SHORT $LN19@UTF8ToUTF1
$LN16@UTF8ToUTF1:

; 854  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	eax, 248				; 000000f8H
	jae	$LN18@UTF8ToUTF1
	and	eax, 7
	mov	ebx, 3
$LN19@UTF8ToUTF1:

; 860  :       }
; 861  : 
; 862  :       if (inend - in < trailing) {

	sub	ecx, esi
	cmp	ecx, ebx
	jl	$LN51@UTF8ToUTF1

; 863  :           break;
; 864  :       }
; 865  : 
; 866  :       for ( ; trailing; trailing--) {

	test	ebx, ebx
	je	SHORT $LN36@UTF8ToUTF1
	mov	edi, DWORD PTR _inend$1$[ebp]
$LL6@UTF8ToUTF1:

; 867  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))  break;

	cmp	esi, edi
	jae	SHORT $LN47@UTF8ToUTF1
	movzx	edx, BYTE PTR [esi]
	inc	esi
	mov	ecx, edx
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN47@UTF8ToUTF1

; 868  :           c <<= 6;
; 869  :           c |= d & 0x3F;

	and	edx, 63					; 0000003fH
	shl	eax, 6
	or	eax, edx
	sub	ebx, 1
	jne	SHORT $LL6@UTF8ToUTF1
$LN47@UTF8ToUTF1:
	mov	edi, DWORD PTR _out$1$[ebp]
$LN36@UTF8ToUTF1:

; 870  :       }
; 871  : 
; 872  :       /* assertion: c is a single UTF-4 value */
; 873  :         if (c < 0x10000) {

	cmp	eax, 65536				; 00010000H
	jae	SHORT $LN23@UTF8ToUTF1

; 874  :             if (out >= outend)  break;

	cmp	edi, DWORD PTR _outend$1$[ebp]
	jae	$LN51@UTF8ToUTF1

; 875  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN26@UTF8ToUTF1

; 876  : 		tmp = (unsigned char *) out;
; 877  : 		*tmp = c >> 8;

	mov	ecx, eax

; 878  : 		*(tmp + 1) = c;

	mov	BYTE PTR [edi+1], al
	shr	ecx, 8
	mov	BYTE PTR [edi], cl

; 879  : 		out++;
; 880  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN26@UTF8ToUTF1:

; 881  : 		*out++ = c;

	mov	WORD PTR [edi], ax

; 882  : 	    }
; 883  :         }

	jmp	SHORT $LN32@UTF8ToUTF1
$LN23@UTF8ToUTF1:

; 884  :         else if (c < 0x110000) {

	cmp	eax, 1114112				; 00110000H
	jae	SHORT $LN51@UTF8ToUTF1

; 885  :             if (out+1 >= outend)  break;

	lea	ebx, DWORD PTR [edi+2]
	cmp	ebx, DWORD PTR _outend$1$[ebp]
	jae	SHORT $LN51@UTF8ToUTF1

; 886  :             c -= 0x10000;

	sub	eax, 65536				; 00010000H
	mov	edx, eax
	shr	eax, 10					; 0000000aH
	and	edx, 1023				; 000003ffH
	or	eax, 55296				; 0000d800H
	or	edx, 56320				; 0000dc00H
	movzx	eax, ax

; 887  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN31@UTF8ToUTF1

; 888  : 		tmp1 = 0xD800 | (c >> 10);

	mov	ecx, eax

; 889  : 		tmp = (unsigned char *) out;
; 890  : 		*tmp = tmp1 >> 8;

	shr	eax, 8
	mov	BYTE PTR [edi], al

; 891  : 		*(tmp + 1) = (unsigned char) tmp1;

	mov	BYTE PTR [edi+1], cl

; 892  : 		out++;

	mov	edi, ebx

; 893  : 
; 894  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	movzx	ecx, dx

; 895  : 		tmp = (unsigned char *) out;
; 896  : 		*tmp = tmp2 >> 8;

	mov	eax, ecx
	shr	eax, 8
	mov	BYTE PTR [edi], al

; 897  : 		*(tmp + 1) = (unsigned char) tmp2;

	mov	BYTE PTR [edi+1], cl

; 898  : 		out++;
; 899  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN31@UTF8ToUTF1:

; 900  : 		*out++ = 0xD800 | (c >> 10);

	mov	WORD PTR [edi], ax
	mov	edi, ebx

; 901  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	WORD PTR [edi], dx
$LN32@UTF8ToUTF1:

; 902  : 	    }
; 903  :         }
; 904  :         else
; 905  : 	    break;
; 906  : 	processed = in;

	mov	ecx, DWORD PTR _inend$1$[ebp]
	add	edi, 2
	mov	DWORD PTR _out$1$[ebp], edi
	mov	edx, esi
	mov	DWORD PTR _processed$1$[ebp], edx
	cmp	esi, ecx
	jb	$LL2@UTF8ToUTF1
$LN51@UTF8ToUTF1:

; 907  :     }
; 908  :     *outlen = (out - outstart) * 2;

	mov	ebx, DWORD PTR _processed$1$[ebp]
$LN3@UTF8ToUTF1:
	sub	edi, DWORD PTR _outb$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	and	edi, -2					; fffffffeH

; 909  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _inlen$[ebp]
	sub	ebx, DWORD PTR _instart$1$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	mov	DWORD PTR [ecx], ebx

; 910  :     return(*outlen);

	mov	eax, DWORD PTR [eax]

; 911  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@UTF8ToUTF1:

; 855  :       else {
; 856  :           /* no chance for this in UTF-16 */
; 857  : 	  *outlen = out - outstart;

	sub	edi, DWORD PTR _outb$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]

; 858  : 	  *inlen = processed - instart;

	mov	ecx, DWORD PTR _inlen$[ebp]
	sar	edi, 1
	sub	edx, DWORD PTR _instart$1$[ebp]
	mov	DWORD PTR [eax], edi

; 859  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	pop	edi

; 911  : }

	pop	esi
	mov	DWORD PTR [ecx], edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@UTF8ToUTF1:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8ToUTF16BE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF16BEToUTF8
_TEXT	SEGMENT
_inend$1$ = -20						; size = 4
_outstart$1$ = -16					; size = 4
_xmlLittleEndian$1$ = -12				; size = 4
_in$1$ = -8						; size = 4
_outend$1$ = -4						; size = 4
_processed$1$ = 8					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF16BEToUTF8 PROC					; COMDAT

; 734  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	edi, DWORD PTR _inb$[ebp]
	mov	ebx, edi
	mov	eax, DWORD PTR [eax]
	add	eax, esi
	mov	DWORD PTR _outstart$1$[ebp], esi
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _outend$1$[ebp], eax
	mov	eax, ecx
	mov	DWORD PTR _processed$1$[ebp], edi
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN39@UTF16BEToU

; 735  :     unsigned char* outstart = out;
; 736  :     const unsigned char* processed = inb;
; 737  :     unsigned char* outend = out + *outlen;
; 738  :     unsigned short* in = (unsigned short*) inb;
; 739  :     unsigned short* inend;
; 740  :     unsigned int c, d, inlen;
; 741  :     unsigned char *tmp;
; 742  :     int bits;
; 743  : 
; 744  :     if ((*inlenb % 2) == 1)

	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN39@UTF16BEToU:
	cmp	eax, 1
	jne	SHORT $LN7@UTF16BEToU

; 745  :         (*inlenb)--;

	dec	ecx
	mov	DWORD PTR [edx], ecx
$LN7@UTF16BEToU:

; 746  :     inlen = *inlenb / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx

; 747  :     inend= in + inlen;

	mov	edx, ebx
	sar	eax, 1
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _inend$1$[ebp], ecx

; 748  :     while (in < inend) {

	cmp	edx, ecx
	jae	$LN36@UTF16BEToU
	mov	eax, DWORD PTR _xmlLittleEndian
	mov	DWORD PTR _xmlLittleEndian$1$[ebp], eax
$LL2@UTF16BEToU:

; 749  : 	if (xmlLittleEndian) {

	lea	edi, DWORD PTR [ebx+2]
	test	eax, eax
	je	SHORT $LN8@UTF16BEToU

; 750  : 	    tmp = (unsigned char *) in;
; 751  : 	    c = *tmp++;

	movzx	eax, BYTE PTR [ebx]

; 752  : 	    c = c << 8;
; 753  : 	    c = c | (unsigned int) *tmp;

	movzx	edx, BYTE PTR [ebx+1]
	shl	eax, 8
	or	edx, eax

; 754  : 	    in++;
; 755  : 	} else {

	jmp	SHORT $LN9@UTF16BEToU
$LN8@UTF16BEToU:

; 756  : 	    c= *in++;

	movzx	edx, WORD PTR [ebx]
$LN9@UTF16BEToU:

; 757  : 	}
; 758  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	eax, edx
	mov	ebx, edi
	and	eax, 64512				; 0000fc00H
	mov	DWORD PTR _in$1$[ebp], ebx
	cmp	eax, 55296				; 0000d800H
	jne	SHORT $LN15@UTF16BEToU

; 759  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	cmp	edi, ecx
	jae	$LN14@UTF16BEToU

; 760  : 		*outlen = out - outstart;
; 761  : 		*inlenb = processed - inb;
; 762  : 	        return(-2);
; 763  : 	    }
; 764  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian$1$[ebp], 0
	lea	ebx, DWORD PTR [edi+2]
	mov	DWORD PTR _in$1$[ebp], ebx
	je	SHORT $LN12@UTF16BEToU

; 765  : 		tmp = (unsigned char *) in;
; 766  : 		d = *tmp++;

	movzx	ecx, BYTE PTR [edi]

; 767  : 		d = d << 8;
; 768  : 		d = d | (unsigned int) *tmp;

	movzx	eax, BYTE PTR [edi+1]
	shl	ecx, 8
	or	ecx, eax

; 769  : 		in++;
; 770  : 	    } else {

	jmp	SHORT $LN13@UTF16BEToU
$LN12@UTF16BEToU:

; 771  : 		d= *in++;

	movzx	ecx, WORD PTR [edi]
$LN13@UTF16BEToU:

; 772  : 	    }
; 773  :             if ((d & 0xFC00) == 0xDC00) {

	mov	eax, ecx
	and	eax, 64512				; 0000fc00H
	cmp	eax, 56320				; 0000dc00H
	jne	$LN14@UTF16BEToU

; 774  :                 c &= 0x03FF;
; 775  :                 c <<= 10;

	and	edx, 1023				; 000003ffH

; 776  :                 c |= d & 0x03FF;

	and	ecx, 1023				; 000003ffH
	shl	edx, 10					; 0000000aH
	or	edx, ecx

; 777  :                 c += 0x10000;

	add	edx, 65536				; 00010000H
$LN15@UTF16BEToU:

; 782  : 	        return(-2);
; 783  : 	    }
; 784  :         }
; 785  : 
; 786  : 	/* assertion: c is a single UTF-4 value */
; 787  :         if (out >= outend)

	cmp	esi, DWORD PTR _outend$1$[ebp]
	jae	$LN38@UTF16BEToU

; 788  : 	    break;
; 789  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	lea	edi, DWORD PTR [esi+1]
	cmp	edx, 128				; 00000080H
	jae	SHORT $LN17@UTF16BEToU
	mov	ecx, -6					; fffffffaH
	mov	al, dl
	jmp	SHORT $LN22@UTF16BEToU
$LN17@UTF16BEToU:

; 790  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	mov	eax, edx
	cmp	edx, 2048				; 00000800H
	jae	SHORT $LN19@UTF16BEToU
	shr	eax, 6
	xor	ecx, ecx
	and	al, 31					; 0000001fH
	or	al, 192					; 000000c0H
	jmp	SHORT $LN22@UTF16BEToU
$LN19@UTF16BEToU:

; 791  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	cmp	edx, 65536				; 00010000H
	jae	SHORT $LN21@UTF16BEToU
	shr	eax, 12					; 0000000cH
	mov	ecx, 6
	and	al, 15					; 0000000fH
	or	al, 224					; 000000e0H
	jmp	SHORT $LN22@UTF16BEToU
$LN21@UTF16BEToU:

; 792  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	shr	eax, 18					; 00000012H
	mov	ecx, 12					; 0000000cH
	or	al, 240					; 000000f0H
$LN22@UTF16BEToU:

; 793  : 
; 794  :         for ( ; bits >= 0; bits-= 6) {

	mov	BYTE PTR [esi], al
	mov	esi, edi
	test	ecx, ecx
	js	SHORT $LN27@UTF16BEToU
	mov	ebx, DWORD PTR _outend$1$[ebp]
	npad	5
$LL6@UTF16BEToU:

; 795  :             if (out >= outend)

	cmp	esi, ebx
	jae	SHORT $LN37@UTF16BEToU

; 796  : 	        break;
; 797  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	eax, edx
	shr	eax, cl
	and	al, 63					; 0000003fH
	or	al, 128					; 00000080H
	mov	BYTE PTR [esi], al
	inc	esi
	sub	ecx, 6
	jns	SHORT $LL6@UTF16BEToU
$LN37@UTF16BEToU:
	mov	ebx, DWORD PTR _in$1$[ebp]
$LN27@UTF16BEToU:

; 748  :     while (in < inend) {

	mov	ecx, DWORD PTR _inend$1$[ebp]

; 798  :         }
; 799  : 	processed = (const unsigned char*) in;

	mov	edi, ebx
	mov	DWORD PTR _processed$1$[ebp], ebx
	cmp	ebx, ecx
	jae	SHORT $LN36@UTF16BEToU

; 748  :     while (in < inend) {

	mov	eax, DWORD PTR _xmlLittleEndian$1$[ebp]
	jmp	$LL2@UTF16BEToU
$LN14@UTF16BEToU:

; 778  :             }
; 779  :             else {
; 780  : 		*outlen = out - outstart;

	mov	eax, DWORD PTR _outlen$[ebp]
	sub	esi, DWORD PTR _outstart$1$[ebp]

; 781  : 		*inlenb = processed - inb;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR _processed$1$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]

; 804  : }

	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@UTF16BEToU:

; 782  : 	        return(-2);
; 783  : 	    }
; 784  :         }
; 785  : 
; 786  : 	/* assertion: c is a single UTF-4 value */
; 787  :         if (out >= outend)

	mov	edi, DWORD PTR _processed$1$[ebp]
$LN36@UTF16BEToU:

; 800  :     }
; 801  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _outlen$[ebp]
	sub	esi, DWORD PTR _outstart$1$[ebp]

; 802  :     *inlenb = processed - inb;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	sub	edi, DWORD PTR _inb$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edi

; 803  :     return(*outlen);

	mov	eax, DWORD PTR [eax]
	pop	edi

; 804  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF16BEToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16
_TEXT	SEGMENT
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16 PROC					; COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _in$[ebp]
	test	eax, eax
	jne	SHORT $LN2@UTF8ToUTF1

; 691  :     if (in == NULL) {
; 692  : 	/*
; 693  : 	 * initialization, add the Byte Order Mark for UTF-16LE
; 694  : 	 */
; 695  :         if (*outlen >= 2) {

	mov	ecx, DWORD PTR _outlen$[ebp]
	cmp	DWORD PTR [ecx], 2
	jl	SHORT $LN3@UTF8ToUTF1

; 696  : 	    outb[0] = 0xFF;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	WORD PTR [eax], 65279			; 0000feffH

; 697  : 	    outb[1] = 0xFE;
; 698  : 	    *outlen = 2;
; 699  : 	    *inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 2
	mov	DWORD PTR [eax], 0

; 700  : #ifdef DEBUG_ENCODING
; 701  :             xmlGenericError(xmlGenericErrorContext,
; 702  : 		    "Added FFFE Byte Order Mark\n");
; 703  : #endif
; 704  : 	    return(2);

	mov	eax, 2

; 711  : }

	pop	ebp
	ret	0
$LN3@UTF8ToUTF1:

; 705  : 	}
; 706  : 	*outlen = 0;
; 707  : 	*inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [eax], 0

; 708  : 	return(0);

	xor	eax, eax

; 711  : }

	pop	ebp
	ret	0
$LN2@UTF8ToUTF1:

; 709  :     }
; 710  :     return (UTF8ToUTF16LE(outb, outlen, in, inlen));

	mov	DWORD PTR _in$[ebp], eax

; 711  : }

	pop	ebp

; 709  :     }
; 710  :     return (UTF8ToUTF16LE(outb, outlen, in, inlen));

	jmp	_UTF8ToUTF16LE
_UTF8ToUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16LE
_TEXT	SEGMENT
_instart$1$ = -16					; size = 4
_inend$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
_outend$1$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_processed$1$ = 16					; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16LE PROC					; COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	mov	ebx, esi
	mov	eax, DWORD PTR _outb$[ebp]
	mov	edi, eax
	mov	DWORD PTR _out$1$[ebp], eax
	mov	DWORD PTR _processed$1$[ebp], ebx
	mov	DWORD PTR _instart$1$[ebp], esi
	test	eax, eax
	je	$LN8@UTF8ToUTF1

; 582  :     unsigned short* out = (unsigned short*) outb;
; 583  :     const unsigned char* processed = in;
; 584  :     const unsigned char *const instart = in;
; 585  :     unsigned short* outstart= out;
; 586  :     unsigned short* outend;
; 587  :     const unsigned char* inend;
; 588  :     unsigned int c, d;
; 589  :     int trailing;
; 590  :     unsigned char *tmp;
; 591  :     unsigned short tmp1, tmp2;
; 592  : 
; 593  :     /* UTF16LE encoding has no BOM */
; 594  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	mov	edx, DWORD PTR _outlen$[ebp]
	test	edx, edx
	je	$LN8@UTF8ToUTF1
	mov	eax, DWORD PTR _inlen$[ebp]
	test	eax, eax
	je	$LN8@UTF8ToUTF1

; 595  :     if (in == NULL) {

	test	esi, esi
	jne	SHORT $LN9@UTF8ToUTF1

; 596  : 	*outlen = 0;

	mov	DWORD PTR [edx], esi
	pop	edi

; 597  : 	*inlen = 0;

	mov	DWORD PTR [eax], esi

; 598  : 	return(0);

	xor	eax, eax

; 672  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@UTF8ToUTF1:

; 599  :     }
; 600  :     inend= in + *inlen;

	mov	ecx, DWORD PTR [eax]

; 601  :     outend = out + (*outlen / 2);

	mov	eax, DWORD PTR [edx]
	add	ecx, esi
	cdq
	sub	eax, edx
	mov	DWORD PTR _inend$1$[ebp], ecx
	sar	eax, 1
	mov	edx, edi
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _outend$1$[ebp], eax

; 602  :     while (in < inend) {

	cmp	esi, ecx
	jae	$LN3@UTF8ToUTF1
	mov	edx, ebx
$LL2@UTF8ToUTF1:

; 603  :       d= *in++;

	movzx	eax, BYTE PTR [esi]
	inc	esi

; 604  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN10@UTF8ToUTF1
	xor	ebx, ebx
	jmp	SHORT $LN19@UTF8ToUTF1
$LN10@UTF8ToUTF1:

; 605  :       else if (d < 0xC0) {

	cmp	eax, 192				; 000000c0H
	jb	$LN18@UTF8ToUTF1

; 606  :           /* trailing byte in leading position */
; 607  : 	  *outlen = (out - outstart) * 2;
; 608  : 	  *inlen = processed - instart;
; 609  : 	  return(-2);
; 610  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	eax, 224				; 000000e0H
	jae	SHORT $LN14@UTF8ToUTF1
	and	eax, 31					; 0000001fH
	mov	ebx, 1
	jmp	SHORT $LN19@UTF8ToUTF1
$LN14@UTF8ToUTF1:

; 611  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	eax, 240				; 000000f0H
	jae	SHORT $LN16@UTF8ToUTF1
	and	eax, 15					; 0000000fH
	mov	ebx, 2
	jmp	SHORT $LN19@UTF8ToUTF1
$LN16@UTF8ToUTF1:

; 612  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	eax, 248				; 000000f8H
	jae	$LN18@UTF8ToUTF1
	and	eax, 7
	mov	ebx, 3
$LN19@UTF8ToUTF1:

; 618  :       }
; 619  : 
; 620  :       if (inend - in < trailing) {

	sub	ecx, esi
	cmp	ecx, ebx
	jl	$LN51@UTF8ToUTF1

; 621  :           break;
; 622  :       }
; 623  : 
; 624  :       for ( ; trailing; trailing--) {

	test	ebx, ebx
	je	SHORT $LN36@UTF8ToUTF1
	mov	edi, DWORD PTR _inend$1$[ebp]
$LL6@UTF8ToUTF1:

; 625  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	cmp	esi, edi
	jae	SHORT $LN47@UTF8ToUTF1
	movzx	edx, BYTE PTR [esi]
	inc	esi
	mov	ecx, edx
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN47@UTF8ToUTF1

; 626  : 	      break;
; 627  :           c <<= 6;
; 628  :           c |= d & 0x3F;

	and	edx, 63					; 0000003fH
	shl	eax, 6
	or	eax, edx
	sub	ebx, 1
	jne	SHORT $LL6@UTF8ToUTF1
$LN47@UTF8ToUTF1:
	mov	edi, DWORD PTR _out$1$[ebp]
$LN36@UTF8ToUTF1:

; 629  :       }
; 630  : 
; 631  :       /* assertion: c is a single UTF-4 value */
; 632  :         if (c < 0x10000) {

	cmp	eax, 65536				; 00010000H
	jae	SHORT $LN23@UTF8ToUTF1

; 633  :             if (out >= outend)

	cmp	edi, DWORD PTR _outend$1$[ebp]
	jae	$LN51@UTF8ToUTF1

; 634  : 	        break;
; 635  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN26@UTF8ToUTF1

; 636  : 		*out++ = c;

	mov	WORD PTR [edi], ax

; 637  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN26@UTF8ToUTF1:

; 638  : 		tmp = (unsigned char *) out;
; 639  : 		*tmp = c ;

	mov	BYTE PTR [edi], al

; 640  : 		*(tmp + 1) = c >> 8 ;

	shr	eax, 8

; 641  : 		out++;
; 642  : 	    }
; 643  :         }

	jmp	SHORT $LN52@UTF8ToUTF1
$LN23@UTF8ToUTF1:

; 644  :         else if (c < 0x110000) {

	cmp	eax, 1114112				; 00110000H
	jae	SHORT $LN51@UTF8ToUTF1

; 645  :             if (out+1 >= outend)

	lea	edx, DWORD PTR [edi+2]
	cmp	edx, DWORD PTR _outend$1$[ebp]
	jae	SHORT $LN51@UTF8ToUTF1

; 646  : 	        break;
; 647  :             c -= 0x10000;

	sub	eax, 65536				; 00010000H
	mov	ecx, eax
	shr	eax, 10					; 0000000aH
	and	ecx, 1023				; 000003ffH
	or	eax, 55296				; 0000d800H
	or	ecx, 56320				; 0000dc00H
	movzx	eax, ax

; 648  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN31@UTF8ToUTF1

; 649  : 		*out++ = 0xD800 | (c >> 10);

	mov	WORD PTR [edi], ax
	mov	edi, edx

; 650  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	WORD PTR [edi], cx

; 651  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN31@UTF8ToUTF1:

; 652  : 		tmp1 = 0xD800 | (c >> 10);
; 653  : 		tmp = (unsigned char *) out;
; 654  : 		*tmp = (unsigned char) tmp1;

	mov	BYTE PTR [edi], al

; 655  : 		*(tmp + 1) = tmp1 >> 8;

	shr	eax, 8
	mov	BYTE PTR [edi+1], al

; 656  : 		out++;

	mov	edi, edx

; 657  : 
; 658  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	movzx	eax, cx

; 659  : 		tmp = (unsigned char *) out;
; 660  : 		*tmp  = (unsigned char) tmp2;

	mov	BYTE PTR [edi], al

; 661  : 		*(tmp + 1) = tmp2 >> 8;

	shr	eax, 8
$LN52@UTF8ToUTF1:

; 662  : 		out++;
; 663  : 	    }
; 664  :         }
; 665  :         else
; 666  : 	    break;
; 667  : 	processed = in;

	mov	BYTE PTR [edi+1], al
$LN32@UTF8ToUTF1:

; 602  :     while (in < inend) {

	mov	ecx, DWORD PTR _inend$1$[ebp]

; 662  : 		out++;
; 663  : 	    }
; 664  :         }
; 665  :         else
; 666  : 	    break;
; 667  : 	processed = in;

	add	edi, 2
	mov	DWORD PTR _out$1$[ebp], edi
	mov	edx, esi
	mov	DWORD PTR _processed$1$[ebp], edx
	cmp	esi, ecx
	jb	$LL2@UTF8ToUTF1
$LN51@UTF8ToUTF1:

; 668  :     }
; 669  :     *outlen = (out - outstart) * 2;

	mov	ebx, DWORD PTR _processed$1$[ebp]
$LN3@UTF8ToUTF1:
	sub	edi, DWORD PTR _outb$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	and	edi, -2					; fffffffeH

; 670  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _inlen$[ebp]
	sub	ebx, DWORD PTR _instart$1$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	mov	DWORD PTR [ecx], ebx

; 671  :     return(*outlen);

	mov	eax, DWORD PTR [eax]

; 672  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@UTF8ToUTF1:

; 613  :       else {
; 614  : 	/* no chance for this in UTF-16 */
; 615  : 	*outlen = (out - outstart) * 2;

	sub	edi, DWORD PTR _outb$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	and	edi, -2					; fffffffeH

; 616  : 	*inlen = processed - instart;

	mov	ecx, DWORD PTR _inlen$[ebp]
	sub	edx, DWORD PTR _instart$1$[ebp]
	mov	DWORD PTR [eax], edi

; 617  : 	return(-2);

	mov	eax, -2					; fffffffeH
	pop	edi

; 672  : }

	pop	esi
	mov	DWORD PTR [ecx], edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@UTF8ToUTF1:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8ToUTF16LE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF16LEToUTF8
_TEXT	SEGMENT
_outend$1$ = -20					; size = 4
_outstart$1$ = -16					; size = 4
_inend$1$ = -12						; size = 4
_in$1$ = -8						; size = 4
_xmlLittleEndian$1$ = -4				; size = 4
_processed$1$ = 8					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF16LEToUTF8 PROC					; COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _inb$[ebp]
	mov	edi, ecx
	mov	DWORD PTR _outstart$1$[ebp], esi
	mov	eax, DWORD PTR [eax]
	add	eax, esi
	mov	DWORD PTR _processed$1$[ebp], edi
	mov	DWORD PTR _outend$1$[ebp], eax
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	eax, edx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN40@UTF16LEToU

; 497  :     unsigned char* outstart = out;
; 498  :     const unsigned char* processed = inb;
; 499  :     unsigned char* outend = out + *outlen;
; 500  :     unsigned short* in = (unsigned short*) inb;
; 501  :     unsigned short* inend;
; 502  :     unsigned int c, d, inlen;
; 503  :     unsigned char *tmp;
; 504  :     int bits;
; 505  : 
; 506  :     if ((*inlenb % 2) == 1)

	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN40@UTF16LEToU:
	cmp	eax, 1
	jne	SHORT $LN7@UTF16LEToU

; 507  :         (*inlenb)--;

	mov	eax, DWORD PTR _inlenb$[ebp]
	dec	edx
	mov	DWORD PTR [eax], edx
$LN7@UTF16LEToU:

; 508  :     inlen = *inlenb / 2;

	mov	eax, edx
	cdq
	sub	eax, edx

; 509  :     inend = in + inlen;

	mov	edx, ecx
	sar	eax, 1
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _inend$1$[ebp], eax

; 510  :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	cmp	edx, eax
	jae	$LN36@UTF16LEToU
	mov	eax, DWORD PTR _xmlLittleEndian
	mov	DWORD PTR _xmlLittleEndian$1$[ebp], eax
$LL2@UTF16LEToU:
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	ebx, esi
	sub	ebx, DWORD PTR _outstart$1$[ebp]
	lea	eax, DWORD PTR [ebx+5]
	cmp	eax, DWORD PTR [edx]
	jge	$LN36@UTF16LEToU

; 511  :         if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian$1$[ebp], 0
	lea	edi, DWORD PTR [ecx+2]
	je	SHORT $LN8@UTF16LEToU

; 512  : 	    c= *in++;

	movzx	edx, WORD PTR [ecx]

; 513  : 	} else {

	jmp	SHORT $LN9@UTF16LEToU
$LN8@UTF16LEToU:

; 514  : 	    tmp = (unsigned char *) in;
; 515  : 	    c = *tmp++;
; 516  : 	    c = c | (((unsigned int)*tmp) << 8);

	movzx	edx, BYTE PTR [ecx+1]
	movzx	eax, BYTE PTR [ecx]
	shl	edx, 8
	or	edx, eax
$LN9@UTF16LEToU:

; 517  : 	    in++;
; 518  : 	}
; 519  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	eax, edx
	mov	DWORD PTR _in$1$[ebp], edi
	and	eax, 64512				; 0000fc00H
	cmp	eax, 55296				; 0000d800H
	jne	SHORT $LN15@UTF16LEToU

; 520  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	cmp	edi, DWORD PTR _inend$1$[ebp]
	jae	$LN39@UTF16LEToU

; 521  : 		break;
; 522  : 	    }
; 523  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian$1$[ebp], 0
	lea	eax, DWORD PTR [edi+2]
	mov	DWORD PTR _in$1$[ebp], eax
	je	SHORT $LN12@UTF16LEToU

; 524  : 		d = *in++;

	movzx	ecx, WORD PTR [edi]

; 525  : 	    } else {

	jmp	SHORT $LN13@UTF16LEToU
$LN12@UTF16LEToU:

; 526  : 		tmp = (unsigned char *) in;
; 527  : 		d = *tmp++;
; 528  : 		d = d | (((unsigned int)*tmp) << 8);

	movzx	ecx, BYTE PTR [edi+1]
	movzx	eax, BYTE PTR [edi]
	shl	ecx, 8
	or	ecx, eax
$LN13@UTF16LEToU:

; 529  : 		in++;
; 530  : 	    }
; 531  :             if ((d & 0xFC00) == 0xDC00) {

	mov	eax, ecx
	and	eax, 64512				; 0000fc00H
	cmp	eax, 56320				; 0000dc00H
	jne	$LN14@UTF16LEToU

; 532  :                 c &= 0x03FF;
; 533  :                 c <<= 10;

	and	edx, 1023				; 000003ffH

; 534  :                 c |= d & 0x03FF;

	and	ecx, 1023				; 000003ffH
	shl	edx, 10					; 0000000aH
	or	edx, ecx

; 535  :                 c += 0x10000;

	add	edx, 65536				; 00010000H
$LN15@UTF16LEToU:

; 540  : 	        return(-2);
; 541  : 	    }
; 542  :         }
; 543  : 
; 544  : 	/* assertion: c is a single UTF-4 value */
; 545  :         if (out >= outend)

	mov	ebx, DWORD PTR _outend$1$[ebp]
	cmp	esi, ebx
	jae	$LN39@UTF16LEToU

; 546  : 	    break;
; 547  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	lea	edi, DWORD PTR [esi+1]
	cmp	edx, 128				; 00000080H
	jae	SHORT $LN17@UTF16LEToU
	mov	ecx, -6					; fffffffaH
	mov	al, dl
	jmp	SHORT $LN22@UTF16LEToU
$LN17@UTF16LEToU:

; 548  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	mov	eax, edx
	cmp	edx, 2048				; 00000800H
	jae	SHORT $LN19@UTF16LEToU
	shr	eax, 6
	xor	ecx, ecx
	and	al, 31					; 0000001fH
	or	al, 192					; 000000c0H
	jmp	SHORT $LN22@UTF16LEToU
$LN19@UTF16LEToU:

; 549  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	cmp	edx, 65536				; 00010000H
	jae	SHORT $LN21@UTF16LEToU
	shr	eax, 12					; 0000000cH
	mov	ecx, 6
	and	al, 15					; 0000000fH
	or	al, 224					; 000000e0H
	jmp	SHORT $LN22@UTF16LEToU
$LN21@UTF16LEToU:

; 550  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	shr	eax, 18					; 00000012H
	mov	ecx, 12					; 0000000cH
	or	al, 240					; 000000f0H
$LN22@UTF16LEToU:

; 551  : 
; 552  :         for ( ; bits >= 0; bits-= 6) {

	mov	BYTE PTR [esi], al
	mov	esi, edi
	test	ecx, ecx
	js	SHORT $LN37@UTF16LEToU
$LL6@UTF16LEToU:

; 553  :             if (out >= outend)

	cmp	esi, ebx
	jae	SHORT $LN37@UTF16LEToU

; 554  : 	        break;
; 555  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	eax, edx
	shr	eax, cl
	and	al, 63					; 0000003fH
	or	al, 128					; 00000080H
	mov	BYTE PTR [esi], al
	inc	esi
	sub	ecx, 6
	jns	SHORT $LL6@UTF16LEToU
$LN37@UTF16LEToU:

; 556  :         }
; 557  : 	processed = (const unsigned char*) in;

	mov	ecx, DWORD PTR _in$1$[ebp]
	mov	edi, ecx
	mov	DWORD PTR _processed$1$[ebp], edi
	cmp	ecx, DWORD PTR _inend$1$[ebp]
	jb	$LL2@UTF16LEToU

; 510  :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	jmp	SHORT $LN36@UTF16LEToU
$LN14@UTF16LEToU:

; 536  :             }
; 537  :             else {
; 538  : 		*outlen = out - outstart;

	mov	eax, DWORD PTR _outlen$[ebp]

; 539  : 		*inlenb = processed - inb;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	pop	edi

; 562  : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR _processed$1$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, -2					; fffffffeH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@UTF16LEToU:

; 558  :     }
; 559  :     *outlen = out - outstart;

	mov	edi, DWORD PTR _processed$1$[ebp]
$LN36@UTF16LEToU:
	mov	eax, DWORD PTR _outlen$[ebp]
	sub	esi, DWORD PTR _outstart$1$[ebp]

; 560  :     *inlenb = processed - inb;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	sub	edi, DWORD PTR _inb$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edi

; 561  :     return(*outlen);

	mov	eax, DWORD PTR [eax]
	pop	edi

; 562  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF16LEToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF8
_TEXT	SEGMENT
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF8ToUTF8 PROC					; COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _out$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@UTF8ToUTF8

; 358  :     int len;
; 359  : 
; 360  :     if ((out == NULL) || (outlen == NULL) || (inlenb == NULL))

	mov	esi, DWORD PTR _outlen$[ebp]
	test	esi, esi
	je	SHORT $LN3@UTF8ToUTF8
	mov	edi, DWORD PTR _inlenb$[ebp]
	test	edi, edi
	je	SHORT $LN3@UTF8ToUTF8

; 361  : 	return(-1);
; 362  :     if (inb == NULL) {

	mov	edx, DWORD PTR _inb$[ebp]
	test	edx, edx
	jne	SHORT $LN4@UTF8ToUTF8

; 363  :         /* inb == NULL means output is initialized. */
; 364  :         *outlen = 0;

	mov	DWORD PTR [esi], edx

; 365  :         *inlenb = 0;
; 366  :         return(0);

	xor	eax, eax
	mov	DWORD PTR [edi], edx
	pop	edi

; 381  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN4@UTF8ToUTF8:

; 367  :     }
; 368  :     if (*outlen > *inlenb) {

	mov	ebx, DWORD PTR [edi]

; 369  : 	len = *inlenb;
; 370  :     } else {
; 371  : 	len = *outlen;
; 372  :     }
; 373  :     if (len < 0)

	cmp	DWORD PTR [esi], ebx
	cmovle	ebx, DWORD PTR [esi]
	test	ebx, ebx
	js	SHORT $LN3@UTF8ToUTF8

; 374  : 	return(-1);
; 375  : 
; 376  :     memcpy(out, inb, len);

	push	ebx
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 377  : 
; 378  :     *outlen = len;

	mov	DWORD PTR [esi], ebx

; 379  :     *inlenb = len;

	mov	DWORD PTR [edi], ebx

; 380  :     return(*outlen);

	mov	eax, DWORD PTR [esi]
	pop	edi

; 381  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN3@UTF8ToUTF8:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
_UTF8ToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8Toascii
_TEXT	SEGMENT
_outend$1$ = -16					; size = 4
_instart$1$ = -12					; size = 4
_outstart$1$ = -8					; size = 4
_inend$1$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_processed$1$ = 16					; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8Toascii PROC					; COMDAT

; 224  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _in$[ebp]
	mov	ecx, esi
	mov	ebx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _processed$1$[ebp], ecx
	mov	DWORD PTR _outstart$1$[ebp], ebx
	mov	DWORD PTR _instart$1$[ebp], esi
	test	ebx, ebx
	je	$LN8@UTF8Toasci

; 225  :     const unsigned char* processed = in;
; 226  :     const unsigned char* outend;
; 227  :     const unsigned char* outstart = out;
; 228  :     const unsigned char* instart = in;
; 229  :     const unsigned char* inend;
; 230  :     unsigned int c, d;
; 231  :     int trailing;
; 232  : 
; 233  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	mov	eax, DWORD PTR _outlen$[ebp]
	test	eax, eax
	je	$LN8@UTF8Toasci
	mov	edx, DWORD PTR _inlen$[ebp]
	test	edx, edx
	je	$LN8@UTF8Toasci

; 234  :     if (in == NULL) {

	test	esi, esi
	jne	SHORT $LN9@UTF8Toasci

; 235  :         /*
; 236  : 	 * initialization nothing to do
; 237  : 	 */
; 238  : 	*outlen = 0;

	mov	DWORD PTR [eax], esi

; 239  : 	*inlen = 0;
; 240  : 	return(0);

	xor	eax, eax
	mov	DWORD PTR [edx], esi
	pop	esi

; 289  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@UTF8Toasci:

; 241  :     }
; 242  :     inend = in + (*inlen);

	mov	edx, DWORD PTR [edx]

; 243  :     outend = out + (*outlen);

	mov	eax, DWORD PTR [eax]
	add	edx, esi
	add	eax, ebx
	mov	DWORD PTR _inend$1$[ebp], edx
	mov	DWORD PTR _outend$1$[ebp], eax
	push	edi

; 244  :     while (in < inend) {

	cmp	esi, edx
	jae	$LN3@UTF8Toasci
	npad	8
$LL2@UTF8Toasci:

; 245  : 	d = *in++;

	movzx	eax, BYTE PTR [esi]
	inc	esi

; 246  : 	if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN10@UTF8Toasci
	xor	edi, edi
	jmp	SHORT $LN19@UTF8Toasci
$LN10@UTF8Toasci:

; 247  : 	else if (d < 0xC0) {

	cmp	eax, 192				; 000000c0H
	jb	$LN18@UTF8Toasci

; 248  : 	    /* trailing byte in leading position */
; 249  : 	    *outlen = out - outstart;
; 250  : 	    *inlen = processed - instart;
; 251  : 	    return(-2);
; 252  :         } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	eax, 224				; 000000e0H
	jae	SHORT $LN14@UTF8Toasci
	and	eax, 31					; 0000001fH
	mov	edi, 1
	jmp	SHORT $LN19@UTF8Toasci
$LN14@UTF8Toasci:

; 253  :         else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	eax, 240				; 000000f0H
	jae	SHORT $LN16@UTF8Toasci
	and	eax, 15					; 0000000fH
	mov	edi, 2
	jmp	SHORT $LN19@UTF8Toasci
$LN16@UTF8Toasci:

; 254  :         else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	eax, 248				; 000000f8H
	jae	SHORT $LN18@UTF8Toasci
	and	eax, 7
	mov	edi, 3
$LN19@UTF8Toasci:

; 259  : 	    return(-2);
; 260  : 	}
; 261  : 
; 262  : 	if (inend - in < trailing) {

	mov	ecx, edx
	sub	ecx, esi
	cmp	ecx, edi
	jl	SHORT $LN41@UTF8Toasci

; 263  : 	    break;
; 264  : 	}
; 265  : 
; 266  : 	for ( ; trailing; trailing--) {

	test	edi, edi
	je	SHORT $LN29@UTF8Toasci
	mov	ebx, DWORD PTR _inend$1$[ebp]
	npad	6
$LL6@UTF8Toasci:

; 267  : 	    if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	cmp	esi, ebx
	jae	SHORT $LN39@UTF8Toasci
	movzx	edx, BYTE PTR [esi]
	inc	esi
	mov	ecx, edx
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN39@UTF8Toasci

; 268  : 		break;
; 269  : 	    c <<= 6;
; 270  : 	    c |= d & 0x3F;

	and	edx, 63					; 0000003fH
	shl	eax, 6
	or	eax, edx
	sub	edi, 1
	jne	SHORT $LL6@UTF8Toasci
$LN39@UTF8Toasci:
	mov	ebx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _inend$1$[ebp]
$LN29@UTF8Toasci:

; 271  : 	}
; 272  : 
; 273  : 	/* assertion: c is a single UTF-4 value */
; 274  : 	if (c < 0x80) {

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN42@UTF8Toasci

; 275  : 	    if (out >= outend)

	cmp	ebx, DWORD PTR _outend$1$[ebp]
	jae	SHORT $LN41@UTF8Toasci

; 276  : 		break;
; 277  : 	    *out++ = c;

	mov	BYTE PTR [ebx], al

; 278  : 	} else {
; 279  : 	    /* no chance for this in Ascii */
; 280  : 	    *outlen = out - outstart;
; 281  : 	    *inlen = processed - instart;
; 282  : 	    return(-2);
; 283  : 	}
; 284  : 	processed = in;

	mov	ecx, esi
	inc	ebx
	mov	DWORD PTR _processed$1$[ebp], ecx
	mov	DWORD PTR _out$[ebp], ebx
	cmp	esi, edx
	jb	$LL2@UTF8Toasci

; 275  : 	    if (out >= outend)

	jmp	SHORT $LN3@UTF8Toasci
$LN42@UTF8Toasci:

; 271  : 	}
; 272  : 
; 273  : 	/* assertion: c is a single UTF-4 value */
; 274  : 	if (c < 0x80) {

	mov	ecx, DWORD PTR _processed$1$[ebp]
$LN18@UTF8Toasci:

; 255  : 	else {
; 256  : 	    /* no chance for this in Ascii */
; 257  : 	    *outlen = out - outstart;

	mov	eax, DWORD PTR _outlen$[ebp]
	sub	ebx, DWORD PTR _outstart$1$[ebp]

; 258  : 	    *inlen = processed - instart;

	sub	ecx, DWORD PTR _instart$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR _inlen$[ebp]
	pop	esi

; 289  : }

	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	eax, -2					; fffffffeH
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@UTF8Toasci:

; 285  :     }
; 286  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _processed$1$[ebp]
$LN3@UTF8Toasci:
	mov	edx, DWORD PTR _outlen$[ebp]

; 287  :     *inlen = processed - instart;

	mov	eax, DWORD PTR _inlen$[ebp]
	sub	ebx, DWORD PTR _outstart$1$[ebp]
	sub	ecx, DWORD PTR _instart$1$[ebp]
	pop	edi
	mov	DWORD PTR [edx], ebx
	pop	esi
	mov	DWORD PTR [eax], ecx

; 288  :     return(*outlen);

	mov	eax, DWORD PTR [edx]

; 289  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@UTF8Toasci:
	pop	esi

; 225  :     const unsigned char* processed = in;
; 226  :     const unsigned char* outend;
; 227  :     const unsigned char* outstart = out;
; 228  :     const unsigned char* instart = in;
; 229  :     const unsigned char* inend;
; 230  :     unsigned int c, d;
; 231  :     int trailing;
; 232  : 
; 233  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	or	eax, -1

; 289  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8Toascii ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _asciiToUTF8
_TEXT	SEGMENT
_outstart$1$ = -4					; size = 4
_base$1$ = 8						; size = 4
_out$ = 8						; size = 4
_inend$1$ = 12						; size = 4
_outlen$ = 12						; size = 4
_outend$1$ = 16						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_asciiToUTF8 PROC					; COMDAT

; 177  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _outlen$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edi, ecx
	mov	DWORD PTR _outstart$1$[ebp], edx
	mov	eax, DWORD PTR [ebx]
	add	eax, edx
	mov	DWORD PTR _base$1$[ebp], ecx
	mov	DWORD PTR _outend$1$[ebp], eax
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, ecx
	mov	DWORD PTR _inend$1$[ebp], eax
	cmp	ecx, eax
	jae	SHORT $LN3@asciiToUTF
	xor	esi, esi
	npad	7
$LL2@asciiToUTF:

; 178  :     unsigned char* outstart = out;
; 179  :     const unsigned char* base = in;
; 180  :     const unsigned char* processed = in;
; 181  :     unsigned char* outend = out + *outlen;
; 182  :     const unsigned char* inend;
; 183  :     unsigned int c;
; 184  : 
; 185  :     inend = in + (*inlen);
; 186  :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	lea	eax, DWORD PTR [esi+5]
	cmp	eax, DWORD PTR [ebx]
	jge	SHORT $LN3@asciiToUTF

; 187  : 	c= *in++;

	mov	al, BYTE PTR [ecx]
	inc	ecx

; 188  : 
; 189  :         if (out >= outend)

	cmp	edx, DWORD PTR _outend$1$[ebp]
	jae	SHORT $LN3@asciiToUTF

; 190  : 	    break;
; 191  :         if (c < 0x80) {

	cmp	al, 128					; 00000080H
	jae	SHORT $LN5@asciiToUTF

; 192  : 	    *out++ = c;

	mov	BYTE PTR [edx], al
	inc	esi
	inc	edx

; 197  : 	}
; 198  : 
; 199  : 	processed = (const unsigned char*) in;

	mov	edi, ecx
	cmp	ecx, DWORD PTR _inend$1$[ebp]
	jb	SHORT $LL2@asciiToUTF
$LN3@asciiToUTF:

; 200  :     }
; 201  :     *outlen = out - outstart;
; 202  :     *inlen = processed - base;

	mov	eax, DWORD PTR _inlen$[ebp]
	sub	edx, DWORD PTR _outstart$1$[ebp]
	sub	edi, DWORD PTR _base$1$[ebp]
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [eax], edi

; 203  :     return(*outlen);

	mov	eax, DWORD PTR [ebx]
	pop	edi

; 204  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@asciiToUTF:

; 193  : 	} else {
; 194  : 	    *outlen = out - outstart;
; 195  : 	    *inlen = processed - base;

	mov	eax, DWORD PTR _inlen$[ebp]
	sub	edi, DWORD PTR _base$1$[ebp]
	mov	DWORD PTR [ebx], esi
	mov	DWORD PTR [eax], edi

; 196  : 	    return(-1);

	or	eax, -1
	pop	edi

; 204  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_asciiToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncodingErr
_TEXT	SEGMENT
_error$ = 8						; size = 4
_msg$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlEncodingErr PROC					; COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	3
	push	DWORD PTR _error$[ebp]
	push	27					; 0000001bH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 99   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,
; 100  :                     XML_FROM_I18N, error, XML_ERR_FATAL,
; 101  :                     NULL, 0, val, NULL, NULL, 0, 0, msg, val);
; 102  : }

	pop	ebp
	ret	0
_xmlEncodingErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncodingErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlEncodingErrMemory PROC				; COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	27					; 0000001bH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 86   :     __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 87   : }

	pop	ebp
	ret	0
_xmlEncodingErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncOutput
_TEXT	SEGMENT
_buf$1 = -112						; size = 50
_charref$2 = -60					; size = 20
tv294 = -40						; size = 4
_charrefLen$1$ = -40					; size = 4
_icv_out$3 = -36					; size = 4
_icv_in$4 = -36						; size = 4
_icv_in$5 = -32						; size = 4
_icv_out$6 = -32					; size = 4
_len$7 = -28						; size = 4
_writtentot$1$ = -24					; size = 4
_icv_inlen$8 = -20					; size = 4
_icv_outlen$9 = -20					; size = 4
_icv_outlen$10 = -16					; size = 4
_icv_inlen$11 = -16					; size = 4
_in$1$ = -12						; size = 4
_c_in$ = -8						; size = 4
_c_out$ = -4						; size = 4
tv321 = 8						; size = 4
_output$ = 8						; size = 4
_init$ = 12						; size = 4
_xmlCharEncOutput PROC					; COMDAT

; 2394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _output$[ebp]
	mov	DWORD PTR _writtentot$1$[ebp], 0
	test	eax, eax
	je	$LN5@xmlCharEnc

; 2395 :     int ret;
; 2396 :     size_t written;
; 2397 :     size_t writtentot = 0;
; 2398 :     size_t toconv;
; 2399 :     int c_in;
; 2400 :     int c_out;
; 2401 :     xmlBufPtr in;
; 2402 :     xmlBufPtr out;
; 2403 : 
; 2404 :     if ((output == NULL) || (output->encoder == NULL) ||
; 2405 :         (output->buffer == NULL) || (output->conv == NULL))

	cmp	DWORD PTR [eax+12], 0
	je	$LN5@xmlCharEnc
	mov	edi, DWORD PTR [eax+16]
	mov	DWORD PTR _in$1$[ebp], edi
	test	edi, edi
	je	$LN5@xmlCharEnc
	mov	ebx, DWORD PTR [eax+20]
	test	ebx, ebx
	je	$LN5@xmlCharEnc
	push	esi
$retry$79:

; 2407 :     out = output->conv;
; 2408 :     in = output->buffer;
; 2409 : 
; 2410 : retry:
; 2411 : 
; 2412 :     written = xmlBufAvail(out);

	push	ebx
	call	_xmlBufAvail
	mov	esi, eax
	add	esp, 4

; 2413 :     if (written > 0)

	test	esi, esi
	je	SHORT $LN6@xmlCharEnc

; 2414 :         written--; /* count '\0' */

	dec	esi
$LN6@xmlCharEnc:

; 2415 : 
; 2416 :     /*
; 2417 :      * First specific handling of the initialization call
; 2418 :      */
; 2419 :     if (init) {

	cmp	DWORD PTR _init$[ebp], 0
	jne	$LN64@xmlCharEnc

; 2431 :     }
; 2432 : 
; 2433 :     /*
; 2434 :      * Conversion itself.
; 2435 :      */
; 2436 :     toconv = xmlBufUse(in);

	push	edi
	call	_xmlBufUse
	mov	edi, eax
	add	esp, 4

; 2437 :     if (toconv == 0)

	test	edi, edi
	je	$LN65@xmlCharEnc

; 2438 :         return (0);
; 2439 :     if (toconv > 64 * 1024)

	cmp	edi, 65536				; 00010000H
	mov	eax, 65536				; 00010000H
	cmova	edi, eax

; 2440 :         toconv = 64 * 1024;
; 2441 :     if (toconv * 4 >= written) {

	lea	eax, DWORD PTR [edi*4]
	cmp	eax, esi
	jb	SHORT $LN10@xmlCharEnc

; 2442 :         xmlBufGrow(out, toconv * 4);

	push	eax
	push	ebx
	call	_xmlBufGrow

; 2443 :         written = xmlBufAvail(out) - 1;

	push	ebx
	call	_xmlBufAvail
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax-1]
$LN10@xmlCharEnc:

; 2444 :     }
; 2445 :     if (written > 256 * 1024)

	cmp	esi, 262144				; 00040000H

; 2446 :         written = 256 * 1024;
; 2447 : 
; 2448 :     c_in = toconv;

	mov	DWORD PTR _c_in$[ebp], edi

; 2449 :     c_out = written;
; 2450 :     ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	mov	edi, DWORD PTR _in$1$[ebp]
	mov	eax, 262144				; 00040000H
	cmova	esi, eax
	push	edi
	mov	DWORD PTR _c_out$[ebp], esi
	call	_xmlBufContent
	push	ebx
	mov	esi, eax
	call	_xmlBufEnd
	mov	ecx, DWORD PTR _output$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [ecx+12]

; 1950 :     if (handler->output != NULL) {

	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN25@xmlCharEnc

; 1951 :         ret = handler->output(out, outlen, in, inlen);

	lea	ecx, DWORD PTR _c_in$[ebp]
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _c_out$[ebp]
	push	ecx
	push	eax
	call	edx
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1952 :     }

	jmp	$LN28@xmlCharEnc
$LN25@xmlCharEnc:

; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	ecx, DWORD PTR [ecx+16]
	test	ecx, ecx
	je	SHORT $LN27@xmlCharEnc

; 1804 :     const char *icv_in = (const char *) in;

	mov	DWORD PTR _icv_in$4[ebp], esi

; 1805 :     char *icv_out = (char *) out;

	mov	DWORD PTR _icv_out$6[ebp], eax

; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	test	eax, eax
	je	SHORT $LN32@xmlCharEnc
	test	esi, esi
	je	SHORT $LN32@xmlCharEnc

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	eax, DWORD PTR _c_in$[ebp]
	mov	DWORD PTR _icv_inlen$11[ebp], eax

; 1813 :     icv_outlen = *outlen;

	mov	eax, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR _icv_outlen$9[ebp], eax

; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	lea	eax, DWORD PTR _icv_outlen$9[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_out$6[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_inlen$11[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_in$4[ebp]
	push	eax
	push	ecx
	call	DWORD PTR __imp__libiconv

; 1815 :     *inlen -= icv_inlen;

	mov	edx, DWORD PTR _icv_inlen$11[ebp]
	add	esp, 20					; 00000014H

; 1816 :     *outlen -= icv_outlen;

	mov	ecx, DWORD PTR _icv_outlen$9[ebp]
	sub	DWORD PTR _c_in$[ebp], edx
	sub	DWORD PTR _c_out$[ebp], ecx

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	test	edx, edx
	jne	SHORT $LN35@xmlCharEnc
	cmp	eax, -1
	je	SHORT $LN35@xmlCharEnc

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN28@xmlCharEnc
$LN35@xmlCharEnc:

; 1818 : #ifdef EILSEQ
; 1819 :         if (errno == EILSEQ) {

	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN36@xmlCharEnc

; 1820 :             return -2;

	mov	esi, -2					; fffffffeH
	jmp	SHORT $LN28@xmlCharEnc
$LN36@xmlCharEnc:

; 1821 :         } else
; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	call	esi
	cmp	DWORD PTR [eax], 7
	jne	SHORT $LN38@xmlCharEnc

; 1825 :             return -1;

	or	esi, -1
	jmp	SHORT $LN28@xmlCharEnc
$LN38@xmlCharEnc:

; 1826 :         } else
; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	call	esi
	mov	esi, -3					; fffffffdH

; 1830 :             return -3;
; 1831 :         } else
; 1832 : #endif
; 1833 :         {
; 1834 :             return -3;

	jmp	SHORT $LN28@xmlCharEnc
$LN32@xmlCharEnc:

; 1810 :         return(-1);

	or	esi, -1

; 1956 :     }

	jmp	SHORT $LN76@xmlCharEnc
$LN27@xmlCharEnc:

; 1966 :         *inlen = 0;

	mov	DWORD PTR _c_in$[ebp], 0

; 1967 :         ret = -4;

	mov	esi, -4					; fffffffcH
$LN76@xmlCharEnc:

; 2451 :                             xmlBufContent(in), &c_in);
; 2452 :     xmlBufShrink(in, c_in);

	mov	DWORD PTR _c_out$[ebp], 0
$LN28@xmlCharEnc:
	push	DWORD PTR _c_in$[ebp]
	push	edi
	call	_xmlBufShrink

; 2453 :     xmlBufAddLen(out, c_out);

	push	DWORD PTR _c_out$[ebp]
	push	ebx
	call	_xmlBufAddLen

; 2454 :     writtentot += c_out;

	mov	eax, DWORD PTR _c_out$[ebp]
	add	esp, 16					; 00000010H
	add	DWORD PTR _writtentot$1$[ebp], eax

; 2455 :     if (ret == -1) {

	cmp	esi, -1
	jne	SHORT $LN12@xmlCharEnc

; 2456 :         if (c_out > 0) {

	test	eax, eax
	jg	$retry$79

; 2457 :             /* Can be a limitation of iconv or uconv */
; 2458 :             goto retry;
; 2459 :         }
; 2460 :         ret = -3;

	mov	esi, -3					; fffffffdH

; 2541 : 	}
; 2542 :     }
; 2543 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 2544 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlCharEnc:

; 2461 :     }
; 2462 : 
; 2463 :     /*
; 2464 :      * Attempt to handle error cases
; 2465 :      */
; 2466 :     switch (ret) {

	cmp	esi, -4					; fffffffcH
	je	$LN17@xmlCharEnc
	cmp	esi, -2					; fffffffeH
	jne	$LN2@xmlCharEnc

; 2490 :             break;
; 2491 :         case -2: {
; 2492 : 	    xmlChar charref[20];
; 2493 : 	    int len = (int) xmlBufUse(in);

	push	edi
	call	_xmlBufUse

; 2494 :             xmlChar *content = xmlBufContent(in);

	push	edi
	mov	DWORD PTR _len$7[ebp], eax
	call	_xmlBufContent
	mov	edi, eax

; 2495 : 	    int cur, charrefLen;
; 2496 : 
; 2497 : 	    cur = xmlGetUTF8Char(content, &len);

	lea	eax, DWORD PTR _len$7[ebp]
	push	eax
	push	edi
	call	_xmlGetUTF8Char
	add	esp, 16					; 00000010H

; 2498 : 	    if (cur <= 0)

	test	eax, eax
	jle	$LN2@xmlCharEnc

; 2499 :                 break;
; 2500 : 
; 2501 : #ifdef DEBUG_ENCODING
; 2502 :             xmlGenericError(xmlGenericErrorContext,
; 2503 :                     "handling output conversion error\n");
; 2504 :             xmlGenericError(xmlGenericErrorContext,
; 2505 :                     "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
; 2506 :                     content[0], content[1],
; 2507 :                     content[2], content[3]);
; 2508 : #endif
; 2509 :             /*
; 2510 :              * Removes the UTF8 sequence, and replace it by a charref
; 2511 :              * and continue the transcoding phase, hoping the error
; 2512 :              * did not mangle the encoder state.
; 2513 :              */
; 2514 :             charrefLen = snprintf((char *) &charref[0], sizeof(charref),

	push	eax
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	lea	eax, DWORD PTR _charref$2[ebp]
	push	20					; 00000014H
	push	eax
	call	_snprintf

; 2515 :                              "&#%d;", cur);
; 2516 :             xmlBufShrink(in, len);

	push	DWORD PTR _len$7[ebp]
	mov	esi, eax
	push	DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _charrefLen$1$[ebp], esi
	call	_xmlBufShrink

; 2517 :             xmlBufGrow(out, charrefLen * 4);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	ebx
	call	_xmlBufGrow

; 2518 :             c_out = xmlBufAvail(out) - 1;

	push	ebx
	call	_xmlBufAvail
	dec	eax

; 2519 :             c_in = charrefLen;

	mov	DWORD PTR _c_in$[ebp], esi

; 2520 :             ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	push	ebx
	mov	DWORD PTR _c_out$[ebp], eax
	call	_xmlBufEnd
	mov	ecx, DWORD PTR _output$[ebp]
	add	esp, 40					; 00000028H
	mov	ecx, DWORD PTR [ecx+12]

; 1950 :     if (handler->output != NULL) {

	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN44@xmlCharEnc

; 1951 :         ret = handler->output(out, outlen, in, inlen);

	lea	ecx, DWORD PTR _c_in$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _charref$2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _c_out$[ebp]
	push	ecx
	push	eax
	call	edx
	mov	esi, eax
	add	esp, 16					; 00000010H

; 1952 :     }

	mov	eax, DWORD PTR _c_out$[ebp]
	jmp	SHORT $LN47@xmlCharEnc
$LN44@xmlCharEnc:

; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	ecx, DWORD PTR [ecx+16]
	test	ecx, ecx
	je	SHORT $LN46@xmlCharEnc

; 1805 :     char *icv_out = (char *) out;

	mov	DWORD PTR _icv_out$3[ebp], eax
	lea	edx, DWORD PTR _charref$2[ebp]
	mov	DWORD PTR _icv_in$5[ebp], edx

; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	test	eax, eax
	je	SHORT $LN51@xmlCharEnc

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	eax, DWORD PTR _c_in$[ebp]
	mov	DWORD PTR _icv_inlen$8[ebp], eax

; 1813 :     icv_outlen = *outlen;

	mov	eax, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR _icv_outlen$10[ebp], eax

; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	lea	eax, DWORD PTR _icv_outlen$10[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_out$3[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_inlen$8[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_in$5[ebp]
	push	eax
	push	ecx
	call	DWORD PTR __imp__libiconv

; 1815 :     *inlen -= icv_inlen;

	mov	ecx, DWORD PTR _icv_inlen$8[ebp]
	mov	edx, eax

; 1816 :     *outlen -= icv_outlen;

	mov	eax, DWORD PTR _c_out$[ebp]
	add	esp, 20					; 00000014H
	sub	eax, DWORD PTR _icv_outlen$10[ebp]
	sub	DWORD PTR _c_in$[ebp], ecx
	mov	DWORD PTR _c_out$[ebp], eax

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	test	ecx, ecx
	jne	SHORT $LN54@xmlCharEnc
	cmp	edx, -1
	je	SHORT $LN54@xmlCharEnc

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN47@xmlCharEnc
$LN51@xmlCharEnc:

; 1809 :         if (outlen != NULL) *outlen = 0;

	xor	eax, eax

; 1810 :         return(-1);

	or	esi, -1

; 1956 :     }

	jmp	SHORT $LN77@xmlCharEnc
$LN46@xmlCharEnc:

; 1957 : #endif /* LIBXML_ICONV_ENABLED */
; 1958 : #ifdef LIBXML_ICU_ENABLED
; 1959 :     else if (handler->uconv_out != NULL) {
; 1960 :         ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,
; 1961 :                               TRUE);
; 1962 :     }
; 1963 : #endif /* LIBXML_ICU_ENABLED */
; 1964 :     else {
; 1965 :         *outlen = 0;

	xor	eax, eax

; 1967 :         ret = -4;

	mov	esi, -4					; fffffffcH
	mov	DWORD PTR _c_in$[ebp], eax
$LN77@xmlCharEnc:

; 2521 :                                     charref, &c_in);
; 2522 : 
; 2523 : 	    if ((ret < 0) || (c_in != charrefLen)) {

	mov	DWORD PTR _c_out$[ebp], eax
$LN47@xmlCharEnc:
	test	esi, esi
	js	SHORT $LN68@xmlCharEnc
	mov	ecx, DWORD PTR _charrefLen$1$[ebp]
	cmp	DWORD PTR _c_in$[ebp], ecx
	jne	SHORT $LN68@xmlCharEnc

; 2534 : 		    content[0] = ' ';
; 2535 :                 break;
; 2536 : 	    }
; 2537 : 
; 2538 :             xmlBufAddLen(out, c_out);

	push	eax
	push	ebx
	call	_xmlBufAddLen

; 2539 :             writtentot += c_out;
; 2540 :             goto retry;

	mov	edi, DWORD PTR _in$1$[ebp]
	add	esp, 8
	jmp	$retry$79
$LN54@xmlCharEnc:

; 1819 :         if (errno == EILSEQ) {

	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN55@xmlCharEnc

; 2520 :             ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	mov	esi, -2					; fffffffeH

; 1820 :             return -2;

	jmp	SHORT $LN68@xmlCharEnc
$LN55@xmlCharEnc:

; 1821 :         } else
; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	call	esi
	cmp	DWORD PTR [eax], 7
	jne	SHORT $LN57@xmlCharEnc

; 2520 :             ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	or	esi, -1

; 1825 :             return -1;

	jmp	SHORT $LN68@xmlCharEnc
$LN57@xmlCharEnc:

; 1826 :         } else
; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	call	esi
	mov	esi, -3					; fffffffdH
$LN68@xmlCharEnc:

; 2524 : 		char buf[50];
; 2525 : 
; 2526 : 		snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	movzx	eax, BYTE PTR [edi+3]
	push	eax
	movzx	eax, BYTE PTR [edi+2]
	push	eax
	movzx	eax, BYTE PTR [edi+1]
	push	eax
	movzx	eax, BYTE PTR [edi]
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	49					; 00000031H
	push	eax
	call	_snprintf

; 2527 : 			 content[0], content[1],
; 2528 : 			 content[2], content[3]);
; 2529 : 		buf[49] = 0;
; 2530 : 		xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+49], 0
	push	eax
	push	OFFSET ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
	push	6003					; 00001773H
	call	_xmlEncodingErr

; 2531 : 		    "output conversion failed due to conv error, bytes %s\n",
; 2532 : 			       buf);
; 2533 : 		if (xmlBufGetAllocationScheme(in) != XML_BUFFER_ALLOC_IMMUTABLE)

	push	DWORD PTR _in$1$[ebp]
	call	_xmlBufGetAllocationScheme
	add	esp, 44					; 0000002cH
	cmp	eax, 2
	je	SHORT $LN2@xmlCharEnc

; 2541 : 	}
; 2542 :     }
; 2543 :     return(ret);

	mov	eax, esi
	mov	BYTE PTR [edi], 32			; 00000020H
	pop	esi
	pop	edi

; 2544 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlCharEnc:

; 2467 :         case 0:
; 2468 : #ifdef DEBUG_ENCODING
; 2469 : 	    xmlGenericError(xmlGenericErrorContext,
; 2470 : 		    "converted %d bytes to %d bytes of output\n",
; 2471 : 	            c_in, c_out);
; 2472 : #endif
; 2473 : 	    break;
; 2474 :         case -1:
; 2475 : #ifdef DEBUG_ENCODING
; 2476 : 	    xmlGenericError(xmlGenericErrorContext,
; 2477 : 		    "output conversion failed by lack of space\n");
; 2478 : #endif
; 2479 : 	    break;
; 2480 :         case -3:
; 2481 : #ifdef DEBUG_ENCODING
; 2482 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of output %d left\n",
; 2483 : 	            c_in, c_out, (int) xmlBufUse(in));
; 2484 : #endif
; 2485 : 	    break;
; 2486 :         case -4:
; 2487 :             xmlEncodingErr(XML_I18N_NO_OUTPUT,

	push	0
	push	OFFSET ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
	push	6004					; 00001774H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2488 :                            "xmlCharEncOutFunc: no output function !\n", NULL);
; 2489 :             ret = -1;

	or	esi, -1
$LN2@xmlCharEnc:

; 2541 : 	}
; 2542 :     }
; 2543 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 2544 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@xmlCharEnc:

; 2420 :         c_in = 0;
; 2421 :         c_out = written;
; 2422 :         /* TODO: Check return value. */
; 2423 :         xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	lea	eax, DWORD PTR _c_in$[ebp]
	mov	DWORD PTR _c_in$[ebp], 0
	push	eax
	push	0
	lea	eax, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR _c_out$[ebp], esi
	push	eax
	push	ebx
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _output$[ebp]
	push	DWORD PTR [eax+12]
	call	_xmlEncOutputChunk

; 2424 :                           NULL, &c_in);
; 2425 :         xmlBufAddLen(out, c_out);

	push	DWORD PTR _c_out$[ebp]
	push	ebx
	call	_xmlBufAddLen
	add	esp, 28					; 0000001cH
$LN65@xmlCharEnc:

; 2426 : #ifdef DEBUG_ENCODING
; 2427 : 	xmlGenericError(xmlGenericErrorContext,
; 2428 : 		"initialized encoder\n");
; 2429 : #endif
; 2430 :         return(0);

	pop	esi
	pop	edi
	xor	eax, eax

; 2544 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCharEnc:
	pop	edi

; 2406 :         return (-1);

	or	eax, -1

; 2544 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncInput
_TEXT	SEGMENT
_buf$1 = -60						; size = 50
_c_in$ = -8						; size = 4
_c_out$ = -4						; size = 4
_in$1$ = 8						; size = 4
_input$ = 8						; size = 4
_flush$ = 12						; size = 4
_xmlCharEncInput PROC					; COMDAT

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _input$[ebp]
	test	edi, edi
	je	$LN5@xmlCharEnc

; 2205 :     int ret;
; 2206 :     size_t written;
; 2207 :     size_t toconv;
; 2208 :     int c_in;
; 2209 :     int c_out;
; 2210 :     xmlBufPtr in;
; 2211 :     xmlBufPtr out;
; 2212 : 
; 2213 :     if ((input == NULL) || (input->encoder == NULL) ||
; 2214 :         (input->buffer == NULL) || (input->raw == NULL))

	cmp	DWORD PTR [edi+12], 0
	je	$LN5@xmlCharEnc
	mov	ebx, DWORD PTR [edi+16]
	test	ebx, ebx
	je	$LN5@xmlCharEnc
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _in$1$[ebp], eax
	test	eax, eax
	je	$LN5@xmlCharEnc

; 2216 :     out = input->buffer;
; 2217 :     in = input->raw;
; 2218 : 
; 2219 :     toconv = xmlBufUse(in);

	push	esi
	push	eax
	call	_xmlBufUse
	mov	esi, eax
	add	esp, 4

; 2220 :     if (toconv == 0)

	test	esi, esi
	jne	SHORT $LN6@xmlCharEnc

; 2286 : }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCharEnc:

; 2221 :         return (0);
; 2222 :     if ((toconv > 64 * 1024) && (flush == 0))

	cmp	esi, 65536				; 00010000H
	jbe	SHORT $LN7@xmlCharEnc
	cmp	DWORD PTR _flush$[ebp], 0
	mov	eax, 65536				; 00010000H
	cmove	esi, eax
$LN7@xmlCharEnc:

; 2223 :         toconv = 64 * 1024;
; 2224 :     written = xmlBufAvail(out);

	push	ebx
	call	_xmlBufAvail
	add	esp, 4

; 2225 :     if (written > 0)

	test	eax, eax
	je	SHORT $LN8@xmlCharEnc

; 2226 :         written--; /* count '\0' */

	dec	eax
$LN8@xmlCharEnc:

; 2227 :     if (toconv * 2 >= written) {

	lea	ecx, DWORD PTR [esi+esi]
	cmp	ecx, eax
	jb	SHORT $LN10@xmlCharEnc

; 2228 :         xmlBufGrow(out, toconv * 2);

	push	ecx
	push	ebx
	call	_xmlBufGrow

; 2229 :         written = xmlBufAvail(out);

	push	ebx
	call	_xmlBufAvail
	add	esp, 12					; 0000000cH

; 2230 :         if (written > 0)

	test	eax, eax
	je	SHORT $LN10@xmlCharEnc

; 2231 :             written--; /* count '\0' */

	dec	eax
$LN10@xmlCharEnc:

; 2232 :     }
; 2233 :     if ((written > 128 * 1024) && (flush == 0))

	mov	ecx, DWORD PTR _flush$[ebp]
	cmp	eax, 131072				; 00020000H
	jbe	SHORT $LN11@xmlCharEnc
	test	ecx, ecx
	mov	edx, 131072				; 00020000H
	cmove	eax, edx
$LN11@xmlCharEnc:

; 2234 :         written = 128 * 1024;
; 2235 : 
; 2236 :     c_in = toconv;
; 2237 :     c_out = written;

	mov	DWORD PTR _c_out$[ebp], eax

; 2238 :     ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,

	lea	eax, DWORD PTR _c_in$[ebp]
	push	ecx
	mov	DWORD PTR _c_in$[ebp], esi
	mov	esi, DWORD PTR _in$1$[ebp]
	push	eax
	push	esi
	call	_xmlBufContent
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _c_out$[ebp]
	push	eax
	push	ebx
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlEncInputChunk

; 2239 :                            xmlBufContent(in), &c_in, flush);
; 2240 :     xmlBufShrink(in, c_in);

	push	DWORD PTR _c_in$[ebp]
	mov	edi, eax
	push	esi
	call	_xmlBufShrink

; 2241 :     xmlBufAddLen(out, c_out);

	push	DWORD PTR _c_out$[ebp]
	push	ebx
	call	_xmlBufAddLen
	add	esp, 40					; 00000028H

; 2242 :     if (ret == -1)

	mov	eax, -3					; fffffffdH
	cmp	edi, -1
	cmove	edi, eax

; 2243 :         ret = -3;
; 2244 : 
; 2245 :     switch (ret) {

	cmp	edi, -2					; fffffffeH
	jne	SHORT $LN2@xmlCharEnc

; 2246 :         case 0:
; 2247 : #ifdef DEBUG_ENCODING
; 2248 :             xmlGenericError(xmlGenericErrorContext,
; 2249 :                             "converted %d bytes to %d bytes of input\n",
; 2250 :                             c_in, c_out);
; 2251 : #endif
; 2252 :             break;
; 2253 :         case -1:
; 2254 : #ifdef DEBUG_ENCODING
; 2255 :             xmlGenericError(xmlGenericErrorContext,
; 2256 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2257 :                             c_in, c_out, (int)xmlBufUse(in));
; 2258 : #endif
; 2259 :             break;
; 2260 :         case -3:
; 2261 : #ifdef DEBUG_ENCODING
; 2262 :             xmlGenericError(xmlGenericErrorContext,
; 2263 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2264 :                             c_in, c_out, (int)xmlBufUse(in));
; 2265 : #endif
; 2266 :             break;
; 2267 :         case -2: {
; 2268 :             char buf[50];
; 2269 :             const xmlChar *content = xmlBufContent(in);

	push	esi
	call	_xmlBufContent

; 2270 : 
; 2271 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	movzx	ecx, BYTE PTR [eax+3]
	push	ecx
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	movzx	ecx, BYTE PTR [eax+1]
	movzx	eax, BYTE PTR [eax]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	49					; 00000031H
	push	eax
	call	_snprintf

; 2272 : 		     content[0], content[1],
; 2273 : 		     content[2], content[3]);
; 2274 : 	    buf[49] = 0;
; 2275 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+49], 0
	push	eax
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 44					; 0000002cH
$LN2@xmlCharEnc:

; 2276 : 		    "input conversion failed due to input error, bytes %s\n",
; 2277 : 		           buf);
; 2278 :         }
; 2279 :     }
; 2280 :     /*
; 2281 :      * Ignore when input buffer is not on a boundary
; 2282 :      */
; 2283 :     if (ret == -3)
; 2284 :         ret = 0;
; 2285 :     return (c_out? c_out : ret);

	mov	ecx, DWORD PTR _c_out$[ebp]
	xor	eax, eax
	cmp	edi, -3					; fffffffdH
	pop	esi
	cmovne	eax, edi
	test	ecx, ecx
	pop	edi
	cmovne	eax, ecx

; 2286 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCharEnc:
	pop	edi

; 2215 :         return (-1);

	or	eax, -1

; 2286 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLineInput
_TEXT	SEGMENT
_buf$1 = -60						; size = 50
_c_out$ = -8						; size = 4
_c_in$ = -4						; size = 4
_in$1$ = 8						; size = 4
_input$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCharEncFirstLineInput PROC				; COMDAT

; 2097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _input$[ebp]
	test	edi, edi
	je	$LN5@xmlCharEnc

; 2098 :     int ret;
; 2099 :     size_t written;
; 2100 :     size_t toconv;
; 2101 :     int c_in;
; 2102 :     int c_out;
; 2103 :     xmlBufPtr in;
; 2104 :     xmlBufPtr out;
; 2105 : 
; 2106 :     if ((input == NULL) || (input->encoder == NULL) ||
; 2107 :         (input->buffer == NULL) || (input->raw == NULL))

	cmp	DWORD PTR [edi+12], 0
	je	$LN5@xmlCharEnc
	mov	ebx, DWORD PTR [edi+16]
	test	ebx, ebx
	je	$LN5@xmlCharEnc
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _in$1$[ebp], eax
	test	eax, eax
	je	$LN5@xmlCharEnc

; 2109 :     out = input->buffer;
; 2110 :     in = input->raw;
; 2111 : 
; 2112 :     toconv = xmlBufUse(in);

	push	esi
	push	eax
	call	_xmlBufUse
	mov	esi, eax
	add	esp, 4

; 2113 :     if (toconv == 0)

	test	esi, esi
	jne	SHORT $LN6@xmlCharEnc

; 2188 : }

	pop	esi
	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCharEnc:

; 2114 :         return (0);
; 2115 :     written = xmlBufAvail(out) - 1; /* count '\0' */

	push	ebx
	call	_xmlBufAvail

; 2116 :     /*
; 2117 :      * echo '<?xml version="1.0" encoding="UCS4"?>' | wc -c => 38
; 2118 :      * 45 chars should be sufficient to reach the end of the encoding
; 2119 :      * declaration without going too far inside the document content.
; 2120 :      * on UTF-16 this means 90bytes, on UCS4 this means 180
; 2121 :      * The actual value depending on guessed encoding is passed as @len
; 2122 :      * if provided
; 2123 :      */
; 2124 :     if (len >= 0) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	esp, 4
	dec	eax
	test	ecx, ecx
	js	SHORT $LN7@xmlCharEnc

; 2125 :         if (toconv > (unsigned int) len)

	cmp	esi, ecx
	jbe	SHORT $LN10@xmlCharEnc

; 2126 :             toconv = len;

	mov	esi, ecx

; 2127 :     } else {

	jmp	SHORT $LN10@xmlCharEnc
$LN7@xmlCharEnc:

; 2128 :         if (toconv > 180)

	mov	ecx, 180				; 000000b4H
	cmp	esi, ecx
	cmova	esi, ecx
$LN10@xmlCharEnc:

; 2129 :             toconv = 180;
; 2130 :     }
; 2131 :     if (toconv * 2 >= written) {

	lea	ecx, DWORD PTR [esi+esi]
	cmp	ecx, eax
	jb	SHORT $LN11@xmlCharEnc

; 2132 :         xmlBufGrow(out, toconv * 2);

	push	ecx
	push	ebx
	call	_xmlBufGrow

; 2133 :         written = xmlBufAvail(out) - 1;

	push	ebx
	call	_xmlBufAvail
	add	esp, 12					; 0000000cH
	dec	eax
$LN11@xmlCharEnc:

; 2134 :     }
; 2135 :     if (written > 360)

	mov	ecx, 360				; 00000168H

; 2136 :         written = 360;
; 2137 : 
; 2138 :     c_in = toconv;

	mov	DWORD PTR _c_in$[ebp], esi

; 2139 :     c_out = written;
; 2140 :     ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,

	mov	esi, DWORD PTR _in$1$[ebp]
	cmp	eax, ecx
	push	0
	cmova	eax, ecx
	mov	DWORD PTR _c_out$[ebp], eax
	lea	eax, DWORD PTR _c_in$[ebp]
	push	eax
	push	esi
	call	_xmlBufContent
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _c_out$[ebp]
	push	eax
	push	ebx
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	push	DWORD PTR [edi+12]
	call	_xmlEncInputChunk

; 2141 :                            xmlBufContent(in), &c_in, 0);
; 2142 :     xmlBufShrink(in, c_in);

	push	DWORD PTR _c_in$[ebp]
	mov	edi, eax
	push	esi
	call	_xmlBufShrink

; 2143 :     xmlBufAddLen(out, c_out);

	push	DWORD PTR _c_out$[ebp]
	push	ebx
	call	_xmlBufAddLen
	add	esp, 40					; 00000028H

; 2144 :     if (ret == -1)

	mov	eax, -3					; fffffffdH
	cmp	edi, -1
	cmove	edi, eax

; 2145 :         ret = -3;
; 2146 : 
; 2147 :     switch (ret) {

	cmp	edi, -2					; fffffffeH
	jne	SHORT $LN2@xmlCharEnc

; 2148 :         case 0:
; 2149 : #ifdef DEBUG_ENCODING
; 2150 :             xmlGenericError(xmlGenericErrorContext,
; 2151 :                             "converted %d bytes to %d bytes of input\n",
; 2152 :                             c_in, c_out);
; 2153 : #endif
; 2154 :             break;
; 2155 :         case -1:
; 2156 : #ifdef DEBUG_ENCODING
; 2157 :             xmlGenericError(xmlGenericErrorContext,
; 2158 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2159 :                             c_in, c_out, (int)xmlBufUse(in));
; 2160 : #endif
; 2161 :             break;
; 2162 :         case -3:
; 2163 : #ifdef DEBUG_ENCODING
; 2164 :             xmlGenericError(xmlGenericErrorContext,
; 2165 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2166 :                             c_in, c_out, (int)xmlBufUse(in));
; 2167 : #endif
; 2168 :             break;
; 2169 :         case -2: {
; 2170 :             char buf[50];
; 2171 :             const xmlChar *content = xmlBufContent(in);

	push	esi
	call	_xmlBufContent

; 2172 : 
; 2173 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	movzx	ecx, BYTE PTR [eax+3]
	push	ecx
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	movzx	ecx, BYTE PTR [eax+1]
	movzx	eax, BYTE PTR [eax]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	49					; 00000031H
	push	eax
	call	_snprintf

; 2174 : 		     content[0], content[1],
; 2175 : 		     content[2], content[3]);
; 2176 : 	    buf[49] = 0;
; 2177 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+49], 0
	push	eax
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 44					; 0000002cH
$LN2@xmlCharEnc:

; 2178 : 		    "input conversion failed due to input error, bytes %s\n",
; 2179 : 		           buf);
; 2180 :         }
; 2181 :     }
; 2182 :     /*
; 2183 :      * Ignore when input buffer is not on a boundary
; 2184 :      */
; 2185 :     if (ret == -3) ret = 0;
; 2186 :     if (ret == -1) ret = 0;

	xor	ecx, ecx
	cmp	edi, -3					; fffffffdH
	pop	esi
	cmovne	ecx, edi

; 2187 :     return(ret);

	xor	eax, eax
	cmp	ecx, -1
	pop	edi
	cmovne	eax, ecx

; 2188 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCharEnc:
	pop	edi

; 2108 :         return (-1);

	or	eax, -1

; 2188 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncFirstLineInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLineInt
_TEXT	SEGMENT
_written$ = -8						; size = 4
_toconv$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlCharEncFirstLineInt PROC				; COMDAT

; 1990 :                        xmlBufferPtr in, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _handler$[ebp]
	test	esi, esi
	je	$LN14@xmlCharEnc

; 1991 :     int ret;
; 1992 :     int written;
; 1993 :     int toconv;
; 1994 : 
; 1995 :     if (handler == NULL) return(-1);
; 1996 :     if (out == NULL) return(-1);

	mov	edi, DWORD PTR _out$[ebp]
	test	edi, edi
	je	$LN14@xmlCharEnc

; 1997 :     if (in == NULL) return(-1);

	mov	ebx, DWORD PTR _in$[ebp]
	test	ebx, ebx
	je	$LN14@xmlCharEnc

; 1998 : 
; 1999 :     /* calculate space available */
; 2000 :     written = out->size - out->use - 1; /* count '\0' */

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+4]
	sub	eax, edx

; 2001 :     toconv = in->use;
; 2002 :     /*
; 2003 :      * echo '<?xml version="1.0" encoding="UCS4"?>' | wc -c => 38
; 2004 :      * 45 chars should be sufficient to reach the end of the encoding
; 2005 :      * declaration without going too far inside the document content.
; 2006 :      * on UTF-16 this means 90bytes, on UCS4 this means 180
; 2007 :      * The actual value depending on guessed encoding is passed as @len
; 2008 :      * if provided
; 2009 :      */
; 2010 :     if (len >= 0) {

	mov	ecx, DWORD PTR _len$[ebp]
	dec	eax
	mov	DWORD PTR _written$[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _toconv$[ebp], eax
	test	ecx, ecx
	js	SHORT $LN5@xmlCharEnc

; 2011 :         if (toconv > len)

	cmp	eax, ecx
	jle	SHORT $LN8@xmlCharEnc

; 2012 :             toconv = len;

	mov	DWORD PTR _toconv$[ebp], ecx
	mov	eax, ecx

; 2013 :     } else {

	jmp	SHORT $LN8@xmlCharEnc
$LN5@xmlCharEnc:

; 2014 :         if (toconv > 180)

	cmp	eax, 180				; 000000b4H
	jle	SHORT $LN8@xmlCharEnc

; 2015 :             toconv = 180;

	mov	DWORD PTR _toconv$[ebp], 180		; 000000b4H
	mov	eax, 180				; 000000b4H
$LN8@xmlCharEnc:

; 2016 :     }
; 2017 :     if (toconv * 2 >= written) {

	add	eax, eax
	cmp	eax, DWORD PTR _written$[ebp]
	jl	SHORT $LN9@xmlCharEnc

; 2018 :         xmlBufferGrow(out, toconv * 2);

	push	eax
	push	edi
	call	_xmlBufferGrow

; 2019 : 	written = out->size - out->use - 1;

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	mov	edx, DWORD PTR [edi+4]
	sub	eax, edx
	dec	eax
	mov	DWORD PTR _written$[ebp], eax
$LN9@xmlCharEnc:

; 2020 :     }
; 2021 : 
; 2022 :     ret = xmlEncInputChunk(handler, &out->content[out->use], &written,

	push	0
	lea	eax, DWORD PTR _toconv$[ebp]
	push	eax
	push	DWORD PTR [ebx]
	lea	eax, DWORD PTR _written$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi]
	add	eax, edx
	push	eax
	push	esi
	call	_xmlEncInputChunk

; 2023 :                            in->content, &toconv, 0);
; 2024 :     xmlBufferShrink(in, toconv);

	push	DWORD PTR _toconv$[ebp]
	mov	esi, eax
	push	ebx
	call	_xmlBufferShrink

; 2025 :     out->use += written;

	mov	ecx, DWORD PTR _written$[ebp]
	add	esp, 32					; 00000020H
	add	DWORD PTR [edi+4], ecx

; 2026 :     out->content[out->use] = 0;
; 2027 :     if (ret == -1) ret = -3;

	mov	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR [edi]
	cmp	esi, -1
	mov	edx, DWORD PTR [edi+4]
	cmove	esi, eax
	pop	edi
	mov	BYTE PTR [edx+ecx], 0

; 2028 : 
; 2029 : #ifdef DEBUG_ENCODING
; 2030 :     switch (ret) {
; 2031 :         case 0:
; 2032 : 	    xmlGenericError(xmlGenericErrorContext,
; 2033 : 		    "converted %d bytes to %d bytes of input\n",
; 2034 : 	            toconv, written);
; 2035 : 	    break;
; 2036 :         case -1:
; 2037 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2038 : 	            toconv, written, in->use);
; 2039 : 	    break;
; 2040 :         case -2:
; 2041 : 	    xmlGenericError(xmlGenericErrorContext,
; 2042 : 		    "input conversion failed due to input error\n");
; 2043 : 	    break;
; 2044 :         case -3:
; 2045 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2046 : 	            toconv, written, in->use);
; 2047 : 	    break;
; 2048 : 	default:
; 2049 : 	    xmlGenericError(xmlGenericErrorContext,"Unknown input conversion failed %d\n", ret);
; 2050 :     }
; 2051 : #endif /* DEBUG_ENCODING */
; 2052 :     /*
; 2053 :      * Ignore when input buffer is not on a boundary
; 2054 :      */
; 2055 :     if (ret == -3) ret = 0;
; 2056 :     if (ret == -1) ret = 0;

	xor	ecx, ecx
	cmp	esi, eax
	cmovne	ecx, esi

; 2057 :     return(ret);

	xor	eax, eax
	cmp	ecx, -1

; 2058 : }

	pop	esi
	cmovne	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlCharEnc:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncFirstLineInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _isolat1ToUTF8
_TEXT	SEGMENT
_base$1$ = -12						; size = 4
_outstart$1$ = -8					; size = 4
_inend$1$ = -4						; size = 4
_outend$1$ = 8						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
tv266 = 16						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_isolat1ToUTF8 PROC					; COMDAT

; 308  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _outstart$1$[ebp], esi
	mov	DWORD PTR _base$1$[ebp], eax
	test	esi, esi
	je	$LN7@isolat1ToU

; 309  :     unsigned char* outstart = out;
; 310  :     const unsigned char* base = in;
; 311  :     unsigned char* outend;
; 312  :     const unsigned char* inend;
; 313  :     const unsigned char* instop;
; 314  : 
; 315  :     if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))

	test	eax, eax
	je	$LN7@isolat1ToU
	mov	edx, DWORD PTR _outlen$[ebp]
	test	edx, edx
	je	$LN7@isolat1ToU
	mov	edi, DWORD PTR _inlen$[ebp]
	test	edi, edi
	je	$LN7@isolat1ToU

; 317  : 
; 318  :     outend = out + *outlen;

	mov	ecx, DWORD PTR [edx]
	add	ecx, esi
	mov	DWORD PTR _outend$1$[ebp], ecx

; 319  :     inend = in + (*inlen);

	mov	ecx, DWORD PTR [edi]
	add	ecx, eax
	mov	DWORD PTR _inend$1$[ebp], ecx

; 320  :     instop = inend;

	mov	edi, ecx

; 321  : 
; 322  :     while ((in < inend) && (out < outend - 1)) {

	cmp	eax, ecx
	jae	SHORT $LN10@isolat1ToU
	mov	edx, DWORD PTR _outend$1$[ebp]
	push	ebx
	lea	ebx, DWORD PTR [edx-1]
	mov	DWORD PTR tv266[ebp], ebx
$LL2@isolat1ToU:
	mov	ebx, edi
	cmp	esi, DWORD PTR tv266[ebp]
	jae	SHORT $LN3@isolat1ToU

; 323  : 	if (*in >= 0x80) {

	mov	cl, BYTE PTR [eax]
	cmp	cl, 128					; 00000080H
	jb	SHORT $LN8@isolat1ToU

; 324  : 	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;

	shr	cl, 6
	or	cl, 192					; 000000c0H
	mov	BYTE PTR [esi], cl

; 325  :             *out++ = ((*in) & 0x3F) | 0x80;

	mov	cl, BYTE PTR [eax]
	and	cl, 63					; 0000003fH
	or	cl, 128					; 00000080H
	mov	BYTE PTR [esi+1], cl
	add	esi, 2

; 326  : 	    ++in;

	inc	eax
$LN8@isolat1ToU:

; 327  : 	}
; 328  : 	if ((instop - in) > (outend - out)) instop = in + (outend - out);

	sub	edx, esi
	mov	ecx, edi
	sub	ecx, eax

; 329  : 	while ((in < instop) && (*in < 0x80)) {

	cmp	ecx, edx
	lea	edi, DWORD PTR [edx+eax]
	cmovle	edi, ebx
	cmp	eax, edi
	jae	SHORT $LN20@isolat1ToU
	npad	7
$LL4@isolat1ToU:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 128					; 00000080H
	jae	SHORT $LN20@isolat1ToU

; 330  : 	    *out++ = *in++;

	mov	BYTE PTR [esi], cl
	inc	eax
	inc	esi
	cmp	eax, edi
	jb	SHORT $LL4@isolat1ToU
$LN20@isolat1ToU:

; 321  : 
; 322  :     while ((in < inend) && (out < outend - 1)) {

	mov	ecx, DWORD PTR _inend$1$[ebp]
	mov	edx, DWORD PTR _outend$1$[ebp]
	cmp	eax, ecx
	jb	SHORT $LL2@isolat1ToU
$LN23@isolat1ToU:

; 331  : 	}
; 332  :     }
; 333  :     if ((in < inend) && (out < outend) && (*in < 0x80)) {

	mov	edx, DWORD PTR _outlen$[ebp]
$LN24@isolat1ToU:
	pop	ebx
$LN10@isolat1ToU:

; 335  :     }
; 336  :     *outlen = out - outstart;

	sub	esi, DWORD PTR _outstart$1$[ebp]

; 337  :     *inlen = in - base;

	mov	ecx, DWORD PTR _inlen$[ebp]
	sub	eax, DWORD PTR _base$1$[ebp]
	mov	DWORD PTR [edx], esi
	pop	edi
	mov	DWORD PTR [ecx], eax

; 338  :     return(*outlen);

	mov	eax, DWORD PTR [edx]

; 339  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@isolat1ToU:

; 331  : 	}
; 332  :     }
; 333  :     if ((in < inend) && (out < outend) && (*in < 0x80)) {

	cmp	eax, ecx
	jae	SHORT $LN23@isolat1ToU
	cmp	esi, edx
	jae	SHORT $LN23@isolat1ToU
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR _outlen$[ebp]
	cmp	cl, 128					; 00000080H
	jae	SHORT $LN24@isolat1ToU

; 334  :         *out++ = *in++;

	mov	BYTE PTR [esi], cl
	inc	esi
	inc	eax
	jmp	SHORT $LN24@isolat1ToU
$LN7@isolat1ToU:
	pop	edi

; 316  : 	return(-1);

	or	eax, -1

; 339  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_isolat1ToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8Toisolat1
_TEXT	SEGMENT
_outend$1$ = -12					; size = 4
_inend$1$ = -8						; size = 4
_instart$1$ = -4					; size = 4
_outstart$1$ = 8					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_processed$1$ = 16					; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8Toisolat1 PROC					; COMDAT

; 403  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _in$[ebp]
	mov	ecx, edx
	mov	ebx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _processed$1$[ebp], ecx
	mov	DWORD PTR _outstart$1$[ebp], ebx
	mov	DWORD PTR _instart$1$[ebp], edx
	test	ebx, ebx
	je	$LN8@UTF8Toisol

; 404  :     const unsigned char* processed = in;
; 405  :     const unsigned char* outend;
; 406  :     const unsigned char* outstart = out;
; 407  :     const unsigned char* instart = in;
; 408  :     const unsigned char* inend;
; 409  :     unsigned int c, d;
; 410  :     int trailing;
; 411  : 
; 412  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	mov	eax, DWORD PTR _outlen$[ebp]
	test	eax, eax
	je	$LN8@UTF8Toisol
	mov	esi, DWORD PTR _inlen$[ebp]
	test	esi, esi
	je	$LN8@UTF8Toisol

; 413  :     if (in == NULL) {

	test	edx, edx
	jne	SHORT $LN9@UTF8Toisol

; 414  :         /*
; 415  : 	 * initialization nothing to do
; 416  : 	 */
; 417  : 	*outlen = 0;

	mov	DWORD PTR [eax], edx

; 418  : 	*inlen = 0;
; 419  : 	return(0);

	xor	eax, eax
	mov	DWORD PTR [esi], edx
	pop	esi

; 473  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@UTF8Toisol:

; 420  :     }
; 421  :     inend = in + (*inlen);

	mov	esi, DWORD PTR [esi]

; 422  :     outend = out + (*outlen);

	mov	eax, DWORD PTR [eax]
	add	esi, edx
	add	eax, ebx
	mov	DWORD PTR _inend$1$[ebp], esi
	mov	DWORD PTR _outend$1$[ebp], eax
	push	edi

; 423  :     while (in < inend) {

	cmp	edx, esi
	jae	$LN3@UTF8Toisol
	npad	8
$LL2@UTF8Toisol:

; 424  : 	d = *in++;

	movzx	eax, BYTE PTR [edx]
	inc	edx

; 425  : 	if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN10@UTF8Toisol
	xor	edi, edi
	jmp	SHORT $LN19@UTF8Toisol
$LN10@UTF8Toisol:

; 426  : 	else if (d < 0xC0) {

	cmp	eax, 192				; 000000c0H
	jb	$LN18@UTF8Toisol

; 427  : 	    /* trailing byte in leading position */
; 428  : 	    *outlen = out - outstart;
; 429  : 	    *inlen = processed - instart;
; 430  : 	    return(-2);
; 431  :         } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	eax, 224				; 000000e0H
	jae	SHORT $LN14@UTF8Toisol
	and	eax, 31					; 0000001fH
	mov	edi, 1
	jmp	SHORT $LN19@UTF8Toisol
$LN14@UTF8Toisol:

; 432  :         else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	eax, 240				; 000000f0H
	jae	SHORT $LN16@UTF8Toisol
	and	eax, 15					; 0000000fH
	mov	edi, 2
	jmp	SHORT $LN19@UTF8Toisol
$LN16@UTF8Toisol:

; 433  :         else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	eax, 248				; 000000f8H
	jae	SHORT $LN18@UTF8Toisol
	and	eax, 7
	mov	edi, 3
$LN19@UTF8Toisol:

; 438  : 	    return(-2);
; 439  : 	}
; 440  : 
; 441  : 	if (inend - in < trailing) {

	mov	ecx, esi
	sub	ecx, edx
	cmp	ecx, edi
	jl	SHORT $LN41@UTF8Toisol

; 442  : 	    break;
; 443  : 	}
; 444  : 
; 445  : 	for ( ; trailing; trailing--) {

	test	edi, edi
	je	SHORT $LN29@UTF8Toisol
$LL6@UTF8Toisol:

; 446  : 	    if (in >= inend)

	cmp	edx, esi
	jae	SHORT $LN29@UTF8Toisol

; 447  : 		break;
; 448  : 	    if (((d= *in++) & 0xC0) != 0x80) {

	movzx	esi, BYTE PTR [edx]
	inc	edx
	mov	ecx, esi
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN43@UTF8Toisol

; 449  : 		*outlen = out - outstart;
; 450  : 		*inlen = processed - instart;
; 451  : 		return(-2);
; 452  : 	    }
; 453  : 	    c <<= 6;
; 454  : 	    c |= d & 0x3F;

	and	esi, 63					; 0000003fH
	shl	eax, 6
	or	eax, esi
	mov	esi, DWORD PTR _inend$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL6@UTF8Toisol
$LN29@UTF8Toisol:

; 455  : 	}
; 456  : 
; 457  : 	/* assertion: c is a single UTF-4 value */
; 458  : 	if (c <= 0xFF) {

	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN43@UTF8Toisol

; 459  : 	    if (out >= outend)

	cmp	ebx, DWORD PTR _outend$1$[ebp]
	jae	SHORT $LN41@UTF8Toisol

; 460  : 		break;
; 461  : 	    *out++ = c;

	mov	BYTE PTR [ebx], al

; 462  : 	} else {
; 463  : 	    /* no chance for this in IsoLat1 */
; 464  : 	    *outlen = out - outstart;
; 465  : 	    *inlen = processed - instart;
; 466  : 	    return(-2);
; 467  : 	}
; 468  : 	processed = in;

	mov	ecx, edx
	inc	ebx
	mov	DWORD PTR _processed$1$[ebp], ecx
	cmp	edx, esi
	jb	$LL2@UTF8Toisol

; 459  : 	    if (out >= outend)

	jmp	SHORT $LN3@UTF8Toisol
$LN43@UTF8Toisol:

; 434  : 	else {
; 435  : 	    /* no chance for this in IsoLat1 */
; 436  : 	    *outlen = out - outstart;

	mov	ecx, DWORD PTR _processed$1$[ebp]
$LN18@UTF8Toisol:
	mov	eax, DWORD PTR _outlen$[ebp]
	sub	ebx, DWORD PTR _outstart$1$[ebp]

; 437  : 	    *inlen = processed - instart;

	sub	ecx, DWORD PTR _instart$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR _inlen$[ebp]
	pop	esi

; 473  : }

	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	eax, -2					; fffffffeH
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@UTF8Toisol:

; 469  :     }
; 470  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _processed$1$[ebp]
$LN3@UTF8Toisol:
	mov	edx, DWORD PTR _outlen$[ebp]

; 471  :     *inlen = processed - instart;

	mov	eax, DWORD PTR _inlen$[ebp]
	sub	ebx, DWORD PTR _outstart$1$[ebp]
	sub	ecx, DWORD PTR _instart$1$[ebp]
	pop	edi
	mov	DWORD PTR [edx], ebx
	pop	esi
	mov	DWORD PTR [eax], ecx

; 472  :     return(*outlen);

	mov	eax, DWORD PTR [edx]

; 473  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@UTF8Toisol:
	pop	esi

; 404  :     const unsigned char* processed = in;
; 405  :     const unsigned char* outend;
; 406  :     const unsigned char* outstart = out;
; 407  :     const unsigned char* instart = in;
; 408  :     const unsigned char* inend;
; 409  :     unsigned int c, d;
; 410  :     int trailing;
; 411  : 
; 412  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	or	eax, -1

; 473  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8Toisolat1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncCloseFunc
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_xmlCharEncCloseFunc PROC				; COMDAT

; 2720 : xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _handler$[ebp]
	xor	edi, edi
	test	esi, esi
	je	$LN27@xmlCharEnc

; 2721 :     int ret = 0;
; 2722 :     int tofree = 0;
; 2723 :     int i, handler_in_list = 0;
; 2724 : 
; 2725 :     if (handler == NULL) return(-1);
; 2726 :     if (handler->name == NULL) return(-1);

	cmp	DWORD PTR [esi], edi
	je	$LN27@xmlCharEnc

; 2727 :     if (handlers != NULL) {

	mov	ecx, DWORD PTR _handlers
	test	ecx, ecx
	je	SHORT $LN24@xmlCharEnc

; 2728 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	mov	edx, DWORD PTR _nbCharEncodingHandler
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN24@xmlCharEnc
	npad	6
$LL4@xmlCharEnc:

; 2729 :             if (handler == handlers[i]) {

	cmp	esi, DWORD PTR [ecx+eax*4]
	je	SHORT $LN15@xmlCharEnc

; 2728 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL4@xmlCharEnc
$LN24@xmlCharEnc:

; 2730 : 	        handler_in_list = 1;
; 2731 : 		break;
; 2732 : 	    }
; 2733 : 	}
; 2734 :     }
; 2735 : #ifdef LIBXML_ICONV_ENABLED
; 2736 :     /*
; 2737 :      * Iconv handlers can be used only once, free the whole block.
; 2738 :      * and the associated icon resources.
; 2739 :      */
; 2740 :     if ((handler_in_list == 0) &&

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jne	SHORT $LN29@xmlCharEnc
	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN15@xmlCharEnc

; 2741 :         ((handler->iconv_out != NULL) || (handler->iconv_in != NULL))) {
; 2742 :         tofree = 1;
; 2743 : 	if (handler->iconv_out != NULL) {

	test	eax, eax
	je	SHORT $LN11@xmlCharEnc
$LN29@xmlCharEnc:

; 2744 : 	    if (iconv_close(handler->iconv_out))

	push	eax
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4

; 2745 : 		ret = -1;
; 2746 : 	    handler->iconv_out = NULL;

	mov	DWORD PTR [esi+16], 0
	test	eax, eax
	mov	eax, -1
	cmovne	edi, eax
$LN11@xmlCharEnc:

; 2747 : 	}
; 2748 : 	if (handler->iconv_in != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN25@xmlCharEnc

; 2749 : 	    if (iconv_close(handler->iconv_in))

	push	eax
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4

; 2750 : 		ret = -1;
; 2751 : 	    handler->iconv_in = NULL;

	mov	DWORD PTR [esi+12], 0
	test	eax, eax
	mov	eax, -1
	cmovne	edi, eax
$LN25@xmlCharEnc:

; 2752 : 	}
; 2753 :     }
; 2754 : #endif /* LIBXML_ICONV_ENABLED */
; 2755 : #ifdef LIBXML_ICU_ENABLED
; 2756 :     if ((handler_in_list == 0) &&
; 2757 :         ((handler->uconv_out != NULL) || (handler->uconv_in != NULL))) {
; 2758 :         tofree = 1;
; 2759 : 	if (handler->uconv_out != NULL) {
; 2760 : 	    closeIcuConverter(handler->uconv_out);
; 2761 : 	    handler->uconv_out = NULL;
; 2762 : 	}
; 2763 : 	if (handler->uconv_in != NULL) {
; 2764 : 	    closeIcuConverter(handler->uconv_in);
; 2765 : 	    handler->uconv_in = NULL;
; 2766 : 	}
; 2767 :     }
; 2768 : #endif
; 2769 :     if (tofree) {
; 2770 :         /* free up only dynamic handlers iconv/uconv */
; 2771 :         if (handler->name != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN16@xmlCharEnc

; 2772 :             xmlFree(handler->name);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN16@xmlCharEnc:

; 2773 :         handler->name = NULL;
; 2774 :         xmlFree(handler);

	push	esi
	mov	DWORD PTR [esi], 0
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN15@xmlCharEnc:

; 2775 :     }
; 2776 : #ifdef DEBUG_ENCODING
; 2777 :     if (ret)
; 2778 :         xmlGenericError(xmlGenericErrorContext,
; 2779 : 		"failed to close the encoding handler\n");
; 2780 :     else
; 2781 :         xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"closed the encoding handler\n");
; 2783 : #endif
; 2784 : 
; 2785 :     return(ret);

	mov	eax, edi
	pop	edi

; 2786 : }

	pop	esi
	pop	ebp
	ret	0
$LN27@xmlCharEnc:
	pop	edi

; 2721 :     int ret = 0;
; 2722 :     int tofree = 0;
; 2723 :     int i, handler_in_list = 0;
; 2724 : 
; 2725 :     if (handler == NULL) return(-1);
; 2726 :     if (handler->name == NULL) return(-1);

	or	eax, -1

; 2786 : }

	pop	esi
	pop	ebp
	ret	0
_xmlCharEncCloseFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLine
_TEXT	SEGMENT
_written$1 = -4						; size = 4
_toconv$2 = 8						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncFirstLine PROC				; COMDAT

; 2076 :                  xmlBufferPtr in) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1995 :     if (handler == NULL) return(-1);

	mov	esi, DWORD PTR _handler$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xmlCharEnc

; 2077 :     return(xmlCharEncFirstLineInt(handler, out, in, -1));

	or	eax, -1
	pop	esi

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlCharEnc:
	push	edi

; 1996 :     if (out == NULL) return(-1);

	mov	edi, DWORD PTR _out$[ebp]
	test	edi, edi
	jne	SHORT $LN5@xmlCharEnc

; 2077 :     return(xmlCharEncFirstLineInt(handler, out, in, -1));

	pop	edi
	or	eax, -1
	pop	esi

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlCharEnc:
	push	ebx

; 1997 :     if (in == NULL) return(-1);

	mov	ebx, DWORD PTR _in$[ebp]
	test	ebx, ebx
	jne	SHORT $LN6@xmlCharEnc

; 2077 :     return(xmlCharEncFirstLineInt(handler, out, in, -1));

	pop	ebx
	pop	edi
	or	eax, -1
	pop	esi

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlCharEnc:

; 2000 :     written = out->size - out->use - 1; /* count '\0' */

	mov	edx, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	sub	edx, ecx

; 2001 :     toconv = in->use;

	mov	eax, DWORD PTR [ebx+4]
	dec	edx
	mov	DWORD PTR _written$1[ebp], edx
	mov	DWORD PTR _toconv$2[ebp], eax
	cmp	eax, 180				; 000000b4H

; 2002 :     /*
; 2003 :      * echo '<?xml version="1.0" encoding="UCS4"?>' | wc -c => 38
; 2004 :      * 45 chars should be sufficient to reach the end of the encoding
; 2005 :      * declaration without going too far inside the document content.
; 2006 :      * on UTF-16 this means 90bytes, on UCS4 this means 180
; 2007 :      * The actual value depending on guessed encoding is passed as @len
; 2008 :      * if provided
; 2009 :      */
; 2010 :     if (len >= 0) {
; 2011 :         if (toconv > len)
; 2012 :             toconv = len;
; 2013 :     } else {
; 2014 :         if (toconv > 180)

	jle	SHORT $LN10@xmlCharEnc

; 2015 :             toconv = 180;

	mov	DWORD PTR _toconv$2[ebp], 180		; 000000b4H
	mov	eax, 180				; 000000b4H
$LN10@xmlCharEnc:

; 2016 :     }
; 2017 :     if (toconv * 2 >= written) {

	add	eax, eax
	cmp	eax, edx
	jl	SHORT $LN11@xmlCharEnc

; 2018 :         xmlBufferGrow(out, toconv * 2);

	push	eax
	push	edi
	call	_xmlBufferGrow

; 2019 : 	written = out->size - out->use - 1;

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	mov	ecx, DWORD PTR [edi+4]
	sub	eax, ecx
	dec	eax
	mov	DWORD PTR _written$1[ebp], eax
$LN11@xmlCharEnc:

; 2020 :     }
; 2021 : 
; 2022 :     ret = xmlEncInputChunk(handler, &out->content[out->use], &written,

	push	0
	lea	eax, DWORD PTR _toconv$2[ebp]
	push	eax
	push	DWORD PTR [ebx]
	lea	eax, DWORD PTR _written$1[ebp]
	push	eax
	mov	eax, DWORD PTR [edi]
	add	eax, ecx
	push	eax
	push	esi
	call	_xmlEncInputChunk

; 2023 :                            in->content, &toconv, 0);
; 2024 :     xmlBufferShrink(in, toconv);

	push	DWORD PTR _toconv$2[ebp]
	mov	esi, eax
	push	ebx
	call	_xmlBufferShrink

; 2025 :     out->use += written;

	mov	ecx, DWORD PTR _written$1[ebp]
	add	esp, 32					; 00000020H
	add	DWORD PTR [edi+4], ecx

; 2027 :     if (ret == -1) ret = -3;

	mov	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR [edi]
	cmp	esi, -1
	mov	edx, DWORD PTR [edi+4]
	cmove	esi, eax
	pop	ebx
	pop	edi

; 2026 :     out->content[out->use] = 0;

	mov	BYTE PTR [edx+ecx], 0

; 2028 : 
; 2029 : #ifdef DEBUG_ENCODING
; 2030 :     switch (ret) {
; 2031 :         case 0:
; 2032 : 	    xmlGenericError(xmlGenericErrorContext,
; 2033 : 		    "converted %d bytes to %d bytes of input\n",
; 2034 : 	            toconv, written);
; 2035 : 	    break;
; 2036 :         case -1:
; 2037 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2038 : 	            toconv, written, in->use);
; 2039 : 	    break;
; 2040 :         case -2:
; 2041 : 	    xmlGenericError(xmlGenericErrorContext,
; 2042 : 		    "input conversion failed due to input error\n");
; 2043 : 	    break;
; 2044 :         case -3:
; 2045 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2046 : 	            toconv, written, in->use);
; 2047 : 	    break;
; 2048 : 	default:
; 2049 : 	    xmlGenericError(xmlGenericErrorContext,"Unknown input conversion failed %d\n", ret);
; 2050 :     }
; 2051 : #endif /* DEBUG_ENCODING */
; 2052 :     /*
; 2053 :      * Ignore when input buffer is not on a boundary
; 2054 :      */
; 2055 :     if (ret == -3) ret = 0;
; 2056 :     if (ret == -1) ret = 0;

	xor	ecx, ecx
	cmp	esi, eax
	cmovne	ecx, esi

; 2057 :     return(ret);

	xor	eax, eax
	cmp	ecx, -1
	pop	esi
	cmovne	eax, ecx

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncFirstLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncInFunc
_TEXT	SEGMENT
_buf$1 = -60						; size = 50
_toconv$ = -8						; size = 4
_written$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncInFunc PROC					; COMDAT

; 2304 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _handler$[ebp]
	test	ebx, ebx
	je	$LN16@xmlCharEnc

; 2305 :     int ret;
; 2306 :     int written;
; 2307 :     int toconv;
; 2308 : 
; 2309 :     if (handler == NULL)
; 2310 :         return (-1);
; 2311 :     if (out == NULL)

	mov	esi, DWORD PTR _out$[ebp]
	test	esi, esi
	je	$LN16@xmlCharEnc

; 2312 :         return (-1);
; 2313 :     if (in == NULL)

	mov	edi, DWORD PTR _in$[ebp]
	test	edi, edi
	je	$LN16@xmlCharEnc

; 2314 :         return (-1);
; 2315 : 
; 2316 :     toconv = in->use;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _toconv$[ebp], ecx
	test	ecx, ecx

; 2317 :     if (toconv == 0)

	jne	SHORT $LN7@xmlCharEnc

; 2372 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlCharEnc:

; 2318 :         return (0);
; 2319 :     written = out->size - out->use -1; /* count '\0' */

	mov	eax, DWORD PTR [esi+8]
	add	ecx, ecx
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	dec	eax
	mov	DWORD PTR _written$[ebp], eax

; 2320 :     if (toconv * 2 >= written) {

	cmp	ecx, eax
	jl	SHORT $LN8@xmlCharEnc

; 2321 :         xmlBufferGrow(out, out->size + toconv * 2);

	mov	eax, DWORD PTR [esi+8]
	add	eax, ecx
	push	eax
	push	esi
	call	_xmlBufferGrow

; 2322 :         written = out->size - out->use - 1;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	dec	eax
	mov	DWORD PTR _written$[ebp], eax
$LN8@xmlCharEnc:

; 2323 :     }
; 2324 :     ret = xmlEncInputChunk(handler, &out->content[out->use], &written,

	push	1
	lea	eax, DWORD PTR _toconv$[ebp]
	push	eax
	push	DWORD PTR [edi]
	lea	eax, DWORD PTR _written$[ebp]
	push	eax
	mov	eax, DWORD PTR [esi]
	add	eax, edx
	push	eax
	push	ebx
	call	_xmlEncInputChunk

; 2325 :                            in->content, &toconv, 1);
; 2326 :     xmlBufferShrink(in, toconv);

	push	DWORD PTR _toconv$[ebp]
	mov	ebx, eax
	push	edi
	call	_xmlBufferShrink

; 2327 :     out->use += written;

	mov	ecx, DWORD PTR _written$[ebp]
	add	esp, 32					; 00000020H
	add	DWORD PTR [esi+4], ecx

; 2328 :     out->content[out->use] = 0;
; 2329 :     if (ret == -1)

	mov	eax, -3					; fffffffdH
	mov	edx, DWORD PTR [esi+4]
	cmp	ebx, -1
	mov	ecx, DWORD PTR [esi]
	cmove	ebx, eax
	mov	BYTE PTR [edx+ecx], 0

; 2330 :         ret = -3;
; 2331 : 
; 2332 :     switch (ret) {

	cmp	ebx, -2					; fffffffeH
	jne	SHORT $LN2@xmlCharEnc

; 2333 :         case 0:
; 2334 : #ifdef DEBUG_ENCODING
; 2335 :             xmlGenericError(xmlGenericErrorContext,
; 2336 :                             "converted %d bytes to %d bytes of input\n",
; 2337 :                             toconv, written);
; 2338 : #endif
; 2339 :             break;
; 2340 :         case -1:
; 2341 : #ifdef DEBUG_ENCODING
; 2342 :             xmlGenericError(xmlGenericErrorContext,
; 2343 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2344 :                             toconv, written, in->use);
; 2345 : #endif
; 2346 :             break;
; 2347 :         case -3:
; 2348 : #ifdef DEBUG_ENCODING
; 2349 :             xmlGenericError(xmlGenericErrorContext,
; 2350 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2351 :                             toconv, written, in->use);
; 2352 : #endif
; 2353 :             break;
; 2354 :         case -2: {
; 2355 :             char buf[50];
; 2356 : 
; 2357 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	ecx, DWORD PTR [edi]
	movzx	eax, BYTE PTR [ecx+3]
	push	eax
	movzx	eax, BYTE PTR [ecx+2]
	push	eax
	movzx	eax, BYTE PTR [ecx+1]
	push	eax
	movzx	eax, BYTE PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	49					; 00000031H
	push	eax
	call	_snprintf

; 2358 : 		     in->content[0], in->content[1],
; 2359 : 		     in->content[2], in->content[3]);
; 2360 : 	    buf[49] = 0;
; 2361 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+49], 0
	push	eax
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 40					; 00000028H
$LN2@xmlCharEnc:

; 2362 : 		    "input conversion failed due to input error, bytes %s\n",
; 2363 : 		           buf);
; 2364 :         }
; 2365 :     }
; 2366 :     /*
; 2367 :      * Ignore when input buffer is not on a boundary
; 2368 :      */
; 2369 :     if (ret == -3)
; 2370 :         ret = 0;
; 2371 :     return (written? written : ret);

	mov	ecx, DWORD PTR _written$[ebp]
	xor	eax, eax
	cmp	ebx, -3					; fffffffdH
	pop	edi
	cmovne	eax, ebx
	test	ecx, ecx

; 2372 : }

	pop	esi
	cmovne	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlCharEnc:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncInFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncOutFunc
_TEXT	SEGMENT
_buf$1 = -108						; size = 50
_charref$2 = -56					; size = 20
_icv_in$3 = -36						; size = 4
tv276 = -36						; size = 4
_icv_out$4 = -32					; size = 4
_icv_outlen$5 = -28					; size = 4
_icv_out$6 = -28					; size = 4
_icv_inlen$7 = -24					; size = 4
_icv_in$8 = -24						; size = 4
_writtentot$1$ = -20					; size = 4
_icv_outlen$9 = -16					; size = 4
_len$10 = -16						; size = 4
_charrefLen$1$ = -12					; size = 4
_icv_inlen$11 = -12					; size = 4
_toconv$ = -8						; size = 4
_written$ = -4						; size = 4
tv335 = 8						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncOutFunc PROC					; COMDAT

; 2567 :                   xmlBufferPtr in) {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _handler$[ebp], 0
	mov	DWORD PTR _writtentot$1$[ebp], 0
	je	$LN80@xmlCharEnc

; 2568 :     int ret;
; 2569 :     int written;
; 2570 :     int writtentot = 0;
; 2571 :     int toconv;
; 2572 :     int output = 0;
; 2573 : 
; 2574 :     if (handler == NULL) return(-1);
; 2575 :     if (out == NULL) return(-1);

	mov	edi, DWORD PTR _out$[ebp]
	test	edi, edi
	je	$LN80@xmlCharEnc
	push	ebx
	mov	ebx, DWORD PTR _in$[ebp]
	push	esi
$retry$86:

; 2576 : 
; 2577 : retry:
; 2578 : 
; 2579 :     written = out->size - out->use;

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+4]
	sub	ecx, edx
	mov	DWORD PTR _written$[ebp], ecx
	mov	esi, ecx
	test	ecx, ecx

; 2580 : 
; 2581 :     if (written > 0)

	jle	SHORT $LN6@xmlCharEnc

; 2582 : 	written--; /* Gennady: count '/0' */

	lea	esi, DWORD PTR [ecx-1]
	mov	ecx, esi
	mov	DWORD PTR _written$[ebp], ecx
$LN6@xmlCharEnc:

; 2583 : 
; 2584 :     /*
; 2585 :      * First specific handling of in = NULL, i.e. the initialization call
; 2586 :      */
; 2587 :     if (in == NULL) {

	test	ebx, ebx
	je	$LN63@xmlCharEnc

; 2599 :     }
; 2600 : 
; 2601 :     /*
; 2602 :      * Conversion itself.
; 2603 :      */
; 2604 :     toconv = in->use;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _toconv$[ebp], eax
	test	eax, eax

; 2605 :     if (toconv == 0)

	je	$LN64@xmlCharEnc

; 2606 : 	return(0);
; 2607 :     if (toconv * 4 >= written) {

	shl	eax, 2
	cmp	eax, esi
	jl	SHORT $LN79@xmlCharEnc

; 2608 :         xmlBufferGrow(out, toconv * 4);

	push	eax
	push	edi
	call	_xmlBufferGrow

; 2609 : 	written = out->size - out->use - 1;

	mov	ecx, DWORD PTR [edi+8]
	add	esp, 8
	mov	edx, DWORD PTR [edi+4]
	sub	ecx, edx
	dec	ecx
	mov	DWORD PTR _written$[ebp], ecx
$LN79@xmlCharEnc:

; 2610 :     }
; 2611 :     ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [ebx]
	add	eax, edx

; 1950 :     if (handler->output != NULL) {

	mov	edx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR [edx+8]
	test	edx, edx
	je	SHORT $LN24@xmlCharEnc

; 1951 :         ret = handler->output(out, outlen, in, inlen);

	lea	ecx, DWORD PTR _toconv$[ebp]
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _written$[ebp]
	push	ecx
	push	eax
	call	edx
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1952 :     }

	jmp	$LN27@xmlCharEnc
$LN24@xmlCharEnc:

; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	edx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR [edx+16]
	test	edx, edx
	je	SHORT $LN26@xmlCharEnc

; 1804 :     const char *icv_in = (const char *) in;

	mov	DWORD PTR _icv_in$8[ebp], esi

; 1805 :     char *icv_out = (char *) out;

	mov	DWORD PTR _icv_out$6[ebp], eax

; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	test	eax, eax
	je	SHORT $LN31@xmlCharEnc
	test	esi, esi
	je	SHORT $LN31@xmlCharEnc

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	eax, DWORD PTR _toconv$[ebp]
	mov	DWORD PTR _icv_inlen$11[ebp], eax

; 1813 :     icv_outlen = *outlen;
; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	lea	eax, DWORD PTR _icv_outlen$9[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_out$6[ebp]
	mov	DWORD PTR _icv_outlen$9[ebp], ecx
	push	eax
	lea	eax, DWORD PTR _icv_inlen$11[ebp]
	push	eax
	lea	eax, DWORD PTR _icv_in$8[ebp]
	push	eax
	push	edx
	call	DWORD PTR __imp__libiconv

; 1815 :     *inlen -= icv_inlen;

	mov	edx, DWORD PTR _icv_inlen$11[ebp]
	add	esp, 20					; 00000014H

; 1816 :     *outlen -= icv_outlen;

	mov	ecx, DWORD PTR _icv_outlen$9[ebp]
	sub	DWORD PTR _toconv$[ebp], edx
	sub	DWORD PTR _written$[ebp], ecx

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	test	edx, edx
	jne	SHORT $LN34@xmlCharEnc
	cmp	eax, -1
	je	SHORT $LN34@xmlCharEnc

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN27@xmlCharEnc
$LN34@xmlCharEnc:

; 1818 : #ifdef EILSEQ
; 1819 :         if (errno == EILSEQ) {

	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN35@xmlCharEnc

; 1820 :             return -2;

	mov	esi, -2					; fffffffeH
	jmp	SHORT $LN27@xmlCharEnc
$LN35@xmlCharEnc:

; 1821 :         } else
; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	call	esi
	cmp	DWORD PTR [eax], 7
	jne	SHORT $LN37@xmlCharEnc

; 1825 :             return -1;

	or	esi, -1
	jmp	SHORT $LN27@xmlCharEnc
$LN37@xmlCharEnc:

; 1826 :         } else
; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	call	esi
	mov	esi, -3					; fffffffdH

; 1830 :             return -3;
; 1831 :         } else
; 1832 : #endif
; 1833 :         {
; 1834 :             return -3;

	jmp	SHORT $LN27@xmlCharEnc
$LN31@xmlCharEnc:

; 1810 :         return(-1);

	or	esi, -1

; 1956 :     }

	jmp	SHORT $LN83@xmlCharEnc
$LN26@xmlCharEnc:

; 1966 :         *inlen = 0;

	mov	DWORD PTR _toconv$[ebp], 0

; 1967 :         ret = -4;

	mov	esi, -4					; fffffffcH
$LN83@xmlCharEnc:

; 2612 :                             in->content, &toconv);
; 2613 :     xmlBufferShrink(in, toconv);

	mov	DWORD PTR _written$[ebp], 0
$LN27@xmlCharEnc:
	push	DWORD PTR _toconv$[ebp]
	push	ebx
	call	_xmlBufferShrink

; 2614 :     out->use += written;

	mov	eax, DWORD PTR _written$[ebp]
	add	esp, 8
	add	DWORD PTR [edi+4], eax

; 2615 :     writtentot += written;

	add	DWORD PTR _writtentot$1$[ebp], eax
	mov	ecx, DWORD PTR [edi+4]

; 2616 :     out->content[out->use] = 0;

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [ecx+eax], 0

; 2617 :     if (ret == -1) {

	cmp	esi, -1
	jne	SHORT $LN10@xmlCharEnc

; 2618 :         if (written > 0) {

	cmp	DWORD PTR _written$[ebp], 0
	jg	$retry$86

; 2619 :             /* Can be a limitation of iconv or uconv */
; 2620 :             goto retry;
; 2621 :         }
; 2622 :         ret = -3;

	mov	esi, -3					; fffffffdH

; 2706 : 	}
; 2707 :     }
; 2708 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 2709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlCharEnc:

; 2623 :     }
; 2624 : 
; 2625 :     if (ret >= 0) output += ret;
; 2626 : 
; 2627 :     /*
; 2628 :      * Attempt to handle error cases
; 2629 :      */
; 2630 :     switch (ret) {

	cmp	esi, -4					; fffffffcH
	je	$LN16@xmlCharEnc
	cmp	esi, -2					; fffffffeH
	jne	$LN2@xmlCharEnc

; 2654 :             break;
; 2655 :         case -2: {
; 2656 : 	    xmlChar charref[20];
; 2657 : 	    int len = in->use;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _len$10[ebp], eax

; 2658 : 	    const xmlChar *utf = (const xmlChar *) in->content;
; 2659 : 	    int cur, charrefLen;
; 2660 : 
; 2661 : 	    cur = xmlGetUTF8Char(utf, &len);

	lea	eax, DWORD PTR _len$10[ebp]
	push	eax
	push	DWORD PTR [ebx]
	call	_xmlGetUTF8Char
	add	esp, 8

; 2662 : 	    if (cur <= 0)

	test	eax, eax
	jle	$LN2@xmlCharEnc

; 2663 :                 break;
; 2664 : 
; 2665 : #ifdef DEBUG_ENCODING
; 2666 :             xmlGenericError(xmlGenericErrorContext,
; 2667 :                     "handling output conversion error\n");
; 2668 :             xmlGenericError(xmlGenericErrorContext,
; 2669 :                     "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
; 2670 :                     in->content[0], in->content[1],
; 2671 :                     in->content[2], in->content[3]);
; 2672 : #endif
; 2673 :             /*
; 2674 :              * Removes the UTF8 sequence, and replace it by a charref
; 2675 :              * and continue the transcoding phase, hoping the error
; 2676 :              * did not mangle the encoder state.
; 2677 :              */
; 2678 :             charrefLen = snprintf((char *) &charref[0], sizeof(charref),

	push	eax
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	lea	eax, DWORD PTR _charref$2[ebp]
	push	20					; 00000014H
	push	eax
	call	_snprintf

; 2679 :                              "&#%d;", cur);
; 2680 :             xmlBufferShrink(in, len);

	push	DWORD PTR _len$10[ebp]
	mov	esi, eax
	push	ebx
	mov	DWORD PTR _charrefLen$1$[ebp], esi
	call	_xmlBufferShrink

; 2681 :             xmlBufferGrow(out, charrefLen * 4);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edi
	call	_xmlBufferGrow

; 1950 :     if (handler->output != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]

; 2681 :             xmlBufferGrow(out, charrefLen * 4);

	add	esp, 32					; 00000020H

; 2682 : 	    written = out->size - out->use - 1;

	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]

; 2684 :             ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	mov	ecx, DWORD PTR [edi]
	dec	esi
	add	ecx, DWORD PTR [edi+4]

; 1950 :     if (handler->output != NULL) {

	mov	eax, DWORD PTR [eax+8]

; 2683 :             toconv = charrefLen;

	mov	edx, DWORD PTR _charrefLen$1$[ebp]
	mov	DWORD PTR _written$[ebp], esi
	mov	DWORD PTR _toconv$[ebp], edx

; 1950 :     if (handler->output != NULL) {

	test	eax, eax
	je	SHORT $LN43@xmlCharEnc

; 1951 :         ret = handler->output(out, outlen, in, inlen);

	lea	edx, DWORD PTR _toconv$[ebp]
	push	edx
	lea	edx, DWORD PTR _charref$2[ebp]
	push	edx
	lea	edx, DWORD PTR _written$[ebp]
	push	edx
	push	ecx
	call	eax

; 1952 :     }

	mov	edx, DWORD PTR _toconv$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _written$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN46@xmlCharEnc
$LN43@xmlCharEnc:

; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN45@xmlCharEnc

; 1805 :     char *icv_out = (char *) out;

	mov	DWORD PTR _icv_out$4[ebp], ecx
	lea	ebx, DWORD PTR _charref$2[ebp]
	mov	DWORD PTR _icv_in$3[ebp], ebx

; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	mov	ebx, DWORD PTR _in$[ebp]
	test	ecx, ecx
	je	SHORT $LN50@xmlCharEnc

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	ecx, DWORD PTR _charrefLen$1$[ebp]
	mov	DWORD PTR _icv_inlen$7[ebp], ecx

; 1813 :     icv_outlen = *outlen;
; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	lea	ecx, DWORD PTR _icv_outlen$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR _icv_out$4[ebp]
	mov	DWORD PTR _icv_outlen$5[ebp], esi
	push	ecx
	lea	ecx, DWORD PTR _icv_inlen$7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _icv_in$3[ebp]
	push	ecx
	push	eax
	call	DWORD PTR __imp__libiconv

; 1815 :     *inlen -= icv_inlen;

	mov	edx, DWORD PTR _toconv$[ebp]
	mov	esi, eax

; 1816 :     *outlen -= icv_outlen;

	mov	eax, DWORD PTR _written$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _icv_inlen$7[ebp]
	sub	edx, ecx
	sub	eax, DWORD PTR _icv_outlen$5[ebp]
	mov	DWORD PTR _toconv$[ebp], edx
	mov	DWORD PTR _written$[ebp], eax

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	test	ecx, ecx
	jne	SHORT $LN53@xmlCharEnc
	cmp	esi, -1
	je	SHORT $LN53@xmlCharEnc

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN46@xmlCharEnc
$LN50@xmlCharEnc:

; 1809 :         if (outlen != NULL) *outlen = 0;

	xor	eax, eax

; 1810 :         return(-1);

	or	esi, -1

; 1956 :     }

	jmp	SHORT $LN84@xmlCharEnc
$LN45@xmlCharEnc:

; 1957 : #endif /* LIBXML_ICONV_ENABLED */
; 1958 : #ifdef LIBXML_ICU_ENABLED
; 1959 :     else if (handler->uconv_out != NULL) {
; 1960 :         ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,
; 1961 :                               TRUE);
; 1962 :     }
; 1963 : #endif /* LIBXML_ICU_ENABLED */
; 1964 :     else {
; 1965 :         *outlen = 0;

	xor	eax, eax

; 1967 :         ret = -4;

	mov	esi, -4					; fffffffcH
	xor	edx, edx
	mov	DWORD PTR _toconv$[ebp], edx
$LN84@xmlCharEnc:

; 2685 :                                     charref, &toconv);
; 2686 : 
; 2687 : 	    if ((ret < 0) || (toconv != charrefLen)) {

	mov	DWORD PTR _written$[ebp], eax
$LN46@xmlCharEnc:
	test	esi, esi
	js	SHORT $LN67@xmlCharEnc
	cmp	edx, DWORD PTR _charrefLen$1$[ebp]
	jne	SHORT $LN67@xmlCharEnc

; 2699 : 	        break;
; 2700 : 	    }
; 2701 : 
; 2702 :             out->use += written;

	add	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [edi+4]

; 2703 :             writtentot += written;
; 2704 :             out->content[out->use] = 0;

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [ecx+eax], 0

; 2705 :             goto retry;

	jmp	$retry$86
$LN53@xmlCharEnc:

; 1819 :         if (errno == EILSEQ) {

	mov	esi, DWORD PTR __imp___errno
	call	esi
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN54@xmlCharEnc

; 2684 :             ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	mov	esi, -2					; fffffffeH

; 1820 :             return -2;

	jmp	SHORT $LN67@xmlCharEnc
$LN54@xmlCharEnc:

; 1821 :         } else
; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	call	esi
	cmp	DWORD PTR [eax], 7
	jne	SHORT $LN56@xmlCharEnc

; 2684 :             ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	or	esi, -1

; 1825 :             return -1;

	jmp	SHORT $LN67@xmlCharEnc
$LN56@xmlCharEnc:

; 1826 :         } else
; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	call	esi
	mov	esi, -3					; fffffffdH
$LN67@xmlCharEnc:

; 2688 : 		char buf[50];
; 2689 : 
; 2690 : 		snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	ecx, DWORD PTR [ebx]
	movzx	eax, BYTE PTR [ecx+3]
	push	eax
	movzx	eax, BYTE PTR [ecx+2]
	push	eax
	movzx	eax, BYTE PTR [ecx+1]
	push	eax
	movzx	eax, BYTE PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	lea	eax, DWORD PTR _buf$1[ebp]
	push	49					; 00000031H
	push	eax
	call	_snprintf

; 2691 : 			 in->content[0], in->content[1],
; 2692 : 			 in->content[2], in->content[3]);
; 2693 : 		buf[49] = 0;
; 2694 : 		xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$1[ebp]
	mov	BYTE PTR _buf$1[ebp+49], 0
	push	eax
	push	OFFSET ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 40					; 00000028H

; 2695 : 		    "output conversion failed due to conv error, bytes %s\n",
; 2696 : 			       buf);
; 2697 : 		if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)

	cmp	DWORD PTR [ebx+12], 2
	je	SHORT $LN2@xmlCharEnc

; 2698 : 		    in->content[0] = ' ';

	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR [eax], 32			; 00000020H

; 2706 : 	}
; 2707 :     }
; 2708 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 2709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlCharEnc:

; 2631 :         case 0:
; 2632 : #ifdef DEBUG_ENCODING
; 2633 : 	    xmlGenericError(xmlGenericErrorContext,
; 2634 : 		    "converted %d bytes to %d bytes of output\n",
; 2635 : 	            toconv, written);
; 2636 : #endif
; 2637 : 	    break;
; 2638 :         case -1:
; 2639 : #ifdef DEBUG_ENCODING
; 2640 : 	    xmlGenericError(xmlGenericErrorContext,
; 2641 : 		    "output conversion failed by lack of space\n");
; 2642 : #endif
; 2643 : 	    break;
; 2644 :         case -3:
; 2645 : #ifdef DEBUG_ENCODING
; 2646 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of output %d left\n",
; 2647 : 	            toconv, written, in->use);
; 2648 : #endif
; 2649 : 	    break;
; 2650 :         case -4:
; 2651 : 	    xmlEncodingErr(XML_I18N_NO_OUTPUT,

	push	0
	push	OFFSET ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
	push	6004					; 00001774H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2652 : 		           "xmlCharEncOutFunc: no output function !\n", NULL);
; 2653 : 	    ret = -1;

	or	esi, -1
$LN2@xmlCharEnc:

; 2706 : 	}
; 2707 :     }
; 2708 :     return(ret);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 2709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@xmlCharEnc:

; 2588 :         toconv = 0;
; 2589 :         /* TODO: Check return value. */
; 2590 :         xmlEncOutputChunk(handler, &out->content[out->use], &written,

	lea	eax, DWORD PTR _toconv$[ebp]
	mov	DWORD PTR _toconv$[ebp], 0
	push	eax
	push	0
	lea	eax, DWORD PTR _written$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi]
	add	eax, edx
	push	eax
	push	DWORD PTR _handler$[ebp]
	call	_xmlEncOutputChunk

; 2591 :                           NULL, &toconv);
; 2592 :         out->use += written;

	mov	eax, DWORD PTR _written$[ebp]
	add	esp, 20					; 00000014H
	add	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [edi+4]

; 2593 :         out->content[out->use] = 0;

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [ecx+eax], 0
$LN64@xmlCharEnc:

; 2594 : #ifdef DEBUG_ENCODING
; 2595 : 	xmlGenericError(xmlGenericErrorContext,
; 2596 : 		"initialized encoder\n");
; 2597 : #endif
; 2598 :         return(0);

	pop	esi
	pop	ebx
	xor	eax, eax
	pop	edi

; 2709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@xmlCharEnc:

; 2568 :     int ret;
; 2569 :     int written;
; 2570 :     int writtentot = 0;
; 2571 :     int toconv;
; 2572 :     int output = 0;
; 2573 : 
; 2574 :     if (handler == NULL) return(-1);
; 2575 :     if (out == NULL) return(-1);

	or	eax, -1
	pop	edi

; 2709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncOutFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlDetectCharEncoding
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlDetectCharEncoding PROC				; COMDAT

; 933  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _in$[ebp]
	test	eax, eax
	je	$LN16@xmlDetectC

; 934  :     if (in == NULL)
; 935  :         return(XML_CHAR_ENCODING_NONE);
; 936  :     if (len >= 4) {

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, 4
	jl	$LN11@xmlDetectC

; 937  : 	if ((in[0] == 0x00) && (in[1] == 0x00) &&
; 938  : 	    (in[2] == 0x00) && (in[3] == 0x3C))

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	jne	SHORT $LN4@xmlDetectC
	mov	cl, BYTE PTR [eax+1]
	test	cl, cl
	jne	SHORT $LN6@xmlDetectC
	cmp	BYTE PTR [eax+2], cl
	jne	SHORT $LN19@xmlDetectC
	cmp	BYTE PTR [eax+3], 60			; 0000003cH
	jne	SHORT $LN19@xmlDetectC

; 939  : 	    return(XML_CHAR_ENCODING_UCS4BE);

	mov	eax, 5

; 984  : }

	pop	ebp
	ret	0
$LN19@xmlDetectC:

; 943  : 	if ((in[0] == 0x00) && (in[1] == 0x00) &&
; 944  : 	    (in[2] == 0x3C) && (in[3] == 0x00))

	test	cl, cl
	jne	SHORT $LN6@xmlDetectC
	cmp	BYTE PTR [eax+2], 60			; 0000003cH
	jne	SHORT $LN6@xmlDetectC
	cmp	BYTE PTR [eax+3], cl
	jne	SHORT $LN6@xmlDetectC

; 945  : 	    return(XML_CHAR_ENCODING_UCS4_2143);

	mov	eax, 7

; 984  : }

	pop	ebp
	ret	0
$LN6@xmlDetectC:

; 946  : 	if ((in[0] == 0x00) && (in[1] == 0x3C) &&
; 947  : 	    (in[2] == 0x00) && (in[3] == 0x00))

	cmp	cl, 60					; 0000003cH
	jne	$LN11@xmlDetectC
	cmp	BYTE PTR [eax+2], 0
	jne	SHORT $LN21@xmlDetectC
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN21@xmlDetectC

; 948  : 	    return(XML_CHAR_ENCODING_UCS4_3412);

	mov	eax, 8

; 984  : }

	pop	ebp
	ret	0
$LN21@xmlDetectC:

; 962  : 	    return(XML_CHAR_ENCODING_UTF16LE);
; 963  : 	if ((in[0] == 0x00) && (in[1] == 0x3C) &&
; 964  : 	    (in[2] == 0x00) && (in[3] == 0x3F))

	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+2], 0
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+3], 63			; 0000003fH
	je	$LN22@xmlDetectC
	jmp	SHORT $LN11@xmlDetectC
$LN4@xmlDetectC:

; 940  : 	if ((in[0] == 0x3C) && (in[1] == 0x00) &&
; 941  : 	    (in[2] == 0x00) && (in[3] == 0x00))

	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN7@xmlDetectC
	cmp	BYTE PTR [eax+1], 0
	jne	SHORT $LN20@xmlDetectC
	cmp	BYTE PTR [eax+2], 0
	jne	SHORT $LN20@xmlDetectC
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN20@xmlDetectC

; 942  : 	    return(XML_CHAR_ENCODING_UCS4LE);

	mov	eax, 4

; 984  : }

	pop	ebp
	ret	0
$LN7@xmlDetectC:

; 949  : 	if ((in[0] == 0x4C) && (in[1] == 0x6F) &&
; 950  : 	    (in[2] == 0xA7) && (in[3] == 0x94))

	cmp	cl, 76					; 0000004cH
	jne	SHORT $LN8@xmlDetectC
	cmp	BYTE PTR [eax+1], 111			; 0000006fH
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+2], 167			; 000000a7H
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+3], 148			; 00000094H
	jne	SHORT $LN11@xmlDetectC

; 951  : 	    return(XML_CHAR_ENCODING_EBCDIC);

	mov	eax, 6

; 984  : }

	pop	ebp
	ret	0
$LN8@xmlDetectC:

; 952  : 	if ((in[0] == 0x3C) && (in[1] == 0x3F) &&
; 953  : 	    (in[2] == 0x78) && (in[3] == 0x6D))

	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN11@xmlDetectC
$LN20@xmlDetectC:
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 63					; 0000003fH
	jne	SHORT $LN9@xmlDetectC
	cmp	BYTE PTR [eax+2], 120			; 00000078H
	jne	SHORT $LN9@xmlDetectC
	cmp	BYTE PTR [eax+3], 109			; 0000006dH
	je	SHORT $LN24@xmlDetectC
$LN9@xmlDetectC:

; 954  : 	    return(XML_CHAR_ENCODING_UTF8);
; 955  : 	/*
; 956  : 	 * Although not part of the recommendation, we also
; 957  : 	 * attempt an "auto-recognition" of UTF-16LE and
; 958  : 	 * UTF-16BE encodings.
; 959  : 	 */
; 960  : 	if ((in[0] == 0x3C) && (in[1] == 0x00) &&
; 961  : 	    (in[2] == 0x3F) && (in[3] == 0x00))

	test	cl, cl
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+2], 63			; 0000003fH
	jne	SHORT $LN11@xmlDetectC
	cmp	BYTE PTR [eax+3], cl
	je	SHORT $LN23@xmlDetectC
$LN11@xmlDetectC:

; 965  : 	    return(XML_CHAR_ENCODING_UTF16BE);
; 966  :     }
; 967  :     if (len >= 3) {

	cmp	edx, 3
	jl	SHORT $LN13@xmlDetectC

; 968  : 	/*
; 969  : 	 * Errata on XML-1.0 June 20 2001
; 970  : 	 * We now allow an UTF8 encoded BOM
; 971  : 	 */
; 972  : 	if ((in[0] == 0xEF) && (in[1] == 0xBB) &&

	cmp	BYTE PTR [eax], 239			; 000000efH
	jne	SHORT $LN13@xmlDetectC
	cmp	BYTE PTR [eax+1], 187			; 000000bbH
	jne	SHORT $LN13@xmlDetectC
	cmp	BYTE PTR [eax+2], 191			; 000000bfH
	jne	SHORT $LN13@xmlDetectC
$LN24@xmlDetectC:

; 973  : 	    (in[2] == 0xBF))
; 974  : 	    return(XML_CHAR_ENCODING_UTF8);

	mov	eax, 1

; 984  : }

	pop	ebp
	ret	0
$LN13@xmlDetectC:

; 975  :     }
; 976  :     /* For UTF-16 we can recognize by the BOM */
; 977  :     if (len >= 2) {

	cmp	edx, 2
	jl	SHORT $LN16@xmlDetectC

; 978  : 	if ((in[0] == 0xFE) && (in[1] == 0xFF))

	mov	cl, BYTE PTR [eax]
	cmp	cl, 254					; 000000feH
	jne	SHORT $LN18@xmlDetectC
	cmp	BYTE PTR [eax+1], 255			; 000000ffH
	jne	SHORT $LN16@xmlDetectC
$LN22@xmlDetectC:

; 979  : 	    return(XML_CHAR_ENCODING_UTF16BE);

	mov	eax, 3

; 984  : }

	pop	ebp
	ret	0
$LN18@xmlDetectC:

; 980  : 	if ((in[0] == 0xFF) && (in[1] == 0xFE))

	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN16@xmlDetectC
	cmp	BYTE PTR [eax+1], 254			; 000000feH
	jne	SHORT $LN16@xmlDetectC
$LN23@xmlDetectC:

; 981  : 	    return(XML_CHAR_ENCODING_UTF16LE);

	mov	eax, 2

; 984  : }

	pop	ebp
	ret	0
$LN16@xmlDetectC:

; 982  :     }
; 983  :     return(XML_CHAR_ENCODING_NONE);

	xor	eax, eax

; 984  : }

	pop	ebp
	ret	0
_xmlDetectCharEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetCharEncodingName
_TEXT	SEGMENT
_enc$ = 8						; size = 4
_xmlGetCharEncodingName PROC				; COMDAT

; 1234 : xmlGetCharEncodingName(xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _enc$[ebp]
	inc	eax
	cmp	eax, 23					; 00000017H
	ja	SHORT $LN2@xmlGetChar

; 1235 :     switch (enc) {

	jmp	DWORD PTR $LN30@xmlGetChar[eax*4]
$LN6@xmlGetChar:

; 1236 :         case XML_CHAR_ENCODING_ERROR:
; 1237 : 	    return(NULL);
; 1238 :         case XML_CHAR_ENCODING_NONE:
; 1239 : 	    return(NULL);
; 1240 :         case XML_CHAR_ENCODING_UTF8:
; 1241 : 	    return("UTF-8");

	mov	eax, OFFSET ??_C@_05EGJIMALK@UTF?98@

; 1286 : }

	pop	ebp
	ret	0
$LN8@xmlGetChar:

; 1242 :         case XML_CHAR_ENCODING_UTF16LE:
; 1243 : 	    return("UTF-16");
; 1244 :         case XML_CHAR_ENCODING_UTF16BE:
; 1245 : 	    return("UTF-16");

	mov	eax, OFFSET ??_C@_06KNDPGIKI@UTF?916@

; 1286 : }

	pop	ebp
	ret	0
$LN9@xmlGetChar:

; 1246 :         case XML_CHAR_ENCODING_EBCDIC:
; 1247 :             return("EBCDIC");

	mov	eax, OFFSET ??_C@_06JJAKJGEC@EBCDIC@

; 1286 : }

	pop	ebp
	ret	0
$LN13@xmlGetChar:

; 1248 :         case XML_CHAR_ENCODING_UCS4LE:
; 1249 :             return("ISO-10646-UCS-4");
; 1250 :         case XML_CHAR_ENCODING_UCS4BE:
; 1251 :             return("ISO-10646-UCS-4");
; 1252 :         case XML_CHAR_ENCODING_UCS4_2143:
; 1253 :             return("ISO-10646-UCS-4");
; 1254 :         case XML_CHAR_ENCODING_UCS4_3412:
; 1255 :             return("ISO-10646-UCS-4");

	mov	eax, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@

; 1286 : }

	pop	ebp
	ret	0
$LN14@xmlGetChar:

; 1256 :         case XML_CHAR_ENCODING_UCS2:
; 1257 :             return("ISO-10646-UCS-2");

	mov	eax, OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@

; 1286 : }

	pop	ebp
	ret	0
$LN15@xmlGetChar:

; 1258 :         case XML_CHAR_ENCODING_8859_1:
; 1259 : 	    return("ISO-8859-1");

	mov	eax, OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@

; 1286 : }

	pop	ebp
	ret	0
$LN16@xmlGetChar:

; 1260 :         case XML_CHAR_ENCODING_8859_2:
; 1261 : 	    return("ISO-8859-2");

	mov	eax, OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@

; 1286 : }

	pop	ebp
	ret	0
$LN17@xmlGetChar:

; 1262 :         case XML_CHAR_ENCODING_8859_3:
; 1263 : 	    return("ISO-8859-3");

	mov	eax, OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@

; 1286 : }

	pop	ebp
	ret	0
$LN18@xmlGetChar:

; 1264 :         case XML_CHAR_ENCODING_8859_4:
; 1265 : 	    return("ISO-8859-4");

	mov	eax, OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@

; 1286 : }

	pop	ebp
	ret	0
$LN19@xmlGetChar:

; 1266 :         case XML_CHAR_ENCODING_8859_5:
; 1267 : 	    return("ISO-8859-5");

	mov	eax, OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@

; 1286 : }

	pop	ebp
	ret	0
$LN20@xmlGetChar:

; 1268 :         case XML_CHAR_ENCODING_8859_6:
; 1269 : 	    return("ISO-8859-6");

	mov	eax, OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@

; 1286 : }

	pop	ebp
	ret	0
$LN21@xmlGetChar:

; 1270 :         case XML_CHAR_ENCODING_8859_7:
; 1271 : 	    return("ISO-8859-7");

	mov	eax, OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@

; 1286 : }

	pop	ebp
	ret	0
$LN22@xmlGetChar:

; 1272 :         case XML_CHAR_ENCODING_8859_8:
; 1273 : 	    return("ISO-8859-8");

	mov	eax, OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@

; 1286 : }

	pop	ebp
	ret	0
$LN23@xmlGetChar:

; 1274 :         case XML_CHAR_ENCODING_8859_9:
; 1275 : 	    return("ISO-8859-9");

	mov	eax, OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@

; 1286 : }

	pop	ebp
	ret	0
$LN24@xmlGetChar:

; 1276 :         case XML_CHAR_ENCODING_2022_JP:
; 1277 :             return("ISO-2022-JP");

	mov	eax, OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@

; 1286 : }

	pop	ebp
	ret	0
$LN25@xmlGetChar:

; 1278 :         case XML_CHAR_ENCODING_SHIFT_JIS:
; 1279 :             return("Shift-JIS");

	mov	eax, OFFSET ??_C@_09DNLJOPNC@Shift?9JIS@

; 1286 : }

	pop	ebp
	ret	0
$LN26@xmlGetChar:

; 1280 :         case XML_CHAR_ENCODING_EUC_JP:
; 1281 :             return("EUC-JP");

	mov	eax, OFFSET ??_C@_06KCFOODCD@EUC?9JP@

; 1286 : }

	pop	ebp
	ret	0
$LN2@xmlGetChar:

; 1282 : 	case XML_CHAR_ENCODING_ASCII:
; 1283 : 	    return(NULL);
; 1284 :     }
; 1285 :     return(NULL);

	xor	eax, eax

; 1286 : }

	pop	ebp
	ret	0
$LN30@xmlGetChar:
	DD	$LN2@xmlGetChar
	DD	$LN2@xmlGetChar
	DD	$LN6@xmlGetChar
	DD	$LN8@xmlGetChar
	DD	$LN8@xmlGetChar
	DD	$LN13@xmlGetChar
	DD	$LN13@xmlGetChar
	DD	$LN9@xmlGetChar
	DD	$LN13@xmlGetChar
	DD	$LN13@xmlGetChar
	DD	$LN14@xmlGetChar
	DD	$LN15@xmlGetChar
	DD	$LN16@xmlGetChar
	DD	$LN17@xmlGetChar
	DD	$LN18@xmlGetChar
	DD	$LN19@xmlGetChar
	DD	$LN20@xmlGetChar
	DD	$LN21@xmlGetChar
	DD	$LN22@xmlGetChar
	DD	$LN23@xmlGetChar
	DD	$LN24@xmlGetChar
	DD	$LN25@xmlGetChar
	DD	$LN26@xmlGetChar
	DD	$LN2@xmlGetChar
_xmlGetCharEncodingName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlParseCharEncoding
_TEXT	SEGMENT
_upper$ = -500						; size = 500
_name$ = 8						; size = 4
_xmlParseCharEncoding PROC				; COMDAT

; 1151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	test	edi, edi
	je	$LN47@xmlParseCh

; 1152 :     const char *alias;
; 1153 :     char upper[500];
; 1154 :     int i;
; 1155 : 
; 1156 :     if (name == NULL)
; 1157 : 	return(XML_CHAR_ENCODING_NONE);
; 1158 : 
; 1159 :     /*
; 1160 :      * Do the alias resolution
; 1161 :      */
; 1162 :     alias = xmlGetEncodingAlias(name);

	push	ebx
	push	esi
	push	edi
	call	_xmlGetEncodingAlias

; 1163 :     if (alias != NULL)
; 1164 : 	name = alias;
; 1165 : 
; 1166 :     for (i = 0;i < 499;i++) {

	mov	ebx, DWORD PTR __imp__toupper
	add	esp, 4
	test	eax, eax
	cmovne	edi, eax
	xor	esi, esi
$LL4@xmlParseCh:

; 1167 :         upper[i] = toupper(name[i]);

	movsx	eax, BYTE PTR [edi+esi]
	push	eax
	call	ebx
	add	esp, 4
	mov	BYTE PTR _upper$[ebp+esi], al

; 1168 : 	if (upper[i] == 0) break;

	test	al, al
	je	SHORT $LN37@xmlParseCh

; 1163 :     if (alias != NULL)
; 1164 : 	name = alias;
; 1165 : 
; 1166 :     for (i = 0;i < 499;i++) {

	inc	esi
	cmp	esi, 499				; 000001f3H
	jl	SHORT $LL4@xmlParseCh
$LN37@xmlParseCh:

; 1169 :     }
; 1170 :     upper[i] = 0;

	mov	BYTE PTR _upper$[ebp+esi], 0

; 1171 : 
; 1172 :     if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);

	lea	eax, DWORD PTR _upper$[ebp]
	pop	esi
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@@
	pop	ebx
	npad	6
$LL48@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN49@xmlParseCh
	test	dl, dl
	je	SHORT $LN50@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN49@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL48@xmlParseCh
$LN50@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN51@xmlParseCh
$LN49@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN51@xmlParseCh:
	test	eax, eax
	je	$LN47@xmlParseCh

; 1173 :     if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);

	mov	ecx, OFFSET ??_C@_05EGJIMALK@UTF?98@
	lea	eax, DWORD PTR _upper$[ebp]
$LL52@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN53@xmlParseCh
	test	dl, dl
	je	SHORT $LN54@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN53@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL52@xmlParseCh
$LN54@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN55@xmlParseCh
$LN53@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN55@xmlParseCh:
	test	eax, eax
	je	$LN46@xmlParseCh

; 1174 :     if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);

	mov	ecx, OFFSET ??_C@_04OOMJJNCF@UTF8@
	lea	eax, DWORD PTR _upper$[ebp]
$LL56@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN57@xmlParseCh
	test	dl, dl
	je	SHORT $LN58@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN57@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL56@xmlParseCh
$LN58@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN59@xmlParseCh
$LN57@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN59@xmlParseCh:
	test	eax, eax
	je	$LN46@xmlParseCh

; 1175 : 
; 1176 :     /*
; 1177 :      * NOTE: if we were able to parse this, the endianness of UTF16 is
; 1178 :      *       already found and in use
; 1179 :      */
; 1180 :     if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);

	mov	ecx, OFFSET ??_C@_06KNDPGIKI@UTF?916@
	lea	eax, DWORD PTR _upper$[ebp]
$LL60@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN61@xmlParseCh
	test	dl, dl
	je	SHORT $LN62@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN61@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL60@xmlParseCh
$LN62@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN63@xmlParseCh
$LN61@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN63@xmlParseCh:
	test	eax, eax
	je	$LN45@xmlParseCh

; 1181 :     if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);

	mov	ecx, OFFSET ??_C@_05MNCHLHCA@UTF16@
	lea	eax, DWORD PTR _upper$[ebp]
$LL64@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN65@xmlParseCh
	test	dl, dl
	je	SHORT $LN66@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN65@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL64@xmlParseCh
$LN66@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN67@xmlParseCh
$LN65@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN67@xmlParseCh:
	test	eax, eax
	je	$LN45@xmlParseCh

; 1182 : 
; 1183 :     if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);

	mov	ecx, OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
	lea	eax, DWORD PTR _upper$[ebp]
$LL68@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN69@xmlParseCh
	test	dl, dl
	je	SHORT $LN70@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN69@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL68@xmlParseCh
$LN70@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN71@xmlParseCh
$LN69@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN71@xmlParseCh:
	test	eax, eax
	je	$LN44@xmlParseCh

; 1184 :     if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);

	mov	ecx, OFFSET ??_C@_05JHAMEAP@UCS?92@
	lea	eax, DWORD PTR _upper$[ebp]
$LL72@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN73@xmlParseCh
	test	dl, dl
	je	SHORT $LN74@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN73@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL72@xmlParseCh
$LN74@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN75@xmlParseCh
$LN73@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN75@xmlParseCh:
	test	eax, eax
	je	$LN44@xmlParseCh

; 1185 :     if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);

	mov	ecx, OFFSET ??_C@_04MDAFHLBC@UCS2@
	lea	eax, DWORD PTR _upper$[ebp]
$LL76@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN77@xmlParseCh
	test	dl, dl
	je	SHORT $LN78@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN77@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL76@xmlParseCh
$LN78@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN79@xmlParseCh
$LN77@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN79@xmlParseCh:
	test	eax, eax
	je	$LN44@xmlParseCh

; 1186 : 
; 1187 :     /*
; 1188 :      * NOTE: if we were able to parse this, the endianness of UCS4 is
; 1189 :      *       already found and in use
; 1190 :      */
; 1191 :     if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	ecx, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	lea	eax, DWORD PTR _upper$[ebp]
$LL80@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN81@xmlParseCh
	test	dl, dl
	je	SHORT $LN82@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN81@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL80@xmlParseCh
$LN82@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN83@xmlParseCh
$LN81@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN83@xmlParseCh:
	test	eax, eax
	je	$LN43@xmlParseCh

; 1192 :     if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	ecx, OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	lea	eax, DWORD PTR _upper$[ebp]
$LL84@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN85@xmlParseCh
	test	dl, dl
	je	SHORT $LN86@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN85@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL84@xmlParseCh
$LN86@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN87@xmlParseCh
$LN85@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN87@xmlParseCh:
	test	eax, eax
	je	$LN43@xmlParseCh

; 1193 :     if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	ecx, OFFSET ??_C@_04JFFPNMJE@UCS4@
	lea	eax, DWORD PTR _upper$[ebp]
$LL88@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN89@xmlParseCh
	test	dl, dl
	je	SHORT $LN90@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN89@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL88@xmlParseCh
$LN90@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN91@xmlParseCh
$LN89@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN91@xmlParseCh:
	test	eax, eax
	je	$LN43@xmlParseCh

; 1194 : 
; 1195 : 
; 1196 :     if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);

	mov	ecx, OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	lea	eax, DWORD PTR _upper$[ebp]
$LL92@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN93@xmlParseCh
	test	dl, dl
	je	SHORT $LN94@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN93@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL92@xmlParseCh
$LN94@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN95@xmlParseCh
$LN93@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN95@xmlParseCh:
	test	eax, eax
	je	$LN42@xmlParseCh

; 1197 :     if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);

	mov	ecx, OFFSET ??_C@_0M@HACBCLE@ISO?9LATIN?91@
	lea	eax, DWORD PTR _upper$[ebp]
$LL96@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN97@xmlParseCh
	test	dl, dl
	je	SHORT $LN98@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN97@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL96@xmlParseCh
$LN98@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN99@xmlParseCh
$LN97@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN99@xmlParseCh:
	test	eax, eax
	je	$LN42@xmlParseCh

; 1198 :     if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);

	mov	ecx, OFFSET ??_C@_0M@POJFGGLA@ISO?5LATIN?51@
	lea	eax, DWORD PTR _upper$[ebp]
$LL100@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN101@xmlParseCh
	test	dl, dl
	je	SHORT $LN102@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN101@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL100@xmlParseCh
$LN102@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN103@xmlParseCh
$LN101@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN103@xmlParseCh:
	test	eax, eax
	je	$LN42@xmlParseCh

; 1199 : 
; 1200 :     if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);

	mov	ecx, OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@
	lea	eax, DWORD PTR _upper$[ebp]
$LL104@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN105@xmlParseCh
	test	dl, dl
	je	SHORT $LN106@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN105@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL104@xmlParseCh
$LN106@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN107@xmlParseCh
$LN105@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN107@xmlParseCh:
	test	eax, eax
	je	$LN41@xmlParseCh

; 1201 :     if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);

	mov	ecx, OFFSET ??_C@_0M@CMCPEBHH@ISO?9LATIN?92@
	lea	eax, DWORD PTR _upper$[ebp]
$LL108@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN109@xmlParseCh
	test	dl, dl
	je	SHORT $LN110@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN109@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL108@xmlParseCh
$LN110@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN111@xmlParseCh
$LN109@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN111@xmlParseCh:
	test	eax, eax
	je	$LN41@xmlParseCh

; 1202 :     if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);

	mov	ecx, OFFSET ??_C@_0M@NFLIDFHD@ISO?5LATIN?52@
	lea	eax, DWORD PTR _upper$[ebp]
$LL112@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN113@xmlParseCh
	test	dl, dl
	je	SHORT $LN114@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN113@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL112@xmlParseCh
$LN114@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN115@xmlParseCh
$LN113@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN115@xmlParseCh:
	test	eax, eax
	je	$LN41@xmlParseCh

; 1203 : 
; 1204 :     if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);

	mov	ecx, OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@
	lea	eax, DWORD PTR _upper$[ebp]
$LL116@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN117@xmlParseCh
	test	dl, dl
	je	SHORT $LN118@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN117@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL116@xmlParseCh
$LN118@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN119@xmlParseCh
$LN117@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN119@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN25@xmlParseCh
	mov	eax, 12					; 0000000cH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlParseCh:

; 1205 :     if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);

	mov	ecx, OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@
	lea	eax, DWORD PTR _upper$[ebp]
$LL120@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN121@xmlParseCh
	test	dl, dl
	je	SHORT $LN122@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN121@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL120@xmlParseCh
$LN122@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN123@xmlParseCh
$LN121@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN123@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN26@xmlParseCh
	mov	eax, 13					; 0000000dH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlParseCh:

; 1206 :     if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);

	mov	ecx, OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@
	lea	eax, DWORD PTR _upper$[ebp]
$LL124@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN125@xmlParseCh
	test	dl, dl
	je	SHORT $LN126@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN125@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL124@xmlParseCh
$LN126@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN127@xmlParseCh
$LN125@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN127@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN27@xmlParseCh
	mov	eax, 14					; 0000000eH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@xmlParseCh:

; 1207 :     if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);

	mov	ecx, OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@
	lea	eax, DWORD PTR _upper$[ebp]
$LL128@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN129@xmlParseCh
	test	dl, dl
	je	SHORT $LN130@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN129@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL128@xmlParseCh
$LN130@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN131@xmlParseCh
$LN129@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN131@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN28@xmlParseCh
	mov	eax, 15					; 0000000fH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlParseCh:

; 1208 :     if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);

	mov	ecx, OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@
	lea	eax, DWORD PTR _upper$[ebp]
$LL132@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN133@xmlParseCh
	test	dl, dl
	je	SHORT $LN134@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN133@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL132@xmlParseCh
$LN134@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN135@xmlParseCh
$LN133@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN135@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN29@xmlParseCh
	mov	eax, 16					; 00000010H
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlParseCh:

; 1209 :     if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);

	mov	ecx, OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@
	lea	eax, DWORD PTR _upper$[ebp]
	npad	2
$LL136@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN137@xmlParseCh
	test	dl, dl
	je	SHORT $LN138@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN137@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL136@xmlParseCh
$LN138@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN139@xmlParseCh
$LN137@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN139@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN30@xmlParseCh
	mov	eax, 17					; 00000011H
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlParseCh:

; 1210 :     if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);

	mov	ecx, OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@
	lea	eax, DWORD PTR _upper$[ebp]
	npad	2
$LL140@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN141@xmlParseCh
	test	dl, dl
	je	SHORT $LN142@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN141@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL140@xmlParseCh
$LN142@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN143@xmlParseCh
$LN141@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN143@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN31@xmlParseCh
	mov	eax, 18					; 00000012H
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlParseCh:

; 1211 : 
; 1212 :     if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);

	mov	ecx, OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@
	lea	eax, DWORD PTR _upper$[ebp]
	npad	2
$LL144@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN145@xmlParseCh
	test	dl, dl
	je	SHORT $LN146@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN145@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL144@xmlParseCh
$LN146@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN147@xmlParseCh
$LN145@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN147@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN32@xmlParseCh
	mov	eax, 19					; 00000013H
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlParseCh:

; 1213 :     if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);

	mov	ecx, OFFSET ??_C@_09NDNIACC@SHIFT_JIS@
	lea	eax, DWORD PTR _upper$[ebp]
	npad	2
$LL148@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN149@xmlParseCh
	test	dl, dl
	je	SHORT $LN150@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN149@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL148@xmlParseCh
$LN150@xmlParseCh:
	xor	eax, eax
	jmp	SHORT $LN151@xmlParseCh
$LN149@xmlParseCh:
	sbb	eax, eax
	or	eax, 1
$LN151@xmlParseCh:
	test	eax, eax
	jne	SHORT $LN33@xmlParseCh
	mov	eax, 20					; 00000014H
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlParseCh:

; 1214 :     if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);

	mov	ecx, OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	lea	eax, DWORD PTR _upper$[ebp]
	npad	2
$LL152@xmlParseCh:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN153@xmlParseCh
	test	dl, dl
	je	SHORT $LN154@xmlParseCh
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN153@xmlParseCh
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL152@xmlParseCh
$LN154@xmlParseCh:
	xor	ecx, ecx
	or	eax, -1
	test	ecx, ecx
	mov	edx, 21					; 00000015H
	pop	edi
	cmove	eax, edx

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN153@xmlParseCh:

; 1214 :     if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);

	sbb	ecx, ecx
	mov	edx, 21					; 00000015H
	or	ecx, 1
	or	eax, -1
	test	ecx, ecx
	pop	edi
	cmove	eax, edx

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlParseCh:

; 1202 :     if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);

	mov	eax, 11					; 0000000bH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseCh:

; 1198 :     if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);

	mov	eax, 10					; 0000000aH
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@xmlParseCh:

; 1193 :     if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	eax, 4
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlParseCh:

; 1185 :     if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);

	mov	eax, 9
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@xmlParseCh:

; 1181 :     if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);

	mov	eax, 2
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlParseCh:

; 1174 :     if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);

	mov	eax, 1
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@xmlParseCh:

; 1171 : 
; 1172 :     if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);

	xor	eax, eax
	pop	edi

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);
; 1220 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCleanupEncodingAliases
_TEXT	SEGMENT
_xmlCleanupEncodingAliases PROC				; COMDAT
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	test	eax, eax
	je	SHORT $LN1@xmlCleanup

; 993  :     int i;
; 994  : 
; 995  :     if (xmlCharEncodingAliases == NULL)
; 996  : 	return;
; 997  : 
; 998  :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _xmlCharEncodingAliasesNb, esi
	jle	SHORT $LN3@xmlCleanup
	npad	2
$LL4@xmlCleanup:

; 999  : 	if (xmlCharEncodingAliases[i].name != NULL)

	mov	ecx, DWORD PTR [eax+esi*8]
	test	ecx, ecx
	je	SHORT $LN6@xmlCleanup

; 1000 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	add	esp, 4
$LN6@xmlCleanup:

; 1001 : 	if (xmlCharEncodingAliases[i].alias != NULL)

	mov	ecx, DWORD PTR [eax+esi*8+4]
	test	ecx, ecx
	je	SHORT $LN2@xmlCleanup

; 1002 : 	    xmlFree((char *) xmlCharEncodingAliases[i].alias);

	push	ecx
	call	DWORD PTR _xmlFree
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	add	esp, 4
$LN2@xmlCleanup:

; 993  :     int i;
; 994  : 
; 995  :     if (xmlCharEncodingAliases == NULL)
; 996  : 	return;
; 997  : 
; 998  :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	inc	esi
	cmp	esi, DWORD PTR _xmlCharEncodingAliasesNb
	jl	SHORT $LL4@xmlCleanup
$LN3@xmlCleanup:

; 1003 :     }
; 1004 :     xmlCharEncodingAliasesNb = 0;
; 1005 :     xmlCharEncodingAliasesMax = 0;
; 1006 :     xmlFree(xmlCharEncodingAliases);

	push	eax
	mov	DWORD PTR _xmlCharEncodingAliasesNb, 0
	mov	DWORD PTR _xmlCharEncodingAliasesMax, 0
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1007 :     xmlCharEncodingAliases = NULL;

	mov	DWORD PTR _xmlCharEncodingAliases, 0
	pop	esi
$LN1@xmlCleanup:

; 1008 : }

	ret	0
_xmlCleanupEncodingAliases ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetEncodingAlias
_TEXT	SEGMENT
_upper$ = -100						; size = 100
_alias$ = 8						; size = 4
_xmlGetEncodingAlias PROC				; COMDAT

; 1019 : xmlGetEncodingAlias(const char *alias) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _alias$[ebp]
	call	@__CheckForDebuggerJustMyCode@4
	test	edi, edi
	je	SHORT $LN6@xmlGetEnco

; 1020 :     int i;
; 1021 :     char upper[100];
; 1022 : 
; 1023 :     if (alias == NULL)
; 1024 : 	return(NULL);
; 1025 : 
; 1026 :     if (xmlCharEncodingAliases == NULL)

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	je	SHORT $LN6@xmlGetEnco

; 1027 : 	return(NULL);
; 1028 : 
; 1029 :     for (i = 0;i < 99;i++) {

	mov	ebx, DWORD PTR __imp__toupper
	xor	esi, esi
	npad	5
$LL4@xmlGetEnco:

; 1030 :         upper[i] = toupper(alias[i]);

	movsx	eax, BYTE PTR [edi+esi]
	push	eax
	call	ebx
	add	esp, 4
	mov	BYTE PTR _upper$[ebp+esi], al

; 1031 : 	if (upper[i] == 0) break;

	test	al, al
	je	SHORT $LN15@xmlGetEnco

; 1027 : 	return(NULL);
; 1028 : 
; 1029 :     for (i = 0;i < 99;i++) {

	inc	esi
	cmp	esi, 99					; 00000063H
	jl	SHORT $LL4@xmlGetEnco
$LN15@xmlGetEnco:

; 1034 : 
; 1035 :     /*
; 1036 :      * Walk down the list looking for a definition of the alias
; 1037 :      */
; 1038 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	ebx, DWORD PTR _xmlCharEncodingAliasesNb
	mov	BYTE PTR _upper$[ebp+esi], 0
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN6@xmlGetEnco

; 1032 :     }
; 1033 :     upper[i] = 0;

	mov	edi, DWORD PTR _xmlCharEncodingAliases
	add	edi, 4
$LL7@xmlGetEnco:

; 1039 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR _upper$[ebp]
$LL23@xmlGetEnco:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN24@xmlGetEnco
	test	dl, dl
	je	SHORT $LN25@xmlGetEnco
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN24@xmlGetEnco
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL23@xmlGetEnco
$LN25@xmlGetEnco:
	xor	eax, eax
	jmp	SHORT $LN26@xmlGetEnco
$LN24@xmlGetEnco:
	sbb	eax, eax
	or	eax, 1
$LN26@xmlGetEnco:
	test	eax, eax
	je	SHORT $LN16@xmlGetEnco

; 1034 : 
; 1035 :     /*
; 1036 :      * Walk down the list looking for a definition of the alias
; 1037 :      */
; 1038 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	inc	esi
	add	edi, 8
	cmp	esi, ebx
	jl	SHORT $LL7@xmlGetEnco
$LN6@xmlGetEnco:
	pop	edi

; 1041 : 	}
; 1042 :     }
; 1043 :     return(NULL);
; 1044 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlGetEnco:

; 1040 : 	    return(xmlCharEncodingAliases[i].name);

	mov	eax, DWORD PTR _xmlCharEncodingAliases
	pop	edi
	mov	eax, DWORD PTR [eax+esi*8]

; 1041 : 	}
; 1042 :     }
; 1043 :     return(NULL);
; 1044 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlDelEncodingAlias
_TEXT	SEGMENT
_alias$ = 8						; size = 4
_xmlDelEncodingAlias PROC				; COMDAT

; 1114 : xmlDelEncodingAlias(const char *alias) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _alias$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlDelEnco

; 1115 :     int i;
; 1116 : 
; 1117 :     if (alias == NULL)
; 1118 : 	return(-1);
; 1119 : 
; 1120 :     if (xmlCharEncodingAliases == NULL)

	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	test	ecx, ecx
	je	SHORT $LN3@xmlDelEnco

; 1121 : 	return(-1);
; 1122 :     /*
; 1123 :      * Walk down the list looking for a definition of the alias
; 1124 :      */
; 1125 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	ebx, DWORD PTR _xmlCharEncodingAliasesNb
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN3@xmlDelEnco
	lea	edi, DWORD PTR [ecx+4]
$LL4@xmlDelEnco:

; 1126 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {

	mov	ecx, DWORD PTR [edi]
$LL14@xmlDelEnco:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN15@xmlDelEnco
	test	dl, dl
	je	SHORT $LN16@xmlDelEnco
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN15@xmlDelEnco
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL14@xmlDelEnco
$LN16@xmlDelEnco:
	xor	eax, eax
	jmp	SHORT $LN17@xmlDelEnco
$LN15@xmlDelEnco:
	sbb	eax, eax
	or	eax, 1
$LN17@xmlDelEnco:
	test	eax, eax
	je	SHORT $LN10@xmlDelEnco

; 1121 : 	return(-1);
; 1122 :     /*
; 1123 :      * Walk down the list looking for a definition of the alias
; 1124 :      */
; 1125 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	eax, DWORD PTR _alias$[ebp]
	inc	esi
	add	edi, 8
	cmp	esi, ebx
	jl	SHORT $LL4@xmlDelEnco
$LN3@xmlDelEnco:
	pop	edi

; 1133 : 	}
; 1134 :     }
; 1135 :     return(-1);
; 1136 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN10@xmlDelEnco:

; 1127 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	mov	eax, DWORD PTR _xmlCharEncodingAliases
	push	DWORD PTR [eax+esi*8]
	call	DWORD PTR _xmlFree

; 1128 : 	    xmlFree((char *) xmlCharEncodingAliases[i].alias);

	mov	eax, DWORD PTR _xmlCharEncodingAliases
	push	DWORD PTR [eax+esi*8+4]
	call	DWORD PTR _xmlFree

; 1129 : 	    xmlCharEncodingAliasesNb--;

	mov	edx, DWORD PTR _xmlCharEncodingAliasesNb

; 1130 : 	    memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],

	mov	eax, DWORD PTR _xmlCharEncodingAliases
	dec	edx
	mov	DWORD PTR _xmlCharEncodingAliasesNb, edx
	sub	edx, esi
	shl	edx, 3
	push	edx
	lea	ecx, DWORD PTR [eax+esi*8]
	lea	eax, DWORD PTR [ecx+8]
	push	eax
	push	ecx
	call	_memmove
	add	esp, 20					; 00000014H

; 1131 : 		    sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));
; 1132 : 	    return(0);

	xor	eax, eax
	pop	edi

; 1133 : 	}
; 1134 :     }
; 1135 :     return(-1);
; 1136 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlDelEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlAddEncodingAlias
_TEXT	SEGMENT
_upper$ = -100						; size = 100
_name$ = 8						; size = 4
_alias$ = 12						; size = 4
_xmlAddEncodingAlias PROC				; COMDAT

; 1057 : xmlAddEncodingAlias(const char *name, const char *alias) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _alias$[ebp]
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN9@xmlAddEnco

; 1058 :     int i;
; 1059 :     char upper[100];
; 1060 : 
; 1061 :     if ((name == NULL) || (alias == NULL))

	test	edi, edi
	je	SHORT $LN9@xmlAddEnco

; 1062 : 	return(-1);
; 1063 : 
; 1064 :     for (i = 0;i < 99;i++) {

	mov	ebx, DWORD PTR __imp__toupper
	xor	esi, esi
$LL4@xmlAddEnco:

; 1065 :         upper[i] = toupper(alias[i]);

	movsx	eax, BYTE PTR [edi+esi]
	push	eax
	call	ebx
	add	esp, 4
	mov	BYTE PTR _upper$[ebp+esi], al

; 1066 : 	if (upper[i] == 0) break;

	test	al, al
	je	SHORT $LN19@xmlAddEnco

; 1062 : 	return(-1);
; 1063 : 
; 1064 :     for (i = 0;i < 99;i++) {

	inc	esi
	cmp	esi, 99					; 00000063H
	jl	SHORT $LL4@xmlAddEnco
$LN19@xmlAddEnco:

; 1067 :     }
; 1068 :     upper[i] = 0;
; 1069 : 
; 1070 :     if (xmlCharEncodingAliases == NULL) {

	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	mov	BYTE PTR _upper$[ebp+esi], 0
	test	ecx, ecx
	jne	SHORT $LN11@xmlAddEnco

; 1071 : 	xmlCharEncodingAliasesNb = 0;
; 1072 : 	xmlCharEncodingAliasesMax = 20;
; 1073 : 	xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)

	push	160					; 000000a0H
	mov	DWORD PTR _xmlCharEncodingAliasesNb, ecx
	mov	DWORD PTR _xmlCharEncodingAliasesMax, 20 ; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _xmlCharEncodingAliases, ecx

; 1074 : 	      xmlMalloc(xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));
; 1075 : 	if (xmlCharEncodingAliases == NULL)

	test	ecx, ecx
	jne	SHORT $LN32@xmlAddEnco
$LN9@xmlAddEnco:
	pop	edi

; 1102 :     return(0);
; 1103 : }

	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlAddEnco:

; 1076 : 	    return(-1);
; 1077 :     } else if (xmlCharEncodingAliasesNb >= xmlCharEncodingAliasesMax) {

	mov	ebx, DWORD PTR _xmlCharEncodingAliasesNb
	mov	eax, DWORD PTR _xmlCharEncodingAliasesMax
	cmp	ebx, eax
	jl	SHORT $LN14@xmlAddEnco

; 1078 : 	xmlCharEncodingAliasesMax *= 2;

	add	eax, eax
	mov	DWORD PTR _xmlCharEncodingAliasesMax, eax
	shl	eax, 3

; 1079 : 	xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)

	push	eax
	push	ecx
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _xmlCharEncodingAliases, ecx
$LN32@xmlAddEnco:

; 1080 : 	      xmlRealloc(xmlCharEncodingAliases,
; 1081 : 		         xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));
; 1082 :     }
; 1083 :     /*
; 1084 :      * Walk down the list looking for a definition of the alias
; 1085 :      */
; 1086 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	ebx, DWORD PTR _xmlCharEncodingAliasesNb
$LN14@xmlAddEnco:
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN6@xmlAddEnco
	lea	edi, DWORD PTR [ecx+4]
	npad	2
$LL7@xmlAddEnco:

; 1087 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _upper$[ebp]
$LL27@xmlAddEnco:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN28@xmlAddEnco
	test	dl, dl
	je	SHORT $LN29@xmlAddEnco
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN28@xmlAddEnco
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL27@xmlAddEnco
$LN29@xmlAddEnco:
	xor	eax, eax
	jmp	SHORT $LN30@xmlAddEnco
$LN28@xmlAddEnco:
	sbb	eax, eax
	or	eax, 1
$LN30@xmlAddEnco:
	test	eax, eax
	je	SHORT $LN20@xmlAddEnco

; 1080 : 	      xmlRealloc(xmlCharEncodingAliases,
; 1081 : 		         xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));
; 1082 :     }
; 1083 :     /*
; 1084 :      * Walk down the list looking for a definition of the alias
; 1085 :      */
; 1086 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	inc	esi
	add	edi, 8
	cmp	esi, ebx
	jl	SHORT $LL7@xmlAddEnco
$LN6@xmlAddEnco:

; 1094 : 	}
; 1095 :     }
; 1096 :     /*
; 1097 :      * Add the definition
; 1098 :      */
; 1099 :     xmlCharEncodingAliases[xmlCharEncodingAliasesNb].name = xmlMemStrdup(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	ecx, DWORD PTR _xmlCharEncodingAliasesNb
	mov	DWORD PTR [edx+ecx*8], eax

; 1100 :     xmlCharEncodingAliases[xmlCharEncodingAliasesNb].alias = xmlMemStrdup(upper);

	lea	eax, DWORD PTR _upper$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	edx, DWORD PTR _xmlCharEncodingAliasesNb
	add	esp, 8
	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	pop	edi
	mov	DWORD PTR [ecx+edx*8+4], eax

; 1101 :     xmlCharEncodingAliasesNb++;

	inc	edx

; 1102 :     return(0);
; 1103 : }

	pop	esi
	mov	DWORD PTR _xmlCharEncodingAliasesNb, edx
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlAddEnco:

; 1088 : 	    /*
; 1089 : 	     * Replace the definition.
; 1090 : 	     */
; 1091 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	mov	eax, DWORD PTR _xmlCharEncodingAliases
	push	DWORD PTR [eax+esi*8]
	call	DWORD PTR _xmlFree

; 1092 : 	    xmlCharEncodingAliases[i].name = xmlMemStrdup(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	add	esp, 8
	pop	edi
	mov	DWORD PTR [ecx+esi*8], eax

; 1093 : 	    return(0);

	xor	eax, eax

; 1102 :     return(0);
; 1103 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlNewCharEncodingHandler
_TEXT	SEGMENT
_upper$ = -500						; size = 500
_name$ = 8						; size = 4
_input$ = 12						; size = 4
_output$ = 16						; size = 4
_xmlNewCharEncodingHandler PROC				; COMDAT

; 1320 :                           xmlCharEncodingOutputFunc output) {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _name$[ebp]
	push	edi
	call	_xmlGetEncodingAlias
	add	esp, 4
	test	eax, eax
	cmovne	edi, eax
	test	edi, edi
	jne	SHORT $LN6@xmlNewChar

; 99   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,

	push	edi
	push	OFFSET ??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	push	3
	push	6000					; 00001770H
	push	27					; 0000001bH
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1321 :     xmlCharEncodingHandlerPtr handler;
; 1322 :     const char *alias;
; 1323 :     char upper[500];
; 1324 :     int i;
; 1325 :     char *up = NULL;
; 1326 : 
; 1327 :     /*
; 1328 :      * Do the alias resolution
; 1329 :      */
; 1330 :     alias = xmlGetEncodingAlias(name);
; 1331 :     if (alias != NULL)
; 1332 : 	name = alias;
; 1333 : 
; 1334 :     /*
; 1335 :      * Keep only the uppercase version of the encoding.
; 1336 :      */
; 1337 :     if (name == NULL) {
; 1338 :         xmlEncodingErr(XML_I18N_NO_NAME,
; 1339 : 		       "xmlNewCharEncodingHandler : no name !\n", NULL);
; 1340 : 	return(NULL);

	xor	eax, eax
	pop	edi

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlNewChar:
	push	ebx

; 1341 :     }
; 1342 :     for (i = 0;i < 499;i++) {

	mov	ebx, DWORD PTR __imp__toupper
	push	esi
	xor	esi, esi
	npad	3
$LL4@xmlNewChar:

; 1343 :         upper[i] = toupper(name[i]);

	movsx	eax, BYTE PTR [edi+esi]
	push	eax
	call	ebx
	add	esp, 4
	mov	BYTE PTR _upper$[ebp+esi], al

; 1344 : 	if (upper[i] == 0) break;

	test	al, al
	je	SHORT $LN18@xmlNewChar

; 1341 :     }
; 1342 :     for (i = 0;i < 499;i++) {

	inc	esi
	cmp	esi, 499				; 000001f3H
	jl	SHORT $LL4@xmlNewChar
$LN18@xmlNewChar:

; 1345 :     }
; 1346 :     upper[i] = 0;
; 1347 :     up = xmlMemStrdup(upper);

	lea	eax, DWORD PTR _upper$[ebp]
	mov	BYTE PTR _upper$[ebp+esi], 0
	push	eax
	call	DWORD PTR _xmlMemStrdup
	mov	edi, eax
	add	esp, 4

; 1348 :     if (up == NULL) {

	test	edi, edi
	jne	SHORT $LN8@xmlNewChar

; 86   :     __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
	push	eax
	push	eax
	push	2
	push	27					; 0000001bH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1349 :         xmlEncodingErrMemory("xmlNewCharEncodingHandler : out of memory !\n");
; 1350 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlNewChar:

; 1351 :     }
; 1352 : 
; 1353 :     /*
; 1354 :      * allocate and fill-up an handler block.
; 1355 :      */
; 1356 :     handler = (xmlCharEncodingHandlerPtr)

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1357 :               xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1358 :     if (handler == NULL) {

	test	esi, esi
	jne	SHORT $LN9@xmlNewChar

; 1359 :         xmlFree(up);

	push	edi
	call	DWORD PTR _xmlFree

; 86   :     __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
	push	esi
	push	esi
	push	2
	push	27					; 0000001bH
	call	___xmlSimpleError
	add	esp, 24					; 00000018H

; 1360 :         xmlEncodingErrMemory("xmlNewCharEncodingHandler : out of memory !\n");
; 1361 : 	return(NULL);

	xor	eax, eax
	pop	esi
	pop	ebx
	pop	edi

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlNewChar:

; 1362 :     }
; 1363 :     memset(handler, 0, sizeof(xmlCharEncodingHandler));
; 1364 :     handler->input = input;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [esi+4], eax

; 1365 :     handler->output = output;

	mov	eax, DWORD PTR _output$[ebp]

; 1366 :     handler->name = up;
; 1367 : 
; 1368 : #ifdef LIBXML_ICONV_ENABLED
; 1369 :     handler->iconv_in = NULL;
; 1370 :     handler->iconv_out = NULL;
; 1371 : #endif
; 1372 : #ifdef LIBXML_ICU_ENABLED
; 1373 :     handler->uconv_in = NULL;
; 1374 :     handler->uconv_out = NULL;
; 1375 : #endif
; 1376 : 
; 1377 :     /*
; 1378 :      * registers and returns the handler.
; 1379 :      */
; 1380 :     xmlRegisterCharEncodingHandler(handler);

	push	esi
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	call	_xmlRegisterCharEncodingHandler
	add	esp, 4

; 1381 : #ifdef DEBUG_ENCODING
; 1382 :     xmlGenericError(xmlGenericErrorContext,
; 1383 : 	    "Registered encoding handler for %s\n", name);
; 1384 : #endif
; 1385 :     return(handler);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlFindCharEncodingHandler
_TEXT	SEGMENT
_upper$ = -104						; size = 100
tv301 = -4						; size = 4
_icv_in$1$ = -4						; size = 4
_name$ = 8						; size = 4
_xmlFindCharEncodingHandler PROC			; COMDAT

; 1641 : xmlFindCharEncodingHandler(const char *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN8@xmlFindCha

; 1642 :     const char *nalias;
; 1643 :     const char *norig;
; 1644 :     xmlCharEncoding alias;
; 1645 : #ifdef LIBXML_ICONV_ENABLED
; 1646 :     xmlCharEncodingHandlerPtr enc;
; 1647 :     iconv_t icv_in, icv_out;
; 1648 : #endif /* LIBXML_ICONV_ENABLED */
; 1649 : #ifdef LIBXML_ICU_ENABLED
; 1650 :     xmlCharEncodingHandlerPtr encu;
; 1651 :     uconv_t *ucv_in, *ucv_out;
; 1652 : #endif /* LIBXML_ICU_ENABLED */
; 1653 :     char upper[100];
; 1654 :     int i;
; 1655 : 
; 1656 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	call	_xmlInitCharEncodingHandlers
$LN8@xmlFindCha:
	push	ebx

; 1657 :     if (name == NULL) return(xmlDefaultCharEncodingHandler);

	mov	ebx, DWORD PTR _name$[ebp]
	test	ebx, ebx
	je	$LN38@xmlFindCha

; 1658 :     if (name[0] == 0) return(xmlDefaultCharEncodingHandler);

	cmp	BYTE PTR [ebx], 0
	je	$LN38@xmlFindCha

; 1659 : 
; 1660 :     /*
; 1661 :      * Do the alias resolution
; 1662 :      */
; 1663 :     norig = name;
; 1664 :     nalias = xmlGetEncodingAlias(name);

	push	esi
	push	edi
	push	ebx
	call	_xmlGetEncodingAlias
	add	esp, 4

; 1665 :     if (nalias != NULL)

	mov	edi, ebx

; 1666 : 	name = nalias;
; 1667 : 
; 1668 :     /*
; 1669 :      * Check first for directly registered encoding names
; 1670 :      */
; 1671 :     for (i = 0;i < 99;i++) {

	mov	ebx, DWORD PTR __imp__toupper
	test	eax, eax
	cmovne	edi, eax
	xor	esi, esi
	npad	3
$LL4@xmlFindCha:

; 1672 :         upper[i] = toupper(name[i]);

	movsx	eax, BYTE PTR [edi+esi]
	push	eax
	call	ebx
	add	esp, 4
	mov	BYTE PTR _upper$[ebp+esi], al

; 1673 : 	if (upper[i] == 0) break;

	test	al, al
	je	SHORT $LN29@xmlFindCha

; 1666 : 	name = nalias;
; 1667 : 
; 1668 :     /*
; 1669 :      * Check first for directly registered encoding names
; 1670 :      */
; 1671 :     for (i = 0;i < 99;i++) {

	inc	esi
	cmp	esi, 99					; 00000063H
	jl	SHORT $LL4@xmlFindCha
$LN29@xmlFindCha:

; 1674 :     }
; 1675 :     upper[i] = 0;
; 1676 : 
; 1677 :     if (handlers != NULL) {

	mov	eax, DWORD PTR _handlers
	mov	BYTE PTR _upper$[ebp+esi], 0
	test	eax, eax
	je	SHORT $LN6@xmlFindCha

; 1678 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	mov	ebx, DWORD PTR _nbCharEncodingHandler
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN6@xmlFindCha
$LL7@xmlFindCha:

; 1679 :             if (!strcmp(upper, handlers[i]->name)) {

	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR tv301[ebp], eax
	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR _upper$[ebp]
	npad	3
$LL39@xmlFindCha:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN40@xmlFindCha
	test	dl, dl
	je	SHORT $LN41@xmlFindCha
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN40@xmlFindCha
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL39@xmlFindCha
$LN41@xmlFindCha:
	xor	eax, eax
	jmp	SHORT $LN42@xmlFindCha
$LN40@xmlFindCha:
	sbb	eax, eax
	or	eax, 1
$LN42@xmlFindCha:
	test	eax, eax
	je	$LN30@xmlFindCha

; 1678 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	mov	eax, DWORD PTR _handlers
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL7@xmlFindCha
$LN6@xmlFindCha:

; 1685 :             }
; 1686 :         }
; 1687 :     }
; 1688 : 
; 1689 : #ifdef LIBXML_ICONV_ENABLED
; 1690 :     /* check whether iconv can handle this */
; 1691 :     icv_in = iconv_open("UTF-8", name);

	mov	ebx, DWORD PTR __imp__libiconv_open
	push	edi
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	ebx
	mov	esi, eax

; 1692 :     icv_out = iconv_open(name, "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	edi
	mov	DWORD PTR _icv_in$1$[ebp], esi
	call	ebx
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 1693 :     if (icv_in == (iconv_t) -1) {

	cmp	esi, -1
	jne	SHORT $LN15@xmlFindCha

; 1694 :         icv_in = iconv_open("UTF-8", upper);

	lea	eax, DWORD PTR _upper$[ebp]
	push	eax
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	mov	DWORD PTR _icv_in$1$[ebp], eax
	mov	esi, eax
$LN15@xmlFindCha:

; 1695 :     }
; 1696 :     if (icv_out == (iconv_t) -1) {

	cmp	ebx, -1
	jne	SHORT $LN16@xmlFindCha

; 1697 : 	icv_out = iconv_open(upper, "UTF-8");

	lea	eax, DWORD PTR _upper$[ebp]
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	eax
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	mov	ebx, eax
$LN16@xmlFindCha:

; 1698 :     }
; 1699 :     if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {

	cmp	esi, -1
	je	SHORT $LN37@xmlFindCha
	cmp	ebx, -1
	je	SHORT $LN21@xmlFindCha

; 1700 : 	    enc = (xmlCharEncodingHandlerPtr)

	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4

; 1701 : 	          xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1702 : 	    if (enc == NULL) {

	test	esi, esi
	jne	SHORT $LN19@xmlFindCha

; 1703 : 	        iconv_close(icv_in);

	mov	eax, DWORD PTR _icv_in$1$[ebp]
	mov	esi, DWORD PTR __imp__libiconv_close
	push	eax
	call	esi

; 1704 : 	        iconv_close(icv_out);

	push	ebx
	call	esi
	add	esp, 8
$LN23@xmlFindCha:

; 1705 : 		return(NULL);

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);
; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlFindCha:

; 1680 : #ifdef DEBUG_ENCODING
; 1681 :                 xmlGenericError(xmlGenericErrorContext,
; 1682 :                         "Found registered handler for encoding %s\n", name);
; 1683 : #endif
; 1684 :                 return(handlers[i]);

	mov	eax, DWORD PTR tv301[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);
; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlFindCha:
	xorps	xmm0, xmm0

; 1706 : 	    }
; 1707 :             memset(enc, 0, sizeof(xmlCharEncodingHandler));

	movups	XMMWORD PTR [esi], xmm0

; 1708 : 	    enc->name = xmlMemStrdup(name);

	push	edi
	mov	DWORD PTR [esi+16], 0
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 1709 : 	    enc->input = NULL;
; 1710 : 	    enc->output = NULL;
; 1711 : 	    enc->iconv_in = icv_in;

	mov	eax, DWORD PTR _icv_in$1$[ebp]
	mov	DWORD PTR [esi+12], eax

; 1712 : 	    enc->iconv_out = icv_out;
; 1713 : #ifdef DEBUG_ENCODING
; 1714 :             xmlGenericError(xmlGenericErrorContext,
; 1715 : 		    "Found iconv handler for encoding %s\n", name);
; 1716 : #endif
; 1717 : 	    return enc;

	mov	eax, esi
	mov	DWORD PTR [esi+16], ebx
	pop	edi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	pop	esi
	pop	ebx

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);
; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlFindCha:

; 1718 :     } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {

	cmp	ebx, -1
	je	SHORT $LN25@xmlFindCha
$LN21@xmlFindCha:

; 99   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,

	push	edi
	push	OFFSET ??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@
	push	0
	push	0
	push	0
	push	0
	push	edi
	push	0
	push	0
	push	3
	push	1
	push	27					; 0000001bH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN25@xmlFindCha:

; 1719 : 	    xmlEncodingErr(XML_ERR_INTERNAL_ERROR,
; 1720 : 		    "iconv : problems with filters for '%s'\n", name);
; 1721 :     }
; 1722 : #endif /* LIBXML_ICONV_ENABLED */
; 1723 : #ifdef LIBXML_ICU_ENABLED
; 1724 :     /* check whether icu can handle this */
; 1725 :     ucv_in = openIcuConverter(name, 1);
; 1726 :     ucv_out = openIcuConverter(name, 0);
; 1727 :     if (ucv_in != NULL && ucv_out != NULL) {
; 1728 : 	    encu = (xmlCharEncodingHandlerPtr)
; 1729 : 	           xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1730 : 	    if (encu == NULL) {
; 1731 :                 closeIcuConverter(ucv_in);
; 1732 :                 closeIcuConverter(ucv_out);
; 1733 : 		return(NULL);
; 1734 : 	    }
; 1735 :             memset(encu, 0, sizeof(xmlCharEncodingHandler));
; 1736 : 	    encu->name = xmlMemStrdup(name);
; 1737 : 	    encu->input = NULL;
; 1738 : 	    encu->output = NULL;
; 1739 : 	    encu->uconv_in = ucv_in;
; 1740 : 	    encu->uconv_out = ucv_out;
; 1741 : #ifdef DEBUG_ENCODING
; 1742 :             xmlGenericError(xmlGenericErrorContext,
; 1743 : 		    "Found ICU converter handler for encoding %s\n", name);
; 1744 : #endif
; 1745 : 	    return encu;
; 1746 :     } else if (ucv_in != NULL || ucv_out != NULL) {
; 1747 :             closeIcuConverter(ucv_in);
; 1748 :             closeIcuConverter(ucv_out);
; 1749 : 	    xmlEncodingErr(XML_ERR_INTERNAL_ERROR,
; 1750 : 		    "ICU converter : problems with filters for '%s'\n", name);
; 1751 :     }
; 1752 : #endif /* LIBXML_ICU_ENABLED */
; 1753 : 
; 1754 : #ifdef DEBUG_ENCODING
; 1755 :     xmlGenericError(xmlGenericErrorContext,
; 1756 : 	    "No handler found for encoding %s\n", name);
; 1757 : #endif
; 1758 : 
; 1759 :     /*
; 1760 :      * Fallback using the canonical names
; 1761 :      */
; 1762 :     alias = xmlParseCharEncoding(norig);

	push	DWORD PTR _name$[ebp]
	call	_xmlParseCharEncoding
	add	esp, 4

; 1763 :     if (alias != XML_CHAR_ENCODING_ERROR) {

	cmp	eax, -1
	je	$LN23@xmlFindCha

; 1764 :         const char* canon;
; 1765 :         canon = xmlGetCharEncodingName(alias);

	push	eax
	call	_xmlGetCharEncodingName
	mov	edx, eax
	add	esp, 4

; 1766 :         if ((canon != NULL) && (strcmp(name, canon))) {

	test	edx, edx
	je	$LN23@xmlFindCha
	mov	ecx, edx
	npad	2
$LL43@xmlFindCha:
	mov	al, BYTE PTR [edi]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN44@xmlFindCha
	test	al, al
	je	SHORT $LN45@xmlFindCha
	mov	al, BYTE PTR [edi+1]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN44@xmlFindCha
	add	edi, 2
	add	ecx, 2
	test	al, al
	jne	SHORT $LL43@xmlFindCha
$LN45@xmlFindCha:
	xor	eax, eax
	jmp	SHORT $LN46@xmlFindCha
$LN44@xmlFindCha:
	sbb	eax, eax
	or	eax, 1
$LN46@xmlFindCha:
	test	eax, eax
	je	$LN23@xmlFindCha

; 1767 : 	    return(xmlFindCharEncodingHandler(canon));

	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);
; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@xmlFindCha:

; 1658 :     if (name[0] == 0) return(xmlDefaultCharEncodingHandler);

	mov	eax, DWORD PTR _xmlDefaultCharEncodingHandler
	pop	ebx

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);
; 1773 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFindCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetCharEncodingHandler
_TEXT	SEGMENT
_enc$ = 8						; size = 4
_xmlGetCharEncodingHandler PROC				; COMDAT

; 1507 : xmlGetCharEncodingHandler(xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN4@xmlGetChar

; 1508 :     xmlCharEncodingHandlerPtr handler;
; 1509 : 
; 1510 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	call	_xmlInitCharEncodingHandlers
$LN4@xmlGetChar:

; 1511 :     switch (enc) {

	mov	eax, DWORD PTR _enc$[ebp]
	inc	eax
	cmp	eax, 22					; 00000016H
	ja	$LN54@xmlGetChar
	jmp	DWORD PTR $LN59@xmlGetChar[eax*4]
$LN8@xmlGetChar:

; 1512 :         case XML_CHAR_ENCODING_ERROR:
; 1513 : 	    return(NULL);
; 1514 :         case XML_CHAR_ENCODING_NONE:
; 1515 : 	    return(NULL);
; 1516 :         case XML_CHAR_ENCODING_UTF8:
; 1517 : 	    return(NULL);
; 1518 :         case XML_CHAR_ENCODING_UTF16LE:
; 1519 : 	    return(xmlUTF16LEHandler);

	mov	eax, DWORD PTR _xmlUTF16LEHandler

; 1630 : }

	pop	ebp
	ret	0
$LN9@xmlGetChar:

; 1520 :         case XML_CHAR_ENCODING_UTF16BE:
; 1521 : 	    return(xmlUTF16BEHandler);

	mov	eax, DWORD PTR _xmlUTF16BEHandler

; 1630 : }

	pop	ebp
	ret	0
$LN10@xmlGetChar:

; 1522 :         case XML_CHAR_ENCODING_EBCDIC:
; 1523 :             handler = xmlFindCharEncodingHandler("EBCDIC");

	push	OFFSET ??_C@_06JJAKJGEC@EBCDIC@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1524 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	$LN1@xmlGetChar

; 1525 :             handler = xmlFindCharEncodingHandler("ebcdic");

	push	OFFSET ??_C@_06JNCBEIJA@ebcdic@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1526 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	$LN1@xmlGetChar

; 1527 :             handler = xmlFindCharEncodingHandler("EBCDIC-US");

	push	OFFSET ??_C@_09BNGJAIJK@EBCDIC?9US@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1528 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	$LN1@xmlGetChar

; 1529 :             handler = xmlFindCharEncodingHandler("IBM-037");

	push	OFFSET ??_C@_07LDANGMFL@IBM?9037@
$LN57@xmlGetChar:

; 1630 : }

	call	_xmlFindCharEncodingHandler
	add	esp, 4
	test	eax, eax
	je	$LN54@xmlGetChar
	pop	ebp
	ret	0
$LN15@xmlGetChar:
	push	OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	test	eax, eax
	jne	$LN1@xmlGetChar
	push	OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	test	eax, eax
	jne	$LN1@xmlGetChar
	push	OFFSET ??_C@_04JFFPNMJE@UCS4@
	jmp	SHORT $LN57@xmlGetChar
$LN25@xmlGetChar:

; 1530 :             if (handler != NULL) return(handler);
; 1531 : 	    break;
; 1532 :         case XML_CHAR_ENCODING_UCS4BE:
; 1533 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
; 1534 :             if (handler != NULL) return(handler);
; 1535 :             handler = xmlFindCharEncodingHandler("UCS-4");
; 1536 :             if (handler != NULL) return(handler);
; 1537 :             handler = xmlFindCharEncodingHandler("UCS4");
; 1538 :             if (handler != NULL) return(handler);
; 1539 : 	    break;
; 1540 :         case XML_CHAR_ENCODING_UCS4LE:
; 1541 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
; 1542 :             if (handler != NULL) return(handler);
; 1543 :             handler = xmlFindCharEncodingHandler("UCS-4");
; 1544 :             if (handler != NULL) return(handler);
; 1545 :             handler = xmlFindCharEncodingHandler("UCS4");
; 1546 :             if (handler != NULL) return(handler);
; 1547 : 	    break;
; 1548 :         case XML_CHAR_ENCODING_UCS4_2143:
; 1549 : 	    break;
; 1550 :         case XML_CHAR_ENCODING_UCS4_3412:
; 1551 : 	    break;
; 1552 :         case XML_CHAR_ENCODING_UCS2:
; 1553 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");

	push	OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1554 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	$LN1@xmlGetChar

; 1555 :             handler = xmlFindCharEncodingHandler("UCS-2");

	push	OFFSET ??_C@_05JHAMEAP@UCS?92@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1556 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	$LN1@xmlGetChar

; 1557 :             handler = xmlFindCharEncodingHandler("UCS2");

	push	OFFSET ??_C@_04MDAFHLBC@UCS2@

; 1558 :             if (handler != NULL) return(handler);

	jmp	SHORT $LN57@xmlGetChar
$LN29@xmlGetChar:

; 1559 : 	    break;
; 1560 : 
; 1561 : 	    /*
; 1562 : 	     * We used to keep ISO Latin encodings native in the
; 1563 : 	     * generated data. This led to so many problems that
; 1564 : 	     * this has been removed. One can still change this
; 1565 : 	     * back by registering no-ops encoders for those
; 1566 : 	     */
; 1567 :         case XML_CHAR_ENCODING_8859_1:
; 1568 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@

; 1569 : 	    if (handler != NULL) return(handler);

	jmp	SHORT $LN57@xmlGetChar
$LN31@xmlGetChar:

; 1570 : 	    break;
; 1571 :         case XML_CHAR_ENCODING_8859_2:
; 1572 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-2");

	push	OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@

; 1573 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN33@xmlGetChar:

; 1574 : 	    break;
; 1575 :         case XML_CHAR_ENCODING_8859_3:
; 1576 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-3");

	push	OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@

; 1577 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN35@xmlGetChar:

; 1578 : 	    break;
; 1579 :         case XML_CHAR_ENCODING_8859_4:
; 1580 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-4");

	push	OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@

; 1581 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN37@xmlGetChar:

; 1582 : 	    break;
; 1583 :         case XML_CHAR_ENCODING_8859_5:
; 1584 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-5");

	push	OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@

; 1585 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN39@xmlGetChar:

; 1586 : 	    break;
; 1587 :         case XML_CHAR_ENCODING_8859_6:
; 1588 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-6");

	push	OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@

; 1589 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN41@xmlGetChar:

; 1590 : 	    break;
; 1591 :         case XML_CHAR_ENCODING_8859_7:
; 1592 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-7");

	push	OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@

; 1593 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN43@xmlGetChar:

; 1594 : 	    break;
; 1595 :         case XML_CHAR_ENCODING_8859_8:
; 1596 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-8");

	push	OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@

; 1597 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN45@xmlGetChar:

; 1598 : 	    break;
; 1599 :         case XML_CHAR_ENCODING_8859_9:
; 1600 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-9");

	push	OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@

; 1601 : 	    if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN47@xmlGetChar:

; 1602 : 	    break;
; 1603 : 
; 1604 : 
; 1605 :         case XML_CHAR_ENCODING_2022_JP:
; 1606 :             handler = xmlFindCharEncodingHandler("ISO-2022-JP");

	push	OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@

; 1607 :             if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN49@xmlGetChar:

; 1608 : 	    break;
; 1609 :         case XML_CHAR_ENCODING_SHIFT_JIS:
; 1610 :             handler = xmlFindCharEncodingHandler("SHIFT-JIS");

	push	OFFSET ??_C@_09IOCPDDIN@SHIFT?9JIS@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1611 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	SHORT $LN1@xmlGetChar

; 1612 :             handler = xmlFindCharEncodingHandler("SHIFT_JIS");

	push	OFFSET ??_C@_09NDNIACC@SHIFT_JIS@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1613 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	SHORT $LN1@xmlGetChar

; 1614 :             handler = xmlFindCharEncodingHandler("Shift_JIS");

	push	OFFSET ??_C@_09LOKLFMHN@Shift_JIS@

; 1615 :             if (handler != NULL) return(handler);

	jmp	$LN57@xmlGetChar
$LN53@xmlGetChar:

; 1616 : 	    break;
; 1617 :         case XML_CHAR_ENCODING_EUC_JP:
; 1618 :             handler = xmlFindCharEncodingHandler("EUC-JP");

	push	OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	call	_xmlFindCharEncodingHandler
	add	esp, 4

; 1619 :             if (handler != NULL) return(handler);

	test	eax, eax
	jne	SHORT $LN1@xmlGetChar
$LN54@xmlGetChar:

; 1620 : 	    break;
; 1621 : 	default:
; 1622 : 	    break;
; 1623 :     }
; 1624 : 
; 1625 : #ifdef DEBUG_ENCODING
; 1626 :     xmlGenericError(xmlGenericErrorContext,
; 1627 : 	    "No handler found for encoding %d\n", enc);
; 1628 : #endif
; 1629 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetChar:

; 1630 : }

	pop	ebp
	ret	0
	npad	1
$LN59@xmlGetChar:
	DD	$LN54@xmlGetChar
	DD	$LN54@xmlGetChar
	DD	$LN54@xmlGetChar
	DD	$LN8@xmlGetChar
	DD	$LN9@xmlGetChar
	DD	$LN15@xmlGetChar
	DD	$LN15@xmlGetChar
	DD	$LN10@xmlGetChar
	DD	$LN54@xmlGetChar
	DD	$LN54@xmlGetChar
	DD	$LN25@xmlGetChar
	DD	$LN29@xmlGetChar
	DD	$LN31@xmlGetChar
	DD	$LN33@xmlGetChar
	DD	$LN35@xmlGetChar
	DD	$LN37@xmlGetChar
	DD	$LN39@xmlGetChar
	DD	$LN41@xmlGetChar
	DD	$LN43@xmlGetChar
	DD	$LN45@xmlGetChar
	DD	$LN47@xmlGetChar
	DD	$LN49@xmlGetChar
	DD	$LN53@xmlGetChar
_xmlGetCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlRegisterCharEncodingHandler
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_xmlRegisterCharEncodingHandler PROC			; COMDAT

; 1481 : xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _handlers
	test	eax, eax
	jne	SHORT $LN2@xmlRegiste

; 1482 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	call	_xmlInitCharEncodingHandlers
	mov	eax, DWORD PTR _handlers
$LN2@xmlRegiste:

; 1483 :     if ((handler == NULL) || (handlers == NULL)) {

	mov	edx, DWORD PTR _handler$[ebp]
	test	edx, edx
	je	SHORT $LN4@xmlRegiste
	test	eax, eax
	je	SHORT $LN4@xmlRegiste

; 1484 :         xmlEncodingErr(XML_I18N_NO_HANDLER,
; 1485 : 		"xmlRegisterCharEncodingHandler: NULL handler !\n", NULL);
; 1486 : 	return;
; 1487 :     }
; 1488 : 
; 1489 :     if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS) {

	mov	ecx, DWORD PTR _nbCharEncodingHandler
	cmp	ecx, 50					; 00000032H
	jl	SHORT $LN5@xmlRegiste

; 1490 :         xmlEncodingErr(XML_I18N_EXCESS_HANDLER,

	push	OFFSET ??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@
	push	OFFSET ??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@
	push	6002					; 00001772H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 1496 : }

	pop	ebp
	ret	0
$LN5@xmlRegiste:

; 1491 : 	"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n",
; 1492 : 	               "MAX_ENCODING_HANDLERS");
; 1493 : 	return;
; 1494 :     }
; 1495 :     handlers[nbCharEncodingHandler++] = handler;

	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	mov	DWORD PTR _nbCharEncodingHandler, ecx

; 1496 : }

	pop	ebp
	ret	0
$LN4@xmlRegiste:

; 99   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,

	push	0
	push	OFFSET ??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	6001					; 00001771H
	push	27					; 0000001bH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 1496 : }

	pop	ebp
	ret	0
_xmlRegisterCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCleanupCharEncodingHandlers
_TEXT	SEGMENT
_xmlCleanupCharEncodingHandlers PROC			; COMDAT
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlCleanupEncodingAliases
	mov	ecx, DWORD PTR _handlers
	test	ecx, ecx
	je	SHORT $LN1@xmlCleanup

; 1456 :     xmlCleanupEncodingAliases();
; 1457 : 
; 1458 :     if (handlers == NULL) return;
; 1459 : 
; 1460 :     for (;nbCharEncodingHandler > 0;) {

	mov	eax, DWORD PTR _nbCharEncodingHandler
	test	eax, eax
	jle	SHORT $LN3@xmlCleanup
$LL2@xmlCleanup:

; 1461 :         nbCharEncodingHandler--;
; 1462 : 	if (handlers[nbCharEncodingHandler] != NULL) {

	mov	edx, DWORD PTR [ecx+eax*4-4]
	dec	eax
	mov	DWORD PTR _nbCharEncodingHandler, eax
	test	edx, edx
	je	SHORT $LN6@xmlCleanup

; 1463 : 	    if (handlers[nbCharEncodingHandler]->name != NULL)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN7@xmlCleanup

; 1464 : 		xmlFree(handlers[nbCharEncodingHandler]->name);

	push	edx
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _handlers
	add	esp, 4
	mov	eax, DWORD PTR _nbCharEncodingHandler
$LN7@xmlCleanup:

; 1465 : 	    xmlFree(handlers[nbCharEncodingHandler]);

	push	DWORD PTR [ecx+eax*4]
	call	DWORD PTR _xmlFree
	mov	ecx, DWORD PTR _handlers
	add	esp, 4
	mov	eax, DWORD PTR _nbCharEncodingHandler
$LN6@xmlCleanup:

; 1456 :     xmlCleanupEncodingAliases();
; 1457 : 
; 1458 :     if (handlers == NULL) return;
; 1459 : 
; 1460 :     for (;nbCharEncodingHandler > 0;) {

	test	eax, eax
	jg	SHORT $LL2@xmlCleanup
$LN3@xmlCleanup:

; 1466 : 	}
; 1467 :     }
; 1468 :     xmlFree(handlers);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1469 :     handlers = NULL;

	mov	DWORD PTR _handlers, 0

; 1470 :     nbCharEncodingHandler = 0;

	mov	DWORD PTR _nbCharEncodingHandler, 0

; 1471 :     xmlDefaultCharEncodingHandler = NULL;

	mov	DWORD PTR _xmlDefaultCharEncodingHandler, 0
$LN1@xmlCleanup:

; 1472 : }

	ret	0
_xmlCleanupCharEncodingHandlers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlInitCharEncodingHandlers
_TEXT	SEGMENT
_xmlInitCharEncodingHandlers PROC			; COMDAT
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _handlers, 0
	jne	$LN1@xmlInitCha

; 1398 :     unsigned short int tst = 0x1234;
; 1399 :     unsigned char *ptr = (unsigned char *) &tst;
; 1400 : 
; 1401 :     if (handlers != NULL) return;
; 1402 : 
; 1403 :     handlers = (xmlCharEncodingHandlerPtr *)

	push	200					; 000000c8H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _handlers, eax

; 1404 :         xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(xmlCharEncodingHandlerPtr));
; 1405 : 
; 1406 :     if (*ptr == 0x12) xmlLittleEndian = 0;
; 1407 :     else if (*ptr == 0x34) xmlLittleEndian = 1;

	mov	DWORD PTR _xmlLittleEndian, 1

; 1408 :     else {
; 1409 :         xmlEncodingErr(XML_ERR_INTERNAL_ERROR,
; 1410 : 	               "Odd problem at endianness detection\n", NULL);
; 1411 :     }
; 1412 : 
; 1413 :     if (handlers == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlInitCha

; 86   :     __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@
	push	eax
	push	eax
	push	2
	push	27					; 0000001bH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 1429 : #endif
; 1430 : #else
; 1431 :     xmlUTF16LEHandler =
; 1432 :           xmlNewCharEncodingHandler("UTF-16LE", UTF16LEToUTF8, NULL);
; 1433 :     xmlUTF16BEHandler =
; 1434 :           xmlNewCharEncodingHandler("UTF-16BE", UTF16BEToUTF8, NULL);
; 1435 :     xmlNewCharEncodingHandler("UTF-16", UTF16LEToUTF8, NULL);
; 1436 :     xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, NULL);
; 1437 :     xmlNewCharEncodingHandler("ASCII", asciiToUTF8, NULL);
; 1438 :     xmlNewCharEncodingHandler("US-ASCII", asciiToUTF8, NULL);
; 1439 : #endif /* LIBXML_OUTPUT_ENABLED */
; 1440 : #if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)
; 1441 : #ifdef LIBXML_ISO8859X_ENABLED
; 1442 :     xmlRegisterCharEncodingHandlersISO8859x ();
; 1443 : #endif
; 1444 : #endif
; 1445 : 
; 1446 : }

	ret	0
$LN7@xmlInitCha:

; 1414 :         xmlEncodingErrMemory("xmlInitCharEncodingHandlers : out of memory !\n");
; 1415 : 	return;
; 1416 :     }
; 1417 :     xmlNewCharEncodingHandler("UTF-8", UTF8ToUTF8, UTF8ToUTF8);

	push	OFFSET _UTF8ToUTF8
	push	OFFSET _UTF8ToUTF8
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	_xmlNewCharEncodingHandler

; 1418 : #ifdef LIBXML_OUTPUT_ENABLED
; 1419 :     xmlUTF16LEHandler =

	push	OFFSET _UTF8ToUTF16LE
	push	OFFSET _UTF16LEToUTF8
	push	OFFSET ??_C@_08NBDJLNFA@UTF?916LE@
	call	_xmlNewCharEncodingHandler

; 1420 :           xmlNewCharEncodingHandler("UTF-16LE", UTF16LEToUTF8, UTF8ToUTF16LE);
; 1421 :     xmlUTF16BEHandler =

	push	OFFSET _UTF8ToUTF16BE
	push	OFFSET _UTF16BEToUTF8
	push	OFFSET ??_C@_08NLKHJAFK@UTF?916BE@
	mov	DWORD PTR _xmlUTF16LEHandler, eax
	call	_xmlNewCharEncodingHandler

; 1422 :           xmlNewCharEncodingHandler("UTF-16BE", UTF16BEToUTF8, UTF8ToUTF16BE);
; 1423 :     xmlNewCharEncodingHandler("UTF-16", UTF16LEToUTF8, UTF8ToUTF16);

	push	OFFSET _UTF8ToUTF16
	push	OFFSET _UTF16LEToUTF8
	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	mov	DWORD PTR _xmlUTF16BEHandler, eax
	call	_xmlNewCharEncodingHandler

; 1424 :     xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1);

	push	OFFSET _UTF8Toisolat1
	push	OFFSET _isolat1ToUTF8
	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlNewCharEncodingHandler

; 1425 :     xmlNewCharEncodingHandler("ASCII", asciiToUTF8, UTF8Toascii);

	push	OFFSET _UTF8Toascii
	push	OFFSET _asciiToUTF8
	push	OFFSET ??_C@_05CCNLIHFO@ASCII@
	call	_xmlNewCharEncodingHandler
	add	esp, 72					; 00000048H

; 1426 :     xmlNewCharEncodingHandler("US-ASCII", asciiToUTF8, UTF8Toascii);

	push	OFFSET _UTF8Toascii
	push	OFFSET _asciiToUTF8
	push	OFFSET ??_C@_08DIBGJKBD@US?9ASCII@
	call	_xmlNewCharEncodingHandler

; 1427 : #ifdef LIBXML_HTML_ENABLED
; 1428 :     xmlNewCharEncodingHandler("HTML", NULL, UTF8ToHtml);

	push	OFFSET _UTF8ToHtml
	push	0
	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlNewCharEncodingHandler
	add	esp, 24					; 00000018H
$LN1@xmlInitCha:

; 1429 : #endif
; 1430 : #else
; 1431 :     xmlUTF16LEHandler =
; 1432 :           xmlNewCharEncodingHandler("UTF-16LE", UTF16LEToUTF8, NULL);
; 1433 :     xmlUTF16BEHandler =
; 1434 :           xmlNewCharEncodingHandler("UTF-16BE", UTF16BEToUTF8, NULL);
; 1435 :     xmlNewCharEncodingHandler("UTF-16", UTF16LEToUTF8, NULL);
; 1436 :     xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, NULL);
; 1437 :     xmlNewCharEncodingHandler("ASCII", asciiToUTF8, NULL);
; 1438 :     xmlNewCharEncodingHandler("US-ASCII", asciiToUTF8, NULL);
; 1439 : #endif /* LIBXML_OUTPUT_ENABLED */
; 1440 : #if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)
; 1441 : #ifdef LIBXML_ISO8859X_ENABLED
; 1442 :     xmlRegisterCharEncodingHandlersISO8859x ();
; 1443 : #endif
; 1444 : #endif
; 1445 : 
; 1446 : }

	ret	0
_xmlInitCharEncodingHandlers ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlByteConsumed
_TEXT	SEGMENT
_convbuf$1 = -32008					; size = 32000
_handler$1$ = -8					; size = 4
_toconv$2 = -4						; size = 4
_written$3 = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlByteConsumed PROC					; COMDAT

; 2803 : xmlByteConsumed(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	eax, 32008				; 00007d08H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN19@xmlByteCon

; 2804 :     xmlParserInputPtr in;
; 2805 : 
; 2806 :     if (ctxt == NULL) return(-1);
; 2807 :     in = ctxt->input;
; 2808 :     if (in == NULL)  return(-1);

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	je	$LN19@xmlByteCon

; 2809 :     if ((in->buf != NULL) && (in->buf->encoder != NULL)) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@xmlByteCon
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _handler$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN7@xmlByteCon

; 2810 :         unsigned int unused = 0;
; 2811 : 	xmlCharEncodingHandler * handler = in->buf->encoder;
; 2812 :         /*
; 2813 : 	 * Encoding conversion, compute the number of unused original
; 2814 : 	 * bytes from the input not consumed and substract that from
; 2815 : 	 * the raw consumed value, this is not a cheap operation
; 2816 : 	 */
; 2817 :         if (in->end - in->cur > 0) {

	mov	eax, DWORD PTR [esi+20]
	xor	ebx, ebx
	mov	edi, DWORD PTR [esi+16]
	sub	eax, edi
	test	eax, eax
	jle	SHORT $LN3@xmlByteCon
	npad	2
$LL4@xmlByteCon:

; 2818 : 	    unsigned char convbuf[32000];
; 2819 : 	    const unsigned char *cur = (const unsigned char *)in->cur;
; 2820 : 	    int toconv = in->end - in->cur, written = 32000;
; 2821 : 
; 2822 : 	    int ret;
; 2823 : 
; 2824 :             do {
; 2825 :                 toconv = in->end - cur;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi

; 2826 :                 written = 32000;

	mov	DWORD PTR _written$3[ebp], 32000	; 00007d00H
	mov	DWORD PTR _toconv$2[ebp], eax

; 2827 :                 ret = xmlEncOutputChunk(handler, &convbuf[0], &written,

	lea	eax, DWORD PTR _toconv$2[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR _written$3[ebp]
	push	eax
	lea	eax, DWORD PTR _convbuf$1[ebp]
	push	eax
	push	ecx
	call	_xmlEncOutputChunk

; 2828 :                                         cur, &toconv);
; 2829 :                 if (ret < 0) {

	mov	ecx, DWORD PTR _written$3[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	jns	SHORT $LN11@xmlByteCon

; 2830 :                     if (written > 0)

	test	ecx, ecx
	jle	SHORT $LN19@xmlByteCon

; 2831 :                         ret = -2;

	mov	eax, -2					; fffffffeH
$LN11@xmlByteCon:

; 2832 :                     else
; 2833 :                         return(-1);
; 2834 :                 }
; 2835 :                 unused += written;
; 2836 :                 cur += toconv;

	add	edi, DWORD PTR _toconv$2[ebp]
	add	ebx, ecx

; 2837 :             } while (ret == -2);

	mov	ecx, DWORD PTR _handler$1$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LL4@xmlByteCon
$LN3@xmlByteCon:

; 2838 : 	}
; 2839 : 	if (in->buf->rawconsumed < unused)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, ebx
	jb	SHORT $LN19@xmlByteCon

; 2844 : }

	pop	edi
	pop	esi
	sub	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlByteCon:

; 2840 : 	    return(-1);
; 2841 : 	return(in->buf->rawconsumed - unused);
; 2842 :     }
; 2843 :     return(in->consumed + (in->cur - in->base));

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+12]
	add	eax, DWORD PTR [esi+16]
	pop	edi

; 2844 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlByteCon:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlByteConsumed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR __Format$[ebp]

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	DWORD PTR __BufferCount$[ebp]
	or	ecx, 2
	push	DWORD PTR __Buffer$[ebp]
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);
; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;

	pop	esi

; 1956 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
