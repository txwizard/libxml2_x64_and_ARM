; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlstring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__012E1D79_xmlstring@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlStrdup
PUBLIC	_xmlStrndup
PUBLIC	_xmlCharStrndup
PUBLIC	_xmlCharStrdup
PUBLIC	_xmlStrsub
PUBLIC	_xmlStrchr
PUBLIC	_xmlStrstr
PUBLIC	_xmlStrcasestr
PUBLIC	_xmlStrcmp
PUBLIC	_xmlStrncmp
PUBLIC	_xmlStrcasecmp
PUBLIC	_xmlStrncasecmp
PUBLIC	_xmlStrEqual
PUBLIC	_xmlStrQEqual
PUBLIC	_xmlStrlen
PUBLIC	_xmlStrcat
PUBLIC	_xmlStrncat
PUBLIC	_xmlStrncatNew
PUBLIC	_xmlStrPrintf
PUBLIC	_xmlStrVPrintf
PUBLIC	_xmlGetUTF8Char
PUBLIC	_xmlCheckUTF8
PUBLIC	_xmlUTF8Strsize
PUBLIC	_xmlUTF8Strndup
PUBLIC	_xmlUTF8Strpos
PUBLIC	_xmlUTF8Strloc
PUBLIC	_xmlUTF8Strsub
PUBLIC	_xmlUTF8Strlen
PUBLIC	_xmlUTF8Size
PUBLIC	_xmlUTF8Charcmp
PUBLIC	___local_stdio_printf_options
PUBLIC	_xmlEscapeFormatString
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@ ; `string'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlErrMemory:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT ??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@
CONST	SEGMENT
??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@ DB 'malloc of %ld '
	DB	'byte failed', 0aH, 00H			; `string'
CONST	ENDS
CONST	SEGMENT
_casemap DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0e0H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlEscapeFormatString
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_xmlEscapeFormatString PROC				; COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _msg$[ebp]
	xor	ecx, ecx
	xor	edx, edx
	test	edi, edi
	je	$LN9@xmlEscapeF

; 1003 :     xmlChar *msgPtr = NULL;
; 1004 :     xmlChar *result = NULL;
; 1005 :     xmlChar *resultPtr = NULL;
; 1006 :     size_t count = 0;
; 1007 :     size_t msgLen = 0;
; 1008 :     size_t resultLen = 0;
; 1009 : 
; 1010 :     if (!msg || !*msg)

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	$LN9@xmlEscapeF

; 1012 : 
; 1013 :     for (msgPtr = *msg; *msgPtr != '\0'; ++msgPtr) {

	push	ebx
	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN23@xmlEscapeF
	npad	1
$LL4@xmlEscapeF:

; 1014 :         ++msgLen;

	inc	edx
	lea	eax, DWORD PTR [ecx+1]
	cmp	bl, 37					; 00000025H
	cmovne	eax, ecx
	mov	bl, BYTE PTR [esi+edx]
	mov	ecx, eax
	test	bl, bl
	jne	SHORT $LL4@xmlEscapeF

; 1015 :         if (*msgPtr == '%')
; 1016 :             ++count;
; 1017 :     }
; 1018 : 
; 1019 :     if (count == 0)

	test	ecx, ecx
	je	SHORT $LN23@xmlEscapeF

; 1020 :         return(*msg);
; 1021 : 
; 1022 :     resultLen = msgLen + count + 1;

	lea	ebx, DWORD PTR [ecx+1]
	add	ebx, edx

; 1023 :     result = (xmlChar *) xmlMallocAtomic(resultLen * sizeof(xmlChar));

	push	ebx
	call	DWORD PTR _xmlMallocAtomic
	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	add	esp, 4

; 1024 :     if (result == NULL) {

	test	esi, esi
	jne	SHORT $LN12@xmlEscapeF

; 1025 :         /* Clear *msg to prevent format string vulnerabilities in
; 1026 :            out-of-memory situations. */
; 1027 :         xmlFree(*msg);

	push	ecx
	call	DWORD PTR _xmlFree

; 1028 :         *msg = NULL;
; 1029 :         xmlErrMemory(NULL, NULL);

	push	esi
	push	esi
	mov	DWORD PTR [edi], esi
	call	_xmlErrMemory
	add	esp, 12					; 0000000cH

; 1030 :         return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 1044 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@xmlEscapeF:

; 1031 :     }
; 1032 : 
; 1033 :     for (msgPtr = *msg, resultPtr = result; *msgPtr != '\0'; ++msgPtr, ++resultPtr) {

	mov	dl, BYTE PTR [ecx]
	mov	eax, esi
	test	dl, dl
	je	SHORT $LN6@xmlEscapeF
$LL7@xmlEscapeF:

; 1034 :         *resultPtr = *msgPtr;

	mov	BYTE PTR [eax], dl

; 1035 :         if (*msgPtr == '%')

	cmp	BYTE PTR [ecx], 37			; 00000025H
	jne	SHORT $LN5@xmlEscapeF

; 1036 :             *(++resultPtr) = '%';

	inc	eax
	mov	BYTE PTR [eax], 37			; 00000025H
$LN5@xmlEscapeF:

; 1031 :     }
; 1032 : 
; 1033 :     for (msgPtr = *msg, resultPtr = result; *msgPtr != '\0'; ++msgPtr, ++resultPtr) {

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	inc	eax
	test	dl, dl
	jne	SHORT $LL7@xmlEscapeF
$LN6@xmlEscapeF:

; 1037 :     }
; 1038 :     result[resultLen - 1] = '\0';

	mov	BYTE PTR [ebx+esi-1], 0

; 1039 : 
; 1040 :     xmlFree(*msg);

	push	DWORD PTR [edi]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1041 :     *msg = result;

	mov	DWORD PTR [edi], esi
$LN23@xmlEscapeF:

; 1042 : 
; 1043 :     return *msg;

	pop	ebx
	pop	edi
	mov	eax, esi

; 1044 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlEscapeF:
	pop	edi

; 1011 :         return(NULL);

	xor	eax, eax

; 1044 : }

	pop	esi
	pop	ebp
	ret	0
_xmlEscapeFormatString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4
	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	mov	ecx, eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Buffer$[ebp]
	or	eax, 2
	push	DWORD PTR [ecx+4]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsprintf
	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(
; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Charcmp
_TEXT	SEGMENT
_utf1$ = 8						; size = 4
_utf2$ = 12						; size = 4
_xmlUTF8Charcmp PROC					; COMDAT

; 646  : xmlUTF8Charcmp(const xmlChar *utf1, const xmlChar *utf2) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _utf1$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlUTF8Cha

; 647  : 
; 648  :     if (utf1 == NULL ) {
; 649  :         if (utf2 == NULL)

	mov	eax, DWORD PTR _utf2$[ebp]
	neg	eax
	pop	esi
	sbb	eax, eax

; 654  : }

	pop	ebp
	ret	0
$LN2@xmlUTF8Cha:

; 650  :             return 0;
; 651  :         return -1;
; 652  :     }
; 653  :     return xmlStrncmp(utf1, utf2, xmlUTF8Size(utf1));

	push	esi
	call	_xmlUTF8Size
	push	eax
	push	DWORD PTR _utf2$[ebp]
	push	esi
	call	_xmlStrncmp
	add	esp, 16					; 00000010H
	pop	esi

; 654  : }

	pop	ebp
	ret	0
_xmlUTF8Charcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Size
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_xmlUTF8Size PROC					; COMDAT

; 615  : xmlUTF8Size(const xmlChar *utf) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _utf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlUTF8Siz

; 616  :     xmlChar mask;
; 617  :     int len;
; 618  : 
; 619  :     if (utf == NULL)
; 620  :         return -1;
; 621  :     if (*utf < 0x80)

	mov	dl, BYTE PTR [eax]
	cmp	dl, 128					; 00000080H
	jae	SHORT $LN6@xmlUTF8Siz

; 622  :         return 1;

	mov	eax, 1
	pop	ebx

; 634  : }

	pop	ebp
	ret	0
$LN6@xmlUTF8Siz:

; 623  :     /* check valid UTF8 character */
; 624  :     if (!(*utf & 0x40))

	test	dl, 64					; 00000040H
	je	SHORT $LN3@xmlUTF8Siz

; 625  :         return -1;
; 626  :     /* determine number of bytes in char */
; 627  :     len = 2;

	mov	ecx, 2

; 628  :     for (mask=0x20; mask != 0; mask>>=1) {

	mov	al, 32					; 00000020H
$LL4@xmlUTF8Siz:

; 629  :         if (!(*utf & mask))

	mov	bl, al
	test	dl, al
	je	SHORT $LN11@xmlUTF8Siz

; 631  :         len++;

	inc	ecx
	shr	al, 1
	cmp	bl, 2
	jae	SHORT $LL4@xmlUTF8Siz
$LN3@xmlUTF8Siz:

; 632  :     }
; 633  :     return -1;

	or	eax, -1
	pop	ebx

; 634  : }

	pop	ebp
	ret	0
$LN11@xmlUTF8Siz:

; 630  :             return len;

	mov	eax, ecx
	pop	ebx

; 634  : }

	pop	ebp
	ret	0
_xmlUTF8Size ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strlen
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_xmlUTF8Strlen PROC					; COMDAT

; 666  : xmlUTF8Strlen(const xmlChar *utf) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _utf$[ebp]
	xor	edi, edi
	test	eax, eax
	je	SHORT $LN19@xmlUTF8Str

; 667  :     int ret = 0;
; 668  : 
; 669  :     if (utf == NULL)
; 670  :         return(-1);
; 671  : 
; 672  :     while (*utf != 0) {

	mov	dl, BYTE PTR [eax]
	test	dl, dl
	je	SHORT $LN3@xmlUTF8Str
$LN23@xmlUTF8Str:

; 673  :         if (utf[0] & 0x80) {

	jns	SHORT $LN5@xmlUTF8Str

; 674  :             if ((utf[1] & 0xc0) != 0x80)

	mov	cl, BYTE PTR [eax+1]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN19@xmlUTF8Str

; 675  :                 return(-1);
; 676  :             if ((utf[0] & 0xe0) == 0xe0) {

	mov	cl, dl
	and	cl, 224					; 000000e0H
	cmp	cl, 224					; 000000e0H
	jne	SHORT $LN8@xmlUTF8Str

; 677  :                 if ((utf[2] & 0xc0) != 0x80)

	mov	cl, BYTE PTR [eax+2]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN19@xmlUTF8Str

; 678  :                     return(-1);
; 679  :                 if ((utf[0] & 0xf0) == 0xf0) {

	mov	cl, dl
	and	cl, 240					; 000000f0H
	cmp	cl, 240					; 000000f0H
	jne	SHORT $LN11@xmlUTF8Str

; 680  :                     if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	and	dl, 248					; 000000f8H
	cmp	dl, cl
	jne	SHORT $LN19@xmlUTF8Str
	mov	cl, BYTE PTR [eax+3]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN19@xmlUTF8Str

; 682  :                     utf += 4;

	mov	ecx, 4

; 685  :                 }
; 686  :             } else {

	add	eax, ecx
	jmp	SHORT $LN6@xmlUTF8Str
$LN11@xmlUTF8Str:

; 683  :                 } else {
; 684  :                     utf += 3;

	mov	ecx, 3

; 685  :                 }
; 686  :             } else {

	add	eax, ecx
	jmp	SHORT $LN6@xmlUTF8Str
$LN8@xmlUTF8Str:

; 687  :                 utf += 2;

	add	eax, 2

; 688  :             }
; 689  :         } else {

	jmp	SHORT $LN6@xmlUTF8Str
$LN5@xmlUTF8Str:

; 690  :             utf++;

	inc	eax
$LN6@xmlUTF8Str:

; 667  :     int ret = 0;
; 668  : 
; 669  :     if (utf == NULL)
; 670  :         return(-1);
; 671  : 
; 672  :     while (*utf != 0) {

	mov	dl, BYTE PTR [eax]

; 691  :         }
; 692  :         ret++;

	inc	edi
	test	dl, dl
	jne	SHORT $LN23@xmlUTF8Str
$LN3@xmlUTF8Str:

; 693  :     }
; 694  :     return(ret);

	mov	eax, edi
	pop	edi

; 695  : }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlUTF8Str:
	pop	edi

; 681  :                         return(-1);

	or	eax, -1

; 695  : }

	pop	esi
	pop	ebp
	ret	0
_xmlUTF8Strlen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strsub
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_start$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlUTF8Strsub PROC					; COMDAT

; 964  : xmlUTF8Strsub(const xmlChar *utf, int start, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _utf$[ebp]
	test	edx, edx
	je	SHORT $LN17@xmlUTF8Str

; 965  :     int            i;
; 966  :     xmlChar ch;
; 967  : 
; 968  :     if (utf == NULL) return(NULL);
; 969  :     if (start < 0) return(NULL);

	mov	edi, DWORD PTR _start$[ebp]
	test	edi, edi
	js	SHORT $LN17@xmlUTF8Str

; 970  :     if (len < 0) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN17@xmlUTF8Str

; 971  : 
; 972  :     /*
; 973  :      * Skip over any leading chars
; 974  :      */
; 975  :     for (i = 0;i < start;i++) {

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@xmlUTF8Str
	npad	7
$LL4@xmlUTF8Str:

; 976  :         if ((ch=*utf++) == 0) return(NULL);

	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	je	SHORT $LN17@xmlUTF8Str

; 977  :         if ( ch & 0x80 ) {

	jns	SHORT $LN2@xmlUTF8Str

; 978  :             /* if not simple ascii, verify proper format */
; 979  :             if ( (ch & 0xc0) != 0xc0 )

	mov	cl, al
	and	cl, 192					; 000000c0H
	cmp	cl, 192					; 000000c0H
	jne	SHORT $LN17@xmlUTF8Str

; 980  :                 return(NULL);
; 981  :             /* then skip over remaining bytes for this char */
; 982  :             while ( (ch <<= 1) & 0x80 )

	add	al, al
	jns	SHORT $LN2@xmlUTF8Str
$LL5@xmlUTF8Str:

; 983  :                 if ( (*utf++ & 0xc0) != 0x80 )

	mov	cl, BYTE PTR [edx]
	inc	edx
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN17@xmlUTF8Str

; 980  :                 return(NULL);
; 981  :             /* then skip over remaining bytes for this char */
; 982  :             while ( (ch <<= 1) & 0x80 )

	add	al, al
	js	SHORT $LL5@xmlUTF8Str
$LN2@xmlUTF8Str:

; 971  : 
; 972  :     /*
; 973  :      * Skip over any leading chars
; 974  :      */
; 975  :     for (i = 0;i < start;i++) {

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@xmlUTF8Str
$LN3@xmlUTF8Str:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     return(xmlUTF8Strndup(utf, len));

	push	DWORD PTR _len$[ebp]
	push	edx
	call	_xmlUTF8Strndup
	add	esp, 8
	pop	edi

; 989  : }

	pop	esi
	pop	ebp
	ret	0
$LN17@xmlUTF8Str:
	pop	edi

; 984  :                     return(NULL);

	xor	eax, eax

; 989  : }

	pop	esi
	pop	ebp
	ret	0
_xmlUTF8Strsub ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strloc
_TEXT	SEGMENT
_size$1$ = 8						; size = 4
_utf$ = 8						; size = 4
_utfchar$ = 12						; size = 4
_xmlUTF8Strloc PROC					; COMDAT

; 927  : xmlUTF8Strloc(const xmlChar *utf, const xmlChar *utfchar) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _utf$[ebp]
	test	esi, esi
	je	SHORT $LN8@xmlUTF8Str

; 928  :     int i, size;
; 929  :     xmlChar ch;
; 930  : 
; 931  :     if (utf==NULL || utfchar==NULL) return -1;

	mov	eax, DWORD PTR _utfchar$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlUTF8Str

; 932  :     size = xmlUTF8Strsize(utfchar, 1);

	push	1
	push	eax
	call	_xmlUTF8Strsize

; 933  :         for(i=0; (ch=*utf) != 0; i++) {

	mov	bl, BYTE PTR [esi]
	add	esp, 8
	xor	edi, edi
	mov	DWORD PTR _size$1$[ebp], eax
	test	bl, bl
	je	SHORT $LN8@xmlUTF8Str
$LL4@xmlUTF8Str:

; 934  :             if (xmlStrncmp(utf, utfchar, size)==0)

	push	eax
	push	DWORD PTR _utfchar$[ebp]
	push	esi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@xmlUTF8Str

; 936  :             utf++;

	inc	esi

; 937  :             if ( ch & 0x80 ) {

	test	bl, bl
	jns	SHORT $LN2@xmlUTF8Str

; 938  :                 /* if not simple ascii, verify proper format */
; 939  :                 if ( (ch & 0xc0) != 0xc0 )

	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN8@xmlUTF8Str

; 940  :                     return(-1);
; 941  :                 /* then skip over remaining bytes for this char */
; 942  :                 while ( (ch <<= 1) & 0x80 )

	add	bl, bl
	jns	SHORT $LN2@xmlUTF8Str
$LL5@xmlUTF8Str:

; 943  :                     if ( (*utf++ & 0xc0) != 0x80 )

	mov	al, BYTE PTR [esi]
	inc	esi
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN8@xmlUTF8Str

; 940  :                     return(-1);
; 941  :                 /* then skip over remaining bytes for this char */
; 942  :                 while ( (ch <<= 1) & 0x80 )

	add	bl, bl
	js	SHORT $LL5@xmlUTF8Str
$LN2@xmlUTF8Str:

; 933  :         for(i=0; (ch=*utf) != 0; i++) {

	mov	bl, BYTE PTR [esi]
	inc	edi
	mov	eax, DWORD PTR _size$1$[ebp]
	test	bl, bl
	jne	SHORT $LL4@xmlUTF8Str
$LN8@xmlUTF8Str:
	pop	edi

; 944  :                         return(-1);
; 945  :             }
; 946  :         }
; 947  : 
; 948  :     return(-1);
; 949  : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN17@xmlUTF8Str:

; 935  :                 return(i);

	mov	eax, edi
	pop	edi

; 944  :                         return(-1);
; 945  :             }
; 946  :         }
; 947  : 
; 948  :     return(-1);
; 949  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlUTF8Strloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strpos
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_pos$ = 12						; size = 4
_xmlUTF8Strpos PROC					; COMDAT

; 895  : xmlUTF8Strpos(const xmlChar *utf, int pos) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _utf$[ebp]
	test	edx, edx
	je	SHORT $LN15@xmlUTF8Str

; 896  :     xmlChar ch;
; 897  : 
; 898  :     if (utf == NULL) return(NULL);
; 899  :     if (pos < 0)

	mov	esi, DWORD PTR _pos$[ebp]
	test	esi, esi
	js	SHORT $LN15@xmlUTF8Str

; 900  :         return(NULL);
; 901  :     while (pos--) {

	je	SHORT $LN18@xmlUTF8Str
	npad	2
$LL2@xmlUTF8Str:

; 902  :         if ((ch=*utf++) == 0) return(NULL);

	mov	cl, BYTE PTR [edx]
	dec	esi
	inc	edx
	test	cl, cl
	je	SHORT $LN15@xmlUTF8Str

; 903  :         if ( ch & 0x80 ) {

	jns	SHORT $LN5@xmlUTF8Str

; 904  :             /* if not simple ascii, verify proper format */
; 905  :             if ( (ch & 0xc0) != 0xc0 )

	mov	al, cl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN15@xmlUTF8Str

; 906  :                 return(NULL);
; 907  :             /* then skip over remaining bytes for this char */
; 908  :             while ( (ch <<= 1) & 0x80 )

	add	cl, cl
	jns	SHORT $LN5@xmlUTF8Str
$LL4@xmlUTF8Str:

; 909  :                 if ( (*utf++ & 0xc0) != 0x80 )

	mov	al, BYTE PTR [edx]
	inc	edx
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN15@xmlUTF8Str

; 906  :                 return(NULL);
; 907  :             /* then skip over remaining bytes for this char */
; 908  :             while ( (ch <<= 1) & 0x80 )

	add	cl, cl
	js	SHORT $LL4@xmlUTF8Str
$LN5@xmlUTF8Str:

; 900  :         return(NULL);
; 901  :     while (pos--) {

	test	esi, esi
	jne	SHORT $LL2@xmlUTF8Str
$LN18@xmlUTF8Str:

; 911  :         }
; 912  :     }
; 913  :     return((xmlChar *)utf);

	mov	eax, edx
	pop	esi

; 914  : }

	pop	ebp
	ret	0
$LN15@xmlUTF8Str:

; 910  :                     return(NULL);

	xor	eax, eax
	pop	esi

; 914  : }

	pop	ebp
	ret	0
_xmlUTF8Strpos ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strndup
_TEXT	SEGMENT
_i$1$ = 8						; size = 4
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlUTF8Strndup PROC					; COMDAT

; 866  : xmlUTF8Strndup(const xmlChar *utf, int len) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _utf$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlUTF8Str

; 867  :     xmlChar *ret;
; 868  :     int i;
; 869  : 
; 870  :     if ((utf == NULL) || (len < 0)) return(NULL);

	mov	ebx, DWORD PTR _len$[ebp]
	test	ebx, ebx
	js	SHORT $LN3@xmlUTF8Str

; 871  :     i = xmlUTF8Strsize(utf, len);

	push	esi
	push	ebx
	push	edi
	call	_xmlUTF8Strsize
	mov	DWORD PTR _i$1$[ebp], eax

; 872  :     ret = (xmlChar *) xmlMallocAtomic((i + 1) * sizeof(xmlChar));

	lea	ecx, DWORD PTR [eax+1]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 873  :     if (ret == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlUTF8Str

; 874  :         xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 12					; 0000000cH

; 875  :                 "malloc of %ld byte failed\n",
; 876  :                 (len + 1) * (long)sizeof(xmlChar));
; 877  :         return(NULL);

	xor	eax, eax
	pop	esi
	pop	edi

; 882  : }

	pop	ebx
	pop	ebp
	ret	0
$LN4@xmlUTF8Str:

; 878  :     }
; 879  :     memcpy(ret, utf, i * sizeof(xmlChar));

	mov	ebx, DWORD PTR _i$1$[ebp]
	push	ebx
	push	edi
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 880  :     ret[i] = 0;

	mov	BYTE PTR [esi+ebx], 0

; 881  :     return(ret);

	mov	eax, esi
	pop	esi
	pop	edi

; 882  : }

	pop	ebx
	pop	ebp
	ret	0
$LN3@xmlUTF8Str:
	pop	edi

; 867  :     xmlChar *ret;
; 868  :     int i;
; 869  : 
; 870  :     if ((utf == NULL) || (len < 0)) return(NULL);

	xor	eax, eax

; 882  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlUTF8Strndup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strsize
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlUTF8Strsize PROC					; COMDAT

; 833  : xmlUTF8Strsize(const xmlChar *utf, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _utf$[ebp]
	mov	eax, esi
	test	esi, esi
	je	SHORT $LN24@xmlUTF8Str

; 834  :     const xmlChar   *ptr=utf;
; 835  :     xmlChar         ch;
; 836  : 
; 837  :     if (utf == NULL)
; 838  :         return(0);
; 839  : 
; 840  :     if (len <= 0)

	mov	edx, DWORD PTR _len$[ebp]
	test	edx, edx
	jle	SHORT $LN24@xmlUTF8Str
	npad	2
$LL2@xmlUTF8Str:

; 844  :         if ( !*ptr )

	mov	cl, BYTE PTR [eax]
	dec	edx
	test	cl, cl
	je	SHORT $LN15@xmlUTF8Str

; 845  :             break;
; 846  :         if ( (ch = *ptr++) & 0x80)

	inc	eax
	test	cl, cl
	jns	SHORT $LN29@xmlUTF8Str

; 847  :             while ((ch<<=1) & 0x80 ) {

	add	cl, cl
	jns	SHORT $LN29@xmlUTF8Str
$LL4@xmlUTF8Str:

; 848  : 		if (*ptr == 0) break;

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN29@xmlUTF8Str

; 849  :                 ptr++;

	inc	eax
	add	cl, cl
	js	SHORT $LL4@xmlUTF8Str
$LN29@xmlUTF8Str:

; 842  : 
; 843  :     while ( len-- > 0) {

	test	edx, edx
	jg	SHORT $LL2@xmlUTF8Str
$LN15@xmlUTF8Str:

; 850  : 	    }
; 851  :     }
; 852  :     return (ptr - utf);

	sub	eax, esi
	pop	esi

; 853  : }

	pop	ebp
	ret	0
$LN24@xmlUTF8Str:

; 841  :         return(0);

	xor	eax, eax
	pop	esi

; 853  : }

	pop	ebp
	ret	0
_xmlUTF8Strsize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCheckUTF8
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_xmlCheckUTF8 PROC					; COMDAT

; 782  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _utf$[ebp]
	test	esi, esi
	je	$LN15@xmlCheckUT

; 783  :     int ix;
; 784  :     unsigned char c;
; 785  : 
; 786  :     if (utf == NULL)
; 787  :         return(0);
; 788  :     /*
; 789  :      * utf is a string of 1, 2, 3 or 4 bytes.  The valid strings
; 790  :      * are as follows (in "bit format"):
; 791  :      *    0xxxxxxx                                      valid 1-byte
; 792  :      *    110xxxxx 10xxxxxx                             valid 2-byte
; 793  :      *    1110xxxx 10xxxxxx 10xxxxxx                    valid 3-byte
; 794  :      *    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx           valid 4-byte
; 795  :      */
; 796  :     for (ix = 0; (c = utf[ix]);) {      /* string is 0-terminated */

	mov	dl, BYTE PTR [esi]
	xor	eax, eax
	test	dl, dl
	je	$LN3@xmlCheckUT
$LN26@xmlCheckUT:

; 797  :         if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */

	js	SHORT $LN6@xmlCheckUT

; 798  :             ix++;

	mov	ecx, 1
	jmp	SHORT $LN16@xmlCheckUT
$LN6@xmlCheckUT:

; 799  : 	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */

	mov	cl, dl
	and	cl, 224					; 000000e0H
	cmp	cl, 192					; 000000c0H
	jne	SHORT $LN8@xmlCheckUT

; 800  : 	    if ((utf[ix+1] & 0xc0 ) != 0x80)

	mov	cl, BYTE PTR [eax+esi+1]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT

; 801  : 	        return 0;
; 802  : 	    ix += 2;

	mov	ecx, 2
	jmp	SHORT $LN16@xmlCheckUT
$LN8@xmlCheckUT:

; 803  : 	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */

	mov	cl, dl
	and	cl, 240					; 000000f0H
	cmp	cl, 224					; 000000e0H
	jne	SHORT $LN11@xmlCheckUT

; 804  : 	    if (((utf[ix+1] & 0xc0) != 0x80) ||

	mov	cl, BYTE PTR [eax+esi+1]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT
	mov	cl, BYTE PTR [eax+esi+2]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT

; 805  : 	        ((utf[ix+2] & 0xc0) != 0x80))
; 806  : 		    return 0;
; 807  : 	    ix += 3;

	mov	ecx, 3
	jmp	SHORT $LN16@xmlCheckUT
$LN11@xmlCheckUT:

; 808  : 	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */

	and	dl, 248					; 000000f8H
	cmp	dl, 240					; 000000f0H
	jne	SHORT $LN15@xmlCheckUT

; 809  : 	    if (((utf[ix+1] & 0xc0) != 0x80) ||
; 810  : 	        ((utf[ix+2] & 0xc0) != 0x80) ||

	mov	cl, BYTE PTR [eax+esi+1]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT
	mov	cl, BYTE PTR [eax+esi+2]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT
	mov	cl, BYTE PTR [eax+esi+3]
	and	cl, 192					; 000000c0H
	cmp	cl, 128					; 00000080H
	jne	SHORT $LN15@xmlCheckUT

; 811  : 		((utf[ix+3] & 0xc0) != 0x80))
; 812  : 		    return 0;
; 813  : 	    ix += 4;

	mov	ecx, 4
$LN16@xmlCheckUT:

; 783  :     int ix;
; 784  :     unsigned char c;
; 785  : 
; 786  :     if (utf == NULL)
; 787  :         return(0);
; 788  :     /*
; 789  :      * utf is a string of 1, 2, 3 or 4 bytes.  The valid strings
; 790  :      * are as follows (in "bit format"):
; 791  :      *    0xxxxxxx                                      valid 1-byte
; 792  :      *    110xxxxx 10xxxxxx                             valid 2-byte
; 793  :      *    1110xxxx 10xxxxxx 10xxxxxx                    valid 3-byte
; 794  :      *    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx           valid 4-byte
; 795  :      */
; 796  :     for (ix = 0; (c = utf[ix]);) {      /* string is 0-terminated */

	add	eax, ecx
	mov	dl, BYTE PTR [eax+esi]
	test	dl, dl
	jne	$LN26@xmlCheckUT
$LN3@xmlCheckUT:

; 816  :       }
; 817  :       return(1);

	mov	eax, 1
	pop	esi

; 818  : }

	pop	ebp
	ret	0
$LN15@xmlCheckUT:

; 814  : 	} else				/* unknown encoding */
; 815  : 	    return 0;

	xor	eax, eax
	pop	esi

; 818  : }

	pop	ebp
	ret	0
_xmlCheckUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlGetUTF8Char
_TEXT	SEGMENT
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlGetUTF8Char PROC					; COMDAT

; 710  : xmlGetUTF8Char(const unsigned char *utf, int *len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _utf$[ebp]
	mov	esi, DWORD PTR _len$[ebp]
	test	edx, edx
	je	$error$21

; 711  :     unsigned int c;
; 712  : 
; 713  :     if (utf == NULL)
; 714  :         goto error;
; 715  :     if (len == NULL)

	test	esi, esi
	je	$LN18@xmlGetUTF8

; 716  :         goto error;
; 717  :     if (*len < 1)

	mov	edi, DWORD PTR [esi]
	cmp	edi, 1
	jl	$error$21

; 718  :         goto error;
; 719  : 
; 720  :     c = utf[0];

	movzx	ecx, BYTE PTR [edx]

; 721  :     if (c & 0x80) {

	test	cl, cl
	jns	$LN5@xmlGetUTF8

; 722  :         if (*len < 2)

	cmp	edi, 2
	jl	$error$21

; 723  :             goto error;
; 724  :         if ((utf[1] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+1]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$error$21

; 725  :             goto error;
; 726  :         if ((c & 0xe0) == 0xe0) {

	mov	eax, ecx
	and	eax, 224				; 000000e0H
	cmp	al, 224					; 000000e0H
	jne	$LN9@xmlGetUTF8

; 727  :             if (*len < 3)

	cmp	edi, 3
	jl	$error$21

; 728  :                 goto error;
; 729  :             if ((utf[2] & 0xc0) != 0x80)

	mov	al, BYTE PTR [edx+2]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$error$21

; 730  :                 goto error;
; 731  :             if ((c & 0xf0) == 0xf0) {

	mov	eax, ecx
	and	eax, 240				; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN13@xmlGetUTF8

; 732  :                 if (*len < 4)

	cmp	edi, 4
	jl	$error$21

; 733  :                     goto error;
; 734  :                 if ((c & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	and	ecx, 248				; 000000f8H
	cmp	cl, al
	jne	$error$21
	mov	al, BYTE PTR [edx+3]
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	$error$21

; 735  :                     goto error;
; 736  :                 *len = 4;

	mov	DWORD PTR [esi], 4

; 737  :                 /* 4-byte code */
; 738  :                 c = (utf[0] & 0x7) << 18;
; 739  :                 c |= (utf[1] & 0x3f) << 12;
; 740  :                 c |= (utf[2] & 0x3f) << 6;
; 741  :                 c |= utf[3] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 7
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	pop	edi

; 758  :     }
; 759  :     return(c);

	mov	eax, ecx

; 765  : }

	pop	esi
	pop	ebp
	ret	0
$LN13@xmlGetUTF8:

; 742  :             } else {
; 743  :               /* 3-byte code */
; 744  :                 *len = 3;

	mov	DWORD PTR [esi], 3

; 745  :                 c = (utf[0] & 0xf) << 12;
; 746  :                 c |= (utf[1] & 0x3f) << 6;
; 747  :                 c |= utf[2] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	pop	edi

; 758  :     }
; 759  :     return(c);

	mov	eax, ecx

; 765  : }

	pop	esi
	pop	ebp
	ret	0
$LN9@xmlGetUTF8:

; 748  :             }
; 749  :         } else {
; 750  :           /* 2-byte code */
; 751  :             *len = 2;

	mov	DWORD PTR [esi], 2

; 752  :             c = (utf[0] & 0x1f) << 6;
; 753  :             c |= utf[1] & 0x3f;

	movzx	ecx, BYTE PTR [edx]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, 31					; 0000001fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	pop	edi

; 758  :     }
; 759  :     return(c);

	mov	eax, ecx

; 765  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlGetUTF8:
	pop	edi

; 754  :         }
; 755  :     } else {
; 756  :         /* 1-byte code */
; 757  :         *len = 1;

	mov	DWORD PTR [esi], 1

; 758  :     }
; 759  :     return(c);

	mov	eax, ecx

; 765  : }

	pop	esi
	pop	ebp
	ret	0
$error$21:

; 760  : 
; 761  : error:
; 762  :     if (len != NULL)

	test	esi, esi
	je	SHORT $LN18@xmlGetUTF8

; 763  : 	*len = 0;

	mov	DWORD PTR [esi], 0
$LN18@xmlGetUTF8:
	pop	edi

; 764  :     return(-1);

	or	eax, -1

; 765  : }

	pop	esi
	pop	ebp
	ret	0
_xmlGetUTF8Char ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrVPrintf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_msg$ = 16						; size = 4
_ap$ = 20						; size = 4
_xmlStrVPrintf PROC					; COMDAT

; 577  : xmlStrVPrintf(xmlChar *buf, int len, const char *msg, va_list ap) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlStrVPri

; 578  :     int ret;
; 579  : 
; 580  :     if((buf == NULL) || (msg == NULL)) {

	mov	esi, DWORD PTR _msg$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlStrVPri
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	push	DWORD PTR _ap$[ebp]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _len$[ebp]
	or	ecx, 2
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 585  :     buf[len - 1] = 0; /* be safe ! */

	mov	BYTE PTR [edi+esi-1], 0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
	pop	edi
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 588  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlStrVPri:
	pop	edi

; 581  :         return(-1);

	or	eax, -1

; 588  : }

	pop	esi
	pop	ebp
	ret	0
_xmlStrVPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrPrintf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlStrPrintf PROC					; COMDAT

; 549  : xmlStrPrintf(xmlChar *buf, int len, const char *msg, ...) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _buf$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlStrPrin

; 550  :     va_list args;
; 551  :     int ret;
; 552  : 
; 553  :     if((buf == NULL) || (msg == NULL)) {

	mov	esi, DWORD PTR _msg$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlStrPrin
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	___local_stdio_printf_options
	lea	ecx, DWORD PTR _msg$[ebp+4]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _len$[ebp]
	or	ecx, 2
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 560  :     buf[len - 1] = 0; /* be safe ! */

	mov	BYTE PTR [edi+esi-1], 0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1444 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	test	eax, eax
	cmovs	eax, ecx
	pop	edi
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 563  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlStrPrin:
	pop	edi

; 554  :         return(-1);

	or	eax, -1

; 563  : }

	pop	esi
	pop	ebp
	ret	0
_xmlStrPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncatNew
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_size$1$ = 16						; size = 4
_len$ = 16						; size = 4
_xmlStrncatNew PROC					; COMDAT

; 485  : xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _len$[ebp]
	mov	ebx, DWORD PTR _str2$[ebp]
	test	edi, edi
	jns	SHORT $LN3@xmlStrncat

; 423  :     int len = 0;

	xor	edi, edi

; 424  : 
; 425  :     if (str == NULL) return(0);

	test	ebx, ebx
	je	$LN5@xmlStrncat

; 426  :     while (*str != 0) { /* non input consuming */

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN12@xmlStrncat
	npad	6
$LL11@xmlStrncat:

; 427  :         str++;
; 428  :         len++;

	inc	edi
	cmp	BYTE PTR [edi+ebx], 0
	jne	SHORT $LL11@xmlStrncat
$LN12@xmlStrncat:

; 486  :     int size;
; 487  :     xmlChar *ret;
; 488  : 
; 489  :     if (len < 0) {
; 490  :         len = xmlStrlen(str2);
; 491  :         if (len < 0)

	test	edi, edi
	js	SHORT $LN28@xmlStrncat
$LN3@xmlStrncat:

; 492  :             return(NULL);
; 493  :     }
; 494  :     if ((str2 == NULL) || (len == 0))

	test	ebx, ebx
	je	$LN5@xmlStrncat
	test	edi, edi
	je	$LN5@xmlStrncat

; 495  :         return(xmlStrdup(str1));
; 496  :     if (str1 == NULL)

	mov	esi, DWORD PTR _str1$[ebp]
	test	esi, esi
	jne	SHORT $LN6@xmlStrncat

; 497  :         return(xmlStrndup(str2, len));

	push	edi
	push	ebx

; 511  : }

	call	_xmlStrndup
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlStrncat:

; 498  : 
; 499  :     size = xmlStrlen(str1);

	push	esi
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$1$[ebp], eax

; 500  :     if (size < 0)

	test	eax, eax
	jns	SHORT $LN7@xmlStrncat
$LN28@xmlStrncat:
	pop	edi

; 511  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlStrncat:

; 501  :         return(NULL);
; 502  :     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));

	inc	eax
	add	eax, edi
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], eax

; 503  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN8@xmlStrncat

; 504  :         xmlErrMemory(NULL, NULL);

	push	eax
	push	eax
	call	_xmlErrMemory

; 505  :         return(xmlStrndup(str1, size));

	push	DWORD PTR _size$1$[ebp]
	push	esi
	call	_xmlStrndup
	add	esp, 16					; 00000010H
	pop	edi

; 511  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlStrncat:

; 506  :     }
; 507  :     memcpy(ret, str1, size * sizeof(xmlChar));

	push	DWORD PTR _size$1$[ebp]
	push	esi
	push	eax
	call	_memcpy

; 508  :     memcpy(&ret[size], str2, len * sizeof(xmlChar));

	mov	esi, DWORD PTR _ret$1$[ebp]
	add	esi, DWORD PTR _size$1$[ebp]
	push	edi
	push	ebx
	push	esi
	call	_memcpy

; 509  :     ret[size + len] = 0;
; 510  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 24					; 00000018H
	mov	BYTE PTR [esi+edi], 0
	pop	edi

; 511  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlStrncat:

; 67   :     const xmlChar *p = cur;

	mov	ecx, DWORD PTR _str1$[ebp]
	mov	eax, ecx

; 68   : 
; 69   :     if (cur == NULL) return(NULL);

	test	ecx, ecx
	je	SHORT $LN28@xmlStrncat

; 70   :     while (*p != 0) p++; /* non input consuming */

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN17@xmlStrncat
$LL16@xmlStrncat:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL16@xmlStrncat
$LN17@xmlStrncat:

; 71   :     return(xmlStrndup(cur, p - cur));

	sub	eax, ecx
	push	eax
	push	ecx

; 511  : }

	call	_xmlStrndup
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncatNew ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncat
_TEXT	SEGMENT
_ret$1$ = -4						; size = 4
_cur$ = 8						; size = 4
_size$1$ = 12						; size = 4
_add$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncat PROC					; COMDAT

; 448  : xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _add$[ebp]
	test	ebx, ebx
	je	$LN3@xmlStrncat

; 449  :     int size;
; 450  :     xmlChar *ret;
; 451  : 
; 452  :     if ((add == NULL) || (len == 0))

	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlStrncat

; 454  :     if (len < 0)

	push	esi
	js	SHORT $LN9@xmlStrncat

; 455  : 	return(NULL);
; 456  :     if (cur == NULL)

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	jne	SHORT $LN5@xmlStrncat

; 457  :         return(xmlStrndup(add, len));

	push	edi
	push	ebx
	call	_xmlStrndup
	add	esp, 8
	pop	esi
	pop	edi

; 470  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlStrncat:

; 458  : 
; 459  :     size = xmlStrlen(cur);

	push	esi
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$1$[ebp], eax

; 460  :     if (size < 0)

	test	eax, eax
	js	SHORT $LN9@xmlStrncat

; 462  :     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));

	inc	eax
	add	eax, edi
	push	eax
	push	esi
	call	DWORD PTR _xmlRealloc
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _ret$1$[ebp], ecx

; 463  :     if (ret == NULL) {

	test	ecx, ecx
	jne	SHORT $LN7@xmlStrncat

; 464  :         xmlErrMemory(NULL, NULL);

	push	eax
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 465  :         return(cur);

	mov	eax, esi
	pop	esi
	pop	edi

; 470  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlStrncat:

; 466  :     }
; 467  :     memcpy(&ret[size], add, len * sizeof(xmlChar));

	mov	esi, DWORD PTR _size$1$[ebp]
	push	edi
	add	esi, ecx
	push	ebx
	push	esi
	call	_memcpy

; 468  :     ret[size + len] = 0;
; 469  :     return(ret);

	mov	eax, DWORD PTR _ret$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+edi], 0
	pop	esi
	pop	edi

; 470  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlStrncat:
	pop	esi
	pop	edi

; 461  :         return(NULL);

	xor	eax, eax

; 470  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlStrncat:

; 453  :         return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	pop	edi

; 470  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcat
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_add$ = 12						; size = 4
_xmlStrcat PROC						; COMDAT

; 526  : xmlStrcat(xmlChar *cur, const xmlChar *add) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _add$[ebp]
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, esi
	test	esi, esi
	jne	SHORT $LN4@xmlStrcat

; 527  :     const xmlChar *p = add;
; 528  : 
; 529  :     if (add == NULL) return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	pop	esi

; 535  : }

	pop	ebp
	ret	0
$LN4@xmlStrcat:

; 530  :     if (cur == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [esi]
	test	edx, edx
	jne	SHORT $LN13@xmlStrcat

; 70   :     while (*p != 0) p++; /* non input consuming */

	test	cl, cl
	je	SHORT $LN9@xmlStrcat
	npad	6
$LL8@xmlStrcat:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL8@xmlStrcat
$LN9@xmlStrcat:

; 71   :     return(xmlStrndup(cur, p - cur));

	sub	eax, esi
	push	eax
	push	esi
	call	_xmlStrndup
	add	esp, 8
	pop	esi

; 535  : }

	pop	ebp
	ret	0
$LN13@xmlStrcat:

; 531  :         return(xmlStrdup(add));
; 532  : 
; 533  :     while (*p != 0) p++; /* non input consuming */

	test	cl, cl
	je	SHORT $LN3@xmlStrcat
	npad	7
$LL2@xmlStrcat:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlStrcat
$LN3@xmlStrcat:

; 534  :     return(xmlStrncat(cur, add, p - add));

	sub	eax, esi
	push	eax
	push	esi
	push	edx
	call	_xmlStrncat
	add	esp, 12					; 0000000cH
	pop	esi

; 535  : }

	pop	ebp
	ret	0
_xmlStrcat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrlen
_TEXT	SEGMENT
_str$ = 8						; size = 4
_xmlStrlen PROC						; COMDAT

; 422  : xmlStrlen(const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	xor	ecx, ecx
	test	eax, eax
	jne	SHORT $LN6@xmlStrlen

; 431  : }

	pop	ebp
	ret	0
$LN6@xmlStrlen:

; 423  :     int len = 0;
; 424  : 
; 425  :     if (str == NULL) return(0);
; 426  :     while (*str != 0) { /* non input consuming */

	cmp	BYTE PTR [eax], cl
	je	SHORT $LN3@xmlStrlen
	npad	4
$LL2@xmlStrlen:

; 427  :         str++;

	lea	eax, DWORD PTR [eax+1]

; 428  :         len++;

	inc	ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlStrlen
$LN3@xmlStrlen:

; 429  :     }
; 430  :     return(len);

	mov	eax, ecx

; 431  : }

	pop	ebp
	ret	0
_xmlStrlen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrQEqual
_TEXT	SEGMENT
_pref$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlStrQEqual PROC					; COMDAT

; 179  : xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _pref$[ebp]
	test	edi, edi
	jne	SHORT $LN8@xmlStrQEqu

; 180  :     if (pref == NULL) return(xmlStrEqual(name, str));

	push	DWORD PTR _str$[ebp]
	push	DWORD PTR _name$[ebp]
	call	_xmlStrEqual
	add	esp, 8
	pop	edi

; 192  : }

	pop	ebp
	ret	0
$LN8@xmlStrQEqu:
	push	ebx
	push	esi

; 181  :     if (name == NULL) return(0);

	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	SHORT $LN19@xmlStrQEqu

; 182  :     if (str == NULL) return(0);

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN19@xmlStrQEqu

; 183  : 
; 184  :     do {
; 185  :         if (*pref++ != *str) return(0);

	mov	cl, BYTE PTR [eax]
	mov	ebx, eax
	cmp	BYTE PTR [edi], cl
	jne	SHORT $LN19@xmlStrQEqu
	sub	edi, eax
$LL4@xmlStrQEqu:

; 186  :     } while ((*str++) && (*pref));

	inc	eax
	test	cl, cl
	je	SHORT $LN12@xmlStrQEqu
	mov	dl, BYTE PTR [edi+eax]
	test	dl, dl
	je	SHORT $LN12@xmlStrQEqu

; 183  : 
; 184  :     do {
; 185  :         if (*pref++ != *str) return(0);

	mov	cl, BYTE PTR [eax]
	mov	ebx, eax
	cmp	dl, cl
	je	SHORT $LL4@xmlStrQEqu
$LN19@xmlStrQEqu:
	pop	esi
	pop	ebx

; 188  :     do {
; 189  :         if (*name++ != *str) return(0);

	xor	eax, eax
	pop	edi

; 192  : }

	pop	ebp
	ret	0
$LN12@xmlStrQEqu:

; 187  :     if (*str++ != ':') return(0);

	mov	al, BYTE PTR [eax]
	lea	ecx, DWORD PTR [ebx+2]
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN19@xmlStrQEqu
$LL7@xmlStrQEqu:

; 188  :     do {
; 189  :         if (*name++ != *str) return(0);

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	dl, BYTE PTR [ecx]
	cmp	al, dl
	jne	SHORT $LN19@xmlStrQEqu

; 190  :     } while (*str++);

	inc	ecx
	test	dl, dl
	jne	SHORT $LL7@xmlStrQEqu

; 191  :     return(1);

	pop	esi
	pop	ebx
	mov	eax, 1
	pop	edi

; 192  : }

	pop	ebp
	ret	0
_xmlStrQEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrEqual
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrEqual PROC					; COMDAT

; 157  : xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	edx, ecx
	je	SHORT $LN12@xmlStrEqua

; 158  :     if (str1 == str2) return(1);
; 159  :     if (str1 == NULL) return(0);

	test	edx, edx
	je	SHORT $LN11@xmlStrEqua

; 160  :     if (str2 == NULL) return(0);

	test	ecx, ecx
	je	SHORT $LN11@xmlStrEqua
$LL4@xmlStrEqua:

; 161  :     do {
; 162  :         if (*str1++ != *str2) return(0);

	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	bl, BYTE PTR [ecx]
	cmp	al, bl
	jne	SHORT $LN11@xmlStrEqua

; 163  :     } while (*str2++);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlStrEqua
$LN12@xmlStrEqua:

; 164  :     return(1);

	mov	eax, 1
	pop	ebx

; 165  : }

	pop	ebp
	ret	0
$LN11@xmlStrEqua:

; 161  :     do {
; 162  :         if (*str1++ != *str2) return(0);

	xor	eax, eax
	pop	ebx

; 165  : }

	pop	ebp
	ret	0
_xmlStrEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncasecmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncasecmp PROC					; COMDAT

; 296  : xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _len$[ebp]
	test	edx, edx
	jle	SHORT $LN19@xmlStrncas

; 297  :     register int tmp;
; 298  : 
; 299  :     if (len <= 0) return(0);
; 300  :     if (str1 == str2) return(0);

	mov	edi, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	edi, ecx
	je	SHORT $LN19@xmlStrncas

; 301  :     if (str1 == NULL) return(-1);

	test	edi, edi
	jne	SHORT $LN7@xmlStrncas
	or	eax, -1
	pop	edi

; 308  : }

	pop	ebp
	ret	0
$LN7@xmlStrncas:

; 302  :     if (str2 == NULL) return(1);

	test	ecx, ecx
	jne	SHORT $LN25@xmlStrncas
	lea	eax, DWORD PTR [ecx+1]
	pop	edi

; 308  : }

	pop	ebp
	ret	0
$LN25@xmlStrncas:
	push	ebx
	push	esi
$LL4@xmlStrncas:

; 303  :     do {
; 304  :         tmp = casemap[*str1++] - casemap[*str2];

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	mov	bl, BYTE PTR [ecx]
	movzx	esi, BYTE PTR _casemap[eax]
	movzx	eax, bl
	movzx	eax, BYTE PTR _casemap[eax]
	sub	esi, eax

; 305  :         if (tmp != 0 || --len == 0) return(tmp);

	jne	SHORT $LN10@xmlStrncas
	sub	edx, 1
	je	SHORT $LN10@xmlStrncas

; 306  :     } while (*str2++ != 0);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlStrncas

; 307  :     return 0;

	pop	esi
	pop	ebx
	xor	eax, eax
	pop	edi

; 308  : }

	pop	ebp
	ret	0
$LN10@xmlStrncas:

; 305  :         if (tmp != 0 || --len == 0) return(tmp);

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	edi

; 308  : }

	pop	ebp
	ret	0
$LN19@xmlStrncas:

; 297  :     register int tmp;
; 298  : 
; 299  :     if (len <= 0) return(0);
; 300  :     if (str1 == str2) return(0);

	xor	eax, eax
	pop	edi

; 308  : }

	pop	ebp
	ret	0
_xmlStrncasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcasecmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrcasecmp PROC					; COMDAT

; 271  : xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	esi, ecx
	je	SHORT $LN12@xmlStrcase

; 272  :     register int tmp;
; 273  : 
; 274  :     if (str1 == str2) return(0);
; 275  :     if (str1 == NULL) return(-1);

	test	esi, esi
	jne	SHORT $LN6@xmlStrcase
	pop	esi
	or	eax, -1

; 282  : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlStrcase:

; 276  :     if (str2 == NULL) return(1);

	test	ecx, ecx
	jne	SHORT $LL4@xmlStrcase
	pop	esi
	lea	eax, DWORD PTR [ecx+1]

; 282  : }

	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LL4@xmlStrcase:

; 277  :     do {
; 278  :         tmp = casemap[*str1++] - casemap[*str2];

	movzx	eax, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	bl, BYTE PTR [ecx]
	movzx	edx, BYTE PTR _casemap[eax]
	movzx	eax, bl
	movzx	eax, BYTE PTR _casemap[eax]
	sub	edx, eax

; 279  :         if (tmp != 0) return(tmp);

	jne	SHORT $LN11@xmlStrcase

; 280  :     } while (*str2++ != 0);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlStrcase
$LN12@xmlStrcase:
	pop	esi

; 281  :     return 0;

	xor	eax, eax

; 282  : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlStrcase:
	pop	esi

; 279  :         if (tmp != 0) return(tmp);

	mov	eax, edx

; 282  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlStrcasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncmp PROC					; COMDAT

; 206  : xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _len$[ebp]
	test	edi, edi
	jle	SHORT $LN19@xmlStrncmp

; 207  :     register int tmp;
; 208  : 
; 209  :     if (len <= 0) return(0);
; 210  :     if (str1 == str2) return(0);

	mov	esi, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	esi, ecx
	je	SHORT $LN19@xmlStrncmp

; 211  :     if (str1 == NULL) return(-1);

	test	esi, esi
	jne	SHORT $LN7@xmlStrncmp
	pop	edi
	or	eax, -1

; 222  : #endif
; 223  : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlStrncmp:

; 212  :     if (str2 == NULL) return(1);

	test	ecx, ecx
	jne	SHORT $LN25@xmlStrncmp
	pop	edi
	lea	eax, DWORD PTR [ecx+1]

; 222  : #endif
; 223  : }

	pop	esi
	pop	ebp
	ret	0
$LN25@xmlStrncmp:
	push	ebx
$LL4@xmlStrncmp:

; 213  : #ifdef __GNUC__
; 214  :     tmp = strncmp((const char *)str1, (const char *)str2, len);
; 215  :     return tmp;
; 216  : #else
; 217  :     do {
; 218  :         tmp = *str1++ - *str2;

	mov	bl, BYTE PTR [ecx]
	lea	esi, DWORD PTR [esi+1]
	movzx	edx, BYTE PTR [esi-1]
	movzx	eax, bl
	sub	edx, eax

; 219  :         if (tmp != 0 || --len == 0) return(tmp);

	jne	SHORT $LN10@xmlStrncmp
	sub	edi, 1
	je	SHORT $LN10@xmlStrncmp

; 220  :     } while (*str2++ != 0);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlStrncmp

; 221  :     return 0;

	pop	ebx
	pop	edi
	xor	eax, eax

; 222  : #endif
; 223  : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlStrncmp:
	pop	ebx
	pop	edi

; 219  :         if (tmp != 0 || --len == 0) return(tmp);

	mov	eax, edx

; 222  : #endif
; 223  : }

	pop	esi
	pop	ebp
	ret	0
$LN19@xmlStrncmp:
	pop	edi

; 207  :     register int tmp;
; 208  : 
; 209  :     if (len <= 0) return(0);
; 210  :     if (str1 == str2) return(0);

	xor	eax, eax

; 222  : #endif
; 223  : }

	pop	esi
	pop	ebp
	ret	0
_xmlStrncmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrcmp PROC						; COMDAT

; 132  : xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str1$[ebp]
	mov	ecx, DWORD PTR _str2$[ebp]
	cmp	esi, ecx
	je	SHORT $LN12@xmlStrcmp

; 133  :     register int tmp;
; 134  : 
; 135  :     if (str1 == str2) return(0);
; 136  :     if (str1 == NULL) return(-1);

	test	esi, esi
	jne	SHORT $LN6@xmlStrcmp
	pop	esi
	or	eax, -1

; 143  : }

	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlStrcmp:

; 137  :     if (str2 == NULL) return(1);

	test	ecx, ecx
	jne	SHORT $LL4@xmlStrcmp
	pop	esi
	lea	eax, DWORD PTR [ecx+1]

; 143  : }

	pop	ebx
	pop	ebp
	ret	0
	npad	1
$LL4@xmlStrcmp:

; 138  :     do {
; 139  :         tmp = *str1++ - *str2;

	mov	bl, BYTE PTR [ecx]
	lea	esi, DWORD PTR [esi+1]
	movzx	edx, BYTE PTR [esi-1]
	movzx	eax, bl
	sub	edx, eax

; 140  :         if (tmp != 0) return(tmp);

	jne	SHORT $LN11@xmlStrcmp

; 141  :     } while (*str2++ != 0);

	inc	ecx
	test	bl, bl
	jne	SHORT $LL4@xmlStrcmp
$LN12@xmlStrcmp:
	pop	esi

; 142  :     return 0;

	xor	eax, eax

; 143  : }

	pop	ebx
	pop	ebp
	ret	0
$LN11@xmlStrcmp:
	pop	esi

; 140  :         if (tmp != 0) return(tmp);

	mov	eax, edx

; 143  : }

	pop	ebx
	pop	ebp
	ret	0
_xmlStrcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcasestr
_TEXT	SEGMENT
_str$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlStrcasestr PROC					; COMDAT

; 369  : xmlStrcasestr(const xmlChar *str, const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlStrcase

; 370  :     int n;
; 371  : 
; 372  :     if (str == NULL) return(NULL);
; 373  :     if (val == NULL) return(NULL);

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlStrcase

; 423  :     int len = 0;

	xor	edi, edi

; 424  : 
; 425  :     if (str == NULL) return(0);
; 426  :     while (*str != 0) { /* non input consuming */

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN24@xmlStrcase
$LL11@xmlStrcase:

; 427  :         str++;
; 428  :         len++;

	inc	edi
	cmp	BYTE PTR [edi+ebx], 0
	jne	SHORT $LL11@xmlStrcase

; 374  :     n = xmlStrlen(val);
; 375  : 
; 376  :     if (n == 0) return(str);

	test	edi, edi
	je	SHORT $LN24@xmlStrcase

; 377  :     while (*str != 0) { /* non input consuming */

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN3@xmlStrcase
	npad	10
$LL2@xmlStrcase:

; 378  :         if (casemap[*str] == casemap[*val])

	movzx	ecx, BYTE PTR [ebx]
	movzx	eax, al
	mov	al, BYTE PTR _casemap[eax]
	cmp	al, BYTE PTR _casemap[ecx]
	jne	SHORT $LN8@xmlStrcase

; 379  :             if (!xmlStrncasecmp(str, val, n)) return(str);

	push	edi
	push	ebx
	push	esi
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@xmlStrcase
$LN8@xmlStrcase:

; 377  :     while (*str != 0) { /* non input consuming */

	mov	al, BYTE PTR [esi+1]

; 380  :         str++;

	inc	esi
	test	al, al
	jne	SHORT $LL2@xmlStrcase
$LN3@xmlStrcase:
	pop	edi

; 381  :     }
; 382  :     return(NULL);
; 383  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlStrcase:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlStrcasestr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrstr
_TEXT	SEGMENT
_str$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlStrstr PROC						; COMDAT

; 341  : xmlStrstr(const xmlChar *str, const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _str$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlStrstr

; 342  :     int n;
; 343  : 
; 344  :     if (str == NULL) return(NULL);
; 345  :     if (val == NULL) return(NULL);

	mov	ebx, DWORD PTR _val$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@xmlStrstr

; 423  :     int len = 0;

	xor	esi, esi

; 424  : 
; 425  :     if (str == NULL) return(0);
; 426  :     while (*str != 0) { /* non input consuming */

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN24@xmlStrstr
$LL11@xmlStrstr:

; 427  :         str++;
; 428  :         len++;

	inc	esi
	cmp	BYTE PTR [esi+ebx], 0
	jne	SHORT $LL11@xmlStrstr

; 346  :     n = xmlStrlen(val);
; 347  : 
; 348  :     if (n == 0) return(str);

	test	esi, esi
	je	SHORT $LN24@xmlStrstr

; 349  :     while (*str != 0) { /* non input consuming */

	mov	al, BYTE PTR [edi]
	test	al, al
	je	SHORT $LN3@xmlStrstr
$LL2@xmlStrstr:

; 350  :         if (*str == *val) {

	cmp	al, BYTE PTR [ebx]
	jne	SHORT $LN8@xmlStrstr

; 351  :             if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);

	push	esi
	push	ebx
	push	edi
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@xmlStrstr
$LN8@xmlStrstr:

; 349  :     while (*str != 0) { /* non input consuming */

	mov	al, BYTE PTR [edi+1]

; 352  :         }
; 353  :         str++;

	inc	edi
	test	al, al
	jne	SHORT $LL2@xmlStrstr
$LN3@xmlStrstr:
	pop	edi

; 354  :     }
; 355  :     return(NULL);
; 356  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN24@xmlStrstr:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlStrstr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrchr
_TEXT	SEGMENT
_str$ = 8						; size = 4
_val$ = 12						; size = 1
_xmlStrchr PROC						; COMDAT

; 321  : xmlStrchr(const xmlChar *str, xmlChar val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlStrchr

; 322  :     if (str == NULL) return(NULL);
; 323  :     while (*str != 0) { /* non input consuming */

	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN3@xmlStrchr
	mov	dl, BYTE PTR _val$[ebp]
	npad	3
$LL2@xmlStrchr:

; 324  :         if (*str == val) return((xmlChar *) str);

	cmp	cl, dl
	je	SHORT $LN1@xmlStrchr

; 325  :         str++;

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2@xmlStrchr
$LN3@xmlStrchr:

; 326  :     }
; 327  :     return(NULL);

	xor	eax, eax
$LN1@xmlStrchr:

; 328  : }

	pop	ebp
	ret	0
_xmlStrchr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrsub
_TEXT	SEGMENT
_str$ = 8						; size = 4
_start$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrsub PROC						; COMDAT

; 397  : xmlStrsub(const xmlChar *str, int start, int len) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	SHORT $LN16@xmlStrsub

; 398  :     int i;
; 399  : 
; 400  :     if (str == NULL) return(NULL);
; 401  :     if (start < 0) return(NULL);

	mov	edx, DWORD PTR _start$[ebp]
	test	edx, edx
	js	SHORT $LN16@xmlStrsub

; 402  :     if (len < 0) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN16@xmlStrsub

; 403  : 
; 404  :     for (i = 0;i < start;i++) {

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN3@xmlStrsub
$LL4@xmlStrsub:

; 405  :         if (*str == 0) return(NULL);

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN16@xmlStrsub

; 406  :         str++;

	inc	ecx
	inc	eax
	cmp	ecx, edx
	jl	SHORT $LL4@xmlStrsub
$LN3@xmlStrsub:

; 407  :     }
; 408  :     if (*str == 0) return(NULL);

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN16@xmlStrsub

; 409  :     return(xmlStrndup(str, len));

	push	DWORD PTR _len$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8

; 410  : }

	pop	ebp
	ret	0
$LN16@xmlStrsub:

; 407  :     }
; 408  :     if (*str == 0) return(NULL);

	xor	eax, eax

; 410  : }

	pop	ebp
	ret	0
_xmlStrsub ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCharStrdup
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlCharStrdup PROC					; COMDAT

; 113  : xmlCharStrdup(const char *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LN6@xmlCharStr

; 119  : }

	pop	ebp
	ret	0
$LN6@xmlCharStr:

; 114  :     const char *p = cur;
; 115  : 
; 116  :     if (cur == NULL) return(NULL);
; 117  :     while (*p != '\0') p++; /* non input consuming */

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN3@xmlCharStr
	npad	3
$LL2@xmlCharStr:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlCharStr
$LN3@xmlCharStr:

; 118  :     return(xmlCharStrndup(cur, p - cur));

	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlCharStrndup
	add	esp, 8

; 119  : }

	pop	ebp
	ret	0
_xmlCharStrdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCharStrndup
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCharStrndup PROC					; COMDAT

; 85   : xmlCharStrndup(const char *cur, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlCharStr

; 86   :     int i;
; 87   :     xmlChar *ret;
; 88   : 
; 89   :     if ((cur == NULL) || (len < 0)) return(NULL);

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	js	SHORT $LN6@xmlCharStr

; 90   :     ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));

	lea	eax, DWORD PTR [esi+1]
	push	ebx
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	mov	ebx, eax
	add	esp, 4

; 91   :     if (ret == NULL) {

	test	ebx, ebx
	jne	SHORT $LN7@xmlCharStr

; 92   :         xmlErrMemory(NULL, NULL);

	push	eax
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 93   :         return(NULL);

	xor	eax, eax
	pop	ebx
	pop	edi

; 101  : }

	pop	esi
	pop	ebp
	ret	0
$LN7@xmlCharStr:

; 94   :     }
; 95   :     for (i = 0;i < len;i++) {

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN3@xmlCharStr
	mov	ecx, ebx
	sub	edi, ebx
	npad	4
$LL4@xmlCharStr:

; 96   :         ret[i] = (xmlChar) cur[i];

	mov	al, BYTE PTR [edi+ecx]
	mov	BYTE PTR [ecx], al

; 97   :         if (ret[i] == 0) return(ret);

	test	al, al
	je	SHORT $LN11@xmlCharStr

; 94   :     }
; 95   :     for (i = 0;i < len;i++) {

	inc	edx
	inc	ecx
	cmp	edx, esi
	jl	SHORT $LL4@xmlCharStr
$LN3@xmlCharStr:

; 98   :     }
; 99   :     ret[len] = 0;

	mov	BYTE PTR [ebx+esi], 0
$LN11@xmlCharStr:

; 100  :     return(ret);

	mov	eax, ebx
	pop	ebx
	pop	edi

; 101  : }

	pop	esi
	pop	ebp
	ret	0
$LN6@xmlCharStr:
	pop	edi

; 86   :     int i;
; 87   :     xmlChar *ret;
; 88   : 
; 89   :     if ((cur == NULL) || (len < 0)) return(NULL);

	xor	eax, eax

; 101  : }

	pop	esi
	pop	ebp
	ret	0
_xmlCharStrndup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrndup
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlStrndup PROC					; COMDAT

; 41   : xmlStrndup(const xmlChar *cur, int len) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlStrndup

; 42   :     xmlChar *ret;
; 43   : 
; 44   :     if ((cur == NULL) || (len < 0)) return(NULL);

	mov	esi, DWORD PTR _len$[ebp]
	test	esi, esi
	js	SHORT $LN3@xmlStrndup

; 45   :     ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));

	lea	eax, DWORD PTR [esi+1]
	push	edi
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	mov	edi, eax
	add	esp, 4

; 46   :     if (ret == NULL) {

	test	edi, edi
	jne	SHORT $LN4@xmlStrndup

; 47   :         xmlErrMemory(NULL, NULL);

	push	eax
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 48   :         return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 53   : }

	pop	ebp
	ret	0
$LN4@xmlStrndup:

; 49   :     }
; 50   :     memcpy(ret, cur, len * sizeof(xmlChar));

	push	esi
	push	DWORD PTR _cur$[ebp]
	push	edi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 51   :     ret[len] = 0;

	mov	BYTE PTR [edi+esi], 0

; 52   :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 53   : }

	pop	ebp
	ret	0
$LN3@xmlStrndup:

; 42   :     xmlChar *ret;
; 43   : 
; 44   :     if ((cur == NULL) || (len < 0)) return(NULL);

	xor	eax, eax
	pop	esi

; 53   : }

	pop	ebp
	ret	0
_xmlStrndup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrdup
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlStrdup PROC						; COMDAT

; 66   : xmlStrdup(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LN6@xmlStrdup

; 72   : }

	pop	ebp
	ret	0
$LN6@xmlStrdup:

; 67   :     const xmlChar *p = cur;
; 68   : 
; 69   :     if (cur == NULL) return(NULL);
; 70   :     while (*p != 0) p++; /* non input consuming */

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN3@xmlStrdup
	npad	3
$LL2@xmlStrdup:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@xmlStrdup
$LN3@xmlStrdup:

; 71   :     return(xmlStrndup(cur, p - cur));

	sub	eax, ecx
	push	eax
	push	ecx
	call	_xmlStrndup
	add	esp, 8

; 72   : }

	pop	ebp
	ret	0
_xmlStrdup ENDP
_TEXT	ENDS
END
