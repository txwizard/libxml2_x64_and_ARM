; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xpointer.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__BEF3E6F7_xpointer@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlXPtrLocationSetCreate
PUBLIC	_xmlXPtrFreeLocationSet
PUBLIC	_xmlXPtrLocationSetMerge
PUBLIC	_xmlXPtrNewRange
PUBLIC	_xmlXPtrNewRangePoints
PUBLIC	_xmlXPtrNewRangeNodePoint
PUBLIC	_xmlXPtrNewRangePointNode
PUBLIC	_xmlXPtrNewRangeNodes
PUBLIC	_xmlXPtrNewLocationSetNodes
PUBLIC	_xmlXPtrNewLocationSetNodeSet
PUBLIC	_xmlXPtrNewRangeNodeObject
PUBLIC	_xmlXPtrNewCollapsedRange
PUBLIC	_xmlXPtrLocationSetAdd
PUBLIC	_xmlXPtrWrapLocationSet
PUBLIC	_xmlXPtrLocationSetDel
PUBLIC	_xmlXPtrLocationSetRemove
PUBLIC	_xmlXPtrNewContext
PUBLIC	_xmlXPtrEval
PUBLIC	_xmlXPtrRangeToFunction
PUBLIC	_xmlXPtrBuildNodeList
PUBLIC	_xmlXPtrEvalRangePredicate
PUBLIC	_xmlXPtrAdvanceNode
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BB@DMDDEGKA@allocating?5point@		; `string'
PUBLIC	??_C@_0BB@PBEHJOM@allocating?5range@		; `string'
PUBLIC	??_C@_0BH@HNICMPAH@allocating?5locationset@	; `string'
PUBLIC	??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@	; `string'
PUBLIC	??_C@_0BC@MDOPFBLJ@allocating?5buffer@		; `string'
PUBLIC	??_C@_08DNJCJFMK@xpointer@			; `string'
PUBLIC	??_C@_07HCLJNICE@element@			; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@ ; `string'
PUBLIC	??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@ ; `string'
PUBLIC	??_C@_05CCGOGOBM@range@				; `string'
PUBLIC	??_C@_0N@FPBCPIBK@range?9inside@		; `string'
PUBLIC	??_C@_0N@NHPDEMLM@string?9range@		; `string'
PUBLIC	??_C@_0M@KAHBAHMC@start?9point@			; `string'
PUBLIC	??_C@_09BKKFPLJK@end?9point@			; `string'
PUBLIC	??_C@_04NDJIBAID@here@				; `string'
PUBLIC	??_C@_07NGBELOAG@?5origin@			; `string'
PUBLIC	??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@ ; `string'
PUBLIC	??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@ ; `string'
PUBLIC	??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlNewTextLen:PROC
EXTRN	_xmlCopyNode:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddNextSibling:PROC
EXTRN	_xmlResetError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathObjectCopy:PROC
EXTRN	_xmlXPathCmpNodes:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathInit:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlSaveUri:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlXPathErr:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlXPathRegisterFunc:PROC
EXTRN	_xmlXPathNewParserContext:PROC
EXTRN	_xmlXPathFreeParserContext:PROC
EXTRN	_valuePop:PROC
EXTRN	_valuePush:PROC
EXTRN	_xmlXPathNewString:PROC
EXTRN	_xmlXPathNewNodeSet:PROC
EXTRN	_xmlXPathRoot:PROC
EXTRN	_xmlXPathEvalExpr:PROC
EXTRN	_xmlXPathParseName:PROC
EXTRN	_xmlXPathParseNCName:PROC
EXTRN	_xmlXPathEvaluatePredicateResult:PROC
EXTRN	_xmlXPathIdFunction:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ DB 'Internal erro'
	DB	'r at %s:%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xpointer.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@
CONST	SEGMENT
??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@ DB 'xmlXPt'
	DB	'rEval: object(s) left on the eval stack', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@
CONST	SEGMENT
??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@ DB 'xmlXPtrEval: '
	DB	'evaluation failed to return a node set', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGBELOAG@?5origin@
CONST	SEGMENT
??_C@_07NGBELOAG@?5origin@ DB ' origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NDJIBAID@here@
CONST	SEGMENT
??_C@_04NDJIBAID@here@ DB 'here', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKKFPLJK@end?9point@
CONST	SEGMENT
??_C@_09BKKFPLJK@end?9point@ DB 'end-point', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KAHBAHMC@start?9point@
CONST	SEGMENT
??_C@_0M@KAHBAHMC@start?9point@ DB 'start-point', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHPDEMLM@string?9range@
CONST	SEGMENT
??_C@_0N@NHPDEMLM@string?9range@ DB 'string-range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPBCPIBK@range?9inside@
CONST	SEGMENT
??_C@_0N@FPBCPIBK@range?9inside@ DB 'range-inside', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGOGOBM@range@
CONST	SEGMENT
??_C@_05CCGOGOBM@range@ DB 'range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@
CONST	SEGMENT
??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@ DB 'allocating evalua'
	DB	'tion context', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@
CONST	SEGMENT
??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@ DB 'warning: Chi'
	DB	'ldSeq not starting by /1', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@ DB 'unsupported sche'
	DB	'me ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element@
CONST	SEGMENT
??_C@_07HCLJNICE@element@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNJCJFMK@xpointer@
CONST	SEGMENT
??_C@_08DNJCJFMK@xpointer@ DB 'xpointer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
CONST	SEGMENT
??_C@_0BC@MDOPFBLJ@allocating?5buffer@ DB 'allocating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
CONST	SEGMENT
??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@ DB 'adding location to set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNICMPAH@allocating?5locationset@
CONST	SEGMENT
??_C@_0BH@HNICMPAH@allocating?5locationset@ DB 'allocating locationset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBEHJOM@allocating?5range@
CONST	SEGMENT
??_C@_0BB@PBEHJOM@allocating?5range@ DB 'allocating range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMDDEGKA@allocating?5point@
CONST	SEGMENT
??_C@_0BB@DMDDEGKA@allocating?5point@ DB 'allocating point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetEndPoint
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_node$ = 12						; size = 4
_indx$ = 16						; size = 4
_xmlXPtrGetEndPoint PROC				; COMDAT

; 2634 : xmlXPtrGetEndPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _obj$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPtrGet

; 2635 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlXPtrGet
	mov	esi, DWORD PTR _indx$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlXPtrGet

; 2637 : 
; 2638 :     switch (obj->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 5
	je	SHORT $LN6@xmlXPtrGet
	sub	eax, 1
	jne	SHORT $LN5@xmlXPtrGet
$LN6@xmlXPtrGet:

; 2639 :         case XPATH_POINT:
; 2640 : 	    *node = obj->user;
; 2641 : 	    if (obj->index <= 0)
; 2642 : 		*indx = 0;
; 2643 : 	    else
; 2644 : 		*indx = obj->index;
; 2645 : 	    return(0);
; 2646 :         case XPATH_RANGE:
; 2647 : 	    *node = obj->user;
; 2648 : 	    if (obj->index <= 0)
; 2649 : 		*indx = 0;
; 2650 : 	    else
; 2651 : 		*indx = obj->index;
; 2652 : 	    return(0);
; 2653 : 	default:
; 2654 : 	    break;
; 2655 :     }
; 2656 :     return(-1);
; 2657 : }

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx], eax
	xor	eax, eax
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	cmovg	eax, ecx
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPtrGet:

; 2636 : 	return(-1);

	or	eax, -1
	pop	esi

; 2639 :         case XPATH_POINT:
; 2640 : 	    *node = obj->user;
; 2641 : 	    if (obj->index <= 0)
; 2642 : 		*indx = 0;
; 2643 : 	    else
; 2644 : 		*indx = obj->index;
; 2645 : 	    return(0);
; 2646 :         case XPATH_RANGE:
; 2647 : 	    *node = obj->user;
; 2648 : 	    if (obj->index <= 0)
; 2649 : 		*indx = 0;
; 2650 : 	    else
; 2651 : 		*indx = obj->index;
; 2652 : 	    return(0);
; 2653 : 	default:
; 2654 : 	    break;
; 2655 :     }
; 2656 :     return(-1);
; 2657 : }

	pop	ebp
	ret	0
_xmlXPtrGetEndPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetStartPoint
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_node$ = 12						; size = 4
_indx$ = 16						; size = 4
_xmlXPtrGetStartPoint PROC				; COMDAT

; 2598 : xmlXPtrGetStartPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _obj$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPtrGet

; 2599 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	mov	edx, DWORD PTR _node$[ebp]
	test	edx, edx
	je	SHORT $LN5@xmlXPtrGet
	mov	esi, DWORD PTR _indx$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlXPtrGet

; 2601 : 
; 2602 :     switch (obj->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 5
	je	SHORT $LN6@xmlXPtrGet
	sub	eax, 1
	jne	SHORT $LN5@xmlXPtrGet
$LN6@xmlXPtrGet:

; 2603 :         case XPATH_POINT:
; 2604 : 	    *node = obj->user;
; 2605 : 	    if (obj->index <= 0)
; 2606 : 		*indx = 0;
; 2607 : 	    else
; 2608 : 		*indx = obj->index;
; 2609 : 	    return(0);
; 2610 :         case XPATH_RANGE:
; 2611 : 	    *node = obj->user;
; 2612 : 	    if (obj->index <= 0)
; 2613 : 		*indx = 0;
; 2614 : 	    else
; 2615 : 		*indx = obj->index;
; 2616 : 	    return(0);
; 2617 : 	default:
; 2618 : 	    break;
; 2619 :     }
; 2620 :     return(-1);
; 2621 : }

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx], eax
	xor	eax, eax
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	cmovg	eax, ecx
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPtrGet:

; 2600 : 	return(-1);

	or	eax, -1
	pop	esi

; 2603 :         case XPATH_POINT:
; 2604 : 	    *node = obj->user;
; 2605 : 	    if (obj->index <= 0)
; 2606 : 		*indx = 0;
; 2607 : 	    else
; 2608 : 		*indx = obj->index;
; 2609 : 	    return(0);
; 2610 :         case XPATH_RANGE:
; 2611 : 	    *node = obj->user;
; 2612 : 	    if (obj->index <= 0)
; 2613 : 		*indx = 0;
; 2614 : 	    else
; 2615 : 		*indx = obj->index;
; 2616 : 	    return(0);
; 2617 : 	default:
; 2618 : 	    break;
; 2619 :     }
; 2620 :     return(-1);
; 2621 : }

	pop	ebp
	ret	0
_xmlXPtrGetStartPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetLastChar
_TEXT	SEGMENT
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrGetLastChar PROC				; COMDAT

; 2552 : xmlXPtrGetLastChar(xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN5@xmlXPtrGet

; 2553 :     xmlNodePtr cur;
; 2554 :     int pos, len = 0;
; 2555 : 
; 2556 :     if ((node == NULL) || (*node == NULL) ||
; 2557 :         ((*node)->type == XML_NAMESPACE_DECL) || (indx == NULL))

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN5@xmlXPtrGet
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 18					; 00000012H
	je	SHORT $LN5@xmlXPtrGet
	mov	ebx, DWORD PTR _indx$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@xmlXPtrGet

; 2561 : 
; 2562 :     if ((cur->type == XML_ELEMENT_NODE) ||
; 2563 : 	(cur->type == XML_DOCUMENT_NODE) ||

	cmp	eax, 1
	je	SHORT $LN7@xmlXPtrGet
	cmp	eax, 9
	je	SHORT $LN7@xmlXPtrGet
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN15@xmlXPtrGet
$LN7@xmlXPtrGet:

; 2558 : 	return(-1);
; 2559 :     cur = *node;
; 2560 :     pos = *indx;

	mov	eax, DWORD PTR [ebx]

; 2564 : 	(cur->type == XML_HTML_DOCUMENT_NODE)) {
; 2565 : 	if (pos > 0) {

	test	eax, eax
	jle	SHORT $LN15@xmlXPtrGet

; 2566 : 	    cur = xmlXPtrGetNthChild(cur, pos);

	push	eax
	push	esi
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	esi, eax
$LN15@xmlXPtrGet:

; 2567 : 	}
; 2568 :     }
; 2569 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlXPtrGet
$LL2@xmlXPtrGet:

; 2570 : 	if (cur->last != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN9@xmlXPtrGet

; 2571 : 	    cur = cur->last;

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL2@xmlXPtrGet
$LN5@xmlXPtrGet:
	pop	edi

; 2585 : }

	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN9@xmlXPtrGet:

; 2572 : 	else if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN5@xmlXPtrGet
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN5@xmlXPtrGet

; 2573 : 	         (cur->content != NULL)) {
; 2574 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	add	esp, 4

; 2575 : 	    break;
; 2576 : 	} else {
; 2577 : 	    return(-1);
; 2578 : 	}
; 2579 :     }
; 2580 :     if (cur == NULL)
; 2581 : 	return(-1);
; 2582 :     *node = cur;

	mov	DWORD PTR [edi], esi

; 2583 :     *indx = len;

	mov	DWORD PTR [ebx], eax

; 2584 :     return(0);

	xor	eax, eax
	pop	edi

; 2585 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPtrGetLastChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrSearchString
_TEXT	SEGMENT
tv429 = -28						; size = 4
_len$1$ = -24						; size = 4
_pos$1$ = -20						; size = 4
_first$ = -16						; size = 1
_cur$1$ = -12						; size = 4
_string$1$ = -8						; size = 4
_pos$2$ = -4						; size = 4
_string$ = 8						; size = 4
_start$ = 12						; size = 4
_startindex$ = 16					; size = 4
_end$ = 20						; size = 4
_endindex$ = 24						; size = 4
_xmlXPtrSearchString PROC				; COMDAT

; 2468 : 	            xmlNodePtr *end, int *endindex) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _string$[ebp]
	test	ecx, ecx
	je	$LN8@xmlXPtrSea

; 2469 :     xmlNodePtr cur;
; 2470 :     const xmlChar *str;
; 2471 :     int pos; /* 0 based */
; 2472 :     int len; /* in bytes */
; 2473 :     xmlChar first;
; 2474 : 
; 2475 :     if (string == NULL)
; 2476 : 	return(-1);
; 2477 :     if ((start == NULL) || (*start == NULL) ||
; 2478 :         ((*start)->type == XML_NAMESPACE_DECL) || (startindex == NULL))

	mov	eax, DWORD PTR _start$[ebp]
	test	eax, eax
	je	$LN8@xmlXPtrSea
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _cur$1$[ebp], ebx
	test	ebx, ebx
	je	$LN8@xmlXPtrSea
	cmp	DWORD PTR [ebx+4], 18			; 00000012H
	je	$LN8@xmlXPtrSea
	mov	edx, DWORD PTR _startindex$[ebp]
	test	edx, edx
	je	$LN8@xmlXPtrSea

; 2480 :     if ((end == NULL) || (endindex == NULL))

	mov	edi, DWORD PTR _end$[ebp]
	test	edi, edi
	je	$LN8@xmlXPtrSea
	mov	eax, DWORD PTR _endindex$[ebp]
	test	eax, eax
	je	$LN8@xmlXPtrSea

; 2481 : 	return(-1);
; 2482 :     cur = *start;
; 2483 :     pos = *startindex - 1;
; 2484 :     first = string[0];

	mov	cl, BYTE PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [edx]
	dec	esi
	mov	BYTE PTR _first$[ebp], cl
	npad	7
$LL2@xmlXPtrSea:

; 2485 : 
; 2486 :     while (cur != NULL) {
; 2487 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	cmp	DWORD PTR [ebx+4], 1
	je	$LN61@xmlXPtrSea
	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	$LN66@xmlXPtrSea

; 2488 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$1$[ebp], eax

; 2489 : 	    while (pos <= len) {

	cmp	esi, eax
	jg	$LN66@xmlXPtrSea
	npad	7
$LL4@xmlXPtrSea:

; 2490 : 		if (first != 0) {

	cmp	BYTE PTR _first$[ebp], 0
	je	$LN12@xmlXPtrSea

; 2491 : 		    str = xmlStrchr(&cur->content[pos], first);

	mov	eax, DWORD PTR [ebx+40]
	push	DWORD PTR _first$[ebp]
	add	eax, esi
	push	eax
	call	_xmlStrchr
	mov	ecx, eax
	add	esp, 8

; 2492 : 		    if (str != NULL) {

	test	ecx, ecx
	je	$LN14@xmlXPtrSea

; 2493 : 			pos = (str - (xmlChar *)(cur->content));

	sub	ecx, DWORD PTR [ebx+40]

; 2393 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [ebx+4], 18			; 00000012H

; 2494 : #ifdef DEBUG_RANGES
; 2495 : 			xmlGenericError(xmlGenericErrorContext,
; 2496 : 				"found '%c' at index %d of ->",
; 2497 : 				first, pos + 1);
; 2498 : 			xmlDebugDumpString(stdout, cur->content);
; 2499 : 			xmlGenericError(xmlGenericErrorContext, "\n");
; 2500 : #endif
; 2501 : 			if (xmlXPtrMatchString(string, cur, pos + 1,

	mov	edx, DWORD PTR _string$[ebp]
	mov	DWORD PTR _pos$2$[ebp], ecx
	mov	DWORD PTR _string$1$[ebp], edx

; 2393 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	je	$LN58@xmlXPtrSea

; 2394 : 	return(-1);
; 2395 :     if ((end == NULL) || (*end == NULL) ||
; 2396 :         ((*end)->type == XML_NAMESPACE_DECL) || (endindex == NULL))

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN58@xmlXPtrSea
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	$LN58@xmlXPtrSea

; 2397 : 	return(-1);
; 2398 :     cur = start;
; 2399 :     pos = startindex - 1;

	mov	esi, ecx
	mov	edi, ebx

; 2400 :     stringlen = xmlStrlen(string);

	push	edx
	mov	DWORD PTR _pos$1$[ebp], esi
	call	_xmlStrlen
	mov	ebx, eax
	add	esp, 4

; 2401 : 
; 2402 :     while (stringlen > 0) {

	test	ebx, ebx
	jle	SHORT $LN63@xmlXPtrSea
$LL21@xmlXPtrSea:

; 2403 : 	if ((cur == *end) && (pos + stringlen > *endindex))

	mov	ecx, DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv429[ebp], eax
	cmp	edi, DWORD PTR [ecx]
	jne	SHORT $LN52@xmlXPtrSea
	mov	ecx, DWORD PTR _endindex$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jg	$LN43@xmlXPtrSea
$LN52@xmlXPtrSea:

; 2404 : 	    return(0);
; 2405 : 
; 2406 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	cmp	DWORD PTR [edi+4], 1
	je	SHORT $LN35@xmlXPtrSea
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN35@xmlXPtrSea

; 2407 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	mov	ecx, DWORD PTR [edi+40]
	mov	esi, eax
	mov	eax, DWORD PTR _pos$1$[ebp]
	add	esp, 4
	add	ecx, eax

; 2408 : 	    if (len >= pos + stringlen) {

	lea	edx, DWORD PTR [eax+ebx]
	cmp	esi, edx
	jge	SHORT $LN42@xmlXPtrSea

; 2421 : 		} else {
; 2422 : 		    return(0);
; 2423 : 		}
; 2424 : 	    } else {
; 2425 :                 int sub = len - pos;

	sub	esi, eax

; 2426 : 		match = (!xmlStrncmp(&cur->content[pos], string, sub));

	push	esi
	push	DWORD PTR _string$1$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2427 : 		if (match) {

	jne	SHORT $LN43@xmlXPtrSea

; 2428 : #ifdef DEBUG_RANGES
; 2429 : 		    xmlGenericError(xmlGenericErrorContext,
; 2430 : 			    "found subrange %d bytes at index %d of ->",
; 2431 : 			    sub, pos + 1);
; 2432 : 		    xmlDebugDumpString(stdout, cur->content);
; 2433 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2434 : #endif
; 2435 :                     string = &string[sub];

	add	DWORD PTR _string$1$[ebp], esi

; 2436 : 		    stringlen -= sub;

	sub	ebx, esi
$LN35@xmlXPtrSea:

; 2437 : 		} else {
; 2438 : 		    return(0);
; 2439 : 		}
; 2440 : 	    }
; 2441 : 	}
; 2442 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	edi
	call	_xmlXPtrAdvanceNode
	mov	edi, eax
	add	esp, 8

; 2443 : 	if (cur == NULL)

	test	edi, edi
	je	SHORT $LN43@xmlXPtrSea

; 2444 : 	    return(0);
; 2445 : 	pos = 0;

	xor	esi, esi
	mov	DWORD PTR _pos$1$[ebp], esi
	test	ebx, ebx
	jg	SHORT $LL21@xmlXPtrSea
$LN63@xmlXPtrSea:

; 2502 : 					       end, endindex)) {
; 2503 : 			    *start = cur;

	mov	ecx, DWORD PTR _pos$2$[ebp]
$LN58@xmlXPtrSea:
	lea	esi, DWORD PTR [ecx+1]
$LN44@xmlXPtrSea:
	mov	ecx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR _cur$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 2504 : 			    *startindex = pos + 1;
; 2505 : 			    return(1);

	mov	eax, 1
	mov	ecx, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [ecx], esi
	pop	esi
	pop	edi

; 2538 :     }
; 2539 :     return(0);
; 2540 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlXPtrSea:

; 2409 : 		match = (!xmlStrncmp(&cur->content[pos], string, stringlen));

	mov	esi, DWORD PTR _pos$2$[ebp]
	push	ebx
	push	DWORD PTR _string$1$[ebp]
	inc	esi
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2410 : 		if (match) {

	jne	SHORT $LN56@xmlXPtrSea

; 2411 : #ifdef DEBUG_RANGES
; 2412 : 		    xmlGenericError(xmlGenericErrorContext,
; 2413 : 			    "found range %d bytes at index %d of ->",
; 2414 : 			    stringlen, pos + 1);
; 2415 : 		    xmlDebugDumpString(stdout, cur->content);
; 2416 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2417 : #endif
; 2418 : 		    *end = cur;

	mov	eax, DWORD PTR _end$[ebp]

; 2419 : 		    *endindex = pos + stringlen;

	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR tv429[ebp]
	mov	DWORD PTR [ecx], eax

; 2420 : 		    return(1);

	jmp	SHORT $LN44@xmlXPtrSea
$LN43@xmlXPtrSea:

; 2506 : 			}
; 2507 : 			pos++;
; 2508 : 		    } else {

	mov	esi, DWORD PTR _pos$2$[ebp]
	inc	esi
$LN56@xmlXPtrSea:
	mov	ebx, DWORD PTR _cur$1$[ebp]
	mov	edi, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR _len$1$[ebp]
	jmp	SHORT $LN15@xmlXPtrSea
$LN14@xmlXPtrSea:

; 2509 : 			pos = len + 1;

	mov	eax, DWORD PTR _len$1$[ebp]
	lea	esi, DWORD PTR [eax+1]
$LN15@xmlXPtrSea:

; 2489 : 	    while (pos <= len) {

	cmp	esi, eax
	jle	$LL4@xmlXPtrSea
$LN66@xmlXPtrSea:

; 2528 : 		    return(1);
; 2529 : 		}
; 2530 : 	    }
; 2531 : 	}
; 2532 : 	if ((cur == *end) && (pos >= *endindex))

	mov	eax, DWORD PTR _endindex$[ebp]
$LN61@xmlXPtrSea:
	cmp	ebx, DWORD PTR [edi]
	jne	SHORT $LN17@xmlXPtrSea
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LN46@xmlXPtrSea
$LN17@xmlXPtrSea:

; 2533 : 	    return(0);
; 2534 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	ebx
	call	_xmlXPtrAdvanceNode
	mov	ebx, eax
	mov	DWORD PTR _cur$1$[ebp], eax
	add	esp, 8

; 2535 : 	if (cur == NULL)

	test	ebx, ebx
	je	SHORT $LN46@xmlXPtrSea

; 2537 : 	pos = 1;

	mov	eax, DWORD PTR _endindex$[ebp]
	mov	esi, 1
	jmp	$LL2@xmlXPtrSea
$LN12@xmlXPtrSea:

; 2510 : 		    }
; 2511 : 		} else {
; 2512 : 		    /*
; 2513 : 		     * An empty string is considered to match before each
; 2514 : 		     * character of the string-value and after the final
; 2515 : 		     * character.
; 2516 : 		     */
; 2517 : #ifdef DEBUG_RANGES
; 2518 : 		    xmlGenericError(xmlGenericErrorContext,
; 2519 : 			    "found '' at index %d of ->",
; 2520 : 			    pos + 1);
; 2521 : 		    xmlDebugDumpString(stdout, cur->content);
; 2522 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2523 : #endif
; 2524 : 		    *start = cur;

	mov	ecx, DWORD PTR _start$[ebp]

; 2525 : 		    *startindex = pos + 1;

	lea	eax, DWORD PTR [esi+1]
	pop	esi
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [ecx], eax

; 2526 : 		    *end = cur;
; 2527 : 		    *endindex = pos + 1;

	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [edi], ebx
	pop	edi

; 2538 :     }
; 2539 :     return(0);
; 2540 : }

	pop	ebx
	mov	DWORD PTR [ecx], eax
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@xmlXPtrSea:
	pop	esi
	pop	edi

; 2536 : 	    return(0);

	xor	eax, eax

; 2538 :     }
; 2539 :     return(0);
; 2540 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPtrSea:
	pop	edi

; 2479 : 	return(-1);

	or	eax, -1

; 2538 :     }
; 2539 :     return(0);
; 2540 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrSearchString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrMatchString
_TEXT	SEGMENT
tv281 = -8						; size = 4
_pos$1$ = -4						; size = 4
_string$ = 8						; size = 4
_start$ = 12						; size = 4
_startindex$ = 16					; size = 4
_end$ = 20						; size = 4
_endindex$ = 24						; size = 4
_xmlXPtrMatchString PROC				; COMDAT

; 2384 : 	            xmlNodePtr *end, int *endindex) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _string$[ebp]
	test	ecx, ecx
	je	$LN6@xmlXPtrMat

; 2385 :     xmlNodePtr cur;
; 2386 :     int pos; /* 0 based */
; 2387 :     int len; /* in bytes */
; 2388 :     int stringlen; /* in bytes */
; 2389 :     int match;
; 2390 : 
; 2391 :     if (string == NULL)
; 2392 : 	return(-1);
; 2393 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	mov	esi, DWORD PTR _start$[ebp]
	test	esi, esi
	je	$LN6@xmlXPtrMat
	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	$LN6@xmlXPtrMat

; 2395 :     if ((end == NULL) || (*end == NULL) ||
; 2396 :         ((*end)->type == XML_NAMESPACE_DECL) || (endindex == NULL))

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	$LN6@xmlXPtrMat
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	$LN6@xmlXPtrMat
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	$LN6@xmlXPtrMat
	cmp	DWORD PTR _endindex$[ebp], 0
	je	$LN6@xmlXPtrMat

; 2397 : 	return(-1);
; 2398 :     cur = start;
; 2399 :     pos = startindex - 1;

	push	ebx
	push	edi
	mov	edi, DWORD PTR _startindex$[ebp]
	dec	edi

; 2400 :     stringlen = xmlStrlen(string);

	push	ecx
	mov	DWORD PTR _pos$1$[ebp], edi
	call	_xmlStrlen
	mov	ebx, eax
	add	esp, 4

; 2401 : 
; 2402 :     while (stringlen > 0) {

	test	ebx, ebx
	jle	$LN3@xmlXPtrMat
$LL2@xmlXPtrMat:

; 2403 : 	if ((cur == *end) && (pos + stringlen > *endindex))

	mov	ecx, DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv281[ebp], eax
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN25@xmlXPtrMat
	mov	ecx, DWORD PTR _endindex$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jg	$LN22@xmlXPtrMat
$LN25@xmlXPtrMat:

; 2404 : 	    return(0);
; 2405 : 
; 2406 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN16@xmlXPtrMat
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN16@xmlXPtrMat

; 2407 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	mov	edx, DWORD PTR [esi+40]
	mov	edi, eax
	mov	eax, DWORD PTR _pos$1$[ebp]
	add	esp, 4
	add	edx, eax

; 2408 : 	    if (len >= pos + stringlen) {

	lea	ecx, DWORD PTR [eax+ebx]
	cmp	edi, ecx
	jge	SHORT $LN21@xmlXPtrMat

; 2421 : 		} else {
; 2422 : 		    return(0);
; 2423 : 		}
; 2424 : 	    } else {
; 2425 :                 int sub = len - pos;

	sub	edi, eax

; 2426 : 		match = (!xmlStrncmp(&cur->content[pos], string, sub));

	push	edi
	push	DWORD PTR _string$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2427 : 		if (match) {

	jne	SHORT $LN22@xmlXPtrMat

; 2428 : #ifdef DEBUG_RANGES
; 2429 : 		    xmlGenericError(xmlGenericErrorContext,
; 2430 : 			    "found subrange %d bytes at index %d of ->",
; 2431 : 			    sub, pos + 1);
; 2432 : 		    xmlDebugDumpString(stdout, cur->content);
; 2433 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2434 : #endif
; 2435 :                     string = &string[sub];

	add	DWORD PTR _string$[ebp], edi

; 2436 : 		    stringlen -= sub;

	sub	ebx, edi
$LN16@xmlXPtrMat:

; 2437 : 		} else {
; 2438 : 		    return(0);
; 2439 : 		}
; 2440 : 	    }
; 2441 : 	}
; 2442 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	esi
	call	_xmlXPtrAdvanceNode
	mov	esi, eax
	add	esp, 8

; 2443 : 	if (cur == NULL)

	test	esi, esi
	je	SHORT $LN22@xmlXPtrMat

; 2445 : 	pos = 0;

	xor	edi, edi
	mov	DWORD PTR _pos$1$[ebp], edi
	test	ebx, ebx
	jg	SHORT $LL2@xmlXPtrMat

; 2420 : 		    return(1);

	lea	eax, DWORD PTR [edi+1]
	pop	edi
	pop	ebx
	pop	esi

; 2446 :     }
; 2447 :     return(1);
; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXPtrMat:

; 2409 : 		match = (!xmlStrncmp(&cur->content[pos], string, stringlen));

	push	ebx
	push	DWORD PTR _string$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax

; 2410 : 		if (match) {

	jne	SHORT $LN22@xmlXPtrMat

; 2411 : #ifdef DEBUG_RANGES
; 2412 : 		    xmlGenericError(xmlGenericErrorContext,
; 2413 : 			    "found range %d bytes at index %d of ->",
; 2414 : 			    stringlen, pos + 1);
; 2415 : 		    xmlDebugDumpString(stdout, cur->content);
; 2416 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2417 : #endif
; 2418 : 		    *end = cur;

	mov	eax, DWORD PTR _end$[ebp]

; 2419 : 		    *endindex = pos + stringlen;

	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR tv281[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@xmlXPtrMat:

; 2420 : 		    return(1);

	pop	edi
	pop	ebx
	mov	eax, 1
	pop	esi

; 2446 :     }
; 2447 :     return(1);
; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlXPtrMat:
	pop	edi
	pop	ebx

; 2444 : 	    return(0);

	xor	eax, eax
	pop	esi

; 2446 :     }
; 2447 :     return(1);
; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPtrMat:

; 2394 : 	return(-1);

	or	eax, -1
	pop	esi

; 2446 :     }
; 2447 :     return(1);
; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrMatchString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrAdvanceChar
_TEXT	SEGMENT
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_bytes$ = 16						; size = 4
_xmlXPtrAdvanceChar PROC				; COMDAT

; 2294 : xmlXPtrAdvanceChar(xmlNodePtr *node, int *indx, int bytes) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPtrAdv

; 2295 :     xmlNodePtr cur;
; 2296 :     int pos;
; 2297 :     int len;
; 2298 : 
; 2299 :     if ((node == NULL) || (indx == NULL))

	mov	edx, DWORD PTR _indx$[ebp]
	test	edx, edx
	je	SHORT $LN7@xmlXPtrAdv

; 2300 : 	return(-1);
; 2301 :     cur = *node;

	mov	esi, DWORD PTR [ecx]

; 2302 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	test	esi, esi
	je	SHORT $LN7@xmlXPtrAdv
	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN7@xmlXPtrAdv

; 2303 : 	return(-1);
; 2304 :     pos = *indx;
; 2305 : 
; 2306 :     while (bytes >= 0) {

	mov	ebx, DWORD PTR _bytes$[ebp]
	mov	edi, DWORD PTR [edx]
	test	ebx, ebx
	js	SHORT $LN7@xmlXPtrAdv
$LL2@xmlXPtrAdv:

; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	test	esi, esi
	je	SHORT $LN24@xmlXPtrAdv
$LL4@xmlXPtrAdv:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN10@xmlXPtrAdv
	cmp	eax, 9
	je	SHORT $LN10@xmlXPtrAdv
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrAdv
$LN10@xmlXPtrAdv:

; 2312 : 	       ((cur->type == XML_ELEMENT_NODE) ||
; 2313 : 	        (cur->type == XML_DOCUMENT_NODE) ||
; 2314 : 	        (cur->type == XML_HTML_DOCUMENT_NODE))) {
; 2315 : 	    if (pos > 0) {

	test	edi, edi
	jle	SHORT $LN11@xmlXPtrAdv

; 2316 : 		cur = xmlXPtrGetNthChild(cur, pos);

	push	edi
	push	esi
	call	_xmlXPtrGetNthChild

; 2317 : 		pos = 0;
; 2318 : 	    } else {

	jmp	SHORT $LN36@xmlXPtrAdv
$LN11@xmlXPtrAdv:

; 2319 : 		cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	esi
	call	_xmlXPtrAdvanceNode
$LN36@xmlXPtrAdv:

; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	mov	esi, eax
	add	esp, 8
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LL4@xmlXPtrAdv
$LN24@xmlXPtrAdv:

; 2320 : 		pos = 0;
; 2321 : 	    }
; 2322 : 	}
; 2323 : 
; 2324 : 	if (cur == NULL) {
; 2325 : 	    *node = NULL;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx], 0

; 2326 : 	    *indx = 0;

	mov	ecx, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [ecx], 0
$LN7@xmlXPtrAdv:

; 2360 : 	    return(0);
; 2361 : 	}
; 2362 :     }
; 2363 :     return(-1);
; 2364 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN5@xmlXPtrAdv:

; 2327 : 	    return(-1);
; 2328 : 	}
; 2329 : 
; 2330 : 	/*
; 2331 : 	 * if there is no move needed return the current value.
; 2332 : 	 */
; 2333 : 	if (pos == 0) pos = 1;

	test	edi, edi
	mov	ecx, 1
	cmove	edi, ecx

; 2334 : 	if (bytes == 0) {

	test	ebx, ebx
	je	$LN25@xmlXPtrAdv

; 2338 : 	}
; 2339 : 	/*
; 2340 : 	 * We should have a text (or cdata) node ...
; 2341 : 	 */
; 2342 : 	len = 0;

	xor	ebx, ebx

; 2343 : 	if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	eax, ecx
	je	SHORT $LN16@xmlXPtrAdv
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN16@xmlXPtrAdv

; 2344 :             (cur->content != NULL)) {
; 2345 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	ebx, eax
$LN16@xmlXPtrAdv:

; 2346 : 	}
; 2347 : 	if (pos > len) {

	cmp	edi, ebx
	jle	SHORT $LN17@xmlXPtrAdv

; 2348 : 	    /* Strange, the indx in the text node is greater than it's len */
; 2349 : 	    STRANGE

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	2349					; 0000092dH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 16					; 00000010H

; 2350 : 	    pos = len;

	mov	edi, ebx
$LN17@xmlXPtrAdv:

; 2351 : 	}
; 2352 : 	if (pos + bytes >= len) {

	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, edi
	cmp	eax, ebx
	jl	SHORT $LN26@xmlXPtrAdv

; 2353 : 	    bytes -= (len - pos);

	sub	edi, ebx
	mov	ebx, DWORD PTR _bytes$[ebp]

; 2354 : 	    cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	add	ebx, edi
	push	esi
	mov	DWORD PTR _bytes$[ebp], ebx
	call	_xmlXPtrAdvanceNode
	add	esp, 8

; 2355 : 	    pos = 0;

	xor	edi, edi
	mov	esi, eax
	test	ebx, ebx
	jns	$LL2@xmlXPtrAdv

; 2360 : 	    return(0);
; 2361 : 	}
; 2362 :     }
; 2363 :     return(-1);
; 2364 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN26@xmlXPtrAdv:

; 2356 : 	} else if (pos + bytes < len) {
; 2357 : 	    pos += bytes;
; 2358 : 	    *node = cur;

	mov	ecx, DWORD PTR _node$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], esi

; 2359 : 	    *indx = pos;

	mov	ecx, DWORD PTR _indx$[ebp]

; 2360 : 	    return(0);
; 2361 : 	}
; 2362 :     }
; 2363 :     return(-1);
; 2364 : }

	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
	xor	eax, eax
	pop	ebp
	ret	0
$LN25@xmlXPtrAdv:

; 2335 : 	    *node = cur;

	mov	ecx, DWORD PTR _node$[ebp]

; 2336 : 	    *indx = pos;
; 2337 : 	    return(0);

	xor	eax, eax
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [ecx], edi
	pop	edi

; 2360 : 	    return(0);
; 2361 : 	}
; 2362 :     }
; 2363 :     return(-1);
; 2364 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_xmlXPtrAdvanceChar ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrInsideRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_loc$ = 12						; size = 4
_xmlXPtrInsideRange PROC				; COMDAT

; 2073 : xmlXPtrInsideRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _loc$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlXPtrIns

; 2074 :     if (loc == NULL)
; 2075 : 	return(NULL);
; 2076 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@xmlXPtrIns
	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	je	SHORT $LN10@xmlXPtrIns
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN10@xmlXPtrIns

; 2077 : 	(ctxt->context->doc == NULL))
; 2078 : 	return(NULL);
; 2079 :     switch (loc->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 5
	je	SHORT $LN11@xmlXPtrIns
	sub	ecx, 1
	je	SHORT $LN17@xmlXPtrIns

; 2115 : 		    case XML_PI_NODE:
; 2116 : 		    case XML_COMMENT_NODE:
; 2117 : 		    case XML_TEXT_NODE:
; 2118 : 		    case XML_CDATA_SECTION_NODE: {
; 2119 : 			if (node->content == NULL) {
; 2120 : 			    return(xmlXPtrNewRange(node, 0, node, 0));
; 2121 : 			} else {
; 2122 : 			    return(xmlXPtrNewRange(node, 0, node,
; 2123 : 						   xmlStrlen(node->content)));
; 2124 : 			}
; 2125 : 		    }
; 2126 : 		    case XML_ATTRIBUTE_NODE:
; 2127 : 		    case XML_ELEMENT_NODE:
; 2128 : 		    case XML_ENTITY_REF_NODE:
; 2129 : 		    case XML_DOCUMENT_NODE:
; 2130 : 		    case XML_NOTATION_NODE:
; 2131 : 		    case XML_HTML_DOCUMENT_NODE: {
; 2132 : 			return(xmlXPtrNewRange(node, 0, node,
; 2133 : 					       xmlXPtrGetArity(node)));
; 2134 : 		    }
; 2135 : 		    default:
; 2136 : 			break;
; 2137 : 		}
; 2138 : 		return(NULL);
; 2139 : 	    }
; 2140 :         }
; 2141 : 	default:
; 2142 : 	    TODO /* missed one case ??? */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2142					; 0000085eH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN10@xmlXPtrIns:

; 2143 :     }
; 2144 :     return(NULL);
; 2145 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN17@xmlXPtrIns:

; 2083 : 		case XML_PI_NODE:
; 2084 : 		case XML_COMMENT_NODE:
; 2085 : 		case XML_TEXT_NODE:
; 2086 : 		case XML_CDATA_SECTION_NODE: {
; 2087 : 		    if (node->content == NULL) {
; 2088 : 			return(xmlXPtrNewRange(node, 0, node, 0));
; 2089 : 		    } else {
; 2090 : 			return(xmlXPtrNewRange(node, 0, node,
; 2091 : 					       xmlStrlen(node->content)));
; 2092 : 		    }
; 2093 : 		}
; 2094 : 		case XML_ATTRIBUTE_NODE:
; 2095 : 		case XML_ELEMENT_NODE:
; 2096 : 		case XML_ENTITY_REF_NODE:
; 2097 : 		case XML_DOCUMENT_NODE:
; 2098 : 		case XML_NOTATION_NODE:
; 2099 : 		case XML_HTML_DOCUMENT_NODE: {
; 2100 : 		    return(xmlXPtrNewRange(node, 0, node,
; 2101 : 					   xmlXPtrGetArity(node)));
; 2102 : 		}
; 2103 : 		default:
; 2104 : 		    break;
; 2105 : 	    }
; 2106 : 	    return(NULL);
; 2107 : 	}
; 2108 :         case XPATH_RANGE: {
; 2109 : 	    xmlNodePtr node = (xmlNodePtr) loc->user;
; 2110 : 	    if (loc->user2 != NULL) {

	mov	ecx, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN18@xmlXPtrIns

; 2111 : 		return(xmlXPtrNewRange(node, loc->index,

	push	DWORD PTR [eax+40]
	push	ecx
	push	DWORD PTR [eax+32]
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	pop	esi

; 2143 :     }
; 2144 :     return(NULL);
; 2145 : }

	pop	ebp
	ret	0
$LN18@xmlXPtrIns:

; 2112 : 			               loc->user2, loc->index2));
; 2113 : 	    } else {
; 2114 : 		switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN10@xmlXPtrIns
	movzx	eax, BYTE PTR $LN39@xmlXPtrIns[eax]
	jmp	DWORD PTR $LN44@xmlXPtrIns[eax*4]
$LN11@xmlXPtrIns:

; 2080 :         case XPATH_POINT: {
; 2081 : 	    xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	esi, DWORD PTR [eax+28]

; 2082 : 	    switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN10@xmlXPtrIns
	movzx	eax, BYTE PTR $LN40@xmlXPtrIns[eax]
	jmp	DWORD PTR $LN45@xmlXPtrIns[eax*4]
$LN12@xmlXPtrIns:

; 2143 :     }
; 2144 :     return(NULL);
; 2145 : }

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN13@xmlXPtrIns
	push	eax
	push	esi
	push	eax
	push	esi
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax
	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	0
$LN13@xmlXPtrIns:
	push	eax
	call	_xmlStrlen
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebp
	ret	0
$LN14@xmlXPtrIns:
	push	esi
	call	_xmlXPtrGetArity
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebp
	ret	0
	npad	1
$LN44@xmlXPtrIns:
	DD	$LN14@xmlXPtrIns
	DD	$LN12@xmlXPtrIns
	DD	$LN10@xmlXPtrIns
$LN39@xmlXPtrIns:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
	npad	3
$LN45@xmlXPtrIns:
	DD	$LN14@xmlXPtrIns
	DD	$LN12@xmlXPtrIns
	DD	$LN10@xmlXPtrIns
$LN40@xmlXPtrIns:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrInsideRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrCoveringRange
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_loc$ = 12						; size = 4
_xmlXPtrCoveringRange PROC				; COMDAT

; 1949 : xmlXPtrCoveringRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _loc$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@xmlXPtrCov

; 1950 :     if (loc == NULL)
; 1951 : 	return(NULL);
; 1952 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN8@xmlXPtrCov
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN8@xmlXPtrCov
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN8@xmlXPtrCov

; 1953 : 	(ctxt->context->doc == NULL))
; 1954 : 	return(NULL);
; 1955 :     switch (loc->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 5
	je	$LN9@xmlXPtrCov
	sub	eax, 1
	je	SHORT $LN10@xmlXPtrCov

; 1987 : 					           node, indx + 1));
; 1988 : 			}
; 1989 : 			default:
; 1990 : 			    return(NULL);
; 1991 : 		    }
; 1992 : 		}
; 1993 : 	    }
; 1994 : 	default:
; 1995 : 	    TODO /* missed one case ??? */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1995					; 000007cbH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN8@xmlXPtrCov:

; 1996 :     }
; 1997 :     return(NULL);
; 1998 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN10@xmlXPtrCov:

; 1958 : 			           loc->user, loc->index));
; 1959 :         case XPATH_RANGE:
; 1960 : 	    if (loc->user2 != NULL) {

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN11@xmlXPtrCov

; 1961 : 		return(xmlXPtrNewRange(loc->user, loc->index,

	push	DWORD PTR [ecx+40]
	push	eax
	push	DWORD PTR [ecx+32]
	push	DWORD PTR [ecx+28]
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	pop	esi

; 1996 :     }
; 1997 :     return(NULL);
; 1998 : }

	pop	ebp
	ret	0
$LN11@xmlXPtrCov:

; 1962 : 			              loc->user2, loc->index2));
; 1963 : 	    } else {
; 1964 : 		xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	esi, DWORD PTR [ecx+28]

; 1965 : 		if (node == (xmlNodePtr) ctxt->context->doc) {

	cmp	esi, edx
	je	SHORT $LN15@xmlXPtrCov

; 1966 : 		    return(xmlXPtrNewRange(node, 0, node,
; 1967 : 					   xmlXPtrGetArity(node)));
; 1968 : 		} else {
; 1969 : 		    switch (node->type) {

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ecx-1]
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN8@xmlXPtrCov
	movzx	eax, BYTE PTR $LN33@xmlXPtrCov[eax]
	jmp	DWORD PTR $LN35@xmlXPtrCov[eax*4]
$LN15@xmlXPtrCov:

; 1996 :     }
; 1997 :     return(NULL);
; 1998 : }

	push	esi
	call	_xmlXPtrGetArity
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebp
	ret	0
$LN16@xmlXPtrCov:

; 1970 : 			case XML_ATTRIBUTE_NODE:
; 1971 : 			/* !!! our model is slightly different than XPath */
; 1972 : 			    return(xmlXPtrNewRange(node, 0, node,
; 1973 : 					           xmlXPtrGetArity(node)));
; 1974 : 			case XML_ELEMENT_NODE:
; 1975 : 			case XML_TEXT_NODE:
; 1976 : 			case XML_CDATA_SECTION_NODE:
; 1977 : 			case XML_ENTITY_REF_NODE:
; 1978 : 			case XML_PI_NODE:
; 1979 : 			case XML_COMMENT_NODE:
; 1980 : 			case XML_DOCUMENT_NODE:
; 1981 : 			case XML_NOTATION_NODE:
; 1982 : 			case XML_HTML_DOCUMENT_NODE: {
; 1983 : 			    int indx = xmlXPtrGetIndex(node);

	mov	eax, esi

; 169  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	ecx, 18					; 00000012H
	je	SHORT $LN25@xmlXPtrCov

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	edx, 1
$LL23@xmlXPtrCov:

; 172  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 173  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN27@xmlXPtrCov
	cmp	ecx, 9
	je	SHORT $LN27@xmlXPtrCov
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN21@xmlXPtrCov
$LN27@xmlXPtrCov:

; 174  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 175  : 	    i++;

	inc	edx
$LN21@xmlXPtrCov:

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL23@xmlXPtrCov

; 176  : 	}
; 177  :     }
; 178  :     return(i);

	jmp	SHORT $LN20@xmlXPtrCov
$LN25@xmlXPtrCov:

; 170  : 	return(-1);

	or	edx, -1
$LN20@xmlXPtrCov:

; 1984 : 
; 1985 : 			    node = node->parent;

	mov	ecx, DWORD PTR [esi+20]

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	lea	eax, DWORD PTR [edx+1]
	push	eax
	push	ecx
	lea	eax, DWORD PTR [edx-1]
	push	eax
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	pop	esi

; 1996 :     }
; 1997 :     return(NULL);
; 1998 : }

	pop	ebp
	ret	0
$LN9@xmlXPtrCov:

; 1956 :         case XPATH_POINT:
; 1957 : 	    return(xmlXPtrNewRange(loc->user, loc->index,

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [ecx+28]
	push	eax
	push	ecx
	push	eax
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	pop	esi

; 1996 :     }
; 1997 :     return(NULL);
; 1998 : }

	pop	ebp
	ret	0
$LN35@xmlXPtrCov:
	DD	$LN16@xmlXPtrCov
	DD	$LN15@xmlXPtrCov
	DD	$LN8@xmlXPtrCov
$LN33@xmlXPtrCov:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrCoveringRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNbLocChildren
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlXPtrNbLocChildren PROC				; COMDAT

; 1676 : xmlXPtrNbLocChildren(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _node$[ebp]
	xor	ecx, ecx
	test	edx, edx
	je	SHORT $LN11@xmlXPtrNbL

; 1677 :     int ret = 0;
; 1678 :     if (node == NULL)
; 1679 : 	return(-1);
; 1680 :     switch (node->type) {

	mov	eax, DWORD PTR [edx+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN11@xmlXPtrNbL
	movzx	eax, BYTE PTR $LN17@xmlXPtrNbL[eax]
	jmp	DWORD PTR $LN19@xmlXPtrNbL[eax*4]
$LN7@xmlXPtrNbL:

; 1681 :         case XML_HTML_DOCUMENT_NODE:
; 1682 :         case XML_DOCUMENT_NODE:
; 1683 :         case XML_ELEMENT_NODE:
; 1684 : 	    node = node->children;

	mov	edx, DWORD PTR [edx+12]

; 1685 : 	    while (node != NULL) {

	test	edx, edx
	je	SHORT $LN2@xmlXPtrNbL
$LL4@xmlXPtrNbL:

; 1686 : 		if (node->type == XML_ELEMENT_NODE)
; 1687 : 		    ret++;
; 1688 : 		node = node->next;

	cmp	DWORD PTR [edx+4], 1
	lea	eax, DWORD PTR [ecx+1]
	mov	edx, DWORD PTR [edx+24]
	cmovne	eax, ecx
	mov	ecx, eax
	test	edx, edx
	jne	SHORT $LL4@xmlXPtrNbL

; 1705 : }

	pop	ebp
	ret	0
$LN10@xmlXPtrNbL:

; 1689 : 	    }
; 1690 : 	    break;
; 1691 :         case XML_ATTRIBUTE_NODE:
; 1692 : 	    return(-1);
; 1693 : 
; 1694 :         case XML_PI_NODE:
; 1695 :         case XML_COMMENT_NODE:
; 1696 :         case XML_TEXT_NODE:
; 1697 :         case XML_CDATA_SECTION_NODE:
; 1698 :         case XML_ENTITY_REF_NODE:
; 1699 : 	    ret = xmlStrlen(node->content);

	push	DWORD PTR [edx+40]
	call	_xmlStrlen
	add	esp, 4
	mov	ecx, eax
$LN2@xmlXPtrNbL:

; 1703 :     }
; 1704 :     return(ret);

	mov	eax, ecx

; 1705 : }

	pop	ebp
	ret	0
$LN11@xmlXPtrNbL:

; 1700 : 	    break;
; 1701 : 	default:
; 1702 : 	    return(-1);

	or	eax, -1

; 1705 : }

	pop	ebp
	ret	0
	npad	1
$LN19@xmlXPtrNbL:
	DD	$LN7@xmlXPtrNbL
	DD	$LN11@xmlXPtrNbL
	DD	$LN10@xmlXPtrNbL
	DD	$LN11@xmlXPtrNbL
$LN17@xmlXPtrNbL:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	3
	DB	2
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	0
_xmlXPtrNbLocChildren ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrBuildRangeNodeList
_TEXT	SEGMENT
_tmp$4$ = -24						; size = 4
_end$1$ = -20						; size = 4
_start$1$ = -16						; size = 4
$T1 = -12						; size = 4
_tmp$1$ = -8						; size = 4
_last$1$ = -8						; size = 4
_parent$1$ = -4						; size = 4
_index1$1$ = 8						; size = 4
_range$ = 8						; size = 4
_xmlXPtrBuildRangeNodeList PROC				; COMDAT

; 1409 : xmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _range$[ebp]
	xor	esi, esi
	xor	edx, edx
	mov	DWORD PTR _last$1$[ebp], esi
	xor	ebx, ebx
	mov	DWORD PTR _parent$1$[ebp], edx
	test	eax, eax
	je	$LN9@xmlXPtrBui

; 1410 :     /* pointers to generated nodes */
; 1411 :     xmlNodePtr list = NULL, last = NULL, parent = NULL, tmp;
; 1412 :     /* pointers to traversal nodes */
; 1413 :     xmlNodePtr start, cur, end;
; 1414 :     int index1, index2;
; 1415 : 
; 1416 :     if (range == NULL)
; 1417 : 	return(NULL);
; 1418 :     if (range->type != XPATH_RANGE)

	cmp	DWORD PTR [eax], 6
	jne	$LN9@xmlXPtrBui

; 1419 : 	return(NULL);
; 1420 :     start = (xmlNodePtr) range->user;

	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _start$1$[ebp], ecx

; 1421 : 
; 1422 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	test	ecx, ecx
	je	$LN9@xmlXPtrBui
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	$LN9@xmlXPtrBui

; 1423 : 	return(NULL);
; 1424 :     end = range->user2;

	mov	edi, DWORD PTR [eax+36]
	mov	DWORD PTR _end$1$[ebp], edi

; 1425 :     if (end == NULL)

	test	edi, edi
	jne	SHORT $LN10@xmlXPtrBui

; 1426 : 	return(xmlCopyNode(start, 1));

	push	1
	push	ecx
	call	_xmlCopyNode
	add	esp, 8
	pop	edi

; 1567 :     }
; 1568 :     return(list);
; 1569 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPtrBui:

; 1427 :     if (end->type == XML_NAMESPACE_DECL)

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	$LN9@xmlXPtrBui

; 1428 :         return(NULL);
; 1429 : 
; 1430 :     cur = start;

	mov	edi, ecx

; 1431 :     index1 = range->index;

	mov	ecx, DWORD PTR [eax+32]

; 1432 :     index2 = range->index2;

	mov	eax, DWORD PTR [eax+40]
	mov	DWORD PTR _index1$1$[ebp], ecx
	mov	DWORD PTR $T1[ebp], eax
	npad	1
$LL2@xmlXPtrBui:

; 1434 : 	if (cur == end) {

	cmp	edi, DWORD PTR _end$1$[ebp]
	jne	$LN12@xmlXPtrBui

; 1435 : 	    if (cur->type == XML_TEXT_NODE) {

	cmp	DWORD PTR [edi+4], 3
	je	$LN55@xmlXPtrBui

; 1461 : 	    } else {
; 1462 : 		tmp = xmlCopyNode(cur, 0);

	push	0
	push	edi
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$1$[ebp], eax

; 1463 : 		if (list == NULL)

	test	ebx, ebx
	jne	SHORT $LN23@xmlXPtrBui

; 1464 : 		    list = tmp;

	mov	ebx, eax
	jmp	SHORT $LN26@xmlXPtrBui
$LN23@xmlXPtrBui:

; 1465 : 		else {
; 1466 : 		    if (last != NULL)

	push	eax
	test	esi, esi
	je	SHORT $LN25@xmlXPtrBui

; 1467 : 			xmlAddNextSibling(last, tmp);

	push	esi
	call	_xmlAddNextSibling
	jmp	SHORT $LN65@xmlXPtrBui
$LN25@xmlXPtrBui:

; 1468 : 		    else
; 1469 : 			xmlAddChild(parent, tmp);

	mov	ecx, DWORD PTR _parent$1$[ebp]
	push	ecx
	call	_xmlAddChild
$LN65@xmlXPtrBui:

; 1470 : 		}
; 1471 : 		last = NULL;

	mov	eax, DWORD PTR _tmp$1$[ebp]
	add	esp, 8
$LN26@xmlXPtrBui:
	xor	esi, esi

; 1472 : 		parent = tmp;

	mov	DWORD PTR _parent$1$[ebp], eax

; 1473 : 
; 1474 : 		if (index2 > 1) {

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _last$1$[ebp], esi
	cmp	eax, 1
	jle	SHORT $LN27@xmlXPtrBui

; 1475 : 		    end = xmlXPtrGetNthChild(cur, index2 - 1);

	dec	eax
	push	eax
	push	edi
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _end$1$[ebp], eax

; 1476 : 		    index2 = 0;

	xor	eax, eax
	mov	DWORD PTR $T1[ebp], eax
$LN27@xmlXPtrBui:

; 1477 : 		}
; 1478 : 		if ((cur == start) && (index1 > 1)) {

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	SHORT $LN28@xmlXPtrBui
	mov	eax, DWORD PTR _index1$1$[ebp]
	cmp	eax, 1
	jle	SHORT $LN28@xmlXPtrBui

; 1479 : 		    cur = xmlXPtrGetNthChild(cur, index1 - 1);

	dec	eax
	push	eax
	push	edi
	call	_xmlXPtrGetNthChild
	add	esp, 8

; 1480 : 		    index1 = 0;

	xor	ecx, ecx
	mov	DWORD PTR _index1$1$[ebp], ecx

; 1481 : 		} else {

	jmp	$LN66@xmlXPtrBui
$LN28@xmlXPtrBui:

; 1482 : 		    cur = cur->children;

	mov	edi, DWORD PTR [edi+12]

; 1483 : 		}
; 1484 : 		/*
; 1485 : 		 * Now gather the remaining nodes from cur to end
; 1486 : 		 */
; 1487 : 		continue; /* while */

	mov	ecx, DWORD PTR _index1$1$[ebp]
	jmp	$LN58@xmlXPtrBui
$LN12@xmlXPtrBui:

; 1488 : 	    }
; 1489 : 	} else if ((cur == start) &&

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	$LN30@xmlXPtrBui
	test	ebx, ebx
	jne	$LN30@xmlXPtrBui

; 1490 : 		   (list == NULL) /* looks superfluous but ... */ ) {
; 1491 : 	    if ((cur->type == XML_TEXT_NODE) ||

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 3
	je	SHORT $LN34@xmlXPtrBui
	cmp	eax, 4
	je	SHORT $LN34@xmlXPtrBui

; 1502 : 		}
; 1503 : 		last = list = tmp;
; 1504 : 	    } else {
; 1505 : 		if ((cur == start) && (index1 > 1)) {

	cmp	ecx, 1
	jle	SHORT $LN38@xmlXPtrBui

; 1506 : 		    tmp = xmlCopyNode(cur, 0);

	push	ebx
	push	edi
	call	_xmlCopyNode
	mov	ebx, eax

; 1507 : 		    list = tmp;
; 1508 : 		    parent = tmp;
; 1509 : 		    last = NULL;

	xor	esi, esi

; 1510 : 		    cur = xmlXPtrGetNthChild(cur, index1 - 1);

	mov	eax, DWORD PTR _index1$1$[ebp]
	dec	eax
	mov	DWORD PTR _parent$1$[ebp], ebx
	push	eax
	push	edi
	mov	DWORD PTR _last$1$[ebp], esi
	call	_xmlXPtrGetNthChild
	add	esp, 16					; 00000010H

; 1511 : 		    index1 = 0;

	xor	ecx, ecx
	mov	DWORD PTR _index1$1$[ebp], ecx

; 1512 : 		    /*
; 1513 : 		     * Now gather the remaining nodes from cur to end
; 1514 : 		     */
; 1515 : 		    continue; /* while */

	jmp	$LN66@xmlXPtrBui
$LN38@xmlXPtrBui:

; 1516 : 		}
; 1517 : 		tmp = xmlCopyNode(cur, 1);

	push	1
	push	edi
	call	_xmlCopyNode

; 1518 : 		list = tmp;
; 1519 : 		parent = NULL;
; 1520 : 		last = tmp;
; 1521 : 	    }
; 1522 : 	} else {

	mov	ebx, eax
	add	esp, 8
	xor	edx, edx
	mov	esi, ebx
	mov	DWORD PTR _parent$1$[ebp], edx
	mov	DWORD PTR _last$1$[ebp], esi
	jmp	$LN48@xmlXPtrBui
$LN34@xmlXPtrBui:

; 1492 : 		(cur->type == XML_CDATA_SECTION_NODE)) {
; 1493 : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR [edi+40]

; 1494 : 
; 1495 : 		if (content == NULL) {

	test	eax, eax
	jne	SHORT $LN35@xmlXPtrBui

; 1496 : 		    tmp = xmlNewTextLen(NULL, 0);

	push	eax
	push	eax
	call	_xmlNewTextLen
	mov	edx, DWORD PTR _parent$1$[ebp]

; 1518 : 		list = tmp;
; 1519 : 		parent = NULL;
; 1520 : 		last = tmp;
; 1521 : 	    }
; 1522 : 	} else {

	mov	ebx, eax
	mov	esi, ebx
	add	esp, 8
	mov	DWORD PTR _last$1$[ebp], esi
	jmp	$LN48@xmlXPtrBui
$LN35@xmlXPtrBui:

; 1497 : 		} else {
; 1498 : 		    if (index1 > 1) {

	cmp	ecx, 1
	jle	SHORT $LN37@xmlXPtrBui

; 1499 : 			content += (index1 - 1);

	dec	eax
	add	eax, ecx
$LN37@xmlXPtrBui:

; 1500 : 		    }
; 1501 : 		    tmp = xmlNewText(content);

	push	eax
	call	_xmlNewText
	mov	edx, DWORD PTR _parent$1$[ebp]

; 1518 : 		list = tmp;
; 1519 : 		parent = NULL;
; 1520 : 		last = tmp;
; 1521 : 	    }
; 1522 : 	} else {

	mov	ebx, eax
	mov	esi, ebx
	add	esp, 4
	mov	DWORD PTR _last$1$[ebp], esi
	jmp	$LN48@xmlXPtrBui
$LN30@xmlXPtrBui:

; 1523 : 	    tmp = NULL;
; 1524 : 	    switch (cur->type) {

	mov	eax, DWORD PTR [edi+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 18					; 00000012H
	ja	SHORT $LN43@xmlXPtrBui
	movzx	eax, BYTE PTR $LN63@xmlXPtrBui[eax]
	jmp	DWORD PTR $LN73@xmlXPtrBui[eax*4]
$LN40@xmlXPtrBui:

; 1525 : 		case XML_DTD_NODE:
; 1526 : 		case XML_ELEMENT_DECL:
; 1527 : 		case XML_ATTRIBUTE_DECL:
; 1528 : 		case XML_ENTITY_NODE:
; 1529 : 		    /* Do not copy DTD informations */
; 1530 : 		    break;
; 1531 : 		case XML_ENTITY_DECL:
; 1532 : 		    TODO /* handle crossing entities -> stack needed */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1532					; 000005fcH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 1533 : 		    break;

	mov	esi, DWORD PTR _last$1$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN64@xmlXPtrBui
$LN42@xmlXPtrBui:

; 1534 : 		case XML_XINCLUDE_START:
; 1535 : 		case XML_XINCLUDE_END:
; 1536 : 		    /* don't consider it part of the tree content */
; 1537 : 		    break;
; 1538 : 		case XML_ATTRIBUTE_NODE:
; 1539 : 		    /* Humm, should not happen ! */
; 1540 : 		    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1540					; 00000604H
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax

; 1541 : 		    break;

	mov	esi, DWORD PTR _last$1$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN64@xmlXPtrBui
$LN43@xmlXPtrBui:

; 1542 : 		default:
; 1543 : 		    tmp = xmlCopyNode(cur, 1);

	push	1
	push	edi
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$4$[ebp], eax

; 1544 : 		    break;
; 1545 : 	    }
; 1546 : 	    if (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN64@xmlXPtrBui

; 1547 : 		if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {

	test	ebx, ebx
	je	$LN56@xmlXPtrBui
	test	esi, esi
	jne	SHORT $LN61@xmlXPtrBui
	mov	ecx, DWORD PTR _parent$1$[ebp]
	test	ecx, ecx
	je	$LN56@xmlXPtrBui

; 1553 : 		else {
; 1554 : 		    xmlAddChild(parent, tmp);

	push	eax
	push	ecx
	call	_xmlAddChild

; 1555 : 		    last = tmp;

	mov	esi, DWORD PTR _tmp$4$[ebp]
	mov	DWORD PTR _last$1$[ebp], esi
	jmp	SHORT $LN70@xmlXPtrBui
$LN61@xmlXPtrBui:

; 1550 : 		}
; 1551 : 		if (last != NULL)
; 1552 : 		    xmlAddNextSibling(last, tmp);

	push	eax
	push	esi
	call	_xmlAddNextSibling
$LN70@xmlXPtrBui:

; 1556 : 		}
; 1557 : 	    }
; 1558 : 	}
; 1559 : 	/*
; 1560 : 	 * Skip to next node in document order
; 1561 : 	 */
; 1562 : 	if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {

	add	esp, 8
$LN64@xmlXPtrBui:
	mov	edx, DWORD PTR _parent$1$[ebp]
$LN48@xmlXPtrBui:
	test	ebx, ebx
	je	$LN57@xmlXPtrBui
	test	esi, esi
	jne	SHORT $LN49@xmlXPtrBui
	test	edx, edx
	je	$LN57@xmlXPtrBui
$LN49@xmlXPtrBui:

; 1564 : 	    return(NULL);
; 1565 : 	}
; 1566 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	edi
	call	_xmlXPtrAdvanceNode
	mov	ecx, DWORD PTR _index1$1$[ebp]
	add	esp, 8
$LN66@xmlXPtrBui:

; 1433 :     while (cur != NULL) {

	mov	edi, eax
$LN58@xmlXPtrBui:
	test	edi, edi
	je	SHORT $LN62@xmlXPtrBui
	mov	edx, DWORD PTR _parent$1$[ebp]
	jmp	$LL2@xmlXPtrBui
$LN55@xmlXPtrBui:

; 1436 : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR [edi+40]

; 1437 : 		int len;
; 1438 : 
; 1439 : 		if (content == NULL) {

	test	eax, eax
	jne	SHORT $LN16@xmlXPtrBui

; 1440 : 		    tmp = xmlNewTextLen(NULL, 0);

	xor	edx, edx

; 1441 : 		} else {

	jmp	SHORT $LN19@xmlXPtrBui
$LN16@xmlXPtrBui:

; 1442 : 		    len = index2;
; 1443 : 		    if ((cur == start) && (index1 > 1)) {

	cmp	edi, DWORD PTR _start$1$[ebp]
	jne	SHORT $LN18@xmlXPtrBui
	cmp	ecx, 1
	jle	SHORT $LN18@xmlXPtrBui

; 1444 : 			content += (index1 - 1);
; 1445 : 			len -= (index1 - 1);

	mov	edx, DWORD PTR $T1[ebp]
	dec	eax
	sub	edx, ecx
	add	eax, ecx
	inc	edx

; 1446 : 			index1 = 0;
; 1447 : 		    } else {

	jmp	SHORT $LN19@xmlXPtrBui
$LN18@xmlXPtrBui:

; 1448 : 			len = index2;

	mov	edx, DWORD PTR $T1[ebp]
$LN19@xmlXPtrBui:

; 1449 : 		    }
; 1450 : 		    tmp = xmlNewTextLen(content, len);
; 1451 : 		}
; 1452 : 		/* single sub text node selection */
; 1453 : 		if (list == NULL)

	push	edx
	push	eax
	call	_xmlNewTextLen
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN1@xmlXPtrBui

; 1454 : 		    return(tmp);
; 1455 : 		/* prune and return full set */
; 1456 : 		if (last != NULL)

	push	eax
	test	esi, esi
	je	SHORT $LN21@xmlXPtrBui

; 1457 : 		    xmlAddNextSibling(last, tmp);

	push	esi
	call	_xmlAddNextSibling

; 1460 : 		return(list);

	add	esp, 8

; 1567 :     }
; 1568 :     return(list);
; 1569 : }

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlXPtrBui:

; 1458 : 		else
; 1459 : 		    xmlAddChild(parent, tmp);

	mov	ecx, DWORD PTR _parent$1$[ebp]
	push	ecx
	call	_xmlAddChild

; 1460 : 		return(list);

	add	esp, 8
$LN62@xmlXPtrBui:

; 1567 :     }
; 1568 :     return(list);
; 1569 : }

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@xmlXPtrBui:

; 1548 : 		    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1548					; 0000060cH

; 1549 : 		    return(NULL);

	jmp	SHORT $LN71@xmlXPtrBui
$LN57@xmlXPtrBui:

; 1563 : 	    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1563					; 0000061bH
$LN71@xmlXPtrBui:

; 1567 :     }
; 1568 :     return(list);
; 1569 : }

	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN9@xmlXPtrBui:
	xor	eax, eax
$LN1@xmlXPtrBui:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN73@xmlXPtrBui:
	DD	$LN42@xmlXPtrBui
	DD	$LN48@xmlXPtrBui
	DD	$LN40@xmlXPtrBui
	DD	$LN43@xmlXPtrBui
$LN63@xmlXPtrBui:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	2
	DB	3
	DB	1
	DB	1
_xmlXPtrBuildRangeNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeFunction
_TEXT	SEGMENT
_newset$1$ = -8						; size = 4
_oldset$1$ = -4						; size = 4
_set$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeFunction PROC				; COMDAT

; 2014 : xmlXPtrRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPtrRan

; 2015 :     int i;
; 2016 :     xmlXPathObjectPtr set;
; 2017 :     xmlLocationSetPtr oldset;
; 2018 :     xmlLocationSetPtr newset;
; 2019 : 
; 2020 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPtrRan
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPtrRan:

; 2015 :     int i;
; 2016 :     xmlXPathObjectPtr set;
; 2017 :     xmlLocationSetPtr oldset;
; 2018 :     xmlLocationSetPtr newset;
; 2019 : 
; 2020 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN7@xmlXPtrRan
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPtrRan:

; 2021 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	$LN9@xmlXPtrRan
	mov	eax, DWORD PTR [eax]
	cmp	eax, 7
	je	SHORT $LN8@xmlXPtrRan
	cmp	eax, 1
	jne	$LN9@xmlXPtrRan
$LN8@xmlXPtrRan:
	push	ebx
	push	esi

; 2025 : 
; 2026 :     set = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _set$1$[ebp], ebx

; 2027 :     if (set->type == XPATH_NODESET) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN10@xmlXPtrRan

; 2028 : 	xmlXPathObjectPtr tmp;
; 2029 : 
; 2030 : 	/*
; 2031 : 	 * First convert to a location set
; 2032 : 	 */
; 2033 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	push	DWORD PTR [ebx+4]
	call	_xmlXPtrNewLocationSetNodeSet

; 2034 : 	xmlXPathFreeObject(set);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeObject
	add	esp, 8

; 2035 : 	if (tmp == NULL)

	test	esi, esi
	jne	SHORT $LN11@xmlXPtrRan

; 2036 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebx
$LN1@xmlXPtrRan:
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPtrRan:

; 2037 : 	set = tmp;

	mov	ebx, esi
	mov	DWORD PTR _set$1$[ebp], esi
$LN10@xmlXPtrRan:

; 2038 :     }
; 2039 :     oldset = (xmlLocationSetPtr) set->user;

	mov	eax, DWORD PTR [ebx+28]

; 2040 : 
; 2041 :     /*
; 2042 :      * The loop is to compute the covering range for each item and add it
; 2043 :      */
; 2044 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	DWORD PTR _oldset$1$[ebp], eax
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1$[ebp], eax

; 2045 :     if (newset == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlXPtrRan

; 2046 : 	xmlXPathFreeObject(set);

	push	ebx
	call	_xmlXPathFreeObject

; 2047 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	edi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPtrRan:

; 2048 :     }
; 2049 :     if (oldset != NULL) {

	mov	eax, DWORD PTR _oldset$1$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPtrRan

; 2050 :         for (i = 0;i < oldset->locNr;i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN52@xmlXPtrRan
$LL4@xmlXPtrRan:

; 2051 :             xmlXPtrLocationSetAdd(newset,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 1950 :     if (loc == NULL)

	test	ecx, ecx
	je	SHORT $LN22@xmlXPtrRan

; 1951 : 	return(NULL);
; 1952 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN22@xmlXPtrRan
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN22@xmlXPtrRan

; 1953 : 	(ctxt->context->doc == NULL))
; 1954 : 	return(NULL);
; 1955 :     switch (loc->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 5
	je	$LN23@xmlXPtrRan
	sub	eax, 1
	je	SHORT $LN24@xmlXPtrRan

; 1987 : 					           node, indx + 1));
; 1988 : 			}
; 1989 : 			default:
; 1990 : 			    return(NULL);
; 1991 : 		    }
; 1992 : 		}
; 1993 : 	    }
; 1994 : 	default:
; 1995 : 	    TODO /* missed one case ??? */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	1995					; 000007cbH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN22@xmlXPtrRan:

; 2051 :             xmlXPtrLocationSetAdd(newset,

	xor	eax, eax
$LN15@xmlXPtrRan:
	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	mov	eax, DWORD PTR _oldset$1$[ebp]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL4@xmlXPtrRan
$LN52@xmlXPtrRan:

; 2052 :                     xmlXPtrCoveringRange(ctxt, oldset->locTab[i]));
; 2053 :         }
; 2054 :     }
; 2055 : 
; 2056 :     /*
; 2057 :      * Save the new value and cleanup
; 2058 :      */
; 2059 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	ebx, DWORD PTR _set$1$[ebp]
$LN3@xmlXPtrRan:
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	edi
	call	_valuePush

; 2060 :     xmlXPathFreeObject(set);

	push	ebx
	call	_xmlXPathFreeObject
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlXPtrRan:

; 1960 : 	    if (loc->user2 != NULL) {

	mov	eax, DWORD PTR [ecx+36]
	test	eax, eax
	je	SHORT $LN25@xmlXPtrRan

; 1961 : 		return(xmlXPtrNewRange(loc->user, loc->index,

	push	DWORD PTR [ecx+40]
	push	eax
	push	DWORD PTR [ecx+32]
	push	DWORD PTR [ecx+28]
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN15@xmlXPtrRan
$LN25@xmlXPtrRan:

; 1962 : 			              loc->user2, loc->index2));
; 1963 : 	    } else {
; 1964 : 		xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	esi, DWORD PTR [ecx+28]

; 1965 : 		if (node == (xmlNodePtr) ctxt->context->doc) {

	cmp	esi, edx
	jne	SHORT $LN27@xmlXPtrRan
$LN29@xmlXPtrRan:

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	esi
	call	_xmlXPtrGetArity
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	jmp	SHORT $LN15@xmlXPtrRan
$LN27@xmlXPtrRan:

; 1969 : 		    switch (node->type) {

	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN22@xmlXPtrRan
	movzx	eax, BYTE PTR $LN51@xmlXPtrRan[eax]
	jmp	DWORD PTR $LN57@xmlXPtrRan[eax*4]
$LN30@xmlXPtrRan:

; 1970 : 			case XML_ATTRIBUTE_NODE:
; 1971 : 			/* !!! our model is slightly different than XPath */
; 1972 : 			    return(xmlXPtrNewRange(node, 0, node,
; 1973 : 					           xmlXPtrGetArity(node)));
; 1974 : 			case XML_ELEMENT_NODE:
; 1975 : 			case XML_TEXT_NODE:
; 1976 : 			case XML_CDATA_SECTION_NODE:
; 1977 : 			case XML_ENTITY_REF_NODE:
; 1978 : 			case XML_PI_NODE:
; 1979 : 			case XML_COMMENT_NODE:
; 1980 : 			case XML_DOCUMENT_NODE:
; 1981 : 			case XML_NOTATION_NODE:
; 1982 : 			case XML_HTML_DOCUMENT_NODE: {
; 1983 : 			    int indx = xmlXPtrGetIndex(node);

	mov	ecx, esi

; 169  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	edx, 18					; 00000012H
	je	SHORT $LN39@xmlXPtrRan

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	edx, 1
$LL37@xmlXPtrRan:

; 172  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 173  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	je	SHORT $LN41@xmlXPtrRan
	cmp	eax, 9
	je	SHORT $LN41@xmlXPtrRan
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN35@xmlXPtrRan
$LN41@xmlXPtrRan:

; 174  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 175  : 	    i++;

	inc	edx
$LN35@xmlXPtrRan:

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	ecx, DWORD PTR [ecx+28]
	test	ecx, ecx
	jne	SHORT $LL37@xmlXPtrRan

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	mov	ecx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [edx+1]
	push	eax

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	ecx

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	lea	eax, DWORD PTR [edx-1]

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	eax
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN15@xmlXPtrRan
$LN39@xmlXPtrRan:

; 1985 : 			    node = node->parent;

	mov	ecx, DWORD PTR [esi+20]

; 170  : 	return(-1);

	or	edx, -1

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	lea	eax, DWORD PTR [edx+1]
	push	eax

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	ecx

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	lea	eax, DWORD PTR [edx-1]

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	eax
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN15@xmlXPtrRan
$LN23@xmlXPtrRan:

; 1957 : 	    return(xmlXPtrNewRange(loc->user, loc->index,

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [ecx+28]
	push	eax

; 2051 :             xmlXPtrLocationSetAdd(newset,

	push	ecx
	push	eax
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN15@xmlXPtrRan
$LN9@xmlXPtrRan:

; 2022 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2023 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2024 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@xmlXPtrRan:
	DD	$LN30@xmlXPtrRan
	DD	$LN29@xmlXPtrRan
	DD	$LN22@xmlXPtrRan
$LN51@xmlXPtrRan:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrRangeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeInsideFunction
_TEXT	SEGMENT
_oldset$1$ = -8						; size = 4
_set$1$ = -4						; size = 4
_newset$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeInsideFunction PROC			; COMDAT

; 2168 : xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN1@xmlXPtrRan

; 2169 :     int i;
; 2170 :     xmlXPathObjectPtr set;
; 2171 :     xmlLocationSetPtr oldset;
; 2172 :     xmlLocationSetPtr newset;
; 2173 : 
; 2174 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPtrRan
	push	12					; 0000000cH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPtrRan:

; 2169 :     int i;
; 2170 :     xmlXPathObjectPtr set;
; 2171 :     xmlLocationSetPtr oldset;
; 2172 :     xmlLocationSetPtr newset;
; 2173 : 
; 2174 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [edi+44]
	inc	eax
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN7@xmlXPtrRan
	push	23					; 00000017H
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlXPtrRan:

; 2175 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	$LN9@xmlXPtrRan
	mov	eax, DWORD PTR [eax]
	cmp	eax, 7
	je	SHORT $LN8@xmlXPtrRan
	cmp	eax, 1
	jne	$LN9@xmlXPtrRan
$LN8@xmlXPtrRan:
	push	ebx
	push	esi

; 2179 : 
; 2180 :     set = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _set$1$[ebp], ebx

; 2181 :     if (set->type == XPATH_NODESET) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN10@xmlXPtrRan

; 2182 : 	xmlXPathObjectPtr tmp;
; 2183 : 
; 2184 : 	/*
; 2185 : 	 * First convert to a location set
; 2186 : 	 */
; 2187 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	push	DWORD PTR [ebx+4]
	call	_xmlXPtrNewLocationSetNodeSet

; 2188 : 	xmlXPathFreeObject(set);

	push	ebx
	mov	esi, eax
	call	_xmlXPathFreeObject
	add	esp, 8

; 2189 : 	if (tmp == NULL)

	test	esi, esi
	jne	SHORT $LN11@xmlXPtrRan

; 2190 : 	     XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi
	pop	ebx
$LN1@xmlXPtrRan:
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPtrRan:

; 2191 : 	set = tmp;

	mov	ebx, esi
	mov	DWORD PTR _set$1$[ebp], esi
$LN10@xmlXPtrRan:

; 2192 :     }
; 2193 :     oldset = (xmlLocationSetPtr) set->user;

	mov	esi, DWORD PTR [ebx+28]

; 2194 : 
; 2195 :     /*
; 2196 :      * The loop is to compute the covering range for each item and add it
; 2197 :      */
; 2198 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	DWORD PTR _oldset$1$[ebp], esi
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1$[ebp], eax

; 2199 :     if (newset == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlXPtrRan

; 2200 : 	xmlXPathFreeObject(set);

	push	ebx
	call	_xmlXPathFreeObject

; 2201 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	edi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlXPtrRan:

; 2202 :     }
; 2203 :     for (i = 0;i < oldset->locNr;i++) {

	xor	ebx, ebx
	cmp	DWORD PTR [esi], ebx
	jle	SHORT $LN3@xmlXPtrRan
	npad	2
$LL4@xmlXPtrRan:

; 2204 : 	xmlXPtrLocationSetAdd(newset,

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+ebx*4]

; 2074 :     if (loc == NULL)

	test	eax, eax
	je	SHORT $LN23@xmlXPtrRan

; 2075 : 	return(NULL);
; 2076 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN23@xmlXPtrRan
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN23@xmlXPtrRan

; 2077 : 	(ctxt->context->doc == NULL))
; 2078 : 	return(NULL);
; 2079 :     switch (loc->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 5
	je	$LN24@xmlXPtrRan
	sub	ecx, 1
	je	SHORT $LN30@xmlXPtrRan

; 2115 : 		    case XML_PI_NODE:
; 2116 : 		    case XML_COMMENT_NODE:
; 2117 : 		    case XML_TEXT_NODE:
; 2118 : 		    case XML_CDATA_SECTION_NODE: {
; 2119 : 			if (node->content == NULL) {
; 2120 : 			    return(xmlXPtrNewRange(node, 0, node, 0));
; 2121 : 			} else {
; 2122 : 			    return(xmlXPtrNewRange(node, 0, node,
; 2123 : 						   xmlStrlen(node->content)));
; 2124 : 			}
; 2125 : 		    }
; 2126 : 		    case XML_ATTRIBUTE_NODE:
; 2127 : 		    case XML_ELEMENT_NODE:
; 2128 : 		    case XML_ENTITY_REF_NODE:
; 2129 : 		    case XML_DOCUMENT_NODE:
; 2130 : 		    case XML_NOTATION_NODE:
; 2131 : 		    case XML_HTML_DOCUMENT_NODE: {
; 2132 : 			return(xmlXPtrNewRange(node, 0, node,
; 2133 : 					       xmlXPtrGetArity(node)));
; 2134 : 		    }
; 2135 : 		    default:
; 2136 : 			break;
; 2137 : 		}
; 2138 : 		return(NULL);
; 2139 : 	    }
; 2140 :         }
; 2141 : 	default:
; 2142 : 	    TODO /* missed one case ??? */

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2142					; 0000085eH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H
$LN23@xmlXPtrRan:

; 2204 : 	xmlXPtrLocationSetAdd(newset,

	xor	esi, esi
$LN14@xmlXPtrRan:
	push	esi
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	mov	esi, DWORD PTR _oldset$1$[ebp]
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [esi]
	jl	SHORT $LL4@xmlXPtrRan
	mov	eax, DWORD PTR _newset$1$[ebp]
$LN3@xmlXPtrRan:

; 2205 : 		xmlXPtrInsideRange(ctxt, oldset->locTab[i]));
; 2206 :     }
; 2207 : 
; 2208 :     /*
; 2209 :      * Save the new value and cleanup
; 2210 :      */
; 2211 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	push	eax
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	edi
	call	_valuePush

; 2212 :     xmlXPathFreeObject(set);

	push	DWORD PTR _set$1$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xmlXPtrRan:

; 2110 : 	    if (loc->user2 != NULL) {

	mov	ecx, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN31@xmlXPtrRan

; 2111 : 		return(xmlXPtrNewRange(node, loc->index,

	push	DWORD PTR [eax+40]
	push	ecx
	push	DWORD PTR [eax+32]
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	mov	esi, eax
	jmp	SHORT $LN14@xmlXPtrRan
$LN31@xmlXPtrRan:

; 2112 : 			               loc->user2, loc->index2));
; 2113 : 	    } else {
; 2114 : 		switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN23@xmlXPtrRan
	movzx	eax, BYTE PTR $LN56@xmlXPtrRan[eax]
	jmp	DWORD PTR $LN64@xmlXPtrRan[eax*4]
$LN24@xmlXPtrRan:

; 2080 :         case XPATH_POINT: {
; 2081 : 	    xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	esi, DWORD PTR [eax+28]

; 2082 : 	    switch (node->type) {

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	SHORT $LN23@xmlXPtrRan
	movzx	eax, BYTE PTR $LN57@xmlXPtrRan[eax]
	jmp	DWORD PTR $LN65@xmlXPtrRan[eax*4]
$LN25@xmlXPtrRan:

; 2204 : 	xmlXPtrLocationSetAdd(newset,

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	jne	SHORT $LN26@xmlXPtrRan
	push	eax
	push	esi
	push	eax
	push	esi
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax
	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H
	jmp	$LN14@xmlXPtrRan
$LN26@xmlXPtrRan:
	push	eax
	call	_xmlStrlen
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	mov	esi, eax
	jmp	$LN14@xmlXPtrRan
$LN27@xmlXPtrRan:
	push	esi
	call	_xmlXPtrGetArity
	push	eax
	push	esi
	push	0
	push	esi
	call	_xmlXPtrNewRange
	add	esp, 20					; 00000014H
	mov	esi, eax
	jmp	$LN14@xmlXPtrRan
$LN9@xmlXPtrRan:

; 2176 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2177 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2178 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN64@xmlXPtrRan:
	DD	$LN27@xmlXPtrRan
	DD	$LN25@xmlXPtrRan
	DD	$LN23@xmlXPtrRan
$LN56@xmlXPtrRan:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
	npad	3
$LN65@xmlXPtrRan:
	DD	$LN27@xmlXPtrRan
	DD	$LN25@xmlXPtrRan
	DD	$LN23@xmlXPtrRan
$LN57@xmlXPtrRan:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrRangeInsideFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrOriginFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrOriginFunction PROC				; COMDAT

; 1734 : xmlXPtrOriginFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPtrOri

; 1735 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPtrOri
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1741 : }

	pop	ebp
	ret	0
$LN3@xmlXPtrOri:

; 1735 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+44]
	jge	SHORT $LN4@xmlXPtrOri
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1741 : }

	pop	ebp
	ret	0
$LN4@xmlXPtrOri:

; 1736 : 
; 1737 :     if (ctxt->context->origin == NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+84]
	test	eax, eax
	jne	SHORT $LN5@xmlXPtrOri

; 1738 : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1741 : }

	pop	ebp
	ret	0
$LN5@xmlXPtrOri:

; 1739 : 
; 1740 :     valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->origin, NULL));

	push	0
	push	eax
	call	_xmlXPtrNewLocationSetNodes
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN1@xmlXPtrOri:
	pop	esi

; 1741 : }

	pop	ebp
	ret	0
_xmlXPtrOriginFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrHereFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrHereFunction PROC				; COMDAT

; 1716 : xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPtrHer

; 1717 :     CHECK_ARITY(0);

	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPtrHer
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1723 : }

	pop	ebp
	ret	0
$LN3@xmlXPtrHer:

; 1717 :     CHECK_ARITY(0);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+44]
	jge	SHORT $LN4@xmlXPtrHer
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1723 : }

	pop	ebp
	ret	0
$LN4@xmlXPtrHer:

; 1718 : 
; 1719 :     if (ctxt->context->here == NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+80]
	test	eax, eax
	jne	SHORT $LN5@xmlXPtrHer

; 1720 : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1723 : }

	pop	ebp
	ret	0
$LN5@xmlXPtrHer:

; 1721 : 
; 1722 :     valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));

	push	0
	push	eax
	call	_xmlXPtrNewLocationSetNodes
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
$LN1@xmlXPtrHer:
	pop	esi

; 1723 : }

	pop	ebp
	ret	0
_xmlXPtrHereFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEndPointFunction
_TEXT	SEGMENT
_oldset$1$ = -4						; size = 4
_newset$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrEndPointFunction PROC				; COMDAT

; 1863 : xmlXPtrEndPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPtrEnd

; 1864 :     xmlXPathObjectPtr tmp, obj, point;
; 1865 :     xmlLocationSetPtr newset = NULL;
; 1866 :     xmlLocationSetPtr oldset = NULL;
; 1867 : 
; 1868 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN8@xmlXPtrEnd
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPtrEnd:

; 1864 :     xmlXPathObjectPtr tmp, obj, point;
; 1865 :     xmlLocationSetPtr newset = NULL;
; 1866 :     xmlLocationSetPtr oldset = NULL;
; 1867 : 
; 1868 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN9@xmlXPtrEnd
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPtrEnd:

; 1869 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN11@xmlXPtrEnd
	mov	eax, DWORD PTR [eax]
	cmp	eax, 7
	je	SHORT $LN10@xmlXPtrEnd
	cmp	eax, 1
	jne	$LN11@xmlXPtrEnd
$LN10@xmlXPtrEnd:
	push	ebx
	push	edi

; 1873 : 
; 1874 :     obj = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 1875 :     if (obj->type == XPATH_NODESET) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN12@xmlXPtrEnd

; 1876 : 	/*
; 1877 : 	 * First convert to a location set
; 1878 : 	 */
; 1879 : 	tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);

	push	DWORD PTR [ebx+4]
	call	_xmlXPtrNewLocationSetNodeSet

; 1880 : 	xmlXPathFreeObject(obj);

	push	ebx
	mov	edi, eax
	call	_xmlXPathFreeObject
	add	esp, 8

; 1881 : 	if (tmp == NULL)

	test	edi, edi
	jne	SHORT $LN13@xmlXPtrEnd

; 1882 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPtrEnd:

; 1883 : 	obj = tmp;

	mov	ebx, edi
$LN12@xmlXPtrEnd:

; 1884 :     }
; 1885 : 
; 1886 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1$[ebp], eax

; 1887 :     if (newset == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlXPtrEnd

; 1888 : 	xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1889 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	esi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlXPtrEnd:

; 1890 :     }
; 1891 :     oldset = (xmlLocationSetPtr) obj->user;

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR _oldset$1$[ebp], eax

; 1892 :     if (oldset != NULL) {

	test	eax, eax
	je	SHORT $LN48@xmlXPtrEnd

; 1893 : 	int i;
; 1894 : 
; 1895 : 	for (i = 0; i < oldset->locNr; i++) {

	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN48@xmlXPtrEnd
	npad	6
$LL4@xmlXPtrEnd:

; 1896 : 	    tmp = oldset->locTab[i];

	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+edi*4]

; 1897 : 	    if (tmp == NULL)

	test	eax, eax
	je	SHORT $LN2@xmlXPtrEnd

; 1898 : 		continue;
; 1899 : 	    point = NULL;
; 1900 : 	    switch (tmp->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 5
	je	SHORT $LN17@xmlXPtrEnd
	sub	ecx, 1
	jne	SHORT $LN2@xmlXPtrEnd

; 1903 : 		    break;
; 1904 : 		case XPATH_RANGE: {
; 1905 : 		    xmlNodePtr node = tmp->user2;

	mov	ecx, DWORD PTR [eax+36]

; 1906 : 		    if (node != NULL) {

	test	ecx, ecx
	je	SHORT $LN19@xmlXPtrEnd

; 1907 : 			if ((node->type == XML_ATTRIBUTE_NODE) ||

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, 2
	je	SHORT $LN41@xmlXPtrEnd
	cmp	edx, 18					; 00000012H
	je	SHORT $LN41@xmlXPtrEnd

; 1912 : 			}
; 1913 : 			point = xmlXPtrNewPoint(node, tmp->index2);

	mov	eax, DWORD PTR [eax+40]
	jmp	SHORT $LN24@xmlXPtrEnd
$LN19@xmlXPtrEnd:

; 1914 : 		    } else if (tmp->user == NULL) {

	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN2@xmlXPtrEnd

; 1915 : 			point = xmlXPtrNewPoint(node,

	xor	ecx, ecx
	or	eax, -1

; 1916 : 				       xmlXPtrNbLocChildren(node));
; 1917 : 		    }
; 1918 : 		    break;

	jmp	SHORT $LN24@xmlXPtrEnd
$LN17@xmlXPtrEnd:

; 1901 : 		case XPATH_POINT:
; 1902 : 		    point = xmlXPtrNewPoint(tmp->user, tmp->index);

	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [eax+32]
$LN24@xmlXPtrEnd:

; 1919 : 	        }
; 1920 : 		default:
; 1921 : 		    /*** Should we raise an error ?
; 1922 : 		    xmlXPathFreeObject(obj);
; 1923 : 		    xmlXPathFreeObject(newset);
; 1924 : 		    XP_ERROR(XPATH_INVALID_TYPE)
; 1925 : 		    ***/
; 1926 : 		    break;
; 1927 : 	    }
; 1928 :             if (point != NULL)

	push	eax
	push	ecx
	call	_xmlXPtrNewPoint
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlXPtrEnd

; 1929 : 		xmlXPtrLocationSetAdd(newset, point);

	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN2@xmlXPtrEnd:

; 1893 : 	int i;
; 1894 : 
; 1895 : 	for (i = 0; i < oldset->locNr; i++) {

	mov	eax, DWORD PTR _oldset$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL4@xmlXPtrEnd
$LN48@xmlXPtrEnd:

; 1930 : 	}
; 1931 :     }
; 1932 :     xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1933 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
$LN1@xmlXPtrEnd:
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlXPtrEnd:

; 1908 :                             (node->type == XML_NAMESPACE_DECL)) {
; 1909 : 			    xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1910 : 			    xmlXPtrFreeLocationSet(newset);

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrFreeLocationSet

; 1911 : 			    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPtrEnd:

; 1870 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 1871 : 	 (ctxt->value->type != XPATH_NODESET)))
; 1872 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEndPointFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrStartPointFunction
_TEXT	SEGMENT
_oldset$1$ = -4						; size = 4
_newset$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrStartPointFunction PROC				; COMDAT

; 1767 : xmlXPtrStartPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN1@xmlXPtrSta

; 1768 :     xmlXPathObjectPtr tmp, obj, point;
; 1769 :     xmlLocationSetPtr newset = NULL;
; 1770 :     xmlLocationSetPtr oldset = NULL;
; 1771 : 
; 1772 :     CHECK_ARITY(1);

	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN8@xmlXPtrSta
	push	12					; 0000000cH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlXPtrSta:

; 1768 :     xmlXPathObjectPtr tmp, obj, point;
; 1769 :     xmlLocationSetPtr newset = NULL;
; 1770 :     xmlLocationSetPtr oldset = NULL;
; 1771 : 
; 1772 :     CHECK_ARITY(1);

	mov	eax, DWORD PTR [esi+44]
	inc	eax
	cmp	DWORD PTR [esi+20], eax
	jge	SHORT $LN9@xmlXPtrSta
	push	23					; 00000017H
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPtrSta:

; 1773 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN11@xmlXPtrSta
	mov	eax, DWORD PTR [eax]
	cmp	eax, 7
	je	SHORT $LN10@xmlXPtrSta
	cmp	eax, 1
	jne	$LN11@xmlXPtrSta
$LN10@xmlXPtrSta:
	push	ebx
	push	edi

; 1777 : 
; 1778 :     obj = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	ebx, eax
	add	esp, 4

; 1779 :     if (obj->type == XPATH_NODESET) {

	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN12@xmlXPtrSta

; 1780 : 	/*
; 1781 : 	 * First convert to a location set
; 1782 : 	 */
; 1783 : 	tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);

	push	DWORD PTR [ebx+4]
	call	_xmlXPtrNewLocationSetNodeSet

; 1784 : 	xmlXPathFreeObject(obj);

	push	ebx
	mov	edi, eax
	call	_xmlXPathFreeObject
	add	esp, 8

; 1785 : 	if (tmp == NULL)

	test	edi, edi
	jne	SHORT $LN13@xmlXPtrSta

; 1786 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xmlXPtrSta:

; 1787 : 	obj = tmp;

	mov	ebx, edi
$LN12@xmlXPtrSta:

; 1788 :     }
; 1789 : 
; 1790 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1$[ebp], eax

; 1791 :     if (newset == NULL) {

	test	eax, eax
	jne	SHORT $LN14@xmlXPtrSta

; 1792 : 	xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1793 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	esi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xmlXPtrSta:

; 1794 :     }
; 1795 :     oldset = (xmlLocationSetPtr) obj->user;

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR _oldset$1$[ebp], eax

; 1796 :     if (oldset != NULL) {

	test	eax, eax
	je	SHORT $LN30@xmlXPtrSta

; 1797 : 	int i;
; 1798 : 
; 1799 : 	for (i = 0; i < oldset->locNr; i++) {

	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN30@xmlXPtrSta
	npad	6
$LL4@xmlXPtrSta:

; 1800 : 	    tmp = oldset->locTab[i];

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+edi*4]

; 1801 : 	    if (tmp == NULL)

	test	ecx, ecx
	je	SHORT $LN2@xmlXPtrSta

; 1802 : 		continue;
; 1803 : 	    point = NULL;
; 1804 : 	    switch (tmp->type) {

	mov	eax, DWORD PTR [ecx]
	sub	eax, 5
	je	SHORT $LN17@xmlXPtrSta
	sub	eax, 1
	jne	SHORT $LN2@xmlXPtrSta

; 1807 : 		    break;
; 1808 : 		case XPATH_RANGE: {
; 1809 : 		    xmlNodePtr node = tmp->user;

	mov	edx, DWORD PTR [ecx+28]

; 1810 : 		    if (node != NULL) {

	test	edx, edx
	je	SHORT $LN2@xmlXPtrSta

; 1811 : 			if ((node->type == XML_ATTRIBUTE_NODE) ||

	mov	eax, DWORD PTR [edx+4]
	cmp	eax, 2
	je	SHORT $LN26@xmlXPtrSta
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN22@xmlXPtrSta
$LN26@xmlXPtrSta:

; 1812 :                             (node->type == XML_NAMESPACE_DECL)) {
; 1813 : 			    xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1814 : 			    xmlXPtrFreeLocationSet(newset);

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrFreeLocationSet

; 1815 : 			    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	esi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
$LN1@xmlXPtrSta:
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlXPtrSta:

; 1805 : 		case XPATH_POINT:
; 1806 : 		    point = xmlXPtrNewPoint(tmp->user, tmp->index);

	mov	edx, DWORD PTR [ecx+28]
$LN22@xmlXPtrSta:

; 1816 : 			}
; 1817 : 			point = xmlXPtrNewPoint(node, tmp->index);
; 1818 : 		    }
; 1819 : 		    break;
; 1820 : 	        }
; 1821 : 		default:
; 1822 : 		    /*** Should we raise an error ?
; 1823 : 		    xmlXPathFreeObject(obj);
; 1824 : 		    xmlXPathFreeObject(newset);
; 1825 : 		    XP_ERROR(XPATH_INVALID_TYPE)
; 1826 : 		    ***/
; 1827 : 		    break;
; 1828 : 	    }
; 1829 :             if (point != NULL)

	mov	eax, DWORD PTR [ecx+32]
	push	eax
	push	edx
	call	_xmlXPtrNewPoint
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlXPtrSta

; 1830 : 		xmlXPtrLocationSetAdd(newset, point);

	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN2@xmlXPtrSta:

; 1797 : 	int i;
; 1798 : 
; 1799 : 	for (i = 0; i < oldset->locNr; i++) {

	mov	eax, DWORD PTR _oldset$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL4@xmlXPtrSta
$LN30@xmlXPtrSta:

; 1831 : 	}
; 1832 :     }
; 1833 :     xmlXPathFreeObject(obj);

	push	ebx
	call	_xmlXPathFreeObject

; 1834 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPtrSta:

; 1774 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 1775 : 	 (ctxt->value->type != XPATH_NODESET)))
; 1776 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1835 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrStartPointFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrStringRangeFunction
_TEXT	SEGMENT
_oldset$1$ = -56					; size = 4
_set$1$ = -52						; size = 4
_i$1$ = -48						; size = 4
_num$1$ = -44						; size = 4
_pos$1$ = -40						; size = 4
_rindx$1 = -36						; size = 4
_fendindex$ = -36					; size = 4
_number$1$ = -32					; size = 4
_position$1$ = -28					; size = 4
_bytes$1$ = -24						; size = 4
_rend$2 = -24						; size = 4
_fend$ = -24						; size = 4
_string$1$ = -20					; size = 4
_end$1$ = -16						; size = 4
_endindex$1$ = -12					; size = 4
_start$ = -8						; size = 4
_startindex$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_newset$1$ = 12						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrStringRangeFunction PROC			; COMDAT

; 2696 : xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _nargs$[ebp]
	xor	eax, eax
	mov	DWORD PTR _end$1$[ebp], eax
	mov	DWORD PTR _position$1$[ebp], eax
	mov	DWORD PTR _number$1$[ebp], eax
	mov	DWORD PTR _pos$1$[ebp], eax
	mov	DWORD PTR _num$1$[ebp], eax
	lea	eax, DWORD PTR [esi-2]
	mov	DWORD PTR _endindex$1$[ebp], 0
	cmp	eax, 2
	ja	$LN9@xmlXPtrStr

; 2712 : 
; 2713 :     if (nargs >= 4) {

	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	cmp	esi, 4
	jl	SHORT $LN13@xmlXPtrStr

; 2714 : 	CHECK_TYPE(XPATH_NUMBER);

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN19@xmlXPtrStr
	cmp	DWORD PTR [eax], 3
	jne	$LN19@xmlXPtrStr

; 2715 : 	number = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _number$1$[ebp], ecx

; 2716 : 	if (number != NULL)

	test	ecx, ecx
	je	SHORT $LN13@xmlXPtrStr

; 2717 : 	    num = (int) number->floatval;

	cvttsd2si eax, QWORD PTR [ecx+16]
	mov	DWORD PTR _num$1$[ebp], eax
$LN13@xmlXPtrStr:

; 2718 :     }
; 2719 :     if (nargs >= 3) {

	cmp	esi, 3
	jl	SHORT $LN17@xmlXPtrStr

; 2720 : 	CHECK_TYPE(XPATH_NUMBER);

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN19@xmlXPtrStr
	cmp	DWORD PTR [eax], 3
	jne	$LN19@xmlXPtrStr

; 2721 : 	position = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _position$1$[ebp], ecx

; 2722 : 	if (position != NULL)

	test	ecx, ecx
	je	SHORT $LN17@xmlXPtrStr

; 2723 : 	    pos = (int) position->floatval;

	cvttsd2si eax, QWORD PTR [ecx+16]
	mov	DWORD PTR _pos$1$[ebp], eax
$LN17@xmlXPtrStr:

; 2724 :     }
; 2725 :     CHECK_TYPE(XPATH_STRING);

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN19@xmlXPtrStr
	cmp	DWORD PTR [eax], 4
	jne	$LN19@xmlXPtrStr

; 2726 :     string = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	esi, eax
	add	esp, 4

; 2727 :     if ((ctxt->value == NULL) ||

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _string$1$[ebp], esi
	test	eax, eax
	je	$LN19@xmlXPtrStr
	mov	eax, DWORD PTR [eax]
	cmp	eax, 7
	je	SHORT $LN20@xmlXPtrStr
	cmp	eax, 1
	jne	$LN19@xmlXPtrStr
$LN20@xmlXPtrStr:
	push	edi

; 2728 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2729 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2730 :         XP_ERROR(XPATH_INVALID_TYPE)
; 2731 : 
; 2732 :     set = valuePop(ctxt);

	push	ebx
	call	_valuePop
	mov	edi, eax

; 2733 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	DWORD PTR _set$1$[ebp], edi
	call	_xmlXPtrLocationSetCreate
	add	esp, 8
	mov	DWORD PTR _newset$1$[ebp], eax

; 2734 :     if (newset == NULL) {

	test	eax, eax
	jne	SHORT $LN22@xmlXPtrStr

; 2735 : 	xmlXPathFreeObject(set);

	push	edi
	call	_xmlXPathFreeObject

; 2736 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	ebx
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
$LN143@xmlXPtrStr:
	pop	edi
	pop	ebx
	pop	esi

; 2828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlXPtrStr:

; 2737 :     }
; 2738 :     if (set->nodesetval == NULL) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$error$149

; 2739 :         goto error;
; 2740 :     }
; 2741 :     if (set->type == XPATH_NODESET) {

	cmp	DWORD PTR [edi], 1
	jne	SHORT $LN24@xmlXPtrStr

; 2742 : 	xmlXPathObjectPtr tmp;
; 2743 : 
; 2744 : 	/*
; 2745 : 	 * First convert to a location set
; 2746 : 	 */
; 2747 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	push	eax
	call	_xmlXPtrNewLocationSetNodeSet

; 2748 : 	xmlXPathFreeObject(set);

	push	edi
	mov	esi, eax
	call	_xmlXPathFreeObject
	add	esp, 8

; 2749 : 	if (tmp == NULL)

	test	esi, esi
	jne	SHORT $LN25@xmlXPtrStr

; 2750 : 	     XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	push	ebx
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 2828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlXPtrStr:

; 2751 : 	set = tmp;

	mov	edi, esi
	mov	esi, DWORD PTR _string$1$[ebp]
	mov	DWORD PTR _set$1$[ebp], edi
$LN24@xmlXPtrStr:

; 2752 :     }
; 2753 :     oldset = (xmlLocationSetPtr) set->user;

	mov	eax, DWORD PTR [edi+28]

; 2754 : 
; 2755 :     /*
; 2756 :      * The loop is to search for each element in the location set
; 2757 :      * the list of location set corresponding to that search
; 2758 :      */
; 2759 :     for (i = 0;i < oldset->locNr;i++) {

	xor	ecx, ecx
	mov	DWORD PTR _oldset$1$[ebp], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [eax], ecx
	jle	$error$149
$LL4@xmlXPtrStr:

; 2760 : #ifdef DEBUG_RANGES
; 2761 : 	xmlXPathDebugDumpObject(stdout, oldset->locTab[i], 0);
; 2762 : #endif
; 2763 : 
; 2764 : 	xmlXPtrGetStartPoint(oldset->locTab[i], &start, &startindex);

	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+ecx*4]

; 2599 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	test	edx, edx
	je	SHORT $LN133@xmlXPtrStr

; 2600 : 	return(-1);
; 2601 : 
; 2602 :     switch (obj->type) {

	mov	esi, DWORD PTR [edx]
	mov	eax, esi
	sub	eax, 5
	je	SHORT $LN44@xmlXPtrStr
	sub	eax, 1
	jne	SHORT $LN132@xmlXPtrStr

; 2606 : 		*indx = 0;
; 2607 : 	    else
; 2608 : 		*indx = obj->index;
; 2609 : 	    return(0);
; 2610 :         case XPATH_RANGE:
; 2611 : 	    *node = obj->user;
; 2612 : 	    if (obj->index <= 0)

	mov	ecx, DWORD PTR [edx+32]

; 2613 : 		*indx = 0;
; 2614 : 	    else
; 2615 : 		*indx = obj->index;
; 2616 : 	    return(0);

	test	ecx, ecx
	cmovg	eax, ecx
	jmp	SHORT $LN144@xmlXPtrStr
$LN132@xmlXPtrStr:

; 2600 : 	return(-1);
; 2601 : 
; 2602 :     switch (obj->type) {

	mov	edi, DWORD PTR _start$[ebp]
	jmp	SHORT $LN45@xmlXPtrStr
$LN44@xmlXPtrStr:

; 2603 :         case XPATH_POINT:
; 2604 : 	    *node = obj->user;
; 2605 : 	    if (obj->index <= 0)

	mov	eax, DWORD PTR [edx+32]
	xor	ecx, ecx
	test	eax, eax
	cmovle	eax, ecx
$LN144@xmlXPtrStr:

; 2638 :     switch (obj->type) {

	mov	edi, DWORD PTR [edx+28]
	mov	DWORD PTR _startindex$[ebp], eax
	mov	DWORD PTR _start$[ebp], edi
$LN45@xmlXPtrStr:
	sub	esi, 5
	je	SHORT $LN57@xmlXPtrStr
	sub	esi, 1
	jne	SHORT $LN58@xmlXPtrStr

; 2642 : 		*indx = 0;
; 2643 : 	    else
; 2644 : 		*indx = obj->index;
; 2645 : 	    return(0);
; 2646 :         case XPATH_RANGE:
; 2647 : 	    *node = obj->user;

	mov	eax, DWORD PTR [edx+28]

; 2648 : 	    if (obj->index <= 0)
; 2649 : 		*indx = 0;
; 2650 : 	    else
; 2651 : 		*indx = obj->index;
; 2652 : 	    return(0);

	xor	ecx, ecx
	mov	DWORD PTR _end$1$[ebp], eax
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	cmovg	ecx, eax
	mov	DWORD PTR _endindex$1$[ebp], ecx
	jmp	SHORT $LN58@xmlXPtrStr
$LN57@xmlXPtrStr:

; 2639 :         case XPATH_POINT:
; 2640 : 	    *node = obj->user;

	mov	eax, DWORD PTR [edx+28]

; 2641 : 	    if (obj->index <= 0)

	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _end$1$[ebp], eax
	xor	eax, eax
	test	ecx, ecx
	cmovle	ecx, eax
	mov	DWORD PTR _endindex$1$[ebp], ecx

; 2599 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	jmp	SHORT $LN58@xmlXPtrStr
$LN133@xmlXPtrStr:
	mov	edi, DWORD PTR _start$[ebp]
$LN58@xmlXPtrStr:

; 2765 : 	xmlXPtrGetEndPoint(oldset->locTab[i], &end, &endindex);
; 2766 : 	xmlXPtrAdvanceChar(&start, &startindex, 0);

	xor	ebx, ebx
	mov	DWORD PTR _bytes$1$[ebp], ebx

; 2301 :     cur = *node;

	test	edi, edi

; 2302 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	je	SHORT $LN73@xmlXPtrStr
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN73@xmlXPtrStr

; 2303 : 	return(-1);
; 2304 :     pos = *indx;

	mov	esi, DWORD PTR _startindex$[ebp]
	npad	7
$LL66@xmlXPtrStr:

; 2305 : 
; 2306 :     while (bytes >= 0) {
; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	test	edi, edi
	je	SHORT $LN105@xmlXPtrStr
$LL68@xmlXPtrStr:
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 1
	je	SHORT $LN74@xmlXPtrStr
	cmp	eax, 9
	je	SHORT $LN74@xmlXPtrStr
	cmp	eax, 13					; 0000000dH
	jne	$LN69@xmlXPtrStr
$LN74@xmlXPtrStr:

; 2312 : 	       ((cur->type == XML_ELEMENT_NODE) ||
; 2313 : 	        (cur->type == XML_DOCUMENT_NODE) ||
; 2314 : 	        (cur->type == XML_HTML_DOCUMENT_NODE))) {
; 2315 : 	    if (pos > 0) {

	test	esi, esi
	jle	SHORT $LN75@xmlXPtrStr

; 2316 : 		cur = xmlXPtrGetNthChild(cur, pos);

	push	esi
	push	edi
	call	_xmlXPtrGetNthChild

; 2317 : 		pos = 0;
; 2318 : 	    } else {

	jmp	SHORT $LN145@xmlXPtrStr
$LN75@xmlXPtrStr:

; 2319 : 		cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	push	edi
	call	_xmlXPtrAdvanceNode
$LN145@xmlXPtrStr:

; 2305 : 
; 2306 :     while (bytes >= 0) {
; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	mov	edi, eax
	add	esp, 8
	xor	esi, esi
	test	edi, edi
	jne	SHORT $LL68@xmlXPtrStr
$LN105@xmlXPtrStr:

; 2320 : 		pos = 0;
; 2321 : 	    }
; 2322 : 	}
; 2323 : 
; 2324 : 	if (cur == NULL) {
; 2325 : 	    *node = NULL;

	mov	DWORD PTR _start$[ebp], 0

; 2326 : 	    *indx = 0;

	mov	DWORD PTR _startindex$[ebp], 0
$LN73@xmlXPtrStr:

; 2557 :         ((*node)->type == XML_NAMESPACE_DECL) || (indx == NULL))

	mov	edi, DWORD PTR _end$1$[ebp]
	test	edi, edi
	je	SHORT $LN140@xmlXPtrStr
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 18					; 00000012H
	je	SHORT $LN140@xmlXPtrStr

; 2558 : 	return(-1);
; 2559 :     cur = *node;

	mov	esi, edi

; 2560 :     pos = *indx;
; 2561 : 
; 2562 :     if ((cur->type == XML_ELEMENT_NODE) ||
; 2563 : 	(cur->type == XML_DOCUMENT_NODE) ||

	cmp	eax, 1
	je	SHORT $LN92@xmlXPtrStr
	cmp	eax, 9
	je	SHORT $LN92@xmlXPtrStr
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN103@xmlXPtrStr
$LN92@xmlXPtrStr:

; 2564 : 	(cur->type == XML_HTML_DOCUMENT_NODE)) {
; 2565 : 	if (pos > 0) {

	mov	eax, DWORD PTR _endindex$1$[ebp]
	test	eax, eax
	jle	SHORT $LN103@xmlXPtrStr

; 2566 : 	    cur = xmlXPtrGetNthChild(cur, pos);

	push	eax
	push	edi
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	esi, eax
$LN103@xmlXPtrStr:

; 2567 : 	}
; 2568 :     }
; 2569 :     while (cur != NULL) {

	test	esi, esi
	je	SHORT $LN140@xmlXPtrStr
	npad	1
$LL87@xmlXPtrStr:

; 2570 : 	if (cur->last != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN94@xmlXPtrStr

; 2571 : 	    cur = cur->last;

	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL87@xmlXPtrStr
$LN140@xmlXPtrStr:

; 2360 : 	    return(0);
; 2361 : 	}
; 2362 :     }
; 2363 :     return(-1);
; 2364 : }
; 2365 : 
; 2366 : /**
; 2367 :  * xmlXPtrMatchString:
; 2368 :  * @string:  the string to search
; 2369 :  * @start:  the start textnode
; 2370 :  * @startindex:  the start index
; 2371 :  * @end:  the end textnode IN/OUT
; 2372 :  * @endindex:  the end index IN/OUT
; 2373 :  *
; 2374 :  * Check whether the document contains @string at the position
; 2375 :  * (@start, @startindex) and limited by the (@end, @endindex) point
; 2376 :  *
; 2377 :  * Returns -1 in case of failure, 0 if not found, 1 if found in which case
; 2378 :  *            (@start, @startindex) will indicate the position of the beginning
; 2379 :  *            of the range and (@end, @endindex) will indicate the end
; 2380 :  *            of the range
; 2381 :  */
; 2382 : static int
; 2383 : xmlXPtrMatchString(const xmlChar *string, xmlNodePtr start, int startindex,
; 2384 : 	            xmlNodePtr *end, int *endindex) {
; 2385 :     xmlNodePtr cur;
; 2386 :     int pos; /* 0 based */
; 2387 :     int len; /* in bytes */
; 2388 :     int stringlen; /* in bytes */
; 2389 :     int match;
; 2390 : 
; 2391 :     if (string == NULL)
; 2392 : 	return(-1);
; 2393 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))
; 2394 : 	return(-1);
; 2395 :     if ((end == NULL) || (*end == NULL) ||
; 2396 :         ((*end)->type == XML_NAMESPACE_DECL) || (endindex == NULL))
; 2397 : 	return(-1);
; 2398 :     cur = start;
; 2399 :     pos = startindex - 1;
; 2400 :     stringlen = xmlStrlen(string);
; 2401 : 
; 2402 :     while (stringlen > 0) {
; 2403 : 	if ((cur == *end) && (pos + stringlen > *endindex))
; 2404 : 	    return(0);
; 2405 : 
; 2406 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {
; 2407 : 	    len = xmlStrlen(cur->content);
; 2408 : 	    if (len >= pos + stringlen) {
; 2409 : 		match = (!xmlStrncmp(&cur->content[pos], string, stringlen));
; 2410 : 		if (match) {
; 2411 : #ifdef DEBUG_RANGES
; 2412 : 		    xmlGenericError(xmlGenericErrorContext,
; 2413 : 			    "found range %d bytes at index %d of ->",
; 2414 : 			    stringlen, pos + 1);
; 2415 : 		    xmlDebugDumpString(stdout, cur->content);
; 2416 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2417 : #endif
; 2418 : 		    *end = cur;
; 2419 : 		    *endindex = pos + stringlen;
; 2420 : 		    return(1);
; 2421 : 		} else {
; 2422 : 		    return(0);
; 2423 : 		}
; 2424 : 	    } else {
; 2425 :                 int sub = len - pos;
; 2426 : 		match = (!xmlStrncmp(&cur->content[pos], string, sub));
; 2427 : 		if (match) {
; 2428 : #ifdef DEBUG_RANGES
; 2429 : 		    xmlGenericError(xmlGenericErrorContext,
; 2430 : 			    "found subrange %d bytes at index %d of ->",
; 2431 : 			    sub, pos + 1);
; 2432 : 		    xmlDebugDumpString(stdout, cur->content);
; 2433 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2434 : #endif
; 2435 :                     string = &string[sub];
; 2436 : 		    stringlen -= sub;
; 2437 : 		} else {
; 2438 : 		    return(0);
; 2439 : 		}
; 2440 : 	    }
; 2441 : 	}
; 2442 : 	cur = xmlXPtrAdvanceNode(cur, NULL);
; 2443 : 	if (cur == NULL)
; 2444 : 	    return(0);
; 2445 : 	pos = 0;
; 2446 :     }
; 2447 :     return(1);
; 2448 : }
; 2449 : 
; 2450 : /**
; 2451 :  * xmlXPtrSearchString:
; 2452 :  * @string:  the string to search
; 2453 :  * @start:  the start textnode IN/OUT
; 2454 :  * @startindex:  the start index IN/OUT
; 2455 :  * @end:  the end textnode
; 2456 :  * @endindex:  the end index
; 2457 :  *
; 2458 :  * Search the next occurrence of @string within the document content
; 2459 :  * until the (@end, @endindex) point is reached
; 2460 :  *
; 2461 :  * Returns -1 in case of failure, 0 if not found, 1 if found in which case
; 2462 :  *            (@start, @startindex) will indicate the position of the beginning
; 2463 :  *            of the range and (@end, @endindex) will indicate the end
; 2464 :  *            of the range
; 2465 :  */
; 2466 : static int
; 2467 : xmlXPtrSearchString(const xmlChar *string, xmlNodePtr *start, int *startindex,
; 2468 : 	            xmlNodePtr *end, int *endindex) {
; 2469 :     xmlNodePtr cur;
; 2470 :     const xmlChar *str;
; 2471 :     int pos; /* 0 based */
; 2472 :     int len; /* in bytes */
; 2473 :     xmlChar first;
; 2474 : 
; 2475 :     if (string == NULL)
; 2476 : 	return(-1);
; 2477 :     if ((start == NULL) || (*start == NULL) ||
; 2478 :         ((*start)->type == XML_NAMESPACE_DECL) || (startindex == NULL))
; 2479 : 	return(-1);
; 2480 :     if ((end == NULL) || (endindex == NULL))
; 2481 : 	return(-1);
; 2482 :     cur = *start;
; 2483 :     pos = *startindex - 1;
; 2484 :     first = string[0];
; 2485 : 
; 2486 :     while (cur != NULL) {
; 2487 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {
; 2488 : 	    len = xmlStrlen(cur->content);
; 2489 : 	    while (pos <= len) {
; 2490 : 		if (first != 0) {
; 2491 : 		    str = xmlStrchr(&cur->content[pos], first);
; 2492 : 		    if (str != NULL) {
; 2493 : 			pos = (str - (xmlChar *)(cur->content));
; 2494 : #ifdef DEBUG_RANGES
; 2495 : 			xmlGenericError(xmlGenericErrorContext,
; 2496 : 				"found '%c' at index %d of ->",
; 2497 : 				first, pos + 1);
; 2498 : 			xmlDebugDumpString(stdout, cur->content);
; 2499 : 			xmlGenericError(xmlGenericErrorContext, "\n");
; 2500 : #endif
; 2501 : 			if (xmlXPtrMatchString(string, cur, pos + 1,
; 2502 : 					       end, endindex)) {
; 2503 : 			    *start = cur;
; 2504 : 			    *startindex = pos + 1;
; 2505 : 			    return(1);
; 2506 : 			}
; 2507 : 			pos++;
; 2508 : 		    } else {
; 2509 : 			pos = len + 1;
; 2510 : 		    }
; 2511 : 		} else {
; 2512 : 		    /*
; 2513 : 		     * An empty string is considered to match before each
; 2514 : 		     * character of the string-value and after the final
; 2515 : 		     * character.
; 2516 : 		     */
; 2517 : #ifdef DEBUG_RANGES
; 2518 : 		    xmlGenericError(xmlGenericErrorContext,
; 2519 : 			    "found '' at index %d of ->",
; 2520 : 			    pos + 1);
; 2521 : 		    xmlDebugDumpString(stdout, cur->content);
; 2522 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2523 : #endif
; 2524 : 		    *start = cur;
; 2525 : 		    *startindex = pos + 1;
; 2526 : 		    *end = cur;
; 2527 : 		    *endindex = pos + 1;
; 2528 : 		    return(1);
; 2529 : 		}
; 2530 : 	    }
; 2531 : 	}
; 2532 : 	if ((cur == *end) && (pos >= *endindex))
; 2533 : 	    return(0);
; 2534 : 	cur = xmlXPtrAdvanceNode(cur, NULL);
; 2535 : 	if (cur == NULL)
; 2536 : 	    return(0);
; 2537 : 	pos = 1;
; 2538 :     }
; 2539 :     return(0);
; 2540 : }
; 2541 : 
; 2542 : /**
; 2543 :  * xmlXPtrGetLastChar:
; 2544 :  * @node:  the node
; 2545 :  * @index:  the index
; 2546 :  *
; 2547 :  * Computes the point coordinates of the last char of this point
; 2548 :  *
; 2549 :  * Returns -1 in case of failure, 0 otherwise
; 2550 :  */
; 2551 : static int
; 2552 : xmlXPtrGetLastChar(xmlNodePtr *node, int *indx) {
; 2553 :     xmlNodePtr cur;
; 2554 :     int pos, len = 0;
; 2555 : 
; 2556 :     if ((node == NULL) || (*node == NULL) ||
; 2557 :         ((*node)->type == XML_NAMESPACE_DECL) || (indx == NULL))

	mov	ebx, DWORD PTR _endindex$1$[ebp]
$LN129@xmlXPtrStr:
	mov	esi, DWORD PTR _string$1$[ebp]
	mov	ecx, DWORD PTR [esi+24]
	npad	6
$LL7@xmlXPtrStr:

; 2767 : 	xmlXPtrGetLastChar(&end, &endindex);
; 2768 : 
; 2769 : #ifdef DEBUG_RANGES
; 2770 : 	xmlGenericError(xmlGenericErrorContext,
; 2771 : 		"from index %d of ->", startindex);
; 2772 : 	xmlDebugDumpString(stdout, start->content);
; 2773 : 	xmlGenericError(xmlGenericErrorContext, "\n");
; 2774 : 	xmlGenericError(xmlGenericErrorContext,
; 2775 : 		"to index %d of ->", endindex);
; 2776 : 	xmlDebugDumpString(stdout, end->content);
; 2777 : 	xmlGenericError(xmlGenericErrorContext, "\n");
; 2778 : #endif
; 2779 : 	do {
; 2780 :             fend = end;
; 2781 :             fendindex = endindex;
; 2782 : 	    found = xmlXPtrSearchString(string->stringval, &start, &startindex,

	lea	eax, DWORD PTR _fendindex$[ebp]
	mov	DWORD PTR _fend$[ebp], edi
	push	eax
	lea	eax, DWORD PTR _fend$[ebp]
	mov	DWORD PTR _fendindex$[ebp], ebx
	push	eax
	lea	eax, DWORD PTR _startindex$[ebp]
	push	eax
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	push	ecx
	call	_xmlXPtrSearchString
	add	esp, 20					; 00000014H

; 2783 : 		                        &fend, &fendindex);
; 2784 : 	    if (found == 1) {

	cmp	eax, 1
	jne	$LN121@xmlXPtrStr

; 2785 : 		if (position == NULL) {

	cmp	DWORD PTR _position$1$[ebp], 0
	mov	edi, DWORD PTR _fend$[ebp]
	mov	esi, DWORD PTR _fendindex$[ebp]
	jne	$LN27@xmlXPtrStr
$LN33@xmlXPtrStr:

; 2803 : 				    xmlXPtrNewRange(start, startindex,
; 2804 : 						    start, startindex));
; 2805 : 		    } else {
; 2806 : 			xmlXPtrLocationSetAdd(newset,
; 2807 : 				    xmlXPtrNewRange(start, startindex,
; 2808 : 						    fend, fendindex));
; 2809 : 		    }
; 2810 : 		}
; 2811 : 		start = fend;

	push	esi
	push	edi
	push	DWORD PTR _startindex$[ebp]
	push	DWORD PTR _start$[ebp]
	jmp	$LN147@xmlXPtrStr
$LN69@xmlXPtrStr:

; 2333 : 	if (pos == 0) pos = 1;

	test	esi, esi
	mov	ecx, 1
	cmove	esi, ecx

; 2334 : 	if (bytes == 0) {

	test	ebx, ebx
	je	SHORT $LN106@xmlXPtrStr

; 2338 : 	}
; 2339 : 	/*
; 2340 : 	 * We should have a text (or cdata) node ...
; 2341 : 	 */
; 2342 : 	len = 0;

	xor	ebx, ebx

; 2343 : 	if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	eax, ecx
	je	SHORT $LN80@xmlXPtrStr
	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	je	SHORT $LN80@xmlXPtrStr

; 2344 :             (cur->content != NULL)) {
; 2345 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	ebx, eax
$LN80@xmlXPtrStr:

; 2346 : 	}
; 2347 : 	if (pos > len) {

	cmp	esi, ebx
	jle	SHORT $LN81@xmlXPtrStr

; 2348 : 	    /* Strange, the indx in the text node is greater than it's len */
; 2349 : 	    STRANGE

	call	___xmlGenericError
	mov	esi, eax
	call	___xmlGenericErrorContext
	push	2349					; 0000092dH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	call	eax
	add	esp, 16					; 00000010H

; 2350 : 	    pos = len;

	mov	esi, ebx
$LN81@xmlXPtrStr:

; 2351 : 	}
; 2352 : 	if (pos + bytes >= len) {

	mov	eax, DWORD PTR _bytes$1$[ebp]
	add	eax, esi
	cmp	eax, ebx
	jl	SHORT $LN107@xmlXPtrStr

; 2353 : 	    bytes -= (len - pos);

	sub	esi, ebx
	mov	ebx, DWORD PTR _bytes$1$[ebp]

; 2354 : 	    cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	add	ebx, esi
	push	edi
	mov	DWORD PTR _bytes$1$[ebp], ebx
	call	_xmlXPtrAdvanceNode
	add	esp, 8

; 2355 : 	    pos = 0;

	xor	esi, esi
	mov	edi, eax
	test	ebx, ebx
	jns	$LL66@xmlXPtrStr

; 2305 : 
; 2306 :     while (bytes >= 0) {
; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	jmp	$LN73@xmlXPtrStr
$LN107@xmlXPtrStr:

; 2356 : 	} else if (pos + bytes < len) {
; 2357 : 	    pos += bytes;
; 2358 : 	    *node = cur;

	mov	DWORD PTR _start$[ebp], edi

; 2359 : 	    *indx = pos;

	mov	DWORD PTR _startindex$[ebp], eax
	jmp	$LN73@xmlXPtrStr
$LN106@xmlXPtrStr:

; 2335 : 	    *node = cur;

	mov	DWORD PTR _start$[ebp], edi

; 2336 : 	    *indx = pos;

	mov	DWORD PTR _startindex$[ebp], esi

; 2337 : 	    return(0);

	jmp	$LN73@xmlXPtrStr
$LN94@xmlXPtrStr:

; 2572 : 	else if ((cur->type != XML_ELEMENT_NODE) &&

	cmp	DWORD PTR [esi+4], 1
	je	$LN140@xmlXPtrStr
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	$LN140@xmlXPtrStr

; 2573 : 	         (cur->content != NULL)) {
; 2574 : 	    len = xmlStrlen(cur->content);

	push	eax
	call	_xmlStrlen
	mov	ebx, eax

; 2575 : 	    break;
; 2576 : 	} else {
; 2577 : 	    return(-1);
; 2578 : 	}
; 2579 :     }
; 2580 :     if (cur == NULL)
; 2581 : 	return(-1);
; 2582 :     *node = cur;

	mov	edi, esi
	add	esp, 4
	mov	DWORD PTR _endindex$1$[ebp], ebx
	mov	DWORD PTR _end$1$[ebp], edi
	jmp	$LN129@xmlXPtrStr
$LN27@xmlXPtrStr:

; 2786 : 		    xmlXPtrLocationSetAdd(newset,
; 2787 : 			 xmlXPtrNewRange(start, startindex, fend, fendindex));
; 2788 : 		} else if (xmlXPtrAdvanceChar(&start, &startindex,
; 2789 : 			                      pos - 1) == 0) {

	mov	eax, DWORD PTR _pos$1$[ebp]
	dec	eax
	push	eax
	lea	eax, DWORD PTR _startindex$[ebp]
	push	eax
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrAdvanceChar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@xmlXPtrStr

; 2790 : 		    if ((number != NULL) && (num > 0)) {

	cmp	DWORD PTR _number$1$[ebp], eax
	je	$LN33@xmlXPtrStr
	mov	ecx, DWORD PTR _num$1$[ebp]
	test	ecx, ecx
	jle	SHORT $LN30@xmlXPtrStr

; 2791 : 			int rindx;
; 2792 : 			xmlNodePtr rend;
; 2793 : 			rend = start;
; 2794 : 			rindx = startindex - 1;

	mov	eax, DWORD PTR _startindex$[ebp]
	mov	ebx, DWORD PTR _start$[ebp]
	dec	eax
	mov	DWORD PTR _rindx$1[ebp], eax

; 2795 : 			if (xmlXPtrAdvanceChar(&rend, &rindx,
; 2796 : 				               num) == 0) {

	lea	eax, DWORD PTR _rindx$1[ebp]
	push	ecx
	push	eax
	lea	eax, DWORD PTR _rend$2[ebp]
	mov	DWORD PTR _rend$2[ebp], ebx
	push	eax
	call	_xmlXPtrAdvanceChar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN135@xmlXPtrStr

; 2797 : 			    xmlXPtrLocationSetAdd(newset,

	push	DWORD PTR _rindx$1[ebp]
	push	DWORD PTR _rend$2[ebp]
	push	DWORD PTR _startindex$[ebp]
	push	ebx
	call	_xmlXPtrNewRange
	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 24					; 00000018H
$LN135@xmlXPtrStr:

; 2803 : 				    xmlXPtrNewRange(start, startindex,
; 2804 : 						    start, startindex));
; 2805 : 		    } else {
; 2806 : 			xmlXPtrLocationSetAdd(newset,
; 2807 : 				    xmlXPtrNewRange(start, startindex,
; 2808 : 						    fend, fendindex));
; 2809 : 		    }
; 2810 : 		}
; 2811 : 		start = fend;

	mov	ebx, DWORD PTR _endindex$1$[ebp]
$LN34@xmlXPtrStr:

; 2812 : 		startindex = fendindex;
; 2813 : 		if (string->stringval[0] == 0)

	mov	eax, DWORD PTR _string$1$[ebp]
	mov	DWORD PTR _start$[ebp], edi
	mov	edi, DWORD PTR _end$1$[ebp]
	mov	DWORD PTR _startindex$[ebp], esi
	mov	ecx, DWORD PTR [eax+24]
	cmp	BYTE PTR [ecx], 0
	jne	$LL7@xmlXPtrStr

; 2814 : 		    startindex++;

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _startindex$[ebp], eax

; 2815 : 	    }
; 2816 : 	} while (found == 1);

	jmp	$LL7@xmlXPtrStr
$LN30@xmlXPtrStr:

; 2798 : 					xmlXPtrNewRange(start, startindex,
; 2799 : 							rend, rindx));
; 2800 : 			}
; 2801 : 		    } else if ((number != NULL) && (num <= 0)) {
; 2802 : 			xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR _startindex$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	push	ecx
	push	eax
	push	ecx
	push	eax
$LN147@xmlXPtrStr:

; 2803 : 				    xmlXPtrNewRange(start, startindex,
; 2804 : 						    start, startindex));
; 2805 : 		    } else {
; 2806 : 			xmlXPtrLocationSetAdd(newset,
; 2807 : 				    xmlXPtrNewRange(start, startindex,
; 2808 : 						    fend, fendindex));
; 2809 : 		    }
; 2810 : 		}
; 2811 : 		start = fend;

	call	_xmlXPtrNewRange
	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 24					; 00000018H
	jmp	SHORT $LN34@xmlXPtrStr
$LN121@xmlXPtrStr:

; 2754 : 
; 2755 :     /*
; 2756 :      * The loop is to search for each element in the location set
; 2757 :      * the list of location set corresponding to that search
; 2758 :      */
; 2759 :     for (i = 0;i < oldset->locNr;i++) {

	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _oldset$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jl	$LL4@xmlXPtrStr
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR _string$1$[ebp]
	mov	edi, DWORD PTR _set$1$[ebp]
$error$149:

; 2817 :     }
; 2818 : 
; 2819 :     /*
; 2820 :      * Save the new value and cleanup
; 2821 :      */
; 2822 : error:
; 2823 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	ebx
	call	_valuePush

; 2824 :     xmlXPathFreeObject(set);

	push	edi
	call	_xmlXPathFreeObject

; 2825 :     xmlXPathFreeObject(string);

	push	esi
	call	_xmlXPathFreeObject

; 2826 :     if (position) xmlXPathFreeObject(position);

	mov	eax, DWORD PTR _position$1$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN36@xmlXPtrStr
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN36@xmlXPtrStr:

; 2827 :     if (number) xmlXPathFreeObject(number);

	mov	eax, DWORD PTR _number$1$[ebp]
	test	eax, eax
	je	$LN143@xmlXPtrStr
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
	pop	edi
	pop	ebx
	pop	esi

; 2828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlXPtrStr:

; 2724 :     }
; 2725 :     CHECK_TYPE(XPATH_STRING);

	push	11					; 0000000bH
	push	ebx
	call	_xmlXPathErr
	add	esp, 8
	pop	ebx
	pop	esi

; 2828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPtrStr:

; 2697 :     int i, startindex, endindex = 0, fendindex;
; 2698 :     xmlNodePtr start, end = 0, fend;
; 2699 :     xmlXPathObjectPtr set;
; 2700 :     xmlLocationSetPtr oldset;
; 2701 :     xmlLocationSetPtr newset;
; 2702 :     xmlXPathObjectPtr string;
; 2703 :     xmlXPathObjectPtr position = NULL;
; 2704 :     xmlXPathObjectPtr number = NULL;
; 2705 :     int found, pos = 0, num = 0;
; 2706 : 
; 2707 :     /*
; 2708 :      * Grab the arguments
; 2709 :      */
; 2710 :     if ((nargs < 2) || (nargs > 4))
; 2711 : 	XP_ERROR(XPATH_INVALID_ARITY);

	push	12					; 0000000cH
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 2828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrStringRangeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalXPointer
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlXPtrEvalXPointer PROC				; COMDAT

; 1228 : xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN70@xmlXPtrEva

; 1229 :     if (ctxt->valueTab == NULL) {
; 1230 : 	/* Allocate the value stack */
; 1231 : 	ctxt->valueTab = (xmlXPathObjectPtr *)

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+28], eax

; 1232 : 			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
; 1233 : 	if (ctxt->valueTab == NULL) {

	test	eax, eax
	jne	SHORT $LN7@xmlXPtrEva

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	esi

; 1264 : }

	pop	ebp
	ret	0
$LN7@xmlXPtrEva:

; 1234 : 	    xmlXPtrErrMemory("allocating evaluation context");
; 1235 : 	    return;
; 1236 : 	}
; 1237 : 	ctxt->valueNr = 0;

	mov	DWORD PTR [esi+20], 0

; 1238 : 	ctxt->valueMax = 10;

	mov	DWORD PTR [esi+24], 10			; 0000000aH

; 1239 : 	ctxt->value = NULL;

	mov	DWORD PTR [esi+16], 0

; 1240 : 	ctxt->valueFrame = 0;

	mov	DWORD PTR [esi+44], 0
$LN70@xmlXPtrEva:
	mov	ecx, DWORD PTR [esi]
$LL2@xmlXPtrEva:

; 1241 :     }
; 1242 :     SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN8@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN9@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN8@xmlXPtrEva
$LN9@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPtrEva
$LN8@xmlXPtrEva:
	test	al, al
	je	SHORT $LL2@xmlXPtrEva
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL2@xmlXPtrEva
$LN3@xmlXPtrEva:

; 1243 :     if (CUR == '/') {

	push	esi
	cmp	al, 47					; 0000002fH
	jne	SHORT $LN10@xmlXPtrEva

; 1244 : 	xmlXPathRoot(ctxt);

	call	_xmlXPathRoot
	add	esp, 4

; 1245 :         xmlXPtrEvalChildSeq(ctxt, NULL);

	xor	ecx, ecx
$LN13@xmlXPtrEva:
	push	ecx
	push	esi
	call	_xmlXPtrEvalChildSeq
	add	esp, 8
$LL4@xmlXPtrEva:

; 1253 : 	    xmlXPtrEvalFullXPtr(ctxt, name);
; 1254 : 	    /* Short evaluation */
; 1255 : 	    return;
; 1256 : 	} else {
; 1257 : 	    /* this handle both Bare Names and Child Sequences */
; 1258 : 	    xmlXPtrEvalChildSeq(ctxt, name);
; 1259 : 	}
; 1260 :     }
; 1261 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN15@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN16@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPtrEva
$LN16@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	$LN5@xmlXPtrEva
$LN15@xmlXPtrEva:
	test	al, al
	je	SHORT $LL4@xmlXPtrEva
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL4@xmlXPtrEva
$LN10@xmlXPtrEva:

; 1246 :     } else {
; 1247 : 	xmlChar *name;
; 1248 : 
; 1249 : 	name = xmlXPathParseName(ctxt);

	call	_xmlXPathParseName
	mov	ecx, eax
	add	esp, 4

; 1250 : 	if (name == NULL)

	test	ecx, ecx
	je	$LN96@xmlXPtrEva

; 1251 : 	    XP_ERROR(XPATH_EXPR_ERROR);
; 1252 : 	if (CUR == '(') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 40			; 00000028H
	jne	SHORT $LN13@xmlXPtrEva
$LL26@xmlXPtrEva:

; 1124 : 	xmlXPtrEvalXPtrPart(ctxt, name);

	push	ecx
	push	esi
	mov	DWORD PTR [esi+8], 0
	call	_xmlXPtrEvalXPtrPart

; 1125 : 
; 1126 : 	/* in case of syntax error, break here */
; 1127 : 	if ((ctxt->error != XPATH_EXPRESSION_OK) &&

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN80@xmlXPtrEva
	cmp	eax, 1900				; 0000076cH
	jne	$LN17@xmlXPtrEva
$LN80@xmlXPtrEva:

; 1128 :             (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))
; 1129 : 	    return;
; 1130 : 
; 1131 : 	/*
; 1132 : 	 * If the returned value is a non-empty nodeset
; 1133 : 	 * or location set, return here.
; 1134 : 	 */
; 1135 : 	if (ctxt->value != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN31@xmlXPtrEva

; 1136 : 	    xmlXPathObjectPtr obj = ctxt->value;
; 1137 : 
; 1138 : 	    switch (obj->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	je	SHORT $LN41@xmlXPtrEva
	sub	ecx, 6
	jne	SHORT $LL32@xmlXPtrEva

; 1139 : 		case XPATH_LOCATIONSET: {
; 1140 : 		    xmlLocationSetPtr loc = ctxt->value->user;

	mov	eax, DWORD PTR [eax+28]

; 1141 : 		    if ((loc != NULL) && (loc->locNr > 0))
; 1142 : 			return;
; 1143 : 		    break;

	jmp	SHORT $LN126@xmlXPtrEva
$LN41@xmlXPtrEva:

; 1144 : 		}
; 1145 : 		case XPATH_NODESET: {
; 1146 : 		    xmlNodeSetPtr loc = ctxt->value->nodesetval;

	mov	eax, DWORD PTR [eax+4]
$LN126@xmlXPtrEva:

; 1147 : 		    if ((loc != NULL) && (loc->nodeNr > 0))
; 1148 : 			return;
; 1149 : 		    break;
; 1150 : 		}
; 1151 : 		default:
; 1152 : 		    break;
; 1153 : 	    }
; 1154 : 
; 1155 : 	    /*
; 1156 : 	     * Evaluating to improper values is equivalent to
; 1157 : 	     * a sub-resource error, clean-up the stack
; 1158 : 	     */
; 1159 : 	    do {
; 1160 : 		obj = valuePop(ctxt);

	test	eax, eax
	je	SHORT $LL32@xmlXPtrEva
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN17@xmlXPtrEva
	npad	7
$LL32@xmlXPtrEva:
	push	esi
	call	_valuePop
	add	esp, 4

; 1161 : 		if (obj != NULL) {

	test	eax, eax
	je	SHORT $LN31@xmlXPtrEva

; 1162 : 		    xmlXPathFreeObject(obj);

	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1163 : 		}
; 1164 : 	    } while (obj != NULL);

	jmp	SHORT $LL32@xmlXPtrEva
$LN31@xmlXPtrEva:

; 1125 : 
; 1126 : 	/* in case of syntax error, break here */
; 1127 : 	if ((ctxt->error != XPATH_EXPRESSION_OK) &&

	mov	ecx, DWORD PTR [esi]
	npad	6
$LL33@xmlXPtrEva:

; 1165 : 	}
; 1166 : 
; 1167 : 	/*
; 1168 : 	 * Is there another XPointer part.
; 1169 : 	 */
; 1170 : 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN45@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN46@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN45@xmlXPtrEva
$LN46@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN34@xmlXPtrEva
$LN45@xmlXPtrEva:
	test	al, al
	je	SHORT $LL33@xmlXPtrEva
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL33@xmlXPtrEva
$LN34@xmlXPtrEva:

; 1171 : 	name = xmlXPathParseName(ctxt);

	push	esi
	call	_xmlXPathParseName
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	$LL26@xmlXPtrEva
	pop	esi

; 1264 : }

	pop	ebp
	ret	0
$LN5@xmlXPtrEva:

; 1262 :     if (CUR != 0)

	test	al, al
	je	SHORT $LN17@xmlXPtrEva
$LN96@xmlXPtrEva:

; 1263 : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN17@xmlXPtrEva:
	pop	esi

; 1264 : }

	pop	ebp
	ret	0
_xmlXPtrEvalXPointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalFullXPtr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalFullXPtr PROC				; COMDAT

; 1117 : xmlXPtrEvalFullXPtr(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _name$[ebp]
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	jne	SHORT $LL2@xmlXPtrEva

; 1118 :     if (name == NULL)
; 1119 :     name = xmlXPathParseName(ctxt);

	push	esi
	call	_xmlXPathParseName
	add	esp, 4

; 1120 :     if (name == NULL)

	test	eax, eax
	jne	SHORT $LL2@xmlXPtrEva

; 1121 : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 1172 :     }
; 1173 : }

	pop	ebp
	ret	0
$LL2@xmlXPtrEva:

; 1122 :     while (name != NULL) {
; 1123 : 	ctxt->error = XPATH_EXPRESSION_OK;
; 1124 : 	xmlXPtrEvalXPtrPart(ctxt, name);

	push	eax
	push	esi
	mov	DWORD PTR [esi+8], 0
	call	_xmlXPtrEvalXPtrPart

; 1125 : 
; 1126 : 	/* in case of syntax error, break here */
; 1127 : 	if ((ctxt->error != XPATH_EXPRESSION_OK) &&

	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@xmlXPtrEva
	cmp	eax, 1900				; 0000076cH
	jne	SHORT $LN69@xmlXPtrEva
$LN42@xmlXPtrEva:

; 1128 :             (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))
; 1129 : 	    return;
; 1130 : 
; 1131 : 	/*
; 1132 : 	 * If the returned value is a non-empty nodeset
; 1133 : 	 * or location set, return here.
; 1134 : 	 */
; 1135 : 	if (ctxt->value != NULL) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN7@xmlXPtrEva

; 1136 : 	    xmlXPathObjectPtr obj = ctxt->value;
; 1137 : 
; 1138 : 	    switch (obj->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	je	SHORT $LN17@xmlXPtrEva
	sub	ecx, 6
	jne	SHORT $LL8@xmlXPtrEva

; 1139 : 		case XPATH_LOCATIONSET: {
; 1140 : 		    xmlLocationSetPtr loc = ctxt->value->user;

	mov	eax, DWORD PTR [eax+28]

; 1141 : 		    if ((loc != NULL) && (loc->locNr > 0))
; 1142 : 			return;
; 1143 : 		    break;

	jmp	SHORT $LN75@xmlXPtrEva
$LN17@xmlXPtrEva:

; 1144 : 		}
; 1145 : 		case XPATH_NODESET: {
; 1146 : 		    xmlNodeSetPtr loc = ctxt->value->nodesetval;

	mov	eax, DWORD PTR [eax+4]
$LN75@xmlXPtrEva:

; 1147 : 		    if ((loc != NULL) && (loc->nodeNr > 0))
; 1148 : 			return;
; 1149 : 		    break;
; 1150 : 		}
; 1151 : 		default:
; 1152 : 		    break;
; 1153 : 	    }
; 1154 : 
; 1155 : 	    /*
; 1156 : 	     * Evaluating to improper values is equivalent to
; 1157 : 	     * a sub-resource error, clean-up the stack
; 1158 : 	     */
; 1159 : 	    do {
; 1160 : 		obj = valuePop(ctxt);

	test	eax, eax
	je	SHORT $LL8@xmlXPtrEva
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN69@xmlXPtrEva
$LL8@xmlXPtrEva:
	push	esi
	call	_valuePop
	add	esp, 4

; 1161 : 		if (obj != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlXPtrEva

; 1162 : 		    xmlXPathFreeObject(obj);

	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1163 : 		}
; 1164 : 	    } while (obj != NULL);

	jmp	SHORT $LL8@xmlXPtrEva
$LN7@xmlXPtrEva:

; 1125 : 
; 1126 : 	/* in case of syntax error, break here */
; 1127 : 	if ((ctxt->error != XPATH_EXPRESSION_OK) &&

	mov	ecx, DWORD PTR [esi]
$LL9@xmlXPtrEva:

; 1165 : 	}
; 1166 : 
; 1167 : 	/*
; 1168 : 	 * Is there another XPointer part.
; 1169 : 	 */
; 1170 : 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN21@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN22@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN21@xmlXPtrEva
$LN22@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN10@xmlXPtrEva
$LN21@xmlXPtrEva:
	test	al, al
	je	SHORT $LL9@xmlXPtrEva
	inc	ecx
	mov	DWORD PTR [esi], ecx
	jmp	SHORT $LL9@xmlXPtrEva
$LN10@xmlXPtrEva:

; 1171 : 	name = xmlXPathParseName(ctxt);

	push	esi
	call	_xmlXPathParseName
	add	esp, 4
	test	eax, eax
	jne	$LL2@xmlXPtrEva
$LN69@xmlXPtrEva:
	pop	esi

; 1172 :     }
; 1173 : }

	pop	ebp
	ret	0
_xmlXPtrEvalFullXPtr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalXPtrPart
_TEXT	SEGMENT
_left$1$ = -12						; size = 4
_value$1$ = -8						; size = 4
_prefix$1$ = -4						; size = 4
_cur$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buffer$1$ = 12						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalXPtrPart PROC				; COMDAT

; 949  : xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	ebx
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _name$[ebp]
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	ebx, ebx
	jne	SHORT $LN9@xmlXPtrEva

; 950  :     xmlChar *buffer, *cur;
; 951  :     int len;
; 952  :     int level;
; 953  : 
; 954  :     if (name == NULL)
; 955  :     name = xmlXPathParseName(ctxt);

	push	edi
	call	_xmlXPathParseName
	mov	ebx, eax
	add	esp, 4

; 956  :     if (name == NULL)

	test	ebx, ebx
	jne	SHORT $LN9@xmlXPtrEva

; 957  : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	edi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlXPtrEva:

; 958  : 
; 959  :     if (CUR != '(') {

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax], 40			; 00000028H
	je	SHORT $LN10@xmlXPtrEva

; 960  :         xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 961  : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	edi
	call	_xmlXPathErr
	add	esp, 12					; 0000000cH
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlXPtrEva:

; 962  :     }
; 963  :     NEXT;

	inc	eax
	push	esi

; 964  :     level = 1;
; 965  : 
; 966  :     len = xmlStrlen(ctxt->cur);

	push	eax
	mov	DWORD PTR [edi], eax
	mov	esi, 1
	call	_xmlStrlen

; 967  :     len++;

	inc	eax

; 968  :     buffer = (xmlChar *) xmlMallocAtomic(len * sizeof (xmlChar));

	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 8
	mov	DWORD PTR _buffer$1$[ebp], eax

; 969  :     if (buffer == NULL) {

	test	eax, eax
	jne	SHORT $LN11@xmlXPtrEva

; 970  :         xmlXPtrErrMemory("allocating buffer");

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	call	_xmlXPtrErrMemory

; 1086 :     xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlXPtrEva:

; 971  :         xmlFree(name);
; 972  : 	return;
; 973  :     }
; 974  : 
; 975  :     cur = buffer;
; 976  :     while (CUR != 0) {

	mov	ecx, DWORD PTR [edi]
	mov	edx, eax
	mov	DWORD PTR _cur$1$[ebp], edx
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN73@xmlXPtrEva
$LL2@xmlXPtrEva:

; 977  : 	if (CUR == ')') {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN12@xmlXPtrEva

; 978  : 	    level--;

	sub	esi, 1

; 979  : 	    if (level == 0) {

	jne	SHORT $LN43@xmlXPtrEva

; 980  : 		NEXT;

	mov	edx, DWORD PTR _cur$1$[ebp]
	test	al, al
	je	SHORT $LN73@xmlXPtrEva
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], eax
	jmp	SHORT $LN73@xmlXPtrEva
$LN12@xmlXPtrEva:

; 981  : 		break;
; 982  : 	    }
; 983  : 	} else if (CUR == '(') {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN15@xmlXPtrEva

; 984  : 	    level++;

	inc	esi
	jmp	SHORT $LN43@xmlXPtrEva
$LN15@xmlXPtrEva:

; 985  : 	} else if (CUR == '^') {

	cmp	al, 94					; 0000005eH
	jne	SHORT $LN43@xmlXPtrEva

; 986  :             if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {

	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	cmp	dl, 41					; 00000029H
	je	SHORT $LN19@xmlXPtrEva
	cmp	dl, 40					; 00000028H
	je	SHORT $LN19@xmlXPtrEva
	cmp	dl, al
	jne	SHORT $LN43@xmlXPtrEva
$LN19@xmlXPtrEva:

; 987  :                 NEXT;

	mov	DWORD PTR [edi], ecx
	mov	al, BYTE PTR [ecx]
$LN43@xmlXPtrEva:

; 988  :             }
; 989  : 	}
; 990  :         *cur++ = CUR;

	mov	ecx, DWORD PTR _cur$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR _cur$1$[ebp], ecx

; 991  : 	NEXT;

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN70@xmlXPtrEva
	inc	ecx
	mov	DWORD PTR [edi], ecx
$LN70@xmlXPtrEva:

; 971  :         xmlFree(name);
; 972  : 	return;
; 973  :     }
; 974  : 
; 975  :     cur = buffer;
; 976  :     while (CUR != 0) {

	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL2@xmlXPtrEva
	mov	edx, DWORD PTR _cur$1$[ebp]
$LN73@xmlXPtrEva:

; 992  :     }
; 993  :     *cur = 0;

	mov	BYTE PTR [edx], 0

; 994  : 
; 995  :     if ((level != 0) && (CUR == 0)) {

	test	esi, esi
	je	SHORT $LN71@xmlXPtrEva
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN71@xmlXPtrEva

; 996  :         xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 997  : 	xmlFree(buffer);

	mov	eax, DWORD PTR _buffer$1$[ebp]
	push	eax

; 998  : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	jmp	$LN79@xmlXPtrEva
$LN71@xmlXPtrEva:

; 999  :     }
; 1000 : 
; 1001 :     if (xmlStrEqual(name, (xmlChar *) "xpointer")) {

	push	OFFSET ??_C@_08DNJCJFMK@xpointer@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlXPtrEva

; 1002 : 	const xmlChar *left = CUR_PTR;
; 1003 : 
; 1004 : 	CUR_PTR = buffer;
; 1005 : 	/*
; 1006 : 	 * To evaluate an xpointer scheme element (4.3) we need:
; 1007 : 	 *   context initialized to the root
; 1008 : 	 *   context position initalized to 1
; 1009 : 	 *   context size initialized to 1
; 1010 : 	 */
; 1011 : 	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;

	mov	ecx, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [edi]
	mov	eax, DWORD PTR _buffer$1$[ebp]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1012 : 	ctxt->context->proximityPosition = 1;

	mov	eax, DWORD PTR [edi+12]

; 1013 : 	ctxt->context->contextSize = 1;
; 1014 : 	xmlXPathEvalExpr(ctxt);

	push	edi
	mov	DWORD PTR [eax+72], 1
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+68], 1
	call	_xmlXPathEvalExpr
	add	esp, 4

; 1015 : 	CUR_PTR=left;

	mov	DWORD PTR [edi], esi
	jmp	$LN29@xmlXPtrEva
$LN21@xmlXPtrEva:

; 1016 :     } else if (xmlStrEqual(name, (xmlChar *) "element")) {

	push	OFFSET ??_C@_07HCLJNICE@element@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlXPtrEva

; 1017 : 	const xmlChar *left = CUR_PTR;
; 1018 : 	xmlChar *name2;
; 1019 : 
; 1020 : 	CUR_PTR = buffer;

	mov	eax, DWORD PTR _buffer$1$[ebp]
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], eax

; 1021 : 	if (buffer[0] == '/') {

	push	edi
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN25@xmlXPtrEva

; 1022 : 	    xmlXPathRoot(ctxt);

	call	_xmlXPathRoot
	add	esp, 4

; 1023 : 	    xmlXPtrEvalChildSeq(ctxt, NULL);

	xor	eax, eax
$LN27@xmlXPtrEva:

; 1031 : 	    }
; 1032 : 	    xmlXPtrEvalChildSeq(ctxt, name2);
; 1033 : 	}
; 1034 : 	CUR_PTR = left;

	push	eax
	push	edi
	call	_xmlXPtrEvalChildSeq
	add	esp, 8
	mov	DWORD PTR [edi], esi
	jmp	$LN29@xmlXPtrEva
$LN25@xmlXPtrEva:

; 1024 : 	} else {
; 1025 : 	    name2 = xmlXPathParseName(ctxt);

	call	_xmlXPathParseName
	add	esp, 4

; 1026 : 	    if (name2 == NULL) {

	test	eax, eax
	jne	SHORT $LN27@xmlXPtrEva

; 1027 : 		CUR_PTR = left;
; 1028 : 		xmlFree(buffer);

	mov	eax, DWORD PTR _buffer$1$[ebp]
	push	eax
	mov	DWORD PTR [edi], esi
	call	DWORD PTR _xmlFree

; 1029 :                 xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 1030 : 		XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	push	edi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlXPtrEva:

; 1035 : #ifdef XPTR_XMLNS_SCHEME
; 1036 :     } else if (xmlStrEqual(name, (xmlChar *) "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	ebx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlXPtrEva

; 1037 : 	const xmlChar *left = CUR_PTR;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _left$1$[ebp], eax

; 1038 : 	xmlChar *prefix;
; 1039 : 	xmlChar *URI;
; 1040 : 	xmlURIPtr value;
; 1041 : 
; 1042 : 	CUR_PTR = buffer;

	mov	eax, DWORD PTR _buffer$1$[ebp]

; 1043 :         prefix = xmlXPathParseNCName(ctxt);

	push	edi
	mov	DWORD PTR [edi], eax
	call	_xmlXPathParseNCName
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _prefix$1$[ebp], esi

; 1044 : 	if (prefix == NULL) {

	test	esi, esi
	jne	SHORT $LN61@xmlXPtrEva

; 1045 : 	    xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree

; 1046 : 	    xmlFree(name);

	push	ebx
$LN79@xmlXPtrEva:
	call	DWORD PTR _xmlFree

; 1047 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	edi
	call	_xmlXPathErr
	add	esp, 16					; 00000010H
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@xmlXPtrEva:
	mov	ecx, DWORD PTR [edi]
	npad	4
$LL4@xmlXPtrEva:

; 1048 : 	}
; 1049 : 	SKIP_BLANKS;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN31@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN32@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN31@xmlXPtrEva
$LN32@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrEva
$LN31@xmlXPtrEva:
	test	al, al
	je	SHORT $LL4@xmlXPtrEva
	inc	ecx
	mov	DWORD PTR [edi], ecx
	jmp	SHORT $LL4@xmlXPtrEva
$LN5@xmlXPtrEva:

; 1050 : 	if (CUR != '=') {

	cmp	al, 61					; 0000003dH
	jne	$LN72@xmlXPtrEva
$LN78@xmlXPtrEva:

; 1051 : 	    xmlFree(prefix);
; 1052 : 	    xmlFree(buffer);
; 1053 : 	    xmlFree(name);
; 1054 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);
; 1055 : 	}
; 1056 : 	NEXT;
; 1057 : 	SKIP_BLANKS;

	inc	ecx
	mov	DWORD PTR [edi], ecx
$LL6@xmlXPtrEva:
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN34@xmlXPtrEva
	cmp	al, 9
	jb	SHORT $LN35@xmlXPtrEva
	cmp	al, 10					; 0000000aH
	jbe	SHORT $LN34@xmlXPtrEva
$LN35@xmlXPtrEva:
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPtrEva
$LN34@xmlXPtrEva:
	test	al, al
	je	SHORT $LL6@xmlXPtrEva
	jmp	SHORT $LN78@xmlXPtrEva
$LN7@xmlXPtrEva:

; 1058 : 	/* @@ check escaping in the XPointer WD */
; 1059 : 
; 1060 : 	value = xmlParseURI((const char *)ctxt->cur);

	push	ecx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _value$1$[ebp], eax

; 1061 : 	if (value == NULL) {

	test	eax, eax
	je	SHORT $LN72@xmlXPtrEva

; 1066 : 	}
; 1067 : 	URI = xmlSaveUri(value);

	push	eax
	call	_xmlSaveUri

; 1068 : 	xmlFreeURI(value);

	push	DWORD PTR _value$1$[ebp]
	mov	esi, eax
	call	_xmlFreeURI
	add	esp, 8

; 1069 : 	if (URI == NULL) {

	test	esi, esi
	jne	SHORT $LN37@xmlXPtrEva

; 1070 : 	    xmlFree(prefix);

	push	DWORD PTR _prefix$1$[ebp]
	call	DWORD PTR _xmlFree

; 1071 : 	    xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree

; 1072 : 	    xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 1073 : 	    XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	push	edi
	call	_xmlXPathErr
	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlXPtrEva:

; 1074 : 	}
; 1075 : 
; 1076 : 	xmlXPathRegisterNs(ctxt->context, prefix, URI);

	push	esi
	push	DWORD PTR _prefix$1$[ebp]
	push	DWORD PTR [edi+12]
	call	_xmlXPathRegisterNs

; 1077 : 	CUR_PTR = left;

	mov	eax, DWORD PTR _left$1$[ebp]

; 1078 : 	xmlFree(URI);

	push	esi
	mov	DWORD PTR [edi], eax
	call	DWORD PTR _xmlFree

; 1079 : 	xmlFree(prefix);

	push	DWORD PTR _prefix$1$[ebp]
	call	DWORD PTR _xmlFree
	add	esp, 20					; 00000014H

; 1080 : #endif /* XPTR_XMLNS_SCHEME */
; 1081 :     } else {

	jmp	SHORT $LN29@xmlXPtrEva
$LN72@xmlXPtrEva:

; 1062 : 	    xmlFree(prefix);

	push	esi
	call	DWORD PTR _xmlFree

; 1063 : 	    xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree

; 1064 : 	    xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree

; 1065 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	push	edi
	call	_xmlXPathErr
	add	esp, 20					; 00000014H
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlXPtrEva:

; 1082 :         xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,

	push	ebx
	push	OFFSET ??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@
	push	1900					; 0000076cH
	push	edi
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H
$LN29@xmlXPtrEva:

; 1083 : 		   "unsupported scheme '%s'\n", name);
; 1084 :     }
; 1085 :     xmlFree(buffer);

	push	DWORD PTR _buffer$1$[ebp]
	call	DWORD PTR _xmlFree

; 1086 :     xmlFree(name);

	push	ebx
	call	DWORD PTR _xmlFree
	add	esp, 8
	pop	esi
	pop	edi

; 1087 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalXPtrPart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetChildNo
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrGetChildNo PROC					; COMDAT

; 891  : xmlXPtrGetChildNo(xmlXPathParserContextPtr ctxt, int indx) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN3@xmlXPtrGet

; 892  :     xmlNodePtr cur = NULL;
; 893  :     xmlXPathObjectPtr obj;
; 894  :     xmlNodeSetPtr oldset;
; 895  : 
; 896  :     CHECK_TYPE(XPATH_NODESET);

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@xmlXPtrGet

; 897  :     obj = valuePop(ctxt);

	push	ebx
	push	edi
	push	esi
	call	_valuePop
	mov	edi, eax
	add	esp, 4

; 898  :     oldset = obj->nodesetval;
; 899  :     if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {

	mov	eax, DWORD PTR _indx$[ebp]
	test	eax, eax
	jle	SHORT $LN5@xmlXPtrGet
	mov	ebx, DWORD PTR [edi+4]
	test	ebx, ebx
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR [ebx], 1
	jne	SHORT $LN5@xmlXPtrGet

; 902  : 	return;
; 903  :     }
; 904  :     cur = xmlXPtrGetNthChild(oldset->nodeTab[0], indx);

	push	eax
	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax]
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	ecx, eax

; 905  :     if (cur == NULL) {

	push	edi
	test	ecx, ecx
	je	SHORT $LN10@xmlXPtrGet

; 906  : 	xmlXPathFreeObject(obj);
; 907  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));
; 908  : 	return;
; 909  :     }
; 910  :     oldset->nodeTab[0] = cur;

	mov	eax, DWORD PTR [ebx+8]

; 911  :     valuePush(ctxt, obj);

	push	esi
	mov	DWORD PTR [eax], ecx
	call	_valuePush
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 912  : }

	pop	ebp
	ret	0
$LN5@xmlXPtrGet:

; 900  : 	xmlXPathFreeObject(obj);

	push	edi
$LN10@xmlXPtrGet:
	call	_xmlXPathFreeObject

; 901  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));

	push	0
	call	_xmlXPathNewNodeSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 912  : }

	pop	ebp
	ret	0
$LN3@xmlXPtrGet:

; 892  :     xmlNodePtr cur = NULL;
; 893  :     xmlXPathObjectPtr obj;
; 894  :     xmlNodeSetPtr oldset;
; 895  : 
; 896  :     CHECK_TYPE(XPATH_NODESET);

	push	11					; 0000000bH
	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	esi

; 912  : }

	pop	ebp
	ret	0
_xmlXPtrGetChildNo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalChildSeq
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_oldset$1$ = 12						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalChildSeq PROC				; COMDAT

; 1187 : xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _name$[ebp]
	test	esi, esi
	jne	SHORT $LN27@xmlXPtrEva

; 1188 :     /*
; 1189 :      * XPointer don't allow by syntax to address in mutirooted trees
; 1190 :      * this might prove useful in some cases, warn about it.
; 1191 :      */
; 1192 :     if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {

	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax], 47			; 0000002fH
	jne	SHORT $LN21@xmlXPtrEva
	cmp	BYTE PTR [eax+1], 49			; 00000031H
	je	SHORT $LN21@xmlXPtrEva

; 1193 :         xmlXPtrErr(ctxt, XML_XPTR_CHILDSEQ_START,

	push	esi
	push	OFFSET ??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@
	push	1901					; 0000076dH
	push	edi
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H

; 1194 : 		   "warning: ChildSeq not starting by /1\n", NULL);
; 1195 :     }
; 1196 : 
; 1197 :     if (name != NULL) {

	jmp	SHORT $LN21@xmlXPtrEva
$LN27@xmlXPtrEva:

; 1198 : 	valuePush(ctxt, xmlXPathNewString(name));

	push	esi
	call	_xmlXPathNewString
	mov	edi, DWORD PTR _ctxt$[ebp]
	push	eax
	push	edi
	call	_valuePush

; 1199 : 	xmlFree(name);

	push	esi
	call	DWORD PTR _xmlFree

; 1200 : 	xmlXPathIdFunction(ctxt, 1);

	push	1
	push	edi
	call	_xmlXPathIdFunction
	add	esp, 24					; 00000018H

; 1201 : 	CHECK_ERROR;

	cmp	DWORD PTR [edi+8], 0
	jne	$LN3@xmlXPtrEva
$LN21@xmlXPtrEva:

; 1202 :     }
; 1203 : 
; 1204 :     while (CUR == '/') {

	mov	esi, DWORD PTR [edi]
	mov	al, BYTE PTR [esi]
	cmp	al, 47					; 0000002fH
	jne	$LN3@xmlXPtrEva
	push	ebx
$LL2@xmlXPtrEva:

; 1205 : 	int child = 0;

	xor	ebx, ebx

; 1206 : 	NEXT;

	test	al, al
	je	SHORT $LN28@xmlXPtrEva
	inc	esi
	mov	DWORD PTR [edi], esi
	mov	al, BYTE PTR [esi]
$LN28@xmlXPtrEva:

; 1207 : 
; 1208 : 	while ((CUR >= '0') && (CUR <= '9')) {

	cmp	al, 48					; 00000030H
	jb	SHORT $LN29@xmlXPtrEva
$LL4@xmlXPtrEva:
	cmp	al, 57					; 00000039H
	ja	SHORT $LN29@xmlXPtrEva

; 1209 : 	    child = child * 10 + (CUR - '0');

	movzx	ecx, al
	lea	ebx, DWORD PTR [ebx+ebx*4]
	lea	ebx, DWORD PTR [ebx-24]
	lea	ebx, DWORD PTR [ecx+ebx*2]

; 1210 : 	    NEXT;

	test	al, al
	je	SHORT $LN12@xmlXPtrEva
	inc	esi
	mov	DWORD PTR [edi], esi
	mov	al, BYTE PTR [esi]
$LN12@xmlXPtrEva:

; 1207 : 
; 1208 : 	while ((CUR >= '0') && (CUR <= '9')) {

	cmp	al, 48					; 00000030H
	jae	SHORT $LL4@xmlXPtrEva
$LN29@xmlXPtrEva:

; 896  :     CHECK_TYPE(XPATH_NODESET);

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN16@xmlXPtrEva
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN16@xmlXPtrEva

; 897  :     obj = valuePop(ctxt);

	push	edi
	call	_valuePop
	add	esp, 4
	mov	esi, eax

; 899  :     if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {

	test	ebx, ebx
	jle	SHORT $LN18@xmlXPtrEva

; 898  :     oldset = obj->nodesetval;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _oldset$1$[ebp], eax

; 899  :     if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {

	test	eax, eax
	je	SHORT $LN18@xmlXPtrEva
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN18@xmlXPtrEva

; 901  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));
; 902  : 	return;
; 903  :     }
; 904  :     cur = xmlXPtrGetNthChild(oldset->nodeTab[0], indx);

	mov	eax, DWORD PTR [eax+8]
	push	ebx
	push	DWORD PTR [eax]
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	ecx, eax

; 905  :     if (cur == NULL) {

	push	esi
	test	ecx, ecx
	je	SHORT $LN31@xmlXPtrEva

; 906  : 	xmlXPathFreeObject(obj);
; 907  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));
; 908  : 	return;
; 909  :     }
; 910  :     oldset->nodeTab[0] = cur;

	mov	eax, DWORD PTR _oldset$1$[ebp]

; 911  :     valuePush(ctxt, obj);

	push	edi
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ecx
	call	_valuePush
	jmp	SHORT $LN30@xmlXPtrEva
$LN18@xmlXPtrEva:

; 900  : 	xmlXPathFreeObject(obj);

	push	esi
$LN31@xmlXPtrEva:

; 1202 :     }
; 1203 : 
; 1204 :     while (CUR == '/') {

	call	_xmlXPathFreeObject
	push	0
	call	_xmlXPathNewNodeSet
	push	eax
	push	edi
	call	_valuePush
	add	esp, 16					; 00000010H
	jmp	SHORT $LN14@xmlXPtrEva
$LN16@xmlXPtrEva:

; 896  :     CHECK_TYPE(XPATH_NODESET);

	push	11					; 0000000bH
	push	edi
	call	_xmlXPathErr
$LN30@xmlXPtrEva:

; 1202 :     }
; 1203 : 
; 1204 :     while (CUR == '/') {

	add	esp, 8
$LN14@xmlXPtrEva:
	mov	esi, DWORD PTR [edi]
	mov	al, BYTE PTR [esi]
	cmp	al, 47					; 0000002fH
	je	$LL2@xmlXPtrEva
	pop	ebx
$LN3@xmlXPtrEva:
	pop	edi

; 1211 : 	}
; 1212 : 	xmlXPtrGetChildNo(ctxt, child);
; 1213 :     }
; 1214 : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPtrEvalChildSeq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeInternal
_TEXT	SEGMENT
_start$ = 8						; size = 4
_startindex$ = 12					; size = 4
_end$ = 16						; size = 4
_endindex$ = 20						; size = 4
_xmlXPtrNewRangeInternal PROC				; COMDAT

; 344  :                         xmlNodePtr end, int endindex) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _start$[ebp]
	test	esi, esi
	je	SHORT $LN2@xmlXPtrNew

; 345  :     xmlXPathObjectPtr ret;
; 346  : 
; 347  :     /*
; 348  :      * Namespace nodes must be copied (see xmlXPathNodeSetDupNs).
; 349  :      * Disallow them for now.
; 350  :      */
; 351  :     if ((start != NULL) && (start->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPtrNew
$LN2@xmlXPtrNew:

; 352  : 	return(NULL);
; 353  :     if ((end != NULL) && (end->type == XML_NAMESPACE_DECL))

	mov	edi, DWORD PTR _end$[ebp]
	test	edi, edi
	je	SHORT $LN3@xmlXPtrNew
	cmp	DWORD PTR [edi+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPtrNew
$LN3@xmlXPtrNew:

; 354  : 	return(NULL);
; 355  : 
; 356  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 357  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPtrNew

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN8@xmlXPtrNew:
	pop	edi

; 367  :     return(ret);
; 368  : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPtrNew:

; 358  :         xmlXPtrErrMemory("allocating range");
; 359  : 	return(NULL);
; 360  :     }
; 361  :     memset(ret, 0, sizeof(xmlXPathObject));
; 362  :     ret->type = XPATH_RANGE;
; 363  :     ret->user = start;
; 364  :     ret->index = startindex;

	mov	ecx, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+44], 0

; 365  :     ret->user2 = end;

	mov	DWORD PTR [eax+36], edi
	mov	DWORD PTR [eax+32], ecx

; 366  :     ret->index2 = endindex;

	mov	ecx, DWORD PTR _endindex$[ebp]
	pop	edi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax], 6
	mov	DWORD PTR [eax+40], ecx

; 367  :     return(ret);
; 368  : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPtrNewRangeInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangesEqual
_TEXT	SEGMENT
_range1$ = 8						; size = 4
_range2$ = 12						; size = 4
_xmlXPtrRangesEqual PROC				; COMDAT

; 311  : xmlXPtrRangesEqual(xmlXPathObjectPtr range1, xmlXPathObjectPtr range2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR _range2$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN2@xmlXPtrRan
$LN12@xmlXPtrRan:

; 327  : 	return(0);
; 328  :     return(1);
; 329  : }

	mov	eax, 1
	pop	ebp
	ret	0
$LN2@xmlXPtrRan:

; 312  :     if (range1 == range2)
; 313  : 	return(1);
; 314  :     if ((range1 == NULL) || (range2 == NULL))

	test	ecx, ecx
	je	SHORT $LN4@xmlXPtrRan
	test	edx, edx
	je	SHORT $LN4@xmlXPtrRan

; 316  :     if (range1->type != range2->type)

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN4@xmlXPtrRan

; 317  : 	return(0);
; 318  :     if (range1->type != XPATH_RANGE)

	cmp	eax, 6
	jne	SHORT $LN4@xmlXPtrRan

; 319  : 	return(0);
; 320  :     if (range1->user != range2->user)

	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+28]
	jne	SHORT $LN4@xmlXPtrRan

; 321  : 	return(0);
; 322  :     if (range1->index != range2->index)

	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [edx+32]
	jne	SHORT $LN4@xmlXPtrRan

; 323  : 	return(0);
; 324  :     if (range1->user2 != range2->user2)

	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [edx+36]
	jne	SHORT $LN4@xmlXPtrRan

; 325  : 	return(0);
; 326  :     if (range1->index2 != range2->index2)

	mov	eax, DWORD PTR [ecx+40]
	cmp	eax, DWORD PTR [edx+40]
	je	SHORT $LN12@xmlXPtrRan
$LN4@xmlXPtrRan:

; 315  : 	return(0);

	xor	eax, eax

; 327  : 	return(0);
; 328  :     return(1);
; 329  : }

	pop	ebp
	ret	0
_xmlXPtrRangesEqual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeCheckOrder
_TEXT	SEGMENT
_range$ = 8						; size = 4
_xmlXPtrRangeCheckOrder PROC				; COMDAT

; 280  : xmlXPtrRangeCheckOrder(xmlXPathObjectPtr range) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _range$[ebp]
	test	esi, esi
	je	SHORT $LN5@xmlXPtrRan

; 281  :     int tmp;
; 282  :     xmlNodePtr tmp2;
; 283  :     if (range == NULL)
; 284  : 	return;
; 285  :     if (range->type != XPATH_RANGE)

	cmp	DWORD PTR [esi], 6
	jne	SHORT $LN5@xmlXPtrRan

; 286  : 	return;
; 287  :     if (range->user2 == NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN5@xmlXPtrRan

; 288  : 	return;
; 289  :     tmp = xmlXPtrCmpPoints(range->user, range->index,

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+40]

; 228  :     if ((node1 == NULL) || (node2 == NULL))

	test	ecx, ecx
	je	SHORT $LN5@xmlXPtrRan

; 229  : 	return(-2);
; 230  :     /*
; 231  :      * a couple of optimizations which will avoid computations in most cases
; 232  :      */
; 233  :     if (node1 == node2) {

	cmp	ecx, eax
	jne	SHORT $LN10@xmlXPtrRan

; 234  : 	if (index1 < index2)

	cmp	DWORD PTR [esi+32], edx

; 235  : 	    return(1);
; 236  : 	if (index1 > index2)

	jle	SHORT $LN5@xmlXPtrRan

; 237  : 	    return(-1);

	jmp	SHORT $LN14@xmlXPtrRan
$LN10@xmlXPtrRan:

; 238  : 	return(0);
; 239  :     }
; 240  :     return(xmlXPathCmpNodes(node1, node2));

	push	eax
	push	ecx
	call	_xmlXPathCmpNodes
	add	esp, 8

; 290  : 	                     range->user2, range->index2);
; 291  :     if (tmp == -1) {

	cmp	eax, -1
	jne	SHORT $LN5@xmlXPtrRan
$LN14@xmlXPtrRan:

; 292  : 	tmp2 = range->user;

	mov	ecx, DWORD PTR [esi+28]

; 293  : 	range->user = range->user2;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+28], eax

; 294  : 	range->user2 = tmp2;
; 295  : 	tmp = range->index;
; 296  : 	range->index = range->index2;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+36], ecx
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+32], eax

; 297  : 	range->index2 = tmp;

	mov	DWORD PTR [esi+40], ecx
$LN5@xmlXPtrRan:
	pop	esi

; 298  :     }
; 299  : }

	pop	ebp
	ret	0
_xmlXPtrRangeCheckOrder ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewPoint
_TEXT	SEGMENT
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrNewPoint PROC					; COMDAT

; 253  : xmlXPtrNewPoint(xmlNodePtr node, int indx) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _node$[ebp]
	test	edi, edi
	je	SHORT $LN6@xmlXPtrNew

; 254  :     xmlXPathObjectPtr ret;
; 255  : 
; 256  :     if (node == NULL)
; 257  : 	return(NULL);
; 258  :     if (indx < 0)

	mov	esi, DWORD PTR _indx$[ebp]
	test	esi, esi
	js	SHORT $LN6@xmlXPtrNew

; 259  : 	return(NULL);
; 260  : 
; 261  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4

; 262  :     if (ret == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPtrNew

; 263  :         xmlXPtrErrMemory("allocating point");

	push	OFFSET ??_C@_0BB@DMDDEGKA@allocating?5point@
	call	_xmlXPtrErrMemory
	add	esp, 4
$LN6@xmlXPtrNew:

; 270  :     return(ret);
; 271  : }

	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPtrNew:

; 264  : 	return(NULL);
; 265  :     }
; 266  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 267  :     ret->type = XPATH_POINT;
; 268  :     ret->user = (void *) node;

	mov	DWORD PTR [eax+28], edi
	pop	edi

; 269  :     ret->index = indx;

	mov	DWORD PTR [eax+32], esi
	mov	DWORD PTR [eax], 5

; 270  :     return(ret);
; 271  : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPtrNewPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrCmpPoints
_TEXT	SEGMENT
_node1$ = 8						; size = 4
_index1$ = 12						; size = 4
_node2$ = 16						; size = 4
_index2$ = 20						; size = 4
_xmlXPtrCmpPoints PROC					; COMDAT

; 227  : xmlXPtrCmpPoints(xmlNodePtr node1, int index1, xmlNodePtr node2, int index2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _node1$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlXPtrCmp

; 228  :     if ((node1 == NULL) || (node2 == NULL))

	mov	eax, DWORD PTR _node2$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlXPtrCmp

; 230  :     /*
; 231  :      * a couple of optimizations which will avoid computations in most cases
; 232  :      */
; 233  :     if (node1 == node2) {

	cmp	ecx, eax
	jne	SHORT $LN4@xmlXPtrCmp

; 234  : 	if (index1 < index2)

	mov	ecx, DWORD PTR _index1$[ebp]
	mov	edx, DWORD PTR _index2$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN5@xmlXPtrCmp

; 235  : 	    return(1);

	mov	eax, 1

; 241  : }

	pop	ebp
	ret	0
$LN5@xmlXPtrCmp:

; 236  : 	if (index1 > index2)

	xor	eax, eax
	cmp	ecx, edx
	setle	al
	dec	eax

; 241  : }

	pop	ebp
	ret	0
$LN4@xmlXPtrCmp:

; 237  : 	    return(-1);
; 238  : 	return(0);
; 239  :     }
; 240  :     return(xmlXPathCmpNodes(node1, node2));

	push	eax
	push	ecx
	call	_xmlXPathCmpNodes
	add	esp, 8

; 241  : }

	pop	ebp
	ret	0
$LN3@xmlXPtrCmp:

; 229  : 	return(-2);

	mov	eax, -2					; fffffffeH

; 241  : }

	pop	ebp
	ret	0
_xmlXPtrCmpPoints ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetNthChild
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_no$ = 12						; size = 4
_xmlXPtrGetNthChild PROC				; COMDAT

; 189  : xmlXPtrGetNthChild(xmlNodePtr cur, int no) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _cur$[ebp]
	test	eax, eax
	je	SHORT $LN1@xmlXPtrGet

; 190  :     int i;
; 191  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN1@xmlXPtrGet

; 192  : 	return(cur);
; 193  :     cur = cur->children;

	mov	eax, DWORD PTR [eax+12]

; 194  :     for (i = 0;i <= no;cur = cur->next) {

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _no$[ebp]
	test	esi, esi
	js	SHORT $LN18@xmlXPtrGet
$LL4@xmlXPtrGet:

; 195  : 	if (cur == NULL)

	test	eax, eax
	je	SHORT $LN13@xmlXPtrGet

; 197  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 198  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, 1
	je	SHORT $LN9@xmlXPtrGet
	cmp	edx, 9
	je	SHORT $LN9@xmlXPtrGet
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN2@xmlXPtrGet
$LN9@xmlXPtrGet:

; 199  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 200  : 	    i++;

	inc	ecx

; 201  : 	    if (i == no)

	cmp	ecx, esi
	je	SHORT $LN18@xmlXPtrGet
$LN2@xmlXPtrGet:

; 194  :     for (i = 0;i <= no;cur = cur->next) {

	mov	eax, DWORD PTR [eax+24]
	cmp	ecx, esi
	jle	SHORT $LL4@xmlXPtrGet
	pop	esi

; 202  : 		break;
; 203  : 	}
; 204  :     }
; 205  :     return(cur);
; 206  : }

	pop	ebp
	ret	0
$LN13@xmlXPtrGet:

; 196  : 	    return(cur);

	xor	eax, eax
$LN18@xmlXPtrGet:
	pop	esi
$LN1@xmlXPtrGet:

; 202  : 		break;
; 203  : 	}
; 204  :     }
; 205  :     return(cur);
; 206  : }

	pop	ebp
	ret	0
_xmlXPtrGetNthChild ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetIndex
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlXPtrGetIndex PROC					; COMDAT

; 167  : xmlXPtrGetIndex(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPtrGet

; 168  :     int i;
; 169  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN6@xmlXPtrGet

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	edx, 1
	npad	1
$LL4@xmlXPtrGet:

; 172  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 173  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPtrGet
	cmp	eax, 9
	je	SHORT $LN8@xmlXPtrGet
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN2@xmlXPtrGet
$LN8@xmlXPtrGet:

; 174  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 175  : 	    i++;

	inc	edx
$LN2@xmlXPtrGet:

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	ecx, DWORD PTR [ecx+28]
	test	ecx, ecx
	jne	SHORT $LL4@xmlXPtrGet

; 176  : 	}
; 177  :     }
; 178  :     return(i);

	mov	eax, edx

; 179  : }

	pop	ebp
	ret	0
$LN6@xmlXPtrGet:

; 170  : 	return(-1);

	or	eax, -1

; 179  : }

	pop	ebp
	ret	0
_xmlXPtrGetIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetArity
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlXPtrGetArity PROC					; COMDAT

; 144  : xmlXPtrGetArity(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _cur$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPtrGet

; 145  :     int i;
; 146  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN6@xmlXPtrGet

; 148  :     cur = cur->children;

	mov	ecx, DWORD PTR [ecx+12]

; 149  :     for (i = 0;cur != NULL;cur = cur->next) {

	xor	edx, edx
	test	ecx, ecx
	je	SHORT $LN3@xmlXPtrGet
$LL4@xmlXPtrGet:

; 150  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 151  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPtrGet
	cmp	eax, 9
	je	SHORT $LN8@xmlXPtrGet
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN2@xmlXPtrGet
$LN8@xmlXPtrGet:

; 152  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 153  : 	    i++;

	inc	edx
$LN2@xmlXPtrGet:

; 149  :     for (i = 0;cur != NULL;cur = cur->next) {

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	jne	SHORT $LL4@xmlXPtrGet
$LN3@xmlXPtrGet:

; 154  : 	}
; 155  :     }
; 156  :     return(i);

	mov	eax, edx

; 157  : }

	pop	ebp
	ret	0
$LN6@xmlXPtrGet:

; 147  : 	return(-1);

	or	eax, -1

; 157  : }

	pop	ebp
	ret	0
_xmlXPtrGetArity ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrAdvanceNode
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_level$ = 12						; size = 4
_xmlXPtrAdvanceNode PROC				; COMDAT

; 2242 : xmlXPtrAdvanceNode(xmlNodePtr cur, int *level) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _level$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
$next$38:

; 2243 : next:
; 2244 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	test	esi, esi
	je	SHORT $LN6@xmlXPtrAdv
	cmp	DWORD PTR [esi+4], 18			; 00000012H
	je	SHORT $LN6@xmlXPtrAdv

; 2245 : 	return(NULL);
; 2246 :     if (cur->children != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $skip$39

; 2247 :         cur = cur->children ;

	mov	esi, eax

; 2248 : 	if (level != NULL)

	test	ebx, ebx
	je	SHORT $found$40

; 2249 : 	    (*level)++;

	inc	DWORD PTR [ebx]

; 2250 : 	goto found;

	jmp	SHORT $found$40
$LL4@xmlXPtrAdv:

; 2251 :     }
; 2252 : skip:		/* This label should only be needed if something is wrong! */
; 2253 :     if (cur->next != NULL) {
; 2254 : 	cur = cur->next;
; 2255 : 	goto found;
; 2256 :     }
; 2257 :     do {
; 2258 :         cur = cur->parent;

	mov	esi, DWORD PTR [esi+20]

; 2259 : 	if (level != NULL)

	test	ebx, ebx
	je	SHORT $LN10@xmlXPtrAdv

; 2260 : 	    (*level)--;

	dec	DWORD PTR [ebx]
$LN10@xmlXPtrAdv:

; 2261 :         if (cur == NULL) return(NULL);

	test	esi, esi
	je	SHORT $LN6@xmlXPtrAdv
$skip$39:

; 2262 :         if (cur->next != NULL) {
; 2263 : 	    cur = cur->next;
; 2264 : 	    goto found;
; 2265 : 	}
; 2266 :     } while (cur != NULL);
; 2267 : 
; 2268 : found:
; 2269 :     if ((cur->type != XML_ELEMENT_NODE) &&
; 2270 : 	(cur->type != XML_TEXT_NODE) &&
; 2271 : 	(cur->type != XML_DOCUMENT_NODE) &&
; 2272 : 	(cur->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LL4@xmlXPtrAdv
	mov	esi, eax
$found$40:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN13@xmlXPtrAdv
	cmp	eax, 3
	je	SHORT $LN13@xmlXPtrAdv
	cmp	eax, 9
	je	SHORT $LN13@xmlXPtrAdv
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN13@xmlXPtrAdv
	cmp	eax, 4
	je	SHORT $LN13@xmlXPtrAdv

; 2273 : 	(cur->type != XML_CDATA_SECTION_NODE)) {
; 2274 : 	    if (cur->type == XML_ENTITY_REF_NODE) {	/* Shouldn't happen */

	cmp	eax, 5
	jne	SHORT $next$38

; 2275 : 		TODO

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	2275					; 000008e3H
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 16					; 00000010H

; 2276 : 		goto skip;

	jmp	SHORT $skip$39
$LN13@xmlXPtrAdv:
	pop	edi

; 2277 : 	    }
; 2278 : 	    goto next;
; 2279 : 	}
; 2280 :     return(cur);

	mov	eax, esi

; 2281 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN6@xmlXPtrAdv:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
_xmlXPtrAdvanceNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlXPtrErr PROC					; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _error$[ebp]
	test	esi, esi
	je	$LN4@xmlXPtrErr

; 97   :     if (ctxt != NULL)
; 98   :         ctxt->error = error;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], edi

; 99   :     if ((ctxt == NULL) || (ctxt->context == NULL)) {

	test	eax, eax
	je	$LN4@xmlXPtrErr

; 101  : 			NULL, NULL, XML_FROM_XPOINTER, error,
; 102  : 			XML_ERR_ERROR, NULL, 0,
; 103  : 			(const char *) extra, NULL, NULL, 0, 0,
; 104  : 			msg, extra);
; 105  : 	return;
; 106  :     }
; 107  : 
; 108  :     /* cleanup current last error */
; 109  :     xmlResetError(&ctxt->context->lastError);

	add	eax, 136				; 00000088H
	push	ebx
	push	eax
	call	_xmlResetError

; 110  : 
; 111  :     ctxt->context->lastError.domain = XML_FROM_XPOINTER;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+136], 13			; 0000000dH

; 112  :     ctxt->context->lastError.code = error;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+140], edi

; 113  :     ctxt->context->lastError.level = XML_ERR_ERROR;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+148], 2

; 114  :     ctxt->context->lastError.str1 = (char *) xmlStrdup(ctxt->base);

	push	DWORD PTR [esi+4]
	call	_xmlStrdup
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 8
	mov	DWORD PTR [ecx+160], eax

; 115  :     ctxt->context->lastError.int1 = ctxt->cur - ctxt->base;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+172], ecx

; 116  :     ctxt->context->lastError.node = ctxt->context->debugNode;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx+188]
	mov	DWORD PTR [ecx+184], eax

; 117  :     if (ctxt->context->error != NULL) {

	mov	ebx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ebx+132]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPtrErr

; 118  : 	ctxt->context->error(ctxt->context->userData,

	lea	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+128]
	call	ecx
	add	esp, 8
	pop	ebx
	pop	edi

; 122  : 			NULL, ctxt->context->debugNode, XML_FROM_XPOINTER,
; 123  : 			error, XML_ERR_ERROR, NULL, 0,
; 124  : 			(const char *) extra, (const char *) ctxt->base, NULL,
; 125  : 			ctxt->cur - ctxt->base, 0,
; 126  : 			msg, extra);
; 127  :     }
; 128  : }

	pop	esi
	pop	ebp
	ret	0
$LN5@xmlXPtrErr:

; 119  : 	                     &ctxt->context->lastError);
; 120  :     } else {
; 121  : 	__xmlRaiseError(NULL, NULL, NULL,

	mov	edx, DWORD PTR _extra$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	DWORD PTR _msg$[ebp]
	sub	eax, ecx
	push	0
	push	eax
	push	0
	push	ecx
	push	edx
	push	0
	push	0
	push	2
	push	edi
	push	13					; 0000000dH
	push	DWORD PTR [ebx+188]
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	ebx
	pop	edi

; 122  : 			NULL, ctxt->context->debugNode, XML_FROM_XPOINTER,
; 123  : 			error, XML_ERR_ERROR, NULL, 0,
; 124  : 			(const char *) extra, (const char *) ctxt->base, NULL,
; 125  : 			ctxt->cur - ctxt->base, 0,
; 126  : 			msg, extra);
; 127  :     }
; 128  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlXPtrErr:

; 100  : 	__xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	DWORD PTR _msg$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	edi
	push	13					; 0000000dH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	edi

; 122  : 			NULL, ctxt->context->debugNode, XML_FROM_XPOINTER,
; 123  : 			error, XML_ERR_ERROR, NULL, 0,
; 124  : 			(const char *) extra, (const char *) ctxt->base, NULL,
; 125  : 			ctxt->cur - ctxt->base, 0,
; 126  : 			msg, extra);
; 127  :     }
; 128  : }

	pop	esi
	pop	ebp
	ret	0
_xmlXPtrErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlXPtrErrMemory PROC					; COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	push	eax
	push	0
	push	0
	push	2
	push	2
	push	13					; 0000000dH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,
; 81   : 		    XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0, extra,
; 82   : 		    NULL, NULL, 0, 0,
; 83   : 		    "Memory allocation failed : %s\n", extra);
; 84   : }

	pop	ebp
	ret	0
_xmlXPtrErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalRangePredicate
_TEXT	SEGMENT
_obj$1$ = -20						; size = 4
_i$1$ = -16						; size = 4
_tmp$1$ = -12						; size = 4
tv769 = -8						; size = 4
_cur$1$ = -4						; size = 4
_newset$1$ = 8						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPtrEvalRangePredicate PROC				; COMDAT

; 2841 : xmlXPtrEvalRangePredicate(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	$LN10@xmlXPtrEva
	mov	eax, DWORD PTR [esi]
	npad	2
$LL2@xmlXPtrEva:

; 2842 :     const xmlChar *cur;
; 2843 :     xmlXPathObjectPtr res;
; 2844 :     xmlXPathObjectPtr obj, tmp;
; 2845 :     xmlLocationSetPtr newset = NULL;
; 2846 :     xmlLocationSetPtr oldset;
; 2847 :     int i;
; 2848 : 
; 2849 :     if (ctxt == NULL) return;
; 2850 : 
; 2851 :     SKIP_BLANKS;

	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN12@xmlXPtrEva
	cmp	cl, 9
	jb	SHORT $LN13@xmlXPtrEva
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN12@xmlXPtrEva
$LN13@xmlXPtrEva:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPtrEva
$LN12@xmlXPtrEva:
	test	cl, cl
	je	SHORT $LL2@xmlXPtrEva
	inc	eax
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LL2@xmlXPtrEva
$LN3@xmlXPtrEva:
	push	ebx
	push	edi

; 2852 :     if (CUR != '[') {

	cmp	cl, 91					; 0000005bH
	jne	$LN67@xmlXPtrEva
$LN70@xmlXPtrEva:

; 2853 : 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
; 2854 :     }
; 2855 :     NEXT;
; 2856 :     SKIP_BLANKS;

	inc	eax
	mov	DWORD PTR [esi], eax
	npad	3
$LL4@xmlXPtrEva:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN15@xmlXPtrEva
	cmp	cl, 9
	jb	SHORT $LN16@xmlXPtrEva
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN15@xmlXPtrEva
$LN16@xmlXPtrEva:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrEva
$LN15@xmlXPtrEva:
	test	cl, cl
	je	SHORT $LL4@xmlXPtrEva
	jmp	SHORT $LN70@xmlXPtrEva
$LN5@xmlXPtrEva:

; 2857 : 
; 2858 :     /*
; 2859 :      * Extract the old set, and then evaluate the result of the
; 2860 :      * expression for all the element in the set. use it to grow
; 2861 :      * up a new set.
; 2862 :      */
; 2863 :     CHECK_TYPE(XPATH_LOCATIONSET);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN18@xmlXPtrEva
	cmp	DWORD PTR [eax], 7
	jne	$LN18@xmlXPtrEva

; 2864 :     obj = valuePop(ctxt);

	push	esi
	call	_valuePop

; 2865 :     oldset = obj->user;
; 2866 :     ctxt->context->node = NULL;

	mov	ecx, DWORD PTR [esi+12]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _obj$1$[ebp], edi
	mov	ebx, DWORD PTR [edi+28]
	mov	DWORD PTR [ecx+4], 0

; 2867 : 
; 2868 :     if ((oldset == NULL) || (oldset->locNr == 0)) {

	test	ebx, ebx
	je	$LN21@xmlXPtrEva
	cmp	DWORD PTR [ebx], 0
	je	$LN21@xmlXPtrEva

; 2877 :     } else {
; 2878 : 	/*
; 2879 : 	 * Save the expression pointer since we will have to evaluate
; 2880 : 	 * it multiple times. Initialize the new set.
; 2881 : 	 */
; 2882 :         cur = ctxt->cur;

	mov	eax, DWORD PTR [esi]

; 2883 : 	newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	mov	DWORD PTR _cur$1$[ebp], eax
	call	_xmlXPtrLocationSetCreate

; 2884 : 
; 2885 :         for (i = 0; i < oldset->locNr; i++) {

	xor	edi, edi
	mov	DWORD PTR _newset$1$[ebp], eax
	add	esp, 4
	cmp	DWORD PTR [ebx], edi
	jle	$LN7@xmlXPtrEva
	npad	8
$LL8@xmlXPtrEva:

; 2886 : 	    ctxt->cur = cur;

	mov	eax, DWORD PTR _cur$1$[ebp]

; 2887 : 
; 2888 : 	    /*
; 2889 : 	     * Run the evaluation with a node list made of a single item
; 2890 : 	     * in the nodeset.
; 2891 : 	     */
; 2892 : 	    ctxt->context->node = oldset->locTab[i]->user;

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR tv769[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+4], eax

; 2893 : 	    tmp = xmlXPathNewNodeSet(ctxt->context->node);

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax+4]
	call	_xmlXPathNewNodeSet

; 2894 : 	    valuePush(ctxt, tmp);

	push	eax
	push	esi
	mov	DWORD PTR _tmp$1$[ebp], eax
	call	_valuePush

; 2895 : 	    ctxt->context->contextSize = oldset->locNr;

	mov	edx, DWORD PTR [esi+12]

; 2896 : 	    ctxt->context->proximityPosition = i + 1;

	inc	edi
	mov	ecx, DWORD PTR [ebx]

; 2897 : 
; 2898 : 	    xmlXPathEvalExpr(ctxt);

	push	esi
	mov	DWORD PTR _i$1$[ebp], edi
	mov	DWORD PTR [edx+68], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+72], edi
	call	_xmlXPathEvalExpr
	add	esp, 16					; 00000010H

; 2899 : 	    CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	$LN68@xmlXPtrEva

; 2900 : 
; 2901 : 	    /*
; 2902 : 	     * The result of the evaluation need to be tested to
; 2903 : 	     * decided whether the filter succeeded or not
; 2904 : 	     */
; 2905 : 	    res = valuePop(ctxt);

	push	esi
	call	_valuePop
	mov	edi, eax

; 2906 : 	    if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	push	edi
	push	esi
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@xmlXPtrEva

; 2907 : 	        xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR tv769[ebp]
	push	DWORD PTR [eax+ecx]
	call	_xmlXPathObjectCopy
	push	eax
	push	DWORD PTR _newset$1$[ebp]
	call	_xmlXPtrLocationSetAdd
	add	esp, 12					; 0000000cH
$LN25@xmlXPtrEva:

; 2908 : 			xmlXPathObjectCopy(oldset->locTab[i]));
; 2909 : 	    }
; 2910 : 
; 2911 : 	    /*
; 2912 : 	     * Cleanup
; 2913 : 	     */
; 2914 : 	    if (res != NULL)

	test	edi, edi
	je	SHORT $LN26@xmlXPtrEva

; 2915 : 		xmlXPathFreeObject(res);

	push	edi
	call	_xmlXPathFreeObject
	add	esp, 4
$LN26@xmlXPtrEva:

; 2916 : 	    if (ctxt->value == tmp) {

	mov	eax, DWORD PTR _tmp$1$[ebp]
	cmp	DWORD PTR [esi+16], eax
	jne	SHORT $LN27@xmlXPtrEva

; 2917 : 		res = valuePop(ctxt);

	push	esi
	call	_valuePop

; 2918 : 		xmlXPathFreeObject(res);

	push	eax
	call	_xmlXPathFreeObject
	add	esp, 8
$LN27@xmlXPtrEva:

; 2919 : 	    }
; 2920 : 
; 2921 : 	    ctxt->context->node = NULL;

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR [eax+4], 0
	cmp	edi, DWORD PTR [ebx]
	jl	$LL8@xmlXPtrEva
$LN7@xmlXPtrEva:

; 2922 : 	}
; 2923 : 
; 2924 : 	/*
; 2925 : 	 * The result is used as the new evaluation set.
; 2926 : 	 */
; 2927 : 	xmlXPathFreeObject(obj);

	push	DWORD PTR _obj$1$[ebp]
	call	_xmlXPathFreeObject

; 2928 : 	ctxt->context->node = NULL;

	mov	eax, DWORD PTR [esi+12]

; 2929 : 	ctxt->context->contextSize = -1;
; 2930 : 	ctxt->context->proximityPosition = -1;
; 2931 : 	valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	push	DWORD PTR _newset$1$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+68], -1
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+72], -1
	call	_xmlXPtrWrapLocationSet
	push	eax
	push	esi
	call	_valuePush
	add	esp, 16					; 00000010H
	jmp	SHORT $LN23@xmlXPtrEva
$LN21@xmlXPtrEva:

; 2869 : 	ctxt->context->contextSize = 0;

	mov	eax, DWORD PTR [esi+12]

; 2870 : 	ctxt->context->proximityPosition = 0;
; 2871 : 	xmlXPathEvalExpr(ctxt);

	push	esi
	mov	DWORD PTR [eax+68], 0
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+72], 0
	call	_xmlXPathEvalExpr

; 2872 : 	res = valuePop(ctxt);

	push	esi
	call	_valuePop
	add	esp, 8

; 2873 : 	if (res != NULL)

	test	eax, eax
	je	SHORT $LN22@xmlXPtrEva

; 2874 : 	    xmlXPathFreeObject(res);

	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN22@xmlXPtrEva:

; 2875 : 	valuePush(ctxt, obj);

	push	edi
	push	esi
	call	_valuePush
	add	esp, 8

; 2876 : 	CHECK_ERROR;

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN68@xmlXPtrEva
$LN23@xmlXPtrEva:

; 2932 :     }
; 2933 :     if (CUR != ']') {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN67@xmlXPtrEva
$LN71@xmlXPtrEva:

; 2935 :     }
; 2936 : 
; 2937 :     NEXT;
; 2938 :     SKIP_BLANKS;

	inc	eax
	mov	DWORD PTR [esi], eax
$LL9@xmlXPtrEva:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 32					; 00000020H
	je	SHORT $LN29@xmlXPtrEva
	cmp	cl, 9
	jb	SHORT $LN30@xmlXPtrEva
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN29@xmlXPtrEva
$LN30@xmlXPtrEva:
	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN68@xmlXPtrEva
$LN29@xmlXPtrEva:
	test	cl, cl
	je	SHORT $LL9@xmlXPtrEva
	jmp	SHORT $LN71@xmlXPtrEva
$LN18@xmlXPtrEva:

; 2857 : 
; 2858 :     /*
; 2859 :      * Extract the old set, and then evaluate the result of the
; 2860 :      * expression for all the element in the set. use it to grow
; 2861 :      * up a new set.
; 2862 :      */
; 2863 :     CHECK_TYPE(XPATH_LOCATIONSET);

	push	11					; 0000000bH

; 2934 : 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);

	push	esi
	call	_xmlXPathErr
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 2939 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@xmlXPtrEva:

; 2934 : 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);

	push	6
	push	esi
	call	_xmlXPathErr
	add	esp, 8
$LN68@xmlXPtrEva:
	pop	edi
	pop	ebx
$LN10@xmlXPtrEva:
	pop	esi

; 2939 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalRangePredicate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrBuildNodeList
_TEXT	SEGMENT
_list$1$ = -4						; size = 4
_obj$ = 8						; size = 4
_xmlXPtrBuildNodeList PROC				; COMDAT

; 1582 : xmlXPtrBuildNodeList(xmlXPathObjectPtr obj) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _obj$[ebp]
	xor	edx, edx
	xor	esi, esi
	mov	DWORD PTR _list$1$[ebp], edx
	test	ecx, ecx
	je	$LN44@xmlXPtrBui

; 1583 :     xmlNodePtr list = NULL, last = NULL;
; 1584 :     int i;
; 1585 : 
; 1586 :     if (obj == NULL)
; 1587 : 	return(NULL);
; 1588 :     switch (obj->type) {

	mov	eax, DWORD PTR [ecx]
	dec	eax
	cmp	eax, 6
	ja	SHORT $LN30@xmlXPtrBui
	jmp	DWORD PTR $LN48@xmlXPtrBui[eax*4]
$LN15@xmlXPtrBui:

; 1589 :         case XPATH_NODESET: {
; 1590 : 	    xmlNodeSetPtr set = obj->nodesetval;

	mov	ebx, DWORD PTR [ecx+4]

; 1591 : 	    if (set == NULL)

	test	ebx, ebx
	je	$LN44@xmlXPtrBui

; 1592 : 		return(NULL);
; 1593 : 	    for (i = 0;i < set->nodeNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edx
	jle	SHORT $LN30@xmlXPtrBui
$LL6@xmlXPtrBui:

; 1594 : 		if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [eax+edi*4]
	test	ecx, ecx
	je	SHORT $LN4@xmlXPtrBui

; 1595 : 		    continue;
; 1596 : 		switch (set->nodeTab[i]->type) {

	mov	eax, DWORD PTR [ecx+4]
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	SHORT $LN7@xmlXPtrBui
	movzx	eax, BYTE PTR $LN45@xmlXPtrBui[eax]
	jmp	DWORD PTR $LN49@xmlXPtrBui[eax*4]
$LN7@xmlXPtrBui:

; 1597 : 		    case XML_TEXT_NODE:
; 1598 : 		    case XML_CDATA_SECTION_NODE:
; 1599 : 		    case XML_ELEMENT_NODE:
; 1600 : 		    case XML_ENTITY_REF_NODE:
; 1601 : 		    case XML_ENTITY_NODE:
; 1602 : 		    case XML_PI_NODE:
; 1603 : 		    case XML_COMMENT_NODE:
; 1604 : 		    case XML_DOCUMENT_NODE:
; 1605 : 		    case XML_HTML_DOCUMENT_NODE:
; 1606 : #ifdef LIBXML_DOCB_ENABLED
; 1607 : 		    case XML_DOCB_DOCUMENT_NODE:
; 1608 : #endif
; 1609 : 		    case XML_XINCLUDE_START:
; 1610 : 		    case XML_XINCLUDE_END:
; 1611 : 			break;
; 1612 : 		    case XML_ATTRIBUTE_NODE:
; 1613 : 		    case XML_NAMESPACE_DECL:
; 1614 : 		    case XML_DOCUMENT_TYPE_NODE:
; 1615 : 		    case XML_DOCUMENT_FRAG_NODE:
; 1616 : 		    case XML_NOTATION_NODE:
; 1617 : 		    case XML_DTD_NODE:
; 1618 : 		    case XML_ELEMENT_DECL:
; 1619 : 		    case XML_ATTRIBUTE_DECL:
; 1620 : 		    case XML_ENTITY_DECL:
; 1621 : 			continue; /* for */
; 1622 : 		}
; 1623 : 		if (last == NULL)

	push	1
	push	ecx
	call	_xmlCopyNode
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN20@xmlXPtrBui

; 1624 : 		    list = last = xmlCopyNode(set->nodeTab[i], 1);

	mov	esi, eax
	mov	DWORD PTR _list$1$[ebp], esi
	jmp	SHORT $LN4@xmlXPtrBui
$LN20@xmlXPtrBui:

; 1625 : 		else {
; 1626 : 		    xmlAddNextSibling(last, xmlCopyNode(set->nodeTab[i], 1));

	push	eax
	push	esi
	call	_xmlAddNextSibling

; 1627 : 		    if (last->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	add	esp, 8
	test	eax, eax
	cmovne	esi, eax
$LN4@xmlXPtrBui:

; 1592 : 		return(NULL);
; 1593 : 	    for (i = 0;i < set->nodeNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL6@xmlXPtrBui

; 1654 : 	default:
; 1655 : 	    break;
; 1656 :     }
; 1657 :     return(list);

	mov	edx, DWORD PTR _list$1$[ebp]
$LN30@xmlXPtrBui:
	pop	edi

; 1658 : }

	pop	esi
	mov	eax, edx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xmlXPtrBui:

; 1628 : 			last = last->next;
; 1629 : 		}
; 1630 : 	    }
; 1631 : 	    break;
; 1632 : 	}
; 1633 : 	case XPATH_LOCATIONSET: {
; 1634 : 	    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;

	mov	ebx, DWORD PTR [ecx+28]

; 1635 : 	    if (set == NULL)

	test	ebx, ebx
	je	$LN44@xmlXPtrBui

; 1636 : 		return(NULL);
; 1637 : 	    for (i = 0;i < set->locNr;i++) {

	xor	edi, edi
	cmp	DWORD PTR [ebx], edx
	jle	SHORT $LN30@xmlXPtrBui
$LL11@xmlXPtrBui:

; 1638 : 		if (last == NULL)

	mov	eax, DWORD PTR [ebx+8]
	push	DWORD PTR [eax+edi*4]
	call	_xmlXPtrBuildNodeList
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN25@xmlXPtrBui

; 1639 : 		    list = last = xmlXPtrBuildNodeList(set->locTab[i]);

	mov	esi, eax
	mov	DWORD PTR _list$1$[ebp], esi
	jmp	SHORT $LN26@xmlXPtrBui
$LN25@xmlXPtrBui:

; 1640 : 		else
; 1641 : 		    xmlAddNextSibling(last,

	push	eax
	push	esi
	call	_xmlAddNextSibling
	add	esp, 8
$LN26@xmlXPtrBui:

; 1642 : 			    xmlXPtrBuildNodeList(set->locTab[i]));
; 1643 : 		if (last != NULL) {

	test	esi, esi
	je	SHORT $LN9@xmlXPtrBui

; 1644 : 		    while (last->next != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN9@xmlXPtrBui
	npad	2
$LL12@xmlXPtrBui:

; 1645 : 			last = last->next;

	mov	esi, eax
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LL12@xmlXPtrBui
$LN9@xmlXPtrBui:

; 1636 : 		return(NULL);
; 1637 : 	    for (i = 0;i < set->locNr;i++) {

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL11@xmlXPtrBui

; 1654 : 	default:
; 1655 : 	    break;
; 1656 :     }
; 1657 :     return(list);

	mov	edx, DWORD PTR _list$1$[ebp]
	mov	eax, edx
	pop	edi

; 1658 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlXPtrBui:

; 1646 : 		}
; 1647 : 	    }
; 1648 : 	    break;
; 1649 : 	}
; 1650 : 	case XPATH_RANGE:
; 1651 : 	    return(xmlXPtrBuildRangeNodeList(obj));

	push	ecx
	call	_xmlXPtrBuildRangeNodeList
	add	esp, 4
	pop	edi

; 1658 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlXPtrBui:

; 1652 : 	case XPATH_POINT:
; 1653 : 	    return(xmlCopyNode(obj->user, 0));

	push	0
	push	DWORD PTR [ecx+28]
	call	_xmlCopyNode
	add	esp, 8
	pop	edi

; 1658 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@xmlXPtrBui:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN48@xmlXPtrBui:
	DD	$LN15@xmlXPtrBui
	DD	$LN30@xmlXPtrBui
	DD	$LN30@xmlXPtrBui
	DD	$LN30@xmlXPtrBui
	DD	$LN29@xmlXPtrBui
	DD	$LN28@xmlXPtrBui
	DD	$LN23@xmlXPtrBui
$LN49@xmlXPtrBui:
	DD	$LN4@xmlXPtrBui
	DD	$LN7@xmlXPtrBui
$LN45@xmlXPtrBui:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_xmlXPtrBuildNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeToFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeToFunction PROC				; COMDAT

; 2227 :                        int nargs ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2228 :     XP_ERROR(XPATH_EXPR_ERROR);

	mov	DWORD PTR _nargs$[ebp], 7

; 2229 : }

	pop	ebp

; 2228 :     XP_ERROR(XPATH_EXPR_ERROR);

	jmp	_xmlXPathErr
_xmlXPtrRangeToFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEval
_TEXT	SEGMENT
_res$1$ = -4						; size = 4
_str$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlXPtrEval PROC					; COMDAT

; 1339 : xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	DWORD PTR _res$1$[ebp], 0
	xor	esi, esi
	call	_xmlXPathInit
	mov	ebx, DWORD PTR _ctx$[ebp]
	test	ebx, ebx
	je	$LN6@xmlXPtrEva

; 1340 :     xmlXPathParserContextPtr ctxt;
; 1341 :     xmlXPathObjectPtr res = NULL, tmp;
; 1342 :     xmlXPathObjectPtr init = NULL;
; 1343 :     int stack = 0;
; 1344 : 
; 1345 :     xmlXPathInit();
; 1346 : 
; 1347 :     if ((ctx == NULL) || (str == NULL))

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	je	$LN6@xmlXPtrEva

; 1348 : 	return(NULL);
; 1349 : 
; 1350 :     ctxt = xmlXPathNewParserContext(str, ctx);

	push	ebx
	push	eax
	call	_xmlXPathNewParserContext
	mov	edi, eax
	add	esp, 8

; 1351 :     if (ctxt == NULL)

	test	edi, edi
	je	$LN6@xmlXPtrEva

; 1352 : 	return(NULL);
; 1353 :     ctxt->xptr = 1;
; 1354 :     xmlXPtrEvalXPointer(ctxt);

	push	edi
	mov	DWORD PTR [edi+36], 1
	call	_xmlXPtrEvalXPointer

; 1355 : 
; 1356 :     if ((ctxt->value != NULL) &&
; 1357 : 	(ctxt->value->type != XPATH_NODESET) &&

	mov	eax, DWORD PTR [edi+16]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@xmlXPtrEva
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	je	SHORT $LN8@xmlXPtrEva
	cmp	eax, 7
	je	SHORT $LN8@xmlXPtrEva

; 1358 : 	(ctxt->value->type != XPATH_LOCATIONSET)) {
; 1359 :         xmlXPtrErr(ctxt, XML_XPTR_EVAL_FAILED,

	push	esi
	push	OFFSET ??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@
	push	1902					; 0000076eH
	push	edi
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H

; 1360 : 		"xmlXPtrEval: evaluation failed to return a node set\n",
; 1361 : 		   NULL);
; 1362 :     } else {

	jmp	SHORT $LL4@xmlXPtrEva
$LN8@xmlXPtrEva:

; 1363 : 	res = valuePop(ctxt);

	push	edi
	call	_valuePop
	mov	DWORD PTR _res$1$[ebp], eax
$LN33@xmlXPtrEva:

; 1364 :     }
; 1365 : 
; 1366 :     do {
; 1367 :         tmp = valuePop(ctxt);

	add	esp, 4
	npad	2
$LL4@xmlXPtrEva:
	push	edi
	call	_valuePop
	mov	ecx, eax
	add	esp, 4

; 1368 : 	if (tmp != NULL) {

	test	ecx, ecx
	je	SHORT $LN24@xmlXPtrEva

; 1369 : 	    if (tmp != init) {
; 1370 : 		if (tmp->type == XPATH_NODESET) {

	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN12@xmlXPtrEva

; 1371 : 		    /*
; 1372 : 		     * Evaluation may push a root nodeset which is unused
; 1373 : 		     */
; 1374 : 		    xmlNodeSetPtr set;
; 1375 : 		    set = tmp->nodesetval;

	mov	eax, DWORD PTR [ecx+4]

; 1376 : 		    if ((set == NULL) || (set->nodeNr != 1) ||

	test	eax, eax
	je	SHORT $LN12@xmlXPtrEva
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlXPtrEva
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ebx]
	je	SHORT $LN13@xmlXPtrEva
$LN12@xmlXPtrEva:

; 1377 : 			(set->nodeTab[0] != (xmlNodePtr) ctx->doc))
; 1378 : 			stack++;
; 1379 : 		} else
; 1380 : 		    stack++;
; 1381 : 	    }
; 1382 : 	    xmlXPathFreeObject(tmp);

	inc	esi
$LN13@xmlXPtrEva:
	push	ecx
	call	_xmlXPathFreeObject

; 1383 :         }
; 1384 :     } while (tmp != NULL);

	jmp	SHORT $LN33@xmlXPtrEva
$LN24@xmlXPtrEva:

; 1385 :     if (stack != 0) {

	test	esi, esi
	je	SHORT $LN16@xmlXPtrEva

; 1386 :         xmlXPtrErr(ctxt, XML_XPTR_EXTRA_OBJECTS,

	push	0
	push	OFFSET ??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@
	push	1903					; 0000076fH
	push	edi
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H
$LN16@xmlXPtrEva:

; 1387 : 		   "xmlXPtrEval: object(s) left on the eval stack\n",
; 1388 : 		   NULL);
; 1389 :     }
; 1390 :     if (ctxt->error != XPATH_EXPRESSION_OK) {

	mov	ebx, DWORD PTR [edi+8]
	test	ebx, ebx
	je	SHORT $LN17@xmlXPtrEva

; 1391 : 	xmlXPathFreeObject(res);

	push	DWORD PTR _res$1$[ebp]
	call	_xmlXPathFreeObject
	add	esp, 4
$LN17@xmlXPtrEva:

; 1392 : 	res = NULL;
; 1393 :     }
; 1394 : 
; 1395 :     xmlXPathFreeParserContext(ctxt);

	xor	esi, esi
	test	ebx, ebx
	push	edi
	cmove	esi, DWORD PTR _res$1$[ebp]
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 1396 :     return(res);

	mov	eax, esi
	pop	edi

; 1397 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlXPtrEva:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEval ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewContext
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_here$ = 12						; size = 4
_origin$ = 16						; size = 4
_xmlXPtrNewContext PROC					; COMDAT

; 1300 : xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _doc$[ebp]
	call	_xmlXPathNewContext
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPtrNew
	pop	esi

; 1326 : }

	pop	ebp
	ret	0
$LN2@xmlXPtrNew:

; 1301 :     xmlXPathContextPtr ret;
; 1302 : 
; 1303 :     ret = xmlXPathNewContext(doc);
; 1304 :     if (ret == NULL)
; 1305 : 	return(ret);
; 1306 :     ret->xptr = 1;
; 1307 :     ret->here = here;

	mov	eax, DWORD PTR _here$[ebp]

; 1308 :     ret->origin = origin;
; 1309 : 
; 1310 :     xmlXPathRegisterFunc(ret, (xmlChar *)"range",

	push	OFFSET _xmlXPtrRangeFunction
	mov	DWORD PTR [esi+80], eax
	mov	eax, DWORD PTR _origin$[ebp]
	push	OFFSET ??_C@_05CCGOGOBM@range@
	push	esi
	mov	DWORD PTR [esi+76], 1
	mov	DWORD PTR [esi+84], eax
	call	_xmlXPathRegisterFunc

; 1311 : 	                 xmlXPtrRangeFunction);
; 1312 :     xmlXPathRegisterFunc(ret, (xmlChar *)"range-inside",

	push	OFFSET _xmlXPtrRangeInsideFunction
	push	OFFSET ??_C@_0N@FPBCPIBK@range?9inside@
	push	esi
	call	_xmlXPathRegisterFunc

; 1313 : 	                 xmlXPtrRangeInsideFunction);
; 1314 :     xmlXPathRegisterFunc(ret, (xmlChar *)"string-range",

	push	OFFSET _xmlXPtrStringRangeFunction
	push	OFFSET ??_C@_0N@NHPDEMLM@string?9range@
	push	esi
	call	_xmlXPathRegisterFunc

; 1315 : 	                 xmlXPtrStringRangeFunction);
; 1316 :     xmlXPathRegisterFunc(ret, (xmlChar *)"start-point",

	push	OFFSET _xmlXPtrStartPointFunction
	push	OFFSET ??_C@_0M@KAHBAHMC@start?9point@
	push	esi
	call	_xmlXPathRegisterFunc

; 1317 : 	                 xmlXPtrStartPointFunction);
; 1318 :     xmlXPathRegisterFunc(ret, (xmlChar *)"end-point",

	push	OFFSET _xmlXPtrEndPointFunction
	push	OFFSET ??_C@_09BKKFPLJK@end?9point@
	push	esi
	call	_xmlXPathRegisterFunc

; 1319 : 	                 xmlXPtrEndPointFunction);
; 1320 :     xmlXPathRegisterFunc(ret, (xmlChar *)"here",

	push	OFFSET _xmlXPtrHereFunction
	push	OFFSET ??_C@_04NDJIBAID@here@
	push	esi
	call	_xmlXPathRegisterFunc
	add	esp, 72					; 00000048H

; 1321 : 	                 xmlXPtrHereFunction);
; 1322 :     xmlXPathRegisterFunc(ret, (xmlChar *)" origin",

	push	OFFSET _xmlXPtrOriginFunction
	push	OFFSET ??_C@_07NGBELOAG@?5origin@
	push	esi
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1323 : 	                 xmlXPtrOriginFunction);
; 1324 : 
; 1325 :     return(ret);

	mov	eax, esi
	pop	esi

; 1326 : }

	pop	ebp
	ret	0
_xmlXPtrNewContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetRemove
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetRemove PROC				; COMDAT

; 723  : xmlXPtrLocationSetRemove(xmlLocationSetPtr cur, int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPtrLoc

; 724  :     if (cur == NULL) return;
; 725  :     if (val >= cur->locNr) return;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _val$[ebp]
	cmp	edx, ecx
	jge	SHORT $LN1@xmlXPtrLoc

; 726  :     cur->locNr--;

	dec	ecx
	mov	DWORD PTR [esi], ecx

; 727  :     for (;val < cur->locNr;val++)

	cmp	edx, ecx
	jge	SHORT $LN11@xmlXPtrLoc
$LL4@xmlXPtrLoc:

; 728  :         cur->locTab[val] = cur->locTab[val + 1];

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+edx*4]
	inc	edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR [esi]
	cmp	edx, ecx
	jl	SHORT $LL4@xmlXPtrLoc
$LN11@xmlXPtrLoc:

; 729  :     cur->locTab[cur->locNr] = NULL;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], 0
$LN1@xmlXPtrLoc:
	pop	esi

; 730  : }

	pop	ebp
	ret	0
_xmlXPtrLocationSetRemove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetDel
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetDel PROC				; COMDAT

; 690  : xmlXPtrLocationSetDel(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPtrLoc

; 691  :     int i;
; 692  : 
; 693  :     if (cur == NULL) return;
; 694  :     if (val == NULL) return;

	push	edi
	mov	edi, DWORD PTR _val$[ebp]
	test	edi, edi
	je	SHORT $LN23@xmlXPtrLoc

; 695  : 
; 696  :     /*
; 697  :      * check against doublons
; 698  :      */
; 699  :     for (i = 0;i < cur->locNr;i++)

	mov	edx, DWORD PTR [esi]
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN23@xmlXPtrLoc

; 700  :         if (cur->locTab[i] == val) break;

	mov	ecx, DWORD PTR [esi+8]
$LL4@xmlXPtrLoc:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN15@xmlXPtrLoc

; 695  : 
; 696  :     /*
; 697  :      * check against doublons
; 698  :      */
; 699  :     for (i = 0;i < cur->locNr;i++)

	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL4@xmlXPtrLoc
	pop	edi
	pop	esi

; 713  : }

	pop	ebp
	ret	0
$LN15@xmlXPtrLoc:

; 701  : 
; 702  :     if (i >= cur->locNr) {

	cmp	eax, edx
	jge	SHORT $LN23@xmlXPtrLoc

; 703  : #ifdef DEBUG
; 704  :         xmlGenericError(xmlGenericErrorContext,
; 705  : 	        "xmlXPtrLocationSetDel: Range wasn't found in RangeList\n");
; 706  : #endif
; 707  :         return;
; 708  :     }
; 709  :     cur->locNr--;

	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR [esi], ecx

; 710  :     for (;i < cur->locNr;i++)

	cmp	eax, ecx
	jge	SHORT $LN20@xmlXPtrLoc
$LL7@xmlXPtrLoc:

; 711  :         cur->locTab[i] = cur->locTab[i + 1];

	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [ecx+eax*4]
	inc	eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi]
	cmp	eax, ecx
	jl	SHORT $LL7@xmlXPtrLoc
$LN20@xmlXPtrLoc:

; 712  :     cur->locTab[cur->locNr] = NULL;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], 0
$LN23@xmlXPtrLoc:
	pop	edi
$LN1@xmlXPtrLoc:
	pop	esi

; 713  : }

	pop	ebp
	ret	0
_xmlXPtrLocationSetDel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrWrapLocationSet
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPtrWrapLocationSet PROC				; COMDAT

; 826  : xmlXPtrWrapLocationSet(xmlLocationSetPtr val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@xmlXPtrWra

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 827  :     xmlXPathObjectPtr ret;
; 828  : 
; 829  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 830  :     if (ret == NULL) {
; 831  :         xmlXPtrErrMemory("allocating locationset");
; 832  : 	return(NULL);

	xor	eax, eax

; 837  :     return(ret);
; 838  : }

	pop	ebp
	ret	0
$LN2@xmlXPtrWra:

; 833  :     }
; 834  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
; 835  :     ret->type = XPATH_LOCATIONSET;
; 836  :     ret->user = (void *) val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax], 7
	mov	DWORD PTR [eax+28], ecx

; 837  :     return(ret);
; 838  : }

	pop	ebp
	ret	0
_xmlXPtrWrapLocationSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetAdd
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetAdd PROC				; COMDAT

; 612  : xmlXPtrLocationSetAdd(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN6@xmlXPtrLoc

; 613  :     int i;
; 614  : 
; 615  :     if ((cur == NULL) || (val == NULL)) return;

	push	esi
	mov	esi, DWORD PTR _val$[ebp]
	test	esi, esi
	je	$LN35@xmlXPtrLoc

; 616  : 
; 617  :     /*
; 618  :      * check against doublons
; 619  :      */
; 620  :     for (i = 0;i < cur->locNr;i++) {

	mov	ecx, DWORD PTR [edi]
	xor	edx, edx
	push	ebx
	test	ecx, ecx
	jle	SHORT $LN3@xmlXPtrLoc

; 621  : 	if (xmlXPtrRangesEqual(cur->locTab[i], val)) {

	mov	ebx, DWORD PTR [edi+8]
$LL4@xmlXPtrLoc:
	mov	ecx, DWORD PTR [ebx]

; 312  :     if (range1 == range2)

	cmp	ecx, esi
	je	$LN28@xmlXPtrLoc

; 313  : 	return(1);
; 314  :     if ((range1 == NULL) || (range2 == NULL))

	test	ecx, ecx
	je	SHORT $LN17@xmlXPtrLoc

; 315  : 	return(0);
; 316  :     if (range1->type != range2->type)

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN17@xmlXPtrLoc

; 317  : 	return(0);
; 318  :     if (range1->type != XPATH_RANGE)

	cmp	eax, 6
	jne	SHORT $LN17@xmlXPtrLoc

; 319  : 	return(0);
; 320  :     if (range1->user != range2->user)

	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [esi+28]
	jne	SHORT $LN17@xmlXPtrLoc

; 321  : 	return(0);
; 322  :     if (range1->index != range2->index)

	mov	eax, DWORD PTR [ecx+32]
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN17@xmlXPtrLoc

; 323  : 	return(0);
; 324  :     if (range1->user2 != range2->user2)

	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [esi+36]
	jne	SHORT $LN17@xmlXPtrLoc

; 325  : 	return(0);
; 326  :     if (range1->index2 != range2->index2)

	mov	eax, DWORD PTR [ecx+40]
	cmp	eax, DWORD PTR [esi+40]
	je	SHORT $LN28@xmlXPtrLoc
$LN17@xmlXPtrLoc:

; 616  : 
; 617  :     /*
; 618  :      * check against doublons
; 619  :      */
; 620  :     for (i = 0;i < cur->locNr;i++) {

	mov	ecx, DWORD PTR [edi]
	inc	edx
	add	ebx, 4
	cmp	edx, ecx
	jl	SHORT $LL4@xmlXPtrLoc
$LN3@xmlXPtrLoc:

; 623  : 	    return;
; 624  : 	}
; 625  :     }
; 626  : 
; 627  :     /*
; 628  :      * grow the locTab if needed
; 629  :      */
; 630  :     if (cur->locMax == 0) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN8@xmlXPtrLoc

; 631  :         cur->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+8], eax

; 632  : 					     sizeof(xmlXPathObjectPtr));
; 633  : 	if (cur->locTab == NULL) {

	test	eax, eax
	jne	SHORT $LN10@xmlXPtrLoc

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	pop	ebx
	pop	esi
	pop	edi

; 653  : }

	pop	ebp
	ret	0
$LN28@xmlXPtrLoc:

; 622  : 	    xmlXPathFreeObject(val);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4
	pop	ebx
	pop	esi
	pop	edi

; 653  : }

	pop	ebp
	ret	0
$LN10@xmlXPtrLoc:
	xorps	xmm0, xmm0

; 634  : 	    xmlXPtrErrMemory("adding location to set");
; 635  : 	    return;
; 636  : 	}
; 637  : 	memset(cur->locTab, 0 ,

	movups	XMMWORD PTR [eax], xmm0
	pop	ebx
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 651  :     }
; 652  :     cur->locTab[cur->locNr++] = val;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], 10			; 0000000aH
	mov	DWORD PTR [eax+ecx*4], esi
	inc	DWORD PTR [edi]
	pop	esi
	pop	edi

; 653  : }

	pop	ebp
	ret	0
$LN8@xmlXPtrLoc:

; 638  : 	       XML_RANGESET_DEFAULT * (size_t) sizeof(xmlXPathObjectPtr));
; 639  :         cur->locMax = XML_RANGESET_DEFAULT;
; 640  :     } else if (cur->locNr == cur->locMax) {

	cmp	ecx, eax
	jne	SHORT $LN11@xmlXPtrLoc

; 641  :         xmlXPathObjectPtr *temp;
; 642  : 
; 643  :         cur->locMax *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+4], eax

; 644  : 	temp = (xmlXPathObjectPtr *) xmlRealloc(cur->locTab, cur->locMax *

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 645  : 				      sizeof(xmlXPathObjectPtr));
; 646  : 	if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN12@xmlXPtrLoc

; 647  : 	    xmlXPtrErrMemory("adding location to set");

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	call	_xmlXPtrErrMemory
	add	esp, 4
	pop	ebx
	pop	esi
	pop	edi

; 653  : }

	pop	ebp
	ret	0
$LN12@xmlXPtrLoc:

; 648  : 	    return;
; 649  : 	}
; 650  : 	cur->locTab = temp;

	mov	DWORD PTR [edi+8], eax
$LN11@xmlXPtrLoc:

; 651  :     }
; 652  :     cur->locTab[cur->locNr++] = val;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+8]
	pop	ebx
	mov	DWORD PTR [eax+ecx*4], esi
	inc	DWORD PTR [edi]
$LN35@xmlXPtrLoc:
	pop	esi
$LN6@xmlXPtrLoc:
	pop	edi

; 653  : }

	pop	ebp
	ret	0
_xmlXPtrLocationSetAdd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewCollapsedRange
_TEXT	SEGMENT
_start$ = 8						; size = 4
_xmlXPtrNewCollapsedRange PROC				; COMDAT

; 510  : xmlXPtrNewCollapsedRange(xmlNodePtr start) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _start$[ebp]
	test	eax, eax
	jne	SHORT $LN2@xmlXPtrNew

; 517  :     return(ret);
; 518  : }

	pop	ebp
	ret	0
$LN2@xmlXPtrNew:

; 511  :     xmlXPathObjectPtr ret;
; 512  : 
; 513  :     if (start == NULL)
; 514  : 	return(NULL);
; 515  : 
; 516  :     ret = xmlXPtrNewRangeInternal(start, -1, NULL, -1);

	push	-1
	push	0
	push	-1
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H

; 517  :     return(ret);
; 518  : }

	pop	ebp
	ret	0
_xmlXPtrNewCollapsedRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodeObject
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodeObject PROC				; COMDAT

; 530  : xmlXPtrNewRangeNodeObject(xmlNodePtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edx, DWORD PTR _start$[ebp]
	test	edx, edx
	je	SHORT $LN10@xmlXPtrNew

; 531  :     xmlNodePtr endNode;
; 532  :     int endIndex;
; 533  :     xmlXPathObjectPtr ret;
; 534  : 
; 535  :     if (start == NULL)
; 536  : 	return(NULL);
; 537  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	SHORT $LN10@xmlXPtrNew

; 538  : 	return(NULL);
; 539  :     switch (end->type) {

	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	je	SHORT $LN8@xmlXPtrNew
	sub	ecx, 4
	je	SHORT $LN6@xmlXPtrNew
	sub	ecx, 1
	jne	SHORT $LN10@xmlXPtrNew

; 544  : 	case XPATH_RANGE:
; 545  : 	    endNode = end->user2;

	mov	ecx, DWORD PTR [eax+36]

; 546  : 	    endIndex = end->index2;

	mov	eax, DWORD PTR [eax+40]

; 547  : 	    break;

	jmp	SHORT $LN2@xmlXPtrNew
$LN6@xmlXPtrNew:

; 540  : 	case XPATH_POINT:
; 541  : 	    endNode = end->user;

	mov	ecx, DWORD PTR [eax+28]

; 542  : 	    endIndex = end->index;

	mov	eax, DWORD PTR [eax+32]

; 543  : 	    break;

	jmp	SHORT $LN2@xmlXPtrNew
$LN8@xmlXPtrNew:

; 548  : 	case XPATH_NODESET:
; 549  : 	    /*
; 550  : 	     * Empty set ...
; 551  : 	     */
; 552  : 	    if ((end->nodesetval == NULL) || (end->nodesetval->nodeNr <= 0))

	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN10@xmlXPtrNew
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN10@xmlXPtrNew

; 554  : 	    endNode = end->nodesetval->nodeTab[end->nodesetval->nodeNr - 1];

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+ecx*4-4]

; 555  : 	    endIndex = -1;

	or	eax, -1
$LN2@xmlXPtrNew:

; 556  : 	    break;
; 557  : 	default:
; 558  : 	    /* TODO */
; 559  : 	    return(NULL);
; 560  :     }
; 561  : 
; 562  :     ret = xmlXPtrNewRangeInternal(start, -1, endNode, endIndex);

	push	esi
	push	eax
	push	ecx
	push	-1
	push	edx
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 563  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 564  :     return(ret);

	mov	eax, esi
	pop	esi

; 565  : }

	pop	ebp
	ret	0
$LN10@xmlXPtrNew:

; 553  : 		return(NULL);

	xor	eax, eax

; 565  : }

	pop	ebp
	ret	0
_xmlXPtrNewRangeNodeObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewLocationSetNodeSet
_TEXT	SEGMENT
_ret$1$ = -8						; size = 4
_newset$1$ = -4						; size = 4
_set$ = 8						; size = 4
_xmlXPtrNewLocationSetNodeSet PROC			; COMDAT

; 790  : xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _ret$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN5@xmlXPtrNew

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 791  :     xmlXPathObjectPtr ret;
; 792  : 
; 793  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 794  :     if (ret == NULL) {
; 795  :         xmlXPtrErrMemory("allocating locationset");
; 796  : 	return(NULL);

	xor	eax, eax
	pop	ebx

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@xmlXPtrNew:
	push	edi

; 797  :     }
; 798  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	ebx
	call	_memset

; 799  :     ret->type = XPATH_LOCATIONSET;
; 800  :     if (set != NULL) {

	mov	edi, DWORD PTR _set$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx], 7
	test	edi, edi
	je	SHORT $LN6@xmlXPtrNew

; 801  : 	int i;
; 802  : 	xmlLocationSetPtr newset;
; 803  : 
; 804  : 	newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1$[ebp], eax

; 805  : 	if (newset == NULL)

	test	eax, eax
	je	SHORT $LN6@xmlXPtrNew

; 806  : 	    return(ret);
; 807  : 
; 808  : 	for (i = 0;i < set->nodeNr;i++)

	push	esi
	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN3@xmlXPtrNew
	mov	ebx, eax
	npad	7
$LL4@xmlXPtrNew:

; 809  : 	    xmlXPtrLocationSetAdd(newset,

	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 513  :     if (start == NULL)

	test	eax, eax
	je	SHORT $LN11@xmlXPtrNew
$LN12@xmlXPtrNew:

; 514  : 	return(NULL);
; 515  : 
; 516  :     ret = xmlXPtrNewRangeInternal(start, -1, NULL, -1);

	push	-1
	push	0
	push	-1
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
$LN11@xmlXPtrNew:

; 809  : 	    xmlXPtrLocationSetAdd(newset,

	push	eax
	push	ebx
	call	_xmlXPtrLocationSetAdd
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL4@xmlXPtrNew
	mov	ebx, DWORD PTR _ret$1$[ebp]
	mov	eax, DWORD PTR _newset$1$[ebp]
$LN3@xmlXPtrNew:

; 810  : 		        xmlXPtrNewCollapsedRange(set->nodeTab[i]));
; 811  : 
; 812  : 	ret->user = (void *) newset;

	mov	DWORD PTR [ebx+28], eax
	pop	esi
$LN6@xmlXPtrNew:

; 813  :     }
; 814  :     return(ret);

	pop	edi
	mov	eax, ebx
	pop	ebx

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewLocationSetNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewLocationSetNodes
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewLocationSetNodes PROC			; COMDAT

; 763  : xmlXPtrNewLocationSetNodes(xmlNodePtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPtrNew

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 764  :     xmlXPathObjectPtr ret;
; 765  : 
; 766  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
; 767  :     if (ret == NULL) {
; 768  :         xmlXPtrErrMemory("allocating locationset");
; 769  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 778  : }

	pop	ebp
	ret	0
$LN2@xmlXPtrNew:
	push	edi

; 770  :     }
; 771  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	push	esi
	call	_memset

; 772  :     ret->type = XPATH_LOCATIONSET;
; 773  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], 7
	test	eax, eax
	jne	SHORT $LN3@xmlXPtrNew

; 513  :     if (start == NULL)

	mov	eax, DWORD PTR _start$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlXPtrNew

; 514  : 	return(NULL);
; 515  : 
; 516  :     ret = xmlXPtrNewRangeInternal(start, -1, NULL, -1);

	push	-1
	push	0
	push	-1
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H

; 517  :     return(ret);

	mov	edi, eax

; 774  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewCollapsedRange(start));
; 775  :     else
; 776  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewRangeNodes(start,end));
; 777  :     return(ret);

	push	edi
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR [esi+28], eax
	mov	eax, esi
	pop	edi
	pop	esi

; 778  : }

	pop	ebp
	ret	0
$LN3@xmlXPtrNew:

; 491  :     if (start == NULL)

	mov	ecx, DWORD PTR _start$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@xmlXPtrNew
$LN15@xmlXPtrNew:

; 774  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewCollapsedRange(start));
; 775  :     else
; 776  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewRangeNodes(start,end));
; 777  :     return(ret);

	xor	edi, edi
	push	edi
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR [esi+28], eax
	mov	eax, esi
	pop	edi
	pop	esi

; 778  : }

	pop	ebp
	ret	0
$LN12@xmlXPtrNew:

; 496  :     ret = xmlXPtrNewRangeInternal(start, -1, end, -1);

	push	-1
	push	eax
	push	-1
	push	ecx
	call	_xmlXPtrNewRangeInternal
	mov	edi, eax

; 497  :     xmlXPtrRangeCheckOrder(ret);

	push	edi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 774  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewCollapsedRange(start));
; 775  :     else
; 776  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewRangeNodes(start,end));
; 777  :     return(ret);

	push	edi
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR [esi+28], eax
	mov	eax, esi
	pop	edi
	pop	esi

; 778  : }

	pop	ebp
	ret	0
_xmlXPtrNewLocationSetNodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodes
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodes PROC				; COMDAT

; 488  : xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@xmlXPtrNew

; 489  :     xmlXPathObjectPtr ret;
; 490  : 
; 491  :     if (start == NULL)
; 492  : 	return(NULL);
; 493  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlXPtrNew

; 495  : 
; 496  :     ret = xmlXPtrNewRangeInternal(start, -1, end, -1);

	push	esi
	push	-1
	push	eax
	push	-1
	push	ecx
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 497  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 498  :     return(ret);

	mov	eax, esi
	pop	esi

; 499  : }

	pop	ebp
	ret	0
$LN5@xmlXPtrNew:

; 494  : 	return(NULL);

	xor	eax, eax

; 499  : }

	pop	ebp
	ret	0
_xmlXPtrNewRangeNodes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangePointNode
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangePointNode PROC				; COMDAT

; 438  : xmlXPtrNewRangePointNode(xmlXPathObjectPtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _start$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlXPtrNew

; 439  :     xmlXPathObjectPtr ret;
; 440  : 
; 441  :     if (start == NULL)
; 442  : 	return(NULL);
; 443  :     if (end == NULL)

	mov	ecx, DWORD PTR _end$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPtrNew

; 444  : 	return(NULL);
; 445  :     if (start->type != XPATH_POINT)

	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN6@xmlXPtrNew

; 447  : 
; 448  :     ret = xmlXPtrNewRangeInternal(start->user, start->index, end, -1);

	push	esi
	push	-1
	push	ecx
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax+28]
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 449  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 450  :     return(ret);

	mov	eax, esi
	pop	esi

; 451  : }

	pop	ebp
	ret	0
$LN6@xmlXPtrNew:

; 446  : 	return(NULL);

	xor	eax, eax

; 451  : }

	pop	ebp
	ret	0
_xmlXPtrNewRangePointNode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodePoint
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodePoint PROC				; COMDAT

; 463  : xmlXPtrNewRangeNodePoint(xmlNodePtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@xmlXPtrNew

; 464  :     xmlXPathObjectPtr ret;
; 465  : 
; 466  :     if (start == NULL)
; 467  : 	return(NULL);
; 468  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlXPtrNew

; 469  : 	return(NULL);
; 470  :     if (end->type != XPATH_POINT)

	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN6@xmlXPtrNew

; 472  : 
; 473  :     ret = xmlXPtrNewRangeInternal(start, -1, end->user, end->index);

	push	esi
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax+28]
	push	-1
	push	ecx
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 474  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 475  :     return(ret);

	mov	eax, esi
	pop	esi

; 476  : }

	pop	ebp
	ret	0
$LN6@xmlXPtrNew:

; 471  : 	return(NULL);

	xor	eax, eax

; 476  : }

	pop	ebp
	ret	0
_xmlXPtrNewRangeNodePoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangePoints
_TEXT	SEGMENT
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangePoints PROC				; COMDAT

; 410  : xmlXPtrNewRangePoints(xmlXPathObjectPtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPtrNew

; 411  :     xmlXPathObjectPtr ret;
; 412  : 
; 413  :     if (start == NULL)
; 414  : 	return(NULL);
; 415  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlXPtrNew

; 416  : 	return(NULL);
; 417  :     if (start->type != XPATH_POINT)

	cmp	DWORD PTR [ecx], 5
	jne	SHORT $LN7@xmlXPtrNew

; 418  : 	return(NULL);
; 419  :     if (end->type != XPATH_POINT)

	cmp	DWORD PTR [eax], 5
	jne	SHORT $LN7@xmlXPtrNew

; 421  : 
; 422  :     ret = xmlXPtrNewRangeInternal(start->user, start->index, end->user,

	push	esi
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax+28]
	push	DWORD PTR [ecx+32]
	push	DWORD PTR [ecx+28]
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 423  :                                   end->index);
; 424  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 425  :     return(ret);

	mov	eax, esi
	pop	esi

; 426  : }

	pop	ebp
	ret	0
$LN7@xmlXPtrNew:

; 420  : 	return(NULL);

	xor	eax, eax

; 426  : }

	pop	ebp
	ret	0
_xmlXPtrNewRangePoints ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRange
_TEXT	SEGMENT
_start$ = 8						; size = 4
_startindex$ = 12					; size = 4
_end$ = 16						; size = 4
_endindex$ = 20						; size = 4
_xmlXPtrNewRange PROC					; COMDAT

; 383  : 	        xmlNodePtr end, int endindex) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _start$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@xmlXPtrNew

; 384  :     xmlXPathObjectPtr ret;
; 385  : 
; 386  :     if (start == NULL)
; 387  : 	return(NULL);
; 388  :     if (end == NULL)

	mov	eax, DWORD PTR _end$[ebp]
	test	eax, eax
	je	SHORT $LN7@xmlXPtrNew

; 389  : 	return(NULL);
; 390  :     if (startindex < 0)

	mov	edx, DWORD PTR _startindex$[ebp]
	test	edx, edx
	js	SHORT $LN7@xmlXPtrNew

; 391  : 	return(NULL);
; 392  :     if (endindex < 0)

	mov	esi, DWORD PTR _endindex$[ebp]
	test	esi, esi
	js	SHORT $LN7@xmlXPtrNew

; 394  : 
; 395  :     ret = xmlXPtrNewRangeInternal(start, startindex, end, endindex);

	push	esi
	push	eax
	push	edx
	push	ecx
	call	_xmlXPtrNewRangeInternal
	mov	esi, eax

; 396  :     xmlXPtrRangeCheckOrder(ret);

	push	esi
	call	_xmlXPtrRangeCheckOrder
	add	esp, 20					; 00000014H

; 397  :     return(ret);

	mov	eax, esi
	pop	esi

; 398  : }

	pop	ebp
	ret	0
$LN7@xmlXPtrNew:

; 393  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 398  : }

	pop	ebp
	ret	0
_xmlXPtrNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetMerge
_TEXT	SEGMENT
_i$1$ = 8						; size = 4
_val1$ = 8						; size = 4
_val2$ = 12						; size = 4
_xmlXPtrLocationSetMerge PROC				; COMDAT

; 665  : xmlXPtrLocationSetMerge(xmlLocationSetPtr val1, xmlLocationSetPtr val2) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _val1$[ebp]
	test	edi, edi
	jne	SHORT $LN5@xmlXPtrLoc

; 666  :     int i;
; 667  : 
; 668  :     if (val1 == NULL) return(NULL);

	xor	eax, eax
	pop	edi

; 680  : }

	pop	ebp
	ret	0
$LN5@xmlXPtrLoc:

; 669  :     if (val2 == NULL) return(val1);

	mov	eax, DWORD PTR _val2$[ebp]
	test	eax, eax
	je	$LN3@xmlXPtrLoc

; 670  : 
; 671  :     /*
; 672  :      * !!!!! this can be optimized a lot, knowing that both
; 673  :      *       val1 and val2 already have unicity of their values.
; 674  :      */
; 675  : 
; 676  :     for (i = 0;i < val2->locNr;i++)

	push	esi
	xor	esi, esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	DWORD PTR [eax], esi
	jle	$LN47@xmlXPtrLoc
	push	ebx
$LL4@xmlXPtrLoc:

; 677  :         xmlXPtrLocationSetAdd(val1, val2->locTab[i]);

	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+esi*4]

; 615  :     if ((cur == NULL) || (val == NULL)) return;

	test	esi, esi
	je	$LN2@xmlXPtrLoc

; 616  : 
; 617  :     /*
; 618  :      * check against doublons
; 619  :      */
; 620  :     for (i = 0;i < cur->locNr;i++) {

	mov	ebx, DWORD PTR [edi]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN10@xmlXPtrLoc

; 320  :     if (range1->user != range2->user)

	mov	ebx, DWORD PTR [edi+8]
	npad	3
$LL11@xmlXPtrLoc:

; 621  : 	if (xmlXPtrRangesEqual(cur->locTab[i], val)) {

	mov	eax, DWORD PTR [ebx]

; 312  :     if (range1 == range2)

	cmp	eax, esi
	je	SHORT $LN36@xmlXPtrLoc

; 313  : 	return(1);
; 314  :     if ((range1 == NULL) || (range2 == NULL))

	test	eax, eax
	je	SHORT $LN24@xmlXPtrLoc

; 315  : 	return(0);
; 316  :     if (range1->type != range2->type)

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN24@xmlXPtrLoc

; 317  : 	return(0);
; 318  :     if (range1->type != XPATH_RANGE)

	cmp	ecx, 6
	jne	SHORT $LN24@xmlXPtrLoc

; 319  : 	return(0);
; 320  :     if (range1->user != range2->user)

	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR [esi+28]
	jne	SHORT $LN24@xmlXPtrLoc

; 321  : 	return(0);
; 322  :     if (range1->index != range2->index)

	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR [esi+32]
	jne	SHORT $LN24@xmlXPtrLoc

; 323  : 	return(0);
; 324  :     if (range1->user2 != range2->user2)

	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR [esi+36]
	jne	SHORT $LN24@xmlXPtrLoc

; 325  : 	return(0);
; 326  :     if (range1->index2 != range2->index2)

	mov	eax, DWORD PTR [eax+40]
	cmp	eax, DWORD PTR [esi+40]
	je	SHORT $LN36@xmlXPtrLoc
$LN24@xmlXPtrLoc:

; 620  :     for (i = 0;i < cur->locNr;i++) {

	inc	edx
	add	ebx, 4
	cmp	edx, DWORD PTR [edi]
	jl	SHORT $LL11@xmlXPtrLoc
	mov	ebx, DWORD PTR [edi]
$LN10@xmlXPtrLoc:

; 624  : 	}
; 625  :     }
; 626  : 
; 627  :     /*
; 628  :      * grow the locTab if needed
; 629  :      */
; 630  :     if (cur->locMax == 0) {

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN15@xmlXPtrLoc

; 631  :         cur->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [edi+8], eax

; 632  : 					     sizeof(xmlXPathObjectPtr));
; 633  : 	if (cur->locTab == NULL) {

	test	eax, eax
	jne	SHORT $LN17@xmlXPtrLoc

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 635  : 	    return;

	jmp	SHORT $LN2@xmlXPtrLoc
$LN36@xmlXPtrLoc:

; 622  : 	    xmlXPathFreeObject(val);

	push	esi
	call	_xmlXPathFreeObject
	add	esp, 4

; 623  : 	    return;

	jmp	SHORT $LN2@xmlXPtrLoc
$LN17@xmlXPtrLoc:
	xorps	xmm0, xmm0

; 636  : 	}
; 637  : 	memset(cur->locTab, 0 ,

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 638  : 	       XML_RANGESET_DEFAULT * (size_t) sizeof(xmlXPathObjectPtr));
; 639  :         cur->locMax = XML_RANGESET_DEFAULT;

	mov	DWORD PTR [edi+4], 10			; 0000000aH
	jmp	SHORT $LN18@xmlXPtrLoc
$LN15@xmlXPtrLoc:

; 640  :     } else if (cur->locNr == cur->locMax) {

	cmp	ebx, eax
	jne	SHORT $LN18@xmlXPtrLoc

; 641  :         xmlXPathObjectPtr *temp;
; 642  : 
; 643  :         cur->locMax *= 2;

	add	eax, eax
	mov	DWORD PTR [edi+4], eax

; 644  : 	temp = (xmlXPathObjectPtr *) xmlRealloc(cur->locTab, cur->locMax *

	shl	eax, 2
	push	eax
	push	DWORD PTR [edi+8]
	call	DWORD PTR _xmlRealloc
	add	esp, 8

; 645  : 				      sizeof(xmlXPathObjectPtr));
; 646  : 	if (temp == NULL) {

	test	eax, eax
	jne	SHORT $LN19@xmlXPtrLoc

; 647  : 	    xmlXPtrErrMemory("adding location to set");

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 648  : 	    return;

	jmp	SHORT $LN2@xmlXPtrLoc
$LN19@xmlXPtrLoc:

; 649  : 	}
; 650  : 	cur->locTab = temp;

	mov	DWORD PTR [edi+8], eax
$LN18@xmlXPtrLoc:

; 651  :     }
; 652  :     cur->locTab[cur->locNr++] = val;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+ecx*4], esi
	inc	DWORD PTR [edi]
$LN2@xmlXPtrLoc:

; 670  : 
; 671  :     /*
; 672  :      * !!!!! this can be optimized a lot, knowing that both
; 673  :      *       val1 and val2 already have unicity of their values.
; 674  :      */
; 675  : 
; 676  :     for (i = 0;i < val2->locNr;i++)

	mov	esi, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _val2$[ebp]
	inc	esi
	mov	DWORD PTR _i$1$[ebp], esi
	cmp	esi, DWORD PTR [eax]
	jl	$LL4@xmlXPtrLoc
	pop	ebx
$LN47@xmlXPtrLoc:
	pop	esi
$LN3@xmlXPtrLoc:

; 678  : 
; 679  :     return(val1);

	mov	eax, edi
	pop	edi

; 680  : }

	pop	ebp
	ret	0
_xmlXPtrLocationSetMerge ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrFreeLocationSet
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_xmlXPtrFreeLocationSet PROC				; COMDAT

; 739  : xmlXPtrFreeLocationSet(xmlLocationSetPtr obj) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _obj$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlXPtrFre

; 740  :     int i;
; 741  : 
; 742  :     if (obj == NULL) return;
; 743  :     if (obj->locTab != NULL) {

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN6@xmlXPtrFre

; 744  : 	for (i = 0;i < obj->locNr; i++) {

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi], edi
	jle	SHORT $LN3@xmlXPtrFre
$LL4@xmlXPtrFre:

; 745  :             xmlXPathFreeObject(obj->locTab[i]);

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax+edi*4]
	call	_xmlXPathFreeObject
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi]
	jl	SHORT $LL4@xmlXPtrFre
	mov	eax, DWORD PTR [esi+8]
$LN3@xmlXPtrFre:

; 746  : 	}
; 747  : 	xmlFree(obj->locTab);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	pop	edi
$LN6@xmlXPtrFre:

; 748  :     }
; 749  :     xmlFree(obj);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlXPtrFre:
	pop	esi

; 750  : }

	pop	ebp
	ret	0
_xmlXPtrFreeLocationSet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetCreate
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlXPtrLocationSetCreate PROC				; COMDAT

; 578  : xmlXPtrLocationSetCreate(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlXPtrLoc

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	eax
	push	eax
	push	eax
	push	eax
	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	push	eax
	push	eax
	push	2
	push	2
	push	13					; 0000000dH
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 579  :     xmlLocationSetPtr ret;
; 580  : 
; 581  :     ret = (xmlLocationSetPtr) xmlMalloc(sizeof(xmlLocationSet));
; 582  :     if (ret == NULL) {
; 583  :         xmlXPtrErrMemory("allocating locationset");
; 584  : 	return(NULL);

	xor	eax, eax
	pop	esi

; 601  : }

	pop	ebp
	ret	0
$LN2@xmlXPtrLoc:
	push	edi

; 585  :     }
; 586  :     memset(ret, 0 , (size_t) sizeof(xmlLocationSet));
; 587  :     if (val != NULL) {

	mov	edi, DWORD PTR _val$[ebp]
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	je	SHORT $LN3@xmlXPtrLoc

; 588  :         ret->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *

	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 589  : 					     sizeof(xmlXPathObjectPtr));
; 590  : 	if (ret->locTab == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlXPtrLoc

; 591  : 	    xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory

; 592  : 	    xmlFree(ret);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 8

; 593  : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 601  : }

	pop	ebp
	ret	0
$LN4@xmlXPtrLoc:
	xorps	xmm0, xmm0

; 594  : 	}
; 595  : 	memset(ret->locTab, 0 ,

	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0

; 596  : 	       XML_RANGESET_DEFAULT * (size_t) sizeof(xmlXPathObjectPtr));
; 597  :         ret->locMax = XML_RANGESET_DEFAULT;
; 598  : 	ret->locTab[ret->locNr++] = val;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], 10			; 0000000aH
	mov	DWORD PTR [eax+ecx*4], edi
	inc	DWORD PTR [esi]
$LN3@xmlXPtrLoc:

; 599  :     }
; 600  :     return(ret);

	pop	edi
	mov	eax, esi
	pop	esi

; 601  : }

	pop	ebp
	ret	0
_xmlXPtrLocationSetCreate ENDP
_TEXT	ENDS
END
