; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlsave.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__BAD788A4_xmlsave@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlAttrSerializeTxtContent
PUBLIC	_xmlDocDumpFormatMemory
PUBLIC	_xmlDocDumpMemory
PUBLIC	_xmlDocDumpMemoryEnc
PUBLIC	_xmlDocDumpFormatMemoryEnc
PUBLIC	_xmlDocFormatDump
PUBLIC	_xmlDocDump
PUBLIC	_xmlElemDump
PUBLIC	_xmlSaveFile
PUBLIC	_xmlSaveFormatFile
PUBLIC	_xmlBufNodeDump
PUBLIC	_xmlNodeDump
PUBLIC	_xmlSaveFileTo
PUBLIC	_xmlSaveFormatFileTo
PUBLIC	_xmlNodeDumpOutput
PUBLIC	_xmlSaveFormatFileEnc
PUBLIC	_xmlSaveFileEnc
PUBLIC	_xmlIsXHTML
PUBLIC	_xmlSaveToFd
PUBLIC	_xmlSaveToFilename
PUBLIC	_xmlSaveToBuffer
PUBLIC	_xmlSaveToIO
PUBLIC	_xmlSaveDoc
PUBLIC	_xmlSaveTree
PUBLIC	_xmlSaveFlush
PUBLIC	_xmlSaveClose
PUBLIC	_xmlSaveSetEscape
PUBLIC	_xmlSaveSetAttrEscape
PUBLIC	_xmlBufAttrSerializeTxtContent
PUBLIC	_xmlBufDumpNotationTable
PUBLIC	_xmlBufDumpElementDecl
PUBLIC	_xmlBufDumpAttributeDecl
PUBLIC	_xmlBufDumpEntityDecl
PUBLIC	_xmlNsListDumpOutput
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@ ; `string'
PUBLIC	??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@ ; `string'
PUBLIC	??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@ ; `string'
PUBLIC	??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ ; `string'
PUBLIC	??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ ; `string'
PUBLIC	??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@	; `string'
PUBLIC	??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@ ; `string'
PUBLIC	??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@	; `string'
PUBLIC	??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@ ; `string'
PUBLIC	??_C@_0BI@FGAKHCKD@creating?5saving?5context@	; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_06PNFLLAEF@xmlns?3@			; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN@				; `string'
PUBLIC	??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@		; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_03OEIPKGAG@?5?$FL?6@			; `string'
PUBLIC	??_C@_02CFBPIAHD@?$FN?$DO@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_02ILLPBGAO@?$DN?$CC@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_02HFBBBACF@?$DM?$DP@			; `string'
PUBLIC	??_C@_02GOEMJPDN@?$DP?$DO@			; `string'
PUBLIC	??_C@_04FFDNBKGC@?$DM?$CB?9?9@			; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@ ; `string'
PUBLIC	??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@		; `string'
PUBLIC	??_C@_03MCHNFBAC@?$FN?$FN?$DO@			; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_02HCGKDMEN@?1?$DO@			; `string'
PUBLIC	??_C@_02DPNDACHE@?$DM?1@			; `string'
PUBLIC	??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@	; `string'
PUBLIC	??_C@_05FLCMBAOK@?$CC1?40?$CC@			; `string'
PUBLIC	??_C@_0L@GJNPICMJ@?5encoding?$DN@		; `string'
PUBLIC	??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@	; `string'
PUBLIC	??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@	; `string'
PUBLIC	??_C@_03KCOJOIAE@?$DP?$DO?6@			; `string'
PUBLIC	??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@ ; `string'
PUBLIC	??_C@_04GOEDGNCF@area@				; `string'
PUBLIC	??_C@_02FGOECCNH@br@				; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_08IOLGIJGJ@basefont@			; `string'
PUBLIC	??_C@_03HNOLNALI@col@				; `string'
PUBLIC	??_C@_05MIJNFGED@frame@				; `string'
PUBLIC	??_C@_02FLHDKHAB@hr@				; `string'
PUBLIC	??_C@_03PCCGDNHJ@img@				; `string'
PUBLIC	??_C@_05DFJCHPDH@input@				; `string'
PUBLIC	??_C@_07JMLOFMGP@isindex@			; `string'
PUBLIC	??_C@_04OHHBHOGB@link@				; `string'
PUBLIC	??_C@_04HLJJCGEF@meta@				; `string'
PUBLIC	??_C@_05LJDNNBIK@param@				; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p@				; `string'
PUBLIC	??_C@_03FEJMGOGI@div@				; `string'
PUBLIC	??_C@_03HBNNNHNM@map@				; `string'
PUBLIC	??_C@_06MJBNHHFM@applet@			; `string'
PUBLIC	??_C@_04MLMMMEIO@form@				; `string'
PUBLIC	??_C@_06PKBNCBKI@iframe@			; `string'
PUBLIC	??_C@_05OCPGBOOB@?5id?$DN?$CC@			; `string'
PUBLIC	??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@		; `string'
PUBLIC	??_C@_07OHOHIONL@?5lang?$DN?$CC@		; `string'
PUBLIC	??_C@_04PNIFHPHN@html@				; `string'
PUBLIC	??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@ ; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_0L@NALBGOHO@http?9equiv@			; `string'
PUBLIC	??_C@_0N@LAFFMKKA@Content?9Type@		; `string'
PUBLIC	??_C@_03MFNJFHN@?5?1?$DO@			; `string'
PUBLIC	??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@ ; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04FADKMBBI@?$CC?5?1?$DO@			; `string'
PUBLIC	??_C@_05EJOHHIMP@?$CG?$CD10?$DL@		; `string'
PUBLIC	??_C@_05ELKBMGJG@?$CG?$CD13?$DL@		; `string'
PUBLIC	??_C@_04NCNDODLB@?$CG?$CD9?$DL@			; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_04GJOGLFEJ@?$CGlt?$DL@			; `string'
PUBLIC	??_C@_04LOOHDCEI@?$CGgt?$DL@			; `string'
PUBLIC	??_C@_05JKJFEODM@?$CGamp?$DL@			; `string'
PUBLIC	??_C@_0BA@GIGPFFIA@creating?5buffer@		; `string'
PUBLIC	??_C@_0BA@CMJGPMBH@creating?5output@		; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlGetIntSubset:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlGetProp:PROC
EXTRN	_xmlGetCompressMode:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlDumpNotationTable:PROC
EXTRN	_xmlDumpElementDecl:PROC
EXTRN	_xmlDumpAttributeDecl:PROC
EXTRN	_xmlDumpEntityDecl:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlParseCharEncoding:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	_xmlAllocOutputBuffer:PROC
EXTRN	_xmlOutputBufferCreateFilename:PROC
EXTRN	_xmlOutputBufferCreateFile:PROC
EXTRN	_xmlOutputBufferCreateBuffer:PROC
EXTRN	_xmlOutputBufferCreateFd:PROC
EXTRN	_xmlOutputBufferCreateIO:PROC
EXTRN	_xmlOutputBufferWrite:PROC
EXTRN	_xmlOutputBufferWriteString:PROC
EXTRN	_xmlOutputBufferWriteEscape:PROC
EXTRN	_xmlOutputBufferFlush:PROC
EXTRN	_xmlOutputBufferClose:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlIndentTreeOutput:PROC
EXTRN	___xmlTreeIndentString:PROC
EXTRN	___xmlSaveNoEmptyTags:PROC
EXTRN	_htmlGetMetaEncoding:PROC
EXTRN	_htmlSetMetaEncoding:PROC
EXTRN	_htmlNodeDumpFormatOutput:PROC
EXTRN	_htmlDocContentDumpFormatOutput:PROC
EXTRN	_htmlNodeDumpOutput:PROC
EXTRN	_htmlIsBooleanAttr:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufSetAllocationScheme:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufFree:PROC
EXTRN	_xmlBufAdd:PROC
EXTRN	_xmlBufWriteQuotedString:PROC
EXTRN	_xmlBufFromBuffer:PROC
EXTRN	_xmlBufBackToBuffer:PROC
EXTRN	_xmlBufMergeBuffer:PROC
EXTRN	_xmlCharEncOutput:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
;	COMDAT ??_C@_0BA@CMJGPMBH@creating?5output@
CONST	SEGMENT
??_C@_0BA@CMJGPMBH@creating?5output@ DB 'creating output', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIGPFFIA@creating?5buffer@
CONST	SEGMENT
??_C@_0BA@GIGPFFIA@creating?5buffer@ DB 'creating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJFEODM@?$CGamp?$DL@
CONST	SEGMENT
??_C@_05JKJFEODM@?$CGamp?$DL@ DB '&amp;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOOHDCEI@?$CGgt?$DL@
CONST	SEGMENT
??_C@_04LOOHDCEI@?$CGgt?$DL@ DB '&gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GJOGLFEJ@?$CGlt?$DL@
CONST	SEGMENT
??_C@_04GJOGLFEJ@?$CGlt?$DL@ DB '&lt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCNDODLB@?$CG?$CD9?$DL@
CONST	SEGMENT
??_C@_04NCNDODLB@?$CG?$CD9?$DL@ DB '&#9;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELKBMGJG@?$CG?$CD13?$DL@
CONST	SEGMENT
??_C@_05ELKBMGJG@?$CG?$CD13?$DL@ DB '&#13;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJOHHIMP@?$CG?$CD10?$DL@
CONST	SEGMENT
??_C@_05EJOHHIMP@?$CG?$CD10?$DL@ DB '&#10;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FADKMBBI@?$CC?5?1?$DO@
CONST	SEGMENT
??_C@_04FADKMBBI@?$CC?5?1?$DO@ DB '" />', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
CONST	SEGMENT
??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@ DB '<m'
	DB	'eta http-equiv="Content-Type" content="text/html; charset=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFNJFHN@?5?1?$DO@
CONST	SEGMENT
??_C@_03MFNJFHN@?5?1?$DO@ DB ' />', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAFFMKKA@Content?9Type@
CONST	SEGMENT
??_C@_0N@LAFFMKKA@Content?9Type@ DB 'Content-Type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NALBGOHO@http?9equiv@
CONST	SEGMENT
??_C@_0L@NALBGOHO@http?9equiv@ DB 'http-equiv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@
CONST	SEGMENT
??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@ DB ' xm'
	DB	'lns="http://www.w3.org/1999/xhtml"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNIFHPHN@html@
CONST	SEGMENT
??_C@_04PNIFHPHN@html@ DB 'html', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHOHIONL@?5lang?$DN?$CC@
CONST	SEGMENT
??_C@_07OHOHIONL@?5lang?$DN?$CC@ DB ' lang="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@
CONST	SEGMENT
??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@ DB ' xml:lang="', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCPGBOOB@?5id?$DN?$CC@
CONST	SEGMENT
??_C@_05OCPGBOOB@?5id?$DN?$CC@ DB ' id="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PKBNCBKI@iframe@
CONST	SEGMENT
??_C@_06PKBNCBKI@iframe@ DB 'iframe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLMMMEIO@form@
CONST	SEGMENT
??_C@_04MLMMMEIO@form@ DB 'form', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJBNHHFM@applet@
CONST	SEGMENT
??_C@_06MJBNHHFM@applet@ DB 'applet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map@
CONST	SEGMENT
??_C@_03HBNNNHNM@map@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEJMGOGI@div@
CONST	SEGMENT
??_C@_03FEJMGOGI@div@ DB 'div', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p@
CONST	SEGMENT
??_C@_01JBBJJEPG@p@ DB 'p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LJDNNBIK@param@
CONST	SEGMENT
??_C@_05LJDNNBIK@param@ DB 'param', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLJJCGEF@meta@
CONST	SEGMENT
??_C@_04HLJJCGEF@meta@ DB 'meta', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHHBHOGB@link@
CONST	SEGMENT
??_C@_04OHHBHOGB@link@ DB 'link', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMLOFMGP@isindex@
CONST	SEGMENT
??_C@_07JMLOFMGP@isindex@ DB 'isindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFJCHPDH@input@
CONST	SEGMENT
??_C@_05DFJCHPDH@input@ DB 'input', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCCGDNHJ@img@
CONST	SEGMENT
??_C@_03PCCGDNHJ@img@ DB 'img', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FLHDKHAB@hr@
CONST	SEGMENT
??_C@_02FLHDKHAB@hr@ DB 'hr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIJNFGED@frame@
CONST	SEGMENT
??_C@_05MIJNFGED@frame@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HNOLNALI@col@
CONST	SEGMENT
??_C@_03HNOLNALI@col@ DB 'col', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOLGIJGJ@basefont@
CONST	SEGMENT
??_C@_08IOLGIJGJ@basefont@ DB 'basefont', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGOECCNH@br@
CONST	SEGMENT
??_C@_02FGOECCNH@br@ DB 'br', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOEDGNCF@area@
CONST	SEGMENT
??_C@_04GOEDGNCF@area@ DB 'area', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@
CONST	SEGMENT
??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@ DB 'http://www.w3'
	DB	'.org/1999/xhtml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCOJOIAE@?$DP?$DO?6@
CONST	SEGMENT
??_C@_03KCOJOIAE@?$DP?$DO?6@ DB '?>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@
CONST	SEGMENT
??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@ DB ' standalone="yes"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@
CONST	SEGMENT
??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@ DB ' standalone="no"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJNPICMJ@?5encoding?$DN@
CONST	SEGMENT
??_C@_0L@GJNPICMJ@?5encoding?$DN@ DB ' encoding=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLCMBAOK@?$CC1?40?$CC@
CONST	SEGMENT
??_C@_05FLCMBAOK@?$CC1?40?$CC@ DB '"1.0"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@
CONST	SEGMENT
??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@ DB '<?xml version=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNDACHE@?$DM?1@
CONST	SEGMENT
??_C@_02DPNDACHE@?$DM?1@ DB '</', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCGKDMEN@?1?$DO@
CONST	SEGMENT
??_C@_02HCGKDMEN@?1?$DO@ DB '/>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
CONST	SEGMENT
??_C@_03MCHNFBAC@?$FN?$FN?$DO@ DB ']]>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
CONST	SEGMENT
??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@ DB '<![CDATA[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
CONST	SEGMENT
??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@ DB '<![CDATA[]]>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
CONST	SEGMENT
??_C@_04FFDNBKGC@?$DM?$CB?9?9@ DB '<!--', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GOEMJPDN@?$DP?$DO@
CONST	SEGMENT
??_C@_02GOEMJPDN@?$DP?$DO@ DB '?>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HFBBBACF@?$DM?$DP@
CONST	SEGMENT
??_C@_02HFBBBACF@?$DM?$DP@ DB '<?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ILLPBGAO@?$DN?$CC@
CONST	SEGMENT
??_C@_02ILLPBGAO@?$DN?$CC@ DB '="', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CFBPIAHD@?$FN?$DO@
CONST	SEGMENT
??_C@_02CFBPIAHD@?$FN?$DO@ DB ']>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEIPKGAG@?5?$FL?6@
CONST	SEGMENT
??_C@_03OEIPKGAG@?5?$FL?6@ DB ' [', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
CONST	SEGMENT
??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@ DB '<!DOCTYPE ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNFLLAEF@xmlns?3@
CONST	SEGMENT
??_C@_06PNFLLAEF@xmlns?3@ DB 'xmlns:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@
CONST	SEGMENT
??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@ DB 'creating encoding buff'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGAKHCKD@creating?5saving?5context@
CONST	SEGMENT
??_C@_0BI@FGAKHCKD@creating?5saving?5context@ DB 'creating saving context'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@
CONST	SEGMENT
??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@ DB 'xmlEscapeEnt'
	DB	'ities : char out of range', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
CONST	SEGMENT
??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@ DB 'unexpected error numb'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@
CONST	SEGMENT
??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@ DB 'document has no DOCT'
	DB	'YPE', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@ DB 'unknown encoding %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
CONST	SEGMENT
??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@ DB 'invalid character val'
	DB	'ue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
CONST	SEGMENT
??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@ DB 'string is not in UT'
	DB	'F-8', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
CONST	SEGMENT
??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@ DB 'http://ww'
	DB	'w.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@
CONST	SEGMENT
??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@ DB '-//W3C//'
	DB	'DTD XHTML 1.0 Transitional//EN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@
CONST	SEGMENT
??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@ DB '-//W3C/'
	DB	'/DTD XHTML 1.0 Frameset//EN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@
CONST	SEGMENT
??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@ DB '-//W3C'
	DB	'//DTD XHTML 1.0 Strict//EN', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlNodeListDumpOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xhtmlNodeListDumpOutput PROC				; COMDAT

; 1417 : xhtmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xhtmlNodeL

; 1418 :     xmlOutputBufferPtr buf;
; 1419 : 
; 1420 :     if (cur == NULL) return;
; 1421 :     buf = ctxt->buf;

	push	ebx
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [edi+24]
	npad	3
$LL2@xhtmlNodeL:

; 1422 :     while (cur != NULL) {
; 1423 : 	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&

	cmp	DWORD PTR [edi+40], 1
	jne	SHORT $LN5@xhtmlNodeL
	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xhtmlNodeL
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $LN5@xhtmlNodeL

; 1424 : 	    (cur->type == XML_ELEMENT_NODE))
; 1425 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	edx, DWORD PTR [edi+108]
	lea	eax, DWORD PTR [edi+44]
	cmp	DWORD PTR [edi+36], edx
	push	eax
	cmovle	edx, DWORD PTR [edi+36]
	imul	edx, DWORD PTR [edi+112]
	push	edx
	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xhtmlNodeL:

; 1426 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1427 : 				  ctxt->indent_nr : ctxt->level),
; 1428 : 				 ctxt->indent);
; 1429 :         xhtmlNodeDumpOutput(ctxt, cur);

	push	esi
	push	edi
	call	_xhtmlNodeDumpOutput
	add	esp, 8

; 1430 : 	if (ctxt->format == 1) {

	cmp	DWORD PTR [edi+40], 1
	jne	SHORT $LN6@xhtmlNodeL

; 1431 : 	    xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN6@xhtmlNodeL:

; 1432 : 	}
; 1433 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xhtmlNodeL
	pop	edi
	pop	ebx
$LN3@xhtmlNodeL:
	pop	esi

; 1434 :     }
; 1435 : }

	pop	ebp
	ret	0
_xhtmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlAttrListDumpOutput
_TEXT	SEGMENT
_parent$1$ = -20					; size = 4
_lang$1$ = -16						; size = 4
_name$1$ = -12						; size = 4
_id$1$ = -8						; size = 4
_xml_lang$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_buf$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xhtmlAttrListDumpOutput PROC				; COMDAT

; 1331 : xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	xor	esi, esi
	xor	ebx, ebx
	mov	DWORD PTR _xml_lang$1$[ebp], esi
	xor	eax, eax
	mov	esi, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _lang$1$[ebp], ebx
	mov	DWORD PTR _id$1$[ebp], eax
	test	esi, esi
	je	$LN22@xhtmlAttrL

; 1332 :     xmlAttrPtr xml_lang = NULL;
; 1333 :     xmlAttrPtr lang = NULL;
; 1334 :     xmlAttrPtr name = NULL;
; 1335 :     xmlAttrPtr id = NULL;
; 1336 :     xmlNodePtr parent;
; 1337 :     xmlOutputBufferPtr buf;
; 1338 : 
; 1339 :     if (cur == NULL) return;
; 1340 :     buf = ctxt->buf;

	mov	ebx, DWORD PTR [esi+20]
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]

; 1341 :     parent = cur->parent;

	mov	DWORD PTR _parent$1$[ebp], ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR [edi+24]
	mov	DWORD PTR _buf$1$[ebp], edi
	xor	edi, edi
$LL2@xhtmlAttrL:

; 1342 :     while (cur != NULL) {
; 1343 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "id")))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN40@xhtmlAttrL
	push	OFFSET ??_C@_02EGCJHIOB@id@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xhtmlAttrL

; 1344 : 	    id = cur;

	mov	DWORD PTR _id$1$[ebp], esi
	jmp	$LN16@xhtmlAttrL
$LN33@xhtmlAttrL:

; 1345 : 	else
; 1346 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "name")))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN40@xhtmlAttrL
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@xhtmlAttrL

; 1347 : 	    name = cur;

	mov	edi, esi
	jmp	$LN16@xhtmlAttrL
$LN34@xhtmlAttrL:

; 1348 : 	else
; 1349 : 	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")))

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN40@xhtmlAttrL
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@xhtmlAttrL

; 1350 : 	    lang = cur;

	mov	DWORD PTR _lang$1$[ebp], esi
	jmp	$LN16@xhtmlAttrL
$LN35@xhtmlAttrL:

; 1351 : 	else
; 1352 : 	if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")) &&

	cmp	DWORD PTR [esi+36], 0
	je	SHORT $LN42@xhtmlAttrL
$LN40@xhtmlAttrL:
	push	OFFSET ??_C@_04IOHABJIC@lang@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xhtmlAttrL
	mov	eax, DWORD PTR [esi+36]
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [eax+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xhtmlAttrL

; 1353 : 	    (xmlStrEqual(cur->ns->prefix, BAD_CAST "xml")))
; 1354 : 	    xml_lang = cur;

	mov	DWORD PTR _xml_lang$1$[ebp], esi
	jmp	SHORT $LN16@xhtmlAttrL
$LN11@xhtmlAttrL:

; 1355 : 	else if ((cur->ns == NULL) &&
; 1356 : 		 ((cur->children == NULL) ||
; 1357 : 		  (cur->children->content == NULL) ||
; 1358 : 		  (cur->children->content[0] == 0)) &&

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN16@xhtmlAttrL
$LN42@xhtmlAttrL:
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN14@xhtmlAttrL
	mov	eax, DWORD PTR [eax+40]
	test	eax, eax
	je	SHORT $LN14@xhtmlAttrL
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN16@xhtmlAttrL
$LN14@xhtmlAttrL:
	push	DWORD PTR [esi+8]
	call	_htmlIsBooleanAttr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@xhtmlAttrL

; 1359 : 		 (htmlIsBooleanAttr(cur->name))) {
; 1360 : 	    if (cur->children != NULL)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN15@xhtmlAttrL

; 1361 : 		xmlFreeNode(cur->children);

	push	eax
	call	_xmlFreeNode
	add	esp, 4
$LN15@xhtmlAttrL:

; 1362 : 	    cur->children = xmlNewText(cur->name);

	push	DWORD PTR [esi+8]
	call	_xmlNewText
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 1363 : 	    if (cur->children != NULL)

	test	eax, eax
	je	SHORT $LN16@xhtmlAttrL

; 1364 : 		cur->children->parent = (xmlNodePtr) cur;

	mov	DWORD PTR [eax+20], esi
$LN16@xhtmlAttrL:

; 1365 : 	}
; 1366 :         xmlAttrDumpOutput(ctxt, cur);

	push	esi
	push	ebx
	call	_xmlAttrDumpOutput

; 1367 : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	$LL2@xhtmlAttrL

; 1368 :     }
; 1369 :     /*
; 1370 :      * C.8
; 1371 :      */
; 1372 :     if ((name != NULL) && (id == NULL)) {

	mov	ebx, DWORD PTR _parent$1$[ebp]
	test	edi, edi
	mov	DWORD PTR _name$1$[ebp], edi
	mov	edi, DWORD PTR _buf$1$[ebp]
	je	$LN18@xhtmlAttrL
	cmp	DWORD PTR _id$1$[ebp], esi
	jne	$LN18@xhtmlAttrL

; 1373 : 	if ((parent != NULL) && (parent->name != NULL) &&

	test	ebx, ebx
	je	$LN18@xhtmlAttrL
	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	$LN18@xhtmlAttrL
	push	OFFSET ??_C@_01MCMALHOG@a@
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN19@xhtmlAttrL
	push	OFFSET ??_C@_01JBBJJEPG@p@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN19@xhtmlAttrL
	push	OFFSET ??_C@_03FEJMGOGI@div@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_03PCCGDNHJ@img@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_03HBNNNHNM@map@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_06MJBNHHFM@applet@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_04MLMMMEIO@form@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_05MIJNFGED@frame@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@xhtmlAttrL
	push	OFFSET ??_C@_06PKBNCBKI@iframe@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xhtmlAttrL
$LN19@xhtmlAttrL:

; 1374 : 	    ((xmlStrEqual(parent->name, BAD_CAST "a")) ||
; 1375 : 	     (xmlStrEqual(parent->name, BAD_CAST "p")) ||
; 1376 : 	     (xmlStrEqual(parent->name, BAD_CAST "div")) ||
; 1377 : 	     (xmlStrEqual(parent->name, BAD_CAST "img")) ||
; 1378 : 	     (xmlStrEqual(parent->name, BAD_CAST "map")) ||
; 1379 : 	     (xmlStrEqual(parent->name, BAD_CAST "applet")) ||
; 1380 : 	     (xmlStrEqual(parent->name, BAD_CAST "form")) ||
; 1381 : 	     (xmlStrEqual(parent->name, BAD_CAST "frame")) ||
; 1382 : 	     (xmlStrEqual(parent->name, BAD_CAST "iframe")))) {
; 1383 : 	    xmlOutputBufferWrite(buf, 5, " id=\"");

	push	OFFSET ??_C@_05OCPGBOOB@?5id?$DN?$CC@
	push	5
	push	edi
	call	_xmlOutputBufferWrite

; 1384 : 	    xmlAttrSerializeContent(buf, name);

	mov	eax, DWORD PTR _name$1$[ebp]
	push	eax
	push	edi
	call	_xmlAttrSerializeContent

; 1385 : 	    xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
$LN18@xhtmlAttrL:

; 1386 : 	}
; 1387 :     }
; 1388 :     /*
; 1389 :      * C.7.
; 1390 :      */
; 1391 :     if ((lang != NULL) && (xml_lang == NULL)) {

	mov	ebx, DWORD PTR _lang$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN20@xhtmlAttrL
	cmp	DWORD PTR _xml_lang$1$[ebp], 0
	jne	SHORT $LN36@xhtmlAttrL

; 1392 : 	xmlOutputBufferWrite(buf, 11, " xml:lang=\"");

	push	OFFSET ??_C@_0M@NGPFCPAA@?5xml?3lang?$DN?$CC@
	push	11					; 0000000bH
	push	edi
	call	_xmlOutputBufferWrite

; 1393 : 	xmlAttrSerializeContent(buf, lang);

	push	ebx

; 1394 : 	xmlOutputBufferWrite(buf, 1, "\"");
; 1395 :     } else

	jmp	SHORT $LN43@xhtmlAttrL
$LN20@xhtmlAttrL:

; 1396 :     if ((xml_lang != NULL) && (lang == NULL)) {

	mov	esi, DWORD PTR _xml_lang$1$[ebp]
	test	esi, esi
	je	SHORT $LN36@xhtmlAttrL

; 1397 : 	xmlOutputBufferWrite(buf, 7, " lang=\"");

	push	OFFSET ??_C@_07OHOHIONL@?5lang?$DN?$CC@
	push	7
	push	edi
	call	_xmlOutputBufferWrite

; 1398 : 	xmlAttrSerializeContent(buf, xml_lang);

	push	esi
$LN43@xhtmlAttrL:
	push	edi
	call	_xmlAttrSerializeContent

; 1399 : 	xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
$LN36@xhtmlAttrL:
	pop	edi
$LN22@xhtmlAttrL:
	pop	esi

; 1400 :     }
; 1401 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xhtmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlIsEmpty
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xhtmlIsEmpty PROC					; COMDAT

; 1266 : xhtmlIsEmpty(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	jne	SHORT $LN4@xhtmlIsEmp

; 1267 :     if (node == NULL)
; 1268 : 	return(-1);

	or	eax, -1
	pop	esi

; 1322 : }

	pop	ebp
	ret	0
$LN4@xhtmlIsEmp:

; 1269 :     if (node->type != XML_ELEMENT_NODE)

	cmp	DWORD PTR [esi+4], 1
	jne	$LN2@xhtmlIsEmp

; 1270 : 	return(0);
; 1271 :     if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN6@xhtmlIsEmp
	push	OFFSET ??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN2@xhtmlIsEmp
$LN6@xhtmlIsEmp:

; 1272 : 	return(0);
; 1273 :     if (node->children != NULL)

	cmp	DWORD PTR [esi+12], 0
	jne	$LN2@xhtmlIsEmp

; 1274 : 	return(0);
; 1275 :     switch (node->name[0]) {

	mov	ecx, DWORD PTR [esi+8]
	movzx	eax, BYTE PTR [ecx]
	add	eax, -97				; ffffff9fH
	cmp	eax, 15					; 0000000fH
	ja	$LN2@xhtmlIsEmp
	jmp	DWORD PTR $LN36@xhtmlIsEmp[eax*4]
$LN8@xhtmlIsEmp:

; 1276 : 	case 'a':
; 1277 : 	    if (xmlStrEqual(node->name, BAD_CAST "area"))

	push	OFFSET ??_C@_04GOEDGNCF@area@
	jmp	$LN33@xhtmlIsEmp
$LN10@xhtmlIsEmp:

; 1278 : 		return(1);
; 1279 : 	    return(0);
; 1280 : 	case 'b':
; 1281 : 	    if (xmlStrEqual(node->name, BAD_CAST "br"))

	push	OFFSET ??_C@_02FGOECCNH@br@
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN31@xhtmlIsEmp

; 1282 : 		return(1);
; 1283 : 	    if (xmlStrEqual(node->name, BAD_CAST "base"))

	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@xhtmlIsEmp

; 1284 : 		return(1);
; 1285 : 	    if (xmlStrEqual(node->name, BAD_CAST "basefont"))

	push	OFFSET ??_C@_08IOLGIJGJ@basefont@
	push	DWORD PTR [esi+8]
	jmp	SHORT $LN34@xhtmlIsEmp
$LN14@xhtmlIsEmp:

; 1286 : 		return(1);
; 1287 : 	    return(0);
; 1288 : 	case 'c':
; 1289 : 	    if (xmlStrEqual(node->name, BAD_CAST "col"))

	push	OFFSET ??_C@_03HNOLNALI@col@
	jmp	SHORT $LN33@xhtmlIsEmp
$LN16@xhtmlIsEmp:

; 1290 : 		return(1);
; 1291 : 	    return(0);
; 1292 : 	case 'f':
; 1293 : 	    if (xmlStrEqual(node->name, BAD_CAST "frame"))

	push	OFFSET ??_C@_05MIJNFGED@frame@
	jmp	SHORT $LN33@xhtmlIsEmp
$LN18@xhtmlIsEmp:

; 1294 : 		return(1);
; 1295 : 	    return(0);
; 1296 : 	case 'h':
; 1297 : 	    if (xmlStrEqual(node->name, BAD_CAST "hr"))

	push	OFFSET ??_C@_02FLHDKHAB@hr@
	jmp	SHORT $LN33@xhtmlIsEmp
$LN20@xhtmlIsEmp:

; 1298 : 		return(1);
; 1299 : 	    return(0);
; 1300 : 	case 'i':
; 1301 : 	    if (xmlStrEqual(node->name, BAD_CAST "img"))

	push	OFFSET ??_C@_03PCCGDNHJ@img@
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@xhtmlIsEmp

; 1302 : 		return(1);
; 1303 : 	    if (xmlStrEqual(node->name, BAD_CAST "input"))

	push	OFFSET ??_C@_05DFJCHPDH@input@
	push	DWORD PTR [esi+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@xhtmlIsEmp

; 1304 : 		return(1);
; 1305 : 	    if (xmlStrEqual(node->name, BAD_CAST "isindex"))

	push	OFFSET ??_C@_07JMLOFMGP@isindex@
	push	DWORD PTR [esi+8]
	jmp	SHORT $LN34@xhtmlIsEmp
$LN24@xhtmlIsEmp:

; 1306 : 		return(1);
; 1307 : 	    return(0);
; 1308 : 	case 'l':
; 1309 : 	    if (xmlStrEqual(node->name, BAD_CAST "link"))

	push	OFFSET ??_C@_04OHHBHOGB@link@
	jmp	SHORT $LN33@xhtmlIsEmp
$LN26@xhtmlIsEmp:

; 1310 : 		return(1);
; 1311 : 	    return(0);
; 1312 : 	case 'm':
; 1313 : 	    if (xmlStrEqual(node->name, BAD_CAST "meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	jmp	SHORT $LN33@xhtmlIsEmp
$LN28@xhtmlIsEmp:

; 1314 : 		return(1);
; 1315 : 	    return(0);
; 1316 : 	case 'p':
; 1317 : 	    if (xmlStrEqual(node->name, BAD_CAST "param"))

	push	OFFSET ??_C@_05LJDNNBIK@param@
$LN33@xhtmlIsEmp:

; 1318 : 		return(1);

	push	ecx
$LN34@xhtmlIsEmp:
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xhtmlIsEmp
$LN31@xhtmlIsEmp:
	mov	eax, 1
	pop	esi

; 1322 : }

	pop	ebp
	ret	0
$LN2@xhtmlIsEmp:

; 1319 : 	    return(0);
; 1320 :     }
; 1321 :     return(0);

	xor	eax, eax
	pop	esi

; 1322 : }

	pop	ebp
	ret	0
	npad	1
$LN36@xhtmlIsEmp:
	DD	$LN8@xhtmlIsEmp
	DD	$LN10@xhtmlIsEmp
	DD	$LN14@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN16@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN18@xhtmlIsEmp
	DD	$LN20@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN24@xhtmlIsEmp
	DD	$LN26@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN2@xhtmlIsEmp
	DD	$LN28@xhtmlIsEmp
_xhtmlIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _htmlNodeDumpOutputInternal
_TEXT	SEGMENT
_oldctxtenc$1$ = -12					; size = 4
_switched_encoding$1$ = -8				; size = 4
_buf$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_htmlNodeDumpOutputInternal PROC			; COMDAT

; 841  : htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _switched_encoding$1$[ebp], ebx
	mov	ecx, DWORD PTR [eax+16]
	mov	edi, ecx
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _oldctxtenc$1$[ebp], ecx
	mov	DWORD PTR _buf$1$[ebp], eax
	call	_xmlInitParser
	mov	esi, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	je	SHORT $LN5@htmlNodeDu

; 842  :     const xmlChar *oldenc = NULL;
; 843  :     const xmlChar *oldctxtenc = ctxt->encoding;
; 844  :     const xmlChar *encoding = ctxt->encoding;
; 845  :     xmlOutputBufferPtr buf = ctxt->buf;
; 846  :     int switched_encoding = 0;
; 847  :     xmlDocPtr doc;
; 848  : 
; 849  :     xmlInitParser();
; 850  : 
; 851  :     doc = cur->doc;
; 852  :     if (doc != NULL) {
; 853  :         oldenc = doc->encoding;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [esi+60]

; 854  : 	if (ctxt->encoding != NULL) {

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN3@htmlNodeDu

; 855  : 	    doc->encoding = BAD_CAST ctxt->encoding;

	mov	DWORD PTR [esi+60], eax
	jmp	SHORT $LN5@htmlNodeDu
$LN3@htmlNodeDu:

; 856  : 	} else if (doc->encoding != NULL) {

	test	ebx, ebx
	cmovne	edi, ebx
$LN5@htmlNodeDu:

; 857  : 	    encoding = doc->encoding;
; 858  : 	}
; 859  :     }
; 860  : 
; 861  :     if ((encoding != NULL) && (doc != NULL))

	test	edi, edi
	je	SHORT $LN16@htmlNodeDu
	test	esi, esi
	je	SHORT $LN8@htmlNodeDu

; 862  : 	htmlSetMetaEncoding(doc, (const xmlChar *) encoding);

	push	edi
	push	esi
	call	_htmlSetMetaEncoding
	add	esp, 8

; 863  :     if ((encoding == NULL) && (doc != NULL))

	jmp	SHORT $LN8@htmlNodeDu
$LN16@htmlNodeDu:
	test	esi, esi
	je	SHORT $LN17@htmlNodeDu

; 864  : 	encoding = htmlGetMetaEncoding(doc);

	push	esi
	call	_htmlGetMetaEncoding
	mov	edi, eax
	add	esp, 4

; 865  :     if (encoding == NULL)

	test	edi, edi
	jne	SHORT $LN8@htmlNodeDu
$LN17@htmlNodeDu:

; 866  : 	encoding = BAD_CAST "HTML";

	mov	edi, OFFSET ??_C@_04DBLPJNAF@HTML@
$LN8@htmlNodeDu:

; 867  :     if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 868  : 	(buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN9@htmlNodeDu
	mov	eax, DWORD PTR _buf$1$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@htmlNodeDu
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN9@htmlNodeDu

; 869  : 	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	push	edi
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN10@htmlNodeDu

; 870  : 	    doc->encoding = oldenc;

	pop	edi
	mov	DWORD PTR [esi+60], ebx

; 871  : 	    return(-1);

	or	eax, -1

; 889  :     return(0);
; 890  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@htmlNodeDu:

; 872  : 	}
; 873  : 	switched_encoding = 1;

	mov	DWORD PTR _switched_encoding$1$[ebp], 1
$LN9@htmlNodeDu:

; 874  :     }
; 875  :     if (ctxt->options & XML_SAVE_FORMAT)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+32]
	and	eax, 1

; 876  : 	htmlNodeDumpFormatOutput(buf, doc, cur,
; 877  : 				       (const char *)encoding, 1);
; 878  :     else
; 879  : 	htmlNodeDumpFormatOutput(buf, doc, cur,
; 880  : 				       (const char *)encoding, 0);
; 881  :     /*
; 882  :      * Restore the state of the saving context at the end of the document
; 883  :      */
; 884  :     if ((switched_encoding) && (oldctxtenc == NULL)) {

	push	eax
	push	edi
	push	DWORD PTR _cur$[ebp]
	push	esi
	push	DWORD PTR _buf$1$[ebp]
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _switched_encoding$1$[ebp], 0
	je	SHORT $LN13@htmlNodeDu
	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN13@htmlNodeDu

; 885  : 	xmlSaveClearEncoding(ctxt);

	push	DWORD PTR _ctxt$[ebp]
	call	_xmlSaveClearEncoding
	add	esp, 4
$LN13@htmlNodeDu:

; 886  :     }
; 887  :     if (doc != NULL)

	test	esi, esi
	je	SHORT $LN14@htmlNodeDu

; 888  : 	doc->encoding = oldenc;

	mov	DWORD PTR [esi+60], ebx
$LN14@htmlNodeDu:
	pop	edi

; 889  :     return(0);
; 890  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_htmlNodeDumpOutputInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrListDumpOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAttrListDumpOutput PROC				; COMDAT

; 794  : xmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN3@xmlAttrLis
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	esi
$LN18@xmlAttrLis:

; 768  :     buf = ctxt->buf;

	mov	esi, DWORD PTR [ebx+24]

; 769  :     if (buf == NULL) return;

	test	esi, esi
	je	SHORT $LN6@xmlAttrLis

; 770  :     if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN9@xmlAttrLis

; 771  :         xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN10@xmlAttrLis
$LN9@xmlAttrLis:

; 772  :     else
; 773  :         xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN10@xmlAttrLis:

; 774  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN11@xmlAttrLis
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN11@xmlAttrLis

; 775  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	esi
	call	_xmlOutputBufferWriteString

; 776  : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN11@xmlAttrLis:

; 777  :     }
; 778  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlOutputBufferWriteString

; 779  :     xmlOutputBufferWrite(buf, 2, "=\"");

	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC@
	push	2
	push	esi
	call	_xmlOutputBufferWrite

; 780  :     xmlAttrSerializeContent(buf, cur);

	push	edi
	push	esi
	call	_xmlAttrSerializeContent

; 781  :     xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 40					; 00000028H
$LN6@xmlAttrLis:

; 795  :     if (cur == NULL) return;
; 796  :     while (cur != NULL) {
; 797  :         xmlAttrDumpOutput(ctxt, cur);
; 798  : 	cur = cur->next;

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	$LN18@xmlAttrLis
	pop	esi
	pop	ebx
$LN3@xmlAttrLis:
	pop	edi

; 799  :     }
; 800  : }

	pop	ebp
	ret	0
_xmlAttrListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrDumpOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlAttrDumpOutput PROC					; COMDAT

; 764  : xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN1@xmlAttrDum

; 765  :     xmlOutputBufferPtr buf;
; 766  : 
; 767  :     if (cur == NULL) return;
; 768  :     buf = ctxt->buf;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	mov	esi, DWORD PTR [eax+24]

; 769  :     if (buf == NULL) return;

	test	esi, esi
	je	SHORT $LN8@xmlAttrDum

; 770  :     if (ctxt->format == 2)

	cmp	DWORD PTR [eax+40], 2
	jne	SHORT $LN4@xmlAttrDum

; 771  :         xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	push	eax
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN5@xmlAttrDum
$LN4@xmlAttrDum:

; 772  :     else
; 773  :         xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xmlAttrDum:

; 774  :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	je	SHORT $LN6@xmlAttrDum
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN6@xmlAttrDum

; 775  :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	esi
	call	_xmlOutputBufferWriteString

; 776  : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN6@xmlAttrDum:

; 777  :     }
; 778  :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [edi+8]
	push	esi
	call	_xmlOutputBufferWriteString

; 779  :     xmlOutputBufferWrite(buf, 2, "=\"");

	push	OFFSET ??_C@_02ILLPBGAO@?$DN?$CC@
	push	2
	push	esi
	call	_xmlOutputBufferWrite

; 780  :     xmlAttrSerializeContent(buf, cur);

	push	edi
	push	esi
	call	_xmlAttrSerializeContent

; 781  :     xmlOutputBufferWrite(buf, 1, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 40					; 00000028H
$LN8@xmlAttrDum:
	pop	esi
$LN1@xmlAttrDum:
	pop	edi

; 782  : }

	pop	ebp
	ret	0
_xmlAttrDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDtdDumpOutput
_TEXT	SEGMENT
_buf$1$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlDtdDumpOutput PROC					; COMDAT

; 707  : xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _dtd$[ebp]
	test	ebx, ebx
	je	$LN4@xmlDtdDump

; 708  :     xmlOutputBufferPtr buf;
; 709  :     int format, level;
; 710  :     xmlDocPtr doc;
; 711  : 
; 712  :     if (dtd == NULL) return;
; 713  :     if ((ctxt == NULL) || (ctxt->buf == NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	$LN4@xmlDtdDump
	push	esi
	mov	esi, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$1$[ebp], esi
	test	esi, esi
	je	$LN15@xmlDtdDump

; 714  :         return;
; 715  :     buf = ctxt->buf;
; 716  :     xmlOutputBufferWrite(buf, 10, "<!DOCTYPE ");

	push	OFFSET ??_C@_0L@JKHDJBPI@?$DM?$CBDOCTYPE?5@
	push	10					; 0000000aH
	push	esi
	call	_xmlOutputBufferWrite

; 717  :     xmlOutputBufferWriteString(buf, (const char *)dtd->name);

	push	DWORD PTR [ebx+8]
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H

; 718  :     if (dtd->ExternalID != NULL) {

	cmp	DWORD PTR [ebx+52], 0
	je	SHORT $LN5@xmlDtdDump

; 719  : 	xmlOutputBufferWrite(buf, 8, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	push	8
	push	esi
	call	_xmlOutputBufferWrite

; 720  : 	xmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);

	push	DWORD PTR [ebx+52]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString

; 721  : 	xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	esi
	call	_xmlOutputBufferWrite

; 722  : 	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);

	push	DWORD PTR [ebx+56]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 40					; 00000028H
	jmp	SHORT $LN7@xmlDtdDump
$LN5@xmlDtdDump:

; 723  :     }  else if (dtd->SystemID != NULL) {

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN7@xmlDtdDump

; 724  : 	xmlOutputBufferWrite(buf, 8, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	push	8
	push	esi
	call	_xmlOutputBufferWrite

; 725  : 	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);

	push	DWORD PTR [ebx+56]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 20					; 00000014H
$LN7@xmlDtdDump:

; 726  :     }
; 727  :     if ((dtd->entities == NULL) && (dtd->elements == NULL) &&
; 728  :         (dtd->attributes == NULL) && (dtd->notations == NULL) &&

	cmp	DWORD PTR [ebx+48], 0
	jne	SHORT $LN8@xmlDtdDump
	cmp	DWORD PTR [ebx+40], 0
	jne	SHORT $LN8@xmlDtdDump
	cmp	DWORD PTR [ebx+44], 0
	jne	SHORT $LN8@xmlDtdDump
	cmp	DWORD PTR [ebx+36], 0
	jne	SHORT $LN8@xmlDtdDump
	cmp	DWORD PTR [ebx+60], 0
	jne	SHORT $LN8@xmlDtdDump

; 729  : 	(dtd->pentities == NULL)) {
; 730  : 	xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx

; 754  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlDtdDump:
	push	edi

; 731  : 	return;
; 732  :     }
; 733  :     xmlOutputBufferWrite(buf, 3, " [\n");

	push	OFFSET ??_C@_03OEIPKGAG@?5?$FL?6@
	push	3
	push	esi
	call	_xmlOutputBufferWrite

; 734  :     /*
; 735  :      * Dump the notations first they are not in the DTD children list
; 736  :      * Do this only on a standalone DTD or on the internal subset though.
; 737  :      */
; 738  :     if ((dtd->notations != NULL) && ((dtd->doc == NULL) ||

	mov	edi, DWORD PTR [ebx+36]
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN12@xmlDtdDump
	mov	eax, DWORD PTR [ebx+32]
	test	eax, eax
	je	SHORT $LN10@xmlDtdDump
	cmp	DWORD PTR [eax+44], ebx
	jne	SHORT $LN12@xmlDtdDump
$LN10@xmlDtdDump:

; 739  :         (dtd->doc->intSubset == dtd))) {
; 740  :         xmlBufDumpNotationTable(buf->buffer,

	mov	ebx, DWORD PTR [esi+16]

; 471  :     buffer = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	esi, eax

; 472  :     if (buffer == NULL) {

	test	esi, esi
	je	SHORT $LN12@xmlDtdDump

; 473  :         /*
; 474  :          * TODO set the error in buf
; 475  :          */
; 476  :         return;
; 477  :     }
; 478  :     xmlDumpNotationTable(buffer, table);

	push	edi
	push	esi
	call	_xmlDumpNotationTable

; 479  :     xmlBufMergeBuffer(buf, buffer);

	push	esi
	push	ebx
	call	_xmlBufMergeBuffer
	add	esp, 16					; 00000010H
$LN12@xmlDtdDump:

; 741  :                                 (xmlNotationTablePtr) dtd->notations);
; 742  :     }
; 743  :     format = ctxt->format;

	mov	edx, DWORD PTR _ctxt$[ebp]

; 744  :     level = ctxt->level;
; 745  :     doc = ctxt->doc;
; 746  :     ctxt->format = 0;
; 747  :     ctxt->level = -1;
; 748  :     ctxt->doc = dtd->doc;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	ebx, DWORD PTR [edx+40]
	mov	edi, DWORD PTR [edx+36]
	mov	esi, DWORD PTR [edx+28]
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+36], -1
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+28], eax

; 749  :     xmlNodeListDumpOutput(ctxt, dtd->children);

	push	DWORD PTR [ecx+12]
	push	edx
	call	_xmlNodeListDumpOutput

; 750  :     ctxt->format = format;

	mov	eax, DWORD PTR _ctxt$[ebp]

; 751  :     ctxt->level = level;
; 752  :     ctxt->doc = doc;
; 753  :     xmlOutputBufferWrite(buf, 2, "]>");

	push	OFFSET ??_C@_02CFBPIAHD@?$FN?$DO@
	push	2
	push	DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR [eax+40], ebx
	mov	DWORD PTR [eax+36], edi
	mov	DWORD PTR [eax+28], esi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
	pop	edi
$LN15@xmlDtdDump:
	pop	esi
$LN4@xmlDtdDump:
	pop	ebx

; 754  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDtdDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsListDumpOutputCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsListDumpOutputCtxt PROC				; COMDAT

; 676  : xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlNsListD
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi
	npad	2
$LL2@xmlNsListD:

; 677  :     while (cur != NULL) {
; 678  :         xmlNsDumpOutput(ctxt->buf, cur, ctxt);

	mov	edi, DWORD PTR [ebx+24]

; 633  :     if ((cur == NULL) || (buf == NULL)) return;

	test	esi, esi
	je	$LN7@xmlNsListD
	test	edi, edi
	je	$LN7@xmlNsListD

; 634  :     if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	jne	$LN7@xmlNsListD
	cmp	DWORD PTR [esi+8], 0
	je	$LN7@xmlNsListD

; 635  : 	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlNsListD

; 636  : 	    return;
; 637  : 
; 638  : 	if (ctxt != NULL && ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN10@xmlNsListD

; 639  : 	    xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN11@xmlNsListD
$LN10@xmlNsListD:

; 640  : 	else
; 641  : 	    xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN11@xmlNsListD:

; 642  : 
; 643  :         /* Within the context of an element attributes */
; 644  : 	if (cur->prefix != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN12@xmlNsListD

; 645  : 	    xmlOutputBufferWrite(buf, 6, "xmlns:");

	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3@
	push	6
	push	edi
	call	_xmlOutputBufferWrite

; 646  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->prefix);

	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H

; 647  : 	} else

	jmp	SHORT $LN13@xmlNsListD
$LN12@xmlNsListD:

; 648  : 	    xmlOutputBufferWrite(buf, 5, "xmlns");

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	5
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN13@xmlNsListD:

; 649  : 	xmlOutputBufferWrite(buf, 1, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 650  : 	xmlBufWriteQuotedString(buf->buffer, cur->href);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 20					; 00000014H
$LN7@xmlNsListD:

; 679  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LL2@xmlNsListD
	pop	edi
	pop	ebx
$LN3@xmlNsListD:
	pop	esi

; 680  :     }
; 681  : }

	pop	ebp
	ret	0
_xmlNsListDumpOutputCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsDumpOutputCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsDumpOutputCtxt PROC				; COMDAT

; 663  : xmlNsDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR [eax+24]
	call	_xmlNsDumpOutput
	add	esp, 12					; 0000000cH

; 664  :     xmlNsDumpOutput(ctxt->buf, cur, ctxt);
; 665  : }

	pop	ebp
	ret	0
_xmlNsDumpOutputCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_ctxt$ = 16						; size = 4
_xmlNsDumpOutput PROC					; COMDAT

; 632  : xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur, xmlSaveCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN3@xmlNsDumpO

; 633  :     if ((cur == NULL) || (buf == NULL)) return;

	push	esi
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN11@xmlNsDumpO

; 634  :     if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {

	cmp	DWORD PTR [edi+4], 18			; 00000012H
	jne	$LN11@xmlNsDumpO
	cmp	DWORD PTR [edi+8], 0
	je	$LN11@xmlNsDumpO

; 635  : 	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [edi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlNsDumpO

; 636  : 	    return;
; 637  : 
; 638  : 	if (ctxt != NULL && ctxt->format == 2)

	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN6@xmlNsDumpO
	cmp	DWORD PTR [eax+40], 2
	jne	SHORT $LN6@xmlNsDumpO

; 639  : 	    xmlOutputBufferWriteWSNonSig(ctxt, 2);

	push	2
	push	eax
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
	jmp	SHORT $LN7@xmlNsDumpO
$LN6@xmlNsDumpO:

; 640  : 	else
; 641  : 	    xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN7@xmlNsDumpO:

; 642  : 
; 643  :         /* Within the context of an element attributes */
; 644  : 	if (cur->prefix != NULL) {

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN8@xmlNsDumpO

; 645  : 	    xmlOutputBufferWrite(buf, 6, "xmlns:");

	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3@
	push	6
	push	esi
	call	_xmlOutputBufferWrite

; 646  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->prefix);

	push	DWORD PTR [edi+12]
	push	esi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H

; 647  : 	} else

	jmp	SHORT $LN9@xmlNsDumpO
$LN8@xmlNsDumpO:

; 648  : 	    xmlOutputBufferWrite(buf, 5, "xmlns");

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	5
	push	esi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN9@xmlNsDumpO:

; 649  : 	xmlOutputBufferWrite(buf, 1, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	1
	push	esi
	call	_xmlOutputBufferWrite

; 650  : 	xmlBufWriteQuotedString(buf->buffer, cur->href);

	push	DWORD PTR [edi+8]
	push	DWORD PTR [esi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 20					; 00000014H
$LN11@xmlNsDumpO:
	pop	esi
$LN3@xmlNsDumpO:
	pop	edi

; 651  :     }
; 652  : }

	pop	ebp
	ret	0
_xmlNsDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlOutputBufferWriteWSNonSig
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlOutputBufferWriteWSNonSig PROC			; COMDAT

; 608  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN6@xmlOutputB

; 609  :     int i;
; 610  :     if ((ctxt == NULL) || (ctxt->buf == NULL))

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@xmlOutputB

; 611  :         return;
; 612  :     xmlOutputBufferWrite(ctxt->buf, 1, "\n");

	push	ebx
	push	edi
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	eax
	call	_xmlOutputBufferWrite

; 613  :     for (i = 0; i < (ctxt->level + extra); i += ctxt->indent_nr) {

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _extra$[ebp]
	xor	edi, edi
	lea	eax, DWORD PTR [ecx+ebx]
	test	eax, eax
	jle	SHORT $LN14@xmlOutputB
	mov	edx, DWORD PTR [esi+108]
	lea	eax, DWORD PTR [esi+44]
$LL4@xmlOutputB:

; 614  :         xmlOutputBufferWrite(ctxt->buf, ctxt->indent_size *

	sub	ecx, edi
	add	ecx, ebx
	cmp	ecx, edx
	push	eax
	cmovle	edx, ecx
	imul	edx, DWORD PTR [esi+112]
	push	edx
	push	DWORD PTR [esi+24]
	call	_xmlOutputBufferWrite
	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [esi+108]
	add	edi, edx
	lea	eax, DWORD PTR [ecx+ebx]
	cmp	edi, eax
	lea	eax, DWORD PTR [esi+44]
	jl	SHORT $LL4@xmlOutputB
$LN14@xmlOutputB:
	pop	edi
	pop	ebx
$LN6@xmlOutputB:
	pop	esi

; 615  :                 ((ctxt->level + extra - i) > ctxt->indent_nr ?
; 616  :                  ctxt->indent_nr : (ctxt->level + extra - i)),
; 617  :                 ctxt->indent);
; 618  :     }
; 619  : }

	pop	ebp
	ret	0
_xmlOutputBufferWriteWSNonSig ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocContentDumpOutput
_TEXT	SEGMENT
_oldescapeAttr$1$ = -20					; size = 4
_oldescape$1$ = -16					; size = 4
_switched_encoding$1$ = -12				; size = 4
_oldenc$1$ = -8						; size = 4
_oldctxtenc$1$ = -4					; size = 4
_is_xhtml$2$ = 8					; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlDocContentDumpOutput PROC				; COMDAT

; 1102 : xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _switched_encoding$1$[ebp], 0
	mov	ebx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+60]
	mov	DWORD PTR _oldenc$1$[ebp], eax
	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	mov	DWORD PTR _oldctxtenc$1$[ebp], eax
	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR _oldescape$1$[ebp], eax
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR _oldescapeAttr$1$[ebp], eax
	call	_xmlInitParser
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN6@xmlDocCont

; 1103 : #ifdef LIBXML_HTML_ENABLED
; 1104 :     xmlDtdPtr dtd;
; 1105 :     int is_xhtml = 0;
; 1106 : #endif
; 1107 :     const xmlChar *oldenc = cur->encoding;
; 1108 :     const xmlChar *oldctxtenc = ctxt->encoding;
; 1109 :     const xmlChar *encoding = ctxt->encoding;
; 1110 :     xmlCharEncodingOutputFunc oldescape = ctxt->escape;
; 1111 :     xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;
; 1112 :     xmlOutputBufferPtr buf = ctxt->buf;
; 1113 :     xmlCharEncoding enc;
; 1114 :     int switched_encoding = 0;
; 1115 : 
; 1116 :     xmlInitParser();
; 1117 : 
; 1118 :     if ((cur->type != XML_HTML_DOCUMENT_NODE) &&

	cmp	ecx, 9
	jne	$LN56@xmlDocCont
$LN6@xmlDocCont:

; 1119 :         (cur->type != XML_DOCUMENT_NODE))
; 1120 : 	 return(-1);
; 1121 : 
; 1122 :     if (ctxt->encoding != NULL) {

	mov	edx, DWORD PTR [esi+16]
	test	edx, edx
	je	SHORT $LN7@xmlDocCont

; 1123 :         cur->encoding = BAD_CAST ctxt->encoding;

	mov	DWORD PTR [eax+60], edx
	jmp	SHORT $LN9@xmlDocCont
$LN7@xmlDocCont:

; 1124 :     } else if (cur->encoding != NULL) {

	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	cmovne	edi, eax
	mov	eax, DWORD PTR _cur$[ebp]
$LN9@xmlDocCont:

; 1125 : 	encoding = cur->encoding;
; 1126 :     }
; 1127 : 
; 1128 :     if (((cur->type == XML_HTML_DOCUMENT_NODE) &&
; 1129 :          ((ctxt->options & XML_SAVE_AS_XML) == 0) &&
; 1130 :          ((ctxt->options & XML_SAVE_XHTML) == 0)) ||

	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN51@xmlDocCont
	test	BYTE PTR [esi+32], 48			; 00000030H
	je	SHORT $LN12@xmlDocCont
$LN51@xmlDocCont:
	mov	edx, DWORD PTR [esi+32]
	test	dl, 64					; 00000040H
	je	SHORT $LN10@xmlDocCont
$LN12@xmlDocCont:

; 1131 :         (ctxt->options & XML_SAVE_AS_HTML)) {
; 1132 : #ifdef LIBXML_HTML_ENABLED
; 1133 :         if (encoding != NULL)

	test	edi, edi
	je	SHORT $LN49@xmlDocCont

; 1134 : 	    htmlSetMetaEncoding(cur, (const xmlChar *) encoding);

	push	edi
	push	eax
	call	_htmlSetMetaEncoding
	add	esp, 8

; 1135 :         if (encoding == NULL)

	jmp	SHORT $LN16@xmlDocCont
$LN49@xmlDocCont:

; 1136 : 	    encoding = htmlGetMetaEncoding(cur);

	push	eax
	call	_htmlGetMetaEncoding
	add	esp, 4

; 1137 :         if (encoding == NULL)

	mov	edi, OFFSET ??_C@_04DBLPJNAF@HTML@
	test	eax, eax
	cmovne	edi, eax
$LN16@xmlDocCont:

; 1138 : 	    encoding = BAD_CAST "HTML";
; 1139 : 	if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 1140 : 	    (buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN18@xmlDocCont
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN18@xmlDocCont
	cmp	DWORD PTR [ebx+20], 0
	jne	SHORT $LN18@xmlDocCont

; 1141 : 	    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	push	edi
	push	esi
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	js	SHORT $LN52@xmlDocCont
$LN18@xmlDocCont:

; 1142 : 		cur->encoding = oldenc;
; 1143 : 		return(-1);
; 1144 : 	    }
; 1145 : 	}
; 1146 :         if (ctxt->options & XML_SAVE_FORMAT)

	mov	eax, DWORD PTR [esi+32]
	and	eax, 1

; 1147 : 	    htmlDocContentDumpFormatOutput(buf, cur,
; 1148 : 	                                   (const char *)encoding, 1);
; 1149 : 	else
; 1150 : 	    htmlDocContentDumpFormatOutput(buf, cur,
; 1151 : 	                                   (const char *)encoding, 0);
; 1152 : 	if (ctxt->encoding != NULL)

	push	eax
	push	edi
	mov	edi, DWORD PTR _cur$[ebp]
	push	edi
	push	ebx
	call	_htmlDocContentDumpFormatOutput
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+16], 0
	je	$LN21@xmlDocCont

; 1153 : 	    cur->encoding = oldenc;

	mov	ecx, DWORD PTR _oldenc$1$[ebp]

; 1247 :     return(0);
; 1248 : }

	xor	eax, eax
	mov	DWORD PTR [edi+60], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlDocCont:

; 1154 : 	return(0);
; 1155 : #else
; 1156 :         return(-1);
; 1157 : #endif
; 1158 :     } else if ((cur->type == XML_DOCUMENT_NODE) ||
; 1159 :                (ctxt->options & XML_SAVE_AS_XML) ||

	cmp	ecx, 9
	je	SHORT $LN23@xmlDocCont
	test	dl, 48					; 00000030H
	je	$LN42@xmlDocCont
$LN23@xmlDocCont:

; 1160 :                (ctxt->options & XML_SAVE_XHTML)) {
; 1161 : 	enc = xmlParseCharEncoding((const char*) encoding);

	push	edi
	call	_xmlParseCharEncoding
	add	esp, 4

; 1162 : 	if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 1163 : 	    (buf->encoder == NULL) && (buf->conv == NULL) &&

	test	edi, edi
	je	SHORT $LN28@xmlDocCont
	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN28@xmlDocCont
	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN28@xmlDocCont
	cmp	DWORD PTR [ebx+20], 0
	jne	SHORT $LN28@xmlDocCont
	test	BYTE PTR [esi+32], 2
	jne	SHORT $LN28@xmlDocCont

; 1164 : 	    ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {
; 1165 : 	    if ((enc != XML_CHAR_ENCODING_UTF8) &&
; 1166 : 		(enc != XML_CHAR_ENCODING_NONE) &&

	cmp	eax, 1
	je	SHORT $LN25@xmlDocCont
	test	eax, eax
	je	SHORT $LN25@xmlDocCont
	cmp	eax, 22					; 00000016H
	je	SHORT $LN25@xmlDocCont

; 1167 : 		(enc != XML_CHAR_ENCODING_ASCII)) {
; 1168 : 		/*
; 1169 : 		 * we need to switch to this encoding but just for this
; 1170 : 		 * document since we output the XMLDecl the conversion
; 1171 : 		 * must be done to not generate not well formed documents.
; 1172 : 		 */
; 1173 : 		if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	push	edi
	push	esi
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN26@xmlDocCont
$LN52@xmlDocCont:

; 1174 : 		    cur->encoding = oldenc;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _oldenc$1$[ebp]
	mov	DWORD PTR [eax+60], ecx
$LN56@xmlDocCont:

; 1247 :     return(0);
; 1248 : }

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlDocCont:

; 1175 : 		    return(-1);
; 1176 : 		}
; 1177 : 		switched_encoding = 1;

	mov	DWORD PTR _switched_encoding$1$[ebp], 1
$LN25@xmlDocCont:

; 1178 : 	    }
; 1179 : 	    if (ctxt->escape == xmlEscapeEntities)

	cmp	DWORD PTR [esi+116], OFFSET _xmlEscapeEntities
	jne	SHORT $LN27@xmlDocCont

; 1180 : 		ctxt->escape = NULL;

	mov	DWORD PTR [esi+116], 0
$LN27@xmlDocCont:

; 1181 : 	    if (ctxt->escapeAttr == xmlEscapeEntities)

	cmp	DWORD PTR [esi+120], OFFSET _xmlEscapeEntities
	jne	SHORT $LN28@xmlDocCont

; 1182 : 		ctxt->escapeAttr = NULL;

	mov	DWORD PTR [esi+120], 0
$LN28@xmlDocCont:

; 1183 : 	}
; 1184 : 
; 1185 : 
; 1186 : 	/*
; 1187 : 	 * Save the XML declaration
; 1188 : 	 */
; 1189 : 	if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {

	mov	ecx, DWORD PTR [esi+32]
	test	cl, 2
	jne	$LN53@xmlDocCont

; 1190 : 	    xmlOutputBufferWrite(buf, 14, "<?xml version=");

	push	OFFSET ??_C@_0P@CNJADHFP@?$DM?$DPxml?5version?$DN@
	push	14					; 0000000eH
	push	ebx
	call	_xmlOutputBufferWrite

; 1191 : 	    if (cur->version != NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	je	SHORT $LN30@xmlDocCont

; 1192 : 		xmlBufWriteQuotedString(buf->buffer, cur->version);

	push	eax
	push	DWORD PTR [ebx+16]
	call	_xmlBufWriteQuotedString
	add	esp, 8
	jmp	SHORT $LN31@xmlDocCont
$LN30@xmlDocCont:

; 1193 : 	    else
; 1194 : 		xmlOutputBufferWrite(buf, 5, "\"1.0\"");

	push	OFFSET ??_C@_05FLCMBAOK@?$CC1?40?$CC@
	push	5
	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN31@xmlDocCont:

; 1195 : 	    if (encoding != NULL) {

	test	edi, edi
	je	SHORT $LN32@xmlDocCont

; 1196 : 		xmlOutputBufferWrite(buf, 10, " encoding=");

	push	OFFSET ??_C@_0L@GJNPICMJ@?5encoding?$DN@
	push	10					; 0000000aH
	push	ebx
	call	_xmlOutputBufferWrite

; 1197 : 		xmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);

	push	edi
	push	DWORD PTR [ebx+16]
	call	_xmlBufWriteQuotedString
	add	esp, 20					; 00000014H
$LN32@xmlDocCont:

; 1198 : 	    }
; 1199 : 	    switch (cur->standalone) {

	mov	edi, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edi+40]
	sub	eax, 0
	je	SHORT $LN33@xmlDocCont
	sub	eax, 1
	jne	SHORT $LN2@xmlDocCont

; 1202 : 		    break;
; 1203 : 		case 1:
; 1204 : 		    xmlOutputBufferWrite(buf, 17, " standalone=\"yes\"");

	push	OFFSET ??_C@_0BC@MEICOMAE@?5standalone?$DN?$CCyes?$CC@
	push	17					; 00000011H
	jmp	SHORT $LN54@xmlDocCont
$LN33@xmlDocCont:

; 1200 : 		case 0:
; 1201 : 		    xmlOutputBufferWrite(buf, 16, " standalone=\"no\"");

	push	OFFSET ??_C@_0BB@FFDPHLPI@?5standalone?$DN?$CCno?$CC@
	push	16					; 00000010H
$LN54@xmlDocCont:

; 1205 : 		    break;
; 1206 : 	    }
; 1207 : 	    xmlOutputBufferWrite(buf, 3, "?>\n");

	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN2@xmlDocCont:
	push	OFFSET ??_C@_03KCOJOIAE@?$DP?$DO?6@
	push	3
	push	ebx
	call	_xmlOutputBufferWrite
	mov	ecx, DWORD PTR [esi+32]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN29@xmlDocCont
$LN53@xmlDocCont:

; 1183 : 	}
; 1184 : 
; 1185 : 
; 1186 : 	/*
; 1187 : 	 * Save the XML declaration
; 1188 : 	 */
; 1189 : 	if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {

	mov	edi, DWORD PTR _cur$[ebp]
$LN29@xmlDocCont:

; 1208 : 	}
; 1209 : 
; 1210 : #ifdef LIBXML_HTML_ENABLED
; 1211 :         if (ctxt->options & XML_SAVE_XHTML)

	mov	eax, ecx
	shr	eax, 4
	and	eax, 1
	mov	DWORD PTR _is_xhtml$2$[ebp], eax

; 1212 :             is_xhtml = 1;
; 1213 : 	if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {

	test	cl, 8
	jne	SHORT $LN38@xmlDocCont

; 1214 : 	    dtd = xmlGetIntSubset(cur);

	push	edi
	call	_xmlGetIntSubset
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR _is_xhtml$2$[ebp]
	mov	DWORD PTR _is_xhtml$2$[ebp], eax

; 1215 : 	    if (dtd != NULL) {

	test	ecx, ecx
	je	SHORT $LN38@xmlDocCont

; 1216 : 		is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);

	push	DWORD PTR [ecx+52]
	push	DWORD PTR [ecx+56]
	call	_xmlIsXHTML

; 1217 : 		if (is_xhtml < 0) is_xhtml = 0;

	xor	ecx, ecx
	add	esp, 8
	test	eax, eax
	cmovs	eax, ecx
	mov	DWORD PTR _is_xhtml$2$[ebp], eax
$LN38@xmlDocCont:

; 1218 : 	    }
; 1219 : 	}
; 1220 : #endif
; 1221 : 	if (cur->children != NULL) {

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	je	SHORT $LN5@xmlDocCont
$LL4@xmlDocCont:

; 1222 : 	    xmlNodePtr child = cur->children;
; 1223 : 
; 1224 : 	    while (child != NULL) {
; 1225 : 		ctxt->level = 0;

	mov	DWORD PTR [esi+36], 0

; 1226 : #ifdef LIBXML_HTML_ENABLED
; 1227 : 		if (is_xhtml)

	push	edi
	push	esi
	test	eax, eax
	je	SHORT $LN40@xmlDocCont

; 1228 : 		    xhtmlNodeDumpOutput(ctxt, child);

	call	_xhtmlNodeDumpOutput
	jmp	SHORT $LN55@xmlDocCont
$LN40@xmlDocCont:

; 1229 : 		else
; 1230 : #endif
; 1231 : 		    xmlNodeDumpOutputInternal(ctxt, child);

	call	_xmlNodeDumpOutputInternal
$LN55@xmlDocCont:

; 1232 : 		xmlOutputBufferWrite(buf, 1, "\n");

	add	esp, 8
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	ebx
	call	_xmlOutputBufferWrite

; 1233 : 		child = child->next;

	mov	edi, DWORD PTR [edi+24]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _is_xhtml$2$[ebp]
	test	edi, edi
	jne	SHORT $LL4@xmlDocCont
$LN5@xmlDocCont:

; 1234 : 	    }
; 1235 : 	}
; 1236 :     }
; 1237 : 
; 1238 :     /*
; 1239 :      * Restore the state of the saving context at the end of the document
; 1240 :      */
; 1241 :     if ((switched_encoding) && (oldctxtenc == NULL)) {

	cmp	DWORD PTR _switched_encoding$1$[ebp], 0
	je	SHORT $LN42@xmlDocCont
	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN42@xmlDocCont

; 1242 : 	xmlSaveClearEncoding(ctxt);

	push	esi
	call	_xmlSaveClearEncoding

; 1243 : 	ctxt->escape = oldescape;

	mov	eax, DWORD PTR _oldescape$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+116], eax

; 1244 : 	ctxt->escapeAttr = oldescapeAttr;

	mov	eax, DWORD PTR _oldescapeAttr$1$[ebp]
	mov	DWORD PTR [esi+120], eax
$LN42@xmlDocCont:

; 1245 :     }
; 1246 :     cur->encoding = oldenc;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _oldenc$1$[ebp]
	mov	DWORD PTR [eax+60], ecx
$LN21@xmlDocCont:

; 1247 :     return(0);
; 1248 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDocContentDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNsListDumpOutput
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNsListDumpOutput PROC				; COMDAT

; 692  : xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN3@xmlNsListD
	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
$LN20@xmlNsListD:

; 633  :     if ((cur == NULL) || (buf == NULL)) return;

	test	edi, edi
	je	SHORT $LN7@xmlNsListD

; 634  :     if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {

	cmp	DWORD PTR [esi+4], 18			; 00000012H
	jne	SHORT $LN7@xmlNsListD
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN7@xmlNsListD

; 635  : 	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))

	push	OFFSET ??_C@_03PJHHNEEI@xml@
	push	DWORD PTR [esi+12]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlNsListD

; 636  : 	    return;
; 637  : 
; 638  : 	if (ctxt != NULL && ctxt->format == 2)
; 639  : 	    xmlOutputBufferWriteWSNonSig(ctxt, 2);
; 640  : 	else
; 641  : 	    xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 642  : 
; 643  :         /* Within the context of an element attributes */
; 644  : 	if (cur->prefix != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN12@xmlNsListD

; 645  : 	    xmlOutputBufferWrite(buf, 6, "xmlns:");

	push	OFFSET ??_C@_06PNFLLAEF@xmlns?3@
	push	6
	push	edi
	call	_xmlOutputBufferWrite

; 646  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->prefix);

	push	DWORD PTR [esi+12]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H

; 647  : 	} else

	jmp	SHORT $LN13@xmlNsListD
$LN12@xmlNsListD:

; 648  : 	    xmlOutputBufferWrite(buf, 5, "xmlns");

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	push	5
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN13@xmlNsListD:

; 649  : 	xmlOutputBufferWrite(buf, 1, "=");

	push	OFFSET ??_C@_01NEMOKFLO@?$DN@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 650  : 	xmlBufWriteQuotedString(buf->buffer, cur->href);

	push	DWORD PTR [esi+8]
	push	DWORD PTR [edi+16]
	call	_xmlBufWriteQuotedString
	add	esp, 20					; 00000014H
$LN7@xmlNsListD:

; 693  :     while (cur != NULL) {
; 694  :         xmlNsDumpOutput(buf, cur, NULL);
; 695  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	jne	$LN20@xmlNsListD
	pop	edi
$LN3@xmlNsListD:
	pop	esi

; 696  :     }
; 697  : }

	pop	ebp
	ret	0
_xmlNsListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDumpOutputInternal
_TEXT	SEGMENT
_oldenc$1$ = -16					; size = 4
_format$1$ = -16					; size = 4
_doc$1$ = -12						; size = 4
_oldctxtenc$1$ = -8					; size = 4
_switched_encoding$1$ = -4				; size = 4
_ctxt$ = 8						; size = 4
_encoding$1$ = 12					; size = 4
_cur$ = 12						; size = 4
_xmlNodeDumpOutputInternal PROC				; COMDAT

; 900  : xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	$LN1@xmlNodeDum

; 901  :     int format;
; 902  :     xmlNodePtr tmp;
; 903  :     xmlChar *start, *end;
; 904  :     xmlOutputBufferPtr buf;
; 905  : 
; 906  :     if (cur == NULL) return;
; 907  :     buf = ctxt->buf;

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR _ctxt$[ebp]
	push	edi
	mov	edi, DWORD PTR [ebx+24]

; 908  :     if (cur->type == XML_XINCLUDE_START)

	cmp	eax, 19					; 00000013H
	je	$LN238@xmlNodeDum

; 909  : 	return;
; 910  :     if (cur->type == XML_XINCLUDE_END)

	cmp	eax, 20					; 00000014H
	je	$LN238@xmlNodeDum

; 911  : 	return;
; 912  :     if ((cur->type == XML_DOCUMENT_NODE) ||

	cmp	eax, 9
	je	$LN10@xmlNodeDum
	cmp	eax, 13					; 0000000dH
	je	$LN10@xmlNodeDum

; 915  : 	return;
; 916  :     }
; 917  : #ifdef LIBXML_HTML_ENABLED
; 918  :     if (ctxt->options & XML_SAVE_XHTML) {

	mov	ecx, DWORD PTR [ebx+32]
	test	cl, 16					; 00000010H
	je	SHORT $LN11@xmlNodeDum

; 919  :         xhtmlNodeDumpOutput(ctxt, cur);

	push	esi
	push	ebx
	call	_xhtmlNodeDumpOutput
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlNodeDum:

; 920  :         return;
; 921  :     }
; 922  :     if (((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL) &&
; 923  :          (cur->doc->type == XML_HTML_DOCUMENT_NODE) &&
; 924  :          ((ctxt->options & XML_SAVE_AS_XML) == 0)) ||

	cmp	eax, 18					; 00000012H
	je	SHORT $LN14@xmlNodeDum
	mov	edx, DWORD PTR [esi+32]
	test	edx, edx
	je	SHORT $LN14@xmlNodeDum
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN14@xmlNodeDum
	test	cl, 32					; 00000020H
	je	SHORT $LN13@xmlNodeDum
$LN14@xmlNodeDum:
	test	cl, 64					; 00000040H
	je	$LN12@xmlNodeDum
$LN13@xmlNodeDum:

; 843  :     const xmlChar *oldctxtenc = ctxt->encoding;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _oldenc$1$[ebp], 0
	mov	DWORD PTR _oldctxtenc$1$[ebp], eax

; 844  :     const xmlChar *encoding = ctxt->encoding;

	mov	DWORD PTR _encoding$1$[ebp], eax

; 845  :     xmlOutputBufferPtr buf = ctxt->buf;
; 846  :     int switched_encoding = 0;

	mov	DWORD PTR _switched_encoding$1$[ebp], 0

; 847  :     xmlDocPtr doc;
; 848  : 
; 849  :     xmlInitParser();

	call	_xmlInitParser

; 850  : 
; 851  :     doc = cur->doc;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _doc$1$[ebp], eax

; 852  :     if (doc != NULL) {

	test	eax, eax
	je	SHORT $LN237@xmlNodeDum

; 853  :         oldenc = doc->encoding;
; 854  : 	if (ctxt->encoding != NULL) {

	mov	ecx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [eax+60]
	mov	DWORD PTR _oldenc$1$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN199@xmlNodeDum

; 855  : 	    doc->encoding = BAD_CAST ctxt->encoding;

	mov	DWORD PTR [eax+60], ecx
$LN237@xmlNodeDum:

; 857  : 	    encoding = doc->encoding;
; 858  : 	}
; 859  :     }
; 860  : 
; 861  :     if ((encoding != NULL) && (doc != NULL))

	mov	ecx, DWORD PTR _encoding$1$[ebp]
$LN201@xmlNodeDum:
	test	ecx, ecx
	je	SHORT $LN231@xmlNodeDum
	test	eax, eax
	je	SHORT $LN204@xmlNodeDum

; 862  : 	htmlSetMetaEncoding(doc, (const xmlChar *) encoding);

	push	ecx
	push	eax
	call	_htmlSetMetaEncoding

; 863  :     if ((encoding == NULL) && (doc != NULL))

	mov	ecx, DWORD PTR _encoding$1$[ebp]
	add	esp, 8
	jmp	SHORT $LN204@xmlNodeDum
$LN199@xmlNodeDum:

; 856  : 	} else if (doc->encoding != NULL) {

	mov	ecx, DWORD PTR _encoding$1$[ebp]
	test	edx, edx
	cmovne	ecx, edx
	mov	DWORD PTR _encoding$1$[ebp], ecx
	jmp	SHORT $LN201@xmlNodeDum
$LN231@xmlNodeDum:

; 863  :     if ((encoding == NULL) && (doc != NULL))

	test	eax, eax
	je	SHORT $LN232@xmlNodeDum

; 864  : 	encoding = htmlGetMetaEncoding(doc);

	push	eax
	call	_htmlGetMetaEncoding
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _encoding$1$[ebp], ecx

; 865  :     if (encoding == NULL)

	test	ecx, ecx
	jne	SHORT $LN204@xmlNodeDum
$LN232@xmlNodeDum:

; 866  : 	encoding = BAD_CAST "HTML";

	mov	ecx, OFFSET ??_C@_04DBLPJNAF@HTML@
	mov	DWORD PTR _encoding$1$[ebp], ecx
$LN204@xmlNodeDum:

; 867  :     if ((encoding != NULL) && (oldctxtenc == NULL) &&
; 868  : 	(buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN205@xmlNodeDum
	cmp	DWORD PTR [edi+12], 0
	jne	SHORT $LN205@xmlNodeDum
	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN205@xmlNodeDum

; 869  : 	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	push	ecx
	push	ebx
	call	_xmlSaveSwitchEncoding
	add	esp, 8
	test	eax, eax
	js	SHORT $LN236@xmlNodeDum

; 870  : 	    doc->encoding = oldenc;
; 871  : 	    return(-1);
; 872  : 	}
; 873  : 	switched_encoding = 1;

	mov	DWORD PTR _switched_encoding$1$[ebp], 1
$LN205@xmlNodeDum:

; 874  :     }
; 875  :     if (ctxt->options & XML_SAVE_FORMAT)

	mov	eax, DWORD PTR [ebx+32]
	and	eax, 1

; 876  : 	htmlNodeDumpFormatOutput(buf, doc, cur,
; 877  : 				       (const char *)encoding, 1);
; 878  :     else
; 879  : 	htmlNodeDumpFormatOutput(buf, doc, cur,
; 880  : 				       (const char *)encoding, 0);
; 881  :     /*
; 882  :      * Restore the state of the saving context at the end of the document
; 883  :      */
; 884  :     if ((switched_encoding) && (oldctxtenc == NULL)) {

	push	eax
	mov	eax, DWORD PTR _encoding$1$[ebp]
	push	eax
	push	esi
	mov	esi, DWORD PTR _doc$1$[ebp]
	push	esi
	push	edi
	call	_htmlNodeDumpFormatOutput
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _switched_encoding$1$[ebp], 0
	je	SHORT $LN209@xmlNodeDum
	cmp	DWORD PTR _oldctxtenc$1$[ebp], 0
	jne	SHORT $LN209@xmlNodeDum

; 885  : 	xmlSaveClearEncoding(ctxt);

	push	ebx
	call	_xmlSaveClearEncoding
	add	esp, 4
$LN209@xmlNodeDum:

; 886  :     }
; 887  :     if (doc != NULL)

	test	esi, esi
	je	$LN238@xmlNodeDum

; 888  : 	doc->encoding = oldenc;

	mov	eax, DWORD PTR _oldenc$1$[ebp]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+60], eax
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN236@xmlNodeDum:

; 869  : 	if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {

	mov	esi, DWORD PTR _doc$1$[ebp]

; 888  : 	doc->encoding = oldenc;

	mov	eax, DWORD PTR _oldenc$1$[ebp]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+60], eax
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlNodeDum:

; 925  :         (ctxt->options & XML_SAVE_AS_HTML)) {
; 926  : 	htmlNodeDumpOutputInternal(ctxt, cur);
; 927  : 	return;
; 928  :     }
; 929  : #endif
; 930  :     if (cur->type == XML_DTD_NODE) {

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN15@xmlNodeDum

; 931  :         xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);

	push	esi
	push	ebx
	call	_xmlDtdDumpOutput
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlNodeDum:

; 932  : 	return;
; 933  :     }
; 934  :     if (cur->type == XML_DOCUMENT_FRAG_NODE) {

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN16@xmlNodeDum

; 935  :         xmlNodeListDumpOutput(ctxt, cur->children);

	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlNodeListDumpOutput
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlNodeDum:

; 936  : 	return;
; 937  :     }
; 938  :     if (cur->type == XML_ELEMENT_DECL) {

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN17@xmlNodeDum

; 939  :         xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);

	push	esi
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpElementDecl
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlNodeDum:

; 940  : 	return;
; 941  :     }
; 942  :     if (cur->type == XML_ATTRIBUTE_DECL) {

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN18@xmlNodeDum

; 943  :         xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);

	push	esi
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpAttributeDecl
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xmlNodeDum:

; 944  : 	return;
; 945  :     }
; 946  :     if (cur->type == XML_ENTITY_DECL) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN19@xmlNodeDum

; 947  :         xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);

	push	esi
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpEntityDecl
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xmlNodeDum:

; 948  : 	return;
; 949  :     }
; 950  :     if (cur->type == XML_TEXT_NODE) {

	cmp	eax, 3
	jne	SHORT $LN20@xmlNodeDum

; 951  : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	$LN238@xmlNodeDum

; 952  : 	    if (cur->name != xmlStringTextNoenc) {

	cmp	DWORD PTR [esi+8], OFFSET _xmlStringTextNoenc
	je	SHORT $LN22@xmlNodeDum

; 953  :                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	push	DWORD PTR [ebx+116]
	push	eax
	push	edi
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlNodeDum:

; 954  : 	    } else {
; 955  : 		/*
; 956  : 		 * Disable escaping, needed for XSLT
; 957  : 		 */
; 958  : 		xmlOutputBufferWriteString(buf, (const char *) cur->content);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlNodeDum:

; 959  : 	    }
; 960  : 	}
; 961  : 
; 962  : 	return;
; 963  :     }
; 964  :     if (cur->type == XML_PI_NODE) {

	cmp	eax, 7
	jne	$LN24@xmlNodeDum

; 965  : 	if (cur->content != NULL) {

	mov	esi, DWORD PTR [esi+40]
	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	push	edi
	call	_xmlOutputBufferWrite
	mov	eax, DWORD PTR _cur$[ebp]
	push	DWORD PTR [eax+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H
	test	esi, esi
	je	SHORT $LN25@xmlNodeDum

; 966  : 	    xmlOutputBufferWrite(buf, 2, "<?");
; 967  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
; 968  : 	    if (cur->content != NULL) {

	mov	esi, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [esi+40], 0
	je	SHORT $LN30@xmlNodeDum

; 969  : 	        if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN28@xmlNodeDum

; 970  : 	            xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8

; 973  : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString

; 974  : 	    }
; 975  : 	    xmlOutputBufferWrite(buf, 2, "?>");
; 976  : 	} else {

	jmp	SHORT $LN241@xmlNodeDum
$LN28@xmlNodeDum:

; 971  : 	        else
; 972  : 	            xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 973  : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString

; 974  : 	    }
; 975  : 	    xmlOutputBufferWrite(buf, 2, "?>");
; 976  : 	} else {

	jmp	SHORT $LN241@xmlNodeDum
$LN25@xmlNodeDum:

; 977  : 	    xmlOutputBufferWrite(buf, 2, "<?");
; 978  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
; 979  : 	    if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN30@xmlNodeDum

; 980  : 	        xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
$LN241@xmlNodeDum:

; 981  : 	    xmlOutputBufferWrite(buf, 2, "?>");
; 982  : 	}
; 983  : 	return;

	add	esp, 8
$LN30@xmlNodeDum:
	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xmlNodeDum:

; 984  :     }
; 985  :     if (cur->type == XML_COMMENT_NODE) {

	cmp	eax, 8
	jne	SHORT $LN31@xmlNodeDum

; 986  : 	if (cur->content != NULL) {

	cmp	DWORD PTR [esi+40], 0
	je	$LN238@xmlNodeDum

; 987  : 	    xmlOutputBufferWrite(buf, 4, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	4
	push	edi
	call	_xmlOutputBufferWrite

; 988  : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [esi+40]
	push	edi
	call	_xmlOutputBufferWriteString

; 989  : 	    xmlOutputBufferWrite(buf, 3, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xmlNodeDum:

; 990  : 	}
; 991  : 	return;
; 992  :     }
; 993  :     if (cur->type == XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	SHORT $LN33@xmlNodeDum

; 994  :         xmlOutputBufferWrite(buf, 1, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 995  : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 996  :         xmlOutputBufferWrite(buf, 1, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xmlNodeDum:

; 997  : 	return;
; 998  :     }
; 999  :     if (cur->type == XML_CDATA_SECTION_NODE) {

	cmp	eax, 4
	jne	$LN34@xmlNodeDum

; 1000 : 	if (cur->content == NULL || *cur->content == '\0') {

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	je	$LN37@xmlNodeDum
	mov	al, BYTE PTR [esi]
	test	al, al
	je	$LN37@xmlNodeDum

; 1002 : 	} else {
; 1003 : 	    start = end = cur->content;

	mov	ebx, esi
	npad	1
$LL2@xmlNodeDum:

; 1004 : 	    while (*end != '\0') {
; 1005 : 		if ((*end == ']') && (*(end + 1) == ']') &&

	cmp	al, 93					; 0000005dH
	jne	SHORT $LN38@xmlNodeDum
	cmp	BYTE PTR [esi+1], al
	jne	SHORT $LN38@xmlNodeDum
	cmp	BYTE PTR [esi+2], 62			; 0000003eH
	lea	eax, DWORD PTR [esi+2]
	jne	SHORT $LN38@xmlNodeDum

; 1006 : 		    (*(end + 2) == '>')) {
; 1007 : 		    end = end + 2;
; 1008 : 		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	push	edi
	mov	esi, eax
	call	_xmlOutputBufferWrite

; 1009 : 		    xmlOutputBufferWrite(buf, end - start, (const char *)start);

	mov	eax, esi
	push	ebx
	sub	eax, ebx
	push	eax
	push	edi
	call	_xmlOutputBufferWrite

; 1010 : 		    xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 36					; 00000024H

; 1011 : 		    start = end;

	mov	ebx, esi
$LN38@xmlNodeDum:

; 1012 : 		}
; 1013 : 		end++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL2@xmlNodeDum

; 1014 : 	    }
; 1015 : 	    if (start != end) {

	cmp	ebx, esi
	je	$LN238@xmlNodeDum

; 1016 : 		xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	push	edi
	call	_xmlOutputBufferWrite

; 1017 : 		xmlOutputBufferWriteString(buf, (const char *)start);

	push	ebx
	push	edi
	call	_xmlOutputBufferWriteString

; 1018 : 		xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xmlNodeDum:

; 1001 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	push	OFFSET ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
	push	12					; 0000000cH
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xmlNodeDum:

; 1019 : 	    }
; 1020 : 	}
; 1021 : 	return;
; 1022 :     }
; 1023 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN40@xmlNodeDum

; 1024 : 	xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);

	push	esi
	push	ebx
	call	_xmlAttrDumpOutput
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@xmlNodeDum:

; 1025 : 	return;
; 1026 :     }
; 1027 :     if (cur->type == XML_NAMESPACE_DECL) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN41@xmlNodeDum

; 1028 : 	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);

	push	esi
	push	ebx
	call	_xmlNsDumpOutputCtxt
	add	esp, 8
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@xmlNodeDum:

; 1029 : 	return;
; 1030 :     }
; 1031 : 
; 1032 :     format = ctxt->format;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _format$1$[ebp], eax

; 1033 :     if (format == 1) {

	cmp	eax, 1
	jne	SHORT $LN5@xmlNodeDum

; 1034 : 	tmp = cur->children;

	mov	eax, DWORD PTR [esi+12]

; 1035 : 	while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN5@xmlNodeDum
	npad	1
$LL4@xmlNodeDum:

; 1036 : 	    if ((tmp->type == XML_TEXT_NODE) ||
; 1037 : 		(tmp->type == XML_CDATA_SECTION_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	SHORT $LN220@xmlNodeDum
	cmp	ecx, 4
	je	SHORT $LN220@xmlNodeDum
	cmp	ecx, 5
	je	SHORT $LN220@xmlNodeDum

; 1040 : 		break;
; 1041 : 	    }
; 1042 : 	    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL4@xmlNodeDum

; 1036 : 	    if ((tmp->type == XML_TEXT_NODE) ||
; 1037 : 		(tmp->type == XML_CDATA_SECTION_NODE) ||

	jmp	SHORT $LN5@xmlNodeDum
$LN220@xmlNodeDum:

; 1038 : 		(tmp->type == XML_ENTITY_REF_NODE)) {
; 1039 : 		ctxt->format = 0;

	mov	DWORD PTR [ebx+40], 0
$LN5@xmlNodeDum:

; 1043 : 	}
; 1044 :     }
; 1045 :     xmlOutputBufferWrite(buf, 1, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 1046 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN45@xmlNodeDum
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN45@xmlNodeDum

; 1047 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 1048 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN45@xmlNodeDum:

; 1049 :     }
; 1050 : 
; 1051 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 1052 :     if (cur->nsDef)

	mov	eax, DWORD PTR [esi+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN46@xmlNodeDum

; 1053 :         xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);

	push	eax
	push	ebx
	call	_xmlNsListDumpOutputCtxt
	add	esp, 8
$LN46@xmlNodeDum:

; 1054 :     if (cur->properties != NULL)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN214@xmlNodeDum
	mov	esi, eax
	npad	3
$LL213@xmlNodeDum:

; 797  :         xmlAttrDumpOutput(ctxt, cur);

	push	esi
	push	ebx
	call	_xmlAttrDumpOutput

; 798  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL213@xmlNodeDum
	mov	esi, DWORD PTR _cur$[ebp]
$LN214@xmlNodeDum:

; 1055 :         xmlAttrListDumpOutput(ctxt, cur->properties);
; 1056 : 
; 1057 :     if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&
; 1058 : 	(cur->children == NULL) && ((ctxt->options & XML_SAVE_NO_EMPTY) == 0)) {

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN234@xmlNodeDum
	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN48@xmlNodeDum
$LN234@xmlNodeDum:
	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN48@xmlNodeDum
	test	BYTE PTR [ebx+32], 4
	jne	SHORT $LN48@xmlNodeDum

; 1059 :         if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN50@xmlNodeDum

; 1060 :             xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN50@xmlNodeDum:

; 1061 :         xmlOutputBufferWrite(buf, 2, "/>");

	push	OFFSET ??_C@_02HCGKDMEN@?1?$DO@
	push	2
	push	edi
	call	_xmlOutputBufferWrite

; 1062 : 	ctxt->format = format;

	mov	eax, DWORD PTR _format$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+40], eax
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@xmlNodeDum:

; 1063 : 	return;
; 1064 :     }
; 1065 :     if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN51@xmlNodeDum

; 1066 :         xmlOutputBufferWriteWSNonSig(ctxt, 1);

	push	1
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN51@xmlNodeDum:

; 1067 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1068 :     if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN52@xmlNodeDum
	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN52@xmlNodeDum

; 1069 : 	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	push	DWORD PTR [ebx+116]
	push	eax
	push	edi
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH
$LN52@xmlNodeDum:

; 1070 :     }
; 1071 :     if (cur->children != NULL) {

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN57@xmlNodeDum

; 1072 : 	if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");

	cmp	DWORD PTR [ebx+40], 1
	jne	SHORT $LN54@xmlNodeDum
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN54@xmlNodeDum:

; 1073 : 	if (ctxt->level >= 0) ctxt->level++;

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	js	SHORT $LN55@xmlNodeDum
	inc	eax
	mov	DWORD PTR [ebx+36], eax
$LN55@xmlNodeDum:

; 1074 : 	xmlNodeListDumpOutput(ctxt, cur->children);

	push	DWORD PTR [esi+12]
	push	ebx
	call	_xmlNodeListDumpOutput

; 1075 : 	if (ctxt->level > 0) ctxt->level--;

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN56@xmlNodeDum
	dec	eax
	mov	DWORD PTR [ebx+36], eax
$LN56@xmlNodeDum:

; 1076 : 	if ((xmlIndentTreeOutput) && (ctxt->format == 1))

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@xmlNodeDum
	cmp	DWORD PTR [ebx+40], 1
	jne	SHORT $LN57@xmlNodeDum

; 1077 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	edx, DWORD PTR [ebx+108]
	lea	eax, DWORD PTR [ebx+44]
	cmp	DWORD PTR [ebx+36], edx
	push	eax
	cmovle	edx, DWORD PTR [ebx+36]
	imul	edx, DWORD PTR [ebx+112]
	push	edx
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN57@xmlNodeDum:

; 1078 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1079 : 				  ctxt->indent_nr : ctxt->level),
; 1080 : 				 ctxt->indent);
; 1081 :     }
; 1082 :     xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	push	edi
	call	_xmlOutputBufferWrite

; 1083 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN58@xmlNodeDum
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN58@xmlNodeDum

; 1084 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 1085 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN58@xmlNodeDum:

; 1086 :     }
; 1087 : 
; 1088 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [esi+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1089 :     if (ctxt->format == 2)

	cmp	DWORD PTR [ebx+40], 2
	jne	SHORT $LN59@xmlNodeDum

; 1090 :         xmlOutputBufferWriteWSNonSig(ctxt, 0);

	push	0
	push	ebx
	call	_xmlOutputBufferWriteWSNonSig
	add	esp, 8
$LN59@xmlNodeDum:

; 1091 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 1092 :     ctxt->format = format;

	mov	eax, DWORD PTR _format$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+40], eax
	pop	edi
	pop	ebx
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlNodeDum:

; 913  :         (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 914  : 	xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);

	push	esi
	push	ebx
	call	_xmlDocContentDumpOutput
	add	esp, 8
$LN238@xmlNodeDum:
	pop	edi
	pop	ebx
$LN1@xmlNodeDum:
	pop	esi

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeDumpOutputInternal ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeListDumpOutput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlNodeListDumpOutput PROC				; COMDAT

; 811  : xmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlNodeLis

; 812  :     xmlOutputBufferPtr buf;
; 813  : 
; 814  :     if (cur == NULL) return;
; 815  :     buf = ctxt->buf;

	push	ebx
	push	edi
	mov	edi, DWORD PTR _ctxt$[ebp]
	mov	ebx, DWORD PTR [edi+24]
	npad	3
$LL2@xmlNodeLis:

; 816  :     while (cur != NULL) {
; 817  : 	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&

	cmp	DWORD PTR [edi+40], 1
	jne	SHORT $LN5@xmlNodeLis
	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlNodeLis
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN6@xmlNodeLis
	cmp	eax, 8
	je	SHORT $LN6@xmlNodeLis
	cmp	eax, 7
	jne	SHORT $LN5@xmlNodeLis
$LN6@xmlNodeLis:

; 818  : 	    ((cur->type == XML_ELEMENT_NODE) ||
; 819  : 	     (cur->type == XML_COMMENT_NODE) ||
; 820  : 	     (cur->type == XML_PI_NODE)))
; 821  : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	edx, DWORD PTR [edi+108]
	lea	eax, DWORD PTR [edi+44]
	cmp	DWORD PTR [edi+36], edx
	push	eax
	cmovle	edx, DWORD PTR [edi+36]
	imul	edx, DWORD PTR [edi+112]
	push	edx
	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN5@xmlNodeLis:

; 822  : 	                         (ctxt->level > ctxt->indent_nr ?
; 823  : 				  ctxt->indent_nr : ctxt->level),
; 824  : 				 ctxt->indent);
; 825  :         xmlNodeDumpOutputInternal(ctxt, cur);

	push	esi
	push	edi
	call	_xmlNodeDumpOutputInternal
	add	esp, 8

; 826  : 	if (ctxt->format == 1) {

	cmp	DWORD PTR [edi+40], 1
	jne	SHORT $LN7@xmlNodeLis

; 827  : 	    xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	ebx
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN7@xmlNodeLis:

; 828  : 	}
; 829  : 	cur = cur->next;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@xmlNodeLis
	pop	edi
	pop	ebx
$LN3@xmlNodeLis:
	pop	esi

; 830  :     }
; 831  : }

	pop	ebp
	ret	0
_xmlNodeListDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xhtmlNodeDumpOutput
_TEXT	SEGMENT
_httpequiv$1$ = -12					; size = 4
_indent$1$ = -12					; size = 4
_tmp$2$ = -8						; size = 4
_addmeta$1$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_format$1$ = 12						; size = 4
_cur$ = 12						; size = 4
_xhtmlNodeDumpOutput PROC				; COMDAT

; 1449 : xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ebx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _addmeta$1$[ebp], 0
	test	ebx, ebx
	je	$LN1@xhtmlNodeD

; 1450 :     int format, addmeta = 0;
; 1451 :     xmlNodePtr tmp;
; 1452 :     xmlChar *start, *end;
; 1453 :     xmlOutputBufferPtr buf;
; 1454 : 
; 1455 :     if (cur == NULL) return;
; 1456 :     if ((cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, 9
	je	$LN10@xhtmlNodeD
	cmp	eax, 13					; 0000000dH
	je	$LN10@xhtmlNodeD

; 1459 : 	return;
; 1460 :     }
; 1461 :     if (cur->type == XML_XINCLUDE_START)

	cmp	eax, 19					; 00000013H
	je	$LN1@xhtmlNodeD

; 1462 : 	return;
; 1463 :     if (cur->type == XML_XINCLUDE_END)

	cmp	eax, 20					; 00000014H
	je	$LN1@xhtmlNodeD

; 1464 : 	return;
; 1465 :     if (cur->type == XML_NAMESPACE_DECL) {

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN13@xhtmlNodeD

; 1466 : 	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlNsDumpOutputCtxt
	add	esp, 8
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@xhtmlNodeD:

; 1467 : 	return;
; 1468 :     }
; 1469 :     if (cur->type == XML_DTD_NODE) {

	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN14@xhtmlNodeD

; 1470 :         xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlDtdDumpOutput
	add	esp, 8
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@xhtmlNodeD:

; 1471 : 	return;
; 1472 :     }
; 1473 :     if (cur->type == XML_DOCUMENT_FRAG_NODE) {

	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN15@xhtmlNodeD

; 1474 :         xhtmlNodeListDumpOutput(ctxt, cur->children);

	push	DWORD PTR [ebx+12]
	push	DWORD PTR _ctxt$[ebp]
	call	_xhtmlNodeListDumpOutput
	add	esp, 8
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xhtmlNodeD:
	push	esi

; 1475 : 	return;
; 1476 :     }
; 1477 :     buf = ctxt->buf;

	mov	esi, DWORD PTR _ctxt$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+24]

; 1478 :     if (cur->type == XML_ELEMENT_DECL) {

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN16@xhtmlNodeD

; 1479 :         xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);

	push	ebx
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpElementDecl
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xhtmlNodeD:

; 1480 : 	return;
; 1481 :     }
; 1482 :     if (cur->type == XML_ATTRIBUTE_DECL) {

	cmp	eax, 16					; 00000010H
	jne	SHORT $LN17@xhtmlNodeD

; 1483 :         xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);

	push	ebx
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpAttributeDecl
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xhtmlNodeD:

; 1484 : 	return;
; 1485 :     }
; 1486 :     if (cur->type == XML_ENTITY_DECL) {

	cmp	eax, 17					; 00000011H
	jne	SHORT $LN18@xhtmlNodeD

; 1487 :         xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);

	push	ebx
	push	DWORD PTR [edi+16]
	call	_xmlBufDumpEntityDecl
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@xhtmlNodeD:

; 1488 : 	return;
; 1489 :     }
; 1490 :     if (cur->type == XML_TEXT_NODE) {

	cmp	eax, 3
	jne	SHORT $LN19@xhtmlNodeD

; 1491 : 	if (cur->content != NULL) {

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	$LN188@xhtmlNodeD

; 1492 : 	    if ((cur->name == xmlStringText) ||

	mov	ecx, DWORD PTR [ebx+8]
	cmp	ecx, OFFSET _xmlStringText
	je	SHORT $LN23@xhtmlNodeD
	cmp	ecx, OFFSET _xmlStringTextNoenc
	jne	SHORT $LN23@xhtmlNodeD

; 1495 : 	    } else {
; 1496 : 		/*
; 1497 : 		 * Disable escaping, needed for XSLT
; 1498 : 		 */
; 1499 : 		xmlOutputBufferWriteString(buf, (const char *) cur->content);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@xhtmlNodeD:

; 1493 : 		(cur->name != xmlStringTextNoenc)) {
; 1494 :                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	push	DWORD PTR [esi+116]
	push	eax
	push	edi
	call	_xmlOutputBufferWriteEscape

; 1537 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@xhtmlNodeD:

; 1500 : 	    }
; 1501 : 	}
; 1502 : 
; 1503 : 	return;
; 1504 :     }
; 1505 :     if (cur->type == XML_PI_NODE) {

	cmp	eax, 7
	jne	SHORT $LN24@xhtmlNodeD

; 1506 : 	if (cur->content != NULL) {

	mov	esi, DWORD PTR [ebx+40]
	push	OFFSET ??_C@_02HFBBBACF@?$DM?$DP@
	push	2
	push	edi
	call	_xmlOutputBufferWrite
	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H
	test	esi, esi
	je	SHORT $LN25@xhtmlNodeD

; 1507 : 	    xmlOutputBufferWrite(buf, 2, "<?");
; 1508 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
; 1509 : 	    if (cur->content != NULL) {

	cmp	DWORD PTR [ebx+40], 0
	je	SHORT $LN25@xhtmlNodeD

; 1510 : 		xmlOutputBufferWrite(buf, 1, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 1511 : 		xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [ebx+40]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 20					; 00000014H
$LN25@xhtmlNodeD:

; 1512 : 	    }
; 1513 : 	    xmlOutputBufferWrite(buf, 2, "?>");
; 1514 : 	} else {
; 1515 : 	    xmlOutputBufferWrite(buf, 2, "<?");
; 1516 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
; 1517 : 	    xmlOutputBufferWrite(buf, 2, "?>");
; 1518 : 	}
; 1519 : 	return;

	push	OFFSET ??_C@_02GOEMJPDN@?$DP?$DO@
	push	2

; 1537 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN188@xhtmlNodeD:
	pop	edi
	pop	esi
$LN1@xhtmlNodeD:
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@xhtmlNodeD:

; 1520 :     }
; 1521 :     if (cur->type == XML_COMMENT_NODE) {

	cmp	eax, 8
	jne	SHORT $LN28@xhtmlNodeD

; 1522 : 	if (cur->content != NULL) {

	cmp	DWORD PTR [ebx+40], 0
	je	SHORT $LN188@xhtmlNodeD

; 1523 : 	    xmlOutputBufferWrite(buf, 4, "<!--");

	push	OFFSET ??_C@_04FFDNBKGC@?$DM?$CB?9?9@
	push	4
	push	edi
	call	_xmlOutputBufferWrite

; 1524 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->content);

	push	DWORD PTR [ebx+40]
	push	edi
	call	_xmlOutputBufferWriteString

; 1525 : 	    xmlOutputBufferWrite(buf, 3, "-->");

	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xhtmlNodeD:

; 1526 : 	}
; 1527 : 	return;
; 1528 :     }
; 1529 :     if (cur->type == XML_ENTITY_REF_NODE) {

	cmp	eax, 5
	jne	SHORT $LN30@xhtmlNodeD

; 1530 :         xmlOutputBufferWrite(buf, 1, "&");

	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 1531 : 	xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 1532 :         xmlOutputBufferWrite(buf, 1, ";");

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@xhtmlNodeD:

; 1533 : 	return;
; 1534 :     }
; 1535 :     if (cur->type == XML_CDATA_SECTION_NODE) {

	cmp	eax, 4
	jne	$LN31@xhtmlNodeD

; 1536 : 	if (cur->content == NULL || *cur->content == '\0') {

	mov	esi, DWORD PTR [ebx+40]
	test	esi, esi
	je	$LN34@xhtmlNodeD
	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN34@xhtmlNodeD

; 1538 : 	} else {
; 1539 : 	    start = end = cur->content;

	mov	ebx, esi
$LL2@xhtmlNodeD:

; 1540 : 	    while (*end != '\0') {
; 1541 : 		if (*end == ']' && *(end + 1) == ']' && *(end + 2) == '>') {

	cmp	al, 93					; 0000005dH
	jne	SHORT $LN35@xhtmlNodeD
	cmp	BYTE PTR [esi+1], al
	jne	SHORT $LN35@xhtmlNodeD
	cmp	BYTE PTR [esi+2], 62			; 0000003eH
	lea	eax, DWORD PTR [esi+2]
	jne	SHORT $LN35@xhtmlNodeD

; 1542 : 		    end = end + 2;
; 1543 : 		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	push	edi
	mov	esi, eax
	call	_xmlOutputBufferWrite

; 1544 : 		    xmlOutputBufferWrite(buf, end - start, (const char *)start);

	mov	eax, esi
	push	ebx
	sub	eax, ebx
	push	eax
	push	edi
	call	_xmlOutputBufferWrite

; 1545 : 		    xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 36					; 00000024H

; 1546 : 		    start = end;

	mov	ebx, esi
$LN35@xhtmlNodeD:

; 1547 : 		}
; 1548 : 		end++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL2@xhtmlNodeD

; 1549 : 	    }
; 1550 : 	    if (start != end) {

	cmp	ebx, esi
	je	$LN188@xhtmlNodeD

; 1551 : 		xmlOutputBufferWrite(buf, 9, "<![CDATA[");

	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	push	9
	push	edi
	call	_xmlOutputBufferWrite

; 1552 : 		xmlOutputBufferWriteString(buf, (const char *)start);

	push	ebx
	push	edi
	call	_xmlOutputBufferWriteString

; 1553 : 		xmlOutputBufferWrite(buf, 3, "]]>");

	push	OFFSET ??_C@_03MCHNFBAC@?$FN?$FN?$DO@
	push	3
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@xhtmlNodeD:

; 1537 : 	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");

	push	OFFSET ??_C@_0N@OGBMJHND@?$DM?$CB?$FLCDATA?$FL?$FN?$FN?$DO@
	push	12					; 0000000cH
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@xhtmlNodeD:

; 1554 : 	    }
; 1555 : 	}
; 1556 : 	return;
; 1557 :     }
; 1558 :     if (cur->type == XML_ATTRIBUTE_NODE) {

	cmp	eax, 2
	jne	SHORT $LN37@xhtmlNodeD

; 1559 :         xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);

	push	ebx
	push	esi
	call	_xmlAttrDumpOutput
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@xhtmlNodeD:

; 1560 : 	return;
; 1561 :     }
; 1562 : 
; 1563 :     format = ctxt->format;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _format$1$[ebp], eax

; 1564 :     if (format == 1) {

	cmp	eax, 1
	jne	SHORT $LN5@xhtmlNodeD

; 1565 : 	tmp = cur->children;

	mov	eax, DWORD PTR [ebx+12]

; 1566 : 	while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN5@xhtmlNodeD
$LL4@xhtmlNodeD:

; 1567 : 	    if ((tmp->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 3
	je	SHORT $LN171@xhtmlNodeD
	cmp	ecx, 5
	je	SHORT $LN171@xhtmlNodeD

; 1570 : 		break;
; 1571 : 	    }
; 1572 : 	    tmp = tmp->next;

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL4@xhtmlNodeD

; 1608 :                     if (xmlStrcasecmp(httpequiv, BAD_CAST"Content-Type") == 0) {

	jmp	SHORT $LN5@xhtmlNodeD
$LN171@xhtmlNodeD:

; 1568 : 		(tmp->type == XML_ENTITY_REF_NODE)) {
; 1569 : 		format = 0;

	mov	DWORD PTR _format$1$[ebp], 0
$LN5@xhtmlNodeD:

; 1573 : 	}
; 1574 :     }
; 1575 :     xmlOutputBufferWrite(buf, 1, "<");

	push	OFFSET ??_C@_01MNNFJEPP@?$DM@
	push	1
	push	edi
	call	_xmlOutputBufferWrite

; 1576 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN41@xhtmlNodeD
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN41@xhtmlNodeD

; 1577 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 1578 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN41@xhtmlNodeD:

; 1579 :     }
; 1580 : 
; 1581 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 1582 :     if (cur->nsDef)

	mov	eax, DWORD PTR [ebx+48]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@xhtmlNodeD

; 1583 :         xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);

	push	eax
	push	esi
	call	_xmlNsListDumpOutputCtxt
	add	esp, 8
$LN42@xhtmlNodeD:

; 1584 :     if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
; 1585 : 	(cur->ns == NULL) && (cur->nsDef == NULL))) {

	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@xhtmlNodeD
	cmp	DWORD PTR [ebx+36], 0
	jne	SHORT $LN43@xhtmlNodeD
	cmp	DWORD PTR [ebx+48], 0
	jne	SHORT $LN43@xhtmlNodeD

; 1586 : 	/*
; 1587 : 	 * 3.1.1. Strictly Conforming Documents A.3.1.1 3/
; 1588 : 	 */
; 1589 : 	xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0CG@NOKOIAPK@?5xmlns?$DN?$CChttp?3?1?1www?4w3?4org?11999?1@
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8
$LN43@xhtmlNodeD:

; 1590 : 		" xmlns=\"http://www.w3.org/1999/xhtml\"");
; 1591 :     }
; 1592 :     if (cur->properties != NULL)

	mov	eax, DWORD PTR [ebx+44]
	test	eax, eax
	je	SHORT $LN44@xhtmlNodeD

; 1593 :         xhtmlAttrListDumpOutput(ctxt, cur->properties);

	push	eax
	push	esi
	call	_xhtmlAttrListDumpOutput
	add	esp, 8
$LN44@xhtmlNodeD:

; 1594 : 
; 1595 :     if ((cur->type == XML_ELEMENT_NODE) &&
; 1596 :         (cur->parent != NULL) &&
; 1597 :         (cur->parent->parent == (xmlNodePtr) cur->doc) &&
; 1598 :         xmlStrEqual(cur->name, BAD_CAST"head") &&

	cmp	DWORD PTR [ebx+4], 1
	jne	$LN186@xhtmlNodeD
	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	$LN49@xhtmlNodeD
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, DWORD PTR [ebx+32]
	jne	$LN49@xhtmlNodeD
	push	OFFSET ??_C@_04NEODDMOL@head@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN49@xhtmlNodeD
	mov	eax, DWORD PTR [ebx+20]
	push	OFFSET ??_C@_04PNIFHPHN@html@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xhtmlNodeD

; 1599 :         xmlStrEqual(cur->parent->name, BAD_CAST"html")) {
; 1600 : 
; 1601 :         tmp = cur->children;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _tmp$2$[ebp], eax

; 1602 :         while (tmp != NULL) {

	test	eax, eax
	je	SHORT $LN187@xhtmlNodeD
	npad	8
$LL6@xhtmlNodeD:

; 1603 :             if (xmlStrEqual(tmp->name, BAD_CAST"meta")) {

	push	OFFSET ??_C@_04HLJJCGEF@meta@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xhtmlNodeD

; 1604 :                 xmlChar *httpequiv;
; 1605 : 
; 1606 :                 httpequiv = xmlGetProp(tmp, BAD_CAST"http-equiv");

	push	OFFSET ??_C@_0L@NALBGOHO@http?9equiv@
	push	DWORD PTR _tmp$2$[ebp]
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _httpequiv$1$[ebp], eax

; 1607 :                 if (httpequiv != NULL) {

	test	eax, eax
	je	SHORT $LN47@xhtmlNodeD

; 1608 :                     if (xmlStrcasecmp(httpequiv, BAD_CAST"Content-Type") == 0) {

	push	OFFSET ??_C@_0N@LAFFMKKA@Content?9Type@
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	push	DWORD PTR _httpequiv$1$[ebp]
	test	eax, eax
	je	SHORT $LN172@xhtmlNodeD

; 1610 :                         break;
; 1611 :                     }
; 1612 :                     xmlFree(httpequiv);

	call	DWORD PTR _xmlFree
	add	esp, 4
$LN47@xhtmlNodeD:

; 1613 :                 }
; 1614 :             }
; 1615 :             tmp = tmp->next;

	mov	eax, DWORD PTR _tmp$2$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _tmp$2$[ebp], eax
	test	eax, eax
	jne	SHORT $LL6@xhtmlNodeD
$LN187@xhtmlNodeD:

; 1618 :             addmeta = 1;

	mov	DWORD PTR _addmeta$1$[ebp], 1
$LN49@xhtmlNodeD:

; 1619 :     }
; 1620 : 
; 1621 :     if ((cur->type == XML_ELEMENT_NODE) && (cur->children == NULL)) {

	cmp	DWORD PTR [ebx+4], 1
	jne	$LN186@xhtmlNodeD
	cmp	DWORD PTR [ebx+12], 0
	jne	$LN186@xhtmlNodeD

; 1622 : 	if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN179@xhtmlNodeD
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN51@xhtmlNodeD

; 1271 :     if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))

	push	OFFSET ??_C@_0BN@BMFLMPPL@http?3?1?1www?4w3?4org?11999?1xhtml@
	push	DWORD PTR [eax+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN51@xhtmlNodeD
$LN179@xhtmlNodeD:

; 1272 : 	return(0);
; 1273 :     if (node->children != NULL)

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN51@xhtmlNodeD

; 1274 : 	return(0);
; 1275 :     switch (node->name[0]) {

	mov	ecx, DWORD PTR [ebx+8]
	movzx	eax, BYTE PTR [ecx]
	add	eax, -97				; ffffff9fH
	cmp	eax, 15					; 0000000fH
	ja	SHORT $LN51@xhtmlNodeD
	jmp	DWORD PTR $LN196@xhtmlNodeD[eax*4]
$LN172@xhtmlNodeD:

; 1609 :                         xmlFree(httpequiv);

	call	DWORD PTR _xmlFree
	add	esp, 4

; 1616 :         }
; 1617 :         if (tmp == NULL)

	jmp	SHORT $LN49@xhtmlNodeD
$LN145@xhtmlNodeD:

; 1277 : 	    if (xmlStrEqual(node->name, BAD_CAST "area"))

	push	OFFSET ??_C@_04GOEDGNCF@area@
$LN192@xhtmlNodeD:

; 1628 : 	} else {
; 1629 : 		if (addmeta == 1) {

	push	ecx
$LN191@xhtmlNodeD:
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN185@xhtmlNodeD
$LN51@xhtmlNodeD:
	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _addmeta$1$[ebp], 1
	jne	$LN60@xhtmlNodeD

; 1630 : 			xmlOutputBufferWrite(buf, 1, ">");
; 1631 : 			if (ctxt->format == 1) {

	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN57@xhtmlNodeD

; 1632 : 				xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1633 : 				if (xmlIndentTreeOutput)

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@xhtmlNodeD

; 1634 : 					xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [esi+108]
	inc	ecx
	cmp	ecx, edx
	push	eax
	cmovle	edx, ecx
	imul	edx, DWORD PTR [esi+112]
	push	edx
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN57@xhtmlNodeD:

; 1635 : 					(ctxt->level + 1 > ctxt->indent_nr ?
; 1636 : 					ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
; 1637 : 			}
; 1638 : 			xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
	push	edi
	call	_xmlOutputBufferWriteString

; 1639 : 				"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
; 1640 : 			if (ctxt->encoding) {

	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
	test	eax, eax
	je	$LN58@xhtmlNodeD

; 1641 : 				xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1642 : 			} else {

	jmp	$LN59@xhtmlNodeD
$LN147@xhtmlNodeD:

; 1281 : 	    if (xmlStrEqual(node->name, BAD_CAST "br"))

	push	OFFSET ??_C@_02FGOECCNH@br@
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN185@xhtmlNodeD

; 1282 : 		return(1);
; 1283 : 	    if (xmlStrEqual(node->name, BAD_CAST "base"))

	push	OFFSET ??_C@_04BHIIPFEC@base@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN185@xhtmlNodeD

; 1284 : 		return(1);
; 1285 : 	    if (xmlStrEqual(node->name, BAD_CAST "basefont"))

	push	OFFSET ??_C@_08IOLGIJGJ@basefont@
	push	DWORD PTR [ebx+8]

; 1286 : 		return(1);
; 1287 : 	    return(0);

	jmp	$LN191@xhtmlNodeD
$LN151@xhtmlNodeD:

; 1288 : 	case 'c':
; 1289 : 	    if (xmlStrEqual(node->name, BAD_CAST "col"))

	push	OFFSET ??_C@_03HNOLNALI@col@

; 1290 : 		return(1);
; 1291 : 	    return(0);

	jmp	$LN192@xhtmlNodeD
$LN153@xhtmlNodeD:

; 1292 : 	case 'f':
; 1293 : 	    if (xmlStrEqual(node->name, BAD_CAST "frame"))

	push	OFFSET ??_C@_05MIJNFGED@frame@

; 1294 : 		return(1);
; 1295 : 	    return(0);

	jmp	$LN192@xhtmlNodeD
$LN155@xhtmlNodeD:

; 1296 : 	case 'h':
; 1297 : 	    if (xmlStrEqual(node->name, BAD_CAST "hr"))

	push	OFFSET ??_C@_02FLHDKHAB@hr@

; 1298 : 		return(1);
; 1299 : 	    return(0);

	jmp	$LN192@xhtmlNodeD
$LN157@xhtmlNodeD:

; 1300 : 	case 'i':
; 1301 : 	    if (xmlStrEqual(node->name, BAD_CAST "img"))

	push	OFFSET ??_C@_03PCCGDNHJ@img@
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN185@xhtmlNodeD

; 1302 : 		return(1);
; 1303 : 	    if (xmlStrEqual(node->name, BAD_CAST "input"))

	push	OFFSET ??_C@_05DFJCHPDH@input@
	push	DWORD PTR [ebx+8]
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN185@xhtmlNodeD

; 1304 : 		return(1);
; 1305 : 	    if (xmlStrEqual(node->name, BAD_CAST "isindex"))

	push	OFFSET ??_C@_07JMLOFMGP@isindex@
	push	DWORD PTR [ebx+8]

; 1306 : 		return(1);
; 1307 : 	    return(0);

	jmp	$LN191@xhtmlNodeD
$LN161@xhtmlNodeD:

; 1308 : 	case 'l':
; 1309 : 	    if (xmlStrEqual(node->name, BAD_CAST "link"))

	push	OFFSET ??_C@_04OHHBHOGB@link@

; 1310 : 		return(1);
; 1311 : 	    return(0);

	jmp	$LN192@xhtmlNodeD
$LN163@xhtmlNodeD:

; 1312 : 	case 'm':
; 1313 : 	    if (xmlStrEqual(node->name, BAD_CAST "meta"))

	push	OFFSET ??_C@_04HLJJCGEF@meta@

; 1314 : 		return(1);
; 1315 : 	    return(0);

	jmp	$LN192@xhtmlNodeD
$LN165@xhtmlNodeD:

; 1316 : 	case 'p':
; 1317 : 	    if (xmlStrEqual(node->name, BAD_CAST "param"))

	push	OFFSET ??_C@_05LJDNNBIK@param@
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN51@xhtmlNodeD
$LN185@xhtmlNodeD:

; 1622 : 	if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&

	cmp	DWORD PTR _addmeta$1$[ebp], 0
	jne	$LN51@xhtmlNodeD

; 1623 : 	    ((xhtmlIsEmpty(cur) == 1) && (addmeta == 0))) {
; 1624 : 	    /*
; 1625 : 	     * C.2. Empty Elements
; 1626 : 	     */
; 1627 : 	    xmlOutputBufferWrite(buf, 3, " />");

	mov	ecx, OFFSET ??_C@_03MFNJFHN@?5?1?$DO@
	mov	eax, 3

; 1661 : 	}
; 1662 : 	return;

	push	ecx
	push	eax
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@xhtmlNodeD:

; 1643 : 				xmlOutputBufferWrite(buf, 5, "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	5
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN59@xhtmlNodeD:

; 1644 : 			}
; 1645 : 			xmlOutputBufferWrite(buf, 4, "\" />");

	push	OFFSET ??_C@_04FADKMBBI@?$CC?5?1?$DO@
	push	4
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1646 : 			if (ctxt->format == 1)

	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN60@xhtmlNodeD

; 1647 : 				xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN60@xhtmlNodeD:

; 1648 : 		} else {
; 1649 : 			xmlOutputBufferWrite(buf, 1, ">");
; 1650 : 		}
; 1651 : 	    /*
; 1652 : 	     * C.3. Element Minimization and Empty Element Content
; 1653 : 	     */
; 1654 : 	    xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	push	edi
	call	_xmlOutputBufferWrite

; 1655 : 	    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN61@xhtmlNodeD
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN61@xhtmlNodeD

; 1656 : 		xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 1657 : 		xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN61@xhtmlNodeD:

; 1658 : 	    }
; 1659 : 	    xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1660 : 	    xmlOutputBufferWrite(buf, 1, ">");

	mov	ecx, OFFSET ??_C@_01PPODPGHN@?$DO@
	mov	eax, 1

; 1661 : 	}
; 1662 : 	return;

	push	ecx
	push	eax
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN186@xhtmlNodeD:

; 1663 :     }
; 1664 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1665 : 	if (addmeta == 1) {

	cmp	DWORD PTR _addmeta$1$[ebp], 1
	jne	$LN62@xhtmlNodeD

; 1666 : 		if (ctxt->format == 1) {

	cmp	DWORD PTR [esi+40], 1
	jne	SHORT $LN64@xhtmlNodeD

; 1667 : 			xmlOutputBufferWrite(buf, 1, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH

; 1668 : 			if (xmlIndentTreeOutput)

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN64@xhtmlNodeD

; 1669 : 				xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [esi+108]
	inc	ecx
	cmp	ecx, edx
	push	eax
	cmovle	edx, ecx
	imul	edx, DWORD PTR [esi+112]
	push	edx
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN64@xhtmlNodeD:

; 1670 : 				(ctxt->level + 1 > ctxt->indent_nr ?
; 1671 : 				ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
; 1672 : 		}
; 1673 : 		xmlOutputBufferWriteString(buf,

	push	OFFSET ??_C@_0DN@ILJMDLKG@?$DMmeta?5http?9equiv?$DN?$CCContent?9Type?$CC@
	push	edi
	call	_xmlOutputBufferWriteString

; 1674 : 			"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
; 1675 : 		if (ctxt->encoding) {

	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN65@xhtmlNodeD

; 1676 : 			xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString
	add	esp, 8

; 1677 : 		} else {

	jmp	SHORT $LN66@xhtmlNodeD
$LN65@xhtmlNodeD:

; 1678 : 			xmlOutputBufferWrite(buf, 5, "UTF-8");

	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	push	5
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN66@xhtmlNodeD:

; 1679 : 		}
; 1680 : 		xmlOutputBufferWrite(buf, 4, "\" />");

	push	OFFSET ??_C@_04FADKMBBI@?$CC?5?1?$DO@
	push	4
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN62@xhtmlNodeD:

; 1681 : 	}
; 1682 :     if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	cmp	DWORD PTR [ebx+4], 1
	je	SHORT $LN67@xhtmlNodeD
	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN67@xhtmlNodeD

; 1683 : 	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);

	push	DWORD PTR [esi+116]
	push	eax
	push	edi
	call	_xmlOutputBufferWriteEscape
	add	esp, 12					; 0000000cH
$LN67@xhtmlNodeD:

; 1684 :     }
; 1685 : 
; 1686 : #if 0
; 1687 :     /*
; 1688 :     * This was removed due to problems with HTML processors.
; 1689 :     * See bug #345147.
; 1690 :     */
; 1691 :     /*
; 1692 :      * 4.8. Script and Style elements
; 1693 :      */
; 1694 :     if ((cur->type == XML_ELEMENT_NODE) &&
; 1695 : 	((xmlStrEqual(cur->name, BAD_CAST "script")) ||
; 1696 : 	 (xmlStrEqual(cur->name, BAD_CAST "style"))) &&
; 1697 : 	((cur->ns == NULL) ||
; 1698 : 	 (xmlStrEqual(cur->ns->href, XHTML_NS_NAME)))) {
; 1699 : 	xmlNodePtr child = cur->children;
; 1700 : 
; 1701 : 	while (child != NULL) {
; 1702 : 	    if (child->type == XML_TEXT_NODE) {
; 1703 : 		if ((xmlStrchr(child->content, '<') == NULL) &&
; 1704 : 		    (xmlStrchr(child->content, '&') == NULL) &&
; 1705 : 		    (xmlStrstr(child->content, BAD_CAST "]]>") == NULL)) {
; 1706 : 		    /* Nothing to escape, so just output as is... */
; 1707 : 		    /* FIXME: Should we do something about "--" also? */
; 1708 : 		    int level = ctxt->level;
; 1709 : 		    int indent = ctxt->format;
; 1710 : 
; 1711 : 		    ctxt->level = 0;
; 1712 : 		    ctxt->format = 0;
; 1713 : 		    xmlOutputBufferWriteString(buf, (const char *) child->content);
; 1714 : 		    /* (We cannot use xhtmlNodeDumpOutput() here because
; 1715 : 		     * we wish to leave '>' unescaped!) */
; 1716 : 		    ctxt->level = level;
; 1717 : 		    ctxt->format = indent;
; 1718 : 		} else {
; 1719 : 		    /* We must use a CDATA section.  Unfortunately,
; 1720 : 		     * this will break CSS and JavaScript when read by
; 1721 : 		     * a browser in HTML4-compliant mode. :-( */
; 1722 : 		    start = end = child->content;
; 1723 : 		    while (*end != '\0') {
; 1724 : 			if (*end == ']' &&
; 1725 : 			    *(end + 1) == ']' &&
; 1726 : 			    *(end + 2) == '>') {
; 1727 : 			    end = end + 2;
; 1728 : 			    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
; 1729 : 			    xmlOutputBufferWrite(buf, end - start,
; 1730 : 						 (const char *)start);
; 1731 : 			    xmlOutputBufferWrite(buf, 3, "]]>");
; 1732 : 			    start = end;
; 1733 : 			}
; 1734 : 			end++;
; 1735 : 		    }
; 1736 : 		    if (start != end) {
; 1737 : 			xmlOutputBufferWrite(buf, 9, "<![CDATA[");
; 1738 : 			xmlOutputBufferWrite(buf, end - start,
; 1739 : 			                     (const char *)start);
; 1740 : 			xmlOutputBufferWrite(buf, 3, "]]>");
; 1741 : 		    }
; 1742 : 		}
; 1743 : 	    } else {
; 1744 : 		int level = ctxt->level;
; 1745 : 		int indent = ctxt->format;
; 1746 : 
; 1747 : 		ctxt->level = 0;
; 1748 : 		ctxt->format = 0;
; 1749 : 		xhtmlNodeDumpOutput(ctxt, child);
; 1750 : 		ctxt->level = level;
; 1751 : 		ctxt->format = indent;
; 1752 : 	    }
; 1753 : 	    child = child->next;
; 1754 : 	}
; 1755 :     }
; 1756 : #endif
; 1757 : 
; 1758 :     if (cur->children != NULL) {

	cmp	DWORD PTR [ebx+12], 0
	je	SHORT $LN72@xhtmlNodeD

; 1759 : 	int indent = ctxt->format;
; 1760 : 
; 1761 : 	if (format == 1) xmlOutputBufferWrite(buf, 1, "\n");

	mov	ecx, DWORD PTR _format$1$[ebp]
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _indent$1$[ebp], eax
	cmp	ecx, 1
	jne	SHORT $LN69@xhtmlNodeD
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	ecx
	push	edi
	call	_xmlOutputBufferWrite
	mov	ecx, DWORD PTR _format$1$[ebp]
	add	esp, 12					; 0000000cH
$LN69@xhtmlNodeD:

; 1762 : 	if (ctxt->level >= 0) ctxt->level++;

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	js	SHORT $LN70@xhtmlNodeD
	inc	eax
	mov	DWORD PTR [esi+36], eax
$LN70@xhtmlNodeD:

; 1763 : 	ctxt->format = format;

	mov	DWORD PTR [esi+40], ecx

; 1764 : 	xhtmlNodeListDumpOutput(ctxt, cur->children);

	push	DWORD PTR [ebx+12]
	push	esi
	call	_xhtmlNodeListDumpOutput

; 1765 : 	if (ctxt->level > 0) ctxt->level--;

	mov	eax, DWORD PTR [esi+36]
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN71@xhtmlNodeD
	dec	eax
	mov	DWORD PTR [esi+36], eax
$LN71@xhtmlNodeD:

; 1766 : 	ctxt->format = indent;

	mov	eax, DWORD PTR _indent$1$[ebp]
	mov	DWORD PTR [esi+40], eax

; 1767 : 	if ((xmlIndentTreeOutput) && (format == 1))

	call	___xmlIndentTreeOutput
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN72@xhtmlNodeD
	cmp	DWORD PTR _format$1$[ebp], 1
	jne	SHORT $LN72@xhtmlNodeD

; 1768 : 	    xmlOutputBufferWrite(buf, ctxt->indent_size *

	mov	edx, DWORD PTR [esi+108]
	lea	eax, DWORD PTR [esi+44]
	cmp	DWORD PTR [esi+36], edx
	push	eax
	cmovle	edx, DWORD PTR [esi+36]
	imul	edx, DWORD PTR [esi+112]
	push	edx
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 12					; 0000000cH
$LN72@xhtmlNodeD:

; 1769 : 	                         (ctxt->level > ctxt->indent_nr ?
; 1770 : 				  ctxt->indent_nr : ctxt->level),
; 1771 : 				 ctxt->indent);
; 1772 :     }
; 1773 :     xmlOutputBufferWrite(buf, 2, "</");

	push	OFFSET ??_C@_02DPNDACHE@?$DM?1@
	push	2
	push	edi
	call	_xmlOutputBufferWrite

; 1774 :     if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {

	mov	eax, DWORD PTR [ebx+36]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN73@xhtmlNodeD
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN73@xhtmlNodeD

; 1775 :         xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);

	push	eax
	push	edi
	call	_xmlOutputBufferWriteString

; 1776 : 	xmlOutputBufferWrite(buf, 1, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
$LN73@xhtmlNodeD:

; 1777 :     }
; 1778 : 
; 1779 :     xmlOutputBufferWriteString(buf, (const char *)cur->name);

	push	DWORD PTR [ebx+8]
	push	edi
	call	_xmlOutputBufferWriteString

; 1780 :     xmlOutputBufferWrite(buf, 1, ">");

	push	OFFSET ??_C@_01PPODPGHN@?$DO@
	push	1
	push	edi
	call	_xmlOutputBufferWrite
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xhtmlNodeD:

; 1457 :         (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 1458 :         xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);

	push	ebx
	push	DWORD PTR _ctxt$[ebp]
	call	_xmlDocContentDumpOutput
	add	esp, 8
	pop	ebx

; 1781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN196@xhtmlNodeD:
	DD	$LN145@xhtmlNodeD
	DD	$LN147@xhtmlNodeD
	DD	$LN151@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN153@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN155@xhtmlNodeD
	DD	$LN157@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN161@xhtmlNodeD
	DD	$LN163@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN51@xhtmlNodeD
	DD	$LN165@xhtmlNodeD
_xhtmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveClearEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSaveClearEncoding PROC				; COMDAT

; 580  : static int xmlSaveClearEncoding(xmlSaveCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	esi, DWORD PTR [eax+24]
	push	esi
	call	_xmlOutputBufferFlush
	push	DWORD PTR [esi+12]
	call	_xmlCharEncCloseFunc
	push	DWORD PTR [esi+20]
	call	_xmlBufFree
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], 0
	xor	eax, eax
	pop	esi

; 581  :     xmlOutputBufferPtr buf = ctxt->buf;
; 582  :     xmlOutputBufferFlush(buf);
; 583  :     xmlCharEncCloseFunc(buf->encoder);
; 584  :     xmlBufFree(buf->conv);
; 585  :     buf->encoder = NULL;
; 586  :     buf->conv = NULL;
; 587  :     return(0);
; 588  : }

	pop	ebp
	ret	0
_xmlSaveClearEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSwitchEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_encoding$ = 12						; size = 4
_xmlSaveSwitchEncoding PROC				; COMDAT

; 556  : static int xmlSaveSwitchEncoding(xmlSaveCtxtPtr ctxt, const char *encoding) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	edi, DWORD PTR _encoding$[ebp]
	mov	esi, DWORD PTR [eax+24]
	test	edi, edi
	je	SHORT $LN2@xmlSaveSwi

; 557  :     xmlOutputBufferPtr buf = ctxt->buf;
; 558  : 
; 559  :     if ((encoding != NULL) && (buf->encoder == NULL) && (buf->conv == NULL)) {

	cmp	DWORD PTR [esi+12], 0
	jne	SHORT $LN2@xmlSaveSwi
	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN2@xmlSaveSwi

; 560  : 	buf->encoder = xmlFindCharEncodingHandler((const char *)encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 561  : 	if (buf->encoder == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSaveSwi

; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 562  : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL,
; 563  : 		       (const char *)encoding);
; 564  : 	    return(-1);

	or	eax, -1
	pop	edi

; 578  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSaveSwi:

; 565  : 	}
; 566  : 	buf->conv = xmlBufCreate();

	call	_xmlBufCreate
	mov	DWORD PTR [esi+20], eax

; 567  : 	if (buf->conv == NULL) {

	test	eax, eax
	jne	SHORT $LN4@xmlSaveSwi

; 568  : 	    xmlCharEncCloseFunc(buf->encoder);

	push	DWORD PTR [esi+12]
	call	_xmlCharEncCloseFunc

; 569  : 	    xmlSaveErrMemory("creating encoding buffer");

	push	OFFSET ??_C@_0BJ@ICFHKFLM@creating?5encoding?5buffer@
	call	_xmlSaveErrMemory
	add	esp, 8

; 570  : 	    return(-1);

	or	eax, -1
	pop	edi

; 578  : }

	pop	esi
	pop	ebp
	ret	0
$LN4@xmlSaveSwi:

; 571  : 	}
; 572  : 	/*
; 573  : 	 * initialize the state, e.g. if outputting a BOM
; 574  : 	 */
; 575  :         xmlCharEncOutput(buf, 1);

	push	1
	push	esi
	call	_xmlCharEncOutput
	add	esp, 8
$LN2@xmlSaveSwi:

; 576  :     }
; 577  :     return(0);

	pop	edi
	xor	eax, eax

; 578  : }

	pop	esi
	pop	ebp
	ret	0
_xmlSaveSwitchEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrSerializeContent
_TEXT	SEGMENT
_tmp$1 = -24						; size = 12
_children$1$ = -12					; size = 4
_l$1$ = -8						; size = 4
_doc$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlAttrSerializeContent PROC				; COMDAT

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _attr$[ebp]
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR _children$1$[ebp], ebx
	test	ebx, ebx
	je	$LN3@xmlAttrSer
	push	esi
	push	edi
$LL2@xmlAttrSer:

; 437  :     xmlNodePtr children;
; 438  : 
; 439  :     children = attr->children;
; 440  :     while (children != NULL) {
; 441  :         switch (children->type) {

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, 3
	je	SHORT $LN6@xmlAttrSer
	sub	eax, 2
	jne	$LN48@xmlAttrSer

; 444  : 		                              attr, children->content);
; 445  : 		break;
; 446  :             case XML_ENTITY_REF_NODE:
; 447  :                 xmlBufAdd(buf->buffer, BAD_CAST "&", 1);

	mov	esi, DWORD PTR _buf$[ebp]
	push	1
	push	OFFSET ??_C@_01HNPIGOCE@?$CG@
	push	DWORD PTR [esi+16]
	call	_xmlBufAdd

; 448  :                 xmlBufAdd(buf->buffer, children->name,

	push	DWORD PTR [ebx+8]
	call	_xmlStrlen
	push	eax
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [esi+16]
	call	_xmlBufAdd

; 449  :                              xmlStrlen(children->name));
; 450  :                 xmlBufAdd(buf->buffer, BAD_CAST ";", 1);

	push	1
	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	DWORD PTR [esi+16]
	call	_xmlBufAdd
	add	esp, 40					; 00000028H

; 451  :                 break;

	jmp	$LN78@xmlAttrSer
$LN6@xmlAttrSer:

; 442  :             case XML_TEXT_NODE:
; 443  : 	        xmlBufAttrSerializeTxtContent(buf->buffer, attr->doc,

	mov	eax, DWORD PTR _buf$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _doc$1$[ebp], edx
	mov	edi, DWORD PTR [eax+16]

; 2051 :     if (string == NULL)

	test	esi, esi
	je	$LN48@xmlAttrSer

; 2052 :         return;
; 2053 :     base = cur = (xmlChar *) string;
; 2054 :     while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	mov	ecx, esi
	test	al, al
	je	$LN78@xmlAttrSer
$LL11@xmlAttrSer:

; 2055 :         if (*cur == '\n') {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN14@xmlAttrSer

; 2056 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN16@xmlAttrSer

; 2057 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN16@xmlAttrSer:

; 2058 :             xmlBufAdd(buf, BAD_CAST "&#10;", 5);

	push	5
	push	OFFSET ??_C@_05EJOHHIMP@?$CG?$CD10?$DL@
	push	edi
	call	_xmlBufAdd

; 2059 :             cur++;
; 2060 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN14@xmlAttrSer:

; 2061 :         } else if (*cur == '\r') {

	cmp	al, 13					; 0000000dH
	jne	SHORT $LN17@xmlAttrSer

; 2062 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN19@xmlAttrSer

; 2063 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN19@xmlAttrSer:

; 2064 :             xmlBufAdd(buf, BAD_CAST "&#13;", 5);

	push	5
	push	OFFSET ??_C@_05ELKBMGJG@?$CG?$CD13?$DL@
	push	edi
	call	_xmlBufAdd

; 2065 :             cur++;
; 2066 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN17@xmlAttrSer:

; 2067 :         } else if (*cur == '\t') {

	cmp	al, 9
	jne	SHORT $LN20@xmlAttrSer

; 2068 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN22@xmlAttrSer

; 2069 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN22@xmlAttrSer:

; 2070 :             xmlBufAdd(buf, BAD_CAST "&#9;", 4);

	push	4
	push	OFFSET ??_C@_04NCNDODLB@?$CG?$CD9?$DL@
	push	edi
	call	_xmlBufAdd

; 2071 :             cur++;
; 2072 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN20@xmlAttrSer:

; 2073 :         } else if (*cur == '"') {

	cmp	al, 34					; 00000022H
	jne	SHORT $LN23@xmlAttrSer

; 2074 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN25@xmlAttrSer

; 2075 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN25@xmlAttrSer:

; 2076 :             xmlBufAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	push	edi
	call	_xmlBufAdd

; 2077 :             cur++;
; 2078 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN23@xmlAttrSer:

; 2079 :         } else if (*cur == '<') {

	cmp	al, 60					; 0000003cH
	jne	SHORT $LN26@xmlAttrSer

; 2080 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN28@xmlAttrSer

; 2081 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN28@xmlAttrSer:

; 2082 :             xmlBufAdd(buf, BAD_CAST "&lt;", 4);

	push	4
	push	OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL@
	push	edi
	call	_xmlBufAdd

; 2083 :             cur++;
; 2084 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN26@xmlAttrSer:

; 2085 :         } else if (*cur == '>') {

	cmp	al, 62					; 0000003eH
	jne	SHORT $LN29@xmlAttrSer

; 2086 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN31@xmlAttrSer

; 2087 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN31@xmlAttrSer:

; 2088 :             xmlBufAdd(buf, BAD_CAST "&gt;", 4);

	push	4
	push	OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL@
	push	edi
	call	_xmlBufAdd

; 2089 :             cur++;
; 2090 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN29@xmlAttrSer:

; 2091 :         } else if (*cur == '&') {

	cmp	al, 38					; 00000026H
	jne	SHORT $LN32@xmlAttrSer

; 2092 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN74@xmlAttrSer

; 2093 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN74@xmlAttrSer:

; 2094 :             xmlBufAdd(buf, BAD_CAST "&amp;", 5);

	push	5
	push	OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL@
	push	edi
	call	_xmlBufAdd

; 2095 :             cur++;
; 2096 :             base = cur;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN32@xmlAttrSer:

; 2097 :         } else if ((*cur >= 0x80) && (cur[1] != 0) &&

	cmp	al, 128					; 00000080H
	jb	$LN35@xmlAttrSer
	cmp	BYTE PTR [esi+1], 0
	je	$LN35@xmlAttrSer
	test	edx, edx
	je	SHORT $LN37@xmlAttrSer
	cmp	DWORD PTR [edx+60], 0
	jne	$LN35@xmlAttrSer
$LN37@xmlAttrSer:

; 2098 : 	           ((doc == NULL) || (doc->encoding == NULL))) {
; 2099 :             /*
; 2100 :              * We assume we have UTF-8 content.
; 2101 :              */
; 2102 :             unsigned char tmp[12];
; 2103 :             int val = 0, l = 1;
; 2104 : 
; 2105 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN75@xmlAttrSer

; 2106 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	mov	al, BYTE PTR [esi]
	add	esp, 12					; 0000000cH
$LN75@xmlAttrSer:

; 2107 :             if (*cur < 0xC0) {

	cmp	al, 192					; 000000c0H
	jae	SHORT $LN39@xmlAttrSer

; 2108 :                 xmlSaveErr(XML_SAVE_NOT_UTF8, (xmlNodePtr) attr, NULL);

	push	0
	push	DWORD PTR _attr$[ebp]
	push	1400					; 00000578H
	call	_xmlSaveErr

; 2109 : 		xmlSerializeHexCharRef(tmp, *cur);

	movzx	eax, BYTE PTR [esi]
	push	eax
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2110 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd

; 2111 :                 cur++;
; 2112 :                 base = cur;
; 2113 :                 continue;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 32					; 00000020H
	inc	esi
	mov	ecx, esi
	jmp	$LN36@xmlAttrSer
$LN39@xmlAttrSer:

; 2114 :             } else if (*cur < 0xE0) {

	cmp	al, 224					; 000000e0H
	jae	SHORT $LN41@xmlAttrSer

; 2115 :                 val = (cur[0]) & 0x1F;
; 2116 :                 val <<= 6;
; 2117 :                 val |= (cur[1]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 31					; 0000001fH

; 2118 :                 l = 2;

	mov	DWORD PTR _l$1$[ebp], 2
	jmp	SHORT $LN79@xmlAttrSer
$LN41@xmlAttrSer:

; 2119 :             } else if ((*cur < 0xF0) && (cur [2] != 0)) {

	cmp	al, 240					; 000000f0H
	jae	SHORT $LN76@xmlAttrSer
	mov	dl, BYTE PTR [esi+2]
	test	dl, dl
	je	SHORT $LN76@xmlAttrSer

; 2120 :                 val = (cur[0]) & 0x0F;
; 2121 :                 val <<= 6;
; 2122 :                 val |= (cur[1]) & 0x3F;
; 2123 :                 val <<= 6;
; 2124 :                 val |= (cur[2]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax

; 2125 :                 l = 3;

	mov	DWORD PTR _l$1$[ebp], 3
	movzx	eax, dl
	jmp	SHORT $LN79@xmlAttrSer
$LN76@xmlAttrSer:

; 2126 :             } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {

	cmp	al, 248					; 000000f8H
	jae	SHORT $LN69@xmlAttrSer
	mov	dl, BYTE PTR [esi+2]
	test	dl, dl
	je	SHORT $LN69@xmlAttrSer
	mov	dh, BYTE PTR [esi+3]
	test	dh, dh
	je	SHORT $LN69@xmlAttrSer

; 2127 :                 val = (cur[0]) & 0x07;
; 2128 :                 val <<= 6;
; 2129 :                 val |= (cur[1]) & 0x3F;
; 2130 :                 val <<= 6;
; 2131 :                 val |= (cur[2]) & 0x3F;
; 2132 :                 val <<= 6;
; 2133 :                 val |= (cur[3]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 7
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax

; 2134 :                 l = 4;

	mov	DWORD PTR _l$1$[ebp], 4
	movzx	eax, dl
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, dh
$LN79@xmlAttrSer:

; 2135 :             }
; 2136 :             if ((l == 1) || (!IS_CHAR(val))) {

	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN58@xmlAttrSer
	cmp	ecx, 9
	jb	SHORT $LN50@xmlAttrSer
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN73@xmlAttrSer
$LN50@xmlAttrSer:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN73@xmlAttrSer
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN73@xmlAttrSer
$LN69@xmlAttrSer:

; 2137 :                 xmlSaveErr(XML_SAVE_CHAR_INVALID, (xmlNodePtr) attr, NULL);

	push	0
	push	DWORD PTR _attr$[ebp]
	push	1401					; 00000579H
	call	_xmlSaveErr

; 2138 : 		xmlSerializeHexCharRef(tmp, *cur);

	movzx	eax, BYTE PTR [esi]
	push	eax
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2139 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd

; 2140 :                 cur++;
; 2141 :                 base = cur;
; 2142 :                 continue;

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 32					; 00000020H
	inc	esi
	mov	ecx, esi
	jmp	SHORT $LN36@xmlAttrSer
$LN58@xmlAttrSer:

; 2135 :             }
; 2136 :             if ((l == 1) || (!IS_CHAR(val))) {

	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN73@xmlAttrSer
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN53@xmlAttrSer
	cmp	ecx, 65533				; 0000fffdH
	jbe	SHORT $LN73@xmlAttrSer
$LN53@xmlAttrSer:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN69@xmlAttrSer
$LN73@xmlAttrSer:

; 2143 :             }
; 2144 :             /*
; 2145 :              * We could do multiple things here. Just save
; 2146 :              * as a char ref
; 2147 :              */
; 2148 : 	    xmlSerializeHexCharRef(tmp, val);

	push	ecx
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2149 :             xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd

; 2150 :             cur += l;
; 2151 :             base = cur;
; 2152 :         } else {

	mov	edx, DWORD PTR _doc$1$[ebp]
	add	esp, 20					; 00000014H
	add	esi, DWORD PTR _l$1$[ebp]
	mov	ecx, esi
	jmp	SHORT $LN36@xmlAttrSer
$LN35@xmlAttrSer:

; 2153 :             cur++;

	inc	esi
$LN36@xmlAttrSer:

; 2052 :         return;
; 2053 :     base = cur = (xmlChar *) string;
; 2054 :     while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	test	al, al
	jne	$LL11@xmlAttrSer

; 2154 :         }
; 2155 :     }
; 2156 :     if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN77@xmlAttrSer

; 2157 :         xmlBufAdd(buf, base, cur - base);

	sub	esi, ecx
	push	esi
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN77@xmlAttrSer:

; 452  :             default:
; 453  :                 /* should not happen unless we have a badly built tree */
; 454  :                 break;
; 455  :         }
; 456  :         children = children->next;

	mov	ebx, DWORD PTR _children$1$[ebp]
$LN78@xmlAttrSer:
	mov	ecx, DWORD PTR _attr$[ebp]
$LN48@xmlAttrSer:
	mov	ebx, DWORD PTR [ebx+24]
	mov	DWORD PTR _children$1$[ebp], ebx
	test	ebx, ebx
	jne	$LL2@xmlAttrSer
	pop	edi
	pop	esi
$LN3@xmlAttrSer:
	pop	ebx

; 457  :     }
; 458  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAttrSerializeContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNewSaveCtxt
_TEXT	SEGMENT
_encoding$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlNewSaveCtxt PROC					; COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	124					; 0000007cH
	call	DWORD PTR _xmlMalloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	jne	SHORT $LN2@xmlNewSave

; 111  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BI@FGAKHCKD@creating?5saving?5context@
	push	eax
	push	eax
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 382  :     xmlSaveCtxtPtr ret;
; 383  : 
; 384  :     ret = (xmlSaveCtxtPtr) xmlMalloc(sizeof(xmlSaveCtxt));
; 385  :     if (ret == NULL) {
; 386  : 	xmlSaveErrMemory("creating saving context");
; 387  : 	return ( NULL );

	xor	eax, eax
	pop	esi

; 419  : }

	pop	ebp
	ret	0
$LN2@xmlNewSave:
	push	edi

; 388  :     }
; 389  :     memset(ret, 0, sizeof(xmlSaveCtxt));

	push	124					; 0000007cH
	push	0
	push	esi
	call	_memset

; 390  : 
; 391  :     if (encoding != NULL) {

	mov	edi, DWORD PTR _encoding$[ebp]
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN3@xmlNewSave

; 392  :         ret->handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 393  : 	if (ret->handler == NULL) {

	push	edi
	test	eax, eax
	jne	SHORT $LN4@xmlNewSave

; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError

; 394  : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);
; 395  :             xmlFreeSaveCtxt(ret);

	push	esi
	call	_xmlFreeSaveCtxt
	add	esp, 24					; 00000018H

; 396  : 	    return(NULL);

	xor	eax, eax
	pop	edi
	pop	esi

; 419  : }

	pop	ebp
	ret	0
$LN4@xmlNewSave:

; 397  : 	}
; 398  :         ret->encoding = xmlStrdup((const xmlChar *)encoding);

	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR [esi+16], eax

; 399  : 	ret->escape = NULL;

	mov	DWORD PTR [esi+116], 0
$LN3@xmlNewSave:

; 400  :     }
; 401  :     xmlSaveCtxtInit(ret);

	push	esi
	call	_xmlSaveCtxtInit

; 402  : 
; 403  :     /*
; 404  :      * Use the options
; 405  :      */
; 406  : 
; 407  :     /* Re-check this option as it may already have been set */
; 408  :     if ((ret->options & XML_SAVE_NO_EMPTY) && ! (options & XML_SAVE_NO_EMPTY)) {

	mov	eax, DWORD PTR _options$[ebp]
	add	esp, 4
	test	BYTE PTR [esi+32], 4
	je	SHORT $LN5@xmlNewSave
	test	al, 4
	jne	SHORT $LN5@xmlNewSave

; 409  : 	options |= XML_SAVE_NO_EMPTY;

	or	eax, 4
$LN5@xmlNewSave:

; 410  :     }
; 411  : 
; 412  :     ret->options = options;

	mov	DWORD PTR [esi+32], eax

; 413  :     if (options & XML_SAVE_FORMAT)

	test	al, 1
	je	SHORT $LN6@xmlNewSave

; 414  :         ret->format = 1;

	pop	edi
	mov	DWORD PTR [esi+40], 1

; 417  : 
; 418  :     return(ret);

	mov	eax, esi
	pop	esi

; 419  : }

	pop	ebp
	ret	0
$LN6@xmlNewSave:

; 415  :     else if (options & XML_SAVE_WSNONSIG)

	test	al, al
	jns	SHORT $LN8@xmlNewSave

; 416  :         ret->format = 2;

	mov	DWORD PTR [esi+40], 2
$LN8@xmlNewSave:
	pop	edi

; 417  : 
; 418  :     return(ret);

	mov	eax, esi
	pop	esi

; 419  : }

	pop	ebp
	ret	0
_xmlNewSaveCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlFreeSaveCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlFreeSaveCtxt PROC					; COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	je	SHORT $LN1@xmlFreeSav

; 364  :     if (ctxt == NULL) return;
; 365  :     if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN3@xmlFreeSav

; 366  :         xmlFree((char *) ctxt->encoding);

	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN3@xmlFreeSav:

; 367  :     if (ctxt->buf != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN4@xmlFreeSav

; 368  :         xmlOutputBufferClose(ctxt->buf);

	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
$LN4@xmlFreeSav:

; 369  :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN1@xmlFreeSav:
	pop	esi

; 370  : }

	pop	ebp
	ret	0
_xmlFreeSaveCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveCtxtInit
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSaveCtxtInit PROC					; COMDAT

; 332  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _ctxt$[ebp]
	test	edi, edi
	je	$LN10@xmlSaveCtx

; 333  :     int i;
; 334  :     int len;
; 335  : 
; 336  :     if (ctxt == NULL) return;
; 337  :     if ((ctxt->encoding == NULL) && (ctxt->escape == NULL))

	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN6@xmlSaveCtx
	cmp	DWORD PTR [edi+116], 0
	jne	SHORT $LN6@xmlSaveCtx

; 338  :         ctxt->escape = xmlEscapeEntities;

	mov	DWORD PTR [edi+116], OFFSET _xmlEscapeEntities
$LN6@xmlSaveCtx:
	push	esi

; 339  :     len = xmlStrlen((xmlChar *)xmlTreeIndentString);

	call	___xmlTreeIndentString
	push	DWORD PTR [eax]
	call	_xmlStrlen
	add	esp, 4
	mov	esi, eax

; 340  :     if ((xmlTreeIndentString == NULL) || (len == 0)) {

	call	___xmlTreeIndentString
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlSaveCtx
	test	esi, esi
	je	SHORT $LN9@xmlSaveCtx

; 342  :     } else {
; 343  : 	ctxt->indent_size = len;
; 344  : 	ctxt->indent_nr = MAX_INDENT / ctxt->indent_size;

	mov	eax, 60					; 0000003cH
	mov	DWORD PTR [edi+112], esi
	cdq
	idiv	esi
	push	ebx

; 345  : 	for (i = 0;i < ctxt->indent_nr;i++)

	xor	ebx, ebx
	mov	DWORD PTR [edi+108], eax
	test	eax, eax
	jle	SHORT $LN15@xmlSaveCtx
$LL4@xmlSaveCtx:

; 346  : 	    memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,

	mov	esi, DWORD PTR [edi+112]
	call	___xmlTreeIndentString
	push	esi
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+112]
	imul	eax, ebx
	add	eax, 44					; 0000002cH
	add	eax, edi
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR [edi+108]
	inc	ebx
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	jl	SHORT $LL4@xmlSaveCtx
	mov	esi, DWORD PTR [edi+112]
$LN15@xmlSaveCtx:

; 347  : 		   ctxt->indent_size);
; 348  :         ctxt->indent[ctxt->indent_nr * ctxt->indent_size] = 0;

	imul	eax, esi
	pop	ebx
	mov	BYTE PTR [eax+edi+44], 0
	jmp	SHORT $LN8@xmlSaveCtx
$LN9@xmlSaveCtx:

; 341  :         memset(&ctxt->indent[0], 0, MAX_INDENT + 1);

	push	61					; 0000003dH
	lea	eax, DWORD PTR [edi+44]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@xmlSaveCtx:

; 349  :     }
; 350  : 
; 351  :     if (xmlSaveNoEmptyTags) {

	call	___xmlSaveNoEmptyTags
	pop	esi
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@xmlSaveCtx

; 352  : 	ctxt->options |= XML_SAVE_NO_EMPTY;

	or	DWORD PTR [edi+32], 4
$LN10@xmlSaveCtx:
	pop	edi

; 353  :     }
; 354  : }

	pop	ebp
	ret	0
_xmlSaveCtxtInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlEscapeEntities
_TEXT	SEGMENT
_inend$1$ = -12						; size = 4
_outend$1$ = -8						; size = 4
_outstart$1$ = -4					; size = 4
$T1 = 8							; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_base$1$ = 16						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_xmlEscapeEntities PROC					; COMDAT

; 209  :                  const xmlChar* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	ebx, DWORD PTR _in$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$1$[ebp], esi
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _inlen$[ebp]
	add	edx, esi
	mov	DWORD PTR _base$1$[ebp], ebx
	mov	DWORD PTR _outend$1$[ebp], edx
	mov	edi, DWORD PTR [eax]
	add	edi, ebx
	mov	DWORD PTR _inend$1$[ebp], edi
	cmp	ebx, edi
	jae	$LN69@xmlEscapeE
	npad	5
$LL2@xmlEscapeE:

; 210  :     unsigned char* outstart = out;
; 211  :     const unsigned char* base = in;
; 212  :     unsigned char* outend = out + *outlen;
; 213  :     const unsigned char* inend;
; 214  :     int val;
; 215  : 
; 216  :     inend = in + (*inlen);
; 217  : 
; 218  :     while ((in < inend) && (out < outend)) {

	cmp	esi, edx
	jae	$LN69@xmlEscapeE

; 219  : 	if (*in == '<') {

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 60					; 0000003cH
	jne	SHORT $LN4@xmlEscapeE

; 220  : 	    if (outend - out < 4) break;

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 4
	jl	$LN69@xmlEscapeE

; 221  : 	    *out++ = '&';

	mov	DWORD PTR [esi], 997485606		; 3b746c26H

; 222  : 	    *out++ = 'l';
; 223  : 	    *out++ = 't';
; 224  : 	    *out++ = ';';

	add	esi, 4

; 225  : 	    in++;
; 226  : 	    continue;

	jmp	$LN70@xmlEscapeE
$LN4@xmlEscapeE:

; 227  : 	} else if (*in == '>') {

	cmp	cl, 62					; 0000003eH
	jne	SHORT $LN7@xmlEscapeE

; 228  : 	    if (outend - out < 4) break;

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 4
	jl	$LN69@xmlEscapeE

; 229  : 	    *out++ = '&';

	mov	DWORD PTR [esi], 997484326		; 3b746726H

; 230  : 	    *out++ = 'g';
; 231  : 	    *out++ = 't';
; 232  : 	    *out++ = ';';

	add	esi, 4

; 233  : 	    in++;
; 234  : 	    continue;

	jmp	$LN70@xmlEscapeE
$LN7@xmlEscapeE:

; 235  : 	} else if (*in == '&') {

	cmp	cl, 38					; 00000026H
	jne	SHORT $LN10@xmlEscapeE

; 236  : 	    if (outend - out < 5) break;

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 5
	jl	$LN69@xmlEscapeE

; 237  : 	    *out++ = '&';

	mov	DWORD PTR [esi], 1886216486		; 706d6126H

; 238  : 	    *out++ = 'a';
; 239  : 	    *out++ = 'm';
; 240  : 	    *out++ = 'p';
; 241  : 	    *out++ = ';';

	mov	BYTE PTR [esi+4], 59			; 0000003bH
	add	esi, 5

; 242  : 	    in++;
; 243  : 	    continue;

	jmp	$LN70@xmlEscapeE
$LN10@xmlEscapeE:

; 244  : 	} else if (((*in >= 0x20) && (*in < 0x80)) ||
; 245  : 	           (*in == '\n') || (*in == '\t')) {

	cmp	cl, 32					; 00000020H
	jb	SHORT $LN16@xmlEscapeE
	cmp	cl, 128					; 00000080H
	jb	$LN15@xmlEscapeE
$LN16@xmlEscapeE:
	cmp	cl, 10					; 0000000aH
	je	$LN15@xmlEscapeE
	cmp	cl, 9
	je	$LN15@xmlEscapeE

; 250  : 	    continue;
; 251  : 	} else if (*in >= 0x80) {

	cmp	cl, 128					; 00000080H
	jb	$LN17@xmlEscapeE

; 252  : 	    /*
; 253  : 	     * We assume we have UTF-8 input.
; 254  : 	     */
; 255  : 	    if (outend - out < 11) break;

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 11					; 0000000bH
	jl	$LN69@xmlEscapeE

; 256  : 
; 257  : 	    if (*in < 0xC0) {

	cmp	cl, 192					; 000000c0H
	jb	$LN57@xmlEscapeE

; 261  : 	    } else if (*in < 0xE0) {

	cmp	cl, 224					; 000000e0H
	jae	SHORT $LN22@xmlEscapeE

; 262  : 		if (inend - in < 2) break;

	mov	eax, edi
	sub	eax, ebx
	cmp	eax, 2
	jl	$LN69@xmlEscapeE

; 263  : 		val = (in[0]) & 0x1F;
; 264  : 		val <<= 6;
; 265  : 		val |= (in[1]) & 0x3F;

	movzx	eax, BYTE PTR [ebx+1]

; 266  : 		in += 2;

	mov	edi, 2
	movzx	ecx, cl
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR $T1[ebp], 3
	jmp	SHORT $LN71@xmlEscapeE
$LN22@xmlEscapeE:

; 267  : 	    } else if (*in < 0xF0) {

	cmp	cl, 240					; 000000f0H
	jae	SHORT $LN25@xmlEscapeE

; 268  : 		if (inend - in < 3) break;

	mov	eax, edi
	sub	eax, ebx
	cmp	eax, 3
	jl	$LN69@xmlEscapeE

; 269  : 		val = (in[0]) & 0x0F;
; 270  : 		val <<= 6;
; 271  : 		val |= (in[1]) & 0x3F;
; 272  : 		val <<= 6;
; 273  : 		val |= (in[2]) & 0x3F;

	movzx	eax, BYTE PTR [ebx+1]

; 274  : 		in += 3;

	mov	edi, 3
	movzx	ecx, cl
	and	eax, 63					; 0000003fH
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR $T1[ebp], 4
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [ebx+2]
	jmp	SHORT $LN71@xmlEscapeE
$LN25@xmlEscapeE:

; 275  : 	    } else if (*in < 0xF8) {

	cmp	cl, 248					; 000000f8H
	jae	$LN28@xmlEscapeE

; 276  : 		if (inend - in < 4) break;

	mov	eax, edi
	sub	eax, ebx
	cmp	eax, 4
	jl	$LN69@xmlEscapeE

; 277  : 		val = (in[0]) & 0x07;
; 278  : 		val <<= 6;
; 279  : 		val |= (in[1]) & 0x3F;
; 280  : 		val <<= 6;
; 281  : 		val |= (in[2]) & 0x3F;
; 282  : 		val <<= 6;
; 283  : 		val |= (in[3]) & 0x3F;

	movzx	eax, BYTE PTR [ebx+1]

; 284  : 		in += 4;

	mov	edi, 4
	movzx	ecx, cl
	and	eax, 63					; 0000003fH
	and	ecx, 7
	mov	DWORD PTR $T1[ebp], 5
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [ebx+2]
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, BYTE PTR [ebx+3]
$LN71@xmlEscapeE:

; 289  : 	    }
; 290  : 	    if (!IS_CHAR(val)) {

	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN46@xmlEscapeE
	cmp	ecx, 9
	jb	SHORT $LN38@xmlEscapeE
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN33@xmlEscapeE
$LN38@xmlEscapeE:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN33@xmlEscapeE
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN33@xmlEscapeE
$LN61@xmlEscapeE:

; 291  : 		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);

	push	0
	push	0
	push	1401					; 00000579H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 292  : 		in++;

	add	ebx, DWORD PTR $T1[ebp]

; 293  : 		goto error;

	jmp	$error$74
$LN46@xmlEscapeE:

; 289  : 	    }
; 290  : 	    if (!IS_CHAR(val)) {

	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN33@xmlEscapeE
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN41@xmlEscapeE
	cmp	ecx, 65533				; 0000fffdH
	jbe	SHORT $LN33@xmlEscapeE
$LN41@xmlEscapeE:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN61@xmlEscapeE

; 305  : 		"xmlEscapeEntities : char out of range\n");
; 306  : 	    in++;
; 307  : 	    goto error;
; 308  : 	}
; 309  :     }

	push	ecx
	push	esi
	call	_xmlSerializeHexCharRef
	mov	edx, DWORD PTR _outend$1$[ebp]
	add	esp, 8
	mov	esi, eax
	jmp	SHORT $LN63@xmlEscapeE
$LN17@xmlEscapeE:

; 294  : 	    }
; 295  : 
; 296  : 	    /*
; 297  : 	     * We could do multiple things here. Just save as a char ref
; 298  : 	     */
; 299  : 	    out = xmlSerializeHexCharRef(out, val);
; 300  : 	} else if (IS_BYTE_CHAR(*in)) {

	cmp	cl, 9
	jb	SHORT $LN35@xmlEscapeE
	cmp	cl, 10					; 0000000aH
	jbe	SHORT $LN34@xmlEscapeE
$LN35@xmlEscapeE:
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN34@xmlEscapeE
	cmp	cl, 32					; 00000020H
	jb	SHORT $LN32@xmlEscapeE
$LN34@xmlEscapeE:

; 301  : 	    if (outend - out < 6) break;

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 6
	jl	SHORT $LN69@xmlEscapeE

; 302  : 	    out = xmlSerializeHexCharRef(out, *in++);

	movzx	ecx, cl
	mov	edi, 1
$LN33@xmlEscapeE:

; 305  : 		"xmlEscapeEntities : char out of range\n");
; 306  : 	    in++;
; 307  : 	    goto error;
; 308  : 	}
; 309  :     }

	push	ecx
	push	esi
	call	_xmlSerializeHexCharRef
	mov	edx, DWORD PTR _outend$1$[ebp]
	add	esp, 8
	mov	esi, eax
	jmp	SHORT $LN63@xmlEscapeE
$LN15@xmlEscapeE:

; 246  : 	    /*
; 247  : 	     * default case, just copy !
; 248  : 	     */
; 249  : 	    *out++ = *in++;

	mov	BYTE PTR [esi], cl
	inc	esi
$LN70@xmlEscapeE:

; 210  :     unsigned char* outstart = out;
; 211  :     const unsigned char* base = in;
; 212  :     unsigned char* outend = out + *outlen;
; 213  :     const unsigned char* inend;
; 214  :     int val;
; 215  : 
; 216  :     inend = in + (*inlen);
; 217  : 
; 218  :     while ((in < inend) && (out < outend)) {

	mov	edi, 1
$LN63@xmlEscapeE:
	add	ebx, edi
	mov	edi, DWORD PTR _inend$1$[ebp]
	cmp	ebx, edi
	jb	$LL2@xmlEscapeE
$LN69@xmlEscapeE:

; 310  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _outlen$[ebp]
	sub	esi, DWORD PTR _outstart$1$[ebp]

; 311  :     *inlen = in - base;

	sub	ebx, DWORD PTR _base$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR _inlen$[ebp]

; 316  :     return(-1);
; 317  : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@xmlEscapeE:

; 285  : 	    } else {
; 286  : 		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);

	push	0
	push	0
	push	1401					; 00000579H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 287  : 		in++;
; 288  : 		goto error;

	jmp	SHORT $LN72@xmlEscapeE
$LN57@xmlEscapeE:

; 258  : 		xmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);

	push	0
	push	0
	push	1400					; 00000578H
	call	_xmlSaveErr
	add	esp, 12					; 0000000cH

; 259  : 		in++;
; 260  : 		goto error;

	jmp	SHORT $LN72@xmlEscapeE
$LN32@xmlEscapeE:

; 303  : 	} else {
; 304  : 	    xmlGenericError(xmlGenericErrorContext,

	call	___xmlGenericError
	mov	edi, eax
	call	___xmlGenericErrorContext
	push	OFFSET ??_C@_0CH@EAFIMPAL@xmlEscapeEntities?5?3?5char?5out?5of@
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	call	eax
	add	esp, 8
$LN72@xmlEscapeE:

; 312  :     return(0);
; 313  : error:
; 314  :     *outlen = out - outstart;

	inc	ebx
$error$74:
	mov	eax, DWORD PTR _outlen$[ebp]
	sub	esi, DWORD PTR _outstart$1$[ebp]

; 315  :     *inlen = in - base;

	sub	ebx, DWORD PTR _base$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR _inlen$[ebp]

; 316  :     return(-1);
; 317  : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEscapeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSerializeHexCharRef
_TEXT	SEGMENT
_out$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlSerializeHexCharRef PROC				; COMDAT

; 152  : xmlSerializeHexCharRef(unsigned char *out, int val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	WORD PTR [ecx], 8998			; 00002326H
	mov	BYTE PTR [ecx+2], 120			; 00000078H
	add	ecx, 3
	cmp	edx, 16					; 00000010H
	jl	SHORT $LN15@xmlSeriali

; 153  :     unsigned char *ptr;
; 154  : 
; 155  :     *out++ = '&';
; 156  :     *out++ = '#';
; 157  :     *out++ = 'x';
; 158  :     if (val < 0x10) ptr = out;
; 159  :     else if (val < 0x100) ptr = out + 1;

	cmp	edx, 256				; 00000100H
	jge	SHORT $LN8@xmlSeriali
	inc	ecx
	jmp	SHORT $LN15@xmlSeriali
$LN8@xmlSeriali:

; 160  :     else if (val < 0x1000) ptr = out + 2;

	cmp	edx, 4096				; 00001000H
	jge	SHORT $LN10@xmlSeriali
	add	ecx, 2
	jmp	SHORT $LN15@xmlSeriali
$LN10@xmlSeriali:

; 161  :     else if (val < 0x10000) ptr = out + 3;

	cmp	edx, 65536				; 00010000H
	jge	SHORT $LN12@xmlSeriali
	add	ecx, 3
	jmp	SHORT $LN15@xmlSeriali
$LN12@xmlSeriali:

; 162  :     else if (val < 0x100000) ptr = out + 4;

	cmp	edx, 1048576				; 00100000H
	jge	SHORT $LN14@xmlSeriali
	add	ecx, 4
	jmp	SHORT $LN15@xmlSeriali
$LN14@xmlSeriali:

; 163  :     else ptr = out + 5;

	add	ecx, 5
$LN15@xmlSeriali:
	push	esi

; 164  :     out = ptr + 1;

	lea	esi, DWORD PTR [ecx+1]

; 165  :     while (val > 0) {

	test	edx, edx
	jle	SHORT $LN3@xmlSeriali
	push	edi
$LL2@xmlSeriali:

; 166  : 	switch (val & 0xF) {

	mov	eax, edx
	and	eax, 15					; 0000000fH
	jmp	DWORD PTR $LN39@xmlSeriali[eax*4]
$LN17@xmlSeriali:

; 167  : 	    case 0: *ptr-- = '0'; break;
; 168  : 	    case 1: *ptr-- = '1'; break;

	mov	BYTE PTR [ecx], 49			; 00000031H
	jmp	SHORT $LN4@xmlSeriali
$LN18@xmlSeriali:

; 169  : 	    case 2: *ptr-- = '2'; break;

	mov	BYTE PTR [ecx], 50			; 00000032H
	jmp	SHORT $LN4@xmlSeriali
$LN19@xmlSeriali:

; 170  : 	    case 3: *ptr-- = '3'; break;

	mov	BYTE PTR [ecx], 51			; 00000033H
	jmp	SHORT $LN4@xmlSeriali
$LN20@xmlSeriali:

; 171  : 	    case 4: *ptr-- = '4'; break;

	mov	BYTE PTR [ecx], 52			; 00000034H
	jmp	SHORT $LN4@xmlSeriali
$LN21@xmlSeriali:

; 172  : 	    case 5: *ptr-- = '5'; break;

	mov	BYTE PTR [ecx], 53			; 00000035H
	jmp	SHORT $LN4@xmlSeriali
$LN22@xmlSeriali:

; 173  : 	    case 6: *ptr-- = '6'; break;

	mov	BYTE PTR [ecx], 54			; 00000036H
	jmp	SHORT $LN4@xmlSeriali
$LN23@xmlSeriali:

; 174  : 	    case 7: *ptr-- = '7'; break;

	mov	BYTE PTR [ecx], 55			; 00000037H
	jmp	SHORT $LN4@xmlSeriali
$LN24@xmlSeriali:

; 175  : 	    case 8: *ptr-- = '8'; break;

	mov	BYTE PTR [ecx], 56			; 00000038H
	jmp	SHORT $LN4@xmlSeriali
$LN25@xmlSeriali:

; 176  : 	    case 9: *ptr-- = '9'; break;

	mov	BYTE PTR [ecx], 57			; 00000039H
	jmp	SHORT $LN4@xmlSeriali
$LN26@xmlSeriali:

; 177  : 	    case 0xA: *ptr-- = 'A'; break;

	mov	BYTE PTR [ecx], 65			; 00000041H
	jmp	SHORT $LN4@xmlSeriali
$LN27@xmlSeriali:

; 178  : 	    case 0xB: *ptr-- = 'B'; break;

	mov	BYTE PTR [ecx], 66			; 00000042H
	jmp	SHORT $LN4@xmlSeriali
$LN28@xmlSeriali:

; 179  : 	    case 0xC: *ptr-- = 'C'; break;

	mov	BYTE PTR [ecx], 67			; 00000043H
	jmp	SHORT $LN4@xmlSeriali
$LN29@xmlSeriali:

; 180  : 	    case 0xD: *ptr-- = 'D'; break;

	mov	BYTE PTR [ecx], 68			; 00000044H
	jmp	SHORT $LN4@xmlSeriali
$LN30@xmlSeriali:

; 181  : 	    case 0xE: *ptr-- = 'E'; break;

	mov	BYTE PTR [ecx], 69			; 00000045H
	jmp	SHORT $LN4@xmlSeriali
$LN31@xmlSeriali:

; 182  : 	    case 0xF: *ptr-- = 'F'; break;

	mov	BYTE PTR [ecx], 70			; 00000046H
	jmp	SHORT $LN4@xmlSeriali
$LN32@xmlSeriali:

; 183  : 	    default: *ptr-- = '0'; break;
; 184  : 	}
; 185  : 	val >>= 4;

	mov	BYTE PTR [ecx], 48			; 00000030H
$LN4@xmlSeriali:
	sar	edx, 4
	dec	ecx
	test	edx, edx
	jg	SHORT $LL2@xmlSeriali
	pop	edi
$LN3@xmlSeriali:

; 186  :     }
; 187  :     *out++ = ';';

	mov	WORD PTR [esi], 59			; 0000003bH

; 188  :     *out = 0;
; 189  :     return(out);

	lea	eax, DWORD PTR [esi+1]
	pop	esi

; 190  : }

	pop	ebp
	ret	0
$LN39@xmlSeriali:
	DD	$LN32@xmlSeriali
	DD	$LN17@xmlSeriali
	DD	$LN18@xmlSeriali
	DD	$LN19@xmlSeriali
	DD	$LN20@xmlSeriali
	DD	$LN21@xmlSeriali
	DD	$LN22@xmlSeriali
	DD	$LN23@xmlSeriali
	DD	$LN24@xmlSeriali
	DD	$LN25@xmlSeriali
	DD	$LN26@xmlSeriali
	DD	$LN27@xmlSeriali
	DD	$LN28@xmlSeriali
	DD	$LN29@xmlSeriali
	DD	$LN30@xmlSeriali
	DD	$LN31@xmlSeriali
_xmlSerializeHexCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveErr
_TEXT	SEGMENT
_code$ = 8						; size = 4
_node$ = 12						; size = 4
_extra$ = 16						; size = 4
_xmlSaveErr PROC					; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _code$[ebp]
	lea	eax, DWORD PTR [ecx-1400]
	cmp	eax, 3
	ja	SHORT $LN8@xmlSaveErr

; 125  :     const char *msg = NULL;
; 126  : 
; 127  :     switch(code) {

	jmp	DWORD PTR $LN11@xmlSaveErr[eax*4]
$LN4@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";
; 130  : 	    break;
; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";
; 133  : 	    break;
; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";
; 136  : 	    break;
; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";
; 139  : 	    break;
; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";
; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BI@KDLJAAPA@string?5is?5not?5in?5UTF?98?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	pop	ebp
	ret	0
$LN5@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";
; 130  : 	    break;
; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";
; 133  : 	    break;
; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";
; 136  : 	    break;
; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";
; 139  : 	    break;
; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";
; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@HMEJBBPL@invalid?5character?5value?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	pop	ebp
	ret	0
$LN6@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";
; 130  : 	    break;
; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";
; 133  : 	    break;
; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";
; 136  : 	    break;
; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";
; 139  : 	    break;
; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";
; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	pop	ebp
	ret	0
$LN7@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";
; 130  : 	    break;
; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";
; 133  : 	    break;
; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";
; 136  : 	    break;
; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";
; 139  : 	    break;
; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";
; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@OKGKFHLI@document?5has?5no?5DOCTYPE?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	pop	ebp
	ret	0
$LN8@xmlSaveErr:

; 128  :         case XML_SAVE_NOT_UTF8:
; 129  : 	    msg = "string is not in UTF-8\n";
; 130  : 	    break;
; 131  : 	case XML_SAVE_CHAR_INVALID:
; 132  : 	    msg = "invalid character value\n";
; 133  : 	    break;
; 134  : 	case XML_SAVE_UNKNOWN_ENCODING:
; 135  : 	    msg = "unknown encoding %s\n";
; 136  : 	    break;
; 137  : 	case XML_SAVE_NO_DOCTYPE:
; 138  : 	    msg = "document has no DOCTYPE\n";
; 139  : 	    break;
; 140  : 	default:
; 141  : 	    msg = "unexpected error number\n";
; 142  :     }
; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	DWORD PTR _extra$[ebp]
	mov	eax, OFFSET ??_C@_0BJ@IPOHNFHE@unexpected?5error?5number?6@
	push	eax
	push	DWORD PTR _node$[ebp]
	push	ecx
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 144  : }

	pop	ebp
	ret	0
	npad	1
$LN11@xmlSaveErr:
	DD	$LN4@xmlSaveErr
	DD	$LN5@xmlSaveErr
	DD	$LN7@xmlSaveErr
	DD	$LN6@xmlSaveErr
_xmlSaveErr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlSaveErrMemory PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _extra$[ebp]
	push	0
	push	0
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 111  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);
; 112  : }

	pop	ebp
	ret	0
_xmlSaveErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpEntityDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlBufDumpEntityDecl PROC				; COMDAT

; 536  : xmlBufDumpEntityDecl(xmlBufPtr buf, xmlEntityPtr ent) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlBufferCreate
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN1@xmlBufDump

; 537  :     xmlBufferPtr buffer;
; 538  : 
; 539  :     buffer = xmlBufferCreate();
; 540  :     if (buffer == NULL) {
; 541  :         /*
; 542  :          * TODO set the error in buf
; 543  :          */
; 544  :         return;
; 545  :     }
; 546  :     xmlDumpEntityDecl(buffer, ent);

	push	DWORD PTR _ent$[ebp]
	push	esi
	call	_xmlDumpEntityDecl

; 547  :     xmlBufMergeBuffer(buf, buffer);

	push	esi
	push	DWORD PTR _buf$[ebp]
	call	_xmlBufMergeBuffer
	add	esp, 16					; 00000010H
$LN1@xmlBufDump:
	pop	esi

; 548  : }

	pop	ebp
	ret	0
_xmlBufDumpEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpAttributeDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlBufDumpAttributeDecl PROC				; COMDAT

; 514  : xmlBufDumpAttributeDecl(xmlBufPtr buf, xmlAttributePtr attr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlBufferCreate
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN1@xmlBufDump

; 515  :     xmlBufferPtr buffer;
; 516  : 
; 517  :     buffer = xmlBufferCreate();
; 518  :     if (buffer == NULL) {
; 519  :         /*
; 520  :          * TODO set the error in buf
; 521  :          */
; 522  :         return;
; 523  :     }
; 524  :     xmlDumpAttributeDecl(buffer, attr);

	push	DWORD PTR _attr$[ebp]
	push	esi
	call	_xmlDumpAttributeDecl

; 525  :     xmlBufMergeBuffer(buf, buffer);

	push	esi
	push	DWORD PTR _buf$[ebp]
	call	_xmlBufMergeBuffer
	add	esp, 16					; 00000010H
$LN1@xmlBufDump:
	pop	esi

; 526  : }

	pop	ebp
	ret	0
_xmlBufDumpAttributeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpElementDecl
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlBufDumpElementDecl PROC				; COMDAT

; 491  : xmlBufDumpElementDecl(xmlBufPtr buf, xmlElementPtr elem) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlBufferCreate
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN1@xmlBufDump

; 492  :     xmlBufferPtr buffer;
; 493  : 
; 494  :     buffer = xmlBufferCreate();
; 495  :     if (buffer == NULL) {
; 496  :         /*
; 497  :          * TODO set the error in buf
; 498  :          */
; 499  :         return;
; 500  :     }
; 501  :     xmlDumpElementDecl(buffer, elem);

	push	DWORD PTR _elem$[ebp]
	push	esi
	call	_xmlDumpElementDecl

; 502  :     xmlBufMergeBuffer(buf, buffer);

	push	esi
	push	DWORD PTR _buf$[ebp]
	call	_xmlBufMergeBuffer
	add	esp, 16					; 00000010H
$LN1@xmlBufDump:
	pop	esi

; 503  : }

	pop	ebp
	ret	0
_xmlBufDumpElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufDumpNotationTable
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlBufDumpNotationTable PROC				; COMDAT

; 468  : xmlBufDumpNotationTable(xmlBufPtr buf, xmlNotationTablePtr table) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlBufferCreate
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN1@xmlBufDump

; 469  :     xmlBufferPtr buffer;
; 470  : 
; 471  :     buffer = xmlBufferCreate();
; 472  :     if (buffer == NULL) {
; 473  :         /*
; 474  :          * TODO set the error in buf
; 475  :          */
; 476  :         return;
; 477  :     }
; 478  :     xmlDumpNotationTable(buffer, table);

	push	DWORD PTR _table$[ebp]
	push	esi
	call	_xmlDumpNotationTable

; 479  :     xmlBufMergeBuffer(buf, buffer);

	push	esi
	push	DWORD PTR _buf$[ebp]
	call	_xmlBufMergeBuffer
	add	esp, 16					; 00000010H
$LN1@xmlBufDump:
	pop	esi

; 480  : }

	pop	ebp
	ret	0
_xmlBufDumpNotationTable ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufAttrSerializeTxtContent
_TEXT	SEGMENT
_tmp$1 = -12						; size = 12
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_attr$ = 16						; size = 4
_l$1$ = 20						; size = 4
_string$ = 20						; size = 4
_xmlBufAttrSerializeTxtContent PROC			; COMDAT

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _string$[ebp]
	test	esi, esi
	je	$LN39@xmlBufAttr

; 2049 :     xmlChar *base, *cur;
; 2050 : 
; 2051 :     if (string == NULL)
; 2052 :         return;
; 2053 :     base = cur = (xmlChar *) string;

	mov	al, BYTE PTR [esi]
	mov	ecx, esi

; 2054 :     while (*cur != 0) {

	test	al, al
	je	$LN39@xmlBufAttr
	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
	push	ebx
	npad	3
$LL2@xmlBufAttr:

; 2055 :         if (*cur == '\n') {

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN5@xmlBufAttr

; 2056 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN7@xmlBufAttr

; 2057 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN7@xmlBufAttr:

; 2058 :             xmlBufAdd(buf, BAD_CAST "&#10;", 5);

	push	5
	push	OFFSET ??_C@_05EJOHHIMP@?$CG?$CD10?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2059 :             cur++;

	inc	esi

; 2060 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN5@xmlBufAttr:

; 2061 :         } else if (*cur == '\r') {

	cmp	al, 13					; 0000000dH
	jne	SHORT $LN8@xmlBufAttr

; 2062 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN10@xmlBufAttr

; 2063 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN10@xmlBufAttr:

; 2064 :             xmlBufAdd(buf, BAD_CAST "&#13;", 5);

	push	5
	push	OFFSET ??_C@_05ELKBMGJG@?$CG?$CD13?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2065 :             cur++;

	inc	esi

; 2066 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN8@xmlBufAttr:

; 2067 :         } else if (*cur == '\t') {

	cmp	al, 9
	jne	SHORT $LN11@xmlBufAttr

; 2068 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN13@xmlBufAttr

; 2069 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN13@xmlBufAttr:

; 2070 :             xmlBufAdd(buf, BAD_CAST "&#9;", 4);

	push	4
	push	OFFSET ??_C@_04NCNDODLB@?$CG?$CD9?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2071 :             cur++;

	inc	esi

; 2072 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN11@xmlBufAttr:

; 2073 :         } else if (*cur == '"') {

	cmp	al, 34					; 00000022H
	jne	SHORT $LN14@xmlBufAttr

; 2074 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN16@xmlBufAttr

; 2075 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN16@xmlBufAttr:

; 2076 :             xmlBufAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2077 :             cur++;

	inc	esi

; 2078 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN14@xmlBufAttr:

; 2079 :         } else if (*cur == '<') {

	cmp	al, 60					; 0000003cH
	jne	SHORT $LN17@xmlBufAttr

; 2080 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN19@xmlBufAttr

; 2081 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN19@xmlBufAttr:

; 2082 :             xmlBufAdd(buf, BAD_CAST "&lt;", 4);

	push	4
	push	OFFSET ??_C@_04GJOGLFEJ@?$CGlt?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2083 :             cur++;

	inc	esi

; 2084 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN17@xmlBufAttr:

; 2085 :         } else if (*cur == '>') {

	cmp	al, 62					; 0000003eH
	jne	SHORT $LN20@xmlBufAttr

; 2086 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN22@xmlBufAttr

; 2087 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN22@xmlBufAttr:

; 2088 :             xmlBufAdd(buf, BAD_CAST "&gt;", 4);

	push	4
	push	OFFSET ??_C@_04LOOHDCEI@?$CGgt?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2089 :             cur++;

	inc	esi

; 2090 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN20@xmlBufAttr:

; 2091 :         } else if (*cur == '&') {

	cmp	al, 38					; 00000026H
	jne	SHORT $LN23@xmlBufAttr

; 2092 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN61@xmlBufAttr

; 2093 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN61@xmlBufAttr:

; 2094 :             xmlBufAdd(buf, BAD_CAST "&amp;", 5);

	push	5
	push	OFFSET ??_C@_05JKJFEODM@?$CGamp?$DL@
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH

; 2095 :             cur++;

	inc	esi

; 2096 :             base = cur;

	mov	ecx, esi
	jmp	$LN27@xmlBufAttr
$LN23@xmlBufAttr:

; 2097 :         } else if ((*cur >= 0x80) && (cur[1] != 0) &&

	cmp	al, 128					; 00000080H
	jb	$LN26@xmlBufAttr
	cmp	BYTE PTR [esi+1], 0
	je	$LN26@xmlBufAttr
	mov	edx, DWORD PTR _doc$[ebp]
	test	edx, edx
	je	SHORT $LN28@xmlBufAttr
	cmp	DWORD PTR [edx+60], 0
	jne	$LN26@xmlBufAttr
$LN28@xmlBufAttr:

; 2098 : 	           ((doc == NULL) || (doc->encoding == NULL))) {
; 2099 :             /*
; 2100 :              * We assume we have UTF-8 content.
; 2101 :              */
; 2102 :             unsigned char tmp[12];
; 2103 :             int val = 0, l = 1;
; 2104 : 
; 2105 :             if (base != cur)

	cmp	ecx, esi
	je	SHORT $LN62@xmlBufAttr

; 2106 :                 xmlBufAdd(buf, base, cur - base);

	mov	eax, esi
	sub	eax, ecx
	push	eax
	push	ecx
	push	edi
	call	_xmlBufAdd
	mov	al, BYTE PTR [esi]
	add	esp, 12					; 0000000cH
$LN62@xmlBufAttr:

; 2107 :             if (*cur < 0xC0) {

	cmp	al, 192					; 000000c0H
	jae	SHORT $LN30@xmlBufAttr

; 2108 :                 xmlSaveErr(XML_SAVE_NOT_UTF8, (xmlNodePtr) attr, NULL);

	push	0
	push	DWORD PTR _attr$[ebp]
	push	1400					; 00000578H
	call	_xmlSaveErr

; 2109 : 		xmlSerializeHexCharRef(tmp, *cur);

	movzx	eax, BYTE PTR [esi]
	push	eax
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2110 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd
	add	esp, 32					; 00000020H

; 2111 :                 cur++;

	inc	esi

; 2112 :                 base = cur;

	mov	ecx, esi

; 2113 :                 continue;

	jmp	$LN27@xmlBufAttr
$LN30@xmlBufAttr:

; 2114 :             } else if (*cur < 0xE0) {

	cmp	al, 224					; 000000e0H
	jae	SHORT $LN32@xmlBufAttr

; 2115 :                 val = (cur[0]) & 0x1F;
; 2116 :                 val <<= 6;
; 2117 :                 val |= (cur[1]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 31					; 0000001fH

; 2118 :                 l = 2;

	mov	DWORD PTR _l$1$[ebp], 2
	jmp	SHORT $LN65@xmlBufAttr
$LN32@xmlBufAttr:

; 2119 :             } else if ((*cur < 0xF0) && (cur [2] != 0)) {

	cmp	al, 240					; 000000f0H
	jae	SHORT $LN63@xmlBufAttr
	mov	dl, BYTE PTR [esi+2]
	test	dl, dl
	je	SHORT $LN63@xmlBufAttr

; 2120 :                 val = (cur[0]) & 0x0F;
; 2121 :                 val <<= 6;
; 2122 :                 val |= (cur[1]) & 0x3F;
; 2123 :                 val <<= 6;
; 2124 :                 val |= (cur[2]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 15					; 0000000fH
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax

; 2125 :                 l = 3;

	mov	DWORD PTR _l$1$[ebp], 3
	movzx	eax, dl
	jmp	SHORT $LN65@xmlBufAttr
$LN63@xmlBufAttr:

; 2126 :             } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {

	cmp	al, 248					; 000000f8H
	jae	SHORT $LN57@xmlBufAttr
	mov	dl, BYTE PTR [esi+2]
	test	dl, dl
	je	SHORT $LN57@xmlBufAttr
	mov	dh, BYTE PTR [esi+3]
	test	dh, dh
	je	SHORT $LN57@xmlBufAttr

; 2127 :                 val = (cur[0]) & 0x07;
; 2128 :                 val <<= 6;
; 2129 :                 val |= (cur[1]) & 0x3F;
; 2130 :                 val <<= 6;
; 2131 :                 val |= (cur[2]) & 0x3F;
; 2132 :                 val <<= 6;
; 2133 :                 val |= (cur[3]) & 0x3F;

	movzx	ecx, al
	movzx	eax, BYTE PTR [esi+1]
	and	ecx, 7
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax

; 2134 :                 l = 4;

	mov	DWORD PTR _l$1$[ebp], 4
	movzx	eax, dl
	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	movzx	eax, dh
$LN65@xmlBufAttr:

; 2135 :             }
; 2136 :             if ((l == 1) || (!IS_CHAR(val))) {

	and	eax, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, eax
	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN49@xmlBufAttr
	cmp	ecx, 9
	jb	SHORT $LN41@xmlBufAttr
	cmp	ecx, 10					; 0000000aH
	jbe	SHORT $LN60@xmlBufAttr
$LN41@xmlBufAttr:
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN60@xmlBufAttr
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN60@xmlBufAttr
$LN57@xmlBufAttr:

; 2137 :                 xmlSaveErr(XML_SAVE_CHAR_INVALID, (xmlNodePtr) attr, NULL);

	push	0
	push	DWORD PTR _attr$[ebp]
	push	1401					; 00000579H
	call	_xmlSaveErr

; 2138 : 		xmlSerializeHexCharRef(tmp, *cur);

	movzx	eax, BYTE PTR [esi]
	push	eax
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2139 :                 xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd
	add	esp, 32					; 00000020H

; 2140 :                 cur++;

	inc	esi

; 2141 :                 base = cur;

	mov	ecx, esi

; 2142 :                 continue;

	jmp	SHORT $LN27@xmlBufAttr
$LN49@xmlBufAttr:

; 2135 :             }
; 2136 :             if ((l == 1) || (!IS_CHAR(val))) {

	cmp	ecx, 55295				; 0000d7ffH
	jbe	SHORT $LN60@xmlBufAttr
	cmp	ecx, 57344				; 0000e000H
	jb	SHORT $LN44@xmlBufAttr
	cmp	ecx, 65533				; 0000fffdH
	jbe	SHORT $LN60@xmlBufAttr
$LN44@xmlBufAttr:
	lea	eax, DWORD PTR [ecx-65536]
	cmp	eax, 1048575				; 000fffffH
	ja	SHORT $LN57@xmlBufAttr
$LN60@xmlBufAttr:

; 2143 :             }
; 2144 :             /*
; 2145 :              * We could do multiple things here. Just save
; 2146 :              * as a char ref
; 2147 :              */
; 2148 : 	    xmlSerializeHexCharRef(tmp, val);

	push	ecx
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlSerializeHexCharRef

; 2149 :             xmlBufAdd(buf, (xmlChar *) tmp, -1);

	push	-1
	lea	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	push	edi
	call	_xmlBufAdd
	add	esp, 20					; 00000014H

; 2150 :             cur += l;

	add	esi, DWORD PTR _l$1$[ebp]

; 2151 :             base = cur;

	mov	ecx, esi

; 2152 :         } else {

	jmp	SHORT $LN27@xmlBufAttr
$LN26@xmlBufAttr:

; 2153 :             cur++;

	inc	esi
$LN27@xmlBufAttr:

; 2054 :     while (*cur != 0) {

	mov	al, BYTE PTR [esi]
	test	al, al
	jne	$LL2@xmlBufAttr

; 2154 :         }
; 2155 :     }
; 2156 :     if (base != cur)

	pop	ebx
	cmp	ecx, esi
	je	SHORT $LN64@xmlBufAttr

; 2157 :         xmlBufAdd(buf, base, cur - base);

	sub	esi, ecx
	push	esi
	push	ecx
	push	edi
	call	_xmlBufAdd
	add	esp, 12					; 0000000cH
$LN64@xmlBufAttr:
	pop	edi
$LN39@xmlBufAttr:
	pop	esi

; 2158 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBufAttrSerializeTxtContent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSetAttrEscape
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_escape$ = 12						; size = 4
_xmlSaveSetAttrEscape PROC				; COMDAT

; 2024 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSaveSet

; 2025 :     if (ctxt == NULL) return(-1);

	or	eax, -1

; 2028 : }

	pop	ebp
	ret	0
$LN2@xmlSaveSet:

; 2026 :     ctxt->escapeAttr = escape;

	mov	eax, DWORD PTR _escape$[ebp]
	mov	DWORD PTR [ecx+120], eax

; 2027 :     return(0);

	xor	eax, eax

; 2028 : }

	pop	ebp
	ret	0
_xmlSaveSetAttrEscape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveSetEscape
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_escape$ = 12						; size = 4
_xmlSaveSetEscape PROC					; COMDAT

; 2007 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@xmlSaveSet

; 2008 :     if (ctxt == NULL) return(-1);

	or	eax, -1

; 2011 : }

	pop	ebp
	ret	0
$LN2@xmlSaveSet:

; 2009 :     ctxt->escape = escape;

	mov	eax, DWORD PTR _escape$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 2010 :     return(0);

	xor	eax, eax

; 2011 : }

	pop	ebp
	ret	0
_xmlSaveSetEscape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveClose
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSaveClose PROC					; COMDAT

; 1987 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _ctxt$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlSaveClo

; 1988 :     int ret;
; 1989 : 
; 1990 :     if (ctxt == NULL) return(-1);

	or	eax, -1
	pop	esi

; 1994 : }

	pop	ebp
	ret	0
$LN2@xmlSaveClo:

; 1972 :     if (ctxt->buf == NULL) return(-1);

	mov	eax, DWORD PTR [esi+24]
	push	edi
	test	eax, eax
	jne	SHORT $LN6@xmlSaveClo
	or	edi, -1
	jmp	SHORT $LN4@xmlSaveClo
$LN6@xmlSaveClo:

; 1973 :     return(xmlOutputBufferFlush(ctxt->buf));

	push	eax
	call	_xmlOutputBufferFlush
	add	esp, 4
	mov	edi, eax
$LN4@xmlSaveClo:

; 365  :     if (ctxt->encoding != NULL)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN10@xmlSaveClo

; 366  :         xmlFree((char *) ctxt->encoding);

	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
$LN10@xmlSaveClo:

; 367  :     if (ctxt->buf != NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN11@xmlSaveClo

; 368  :         xmlOutputBufferClose(ctxt->buf);

	push	eax
	call	_xmlOutputBufferClose
	add	esp, 4
$LN11@xmlSaveClo:

; 369  :     xmlFree(ctxt);

	push	esi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1991 :     ret = xmlSaveFlush(ctxt);
; 1992 :     xmlFreeSaveCtxt(ctxt);
; 1993 :     return(ret);

	mov	eax, edi
	pop	edi
	pop	esi

; 1994 : }

	pop	ebp
	ret	0
_xmlSaveClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFlush
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSaveFlush PROC					; COMDAT

; 1970 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _ctxt$[ebp]
	test	eax, eax
	je	SHORT $LN5@xmlSaveFlu

; 1971 :     if (ctxt == NULL) return(-1);
; 1972 :     if (ctxt->buf == NULL) return(-1);

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN5@xmlSaveFlu

; 1973 :     return(xmlOutputBufferFlush(ctxt->buf));

	mov	DWORD PTR _ctxt$[ebp], eax

; 1974 : }

	pop	ebp

; 1973 :     return(xmlOutputBufferFlush(ctxt->buf));

	jmp	_xmlOutputBufferFlush
$LN5@xmlSaveFlu:

; 1971 :     if (ctxt == NULL) return(-1);
; 1972 :     if (ctxt->buf == NULL) return(-1);

	or	eax, -1

; 1974 : }

	pop	ebp
	ret	0
_xmlSaveFlush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveTree
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlSaveTree PROC					; COMDAT

; 1951 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSaveTre

; 1952 :     long ret = 0;
; 1953 : 
; 1954 :     if ((ctxt == NULL) || (node == NULL)) return(-1);

	mov	eax, DWORD PTR _node$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSaveTre

; 1955 :     xmlNodeDumpOutputInternal(ctxt, node);

	push	eax
	push	ecx
	call	_xmlNodeDumpOutputInternal
	add	esp, 8

; 1956 :     return(ret);

	xor	eax, eax

; 1957 : }

	pop	ebp
	ret	0
$LN3@xmlSaveTre:

; 1952 :     long ret = 0;
; 1953 : 
; 1954 :     if ((ctxt == NULL) || (node == NULL)) return(-1);

	or	eax, -1

; 1957 : }

	pop	ebp
	ret	0
_xmlSaveTree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveDoc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlSaveDoc PROC					; COMDAT

; 1929 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@xmlSaveDoc

; 1930 :     long ret = 0;
; 1931 : 
; 1932 :     if ((ctxt == NULL) || (doc == NULL)) return(-1);

	mov	eax, DWORD PTR _doc$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlSaveDoc

; 1933 :     if (xmlDocContentDumpOutput(ctxt, doc) < 0)

	push	eax
	push	ecx
	call	_xmlDocContentDumpOutput
	add	esp, 8
	test	eax, eax
	js	SHORT $LN3@xmlSaveDoc

; 1934 :         return(-1);
; 1935 :     return(ret);

	xor	eax, eax

; 1936 : }

	pop	ebp
	ret	0
$LN3@xmlSaveDoc:

; 1930 :     long ret = 0;
; 1931 : 
; 1932 :     if ((ctxt == NULL) || (doc == NULL)) return(-1);

	or	eax, -1

; 1936 : }

	pop	ebp
	ret	0
_xmlSaveDoc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToIO
_TEXT	SEGMENT
_iowrite$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlSaveToIO PROC					; COMDAT

; 1903 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	call	_xmlNewSaveCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN5@xmlSaveToI

; 1904 :     xmlSaveCtxtPtr ret;
; 1905 : 
; 1906 :     ret = xmlNewSaveCtxt(encoding, options);
; 1907 :     if (ret == NULL) return(NULL);
; 1908 :     ret->buf = xmlOutputBufferCreateIO(iowrite, ioclose, ioctx, ret->handler);

	push	DWORD PTR [esi+20]
	push	DWORD PTR _ioctx$[ebp]
	push	DWORD PTR _ioclose$[ebp]
	push	DWORD PTR _iowrite$[ebp]
	call	_xmlOutputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax

; 1909 :     if (ret->buf == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSaveToI

; 1910 : 	xmlFreeSaveCtxt(ret);

	push	esi
	call	_xmlFreeSaveCtxt
	add	esp, 4
$LN5@xmlSaveToI:

; 1914 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSaveToI:

; 1911 : 	return(NULL);
; 1912 :     }
; 1913 :     return(ret);

	mov	eax, esi
	pop	esi

; 1914 : }

	pop	ebp
	ret	0
_xmlSaveToIO ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToBuffer
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToBuffer PROC					; COMDAT

; 1859 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	mov	esi, DWORD PTR _encoding$[ebp]
	push	esi
	call	_xmlNewSaveCtxt
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@xmlSaveToB

; 1860 :     xmlSaveCtxtPtr ret;
; 1861 :     xmlOutputBufferPtr out_buff;
; 1862 :     xmlCharEncodingHandlerPtr handler;
; 1863 : 
; 1864 :     ret = xmlNewSaveCtxt(encoding, options);
; 1865 :     if (ret == NULL) return(NULL);
; 1866 : 
; 1867 :     if (encoding != NULL) {

	test	esi, esi
	je	SHORT $LN3@xmlSaveToB

; 1868 :         handler = xmlFindCharEncodingHandler(encoding);

	push	esi
	call	_xmlFindCharEncodingHandler
	mov	esi, eax
	add	esp, 4

; 1869 :         if (handler == NULL) {

	test	esi, esi
	jne	SHORT $LN4@xmlSaveToB

; 1870 :             xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree

; 1884 : }

	add	esp, 4
$LN7@xmlSaveToB:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSaveToB:

; 1871 :             return(NULL);
; 1872 :         }
; 1873 :     } else
; 1874 :         handler = NULL;

	xor	esi, esi
$LN4@xmlSaveToB:

; 1875 :     out_buff = xmlOutputBufferCreateBuffer(buffer, handler);

	push	esi
	push	DWORD PTR _buffer$[ebp]
	call	_xmlOutputBufferCreateBuffer
	add	esp, 8

; 1876 :     if (out_buff == NULL) {

	test	eax, eax
	jne	SHORT $LN6@xmlSaveToB

; 1877 :         xmlFree(ret);

	push	edi
	call	DWORD PTR _xmlFree
	add	esp, 4

; 1878 :         if (handler) xmlCharEncCloseFunc(handler);

	test	esi, esi
	je	SHORT $LN7@xmlSaveToB
	push	esi
	call	_xmlCharEncCloseFunc

; 1884 : }

	add	esp, 4
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN6@xmlSaveToB:

; 1879 :         return(NULL);
; 1880 :     }
; 1881 : 
; 1882 :     ret->buf = out_buff;

	mov	DWORD PTR [edi+24], eax

; 1883 :     return(ret);

	mov	eax, edi
	pop	edi

; 1884 : }

	pop	esi
	pop	ebp
	ret	0
_xmlSaveToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToFilename
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToFilename PROC					; COMDAT

; 1830 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	call	_xmlNewSaveCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN5@xmlSaveToF

; 1831 :     xmlSaveCtxtPtr ret;
; 1832 :     int compression = 0; /* TODO handle compression option */
; 1833 : 
; 1834 :     ret = xmlNewSaveCtxt(encoding, options);
; 1835 :     if (ret == NULL) return(NULL);
; 1836 :     ret->buf = xmlOutputBufferCreateFilename(filename, ret->handler,

	push	0
	push	DWORD PTR [esi+20]
	push	DWORD PTR _filename$[ebp]
	call	_xmlOutputBufferCreateFilename
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], eax

; 1837 :                                              compression);
; 1838 :     if (ret->buf == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSaveToF

; 1839 : 	xmlFreeSaveCtxt(ret);

	push	esi
	call	_xmlFreeSaveCtxt
	add	esp, 4
$LN5@xmlSaveToF:

; 1843 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSaveToF:

; 1840 : 	return(NULL);
; 1841 :     }
; 1842 :     return(ret);

	mov	eax, esi
	pop	esi

; 1843 : }

	pop	ebp
	ret	0
_xmlSaveToFilename ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveToFd
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlSaveToFd PROC					; COMDAT

; 1803 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _options$[ebp]
	push	DWORD PTR _encoding$[ebp]
	call	_xmlNewSaveCtxt
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	SHORT $LN5@xmlSaveToF

; 1804 :     xmlSaveCtxtPtr ret;
; 1805 : 
; 1806 :     ret = xmlNewSaveCtxt(encoding, options);
; 1807 :     if (ret == NULL) return(NULL);
; 1808 :     ret->buf = xmlOutputBufferCreateFd(fd, ret->handler);

	push	DWORD PTR [esi+20]
	push	DWORD PTR _fd$[ebp]
	call	_xmlOutputBufferCreateFd
	add	esp, 8
	mov	DWORD PTR [esi+24], eax

; 1809 :     if (ret->buf == NULL) {

	test	eax, eax
	jne	SHORT $LN3@xmlSaveToF

; 1810 : 	xmlFreeSaveCtxt(ret);

	push	esi
	call	_xmlFreeSaveCtxt
	add	esp, 4
$LN5@xmlSaveToF:

; 1814 : }

	xor	eax, eax
	pop	esi
	pop	ebp
	ret	0
$LN3@xmlSaveToF:

; 1811 : 	return(NULL);
; 1812 :     }
; 1813 :     return(ret);

	mov	eax, esi
	pop	esi

; 1814 : }

	pop	ebp
	ret	0
_xmlSaveToFd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlIsXHTML
_TEXT	SEGMENT
_systemID$ = 8						; size = 4
_publicID$ = 12						; size = 4
_xmlIsXHTML PROC					; COMDAT

; 55   : xmlIsXHTML(const xmlChar *systemID, const xmlChar *publicID) {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _systemID$[ebp]
	mov	esi, DWORD PTR _publicID$[ebp]
	test	edi, edi
	jne	SHORT $LN2@xmlIsXHTML

; 56   :     if ((systemID == NULL) && (publicID == NULL))

	test	esi, esi
	jne	SHORT $LN12@xmlIsXHTML

; 57   : 	return(-1);

	pop	edi
	or	eax, -1

; 69   : }

	pop	esi
	pop	ebp
	ret	0
$LN2@xmlIsXHTML:

; 58   :     if (publicID != NULL) {

	test	esi, esi
	je	SHORT $LN6@xmlIsXHTML
$LN12@xmlIsXHTML:

; 59   : 	if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CB@LIHKBLCO@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Strict?1?1E@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlIsXHTML

; 60   : 	if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CD@EONGLKJJ@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Frameset?1@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlIsXHTML

; 61   : 	if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);

	push	OFFSET ??_C@_0CH@FHDGMIJF@?9?1?1W3C?1?1DTD?5XHTML?51?40?5Transitio@
	push	esi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlIsXHTML
$LN6@xmlIsXHTML:

; 62   :     }
; 63   :     if (systemID != NULL) {

	test	edi, edi
	je	SHORT $LN10@xmlIsXHTML

; 64   : 	if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DC@BHABDBDI@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlIsXHTML

; 65   : 	if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DE@CCGEPDJH@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlIsXHTML

; 66   : 	if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);

	push	OFFSET ??_C@_0DI@KKENBPON@http?3?1?1www?4w3?4org?1TR?1xhtml1?1DTD@
	push	edi
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlIsXHTML
$LN13@xmlIsXHTML:
	pop	edi
	mov	eax, 1

; 69   : }

	pop	esi
	pop	ebp
	ret	0
$LN10@xmlIsXHTML:
	pop	edi

; 67   :     }
; 68   :     return(0);

	xor	eax, eax

; 69   : }

	pop	esi
	pop	ebp
	ret	0
_xmlIsXHTML ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFileEnc
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlSaveFileEnc PROC					; COMDAT

; 2739 : xmlSaveFileEnc(const char *filename, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _encoding$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _filename$[ebp]
	call	_xmlSaveFormatFileEnc
	add	esp, 16					; 00000010H

; 2740 :     return ( xmlSaveFormatFileEnc( filename, cur, encoding, 0 ) );
; 2741 : }

	pop	ebp
	ret	0
_xmlSaveFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFileEnc
_TEXT	SEGMENT
_ctxt$ = -124						; size = 124
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlSaveFormatFileEnc PROC				; COMDAT

; 2685 : 			const char * encoding, int format ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	edi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	test	edi, edi
	je	$LN10@xmlSaveFor

; 2686 :     xmlSaveCtxt ctxt;
; 2687 :     xmlOutputBufferPtr buf;
; 2688 :     xmlCharEncodingHandlerPtr handler = NULL;
; 2689 :     int ret;
; 2690 : 
; 2691 :     if (cur == NULL)
; 2692 : 	return(-1);
; 2693 : 
; 2694 :     if (encoding == NULL)

	mov	esi, DWORD PTR _encoding$[ebp]
	test	esi, esi
	jne	SHORT $LN9@xmlSaveFor

; 2695 : 	encoding = (const char *) cur->encoding;

	mov	esi, DWORD PTR [edi+60]

; 2696 : 
; 2697 :     if (encoding != NULL) {

	test	esi, esi
	je	SHORT $LN5@xmlSaveFor
$LN9@xmlSaveFor:

; 2698 : 
; 2699 : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	esi
	call	_xmlFindCharEncodingHandler
	mov	ebx, eax
	add	esp, 4

; 2700 : 	    if (handler == NULL)

	test	ebx, ebx
	je	SHORT $LN10@xmlSaveFor
$LN5@xmlSaveFor:

; 2701 : 		return(-1);
; 2702 :     }
; 2703 : 
; 2704 : #ifdef LIBXML_ZLIB_ENABLED
; 2705 :     if (cur->compression < 0) cur->compression = xmlGetCompressMode();

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jns	SHORT $LN6@xmlSaveFor
	call	_xmlGetCompressMode
	mov	DWORD PTR [edi+36], eax
$LN6@xmlSaveFor:

; 2706 : #endif
; 2707 :     /*
; 2708 :      * save the content to a temp buffer.
; 2709 :      */
; 2710 :     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);

	push	eax
	push	ebx
	push	DWORD PTR _filename$[ebp]
	call	_xmlOutputBufferCreateFilename
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 2711 :     if (buf == NULL) return(-1);

	test	ebx, ebx
	je	SHORT $LN10@xmlSaveFor

; 2712 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2713 :     ctxt.doc = cur;
; 2714 :     ctxt.buf = buf;
; 2715 :     ctxt.level = 0;
; 2716 :     ctxt.format = format ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _ctxt$[ebp+28], edi
	cmp	DWORD PTR _format$[ebp], eax
	mov	DWORD PTR _ctxt$[ebp+24], ebx
	setne	al
	mov	DWORD PTR _ctxt$[ebp+36], 0
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2717 :     ctxt.encoding = (const xmlChar *) encoding;
; 2718 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp+16], esi
	call	_xmlSaveCtxtInit

; 2719 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H

; 2720 : 
; 2721 :     xmlDocContentDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlDocContentDumpOutput

; 2722 : 
; 2723 :     ret = xmlOutputBufferClose(buf);

	push	ebx
	call	_xmlOutputBufferClose
	add	esp, 28					; 0000001cH
	pop	edi

; 2724 :     return(ret);
; 2725 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@xmlSaveFor:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveFormatFileEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDumpOutput
_TEXT	SEGMENT
_ctxt$ = -124						; size = 124
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_encoding$ = 28						; size = 4
_xmlNodeDumpOutput PROC					; COMDAT

; 2348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	ebx
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	ebx, DWORD PTR _buf$[ebp]
	test	ebx, ebx
	je	$LN3@xmlNodeDum

; 2349 :     xmlSaveCtxt ctxt;
; 2350 : #ifdef LIBXML_HTML_ENABLED
; 2351 :     xmlDtdPtr dtd;
; 2352 :     int is_xhtml = 0;
; 2353 : #endif
; 2354 : 
; 2355 :     xmlInitParser();
; 2356 : 
; 2357 :     if ((buf == NULL) || (cur == NULL)) return;

	push	edi
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	$LN10@xmlNodeDum

; 2358 : 
; 2359 :     if (encoding == NULL)
; 2360 :         encoding = "UTF-8";
; 2361 : 
; 2362 :     memset(&ctxt, 0, sizeof(ctxt));

	push	esi
	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2363 :     ctxt.doc = doc;
; 2364 :     ctxt.buf = buf;
; 2365 :     ctxt.level = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	ecx, OFFSET ??_C@_05EGJIMALK@UTF?98@
	mov	esi, DWORD PTR _doc$[ebp]
	mov	DWORD PTR _ctxt$[ebp+36], eax

; 2366 :     ctxt.format = format ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR _format$[ebp], eax
	mov	DWORD PTR _ctxt$[ebp+28], esi
	setne	al
	mov	DWORD PTR _ctxt$[ebp+24], ebx
	mov	DWORD PTR _ctxt$[ebp+40], eax
	mov	eax, DWORD PTR _encoding$[ebp]
	test	eax, eax
	cmovne	ecx, eax

; 2367 :     ctxt.encoding = (const xmlChar *) encoding;
; 2368 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp+16], ecx
	call	_xmlSaveCtxtInit

; 2369 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H

; 2370 : 
; 2371 : #ifdef LIBXML_HTML_ENABLED
; 2372 :     dtd = xmlGetIntSubset(doc);

	push	esi
	call	_xmlGetIntSubset
	add	esp, 20					; 00000014H
	pop	esi

; 2373 :     if (dtd != NULL) {

	test	eax, eax
	je	SHORT $LN7@xmlNodeDum

; 2374 : 	is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);

	push	DWORD PTR [eax+52]
	push	DWORD PTR [eax+56]
	call	_xmlIsXHTML
	add	esp, 8

; 2375 : 	if (is_xhtml < 0)

	test	eax, eax
	js	SHORT $LN7@xmlNodeDum

; 2376 : 	    is_xhtml = 0;
; 2377 :     }
; 2378 : 
; 2379 :     if (is_xhtml)

	je	SHORT $LN7@xmlNodeDum

; 2380 :         xhtmlNodeDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xhtmlNodeDumpOutput

; 2381 :     else
; 2382 : #endif
; 2383 :         xmlNodeDumpOutputInternal(&ctxt, cur);

	add	esp, 8
	pop	edi
	pop	ebx

; 2384 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlNodeDum:

; 2381 :     else
; 2382 : #endif
; 2383 :         xmlNodeDumpOutputInternal(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlNodeDumpOutputInternal
	add	esp, 8
$LN10@xmlNodeDum:
	pop	edi
$LN3@xmlNodeDum:
	pop	ebx

; 2384 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNodeDumpOutput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFileTo
_TEXT	SEGMENT
_ctxt$ = -124						; size = 124
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlSaveFormatFileTo PROC				; COMDAT

; 2646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlSaveFor

; 2647 :     xmlSaveCtxt ctxt;
; 2648 :     int ret;
; 2649 : 
; 2650 :     if (buf == NULL) return(-1);

	or	eax, -1
	pop	esi

; 2667 :     return (ret);
; 2668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSaveFor:
	push	edi

; 2651 :     if ((cur == NULL) ||

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN4@xmlSaveFor
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 9
	je	SHORT $LN3@xmlSaveFor
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN4@xmlSaveFor
$LN3@xmlSaveFor:

; 2656 :     }
; 2657 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2658 :     ctxt.doc = cur;
; 2659 :     ctxt.buf = buf;
; 2660 :     ctxt.level = 0;
; 2661 :     ctxt.format = format ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _ctxt$[ebp+28], edi
	cmp	DWORD PTR _format$[ebp], eax
	mov	DWORD PTR _ctxt$[ebp+24], esi
	setne	al
	mov	DWORD PTR _ctxt$[ebp+36], 0
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2662 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	eax, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], eax

; 2663 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSaveCtxtInit

; 2664 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H

; 2665 :     xmlDocContentDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlDocContentDumpOutput

; 2666 :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 2667 :     return (ret);
; 2668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@xmlSaveFor:

; 2652 :         ((cur->type != XML_DOCUMENT_NODE) &&
; 2653 : 	 (cur->type != XML_HTML_DOCUMENT_NODE))) {
; 2654 :         xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4

; 2655 : 	return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 2667 :     return (ret);
; 2668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveFormatFileTo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFileTo
_TEXT	SEGMENT
_ctxt$ = -124						; size = 124
_buf$ = 8						; size = 4
_cur$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlSaveFileTo PROC					; COMDAT

; 2608 : xmlSaveFileTo(xmlOutputBufferPtr buf, xmlDocPtr cur, const char *encoding) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	esi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	jne	SHORT $LN2@xmlSaveFil

; 2609 :     xmlSaveCtxt ctxt;
; 2610 :     int ret;
; 2611 : 
; 2612 :     if (buf == NULL) return(-1);

	or	eax, -1
	pop	esi

; 2627 :     return(ret);
; 2628 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@xmlSaveFil:
	push	edi

; 2613 :     if (cur == NULL) {

	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	jne	SHORT $LN3@xmlSaveFil

; 2614 :         xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4

; 2615 : 	return(-1);

	or	eax, -1
	pop	edi
	pop	esi

; 2627 :     return(ret);
; 2628 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlSaveFil:

; 2616 :     }
; 2617 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2618 :     ctxt.doc = cur;
; 2619 :     ctxt.buf = buf;
; 2620 :     ctxt.level = 0;
; 2621 :     ctxt.format = 0;
; 2622 :     ctxt.encoding = (const xmlChar *) encoding;

	mov	eax, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR _ctxt$[ebp+16], eax

; 2623 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp+28], edi
	mov	DWORD PTR _ctxt$[ebp+24], esi
	mov	DWORD PTR _ctxt$[ebp+36], 0
	mov	DWORD PTR _ctxt$[ebp+40], 0
	call	_xmlSaveCtxtInit

; 2624 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H

; 2625 :     xmlDocContentDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	edi
	push	eax
	call	_xmlDocContentDumpOutput

; 2626 :     ret = xmlOutputBufferClose(buf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 2627 :     return(ret);
; 2628 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveFileTo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlNodeDump
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_xmlNodeDump PROC					; COMDAT

; 2203 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlNodeDum

; 2204 :     xmlBufPtr buffer;
; 2205 :     int ret;
; 2206 : 
; 2207 :     if ((buf == NULL) || (cur == NULL))

	mov	esi, DWORD PTR _cur$[ebp]
	test	esi, esi
	je	SHORT $LN3@xmlNodeDum

; 2209 :     buffer = xmlBufFromBuffer(buf);

	push	eax
	call	_xmlBufFromBuffer
	mov	edi, eax
	add	esp, 4

; 2210 :     if (buffer == NULL)

	test	edi, edi
	je	SHORT $LN3@xmlNodeDum

; 2211 :         return(-1);
; 2212 :     ret = xmlBufNodeDump(buffer, doc, cur, level, format);

	push	DWORD PTR _format$[ebp]
	push	DWORD PTR _level$[ebp]
	push	esi
	push	DWORD PTR _doc$[ebp]
	push	edi
	call	_xmlBufNodeDump

; 2213 :     xmlBufBackToBuffer(buffer);

	push	edi
	mov	esi, eax
	call	_xmlBufBackToBuffer
	add	esp, 24					; 00000018H

; 2214 :     if (ret > INT_MAX)
; 2215 :         return(-1);
; 2216 :     return((int) ret);

	mov	eax, esi
	pop	edi

; 2217 : }

	pop	esi
	pop	ebp
	ret	0
$LN3@xmlNodeDum:
	pop	edi

; 2208 :         return(-1);

	or	eax, -1

; 2217 : }

	pop	esi
	pop	ebp
	ret	0
_xmlNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlBufNodeDump
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_level$ = 20						; size = 4
_format$ = 24						; size = 4
_xmlBufNodeDump PROC					; COMDAT

; 2238 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN8@xmlBufNode

; 2239 :     size_t use;
; 2240 :     int ret;
; 2241 :     xmlOutputBufferPtr outbuf;
; 2242 :     int oldalloc;
; 2243 : 
; 2244 :     xmlInitParser();
; 2245 : 
; 2246 :     if (cur == NULL) {
; 2247 : #ifdef DEBUG_TREE
; 2248 :         xmlGenericError(xmlGenericErrorContext,
; 2249 :                         "xmlNodeDump : node == NULL\n");
; 2250 : #endif
; 2251 :         return (-1);
; 2252 :     }
; 2253 :     if (buf == NULL) {

	mov	esi, DWORD PTR _buf$[ebp]
	test	esi, esi
	je	$LN8@xmlBufNode

; 2259 :     }
; 2260 :     outbuf = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));

	push	ebx
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	mov	ebx, eax
	add	esp, 4

; 2261 :     if (outbuf == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlBufNode

; 111  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 2262 :         xmlSaveErrMemory("creating buffer");
; 2263 :         return (-1);

	or	eax, -1
	pop	ebx
	pop	esi

; 2281 : }

	pop	ebp
	ret	0
$LN4@xmlBufNode:

; 2264 :     }
; 2265 :     memset(outbuf, 0, (size_t) sizeof(xmlOutputBuffer));

	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+28], 0
	push	edi

; 2266 :     outbuf->buffer = buf;
; 2267 :     outbuf->encoder = NULL;
; 2268 :     outbuf->writecallback = NULL;
; 2269 :     outbuf->closecallback = NULL;
; 2270 :     outbuf->context = NULL;
; 2271 :     outbuf->written = 0;
; 2272 : 
; 2273 :     use = xmlBufUse(buf);

	push	esi
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+24], 0
	call	_xmlBufUse

; 2274 :     oldalloc = xmlBufGetAllocationScheme(buf);

	push	esi
	mov	edi, eax
	call	_xmlBufGetAllocationScheme

; 2275 :     xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);

	push	0
	push	DWORD PTR _buf$[ebp]
	mov	esi, eax
	call	_xmlBufSetAllocationScheme

; 2276 :     xmlNodeDumpOutput(outbuf, doc, cur, level, format, NULL);

	push	0
	push	DWORD PTR _format$[ebp]
	push	DWORD PTR _level$[ebp]
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	ebx
	call	_xmlNodeDumpOutput

; 2277 :     xmlBufSetAllocationScheme(buf, oldalloc);

	push	esi
	mov	esi, DWORD PTR _buf$[ebp]
	push	esi
	call	_xmlBufSetAllocationScheme

; 2278 :     xmlFree(outbuf);

	push	ebx
	call	DWORD PTR _xmlFree

; 2279 :     ret = xmlBufUse(buf) - use;

	push	esi
	call	_xmlBufUse
	add	esp, 56					; 00000038H
	sub	eax, edi

; 2280 :     return (ret);

	pop	edi
	pop	ebx
	pop	esi

; 2281 : }

	pop	ebp
	ret	0
$LN8@xmlBufNode:

; 2254 : #ifdef DEBUG_TREE
; 2255 :         xmlGenericError(xmlGenericErrorContext,
; 2256 :                         "xmlNodeDump : buf == NULL\n");
; 2257 : #endif
; 2258 :         return (-1);

	or	eax, -1
	pop	esi

; 2281 : }

	pop	ebp
	ret	0
_xmlBufNodeDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFormatFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_format$ = 16						; size = 4
_xmlSaveFormatFile PROC					; COMDAT

; 2758 : xmlSaveFormatFile(const char *filename, xmlDocPtr cur, int format) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _format$[ebp]
	push	0
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _filename$[ebp]
	call	_xmlSaveFormatFileEnc
	add	esp, 16					; 00000010H

; 2759 :     return ( xmlSaveFormatFileEnc( filename, cur, NULL, format ) );
; 2760 : }

	pop	ebp
	ret	0
_xmlSaveFormatFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlSaveFile
_TEXT	SEGMENT
_ctxt$1 = -124						; size = 124
_filename$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlSaveFile PROC					; COMDAT

; 2773 : xmlSaveFile(const char *filename, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4

; 2691 :     if (cur == NULL)

	mov	esi, DWORD PTR _cur$[ebp]
	xor	edi, edi
	test	esi, esi
	jne	SHORT $LN12@xmlSaveFil

; 2774 :     return(xmlSaveFormatFileEnc(filename, cur, NULL, 0));

	pop	edi
	or	eax, -1

; 2775 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlSaveFil:
	push	ebx

; 2695 : 	encoding = (const char *) cur->encoding;

	mov	ebx, DWORD PTR [esi+60]

; 2696 : 
; 2697 :     if (encoding != NULL) {

	test	ebx, ebx
	je	SHORT $LN7@xmlSaveFil

; 2698 : 
; 2699 : 	    handler = xmlFindCharEncodingHandler(encoding);

	push	ebx
	call	_xmlFindCharEncodingHandler
	mov	edi, eax
	add	esp, 4

; 2700 : 	    if (handler == NULL)

	test	edi, edi
	je	SHORT $LN14@xmlSaveFil
$LN7@xmlSaveFil:

; 2701 : 		return(-1);
; 2702 :     }
; 2703 : 
; 2704 : #ifdef LIBXML_ZLIB_ENABLED
; 2705 :     if (cur->compression < 0) cur->compression = xmlGetCompressMode();

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	jns	SHORT $LN8@xmlSaveFil
	call	_xmlGetCompressMode
	mov	DWORD PTR [esi+36], eax
$LN8@xmlSaveFil:

; 2706 : #endif
; 2707 :     /*
; 2708 :      * save the content to a temp buffer.
; 2709 :      */
; 2710 :     buf = xmlOutputBufferCreateFilename(filename, handler, cur->compression);

	push	eax
	push	edi
	push	DWORD PTR _filename$[ebp]
	call	_xmlOutputBufferCreateFilename
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2711 :     if (buf == NULL) return(-1);

	test	edi, edi
	jne	SHORT $LN9@xmlSaveFil
$LN14@xmlSaveFil:
	pop	ebx
	pop	edi

; 2774 :     return(xmlSaveFormatFileEnc(filename, cur, NULL, 0));

	or	eax, -1

; 2775 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@xmlSaveFil:

; 2712 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$1[ebp]
	push	0
	push	eax
	call	_memset

; 2713 :     ctxt.doc = cur;
; 2714 :     ctxt.buf = buf;
; 2715 :     ctxt.level = 0;
; 2716 :     ctxt.format = format ? 1 : 0;
; 2717 :     ctxt.encoding = (const xmlChar *) encoding;
; 2718 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$1[ebp]
	mov	DWORD PTR _ctxt$1[ebp+28], esi
	push	eax
	mov	DWORD PTR _ctxt$1[ebp+24], edi
	mov	DWORD PTR _ctxt$1[ebp+36], 0
	mov	DWORD PTR _ctxt$1[ebp+40], 0
	mov	DWORD PTR _ctxt$1[ebp+16], ebx
	call	_xmlSaveCtxtInit

; 2719 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$1[ebp+32], 32		; 00000020H

; 2720 : 
; 2721 :     xmlDocContentDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$1[ebp]
	push	esi
	push	eax
	call	_xmlDocContentDumpOutput

; 2722 : 
; 2723 :     ret = xmlOutputBufferClose(buf);

	push	edi
	call	_xmlOutputBufferClose
	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi

; 2775 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlElemDump
_TEXT	SEGMENT
_f$ = 8							; size = 4
_doc$ = 12						; size = 4
_cur$ = 16						; size = 4
_xmlElemDump PROC					; COMDAT

; 2293 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	call	_xmlInitParser
	mov	edi, DWORD PTR _cur$[ebp]
	test	edi, edi
	je	SHORT $LN1@xmlElemDum

; 2294 :     xmlOutputBufferPtr outbuf;
; 2295 : 
; 2296 :     xmlInitParser();
; 2297 : 
; 2298 :     if (cur == NULL) {
; 2299 : #ifdef DEBUG_TREE
; 2300 :         xmlGenericError(xmlGenericErrorContext,
; 2301 :                         "xmlElemDump : cur == NULL\n");
; 2302 : #endif
; 2303 :         return;
; 2304 :     }
; 2305 : #ifdef DEBUG_TREE
; 2306 :     if (doc == NULL) {
; 2307 :         xmlGenericError(xmlGenericErrorContext,
; 2308 :                         "xmlElemDump : doc == NULL\n");
; 2309 :     }
; 2310 : #endif
; 2311 : 
; 2312 :     outbuf = xmlOutputBufferCreateFile(f, NULL);

	push	esi
	push	0
	push	DWORD PTR _f$[ebp]
	call	_xmlOutputBufferCreateFile
	mov	esi, eax
	add	esp, 8

; 2313 :     if (outbuf == NULL)

	test	esi, esi
	je	SHORT $LN7@xmlElemDum

; 2314 :         return;
; 2315 :     if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE)) {

	mov	ecx, DWORD PTR _doc$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@xmlElemDum
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN4@xmlElemDum

; 2316 : #ifdef LIBXML_HTML_ENABLED
; 2317 :         htmlNodeDumpOutput(outbuf, doc, cur, NULL);

	push	0
	push	edi
	push	ecx
	push	esi
	call	_htmlNodeDumpOutput
	add	esp, 16					; 00000010H

; 2323 :     xmlOutputBufferClose(outbuf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4
	pop	esi
	pop	edi

; 2324 : }

	pop	ebp
	ret	0
$LN4@xmlElemDum:

; 2318 : #else
; 2319 : 	xmlSaveErr(XML_ERR_INTERNAL_ERROR, cur, "HTML support not compiled in\n");
; 2320 : #endif /* LIBXML_HTML_ENABLED */
; 2321 :     } else
; 2322 :         xmlNodeDumpOutput(outbuf, doc, cur, 0, 1, NULL);

	push	0
	push	1
	push	0
	push	edi
	push	ecx
	push	esi
	call	_xmlNodeDumpOutput
	add	esp, 24					; 00000018H

; 2323 :     xmlOutputBufferClose(outbuf);

	push	esi
	call	_xmlOutputBufferClose
	add	esp, 4
$LN7@xmlElemDum:
	pop	esi
$LN1@xmlElemDum:
	pop	edi

; 2324 : }

	pop	ebp
	ret	0
_xmlElemDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDump
_TEXT	SEGMENT
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_xmlDocDump PROC					; COMDAT

; 2591 : xmlDocDump(FILE *f, xmlDocPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _cur$[ebp]
	push	DWORD PTR _f$[ebp]
	call	_xmlDocFormatDump
	add	esp, 12					; 0000000cH

; 2592 :     return(xmlDocFormatDump (f, cur, 0));
; 2593 : }

	pop	ebp
	ret	0
_xmlDocDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocFormatDump
_TEXT	SEGMENT
_ctxt$ = -124						; size = 124
_f$ = 8							; size = 4
_cur$ = 12						; size = 4
_format$ = 16						; size = 4
_xmlDocFormatDump PROC					; COMDAT

; 2541 : xmlDocFormatDump(FILE *f, xmlDocPtr cur, int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	push	ebx
	push	esi
	push	edi
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, DWORD PTR _cur$[ebp]
	xor	ebx, ebx
	test	esi, esi
	je	$LN7@xmlDocForm

; 2542 :     xmlSaveCtxt ctxt;
; 2543 :     xmlOutputBufferPtr buf;
; 2544 :     const char * encoding;
; 2545 :     xmlCharEncodingHandlerPtr handler = NULL;
; 2546 :     int ret;
; 2547 : 
; 2548 :     if (cur == NULL) {
; 2549 : #ifdef DEBUG_TREE
; 2550 :         xmlGenericError(xmlGenericErrorContext,
; 2551 : 		"xmlDocDump : document == NULL\n");
; 2552 : #endif
; 2553 : 	return(-1);
; 2554 :     }
; 2555 :     encoding = (const char *) cur->encoding;
; 2556 : 
; 2557 :     if (encoding != NULL) {

	mov	edi, DWORD PTR [esi+60]
	test	edi, edi
	je	SHORT $LN4@xmlDocForm

; 2558 : 	handler = xmlFindCharEncodingHandler(encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	ebx, eax
	add	esp, 4

; 2559 : 	if (handler == NULL) {

	test	ebx, ebx
	jne	SHORT $LN4@xmlDocForm

; 2560 : 	    xmlFree((char *) cur->encoding);

	push	DWORD PTR [esi+60]
	call	DWORD PTR _xmlFree
	add	esp, 4

; 2561 : 	    cur->encoding = NULL;

	mov	DWORD PTR [esi+60], ebx

; 2562 : 	    encoding = NULL;

	xor	edi, edi
$LN4@xmlDocForm:

; 2563 : 	}
; 2564 :     }
; 2565 :     buf = xmlOutputBufferCreateFile(f, handler);

	push	ebx
	push	DWORD PTR _f$[ebp]
	call	_xmlOutputBufferCreateFile
	mov	ebx, eax
	add	esp, 8

; 2566 :     if (buf == NULL) return(-1);

	test	ebx, ebx
	je	SHORT $LN7@xmlDocForm

; 2567 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2568 :     ctxt.doc = cur;
; 2569 :     ctxt.buf = buf;
; 2570 :     ctxt.level = 0;
; 2571 :     ctxt.format = format ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _ctxt$[ebp+28], esi
	cmp	DWORD PTR _format$[ebp], eax
	mov	DWORD PTR _ctxt$[ebp+24], ebx
	setne	al
	mov	DWORD PTR _ctxt$[ebp+36], 0
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2572 :     ctxt.encoding = (const xmlChar *) encoding;
; 2573 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp+16], edi
	call	_xmlSaveCtxtInit

; 2574 :     ctxt.options |= XML_SAVE_AS_XML;

	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H

; 2575 :     xmlDocContentDumpOutput(&ctxt, cur);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	esi
	push	eax
	call	_xmlDocContentDumpOutput

; 2576 : 
; 2577 :     ret = xmlOutputBufferClose(buf);

	push	ebx
	call	_xmlOutputBufferClose
	add	esp, 28					; 0000001cH
	pop	edi

; 2578 :     return(ret);
; 2579 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@xmlDocForm:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDocFormatDump ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpFormatMemoryEnc
_TEXT	SEGMENT
_ctxt$ = -128						; size = 124
_dummy$ = -4						; size = 4
_out_doc$ = 8						; size = 4
_doc_txt_ptr$ = 12					; size = 4
_doc_txt_len$ = 16					; size = 4
_txt_encoding$ = 20					; size = 4
_format$ = 24						; size = 4
_xmlDocDumpFormatMemoryEnc PROC				; COMDAT

; 2404 : 		int format) {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	esi
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _doc_txt_len$[ebp]
	lea	esi, DWORD PTR _dummy$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _dummy$[ebp], 0
	test	eax, eax
	cmovne	esi, eax
	mov	eax, DWORD PTR _doc_txt_ptr$[ebp]
	test	eax, eax
	jne	SHORT $LN3@xmlDocDump

; 2405 :     xmlSaveCtxt ctxt;
; 2406 :     int                         dummy = 0;
; 2407 :     xmlOutputBufferPtr          out_buff = NULL;
; 2408 :     xmlCharEncodingHandlerPtr   conv_hdlr = NULL;
; 2409 : 
; 2410 :     if (doc_txt_len == NULL) {
; 2411 :         doc_txt_len = &dummy;   /*  Continue, caller just won't get length */
; 2412 :     }
; 2413 : 
; 2414 :     if (doc_txt_ptr == NULL) {
; 2415 :         *doc_txt_len = 0;

	mov	DWORD PTR [esi], ecx
	pop	esi

; 2470 :     }
; 2471 : 
; 2472 :     return;
; 2473 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@xmlDocDump:
	push	ebx

; 2416 :         return;
; 2417 :     }
; 2418 : 
; 2419 :     *doc_txt_ptr = NULL;
; 2420 :     *doc_txt_len = 0;
; 2421 : 
; 2422 :     if (out_doc == NULL) {

	mov	ebx, DWORD PTR _out_doc$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi], ecx
	test	ebx, ebx
	je	$LN27@xmlDocDump

; 2423 :         /*  No document, no output  */
; 2424 :         return;
; 2425 :     }
; 2426 : 
; 2427 :     /*
; 2428 :      *  Validate the encoding value, if provided.
; 2429 :      *  This logic is copied from xmlSaveFileEnc.
; 2430 :      */
; 2431 : 
; 2432 :     if (txt_encoding == NULL)

	push	edi
	mov	edi, DWORD PTR _txt_encoding$[ebp]
	test	edi, edi
	jne	SHORT $LN25@xmlDocDump

; 2433 : 	txt_encoding = (const char *) out_doc->encoding;

	mov	edi, DWORD PTR [ebx+60]

; 2434 :     if (txt_encoding != NULL) {

	test	edi, edi
	je	SHORT $LN26@xmlDocDump
$LN25@xmlDocDump:

; 2435 : 	conv_hdlr = xmlFindCharEncodingHandler(txt_encoding);

	push	edi
	call	_xmlFindCharEncodingHandler
	mov	ecx, eax
	add	esp, 4

; 2436 : 	if ( conv_hdlr == NULL ) {

	test	ecx, ecx
	jne	SHORT $LN26@xmlDocDump

; 143  :     __xmlSimpleError(XML_FROM_OUTPUT, code, node, msg, extra);

	push	edi
	push	OFFSET ??_C@_0BF@CGOGPJKI@unknown?5encoding?5?$CFs?6@
	push	ebx
	push	1403					; 0000057bH
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	pop	esi

; 2470 :     }
; 2471 : 
; 2472 :     return;
; 2473 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@xmlDocDump:

; 2437 : 	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,
; 2438 : 		       txt_encoding);
; 2439 : 	    return;
; 2440 : 	}
; 2441 :     }
; 2442 : 
; 2443 :     if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {

	push	ecx
	call	_xmlAllocOutputBuffer
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LN8@xmlDocDump

; 111  :     __xmlSimpleError(XML_FROM_OUTPUT, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	push	OFFSET ??_C@_0BA@GIGPFFIA@creating?5buffer@
	push	eax
	push	eax
	push	2
	push	7
	call	___xmlSimpleError
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	pop	esi

; 2470 :     }
; 2471 : 
; 2472 :     return;
; 2473 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xmlDocDump:

; 2444 :         xmlSaveErrMemory("creating buffer");
; 2445 :         return;
; 2446 :     }
; 2447 : 
; 2448 :     memset(&ctxt, 0, sizeof(ctxt));

	push	124					; 0000007cH
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	0
	push	eax
	call	_memset

; 2449 :     ctxt.doc = out_doc;

	mov	eax, DWORD PTR _out_doc$[ebp]
	mov	DWORD PTR _ctxt$[ebp+28], eax

; 2450 :     ctxt.buf = out_buff;
; 2451 :     ctxt.level = 0;
; 2452 :     ctxt.format = format ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR _format$[ebp], eax
	mov	DWORD PTR _ctxt$[ebp+24], ebx
	setne	al
	mov	DWORD PTR _ctxt$[ebp+36], 0
	mov	DWORD PTR _ctxt$[ebp+40], eax

; 2453 :     ctxt.encoding = (const xmlChar *) txt_encoding;
; 2454 :     xmlSaveCtxtInit(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	DWORD PTR _ctxt$[ebp+16], edi
	call	_xmlSaveCtxtInit

; 2455 :     ctxt.options |= XML_SAVE_AS_XML;
; 2456 :     xmlDocContentDumpOutput(&ctxt, out_doc);

	push	DWORD PTR _out_doc$[ebp]
	or	DWORD PTR _ctxt$[ebp+32], 32		; 00000020H
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDocContentDumpOutput

; 2457 :     xmlOutputBufferFlush(out_buff);

	push	ebx
	call	_xmlOutputBufferFlush

; 2458 :     if (out_buff->conv != NULL) {

	mov	eax, DWORD PTR [ebx+20]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN9@xmlDocDump

; 2459 : 	*doc_txt_len = xmlBufUse(out_buff->conv);

	push	eax
	call	_xmlBufUse
	mov	edi, eax
	mov	DWORD PTR [esi], edi

; 2460 : 	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);

	mov	eax, DWORD PTR [ebx+20]

; 2461 :     } else {

	jmp	SHORT $LN29@xmlDocDump
$LN9@xmlDocDump:

; 2462 : 	*doc_txt_len = xmlBufUse(out_buff->buffer);

	push	DWORD PTR [ebx+16]
	call	_xmlBufUse
	mov	edi, eax
	mov	DWORD PTR [esi], edi

; 2463 : 	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);

	mov	eax, DWORD PTR [ebx+16]
$LN29@xmlDocDump:

; 2464 :     }
; 2465 :     (void)xmlOutputBufferClose(out_buff);

	add	esp, 4
	push	eax
	call	_xmlBufContent
	push	edi
	push	eax
	call	_xmlStrndup
	mov	edi, DWORD PTR _doc_txt_ptr$[ebp]
	push	ebx
	mov	DWORD PTR [edi], eax
	call	_xmlOutputBufferClose
	add	esp, 16					; 00000010H

; 2466 : 
; 2467 :     if ((*doc_txt_ptr == NULL) && (*doc_txt_len > 0)) {

	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN28@xmlDocDump
	cmp	DWORD PTR [esi], 0
	jle	SHORT $LN28@xmlDocDump

; 2468 :         *doc_txt_len = 0;
; 2469 :         xmlSaveErrMemory("creating output");

	push	OFFSET ??_C@_0BA@CMJGPMBH@creating?5output@
	mov	DWORD PTR [esi], 0
	call	_xmlSaveErrMemory
	add	esp, 4
$LN28@xmlDocDump:
	pop	edi
$LN27@xmlDocDump:
	pop	ebx
	pop	esi

; 2470 :     }
; 2471 : 
; 2472 :     return;
; 2473 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDocDumpFormatMemoryEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpMemoryEnc
_TEXT	SEGMENT
_out_doc$ = 8						; size = 4
_doc_txt_ptr$ = 12					; size = 4
_doc_txt_len$ = 16					; size = 4
_txt_encoding$ = 20					; size = 4
_xmlDocDumpMemoryEnc PROC				; COMDAT

; 2523 : 	            int * doc_txt_len, const char * txt_encoding) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	DWORD PTR _txt_encoding$[ebp]
	push	DWORD PTR _doc_txt_len$[ebp]
	push	DWORD PTR _doc_txt_ptr$[ebp]
	push	DWORD PTR _out_doc$[ebp]
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2524 :     xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len,
; 2525 : 	                      txt_encoding, 0);
; 2526 : }

	pop	ebp
	ret	0
_xmlDocDumpMemoryEnc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_xmlDocDumpMemory PROC					; COMDAT

; 2487 : xmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	0
	push	0
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _mem$[ebp]
	push	DWORD PTR _cur$[ebp]
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2488 :     xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);
; 2489 : }

	pop	ebp
	ret	0
_xmlDocDumpMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlDocDumpFormatMemory
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_mem$ = 12						; size = 4
_size$ = 16						; size = 4
_format$ = 20						; size = 4
_xmlDocDumpFormatMemory PROC				; COMDAT

; 2505 : xmlDocDumpFormatMemory(xmlDocPtr cur, xmlChar**mem, int *size, int format) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	push	DWORD PTR _format$[ebp]
	push	0
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _mem$[ebp]
	push	DWORD PTR _cur$[ebp]
	call	_xmlDocDumpFormatMemoryEnc
	add	esp, 20					; 00000014H

; 2506 :     xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, format);
; 2507 : }

	pop	ebp
	ret	0
_xmlDocDumpFormatMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlsave.c
;	COMDAT _xmlAttrSerializeTxtContent
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_doc$ = 12						; size = 4
_attr$ = 16						; size = 4
_string$ = 20						; size = 4
_xmlAttrSerializeTxtContent PROC			; COMDAT

; 2172 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BAD788A4_xmlsave@c
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _buf$[ebp]
	test	eax, eax
	je	SHORT $LN3@xmlAttrSer

; 2173 :     xmlBufPtr buffer;
; 2174 : 
; 2175 :     if ((buf == NULL) || (string == NULL))

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@xmlAttrSer

; 2176 :         return;
; 2177 :     buffer = xmlBufFromBuffer(buf);

	push	esi
	push	eax
	call	_xmlBufFromBuffer
	mov	esi, eax
	add	esp, 4

; 2178 :     if (buffer == NULL)

	test	esi, esi
	je	SHORT $LN6@xmlAttrSer

; 2179 :         return;
; 2180 :     xmlBufAttrSerializeTxtContent(buffer, doc, attr, string);

	push	DWORD PTR _string$[ebp]
	push	DWORD PTR _attr$[ebp]
	push	DWORD PTR _doc$[ebp]
	push	esi
	call	_xmlBufAttrSerializeTxtContent

; 2181 :     xmlBufBackToBuffer(buffer);

	push	esi
	call	_xmlBufBackToBuffer
	add	esp, 20					; 00000014H
$LN6@xmlAttrSer:
	pop	esi
$LN3@xmlAttrSer:

; 2182 : }

	pop	ebp
	ret	0
_xmlAttrSerializeTxtContent ENDP
_TEXT	ENDS
END
